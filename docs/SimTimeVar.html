<!DOCTYPE html><html><head><title>Help for package SimTimeVar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SimTimeVar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_one_categorical'><p>Generate linear predictor from logistic model</p></a></li>
<li><a href='#add_time_function_vars'><p>Creates linear time-function variables</p></a></li>
<li><a href='#BN.rBound'><p>Maximum correlation between binary and normal random variables</p></a></li>
<li><a href='#cat.params'><p>An example dataframe for categorical variable parameters</p></a></li>
<li><a href='#closest'><p>Return closest value</p></a></li>
<li><a href='#complete_parameters'><p>Fill in partially incomplete parameters matrix</p></a></li>
<li><a href='#expand_matrix'><p>Longitudinally expand a matrix of single observations by cluster</p></a></li>
<li><a href='#expand_subjects'><p>Longitudinally expand a cluster</p></a></li>
<li><a href='#has_drug_suffix'><p>Checks whether string has &quot;_s&quot; suffix</p></a></li>
<li><a href='#make_one_dataset'><p>Simulate time-varying covariates</p></a></li>
<li><a href='#make_one_linear_pred'><p>Generate linear predictor from logistic model</p></a></li>
<li><a href='#mod.jointly.generate.binary.normal'><p>Return closest value</p></a></li>
<li><a href='#override_static'><p>Override static variable</p></a></li>
<li><a href='#override_tbin_probs'><p>Override probabilities for time-varying binary variables</p></a></li>
<li><a href='#params'><p>An example parameters dataframe</p></a></li>
<li><a href='#pcor'><p>An example across-cluster correlation dataframe</p></a></li>
<li><a href='#proportionize'><p>Turn a number into a valid proportion</p></a></li>
<li><a href='#upper_tri_vec'><p>Turn symmetric matrix into vector</p></a></li>
<li><a href='#wcor'><p>An example within-cluster correlation dataframe</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate Longitudinal Dataset with Time-Varying Correlated
Covariates</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-09-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Maya B. Mathur, Kristopher Kapphahn, Ariadna Garcia, Manisha Desai, Maria E. Montez-Rath</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maya B. Mathur &lt;mmathur@stanford.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Flexibly simulates a dataset with time-varying covariates with user-specified exchangeable correlation structures across and within clusters. Covariates can be normal or binary and can be static within a cluster or time-varying. Time-varying normal variables can optionally have linear trajectories within each cluster. See ?make_one_dataset for the main wrapper function. See Montez-Rath et al. &lt;<a href="https://arxiv.org/abs/1709.10074">arXiv:1709.10074</a>&gt; for methodological details. </td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>metafor, mvtnorm, ICC, miscTools, car, plyr, corpcor, psych,
stats, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-09-29 22:04:44 UTC; mmathur</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-09-30 16:22:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_one_categorical'>Generate linear predictor from logistic model</h2><span id='topic+add_one_categorical'></span>

<h3>Description</h3>

<p>An internal function not intended for the user. Given a dataset and multinomial regression parameters,
generates a categorical variable and adds it to the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_one_categorical(.d, n, obs, cat.parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_one_categorical_+3A_.d">.d</code></td>
<td>
<p>The dataset to which to add the categorical variable.</p>
</td></tr>
<tr><td><code id="add_one_categorical_+3A_n">n</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="add_one_categorical_+3A_obs">obs</code></td>
<td>
<p>The number of observations per cluster.</p>
</td></tr>
<tr><td><code id="add_one_categorical_+3A_cat.parameters">cat.parameters</code></td>
<td>
<p>A dataframe of parameters for generating the categorical variable. See Details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># mini dataset with 3 observations per person
data = data.frame( male = rep( rbinom(n=10, size=1, prob=0.5), each=3 ) )
add_one_categorical( data, 10, 3, cat.params)
</code></pre>

<hr>
<h2 id='add_time_function_vars'>Creates linear time-function variables</h2><span id='topic+add_time_function_vars'></span>

<h3>Description</h3>

<p>Given variable-specific slopes and intercepts for a cluster, creates continuous variables that
increase or 
decrease linearly in time (with normal error with standard deviation <code>error.SD</code>) and
adds them to the dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_time_function_vars(d4, obs, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_time_function_vars_+3A_d4">d4</code></td>
<td>
<p>The dataframe to which to add the time-function variables.</p>
</td></tr>
<tr><td><code id="add_time_function_vars_+3A_obs">obs</code></td>
<td>
<p>The number of observations per cluster.</p>
</td></tr>
<tr><td><code id="add_time_function_vars_+3A_parameters">parameters</code></td>
<td>
<p>The parameters matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>make_one_dataset</code> for additional information.
</p>

<hr>
<h2 id='BN.rBound'>Maximum correlation between binary and normal random variables</h2><span id='topic+BN.rBound'></span>

<h3>Description</h3>

<p>Given parameter <code>p</code> for a Bernoulli random variable, returns its maximum possible
correlation with an arbitrary normal random variable. Used to adjust correlation matrices
whose entries are not theoretically possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BN.rBound(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BN.rBound_+3A_p">p</code></td>
<td>
<p>Parameter of Bernoulli random variable.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># find the largest possible correlation between a normal
#  variable and a binary with parameter 0.1
BN.rBound(0.1)
</code></pre>

<hr>
<h2 id='cat.params'>An example dataframe for categorical variable parameters</h2><span id='topic+cat.params'></span>

<h3>Description</h3>

<p>An example of how to set up the categorical variable parameters dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat.params
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 5 rows and 3 columns.</p>

<hr>
<h2 id='closest'>Return closest value</h2><span id='topic+closest'></span>

<h3>Description</h3>

<p>An internal function not intended for the user. Given a number <code>x</code> and vector of
permitted values, 
returns the closest permitted value to <code>x</code> (in absolute value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closest(x, candidates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closest_+3A_x">x</code></td>
<td>
<p>The number to be compared to the permitted values.</p>
</td></tr>
<tr><td><code id="closest_+3A_candidates">candidates</code></td>
<td>
<p>A vector of permitted values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>closest( x = 5, candidates = c(-3, 8, 25) )
</code></pre>

<hr>
<h2 id='complete_parameters'>Fill in partially incomplete parameters matrix</h2><span id='topic+complete_parameters'></span>

<h3>Description</h3>

<p>Fills in &quot;strategic&quot; <code>NA</code> values in a user-provided parameters matrix by (1) calculating
SDs for proportions using the binomial distribution; (2) calculating variances based on SDs; and (3)
setting within-cluster variances to 1/3 of the across-cluster variances (if not already specified).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_parameters(parameters, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_parameters_+3A_parameters">parameters</code></td>
<td>
<p>Initial parameters matrix that may contain <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="complete_parameters_+3A_n">n</code></td>
<td>
<p>The number of clusters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For binary variables, uses binomial distribution to compute across-cluster standard deviation of proportion. Where there 
are missing values, fills in variances given standard deviations and vice-versa. Where there are missing values in 
<code>within.var</code>, fills these in by defaulting to 1/3 of the corresponding across-cluster variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>complete_parameters(params, n=10)
</code></pre>

<hr>
<h2 id='expand_matrix'>Longitudinally expand a matrix of single observations by cluster</h2><span id='topic+expand_matrix'></span>

<h3>Description</h3>

<p>An internal function not intended for the user. Given a matrix of single observations 
for a cluster, repeats each cluster's entry in each <code>.obs</code> times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_matrix(.matrix, .obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_matrix_+3A_.matrix">.matrix</code></td>
<td>
<p>The matrix of observations to be expanded.</p>
</td></tr>
<tr><td><code id="expand_matrix_+3A_.obs">.obs</code></td>
<td>
<p>The number of observations to generate per cluster.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mat = matrix( seq(1:10), nrow=2, byrow=FALSE)
expand_matrix(mat, 4)
</code></pre>

<hr>
<h2 id='expand_subjects'>Longitudinally expand a cluster</h2><span id='topic+expand_subjects'></span>

<h3>Description</h3>

<p>An internal function not intended for the user. Given a matrix of cluster means for each variable to
be simulated, &quot;expands&quot; them into time-varying observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_subjects(mus3, n.OtherNorms, n.OtherBins, n.TBins, wcor, obs, parameters,
  zero = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_subjects_+3A_mus3">mus3</code></td>
<td>
<p>A matrix of cluster means for each variable.</p>
</td></tr>
<tr><td><code id="expand_subjects_+3A_n.othernorms">n.OtherNorms</code></td>
<td>
<p>The number normal variables (not counting those
used for generating a time-varying binary variable).</p>
</td></tr>
<tr><td><code id="expand_subjects_+3A_n.otherbins">n.OtherBins</code></td>
<td>
<p>The number of static binary variables.</p>
</td></tr>
<tr><td><code id="expand_subjects_+3A_n.tbins">n.TBins</code></td>
<td>
<p>The number of time-varying binary variables.</p>
</td></tr>
<tr><td><code id="expand_subjects_+3A_wcor">wcor</code></td>
<td>
<p>The within-cluster correlation matrix.</p>
</td></tr>
<tr><td><code id="expand_subjects_+3A_obs">obs</code></td>
<td>
<p>The number of observations to generate per cluster.</p>
</td></tr>
<tr><td><code id="expand_subjects_+3A_parameters">parameters</code></td>
<td>
<p>The parameters dataframe.</p>
</td></tr>
<tr><td><code id="expand_subjects_+3A_zero">zero</code></td>
<td>
<p>A small number just larger than 0.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># subject means matrix (normally would be created internally within make_one_dataset)
mus3 = structure(c(1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1e-04, 1e-04, 0.886306145591761, 
1e-04, 1e-04, 1e-04, 1e-04, 0.875187001140343, 0.835990583043838, 
1e-04, 1e-04, 1e-04, 1e-04, 1e-04, 1e-04, 1e-04, 1e-04, 1e-04, 
1e-04, 1e-04, 69.7139993804559, 61.3137637852213, 68.3375516615242, 
57.7893277997516, 66.3744152975352, 63.7829561873355, 66.3864252981679, 
68.8513253460358, 67.4120718557, 67.8332265185068, 192.366192293195, 
128.048983102048, 171.550401133259, 120.348392753954, 158.840864356998, 
170.13484760994, 113.512220330821, 162.715528382999, 138.476877345895, 
159.841096973242, 115.026417822477, 109.527137142158, 117.087914485084, 
121.153861460319, 109.95973584141, 122.96960673409, 90.5100006255084, 
107.523229006601, 108.971677388246, 115.641818648526, -4.33184270434101, 
-5.45143483618415, -2.56331188314257, -1.38204452333064, -1.61744564863871, 
1.83911233741448, 2.0488338883998, -0.237095062415858, -5.47497506857878, 
-3.53078955238741), .Dim = c(10L, 7L))

expand_subjects( mus3 = mus3, n.OtherNorms = 4, n.OtherBins = 1, n.TBins = 2,
                wcor = wcor, obs = 3, parameters = complete_parameters(params, n=10) )
</code></pre>

<hr>
<h2 id='has_drug_suffix'>Checks whether string has &quot;_s&quot; suffix</h2><span id='topic+has_drug_suffix'></span>

<h3>Description</h3>

<p>An internal function not intended for the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_drug_suffix(var.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_drug_suffix_+3A_var.name">var.name</code></td>
<td>
<p>The string to be checked</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>has_drug_suffix("myvariable_s")
has_drug_suffix("myvariable")
</code></pre>

<hr>
<h2 id='make_one_dataset'>Simulate time-varying covariates</h2><span id='topic+make_one_dataset'></span>

<h3>Description</h3>

<p>Simulates a dataset with correlated time-varying covariates with an exchangeable correlation
structure. Covariates can be normal or binary
and can be static within a cluster or time-varying. Time-varying normal variables can optionally 
have linear trajectories within each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_one_dataset(n, obs, n.TBins, pcor, wcor, parameters, cat.parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_one_dataset_+3A_n">n</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="make_one_dataset_+3A_obs">obs</code></td>
<td>
<p>The number of observations per cluster.</p>
</td></tr>
<tr><td><code id="make_one_dataset_+3A_n.tbins">n.TBins</code></td>
<td>
<p>Number of time-varying binary variables.</p>
</td></tr>
<tr><td><code id="make_one_dataset_+3A_pcor">pcor</code></td>
<td>
<p>The across-subject correlation matrix. See Details.</p>
</td></tr>
<tr><td><code id="make_one_dataset_+3A_wcor">wcor</code></td>
<td>
<p>The within-subject correlation matrix. See Details.</p>
</td></tr>
<tr><td><code id="make_one_dataset_+3A_parameters">parameters</code></td>
<td>
<p>A dataframe containing the general simulation parameters. See Details.</p>
</td></tr>
<tr><td><code id="make_one_dataset_+3A_cat.parameters">cat.parameters</code></td>
<td>
<p>A dataframe containing parameters for the categorical variables. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>SPECIFYING THE PARAMETERS MATRIX</strong>
</p>
<p>The matrix <code>parameters</code> contains parameters required to generate all non-categorical variables.
It must contain column names <code>name, type, across.mean, across.SD, across.var, within.var, prop</code>,
and <code>error.SD</code>. (To see an example, use <code>data(params)</code>.) Each variable to be generated requires
either one or two rows in <code>parameters</code>, depending on the variable type. 
</p>
<p>The possible variable types and their corresponding specifications are:
</p>

<ul>
<li> <p><strong>Static binary variables</strong> do not change over time within a cluster. For example, if clusters
are subjects, sex would be a static binary variable. Generating such a variable requires a single row
of type <code>static.binary</code> with <code>prop</code> corresponding to the proportion of clusters for which the
variable equals 1 and all other columns set to <code>NA</code>. (The correct standard deviation will automatically
be computed later.) For example, if the variable is an indicator for a subject's being male, then <code>prop</code>
specifies the proportion of males to be generated. 
</p>
</li>
<li> <p><strong>Time-varying binary variables</strong> can change within a cluster over time, as for
an indicator for whether a subject is currently taking the study drug. These variables require two rows in
<code>parameters</code>. The first row should be of type <code>static.binary</code> with <code>prop</code> representing 
the proportion of clusters for which the time-varying binary variable is 1 at least once
(and all other columns set to <code>NA</code>). For example, this row in <code>parameters</code> could represent the
proportion of subjects who ever take the study drug (&quot;ever-users&quot;).
</p>
<p>The second row should be of type <code>subject.prop</code> with <code>across.mean</code> representing, for clusters
that ever have a 1 for the binary variable, the proportion of observations within the cluster for which
the variable is equal to 1. (All other columns should be set to <code>NA</code>.) For example, this this row in
<code>parameters</code> could 
represent the proportion of observations for which an ever-user is currently taking the drug. To indicate
which pair of variables go together, the <code>subject.prop</code> should have the same name as the <code>static.binary</code>
variable, but with the suffix <code>_s</code> appended (for example, the former could be named <code>drug_s</code> and
the latter <code>drug</code>).
</p>
</li>
<li> <p><strong>Normal variables</strong> are normally distributed within a cluster such that the within-cluster
means are themselves also normally distributed in the population of clusters. Generating a normal variable requires
specification of the population mean (<code>across.mean</code>) and standard deviation (<code>across.SD</code>) as well as of
the within-cluster standard deviation (<code>within.SD</code>). To generate a static continuous variable, simply set
<code>within.SD</code> to be extremely small (e.g., $1 * 10^-7$) and all corresponding correlations in matrix
<code>wcor</code> to 0. 
</p>
</li>
<li> <p><strong>Time-function variables</strong> are linear functions of time (with normal error) within each cluster such 
that the within-cluster baseline values are normally distributed in the population of clusters. Generating a
time-function variable requires two entries. The first entry should be of type <code>time.function</code> and
specifies the population mean (<code>across.mean</code>) and standard deviation (<code>across.SD</code>) of the within-cluster
baseline values as well as the error standard deviation (<code>error.SD</code>). The second entry should be of
type <code>normal</code> and should have the same name as the <code>time.function</code> entry, but with the &quot;_s&quot; suffix.
This entry specifies the mean (<code>across.mean</code>) and standard deviation (<code>across.SD</code>) of the within-cluster
slopes. 
</p>
</li></ul>

<p><strong>SPECIFYING THE CATEGORICAL PARAMETERS MATRIX</strong>
</p>
<p>The matrix <code>cat.parameters</code> contains parameters required to generate the single categorical variable, 
if any.
It must contain column names <code>level, parameter</code>,
and <code>beta</code>. (To see an example, use <code>data(cat.params)</code>.)
</p>

<ul>
<li> <p><strong>The reference level:</strong> Each categorical variable must have exactly one &quot;reference&quot; level. The reference level should have one
row in <code>cat.parameters</code> for which <code>parameters</code> is set to <code>NA</code> and <code>beta</code> is set
to <code>ref</code>. For example, in the example file <code>cat.params</code> specifying parameters to generate a
subject's race, the reference level is <code>white</code>. 
</p>
</li>
<li> <p><strong> Other levels: </strong> Other levels of the categorical variable will have one or more rows. One row with parameter set to <code>intercept</code>
and <code>beta</code> set to a numeric value
represents the intercept term in the corresponding multinomial model. Any subsequent rows, with parameters set to 
names of other variables in the dataset and <code>beta</code> set to numeric values, 
represents other coefficients in the corresponding multinomial models. 
</p>
</li></ul>

<p><strong>SPECIFYING THE POPULATION CORRELATION MATRIX</strong>
</p>
<p>Matrix <code>pcor</code> specifies the population (i.e., across-cluster) correlation matrix. It should have the same
number of rows and columns as <code>parameters</code> as well as the same variable names and ordering of variables.  
</p>
<p><strong>SPECIFYING THE WITHIN-CLUSTER CORRELATION MATRIX</strong>
</p>
<p>Matrix <code>wcor</code> specifies the within-cluster correlation matrix. The order of the variables listed in this file should be
consistent with the order in <code>params</code> and <code>pcor</code>. However, <code>static.binary</code> and <code>subject.prop</code> variables
should not be included in <code>wcor</code> since they are static within a cluster. Static continuous variables should be included,
but all the correlations should be set to zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = make_one_dataset(n=10, obs=10, n.TBins=2, pcor=pcor, wcor=wcor, 
parameters=complete_parameters(params, n=10), cat.parameters=cat.params)$data
</code></pre>

<hr>
<h2 id='make_one_linear_pred'>Generate linear predictor from logistic model</h2><span id='topic+make_one_linear_pred'></span>

<h3>Description</h3>

<p>An internal function not intended for the user. Given a matrix of regression parameters
and a dataset, returns the linear predictor based on the given dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_one_linear_pred(m, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_one_linear_pred_+3A_m">m</code></td>
<td>
<p>Part of the parameter matrix for the linear predictor for a single variable.</p>
</td></tr>
<tr><td><code id="make_one_linear_pred_+3A_data">data</code></td>
<td>
<p>The dataframe from which to generate.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># take part of parameters matrix corresponding to single level of categorical
#  variable
m = cat.params[ cat.params$level == "black", ]
data = data.frame( male = rbinom(n=10, size=1, prob=0.5) )
make_one_linear_pred(m, data)
</code></pre>

<hr>
<h2 id='mod.jointly.generate.binary.normal'>Return closest value</h2><span id='topic+mod.jointly.generate.binary.normal'></span>

<h3>Description</h3>

<p>An internal function not intended for the user. Simulates correlated normal and binary
variables based on the algorithm of Demirtas and Doganay (2012). See references for
further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod.jointly.generate.binary.normal(no.rows, no.bin, no.nor, prop.vec.bin,
  mean.vec.nor, var.nor, corr.vec, adjust.corrs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mod.jointly.generate.binary.normal_+3A_no.rows">no.rows</code></td>
<td>
<p>Number of rows</p>
</td></tr>
<tr><td><code id="mod.jointly.generate.binary.normal_+3A_no.bin">no.bin</code></td>
<td>
<p>Number of binary variables</p>
</td></tr>
<tr><td><code id="mod.jointly.generate.binary.normal_+3A_no.nor">no.nor</code></td>
<td>
<p>Number of normal variables</p>
</td></tr>
<tr><td><code id="mod.jointly.generate.binary.normal_+3A_prop.vec.bin">prop.vec.bin</code></td>
<td>
<p>Vector of parameters for binary variables</p>
</td></tr>
<tr><td><code id="mod.jointly.generate.binary.normal_+3A_mean.vec.nor">mean.vec.nor</code></td>
<td>
<p>Vector of means for binary variables</p>
</td></tr>
<tr><td><code id="mod.jointly.generate.binary.normal_+3A_var.nor">var.nor</code></td>
<td>
<p>Vector of variances for binary variables</p>
</td></tr>
<tr><td><code id="mod.jointly.generate.binary.normal_+3A_corr.vec">corr.vec</code></td>
<td>
<p>Vector of correlations</p>
</td></tr>
<tr><td><code id="mod.jointly.generate.binary.normal_+3A_adjust.corrs">adjust.corrs</code></td>
<td>
<p>Boolean indicating whether theoretically impossible correlations between 
a binary and a normal variable should be adjusted to their closest theoretically possible value.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Demirtas, H., &amp; Doganay, B. (2012). Simultaneous generation of binary and
normal data with specified marginal and association structures. Journal of
Biopharmaceutical Statistics, 22(2), 223-236.
</p>

<hr>
<h2 id='override_static'>Override static variable</h2><span id='topic+override_static'></span>

<h3>Description</h3>

<p>An internal function not intended for the user. For static variables, overrides any time-varying
values to ensure that they are actually static.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>override_static(.static.var.name, .id.var.name = "id", .d, .obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="override_static_+3A_.static.var.name">.static.var.name</code></td>
<td>
<p>Name of static variable.</p>
</td></tr>
<tr><td><code id="override_static_+3A_.id.var.name">.id.var.name</code></td>
<td>
<p>Name of variable defining clusters in dataset.</p>
</td></tr>
<tr><td><code id="override_static_+3A_.d">.d</code></td>
<td>
<p>Dataset</p>
</td></tr>
<tr><td><code id="override_static_+3A_.obs">.obs</code></td>
<td>
<p>The number of observations per cluster.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># example with 10 subjects each with 3 observations
# generate sex in a way where it might vary within a subject
data = data.frame( id = rep(1:10, each=3),
                   male = rbinom( n=10*3, size=1, prob=0.5 ) )
override_static("male", "id", data, 3)
</code></pre>

<hr>
<h2 id='override_tbin_probs'>Override probabilities for time-varying binary variables</h2><span id='topic+override_tbin_probs'></span>

<h3>Description</h3>

<p>An internal function not intended for the user. For clusters assigned to have a given time-varying binary variable
always equal to 0,
overrides to 0 the corresponding proportion of observations with the binary variable equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>override_tbin_probs(mus0, n.TBins, n.OtherBins, zero = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="override_tbin_probs_+3A_mus0">mus0</code></td>
<td>
<p>The matrix of cluster means.</p>
</td></tr>
<tr><td><code id="override_tbin_probs_+3A_n.tbins">n.TBins</code></td>
<td>
<p>Number of time-varying binary variables.</p>
</td></tr>
<tr><td><code id="override_tbin_probs_+3A_n.otherbins">n.OtherBins</code></td>
<td>
<p>The number of static binary variables.</p>
</td></tr>
<tr><td><code id="override_tbin_probs_+3A_zero">zero</code></td>
<td>
<p>A number very close to 0, but slightly larger.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># make example subject means matrix for 1 static binary, 
#  1 time-varying binary, and 1 normal
#  50 subjects and 5 observations (latter plays into variance)
set.seed(451)
mus0 = mod.jointly.generate.binary.normal( no.rows = 50, no.bin = 2, no.nor = 2,
                                           prop.vec.bin = c( .5, .35 ),
                                           mean.vec.nor = c( .4, 100 ),
                                           var.nor = c( (0.4 * 0.6) / 5, 10 ),
                                           corr.vec = c(0.05, .08, 0, 0, -0.03, 0) )

# note that we have ever-users with non-zero propensities to be on drug: not okay
any( mus0[,1] == 0 &amp; mus0[,3] != 0 )

# fix them
mus1 = override_tbin_probs( mus0, 1, 1 )

# all better!
any( mus1[,1] == 0 &amp; mus1[,3] &gt; 0.0001 )
</code></pre>

<hr>
<h2 id='params'>An example parameters dataframe</h2><span id='topic+params'></span>

<h3>Description</h3>

<p>An example of how to set up the parameters dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 12 rows and 8 columns.</p>

<hr>
<h2 id='pcor'>An example across-cluster correlation dataframe</h2><span id='topic+pcor'></span>

<h3>Description</h3>

<p>An example of how to set up the across-cluster correlation dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcor
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 9 rows and 9 columns.</p>

<hr>
<h2 id='proportionize'>Turn a number into a valid proportion</h2><span id='topic+proportionize'></span>

<h3>Description</h3>

<p>An internal function not intended for the user. Turns an arbitrary number into a valid proportion
by setting the number equal to the closest value in [0,1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proportionize(x, zero = 1e-05, one = 0.999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proportionize_+3A_x">x</code></td>
<td>
<p>The number to be turned into a proportion.</p>
</td></tr>
<tr><td><code id="proportionize_+3A_zero">zero</code></td>
<td>
<p>A very small number that is just larger than 0.</p>
</td></tr>
<tr><td><code id="proportionize_+3A_one">one</code></td>
<td>
<p>A number that is just smaller than 1.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>proportionize(-0.03)
proportionize(1.2)
proportionize(.63)
</code></pre>

<hr>
<h2 id='upper_tri_vec'>Turn symmetric matrix into vector</h2><span id='topic+upper_tri_vec'></span>

<h3>Description</h3>

<p>An internal function not intended for the user. Turns a matrix into a vector of the upper-triangular
elements (arranged by row).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upper_tri_vec(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upper_tri_vec_+3A_m">m</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># make a simple correlation matrix
x = rnorm(10); y = rnorm(10); z = rnorm(10)
mat = cor( data.frame(x,y,z) )

# turn into into vector
upper_tri_vec(mat)
</code></pre>

<hr>
<h2 id='wcor'>An example within-cluster correlation dataframe</h2><span id='topic+wcor'></span>

<h3>Description</h3>

<p>An example of how to set up the within-cluster correlation dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wcor
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 6 rows and 6 columns.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
