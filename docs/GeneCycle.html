<!DOCTYPE html><html><head><title>Help for package GeneCycle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GeneCycle}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#avgp'><p>Average Periodogram for Multiple (Genetic) Time Series</p></a></li>
<li><a href='#caulobacter'><p>Microarray Time Series Data for 1444 Caulobacter  Crescentus</p>
Genes</a></li>
<li><a href='#dominant.freqs'><p>Dominant Frequencies in Multiple (Genetic) Time Series</p></a></li>
<li><a href='#fisher.g.test'><p>Fisher's Exact g Test for Multiple (Genetic) Time Series</p></a></li>
<li><a href='#GeneCycle-internal'><p>Internal GeneCycle Functions</p></a></li>
<li><a href='#is.constant'><p>Simple Check for Constant Time Series</p></a></li>
<li><a href='#periodogram'><p>Periodogram Power Spectral Density</p></a></li>
<li><a href='#robust.g.test'><p>Robust g Test for Multiple (Genetic) Time Series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Identification of Periodically Expressed Genes</td>
</tr>
<tr>
<td>Author:</td>
<td>Miika Ahdesmaki, Konstantinos Fokianos, and Korbinian Strimmer.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Miika Ahdesmaki &lt;miika.ahdesmaki@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.7.0), MASS, longitudinal (&ge; 1.1.3), fdrtool (&ge;
1.2.5)</td>
</tr>
<tr>
<td>Description:</td>
<td>The GeneCycle package implements the approaches of Wichert
        et al. (2004) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtg364">doi:10.1093/bioinformatics/btg364</a>&gt;, Ahdesmaki 
        et al. (2005) &lt;<a href="https://doi.org/10.1186%2F1471-2105-6-117">doi:10.1186/1471-2105-6-117</a>&gt; and Ahdesmaki et al.
        (2007) &lt;<a href="https://doi.org/10.1186%2F1471-2105-8-233">doi:10.1186/1471-2105-8-233</a>&gt; for detecting periodically 
        expressed genes from gene expression time series data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-05 12:58:49 UTC; ktql786</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-05 17:20:03 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='avgp'>Average Periodogram for Multiple (Genetic) Time Series</h2><span id='topic+avgp'></span><span id='topic+avpg'></span>

<h3>Description</h3>

<p><code>avgp</code> calculates and plots the average periodogram as described in
Wichert, Fokianos and Strimmer (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avgp(x, title = deparse(substitute(x)), plot = TRUE, angular = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avgp_+3A_x">x</code></td>
<td>
<p>multiple (genetic) time series data. Each <b>column</b> of this
matrix corresponds to a separate variable/time series</p>
</td></tr>
<tr><td><code id="avgp_+3A_title">title</code></td>
<td>
<p>name of the data set (default is the name of the data object)</p>
</td></tr>
<tr><td><code id="avgp_+3A_plot">plot</code></td>
<td>
<p>plot the average periodogram?</p>
</td></tr>
<tr><td><code id="avgp_+3A_angular">angular</code></td>
<td>
<p>convert frequencies to angular frequencies?</p>
</td></tr>
<tr><td><code id="avgp_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>
and to <code><a href="#topic+periodogram">periodogram</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average periodogram is simply the frequency-wise average of the spectral density (as estimated
by the Fourier transform) over all times series. 
To calculate the average periodogram the function <code><a href="#topic+periodogram">periodogram</a></code>
is used. See Wichert, Fokianos and Strimmer (2004)
for more details.
</p>


<h3>Value</h3>

<p>A list object with the following components:
</p>
<table>
<tr><td><code>freq</code></td>
<td>
<p>A vector with the discrete Fourier frequencies (see <code><a href="#topic+periodogram">periodogram</a></code>).
If the option angular=TRUE  then the output are angular frequencies (2*pi*f).</p>
</td></tr>
<tr><td><code>avg.spec</code></td>
<td>
<p>A vector with the average power spectral density at each frequency.</p>
</td></tr>
<tr><td><code>title</code></td>
<td>
<p>Name of the data set underlying the average periodogram.</p>
</td></tr>
</table>
<p>The result is returned invisibly if <code>plot</code> is true.
</p>


<h3>Author(s)</h3>

<p>Konstantinos Fokianos and
Korbinian Strimmer (<a href="https://www.strimmerlab.org/">https://www.strimmerlab.org/</a>).
</p>


<h3>References</h3>

<p>Wichert, S., Fokianos, K., and Strimmer, K. (2004).  Identifying periodically expressed transcripts
in microarray time series data. <em>Bioinformatics</em> <b>20</b>:5-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+periodogram">periodogram</a></code>, <code><a href="stats.html#topic+spectrum">spectrum</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load GeneCycle library
library("GeneCycle")

# load data set
data(caulobacter)

# how many samples and how many genes?
dim(caulobacter)

# average periodogram
avgp.caulobacter &lt;- avgp(caulobacter, "Caulobacter")
avgp.caulobacter

# just compute and don't plot 
avgp(caulobacter, "Caulobacter", plot=FALSE)
</code></pre>

<hr>
<h2 id='caulobacter'>Microarray Time Series Data for 1444 Caulobacter  Crescentus 
Genes</h2><span id='topic+caulobacter'></span>

<h3>Description</h3>

<p>This data set describes the temporal expression of 1444 genes
(open reading frames) in the cell cycle of the bacterium
<em>Caulobacter crescentus</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(caulobacter)
</code></pre>


<h3>Format</h3>

<p><code>caulobacter</code> is a <code><a href="longitudinal.html#topic+longitudinal">longitudinal</a></code> object
containing the data from the Laub et al. (2000) experiment.
Essentially, this is a matrix with with 1444 columns (=genes)
and 11 rows (=time points) 
</p>


<h3>Source</h3>

<p>This data is described in Laub et al. (2000).
</p>


<h3>References</h3>

<p>Laub, M.T., McAdams, H.H., Feldblyum, Fraser, C.M., and Shapiro, L.
(2000) Global analysis of the genetic network controlling
a bacterial cell cycle. <em>Science</em>, <b>290</b>, 2144&ndash;1248.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load GeneCycle library
library("GeneCycle")

# load data set
data(caulobacter)
is.longitudinal(caulobacter)

# how many samples and how many genes?
dim(caulobacter)
summary(caulobacter)
get.time.repeats(caulobacter)

# plot first nine time series
plot(caulobacter, 1:9)
</code></pre>

<hr>
<h2 id='dominant.freqs'>Dominant Frequencies in Multiple (Genetic) Time Series</h2><span id='topic+dominant.freqs'></span>

<h3>Description</h3>

<p><code>dominant.freqs</code> returns the m dominant frequencies (highest peaks)
in each of the periodogram computed for the individual time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominant.freqs(x, m=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dominant.freqs_+3A_x">x</code></td>
<td>
<p>multivariate (genetic) time series (each <b>column</b> of this
matrix corresponds to a separate variable/time series), or a vector with a single
time series</p>
</td></tr>
<tr><td><code id="dominant.freqs_+3A_m">m</code></td>
<td>
<p>number of dominant frequences</p>
</td></tr>
<tr><td><code id="dominant.freqs_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+periodogram">periodogram</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or vector, if only 1 time series is considered) with the
dominant frequencies. In a matrix, each column
corresponds to one time series.
</p>


<h3>Author(s)</h3>

<p>Konstantinos Fokianos and
Korbinian Strimmer (<a href="https://www.strimmerlab.org/">https://www.strimmerlab.org/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+periodogram">periodogram</a></code>, <code><a href="stats.html#topic+spectrum">spectrum</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load GeneCycle library
library("GeneCycle")

# load data set
data(caulobacter)

# how many samples and how many genes?
dim(caulobacter)

# first three dominant frequencies for each gene
dominant.freqs(caulobacter, 3)

# first four dominant frequencies for gene no. 1000
dominant.freqs(caulobacter[,1000], 4)
</code></pre>

<hr>
<h2 id='fisher.g.test'>Fisher's Exact g Test for Multiple (Genetic) Time Series</h2><span id='topic+fisher.g.test'></span>

<h3>Description</h3>

<p><code>fisher.g.test</code> calculates the p-value(s) according to Fisher's
exact g test for one or more time series. This test is useful to detect hidden
periodicities of unknown frequency in a data set.  For an application to
microarray data see Wichert, Fokianos, and Strimmer (2004). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher.g.test(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fisher.g.test_+3A_x">x</code></td>
<td>
<p>vector or matrix with  time series data (one time series per column).</p>
</td></tr>
<tr><td><code id="fisher.g.test_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+periodogram">periodogram</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fisher (1929) devised an exact procedure to test the null hypothesis of Gaussian
white noise against the alternative of an added deterministic periodic component
of unspecified frequency.  The basic idea behind the test is to reject the 
null hypothesis if the periodogram contains a value significantly larger
than the average value (cf. Brockwell and Davis, 1991).  
This test is useful in the context of microarray genetic time series
analysis as a gene selection method - see Wichert, Fokianos and Strimmer (2004)
for more details.   Note that in the special case of a constant time series
the  p-value returned by <code>fisher.g.test</code> is 
exactly 1 (i.e. the null hypothesis is not rejected).
</p>


<h3>Value</h3>

<p>A vector of p-values (one for each time series).  Multiple testing
may then be done using the the false discover rate approach
(function <code><a href="fdrtool.html#topic+fdrtool">fdrtool</a></code>).
</p>


<h3>Author(s)</h3>

<p>Konstantinos Fokianos and
Korbinian Strimmer (<a href="https://www.strimmerlab.org/">https://www.strimmerlab.org/</a>).
</p>


<h3>References</h3>

<p>Fisher, R.A. (1929). Tests of significance in harmonic analysis. <em>Proc. Roy. Soc. A</em>, <b>125</b>, 54&ndash;59.
</p>
<p>Brockwell, P.J., and Davis, R.A.  (1991). Time Series: Theory and Methods (2nd ed).  Springer Verlag.
(the g-test is discussed in section 10.2).
</p>
<p>Wichert, S., Fokianos, K., and Strimmer, K. (2004).  Identifying periodically expressed transcripts
in microarray time series data. <em>Bioinformatics</em> <b>20</b>:5-20.
</p>


<h3>See Also</h3>

<p><code><a href="fdrtool.html#topic+fdrtool">fdrtool</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load GeneCycle library
library("GeneCycle")

# load data set
data(caulobacter)

# how many samples and and how many genes?
dim(caulobacter)

# p-values from Fisher's g test
pval.caulobacter &lt;- fisher.g.test(caulobacter)
pval.caulobacter

# compute Fdr and fdr values
fdr.out &lt;- fdrtool(pval.caulobacter, statistic="pvalue")

# how many significant?
sum(fdr.out$qval &lt; 0.05) # tail area-based Fdr
sum(fdr.out$lfdr &lt; 0.2)  # density-based local fdr

</code></pre>

<hr>
<h2 id='GeneCycle-internal'>Internal GeneCycle Functions</h2><span id='topic+dominant.freqs.single'></span><span id='topic+periodogram.spec.single'></span><span id='topic+periodogram.spec'></span><span id='topic+periodogram.freq'></span><span id='topic+fisher.g.test.single'></span><span id='topic+is.constant.single'></span><span id='topic+robust.spectrum.single'></span><span id='topic+spearman'></span><span id='topic+gPopCreate'></span><span id='topic+myresample'></span><span id='topic+fit.DC'></span><span id='topic+fit.freqs'></span><span id='topic+fit.pi'></span><span id='topic+g.statistic'></span>

<h3>Description</h3>

<p>Internal GeneCycle functions.
</p>


<h3>Note</h3>

<p>These are not to be called by the user (or in some cases are just
waiting for proper documentation to be written).
</p>

<hr>
<h2 id='is.constant'>Simple Check for Constant Time Series</h2><span id='topic+is.constant'></span>

<h3>Description</h3>

<p><code>is.constant</code> is a utility function that
checks whether a time series is constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.constant(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.constant_+3A_x">x</code></td>
<td>
<p>vector or matrix with time series data (one time series per column)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with a boolean statement (<code>TRUE</code> or <code>FALSE</code>) for each time series.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://www.strimmerlab.org/">https://www.strimmerlab.org/</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load GeneCycle library
library("GeneCycle")

# load data set
data(caulobacter)

# any constant genes?
sum(is.constant(caulobacter))

# but here:
series.1 &lt;- rep(1, 10)
series.2 &lt;- seq(1, 10)
is.constant( cbind(series.1, series.2) )

</code></pre>

<hr>
<h2 id='periodogram'>Periodogram Power Spectral Density</h2><span id='topic+periodogram'></span>

<h3>Description</h3>

<p><code>periodogram</code> is a wrapper function for <code><a href="stats.html#topic+spectrum">spectrum</a></code>
with some special options set. It
returns the power spectral density, i.e. the
squared modulus of the Fourier coefficient divided by the length
of the series, for multiple time series as well as the corresponding 
Fourier frequencies. The frequencies range between 
0 and the Nyquist critical frequency fc = <code><a href="stats.html#topic+frequency">frequency</a></code>(x)/2. 
</p>
<p><code>periodogram</code>  is used by the functions
<code><a href="#topic+avgp">avgp</a></code> and <code><a href="#topic+fisher.g.test">fisher.g.test</a></code>.
For general periodogram functions
please refer to <code><a href="stats.html#topic+spectrum">spectrum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodogram(x, method = "builtin")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodogram_+3A_x">x</code></td>
<td>
<p>vector or matrix containing the time series data
(one time series per column)</p>
</td></tr>
<tr><td><code id="periodogram_+3A_method">method</code></td>
<td>
<p>a string that specifies which method should be used to
compute the spectral density: &quot;builtin&quot; employs the function
<code><a href="stats.html#topic+spectrum">spectrum</a></code> with the options 
taper=0, plot=FALSE, fast=FALSE, detrend=FALSE, and demean=TRUE; 
&quot;clone&quot; employs directly the Fourier transform function <code><a href="stats.html#topic+fft">fft</a></code>
(with sames results as &quot;builtin&quot;); and &quot;smooth&quot; uses the
function <code><a href="stats.html#topic+spectrum">spectrum</a></code> with options as above plus span=3.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object with the following components:
</p>
<table>
<tr><td><code>spec</code></td>
<td>
<p>A vector or matrix with the estimated power spectral densities
(one column per time series).</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>A vector with frequencies f ranging from 0 to fc 
(if the sampling rate <code><a href="stats.html#topic+frequency">frequency</a></code>(x)) equals 1 then fc = 0.5).
Angular frequencies may be obtained by multiplication with 2*pi
(i.e. omega = 2*pi*f).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Konstantinos Fokianos and
Korbinian Strimmer (<a href="https://www.strimmerlab.org/">https://www.strimmerlab.org/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+spectrum">spectrum</a></code>, <code><a href="#topic+avgp">avgp</a></code>, <code><a href="#topic+fisher.g.test">fisher.g.test</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load GeneCycle library
library("GeneCycle")

# load data set
data(caulobacter)

# how many genes and how many samples?
dim(caulobacter)

# periodograms of the first 10 genes
periodogram(caulobacter[,1:10])
</code></pre>

<hr>
<h2 id='robust.g.test'>Robust g Test for Multiple (Genetic) Time Series</h2><span id='topic+robust.g.test'></span><span id='topic+robust.spectrum'></span>

<h3>Description</h3>

<p><code>robust.g.test</code> calculates the p-value(s) for a robust
nonparametric version of Fisher's g-test (1929). Details
of this approach are described in Ahdesmaki et al. (2005), along with
an extensive discussion of its application to gene expression data.
From GeneCycle 1.1.0 on the robust regression based method published 
in Ahdesmaki et al. (2007) is also implemented (using Tukey's biweight
based M-estimation/regression.)
</p>
<p><code>robust.spectrum</code> computes a robust rank-based estimate
of the periodogram/correlogram - see  Ahdesmaki et al. (2005)
for details. Alternatively it can also be used (since GeneCycle 1.1.0)
for evaluating the robust regression based spectral estimates,
suitable for processing non-uniformly sampled data (unknown 
periodicity time: return spectral estimates, known periodicity 
time: return p-values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust.g.test(y, index, perm = FALSE, x, noOfPermutations = 300, 
algorithm=c("rank", "regression"), t)
robust.spectrum(x, algorithm = c("rank", "regression"), t, 
periodicity.time = FALSE, noOfPermutations = 300)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robust.g.test_+3A_y">y</code></td>
<td>
<p>the matrix consisting of the spectral estimates
as column vectors</p>
</td></tr>
<tr><td><code id="robust.g.test_+3A_index">index</code></td>
<td>
<p>an index to the spectral estimates (RANK BASED 
APPROACH ONLY; for specifying a periodicity time 
in the regression approach, see the parameter 
periodicity.time) that is to be used in the 
testing for periodicity. If <code>index</code> is 
missing for the rank based approach, the maximum 
component of the spectral estimate is used in 
testing (regardless of the frequency of this 
maximum)</p>
</td></tr>
<tr><td><code id="robust.g.test_+3A_periodicity.time">periodicity.time</code></td>
<td>
<p>time (same units as in vector <code>t</code>) of 
period where periodicity will be detected (ROBUST 
REGRESSION BASED APPROACH ONLY) that is to be used 
in the search for periodicity. If periodicity.time 
is not given for the regression based approach, 
the whole spectrum is evaluated (more time consuming)
and the maximum periodogram ordinate will be investigated</p>
</td></tr>
<tr><td><code id="robust.g.test_+3A_perm">perm</code></td>
<td>
<p>if <code>perm</code> is <code>FALSE</code>, 
a simulated distribution for the g-statistic is used 
(applies to the rank based approach only). 
If per <code>perm</code> is <code>TRUE</code>, permutation 
tests are used to find the distribution of the 
g-statistic for each time series separately. 
With the regression based approach (Ahdesmaki 
et al. 2007) permutation tests will always be used</p>
</td></tr>
<tr><td><code id="robust.g.test_+3A_x">x</code></td>
<td>
<p>a matrix consisting of the time series as column
vectors. In <code>robust.g.test</code> only needed if
permutation tests are used</p>
</td></tr>
<tr><td><code id="robust.g.test_+3A_noofpermutations">noOfPermutations</code></td>
<td>
<p>number of permutations that 
are used for each time series (default = 300)</p>
</td></tr>
<tr><td><code id="robust.g.test_+3A_algorithm">algorithm</code></td>
<td>
<p><code>rank</code> corresponds to the rank based approach 
(Ahdesmaki et al. 2005) and 
<code>regression</code> for the regression based approach (Ahdesmaki et al. 
2007), which is more suitable for time
series with non-uniform sampling (default = rank)</p>
</td></tr>
<tr><td><code id="robust.g.test_+3A_t">t</code></td>
<td>
<p>sampling time vector (only for the regression based 
approach)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Application of <code>robust.g.test</code> can be very computer intensive, 
especially
the production of the distribution of the test statistics may take a 
lot
of time. Therefore, this distribution (dependening on the length of
the time series) is stored in an external file to avoid recomputation
(see example below). When applying permutation tests no external file 
is
used but the computation time will always be high.
</p>
<p>For the general idea behind the Fisher's g test also see  
<code><a href="#topic+fisher.g.test">fisher.g.test</a></code> which implements an analytic approach for 
g-testing.
This is faster but not robust and also assumes Gaussian noise.
</p>
<p>Note that when using the regression based approach there will regularly 
be warnings about the non-convergence of the regression (iteration limit 
default at 20 cycles in <a href="MASS.html#topic+rlm">rlm</a>).
</p>


<h3>Value</h3>

<p><code>robust.g.test</code> returns a list of p-values.
<code>robust.spectrum</code> returns a matrix where the column vectors 
correspond
to the spectra corresponding to each time series. As an exception, if 
the robust regression 
based approach (Ahdesmaki et al. 2007) is used with a known periodicity 
time, the function 
robust.spectrum returns p-values (computation will take a lot of time 
depending on how many
permutations are used per time series and time series length).
</p>


<h3>Author(s)</h3>

<p>Miika Ahdesmaki (<a href="mailto:miika.ahdesmaki@gmail.com">miika.ahdesmaki@gmail.com</a>).
</p>


<h3>References</h3>

<p>Fisher, R.A. (1929). Tests of significance in harmonic analysis. 
<em>Proc. Roy. Soc. A</em>, <b>125</b>, 54&ndash;59.
</p>
<p>Ahdesmaki, M., Lahdesmaki, H., Pearson, R., Huttunen, H., and 
Yli-Harja O.
(2005).  <em>BMC Bioinformatics</em> <b>6</b>:117. <a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-6-117">https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-6-117</a>
</p>
<p>Ahdesmaki, M., Lahdesmaki, H., Gracey, A., Shmulevich, I., and 
Yli-Harja O.
(2007).  <em>BMC Bioinformatics</em> <b>8</b>:233. <a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-8-233">https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-8-233</a>
</p>


<h3>See Also</h3>

<p><code><a href="fdrtool.html#topic+fdrtool">fdrtool</a></code>, <code><a href="#topic+fisher.g.test">fisher.g.test</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load GeneCycle library
library("GeneCycle")

# load data set
data(caulobacter)

# how many samples and and how many genes?
dim(caulobacter)


# robust, rank-based spectral estimator applied to first 5 genes
spe5 = robust.spectrum(caulobacter[,1:5])

# g statistics can be computed from the spectrum (internal use mostly 
# but can be checked here)
## g.statistic(spe5)

# robust p-values, use Monte Carlo simulation (not permutation tests) 
# to estimate the null hypothesis distribution
pval = robust.g.test(spe5)  # generates a file with the name "g_pop_length_11.txt"
pval = robust.g.test(spe5)  # second call: much faster..

pval

# robust p-values, now look at index 4 (index can be anything from 1 
# (DC-level) to N (length of the time series and highest frequency))
pval = robust.g.test(spe5, 4)  # generates a file
pval = robust.g.test(spe5, 4)  # second call: much faster..


pval

# delete the external files 
unlink("g_pop_length_11.txt")
unlink("g_pop_length_11indexed.txt")

#
# Next let us see how the robust regression based approach can be 
# applied (Ahdesmaki et al. 2007)
# First: Unknown frequencies
t=c(0,15,30,45,60,75,90,105,120,135,150)
y = robust.spectrum(x=caulobacter[,1:5],algorithm="regression", t=t)
pvals = robust.g.test(y = y, perm=TRUE, x=caulobacter[,1:5], 
noOfPermutations = 50, algorithm = "regression", t=t)
 
pvals

#
# The following example illustrates how to use the regression based 
# method if we have prior knowledge about the frequency/period time
# of periodicity
t = 0:9 # time indices
t = t + runif(10)-0.5 # make time indices non-uniform
A = 0.5 * matrix(rnorm(50),10,5)       # create random time series (no outliers)
A[,5]=A[,5]+matrix(sin(0.5*pi*t),10,1) # superimpose a sinusoidal
periodicity.time=4                     # where to look for periodicity
# note that now the function robust.spectrum returns the p-values (in 
# all other cases it will return spectral estimates):
pvals=robust.spectrum(x=A,algorithm="regression", 
t=t,periodicity.time=periodicity.time, noOfPermutations=50)
pvals  # 5th p-value is smallish, as expected


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
