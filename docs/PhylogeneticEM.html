<!DOCTYPE html><html><head><title>Help for package PhylogeneticEM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PhylogeneticEM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_complementary'><p>Add several entries, when only one is not NA.</p></a></li>
<li><a href='#allocate_regimes_from_shifts'><p>Allocation of regimes to nodes.</p></a></li>
<li><a href='#allocate_shifts_from_regimes'><p>Allocation of shifts to edges</p></a></li>
<li><a href='#allocate_subset_node.simulate'><p>Iteration allocation</p></a></li>
<li><a href='#check_data'><p>Test the format of data entry.</p></a></li>
<li><a href='#check_dimensions'><p>Check dimensions of the parameters</p></a></li>
<li><a href='#check_parsimony'><p>Check Parsimony, assuming no homoplasy</p></a></li>
<li><a href='#check_parsimony_clusters'><p>Check whether an allocation of the shifts is parsimonious,</p>
in the &quot;infinite site model&quot;.</a></li>
<li><a href='#check_range_alpha'><p>Check range of alpha</p></a></li>
<li><a href='#check.selection.strength'><p>Check selection strength</p></a></li>
<li><a href='#clusters_from_shifts'><p>Clustering associated to a shift allocation, assuming no homoplasy.</p></a></li>
<li><a href='#compute_actualization_matrix_ultrametric'><p>Compute Matrix W of actualization (Ultrametric case)</p></a></li>
<li><a href='#compute_betas_from_shifts'><p>Computation of the optimal values at nodes and tips.</p></a></li>
<li><a href='#compute_diff_exp.BM'><p>Compute differences of expectations between node and parent.</p></a></li>
<li><a href='#compute_dist_phy'><p>Phylogenetic Distances</p></a></li>
<li><a href='#compute_E.simple'><p>E step</p></a></li>
<li><a href='#compute_expectations.BM'><p>Compute the expected states of a BM</p></a></li>
<li><a href='#compute_expectations.scOU'><p>Compute the expected states of a scOU</p></a></li>
<li><a href='#compute_fixed_moments'><p>Compute fixed moments for E step.</p></a></li>
<li><a href='#compute_gauss_lasso'><p>Do a lm on top of a lasso regression.</p></a></li>
<li><a href='#compute_log_likelihood.simple'><p>Log Likelihood</p></a></li>
<li><a href='#compute_mahalanobis_distance.simple'><p>Squared Mahalanobis Distance</p></a></li>
<li><a href='#compute_mean_variance.simple'><p>Compute moments of params_old</p></a></li>
<li><a href='#compute_residuals.simple'><p>Residuals</p></a></li>
<li><a href='#compute_shifts_from_betas'><p>Computation of shifts from the vector of optimal values</p></a></li>
<li><a href='#compute_state_filter'><p>List of potential daughter states when parent is in state k.</p></a></li>
<li><a href='#compute_stationary_variance'><p>Compute the stationary variance matrix</p></a></li>
<li><a href='#compute_sum_var_diff'><p>Compute weighted sum of var_diff</p></a></li>
<li><a href='#compute_times_ca'><p>Common Ancestors Times</p></a></li>
<li><a href='#compute_tree_correlations_matrix.BM'><p>Matrix of tree-induced correlations for the BM</p></a></li>
<li><a href='#compute_tree_correlations_matrix.scOU'><p>Matrix of tree-induced correlations for the scOU</p></a></li>
<li><a href='#compute_var_diff.BM'><p>Compute variances of differences between nodes and parents.</p></a></li>
<li><a href='#compute_var_M.BM'><p>Computation of the variance.</p></a></li>
<li><a href='#compute_variance_block_diagonal.BM'><p>Tips Variances for the BM</p></a></li>
<li><a href='#compute_variance_block_diagonal.OU'><p>Tips Variances for the OU</p></a></li>
<li><a href='#compute_variance_covariance.BM'><p>Complete variance covariance matrix for BM</p></a></li>
<li><a href='#compute_variance_covariance.OU'><p>Complete variance covariance matrix for OU</p></a></li>
<li><a href='#compute_variance_covariance.OU.nonsym'><p>Complete variance covariance matrix for OU</p></a></li>
<li><a href='#compute_variance_covariance.scOU'><p>Complete variance covariance matrix for scOU</p></a></li>
<li><a href='#correspondenceEdges'><p>Correspondence between edges numbers</p></a></li>
<li><a href='#enlight'><p>Make the result lighter</p></a></li>
<li><a href='#enumerate_parsimony'><p>Enumerate all the possible regime allocations, given a clustering</p>
of the tips.</a></li>
<li><a href='#enumerate_tips_under_edges'><p>Tips descendants of nodes.</p></a></li>
<li><a href='#equivalent_shifts'><p>Find all equivalent shifts allocations and values.</p></a></li>
<li><a href='#equivalent_shifts_edges'><p>Find all the equivalent shift edges allocations.</p></a></li>
<li><a href='#equivalent_shifts_values'><p>Find values given edges. OU stationary case. Ultrametric tree.</p></a></li>
<li><a href='#estimate.alpha'><p>Function to estimate alpha</p></a></li>
<li><a href='#estimateEM'><p>Perform One EM</p></a></li>
<li><a href='#extract'><p>Extraction function</p></a></li>
<li><a href='#extract_variance_covariance'><p>Extract sub-matrices of variance.</p></a></li>
<li><a href='#extract.enumerate_parsimony'><p>Extract the result of <code>enumerate_parsimony</code> at a node.</p></a></li>
<li><a href='#extract.equivalent_shifts'><p>Extract the shifts values for one trait.</p></a></li>
<li><a href='#extract.parsimonyCost'><p>Extraction of the actual number of solutions.</p></a></li>
<li><a href='#extract.parsimonyNumber'><p>Extraction of the actual number of solutions.</p></a></li>
<li><a href='#extract.partitionsNumber'><p>Extract from object <code>partitionsNumber</code></p></a></li>
<li><a href='#extract.simul_process'><p>Extraction of simulated traits</p></a></li>
<li><a href='#find_grid_alpha'><p>Find a reasonable grid for alpha</p></a></li>
<li><a href='#find_independent_regression_vectors.glmnet_multivariate'><p>Given a regularization path, find K selected independent variables.</p></a></li>
<li><a href='#find_rotation'><p>Test for rotation invariant datasets</p></a></li>
<li><a href='#find_shift_values'><p>Find values given edges. OU stationary case. Ultrametric tree.</p></a></li>
<li><a href='#format_output'><p>Run the EM for several values of K</p></a></li>
<li><a href='#get_criterion'><p>Get Model Selection Criterion</p></a></li>
<li><a href='#get_variance_node'><p>Get variance matrix of a node</p></a></li>
<li><a href='#go_back_to_original_process'><p>Scale the parameters back to the original process</p></a></li>
<li><a href='#imputed_traits'><p>Ancestral State Reconstruction</p></a></li>
<li><a href='#incidence_matrix_actualization_factors'><p>Compute the actualization factors to apply to the incidence matrix.</p></a></li>
<li><a href='#incidence.matrix'><p>Incidence matrix of a tree.</p></a></li>
<li><a href='#incidence.matrix.full'><p>Incidence matrix of a tree.</p></a></li>
<li><a href='#init.allocate_regimes_from_shifts'><p>Initialization for the allocation of shifts.</p></a></li>
<li><a href='#init.alpha.gamma.estimation'><p>Initialization the selection strength alpha using robust estimation</p></a></li>
<li><a href='#init.compute_betas_from_shifts'><p>Initialization for the computation of the optimal values</p></a></li>
<li><a href='#init.EM.lasso'><p>Initialization of the shifts using Lasso.</p></a></li>
<li><a href='#init.enumerate_parsimony'><p>Initialization for the enumeration of parsimonious solutions.</p></a></li>
<li><a href='#init.incidence.matrix'><p>Initialization for incidence matrix</p></a></li>
<li><a href='#init.incidence.matrix.full'><p>Initialization for incidence matrix (full tree)</p></a></li>
<li><a href='#init.parsimonyCost'><p>Initialization for parsimonyCost.</p></a></li>
<li><a href='#init.parsimonyNumber'><p>Initialization for parsimonyNumber.</p></a></li>
<li><a href='#init.simulate.BM'><p>Initialize BM</p></a></li>
<li><a href='#init.simulate.OU'><p>Initialize state and expectation matrices</p></a></li>
<li><a href='#init.simulate.StateAndExp'><p>Initialize state and expectation matrices</p></a></li>
<li><a href='#is.in.ranges'><p>Check whether parameters are in ranges.</p></a></li>
<li><a href='#lasso_regression_K_fixed.glmnet_multivariate'><p>Do a lasso regression with the number of non-zero variables fixed.</p></a></li>
<li><a href='#log_likelihood'><p>Log Likelihood of a fitted object</p></a></li>
<li><a href='#matrix_of_possibles'><p>Compute parent matrix from possibles daughter matrices.</p></a></li>
<li><a href='#merge_complementary_vectors'><p>Merge several complementary vectors into one.</p></a></li>
<li><a href='#merge_params_independent'><p>Merge a list of independent parameters into into one parameter</p></a></li>
<li><a href='#merge_rotations'><p>Merge fits from independent runs of PhyloEM.</p></a></li>
<li><a href='#model_selection'><p>Model Selection of a fitted object</p></a></li>
<li><a href='#monkeys'><p>New World Monkeys dataset</p></a></li>
<li><a href='#node_optimal_values'><p>Computation of the optimal values at nodes and tips.</p></a></li>
<li><a href='#params_BM'><p>Create an object <code>params_process</code> for a BM</p></a></li>
<li><a href='#params_OU'><p>Create an object <code>params_process</code> for an OU</p></a></li>
<li><a href='#params_process'><p>Create an object params_process</p></a></li>
<li><a href='#params_process.character'><p>Create an object <code>params_process</code></p></a></li>
<li><a href='#params_process.PhyloEM'><p>Parameter estimates</p></a></li>
<li><a href='#parsimonyCost'><p>Minimal number of shifts needed to get a clustering.</p></a></li>
<li><a href='#parsimonyNumber'><p>Number of equivalent parsimonious allocations.</p></a></li>
<li><a href='#partitionsNumber'><p>Number of different models</p></a></li>
<li><a href='#penalty_BaraudGiraudHuet_likelihood'><p>Penalty function type Baraud Giraud Huet.</p></a></li>
<li><a href='#penalty_BirgeMassart_shape1'><p>Penalty function type Birgé-Massart 1</p></a></li>
<li><a href='#penalty_BirgeMassart_shape2'><p>Penalty function type Birgé-Massart 2</p></a></li>
<li><a href='#penalty_pBIC'><p>Penalty function type pBIC</p></a></li>
<li><a href='#PhyloEM'><p>Model Estimation with Detection of Shifts</p></a></li>
<li><a href='#plot_criterion'><p>Plot Model Selection Criterion</p></a></li>
<li><a href='#plot.enumerate_parsimony'><p>Plot all the equivalent solutions.</p></a></li>
<li><a href='#plot.equivalent_shifts'><p>Plot all the equivalent solutions.</p></a></li>
<li><a href='#plot.params_process'><p>Plot for class <code>simul_process</code></p></a></li>
<li><a href='#plot.PhyloEM'><p>Plot for class <code>PhyloEM</code></p></a></li>
<li><a href='#prod_index'><p>Product of elements of a matrix</p></a></li>
<li><a href='#qr_solve_exact'><p>exact qr.solve</p></a></li>
<li><a href='#recursionDown'><p>Generic recursion down the tree.</p></a></li>
<li><a href='#residuals.PhyloEM'><p>Residuals of a fitted object</p></a></li>
<li><a href='#sample_edges_intervals'><p>Sample equally spaced edges.</p></a></li>
<li><a href='#sample_shifts_edges'><p>Sample shifts edges in a parsimonious way.</p></a></li>
<li><a href='#scale_params'><p>Scale variance and selection strength from a linear transform</p></a></li>
<li><a href='#segmentation.BM'><p>Segmentation in the BM case</p></a></li>
<li><a href='#segmentation.OU.specialCase.lasso'><p>Segmentation in the OU special case, using lasso regression</p></a></li>
<li><a href='#segmentation.OU.specialCase.same_shifts'><p>Segmentation in the OU special case, conserving the same shifts</p>
position.</a></li>
<li><a href='#shifts_to_simmap'><p>Simmap format mapping from list of edges</p></a></li>
<li><a href='#shifts.list_to_matrix'><p>Compute the matrix of shifts.</p></a></li>
<li><a href='#shifts.list_to_vector'><p>Compute the vector of shifts.</p></a></li>
<li><a href='#shifts.matrix_to_list'><p>Compute the list of shifts.</p></a></li>
<li><a href='#shifts.vector_to_list'><p>Compute the list of shifts.</p></a></li>
<li><a href='#simul_process'><p>Simulate a Stochastic Process on a tree</p></a></li>
<li><a href='#simulate_internal'><p>Simulate a Stochastic Process on a tree</p></a></li>
<li><a href='#split_params_independent'><p>Split independent parameters into a list of parameters</p></a></li>
<li><a href='#sum_partitions'><p>Sum on all subsets.</p></a></li>
<li><a href='#sum_partitions.cardFixed'><p>Sum on subsets of a given cardinal.</p></a></li>
<li><a href='#sum_prod.comb'><p>Sum on a simplex</p></a></li>
<li><a href='#sum_simplex'><p>Sum on a simplex</p></a></li>
<li><a href='#test.root.state'><p>Test state of root.</p></a></li>
<li><a href='#transform_branch_length'><p>Transform branch length for a re-scaled BM</p></a></li>
<li><a href='#transform_shifts_values'><p>Transform the shift values</p></a></li>
<li><a href='#update.allocate_regimes_from_shifts'><p>Update function for regime allocation.</p></a></li>
<li><a href='#update.compute_betas_from_shifts'><p>Update function for optimal value computation</p></a></li>
<li><a href='#update.enumerate_parsimony'><p>Actualization of the enumeration.</p></a></li>
<li><a href='#update.incidence.matrix'><p>Update function for incidence matrix</p></a></li>
<li><a href='#update.incidence.matrix.full'><p>Update function for incidence matrix</p></a></li>
<li><a href='#update.parsimonyCost'><p>Actualization for parsimonyCost.</p></a></li>
<li><a href='#update.parsimonyNumber'><p>Actualization for parsimonyNumber.</p></a></li>
<li><a href='#update.partitionsNumber.gen'><p>Update formula in the general case</p></a></li>
<li><a href='#wrapper_E_step'><p>Wrapper for E step in EM</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Automatic Shift Detection using a Phylogenetic EM</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.0</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Implementation of the automatic shift detection method for
    Brownian Motion (BM) or Ornstein–Uhlenbeck (OU) models of trait evolution on
    phylogenies. Some tools to handle equivalent shifts configurations are also
    available. See Bastide et al. (2017) &lt;<a href="https://doi.org/10.1111%2Frssb.12206">doi:10.1111/rssb.12206</a>&gt; and
    Bastide et al. (2018) &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyy005">doi:10.1093/sysbio/syy005</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>ape (&ge; 5.3), Matrix (&ge; 1.2.18), R (&ge; 3.6.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>capushe (&ge; 1.1.1), foreach (&ge; 1.4.3), gglasso (&ge; 1.4),
glmnet (&ge; 2.0.5), graphics (&ge; 3.6.0), grDevices (&ge; 3.6.0),
LINselect (&ge; 1.1.1), MASS (&ge; 7.3.45), methods (&ge; 3.6.0),
plyr (&ge; 1.8.4), Rcpp (&ge; 1.0.2), robustbase (&ge; 0.92.6), stats
(&ge; 3.6.0), utils (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>combinat (&ge; 0.0.8), doParallel (&ge; 1.0.10), phytools (&ge;
0.5.38), testthat (&ge; 1.0.2), TreeSim (&ge; 2.2), knitr,
rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pbastide/PhylogeneticEM">https://github.com/pbastide/PhylogeneticEM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pbastide/PhylogeneticEM/issues">https://github.com/pbastide/PhylogeneticEM/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 16:25:48 UTC; bastidep</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Bastide [aut, cre],
  Mahendra Mariadassou [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Bastide &lt;paul.bastide@m4x.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_complementary'>Add several entries, when only one is not NA.</h2><span id='topic+add_complementary'></span>

<h3>Description</h3>

<p><code>add_complementary</code> return the only non NA value of a given vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_complementary(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_complementary_+3A_z">z</code></td>
<td>
<p>a vector containing at most only one non-NA value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in function <code>merge_complementary_vectors</code>
</p>


<h3>Value</h3>

<p>row vector of the same size as entry matrix.
</p>

<hr>
<h2 id='allocate_regimes_from_shifts'>Allocation of regimes to nodes.</h2><span id='topic+allocate_regimes_from_shifts'></span>

<h3>Description</h3>

<p><code>allocate_regimes_from_shifts</code> allocate a number (from 0 to the number 
of shifts) to each node, corresponding to its regime : all nodes below shift 
i are numbered by i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocate_regimes_from_shifts(phylo, shifts_edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allocate_regimes_from_shifts_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="allocate_regimes_from_shifts_+3A_shifts_edges">shifts_edges</code></td>
<td>
<p>edges were the shifts are.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of size (ntaxa + Nnode) of the regimes of each node and tip.
</p>

<hr>
<h2 id='allocate_shifts_from_regimes'>Allocation of shifts to edges</h2><span id='topic+allocate_shifts_from_regimes'></span>

<h3>Description</h3>

<p><code>allocate_shifts_from_regimes</code> returns the position of the shifts induced
by the allocation of the regimes. Only works in an &quot;infinite site&quot; model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocate_shifts_from_regimes(phylo, regimes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allocate_shifts_from_regimes_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="allocate_shifts_from_regimes_+3A_regimes">regimes</code></td>
<td>
<p>: vector of size (ntaxa + Nnode) of the regimes of each node
and tip.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of edges numbers where the shifts are.
</p>

<hr>
<h2 id='allocate_subset_node.simulate'>Iteration allocation</h2><span id='topic+allocate_subset_node.simulate'></span>

<h3>Description</h3>

<p><code>allocate_subset_node.simulate</code> slice the data correctly and allocate the right part.
To be used in function UpdateDown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocate_subset_node.simulate(node, array, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allocate_subset_node.simulate_+3A_node">node</code></td>
<td>
<p>node on which to slice</p>
</td></tr>
<tr><td><code id="allocate_subset_node.simulate_+3A_array">array</code></td>
<td>
<p>structure to be sliced</p>
</td></tr>
<tr><td><code id="allocate_subset_node.simulate_+3A_value">value</code></td>
<td>
<p>value to be attributed to the slice</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array: array p x Nnode x 2 (BM), with slice corresponding to node filled with value
</p>

<hr>
<h2 id='check_data'>Test the format of data entry.</h2><span id='topic+check_data'></span>

<h3>Description</h3>

<p><code>check_data</code> tests if the data matrix has the right format, and if it is
correctly ordered to match the tips names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data(phylo, Y_data, check.tips.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_data_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="check_data_+3A_y_data">Y_data</code></td>
<td>
<p>matrix of data at the tips (pxntaxa)</p>
</td></tr>
<tr><td><code id="check_data_+3A_check.tips.names">check.tips.names</code></td>
<td>
<p>(bool) whether to check the tips names or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Y_data a re-ordered matrix of data (if necessary)
</p>

<hr>
<h2 id='check_dimensions'>Check dimensions of the parameters</h2><span id='topic+check_dimensions'></span>

<h3>Description</h3>

<p><code>check_dimensions</code> checks dimensions of the parameters. 
If wrong, throw an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dimensions(
  p,
  root.state,
  shifts,
  variance,
  selection.strength = NULL,
  optimal.value = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_dimensions_+3A_p">p</code></td>
<td>
<p>dimension of the trait simulated</p>
</td></tr>
<tr><td><code id="check_dimensions_+3A_root.state">root.state</code></td>
<td>
<p>(list) state of the root, with:
random : random state (TRUE) or deterministic state (FALSE)
value.root : if deterministic, value of the character at the root
exp.root : if random, expectation of the character at the root
var.root : if random, variance of the character at the root</p>
</td></tr>
<tr><td><code id="check_dimensions_+3A_shifts">shifts</code></td>
<td>
<p>(list) position and values of the shifts :
edges : vector of the K id of edges where the shifts are
values : matrix p x K of values of the shifts on the edges (one column = one shift)
relativeTimes : vector of dimension K of relative time of the shift from the
parent node of edges</p>
</td></tr>
<tr><td><code id="check_dimensions_+3A_variance">variance</code></td>
<td>
<p>variance-covariance matrix size p x p</p>
</td></tr>
<tr><td><code id="check_dimensions_+3A_selection.strength">selection.strength</code></td>
<td>
<p>matrix of selection strength size p x p (OU)</p>
</td></tr>
<tr><td><code id="check_dimensions_+3A_optimal.value">optimal.value</code></td>
<td>
<p>vector of p optimal values at the root (OU)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='check_parsimony'>Check Parsimony, assuming no homoplasy</h2><span id='topic+check_parsimony'></span>

<h3>Description</h3>

<p><code>check_parsimony</code> take a vector of shifts edges, and check whether the
number of groups of the tips induced by this allocation is exactly the number of
shifts plus one. This is equivalent to parsimony when there is no homoplasy (i.e. no 
convergent regimes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_parsimony(tree, edges, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_parsimony_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree</p>
</td></tr>
<tr><td><code id="check_parsimony_+3A_edges">edges</code></td>
<td>
<p>a vector of edges of the tree, where the shifts are</p>
</td></tr>
<tr><td><code id="check_parsimony_+3A_...">...</code></td>
<td>
<p>possibly, a list giving the descendant tips of each edge</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes explicitly the clustering of the tips, using 
function <code><a href="#topic+clusters_from_shifts">clusters_from_shifts</a></code>.
By default, this function uses <code><a href="#topic+enumerate_tips_under_edges">enumerate_tips_under_edges</a></code> to compute 
the list of tips under each edge, but a list can be provided (to avoid extra
computation, if many tests on the same tree are done).
</p>


<h3>Value</h3>

<p>boolean : TRUE if the allocation is parsimonious.
</p>

<hr>
<h2 id='check_parsimony_clusters'>Check whether an allocation of the shifts is parsimonious, 
in the &quot;infinite site model&quot;.</h2><span id='topic+check_parsimony_clusters'></span>

<h3>Description</h3>

<p><code>check_parsimony_clusters</code> takes a vector clusters of the tips, and
checks whether the number of groups of the tips induced by this allocation is
exactly the number of shifts plus one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_parsimony_clusters(tree, edges, clusters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_parsimony_clusters_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree.</p>
</td></tr>
<tr><td><code id="check_parsimony_clusters_+3A_clusters">clusters</code></td>
<td>
<p>a vector of clusters of the tips of the tree (result of
function <code><a href="#topic+clusters_from_shifts">clusters_from_shifts</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes explicitly the clustering of the tips, using 
function <code>check_parsimony</code>.
By default, this function uses <code>enumerate_tips_under_edges</code> to compute 
the list of tips under each edge, but a list can be provided (if many tests are done).
</p>


<h3>Value</h3>

<p>boolean : TRUE if the allocation is parsimonious.
</p>

<hr>
<h2 id='check_range_alpha'>Check range of alpha</h2><span id='topic+check_range_alpha'></span>

<h3>Description</h3>

<p>Check that the chosen values of alpha are not too large
or too small, in order to avoid numerical instabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_range_alpha(alpha, h_tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_range_alpha_+3A_alpha">alpha</code></td>
<td>
<p>a vector of alpha values.</p>
</td></tr>
<tr><td><code id="check_range_alpha_+3A_h_tree">h_tree</code></td>
<td>
<p>the total height of the tree.</p>
</td></tr>
</table>

<hr>
<h2 id='check.selection.strength'>Check selection strength</h2><span id='topic+check.selection.strength'></span>

<h3>Description</h3>

<p><code>check.selection.strength</code> checks, if the process is an OU, if the
selection strength is not too low, in which case the process is replaced
with a BM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.selection.strength(process, selection.strength = NA, eps = 10^(-6), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.selection.strength_+3A_process">process</code></td>
<td>
<p>: &quot;BM&quot; or &quot;OU&quot;</p>
</td></tr>
<tr><td><code id="check.selection.strength_+3A_selection.strength">selection.strength</code></td>
<td>
<p>the selection strength parameter (if OU)</p>
</td></tr>
<tr><td><code id="check.selection.strength_+3A_eps">eps</code></td>
<td>
<p>the tolerance for the selection strength</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function return a process in a form of a character. If the entry
process is &quot;BM&quot;, then nothing is done. If it is &quot;OU&quot;, then the verification
of the selection strength is done.
</p>


<h3>Value</h3>

<p>character : &quot;BM&quot; or &quot;OU&quot;
</p>

<hr>
<h2 id='clusters_from_shifts'>Clustering associated to a shift allocation, assuming no homoplasy.</h2><span id='topic+clusters_from_shifts'></span>

<h3>Description</h3>

<p><code>clusters_from_shifts</code> take a vector of shifts edges, and gives the
clustering of the tips induced by them, in a &quot;no homoplasy&quot; model (i.e. no
convergence is allowed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusters_from_shifts(tree, edges, part.list = enumerate_tips_under_edges(tree))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusters_from_shifts_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree</p>
</td></tr>
<tr><td><code id="clusters_from_shifts_+3A_edges">edges</code></td>
<td>
<p>a vector of edges of the tree, where the shifts are</p>
</td></tr>
<tr><td><code id="clusters_from_shifts_+3A_part.list">part.list</code></td>
<td>
<p>a list giving the descendant tips of each edge</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this function uses <code><a href="#topic+enumerate_tips_under_edges">enumerate_tips_under_edges</a></code> to compute 
the list of tips under each edge.
</p>


<h3>Value</h3>

<p>list of size n+m-1, entry i is the vector of tips bellow edge i.
</p>

<hr>
<h2 id='compute_actualization_matrix_ultrametric'>Compute Matrix W of actualization (Ultrametric case)</h2><span id='topic+compute_actualization_matrix_ultrametric'></span>

<h3>Description</h3>

<p><code>compute_actualization_matrix_ultrametric</code> computes a squares  p*Nedge bloc diagonal
matrix of the (I_p - exp(-A * (h - t_pa(j))))_{j node}.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_actualization_matrix_ultrametric(
  tree,
  selection.strength,
  times_shared = compute_times_ca(tree)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_actualization_matrix_ultrametric_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree.</p>
</td></tr>
<tr><td><code id="compute_actualization_matrix_ultrametric_+3A_selection.strength">selection.strength</code></td>
<td>
<p>the selection strength of the process.</p>
</td></tr>
<tr><td><code id="compute_actualization_matrix_ultrametric_+3A_times_shared">times_shared</code></td>
<td>
<p>a matrix, result of function <code>compute_times_ca</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Careful: the root is not taken into account in this function.
</p>


<h3>Value</h3>

<p>Matrix of size p*Nedge
</p>

<hr>
<h2 id='compute_betas_from_shifts'>Computation of the optimal values at nodes and tips.</h2><span id='topic+compute_betas_from_shifts'></span>

<h3>Description</h3>

<p><code>compute_betas_from_shifts</code> computes the optimal values at the nodes and tips of the
tree, given the value at the root and the list of shifts occurring in the tree.
It assumes an OU model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_betas_from_shifts(phylo, optimal.value, shifts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_betas_from_shifts_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="compute_betas_from_shifts_+3A_optimal.value">optimal.value</code></td>
<td>
<p>the optimal value at the root of the tree.</p>
</td></tr>
<tr><td><code id="compute_betas_from_shifts_+3A_shifts">shifts</code></td>
<td>
<p>position and values of the shifts .</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this is intended to be an internal function, and should not be used.
In general, use <code><a href="#topic+node_optimal_values">node_optimal_values</a></code> to get optimal values
from a set of parameters.
</p>


<h3>Value</h3>

<p>Vector of size (ntaxa + Nnode) of the optimal values at the tips
of the tree.
</p>

<hr>
<h2 id='compute_diff_exp.BM'>Compute differences of expectations between node and parent.</h2><span id='topic+compute_diff_exp.BM'></span>

<h3>Description</h3>

<p><code>compute_diff_exp</code> compute the differences of conditional expectations between all the
nodes and their parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_diff_exp.BM(phylo, conditional_law_X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_diff_exp.BM_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree</p>
</td></tr>
<tr><td><code id="compute_diff_exp.BM_+3A_conditional_law_x">conditional_law_X</code></td>
<td>
<p>result of function <code>compute_E</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix p x Nedge containing, for each edge e finishing at node i,
the quantity E[Z_i|Y]-E[Z_pa(i)|Y].
</p>

<hr>
<h2 id='compute_dist_phy'>Phylogenetic Distances</h2><span id='topic+compute_dist_phy'></span>

<h3>Description</h3>

<p><code>compute_dist_phy</code> computes the phylogenetic distances d_ij between all the
tips i, j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_dist_phy(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_dist_phy_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies on <code>ape</code> function
<code><a href="ape.html#topic+dist.nodes">dist.nodes</a></code>.
</p>


<h3>Value</h3>

<p>a matrix of phylogenetic distances, ordered as the tips of the
tree. The matrix is of type <code><a href="Matrix.html#topic+symmetricMatrix-class">symmetricMatrix-class</a></code>.
</p>

<hr>
<h2 id='compute_E.simple'>E step</h2><span id='topic+compute_E.simple'></span>

<h3>Description</h3>

<p><code>compute_E.simple</code> computes the E step in the simple case where the invert matrix Sigma_YY_inv is given
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_E.simple(
  phylo,
  times_shared,
  distances_phylo,
  process,
  params_old,
  masque_data = c(rep(TRUE, attr(params_old, "p_dim") * length(phylo$tip.label)),
    rep(FALSE, attr(params_old, "p_dim") * phylo$Nnode)),
  F_moments,
  Y_data_vec_known,
  miss = rep(FALSE, attr(params_old, "p_dim") * length(phylo$tip.label)),
  Y_data,
  U_tree,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_E.simple_+3A_phylo">phylo</code></td>
<td>
<p>Input tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes parameters sim, Sigma and Sigma_YY_inv from  
<code>compute_mean_variance.simple</code>. It uses functions 
<code>extract_variance_covariance</code>, <code>extract_covariance_parents</code>, and
<code>extract_simulate_internal</code> to extract the needed quantities from these objects.
</p>


<h3>Value</h3>

<p>conditional_law_X (list) : list of conditional statistics :
&quot;expectation&quot; : matrix of size p x (ntaxa+Nnode), with ntaxa
first columns set to Y_data (tips), and from ntaxa+1 to conditional expectation
of the nodes conditioned to the tips E[Z_j|Y]
&quot;variances&quot; : array of size p x p x (ntaxa+Nnode) with ntaxa first 
matrices of zeros (tips) and conditional variance of the nodes conditioned to the tips 
Var[Z_j|Y]
&quot;covariances&quot; : array of size p x p x (ntaxa+Nnode) with ntaxa first 
matrices of zeros (tips) and conditional covariance of the nodes and their parents
conditioned to the tips Cov[Z_j,Z_pa(j)|Y], with NA for the root.
&quot;optimal.values&quot; : matrix of size p x ntaxa+Nnode of optimal
values beta(t_j)
</p>

<hr>
<h2 id='compute_expectations.BM'>Compute the expected states of a BM</h2><span id='topic+compute_expectations.BM'></span>

<h3>Description</h3>

<p><code>compute_expectations.BM</code> use the matrix formulation to compute the 
expected values at all the nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_expectations.BM(phylo, root.state, shifts, U_tree = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_expectations.BM_+3A_phylo">phylo</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="compute_expectations.BM_+3A_root.state">root.state</code></td>
<td>
<p>(list): state of the root, with:
random : random state (TRUE) or deterministic state (FALSE)
value.root : if deterministic, value of the character at the root
exp.root : if random, expectation of the character at the root
var.root : if random, variance of the character at the root (pxp matrix)</p>
</td></tr>
<tr><td><code id="compute_expectations.BM_+3A_shifts">shifts</code></td>
<td>
<p>(list) position and values of the shifts :
edges : vector of the K id of edges where the shifts are
values : matrix p x K of values of the shifts on the edges (one column = one shift)
relativeTimes : vector of dimension K of relative time of the shift from the
parent node of edges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>paramSimu: array p x Nnode x 2 (BM). For each trait t, 1 &lt;= t &lt;= p,
paramSimu[t, , ] has two columns, both containing the expected values for
all the nodes.
</p>

<hr>
<h2 id='compute_expectations.scOU'>Compute the expected states of a scOU</h2><span id='topic+compute_expectations.scOU'></span>

<h3>Description</h3>

<p><code>compute_expectations.scOU</code> use the matrix formulation to compute the 
expected values at all the nodes. Assumes a stationary root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_expectations.scOU(
  phylo,
  root.state,
  shifts,
  alpha,
  U_tree = NULL,
  times_shared = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_expectations.scOU_+3A_phylo">phylo</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="compute_expectations.scOU_+3A_root.state">root.state</code></td>
<td>
<p>(list): state of the root, with:
random : random state (TRUE) or deterministic state (FALSE)
value.root : if deterministic, value of the character at the root
exp.root : if random, expectation of the character at the root
var.root : if random, variance of the character at the root (pxp matrix)</p>
</td></tr>
<tr><td><code id="compute_expectations.scOU_+3A_shifts">shifts</code></td>
<td>
<p>(list) position and values of the shifts :
edges : vector of the K id of edges where the shifts are
values : matrix p x K of values of the shifts on the edges (one column = one shift)
relativeTimes : vector of dimension K of relative time of the shift from the
parent node of edges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>paramSimu: array p x Nnode x 2 (BM). For each trait t, 1 &lt;= t &lt;= p,
paramSimu[t, , ] has two columns, both containing the expected values for
all the nodes.
</p>

<hr>
<h2 id='compute_fixed_moments'>Compute fixed moments for E step.</h2><span id='topic+compute_fixed_moments'></span>

<h3>Description</h3>

<p><code>compute_fixed_moments</code> compute the fixed matrices used in E step when
there is no missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_fixed_moments(times_shared, ntaxa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_fixed_moments_+3A_times_shared">times_shared</code></td>
<td>
<p>matrix of the tree, result of function
<code>compute_times_ca</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>F_means the matrix to use for actualization of means.
</p>
<p>F_vars the matrix to use for the actualization of variances.
</p>

<hr>
<h2 id='compute_gauss_lasso'>Do a lm on top of a lasso regression.</h2><span id='topic+compute_gauss_lasso'></span>

<h3>Description</h3>

<p><code>compute_gauss_lasso</code> takes the variables selected by a lasso procedure, and
uses them to do a simple linear least square regression. Function used is
<code>lm</code> for non-transformed data (root = NULL), and <code>lm.fit</code> for
transformed data (root = an integer).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_gauss_lasso(
  Ypt,
  Xp,
  delta,
  root,
  projection = which(rowSums(delta) != 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_gauss_lasso_+3A_ypt">Ypt</code></td>
<td>
<p>(transformed) data</p>
</td></tr>
<tr><td><code id="compute_gauss_lasso_+3A_xp">Xp</code></td>
<td>
<p>(transformed) matrix of regression</p>
</td></tr>
<tr><td><code id="compute_gauss_lasso_+3A_delta">delta</code></td>
<td>
<p>regression coefficients obtained with a lasso regression</p>
</td></tr>
<tr><td><code id="compute_gauss_lasso_+3A_root">root</code></td>
<td>
<p>the position of the root (intercept) in delta</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the value of root, the behavior is different. If root is null, then
we fit a linear regression with an intercept. If root is equal to an integer,
then the &quot;intercept&quot; column of the matrix Xp (that has possibly been trough a 
multiplication with a Cholesky decomposition of the variance) is included, rather
than the intercept.
</p>


<h3>Value</h3>

<p>Named list, with &quot;E0.gauss&quot; the intercept (value at the root);
&quot;shifts.gauss&quot; the list of shifts found on the branches; and &quot;residuals&quot; the
residuals of the regression
</p>

<hr>
<h2 id='compute_log_likelihood.simple'>Log Likelihood</h2><span id='topic+compute_log_likelihood.simple'></span>

<h3>Description</h3>

<p><code>compute_log_likelihood.simple</code> computes the log-likelihood of the data 
in the simple case where the inverse of the variance matrix is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_log_likelihood.simple(
  phylo,
  Y_data_vec,
  sim,
  Sigma,
  Sigma_YY_chol_inv,
  miss = rep(FALSE, dim(sim)[1] * length(phylo$tip.label)),
  masque_data = c(rep(TRUE, dim(sim)[1] * length(phylo$tip.label)), rep(FALSE,
    dim(sim)[1] * phylo$Nnode)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_log_likelihood.simple_+3A_phylo">phylo</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="compute_log_likelihood.simple_+3A_sigma">Sigma</code></td>
<td>
<p>: variance-covariance matrix, result of function <code>compute_variance_covariance</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes parameters sim, Sigma and Sigma_YY_inv from  
<code>compute_mean_variance.simple</code>. It uses functions 
<code>extract_variance_covariance</code>, <code>extract_covariance_parents</code>, and
<code>extract_simulate_internal</code> to extract the needed quantities from these objects.
</p>


<h3>Value</h3>

<p>log likelihood of the data
</p>

<hr>
<h2 id='compute_mahalanobis_distance.simple'>Squared Mahalanobis Distance</h2><span id='topic+compute_mahalanobis_distance.simple'></span>

<h3>Description</h3>

<p><code>compute_mahalanobis_distance.simple</code> computes the squared Mahalanobis distance 
between the data and mean at tips  of the data in the simple case where the inverse
of the variance matrix is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_mahalanobis_distance.simple(
  phylo,
  Y_data_vec,
  sim,
  Sigma_YY_chol_inv,
  miss = rep(FALSE, dim(sim)[1] * length(phylo$tip.label)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_mahalanobis_distance.simple_+3A_phylo">phylo</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="compute_mahalanobis_distance.simple_+3A_y_data_vec">Y_data_vec</code></td>
<td>
<p>: vector indicating the data at the tips.</p>
</td></tr>
<tr><td><code id="compute_mahalanobis_distance.simple_+3A_sim">sim</code></td>
<td>
<p>(list) : result of function <code>simulate</code>.</p>
</td></tr>
<tr><td><code id="compute_mahalanobis_distance.simple_+3A_sigma_yy_chol_inv">Sigma_YY_chol_inv</code></td>
<td>
<p>: invert of the cholesky variance-covariance matrix of the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes parameters sim and Sigma_YY_inv from  
<code>compute_mean_variance.simple</code>. It uses function <code>extract_simulate_internal</code>
to extract the needed quantities from these objects.
</p>


<h3>Value</h3>

<p>squared Mahalanobis distance between data and mean at the tips.
</p>

<hr>
<h2 id='compute_mean_variance.simple'>Compute moments of params_old</h2><span id='topic+compute_mean_variance.simple'></span>

<h3>Description</h3>

<p><code>compute_mean_variance.simple</code> computes the quantities needed to compute
mean and variance matrix with parameters params_old.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_mean_variance.simple(
  phylo,
  times_shared,
  distances_phylo,
  process = c("BM", "OU", "rBM", "scOU"),
  params_old,
  masque_data = c(rep(TRUE, attr(params_old, "p_dim") * length(phylo$tip.label)),
    rep(FALSE, attr(params_old, "p_dim") * phylo$Nnode)),
  sim = NULL,
  U_tree = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_mean_variance.simple_+3A_phylo">phylo</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="compute_mean_variance.simple_+3A_times_shared">times_shared</code></td>
<td>
<p>(matrix) : times of shared ancestry, result of function 
<code>compute_times_ca</code></p>
</td></tr>
<tr><td><code id="compute_mean_variance.simple_+3A_distances_phylo">distances_phylo</code></td>
<td>
<p>(matrix) : phylogenetic distance, result of function 
<code>compute_dist_phy</code></p>
</td></tr>
<tr><td><code id="compute_mean_variance.simple_+3A_process">process</code></td>
<td>
<p>a two letter string indicating the process to consider</p>
</td></tr>
<tr><td><code id="compute_mean_variance.simple_+3A_params_old">params_old</code></td>
<td>
<p>a list of parameters to be used in the computations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by functions <code>compute_E.simple</code> and 
<code>compute_log_likelihood.simple</code>.
</p>


<h3>Value</h3>

<p>sim (list) : result of function <code>simulate</code> with the appropriate
parameters
</p>
<p>Sigma matrix of variance covariance, result of function 
<code>compute_variance_covariance</code>
</p>
<p>Sigma_YY_chol_inv invert of Cholesky matrix of Sigma_YY:
(Sigma_YY)^(-1) = tcrossprod(Sigma_YY_chol_inv)
</p>

<hr>
<h2 id='compute_residuals.simple'>Residuals</h2><span id='topic+compute_residuals.simple'></span>

<h3>Description</h3>

<p><code>compute_residuals.simple</code> computes the residuals after the fit of the
data in the simple case where the inverse of the variance matrix is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_residuals.simple(phylo, Y_data_vec, sim, Sigma_YY_chol_inv, miss)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_residuals.simple_+3A_phylo">phylo</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="compute_residuals.simple_+3A_y_data_vec">Y_data_vec</code></td>
<td>
<p>: vector indicating the data at the tips.</p>
</td></tr>
<tr><td><code id="compute_residuals.simple_+3A_sim">sim</code></td>
<td>
<p>(list) : result of function <code>simulate</code>.</p>
</td></tr>
<tr><td><code id="compute_residuals.simple_+3A_sigma_yy_chol_inv">Sigma_YY_chol_inv</code></td>
<td>
<p>: invert of the Cholesky variance-covariance matrix of the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes parameters sim and Sigma_YY_inv from  
<code>compute_mean_variance.simple</code>. It uses function <code>extract_simulate_internal</code>
to extract the needed quantities from these objects.
</p>

<hr>
<h2 id='compute_shifts_from_betas'>Computation of shifts from the vector of optimal values</h2><span id='topic+compute_shifts_from_betas'></span>

<h3>Description</h3>

<p><code>compute_shifts_from_betas</code> computes the list of shifts corresponding
to the vector of optimal values on nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_shifts_from_betas(phylo, betas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_shifts_from_betas_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="compute_shifts_from_betas_+3A_betas">betas</code></td>
<td>
<p>vector of size (ntaxa + Nnode) of the optimal values at each
node and tip.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses function fun on each row of matrix of edges.
</p>


<h3>Value</h3>

<p>vector of shifts.
</p>

<hr>
<h2 id='compute_state_filter'>List of potential daughter states when parent is in state k.</h2><span id='topic+compute_state_filter'></span>

<h3>Description</h3>

<p><code>compute_state_filter</code> compute the admissible daughters states, i.e. states that 
realize the minimum cost for the tree parent -&gt; daughter -&gt; subtree(daughter), when 
the parent node is in state k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_state_filter(cost, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_state_filter_+3A_cost">cost</code></td>
<td>
<p>a (ndaughters) x (nclus) matrix of the cost of each state for the 
daughters nodes.</p>
</td></tr>
<tr><td><code id="compute_state_filter_+3A_k">k</code></td>
<td>
<p>the parental state considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in functions <code>parsimonyNumber</code> and <code>enumerate_parsimony</code>.
</p>


<h3>Value</h3>

<p>A (ndaughters) x (nclus) binary matrix indicating the admissible
states for the daughters node when parent node is in state k.
</p>

<hr>
<h2 id='compute_stationary_variance'>Compute the stationary variance matrix</h2><span id='topic+compute_stationary_variance'></span>

<h3>Description</h3>

<p><code>compute_stationary_variance</code> computes the stationary variance matrix of
an OU process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_stationary_variance(variance, selection.strength)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_stationary_variance_+3A_variance">variance</code></td>
<td>
<p>the variance (rate matrix) of the process.</p>
</td></tr>
<tr><td><code id="compute_stationary_variance_+3A_selection.strength">selection.strength</code></td>
<td>
<p>the selection strength (alpha) matrix of the 
process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive definite Matrix of class <code><a href="Matrix.html#topic+dpoMatrix-class">dpoMatrix-class</a></code>.
</p>

<hr>
<h2 id='compute_sum_var_diff'>Compute weighted sum of var_diff</h2><span id='topic+compute_sum_var_diff'></span>

<h3>Description</h3>

<p><code>compute_sum_var_diff</code> computes sum_{e edge} ell_j * Var[X_j - X_pa(j) | Y]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_sum_var_diff(phylo, var_diff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_sum_var_diff_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree</p>
</td></tr>
<tr><td><code id="compute_sum_var_diff_+3A_var_diff">var_diff</code></td>
<td>
<p>result of function <code>compute_var_diff.BM</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix p x p
</p>

<hr>
<h2 id='compute_times_ca'>Common Ancestors Times</h2><span id='topic+compute_times_ca'></span>

<h3>Description</h3>

<p><code>compute_times_ca</code> computes the times t_ij between the root and the common
ancestor of two tips i, j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_times_ca(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_times_ca_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies on <code>ape</code> functions
<code><a href="ape.html#topic+node.depth.edgelength">node.depth.edgelength</a></code> and <code><a href="ape.html#topic+mrca">mrca</a></code>.
</p>


<h3>Value</h3>

<p>a matrix of times of shared evolution, ordered as the tips of the
tree. The matrix is of type <code><a href="Matrix.html#topic+symmetricMatrix-class">symmetricMatrix-class</a></code>.
</p>

<hr>
<h2 id='compute_tree_correlations_matrix.BM'>Matrix of tree-induced correlations for the BM</h2><span id='topic+compute_tree_correlations_matrix.BM'></span>

<h3>Description</h3>

<p><code>compute_tree_correlations_matrix.BM</code> returns times_shared its provided argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_tree_correlations_matrix.BM(times_shared, params_old, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_tree_correlations_matrix.BM_+3A_times_shared">times_shared</code></td>
<td>
<p>times of shared ancestry of all nodes and tips, result of function
<code>compute_times_ca</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>times_shared
</p>

<hr>
<h2 id='compute_tree_correlations_matrix.scOU'>Matrix of tree-induced correlations for the scOU</h2><span id='topic+compute_tree_correlations_matrix.scOU'></span>

<h3>Description</h3>

<p><code>compute_tree_correlations_matrix.scOU</code> computes the (n+m)x(m+n) matrix of correlations
induced by the tree. It takes two cases in consideration: root fixed, or root in stationary
state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_tree_correlations_matrix.scOU(
  times_shared,
  distances_phylo,
  params_old,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_tree_correlations_matrix.scOU_+3A_times_shared">times_shared</code></td>
<td>
<p>times of shared ancestry of all nodes and tips, result of function
<code>compute_times_ca</code></p>
</td></tr>
<tr><td><code id="compute_tree_correlations_matrix.scOU_+3A_distances_phylo">distances_phylo</code></td>
<td>
<p>(matrix) : phylogenetic distance, result of function 
<code>compute_dist_phy</code></p>
</td></tr>
<tr><td><code id="compute_tree_correlations_matrix.scOU_+3A_params_old">params_old</code></td>
<td>
<p>(list) : old parameters to be used in the E step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of variance covariance for the scOU
</p>

<hr>
<h2 id='compute_var_diff.BM'>Compute variances of differences between nodes and parents.</h2><span id='topic+compute_var_diff.BM'></span>

<h3>Description</h3>

<p><code>compute_var_diff</code> computes variances of differences between all the
nodes and their parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_var_diff.BM(phylo, conditional_law_X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_var_diff.BM_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree</p>
</td></tr>
<tr><td><code id="compute_var_diff.BM_+3A_conditional_law_x">conditional_law_X</code></td>
<td>
<p>result of function <code>compute_E</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>array p x p x Nedge containing, for each edge e finishing at node i,
the quantity Var[Z_i-Z_pa(i)|Y].
</p>

<hr>
<h2 id='compute_var_M.BM'>Computation of the variance.</h2><span id='topic+compute_var_M.BM'></span>

<h3>Description</h3>

<p><code>compute_var_M.BM</code> finds the variance that is the maximum of likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_var_M.BM(phylo, var_diff, diff_exp, edges_max, random.root, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_var_M.BM_+3A_phylo">phylo</code></td>
<td>
<p>Tree</p>
</td></tr>
<tr><td><code id="compute_var_M.BM_+3A_var_diff">var_diff</code></td>
<td>
<p>variances of differences result of function <code>compute_var_diff.BM</code></p>
</td></tr>
<tr><td><code id="compute_var_M.BM_+3A_diff_exp">diff_exp</code></td>
<td>
<p>differences of expectations result of function <code>compute_diff_exp.BM</code></p>
</td></tr>
<tr><td><code id="compute_var_M.BM_+3A_edges_max">edges_max</code></td>
<td>
<p>Edges where the shifts occur result of function <code>segmentation.BM</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the variances, the costs0 and the edges where the shifts occurs, the
computation of the maximum of likelihood in the variance is simple.
</p>


<h3>Value</h3>

<p>a p x p matrix : the computed variance
</p>

<hr>
<h2 id='compute_variance_block_diagonal.BM'>Tips Variances for the BM</h2><span id='topic+compute_variance_block_diagonal.BM'></span>

<h3>Description</h3>

<p><code>compute_variance_block_diagonal.BM</code> computes the n p*p variance
matrices of each tip vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_variance_block_diagonal.BM(times_shared, params_old, ntaxa, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_variance_block_diagonal.BM_+3A_times_shared">times_shared</code></td>
<td>
<p>times of shared ancestry of all nodes and tips, result 
of function <code>compute_times_ca</code></p>
</td></tr>
<tr><td><code id="compute_variance_block_diagonal.BM_+3A_params_old">params_old</code></td>
<td>
<p>(list) : old parameters to be used in the E step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p * p * ntaxa array with ntaxa variance matrices
</p>

<hr>
<h2 id='compute_variance_block_diagonal.OU'>Tips Variances for the OU</h2><span id='topic+compute_variance_block_diagonal.OU'></span>

<h3>Description</h3>

<p><code>compute_variance_block_diagonal.OU</code> computes the n p*p variance
matrices of each tip vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_variance_block_diagonal.OU(times_shared, params_old, ntaxa, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_variance_block_diagonal.OU_+3A_times_shared">times_shared</code></td>
<td>
<p>times of shared ancestry of all nodes and tips, result 
of function <code>compute_times_ca</code></p>
</td></tr>
<tr><td><code id="compute_variance_block_diagonal.OU_+3A_params_old">params_old</code></td>
<td>
<p>(list) : old parameters to be used in the E step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p * p * ntaxa array with ntaxa variance matrices
</p>

<hr>
<h2 id='compute_variance_covariance.BM'>Complete variance covariance matrix for BM</h2><span id='topic+compute_variance_covariance.BM'></span>

<h3>Description</h3>

<p><code>compute_variance_covariance.BM</code> computes the (n+m)*p squared variance covariance
matrix of vec(X).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_variance_covariance.BM(times_shared, params_old, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_variance_covariance.BM_+3A_times_shared">times_shared</code></td>
<td>
<p>times of shared ancestry of all nodes and tips, result of function
<code>compute_times_ca</code></p>
</td></tr>
<tr><td><code id="compute_variance_covariance.BM_+3A_params_old">params_old</code></td>
<td>
<p>(list) : old parameters to be used in the E step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of variance covariance for the BM
</p>

<hr>
<h2 id='compute_variance_covariance.OU'>Complete variance covariance matrix for OU</h2><span id='topic+compute_variance_covariance.OU'></span>

<h3>Description</h3>

<p><code>compute_variance_covariance.OU</code> computes the (n+m)*p squared variance
covariance matrix of vec(X).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_variance_covariance.OU(times_shared, distances_phylo, params_old, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_variance_covariance.OU_+3A_times_shared">times_shared</code></td>
<td>
<p>times of shared ancestry of all nodes and tips, result 
of function <code>compute_times_ca</code></p>
</td></tr>
<tr><td><code id="compute_variance_covariance.OU_+3A_params_old">params_old</code></td>
<td>
<p>(list) : old parameters to be used in the E step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of variance covariance for the OU
</p>

<hr>
<h2 id='compute_variance_covariance.OU.nonsym'>Complete variance covariance matrix for OU</h2><span id='topic+compute_variance_covariance.OU.nonsym'></span>

<h3>Description</h3>

<p><code>compute_variance_covariance.OU</code> computes the (n+m)*p squared variance
covariance matrix of vec(X).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_variance_covariance.OU.nonsym(
  times_shared,
  distances_phylo,
  params_old,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_variance_covariance.OU.nonsym_+3A_times_shared">times_shared</code></td>
<td>
<p>times of shared ancestry of all nodes and tips, result 
of function <code>compute_times_ca</code></p>
</td></tr>
<tr><td><code id="compute_variance_covariance.OU.nonsym_+3A_params_old">params_old</code></td>
<td>
<p>(list) : old parameters to be used in the E step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of variance covariance for the OU
</p>

<hr>
<h2 id='compute_variance_covariance.scOU'>Complete variance covariance matrix for scOU</h2><span id='topic+compute_variance_covariance.scOU'></span>

<h3>Description</h3>

<p><code>compute_variance_covariance.scOU</code> computes the (n+m)*p squared variance covariance
matrix of vec(X).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_variance_covariance.scOU(
  times_shared,
  distances_phylo,
  params_old,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_variance_covariance.scOU_+3A_times_shared">times_shared</code></td>
<td>
<p>times of shared ancestry of all nodes and tips, result of function
<code>compute_times_ca</code></p>
</td></tr>
<tr><td><code id="compute_variance_covariance.scOU_+3A_distances_phylo">distances_phylo</code></td>
<td>
<p>(matrix) : phylogenetic distance, result of function 
<code>compute_dist_phy</code></p>
</td></tr>
<tr><td><code id="compute_variance_covariance.scOU_+3A_params_old">params_old</code></td>
<td>
<p>(list) : old parameters to be used in the E step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of variance covariance for the scOU
</p>

<hr>
<h2 id='correspondenceEdges'>Correspondence between edges numbers</h2><span id='topic+correspondenceEdges'></span>

<h3>Description</h3>

<p><code>correspondenceEdges</code> takes edges numbers on an input tree, and gives back
their corresponding numbers on the output tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correspondenceEdges(edges, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correspondenceEdges_+3A_edges">edges</code></td>
<td>
<p>vector of index of edges in the tree &quot;from&quot;</p>
</td></tr>
<tr><td><code id="correspondenceEdges_+3A_from">from</code></td>
<td>
<p>initial input tree (format &quot;<code>phylo</code>&quot;)</p>
</td></tr>
<tr><td><code id="correspondenceEdges_+3A_to">to</code></td>
<td>
<p>aimed output tree (format &quot;<code>phylo</code>&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of index of edges in the tree &quot;to&quot;
</p>

<hr>
<h2 id='enlight'>Make the result lighter</h2><span id='topic+enlight'></span><span id='topic+enlight.PhyloEM'></span>

<h3>Description</h3>

<p><code>enlight.PhyloEM</code> takes an object of class <code><a href="#topic+PhyloEM">PhyloEM</a></code>,
and returns the same object, without saving the quantities that can be easily
re-computed using function <code><a href="#topic+imputed_traits.PhyloEM">imputed_traits.PhyloEM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enlight(x)

## S3 method for class 'PhyloEM'
enlight(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enlight_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+PhyloEM">PhyloEM</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting object can be much lighter, saving a lot of memory space, but each
call to the function <code><a href="#topic+imputed_traits.PhyloEM">imputed_traits.PhyloEM</a></code> will be longer. As 
function <code><a href="#topic+plot.PhyloEM">plot.PhyloEM</a></code> relies on this function, this makes the 
plotting also longer.
This has the same effect as setting the option &quot;<code>light_result=TRUE</code>&quot; in the
call of <code><a href="#topic+PhyloEM">PhyloEM</a></code>.
</p>


<h3>Value</h3>

<p>Same as entry, lighter.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>enlight(PhyloEM)</code>: <code><a href="#topic+PhyloEM">PhyloEM</a></code> object
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+PhyloEM">PhyloEM</a></code>, <code><a href="#topic+imputed_traits.PhyloEM">imputed_traits.PhyloEM</a></code>,
<code><a href="#topic+plot.PhyloEM">plot.PhyloEM</a></code>
</p>

<hr>
<h2 id='enumerate_parsimony'>Enumerate all the possible regime allocations, given a clustering 
of the tips.</h2><span id='topic+enumerate_parsimony'></span>

<h3>Description</h3>

<p><code>enumerate_parsimony</code> enumerate all the equivalent allocation of the 
regimes in the tree, a clustering of the tips being given. The number of such
equivalent regimes is given by <code><a href="#topic+parsimonyNumber">parsimonyNumber</a></code> (which is faster).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enumerate_parsimony(phylo, clusters = rep(1, length(phylo$tip.label)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enumerate_parsimony_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="enumerate_parsimony_+3A_clusters">clusters</code></td>
<td>
<p>a vector representing the group of each tip. (Default to only one
group with all the tips.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="#topic+extract.enumerate_parsimony">extract.enumerate_parsimony</a></code> furnishes the result in a
human readable form (for any subtree).
Function <code><a href="#topic+plot.enumerate_parsimony">plot.enumerate_parsimony</a></code> plots all the solutions found on
the tree.
</p>


<h3>Value</h3>

<p>an S3 object of class &quot;<code>enumerate_parsimony</code>&quot;, with:
</p>

<dl>
<dt>nbrReconstructions</dt><dd><p>an object of class &quot;<code>parsimonyCost</code>&quot;, result
of function <code><a href="#topic+parsimonyCost">parsimonyCost</a></code>.</p>
</dd>
<dt>allocations</dt><dd><p>a list of size Nnode + ntaxa. Each entry i of the list
represents the solutions for the subtree starting at node i. It is a list with
nclus entries, each entry being a matrix. A line of the kth matrix for the
ith node is one possible allocation of the shifts, starting with regime k
for node i.</p>
</dd>
<dt>phylo</dt><dd><p>the entry phylogenetic tree</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+extract.enumerate_parsimony">extract.enumerate_parsimony</a></code>,
<code><a href="#topic+plot.enumerate_parsimony">plot.enumerate_parsimony</a></code>, <code><a href="#topic+parsimonyCost">parsimonyCost</a></code>,
<code><a href="#topic+parsimonyNumber">parsimonyNumber</a></code>, <code><a href="#topic+partitionsNumber">partitionsNumber</a></code>,
<code><a href="#topic+equivalent_shifts">equivalent_shifts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- read.tree(text="(((A,B),C),D);")
plot(tree)
clusters &lt;- c(0, 1, 2, 2)
sols &lt;- enumerate_parsimony(tree, clusters)
plot(sols)

## Extract the parsimonious solutions from the root
extract(sols) # each line is a solution, with states of each node

## Extract the number of solutions from the root
extract(sols, what = "number")
extract(parsimonyNumber(tree, clusters)) # same result, more efficient

## Extract the cost of the solutions from the root
extract(sols, what = "cost")
extract(parsimonyCost(tree, clusters)) # same result, more efficient:

## Extract for the sub-tree below node 7
extract(sols, 7) # NAs: non-existing nodes in the sub-tree

</code></pre>

<hr>
<h2 id='enumerate_tips_under_edges'>Tips descendants of nodes.</h2><span id='topic+enumerate_tips_under_edges'></span>

<h3>Description</h3>

<p><code>enumerate_tips_under_edges</code> gives, for each edge of the tree, the labels
of the tips that have this edge as an ancestor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enumerate_tips_under_edges(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enumerate_tips_under_edges_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses function <code><a href="ape.html#topic+prop.part">prop.part</a></code> from package <code>ape</code>.
</p>


<h3>Value</h3>

<p>list of size Nedge, entry i is the vector of tips bellow edge i.
</p>

<hr>
<h2 id='equivalent_shifts'>Find all equivalent shifts allocations and values.</h2><span id='topic+equivalent_shifts'></span>

<h3>Description</h3>

<p><code>equivalent_shifts</code> computes the equivalent shifts positions and their
corresponding values, assuming an ultrametric tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalent_shifts(
  phylo,
  params,
  T_tree = incidence.matrix(phylo),
  part.list = enumerate_tips_under_edges(phylo),
  times_shared = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalent_shifts_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="equivalent_shifts_+3A_params">params</code></td>
<td>
<p>an object of class <code>params_process</code>, result inference by
function <code><a href="#topic+PhyloEM">PhyloEM</a></code>, or constructed through function
<code><a href="#topic+params_process">params_process</a></code></p>
</td></tr>
<tr><td><code id="equivalent_shifts_+3A_t_tree">T_tree</code></td>
<td>
<p>(optional) matrix of incidence of the tree, result of function 
<code><a href="#topic+incidence.matrix">incidence.matrix</a></code></p>
</td></tr>
<tr><td><code id="equivalent_shifts_+3A_part.list">part.list</code></td>
<td>
<p>(optional) list of partition of the tree, result of function
<code><a href="#topic+enumerate_tips_under_edges">enumerate_tips_under_edges</a></code>.</p>
</td></tr>
<tr><td><code id="equivalent_shifts_+3A_times_shared">times_shared</code></td>
<td>
<p>(optional) a matrix, result of function
<code><a href="#topic+compute_times_ca">compute_times_ca</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only valid for ultrametric trees, and for models: BM, OU with
fixed root or stationary root. It assumes that there are no homoplasies.
</p>


<h3>Value</h3>

<p>object of class <code>equivalent_shifts</code>, with entries:
</p>

<dl>
<dt>eq_shifts_edges</dt><dd><p>matrix of equivalent shifts</p>
</dd>
<dt>shifts_and_betas</dt><dd><p>matrix of corresponding shifts values</p>
</dd>
<dt>phylo</dt><dd><p>the entry phylogenetic tree</p>
</dd>
<dt>p</dt><dd><p>the dimension</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+plot.equivalent_shifts">plot.equivalent_shifts</a></code>,
<code><a href="#topic+extract.equivalent_shifts">extract.equivalent_shifts</a></code>, <code><a href="#topic+params_BM">params_BM</a></code>, 
<code><a href="#topic+params_OU">params_OU</a></code>, <code><a href="#topic+enumerate_parsimony">enumerate_parsimony</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("TreeSim", quietly = TRUE)) {
  ## Simualte a tree
  set.seed(17920902)
  ntaxa = 20
  phylo &lt;- TreeSim::sim.bd.taxa.age(n = ntaxa, numbsim = 1, lambda = 0.1,
                                   mu = 0, age = 1, mrca = TRUE)[[1]]
  
  ## Define parameters (BM, fixed root)
  params &lt;- params_BM(p = 4, edges = c(6, 17, 31),
                     values = cbind(1:4, -(1:4), rep(1, 4)))
  ## Find equivalent solutions and plot them
  eq_shifts &lt;- equivalent_shifts(phylo, params)
  eq_shifts
  plot(eq_shifts)
  ## Extract the values
  # Shifts values for trait 2, for the three shifts (rows), and three solutions (columns)
  extract(eq_shifts, trait = 2, what = "shifts_values")
  # Root values for trait 4, for the tree solutions (columns)
  extract(eq_shifts, trait = 4, what = "root_values")
  ## Define parameters (OU, stationary root
  params &lt;- params_OU(p = 4, edges = c(6, 17, 31),
                     selection.strength = 0.1,
                     values = cbind(1:4, -(1:4), rep(1, 4)),
                     random = TRUE)
  ## Find equivalent solutions and plot them
  eq_shifts &lt;- equivalent_shifts(phylo, params)
  eq_shifts
  plot(eq_shifts)
  ## Extract the values
  # Shifts values for trait 2, for the three shifts (rows), and three solutions (columns)
  extract(eq_shifts, trait = 2, what = "shifts_values")
  # Root values for trait 4, for the three solutions (columns)
  extract(eq_shifts, trait = 4, what = "root_values")
}

</code></pre>

<hr>
<h2 id='equivalent_shifts_edges'>Find all the equivalent shift edges allocations.</h2><span id='topic+equivalent_shifts_edges'></span>

<h3>Description</h3>

<p><code>equivalent_shifts_edges</code> uses function <code><a href="#topic+enumerate_parsimony">enumerate_parsimony</a></code>
to find all the shifts positions that are equivalent to a given one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalent_shifts_edges(
  phylo,
  shifts_edges,
  part.list = enumerate_tips_under_edges(phylo)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalent_shifts_edges_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="equivalent_shifts_edges_+3A_shifts_edges">shifts_edges</code></td>
<td>
<p>a vector of shifts positions on the edges of the tree.</p>
</td></tr>
<tr><td><code id="equivalent_shifts_edges_+3A_part.list">part.list</code></td>
<td>
<p>(optional) list of partition of the tree, result of function
<code><a href="#topic+enumerate_tips_under_edges">enumerate_tips_under_edges</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is uses functions <code><a href="#topic+enumerate_parsimony">enumerate_parsimony</a></code> for the
actual computation of equivalent regimes,
<code><a href="#topic+clusters_from_shifts">clusters_from_shifts</a></code> for the clustering of the tips induced
by the original set of shifts given, and
<code><a href="#topic+allocate_shifts_from_regimes">allocate_shifts_from_regimes</a></code> to convert back a parametrization
in term of regimes to a parametrization in term of shifts.
</p>


<h3>Value</h3>

<p>a matrix with as many columns as equivalent allocation, each column
representing a possible parsimonious allocation of shifts on the tree.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+equivalent_shifts">equivalent_shifts</a></code>, <code><a href="#topic+enumerate_parsimony">enumerate_parsimony</a></code>
</p>

<hr>
<h2 id='equivalent_shifts_values'>Find values given edges. OU stationary case. Ultrametric tree.</h2><span id='topic+equivalent_shifts_values'></span>

<h3>Description</h3>

<p><code>equivalent_shifts_values</code> computes the values of the shifts given all
the possible allocations computed by function
<code><a href="#topic+equivalent_shifts_edges">equivalent_shifts_edges</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalent_shifts_values(phylo, eq_shifts_edges, T_tree_ac, vect_Y, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalent_shifts_values_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="equivalent_shifts_values_+3A_eq_shifts_edges">eq_shifts_edges</code></td>
<td>
<p>matrix (optional) result of function
<code><a href="#topic+equivalent_shifts_edges">equivalent_shifts_edges</a></code>.</p>
</td></tr>
<tr><td><code id="equivalent_shifts_values_+3A_t_tree_ac">T_tree_ac</code></td>
<td>
<p>matrix of incidence of the tree, result of function 
<code><a href="#topic+incidence.matrix">incidence.matrix</a></code>, actualized with coefficients computed by
function <code><a href="#topic+incidence_matrix_actualization_factors">incidence_matrix_actualization_factors</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the linear representation of the problem. It fist compute
the mean at the tips given by the original shifts positions and values, and
then uses function <code><a href="base.html#topic+qr.solve">qr.solve</a></code>
to find back the values of the shifts, given their various positions,
and the means at the tips. Function <code>compute_actualization_factors</code> is
used to compute the actualization factor that multiplies the shifts values at
the tips. Careful, only works for ULTRAMETRIC trees.
</p>


<h3>Value</h3>

<p>Named list, with &quot;shifts_values&quot; a matrix of shifts values
corresponding to the shifts positions in eq_shifts_edges; and &quot;betas_0&quot; a
vector of corresponding root optimal values.
</p>

<hr>
<h2 id='estimate.alpha'>Function to estimate alpha</h2><span id='topic+estimate.alpha'></span>

<h3>Description</h3>

<p><code>optimize</code> to maximize the
conditional expectation log likelihood in alpha. The interval is
set to [alpha_old/2, 2*alpha_old], supposing that the previous guess of 
alpha_old is not far from reality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.alpha(
  phylo,
  conditional_law_X,
  sigma2,
  mu,
  shifts,
  alpha_old,
  max_selection.strength
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.alpha_+3A_phylo">phylo</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="estimate.alpha_+3A_conditional_law_x">conditional_law_X</code></td>
<td>
<p>result of function <code>compute_E.OU</code></p>
</td></tr>
<tr><td><code id="estimate.alpha_+3A_sigma2">sigma2</code></td>
<td>
<p>variance of params</p>
</td></tr>
<tr><td><code id="estimate.alpha_+3A_mu">mu</code></td>
<td>
<p>mean of the root state</p>
</td></tr>
<tr><td><code id="estimate.alpha_+3A_shifts">shifts</code></td>
<td>
<p>list of shifts on the tree</p>
</td></tr>
<tr><td><code id="estimate.alpha_+3A_alpha_old">alpha_old</code></td>
<td>
<p>previous estimation of the selection strength</p>
</td></tr>
<tr><td><code id="estimate.alpha_+3A_max_selection.strength">max_selection.strength</code></td>
<td>
<p>the maximal value of alpha authorized by
the user</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses functions <code>compute_var_diff.OU</code> 
and <code>compute_diff_exp.OU</code> in the process. Careful : only works if the
root is stationary, and shifts at nodes.
</p>


<h3>Value</h3>

<p>double : estimation of alpha
</p>

<hr>
<h2 id='estimateEM'>Perform One EM</h2><span id='topic+estimateEM'></span>

<h3>Description</h3>

<p><code>EstimateEM</code> performs one EM for one given number of shifts. It is called
from function <code><a href="#topic+PhyloEM">PhyloEM</a></code>. Its use is mostly internal, and most user
should not need it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateEM(
  phylo,
  Y_data,
  Y_data_imp = Y_data,
  process = c("BM", "OU", "scOU", "rBM"),
  independent = FALSE,
  tol_EM = list(variance = 10^(-2), value.root = 10^(-2), exp.root = 10^(-2), var.root =
    10^(-2), selection.strength = 10^(-2), normalized_half_life = 10^(-2), log_likelihood
    = 10^(-2)),
  Nbr_It_Max = 500,
  method.variance = c("simple", "upward_downward"),
  method.init = c("default", "lasso"),
  method.init.alpha = c("default", "estimation"),
  method.init.alpha.estimation = c("regression", "regression.MM", "median"),
  nbr_of_shifts = 0,
  random.root = TRUE,
  stationary.root = TRUE,
  alpha_known = FALSE,
  eps = 10^(-3),
  known.selection.strength = 1,
  init.selection.strength = 1,
  max_selection.strength = 100,
  use_sigma_for_lasso = TRUE,
  max_triplet_number = 10000,
  min_params = list(variance = 0, value.root = -10^(5), exp.root = -10^(5), var.root = 0,
    selection.strength = 0),
  max_params = list(variance = 10^(5), value.root = 10^(5), exp.root = 10^(5), var.root =
    10^(5), selection.strength = 10^(5)),
  var.init.root = diag(1, nrow(Y_data)),
  variance.init = diag(1, nrow(Y_data), nrow(Y_data)),
  methods.segmentation = c("lasso", "same_shifts", "best_single_move"),
  check.tips.names = FALSE,
  times_shared = NULL,
  distances_phylo = NULL,
  subtree.list = NULL,
  T_tree = NULL,
  U_tree = NULL,
  h_tree = NULL,
  F_moments = NULL,
  tol_half_life = TRUE,
  warning_several_solutions = TRUE,
  convergence_mode = c("relative", "absolute"),
  check_convergence_likelihood = TRUE,
  sBM_variance = FALSE,
  method.OUsun = c("rescale", "raw"),
  K_lag_init = 0,
  allow_negative = FALSE,
  trait_correlation_threshold = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateEM_+3A_phylo">phylo</code></td>
<td>
<p>A phylogenetic tree of class <code>phylo</code> 
(from package <code><a href="ape.html#topic+ape">ape</a></code>).</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_y_data">Y_data</code></td>
<td>
<p>Matrix of data at the tips, size p x ntaxa. Each line is a
trait, and each column is a tip. The column names are checked against the
tip names of the tree.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_y_data_imp">Y_data_imp</code></td>
<td>
<p>(optional) imputed data if previously computed, same format as
<code>Y_data</code>. Mostly here for internal calls.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_process">process</code></td>
<td>
<p>The model used for the fit. One of &quot;BM&quot; (for a full BM model, 
univariate or multivariate); &quot;OU&quot; (for an OU with independent traits, 
univariate or multivariate); or &quot;scOU&quot; (for a &quot;scalar OU&quot; model, see details).</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_independent">independent</code></td>
<td>
<p>Are the trait assumed to be independent from one another?
Default to FALSE. OU in a multivariate setting only works if TRUE.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_tol_em">tol_EM</code></td>
<td>
<p>the tolerance for the convergence of the parameters. A named list, with
items:
</p>

<dl>
<dt>variance</dt><dd><p>default to 10^(-2)</p>
</dd>
<dt>value.root</dt><dd><p>default to 10^(-2)</p>
</dd>
<dt>exp.root</dt><dd><p>default to 10^(-2)</p>
</dd>
<dt>var.root</dt><dd><p>default to 10^(-2)</p>
</dd>
<dt>selection.strength</dt><dd><p>default to 10^(-2)</p>
</dd>
<dt>normalized_half_life</dt><dd><p>default to 10^(-2)</p>
</dd>
<dt>log_likelihood</dt><dd><p>default to 10^(-2)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="estimateEM_+3A_nbr_it_max">Nbr_It_Max</code></td>
<td>
<p>the maximal number of iterations of the EM allowed. Default to
500 iterations.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_method.variance">method.variance</code></td>
<td>
<p>Algorithm to be used for the moments computations at the
E step. One of &quot;simple&quot; for the naive method; of &quot;upward_downward&quot; for the 
Upward Downward method (usually faster). Default to &quot;upward_downward&quot;.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_method.init">method.init</code></td>
<td>
<p>The initialization method. One of &quot;lasso&quot; for the LASSO
base initialization method; or &quot;default&quot; for user-specified initialization
values. Default to &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_method.init.alpha">method.init.alpha</code></td>
<td>
<p>For OU model, initialization method for the selection
strength alpha. One of &quot;estimation&quot; for a cherry-based initialization, using
<code><a href="robustbase.html#topic+nlrob">nlrob</a></code>; or &quot;default&quot; for user-specified 
initialization values. Default to &quot;estimation&quot;.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_method.init.alpha.estimation">method.init.alpha.estimation</code></td>
<td>
<p>If method.init.alpha=&quot;estimation&quot;,
choice of the estimation(s) methods to be used. Choices among &quot;regression&quot;,
(method=&quot;M&quot; is passed to <code><a href="robustbase.html#topic+nlrob">nlrob</a></code>); &quot;regression.MM&quot;
(method=&quot;MM&quot; is passed to <code><a href="robustbase.html#topic+nlrob">nlrob</a></code>) or &quot;median&quot;
(<code><a href="robustbase.html#topic+nlrob">nlrob</a></code> is not used, a simple median is taken).
Default to all of them.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_nbr_of_shifts">nbr_of_shifts</code></td>
<td>
<p>the number of shifts allowed.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_random.root">random.root</code></td>
<td>
<p>whether the root is assumed to be random (TRUE) of fixed
(FALSE). Default to TRUE</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_stationary.root">stationary.root</code></td>
<td>
<p>whether the root is assumed to be in the stationary 
state. Default to TRUE.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_alpha_known">alpha_known</code></td>
<td>
<p>is the selection strength assumed to be known ?
Default to FALSE.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_eps">eps</code></td>
<td>
<p>tolerance on the selection strength value before switching to a BM.
Default to 10^(-3).</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_known.selection.strength">known.selection.strength</code></td>
<td>
<p>if <code>alpha_known=TRUE</code>, the value of the
known selection strength.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_init.selection.strength">init.selection.strength</code></td>
<td>
<p>(optional) a starting point for the selection
strength value.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_max_selection.strength">max_selection.strength</code></td>
<td>
<p>the maximal value allowed of the selection strength.
Default to 100.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_use_sigma_for_lasso">use_sigma_for_lasso</code></td>
<td>
<p>whether to use the first estimation of the variance
matrix in the lasso regression. Default to TRUE.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_max_triplet_number">max_triplet_number</code></td>
<td>
<p>for the initialization of the selection strength value
(when estimated), the maximal number of triplets of tips to be considered.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_min_params">min_params</code></td>
<td>
<p>a named list containing the minimum allowed values for the
parameters. If the estimation is smaller, then the EM stops, and is considered to
be divergent. Default values:
</p>

<dl>
<dt>variance</dt><dd><p>default to 0</p>
</dd>
<dt>value.root</dt><dd><p>default to -10^(5)</p>
</dd>
<dt>exp.root</dt><dd><p>default to -10^(5)</p>
</dd>
<dt>var.root</dt><dd><p>default to 0</p>
</dd>
<dt>selection.strength</dt><dd><p>default to 0</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="estimateEM_+3A_max_params">max_params</code></td>
<td>
<p>a named list containing the maximum allowed values for the
parameters. If the estimation is larger, then the EM stops, and is considered to
be divergent. Default values:
</p>

<dl>
<dt>variance</dt><dd><p>default to 10^(5)</p>
</dd>
<dt>value.root</dt><dd><p>default to 10^(5)</p>
</dd>
<dt>exp.root</dt><dd><p>default to 10^(5)</p>
</dd>
<dt>var.root</dt><dd><p>default to 10^(5)</p>
</dd>
<dt>selection.strength</dt><dd><p>default to 10^(5)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="estimateEM_+3A_var.init.root">var.init.root</code></td>
<td>
<p>optional initialization value for the variance of the root.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_variance.init">variance.init</code></td>
<td>
<p>optional initialization value for the variance.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_methods.segmentation">methods.segmentation</code></td>
<td>
<p>For OU, method(s) used at the M step to find new
candidate shifts positions. Choices among &quot;lasso&quot; for a LASSO-based algorithm;
and &quot;best_single_move&quot; for a one-move at a time based heuristic. Default to 
both of them. Using only &quot;lasso&quot; might speed up the function a lot.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_check.tips.names">check.tips.names</code></td>
<td>
<p>whether to check the tips names of the tree against
the column names of the data. Default to TRUE.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_times_shared">times_shared</code></td>
<td>
<p>(optional) times of shared ancestry of all nodes and tips,
result of function <code><a href="#topic+compute_times_ca">compute_times_ca</a></code></p>
</td></tr>
<tr><td><code id="estimateEM_+3A_distances_phylo">distances_phylo</code></td>
<td>
<p>(optional) phylogenetic distances, result of function 
<code><a href="#topic+compute_dist_phy">compute_dist_phy</a></code>.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_subtree.list">subtree.list</code></td>
<td>
<p>(optional) tips descendants of all the edges, result of
function <code><a href="#topic+enumerate_tips_under_edges">enumerate_tips_under_edges</a></code>.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_t_tree">T_tree</code></td>
<td>
<p>(optional) matrix of incidence of the tree, result of function 
<code><a href="#topic+incidence.matrix">incidence.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_u_tree">U_tree</code></td>
<td>
<p>(optional) full matrix of incidence of the tree, result of function
<code><a href="#topic+incidence.matrix.full">incidence.matrix.full</a></code>.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_h_tree">h_tree</code></td>
<td>
<p>(optional) total height of the tree.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_f_moments">F_moments</code></td>
<td>
<p>(optional, internal)</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_tol_half_life">tol_half_life</code></td>
<td>
<p>should the tolerance criterion be applied to the
phylogenetic half life (TRUE, default) or to the raw selection strength ?</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_warning_several_solutions">warning_several_solutions</code></td>
<td>
<p>whether to issue a warning if several equivalent
solutions are found (default to TRUE).</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_convergence_mode">convergence_mode</code></td>
<td>
<p>one of &quot;relative&quot; (the default) or &quot;absolute&quot;. Should the
tolerance be applied to the raw parameters, or to the renormalized ones ?</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_check_convergence_likelihood">check_convergence_likelihood</code></td>
<td>
<p>should the likelihood be taken into
consideration for convergence assessment ? (default to TRUE).</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_sbm_variance">sBM_variance</code></td>
<td>
<p>Is the root of the BM supposed to be random and
&quot;stationary&quot;? Used for BM equivalent computations. Default to FALSE.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_method.ousun">method.OUsun</code></td>
<td>
<p>Method to be used in univariate OU. One of &quot;rescale&quot; 
(rescale the tree to fit a BM) or &quot;raw&quot; (directly use an OU, only available for
univariate processes).</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_k_lag_init">K_lag_init</code></td>
<td>
<p>Number of extra shifts to be considered at the initialization
step. Increases the accuracy, but can make computations quite slow of taken
too high. Default to 5.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_allow_negative">allow_negative</code></td>
<td>
<p>whether to allow negative values for alpha (Early Burst).
See documentation of <code><a href="#topic+PhyloEM">PhyloEM</a></code> for more details. Default to FALSE.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_trait_correlation_threshold">trait_correlation_threshold</code></td>
<td>
<p>the trait correlation threshold to stop the analysis. Default to 0.9.</p>
</td></tr>
<tr><td><code id="estimateEM_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="#topic+estimateEM">estimateEM</a></code>, including
tolerance parameters for stopping criteria, maximal number of iterations, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See documentation of <code><a href="#topic+PhyloEM">PhyloEM</a></code> for further details.
All the parameters monitoring the EM (like <code>tol_EM</code>, <code>Nbr_It_Max</code>, etc.)
can be called from <code>PhyloEM</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>EstimateEM</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PhyloEM">PhyloEM</a></code>
</p>

<hr>
<h2 id='extract'>Extraction function</h2><span id='topic+extract'></span>

<h3>Description</h3>

<p><code>extract</code> the needed quantities out of an S3 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_x">x</code></td>
<td>
<p>an S3 object.</p>
</td></tr>
<tr><td><code id="extract_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the specific method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer giving the number of equivalent parsimonious solutions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract.parsimonyNumber">extract.parsimonyNumber</a></code>,
<code><a href="#topic+extract.parsimonyCost">extract.parsimonyCost</a></code>,
<code><a href="#topic+extract.enumerate_parsimony">extract.enumerate_parsimony</a></code>,
<code><a href="#topic+extract.partitionsNumber">extract.partitionsNumber</a></code>
</p>

<hr>
<h2 id='extract_variance_covariance'>Extract sub-matrices of variance.</h2><span id='topic+extract_variance_covariance'></span>

<h3>Description</h3>

<p><code>extract_variance_covariance</code> return the adequate sub-matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_variance_covariance(
  struct,
  what = c("YY", "YZ", "ZZ"),
  masque_data = c(rep(TRUE, attr(struct, "ntaxa") * attr(struct, "p_dim")), rep(FALSE,
    (dim(struct)[1] - attr(struct, "ntaxa")) * attr(struct, "p_dim")))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_variance_covariance_+3A_struct">struct</code></td>
<td>
<p>structural matrix of size (ntaxa+Nnode)*p, result 
of function <code>compute_variance_covariance</code></p>
</td></tr>
<tr><td><code id="extract_variance_covariance_+3A_what">what</code></td>
<td>
<p>sub-matrix to be extracted:
&quot;YY&quot; : sub-matrix of tips (p*ntaxa first lines and columns)
&quot;YZ&quot; : sub matrix tips x nodes (p*Nnode last rows and p*ntaxa first columns)
&quot;ZZ&quot; : sub matrix of nodes (p*Nnode last rows and columns)</p>
</td></tr>
<tr><td><code id="extract_variance_covariance_+3A_masque_data">masque_data</code></td>
<td>
<p>Mask of missing data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sub-matrix of variance covariance.
</p>

<hr>
<h2 id='extract.enumerate_parsimony'>Extract the result of <code>enumerate_parsimony</code> at a node.</h2><span id='topic+extract.enumerate_parsimony'></span>

<h3>Description</h3>

<p><code>extract.enumerate_parsimony</code> returns a matrix containing all the
possible regime allocations for the nodes of a given subtree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'enumerate_parsimony'
extract(
  x,
  node = attr(x$allocations, "ntaxa") + 1,
  what = c("solutions", "number", "cost"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.enumerate_parsimony_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>enumerate_parsimony</code>&quot;,
result of function <code><a href="#topic+enumerate_parsimony">enumerate_parsimony</a></code>.</p>
</td></tr>
<tr><td><code id="extract.enumerate_parsimony_+3A_node">node</code></td>
<td>
<p>the node where to retrieve the parsimony number. Default to the
root of the tree.</p>
</td></tr>
<tr><td><code id="extract.enumerate_parsimony_+3A_what">what</code></td>
<td>
<p>the quantity to retrieve. Either &quot;solutions&quot; for the full
solutions, &quot;number&quot; for the number of solutions, or &quot;cost&quot; for the minimal
cost of a solution. Default to &quot;solutions&quot;</p>
</td></tr>
<tr><td><code id="extract.enumerate_parsimony_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with ntaxa + Nnode columns, and as many rows as the number of
possible parsimonious reconstructions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+enumerate_parsimony">enumerate_parsimony</a></code>, <code><a href="#topic+plot.enumerate_parsimony">plot.enumerate_parsimony</a></code>
</p>

<hr>
<h2 id='extract.equivalent_shifts'>Extract the shifts values for one trait.</h2><span id='topic+extract.equivalent_shifts'></span>

<h3>Description</h3>

<p><code>extract.equivalent_shifts</code> takes an object of class
<code>equivalent_shifts</code>, result of function <code><a href="#topic+equivalent_shifts">equivalent_shifts</a></code>,
and returns the shifts of root values for a given trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'equivalent_shifts'
extract(x, trait = 1, what = c("shifts_values", "root_values"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.equivalent_shifts_+3A_x">x</code></td>
<td>
<p>an object of class <code>equivalent_shifts</code>, result of
function <code><a href="#topic+equivalent_shifts">equivalent_shifts</a></code></p>
</td></tr>
<tr><td><code id="extract.equivalent_shifts_+3A_trait">trait</code></td>
<td>
<p>the number of the trait to be extracted. Default to 1.</p>
</td></tr>
<tr><td><code id="extract.equivalent_shifts_+3A_what">what</code></td>
<td>
<p>one of &quot;shifts_values&quot; or &quot;root_values&quot;.</p>
</td></tr>
<tr><td><code id="extract.equivalent_shifts_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the values of the shifts (<code>what = "shifts_values"</code>) or
the root (<code>what = "root_values"</code>) for the trait for each equivalent
configuration. Each column is one configuration.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+equivalent_shifts">equivalent_shifts</a></code>, <code><a href="#topic+plot.equivalent_shifts">plot.equivalent_shifts</a></code>,
<code><a href="#topic+equivalent_shifts_edges">equivalent_shifts_edges</a></code>
</p>

<hr>
<h2 id='extract.parsimonyCost'>Extraction of the actual number of solutions.</h2><span id='topic+extract.parsimonyCost'></span>

<h3>Description</h3>

<p><code>extract.parsimonyCost</code> takes an object of class &quot;<code>parsimonyCost</code>&quot;,
result of function <code><a href="#topic+parsimonyCost">parsimonyCost</a></code>, and computes the minimum cost
at the given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parsimonyCost'
extract(x, node = attr(x, "ntaxa") + 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.parsimonyCost_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>parsimonyCost</code>&quot;, result of function
<code><a href="#topic+parsimonyCost">parsimonyCost</a></code>.</p>
</td></tr>
<tr><td><code id="extract.parsimonyCost_+3A_node">node</code></td>
<td>
<p>the root node of the subtree. By default, the root of the tree.</p>
</td></tr>
<tr><td><code id="extract.parsimonyCost_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer giving the minimum cost of the subtree.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parsimonyCost">parsimonyCost</a></code>
</p>

<hr>
<h2 id='extract.parsimonyNumber'>Extraction of the actual number of solutions.</h2><span id='topic+extract.parsimonyNumber'></span>

<h3>Description</h3>

<p><code>extract.parsimonyNumber</code> takes the two matrices computed by 
<code><a href="#topic+parsimonyNumber">parsimonyNumber</a></code>, and compute the actual number of parsimonious
solution for any subtree starting from a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parsimonyNumber'
extract(
  x,
  node = attr(x$nbrReconstructions, "ntaxa") + 1,
  what = c("number", "cost"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.parsimonyNumber_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>parsimonyNumber</code>&quot;, result of function
<code><a href="#topic+parsimonyNumber">parsimonyNumber</a></code>.</p>
</td></tr>
<tr><td><code id="extract.parsimonyNumber_+3A_node">node</code></td>
<td>
<p>the root node of the subtree. By default, the root of the tree.</p>
</td></tr>
<tr><td><code id="extract.parsimonyNumber_+3A_what">what</code></td>
<td>
<p>the quantity to retrieve. Either &quot;number&quot; for the number of
solutions, or &quot;cost&quot; for the minimal cost of a solution. Default to &quot;number&quot;.</p>
</td></tr>
<tr><td><code id="extract.parsimonyNumber_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parsimonious solutions are the one with the minimum number of shifts (that
are given by matrix costReconstructions). This function sums the number of 
solutions (given in matrix nbrReconstructions) that have the minimum number of 
shifts.
</p>


<h3>Value</h3>

<p>An integer giving the number of equivalent parsimonious solutions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parsimonyNumber">parsimonyNumber</a></code>
</p>

<hr>
<h2 id='extract.partitionsNumber'>Extract from object <code>partitionsNumber</code></h2><span id='topic+extract.partitionsNumber'></span>

<h3>Description</h3>

<p><code>extract.partitionsNumber</code> extracts the number of partitions for a 
given sub-tree, either marked or non-marked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partitionsNumber'
extract(
  x,
  node = attr(x, "ntaxa") + 1,
  npart = attr(x, "npart"),
  marked = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.partitionsNumber_+3A_x">x</code></td>
<td>
<p>an object of class <code>partitionsNumber</code>, result of function
<code><a href="#topic+partitionsNumber">partitionsNumber</a></code>.</p>
</td></tr>
<tr><td><code id="extract.partitionsNumber_+3A_node">node</code></td>
<td>
<p>the root node of the subtree where to get the result.
Default to the root of the tree.</p>
</td></tr>
<tr><td><code id="extract.partitionsNumber_+3A_npart">npart</code></td>
<td>
<p>the number of partitions (colors) allowed at the tips.
Default to the value used in the call of function
<code><a href="#topic+partitionsNumber">partitionsNumber</a></code> (the maximum).</p>
</td></tr>
<tr><td><code id="extract.partitionsNumber_+3A_marked">marked</code></td>
<td>
<p>whether to extract the marked (TRUE) or un-marked (FALSE)
partitions. The number of models is the number of un-marked partitions.
Default to FALSE.</p>
</td></tr>
<tr><td><code id="extract.partitionsNumber_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of partitions with npart colors, on the sub-tree starting
at node, marked or not.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partitionsNumber">partitionsNumber</a></code>
</p>

<hr>
<h2 id='extract.simul_process'>Extraction of simulated traits</h2><span id='topic+extract.simul_process'></span>

<h3>Description</h3>

<p><code>extract.simul_process</code> takes an object of class &quot;<code>simul_process</code>&quot;,
result of function <code><a href="#topic+simul_process">simul_process</a></code>, and extracts the traits values, 
expectations or optimal values at the tips or the internal nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simul_process'
extract(
  x,
  where = c("tips", "nodes"),
  what = c("states", "expectations", "optimal.values"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.simul_process_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>simul_process</code>&quot;, result of function
<code><a href="#topic+simul_process">simul_process</a></code>.</p>
</td></tr>
<tr><td><code id="extract.simul_process_+3A_where">where</code></td>
<td>
<p>one of &quot;tips&quot; (the default) or &quot;nodes&quot;. Where to extract the results.</p>
</td></tr>
<tr><td><code id="extract.simul_process_+3A_what">what</code></td>
<td>
<p>one of &quot;states&quot; (the default), &quot;expectation&quot;, or &quot;optimal.values&quot;.</p>
</td></tr>
<tr><td><code id="extract.simul_process_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>##
</p>


<h3>Value</h3>

<p>A matrix giving the selected quantities at the selected nodes or tips. If
the tips or nods are labeled, then the colnames of the matrix are set accordingly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simul_process">simul_process</a></code>
</p>

<hr>
<h2 id='find_grid_alpha'>Find a reasonable grid for alpha</h2><span id='topic+find_grid_alpha'></span>

<h3>Description</h3>

<p>Grid so that 
2*ln(2)*quantile(d_ij)/factor_up_alpha &lt; t_1/2 &lt; factor_down_alpha * ln(2) * h_tree,
with t_1/2 the phylogenetic half life: t_1/2 = log(2)/alpha.
Ensures that for alpha_min, it is almost a BM, and for alpha_max,
almost all the tips are decorrelated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_grid_alpha(
  phy,
  alpha = NULL,
  nbr_alpha = 10,
  factor_up_alpha = 2,
  factor_down_alpha = 3,
  quantile_low_distance = 1e-04,
  log_transform = TRUE,
  allow_negative = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_grid_alpha_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree of class &quot;<code>phylo</code>&quot;</p>
</td></tr>
<tr><td><code id="find_grid_alpha_+3A_alpha">alpha</code></td>
<td>
<p>fixed vector of alpha values if already known. Default to NULL.</p>
</td></tr>
<tr><td><code id="find_grid_alpha_+3A_nbr_alpha">nbr_alpha</code></td>
<td>
<p>the number of elements in the grid</p>
</td></tr>
<tr><td><code id="find_grid_alpha_+3A_factor_up_alpha">factor_up_alpha</code></td>
<td>
<p>factor for up scalability</p>
</td></tr>
<tr><td><code id="find_grid_alpha_+3A_factor_down_alpha">factor_down_alpha</code></td>
<td>
<p>factor for down scalability</p>
</td></tr>
<tr><td><code id="find_grid_alpha_+3A_quantile_low_distance">quantile_low_distance</code></td>
<td>
<p>quantile for min distance</p>
</td></tr>
<tr><td><code id="find_grid_alpha_+3A_log_transform">log_transform</code></td>
<td>
<p>whether to take a log scale for the spacing of alpha
values. Default to TRUE.</p>
</td></tr>
<tr><td><code id="find_grid_alpha_+3A_allow_negative">allow_negative</code></td>
<td>
<p>whether to allow negative values for alpha (Early Burst).
See documentation of <code><a href="#topic+PhyloEM">PhyloEM</a></code> for more details. Default to FALSE.</p>
</td></tr>
<tr><td><code id="find_grid_alpha_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>quantile_low_distance=0</code>, then <code>quantile(d_ij)=min(d_ij)</code>, and, for any
two tips i,j, the correlation between i and j is bounded by exp(-factor_up_alpha/2).
Those values of alpha will be used for the re-scaling of the tree, which has an 
exponential term in exp(2*alpha*h). The function makes sure that this number is
below the maximal float allowed (equals to <code>.Machine$double.xmax</code>).
</p>


<h3>Value</h3>

<p>A grid of alpha values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transform_branch_length">transform_branch_length</a></code>, <code><a href="base.html#topic+.Machine">.Machine</a></code>
</p>

<hr>
<h2 id='find_independent_regression_vectors.glmnet_multivariate'>Given a regularization path, find K selected independent variables.</h2><span id='topic+find_independent_regression_vectors.glmnet_multivariate'></span>

<h3>Description</h3>

<p><code>find_independent_regression_vectors</code> tries to find a situation where K variables
are selected, so that the selected columns of matrix Xp are independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_independent_regression_vectors.glmnet_multivariate(Xp, K, fit, root)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_independent_regression_vectors.glmnet_multivariate_+3A_xp">Xp</code></td>
<td>
<p>(transformed) matrix of regression</p>
</td></tr>
<tr><td><code id="find_independent_regression_vectors.glmnet_multivariate_+3A_k">K</code></td>
<td>
<p>number of non-zero components allowed</p>
</td></tr>
<tr><td><code id="find_independent_regression_vectors.glmnet_multivariate_+3A_root">root</code></td>
<td>
<p>integer, position of the root column (intercept) excluded from the fit. null 
if no root column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To do that, if a set of selected is not independent, we go back to the previous selected 
variables, and forbid the moves that led to non-independence for the rest of the path.
</p>


<h3>Value</h3>

<p>delta a vector of regression with K non-zero coefficients.
</p>

<hr>
<h2 id='find_rotation'>Test for rotation invariant datasets</h2><span id='topic+find_rotation'></span>

<h3>Description</h3>

<p><code>find_rotation</code> takes two fits from from <code><a href="#topic+PhyloEM">PhyloEM</a></code>,
and test if their datasets are equal up to a rotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_rotation(res1, res2, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_rotation_+3A_res1">res1</code></td>
<td>
<p>an object of class <code><a href="#topic+PhyloEM">PhyloEM</a></code>.</p>
</td></tr>
<tr><td><code id="find_rotation_+3A_res2">res2</code></td>
<td>
<p>an object of class <code><a href="#topic+PhyloEM">PhyloEM</a></code>.</p>
</td></tr>
<tr><td><code id="find_rotation_+3A_tol">tol</code></td>
<td>
<p>relative numerical tolerance. Default to <code>.Machine$double.eps^(0.5)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If appropriate, the rotation matrix rot such that dat1 = rot 
</p>

<hr>
<h2 id='find_shift_values'>Find values given edges. OU stationary case. Ultrametric tree.</h2><span id='topic+find_shift_values'></span>

<h3>Description</h3>

<p><code>find_actualized_shift_values</code> computes the values of the shifts their
positions, and the mean values at the tips.
Warning : this function does not check for consistency. Please make sure that the
shifts positions and the mean values are compatible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_shift_values(shifts_edges, T_tree_ac, vect_Y, p, ntaxa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_shift_values_+3A_shifts_edges">shifts_edges</code></td>
<td>
<p>a vector of positions of shifts on the tree.</p>
</td></tr>
<tr><td><code id="find_shift_values_+3A_t_tree_ac">T_tree_ac</code></td>
<td>
<p>matrix of incidence of the tree, result of function 
<code>incidence.matrix</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code>qr.solve</code> for rectangular linear system solving.
</p>


<h3>Value</h3>

<p>vector, with first entry the values at the root, and other entries the
values of the shifts.
</p>

<hr>
<h2 id='format_output'>Run the EM for several values of K</h2><span id='topic+format_output'></span>

<h3>Description</h3>

<p><code>estimateEM_several_K.OUsr</code> uses function <code>estimateEM</code> on the data, 
for all values of K between 0 and K_max.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_output(results_estim_EM, phylo, time = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_output_+3A_results_estim_em">results_estim_EM</code></td>
<td>
<p>output of function <code>estimateEM</code></p>
</td></tr>
<tr><td><code id="format_output_+3A_time">time</code></td>
<td>
<p>to run the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EM is first launched for K=0, with alpha and gamma estimated. The
estimated values of alpha, gamma and beta_0 found by this first EM are then
used as initialization parameters for all the other runs of the EM for other
K.
The EMs are parallelized thanks to packages <code>foreach</code> and 
<code>doParallel</code>.
WARNING : this code only work of OU with stationary root, on an ultrametric
tree.
</p>


<h3>Value</h3>

<p>summary a data frame with K_max lines, and columns:
- alpha_estim the estimated selection strength
- gamma_estim the estimated root variance
- beta_0_estim the estimated value of root optimum
- EM_steps number of iterations needed before convergence
- DV_estim has the EM diverged ?
- CV_estim has the EM converged ?
- log_likelihood log likelihood of the data using the estimated parameters
- mahalanobis_distance_data_mean the Mahalanobis distance between the data
and the estimated means at the tips
- least_squares the Mahalanobis distance, renormalized by gamma^2: 
mahalanobis_distance_data_mean * gamma_estim.
- mean_number_new_shifts the mean number of shifts that changed over the 
iterations of the EM
- number_equivalent_solutions the number of equivalent solutions to 
the solution found.
- K_try the number of shifts allowed.
- complexity the complexity for K_try
- time the CPU time needed.
</p>
<p>params a list of inferred parameters
</p>
<p>params_init a list of initial parameters
</p>
<p>alpha_0 initial values of alpha
</p>
<p>gamma_0 initial values of gamma
</p>
<p>Zhat reconstructed node states
</p>
<p>m_Y_estim reconstructed tip states
</p>
<p>edge.quality for each edge, relative number of iterations in which they
were present.
</p>

<hr>
<h2 id='get_criterion'>Get Model Selection Criterion</h2><span id='topic+get_criterion'></span>

<h3>Description</h3>

<p>This function takes an object of class <code>PhyloEM</code>, result of function
<code><a href="#topic+PhyloEM">PhyloEM</a></code>, and return the values of the model selection criterion
for each value of K.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_criterion(res, method.selection = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_criterion_+3A_res">res</code></td>
<td>
<p>an object of class <code>PhyloEM</code>, result of function
<code><a href="#topic+PhyloEM">PhyloEM</a></code>.</p>
</td></tr>
<tr><td><code id="get_criterion_+3A_method.selection">method.selection</code></td>
<td>
<p>select the parameters to plot. One of &quot;LINselect&quot;, &quot;DDSE&quot;,
&quot;Djump&quot; or &quot;likelihood&quot; (for un-penalized likelihood). Default to &quot;LINselect&quot;. See
<code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with the values of the criterion for each number of shift K.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code>, <code><a href="#topic+plot.PhyloEM">plot.PhyloEM</a></code>, <code><a href="#topic+plot_criterion">plot_criterion</a></code>
</p>

<hr>
<h2 id='get_variance_node'>Get variance matrix of a node</h2><span id='topic+get_variance_node'></span>

<h3>Description</h3>

<p><code>get_variance_node</code> returns the conditional variance of a node, or the conditional
covariance of a node and its parent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_variance_node(node, vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_variance_node_+3A_node">node</code></td>
<td>
<p>for which to extract the matrix.</p>
</td></tr>
<tr><td><code id="get_variance_node_+3A_vars">vars</code></td>
<td>
<p>matrix of size p x p*(ntaxa+Nnode) result of function <code>compute_E.simple</code>,
entry &quot;variances&quot; or &quot;covariances&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sub-matrix of variance for the node.
</p>

<hr>
<h2 id='go_back_to_original_process'>Scale the parameters back to the original process</h2><span id='topic+go_back_to_original_process'></span>

<h3>Description</h3>

<p><code>go_back_to_original_process</code> takes the inferred parameters with a BM
on a rescaled tree, and gives back the equivalent parameters of the OU on 
the original process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>go_back_to_original_process(
  phy_original,
  known.selection.strength,
  sBM_variance,
  params
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="go_back_to_original_process_+3A_phy_original">phy_original</code></td>
<td>
<p>the original phylogenetic tree</p>
</td></tr>
<tr><td><code id="go_back_to_original_process_+3A_known.selection.strength">known.selection.strength</code></td>
<td>
<p>the known selection strength of the original
OU.</p>
</td></tr>
<tr><td><code id="go_back_to_original_process_+3A_sbm_variance">sBM_variance</code></td>
<td>
<p>boolean. Is the root random ?</p>
</td></tr>
<tr><td><code id="go_back_to_original_process_+3A_params">params</code></td>
<td>
<p>the inferred parameters of the BM on the re-scaled tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>params_scOU the equivalent parameters of the OU on the original tree.
</p>

<hr>
<h2 id='imputed_traits'>Ancestral State Reconstruction</h2><span id='topic+imputed_traits'></span><span id='topic+imputed_traits.PhyloEM'></span>

<h3>Description</h3>

<p><code>imputed_traits.PhyloEM</code> takes an object of class <code><a href="#topic+PhyloEM">PhyloEM</a></code>,
and returns the imputed traits values, either at the internal nodes (ancestral
state reconstruction) or at the tips (data imputation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputed_traits(x, ...)

## S3 method for class 'PhyloEM'
imputed_traits(
  x,
  trait = 1,
  save_all = FALSE,
  where = c("nodes", "tips"),
  what = c("imputed", "variances", "expectations"),
  params = NULL,
  method.selection = NULL,
  reconstructed_states = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputed_traits_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+PhyloEM">PhyloEM</a></code>.</p>
</td></tr>
<tr><td><code id="imputed_traits_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to
<code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code></p>
</td></tr>
<tr><td><code id="imputed_traits_+3A_trait">trait</code></td>
<td>
<p>an integer giving the trait to extract. Default to 1.</p>
</td></tr>
<tr><td><code id="imputed_traits_+3A_save_all">save_all</code></td>
<td>
<p>if TRUE, arguments <code>where</code> and <code>what</code> are ignored, and
all the moments are kept for further extraction with the same function, specifying
the argument <code>reconstructed_states</code>. Default to FALSE.</p>
</td></tr>
<tr><td><code id="imputed_traits_+3A_where">where</code></td>
<td>
<p>either &quot;nodes&quot; for ancestral state reconstruction, or &quot;tips&quot; for
data imputation.</p>
</td></tr>
<tr><td><code id="imputed_traits_+3A_what">what</code></td>
<td>
<p>the quantity to retrieve. Either the imputed traits (default), their
conditional variances, or the simple expectations under the selected process.</p>
</td></tr>
<tr><td><code id="imputed_traits_+3A_params">params</code></td>
<td>
<p>(optional) some user-specified parameters.
Must be of class <code><a href="#topic+params_process">params_process</a></code>. If left blank, they are extracted
using the <code>method.selection</code> argument (see below).</p>
</td></tr>
<tr><td><code id="imputed_traits_+3A_method.selection">method.selection</code></td>
<td>
<p>(optional) the method selection to be used.
One of &quot;LINselect&quot;, &quot;DDSE&quot;, &quot;Djump&quot;. Default to &quot;LINselect&quot;.</p>
</td></tr>
<tr><td><code id="imputed_traits_+3A_reconstructed_states">reconstructed_states</code></td>
<td>
<p>if the reconstructed states have already been
computed (by a previous call of the function, with <code>save_all=TRUE</code>),
they can be passed on here (avoids multiple computations of the E step).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or array with the computed quantities.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>imputed_traits(PhyloEM)</code>: <code><a href="#topic+PhyloEM">PhyloEM</a></code> object
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code>, <code><a href="#topic+PhyloEM">PhyloEM</a></code>
</p>

<hr>
<h2 id='incidence_matrix_actualization_factors'>Compute the actualization factors to apply to the incidence matrix.</h2><span id='topic+incidence_matrix_actualization_factors'></span>

<h3>Description</h3>

<p><code>incidence_matrix_actualization_factors</code> computes a ntaxa x Nedge matrix of the 
(1 - exp(-alpha * (t_i - t_pa(j) - nu_j * l_j)))_{i tip, j node}.
This matrix is to be multiplied to the incidence matrix with an outer product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incidence_matrix_actualization_factors(
  tree,
  selection.strength,
  relativeTimes_tree = 0,
  times_shared = compute_times_ca(tree)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incidence_matrix_actualization_factors_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree.</p>
</td></tr>
<tr><td><code id="incidence_matrix_actualization_factors_+3A_selection.strength">selection.strength</code></td>
<td>
<p>the selection strength of the process.</p>
</td></tr>
<tr><td><code id="incidence_matrix_actualization_factors_+3A_relativetimes_tree">relativeTimes_tree</code></td>
<td>
<p>a Nedge vector of relative times associated with the branches.</p>
</td></tr>
<tr><td><code id="incidence_matrix_actualization_factors_+3A_times_shared">times_shared</code></td>
<td>
<p>a matrix, result of function <code>compute_times_ca</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of size ntaxa x Nedge
</p>

<hr>
<h2 id='incidence.matrix'>Incidence matrix of a tree.</h2><span id='topic+incidence.matrix'></span>

<h3>Description</h3>

<p><code>incidence.matrix</code> computes the incidence matrix T of a tree : for a 
lineage i and a branch b, T[i,b]=1 if b is in the lineage i, and 0 
otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incidence.matrix(phylo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incidence.matrix_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of incidence, size Nedge x ntaxa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incidence.matrix.full">incidence.matrix.full</a></code>
</p>

<hr>
<h2 id='incidence.matrix.full'>Incidence matrix of a tree.</h2><span id='topic+incidence.matrix.full'></span>

<h3>Description</h3>

<p><code>incidence.matrix.full</code> computes the incidence matrix U of a tree : for a 
node i and a branch b, U[i,b]=1 if b is in the lineage i, and 0 
otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incidence.matrix.full(phylo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incidence.matrix.full_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of incidence, size ntaxa + Nnode.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incidence.matrix">incidence.matrix</a></code>
</p>

<hr>
<h2 id='init.allocate_regimes_from_shifts'>Initialization for the allocation of shifts.</h2><span id='topic+init.allocate_regimes_from_shifts'></span>

<h3>Description</h3>

<p><code>init.allocate_regimes_from_shifts</code> initialize the vector of regimes 
at nodes and tips, with the regime (0) at the root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.allocate_regimes_from_shifts(phy, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.allocate_regimes_from_shifts_+3A_phy">phy</code></td>
<td>
<p>Input tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in function <code>allocate_regimes_from_shifts</code> and is 
designed to furnish function <code>update.allocate_regimes_from_shifts</code> with 
the right structure of data.
</p>


<h3>Value</h3>

<p>Matrix of size (Nnode + ntaxa)x1 of NAs, with the 0 at the root.
</p>

<hr>
<h2 id='init.alpha.gamma.estimation'>Initialization the selection strength alpha using robust estimation</h2><span id='topic+init.alpha.gamma.estimation'></span>

<h3>Description</h3>

<p><code>init.alpha.estimation</code> fits (Y_i-Y_j)^2 ~ gamma^2(1-exp(-alpha*d_ij))
for all couples of tips (i,j) that have the same mean, i.e than are not
separated by a shift. Shifts are initialized thanks to a lasso
(function <code>init.EM.lasso</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.alpha.gamma.estimation(
  phylo,
  Y_data,
  nbr_of_shifts,
  times_shared,
  distances_phylo,
  T_tree,
  subtree.list,
  max_triplet_number,
  alpha_known,
  method.init.alpha.estimation,
  tol_EM,
  h_tree,
  miss,
  masque_data,
  independent,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.alpha.gamma.estimation_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="init.alpha.gamma.estimation_+3A_y_data">Y_data</code></td>
<td>
<p>data at the tips.</p>
</td></tr>
<tr><td><code id="init.alpha.gamma.estimation_+3A_nbr_of_shifts">nbr_of_shifts</code></td>
<td>
<p>number of shifts used in the EM algorithm</p>
</td></tr>
<tr><td><code id="init.alpha.gamma.estimation_+3A_distances_phylo">distances_phylo</code></td>
<td>
<p>(matrix) : phylogenetic distance, result of function 
<code>compute_dist_phy</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>robustbase::nlrob</code> is used for the robust fit.
</p>


<h3>Value</h3>

<p>params_init the list of initial parameters to be used, in the right
format.
</p>

<hr>
<h2 id='init.compute_betas_from_shifts'>Initialization for the computation of the optimal values</h2><span id='topic+init.compute_betas_from_shifts'></span>

<h3>Description</h3>

<p><code>init.compute_betas_from_shifts</code> initialize the vector of optimal values at nodes and
tips, with the value at the root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.compute_betas_from_shifts(phy, optimal.value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.compute_betas_from_shifts_+3A_phy">phy</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="init.compute_betas_from_shifts_+3A_optimal.value">optimal.value</code></td>
<td>
<p>the optimal value at the root of the tree</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in function <code>compute_betas_from_shifts</code> and is designed to 
furnish function <code>update.compute_betas_from_shifts</code> with the right structure of data.
</p>


<h3>Value</h3>

<p>Matrix of size (Nnode + ntaxa)x1 of NAs, with the optimal value
at the root.
</p>

<hr>
<h2 id='init.EM.lasso'>Initialization of the shifts using Lasso.</h2><span id='topic+init.EM.lasso'></span>

<h3>Description</h3>

<p><code>init.EM.lasso</code> does the following regression :
||Y_data-T.delta||_(Sigma_YY^(-1)) + lambda |delta|_1
using the function <code>glmnet::glmnet</code> of package <code>glmnet</code>,
through function <code>lasso_regression_K_fixed</code>. 
T is the incidence matrix of the tree, and 
delta the vectorial representation of the shifts (see functions 
<code>incidence.matrix</code> and <code>shifts.list_to_vector</code> for further details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.EM.lasso(
  phylo,
  Y_data,
  Y_data_imp = Y_data,
  Y_data_vec_known = as.vector(Y_data),
  process,
  times_shared = compute_times_ca(phylo),
  distances_phylo,
  nbr_of_shifts,
  K_lag_init = 0,
  use_sigma = TRUE,
  params_sigma = NULL,
  variance.init = diag(1, p, p),
  random.init = FALSE,
  value.root.init = rep(0, p),
  exp.root.init = rep(1, p),
  var.root.init = diag(1, p, p),
  edges.init = NULL,
  values.init = matrix(0, p, length(edges.init)),
  relativeTimes.init = NULL,
  selection.strength.init = 1,
  optimal.value.init = rep(0, p),
  T_tree = incidence.matrix(phylo),
  subtree.list = NULL,
  miss = FALSE,
  sBM_variance = FALSE,
  stationary.root.init = FALSE,
  masque_data,
  independent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.EM.lasso_+3A_y_data">Y_data</code></td>
<td>
<p>data at the tips.</p>
</td></tr>
<tr><td><code id="init.EM.lasso_+3A_times_shared">times_shared</code></td>
<td>
<p>(matrix) : times of shared ancestry, result of function 
<code>compute_times_ca</code>.</p>
</td></tr>
<tr><td><code id="init.EM.lasso_+3A_distances_phylo">distances_phylo</code></td>
<td>
<p>(matrix) : phylogenetic distance, result of function 
<code>compute_dist_phy</code></p>
</td></tr>
<tr><td><code id="init.EM.lasso_+3A_nbr_of_shifts">nbr_of_shifts</code></td>
<td>
<p>number of shifts used in the EM algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Cholesky decomposition of function Sigma_YY^(-1) is used.
lambda is chosen so that delta has the right number of non zero components.
</p>


<h3>Value</h3>

<p>params_init the list of initial parameters to be used, in the right
format.
</p>

<hr>
<h2 id='init.enumerate_parsimony'>Initialization for the enumeration of parsimonious solutions.</h2><span id='topic+init.enumerate_parsimony'></span>

<h3>Description</h3>

<p><code>init.enumerate_parsimony</code> is used in function <code>enumerate_parsimony</code>, 
and initialize the correct data structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.enumerate_parsimony(phy, clusters, pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.enumerate_parsimony_+3A_phy">phy</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="init.enumerate_parsimony_+3A_clusters">clusters</code></td>
<td>
<p>a vector representing the group of each tip.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list with Nnode + ntaxa entries. Entries corresponding to
the tips are initialized with a list of nclus matrices. For tip i of group k, all
matrices are set to NULL, except for the kth, set to a vector of size
Nnode + ntaxa, with entry i set to k, and all the others to NA.
</p>


<h3>Value</h3>

<p>A list of size Nnode + ntaxa, as described above.
</p>

<hr>
<h2 id='init.incidence.matrix'>Initialization for incidence matrix</h2><span id='topic+init.incidence.matrix'></span>

<h3>Description</h3>

<p><code>init.incidence.matrix</code> initialize the matrix updated in
<code>update.incidence.matrix</code> for the computation of the incidence matrix
in <code>incidence.matrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.incidence.matrix(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.incidence.matrix_+3A_phy">phy</code></td>
<td>
<p>Input tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initialized matrix has ntaxa column and Nnode rows. Each node
represent its parental branch. A row corresponding to a tip i is initialized
to a vector of zeros, with only entry i equal to one. (Branch ending at 
tip i is only in the i^th lineage)
</p>


<h3>Value</h3>

<p>Matrix with Nnode rows and ntaxa column.
</p>

<hr>
<h2 id='init.incidence.matrix.full'>Initialization for incidence matrix (full tree)</h2><span id='topic+init.incidence.matrix.full'></span>

<h3>Description</h3>

<p><code>init.incidence.matrix.full</code> initialize the matrix updated in
<code>update.incidence.matrix.full</code> for the computation of the incidence
matrix of the full tree in <code>incidence.matrix.full</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.incidence.matrix.full(phy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.incidence.matrix.full_+3A_phy">phy</code></td>
<td>
<p>Input tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initialized matrix is squared of size ntaxa + Nnode. Each node
represent its parental branch. A row corresponding to a tip i is initialized
to a vector of zeros, with only entry i equal to one. (Branch ending at 
tip i is only in the i^th lineage)
</p>


<h3>Value</h3>

<p>Matrix of size ntaxa + Nnode.
</p>

<hr>
<h2 id='init.parsimonyCost'>Initialization for parsimonyCost.</h2><span id='topic+init.parsimonyCost'></span>

<h3>Description</h3>

<p><code>init.parsimonyCost</code> initialize a (ntaxa + Nnode) x (nclus) matrix with
NAs everywhere, except for the tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.parsimonyCost(phy, clusters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.parsimonyCost_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="init.parsimonyCost_+3A_clusters">clusters</code></td>
<td>
<p>the vector of the clusters of the tips.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At a tip i in state k, the line-vector is initialized as follow : 
(1 - Ind(k=p)_{1&lt;=p&lt;=nclus})*Inf (where Inf * 0 = 0)
</p>


<h3>Value</h3>

<p>A (ntaxa + Nnode)x(nclus) matrix, with ntaxa first lines initialized as
described.
</p>

<hr>
<h2 id='init.parsimonyNumber'>Initialization for parsimonyNumber.</h2><span id='topic+init.parsimonyNumber'></span>

<h3>Description</h3>

<p><code>init.parsimonyNumber</code> initialize a (ntaxa + Nnode)x(nclus) matrix with
NAs everywhere, except for the tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.parsimonyNumber(phy, clusters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.parsimonyNumber_+3A_phy">phy</code></td>
<td>
<p>phylogenetic tree.</p>
</td></tr>
<tr><td><code id="init.parsimonyNumber_+3A_clusters">clusters</code></td>
<td>
<p>the vector of the clusters of the tips.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At a tip i in state k, the line-vector is initialized as follow : Ind(k=p)_{1&lt;=p&lt;=nclus}
</p>


<h3>Value</h3>

<p>A (ntaxa + Nnode)x(nclus) matrix, with ntaxa first lines initialized
as described.
</p>

<hr>
<h2 id='init.simulate.BM'>Initialize BM</h2><span id='topic+init.simulate.BM'></span>

<h3>Description</h3>

<p>Function used in <code><a href="stats.html#topic+simulate">simulate</a></code> for BM initialization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.simulate.BM(phy, p, root.state, simulate_random, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.simulate.BM_+3A_phy">phy</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="init.simulate.BM_+3A_root.state">root.state</code></td>
<td>
<p>(list) State of the root, with:
random : random state (TRUE) or deterministic state (FALSE)
value.root : if deterministic, value of the character at the root
exp.root : if random, expectation of the character at the root
var.root : if random, variance of the character at the root (pxp matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>paramSimu Array p x Nnode x 2 (BM), filled with NAs.
Slice paramSimu[, ntaxa + 1, ] (array p x 2) is initialized with simulated
states and root expectations for all the traits.
</p>

<hr>
<h2 id='init.simulate.OU'>Initialize state and expectation matrices</h2><span id='topic+init.simulate.OU'></span>

<h3>Description</h3>

<p>Function used in <code><a href="stats.html#topic+simulate">simulate</a></code> for OU initialization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.simulate.OU(phy, p, root.state, optimal.value, simulate_random, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.simulate.OU_+3A_phy">phy</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="init.simulate.OU_+3A_p">p</code></td>
<td>
<p>dimension of the trait simulated</p>
</td></tr>
<tr><td><code id="init.simulate.OU_+3A_root.state">root.state</code></td>
<td>
<p>(list): state of the root, with:
random : random state (TRUE) or deterministic state (FALSE)
value.root : if deterministic, value of the character at the root
exp.root : if random, expectation of the character at the root
var.root : if random, variance of the character at the root (pxp matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>paramSimu: array p x Nnode x 3, filled with NAs.
Slice paramSimu[, ntaxa + 1, ] (array p x 3) is initialized with simulated states, root
expectations, and optimal values for all the traits.
</p>

<hr>
<h2 id='init.simulate.StateAndExp'>Initialize state and expectation matrices</h2><span id='topic+init.simulate.StateAndExp'></span>

<h3>Description</h3>

<p>Function used in <code><a href="stats.html#topic+simulate">simulate</a></code> for BM/OU initializations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.simulate.StateAndExp(phy, p, root.state, simulate_random)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.simulate.StateAndExp_+3A_phy">phy</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="init.simulate.StateAndExp_+3A_p">p</code></td>
<td>
<p>dimension of the trait simulated</p>
</td></tr>
<tr><td><code id="init.simulate.StateAndExp_+3A_root.state">root.state</code></td>
<td>
<p>(list): state of the root, with:
random : random state (TRUE) or deterministic state (FALSE)
value.root : if deterministic, value of the character at the root
exp.root : if random, expectation of the character at the root
var.root : if random, variance of the character at the root (pxp matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>paramSimu: array p x Nnode x 2 (BM), filled with NAs.
Slice paramSimu[, ntaxa + 1, ] (array p x 2) is initialized with simulated states and root
expectations for all the traits.
</p>

<hr>
<h2 id='is.in.ranges'>Check whether parameters are in ranges.</h2><span id='topic+is.in.ranges'></span>

<h3>Description</h3>

<p><code>is.in.ranges.params</code> checks whether calculated parameters in the EM are
in the defined ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.in.ranges(p, min, max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.in.ranges_+3A_p">p</code></td>
<td>
<p>list of parameters with the correct structure</p>
</td></tr>
<tr><td><code id="is.in.ranges_+3A_min">min</code></td>
<td>
<p>list of minimum values for the parameters</p>
</td></tr>
<tr><td><code id="is.in.ranges_+3A_max">max</code></td>
<td>
<p>list of maximum values for the parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to test the convergence of the algorithm.
</p>


<h3>Value</h3>

<p>boolean
</p>

<hr>
<h2 id='lasso_regression_K_fixed.glmnet_multivariate'>Do a lasso regression with the number of non-zero variables fixed.</h2><span id='topic+lasso_regression_K_fixed.glmnet_multivariate'></span>

<h3>Description</h3>

<p><code>lasso_regression_K_fixed</code> does the following regression :
||Yp-Xp.delta|| + lambda |delta|_1 using the function <code>glmnet::glmnet</code> of 
package <code>glmnet</code>, where delta is a vector representing the shifts 
occurring on the branches. It does a Gauss lasso regression using function 
<code>lm</code> on top of it. This function is used in functions 
<code>init.EM.lasso</code>, <code>segmentation.OU.specialCase.lasso</code>, ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso_regression_K_fixed.glmnet_multivariate(
  Yp,
  Xp,
  K,
  root = NULL,
  penscale = rep(1, ncol(Xp)),
  K_lag = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lasso_regression_K_fixed.glmnet_multivariate_+3A_yp">Yp</code></td>
<td>
<p>(transformed) data</p>
</td></tr>
<tr><td><code id="lasso_regression_K_fixed.glmnet_multivariate_+3A_xp">Xp</code></td>
<td>
<p>(transformed) matrix of regression</p>
</td></tr>
<tr><td><code id="lasso_regression_K_fixed.glmnet_multivariate_+3A_k">K</code></td>
<td>
<p>number of non-zero components allowed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>lambda is chosen so that delta has the right number of non zero components.
If not possible, either temporarily raise the number of shifts and then select
only the shifts with the highest modulus, or if not possible, throw an error.
</p>


<h3>Value</h3>

<p>E0.gauss the intercept (value at the root)
</p>
<p>shifts.gauss the list of shifts found on the branches
</p>

<hr>
<h2 id='log_likelihood'>Log Likelihood of a fitted object</h2><span id='topic+log_likelihood'></span><span id='topic+log_likelihood.params_process'></span><span id='topic+log_likelihood.PhyloEM'></span>

<h3>Description</h3>

<p><code>log_likelihood</code> computes the log likelihood of some parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_likelihood(x, ...)

## S3 method for class 'params_process'
log_likelihood(x, Y_data, phylo, ...)

## S3 method for class 'PhyloEM'
log_likelihood(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_likelihood_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+params_process">params_process</a></code> or <code><a href="#topic+PhyloEM">PhyloEM</a></code>.</p>
</td></tr>
<tr><td><code id="log_likelihood_+3A_...">...</code></td>
<td>
<p>for a <code>PhyloEM</code> object, further arguments to be passed on to
<code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code> (to choose which parameters to extract from
the results, see documentation of this function).</p>
</td></tr>
<tr><td><code id="log_likelihood_+3A_y_data">Y_data</code></td>
<td>
<p>matrix of data at the tips, size p x ntaxa. Each line is a
trait, and each column is a tip. The column names are checked against the
tip names of the tree.</p>
</td></tr>
<tr><td><code id="log_likelihood_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.
<code><a href="#topic+incidence.matrix.full">incidence.matrix.full</a></code>. Can be specified to avoid extra computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log likelihood of the data with the provided parameters on the tree.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>log_likelihood(params_process)</code>: <code><a href="#topic+params_process">params_process</a></code> object
</p>
</li>
<li> <p><code>log_likelihood(PhyloEM)</code>: <code><a href="#topic+PhyloEM">PhyloEM</a></code> object
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+params_process">params_process</a></code>, <code><a href="#topic+PhyloEM">PhyloEM</a></code>
</p>

<hr>
<h2 id='matrix_of_possibles'>Compute parent matrix from possibles daughter matrices.</h2><span id='topic+matrix_of_possibles'></span>

<h3>Description</h3>

<p><code>matrix_of_possibles</code> is used in function <code>update.enumerate_parsimony</code>
to compute, from the list of possible matrices for the daughters, the matrix for
the node (a group for the parent being fixed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_of_possibles(matrices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_of_possibles_+3A_matrices">matrices</code></td>
<td>
<p>a list of matrices with ndaughters entries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function select all possible combinations of rows from all the daughters, and
merge then into one using function <code>merge_complementary_vectors</code>.
</p>


<h3>Value</h3>

<p>Matrix of all possible regimes for the subtree bellow node parent.
</p>

<hr>
<h2 id='merge_complementary_vectors'>Merge several complementary vectors into one.</h2><span id='topic+merge_complementary_vectors'></span>

<h3>Description</h3>

<p><code>merge_complementary_vectors</code> take several vectors with complementary entries
(i.e, vector of same length, that are such that only one vector has a non NA value
for each entry), and merge them into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_complementary_vectors(comb, mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_complementary_vectors_+3A_comb">comb</code></td>
<td>
<p>vector giving the rows to be kept.</p>
</td></tr>
<tr><td><code id="merge_complementary_vectors_+3A_mat">mat</code></td>
<td>
<p>matrix containing the vectors as rows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vectors are selected from the entry matrix by comb. At each entry, the vectors
are added using function <code>add_complementary</code>.
</p>


<h3>Value</h3>

<p>row vector of the same size as entry matrix.
</p>

<hr>
<h2 id='merge_params_independent'>Merge a list of independent parameters into into one parameter</h2><span id='topic+merge_params_independent'></span>

<h3>Description</h3>

<p><code>merge_params_independent</code> merges a list of p params
objects into one param object of dimension p
The reverse operation is done by <code>split_params_independent</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_params_independent(params_split)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_params_independent_+3A_params_split">params_split</code></td>
<td>
<p>a list of parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parameter object
</p>

<hr>
<h2 id='merge_rotations'>Merge fits from independent runs of PhyloEM.</h2><span id='topic+merge_rotations'></span>

<h3>Description</h3>

<p><code>merge_rotations</code> takes several fits from <code><a href="#topic+PhyloEM">PhyloEM</a></code>, and
merge them according to the best score (maximum likelihood or least squares).
For each number of shifts, 
The datasets needs to be equal up to a rotation. This is tested thanks to a QR
decomposition, see function <code><a href="#topic+find_rotation">find_rotation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_rotations(..., method.selection = NULL, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_rotations_+3A_...">...</code></td>
<td>
<p>objects of class <code><a href="#topic+PhyloEM">PhyloEM</a></code> fitted on datasets that are equal up to a rotation.</p>
</td></tr>
<tr><td><code id="merge_rotations_+3A_method.selection">method.selection</code></td>
<td>
<p>(optional) selection method to be applied to the merged fit. 
See <code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code>.</p>
</td></tr>
<tr><td><code id="merge_rotations_+3A_tol">tol</code></td>
<td>
<p>(optional) relative numerical tolerance. See <code><a href="#topic+find_rotation">find_rotation</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+PhyloEM">PhyloEM</a></code>, result of the merge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load Data
data(monkeys)
## Run method
# Note: use more alpha values for better results.
res &lt;- PhyloEM(Y_data = monkeys$dat,        ## data
               phylo = monkeys$phy,         ## phylogeny
               process = "scOU",            ## scalar OU
               random.root = TRUE,          ## root is stationary
               stationary.root = TRUE,
               K_max = 10,                  ## maximal number of shifts
               nbr_alpha = 4,               ## number of alpha values
               parallel_alpha = TRUE,       ## parallelize on alpha values
               Ncores = 2)
## Rotate dataset
rot &lt;- matrix(c(cos(pi/4), -sin(pi/4), sin(pi/4), cos(pi/4)), nrow= 2, ncol = 2)
Yrot &lt;- t(rot) %*% monkeys$dat
rownames(Yrot) &lt;- rownames(monkeys$dat)
## Fit rotated dataset
# Note: use more alpha values for better results.
res_rot &lt;- PhyloEM(Y_data = Yrot,               ## rotated data
                   phylo = monkeys$phy,         
                   process = "scOU",            
                   random.root = TRUE,          
                   stationary.root = TRUE,
                   K_max = 10,                  
                   nbr_alpha = 4,               
                   parallel_alpha = TRUE,       
                   Ncores = 2)
## Merge the two
res_merge &lt;- merge_rotations(res, res_rot)
## Plot the selected result
plot(res_merge)
## Plot the model selection criterion
plot_criterion(res_merge)

## End(Not run)

</code></pre>

<hr>
<h2 id='model_selection'>Model Selection of a fitted object</h2><span id='topic+model_selection'></span><span id='topic+model_selection.PhyloEM'></span>

<h3>Description</h3>

<p><code>model_selection</code> does the model selection on a fitted <code><a href="#topic+PhyloEM">PhyloEM</a></code> 
object, and returns the same fitted object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_selection(x, ...)

## S3 method for class 'PhyloEM'
model_selection(
  x,
  method.selection = c("LINselect", "DDSE", "Djump"),
  C.BM1 = 0.1,
  C.BM2 = 2.5,
  C.LINselect = 1.1,
  independent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_selection_+3A_x">x</code></td>
<td>
<p>a fitted <code><a href="#topic+PhyloEM">PhyloEM</a></code> object</p>
</td></tr>
<tr><td><code id="model_selection_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="#topic+estimateEM">estimateEM</a></code>, including
tolerance parameters for stopping criteria, maximal number of iterations, etc.</p>
</td></tr>
<tr><td><code id="model_selection_+3A_method.selection">method.selection</code></td>
<td>
<p>Method selection to be used. Several ones can be
used at the same time. One of &quot;LINselect&quot; for the Baraud Giraud Huet LINselect 
method; &quot;DDSE&quot; for the Slope Heuristic or &quot;Djump&quot; for the Jump Heuristic, last
two based the Birgé Massart method.</p>
</td></tr>
<tr><td><code id="model_selection_+3A_c.bm1">C.BM1</code></td>
<td>
<p>Multiplying constant to be used for the BigeMassart1 method.
Need to be positive. Default to 0.1.</p>
</td></tr>
<tr><td><code id="model_selection_+3A_c.bm2">C.BM2</code></td>
<td>
<p>Multiplying constant to be used for the BigeMassart2 method.
Default to 2.5.</p>
</td></tr>
<tr><td><code id="model_selection_+3A_c.linselect">C.LINselect</code></td>
<td>
<p>Multiplying constant to be used for the LINselect method.
Need to be greater than 1. Default to 1.1.</p>
</td></tr>
<tr><td><code id="model_selection_+3A_independent">independent</code></td>
<td>
<p>Are the trait assumed to be independent from one another?
Default to FALSE. OU in a multivariate setting only works if TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same object, but with a slot corresponding to the model selection used. See
function <code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code> to retrieve the selected parameters.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>model_selection(PhyloEM)</code>: <code><a href="#topic+PhyloEM">PhyloEM</a></code> object
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+PhyloEM">PhyloEM</a></code>, <code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code>,
<code><a href="#topic+imputed_traits.PhyloEM">imputed_traits.PhyloEM</a></code>
</p>

<hr>
<h2 id='monkeys'>New World Monkeys dataset</h2><span id='topic+monkeys'></span>

<h3>Description</h3>

<p>Morphometric dataset and phylogeny for brain shape variation of 50 species of
New World monkeys (platyrrhine).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monkeys
</code></pre>


<h3>Format</h3>

<p>A list containing two objects:
</p>

<dl>
<dt>phy</dt><dd><p>The Phylogenetic tree for the platyrrhine species, pruned to match
the species in the morphometric dataset</p>
</dd>
<dt>dat</dt><dd><p>First two PC scores from a PCA of the species-averaged Procrustes
coordinates</p>
</dd>
</dl>



<h3>References</h3>

<p>Aristide, L., dos Reis, S. F., Machado, A. C., Lima, I., Lopes, R. T.
&amp; Perez, S. I. (2016). Brain shape convergence in the adaptive radiation of New
World monkeys. Proceedings of the National Academy of Sciences, 113(8), 2158–2163.
http://doi.org/10.1073/pnas.1514473113
</p>

<hr>
<h2 id='node_optimal_values'>Computation of the optimal values at nodes and tips.</h2><span id='topic+node_optimal_values'></span>

<h3>Description</h3>

<p><code>compute_betas_from_shifts</code> computes the optimal values at the nodes and tips of the
tree, given the value at the root and the list of shifts occurring in the tree.
It assumes an OU model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_optimal_values(param, phylo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_optimal_values_+3A_param">param</code></td>
<td>
<p>an object of class <code><a href="#topic+params_process">params_process</a></code>.</p>
</td></tr>
<tr><td><code id="node_optimal_values_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of size ntraits  x (ntaxa + Nnode) of the optimal values at
the node and tips of the tree.
Column names correspond to the number of the node in the phylo object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1792)
ntaxa = 10
tree &lt;- rphylo(ntaxa, 1, 0.1)
# parameters of the process
par &lt;- params_process("BM",                             ## Process
                      p = 2,                            ## Dimension
                      variance = diag(0.5, 2, 2) + 0.5, ## Rate matrix
                      edges = c(4, 10, 15),             ## Positions of the shifts
                      values = cbind(c(5, 4),           ## Values of the shifts
                                     c(-4, -5),
                                     c(5, -3)))
plot(par, phylo = tree, traits = 1, value_in_box = TRUE,
     shifts_bg = "white", root_bg = "white", ancestral_as_shift = TRUE, root_adj = 5)
nodelabels()
node_optimal_values(par, tree)

</code></pre>

<hr>
<h2 id='params_BM'>Create an object <code>params_process</code> for a BM</h2><span id='topic+params_BM'></span>

<h3>Description</h3>

<p><code>params_BM</code> creates a coherent object params_process from user 
provided values of the parameters. Non specified parameters are set to 
default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params_BM(
  p = 1,
  variance = diag(1, p, p),
  random = FALSE,
  value.root = rep(0, p),
  exp.root = rep(0, p),
  var.root = diag(1, p, p),
  edges = NULL,
  values = matrix(0, p, length(edges)),
  relativeTimes = NULL,
  nbr_of_shifts = length(edges),
  phylo = NULL,
  sBM_variance = FALSE,
  trait_names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_BM_+3A_p">p</code></td>
<td>
<p>the dimension (number of traits) of the parameters. Default to 1.</p>
</td></tr>
<tr><td><code id="params_BM_+3A_variance">variance</code></td>
<td>
<p>the variance (rate matrix) of the BM. Default to 
<code>diag(1, p, p)</code>.</p>
</td></tr>
<tr><td><code id="params_BM_+3A_random">random</code></td>
<td>
<p>whether the root of the BM is random (TRUE) or fixed (FALSE).
Default to FALSE.</p>
</td></tr>
<tr><td><code id="params_BM_+3A_value.root">value.root</code></td>
<td>
<p>if random=FALSE, the root value. Default to 0.</p>
</td></tr>
<tr><td><code id="params_BM_+3A_exp.root">exp.root</code></td>
<td>
<p>if random=TRUE, the root expectation. Default to 0.</p>
</td></tr>
<tr><td><code id="params_BM_+3A_var.root">var.root</code></td>
<td>
<p>if random=TRUE, the root variance. Default to
<code>diag(1, p, p)</code>.</p>
</td></tr>
<tr><td><code id="params_BM_+3A_edges">edges</code></td>
<td>
<p>a vector of edges where the shifts occur. Default to NULL
(no shift).</p>
</td></tr>
<tr><td><code id="params_BM_+3A_values">values</code></td>
<td>
<p>a matrix of shift values, with p lines and as many columns as
the number of shifts. Each column is the p values for one shift. Default to
<code>matrix(0, p, length(edges))</code>.</p>
</td></tr>
<tr><td><code id="params_BM_+3A_relativetimes">relativeTimes</code></td>
<td>
<p>(unused) the relative position of the shift on the
branch, between 0 (beginning of the branch) and 1 (end of the branch). Default
to 0.</p>
</td></tr>
<tr><td><code id="params_BM_+3A_nbr_of_shifts">nbr_of_shifts</code></td>
<td>
<p>the number of shifts to use (randomly drawn). Use only
if <code>edges</code> is not specified. In that case, a phylogenetic tree must be
provided (to allow a random sampling of its edges).</p>
</td></tr>
<tr><td><code id="params_BM_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>. Needed only if
the shifts edges are not specified, or if sBM_variance=TRUE. Default to NULL.
If sBM_variance=TRUE, it must have a specified value for the root branch
length (slot root.edge).</p>
</td></tr>
<tr><td><code id="params_BM_+3A_sbm_variance">sBM_variance</code></td>
<td>
<p>if the root is random, does it depend on the length of the
root edge ? (For equivalent purposes with a rescaled OU). Default to FALSE. If
TRUE, a phylogenetic tree with root edge length must be provided.</p>
</td></tr>
<tr><td><code id="params_BM_+3A_trait_names">trait_names</code></td>
<td>
<p>vector of trait names values. Must be of length p.</p>
</td></tr>
<tr><td><code id="params_BM_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>params_process</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+params_process">params_process</a></code>, <code><a href="#topic+params_OU">params_OU</a></code>
</p>

<hr>
<h2 id='params_OU'>Create an object <code>params_process</code> for an OU</h2><span id='topic+params_OU'></span>

<h3>Description</h3>

<p><code>params_OU</code> creates a coherent object params_process from user 
provided values of the parameters. Non specified parameters are set to 
default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params_OU(
  p = 1,
  variance = diag(1, p, p),
  selection.strength = diag(1, p, p),
  optimal.value = rep(0, p),
  random = TRUE,
  stationary.root = TRUE,
  value.root = rep(0, p),
  exp.root = rep(0, p),
  var.root = diag(1, p, p),
  edges = NULL,
  values = matrix(0, p, length(edges)),
  relativeTimes = NULL,
  nbr_of_shifts = length(edges),
  phylo = NULL,
  trait_names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_OU_+3A_p">p</code></td>
<td>
<p>the dimension (number of traits) of the parameters. Default to 1.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_variance">variance</code></td>
<td>
<p>the variance (rate matrix) of the BM. Default to 
<code>diag(1, p, p)</code>.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_selection.strength">selection.strength</code></td>
<td>
<p>the selection strength matrix. Default to 
<code>diag(1, p, p)</code>.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_optimal.value">optimal.value</code></td>
<td>
<p>the vector of the optimal values at the root. Default
to <code>rep(0, p)</code>.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_random">random</code></td>
<td>
<p>whether the root of the OU is random (TRUE) or fixed (FALSE).
Default to TRUE.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_stationary.root">stationary.root</code></td>
<td>
<p>whether the root of the OU is stationary (TRUE) or not.
Default to TRUE.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_value.root">value.root</code></td>
<td>
<p>if random=FALSE, the root value. Default to 0.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_exp.root">exp.root</code></td>
<td>
<p>if random=TRUE, the root expectation. Default to 0. If
stationary.root=TRUE, default to <code>optimal.value</code>.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_var.root">var.root</code></td>
<td>
<p>if random=TRUE, the root variance. Default to
<code>diag(1, p, p)</code>. If stationary.root=TRUE, default to
the stationary variance computed from <code>variance</code> and
<code>selection.strength</code>, see function
<code><a href="#topic+compute_stationary_variance">compute_stationary_variance</a></code>.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_edges">edges</code></td>
<td>
<p>a vector of edges where the shifts occur. Default to NULL
(no shift).</p>
</td></tr>
<tr><td><code id="params_OU_+3A_values">values</code></td>
<td>
<p>a matrix of shift values, with p lines and as many columns as
the number of shifts. Each column is the p values for one shift. Default to
<code>matrix(0, p, length(edges))</code>.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_relativetimes">relativeTimes</code></td>
<td>
<p>(unused) the relative position of the shift on the
branch, between 0 (beginning of the branch) and 1 (end of the branch). Default
to 0.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_nbr_of_shifts">nbr_of_shifts</code></td>
<td>
<p>the number of shifts to use (randomly drawn). Use only
if <code>edges</code> is not specified. In that case, a phylogenetic tree must be
provided (to allow a random sampling of its edges).</p>
</td></tr>
<tr><td><code id="params_OU_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>. Needed only if
the shifts edges are not specified.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_trait_names">trait_names</code></td>
<td>
<p>vector of trait names values. Must be of length p.</p>
</td></tr>
<tr><td><code id="params_OU_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>params_process</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+params_process">params_process</a></code>, <code><a href="#topic+params_BM">params_BM</a></code>
</p>

<hr>
<h2 id='params_process'>Create an object params_process</h2><span id='topic+params_process'></span>

<h3>Description</h3>

<p><code>params_process</code> creates or extracts a set of parameters of class
<code>params_process</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params_process(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_process_+3A_x">x</code></td>
<td>
<p>an S3 object.</p>
</td></tr>
<tr><td><code id="params_process_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the specific method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>params_process</code>. This is essentially a list containing the following entries:
</p>

<dl>
<dt>process</dt><dd><p>The model used. One of &quot;BM&quot; (for a full BM
model, univariate or multivariate); &quot;OU&quot; (for a full OU model, univariate or
multivariate); or &quot;scOU&quot; (for a &quot;scalar OU&quot; model).</p>
</dd>
<dt>p</dt><dd><p>Dimension of the trait.</p>
</dd>
<dt>root.state</dt><dd><p>List describing the state of the root, with:
</p>

<dl>
<dt>random</dt><dd><p>random state (TRUE) or deterministic state (FALSE)</p>
</dd>
<dt>value.root</dt><dd><p>if deterministic, value of the character at the root</p>
</dd>
<dt>exp.root</dt><dd><p>if random, expectation of the character at the root</p>
</dd>
<dt>var.root</dt><dd><p>if random, variance of the character at the root (pxp matrix)</p>
</dd>
</dl>
</dd>
<dt>shifts</dt><dd><p>List with position and values of the shifts:
</p>

<dl>
<dt>edges</dt><dd><p>vector of the K id of edges where the shifts are</p>
</dd>
<dt>values</dt><dd><p>matrix p x K of values of the shifts on the edges
(one column = one shift)</p>
</dd>
<dt>relativeTimes</dt><dd><p>vector of dimension K of relative time of the shift from the parent node of edges</p>
</dd>
</dl>
</dd>
<dt>variance</dt><dd><p>Variance-covariance matrix size p x p.</p>
</dd>
<dt>selection.strength</dt><dd><p>Matrix of selection strength size p x p (OU).</p>
</dd>
<dt>optimal.value</dt><dd><p>Vector of p optimal values at the root (OU).</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+params_process.character">params_process.character</a></code>,
<code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code>,
<code><a href="#topic+params_BM">params_BM</a></code>, <code><a href="#topic+params_OU">params_OU</a></code>
<code><a href="#topic+simul_process.params_process">simul_process.params_process</a></code>
</p>

<hr>
<h2 id='params_process.character'>Create an object <code>params_process</code></h2><span id='topic+params_process.character'></span>

<h3>Description</h3>

<p><code>params_process</code> creates a coherent object params_process from user 
provided values of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'character'
params_process(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_process.character_+3A_x">x</code></td>
<td>
<p>one of &quot;BM&quot; or &quot;OU&quot;</p>
</td></tr>
<tr><td><code id="params_process.character_+3A_...">...</code></td>
<td>
<p>specified parameters, see functions <code><a href="#topic+params_BM">params_BM</a></code> and 
<code><a href="#topic+params_OU">params_OU</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>params_process</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+params_BM">params_BM</a></code>, <code><a href="#topic+params_OU">params_OU</a></code>
</p>

<hr>
<h2 id='params_process.PhyloEM'>Parameter estimates</h2><span id='topic+params_process.PhyloEM'></span>

<h3>Description</h3>

<p><code>params</code> takes an object of class <code><a href="#topic+PhyloEM">PhyloEM</a></code>, and returns the 
inferred parameters of the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PhyloEM'
params_process(
  x,
  method.selection = NULL,
  K = NULL,
  alpha = NULL,
  rBM = FALSE,
  init = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_process.PhyloEM_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+PhyloEM">PhyloEM</a></code></p>
</td></tr>
<tr><td><code id="params_process.PhyloEM_+3A_method.selection">method.selection</code></td>
<td>
<p>(optional) the method selection to be used.
One of &quot;LINselect&quot;, &quot;DDSE&quot;, &quot;Djump&quot;. Default to &quot;LINselect&quot;.</p>
</td></tr>
<tr><td><code id="params_process.PhyloEM_+3A_k">K</code></td>
<td>
<p>(optional) an integer giving the number of shifts for which to retrieve
the parameters. Default to NULL (automatically selected number of shifts, see
<code>method.selection</code> argument).</p>
</td></tr>
<tr><td><code id="params_process.PhyloEM_+3A_alpha">alpha</code></td>
<td>
<p>(optional) a value of alpha for which to retrieve the parameters. Can
be an (un-ambiguous) estimation of the true value. If
specified, then <code>K</code> must be precised too. Default to NULL (automatically
selected value, see <code>method.selection</code> argument).</p>
</td></tr>
<tr><td><code id="params_process.PhyloEM_+3A_rbm">rBM</code></td>
<td>
<p>(optional) if TRUE, and if the process is &quot;scOU&quot;, returns the raw
parameters of the BM on the re-scaled tree. Default to FALSE, except if 
the selection strength is negative (see doc of <code><a href="#topic+PhyloEM">PhyloEM</a></code> for
an explanation of this particular case).</p>
</td></tr>
<tr><td><code id="params_process.PhyloEM_+3A_init">init</code></td>
<td>
<p>(optional) if TRUE, gives the parameters from the initialization of
the EM. Default to FALSE. This has no effect if <code>K</code> is not specified.</p>
</td></tr>
<tr><td><code id="params_process.PhyloEM_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+params_process">params_process</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PhyloEM">PhyloEM</a></code>, <code><a href="#topic+imputed_traits.PhyloEM">imputed_traits.PhyloEM</a></code>
</p>

<hr>
<h2 id='parsimonyCost'>Minimal number of shifts needed to get a clustering.</h2><span id='topic+parsimonyCost'></span>

<h3>Description</h3>

<p><code>parsimonyCost</code> is an implementation of the Sankoff algorithm,
when the cost of transition between two state is always one. It is used
in functions <code><a href="#topic+parsimonyNumber">parsimonyNumber</a></code> and <code><a href="#topic+enumerate_parsimony">enumerate_parsimony</a></code>
to count or enumerate all the parsimonious solutions given one clustering of the
tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parsimonyCost(phylo, clusters = rep(1, length(phylo$tip.label)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parsimonyCost_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="parsimonyCost_+3A_clusters">clusters</code></td>
<td>
<p>the vector of the clusters of the tips. (Default to all the tips
in a single group).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 class &quot;<code>parsimonyCost</code>&quot; containing a 
(ntaxa + Nnode) x (nclus) matrix of the total number of shifts needed to
get the clustering, if starting from a node in state k. The cost can be
extract from any subtree with function <code><a href="#topic+extract.parsimonyCost">extract.parsimonyCost</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract.parsimonyCost">extract.parsimonyCost</a></code>, <code><a href="#topic+parsimonyNumber">parsimonyNumber</a></code>, 
<code><a href="#topic+enumerate_parsimony">enumerate_parsimony</a></code>, <code><a href="#topic+partitionsNumber">partitionsNumber</a></code>,
<code><a href="#topic+equivalent_shifts">equivalent_shifts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- read.tree(text="(((1,1),2),2);")
plot(tree); nodelabels()
clusters &lt;- c(1, 1, 2, 2)
costs &lt;- parsimonyCost(tree, clusters)
costs

## Extract the parsimony cost at the root
extract(costs)

## Extract the cost for the sub-tree below node 7
extract(costs, 7)

</code></pre>

<hr>
<h2 id='parsimonyNumber'>Number of equivalent parsimonious allocations.</h2><span id='topic+parsimonyNumber'></span>

<h3>Description</h3>

<p><code>parsimonyNumber</code> aims at finding the number of equivalent allocations of
the shifts on the tree, i.e allocations that are parsimonious and compatible
with a given clustering of the tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parsimonyNumber(phylo, clusters = rep(1, length(phylo$tip.label)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parsimonyNumber_+3A_phylo">phylo</code></td>
<td>
<p>phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="parsimonyNumber_+3A_clusters">clusters</code></td>
<td>
<p>the vector of the clusters of the tips. Default to all the tips
in one single cluster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does a recursion up the tree.
The function <code><a href="#topic+extract.parsimonyNumber">extract.parsimonyNumber</a></code> gives the result sought for
any subtree.
The matrix of costs of the states (number of shifts) is also required, it is
computed by function <code><a href="#topic+parsimonyCost">parsimonyCost</a></code>.
</p>


<h3>Value</h3>

<p>an object of S3 class &quot;<code>parsimonyNumber</code>&quot; with:
</p>

<dl>
<dt>nbrReconstructions</dt><dd><p>a (ntaxa + Nnode) x (nclus)
matrix of locally parsimonious solutions starting from a cluster k at a
given node</p>
</dd>
<dt>costReconstructions</dt><dd><p>an object of class &quot;<code>parsimonyCost</code>&quot;,
result of function <code><a href="#topic+parsimonyCost">parsimonyCost</a></code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+extract.parsimonyNumber">extract.parsimonyNumber</a></code>, <code><a href="#topic+parsimonyCost">parsimonyCost</a></code>, 
<code><a href="#topic+enumerate_parsimony">enumerate_parsimony</a></code>, <code><a href="#topic+partitionsNumber">partitionsNumber</a></code>,
<code><a href="#topic+equivalent_shifts">equivalent_shifts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- read.tree(text="(((0,1),2),2);")
plot(tree); nodelabels()
clusters &lt;- c(0, 1, 2, 2)
n_sols &lt;- parsimonyNumber(tree, clusters)
n_sols

## Extract the number of parsimonious solutions at the root
extract(n_sols)

## Extract the cost of the solutions from the root
extract(n_sols, what = "cost")
extract(parsimonyCost(tree, clusters)) # same, more efficient

## Extract for the sub-tree below node 7
extract(n_sols, 7) # Result: 2 (the ancestral state is either "0" or "1"). 

</code></pre>

<hr>
<h2 id='partitionsNumber'>Number of different models</h2><span id='topic+partitionsNumber'></span>

<h3>Description</h3>

<p><code>partitionsNumber</code> computes the number of different models with a given
number of shifts K. It is also the number of colorings of the tips to the 
tree in npart = K + 1 colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partitionsNumber(phylo, npart)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partitionsNumber_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="partitionsNumber_+3A_npart">npart</code></td>
<td>
<p>the numbers of partitions (colors) allowed at the tips. This
is the number of shifts plus one (npart = K + 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>partitionsNumber</code>. This is made of a matrix
with (Nnode + ntaxa) rows and (2*npart) columns. Each column contains two vectors:
for k=1:npart it contains the number of partitions with k groups compatible
with the tree and the shift process; and for k=(npart+1):2*npart, it contains
the number of &quot;marked&quot; partitions with (k-npart) groups compatible with the
tree and the shift process. The actual number can be extracted with function
<code><a href="#topic+extract.partitionsNumber">extract.partitionsNumber</a></code> (see examples below).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract.partitionsNumber">extract.partitionsNumber</a></code>, <code><a href="#topic+parsimonyNumber">parsimonyNumber</a></code>,
<code><a href="#topic+equivalent_shifts">equivalent_shifts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("combinat", quietly = TRUE)) {
  npart &lt;- 8 # number of colors at the tips allowed
  tree &lt;- read.tree(text="(A,(A,(A,A,A),A,A));") # a tree with polytomies
  plot(tree)
  parts_num &lt;- partitionsNumber(tree, npart)
  parts_num
  
  ## Number of possible colorings of the tips in npart colors
  extract(parts_num)
  
  ## Get all the solutions for colorings with 1 to nparts colors
  extract(parts_num, npart = 1:npart)
  
  ## Number of possible colorings of the tips in npart colors
  ## For the sub-tree starting at node 17
  extract(parts_num, node = 10)
  
  ## Number of possible colorings of the tips in npart colors
  ## with one marked color
  extract(parts_num, marked = TRUE)
}


</code></pre>

<hr>
<h2 id='penalty_BaraudGiraudHuet_likelihood'>Penalty function type Baraud Giraud Huet.</h2><span id='topic+penalty_BaraudGiraudHuet_likelihood'></span>

<h3>Description</h3>

<p><code>penalty_BaraudGiraudHuet_likelihood</code> is the penalty defined by : 
pen' = ntaxa * log(1 + pen/(ntaxa - K)) with 
pen = C * (ntaxa - K)/(ntaxa - K - 1) * EDkhi[K + 1; ntaxa - K - 1; exp(-Delta_K)/(K + 1)]
and Delta = log(model_complexity) + log(K + 1) 
such that sum(exp(-Delta_K)) &lt; infty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalty_BaraudGiraudHuet_likelihood(K, model_complexity, ntaxa, C = 1.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalty_BaraudGiraudHuet_likelihood_+3A_k">K</code></td>
<td>
<p>the dimension of the model.</p>
</td></tr>
<tr><td><code id="penalty_BaraudGiraudHuet_likelihood_+3A_model_complexity">model_complexity</code></td>
<td>
<p>the complexity of the set of models with dimension K.</p>
</td></tr>
<tr><td><code id="penalty_BaraudGiraudHuet_likelihood_+3A_ntaxa">ntaxa</code></td>
<td>
<p>the number of tips.</p>
</td></tr>
<tr><td><code id="penalty_BaraudGiraudHuet_likelihood_+3A_c">C</code></td>
<td>
<p>a constant, C &gt; 1. Default is C = 1.1
(as suggested in Baraud Giraud Huet (2009))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Baraud Giraud Huet (2009, 2011).
Must be applied to log-likelihood criterion.
Function pen is computed using function <code>penalty</code> from package
<code>LINselect</code>.
</p>


<h3>Value</h3>

<p>value of the penalty.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penalty_BirgeMassart_shape1">penalty_BirgeMassart_shape1</a></code>,
<code><a href="#topic+penalty_BirgeMassart_shape2">penalty_BirgeMassart_shape2</a></code>
</p>

<hr>
<h2 id='penalty_BirgeMassart_shape1'>Penalty function type Birgé-Massart 1</h2><span id='topic+penalty_BirgeMassart_shape1'></span>

<h3>Description</h3>

<p><code>penalty_BirgeMassart_shape1</code> is the penalty shape defined by : 
pen_shape = (sqrt(K) + sqrt(2 * K * L_K))^2 with sum(exp(- K * L_K)) &lt; infty :
L_K = B + 1/K * log(model_complexity).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalty_BirgeMassart_shape1(K, p, model_complexity, B = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalty_BirgeMassart_shape1_+3A_k">K</code></td>
<td>
<p>the number of shifts</p>
</td></tr>
<tr><td><code id="penalty_BirgeMassart_shape1_+3A_p">p</code></td>
<td>
<p>the dimension of the data</p>
</td></tr>
<tr><td><code id="penalty_BirgeMassart_shape1_+3A_model_complexity">model_complexity</code></td>
<td>
<p>the complexity of the set of models with dimension K</p>
</td></tr>
<tr><td><code id="penalty_BirgeMassart_shape1_+3A_b">B</code></td>
<td>
<p>a non-negative constant. Default is 0.1 
(as suggested in Cleynen &amp; Lebarbier 2015)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Birgé Massart (2001).
Must be applied to least-square criterion.
This penalty should be calibrated using the slope heuristic.
</p>


<h3>Value</h3>

<p>value of the penalty
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penalty_BaraudGiraudHuet_likelihood">penalty_BaraudGiraudHuet_likelihood</a></code>,
<code><a href="#topic+penalty_BirgeMassart_shape2">penalty_BirgeMassart_shape2</a></code>
</p>

<hr>
<h2 id='penalty_BirgeMassart_shape2'>Penalty function type Birgé-Massart 2</h2><span id='topic+penalty_BirgeMassart_shape2'></span>

<h3>Description</h3>

<p><code>penalty_BirgeMassart_shape2</code> is the penalty shape defined by : 
pen_shape = C*K_try + log(model_complexity).
It dominates the penalty defined by <code>penalty_BirgeMassart_shape1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalty_BirgeMassart_shape2(K, p, model_complexity, C = 2.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalty_BirgeMassart_shape2_+3A_k">K</code></td>
<td>
<p>the number of shifts</p>
</td></tr>
<tr><td><code id="penalty_BirgeMassart_shape2_+3A_p">p</code></td>
<td>
<p>the dimension of the data</p>
</td></tr>
<tr><td><code id="penalty_BirgeMassart_shape2_+3A_model_complexity">model_complexity</code></td>
<td>
<p>the complexity of the set of models with dimension K.</p>
</td></tr>
<tr><td><code id="penalty_BirgeMassart_shape2_+3A_c">C</code></td>
<td>
<p>a non-negative constant. Default is 2.5 
(as suggested in Lebarbier 2005)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Birgé Massart (2001).
Must be applied to least-square criterion.
This penalty should be calibrated using the slope heuristic.
</p>


<h3>Value</h3>

<p>value of the penalty.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penalty_BirgeMassart_shape1">penalty_BirgeMassart_shape1</a></code>,
<code><a href="#topic+penalty_BaraudGiraudHuet_likelihood">penalty_BaraudGiraudHuet_likelihood</a></code>
</p>

<hr>
<h2 id='penalty_pBIC'>Penalty function type pBIC</h2><span id='topic+penalty_pBIC'></span>

<h3>Description</h3>

<p><code>penalty_pBIC_scalarOU</code> is the pBIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalty_pBIC(
  all_params,
  model_complexity,
  independent,
  tree,
  times_shared,
  distances_phylo,
  T_tree,
  p,
  K,
  ntaxa,
  process
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalty_pBIC_+3A_model_complexity">model_complexity</code></td>
<td>
<p>the complexity of the set of models with dimension K.</p>
</td></tr>
<tr><td><code id="penalty_pBIC_+3A_k">K</code></td>
<td>
<p>the dimension of the model.</p>
</td></tr>
<tr><td><code id="penalty_pBIC_+3A_ntaxa">ntaxa</code></td>
<td>
<p>the number of tips.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of the penalty.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penalty_BirgeMassart_shape1">penalty_BirgeMassart_shape1</a></code>,
<code><a href="#topic+penalty_BirgeMassart_shape2">penalty_BirgeMassart_shape2</a></code>
</p>

<hr>
<h2 id='PhyloEM'>Model Estimation with Detection of Shifts</h2><span id='topic+PhyloEM'></span>

<h3>Description</h3>

<p><code>PhyloEM</code> is the main function of the package. It uses maximum likelihood
methods to fit a BM or an OU process for several traits evolving along a
phylogenetic tree, with automatic shift detection on the branches of the tree.
This function can handle missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhyloEM(
  phylo,
  Y_data,
  process = c("BM", "OU", "scOU", "rBM"),
  check_postorder = TRUE,
  independent = FALSE,
  K_max = max(floor(sqrt(length(phylo$tip.label))), 10),
  use_previous = FALSE,
  order = TRUE,
  method.selection = c("LINselect", "DDSE", "Djump"),
  C.BM1 = 0.1,
  C.BM2 = 2.5,
  C.LINselect = 1.1,
  method.variance = c("upward_downward", "simple"),
  method.init = "lasso",
  method.init.alpha = "estimation",
  method.init.alpha.estimation = c("regression", "regression.MM", "median"),
  methods.segmentation = c("lasso", "best_single_move"),
  alpha_grid = TRUE,
  nbr_alpha = 10,
  random.root = TRUE,
  stationary.root = random.root,
  alpha = NULL,
  check.tips.names = TRUE,
  progress.bar = TRUE,
  estimates = NULL,
  save_step = FALSE,
  rescale_OU = TRUE,
  parallel_alpha = FALSE,
  Ncores = 3,
  K_lag_init = 5,
  light_result = TRUE,
  tol_tree = .Machine$double.eps^0.5,
  allow_negative = FALSE,
  option_is.ultrametric = 1,
  trait_correlation_threshold = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhyloEM_+3A_phylo">phylo</code></td>
<td>
<p>A phylogenetic tree of class <code>phylo</code> 
(from package <code><a href="ape.html#topic+ape">ape</a></code>).</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_y_data">Y_data</code></td>
<td>
<p>Matrix of data at the tips, size p x ntaxa. Each line is a
trait, and each column is a tip. The column names are checked against the
tip names of the tree.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_process">process</code></td>
<td>
<p>The model used for the fit. One of &quot;BM&quot; (for a full BM model, 
univariate or multivariate); &quot;OU&quot; (for an OU with independent traits, 
univariate or multivariate); or &quot;scOU&quot; (for a &quot;scalar OU&quot; model, see details).</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_check_postorder">check_postorder</code></td>
<td>
<p>Re-order the tree in post-order. If the Upward-Downward
algorithm is used, the tree need to be in post-order. Default to TRUE if the
upward-downward is used, otherwise automatically set to FALSE.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_independent">independent</code></td>
<td>
<p>Are the trait assumed to be independent from one another?
Default to FALSE. OU in a multivariate setting only works if TRUE.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_k_max">K_max</code></td>
<td>
<p>The maximum number of shifts to be considered. Default to 
<code class="reqn">max(|\sqrt ntaxa|, 10)</code>.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_use_previous">use_previous</code></td>
<td>
<p>Should the initialization for K+1 shifts use the 
estimation for $K$ shifts already obtained? Default to FALSE.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_order">order</code></td>
<td>
<p>Should the estimations be done for K increasing (TRUE) or K
decreasing (FALSE)? If use_previous=FALSE, this has no influence, except if one
initialization fails. Default to TRUE.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_method.selection">method.selection</code></td>
<td>
<p>Method selection to be used. Several ones can be
used at the same time. One of &quot;LINselect&quot; for the Baraud Giraud Huet LINselect 
method; &quot;DDSE&quot; for the Slope Heuristic or &quot;Djump&quot; for the Jump Heuristic, last
two based the Birgé Massart method.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_c.bm1">C.BM1</code></td>
<td>
<p>Multiplying constant to be used for the BigeMassart1 method.
Need to be positive. Default to 0.1.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_c.bm2">C.BM2</code></td>
<td>
<p>Multiplying constant to be used for the BigeMassart2 method.
Default to 2.5.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_c.linselect">C.LINselect</code></td>
<td>
<p>Multiplying constant to be used for the LINselect method.
Need to be greater than 1. Default to 1.1.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_method.variance">method.variance</code></td>
<td>
<p>Algorithm to be used for the moments computations at the
E step. One of &quot;simple&quot; for the naive method; of &quot;upward_downward&quot; for the 
Upward Downward method (usually faster). Default to &quot;upward_downward&quot;.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_method.init">method.init</code></td>
<td>
<p>The initialization method. One of &quot;lasso&quot; for the LASSO
base initialization method; or &quot;default&quot; for user-specified initialization
values. Default to &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_method.init.alpha">method.init.alpha</code></td>
<td>
<p>For OU model, initialization method for the selection
strength alpha. One of &quot;estimation&quot; for a cherry-based initialization, using
<code><a href="robustbase.html#topic+nlrob">nlrob</a></code>; or &quot;default&quot; for user-specified 
initialization values. Default to &quot;estimation&quot;.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_method.init.alpha.estimation">method.init.alpha.estimation</code></td>
<td>
<p>If method.init.alpha=&quot;estimation&quot;,
choice of the estimation(s) methods to be used. Choices among &quot;regression&quot;,
(method=&quot;M&quot; is passed to <code><a href="robustbase.html#topic+nlrob">nlrob</a></code>); &quot;regression.MM&quot;
(method=&quot;MM&quot; is passed to <code><a href="robustbase.html#topic+nlrob">nlrob</a></code>) or &quot;median&quot;
(<code><a href="robustbase.html#topic+nlrob">nlrob</a></code> is not used, a simple median is taken).
Default to all of them.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_methods.segmentation">methods.segmentation</code></td>
<td>
<p>For OU, method(s) used at the M step to find new
candidate shifts positions. Choices among &quot;lasso&quot; for a LASSO-based algorithm;
and &quot;best_single_move&quot; for a one-move at a time based heuristic. Default to 
both of them. Using only &quot;lasso&quot; might speed up the function a lot.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_alpha_grid">alpha_grid</code></td>
<td>
<p>whether to use a grid for alpha values. Default to TRUE. This
is the only available method for scOU. This method is not available for OU with
multivariate traits. OU with univariate traits can take both TRUE or FALSE. If
TRUE, a grid based on the branch length of the tree is automatically computed,
using function <code><a href="#topic+find_grid_alpha">find_grid_alpha</a></code>.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_nbr_alpha">nbr_alpha</code></td>
<td>
<p>If <code>alpha_grid=TRUE</code>, the number of alpha values on the
grid. Default to 10.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_random.root">random.root</code></td>
<td>
<p>whether the root is assumed to be random (TRUE) of fixed
(FALSE). Default to TRUE</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_stationary.root">stationary.root</code></td>
<td>
<p>whether the root is assumed to be in the stationary 
state. Default to TRUE.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_alpha">alpha</code></td>
<td>
<p>If the estimation is done with a fixed alpha (either known, or
on a grid), the possible value for alpha. Default to NULL.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_check.tips.names">check.tips.names</code></td>
<td>
<p>whether to check the tips names of the tree against
the column names of the data. Default to TRUE.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_progress.bar">progress.bar</code></td>
<td>
<p>whether to display a progress bar of the computations.
Default to TRUE.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_estimates">estimates</code></td>
<td>
<p>The result of a previous run of this same function. This
function can be re-run for other model election method. Default to NULL.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_save_step">save_step</code></td>
<td>
<p>If alpha_grid=TRUE, whether to save the intermediate results
for each value of alpha (in a temporary file). Useful for long computations.
Default to FALSE.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_rescale_ou">rescale_OU</code></td>
<td>
<p>For the Univariate OU, should the tree be re-scaled to use a BM ? 
This can speed up the computations a lot. However, it can make it harder for the EM to 
explore the space of parameters, and hence lead to a sub-optimal solution.
Default to TRUE.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_parallel_alpha">parallel_alpha</code></td>
<td>
<p>If alpha_grid=TRUE, whether to run the 
estimations with different values of alpha on separate cores. Default to 
FALSE. If TRUE, the log is written as a temporary file.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_ncores">Ncores</code></td>
<td>
<p>If parallel_alpha=TRUE, number of cores to be used.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_k_lag_init">K_lag_init</code></td>
<td>
<p>Number of extra shifts to be considered at the initialization
step. Increases the accuracy, but can make computations quite slow of taken
too high. Default to 5.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_light_result">light_result</code></td>
<td>
<p>if TRUE (the default), the object returned is made light,
without easily computable quantities. If FALSE, the object can be very heavy, but
its subsequent manipulations can be faster (especially for plotting).</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_tol_tree">tol_tree</code></td>
<td>
<p>tolerance to consider a branch length significantly greater than zero, or
two lineages lengths to be different, when checking for ultrametry. 
(Default to .Machine$double.eps^0.5). See <code><a href="ape.html#topic+is.ultrametric">is.ultrametric</a></code> and <code><a href="ape.html#topic+di2multi">di2multi</a></code>.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_allow_negative">allow_negative</code></td>
<td>
<p>whether to allow negative values for alpha (Early Burst).
See details. Default to FALSE.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_option_is.ultrametric">option_is.ultrametric</code></td>
<td>
<p>option for <code><a href="ape.html#topic+is.ultrametric">is.ultrametric</a></code> check. Default to 1.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_trait_correlation_threshold">trait_correlation_threshold</code></td>
<td>
<p>the trait correlation threshold to stop the analysis. Default to 0.9.</p>
</td></tr>
<tr><td><code id="PhyloEM_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="#topic+estimateEM">estimateEM</a></code>, including
tolerance parameters for stopping criteria, maximal number of iterations, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several models can be used:
</p>

<ul>
<li><p> BM with fixed root, univariate or multivariate.
</p>
</li>
<li><p> OU with fixed or stationary root, univariate or multivariate.
</p>
</li></ul>

<p>For the OU in the multivariate setting, two assumptions can be made:
</p>

<ul>
<li><p> Independent traits. This amounts to diagonal rate and selection matrices.
</p>
</li>
<li><p> &quot;Scalar OU&quot; (scOU): the rate matrix can be full, but the selection 
strength matrix is assumed to be scalar, i.e. all the traits are supposed to
go to their optimum values with the same speed.
</p>
</li></ul>

<p>Note that the &quot;scalar OU&quot; model can also be seen as a re-scaling of the tree.
The selection strength parameter alpha can then be interpreted as a measure
of the &quot;phylogenetic signal&quot;:
</p>

<ul>
<li><p> If alpha is close to 0, then the process is similar to a BM on the original tree,
and the signal is strong.
</p>
</li>
<li><p> If alpha is large, then the re-scaled tree is similar to a star-tree,
and the signal is weak.
</p>
</li></ul>

<p>When there are no shifts, and the root is taken to be constant, this
model is actually equivalent to an AC model (Uyeda et al. 2015).
With this interpretation in mind, one might want to explore 
negative values of alpha, in order to fit a DC (or Early Burst) model.
With no shift and a fixed root, the same proof shows that the scOU
with alpha negative is equivalent to the DC model. There are two
strong caveats in doing that.
</p>

<ul>
<li><p> The interpretation of the OU as modeling the dynamic of a trait
undergoing stabilizing selection is lost. In this case, the scOU can only
be seen as a re-scaling of the tree, similar to Pagel's delta.
</p>
</li>
<li><p> The values of the &quot;optimal values&quot;, and of the shifts on them, cannot
be interpreted as such (the process is actually going away from this values,
instead of being attracted). When looking at these values, one should only use
the un-normalized values happening of the underlying BM. You can extract those
using the <code><a href="#topic+params_process">params_process</a></code> function with <code>rBM = TRUE</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>PhyloEM</code>. Relevant quantities can be extracted from it 
using helper functions <code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code>,
<code><a href="#topic+imputed_traits.PhyloEM">imputed_traits.PhyloEM</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.PhyloEM">plot.PhyloEM</a></code>, <code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code>,
<code><a href="#topic+imputed_traits.PhyloEM">imputed_traits.PhyloEM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load Data
data(monkeys)
## Run method
# Note: use more alpha values for better results.
res &lt;- PhyloEM(Y_data = monkeys$dat,        ## data
               phylo = monkeys$phy,         ## phylogeny
               process = "scOU",            ## scalar OU
               random.root = TRUE,          ## root is stationary
               stationary.root = TRUE,
               K_max = 10,                  ## maximal number of shifts
               nbr_alpha = 4,               ## number of alpha values
               parallel_alpha = TRUE,       ## parallelize on alpha values
               Ncores = 2)
## Plot selected solution (LINselect)
plot(res) # three shifts
## Plot selected solution (DDSE)
plot(res, method.selection = "DDSE") # no shift
## Extract and solution with 5 shifts
params_5 &lt;- params_process(res, K = 5)
plot(res, params = params_5)
## Show all equivalent solutions
eq_sol &lt;- equivalent_shifts(monkeys$phy, params_5)
plot(eq_sol)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_criterion'>Plot Model Selection Criterion</h2><span id='topic+plot_criterion'></span>

<h3>Description</h3>

<p>This function takes an object of class <code>PhyloEM</code>, result of function
<code><a href="#topic+PhyloEM">PhyloEM</a></code>, and plots a model selection criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_criterion(
  res,
  method.selection = NULL,
  add = FALSE,
  select.col = "red",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_criterion_+3A_res">res</code></td>
<td>
<p>an object of class <code>PhyloEM</code>, result of function
<code><a href="#topic+PhyloEM">PhyloEM</a></code>.</p>
</td></tr>
<tr><td><code id="plot_criterion_+3A_method.selection">method.selection</code></td>
<td>
<p>select the parameters to plot. One of &quot;LINselect&quot;, &quot;DDSE&quot;,
&quot;Djump&quot; or &quot;likelihood&quot; (for un-penalized likelihood). Default to &quot;LINselect&quot;. See
<code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code>.</p>
</td></tr>
<tr><td><code id="plot_criterion_+3A_add">add</code></td>
<td>
<p>boolean: should the points be added to a current plot (default to FALSE).</p>
</td></tr>
<tr><td><code id="plot_criterion_+3A_select.col">select.col</code></td>
<td>
<p>the color of the point selected by the criterion. Default to &quot;red&quot;.</p>
</td></tr>
<tr><td><code id="plot_criterion_+3A_...">...</code></td>
<td>
<p>further argument to be passed to base <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code>, <code><a href="#topic+plot.PhyloEM">plot.PhyloEM</a></code>, <code><a href="#topic+get_criterion">get_criterion</a></code>
</p>

<hr>
<h2 id='plot.enumerate_parsimony'>Plot all the equivalent solutions.</h2><span id='topic+plot.enumerate_parsimony'></span>

<h3>Description</h3>

<p><code>plot.enumerate_parsimony</code> plots a representation of all the equivalent
solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'enumerate_parsimony'
plot(x, numbering = FALSE, nbr_col = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.enumerate_parsimony_+3A_x">x</code></td>
<td>
<p>an object of class <code>enumerate_parsimony</code>, result of
function <code><a href="#topic+enumerate_parsimony">enumerate_parsimony</a></code></p>
</td></tr>
<tr><td><code id="plot.enumerate_parsimony_+3A_numbering">numbering</code></td>
<td>
<p>whether to number the solutions. Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.enumerate_parsimony_+3A_nbr_col">nbr_col</code></td>
<td>
<p>the number of columns on which to display the plot.
Default to 3.</p>
</td></tr>
<tr><td><code id="plot.enumerate_parsimony_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code> or 
<code><a href="ape.html#topic+nodelabels">nodelabels</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses functions <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code> and
<code><a href="ape.html#topic+nodelabels">nodelabels</a></code> for the actual plotting of the trees.
</p>


<h3>Value</h3>

<p>A plot of the equivalent shifts allocations.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>, <code><a href="#topic+enumerate_parsimony">enumerate_parsimony</a></code>,
<code><a href="#topic+plot.equivalent_shifts">plot.equivalent_shifts</a></code>, <code><a href="ape.html#topic+nodelabels">nodelabels</a></code>
</p>

<hr>
<h2 id='plot.equivalent_shifts'>Plot all the equivalent solutions.</h2><span id='topic+plot.equivalent_shifts'></span>

<h3>Description</h3>

<p><code>plot.equivalent_shifts</code> plots a representation of all the equivalent
shifts allocations, with a representation of the shifts and their values,
and a coloration of the branches in term of regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'equivalent_shifts'
plot(
  x,
  trait = 1,
  show_shifts_values = TRUE,
  numbering = FALSE,
  colors_tips = NULL,
  nbr_col = 3,
  gray_scale = FALSE,
  edge.width = 2,
  shifts_cex = 1.2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.equivalent_shifts_+3A_x">x</code></td>
<td>
<p>an object of class <code>equivalent_shifts</code>, result of
function <code><a href="#topic+equivalent_shifts">equivalent_shifts</a></code></p>
</td></tr>
<tr><td><code id="plot.equivalent_shifts_+3A_trait">trait</code></td>
<td>
<p>(integer) the trait to be plotted, if multivariate. Default to 1.</p>
</td></tr>
<tr><td><code id="plot.equivalent_shifts_+3A_show_shifts_values">show_shifts_values</code></td>
<td>
<p>whether to show the equivalent shifts values or not. 
Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.equivalent_shifts_+3A_numbering">numbering</code></td>
<td>
<p>whether to number the solutions. Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.equivalent_shifts_+3A_colors_tips">colors_tips</code></td>
<td>
<p>user-provided colors for the tips of the tree. A vector
vector with as many colors as there are tips. Will be automatically computed
if not provided.</p>
</td></tr>
<tr><td><code id="plot.equivalent_shifts_+3A_nbr_col">nbr_col</code></td>
<td>
<p>the number of columns on which to display the plot.
Default to 3.</p>
</td></tr>
<tr><td><code id="plot.equivalent_shifts_+3A_gray_scale">gray_scale</code></td>
<td>
<p>if TRUE, the colors are replaced by a gray scale.
Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.equivalent_shifts_+3A_edge.width">edge.width</code></td>
<td>
<p>width of the edge. Default to 1.</p>
</td></tr>
<tr><td><code id="plot.equivalent_shifts_+3A_shifts_cex">shifts_cex</code></td>
<td>
<p>if <code>value_in_box=TRUE</code>, the size of the text in the boxes.
Default to 0.8.</p>
</td></tr>
<tr><td><code id="plot.equivalent_shifts_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses function <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code> for the actual
plotting of the trees.
</p>


<h3>Value</h3>

<p>A plot of the equivalent shifts allocations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+equivalent_shifts">equivalent_shifts</a></code>, <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>
</p>

<hr>
<h2 id='plot.params_process'>Plot for class <code>simul_process</code></h2><span id='topic+plot.params_process'></span>

<h3>Description</h3>

<p>This function takes an object of class <code>params_process</code>, and plots them along
with some data at the tips of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'params_process'
plot(
  x,
  phylo,
  data = NULL,
  traits,
  automatic_colors = TRUE,
  color_characters = "black",
  color_edges = "black",
  plot_ancestral_states = FALSE,
  ancestral_states = NULL,
  imposed_scale,
  ancestral_cex = 2,
  ancestral_pch = 19,
  value_in_box = FALSE,
  ancestral_as_shift = FALSE,
  shifts_cex = 0.6,
  shifts_bg = "chocolate4",
  root_bg = "chocolate4",
  shifts_adj = 0,
  root_adj = 1,
  color_shifts_regimes = FALSE,
  regime_boxes = FALSE,
  alpha_border = 70,
  show.tip.label = FALSE,
  label_cex = 0.5,
  label_offset = 0,
  axis_cex = 0.7,
  edge.width = 1,
  margin_plot = NULL,
  gray_scale = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.params_process_+3A_x">x</code></td>
<td>
<p>an object of class <code>params_process</code>.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_data">data</code></td>
<td>
<p>a matrix of data at the tips of the tree. Must have p rows and
ntaxa columns. If these are simulated, use the <code><a href="#topic+extract.simul_process">extract.simul_process</a></code>
function.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_traits">traits</code></td>
<td>
<p>a vector of integers giving the numbers of the trait to be plotted.
Default to 1:p (all the traits).</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_automatic_colors">automatic_colors</code></td>
<td>
<p>whether to color the edges automatically according to
their regimes. Default to TRUE. If FALSE, colors can be manually specified through
arguments <code>color_characters</code> and <code>colro_edges</code> (see below).</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_color_characters">color_characters</code></td>
<td>
<p>if <code>automatic_colors=FALSE</code>, a vector of colors for
the tips of the tree.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_color_edges">color_edges</code></td>
<td>
<p>if <code>automatic_colors=FALSE</code>, a vector of colors for the
edges of the tree.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_plot_ancestral_states">plot_ancestral_states</code></td>
<td>
<p>whether to plot the ancestral traits inferred at the
internal nodes of the tree. Only available if only one trait is plotted. Default
to FALSE.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_ancestral_states">ancestral_states</code></td>
<td>
<p>if <code>plot_ancestral_states=TRUE</code>, the ancestral states 
must be specified. If these are simulated, use the
<code><a href="#topic+extract.simul_process">extract.simul_process</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_imposed_scale">imposed_scale</code></td>
<td>
<p>if <code>plot_ancestral_states=TRUE</code>, a vector specifying the
imposed scale for the ancestral states plotting. Useful to make comparisons.
Default to the plotted trait.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_ancestral_cex">ancestral_cex</code></td>
<td>
<p>if <code>plot_ancestral_states=TRUE</code>, the size of the
ancestral states on the tree. Default to 2.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_ancestral_pch">ancestral_pch</code></td>
<td>
<p>if <code>plot_ancestral_states=TRUE</code>, the symbol used of the 
ancestral states. Default to circles (<code>pch=19</code>).</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_value_in_box">value_in_box</code></td>
<td>
<p>whether to plot the value of the shift in a box on the edges.
Only available when only one trait is plotted. Can be difficult to read on big
trees. The size of the text in the boxes is controlled by parameter.
Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_ancestral_as_shift">ancestral_as_shift</code></td>
<td>
<p>whether to represent the ancestral value at the root
as an ancestral shift on the root edge. Default to FALSE.
<code>shifts_cex</code> (see below).</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_shifts_cex">shifts_cex</code></td>
<td>
<p>if <code>value_in_box=TRUE</code>, the size of the text in the boxes.
Default to 0.8.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_shifts_bg">shifts_bg</code></td>
<td>
<p>if <code>value_in_box=TRUE</code>, the background color of the boxes.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_root_bg">root_bg</code></td>
<td>
<p>if <code>value_in_box=TRUE</code> and <code>ancestral_as_shift=TRUE</code>,
the background color of the ancestral box.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_shifts_adj">shifts_adj</code></td>
<td>
<p>the adj parameter for the shifts position on the edges. Default
to 0 (beginning of the edge).</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_root_adj">root_adj</code></td>
<td>
<p>if <code>ancestral_as_shift=TRUE</code>, the adj parameter for the
ancestral value position on the root edge. Default to 1.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_color_shifts_regimes">color_shifts_regimes</code></td>
<td>
<p>whether to color each shift according to its regime
(default to the same color of the edge it's on). Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_regime_boxes">regime_boxes</code></td>
<td>
<p>whether to draw a box showing all the tips below a given.
The transparency of the border of the box is controlled by parameter
<code>alpha_border</code> (see below).</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_alpha_border">alpha_border</code></td>
<td>
<p>if <code>regime_boxes=TRUE</code>, the alpha parameter of
the border of the box. Default to 70.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>whether to show the tip labels. Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_label_cex">label_cex</code></td>
<td>
<p>if <code>show.tip.label=TRUE</code>, the size of the labels. Default
to 0.5.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_label_offset">label_offset</code></td>
<td>
<p>if <code>show.tip.label=TRUE</code>, the size of the offset between
the tree and the labels. Default to 0.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_axis_cex">axis_cex</code></td>
<td>
<p>cex for the label values of the plot. Default to 0.7.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_edge.width">edge.width</code></td>
<td>
<p>width of the edge. Default to 1.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_margin_plot">margin_plot</code></td>
<td>
<p>vector giving the margin to around the plot.
Default to <code>c(0, 0, 0, 0)</code>.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_gray_scale">gray_scale</code></td>
<td>
<p>if TRUE, the colors are replaced by a gray scale.
Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.params_process_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+simul_process">simul_process</a></code>, <code><a href="#topic+plot.PhyloEM">plot.PhyloEM</a></code>,
<code><a href="#topic+params_BM">params_BM</a></code>, <code><a href="#topic+params_OU">params_OU</a></code>
</p>

<hr>
<h2 id='plot.PhyloEM'>Plot for class <code>PhyloEM</code></h2><span id='topic+plot.PhyloEM'></span>

<h3>Description</h3>

<p>This function takes an object of class <code>PhyloEM</code>, result of function
<code><a href="#topic+PhyloEM">PhyloEM</a></code>, and plots the result of the inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PhyloEM'
plot(
  x,
  traits = 1:(x$p),
  params = NULL,
  method.selection = NULL,
  automatic_colors = TRUE,
  color_characters = "black",
  color_edges = "black",
  plot_ancestral_states = FALSE,
  name_trait = "Trait Value",
  imposed_scale,
  ancestral_cex = 2,
  ancestral_pch = 19,
  value_in_box = FALSE,
  ancestral_as_shift = FALSE,
  shifts_cex = 0.6,
  shifts_bg = "chocolate4",
  root_bg = "chocolate4",
  shifts_adj = 0,
  root_adj = 1,
  color_shifts_regimes = FALSE,
  regime_boxes = FALSE,
  alpha_border = 70,
  show.tip.label = FALSE,
  label_cex = 0.5,
  label_font = 1,
  label_offset = 0,
  axis_cex = 0.7,
  axis_las = 0,
  show_axis_traits = TRUE,
  edge.width = 1,
  margin_plot = NULL,
  gray_scale = FALSE,
  root.edge = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PhyloEM_+3A_x">x</code></td>
<td>
<p>an object of class <code>PhyloEM</code>, result of function
<code><a href="#topic+PhyloEM">PhyloEM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_traits">traits</code></td>
<td>
<p>a vector of integers giving the numbers of the trait to be plotted.
Default to 1:p (all the traits).</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_params">params</code></td>
<td>
<p>(optional) some user-specified parameters.
Must be of class <code><a href="#topic+params_process">params_process</a></code>. If left blank, they are extracted
using the <code>method.selection</code> argument (see below).</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_method.selection">method.selection</code></td>
<td>
<p>select the parameters to plot. One of &quot;LINselect&quot;, &quot;DDSE&quot;,
&quot;Djump&quot;. Default to &quot;LINselect&quot;. See
<code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_automatic_colors">automatic_colors</code></td>
<td>
<p>whether to color the edges automatically according to
their regimes. Default to TRUE. If FALSE, colors can be manually specified through
arguments <code>color_characters</code> and <code>colro_edges</code> (see below).</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_color_characters">color_characters</code></td>
<td>
<p>if <code>automatic_colors=FALSE</code>, a vector of colors for
the tips of the tree.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_color_edges">color_edges</code></td>
<td>
<p>if <code>automatic_colors=FALSE</code>, a vector of colors for the
edges of the tree.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_plot_ancestral_states">plot_ancestral_states</code></td>
<td>
<p>whether to plot the ancestral traits inferred at the
internal nodes of the tree. Only available if only one trait is plotted. Default
to FALSE.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_name_trait">name_trait</code></td>
<td>
<p>name of the trait scale bar for the ancestral states plotting.
Default to &quot;Trait Value&quot;.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_imposed_scale">imposed_scale</code></td>
<td>
<p>if <code>plot_ancestral_states=TRUE</code>, a vector specifying the
imposed scale for the ancestral states plotting. Useful to make comparisons.
Default to the plotted trait.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_ancestral_cex">ancestral_cex</code></td>
<td>
<p>if <code>plot_ancestral_states=TRUE</code>, the size of the
ancestral states on the tree. Default to 2.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_ancestral_pch">ancestral_pch</code></td>
<td>
<p>if <code>plot_ancestral_states=TRUE</code>, the symbol used of the 
ancestral states. Default to circles (<code>pch=19</code>).</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_value_in_box">value_in_box</code></td>
<td>
<p>whether to plot the value of the shift in a box on the edges.
Only available when only one trait is plotted. Can be difficult to read on big
trees. The size of the text in the boxes is controlled by parameter.
Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_ancestral_as_shift">ancestral_as_shift</code></td>
<td>
<p>whether to represent the ancestral value at the root
as an ancestral shift on the root edge. Default to FALSE.
<code>shifts_cex</code> (see below).</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_shifts_cex">shifts_cex</code></td>
<td>
<p>if <code>value_in_box=TRUE</code>, the size of the text in the boxes.
Default to 0.8.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_shifts_bg">shifts_bg</code></td>
<td>
<p>if <code>value_in_box=TRUE</code>, the background color of the boxes.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_root_bg">root_bg</code></td>
<td>
<p>if <code>value_in_box=TRUE</code> and <code>ancestral_as_shift=TRUE</code>,
the background color of the ancestral box.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_shifts_adj">shifts_adj</code></td>
<td>
<p>the adj parameter for the shifts position on the edges. Default
to 0 (beginning of the edge).</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_root_adj">root_adj</code></td>
<td>
<p>if <code>ancestral_as_shift=TRUE</code>, the adj parameter for the
ancestral value position on the root edge. Default to 1.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_color_shifts_regimes">color_shifts_regimes</code></td>
<td>
<p>whether to color each shift according to its regime
(default to the same color of the edge it's on). Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_regime_boxes">regime_boxes</code></td>
<td>
<p>whether to draw a box showing all the tips below a given.
The transparency of the border of the box is controlled by parameter
<code>alpha_border</code> (see below).</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_alpha_border">alpha_border</code></td>
<td>
<p>if <code>regime_boxes=TRUE</code>, the alpha parameter of
the border of the box. Default to 70.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>whether to show the tip labels. Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_label_cex">label_cex</code></td>
<td>
<p>if <code>show.tip.label=TRUE</code>, the size of the labels. Default
to 0.5.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_label_font">label_font</code></td>
<td>
<p>if <code>show.tip.label=TRUE</code>, the font of the labels (see <a href="graphics.html#topic+par">par</a>).</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_label_offset">label_offset</code></td>
<td>
<p>if <code>show.tip.label=TRUE</code>, the size of the offset between
the tree and the labels. Default to 0.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_axis_cex">axis_cex</code></td>
<td>
<p>cex for the label values of the plot. Default to 0.7.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_axis_las">axis_las</code></td>
<td>
<p>las for the label values of the plot. Default to 0 (see <a href="graphics.html#topic+par">par</a>).</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_show_axis_traits">show_axis_traits</code></td>
<td>
<p>control whether the trait values axis is plotted (default to TRUE).</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_edge.width">edge.width</code></td>
<td>
<p>width of the edge. Default to 1.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_margin_plot">margin_plot</code></td>
<td>
<p>vector giving the margin to around the plot.
Default to <code>c(0, 0, 0, 0)</code>.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_gray_scale">gray_scale</code></td>
<td>
<p>if TRUE, the colors are replaced by a gray scale.
Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_root.edge">root.edge</code></td>
<td>
<p>a logical indicating whether to draw the root edge (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="plot.PhyloEM_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code>, <code><a href="#topic+imputed_traits.PhyloEM">imputed_traits.PhyloEM</a></code>
</p>

<hr>
<h2 id='prod_index'>Product of elements of a matrix</h2><span id='topic+prod_index'></span>

<h3>Description</h3>

<p><code>prod_index</code> return the product of chosen elements of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prod_index(X, Id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prod_index_+3A_x">X</code></td>
<td>
<p>a matrix with p rows and K column. Each row contains the number of
partition in 1&lt;=k&lt;=K groups for one of the p children of a given node</p>
</td></tr>
<tr><td><code id="prod_index_+3A_id">Id</code></td>
<td>
<p>a vector of length p, result of the function <code>xsimplex</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to be used in <code>sum_simplex</code> to be applied to all the
elements given by <code>xsimplex</code>.
Performs the product : X[1,Id[1]]*X[2,Id[2]]*...*X[p,Id[p]] if all the
elements of Id are positive. Otherwise, just return 0.
</p>


<h3>Value</h3>

<p>double : the result of the product.
</p>

<hr>
<h2 id='qr_solve_exact'>exact qr.solve</h2><span id='topic+qr_solve_exact'></span>

<h3>Description</h3>

<p>This is the same function as <code>qr.solve</code>, but it throws an error if an exact fit cannot
be found (instead of returning a least square fitted value, which is the default behavior
of <code>qr.solve</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qr_solve_exact(a, b, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qr_solve_exact_+3A_a">a</code></td>
<td>
<p>a QR decomposition or a rectangular matrix.</p>
</td></tr>
<tr><td><code id="qr_solve_exact_+3A_b">b</code></td>
<td>
<p>a vector or matrix of right-hand sides of equations.
<code>incidence.matrix</code>.</p>
</td></tr>
<tr><td><code id="qr_solve_exact_+3A_tol">tol</code></td>
<td>
<p>the tolerance for detecting linear dependencies in the columns of x.
Only used if LAPACK is false and x is real.</p>
</td></tr>
</table>

<hr>
<h2 id='recursionDown'>Generic recursion down the tree.</h2><span id='topic+recursionDown'></span>

<h3>Description</h3>

<p><code>recursionDown</code> uses the function <code>updateDown</code> to compute
daughters rows of matrix param.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recursionDown(phy, params, updateDown, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recursionDown_+3A_phy">phy</code></td>
<td>
<p>Input tree, in cladewise order.</p>
</td></tr>
<tr><td><code id="recursionDown_+3A_params">params</code></td>
<td>
<p>Matrix of parameters to update by the recursion</p>
</td></tr>
<tr><td><code id="recursionDown_+3A_updatedown">updateDown</code></td>
<td>
<p>Function to be used for the update</p>
</td></tr>
<tr><td><code id="recursionDown_+3A_...">...</code></td>
<td>
<p>Arguments to be used by the function updateDown</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to be used in other more complex function that need to
update a quantity from the root to the tips of a tree. Note that the
input tree must be in cladewise order.
</p>


<h3>Value</h3>

<p>Matrix of parameters updated.
</p>

<hr>
<h2 id='residuals.PhyloEM'>Residuals of a fitted object</h2><span id='topic+residuals.PhyloEM'></span>

<h3>Description</h3>

<p><code>residuals</code> computes the residuals of some parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PhyloEM'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.PhyloEM_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+params_process">params_process</a></code> or <code><a href="#topic+PhyloEM">PhyloEM</a></code>.
trait, and each column is a tip. The column names are checked against the
tip names of the tree.
<code><a href="#topic+incidence.matrix.full">incidence.matrix.full</a></code>. Can be specified to avoid extra computations.</p>
</td></tr>
<tr><td><code id="residuals.PhyloEM_+3A_...">...</code></td>
<td>
<p>for a <code>PhyloEM</code> object, further arguments to be passed on to
<code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code> (to choose which parameters to extract from
the results, see documentation of this function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log likelihood of the data with the provided parameters on the tree.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+params_process">params_process</a></code>, <code><a href="#topic+PhyloEM">PhyloEM</a></code>
</p>

<hr>
<h2 id='sample_edges_intervals'>Sample equally spaced edges.</h2><span id='topic+sample_edges_intervals'></span>

<h3>Description</h3>

<p><code>sample_edges_intervals</code> samples K shifts, each in one of the K intervals
regularly spaced on the height of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_edges_intervals(tree, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_edges_intervals_+3A_tree">tree</code></td>
<td>
<p>: input tree</p>
</td></tr>
<tr><td><code id="sample_edges_intervals_+3A_k">K</code></td>
<td>
<p>: number of edges to be sampled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case where the tree is not ultrametric, its &quot;height&quot; is defined as the minimum
tip height.
</p>


<h3>Value</h3>

<p>vector of edges
</p>

<hr>
<h2 id='sample_shifts_edges'>Sample shifts edges in a parsimonious way.</h2><span id='topic+sample_shifts_edges'></span>

<h3>Description</h3>

<p><code>sample_shifts_edges</code> attempts to find K shifts in the tree which allocations
are parsimonious. The actual generation of edges is done by function 
<code>sample_edges_intervals</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_shifts_edges(tree, K, part.list = enumerate_tips_under_edges(tree))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_shifts_edges_+3A_tree">tree</code></td>
<td>
<p>: input tree</p>
</td></tr>
<tr><td><code id="sample_shifts_edges_+3A_k">K</code></td>
<td>
<p>: number of edges to be sampled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses function <code>enumerate_tips_under_edges</code> to generate a list 
of tips under each edge, and function <code>check_parsimony</code> to check for
parsimony of a given solution, under the assumption of an &quot;infinite site model&quot;.
</p>


<h3>Value</h3>

<p>vector of edges
</p>

<hr>
<h2 id='scale_params'>Scale variance and selection strength from a linear transform</h2><span id='topic+scale_params'></span>

<h3>Description</h3>

<p>Used for process equivalencies on re-scaled trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_params(params, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_params_+3A_params">params</code></td>
<td>
<p>Parameters list</p>
</td></tr>
<tr><td><code id="scale_params_+3A_f">f</code></td>
<td>
<p>Factor of the linear transform. If t' = f * t, the function takes
parameters from phylo' back to phylo.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>re-scaled parameters
</p>

<hr>
<h2 id='segmentation.BM'>Segmentation in the BM case</h2><span id='topic+segmentation.BM'></span>

<h3>Description</h3>

<p><code>segmentation.BM</code> performs the segmentation algorithm described.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentation.BM(nbr_of_shifts, costs0, diff_exp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentation.BM_+3A_nbr_of_shifts">nbr_of_shifts</code></td>
<td>
<p>Number of shifts on the phylogeny allowed</p>
</td></tr>
<tr><td><code id="segmentation.BM_+3A_costs0">costs0</code></td>
<td>
<p>Cost of each edge</p>
</td></tr>
<tr><td><code id="segmentation.BM_+3A_diff_exp">diff_exp</code></td>
<td>
<p>Difference of expectations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the largest values of costs0, and make them null,
thanks to delta and tau.
</p>


<h3>Value</h3>

<p>List containing : edges_max : array of nbr_of_shifts edges where
costs0 is maximal.
shifts:list containing the computed tau and delta
</p>

<hr>
<h2 id='segmentation.OU.specialCase.lasso'>Segmentation in the OU special case, using lasso regression</h2><span id='topic+segmentation.OU.specialCase.lasso'></span>

<h3>Description</h3>

<p><code>segmentation.OU.specialCase.lasso</code> performs the segmentation using a 
lasso regression to select for the edges where the shifts are added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentation.OU.specialCase.lasso(
  phylo,
  nbr_of_shifts,
  D,
  Xp,
  penscale = rep(1, (nrow(phylo$edge) + 1)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentation.OU.specialCase.lasso_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree</p>
</td></tr>
<tr><td><code id="segmentation.OU.specialCase.lasso_+3A_nbr_of_shifts">nbr_of_shifts</code></td>
<td>
<p>Number of shifts on the phylogeny allowed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function re-write the sum of costs to be minimized as a least squares 
regression problem, and uses a lasso regression to solve it. It uses
functions <code>incidence.matrix.full</code> to express the problem as a 
linear model.
</p>


<h3>Value</h3>

<p>List containing : beta_0 : the optimal value at the root
shifts : list containing the computed tau and delta
costs : vector of costs
</p>

<hr>
<h2 id='segmentation.OU.specialCase.same_shifts'>Segmentation in the OU special case, conserving the same shifts
position.</h2><span id='topic+segmentation.OU.specialCase.same_shifts'></span>

<h3>Description</h3>

<p><code>segmentation.OU.specialCase.same_shifts</code> keeps the same shifts position,
and optimize the sum of costs using function 
<code>best_scenario</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentation.OU.specialCase.same_shifts(phylo, shifts_old, D, Xp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentation.OU.specialCase.same_shifts_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree</p>
</td></tr>
<tr><td><code id="segmentation.OU.specialCase.same_shifts_+3A_shifts_old">shifts_old</code></td>
<td>
<p>the previous list of shifts (only position is used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the best move if keeping the previous shifts positions.
</p>


<h3>Value</h3>

<p>List containing : beta_0 : the optimal value at the root
shifts : list containing the computed tau and delta
costs : vector of costs
</p>

<hr>
<h2 id='shifts_to_simmap'>Simmap format mapping from list of edges</h2><span id='topic+shifts_to_simmap'></span>

<h3>Description</h3>

<p><code>shifts_to_simmap</code> takes a vector of edges where the shifts occur, and return a
simmap formatted tree, mapped with corresponding regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shifts_to_simmap(tree, shifts_edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shifts_to_simmap_+3A_tree">tree</code></td>
<td>
<p>input tree in <code><a href="ape.html#topic+phylo">phylo</a></code> format</p>
</td></tr>
<tr><td><code id="shifts_to_simmap_+3A_shifts_edges">shifts_edges</code></td>
<td>
<p>shifts positions on the edges</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ancestral state is always 0, and other states are consecutive integers.
</p>


<h3>Value</h3>

<p>tree a simmap object
</p>

<hr>
<h2 id='shifts.list_to_matrix'>Compute the matrix of shifts.</h2><span id='topic+shifts.list_to_matrix'></span>

<h3>Description</h3>

<p><code>shifts.list_to_matrix</code> takes the list description of the shifts 
to give the matrix representation of the shifts : the b th element of 
the lth line has the value of the shift on character l occurring on that branch b
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shifts.list_to_matrix(phy, shifts, p = nrow(shifts$values))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shifts.list_to_matrix_+3A_phy">phy</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="shifts.list_to_matrix_+3A_shifts">shifts</code></td>
<td>
<p>list description of the shifts : shifts$edges, shifts$values.</p>
</td></tr>
<tr><td><code id="shifts.list_to_matrix_+3A_p">p</code></td>
<td>
<p>number of traits (optional, needed when shifts = NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix p x Nedge of length nbranch.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shifts.matrix_to_list">shifts.matrix_to_list</a></code>
</p>

<hr>
<h2 id='shifts.list_to_vector'>Compute the vector of shifts.</h2><span id='topic+shifts.list_to_vector'></span>

<h3>Description</h3>

<p><code>shifts.list_to_vector</code> takes the list description of the shifts 
to give the vectorial representation of the shifts : the b th element of 
the vector has the value of the shift occurring on that branch b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shifts.list_to_vector(phy, shifts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shifts.list_to_vector_+3A_phy">phy</code></td>
<td>
<p>Input tree.</p>
</td></tr>
<tr><td><code id="shifts.list_to_vector_+3A_shifts">shifts</code></td>
<td>
<p>: list description of the shifts : shifts$edges, shifts$values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of length nbranch.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shifts.vector_to_list">shifts.vector_to_list</a></code>
</p>

<hr>
<h2 id='shifts.matrix_to_list'>Compute the list of shifts.</h2><span id='topic+shifts.matrix_to_list'></span>

<h3>Description</h3>

<p><code>shifts.matrix_to_list</code> takes the vectorial description of the shifts 
to create the list description of the shifts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shifts.matrix_to_list(delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shifts.matrix_to_list_+3A_delta">delta</code></td>
<td>
<p>matrix description of the shift.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing shifts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shifts.list_to_matrix">shifts.list_to_matrix</a></code>
</p>

<hr>
<h2 id='shifts.vector_to_list'>Compute the list of shifts.</h2><span id='topic+shifts.vector_to_list'></span>

<h3>Description</h3>

<p><code>shifts.vector_to_list</code> takes the vectorial description of the shifts 
to create the list description of the shifts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shifts.vector_to_list(delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shifts.vector_to_list_+3A_delta">delta</code></td>
<td>
<p>: vector description of the shift.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of length nbranch.
</p>


<h3>See Also</h3>

<p><code>shifts.list_to_vector</code>
</p>

<hr>
<h2 id='simul_process'>Simulate a Stochastic Process on a tree</h2><span id='topic+simul_process'></span><span id='topic+simul_process.params_process'></span><span id='topic+simul_process.PhyloEM'></span>

<h3>Description</h3>

<p><code>simulate</code> simulate a stochastic process on a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul_process(x, ...)

## S3 method for class 'params_process'
simul_process(
  x,
  phylo,
  simulate_random = TRUE,
  checks = TRUE,
  U_tree = NULL,
  times_shared = NULL,
  ...
)

## S3 method for class 'PhyloEM'
simul_process(
  x,
  simulate_random = TRUE,
  checks = TRUE,
  U_tree = NULL,
  times_shared = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul_process_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+params_process">params_process</a></code> or <code><a href="#topic+PhyloEM">PhyloEM</a></code>.</p>
</td></tr>
<tr><td><code id="simul_process_+3A_...">...</code></td>
<td>
<p>for a <code>PhyloEM</code> object, further arguments to be passed on to
<code><a href="#topic+params_process.PhyloEM">params_process.PhyloEM</a></code> (to choose which parameters to extract from
the results, see documentation of this function).</p>
</td></tr>
<tr><td><code id="simul_process_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="simul_process_+3A_simulate_random">simulate_random</code></td>
<td>
<p>set to FALSE if only the expected values are needed
(and not the random sample). Default to TRUE.</p>
</td></tr>
<tr><td><code id="simul_process_+3A_checks">checks</code></td>
<td>
<p>whether to check the entry parameters for consistency. Default 
to TRUE.</p>
</td></tr>
<tr><td><code id="simul_process_+3A_u_tree">U_tree</code></td>
<td>
<p>optional, full incidence matrix of the tree, result of function
<code><a href="#topic+incidence.matrix.full">incidence.matrix.full</a></code>. Can be specified to avoid extra computations.</p>
</td></tr>
<tr><td><code id="simul_process_+3A_times_shared">times_shared</code></td>
<td>
<p>optional, times of shared ancestry of all nodes and tips,
result of function <code><a href="#topic+compute_times_ca">compute_times_ca</a></code>. Can be specified to avoid extra
computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>simul_process</code>. This contains:
</p>

<dl>
<dt>sim_traits</dt><dd><p>an array with dimensions p x Nnode x 2 (BM)
or p x Nnode x 3 (OU). For each trait t, 1 &lt;= t &lt;= p, sim_traits[t, , ] has
tree columns, containing respectively the simulated state,
expected value and optimal value for all the nodes.</p>
</dd>
<dt>phylo</dt><dd><p>the phylogenetic tree used for the simulations (class <code>phylo</code>).</p>
</dd>
<dt>params</dt><dd><p>the parameters used for the simulations
(class <code>params_proces</code>).</p>
</dd>
</dl>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>simul_process(params_process)</code>: <code><a href="#topic+params_process">params_process</a></code> object
</p>
</li>
<li> <p><code>simul_process(PhyloEM)</code>: <code><a href="#topic+PhyloEM">PhyloEM</a></code> object
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+params_process">params_process</a></code>, <code><a href="#topic+PhyloEM">PhyloEM</a></code>, <code><a href="#topic+extract.simul_process">extract.simul_process</a></code>
</p>

<hr>
<h2 id='simulate_internal'>Simulate a Stochastic Process on a tree</h2><span id='topic+simulate_internal'></span>

<h3>Description</h3>

<p><code>simulate_internal</code> simulate a stochastic process on a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_internal(
  phylo,
  process = c("BM", "OU", "scOU", "OUBM", "StudentOU"),
  p = 1,
  root.state = list(random = FALSE, stationary.root = FALSE, value.root = NA, exp.root =
    NA, var.root = NA),
  shifts = list(edges = NULL, values = NULL, relativeTimes = NULL),
  eps = 10^(-6),
  selection.strength = NULL,
  variance = NULL,
  optimal.value = NULL,
  checks = TRUE,
  simulate_random = TRUE,
  U_tree = NULL,
  times_shared = NULL,
  df = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_internal_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree, class <code><a href="ape.html#topic+phylo">phylo</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_internal_+3A_process">process</code></td>
<td>
<p>The model used for the simulation. One of &quot;BM&quot; (for a full BM
model, univariate or multivariate); &quot;OU&quot; (for a full OU model, univariate or
multivariate); or &quot;scOU&quot; (for a &quot;scalar OU&quot; model).</p>
</td></tr>
<tr><td><code id="simulate_internal_+3A_p">p</code></td>
<td>
<p>Dimension of the simulated trait</p>
</td></tr>
<tr><td><code id="simulate_internal_+3A_root.state">root.state</code></td>
<td>
<p>List describing the state of the root, with:
</p>

<dl>
<dt>random</dt><dd><p>random state (TRUE) or deterministic state (FALSE)</p>
</dd>
<dt>value.root</dt><dd><p>if deterministic, value of the character at the root</p>
</dd>
<dt>exp.root</dt><dd><p>if random, expectation of the character at the root</p>
</dd>
<dt>var.root</dt><dd><p>if random, variance of the character at the root (pxp matrix)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="simulate_internal_+3A_shifts">shifts</code></td>
<td>
<p>List with position and values of the shifts :
</p>

<dl>
<dt>edges</dt><dd><p>vector of the K id of edges where the shifts are</p>
</dd>
<dt>values</dt><dd><p>matrix p x K of values of the shifts on the edges
(one column = one shift)</p>
</dd>
<dt>relativeTimes</dt><dd><p>vector of dimension K of relative time of the shift from the parent node of edges</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="simulate_internal_+3A_eps">eps</code></td>
<td>
<p>Tolerance for the value of the norm 1 of the selection strength matrix for OU</p>
</td></tr>
<tr><td><code id="simulate_internal_+3A_selection.strength">selection.strength</code></td>
<td>
<p>Matrix of selection strength size p x p (OU)</p>
</td></tr>
<tr><td><code id="simulate_internal_+3A_variance">variance</code></td>
<td>
<p>Variance-covariance matrix size p x p</p>
</td></tr>
<tr><td><code id="simulate_internal_+3A_optimal.value">optimal.value</code></td>
<td>
<p>Vector of p optimal values at the root (OU)</p>
</td></tr>
<tr><td><code id="simulate_internal_+3A_checks">checks</code></td>
<td>
<p>whether to check the entry parameters for consistency. Default 
to TRUE.</p>
</td></tr>
<tr><td><code id="simulate_internal_+3A_simulate_random">simulate_random</code></td>
<td>
<p>set to FALSE if only the expected values are needed
(and not the random sample). Default to TRUE.</p>
</td></tr>
<tr><td><code id="simulate_internal_+3A_u_tree">U_tree</code></td>
<td>
<p>optional, full incidence matrix of the tree, result of function
<code>incidence.matrix.full</code>.</p>
</td></tr>
<tr><td><code id="simulate_internal_+3A_times_shared">times_shared</code></td>
<td>
<p>optional, times of shared ancestry of all nodes and tips,
result of function <code><a href="#topic+compute_times_ca">compute_times_ca</a></code>. Can be specified to avoid extra
computations.</p>
</td></tr>
<tr><td><code id="simulate_internal_+3A_df">df</code></td>
<td>
<p>if the process is &quot;StudentOU&quot;, the number of degree of freedom of
the chosen student law. default to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>paramSimu An array with dimensions p x Nnode x 2 (BM)
or p x Nnode x 3 (OU). For each trait t, 1 &lt;= t &lt;= p, paramSimu[t, , ] has
tree columns, containing respectively the simulated state,
expected value and optimal value for all the nodes.
</p>

<hr>
<h2 id='split_params_independent'>Split independent parameters into a list of parameters</h2><span id='topic+split_params_independent'></span>

<h3>Description</h3>

<p><code>split_params_independent</code> split a params object for a 
process with p independent traits into p params objects.
The reverse operation is done by <code>merge_params_independent</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_params_independent(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_params_independent_+3A_params">params</code></td>
<td>
<p>parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of p parameters
</p>

<hr>
<h2 id='sum_partitions'>Sum on all subsets.</h2><span id='topic+sum_partitions'></span>

<h3>Description</h3>

<p><code>sum_partitions</code> returns the sum on all I subset of [1,p], with |I|&gt;m.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_partitions(A, N, K, p, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_partitions_+3A_a">A</code></td>
<td>
<p>a matrix with p rows and K column. Each row contains the number of
marked partition in 1&lt;=k&lt;=K groups for one of the p children of a
given node.</p>
</td></tr>
<tr><td><code id="sum_partitions_+3A_n">N</code></td>
<td>
<p>a matrix with p rows and K column. Each row contains the number of
partition in 1&lt;=k&lt;=K groups for one of the p children of a given node</p>
</td></tr>
<tr><td><code id="sum_partitions_+3A_k">K</code></td>
<td>
<p>an integer. The number of groups wanted.</p>
</td></tr>
<tr><td><code id="sum_partitions_+3A_p">p</code></td>
<td>
<p>an integer. The number of daughters of a node.</p>
</td></tr>
<tr><td><code id="sum_partitions_+3A_m">m</code></td>
<td>
<p>an integer. The minimum cardinal of a subset allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies <code>sum_partitions.cardFixed</code> to all integer between
m and p, and sum the results.
</p>


<h3>Value</h3>

<p>double : the result of the sum.
</p>

<hr>
<h2 id='sum_partitions.cardFixed'>Sum on subsets of a given cardinal.</h2><span id='topic+sum_partitions.cardFixed'></span>

<h3>Description</h3>

<p><code>sum_partitions.cardFixed</code> returns the sum on I subset of [1,p], |I|
fixed, of the sums computed by <code>sum_prod.comb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_partitions.cardFixed(A, N, K, p, cardI)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_partitions.cardFixed_+3A_a">A</code></td>
<td>
<p>a matrix with p rows and K column. Each row contains the number of
marked partition in 1&lt;=k&lt;=K groups for one of the p children of a
given node.</p>
</td></tr>
<tr><td><code id="sum_partitions.cardFixed_+3A_n">N</code></td>
<td>
<p>a matrix with p rows and K column. Each row contains the number of
partition in 1&lt;=k&lt;=K groups for one of the p children of a given node</p>
</td></tr>
<tr><td><code id="sum_partitions.cardFixed_+3A_k">K</code></td>
<td>
<p>an integer. The number of groups wanted.</p>
</td></tr>
<tr><td><code id="sum_partitions.cardFixed_+3A_p">p</code></td>
<td>
<p>an integer. The number of daughters of a node.</p>
</td></tr>
<tr><td><code id="sum_partitions.cardFixed_+3A_cardi">cardI</code></td>
<td>
<p>an integer. The cardinal of the subset wanted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code>combn</code> to enumerate all the subsets I of [1,p] of
a given cardinal, and then performs the wanted sum on these subsets.
</p>


<h3>Value</h3>

<p>double : the result of the sum.
</p>

<hr>
<h2 id='sum_prod.comb'>Sum on a simplex</h2><span id='topic+sum_prod.comb'></span>

<h3>Description</h3>

<p><code>sum_prod.comb</code> returns the sum on k_1+...+k_p=K+|I|-1, k_i&gt;0 of the
products of prod(A[i,k_i], i in I)*prod(N[i,k_i], i not in I).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_prod.comb(I, A, N, K, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_prod.comb_+3A_i">I</code></td>
<td>
<p>a vector of integers representing a subset of [1,p]</p>
</td></tr>
<tr><td><code id="sum_prod.comb_+3A_a">A</code></td>
<td>
<p>a matrix with p rows and K column. Each row contains the number of
marked partition in 1&lt;=k&lt;=K groups for one of the p children of a
given node.</p>
</td></tr>
<tr><td><code id="sum_prod.comb_+3A_n">N</code></td>
<td>
<p>a matrix with p rows and K column. Each row contains the number of
partition in 1&lt;=k&lt;=K groups for one of the p children of a given node</p>
</td></tr>
<tr><td><code id="sum_prod.comb_+3A_k">K</code></td>
<td>
<p>an integer. The number of groups wanted.</p>
</td></tr>
<tr><td><code id="sum_prod.comb_+3A_p">p</code></td>
<td>
<p>an integer. The number of daughters of a node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code>sum_simplex</code> to perform the wanted sum on a ad-hoc
matrix, combination of rows of A and N.
</p>


<h3>Value</h3>

<p>double : the result of the sum.
</p>

<hr>
<h2 id='sum_simplex'>Sum on a simplex</h2><span id='topic+sum_simplex'></span>

<h3>Description</h3>

<p><code>sum_simplex</code> returns the sum on k_1+...+k_p=K, k_i&gt;0 of the products
of NN[i,k_i].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_simplex(NN, K, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_simplex_+3A_nn">NN</code></td>
<td>
<p>a matrix with p rows and K column. Each row contains the number of
partition in 1&lt;=k&lt;=K groups for one of the p children of a given node</p>
</td></tr>
<tr><td><code id="sum_simplex_+3A_k">K</code></td>
<td>
<p>an integer. The number of groups wanted.</p>
</td></tr>
<tr><td><code id="sum_simplex_+3A_p">p</code></td>
<td>
<p>an integer. The number of daughters of a node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code>xsimplex</code> to perform the product of NN[i,k_i] for
all combination of k_i such that k_1+...+k_p=K, k_i&gt;0, using function
<code>prod_index</code>. Then sum all the products.
</p>


<h3>Value</h3>

<p>double : the result of the sum.
</p>

<hr>
<h2 id='test.root.state'>Test state of root.</h2><span id='topic+test.root.state'></span>

<h3>Description</h3>

<p><code>test.root.state</code> test whether the parameters of root.state given
by the user are coherent. If not, it returns a new corrected list to
define root.state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.root.state(root.state, process = c("BM", "OU", "scOU", "OUBM"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.root.state_+3A_root.state">root.state</code></td>
<td>
<p>A list giving the root state</p>
</td></tr>
<tr><td><code id="test.root.state_+3A_process">process</code></td>
<td>
<p>&quot;BM&quot;, &quot;OU&quot; or &quot;scOU&quot;</p>
</td></tr>
<tr><td><code id="test.root.state_+3A_...">...</code></td>
<td>
<p>parameters of the process (if OU)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To test coherence, the following priorities are applied:
random &gt; stationary.root &gt; values.root = exp.root = var.root
</p>


<h3>Value</h3>

<p>Coherent list root.state.
</p>

<hr>
<h2 id='transform_branch_length'>Transform branch length for a re-scaled BM</h2><span id='topic+transform_branch_length'></span>

<h3>Description</h3>

<p>Re-scale the branch length of the tree so that a BM running
on the new tree produces the same observations at the tips than an OU with
parameter alpha.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_branch_length(phylo, alp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_branch_length_+3A_phylo">phylo</code></td>
<td>
<p>A phylogenetic tree of class <code><a href="ape.html#topic+phylo">phylo</a></code>, with branch
lengths.</p>
</td></tr>
<tr><td><code id="transform_branch_length_+3A_alp">alp</code></td>
<td>
<p>Value of the selection strength.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phylo The same phylogenetic tree, with transformed branch lengths.
</p>

<hr>
<h2 id='transform_shifts_values'>Transform the shift values</h2><span id='topic+transform_shifts_values'></span>

<h3>Description</h3>

<p><code>transform_shifts_values</code> takes the shifts generating a given expectation structure
given an OU with alpha = from, and gives back the equivalent shifts values that produce the
same structure with an OU with alpha = to. If from or to is 0, then the process is supposed
to be a BM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_shifts_values(shifts, from = 0, to, phylo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_shifts_values_+3A_shifts">shifts</code></td>
<td>
<p>the shifts on the original process</p>
</td></tr>
<tr><td><code id="transform_shifts_values_+3A_from">from</code></td>
<td>
<p>alpha value of the original process. If equals 0, then the original process is 
taken to be a BM.</p>
</td></tr>
<tr><td><code id="transform_shifts_values_+3A_to">to</code></td>
<td>
<p>alpha value of the destination process</p>
</td></tr>
<tr><td><code id="transform_shifts_values_+3A_phylo">phylo</code></td>
<td>
<p>the phylogenetic tree (un-scaled)</p>
</td></tr>
</table>

<hr>
<h2 id='update.allocate_regimes_from_shifts'>Update function for regime allocation.</h2><span id='topic+update.allocate_regimes_from_shifts'></span>

<h3>Description</h3>

<p><code>update.allocate_regimes_from_shifts</code> computes the regime of a daughter 
node, knowing the regime at the parent node and the vector of shifts positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update.allocate_regimes_from_shifts(edgeNbr, ancestral, shifts_edges, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.allocate_regimes_from_shifts_+3A_edgenbr">edgeNbr</code></td>
<td>
<p>: Number of the edge considered</p>
</td></tr>
<tr><td><code id="update.allocate_regimes_from_shifts_+3A_ancestral">ancestral</code></td>
<td>
<p>: regime of the parent node</p>
</td></tr>
<tr><td><code id="update.allocate_regimes_from_shifts_+3A_shifts_edges">shifts_edges</code></td>
<td>
<p>positions on edges</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in function <code>allocate_regimes_from_shifts</code> and is 
designed to furnish function <code>recursionDown</code> with the right structure of
data.
</p>


<h3>Value</h3>

<p>regime of the daughter node.
</p>

<hr>
<h2 id='update.compute_betas_from_shifts'>Update function for optimal value computation</h2><span id='topic+update.compute_betas_from_shifts'></span>

<h3>Description</h3>

<p><code>update.compute_betas_from_shifts</code> computes the optimal value at a daughter node, 
knowing the optimal value at the parent node and the vector of shifts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update.compute_betas_from_shifts(edgeNbr, ancestral, shifts, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.compute_betas_from_shifts_+3A_edgenbr">edgeNbr</code></td>
<td>
<p>: Number of the edge considered</p>
</td></tr>
<tr><td><code id="update.compute_betas_from_shifts_+3A_ancestral">ancestral</code></td>
<td>
<p>: Computed vector for the parental node</p>
</td></tr>
<tr><td><code id="update.compute_betas_from_shifts_+3A_shifts">shifts</code></td>
<td>
<p>position and values of the shifts</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in function <code>compute_betas_from_shifts</code> and is designed to 
furnish function <code>recursionDown</code> with the right structure of data.
</p>


<h3>Value</h3>

<p>Updated matrix of size (Nnode + ntaxa)x1.
</p>

<hr>
<h2 id='update.enumerate_parsimony'>Actualization of the enumeration.</h2><span id='topic+update.enumerate_parsimony'></span>

<h3>Description</h3>

<p><code>update.enumerate_parsimony</code> is used in function <code>enumerate_parsimony</code>, 
and compute the solution for the parent node, given its children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update.enumerate_parsimony(
  daughters,
  daughtersParams,
  parent,
  cost,
  clus,
  pos,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.enumerate_parsimony_+3A_daughters">daughters</code></td>
<td>
<p>vector of daughters nodes.</p>
</td></tr>
<tr><td><code id="update.enumerate_parsimony_+3A_daughtersparams">daughtersParams</code></td>
<td>
<p>list with length(daughters) entries, each entry being a 
list of k matrices representing the possible allocations starting from daughter.</p>
</td></tr>
<tr><td><code id="update.enumerate_parsimony_+3A_parent">parent</code></td>
<td>
<p>the parent node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a list with L entries corresponding to the children of a node,
and compute, for all the regimes, the possible allocations starting with parent
node in that regime. It uses functions <code>select.matrices</code> to select the
possible states of the children, and <code>matrix_of_possibles</code> to find the 
possible states.
</p>


<h3>Value</h3>

<p>A list of size nclus, each entry being a matrix representing the possible 
allocations starting with node parent in state k.
</p>

<hr>
<h2 id='update.incidence.matrix'>Update function for incidence matrix</h2><span id='topic+update.incidence.matrix'></span>

<h3>Description</h3>

<p><code>update.incidence.matrix</code> updates the matrix initialized in 
<code>init.incidence.matrix</code> for the computation of the incidence matrix
in <code>incidence.matrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update.incidence.matrix(daughtersParams, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.incidence.matrix_+3A_daughtersparams">daughtersParams</code></td>
<td>
<p>: rows of updated matrix corresponding to the
daughters of the current node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A node belongs to all the lineages of its daughters.
</p>


<h3>Value</h3>

<p>Vector of length ntaxa, indicating to which lineages the branch
above the current node belongs to.
</p>

<hr>
<h2 id='update.incidence.matrix.full'>Update function for incidence matrix</h2><span id='topic+update.incidence.matrix.full'></span>

<h3>Description</h3>

<p><code>update.incidence.matrix.full</code> updates the matrix initialized in 
<code>init.incidence.matrix.full</code> for the computation of the incidence matrix
in <code>incidence.matrix.full</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update.incidence.matrix.full(daughtersParams, parent, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.incidence.matrix.full_+3A_daughtersparams">daughtersParams</code></td>
<td>
<p>: rows of updated matrix corresponding to the
daughters of the current node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A node belongs to all the lineages of its daughters.
</p>


<h3>Value</h3>

<p>Vector of length ntaxa + Nnode, indicating to which lineages the 
branch above the current node belongs to.
</p>

<hr>
<h2 id='update.parsimonyCost'>Actualization for parsimonyCost.</h2><span id='topic+update.parsimonyCost'></span>

<h3>Description</h3>

<p><code>update.parsimonyCost</code> compute the line vector of a parent node, given
the vectors of its daughters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update.parsimonyCost(daughtersParams, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.parsimonyCost_+3A_daughtersparams">daughtersParams</code></td>
<td>
<p>a (ndaughters) x (nclus) matrix with the line vectors of the cost
for the daughters node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the cost of putting the parent in a state k, as the 
minimum number of shifts needed to get the given clustering of the trees bellow
parental node.
</p>


<h3>Value</h3>

<p>A line vector corresponding to the parent node.
</p>

<hr>
<h2 id='update.parsimonyNumber'>Actualization for parsimonyNumber.</h2><span id='topic+update.parsimonyNumber'></span>

<h3>Description</h3>

<p><code>update.parsimonyNumber</code> compute the line vector of a parent node, given
the vectors of its daughters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update.parsimonyNumber(daughters, daughtersParams, cost, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.parsimonyNumber_+3A_daughters">daughters</code></td>
<td>
<p>the identifiers of the daughters nodes.</p>
</td></tr>
<tr><td><code id="update.parsimonyNumber_+3A_daughtersparams">daughtersParams</code></td>
<td>
<p>a ndaughters x (nclus) matrix with the line vectors of the number of
solutions for the daughters nodes.</p>
</td></tr>
<tr><td><code id="update.parsimonyNumber_+3A_cost">cost</code></td>
<td>
<p>the (ntaxa + Nnode) x nclus matrix of costs (computed by <code>parsimonyCost</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses function <code>compute_state_filter</code> to find all the admissible
states of the daughters, given a starting state for the parent.
</p>


<h3>Value</h3>

<p>A line vector corresponding to the parent node.
</p>

<hr>
<h2 id='update.partitionsNumber.gen'>Update formula in the general case</h2><span id='topic+update.partitionsNumber.gen'></span>

<h3>Description</h3>

<p><code>update.partitionsNumber.gen</code> apply the actualization formula to get
Nk and Ak of a node given its daughters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update.partitionsNumber.gen(daughtersParams, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.partitionsNumber.gen_+3A_daughtersparams">daughtersParams</code></td>
<td>
<p>: matrix with 2*npart columns. Each row contains
the result of partitionsNumber for the children of a given node</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses functions <code>sum_partitions</code> and <code>sum_simplex</code> to compute
the needed sums.
</p>


<h3>Value</h3>

<p>vector of size 2*npart. For k=1:npart it contains the number of
partitions with k groups compatible with the sub tree starting at the
current node ; and for k=(npart+1):2*npart, it contains the number of
&quot;marked&quot; partitions with (k-npart) groups compatible with the sub tree
starting at the current node.
</p>

<hr>
<h2 id='wrapper_E_step'>Wrapper for E step in EM</h2><span id='topic+wrapper_E_step'></span>

<h3>Description</h3>

<p><code>wrapper_E_step</code> is used in the EM algorithm. It calls itself
recursively in case of independent parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapper_E_step(
  phylo,
  times_shared,
  distances_phylo,
  process,
  params_old,
  masque_data,
  F_moments,
  independent,
  Y_data_vec_known,
  miss,
  Y_data,
  U_tree,
  compute_E
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
