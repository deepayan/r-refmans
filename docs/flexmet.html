<!DOCTYPE html><html><head><title>Help for package flexmet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flexmet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#b2greek'><p>Find the Greek-Letter Parameterization corresponding to a b Vector of</p>
Item Parameters</a></li>
<li><a href='#fmp'><p>Estimate FMP Item Parameters</p></a></li>
<li><a href='#get_surrogates'><p>Find Theta Surrogates</p></a></li>
<li><a href='#greek2b'><p>Find the b Vector from a Greek-Letter Parameterization of Item Parameters.</p></a></li>
<li><a href='#iif_fmp'><p>FMP Item Information Function</p></a></li>
<li><a href='#int_mat'><p>Numerical Integration Matrix</p></a></li>
<li><a href='#inv_poly'><p>Polynomial Functions</p></a></li>
<li><a href='#irf_fmp'><p>FMP Item Response Function</p></a></li>
<li><a href='#linking'><p>Linear and Nonlinear Item Parameter Linking</p></a></li>
<li><a href='#rimse'><p>Root Integrated Mean Squared Difference Between FMP IRFs</p></a></li>
<li><a href='#sim_bmat'><p>Randomly Generate FMP Parameters</p></a></li>
<li><a href='#sim_data'><p>Simulate FMP Data</p></a></li>
<li><a href='#th_est_ml'><p>Latent Trait Estimation</p></a></li>
<li><a href='#transform_b'><p>Transform FMP Item Parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Flexible Latent Trait Metrics using the Filtered Monotonic
Polynomial Item Response Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Application of the filtered monotonic polynomial (FMP) item response
    model to flexibly fit item response models. The package includes tools that
    allow the item response model to be build on any monotonic transformation of
    the latent trait metric, as described by Feuerstahler (2019) &lt;<a href="https://doi.org/10.1007%2Fs11336-018-9642-9">doi:10.1007/s11336-018-9642-9</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>MonoPoly, knitr, rmarkdown, mirt</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-13 19:56:49 UTC; Leah</td>
</tr>
<tr>
<td>Author:</td>
<td>Leah Feuerstahler [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leah Feuerstahler &lt;lfeuerstahler@fordham.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-13 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='b2greek'>Find the Greek-Letter Parameterization corresponding to a b Vector of
Item Parameters</h2><span id='topic+b2greek'></span>

<h3>Description</h3>

<p>Convert the b vector of item parameters (polynomial coefficients) to the
corresponding Greek-letter parameterization (used to ensure monotonicitiy).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b2greek(bvec, ncat = 2, eps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2greek_+3A_bvec">bvec</code></td>
<td>
<p>b vector of item parameters (i.e., polynomial coefficients).</p>
</td></tr>
<tr><td><code id="b2greek_+3A_ncat">ncat</code></td>
<td>
<p>Number of response categories (first ncat - 1 elements of bvec
are intercepts)</p>
</td></tr>
<tr><td><code id="b2greek_+3A_eps">eps</code></td>
<td>
<p>Convergence tolerance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+greek2b">greek2b</a> for more information about the b (polynomial
coefficient) and Greek-letter parameterizations of the FMP model.
</p>


<h3>Value</h3>

<p>A vector of item parameters in the Greek-letter parameterization.
</p>


<h3>References</h3>

<p>Liang, L., &amp; Browne, M. W. (2015). A quasi-parametric method for
fitting flexible item response functions. <em>Journal of Educational and
Behavioral Statistics</em>, <em>40</em>, 5&ndash;34. doi: <a href="https://doi.org/10.3102/1076998614556816">10.3102/1076998614556816</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+greek2b">greek2b</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(bvec &lt;- greek2b(xi = 0, omega = 1, alpha = c(.1, .1), tau = c(-2, -2)))
## 0.00000000  2.71828183 -0.54365637  0.29961860 -0.03950623  0.01148330

(b2greek(bvec))
##  0.0  1.0  0.1 -2.0  0.1 -2.0

</code></pre>

<hr>
<h2 id='fmp'>Estimate FMP Item Parameters</h2><span id='topic+fmp'></span><span id='topic+fmp_1'></span>

<h3>Description</h3>

<p>Estimate FMP item parameters for a single item using user-specified
theta values (fixed-effects) using fmp_1, or estimate FMP item parameters
for multiple items using fixed-effects or random-effects with fmp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmp_1(
  dat,
  k,
  tsur,
  start_vals = NULL,
  method = "CG",
  priors = list(xi = c("none", NaN, NaN), omega = c("none", NaN, NaN), alpha =
    c("none", NaN, NaN), tau = c("none", NaN, NaN)),
  ...
)

fmp(
  dat,
  k,
  start_vals = NULL,
  em = TRUE,
  eps = 1e-04,
  n_quad = 49,
  method = "CG",
  max_em = 500,
  priors = list(xi = c("none", NaN, NaN), omega = c("none", NaN, NaN), alpha =
    c("none", NaN, NaN), tau = c("none", NaN, NaN)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmp_+3A_dat">dat</code></td>
<td>
<p>Vector of item responses for N (# subjects) examinees. Binary 
data should be coded 0/1, and polytomous data should be coded 0, 1, 2, etc.</p>
</td></tr>
<tr><td><code id="fmp_+3A_k">k</code></td>
<td>
<p>Vector of item complexities for each item, see details. If
k &lt; ncol(dat), k's will be recycled.</p>
</td></tr>
<tr><td><code id="fmp_+3A_tsur">tsur</code></td>
<td>
<p>Vector of N (# subjects) surrogate theta values.</p>
</td></tr>
<tr><td><code id="fmp_+3A_start_vals">start_vals</code></td>
<td>
<p>Start values, For fmp_1, a vector of length 2k+2 in the
following order:
</p>
<p>If k = 0: (xi_1, ..., x_C_i - 1, omega)
</p>
<p>If k = 1: (xi_1, ..., x_C_i - 1, omega, alpha1, tau1)
</p>
<p>If k = 2: (xi_1, ..., x_C_i - 1, omega, alpha1, tau1, alpha2, tau2)
</p>
<p>and so forth. For fmp, add start values for item 1, followed by those for
item 2, and so forth. For further help, first fit the model without start
values, then inspect the outputted parmat data frame.</p>
</td></tr>
<tr><td><code id="fmp_+3A_method">method</code></td>
<td>
<p>Optimization method passed to optim.</p>
</td></tr>
<tr><td><code id="fmp_+3A_priors">priors</code></td>
<td>
<p>List of prior information used to estimate the item parameters.
The list should have up to 4 elements named xi, omega, alpha, tau. Each list
should be a vector of length 3: the name of the prior distribution (&quot;norm&quot; or
&quot;none&quot;), the first parameter of the prior distribution, and the second
parameter of the prior distribution. Currently, &quot;norm&quot; and 'none&quot; are the
only available prior distributions.</p>
</td></tr>
<tr><td><code id="fmp_+3A_em">em</code></td>
<td>
<p>If &quot;mirt&quot;, use the mirt (Chalmers, 2012) package to estimate
item parameters. If TRUE, random-effects estimation is used via the EM
algorithm. If FALSE, fixed effects estimation is used with theta
surrogates.</p>
</td></tr>
<tr><td><code id="fmp_+3A_eps">eps</code></td>
<td>
<p>Covergence tolerance for the EM algorithm. The EM algorithm is
said to converge is the maximum absolute difference between parameter
estimates for successive iterations is less than eps. Ignored if em = FALSE.</p>
</td></tr>
<tr><td><code id="fmp_+3A_n_quad">n_quad</code></td>
<td>
<p>Number of quadrature points for EM integration. Ignored if
em = FALSE</p>
</td></tr>
<tr><td><code id="fmp_+3A_max_em">max_em</code></td>
<td>
<p>Maximum number of EM iterations (for em = TRUE only).</p>
</td></tr>
<tr><td><code id="fmp_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to optim (if em != &quot;mirt&quot;) or mirt
(if em == &quot;mirt&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The FMP item response function for a single item <code class="reqn">i</code> with 
responses in categories <code class="reqn">c = 0, ..., C_i - 1</code> is specified using the 
composite function,
</p>
<p style="text-align: center;"><code class="reqn">P(X_i = c | \theta) = exp(\sum_{v=0}^c(b_0i_{v} + m_i(\theta))) / 
(\sum_{u=0}^{C_i - 1} exp(\sum_{v=0}^u(b_{0i_{v}} + m_i(\theta)))) </code>
</p>

<p>where <code class="reqn">m(\theta)</code> is an unbounded and monotonically increasing polynomial
function of the latent trait <code class="reqn">\theta</code>, excluding the intercept (s). 
</p>
<p>The item complexity parameter <code class="reqn">k</code> controls the degree of the polynomial:
</p>
<p style="text-align: center;"><code class="reqn">m(\theta)=b_1\theta+b_2\theta^{2}+...+b_{2k+1}
\theta^{2k+1},</code>
</p>

<p>where <code class="reqn">2k+1</code> equals the order of the polynomial,
<code class="reqn">k</code> is a nonnegative integer, and
</p>
<p style="text-align: center;"><code class="reqn">b=(b1,...,b(2k+1))'</code>
</p>

<p>are item parameters that define the location and shape of the IRF. The
vector <code class="reqn">b</code> is called the b-vector parameterization of the FMP Model.
When <code class="reqn">k=0</code>, the FMP IRF equals either the slope-threshold 
parameterization of the two-parameter item response model (if maxncat = 2) 
or Muraki's (1992) generalized partial credit model (if maxncat &gt; 2).
</p>
<p>For <code class="reqn">m(\theta)</code> to be a monotonic function, the FMP IRF can also be
expressed as a function of the vector
</p>
<p style="text-align: center;"><code class="reqn">\gamma = (\xi, \omega, \alpha_1, \tau_1, \alpha_2, \tau_2,
\cdots \alpha_k,\tau_k)'.</code>
</p>

<p>The <code class="reqn">\gamma</code> vector is called the Greek-letter parameterization of the
FMP model. See Falk &amp; Cai (2016a), Feuerstahler (2016), or Liang &amp; Browne 
(2015) for details about the relationship between the b-vector and 
Greek-letter parameterizations.
</p>


<h3>Value</h3>

<table>
<tr><td><code>bmat</code></td>
<td>
<p>Matrix of estimated b-matrix parameters, each row corresponds
to an item, and contains b0, b1, ...b(max(k)).</p>
</td></tr>
<tr><td><code>parmat</code></td>
<td>
<p>Data frame of parameter estimation information, including the
Greek-letter parameterization, starting value, and parameter estimate.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Vector of item complexities chosen for each item.</p>
</td></tr>
<tr><td><code>log_lik</code></td>
<td>
<p>Model log likelihood.</p>
</td></tr>
<tr><td><code>mod</code></td>
<td>
<p>If em == &quot;mirt&quot;, the mirt object. Otherwise, optimization
information, including output from optim.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Model AIC.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Model BIC.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chalmers, R. P. (2012). mirt: A multidimensional item response theory
package for the R environment. <em>Journal of Statistical Software</em>,
<em>48</em>, 1&ndash;29. doi: <a href="https://doi.org/10.18637/jss.v048.i06">10.18637/jss.v048.i06</a>
</p>
<p>Elphinstone, C. D. (1983). A target distribution model for nonparametric
density estimation. <em>Communication in Statistics&ndash;Theory
and Methods</em>, <em>12</em>, 161&ndash;198. doi: <a href="https://doi.org/10.1080/03610928308828450">10.1080/03610928308828450</a>
</p>
<p>Elphinstone, C. D. (1985). <em>A method of distribution and density
estimation</em> (Unpublished dissertation). University of South Africa,
Pretoria, South Africa.
</p>
<p>Falk, C. F., &amp; Cai, L. (2016a). Maximum marginal likelihood estimation of a
monotonic polynomial generalized partial credit model with applications to
multiple group analysis. <em>Psychometrika</em>, <em>81</em>, 434&ndash;460.
doi: <a href="https://doi.org/10.1007/s11336-014-9428-7">10.1007/s11336-014-9428-7</a>
</p>
<p>Falk, C. F., &amp; Cai, L. (2016b). Semiparametric item response functions in
the context of guessing. <em>Journal of Educational Measurement</em>,
<em>53</em>, 229&ndash;247. doi: <a href="https://doi.org/10.1111/jedm.12111">10.1111/jedm.12111</a>
</p>
<p>Feuerstahler, L. M. (2016). <em>Exploring alternate latent trait metrics
with the filtered monotonic polynomial IRT model</em> (Unpublished dissertation).
University of Minnesota, Minneapolis, MN.
<a href="http://hdl.handle.net/11299/182267">http://hdl.handle.net/11299/182267</a>
</p>
<p>Feuerstahler, L. M. (2019). Metric Transformations and the Filtered
Monotonic Polynomial Item Response Model. <em>Psychometrika</em>, <em>84</em>,
105&ndash;123. doi: <a href="https://doi.org/10.1007/s11336-018-9642-9">10.1007/s11336-018-9642-9</a>
</p>
<p>Liang, L. (2007). <em>A semi-parametric approach to estimating item
response functions</em> (Unpublished dissertation). The Ohio
State University, Columbus, OH. Retrieved from https://etd.ohiolink.edu/
</p>
<p>Liang, L., &amp; Browne, M. W. (2015). A quasi-parametric method for
fitting flexible item response functions. <em>Journal of Educational
and Behavioral Statistics</em>, <em>40</em>, 5&ndash;34. doi: <a href="https://doi.org/10.3102/1076998614556816">10.3102/1076998614556816</a>
</p>
<p>Muraki, E. (1992). A generalized partial credit model: Application of an EM
algorithm. <em>Applied Psychological Measurement</em>, <em>16</em>, 159&ndash;176. 
doi: <a href="https://doi.org/10.1177/014662169201600206">10.1177/014662169201600206</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2345)
bmat &lt;- sim_bmat(n_items = 5, k = 2, ncat = 4)$bmat

theta &lt;- rnorm(50)
dat &lt;- sim_data(bmat = bmat, theta = theta, maxncat = 4)

## fixed-effects estimation for item 1

tsur &lt;- get_surrogates(dat)

# k = 0
fmp0_it_1 &lt;- fmp_1(dat = dat[, 1], k = 0, tsur = tsur)

# k = 1
fmp1_it_1 &lt;- fmp_1(dat = dat[, 1], k = 1, tsur = tsur)

## fixed-effects estimation for all items

fmp0_fixed &lt;- fmp(dat = dat, k = 0, em = FALSE)

## random-effects estimation


fmp0_random &lt;- fmp(dat = dat, k = 0, em = TRUE)


## random-effects estimation using mirt's estimation engine

fmp0_mirt &lt;- fmp(dat = dat, k = 0, em = "mirt")


</code></pre>

<hr>
<h2 id='get_surrogates'>Find Theta Surrogates</h2><span id='topic+get_surrogates'></span>

<h3>Description</h3>

<p>Compute surrogate theta values as the set of normalized first
principal component scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_surrogates(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_surrogates_+3A_dat">dat</code></td>
<td>
<p>Matrix of binary item responses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute surrogate theta values as the
normalized first principal component scores.
</p>


<h3>Value</h3>

<p>Vector of surrogate theta values.
</p>


<h3>References</h3>

<p>Liang, L., &amp; Browne, M. W. (2015). A quasi-parametric method for
fitting flexible item response functions. <em>Journal of Educational and
Behavioral Statistics</em>, <em>40</em>, 5&ndash;34. doi: <a href="https://doi.org/10.3102/1076998614556816">10.3102/1076998614556816</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2342)
bmat &lt;- sim_bmat(n_items = 5, k = 2)$bmat

theta &lt;- rnorm(50)
dat &lt;- sim_data(bmat = bmat, theta = theta)

tsur &lt;- get_surrogates(dat)

</code></pre>

<hr>
<h2 id='greek2b'>Find the b Vector from a Greek-Letter Parameterization of Item Parameters.</h2><span id='topic+greek2b'></span>

<h3>Description</h3>

<p>Convert the Greek-letter parameterization of item parameters (used to ensure
monotonicitiy) to the b-vector parameterization (polynomial coefficients).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greek2b(xi, omega, alpha = NULL, tau = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greek2b_+3A_xi">xi</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="greek2b_+3A_omega">omega</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="greek2b_+3A_alpha">alpha</code></td>
<td>
<p>see details, vector of length k, set to NULL if k = 0</p>
</td></tr>
<tr><td><code id="greek2b_+3A_tau">tau</code></td>
<td>
<p>see details, vector of length k, set to NULL if k = 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For
</p>
<p style="text-align: center;"><code class="reqn">m(\theta) = b_{0} + b_{1}\theta + b_{2}\theta^2 + \cdots +
b_{2k+1}\theta^{2k+1}</code>
</p>

<p>to be a monotonic function, a necessary and sufficient condition is that its
first derivative,
</p>
<p style="text-align: center;"><code class="reqn">p(\theta) = a_{0} + a_{1}\theta + ... + a_{2k}\theta^{2k},</code>
</p>

<p>is nonnegative at all theta. Here, let
</p>
<p style="text-align: center;"><code class="reqn">b_{0} = \xi</code>
</p>

<p>be the constant of integration and
</p>
<p style="text-align: center;"><code class="reqn">b_{s} = a_{s-1}/s</code>
</p>

<p>for <code class="reqn">s = 1, 2, ..., 2k+1</code>.
Notice that <code class="reqn">p(\theta)</code> is a polynomial function of degree <code class="reqn">2k</code>.
A nonnegative polynomial of an even degree can be re-expressed as the
product of k quadratic functions.
</p>
<p>If <code class="reqn">k \geq 1</code>:
</p>
<p style="text-align: center;"><code class="reqn">p(\theta) =  \exp{\omega} \Pi_{s=1}^{k}[1 - 2\alpha_{s}\theta +
(\alpha_{s}^2+ \exp(\tau_{s}))\theta^2]</code>
</p>

<p>If <code class="reqn">k = 0</code>:
</p>
<p style="text-align: center;"><code class="reqn">p(\theta) = 0.</code>
</p>



<h3>Value</h3>

<p>A vector of item parameters in the b parameterization.
</p>


<h3>References</h3>

<p>Liang, L., &amp; Browne, M. W. (2015). A quasi-parametric method for
fitting flexible item response functions. <em>Journal of Educational and
Behavioral Statistics</em>, <em>40</em>, 5&ndash;34. doi: <a href="https://doi.org/10.3102/1076998614556816">10.3102/1076998614556816</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+b2greek">b2greek</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(bvec &lt;- greek2b(xi = 0, omega = 1, alpha = .1, tau = -1))
## 0.0000000  2.7182818 -0.2718282  0.3423943

(b2greek(bvec))
##  0.0  1.0  0.1 -1.0

</code></pre>

<hr>
<h2 id='iif_fmp'>FMP Item Information Function</h2><span id='topic+iif_fmp'></span>

<h3>Description</h3>

<p>Find FMP item information
for user-supplied item and person parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iif_fmp(theta, bmat, maxncat = 2, cvec = NULL, dvec = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iif_fmp_+3A_theta">theta</code></td>
<td>
<p>Vector of latent trait parameters.</p>
</td></tr>
<tr><td><code id="iif_fmp_+3A_bmat">bmat</code></td>
<td>
<p>Items x parameters matrix of FMP item parameters (or a vector of
FMP item parameters for a single item).</p>
</td></tr>
<tr><td><code id="iif_fmp_+3A_maxncat">maxncat</code></td>
<td>
<p>Maximum number of response categories (the first maxncat - 1
columns of bmat are intercepts).</p>
</td></tr>
<tr><td><code id="iif_fmp_+3A_cvec">cvec</code></td>
<td>
<p>Optional vector of lower asymptote parameters. If cvec = NULL,
then all lower asymptotes set to 0.</p>
</td></tr>
<tr><td><code id="iif_fmp_+3A_dvec">dvec</code></td>
<td>
<p>Optional vector of upper asymptote parameters. If dvec = NULL,
then all upper asymptotes set to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of item information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# plot the IIF for a dichotomous item with k = 2

set.seed(2342)
bmat &lt;- sim_bmat(n_items = 1, k = 2)$bmat

theta &lt;- seq(-3, 3, by = .01)

information &lt;- iif_fmp(theta = theta, bmat = bmat)

plot(theta, information, type = 'l')

</code></pre>

<hr>
<h2 id='int_mat'>Numerical Integration Matrix</h2><span id='topic+int_mat'></span>

<h3>Description</h3>

<p>Create a matrix for numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_mat(
  distr = dnorm,
  args = list(mean = 0, sd = 1),
  lb = -4,
  ub = 4,
  npts = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_mat_+3A_distr">distr</code></td>
<td>
<p>A density function with two user-specified parameters. Defaults
to the normal distribution (dnorm), but any density function is permitted.</p>
</td></tr>
<tr><td><code id="int_mat_+3A_args">args</code></td>
<td>
<p>Named list of arguments to distr.</p>
</td></tr>
<tr><td><code id="int_mat_+3A_lb">lb</code></td>
<td>
<p>Lower bound of range over which to numerically integrate.</p>
</td></tr>
<tr><td><code id="int_mat_+3A_ub">ub</code></td>
<td>
<p>Upper bound of range over which to numerically integrate.</p>
</td></tr>
<tr><td><code id="int_mat_+3A_npts">npts</code></td>
<td>
<p>Number of integration points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of two columns. Column 1 is a sequence of x-coordinates, and
column 2 is a sequence of y-coordinates from a normalized distribution.
</p>


<h3>See Also</h3>

<p><a href="#topic+rimse">rimse</a> <a href="#topic+th_est_ml">th_est_ml</a> <a href="#topic+th_est_eap">th_est_eap</a> <a href="#topic+sl_link">sl_link</a>
<a href="#topic+hb_link">hb_link</a>
</p>
<p>@importFrom stats dnorm
</p>

<hr>
<h2 id='inv_poly'>Polynomial Functions</h2><span id='topic+inv_poly'></span><span id='topic+fw_poly'></span>

<h3>Description</h3>

<p>Evaluate a forward or inverse (monotonic) polynomial function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_poly(x, coefs, lb = -1000, ub = 1000)

fw_poly(y, coefs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_poly_+3A_x">x</code></td>
<td>
<p>Scalar polynomial function input.</p>
</td></tr>
<tr><td><code id="inv_poly_+3A_coefs">coefs</code></td>
<td>
<p>Vector of coefficients that define a monotonic polynomial,
see details.</p>
</td></tr>
<tr><td><code id="inv_poly_+3A_lb">lb</code></td>
<td>
<p>Lower bound of the search interval.</p>
</td></tr>
<tr><td><code id="inv_poly_+3A_ub">ub</code></td>
<td>
<p>Upper bound of the search interval.</p>
</td></tr>
<tr><td><code id="inv_poly_+3A_y">y</code></td>
<td>
<p>Scalar polynomial function output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">x = t_0 + t_1y + t_2y^2 + ...</code>
</p>

<p>Then, for coefs = <code class="reqn">(t_0, t_1, t_2, ...)^\prime</code>,
this function finds the corresponding
<code class="reqn">y</code> value (inv_poly) or <code class="reqn">x</code> value (fw_poly).
</p>

<hr>
<h2 id='irf_fmp'>FMP Item Response Function</h2><span id='topic+irf_fmp'></span>

<h3>Description</h3>

<p>Find FMP item response probabilities
for user-supplied item and person parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irf_fmp(theta, bmat, maxncat = 2, returncat = NA, cvec = NULL, dvec = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irf_fmp_+3A_theta">theta</code></td>
<td>
<p>Vector of latent trait parameters.</p>
</td></tr>
<tr><td><code id="irf_fmp_+3A_bmat">bmat</code></td>
<td>
<p>Items x parameters matrix of FMP item parameters (or a vector of
FMP item parameters for a single item).</p>
</td></tr>
<tr><td><code id="irf_fmp_+3A_maxncat">maxncat</code></td>
<td>
<p>Maximum number of response categories (the first maxncat - 1
columns of bmat are intercepts).</p>
</td></tr>
<tr><td><code id="irf_fmp_+3A_returncat">returncat</code></td>
<td>
<p>Response categories for which probabilities should be
returned, 0,..., maxncat - 1.</p>
</td></tr>
<tr><td><code id="irf_fmp_+3A_cvec">cvec</code></td>
<td>
<p>Optional vector of lower asymptote parameters. If cvec = NULL,
then all lower asymptotes set to 0.</p>
</td></tr>
<tr><td><code id="irf_fmp_+3A_dvec">dvec</code></td>
<td>
<p>Optional vector of upper asymptote parameters. If dvec = NULL,
then all upper asymptotes set to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of item response probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# plot the IRF for an item with 4 response categories and k = 2

set.seed(2342)
bmat &lt;- sim_bmat(n_items = 1, ncat = 4, k = 2)$bmat

theta &lt;- seq(-3, 3, by = .01)

probability &lt;- irf_fmp(theta = theta, bmat = bmat,
                       maxncat = 4, returncat = 0:3)

plot(theta, probability[, , 1], type = 'l', ylab = "probability")
points(theta, probability[, , 2], type = 'l')
points(theta, probability[, , 3], type = 'l')
points(theta, probability[, , 4], type = 'l')

</code></pre>

<hr>
<h2 id='linking'>Linear and Nonlinear Item Parameter Linking</h2><span id='topic+linking'></span><span id='topic+sl_link'></span><span id='topic+hb_link'></span>

<h3>Description</h3>

<p>Link two sets of FMP item parameters using linear or nonlinear
transformations of the latent trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sl_link(
  bmat1,
  bmat2,
  maxncat = 2,
  cvec1 = NULL,
  cvec2 = NULL,
  dvec1 = NULL,
  dvec2 = NULL,
  k_theta,
  int = int_mat(),
  ...
)

hb_link(
  bmat1,
  bmat2,
  maxncat = 2,
  cvec1 = NULL,
  cvec2 = NULL,
  dvec1 = NULL,
  dvec2 = NULL,
  k_theta,
  int = int_mat(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linking_+3A_bmat1">bmat1</code></td>
<td>
<p>FMP item parameters on an anchor test.</p>
</td></tr>
<tr><td><code id="linking_+3A_bmat2">bmat2</code></td>
<td>
<p>FMP item parameters to be rescaled.</p>
</td></tr>
<tr><td><code id="linking_+3A_maxncat">maxncat</code></td>
<td>
<p>Maximum number of response categories (the first maxncat - 1
columns of bmat1 and bmat2 are intercepts)</p>
</td></tr>
<tr><td><code id="linking_+3A_cvec1">cvec1</code></td>
<td>
<p>Vector of lower asymptote parameters for the anchor test.</p>
</td></tr>
<tr><td><code id="linking_+3A_cvec2">cvec2</code></td>
<td>
<p>Vector of lower asymptote parameters corresponding to the
rescaled item parameters.</p>
</td></tr>
<tr><td><code id="linking_+3A_dvec1">dvec1</code></td>
<td>
<p>Vector of upper asymptote parameters for the anchor test.</p>
</td></tr>
<tr><td><code id="linking_+3A_dvec2">dvec2</code></td>
<td>
<p>Vector of upper asymptote parameters corresponding to the
rescaled item parameters.</p>
</td></tr>
<tr><td><code id="linking_+3A_k_theta">k_theta</code></td>
<td>
<p>Complexity of the latent trait transformation (k_theta = 0 is
linear, k_theta &gt; 0 is nonlinear).</p>
</td></tr>
<tr><td><code id="linking_+3A_int">int</code></td>
<td>
<p>Matrix with two columns, used for numerical integration. Column 1
is a grid of theta values, column 2 are normalized densities associated with
the column 1 values.</p>
</td></tr>
<tr><td><code id="linking_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to optim.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of item parameter linking is to find a metric
transformation such that the fitted parameters for one test can be
transformed to the same metric as those for the other test. In the Haebara
approach, the overall sum of squared differences between the original and
transformed individual item response functions is minimized. In the
Stocking-Lord approach, the sum of squared differences between the original
and transformed test response functions is minimized. See
Feuerstahler (2016, 2019) for details on linking with the FMP model.
</p>


<h3>Value</h3>

<table>
<tr><td><code>par</code></td>
<td>
<p>(Greek-letter) parameters estimated by optim.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Value of the minimized criterion function.</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>Number of function counts in optim.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>Convergence criterion given by optim.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>Message given by optim.</p>
</td></tr>
<tr><td><code>tvec</code></td>
<td>
<p>Vector of theta transformation coefficients
<code class="reqn">(t = t0,....,t(2k_\theta+1))</code></p>
</td></tr>
<tr><td><code>bmat</code></td>
<td>
<p>Transformed bmat2 item parameters.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Feuerstahler, L. M. (2016). <em>Exploring alternate latent trait metrics
with the filtered monotonic polynomial IRT model</em> (Unpublished dissertation).
University of Minnesota, Minneapolis, MN.
<a href="http://hdl.handle.net/11299/182267">http://hdl.handle.net/11299/182267</a>
</p>
<p>Feuerstahler, L. M. (2019). Metric Transformations and the Filtered
Monotonic Polynomial Item Response Model. <em>Psychometrika</em>, <em>84</em>,
105&ndash;123. doi: <a href="https://doi.org/10.1007/s11336-018-9642-9">10.1007/s11336-018-9642-9</a>
</p>
<p>Haebara, T. (1980). Equating logistic ability scales by a weighted least
squares method. <em>Japanese Psychological Research</em>, <em>22</em>, 144&ndash;149.
doi: <a href="https://doi.org/10.4992/psycholres1954.22.144">10.4992/psycholres1954.22.144</a>
</p>
<p>Stocking, M. L., &amp; Lord, F. M. (1983). Developing a common metric in item
response theory. <em>Applied Psychological Measurement</em>, <em>7</em>,
201&ndash;210. doi: <a href="https://doi.org/10.1002/j.2333-8504.1982.tb01311.x">10.1002/j.2333-8504.1982.tb01311.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2342)
bmat &lt;- sim_bmat(n_items = 10, k = 2)$bmat

theta1 &lt;- rnorm(100)
theta2 &lt;- rnorm(100, mean = -1)

dat1 &lt;- sim_data(bmat = bmat, theta = theta1)
dat2 &lt;- sim_data(bmat = bmat, theta = theta2)

# estimate each model with fixed-effects and k = 0
fmp0_1 &lt;- fmp(dat = dat1, k = 0, em = FALSE)
fmp0_2 &lt;- fmp(dat = dat2, k = 0, em = FALSE)

# Stocking-Lord linking


sl_res &lt;- sl_link(bmat1 = fmp0_1$bmat[1:5, ],
                  bmat2 = fmp0_2$bmat[1:5, ],
                  k_theta = 0)


hb_res &lt;- hb_link(bmat1 = fmp0_1$bmat[1:5, ],
                  bmat2 = fmp0_2$bmat[1:5, ],
                  k_theta = 0)




</code></pre>

<hr>
<h2 id='rimse'>Root Integrated Mean Squared Difference Between FMP IRFs</h2><span id='topic+rimse'></span>

<h3>Description</h3>

<p>Compute the root integrated mean squared error (RIMSE) between two FMP IRFs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rimse(
  bvec1,
  bvec2,
  ncat = 2,
  c1 = NULL,
  d1 = NULL,
  c2 = NULL,
  d2 = NULL,
  int = int_mat()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rimse_+3A_bvec1">bvec1</code></td>
<td>
<p>Either a vector of FMP item parameters or a function
corresponding to a non-FMP IRF. Functions should have exactly one argument,
corresponding to the latent trait.</p>
</td></tr>
<tr><td><code id="rimse_+3A_bvec2">bvec2</code></td>
<td>
<p>Either a vector of FMP item parameters or a function
corresponding to a non-FMP IRF. Functions should have exactly one argument,
corresponding to the latent trait.</p>
</td></tr>
<tr><td><code id="rimse_+3A_ncat">ncat</code></td>
<td>
<p>Number of response categories (first ncat - 1 elemnts of bvec1
and bvec2 are intercepts)</p>
</td></tr>
<tr><td><code id="rimse_+3A_c1">c1</code></td>
<td>
<p>Lower asymptote parameter for bvec1.
Ignored if bvec1 is a function.</p>
</td></tr>
<tr><td><code id="rimse_+3A_d1">d1</code></td>
<td>
<p>Upper asymptote parameter for bvec1.
Ignored if bvec1 is a function.</p>
</td></tr>
<tr><td><code id="rimse_+3A_c2">c2</code></td>
<td>
<p>Lower asymptote parameter for bvec2.
Ignored if bvec2 is a function.</p>
</td></tr>
<tr><td><code id="rimse_+3A_d2">d2</code></td>
<td>
<p>Upper asymptote parameter for bvec2.
Ignored if bvec2 is a function.</p>
</td></tr>
<tr><td><code id="rimse_+3A_int">int</code></td>
<td>
<p>Matrix with two columns, used for numerical integration.
Column 1 is a grid of theta values, column 2 are normalized densities
associated with the column 1 values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Root integrated mean squared difference between two IRFs
(dichotomous items) or expected item scores (polytomous items).
</p>


<h3>References</h3>

<p>Ramsay, J. O. (1991). Kernel smoothing approaches to
nonparametric item characteristic curve estimation. <em>Psychometrika</em>,
<em>56</em>, 611&ndash;630. doi: <a href="https://doi.org/10.1007/BF02294494">10.1007/BF02294494</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2342)
bmat &lt;- sim_bmat(n_items = 2, k = 2, ncat = c(2, 5))$bmat

theta &lt;- rnorm(500)
dat &lt;- sim_data(bmat = bmat, theta = theta, maxncat = 5)

# k = 0
fmp0a &lt;- fmp_1(dat = dat[, 1], k = 0, tsur = theta)
fmp0b &lt;- fmp_1(dat = dat[, 2], k = 0, tsur = theta)


# k = 1
fmp1a &lt;- fmp_1(dat = dat[, 1], k = 1, tsur = theta)
fmp1b &lt;- fmp_1(dat = dat[, 2], k = 1, tsur = theta)


## compare estimated curves to the data-generating curve
rimse(fmp0a$bmat, bmat[1, -c(2:4)])
rimse(fmp0b$bmat, bmat[2, ], ncat = 5)


rimse(fmp1a$bmat, bmat[1, -c(2:4)])
rimse(fmp1b$bmat, bmat[2, ], ncat = 5)


</code></pre>

<hr>
<h2 id='sim_bmat'>Randomly Generate FMP Parameters</h2><span id='topic+sim_bmat'></span>

<h3>Description</h3>

<p>Generate monotonic polynomial coefficients for user-specified item
complexities and prior distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_bmat(
  n_items,
  k,
  ncat = 2,
  xi_dist = list(runif, min = -1, max = 1),
  omega_dist = list(runif, min = -1, max = 1),
  alpha_dist = list(runif, min = -1, max = 0.5),
  tau_dist = list(runif, min = -3, max = 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_bmat_+3A_n_items">n_items</code></td>
<td>
<p>Number of items for which to simulate item parameters.</p>
</td></tr>
<tr><td><code id="sim_bmat_+3A_k">k</code></td>
<td>
<p>Either a scalar for the item complexity of all items or a
vector of length n_items if different items have different item complexities.</p>
</td></tr>
<tr><td><code id="sim_bmat_+3A_ncat">ncat</code></td>
<td>
<p>Vector of length n_item giving the number of response
categories for each item. If of length 1, all items will have the same
number of response categories.</p>
</td></tr>
<tr><td><code id="sim_bmat_+3A_xi_dist">xi_dist</code></td>
<td>
<p>List of information about the distribution from which to 
randomly sample xi parameters. The first element should be a function that
generates random deviates (e.g., runif or rnorm), and further elements 
should be named arguments to the function.</p>
</td></tr>
<tr><td><code id="sim_bmat_+3A_omega_dist">omega_dist</code></td>
<td>
<p>List of information about the distribution from which to 
randomly sample omega parameters. The first element should be a function that
generates random deviates (e.g., runif or rnorm), and further elements 
should be named arguments to the function.</p>
</td></tr>
<tr><td><code id="sim_bmat_+3A_alpha_dist">alpha_dist</code></td>
<td>
<p>List of information about the distribution from which to 
randomly sample alpha parameters. The first element should be a function that
generates random deviates (e.g., runif or rnorm), and further elements 
should be named arguments to the function.
Ignored if all k = 0.</p>
</td></tr>
<tr><td><code id="sim_bmat_+3A_tau_dist">tau_dist</code></td>
<td>
<p>List of information about the distribution from which to 
randomly sample tau parameters. The first element should be a function that
generates random deviates (e.g., runif or rnorm), and further elements 
should be named arguments to the function.
Ignored if all k = 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Randomly generate FMP item parameters for a given k value.
</p>


<h3>Value</h3>

<table>
<tr><td><code>bmat</code></td>
<td>
<p>Item parameters in the b parameterization (polynomial
coefficients).</p>
</td></tr>
<tr><td><code>greekmat</code></td>
<td>
<p>Item parameters in the Greek-letter parameterization</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## generate FMP item parameters for 5 dichotomous items all with k = 2
set.seed(2342)
pars &lt;- sim_bmat(n_items = 5, k = 2)
pars$bmat

## generate FMP item parameters for 5 items with varying k values and 
##  varying numbers of response categories
set.seed(2432)
pars &lt;- sim_bmat(n_items = 5, k = c(1, 2, 0, 0, 2), ncat = c(2, 3, 4, 5, 2))
pars$bmat

</code></pre>

<hr>
<h2 id='sim_data'>Simulate FMP Data</h2><span id='topic+sim_data'></span>

<h3>Description</h3>

<p>Simulate data according to user-specified FMP item parameters and
latent trait parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_data(bmat, theta, maxncat = 2, cvec = NULL, dvec = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_data_+3A_bmat">bmat</code></td>
<td>
<p>Matrix of FMP item parameters.</p>
</td></tr>
<tr><td><code id="sim_data_+3A_theta">theta</code></td>
<td>
<p>Vector of latent trait values.</p>
</td></tr>
<tr><td><code id="sim_data_+3A_maxncat">maxncat</code></td>
<td>
<p>Maximum number of response categories  (the first maxncat - 1
columns of bmat are intercepts)</p>
</td></tr>
<tr><td><code id="sim_data_+3A_cvec">cvec</code></td>
<td>
<p>Optional vector of lower asymptote parameters. If cvec = NULL,
then all lower asymptotes set to 0.</p>
</td></tr>
<tr><td><code id="sim_data_+3A_dvec">dvec</code></td>
<td>
<p>Optional vector of upper asymptote parameters. If dvec = NULL,
then all upper asymptotes set to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of randomly generated binary item responses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate 5-category item responses for normally distributed theta
##   and 5 items with k = 2

set.seed(2342)
bmat &lt;- sim_bmat(n_items = 5, k = 2, ncat = 5)$bmat

theta &lt;- rnorm(50)
dat &lt;- sim_data(bmat = bmat, theta = theta, maxncat = 5)

</code></pre>

<hr>
<h2 id='th_est_ml'>Latent Trait Estimation</h2><span id='topic+th_est_ml'></span><span id='topic+th_est_eap'></span>

<h3>Description</h3>

<p>Compute latent trait estimates using either maximum likelihood (ML) or
expected a posteriori (EAP) trait estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>th_est_ml(dat, bmat, maxncat = 2, cvec = NULL, dvec = NULL, lb = -4, ub = 4)

th_est_eap(
  dat,
  bmat,
  maxncat = 2,
  cvec = NULL,
  dvec = NULL,
  int = int_mat(npts = 33)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="th_est_ml_+3A_dat">dat</code></td>
<td>
<p>Data matrix of binary item responses with one column for each
item. Alternatively, a vector of binary item responses for one person.</p>
</td></tr>
<tr><td><code id="th_est_ml_+3A_bmat">bmat</code></td>
<td>
<p>Matrix of FMP item parameters, one row for each item.</p>
</td></tr>
<tr><td><code id="th_est_ml_+3A_maxncat">maxncat</code></td>
<td>
<p>Maximum number of response categories (the first maxncat - 1
columns of bmat are intercepts)</p>
</td></tr>
<tr><td><code id="th_est_ml_+3A_cvec">cvec</code></td>
<td>
<p>Vector of lower asymptote parameters, one element for each item.</p>
</td></tr>
<tr><td><code id="th_est_ml_+3A_dvec">dvec</code></td>
<td>
<p>Vector of upper asymptote parameters, one element for each item.</p>
</td></tr>
<tr><td><code id="th_est_ml_+3A_lb">lb</code></td>
<td>
<p>Lower bound at which to truncate ML estimates.</p>
</td></tr>
<tr><td><code id="th_est_ml_+3A_ub">ub</code></td>
<td>
<p>Upper bound at which to truncate ML estimates.</p>
</td></tr>
<tr><td><code id="th_est_ml_+3A_int">int</code></td>
<td>
<p>Matrix with two columns used for numerical integration in EAP.
Column 1 contains the x coordinates and Column 2 contains the densities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with two columns: est and either sem or psd
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>Latent trait estimate</p>
</td></tr>
<tr><td><code>sem</code></td>
<td>
<p>Standard error of measurement (mle estimates)</p>
</td></tr>
<tr><td><code>psd</code></td>
<td>
<p>Posterior standard deviation (eap estimates)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(3453)
bmat &lt;- sim_bmat(n_items = 20, k = 0)$bmat

theta &lt;- rnorm(10)
dat &lt;- sim_data(bmat = bmat, theta = theta)

## mle estimates
mles &lt;- th_est_ml(dat = dat, bmat = bmat)

## eap estimates
eaps &lt;- th_est_eap(dat = dat, bmat = bmat)

cor(mles[,1], eaps[,1])
# 0.9967317

</code></pre>

<hr>
<h2 id='transform_b'>Transform FMP Item Parameters</h2><span id='topic+transform_b'></span><span id='topic+inv_transform_b'></span>

<h3>Description</h3>

<p>Given FMP item parameters for a single item and the polynomial coefficients
defining a latent trait transformation, find the transformed FMP
item parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_b(bvec, tvec, ncat = 2)

inv_transform_b(bstarvec, tvec, ncat = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_b_+3A_bvec">bvec</code></td>
<td>
<p>Vector of item parameters on the <code class="reqn">\theta</code> metric: (b0,
b1, b2, b3, ...).</p>
</td></tr>
<tr><td><code id="transform_b_+3A_tvec">tvec</code></td>
<td>
<p>Vector of theta transformation polynomial coefficients: (t0, t1,
t2, t3, ...)</p>
</td></tr>
<tr><td><code id="transform_b_+3A_ncat">ncat</code></td>
<td>
<p>Number of response categories (first ncat - 1 elements of bvec
and bstarvec are intercepts)</p>
</td></tr>
<tr><td><code id="transform_b_+3A_bstarvec">bstarvec</code></td>
<td>
<p>Vector of item parameters on the
<code class="reqn">\theta^{\star}</code> metric: (b*0, b*1, b*2, b*3, ...)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equivalent item response models can be written
</p>
<p style="text-align: center;"><code class="reqn">P(\theta) = b_0 + b_1\theta + b_2\theta^2 + \cdots +
b_{2k+1}\theta^{2k+1}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">P(\theta^\star) = b^\star_0 + b^\star_1\theta^\star +
b^\star_2\theta^{\star2}+\cdots + b^\star_{2k^\star+1}\theta^{2k^\star+1}</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\theta = t_0 + t_1\theta^\star + t_2\theta^{\star 2} + \cdots +
t_{2k_\theta+1}\theta^{\star2k_\theta+1}</code>
</p>

<p>When using inv_transform_b, be aware that multiple tvec/bstarvec pairings 
will lead to the same bvec. Users are advised not to use the 
inv_transform_b function unless bstarvec has first been calculated by a call
to transform_b.
</p>


<h3>Value</h3>

<p>Vector of transformed FMP item parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## example parameters from Table 7 of Reise &amp; Waller (2003)
## goal: transform IRT model to sum score metric

a &lt;- c(0.57, 0.68, 0.76, 0.72, 0.69, 0.57, 0.53, 0.64,
       0.45, 1.01, 1.05, 0.50, 0.58, 0.58, 0.60, 0.59,
       1.03, 0.52, 0.59, 0.99, 0.95, 0.39, 0.50)
b &lt;- c(0.87, 1.02, 0.87, 0.81, 0.75, -0.22, 0.14, 0.56,
       1.69, 0.37, 0.68, 0.56, 1.70, 1.20, 1.04, 1.69,
       0.76, 1.51, 1.89, 1.77, 0.39, 0.08, 2.02)

## convert from difficulties and discriminations to FMP parameters

b1 &lt;- 1.702 * a
b0 &lt;- - 1.702 * a * b
bmat &lt;- cbind(b0, b1)

## theta transformation vector (k_theta = 3)
##  see vignette for details about how to find tvec

tvec &lt;- c(-3.80789e+00, 2.14164e+00, -6.47773e-01, 1.17182e-01,
          -1.20807e-02, 7.02295e-04, -2.13809e-05, 2.65177e-07)

## transform bmat
bstarmat &lt;- t(apply(bmat, 1, transform_b, tvec = tvec))

## inspect transformed parameters
signif(head(bstarmat), 2)

## plot test response function
##  should be a straight line if transformation worked

curve(rowSums(irf_fmp(x, bmat = bstarmat)), xlim = c(0, 23),
      ylim = c(0, 23), xlab = expression(paste(theta,"*")),
      ylab = "Expected Sum Score")
abline(0, 1, col = 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
