<!DOCTYPE html><html><head><title>Help for package lulcc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lulcc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lulcc-package'><p>lulcc: land use change modelling in R</p></a></li>
<li><a href='#AgreementBudget'><p>Create an AgreementBudget object</p></a></li>
<li><a href='#AgreementBudget-class'><p>Class AgreementBudget</p></a></li>
<li><a href='#allocate'><p>Allocate land use change spatially</p></a></li>
<li><a href='#allow'><p>Implement decision rules for land use change</p></a></li>
<li><a href='#allowNeighb'><p>Implement neighbourhood decision rules</p></a></li>
<li><a href='#approxExtrapDemand'><p>Extrapolate land use area in time</p></a></li>
<li><a href='#as.data.frame.ExpVarRasterList'><p>Coerce objects to data.frame</p></a></li>
<li><a href='#c.PredictiveModelList'><p>Merge PredictiveModelList objects</p></a></li>
<li><a href='#CategoryLabel-class'><p>Virtual class CategoryLabel</p></a></li>
<li><a href='#CluesModel'><p>Create a CluesModel object</p></a></li>
<li><a href='#CluesModel-class'><p>Class CluesModel</p></a></li>
<li><a href='#compareAUC'><p>Calculate the area under the ROC curve (AUC)</p></a></li>
<li><a href='#crossTabulate'><p>Cross tabulate land use transitions</p></a></li>
<li><a href='#ExpVarRasterList'><p>Create an ExpVarRasterList object</p></a></li>
<li><a href='#ExpVarRasterList-class'><p>Class ExpVarRasterList</p></a></li>
<li><a href='#Extract+20by+20index'><p>Extract by index</p></a></li>
<li><a href='#FigureOfMerit'><p>Create a FigureOfMerit object</p></a></li>
<li><a href='#FigureOfMerit-class'><p>Class FigureOfMerit</p></a></li>
<li><a href='#getPredictiveModelInputData'><p>Extract data to fit predictive models</p></a></li>
<li><a href='#Model+20fitting'><p>Fit predictive models</p></a></li>
<li><a href='#Model-class'><p>Virtual class Model</p></a></li>
<li><a href='#NeighbRasterStack'><p>Create a NeighbRasterStack object</p></a></li>
<li><a href='#NeighbRasterStack-class'><p>Class NeighbRasterStack</p></a></li>
<li><a href='#ObsLulcRasterStack'><p>Create an ObsLulcRasterStack object</p></a></li>
<li><a href='#ObsLulcRasterStack-class'><p>Class ObsLulcRasterStack</p></a></li>
<li><a href='#OrderedModel'><p>Create an OrderedModel object</p></a></li>
<li><a href='#OrderedModel-class'><p>Class OrderedModel</p></a></li>
<li><a href='#partition'><p>Partition raster data</p></a></li>
<li><a href='#performance'><p>Create ROCR performance objects</p></a></li>
<li><a href='#PerformanceList'><p>Create a PerformanceList object</p></a></li>
<li><a href='#PerformanceList-class'><p>Class PerformanceList</p></a></li>
<li><a href='#pie'><p>Land use change dataset for Plum Island Ecosystem</p></a></li>
<li><a href='#plot'><p>Plot method for objects based on Raster* data</p></a></li>
<li><a href='#plot.AgreementBudget'><p>Plot method for AgreementBudget objects</p></a></li>
<li><a href='#plot.FigureOfMerit'><p>Plot method for FigureOfMerit objects</p></a></li>
<li><a href='#plot.PerformanceList'><p>Plot method for PerformanceList objects</p></a></li>
<li><a href='#predict.PredictiveModelList'><p>Predict location suitability</p></a></li>
<li><a href='#PredictionList'><p>Create a PredictionList object</p></a></li>
<li><a href='#PredictionList-class'><p>Class PredictionList</p></a></li>
<li><a href='#PredictiveModelList-class'><p>Class PredictiveModelList</p></a></li>
<li><a href='#resample+2CExpVarRasterList+2CRaster-method'><p>Resample maps in ExpVarRasterList object or list</p></a></li>
<li><a href='#roundSum'><p>Round elements in matrix or data.frame rows</p></a></li>
<li><a href='#show+2CExpVarRasterList-method'><p>Show</p></a></li>
<li><a href='#sibuyan'><p>Land use change dataset for Sibuyan Island</p></a></li>
<li><a href='#subset+2CExpVarRasterList-method'><p>Subset</p></a></li>
<li><a href='#summary'><p>Summary</p></a></li>
<li><a href='#ThreeMapComparison'><p>Evaluate allocation performance with three maps</p></a></li>
<li><a href='#ThreeMapComparison-class'><p>Class ThreeMapComparison</p></a></li>
<li><a href='#total'><p>Total number of cells in a categorical Raster* object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Land Use Change Modelling in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Moulds &lt;sim.moulds@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Moulds &lt;sim.moulds@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes and methods for spatially explicit land use change
    modelling in R.</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, raster, R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ROCR, lattice, rasterVis</td>
</tr>
<tr>
<td>Suggests:</td>
<td>caret, rpart, randomForest, gsubfn, Hmisc, plyr,
RColorBrewer,</td>
</tr>
<tr>
<td>Collate:</td>
<td>'class-CategoryLabel.R' 'class-ObsLulcRasterStack.R'
'class-PredictiveModelList.R' 'class-ExpVarRasterList.R'
'class-NeighbRasterStack.R' 'class-Model.R'
'class-ThreeMapComparison.R' 'AgreementBudget.R'
'ExpVarRasterList.R' 'FigureOfMerit.R' 'Model.R'
'NeighbRasterStack.R' 'ObsLulcRasterStack.R'
'class-PerformanceList.R' 'PerformanceList.R'
'class-PredictionList.R' 'PredictionList.R'
'ThreeMapComparison.R' 'allocate.R' 'allow.R' 'allowNeighb.R'
'approxExtrapDemand.R' 'as.data.frame.R'
'c.PredictiveModelList.R' 'index.R' 'coerce.R' 'compareAUC.R'
'crossTabulate.R' 'data.R' 'getPredictiveModelInputData.R'
'length.R' 'lulcc-package.R' 'models.R' 'names.R' 'partition.R'
'performance.rocr.R' 'plot.AgreementBudget.R'
'plot.FigureOfMerit.R' 'plot.Performance.R' 'plot.R'
'predict.R' 'resample.R' 'show.R' 'subset.R' 'summary.R'
'total.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-02-25 11:28:50 UTC; simon</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-01 10:50:04 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
</table>
<hr>
<h2 id='lulcc-package'>lulcc: land use change modelling in R</h2><span id='topic+lulcc-package'></span>

<h3>Description</h3>

<p>The lulcc package is an open and extensible framework for land use change
modelling in R.
</p>


<h3>Details</h3>

<p>The aims of the package are as follows:
</p>

<ol>
<li><p> to improve the reproducibility of scientific results and encourage
reuse of code within the land use change modelling community
</p>
</li>
<li><p> to make it easy to directly compare and combine different model
structures
</p>
</li>
<li><p> to allow users to perform several aspects of the modelling process
within the same environment
</p>
</li></ol>

<p>To achieve these aims the package utilises an object-oriented approach based
on the S4 system, which provides a formal structure for the modelling
framework. Generic methods implemented for the <code>lulcc</code> classes include
<code>summary</code>, <code>show</code>, and <code>plot</code>.
</p>
<p>Land use change models are represented by objects inheriting from the
superclass <code>Model</code>. This class is designed to represent general
information required by all models while specific models are represented by
its subclasses. Currently the package includes two inductive land use change
models: the first is an implementation of the Change in Land Use and its
Effects at Small Regional extent (CLUE-S) model (Verburg et al., 2002) (class
<code>CluesModel</code>), while the second is an ordered procedure based on the
algorithm described by Fuchs et al. (2013) but modified to allow stochastic
transitions (class <code>OrderedModel</code>).
</p>
<p>The main input to inductive land use change models is a set of predictive
models relating observed land use or land use change to spatially explicit
explanatory variables. A predictive model is usually obtained for each
category or transition. In lulcc these models are represented by the class
<code>PredictiveModelList</code>. Currently lulcc supports binary logistic regression,
provided by base R (<code>glm</code>), recursive partitioning and regression trees,
provided by package <code>rpart</code> and random forest, provided by package
<code>randomForest</code>. To a large extent the success of the allocation routine
depends on the strength of the predictive models: this is one reason why an R
package for land use change modelling is attractive.
</p>
<p>To validate model output lulcc includes a method developed by Pontius et al.
(2011) that simultaneously compares a reference map for time 1, a reference
map for time 2 and a simulated map for time 2 at multiple resolutions. In
lulcc the results of the comparison are represented by the class
<code>ThreeMapComparison</code>. From objects of this class it is straightforward
to extract information about different sources of agreement and disagreement,
represented by the class <code>AgreementBudget</code>, which can then be plotted. The
results of the comparison are conveniently summarised by the figure of merit,
represented by the class<code>FigureOfMerit</code>.
</p>
<p>In addition to the core functionality described above, lulcc inludes several
utility functions to assist with the model building process. Two example
datasets are also included.
</p>


<h3>Author(s)</h3>

<p>Simon Moulds
</p>


<h3>References</h3>

<p>Fuchs, R., Herold, M., Verburg, P.H., and Clevers, J.G.P.W. (2013). A
high-resolution and harmonized model approach for reconstructing and analysing
historic land changes in Europe, Biogeosciences, 10:1543-1559.
</p>
<p>Pontius Jr, R.G., Peethambaram, S., Castella, J.C. (2011).
Comparison of three maps at multiple resol utions: a case study of land change
simulation in Cho Don District, Vietnam. Annals of the Association of American
Geographers 101(1): 45-62.
</p>
<p>Verburg, P.H., Soepboer, W., Veldkamp, A., Limpiada, R., Espaldon, V., Mastura,
S.S. (2002). Modeling the spatial dynamics of regional land use: the CLUE-S
model. Environmental management, 30(3):391-405.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Plum Island Ecosystems

## load data
data(pie)

## observed maps
obs &lt;- ObsLulcRasterStack(x=pie,
                          pattern="lu", 
                          categories=c(1,2,3), 
                          labels=c("Forest","Built","Other"), 
                          t=c(0,6,14))
obs

plot(obs)

crossTabulate(obs, times=c(0,14))

## explanatory variables
ef &lt;- ExpVarRasterList(x=pie, pattern="ef")
ef

part &lt;- partition(x=obs[[1]], size=0.1, spatial=TRUE)
train.data &lt;- getPredictiveModelInputData(obs=obs, ef=ef, cells=part[["train"]])

forms &lt;- list(Built ~ ef_001+ef_002+ef_003,
              Forest ~ ef_001+ef_002,
              Other ~ ef_001+ef_002)

glm.models &lt;- glmModels(formula=forms, family=binomial, data=train.data, obs=obs)
rpart.models &lt;- rpartModels(formula=forms, data=train.data, obs=obs)
rf.models &lt;- randomForestModels(formula=forms, data=train.data, obs=obs)

## test ability of models to predict allocation of forest, built and other
## land uses in testing partition
test.data &lt;- getPredictiveModelInputData(obs=obs, ef=ef, cells=part[["test"]])

glm.pred &lt;- PredictionList(models=glm.models, newdata=test.data)
glm.perf &lt;- PerformanceList(pred=glm.pred, measure="rch")

rpart.pred &lt;- PredictionList(models=rpart.models, newdata=test.data)
rpart.perf &lt;- PerformanceList(pred=rpart.pred, measure="rch")

rf.pred &lt;- PredictionList(models=rf.models, newdata=test.data)
rf.perf &lt;- PerformanceList(pred=rf.pred, measure="rch")

plot(list(glm=glm.perf, rpart=rpart.perf, rf=rf.perf))

## test ability of models to predict location of urban gain 1985 to 1991
part &lt;- rasterToPoints(obs[[1]], fun=function(x) x != 2, spatial=TRUE)
test.data &lt;- getPredictiveModelInputData(obs=obs, ef=ef, cells=part, t=6)

glm.pred &lt;- PredictionList(models=glm.models[[2]], newdata=test.data)
glm.perf &lt;- PerformanceList(pred=glm.pred, measure="rch")

plot(list(glm=glm.perf))

## obtain demand scenario
dmd &lt;- approxExtrapDemand(obs=obs, tout=0:14)
matplot(dmd, type="l", ylab="Demand (no. of cells)", xlab="Time point",
        lty=1, col=c("Green","Red","Blue"))
legend("topleft", legend=obs@labels, col=c("Green","Red","Blue"), lty=1)

## get neighbourhood values
w &lt;- matrix(data=1, nrow=3, ncol=3)
nb &lt;- NeighbRasterStack(x=obs[[1]], weights=w, categories=2)

## create CLUE-S model object
clues.rules &lt;- matrix(data=1, nrow=3, ncol=3, byrow=TRUE) 

clues.parms &lt;- list(jitter.f=0.0002,
                    scale.f=0.000001,
                    max.iter=1000,
                    max.diff=50, 
                    ave.diff=50) 

clues.model &lt;- CluesModel(obs=obs,
                          ef=ef,
                          models=glm.models,
                          time=0:14,
                          demand=dmd,
                          elas=c(0.2,0.2,0.2),
                          rules=clues.rules,
                          params=clues.parms)

## Create Ordered model
ordered.model &lt;- OrderedModel(obs=obs,
                              ef=ef,
                              models=glm.models,
                              time=0:14,
                              demand=dmd,
                              order=c(2,1,3)) 

## perform allocation
clues.model &lt;- allocate(clues.model)
ordered.model &lt;- allocate(ordered.model, stochastic=TRUE)

## pattern validation

## CLUE-S
clues.tabs &lt;- ThreeMapComparison(x=clues.model,
                                 factors=2^(1:8),
                                 timestep=14)
plot(clues.tabs)
plot(clues.tabs, category=1, factors=2^(1:8)[c(1,3,5,7)])

## Ordered
ordered.tabs &lt;- ThreeMapComparison(x=ordered.model,
                                 factors=2^(1:8),
                                 timestep=14)
plot(ordered.tabs)
plot(ordered.tabs, category=1, factors=2^(1:8)[c(1,3,5,7)])

## calculate agreement budget and plot

## CLUE-S
clues.agr &lt;- AgreementBudget(x=clues.tabs)
plot(clues.agr, from=1, to=2)

## Ordered
ordered.agr &lt;- AgreementBudget(x=ordered.tabs)
plot(ordered.agr, from=1, to=2)

## calculate Figure of Merit and plot

## CLUE-S
clues.fom &lt;- FigureOfMerit(x=clues.tabs)
p1 &lt;- plot(clues.fom, from=1, to=2)

## Ordered
ordered.fom &lt;- FigureOfMerit(x=ordered.tabs)
p2 &lt;- plot(ordered.fom, from=1, to=2)


## End(Not run)

</code></pre>

<hr>
<h2 id='AgreementBudget'>Create an AgreementBudget object</h2><span id='topic+AgreementBudget'></span><span id='topic+AgreementBudget+2CThreeMapComparison-method'></span><span id='topic+AgreementBudget+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>This function quantifies sources of agreement and disagreement between a
reference map for time 1, a reference map for time 2 and a simulated map for
time 2 to provide meaningful information about the performance of land use
change simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AgreementBudget(x, ...)

## S4 method for signature 'ThreeMapComparison'
AgreementBudget(x, ...)

## S4 method for signature 'RasterLayer'
AgreementBudget(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AgreementBudget_+3A_x">x</code></td>
<td>
<p>a ThreeMapComparison object or RasterLayer</p>
</td></tr>
<tr><td><code id="AgreementBudget_+3A_...">...</code></td>
<td>
<p>additional arguments to ThreeMapComparison. Only required if x is
not a ThreeMapComparison object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The types of agreement and disagreement considered are those descibed in
Pontius et al. (2011):
</p>

<ol>
<li><p> Persistence simulated correctly (agreement)
</p>
</li>
<li><p> Persistence simulated as change (disagreement)
</p>
</li>
<li><p> Change simulated incorrectly (disagreement)
</p>
</li>
<li><p> Change simulated correctly (agreement)
</p>
</li>
<li><p> Change simulated as persistence (disagreement)
</p>
</li></ol>



<h3>Value</h3>

<p>An <code>AgreementBudget</code> object.
</p>


<h3>References</h3>

<p>Pontius Jr, R.G., Peethambaram, S., Castella, J.C. (2011).
Comparison of three maps at multiple resolutions: a case study of land change
simulation in Cho Don District, Vietnam. Annals of the Association of American
Geographers 101(1): 45-62.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AgreementBudget-class">AgreementBudget-class</a></code>,
<code><a href="#topic+plot.AgreementBudget">plot.AgreementBudget</a></code>, <code><a href="#topic+ThreeMapComparison">ThreeMapComparison</a></code>,
<code><a href="#topic+FigureOfMerit">FigureOfMerit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='AgreementBudget-class'>Class AgreementBudget</h2><span id='topic+AgreementBudget-class'></span>

<h3>Description</h3>

<p>An S4 class for information about sources of agreement and disagreement
between three categorical raster maps.
</p>


<h3>Slots</h3>


<dl>
<dt><code>tables</code></dt><dd><p>list of data.frames that depict the three dimensional table
described by Pontius et al. (2011) at different resolutions</p>
</dd>
<dt><code>factors</code></dt><dd><p>numeric vector of aggregation factors</p>
</dd>
<dt><code>maps</code></dt><dd><p>list of RasterStack objects containing land use maps at different
resolutions</p>
</dd>
<dt><code>categories</code></dt><dd><p>numeric vector of land use categories</p>
</dd>
<dt><code>labels</code></dt><dd><p>character vector corresponding to <code>categories</code></p>
</dd>
<dt><code>overall</code></dt><dd><p>data.frame containing the overall agreement budget</p>
</dd>
<dt><code>category</code></dt><dd><p>list of data.frames showing the agreement budget for each
category</p>
</dd>
<dt><code>transition</code></dt><dd><p>list of data.frames showing the agreement budget for all
possible transitions</p>
</dd>
</dl>

<hr>
<h2 id='allocate'>Allocate land use change spatially</h2><span id='topic+allocate'></span><span id='topic+allocate+2CCluesModel-method'></span><span id='topic+allocate+2COrderedModel-method'></span>

<h3>Description</h3>

<p>Perform spatially explicit allocation of land use change using different
models. Currently the function provides an implementation of the Change in
Land Use and its Effects at Small regional extent (CLUE-S) model (Verburg et
al., 2002) and an ordered procedure based on the algorithm described by Fuchs
et al., (2013), modified to allow stochastic transitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocate(model, ...)

## S4 method for signature 'CluesModel'
allocate(model, ...)

## S4 method for signature 'OrderedModel'
allocate(model, stochastic = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allocate_+3A_model">model</code></td>
<td>
<p>an object inheriting from class <code>Model</code></p>
</td></tr>
<tr><td><code id="allocate_+3A_...">...</code></td>
<td>
<p>additional arguments for specific methods</p>
</td></tr>
<tr><td><code id="allocate_+3A_stochastic">stochastic</code></td>
<td>
<p>logical indicating whether the model should be run
stochastically. Only used if <code>model</code> is an <code>OrderedModel</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated Model object.
</p>


<h3>References</h3>

<p>Fuchs, R., Herold, M., Verburg, P.H., and Clevers, J.G.P.W. (2013). A
high-resolution and harmonized model approach for reconstructing and analysing
historic land changes in Europe, Biogeosciences, 10:1543-1559.
</p>
<p>Verburg, P.H., Soepboer, W., Veldkamp, A., Limpiada, R., Espaldon, V., Mastura,
S.S. (2002). Modeling the spatial dynamics of regional land use: the CLUE-S
model. Environmental management, 30(3):391-405.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CluesModel">CluesModel</a></code>, <code><a href="#topic+OrderedModel">OrderedModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='allow'>Implement decision rules for land use change</h2><span id='topic+allow'></span>

<h3>Description</h3>

<p>Identify legitimate transitions based on land use history and specific
transition rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allow(x, categories, cd, rules, hist = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allow_+3A_x">x</code></td>
<td>
<p>numeric vector containing the land use pattern for the current
timestep</p>
</td></tr>
<tr><td><code id="allow_+3A_categories">categories</code></td>
<td>
<p>numeric vector containing land use categories in the study
region</p>
</td></tr>
<tr><td><code id="allow_+3A_cd">cd</code></td>
<td>
<p>numeric vector indicating the direction of change for each
land use category. A value of 1 means demand is increasing (i.e. the number
of cells belonging to the category must increase), -1 means decreasing
demand and 0 means demand is static</p>
</td></tr>
<tr><td><code id="allow_+3A_rules">rules</code></td>
<td>
<p>matrix. See details</p>
</td></tr>
<tr><td><code id="allow_+3A_hist">hist</code></td>
<td>
<p>numeric vector containing land use history (values represent the
number of timesteps the cell has contained the current land use category).
Only required for rules 2 and 3</p>
</td></tr>
<tr><td><code id="allow_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Decision rules are based on those described by Verburg et al. (2002). The
<code>rules</code> input argument is a square matrix with dimensions equal to the
number of land use categories in the study region where rows represent the
current land use and columns represent future transitions. The value of each
element should represent a rule from the following list:
</p>

<ol>
<li><p> rule == 0 | rule == 1: this rule concerns specific land use
transitions that are allowed (1) or not (0)
</p>
</li>
<li><p> rule &gt; 100 &amp; rule &lt; 1000: this rule imposes a time limit (rule - 100)
on land use transitions, after which land use change is not allowed. Time
is taken from <code>hist</code>
</p>
</li>
<li><p> rule &gt; 1000: this rule imposes a minimum period of time (rule-1000)
before land use is allowed to change
</p>
</li></ol>

<p><code>allow</code> should be called from <code><a href="#topic+allocate">allocate</a></code> methods. The output
is a matrix with the same dimensions as the matrix used internally by
allocation functions to store land use suitability. Thus, by multiplying the
two matrices together, disallowed transitions are removed from the allocation
procedure.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>References</h3>

<p>Verburg, P.H., Soepboer, W., Veldkamp, A., Limpiada, R., Espaldon,
V., Mastura, S.S. (2002). Modeling the spatial dynamics of regional land use:
the CLUE-S model. Environmental management, 30(3):391-405.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allowNeighb">allowNeighb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plum Island Ecosystems

## load observed land use data
obs &lt;- ObsLulcRasterStack(x=pie,
                   pattern="lu",
                   categories=c(1,2,3),
                   labels=c("forest","built","other"),
                   t=c(0,6,14))

## get land use values
x &lt;- getValues(obs[[1]])
x &lt;- x[!is.na(x)]

## create vector of arbitrary land use history values
hist &lt;- sample(1:10, length(x), replace=TRUE)

## calculate demand and get change direction for first timestep
dmd &lt;- approxExtrapDemand(obs=obs, tout=0:14)
cd &lt;- dmd[2,] - dmd[1,]
 
## create rules matrix, only allowing forest to change if the cell has
## belonged to forest for more than 8 years
rules &lt;- matrix(data=c(1,1008,1008,
                        1,1,1,
                        1,1,1), nrow=3, ncol=3, byrow=TRUE)

allow &lt;- allow(x=x,
               hist=hist,
               categories=obs@categories,
               cd=cd,
               rules=rules)

## create raster showing cells that are allowed to change from forest to built
r &lt;- obs[[1]]
r[!is.na(r)] &lt;- allow[,2]
r[obs[[1]] != 1] &lt;- NA
plot(r)

## NB output is only useful when used within allocation routine

</code></pre>

<hr>
<h2 id='allowNeighb'>Implement neighbourhood decision rules</h2><span id='topic+allowNeighb'></span>

<h3>Description</h3>

<p>Identify legitimate transitions for each cell according to neighbourhood
decision rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allowNeighb(neighb, x, categories, rules, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allowNeighb_+3A_neighb">neighb</code></td>
<td>
<p>a NeighbRasterStack object</p>
</td></tr>
<tr><td><code id="allowNeighb_+3A_x">x</code></td>
<td>
<p>a categorical RasterLayer to which neighbourhood rules should be
applied. If <code>neighb</code> is supplied it is updated with this map</p>
</td></tr>
<tr><td><code id="allowNeighb_+3A_categories">categories</code></td>
<td>
<p>numeric vector containing land use categories. If
<code>allowNeighb</code> is called from an allocation model this argument
should contain all categories in the simulation, regardless of whether
they're associated with a neighbourhood decision rule</p>
</td></tr>
<tr><td><code id="allowNeighb_+3A_rules">rules</code></td>
<td>
<p>a numeric vector with neighbourhood decision rules. Each rule
is a value between 0 and 1 representing the threshold neighbourhood value
above which change is allowed. Rules should correspond with
<code>x@categories</code></p>
</td></tr>
<tr><td><code id="allowNeighb_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allow">allow</a></code>, <code><a href="#topic+NeighbRasterStack">NeighbRasterStack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plum Island Ecosystems

## load observed land use data
obs &lt;- ObsLulcRasterStack(x=pie,
                     pattern="lu",
                     categories=c(1,2,3),
                     labels=c("forest","built","other"),
                     t=c(0,6,14))

## create a NeighbRasterStack object for forest only
w &lt;- matrix(data=1, nrow=3, ncol=3)
nb &lt;- NeighbRasterStack(x=obs[[1]], weights=w, categories=1)

## only allow change to forest within neighbourhood of current forest cells
## note that rules can be any value between zero (less restrictive) and one
## (more restrictive)
nb.allow &lt;- allowNeighb(neighb=nb,
                        x=obs[[1]],
                        categories=obs@categories,
                        rules=0.5)

## create raster showing cells allowed to change to forest
r &lt;- obs[[1]]
r[!is.na(r)] &lt;- nb.allow[,1]
plot(r)

## NB output is only useful when used within an allocation routine

</code></pre>

<hr>
<h2 id='approxExtrapDemand'>Extrapolate land use area in time</h2><span id='topic+approxExtrapDemand'></span>

<h3>Description</h3>

<p>Extrapolate land use area from two or more observed land use maps to provide
a valid (although not necessarily realistic) demand scenario.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxExtrapDemand(obs, tout, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approxExtrapDemand_+3A_obs">obs</code></td>
<td>
<p>an ObsLulcRasterStack object containing at least two maps</p>
</td></tr>
<tr><td><code id="approxExtrapDemand_+3A_tout">tout</code></td>
<td>
<p>numeric vector specifying the timesteps where interpolation is to
take place. Comparable to the <code>xout</code> argument of
<code>Hmisc::<a href="Hmisc.html#topic+approxExtrap">approxExtrap</a></code></p>
</td></tr>
<tr><td><code id="approxExtrapDemand_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>Hmisc::<a href="Hmisc.html#topic+approxExtrap">approxExtrap</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many allocation routines, including the two included with <code>lulcc</code>,
require non-spatial estimates of land use demand for every timestep in the
study period. Some routines are coupled to complex economic models that
predict future or past land use demand based on economic considerations;
however, linear extrapolation of trends remains a useful technique.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>See Also</h3>

<p><code>Hmisc::<a href="Hmisc.html#topic+approxExtrap">approxExtrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plum Island Ecosystems

## load observed land use maps
obs &lt;- ObsLulcRasterStack(x=pie,
                   pattern="lu",
                   categories=c(1,2,3),
                   labels=c("forest","built","other"),
                   t=c(0,6,14))

## obtain demand scenario by interpolating between observed maps
dmd &lt;- approxExtrapDemand(obs=obs, tout=c(0:14))

## plot
matplot(dmd, type="l", ylab="Demand (no. of cells)", xlab="Time point",
        lty=1, col=c("Green","Red","Blue"))
legend("topleft", legend=obs@labels, col=c("Green","Red","Blue"), lty=1)

## linear extrapolation is also possible
dmd &lt;- approxExtrapDemand(obs=obs, tout=c(0:50))

## plot
matplot(dmd, type="l", ylab="Demand (no. of cells)", xlab="Time point",
        lty=1, col=c("Green","Red","Blue"))
legend("topleft", legend=obs@labels, col=c("Green","Red","Blue"), lty=1)

</code></pre>

<hr>
<h2 id='as.data.frame.ExpVarRasterList'>Coerce objects to data.frame</h2><span id='topic+as.data.frame.ExpVarRasterList'></span><span id='topic+as.data.frame.ObsLulcRasterStack'></span><span id='topic+as.data.frame+2CExpVarRasterList-method'></span><span id='topic+as.data.frame+2CObsLulcRasterStack-method'></span>

<h3>Description</h3>

<p>This function extracts data from all raster objects in
<code><a href="#topic+ObsLulcRasterStack">ObsLulcRasterStack</a></code> or <code><a href="#topic+ExpVarRasterList">ExpVarRasterList</a></code> objects
for a specified timestep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ExpVarRasterList'
as.data.frame(x, row.names = NULL,
  optional = FALSE, cells, t = 0, ...)

## S3 method for class 'ObsLulcRasterStack'
as.data.frame(x, row.names = NULL,
  optional = FALSE, cells, t = 0, ...)

## S4 method for signature 'ExpVarRasterList'
as.data.frame(x, row.names = NULL,
  optional = FALSE, cells, t = 0, ...)

## S4 method for signature 'ObsLulcRasterStack'
as.data.frame(x, row.names = NULL,
  optional = FALSE, cells, t = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.ExpVarRasterList_+3A_x">x</code></td>
<td>
<p>an ExpVarRasterList or ObsLulcRasterStack object</p>
</td></tr>
<tr><td><code id="as.data.frame.ExpVarRasterList_+3A_row.names">row.names</code></td>
<td>
<p>NULL or a character vector giving the row.names for the
data.frame. Missing values are not allowed</p>
</td></tr>
<tr><td><code id="as.data.frame.ExpVarRasterList_+3A_optional">optional</code></td>
<td>
<p>logical. If TRUE, setting row names and converting column
names (to syntactic names: see make.names) is optional</p>
</td></tr>
<tr><td><code id="as.data.frame.ExpVarRasterList_+3A_cells">cells</code></td>
<td>
<p>index of cells to be extracted, which may be a
<code>SpatialPoints*</code> object or a numeric vector representing cell numbers
(see <code>raster::<a href="raster.html#topic+extract">extract</a></code>)</p>
</td></tr>
<tr><td><code id="as.data.frame.ExpVarRasterList_+3A_t">t</code></td>
<td>
<p>numeric indicating the time under consideration</p>
</td></tr>
<tr><td><code id="as.data.frame.ExpVarRasterList_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If x is an ObsLulcRasterStack object the raster corresponding to t is first
transformed to a RasterBrick with a boolean layer for each class with
<code>raster::<a href="raster.html#topic+layerize">layerize</a></code>.
</p>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>, <code><a href="#topic+ObsLulcRasterStack">ObsLulcRasterStack</a></code>,
<code><a href="#topic+ExpVarRasterList">ExpVarRasterList</a></code>, <code><a href="#topic+partition">partition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Plum Island Ecosystems

## observed maps
obs &lt;- ObsLulcRasterStack(x=pie,
                          pattern="lu", 
                          categories=c(1,2,3), 
                          labels=c("Forest","Built","Other"), 
                          t=c(0,6,14))

## explanatory variables
ef &lt;- ExpVarRasterList(x=pie, pattern="ef")

## separate data into training and testing partitions
part &lt;- partition(x=obs[[1]], size=0.1, spatial=TRUE)
df1 &lt;- as.data.frame(x=obs, cells=part[["all"]], t=0)
df2 &lt;- as.data.frame(x=ef, cells=part[["all"]], t=0)


## End(Not run)
</code></pre>

<hr>
<h2 id='c.PredictiveModelList'>Merge PredictiveModelList objects</h2><span id='topic+c.PredictiveModelList'></span>

<h3>Description</h3>

<p>Combine different PredictiveModelList objects into one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PredictiveModelList'
c(..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.PredictiveModelList_+3A_...">...</code></td>
<td>
<p>two or more PredictiveModelList objects</p>
</td></tr>
<tr><td><code id="c.PredictiveModelList_+3A_recursive">recursive</code></td>
<td>
<p>for consistency with generic method (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a PredictiveModelList object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Plum Island Ecosystems

## load data
data(pie)

## observed maps
obs &lt;- ObsLulcRasterStack(x=pie,
                   pattern="lu", 
                   categories=c(1,2,3), 
                   labels=c("Forest","Built","Other"), 
                   t=c(0,6,14))

## explanatory variables
ef &lt;- ExpVarRasterList(x=pie, pattern="ef")

part &lt;- partition(x=obs[[1]], size=0.1, spatial=TRUE)
train.data &lt;- getPredictiveModelInputData(obs=obs, ef=ef, cells=part[["train"]], t=0)

forms &lt;- list(Built ~ ef_001+ef_002+ef_003,
              Forest ~ 1,
              Other ~ ef_001+ef_002)

glm.models &lt;- glmModels(formula=forms, family=binomial, data=train.data, obs=obs)
glm.models

## separate glm.models into two PredictiveModelList objects
mod1 &lt;- glm.models[[1]]
mod2 &lt;- glm.models[[2:3]]

## put them back together again
glm.models &lt;- c(mod1, mod2)
glm.models


## End(Not run)
</code></pre>

<hr>
<h2 id='CategoryLabel-class'>Virtual class CategoryLabel</h2><span id='topic+CategoryLabel-class'></span>

<h3>Description</h3>

<p>A virtual S4 class to represent information about categorical Raster* objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>categories</code></dt><dd><p>numeric vector of land use categories</p>
</dd>
<dt><code>labels</code></dt><dd><p>character vector corresponding to <code>categories</code></p>
</dd>
</dl>

<hr>
<h2 id='CluesModel'>Create a CluesModel object</h2><span id='topic+CluesModel'></span><span id='topic+CluesModel+2CObsLulcRasterStack+2CExpVarRasterList+2CPredictiveModelList-method'></span>

<h3>Description</h3>

<p>Methods to create a <code>CluesModel</code> object to supply to
<code><a href="#topic+allocate">allocate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CluesModel(obs, ef, models, ...)


  ## S4 method for signature 
## 'ObsLulcRasterStack,ExpVarRasterList,PredictiveModelList'
CluesModel(obs,
  ef, models, time, demand, hist, mask, neighb = NULL, elas, rules = NULL,
  nb.rules = NULL, params, output = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CluesModel_+3A_obs">obs</code></td>
<td>
<p>an ObsLulcRasterStack</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_ef">ef</code></td>
<td>
<p>an ExpVarRasterList object</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_models">models</code></td>
<td>
<p>a PredictiveModelList object</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_time">time</code></td>
<td>
<p>numeric vector containing timesteps over which simulation will
occur</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_demand">demand</code></td>
<td>
<p>matrix with demand for each land use category in terms of number
of cells to be allocated. The first row should be the number of cells
allocated to the initial observed land use map (i.e. the land use map for
time 0)</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_hist">hist</code></td>
<td>
<p>RasterLayer containing land use history (values represent the
number of years the cell has contained the current land use category)</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_mask">mask</code></td>
<td>
<p>RasterLayer containing binary values where 0 indicates cells
that are not allowed to change</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_neighb">neighb</code></td>
<td>
<p>an object of class NeighbRasterStack</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_elas">elas</code></td>
<td>
<p>numeric indicating the elasticity of each land use category to
change. Elasticity varies between 0 and 1, with 0 indicating a low
resistance to change and 1 indicating a high resistance to change</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_rules">rules</code></td>
<td>
<p>matrix with land use change decision rules</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_nb.rules">nb.rules</code></td>
<td>
<p>numeric with neighbourhood decision rules</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_params">params</code></td>
<td>
<p>list with model parameters</p>
</td></tr>
<tr><td><code id="CluesModel_+3A_output">output</code></td>
<td>
<p>either a RasterStack containing output maps or NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>params</code> argument is a list of parameter values which should contain
the following components:
</p>

<dl>
<dt><code>jitter.f</code></dt><dd><p>Parameter controlling the amount of perturbation
applied to the probability surface prior to running the CLUE-S iterative
algorithm. Higher values result in more perturbation. Default is 0.0001</p>
</dd>
<dt><code>scale.f</code></dt><dd><p>Scale factor which controls the amount by which
suitability is increased if demand is not met. Default is 0.0005</p>
</dd>
<dt><code>max.iter</code></dt><dd><p>The maximum number of iterations in the simulation</p>
</dd>
<dt><code>max.diff</code></dt><dd><p>The maximum allowed difference between allocated and
demanded area of any land use type. Default is 5</p>
</dd>
<dt><code>ave.diff</code></dt><dd><p>The average allowed difference between allocated and
demanded area. Default is 5</p>
</dd>
</dl>

<p>Note that, in order to achieve convergence, it is likely that some adjustment
of these parameters will be required.
</p>


<h3>Value</h3>

<p>A CluesModel object.
</p>


<h3>References</h3>

<p>Verburg, P.H., Soepboer, W., Veldkamp, A., Limpiada, R., Espaldon, V., Mastura,
S.S. (2002). Modeling the spatial dynamics of regional land use: the CLUE-S
model. Environmental management, 30(3):391-405.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CluesModel-class">CluesModel-class</a></code>, <code><a href="#topic+allocate">allocate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='CluesModel-class'>Class CluesModel</h2><span id='topic+CluesModel-class'></span>

<h3>Description</h3>

<p>An S4 class to represent inputs to the CLUE-S land use change model.
</p>


<h3>Slots</h3>


<dl>
<dt><code>obs</code></dt><dd><p>an ObsLulcRasterStack object</p>
</dd>
<dt><code>ef</code></dt><dd><p>an ExpVarRasterList object</p>
</dd>
<dt><code>models</code></dt><dd><p>a PredictiveModelList object</p>
</dd>
<dt><code>time</code></dt><dd><p>numeric vector of timesteps over which simulation will occur</p>
</dd>
<dt><code>demand</code></dt><dd><p>matrix containing demand scenario</p>
</dd>
<dt><code>hist</code></dt><dd><p>RasterLayer showing land use history or NULL</p>
</dd>
<dt><code>mask</code></dt><dd><p>RasterLayer showing masked areas or NULL</p>
</dd>
<dt><code>neighb</code></dt><dd><p>NeighbRasterStack object or NULL</p>
</dd>
<dt><code>categories</code></dt><dd><p>numeric vector of land use categories</p>
</dd>
<dt><code>labels</code></dt><dd><p>character vector corresponding to <code>categories</code></p>
</dd>
<dt><code>rules</code></dt><dd><p>matrix with land use change decision rules</p>
</dd>
<dt><code>nb.rules</code></dt><dd><p>numeric with neighbourhood decision rules</p>
</dd>
<dt><code>elas</code></dt><dd><p>numeric indicating elasticity to change (only required for</p>
</dd>
<dt><code>params</code></dt><dd><p>list with model parameters</p>
</dd>
<dt><code>output</code></dt><dd><p>RasterStack containing simulated land use maps or NULL</p>
</dd>
</dl>

<hr>
<h2 id='compareAUC'>Calculate the area under the ROC curve (AUC)</h2><span id='topic+compareAUC'></span><span id='topic+compareAUC+2CPredictionList-method'></span><span id='topic+compareAUC+2Clist-method'></span>

<h3>Description</h3>

<p>Estimate the AUC for each <code>ROCR::<a href="ROCR.html#topic+prediction">prediction</a></code> object in a
<code><a href="#topic+PredictionList">PredictionList</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareAUC(pred, ...)

## S4 method for signature 'PredictionList'
compareAUC(pred, digits = 4, ...)

## S4 method for signature 'list'
compareAUC(pred, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareAUC_+3A_pred">pred</code></td>
<td>
<p>a PredictionList object or a list of these</p>
</td></tr>
<tr><td><code id="compareAUC_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
<tr><td><code id="compareAUC_+3A_digits">digits</code></td>
<td>
<p>numeric indicating the number of digits to be displayed after
the decimal point for AUC values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can compare the performance of different statistical models by
providing a list of <code>PredictionList</code> objects. Note that <code>compareAUC</code>
should be used in conjunction with other comparison methods because the AUC
does not contain as much information as, for instance, the ROC curve itself
(Pontius and Parmentier, 2014).
</p>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>References</h3>

<p>Sing, T., Sander, O., Beerenwinkel, N., Lengauer, T. (2005). ROCR: visualizing
classifier performance in R. Bioinformatics 21(20):3940-3941.
</p>
<p>Pontius Jr, R. G., &amp; Parmentier, B. (2014). Recommendations for using the
relative operating characteristic (ROC). Landscape ecology, 29(3), 367-382.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PredictionList">PredictionList</a></code>, <code>ROCR::<a href="ROCR.html#topic+performance">performance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see PredictiveModelList examples
</code></pre>

<hr>
<h2 id='crossTabulate'>Cross tabulate land use transitions</h2><span id='topic+crossTabulate'></span><span id='topic+crossTabulate+2CRasterLayer+2CRasterLayer-method'></span><span id='topic+crossTabulate+2CObsLulcRasterStack+2CANY-method'></span>

<h3>Description</h3>

<p>Cross tabulate land use transitions using
<code>raster::<a href="raster.html#topic+crosstab">crosstab</a></code>. This step should form the basis of
further research into the processes driving the most important transitions in
the study region (Pontius et al., 2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossTabulate(x, y, ...)

## S4 method for signature 'RasterLayer,RasterLayer'
crossTabulate(x, y, categories,
  labels = as.character(categories), ...)

## S4 method for signature 'ObsLulcRasterStack,ANY'
crossTabulate(x, y, times, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossTabulate_+3A_x">x</code></td>
<td>
<p>RasterLayer representing land use map from an earlier timestep or an
ObsLulcRasterStack object containing at least two land use maps for different
points in time</p>
</td></tr>
<tr><td><code id="crossTabulate_+3A_y">y</code></td>
<td>
<p>RasterLayer representing land use map from a later timestep. Not used
if <code>x</code> is an ObsLulcRasterStack object</p>
</td></tr>
<tr><td><code id="crossTabulate_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>raster::<a href="raster.html#topic+crosstab">crosstab</a></code></p>
</td></tr>
<tr><td><code id="crossTabulate_+3A_categories">categories</code></td>
<td>
<p>numeric vector containing land use categories to consider.
Not used if <code>x</code> is an ObsLulcRasterStack object</p>
</td></tr>
<tr><td><code id="crossTabulate_+3A_labels">labels</code></td>
<td>
<p>character vector (optional) with labels corresponding to
<code>categories</code>. Not used if <code>x</code> is an ObsLulcRasterStack object</p>
</td></tr>
<tr><td><code id="crossTabulate_+3A_times">times</code></td>
<td>
<p>numeric vector representing the time points of two land use maps
from ObsLulcRasterStack</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>References</h3>

<p>Pontius Jr, R.G., Shusas, E., McEachern, M. (2004). Detecting
important categorical land changes while accounting for persistence.
Agriculture, Ecosystems &amp; Environment 101(2):251-268.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ObsLulcRasterStack">ObsLulcRasterStack</a></code>, <code>raster::<a href="raster.html#topic+crosstab">crosstab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plum Island Ecosystems 

## Load observed land use maps
obs &lt;- ObsLulcRasterStack(x=pie,
                   pattern="lu",
                   categories=c(1,2,3),
                   labels=c("forest","built","other"),
                   t=c(0,6,14))

crossTabulate(x=obs, times=c(0,14))

## RasterLayer input
crossTabulate(x=obs[[1]],
              y=obs[[3]],
              categories=c(1,2,3),
              labels=c("forest","built","other"))

</code></pre>

<hr>
<h2 id='ExpVarRasterList'>Create an ExpVarRasterList object</h2><span id='topic+ExpVarRasterList'></span><span id='topic+ExpVarRasterList+2Cmissing-method'></span><span id='topic+ExpVarRasterList+2Cmissing+2Ccharacter-method'></span><span id='topic+ExpVarRasterList+2Ccharacter-method'></span><span id='topic+ExpVarRasterList+2Ccharacter+2Ccharacter-method'></span><span id='topic+ExpVarRasterList+2CRasterStack-method'></span><span id='topic+ExpVarRasterList+2CRasterStack+2Ccharacter-method'></span><span id='topic+ExpVarRasterList+2Clist-method'></span><span id='topic+ExpVarRasterList+2Clist+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Methods to load maps of explanatory variables, which may be created from file,
an existing Raster* object or a list of Raster* objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpVarRasterList(x, ...)

## S4 method for signature 'missing'
ExpVarRasterList(x, pattern = NULL, ...)

## S4 method for signature 'character'
ExpVarRasterList(x, pattern = NULL, ...)

## S4 method for signature 'RasterStack'
ExpVarRasterList(x, pattern = NULL, ...)

## S4 method for signature 'list'
ExpVarRasterList(x, pattern = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpVarRasterList_+3A_x">x</code></td>
<td>
<p>path (character) to directory containing observed land use maps,
a Raster* object or a list of Raster* objects</p>
</td></tr>
<tr><td><code id="ExpVarRasterList_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>raster::<a href="raster.html#topic+stack">stack</a></code></p>
</td></tr>
<tr><td><code id="ExpVarRasterList_+3A_pattern">pattern</code></td>
<td>
<p>regular expression (character). Only filenames (if <code>x</code> is
a path) or Raster* objects (if <code>x</code> is a list) matching the regular
expression will be returned. See <br />
<code>raster::<a href="raster.html#topic+raster">raster</a></code> for more information about supported
filetypes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Explanatory variables should follow a naming convention to identify them as
static (one map provided for the study period) or dynamic (one map provided
for each year of the study period). The name should consist of two (static)
or three (dynamic) parts: firstly, the prefix should differentiate explanatory
variables from other maps in the directory, list or RasterStack. This should
be followed by a unique number to differentiate the explanatory variables
(note that the order of variables in the ExpVarRasterList object is determined by
this value) If the variable is dynamic this number should be followed by a
second number representing the timestep to which the map applies. Dynamic
variables should include a map for time 0 (corresponding to the initial
observed map) and every subsequent timestep in the simulation. The different
parts should be separated by a period or underscore.
</p>
<p>Maps of different explanatory variables should have the same coordinate
reference system but do not have to have the same extent and resolution as
long as the minimum extent is that of the study region defined by an
<code>ObsLulcRasterStack</code> object. However, maps for different timesteps of the same
dynamic variable should have the same extent and resolution because these are
stored as RasterStack objects.
</p>


<h3>Value</h3>

<p>An ExpVarRasterList object.
</p>


<h3>See Also</h3>

<p><code>raster::<a href="raster.html#topic+stack">stack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plum Island Ecosystems
ef &lt;- ExpVarRasterList(x=pie, pattern="ef")

## Sibuyan
ef &lt;- ExpVarRasterList(x=sibuyan$maps, pattern="ef")

</code></pre>

<hr>
<h2 id='ExpVarRasterList-class'>Class ExpVarRasterList</h2><span id='topic+ExpVarRasterList-class'></span>

<h3>Description</h3>

<p>An S4 class for explanatory variables.
</p>


<h3>Slots</h3>


<dl>
<dt><code>maps</code></dt><dd><p>list of RasterStack objects. The length of the list corresponds to
the number of explanatory variables and the number of layers in each
RasterStack represents time</p>
</dd>
<dt><code>names</code></dt><dd><p>character vector with the name of each variable in <code>maps</code></p>
</dd>
<dt><code>dynamic</code></dt><dd><p>logical indicating whether dynamic variables are present</p>
</dd>
</dl>

<hr>
<h2 id='Extract+20by+20index'>Extract by index</h2><span id='topic+Extract+20by+20index'></span><span id='topic++5B+5B+2CExpVarRasterList+2CANY+2CANY-method'></span><span id='topic++5B+5B+2CCategoryLabel+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p><code>object[[i]]</code> can be used to extract individual objects from container
classes such as <code>ExpVarRasterList</code>, <code>PredictiveModelList</code>, <code>PredictionList</code> and
<code>PerformanceList</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ExpVarRasterList,ANY,ANY'
x[[i, j, ...]]

## S4 method for signature 'CategoryLabel,ANY,ANY'
x[[i, j, ...]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract+2B20by+2B20index_+3A_x">x</code></td>
<td>
<p>an object of class ExpVarRasterList or any object inheriting from the
virtual class CategoryLabel</p>
</td></tr>
<tr><td><code id="Extract+2B20by+2B20index_+3A_i">i</code></td>
<td>
<p>layer number (if 'x' inherits from a RasterStack) or list index (if
'x' stores data as a list)</p>
</td></tr>
<tr><td><code id="Extract+2B20by+2B20index_+3A_j">j</code></td>
<td>
<p>numeric (not used)</p>
</td></tr>
<tr><td><code id="Extract+2B20by+2B20index_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plum Island Ecosystems

## Load observed land use maps
obs &lt;- ObsLulcRasterStack(x=pie,
                   pattern="lu",
                   categories=c(1,2,3),
                   labels=c("forest","built","other"),
                   t=c(0,6,14))

summary(obs[[1]])
summary(obs[[1:2]])

</code></pre>

<hr>
<h2 id='FigureOfMerit'>Create a FigureOfMerit object</h2><span id='topic+FigureOfMerit'></span><span id='topic+FigureOfMerit+2CRasterLayer-method'></span><span id='topic+FigureOfMerit+2CThreeMapComparison-method'></span>

<h3>Description</h3>

<p>Calculate the figure of merit at different levels and at different resolutions
for a reference map at time 1, a reference map at time 2 and a simulated map
at time 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FigureOfMerit(x, ...)

## S4 method for signature 'RasterLayer'
FigureOfMerit(x, ...)

## S4 method for signature 'ThreeMapComparison'
FigureOfMerit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FigureOfMerit_+3A_x">x</code></td>
<td>
<p>a ThreeMapComparison object or RasterLayer</p>
</td></tr>
<tr><td><code id="FigureOfMerit_+3A_...">...</code></td>
<td>
<p>additional arguments to ThreeMapComparison. Only required if x is
not a ThreeMapComparison object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In land use change modelling the figure of merit is the intersection of
observed change and simulated change divided by the union of these, with a
range of 0 (perfect disagreement) to 1 (perfect agreement). It is useful to
calculate the figure of merit at three levels: (1) considering all possible
transitions from all land use categories, (2) considering all transitions from
specific land use categories and (3) considering a specific transition from
one land use category to another.
</p>


<h3>Value</h3>

<p>A FigureOfMerit object.
</p>


<h3>References</h3>

<p>Pontius Jr, R.G., Peethambaram, S., Castella, J.C. (2011).
Comparison of three maps at multiple resolutions: a case study of land change
simulation in Cho Don District, Vietnam. Annals of the Association of American
Geographers 101(1): 45-62.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.FigureOfMerit">plot.FigureOfMerit</a></code>, <code><a href="#topic+ThreeMapComparison">ThreeMapComparison</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='FigureOfMerit-class'>Class FigureOfMerit</h2><span id='topic+FigureOfMerit-class'></span>

<h3>Description</h3>

<p>An S4 class for different figure of merit scores.
</p>


<h3>Slots</h3>


<dl>
<dt><code>tables</code></dt><dd><p>list of data.frames that depict the three dimensional table
described by Pontius et al. (2011) at different resolutions</p>
</dd>
<dt><code>factors</code></dt><dd><p>numeric vector of aggregation factors</p>
</dd>
<dt><code>maps</code></dt><dd><p>list of RasterStack objects containing land use maps at different
resolutions</p>
</dd>
<dt><code>categories</code></dt><dd><p>numeric vector of land use categories</p>
</dd>
<dt><code>labels</code></dt><dd><p>character vector corresponding to <code>categories</code></p>
</dd>
<dt><code>overall</code></dt><dd><p>list containing the overall figure of merit score for each
aggregation factor</p>
</dd>
<dt><code>category</code></dt><dd><p>list of numeric vectors containing category specific scores</p>
</dd>
<dt><code>transition</code></dt><dd><p>list of matrices containing transition specific scores</p>
</dd>
</dl>

<hr>
<h2 id='getPredictiveModelInputData'>Extract data to fit predictive models</h2><span id='topic+getPredictiveModelInputData'></span>

<h3>Description</h3>

<p>Extract a data.frame containing variables required for fitting predictive
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPredictiveModelInputData(obs, ef, cells, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPredictiveModelInputData_+3A_obs">obs</code></td>
<td>
<p>an ObsLulcRasterStack object</p>
</td></tr>
<tr><td><code id="getPredictiveModelInputData_+3A_ef">ef</code></td>
<td>
<p>an ExpVarRasterList object</p>
</td></tr>
<tr><td><code id="getPredictiveModelInputData_+3A_cells">cells</code></td>
<td>
<p>index of cells to be extracted, which may be a
<code>SpatialPoints*</code> object or a numeric vector representing cell numbers
(see <code>raster::<a href="raster.html#topic+extract">extract</a></code>)</p>
</td></tr>
<tr><td><code id="getPredictiveModelInputData_+3A_...">...</code></td>
<td>
<p>additional arguments to <a href="base.html#topic+as.data.frame">as.data.frame</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>, <code><a href="#topic+ObsLulcRasterStack">ObsLulcRasterStack</a></code>,
<code><a href="#topic+ExpVarRasterList">ExpVarRasterList</a></code>, <code><a href="#topic+partition">partition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## TODO
</code></pre>

<hr>
<h2 id='Model+20fitting'>Fit predictive models</h2><span id='topic+Model+20fitting'></span><span id='topic+glmModels'></span><span id='topic+randomForestModels'></span><span id='topic+rpartModels'></span>

<h3>Description</h3>

<p>These functions fit parametric and non-parametric models to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmModels(formula, family = binomial, model = FALSE, ..., obs,
  categories = NA, labels = NA)

randomForestModels(formula, ..., obs, categories = NA, labels = NA)

rpartModels(formula, ..., obs, categories = NA, labels = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Model+2B20fitting_+3A_formula">formula</code></td>
<td>
<p>list containing formula objects</p>
</td></tr>
<tr><td><code id="Model+2B20fitting_+3A_family">family</code></td>
<td>
<p>see <code><a href="stats.html#topic+glm">glm</a></code>. Default is 'binomial'. Only used by
<code>glmModels</code></p>
</td></tr>
<tr><td><code id="Model+2B20fitting_+3A_model">model</code></td>
<td>
<p>see <code><a href="stats.html#topic+glm">glm</a></code>. Default is FALSE. Only used by
<code>glmModels</code></p>
</td></tr>
<tr><td><code id="Model+2B20fitting_+3A_...">...</code></td>
<td>
<p>additional arguments to specific functions</p>
</td></tr>
<tr><td><code id="Model+2B20fitting_+3A_obs">obs</code></td>
<td>
<p>an ObsLulcRasterStack object</p>
</td></tr>
<tr><td><code id="Model+2B20fitting_+3A_categories">categories</code></td>
<td>
<p>numeric vector of land use categories in observed maps.
Only required if 'obs' is missing</p>
</td></tr>
<tr><td><code id="Model+2B20fitting_+3A_labels">labels</code></td>
<td>
<p>character vector (optional) with labels corresponding to
<code>categories</code>. Only required if 'obs' is missing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A PredictiveModelList object.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code>rpart::<a href="rpart.html#topic+rpart">rpart</a></code>,
<code>randomForest::<a href="randomForest.html#topic+randomForest">randomForest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='Model-class'>Virtual class Model</h2><span id='topic+Model-class'></span>

<h3>Description</h3>

<p>A virtual S4 class to represent land use change models.
</p>


<h3>Slots</h3>


<dl>
<dt><code>output</code></dt><dd><p>RasterStack containing simulated land use maps or NULL</p>
</dd>
</dl>

<hr>
<h2 id='NeighbRasterStack'>Create a NeighbRasterStack object</h2><span id='topic+NeighbRasterStack'></span><span id='topic+NeighbRasterStack+2CRasterLayer+2Clist+2CANY-method'></span><span id='topic+NeighbRasterStack+2CRasterLayer+2Cmatrix+2CANY-method'></span><span id='topic+NeighbRasterStack+2CRasterLayer+2CANY+2CNeighbRasterStack-method'></span>

<h3>Description</h3>

<p>Methods to calculate neighbourhood values for cells in raster maps using
<code>raster::<a href="raster.html#topic+focal">focal</a></code>. By default the fraction of non-NA cells
within the moving window (i.e. the size of the weights matrix) devoted to each
land use category is calculated. This behaviour can be changed by altering the
weights matrix or providing an alternative function. The resulting object can
be used as the basis of neighbourhood decision rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NeighbRasterStack(x, weights, neighb, ...)

## S4 method for signature 'RasterLayer,list,ANY'
NeighbRasterStack(x, weights, neighb,
  categories, fun = mean, ...)

## S4 method for signature 'RasterLayer,matrix,ANY'
NeighbRasterStack(x, weights, neighb,
  categories, fun = mean, ...)

## S4 method for signature 'RasterLayer,ANY,NeighbRasterStack'
NeighbRasterStack(x, weights,
  neighb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NeighbRasterStack_+3A_x">x</code></td>
<td>
<p>RasterLayer containing categorical data</p>
</td></tr>
<tr><td><code id="NeighbRasterStack_+3A_weights">weights</code></td>
<td>
<p>list containing a matrix of weights (the <code>w</code> argument in
<code>raster::<a href="raster.html#topic+focal">focal</a></code>) for each land use category. The order
of list or vector elements should correspond to the order of land use
categories in <code>categories</code></p>
</td></tr>
<tr><td><code id="NeighbRasterStack_+3A_neighb">neighb</code></td>
<td>
<p>NeighbRasterStack object. Only used if <code>categories</code> and
<code>weights</code> are not provided. This option can be useful when existing
NeighbRasterStack objects need to be updated because a new land use map is
available, such as during the allocation procedure.</p>
</td></tr>
<tr><td><code id="NeighbRasterStack_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>raster::<a href="raster.html#topic+focal">focal</a></code></p>
</td></tr>
<tr><td><code id="NeighbRasterStack_+3A_categories">categories</code></td>
<td>
<p>numeric vector containing land use categories for which
neighbourhood values should be calculated</p>
</td></tr>
<tr><td><code id="NeighbRasterStack_+3A_fun">fun</code></td>
<td>
<p>function. Input argument to <code>focal</code>. Default is <code>mean</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A NeighbRasterStack object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NeighbRasterStack-class">NeighbRasterStack-class</a></code>, <code><a href="#topic+allowNeighb">allowNeighb</a></code>,
<code>raster::<a href="raster.html#topic+focal">focal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plum Island Ecosystems

## observed data
obs &lt;- ObsLulcRasterStack(x=pie,
                    pattern="lu",
                    categories=c(1,2,3),
                    labels=c("forest","built","other"),
                    t=c(0,6,14))

## create a NeighbRasterStack object for 1985 land use map
w1 &lt;- matrix(data=1, nrow=3, ncol=3, byrow=TRUE)
w2 &lt;- w1
w3 &lt;- w1

nb1 &lt;- NeighbRasterStack(x=obs[[1]],
                 categories=c(1,2,3),
                 weights=list(w1,w2,w3))

## update nb2 for 1991
nb2 &lt;- NeighbRasterStack(x=obs[[2]],
                  neighb=nb1)

## plot neighbourhood map for forest
plot(nb2[[1]])

</code></pre>

<hr>
<h2 id='NeighbRasterStack-class'>Class NeighbRasterStack</h2><span id='topic+NeighbRasterStack-class'></span>

<h3>Description</h3>

<p>An S4 class for neighbourhood maps.
</p>


<h3>Slots</h3>


<dl>
<dt><code>filename</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>layers</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>title</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>extent</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>rotated</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>rotation</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>ncols</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>nrows</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>crs</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>history</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>z</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>calls</code></dt><dd><p>list containing each call to <code>raster::<a href="raster.html#topic+focal">focal</a></code></p>
</dd>
<dt><code>categories</code></dt><dd><p>numeric vector of land use categories for which neighbourhood
maps exist</p>
</dd>
</dl>

<hr>
<h2 id='ObsLulcRasterStack'>Create an ObsLulcRasterStack object</h2><span id='topic+ObsLulcRasterStack'></span><span id='topic+ObsLulcRasterStack+2Cmissing+2Ccharacter-method'></span><span id='topic+ObsLulcRasterStack+2Ccharacter+2Ccharacter-method'></span><span id='topic+ObsLulcRasterStack+2Clist+2Ccharacter-method'></span><span id='topic+ObsLulcRasterStack+2CRasterLayer+2CANY-method'></span><span id='topic+ObsLulcRasterStack+2CRasterStack+2CANY-method'></span>

<h3>Description</h3>

<p>Methods to create an ObsLulcRasterStack object, which may be created from file, an
existing Raster* object or a list of Raster* objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ObsLulcRasterStack(x, pattern, ...)

## S4 method for signature 'missing,character'
ObsLulcRasterStack(x, pattern, ...)

## S4 method for signature 'character,character'
ObsLulcRasterStack(x, pattern, ...)

## S4 method for signature 'list,character'
ObsLulcRasterStack(x, pattern, ...)

## S4 method for signature 'RasterLayer,ANY'
ObsLulcRasterStack(x, pattern, ...)

## S4 method for signature 'RasterStack,ANY'
ObsLulcRasterStack(x, pattern, categories, labels,
  t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ObsLulcRasterStack_+3A_x">x</code></td>
<td>
<p>path (character), Raster* object or list of Raster* objects. Default
behaviour is to search for files in the working directory</p>
</td></tr>
<tr><td><code id="ObsLulcRasterStack_+3A_pattern">pattern</code></td>
<td>
<p>regular expression (character). Only filenames (if <code>x</code> is
a path) or Raster* objects (if <code>x</code> is a list) matching the regular
expression will be returned. See <br />
<code>raster::<a href="raster.html#topic+raster">raster</a></code> for more information about supported filetypes</p>
</td></tr>
<tr><td><code id="ObsLulcRasterStack_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>raster::<a href="raster.html#topic+stack">stack</a></code></p>
</td></tr>
<tr><td><code id="ObsLulcRasterStack_+3A_categories">categories</code></td>
<td>
<p>numeric vector of land use categories in observed maps</p>
</td></tr>
<tr><td><code id="ObsLulcRasterStack_+3A_labels">labels</code></td>
<td>
<p>character vector (optional) with labels corresponding to
<code>categories</code></p>
</td></tr>
<tr><td><code id="ObsLulcRasterStack_+3A_t">t</code></td>
<td>
<p>numeric vector containing the timestep of each observed map. The 
first timestep must be 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Observed land use maps should have the same extent and resolution. The
location of non-NA cells in <code>ObsLulcRasterStack</code> objects defines the region for
subsequent analysis.
</p>


<h3>Value</h3>

<p>An ObsLulcRasterStack object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ObsLulcRasterStack-class">ObsLulcRasterStack-class</a></code>, <code>raster::<a href="raster.html#topic+stack">stack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plum Island Ecosystems
obs &lt;- ObsLulcRasterStack(x=pie,
                   pattern="lu",
                   categories=c(1,2,3),
                   labels=c("forest","built","other"),
                   t=c(0,6,14))

## Sibuyan Island
obs &lt;- ObsLulcRasterStack(x=sibuyan$maps,
                   pattern="lu",
                   categories=c(1,2,3,4,5),
                   labels=c("forest","coconut","grass","rice","other"),
                   t=c(0,14))

</code></pre>

<hr>
<h2 id='ObsLulcRasterStack-class'>Class ObsLulcRasterStack</h2><span id='topic+ObsLulcRasterStack-class'></span>

<h3>Description</h3>

<p>An S4 class for observed land use maps.
</p>


<h3>Slots</h3>


<dl>
<dt><code>filename</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>layers</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>title</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>extent</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>rotated</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>rotation</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>ncols</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>nrows</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>crs</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>history</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>z</code></dt><dd><p>see <code>raster::<a href="raster.html#topic+Raster-class">Raster-class</a></code></p>
</dd>
<dt><code>t</code></dt><dd><p>numeric vector with timesteps corresponding to each observed map</p>
</dd>
<dt><code>categories</code></dt><dd><p>numeric vector of land use categories</p>
</dd>
<dt><code>labels</code></dt><dd><p>character vector corresponding to <code>categories</code></p>
</dd>
</dl>

<hr>
<h2 id='OrderedModel'>Create an OrderedModel object</h2><span id='topic+OrderedModel'></span><span id='topic+OrderedModel+2CObsLulcRasterStack+2CExpVarRasterList+2CPredictiveModelList-method'></span>

<h3>Description</h3>

<p>Methods to create a <code>OrderedModel</code> object to supply to
<code><a href="#topic+allocate">allocate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OrderedModel(obs, ef, models, ...)


  ## S4 method for signature 
## 'ObsLulcRasterStack,ExpVarRasterList,PredictiveModelList'
OrderedModel(obs,
  ef, models, time, demand, hist, mask, neighb = NULL, rules = NULL,
  nb.rules = NULL, order, params, output = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OrderedModel_+3A_obs">obs</code></td>
<td>
<p>an ObsLulcRasterStack object</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_ef">ef</code></td>
<td>
<p>an ExpVarRasterList object</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_models">models</code></td>
<td>
<p>a PredictiveModelList object</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_time">time</code></td>
<td>
<p>numeric vector containing timesteps over which simulation will
occur</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_demand">demand</code></td>
<td>
<p>matrix with demand for each land use category in terms of number
of cells to be allocated. The first row should be the number of cells
allocated to the initial observed land use map (i.e. the land use map for
time 0)</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_hist">hist</code></td>
<td>
<p>RasterLayer containing land use history (values represent the
number of years the cell has contained the current land use category)</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_mask">mask</code></td>
<td>
<p>RasterLayer containing binary values where 0 indicates cells
that are not allowed to change</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_neighb">neighb</code></td>
<td>
<p>an object of class NeighbRasterStack</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_rules">rules</code></td>
<td>
<p>matrix with land use change decision rules</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_nb.rules">nb.rules</code></td>
<td>
<p>numeric with neighbourhood decision rules</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_order">order</code></td>
<td>
<p>numeric vector of land use categories in the order that change
should be allocated. See Details</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_params">params</code></td>
<td>
<p>list with model parameters</p>
</td></tr>
<tr><td><code id="OrderedModel_+3A_output">output</code></td>
<td>
<p>either a RasterStack containing output maps or NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>params</code> argument is a list of parameter values which should contain
the following components:
</p>

<dl>
<dt><code>max.diff</code></dt><dd><p>The maximum allowed difference between allocated and
demanded area of any land use type. Default is 5</p>
</dd>
</dl>



<h3>Value</h3>

<p>An OrderedModel object.
</p>


<h3>References</h3>

<p>Fuchs, R., Herold, M., Verburg, P.H., and Clevers, J.G.P.W. (2013). A
high-resolution and harmonized model approach for reconstructing and analysing
historic land changes in Europe, Biogeosciences, 10:1543-1559.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+OrderedModel-class">OrderedModel-class</a></code>, <code><a href="#topic+allocate">allocate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='OrderedModel-class'>Class OrderedModel</h2><span id='topic+OrderedModel-class'></span>

<h3>Description</h3>

<p>An S4 class to represent inputs to the Ordered allocation procedure
</p>


<h3>Slots</h3>


<dl>
<dt><code>obs</code></dt><dd><p>an ObsLulcRasterStack object</p>
</dd>
<dt><code>ef</code></dt><dd><p>an ExpVarRasterList object</p>
</dd>
<dt><code>models</code></dt><dd><p>a PredictiveModelList object</p>
</dd>
<dt><code>time</code></dt><dd><p>numeric vector of timesteps over which simulation will occur</p>
</dd>
<dt><code>demand</code></dt><dd><p>matrix containing demand scenario</p>
</dd>
<dt><code>hist</code></dt><dd><p>RasterLayer showing land use history or NULL</p>
</dd>
<dt><code>mask</code></dt><dd><p>RasterLayer showing masked areas or NULL</p>
</dd>
<dt><code>neighb</code></dt><dd><p>NeighbRasterStack object or NULL</p>
</dd>
<dt><code>categories</code></dt><dd><p>numeric vector of land use categories</p>
</dd>
<dt><code>labels</code></dt><dd><p>character vector corresponding to <code>categories</code></p>
</dd>
<dt><code>rules</code></dt><dd><p>matrix with land use change decision rules</p>
</dd>
<dt><code>nb.rules</code></dt><dd><p>numeric with neighbourhood decision rules</p>
</dd>
<dt><code>order</code></dt><dd><p>numeric vector of land use categories in the order that change
should be allocated</p>
</dd>
<dt><code>params</code></dt><dd><p>list with model parameters</p>
</dd>
<dt><code>output</code></dt><dd><p>RasterStack containing simulated land use maps or NULL</p>
</dd>
</dl>

<hr>
<h2 id='partition'>Partition raster data</h2><span id='topic+partition'></span>

<h3>Description</h3>

<p>Divide a categorical raster map into training and testing partitions.
A wrapper function for <br />
<code>caret::<a href="caret.html#topic+createDataPartition">createDataPartition</a></code> (Kuhn, 2008) to divide a
categorical raster map into training and testing partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(x, size = 0.5, spatial = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_+3A_x">x</code></td>
<td>
<p>RasterLayer with categorical data</p>
</td></tr>
<tr><td><code id="partition_+3A_size">size</code></td>
<td>
<p>numeric value between zero and one indicating the proportion of
non-NA cells that should be included in the training partition. Default is
0.5, which results in equally sized partitions</p>
</td></tr>
<tr><td><code id="partition_+3A_spatial">spatial</code></td>
<td>
<p>logical. If TRUE, the function returns a SpatialPoints object
with the coordinates of cells in each partition. If FALSE, the cell numbers
are returned</p>
</td></tr>
<tr><td><code id="partition_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code>train</code></dt><dd><p>a SpatialPoints object or numeric vector indicating the
cells in the training partition</p>
</dd>
<dt><code>test</code></dt><dd><p>a SpatialPoints object or numeric vector indicating the
cells in the testing partition</p>
</dd>
<dt><code>all</code></dt><dd><p>a SpatialPoints object or numeric vector indicating all
non-NA cells in the study region</p>
</dd>
</dl>



<h3>References</h3>

<p>Kuhn, M. (2008). Building predictive models in R using the caret
package. Journal of Statistical Software, 28(5), 1-26.
</p>


<h3>See Also</h3>

<p><code>caret::<a href="caret.html#topic+createDataPartition">createDataPartition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Plum Island Ecosystems

## Load observed land use maps
obs &lt;- ObsLulcRasterStack(x=pie,
                   pattern="lu",
                   categories=c(1,2,3),
                   labels=c("forest","built","other"),
                   t=c(0,6,14))

## create equally sized training and testing partitions
part &lt;- partition(x=obs[[1]], size=0.1, spatial=FALSE)
names(part)


## End(Not run)
</code></pre>

<hr>
<h2 id='performance'>Create ROCR performance objects</h2><span id='topic+performance'></span><span id='topic+performance+2Clist-method'></span>

<h3>Description</h3>

<p>A wrapper function for <code>ROCR::<a href="ROCR.html#topic+performance">performance</a></code> (Sing et al,
2005) to create <code>performance</code> objects from a list of <code>prediction</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performance(prediction.obj, ...)

## S4 method for signature 'list'
performance(prediction.obj, measure, x.measure = "cutoff",
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performance_+3A_prediction.obj">prediction.obj</code></td>
<td>
<p>a list of <code>ROCR::<a href="ROCR.html#topic+prediction">prediction</a></code> objects</p>
</td></tr>
<tr><td><code id="performance_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>ROCR::<a href="ROCR.html#topic+performance">performance</a></code></p>
</td></tr>
<tr><td><code id="performance_+3A_measure">measure</code></td>
<td>
<p>performance measure to use for the evaluation. See
<code>ROCR::<a href="ROCR.html#topic+performance">performance</a></code></p>
</td></tr>
<tr><td><code id="performance_+3A_x.measure">x.measure</code></td>
<td>
<p>a second performance measure. See
<code>ROCR::<a href="ROCR.html#topic+performance">performance</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>performance</code> objects.
</p>


<h3>References</h3>

<p>Sing, T., Sander, O., Beerenwinkel, N., Lengauer, T. (2005).
ROCR: visualizing classifier performance in R. Bioinformatics
21(20):3940-3941.
</p>


<h3>See Also</h3>

<p><code>ROCR::<a href="ROCR.html#topic+prediction">prediction</a></code>,
<code>ROCR::<a href="ROCR.html#topic+performance">performance</a></code>
</p>

<hr>
<h2 id='PerformanceList'>Create a PerformanceList object</h2><span id='topic+PerformanceList'></span>

<h3>Description</h3>

<p>This function uses different measures to evaluate multiple
<code>ROCR::<a href="ROCR.html#topic+prediction">prediction</a></code> objects stored in a
<code><a href="#topic+PredictionList">PredictionList</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PerformanceList(pred, measure, x.measure = "cutoff", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PerformanceList_+3A_pred">pred</code></td>
<td>
<p>an object of class PredictionList</p>
</td></tr>
<tr><td><code id="PerformanceList_+3A_measure">measure</code></td>
<td>
<p>performance measure to use for the evaluation. See
<code>ROCR::<a href="ROCR.html#topic+performance">performance</a></code></p>
</td></tr>
<tr><td><code id="PerformanceList_+3A_x.measure">x.measure</code></td>
<td>
<p>a second performance measure. See
<code>ROCR::<a href="ROCR.html#topic+performance">performance</a></code></p>
</td></tr>
<tr><td><code id="PerformanceList_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>ROCR::<a href="ROCR.html#topic+performance">performance</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>PerformanceList</code> object.
</p>


<h3>References</h3>

<p>Sing, T., Sander, O., Beerenwinkel, N., Lengauer, T. (2005).
ROCR: visualizing classifier performance in R. Bioinformatics
21(20):3940-3941.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+performance">performance</a></code>, <code><a href="#topic+PredictionList">PredictionList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='PerformanceList-class'>Class PerformanceList</h2><span id='topic+PerformanceList-class'></span>

<h3>Description</h3>

<p>An S4 class that extends <code>ROCR::<a href="ROCR.html#topic+performance-class">performance-class</a></code> to hold
the results of multiple model evaluations.
</p>


<h3>Slots</h3>


<dl>
<dt><code>performance</code></dt><dd><p>list of ROCR performance objects. Each object is
calculated for the corresponding ROCR prediction object held in the
PredictionList object supplied to the constructor function</p>
</dd>
<dt><code>auc</code></dt><dd><p>numeric vector containing the area under the curve for each
performance object</p>
</dd>
<dt><code>categories</code></dt><dd><p>numeric vector of land use categories for which performance
objects were created</p>
</dd>
<dt><code>labels</code></dt><dd><p>character vector with labels corresponding to <code>categories</code></p>
</dd>
</dl>

<hr>
<h2 id='pie'>Land use change dataset for Plum Island Ecosystem</h2><span id='topic+pie'></span>

<h3>Description</h3>

<p>Dataset containing land use maps for 1985, 1991 and 1999 and several
explanatory variables derived from Pontius and Parmentier (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pie
</code></pre>


<h3>Format</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>lu_pie_1985</dt><dd><p>RasterLayer showing land use in 1985 (forest, built,
other)</p>
</dd>
<dt>lu_pie_1991</dt><dd><p>RasterLayer showing land use in 1991</p>
</dd>
<dt>lu_pie_1999</dt><dd><p>RasterLayer showing land use in 1999</p>
</dd>
<dt>ef_001</dt><dd><p>RasterLayer showing elevation</p>
</dd>
<dt>ef_002</dt><dd><p>RasterLayer showing slope</p>
</dd>
<dt>ef_003</dt><dd><p>RasterLayer showing distance to built land in 1985</p>
</dd>
</dl>


<h3>References</h3>

<p>Pontius Jr, R. G., &amp; Parmentier, B. (2014). Recommendations for using the
relative operating characteristic (ROC). Landscape ecology, 29(3), 367-382.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pie)
</code></pre>

<hr>
<h2 id='plot'>Plot method for objects based on Raster* data</h2><span id='topic+plot'></span><span id='topic+plot.ObsLulcRasterStack'></span><span id='topic+plot.Model'></span><span id='topic+plot.ThreeMapComparison'></span><span id='topic+plot+2CObsLulcRasterStack+2CANY-method'></span><span id='topic+plot+2CModel+2CANY-method'></span><span id='topic+plot+2CThreeMapComparison+2CANY-method'></span>

<h3>Description</h3>

<p>Plot <code>lulcc</code> objects based on Raster* data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ObsLulcRasterStack'
plot(x, y, ...)

## S3 method for class 'Model'
plot(x, y, ...)

## S3 method for class 'ThreeMapComparison'
plot(x, y, category, factors, ...)

## S4 method for signature 'ObsLulcRasterStack,ANY'
plot(x, y, ...)

## S4 method for signature 'Model,ANY'
plot(x, y, ...)

## S4 method for signature 'ThreeMapComparison,ANY'
plot(x, y, category, factors, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>an object from <code>lulcc</code> containing Raster data</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>additional arguments to
<code>rasterVis::<a href="rasterVis.html#topic+levelplot">levelplot</a></code></p>
</td></tr>
<tr><td><code id="plot_+3A_category">category</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="plot_+3A_factors">factors</code></td>
<td>
<p>numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trellis object.
</p>


<h3>See Also</h3>

<p><code>rasterVis::<a href="rasterVis.html#topic+levelplot">levelplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='plot.AgreementBudget'>Plot method for AgreementBudget objects</h2><span id='topic+plot.AgreementBudget'></span><span id='topic+plot+2CAgreementBudget+2CANY-method'></span>

<h3>Description</h3>

<p>Plot an <code><a href="#topic+AgreementBudget">AgreementBudget</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AgreementBudget'
plot(x, y, from, to,
  col = RColorBrewer::brewer.pal(5, "Set2"), key, scales, xlab, ylab, ...)

## S4 method for signature 'AgreementBudget,ANY'
plot(x, y, from, to,
  col = RColorBrewer::brewer.pal(5, "Set2"), key, scales, xlab, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.AgreementBudget_+3A_x">x</code></td>
<td>
<p>an AgreementBudget object</p>
</td></tr>
<tr><td><code id="plot.AgreementBudget_+3A_y">y</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="plot.AgreementBudget_+3A_from">from</code></td>
<td>
<p>optional numeric value representing a land use category. If 
provided without <code>to</code> the figure of merit for all transitions from this
category will be plotted</p>
</td></tr>
<tr><td><code id="plot.AgreementBudget_+3A_to">to</code></td>
<td>
<p>similar to <code>from</code>. If provided with a valid <code>from</code>
argument the transition defined by these two arguments (i.e. <code>from</code> -&gt;
<code>to</code>) will be plotted</p>
</td></tr>
<tr><td><code id="plot.AgreementBudget_+3A_col">col</code></td>
<td>
<p>character specifying the plotting colour. Default is to use the
'Set2' palette from <code>RColorBrewer</code></p>
</td></tr>
<tr><td><code id="plot.AgreementBudget_+3A_key">key</code></td>
<td>
<p>list. See <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
<tr><td><code id="plot.AgreementBudget_+3A_scales">scales</code></td>
<td>
<p>list. See <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
<tr><td><code id="plot.AgreementBudget_+3A_xlab">xlab</code></td>
<td>
<p>character or expression. See <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
<tr><td><code id="plot.AgreementBudget_+3A_ylab">ylab</code></td>
<td>
<p>character or expression. See <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
<tr><td><code id="plot.AgreementBudget_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot layout is based on work presented in Pontius et al. (2011)
</p>


<h3>Value</h3>

<p>A trellis object.
</p>


<h3>References</h3>

<p>Pontius Jr, R.G., Peethambaram, S., Castella, J.C. (2011).
Comparison of three maps at multiple resolutions: a case study of land change
simulation in Cho Don District, Vietnam. Annals of the Association of American
Geographers 101(1): 45-62.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AgreementBudget">AgreementBudget</a></code>, <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='plot.FigureOfMerit'>Plot method for FigureOfMerit objects</h2><span id='topic+plot.FigureOfMerit'></span><span id='topic+plot+2CFigureOfMerit+2CANY-method'></span>

<h3>Description</h3>

<p>Plot the overall, category-specific or transition-specific figure of merit at
different resolutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FigureOfMerit'
plot(x, y, ..., from, to,
  col = RColorBrewer::brewer.pal(8, "Set2"), type = "b", key, scales, xlab,
  ylab)

## S4 method for signature 'FigureOfMerit,ANY'
plot(x, y, ..., from, to,
  col = RColorBrewer::brewer.pal(8, "Set2"), type = "b", key, scales, xlab,
  ylab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.FigureOfMerit_+3A_x">x</code></td>
<td>
<p>a FigureOfMerit object</p>
</td></tr>
<tr><td><code id="plot.FigureOfMerit_+3A_y">y</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="plot.FigureOfMerit_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
<tr><td><code id="plot.FigureOfMerit_+3A_from">from</code></td>
<td>
<p>optional numeric value representing a land use category. If 
provided without <code>to</code> the figure of merit for all transitions from this
category will be plotted</p>
</td></tr>
<tr><td><code id="plot.FigureOfMerit_+3A_to">to</code></td>
<td>
<p>similar to <code>from</code>. If provided with a valid <code>from</code>
argument the transition defined by these two arguments (i.e. <code>from</code> -&gt;
<code>to</code>) will be plotted. It is possible to include more than one category
in which case the different transitions will be included on the same plot</p>
</td></tr>
<tr><td><code id="plot.FigureOfMerit_+3A_col">col</code></td>
<td>
<p>character specifying the plotting colour. Default is to use the
'Set2' palette from <code>RColorBrewer</code></p>
</td></tr>
<tr><td><code id="plot.FigureOfMerit_+3A_type">type</code></td>
<td>
<p>character. See <code>lattice::<a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code></p>
</td></tr>
<tr><td><code id="plot.FigureOfMerit_+3A_key">key</code></td>
<td>
<p>list. See <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
<tr><td><code id="plot.FigureOfMerit_+3A_scales">scales</code></td>
<td>
<p>list. See <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
<tr><td><code id="plot.FigureOfMerit_+3A_xlab">xlab</code></td>
<td>
<p>character or expression. See <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
<tr><td><code id="plot.FigureOfMerit_+3A_ylab">ylab</code></td>
<td>
<p>character or expression. See <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trellis object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FigureOfMerit">FigureOfMerit</a></code>, <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code>,
<code>lattice::<a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='plot.PerformanceList'>Plot method for PerformanceList objects</h2><span id='topic+plot.PerformanceList'></span><span id='topic+plot+2Clist+2CANY-method'></span>

<h3>Description</h3>

<p>Plot the the ROC curve for each <code>performance</code> object in a
<code><a href="#topic+PerformanceList">PerformanceList</a></code> object. If more than one
<code>PerformanceList</code> objects are provided ROC curves for the same land use
category from different objects are included on the same plot for model
comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PerformanceList'
plot(x, y, multipanel = TRUE, type = "l",
  abline = list(c(0, 1), col = "grey"), col = RColorBrewer::brewer.pal(9,
  "Set1"), key.args = NULL, ...)

## S4 method for signature 'list,ANY'
plot(x, y, multipanel = TRUE, type = "l",
  abline = list(c(0, 1), col = "grey"), col = RColorBrewer::brewer.pal(9,
  "Set1"), key.args = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PerformanceList_+3A_x">x</code></td>
<td>
<p>either a single PerformanceList object or a list of these. If a list is
provided it must be named.</p>
</td></tr>
<tr><td><code id="plot.PerformanceList_+3A_y">y</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="plot.PerformanceList_+3A_multipanel">multipanel</code></td>
<td>
<p>logical. If <code>TRUE</code>, create a trellis plot where the
number of panels equals the number of <code>PerformanceList</code> objects.
Otherwise, create a single plot for each PerformanceList object</p>
</td></tr>
<tr><td><code id="plot.PerformanceList_+3A_type">type</code></td>
<td>
<p>character. See <code>lattice::<a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code></p>
</td></tr>
<tr><td><code id="plot.PerformanceList_+3A_abline">abline</code></td>
<td>
<p>list. See <code>lattice::<a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code></p>
</td></tr>
<tr><td><code id="plot.PerformanceList_+3A_col">col</code></td>
<td>
<p>character. Plotting colour</p>
</td></tr>
<tr><td><code id="plot.PerformanceList_+3A_key.args">key.args</code></td>
<td>
<p>list containing additional components to be passed to
the key argument of <br />
<code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
<tr><td><code id="plot.PerformanceList_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trellis object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PerformanceList">PerformanceList</a></code>, <code>lattice::<a href="lattice.html#topic+xyplot">xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='predict.PredictiveModelList'>Predict location suitability</h2><span id='topic+predict.PredictiveModelList'></span><span id='topic+predict+2CPredictiveModelList-method'></span>

<h3>Description</h3>

<p>Estimate location suitability with predictive models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PredictiveModelList'
predict(object, newdata, data.frame = FALSE,
  ...)

## S4 method for signature 'PredictiveModelList'
predict(object, newdata, data.frame = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.PredictiveModelList_+3A_object">object</code></td>
<td>
<p>a PredictiveModelList object</p>
</td></tr>
<tr><td><code id="predict.PredictiveModelList_+3A_newdata">newdata</code></td>
<td>
<p>data.frame containing new data</p>
</td></tr>
<tr><td><code id="predict.PredictiveModelList_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether the function should return a
matrix (default) or data.frame</p>
</td></tr>
<tr><td><code id="predict.PredictiveModelList_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>predict</code> methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually called from <code>allocate</code> to calculate land use
suitability at each timestep. However, it may also be used to produce
suitability maps (see examples).
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Model+20fitting">Model fitting</a></code>, <code><a href="#topic+allocate">allocate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Sibuyan Island

## load observed land use data
obs &lt;- ObsLulcRasterStack(x=sibuyan$maps,
                    pattern="lu",
                    categories=c(1,2,3,4,5),
                    labels=c("Forest","Coconut","Grass","Rice","Other"),
                    t=c(0,14))

## load explanatory variables
ef &lt;- ExpVarRasterList(x=sibuyan$maps, pattern="ef")

## separate data into training and testing partitions
part &lt;- partition(x=obs[[1]], size=0.1, spatial=TRUE)
train.data &lt;- getPredictiveModelInputData(obs=obs, ef=ef, cells=part[["train"]])
all.data &lt;- getPredictiveModelInputData(obs=obs, ef=ef, cells=part[["all"]])

## get glm.models from data
forms &lt;- list(Forest ~ ef_001+ef_002+ef_003+ef_004+ef_005+ef_006+ef_007+ef_008+ef_010+ef_012,
              Coconut ~ ef_001+ef_002+ef_005+ef_007+ef_008+ef_009+ef_010+ef_011+ef_012,
              Grass~ef_001+ef_002+ef_004+ef_005+ef_007+ef_008+ef_009+ef_010+ef_011+ef_012+ef_013,
              Rice~ef_009+ef_010+ef_011,
              Other~1)

glm.models &lt;- glmModels(formula=forms, family=binomial, data=train.data, obs=obs)

## create suitability maps
suitability.maps &lt;- predict(object=glm.models, newdata=all.data, data.frame=TRUE)
points &lt;- rasterToPoints(obs[[1]], spatial=TRUE)
suitability.maps &lt;- SpatialPointsDataFrame(coords=points, data=suitability.maps)
r &lt;- stack(rasterize(x=suitability.maps, y=obs[[1]], field=names(suitability.maps)))
plot(r)

## library(rasterVis)
## levelplot(r)


## End(Not run)
</code></pre>

<hr>
<h2 id='PredictionList'>Create a PredictionList object</h2><span id='topic+PredictionList'></span>

<h3>Description</h3>

<p>This function creates a <code>ROCR::<a href="ROCR.html#topic+prediction">prediction</a></code> object for each
predictive model in a <code>PredictiveModelList</code> object. It should be used with
<code><a href="#topic+PerformanceList">PerformanceList</a></code> to evaluate multiple models with exactly the
same criteria while keeping track of which model corresponds to which land use
category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredictionList(models, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PredictionList_+3A_models">models</code></td>
<td>
<p>a PredictiveModelList object</p>
</td></tr>
<tr><td><code id="PredictionList_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame containing new data</p>
</td></tr>
<tr><td><code id="PredictionList_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>ROCR::<a href="ROCR.html#topic+prediction">prediction</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>PredictionList</code> object.
</p>


<h3>References</h3>

<p>Sing, T., Sander, O., Beerenwinkel, N., Lengauer, T. (2005).
ROCR: visualizing classifier performance in R. Bioinformatics
21(20):3940-3941.
</p>


<h3>See Also</h3>

<p><code>link{PerformanceList}</code>, <code>ROCR::<a href="ROCR.html#topic+prediction">prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='PredictionList-class'>Class PredictionList</h2><span id='topic+PredictionList-class'></span>

<h3>Description</h3>

<p>An S4 class that extends <code>ROCR::<a href="ROCR.html#topic+prediction-class">prediction-class</a></code> to hold
the results of multiple model predictions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>prediction</code></dt><dd><p>a list of <code>ROCR::<a href="ROCR.html#topic+prediction-class">prediction-class</a></code> objects.
These objects are calculated for each statistical model in the
<code>PredictiveModelList</code> object supplied to the constructor function</p>
</dd>
<dt><code>categories</code></dt><dd><p>numeric vector of land use categories for which
<code>prediction</code> objects were created</p>
</dd>
<dt><code>labels</code></dt><dd><p>character vector with labels corresponding to <code>categories</code></p>
</dd>
</dl>

<hr>
<h2 id='PredictiveModelList-class'>Class PredictiveModelList</h2><span id='topic+PredictiveModelList-class'></span>

<h3>Description</h3>

<p>An S4 class to hold multiple mathematical models for different land use
categories belonging to the same map.
</p>


<h3>Slots</h3>


<dl>
<dt><code>models</code></dt><dd><p>list of predictive models</p>
</dd>
<dt><code>categories</code></dt><dd><p>numeric vector of land use categories</p>
</dd>
<dt><code>labels</code></dt><dd><p>character vector with labels corresponding to <code>categories</code></p>
</dd>
</dl>

<hr>
<h2 id='resample+2CExpVarRasterList+2CRaster-method'>Resample maps in ExpVarRasterList object or list</h2><span id='topic+resample+2CExpVarRasterList+2CRaster-method'></span><span id='topic+resample+2Clist+2CRaster-method'></span>

<h3>Description</h3>

<p>A wrapper function for <code>raster::<a href="raster.html#topic+resample">resample</a></code> to resample
raster objects in an ExpVarRasterList object or list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ExpVarRasterList,Raster'
resample(x, y, method = "ngb", ...)

## S4 method for signature 'list,Raster'
resample(x, y, method = "ngb", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample+2B2CExpVarRasterList+2B2CRaster-method_+3A_x">x</code></td>
<td>
<p>an ExpVarRasterList object or list of Raster* maps to be resampled</p>
</td></tr>
<tr><td><code id="resample+2B2CExpVarRasterList+2B2CRaster-method_+3A_y">y</code></td>
<td>
<p>Raster* object with parameters that <code>x</code> should be resampled to</p>
</td></tr>
<tr><td><code id="resample+2B2CExpVarRasterList+2B2CRaster-method_+3A_method">method</code></td>
<td>
<p>method used to compute values for the new RasterLayer, should be
<code>"bilinear"</code> for bilinear interpolation, or <code>"ngb"</code> for nearest
neighbour</p>
</td></tr>
<tr><td><code id="resample+2B2CExpVarRasterList+2B2CRaster-method_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>raster::<a href="raster.html#topic+resample">resample</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ExpVarRasterList object or list, depending on <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ExpVarRasterList">ExpVarRasterList</a></code>, <code>raster::<a href="raster.html#topic+resample">resample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Plum Island Ecosystems

## observed data
obs &lt;- ObsLulcRasterStack(x=pie,
                    pattern="lu",
                    categories=c(1,2,3),
                    labels=c("forest","built","other"),
                    t=c(0,6,14))

## explanatory variables
ef &lt;- ExpVarRasterList(x=pie, pattern="ef")

## resample to ensure maps have same characteristics as observed maps
ef &lt;- resample(x=ef, y=obs, method="ngb")


## End(Not run)
</code></pre>

<hr>
<h2 id='roundSum'>Round elements in matrix or data.frame rows</h2><span id='topic+roundSum'></span>

<h3>Description</h3>

<p>Round all numbers in a matrix or data.frame while ensuring that all rows sum
to the same value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundSum(x, ncell, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roundSum_+3A_x">x</code></td>
<td>
<p>matrix or data.frame</p>
</td></tr>
<tr><td><code id="roundSum_+3A_ncell">ncell</code></td>
<td>
<p>numeric specifying the target sum for each row in <code>x</code></p>
</td></tr>
<tr><td><code id="roundSum_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main application of <code>roundSum</code> is to ensure that each row in the
demand matrix specifies exactly the number of cells to be allocated to each
land use category for the respective timestep. It may also be used to convert
the units of demand to number of cells.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sibuyan Island

## load observed land use data and create demand scenario
obs &lt;- ObsLulcRasterStack(x=sibuyan$maps,
                    pattern="lu",
                    categories=c(1,2,3,4,5),
                    labels=c("Forest","Coconut","Grass","Rice","Other"),
                    t=c(0,14))

dmd &lt;- approxExtrapDemand(obs, tout=0:14)
apply(dmd, 1, sum)

## artificially perturb for illustration purposes
dmd &lt;- dmd * runif(1)
apply(dmd, 1, sum)

## use roundSum to correct demand scenario
ncell &lt;- length(which(!is.na(getValues(sibuyan$maps$lu_sib_1997))))
ncell
dmd &lt;- roundSum(dmd, ncell=ncell)
apply(dmd, 1, sum)

</code></pre>

<hr>
<h2 id='show+2CExpVarRasterList-method'>Show</h2><span id='topic+show+2CExpVarRasterList-method'></span><span id='topic+show+2CPredictiveModelList-method'></span><span id='topic+show+2CPredictionList-method'></span><span id='topic+show+2CPerformanceList-method'></span><span id='topic+show+2CModel-method'></span><span id='topic+show+2CThreeMapComparison-method'></span>

<h3>Description</h3>

<p>Show objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ExpVarRasterList'
show(object)

## S4 method for signature 'PredictiveModelList'
show(object)

## S4 method for signature 'PredictionList'
show(object)

## S4 method for signature 'PerformanceList'
show(object)

## S4 method for signature 'Model'
show(object)

## S4 method for signature 'ThreeMapComparison'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CExpVarRasterList-method_+3A_object">object</code></td>
<td>
<p>an object belonging to one of the classes in <code>lulcc</code></p>
</td></tr>
</table>

<hr>
<h2 id='sibuyan'>Land use change dataset for Sibuyan Island</h2><span id='topic+sibuyan'></span>

<h3>Description</h3>

<p>Dataset containing land use map for 1997 and several explanatory variables for
Sibuyan Island derived from Verburg et al. (2002). Data are modified by Peter
Verburg to demonstrate the CLUE-s model; as such the dataset should not be
used for purposes other than demonstration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sibuyan
</code></pre>


<h3>Format</h3>

<p>A list containing the following components:
</p>

<dl>
<dt>maps</dt><dd><p>list containing the following RasterLayers:</p>
</dd>
</dl>

<dl>
<dt>lu_sib_1997</dt><dd><p>RasterLayer with land use in 1997 (forest, coconut,
grassland, rice, other)</p>
</dd>
<dt>ef_001</dt><dd><p>RasterLayer showing distance to sea</p>
</dd>
<dt>ef_002</dt><dd><p>RasterLayer showing mean population density</p>
</dd>
<dt>ef_003</dt><dd><p>RasterLayer showing occurrence of diorite rock</p>
</dd>
<dt>ef_004</dt><dd><p>RasterLayer showing occurrence of ultramafic rock</p>
</dd>
<dt>ef_005</dt><dd><p>RasterLayer showing occurrence of sediments</p>
</dd>
<dt>ef_006</dt><dd><p>RasterLayer showing areas with no erosion</p>
</dd>
<dt>ef_007</dt><dd><p>RasterLayer showing areas with moderate erosion</p>
</dd>
<dt>ef_008</dt><dd><p>RasterLayer showing elevation</p>
</dd>
<dt>ef_009</dt><dd><p>RasterLayer showing slope</p>
</dd>
<dt>ef_010</dt><dd><p>RasterLayer showing aspect</p>
</dd>
<dt>ef_011</dt><dd><p>RasterLayer showing distance to roads in 1997</p>
</dd>
<dt>ef_012</dt><dd><p>RasterLayer showing distance to urban areas in 1997</p>
</dd>
<dt>ef_013</dt><dd><p>RasterLayer showing distance to streams</p>
</dd>
<dt>restr1</dt><dd><p>RasterLayer showing location of current national park</p>
</dd>
<dt>restr2</dt><dd><p>RasterLayer showing location of proposed national park</p>
</dd>
</dl>

<dl>
<dt>demand</dt><dd><p>list of matrices with different demand scenarios:</p>
</dd>
</dl>

<dl>
<dt>demand1</dt><dd><p>data.frame with demand scenario representing slow growth
scenario</p>
</dd>
<dt>demand2</dt><dd><p>data.frame with demand scenario representing fast growth
scenario</p>
</dd>
<dt>demand3</dt><dd><p>data.frame with demand scenario representing land use
change primarily for food production</p>
</dd>
</dl>



<h3>References</h3>

<p>Verburg, P.H., Soepboer, W., Veldkamp, A., Limpiada, R., Espaldon,
V., Mastura, S.S (2002). Modeling the Spatial Dynamics of Regional Land Use:
The CLUE-S Model. Environmental Management 30(3): 391-405.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sibuyan)
</code></pre>

<hr>
<h2 id='subset+2CExpVarRasterList-method'>Subset</h2><span id='topic+subset+2CExpVarRasterList-method'></span><span id='topic+subset+2CPredictiveModelList-method'></span><span id='topic+subset+2CPerformanceList-method'></span><span id='topic+subset+2CPredictionList-method'></span>

<h3>Description</h3>

<p>Extract a subset of objects from container classes such as
<code>ExpVarRasterList</code>, <code>PredictiveModelList</code>, <code>PredictionList</code> and
<code>PerformanceList</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ExpVarRasterList'
subset(x, subset, ...)

## S4 method for signature 'PredictiveModelList'
subset(x, subset, ...)

## S4 method for signature 'PerformanceList'
subset(x, subset, ...)

## S4 method for signature 'PredictionList'
subset(x, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset+2B2CExpVarRasterList-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>ExpVarRasterList</code>,
<code>PredictiveModelList</code>, <code>PredictionList</code> or <code>PerformanceList</code></p>
</td></tr>
<tr><td><code id="subset+2B2CExpVarRasterList-method_+3A_subset">subset</code></td>
<td>
<p>integer or character indicating the objects to be extracted</p>
</td></tr>
<tr><td><code id="subset+2B2CExpVarRasterList-method_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sibuyan Island

## load observed land use data
obs &lt;- ObsLulcRasterStack(x=sibuyan$maps,
                    pattern="lu",
                    categories=c(1,2,3,4,5),
                    labels=c("Forest","Coconut","Grass","Rice","Other"),
                    t=c(0,14))

summary(obs)
obs &lt;- subset(obs, subset=names(obs)[1])
summary(obs)

## load explanatory variables
ef &lt;- ExpVarRasterList(x=sibuyan$maps, pattern="ef")

summary(ef)
ef &lt;- subset(ef, subset=1:5)
summary(ef)

</code></pre>

<hr>
<h2 id='summary'>Summary</h2><span id='topic+summary'></span><span id='topic+summary+2CObsLulcRasterStack-method'></span><span id='topic+summary+2CExpVarRasterList-method'></span><span id='topic+summary+2CNeighbRasterStack-method'></span><span id='topic+summary+2CPredictiveModelList-method'></span><span id='topic+summary+2CModel-method'></span>

<h3>Description</h3>

<p>Summarise lulcc objects containing Raster* data or predictive models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary(object, ...)

## S4 method for signature 'ObsLulcRasterStack'
summary(object, ...)

## S4 method for signature 'ExpVarRasterList'
summary(object, ...)

## S4 method for signature 'NeighbRasterStack'
summary(object, ...)

## S4 method for signature 'PredictiveModelList'
summary(object, ...)

## S4 method for signature 'Model'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>an object belonging to one of the classes in <code>lulcc</code></p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, data.frame or list
</p>

<hr>
<h2 id='ThreeMapComparison'>Evaluate allocation performance with three maps</h2><span id='topic+ThreeMapComparison'></span><span id='topic+ThreeMapComparison+2CModel+2CANY+2CANY-method'></span><span id='topic+ThreeMapComparison+2CRasterLayer+2CRasterLayer+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>An implementation of the method described by Pontius et al. (2011), which
compares a reference map at time 1, a reference map at time 2 and a simulated
map at time 2 to evaluate allocation performance at multiple resolutions while
taking into account persistence. The method quantifies disagreement within
coarse squares (minor allocation disagreement), disagreement between coarse
squares (major allocation disagreement), disagreement about the quantity of
land use change and agreement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThreeMapComparison(x, x1, y1, ...)

## S4 method for signature 'Model,ANY,ANY'
ThreeMapComparison(x, x1, y1, factors, timestep, ...)

## S4 method for signature 'RasterLayer,RasterLayer,RasterLayer'
ThreeMapComparison(x, x1, y1,
  factors, categories, labels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThreeMapComparison_+3A_x">x</code></td>
<td>
<p>either a RasterLayer of observed land use at time 0 or an object
inheriting from class <code>Model</code></p>
</td></tr>
<tr><td><code id="ThreeMapComparison_+3A_x1">x1</code></td>
<td>
<p>a RasterLayer of observed land use at a subsequent time. Only
required if <code>x</code> is also a RasterLayer</p>
</td></tr>
<tr><td><code id="ThreeMapComparison_+3A_y1">y1</code></td>
<td>
<p>a RasterLayer of simulated land use corresponding to <code>x1</code>. Only
required if <code>x</code> is also a RasterLayer</p>
</td></tr>
<tr><td><code id="ThreeMapComparison_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>raster::<a href="raster.html#topic+aggregate">aggregate</a></code></p>
</td></tr>
<tr><td><code id="ThreeMapComparison_+3A_factors">factors</code></td>
<td>
<p>numeric vector of aggregation factors (equivalent to the 'fact'
argument to <br />
<code>raster::<a href="raster.html#topic+aggregate">aggregate</a></code> representing the resolutions at which
model performance should be tested</p>
</td></tr>
<tr><td><code id="ThreeMapComparison_+3A_timestep">timestep</code></td>
<td>
<p>numeric value indicating the timestep of the simulated land use
map. Only required if <code>x</code> is a <code>Model</code> object</p>
</td></tr>
<tr><td><code id="ThreeMapComparison_+3A_categories">categories</code></td>
<td>
<p>numeric vector of land use categories in observed maps. Only
required if <code>x</code> is a RasterLayer</p>
</td></tr>
<tr><td><code id="ThreeMapComparison_+3A_labels">labels</code></td>
<td>
<p>character vector (optional) with labels corresponding to
<code>categories</code>. Only required if <code>x</code> is a RasterLayer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ThreeMapComparison</code> object.
</p>


<h3>References</h3>

<p>Pontius Jr, R.G., Peethambaram, S., Castella, J.C. (2011).
Comparison of three maps at multiple resol utions: a case study of land change
simulation in Cho Don District, Vietnam. Annals of the Association of American
Geographers 101(1): 45-62.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AgreementBudget">AgreementBudget</a></code>, <code><a href="#topic+FigureOfMerit">FigureOfMerit</a></code>,
<code>raster::<a href="raster.html#topic+aggregate">aggregate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see lulcc-package examples
</code></pre>

<hr>
<h2 id='ThreeMapComparison-class'>Class ThreeMapComparison</h2><span id='topic+ThreeMapComparison-class'></span>

<h3>Description</h3>

<p>An S4 class to hold results of a comparison between a reference map for time
1, a reference map for time 2 and a simulation map for time 2 using the
the method described by Pontius et al. (2011).
</p>


<h3>Slots</h3>


<dl>
<dt><code>tables</code></dt><dd><p>list of data.frames that depict the three dimensional table
described by Pontius et al. (2011) at different resolutions</p>
</dd>
<dt><code>factors</code></dt><dd><p>numeric vector of aggregation factors</p>
</dd>
<dt><code>maps</code></dt><dd><p>list of RasterStack objects containing land use maps at different
resolutions</p>
</dd>
<dt><code>categories</code></dt><dd><p>numeric vector of land use categories</p>
</dd>
<dt><code>labels</code></dt><dd><p>character vector corresponding to <code>categories</code></p>
</dd>
</dl>


<h3>References</h3>

<p>Pontius Jr, R.G., Peethambaram, S., Castella, J.C. (2011).
Comparison of three maps at multiple resol utions: a case study of land change
simulation in Cho Don District, Vietnam. Annals of the Association of American
Geographers 101(1): 45-62.
</p>

<hr>
<h2 id='total'>Total number of cells in a categorical Raster* object</h2><span id='topic+total'></span>

<h3>Description</h3>

<p>Count the number of cells belonging to each category in a Raster* object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total(x, categories)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="total_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="total_+3A_categories">categories</code></td>
<td>
<p>numeric vector containing land use categories. Only cells
belonging to these categories will be counted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code>total</code></dt><dd><p>a matrix containing the total number of cells belonging
to each category. Rows represent layers in the input Raster* object</p>
</dd>
<dt><code>categories</code></dt><dd><p>the categories included in the calculation</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
## Sibuyan Island

## load observed land use data
obs &lt;- ObsLulcRasterStack(x=sibuyan$maps,
                    pattern="lu",
                    categories=c(1,2,3,4,5),
                    labels=c("Forest","Coconut","Grass","Rice","Other"),
                    t=c(0,14))

total(x=obs)
total(x=obs[[1]])
total(x=obs[[2]])

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
