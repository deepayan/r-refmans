<!DOCTYPE html><html lang="en"><head><title>Help for package RecordTest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RecordTest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RecordTest-package'><p><strong>RecordTest</strong>: A Package for Testing the Classical Record Model</p></a></li>
<li><a href='#.MonteCarlo'><p>Monte Carlo Draws</p></a></li>
<li><a href='#brown.method'><p>Brown's Method on the Number of Records</p></a></li>
<li><a href='#change.point'><p>Change-point Detection Tests Based on Records</p></a></li>
<li><a href='#fisher.method'><p>Fisher's Method</p></a></li>
<li><a href='#foster.plot'><p>Plots Based on Foster-Stuart and Diersen-Trenkler Statistics</p></a></li>
<li><a href='#foster.test'><p>Foster-Stuart and Diersen-Trenkler Tests</p></a></li>
<li><a href='#global.test'><p>Global Statistic for Two-Sided Tests</p></a></li>
<li><a href='#I.record'><p>Record Indicators</p></a></li>
<li><a href='#L.plot'><p>Times of Record Plot</p></a></li>
<li><a href='#L.record'><p>Record Times</p></a></li>
<li><a href='#lr.test'><p>Likelihood-Ratio Test for the Likelihood of the Record Indicators</p></a></li>
<li><a href='#N.plot'><p>Number of Records Plot</p></a></li>
<li><a href='#N.record'><p>Number of Records</p></a></li>
<li><a href='#N.test'><p>Number of Records Test</p></a></li>
<li><a href='#Olympic_records_200m'><p>200-Meter Olympic Records from 1900 to 2020</p></a></li>
<li><a href='#p.chisq.test'><p>Pearson's Chi-Square Test for Probabilities of Record</p></a></li>
<li><a href='#p.plot'><p>Probabilities of Record Plots</p></a></li>
<li><a href='#p.record'><p>Probabilities of Record</p></a></li>
<li><a href='#p.regression.test'><p>Probabilities of Record Regression Test</p></a></li>
<li><a href='#Poisson-Binomial'><p>The Poisson Binomial Distribution</p></a></li>
<li><a href='#R.record'><p>Record Values</p></a></li>
<li><a href='#rcrm'><p>The Classical Record Model</p></a></li>
<li><a href='#records'><p>Record Values and Record Times</p></a></li>
<li><a href='#score.test'><p>Score Test for the Likelihood of the Record Indicators</p></a></li>
<li><a href='#series_double'><p>Double the Number of Series</p></a></li>
<li><a href='#series_record'><p>From Record Times to Time Series</p></a></li>
<li><a href='#series_rev'><p>Reverse Elements by Columns</p></a></li>
<li><a href='#series_split'><p>Split Series</p></a></li>
<li><a href='#series_ties'><p>Summary of Record Ties</p></a></li>
<li><a href='#series_uncor'><p>Subset of Uncorrelated Series</p></a></li>
<li><a href='#series_untie'><p>Breaking Record Ties</p></a></li>
<li><a href='#TX_Zaragoza'><p>Time Series of Daily Maximum Temperature at Zaragoza (Spain)</p></a></li>
<li><a href='#ZaragozaSeries'><p>Split and Uncorrelated Time Series <code>TX_Zaragoza</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inference Tools in Time Series Based on Record Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Jorge Castillo-Mateo
    <a href="https://orcid.org/0000-0003-3859-0248"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Ana C. Cebrián <a href="https://orcid.org/0000-0002-9052-9674"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths],
  Jesús Asín <a href="https://orcid.org/0000-0002-0174-789X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jorge Castillo-Mateo &lt;jorgecastillomateo@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggpubr, knitr, rmarkdown</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical tools based on the probabilistic properties of the 
  record occurrence in a sequence of independent and identically distributed 
  continuous random variables. In particular, tools to prepare a time series 
  as well as distribution-free trend and change-point tests and graphical 
  tools to study the record occurrence. Details about the implemented tools 
  can be found in Castillo-Mateo et al. (2023a) &lt;<a href="https://doi.org/10.18637%2Fjss.v106.i05">doi:10.18637/jss.v106.i05</a>&gt; 
  and Castillo-Mateo et al. (2023b) &lt;<a href="https://doi.org/10.1016%2Fj.atmosres.2023.106934">doi:10.1016/j.atmosres.2023.106934</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JorgeCastilloMateo/RecordTest">https://github.com/JorgeCastilloMateo/RecordTest</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JorgeCastilloMateo/RecordTest/issues">https://github.com/JorgeCastilloMateo/RecordTest/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-06 04:36:12 UTC; jorge</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-07 20:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='RecordTest-package'><strong>RecordTest</strong>: A Package for Testing the Classical Record Model</h2><span id='topic+RecordTest-package'></span><span id='topic+RecordTest'></span>

<h3>Description</h3>

<p><strong>RecordTest</strong> provides data preparation, exploratory data 
analysis and inference tools based on theory of records to describe the 
record occurrence and detect trends, change-points or non-stationarities 
in the tails of the time series. Details about the implemented tools can
be found in Castillo-Mateo, Cebrián and Asín (2023a, 2023b).
</p>


<h3>Details</h3>

<p>The Classical Record Model:
</p>
<p>Record statistics are used primarily to quantify the stochastic behaviour
of a process at never-seen-before values, either upper or lower. The setup
of independent and identically distributed (IID) continuous random 
variables (RVs), often called the classical record model, is 
particularly interesting because the common continuous distribution 
underlying the IID continuous RVs will not affect the distribution of the 
variables relative to the record occurrence. Many fields have begun to use
the theory of records to study these remarkable events. Particularly 
productive is the study of record-breaking temperatures and their 
connection with climate change, but also records in other environmental
fields (precipitations, floods, earthquakes, etc.), economy, biology, 
physics or even sports have been analysed.
See Arnold, Balakrishnan and Nagaraja (1998) for an extensive theoretical
introduction to the theory of records and in particular the classical 
record model. See Foster and Stuart (1954), Diersen and Trenkler (1996, 
2001) and Cebrián, Castillo-Mateo and Asín (2022) for the 
distribution-free trend detection tests, and Castillo-Mateo (2022) for the
distribution-free change-point detection tests based on the classical 
record model. See Castillo-Mateo, Cebrián and Asín (2023b) for the version
as permutation tests. For an easy introduction to <strong>RecordTest</strong> use 
<code>vignette("RecordTest")</code>, and see Castillo-Mateo, Cebrián and Asín 
(2023a).
</p>
<p>This package provides tests to study the hypothesis of the classical 
record model, that is that the record occurrence from a series of values 
observed at regular time units come from an IID series of continuous RVs. 
If we have sequences of independent variables with no seasonal component,
the hypothesis of IID variables is equivalent to test the hypothesis of 
homogeneity and stationarity.
</p>
<p>The functions in the data preparation step:
</p>
<p>The functions admit a vector <code>X</code> corresponding to a single series as
an argument. However, some situations could take advantage of having 
<code class="reqn">M</code> uncorrelated vectors to infer from the sample. Then, the input of
the functions to perform the statistical tools can be a matrix <code>X</code> 
where each column corresponds to a vector formed by the values of a 
series <code class="reqn">X_t</code>, for <code class="reqn">t=1,\ldots,T</code>, so that each row of the matrix
correspond to a time <code class="reqn">t</code>.
</p>
<p>In  many real problems, such as those related to environmental phenomena, 
the series of variables to analyse show a seasonal behaviour, and only one
realisation is available. In order to be able to apply the suggested tools
to detect the existence of a trend, the seasonal component has to be 
removed and a sample of <code class="reqn">M</code> uncorrelated series should be obtained. 
Those problems can be solved by preparing the data adequately. 
A wide set of tools to carry out a preliminary analysis and to prepare 
data with a seasonal pattern are implemented in the following functions.
Note that the <code class="reqn">M</code> series can be dependent if the p-values are 	
approximated by permutations.
</p>
<p><code><a href="#topic+series_record">series_record</a></code>: If only the record times are available.
</p>
<p><code><a href="#topic+series_split">series_split</a></code>, <code><a href="#topic+series_double">series_double</a></code>: To split the
series in several subseries and remove the seasonal component and 
autocorrelation.
</p>
<p><code><a href="#topic+series_uncor">series_uncor</a></code>: To extract a subset of uncorrelated subseries 
</p>
<p><code><a href="#topic+series_ties">series_ties</a></code>, <code><a href="#topic+series_untie">series_untie</a></code>: To deal with record
ties.
</p>
<p><code><a href="#topic+series_rev">series_rev</a></code>: To study the series backwards.
</p>
<p>The functions to compute the record statistics are:
</p>
<p><code><a href="#topic+I.record">I.record</a></code>: Computes the observed record indicators. <code>NA</code> 
values are taken as no records unless they appear at <code class="reqn">t = 1</code>.
</p>
<p><code><a href="#topic+N.record">N.record</a></code>, <code><a href="#topic+Nmean.record">Nmean.record</a></code>: Compute the observed
number of records up to time <code class="reqn">t</code>.
</p>
<p><code><a href="#topic+S.record">S.record</a></code>: Computes the observed number of records at every
time <code class="reqn">t</code>, using <code class="reqn">M</code> series.
</p>
<p><code><a href="#topic+p.record">p.record</a></code>: Computes the estimated record probability at every
time <code class="reqn">t</code>, using <code class="reqn">M</code> series.
</p>
<p><code><a href="#topic+L.record">L.record</a></code>: Computes the observed record times.
</p>
<p><code><a href="#topic+R.record">R.record</a></code>: Computes the observed record values.
</p>
<p>The functions to compute the tests:
</p>
<p>All the tests performed are distribution-free/non-parametric tests in 
time series for trend, change-point and non-stationarity in the extremes 
of the distribution based on the null hypothesis that the record 
indicators are independent and the probabilities of record at time <code class="reqn">t</code>
are <code class="reqn">p_t = 1 / t</code>. 
</p>
<p><code><a href="#topic+change.point">change.point</a></code>: Implements Castillo-Mateo change-point tests.
</p>
<p><code><a href="#topic+foster.test">foster.test</a></code>: Implements Foster-Stuart and Diersen-Trenkler
trend tests. 
</p>
<p><code><a href="#topic+N.test">N.test</a></code>: Implements tests based on the (weighted) number of
records.
</p>
<p><code><a href="#topic+brown.method">brown.method</a></code>: Brown's method to combine dependent p-values 
from <code><a href="#topic+N.test">N.test</a></code>.
</p>
<p><code><a href="#topic+fisher.method">fisher.method</a></code>: General function to apply Fisher's method to
independent p-values.
</p>
<p><code><a href="#topic+p.regression.test">p.regression.test</a></code>: Implements a regression test based on the
record probabilities.
</p>
<p><code><a href="#topic+p.chisq.test">p.chisq.test</a></code>: Implements a <code class="reqn">\chi^2</code>-test based on the 
record probabilities.
</p>
<p><code><a href="#topic+lr.test">lr.test</a></code>: Implements likelihood ratio tests based on the 
record indicators.
</p>
<p><code><a href="#topic+score.test">score.test</a></code>: Implements score or Lagrange multiplier
tests based on the record indicators.
</p>
<p>The functions to compute the graphical tools:
</p>
<p><code><a href="#topic+records">records</a></code>: Shows the series remarking its records.
</p>
<p><code><a href="#topic+L.plot">L.plot</a></code>: Shows record times in several series.
</p>
<p><code><a href="#topic+foster.plot">foster.plot</a></code>: Shows plots based on Foster-Stuart and
Diersen-Trenkler statistics.
</p>
<p><code><a href="#topic+N.plot">N.plot</a></code>: Shows the (weighted) number of records.
</p>
<p><code><a href="#topic+p.plot">p.plot</a></code>: Shows the record probabilities in different plots.
</p>
<p>All the tests and graphical tools can be applied to both upper and lower 
records in the forward and backward directions.
</p>
<p>Other functions:
</p>
<p><code><a href="#topic+rcrm">rcrm</a></code>: Random generation for the classical record model.
</p>
<p><code><a href="#topic+dpoisbinom">dpoisbinom</a></code>, <code><a href="#topic+ppoisbinom">ppoisbinom</a></code>, 
<code><a href="#topic+qpoisbinom">qpoisbinom</a></code>, <code><a href="#topic+rpoisbinom">rpoisbinom</a></code>: Density, distribution
function, quantile function and random generation for the Poisson binomial
distribution. Related to the probability distribution function of the 
number of records under the null hypothesis.
</p>
<p>Example datasets:
</p>
<p>There are two example datasets included with this package. It is possible
to load these datasets into R using the <code>data</code> function. The 
datasets have their own help file, which can be accessed by 
<code>help([dataset_name])</code>. 
Data included with <strong>RecordTest</strong> are:
</p>
<p><code><a href="#topic+TX_Zaragoza">TX_Zaragoza</a></code> - Daily maximum temperatures at Zaragoza 
(Spain).
</p>
<p><code><a href="#topic+ZaragozaSeries">ZaragozaSeries</a></code> - Split and uncorrelated subseries 
<code><a href="#topic+TX_Zaragoza">TX_Zaragoza</a>$TX</code>.
</p>
<p><code><a href="#topic+Olympic_records_200m">Olympic_records_200m</a></code> - 200-meter Olympic records from 1900
to 2020.
</p>
<p>To see how to cite <strong>RecordTest</strong> in publications or elsewhere,
use <code>citation("RecordTest")</code>.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo  &lt;jorgecastillomateo@gmail.com&gt;, AC Cebrián, J Asín
</p>


<h3>References</h3>

<p>Arnold BC, Balakrishnan N, Nagaraja HN (1998). 
<em>Records</em>. 
Wiley Series in Probability and Statistics. Wiley, New York.
<a href="https://doi.org/10.1002/9781118150412">doi:10.1002/9781118150412</a>.
</p>
<p>Castillo-Mateo J (2022).
“Distribution-Free Changepoint Detection Tests Based on the Breaking of Records.”
<em>Environmental and Ecological Statistics</em>, <strong>29</strong>(3), 655-676. 
<a href="https://doi.org/10.1007/s10651-022-00539-2">doi:10.1007/s10651-022-00539-2</a>.
</p>
<p>Castillo-Mateo J, Cebrián AC, Asín J (2023a).
“<strong>RecordTest</strong>: An <code>R</code> Package to Analyze Non-Stationarity in the Extremes Based on Record-Breaking Events.”
<em>Journal of Statistical Software</em>, <strong>106</strong>(5), 1-28. 
<a href="https://doi.org/10.18637/jss.v106.i05">doi:10.18637/jss.v106.i05</a>.
</p>
<p>Castillo-Mateo J, Cebrián AC, Asín J (2023b).
“Statistical Analysis of Extreme and Record-Breaking Daily Maximum Temperatures in Peninsular Spain during 1960&ndash;2021.”
<em>Atmospheric Research</em>, <strong>293</strong>, 106934.
<a href="https://doi.org/10.1016/j.atmosres.2023.106934">doi:10.1016/j.atmosres.2023.106934</a>.
</p>
<p>Cebrián AC, Castillo-Mateo J, Asín J (2022).
“Record Tests to Detect Non Stationarity in the Tails with an Application to Climate Change.”
<em>Stochastic Environmental Research and Risk Assessment</em>, <strong>36</strong>(2), 313-330. 
<a href="https://doi.org/10.1007/s00477-021-02122-w">doi:10.1007/s00477-021-02122-w</a>.
</p>
<p>Diersen J, Trenkler G (1996). “Records Tests for Trend in Location.”
<em>Statistics</em>, <strong>28</strong>(1), 1-12.
<a href="https://doi.org/10.1080/02331889708802543">doi:10.1080/02331889708802543</a>.
</p>
<p>Diersen J, Trenkler G (2001). 
“Weighted Records Tests for Splitted Series of Observations.”
In J Kunert, G Trenkler (eds.), 
<em>Mathematical Statistics with Applications in Biometry: Festschrift in Honour of Prof. Dr. Siegfried Schach</em>, 
pp. 163–178. Lohmar: Josef Eul Verlag.
</p>
<p>Foster FG, Stuart A (1954). 
“Distribution-Free Tests in Time-Series Based on the Breaking of Records.”
<em>Journal of the Royal Statistical Society B</em>, 
<strong>16</strong>(1), 1-22.
<a href="https://doi.org/10.1111/j.2517-6161.1954.tb00143.x">doi:10.1111/j.2517-6161.1954.tb00143.x</a>.
</p>

<hr>
<h2 id='.MonteCarlo'>Monte Carlo Draws</h2><span id='topic+.MonteCarlo'></span>

<h3>Description</h3>

<p>This function performs Monte Carlo simulations when needed,
it is not developed for the use of the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.MonteCarlo(
  statistic,
  alternative,
  FUN,
  B = 1000,
  rdist = stats::runif,
  Trows,
  Mcols,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".MonteCarlo_+3A_statistic">statistic</code></td>
<td>
<p>Observed value of the statistic.</p>
</td></tr>
<tr><td><code id=".MonteCarlo_+3A_alternative">alternative</code></td>
<td>
<p>A character string indicating the alternative hypothesis
and must be one of <code>"greater"</code>, <code>"less"</code> or <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code id=".MonteCarlo_+3A_fun">FUN</code></td>
<td>
<p>A function that computes the statistic.</p>
</td></tr>
<tr><td><code id=".MonteCarlo_+3A_b">B</code></td>
<td>
<p>An integer specifying the number of replicates used in the Monte
Carlo approach.</p>
</td></tr>
<tr><td><code id=".MonteCarlo_+3A_rdist">rdist</code></td>
<td>
<p>function that simulates continuous random variables, 
e.g., <code><a href="stats.html#topic+runif">runif</a></code> (fastest in <code>stats</code> package), 
<code><a href="stats.html#topic+rnorm">rnorm</a></code> or <code><a href="stats.html#topic+rexp">rexp</a></code>.</p>
</td></tr>
<tr><td><code id=".MonteCarlo_+3A_trows">Trows</code>, <code id=".MonteCarlo_+3A_mcols">Mcols</code></td>
<td>
<p>Number of rows and columns respectively, of the desired 
sample <code>rdist</code>.</p>
</td></tr>
<tr><td><code id=".MonteCarlo_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated p-value.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>

<hr>
<h2 id='brown.method'>Brown's Method on the Number of Records</h2><span id='topic+brown.method'></span>

<h3>Description</h3>

<p>Performs Brown's method on the p-values of <code><a href="#topic+N.test">N.test</a></code>
as proposed by Cebrián, Castillo-Mateo and Asín (2022). The null 
hypothesis of the classical record model (i.e., of IID continuous RVs) is 
tested against the alternative hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brown.method(
  X,
  weights = function(t) 1,
  record = c(FU = 1, FL = 1, BU = 1, BL = 1),
  alternative = c(FU = "greater", FL = "less", BU = "less", BL = "greater"),
  correct = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brown.method_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="brown.method_+3A_weights">weights</code></td>
<td>
<p>A function indicating the weight given to the different 
records according to their position in the series,
e.g., if <code>function(t) t-1</code> then <code class="reqn">\omega_t = t-1</code>.</p>
</td></tr>
<tr><td><code id="brown.method_+3A_record">record</code></td>
<td>
<p>Vector of length four. Each element is a logical indicating if
the p-value of the test for forward upper, forward lower, backward upper 
and backward lower are going to be used, respectively. Logical values or 
0,1 values are accepted.</p>
</td></tr>
<tr><td><code id="brown.method_+3A_alternative">alternative</code></td>
<td>
<p>Vector of length four. Each element is one of 
<code>"greater"</code> or <code>"less"</code> indicating the alternative hypothesis 
in every test (for forward upper, forward lower, backward upper and 
backward lower records, respectively). Under the alternative hypothesis 
of linear trend the FU and BL records will be greater and the FL and BU
records will be less than under the null, but other combinations (e.g., 
for trend in variation) could be considered.</p>
</td></tr>
<tr><td><code id="brown.method_+3A_correct">correct</code></td>
<td>
<p>Logical. Indicates, whether a continuity correction 
should be applied in <code><a href="#topic+N.test">N.test</a></code>; defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is implemented as given by Cebrián, 
Castillo-Mateo and Asín (2022), where the p-values 
<code class="reqn">p^{(FU)}</code>, <code class="reqn">p^{(FL)}</code>, <code class="reqn">p^{(BU)}</code>, and <code class="reqn">p^{(BL)}</code>
of the test <code><a href="#topic+N.test">N.test</a></code> for the four types of record are used for
the statistic:
</p>
<p style="text-align: center;"><code class="reqn">-2 \left(\log(p^{(FU)}) + \log(p^{(FL)}) + \log(p^{(BU)}) + \log(p^{(BL)})\right).</code>
</p>

<p>Any other combination of p-values for the test is also allowed (see 
argument <code>record</code>).
</p>
<p>According to Brown's method (Brown, 1975) for the union of dependent 
p-values, the statistic follows a <code class="reqn">c \chi^2_{df}</code> distribution, 
with a scale parameter <code class="reqn">c</code> and <code class="reqn">df</code> degrees of freedom that 
depend on the covariance of the p-values. This covariances are 
approximated according to Kost and McDermott (2002):
</p>
<p style="text-align: center;"><code class="reqn">\textrm{COV}\left(-2 \log(p^{(i)}), -2 \log(p^{(j)})\right) \approx 3.263 \rho_{ij} + 0.710 \rho_{ij}^2 + 0.027 \rho_{ij}^3,</code>
</p>

<p>where <code class="reqn">\rho_{ij}</code> is the correlation between their respective 
statistics.
</p>
<p>Power studies indicate that this and <code><a href="#topic+foster.test">foster.test</a></code> using all
four types of record and linear weights are the two most powerful records
tests for trend detection against a linear drift model. In particular, 
this test is more powerful than Mann-Kendall test against alternatives 
with a linear drift in location in series of generalised Pareto variables
and some cases of the generalised extreme value variables (see Cebrián, 
Castillo-Mateo and Asín, 2022).
</p>


<h3>Value</h3>

<p>A <code>"htest"</code> object with elements:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>Value of the chi-square statistic (not scaled).</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>Degrees of freedom <code class="reqn">df</code> and scale parameter <code class="reqn">c</code>.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string indicating the type of test performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Brown M (1975). “A Method for Combining Non-Independent, One-Sided Tests of Significance.” 
<em>Biometrics</em>, <strong>31</strong>(4), 987-992.
<a href="https://doi.org/10.2307/2529826">doi:10.2307/2529826</a>.
</p>
<p>Cebrián AC, Castillo-Mateo J, Asín J (2022).
“Record Tests to Detect Non Stationarity in the Tails with an Application to Climate Change.”
<em>Stochastic Environmental Research and Risk Assessment</em>, <strong>36</strong>(2), 313-330.
<a href="https://doi.org/10.1007/s00477-021-02122-w">doi:10.1007/s00477-021-02122-w</a>.
</p>
<p>Kost JT, McDermott MP (2002). “Combining Dependent P-Values.”
<em>Statistics &amp; Probability Letters</em>, <strong>60</strong>(2), 183-190.
<a href="https://doi.org/10.1016/S0167-7152%2802%2900310-3">doi:10.1016/S0167-7152(02)00310-3</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fisher.method">fisher.method</a></code>, <code><a href="#topic+foster.test">foster.test</a></code>, 
<code><a href="#topic+N.test">N.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>brown.method(ZaragozaSeries)
brown.method(ZaragozaSeries, weights = function(t) t-1)
brown.method(ZaragozaSeries, weights = function(t) t-1, correct = FALSE)

# Join p-values of upper records
brown.method(ZaragozaSeries, weights = function(t) t-1, record = c(1,0,1,0))
# Join p-values of lower records
brown.method(ZaragozaSeries, weights = function(t) t-1, record = c(0,1,0,1))

</code></pre>

<hr>
<h2 id='change.point'>Change-point Detection Tests Based on Records</h2><span id='topic+change.point'></span>

<h3>Description</h3>

<p>Performs change-point detection tests based on the record
occurrence. The hypothesis of the classical record model (i.e., of IID 
continuous RVs) is tested against the alternative hypothesis that after a 
certain time the series stops being IID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change.point(
  X,
  weights = function(t) 1,
  record = c("upper", "lower", "d", "s"),
  correct = c("none", "fisher", "vrbik"),
  permutation.test = FALSE,
  simulate.p.value = FALSE,
  B = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="change.point_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="change.point_+3A_weights">weights</code></td>
<td>
<p>A function indicating the weight given to the different 
records according to their position in the series. Castillo-Mateo (2022)
showed that the weights that get more power for this test are 
<code class="reqn">\omega_t = \sqrt{t^2 / (t - 1)}</code>, i.e., 
<code>weights = function(t) ifelse(t == 1, 0, sqrt(t^2 / (t - 1)))</code> if
<code>record = "upper"</code> or <code>= "lower"</code>.
<code class="reqn">\omega_t = \sqrt{t}</code>, i.e., <code>weights = function(t) sqrt(t)</code> if
<code>record = "d"</code> and <code class="reqn">\omega_t = \sqrt{t^2 / (t-2)}</code>, i.e., 
<code>weights = function(t) ifelse(t %in% 1:2, 0, sqrt(t^2 / (t-2)))</code> if
<code>record = "s"</code>.</p>
</td></tr>
<tr><td><code id="change.point_+3A_record">record</code></td>
<td>
<p>A character string that indicates the type of statistic used.
The statistic with <code>"upper"</code> or <code>= "lower"</code> records, or the 
statistic with the difference, <code>"d"</code>, or the sum, <code>"s"</code>, of 
upper and lower records.</p>
</td></tr>
<tr><td><code id="change.point_+3A_correct">correct</code></td>
<td>
<p>A character string that indicates the continuity correction
in the Kolmogorov distribution made to the statistic: &quot;fisher&quot; (Fisher and
Robbins 2019), &quot;vrbik&quot; (Vrbik 2020) or &quot;none&quot; (the default) if no 
correction is made. The former shows better size and power, but if the 
value of the statistic is too large it becomes <code>NaN</code> and p-value 
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="change.point_+3A_permutation.test">permutation.test</code></td>
<td>
<p>Logical. Indicates whether to compute p-values by
permutation simulation (Castillo-Mateo et al. 2023). It does not require 
that the columns of <code>X</code> be independent. If <code>TRUE</code> and 
<code>simulate.p.value = TRUE</code>, permutations take precedence and 
permutations are performed.</p>
</td></tr>
<tr><td><code id="change.point_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>Logical. Indicates whether to compute p-values by
Monte Carlo simulation. If <code>permutation.test = TRUE</code>, permutations    
take precedence and permutations are performed.</p>
</td></tr>
<tr><td><code id="change.point_+3A_b">B</code></td>
<td>
<p>If <code>permutation.test = TRUE</code> or <code>simulate.p.value = TRUE</code>,
an integer specifying the number of replicates used in the permutation or    
Monte Carlo estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is implemented as given by Castillo-Mateo (2022). The null 
hypothesis is that 
</p>
<p style="text-align: center;"><code class="reqn">H_0: p_t = 1/t, \qquad t=1,\ldots,T,</code>
</p>

<p>where <code class="reqn">p_t</code> is the probability of (upper and/or lower) record at time 
<code class="reqn">t</code>. The two-sided alternative hypothesis is that 
</p>
<p style="text-align: center;"><code class="reqn">H_1: p_t = 1/t, \quad t=1,\ldots,t_0, \qquad p_t \neq 1/t, \quad t=t_0+1,\ldots,T,</code>
</p>

<p>for a change-point <code class="reqn">t_0</code>.
</p>
<p>The variables used for the statistic are
</p>
<p style="text-align: center;"><code class="reqn">K^{\omega}_T = \max_{1\le t \le T} \left| \frac{N_{t}^{\omega} - \textrm{E}(N_{t}^{\omega})}{\sqrt{\textrm{VAR}(N_{T}^{\omega})}} - \frac{\textrm{VAR}(N_{t}^{\omega})}{\textrm{VAR}(N_{T}^{\omega})} \frac{N_{T}^{\omega} - \textrm{E}(N_{T}^{\omega})}{\sqrt{\textrm{VAR}(N_{T}^{\omega})}} \right|,</code>
</p>

<p>where <code class="reqn">N_{t}^\omega = \sum_{m=1}^M \sum_{j=1}^t \omega_j I_{jm}</code>, and
the estimated change-point <code class="reqn">\hat{t}_0</code> is the value <code class="reqn">t</code> where 
<code class="reqn">K^{\omega}_T</code> attains its maximum.
</p>
<p>Argument <code>record</code> indicates if the <code class="reqn">I_{tm}</code>'s are the 
<code>"upper"</code> or <code>"lower"</code> record indicators (see 
<code><a href="#topic+I.record">I.record</a></code>). If <code>record = "d"</code> or <code>= "s"</code>,
<code class="reqn">N_{t}^\omega</code> is substituted in the expressions above by 
<code class="reqn">d_{t}^{\omega,(F)} = N_{t}^{\omega,(FU)} - N_{t}^{\omega,(FL)}</code> or 
<code class="reqn">s_{t}^{\omega,(F)} = N_{t}^{\omega,(FU)} + N_{t}^{\omega,(FL)}</code>, 
respectively.
</p>
<p>The p-value is calculated by means of the asymptotic Kolmogorov
distribution. When <code class="reqn">\omega_t \neq 1</code>, the asymptotic result is not 
fulfilled. In that case, the p-value should be simulated using 	
permutation or Monte Carlo simulations with the option 	
<code>permutation.test = TRUE</code> or <code>simulate.p.value = TRUE</code>, 	
respectively. Permutations is the only method of calculating p-values that	
does not require that the columns of <code>X</code> be independent.	
</p>
<p>As the Kolmogorov distribution is an asymptotic result, it has been seen 	
that the size and power may be a little below than expected, to correct 	
this, any of the continuity corrections can be used:
</p>
<p>If <code>correct = "fisher"</code>,
</p>
<p style="text-align: center;"><code class="reqn">K_T = - \sqrt{T} \log\left(1 - \frac{K_T}{\sqrt{T}}\right).</code>
</p>

<p>If <code>correct = "vrbik"</code>,
</p>
<p style="text-align: center;"><code class="reqn">K_T = K_T + \frac{1}{6\sqrt{T}} + \frac{K_T - 1}{4T}.</code>
</p>



<h3>Value</h3>

<p>A <code>"htest"</code> object with elements:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>Value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>The alternative hypothesis.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated change-point time.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string indicating the type of test performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Castillo-Mateo J (2022).
“Distribution-Free Changepoint Detection Tests Based on the Breaking of Records.”
<em>Environmental and Ecological Statistics</em>, <strong>29</strong>(3), 655-676.
<a href="https://doi.org/10.1007/s10651-022-00539-2">doi:10.1007/s10651-022-00539-2</a>.
</p>
<p>Castillo-Mateo J, Cebrián AC, Asín J (2023).
“Statistical Analysis of Extreme and Record-Breaking Daily Maximum Temperatures in Peninsular Spain during 1960&ndash;2021.”
<em>Atmospheric Research</em>, <strong>293</strong>, 106934.
<a href="https://doi.org/10.1016/j.atmosres.2023.106934">doi:10.1016/j.atmosres.2023.106934</a>.
</p>
<p>Fisher TJ, Robbins MW (2019). 
“A Cheap Trick to Improve the Power of a Conservative Hypothesis Test.”
<em>The American Statistician</em>, <strong>73</strong>(3), 232-242.
<a href="https://doi.org/10.1080/00031305.2017.1395364">doi:10.1080/00031305.2017.1395364</a>.
</p>
<p>Vrbik J (2020). 
“Deriving CDF of Kolmogorov-Smirnov Test Statistic.”
<em>Applied Mathematics</em>, <strong>11</strong>(3), 227-246.
<a href="https://doi.org/10.4236/am.2020.113018">doi:10.4236/am.2020.113018</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+records">records</a></code>, <code><a href="#topic+foster.test">foster.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>change.point(ZaragozaSeries)

change.point(series_split(TX_Zaragoza$TX), record = "d", 	
  weights = function(t) sqrt(t), 
  permutation.test = TRUE, B = 50)

change.point(ZaragozaSeries, record = "d", 
  weights = function(t) sqrt(t), simulate.p.value = TRUE)

test.result &lt;- change.point(rowMeans(ZaragozaSeries))
test.result

## Not run: Load package ggplot2 to plot the changepoint
#library("ggplot2")
#records(rowMeans(ZaragozaSeries)) + 
#  ggplot2::geom_vline(xintercept = test.result$estimate, colour = "red")

</code></pre>

<hr>
<h2 id='fisher.method'>Fisher's Method</h2><span id='topic+fisher.method'></span>

<h3>Description</h3>

<p>Performs Fisher's method, which is used to combine the p-values
from several independent tests bearing upon the same overall null 
hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher.method(p.values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fisher.method_+3A_p.values">p.values</code></td>
<td>
<p>A vector containing the p-values from the single tests.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fisher's method (Fisher, 1925) combines the p-values from <code class="reqn">k</code> 
independent tests, into one test statistic using the following formula:
</p>
<p style="text-align: center;"><code class="reqn">-2 \sum_{i=1}^{k} \log(p_{i}) \sim \chi_{2k}^{2},</code>
</p>

<p>where <code class="reqn">p_i</code> is the p-value for the <code class="reqn">i</code>th hypothesis test.
</p>
<p>For example, Foster and Stuart (1954) proposed this method to combine the
information of the p-values from the <code class="reqn">D</code> and <code class="reqn">S</code>-statistics (see 
Examples), since they are independent.
</p>


<h3>Value</h3>

<p>A <code>"htest"</code> object with elements:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>Value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string indicating the type of test performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Fisher RA (1925). 
<em>Statistical Methods for Research Workers</em>. 
Oliver and Boyd, Edinburgh. 
</p>
<p>Foster FG, Stuart A (1954). 
“Distribution-Free Tests in Time-Series Based on the Breaking of Records.”
<em>Journal of the Royal Statistical Society B</em>, 
<strong>16</strong>(1), 1-22.
<a href="https://doi.org/10.1111/j.2517-6161.1954.tb00143.x">doi:10.1111/j.2517-6161.1954.tb00143.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brown.method">brown.method</a></code>, <code><a href="#topic+foster.test">foster.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Join the independent p-values of the D and S-statistics
fisher.method(c(foster.test(ZaragozaSeries, statistic = "D")$p.value,
  foster.test(ZaragozaSeries, statistic = "S")$p.value))
# Adding weights
fisher.method(c(foster.test(ZaragozaSeries, weights = function(t) t-1, statistic = "D")$p.value,
  foster.test(ZaragozaSeries, weights = function(t) t-1, statistic = "S")$p.value))

</code></pre>

<hr>
<h2 id='foster.plot'>Plots Based on Foster-Stuart and Diersen-Trenkler Statistics</h2><span id='topic+foster.plot'></span>

<h3>Description</h3>

<p>This function builds a ggplot object to display two-sided
reference intervals based on Foster-Stuart and Diersen-Trenkler 
statistics to study the hypothesis of the classical record model (i.e., 
of IID continuous RVs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foster.plot(
  X,
  weights = function(t) 1,
  statistic = c("D", "d", "S", "s", "U", "L", "W"),
  point.col = "black",
  point.shape = 19,
  conf.int = TRUE,
  conf.level = 0.9,
  conf.aes = c("ribbon", "errorbar"),
  conf.col = "grey69"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="foster.plot_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="foster.plot_+3A_weights">weights</code></td>
<td>
<p>A function indicating the weight given to the different 
records according to their position in the series,
e.g., if <code>function(t) t-1</code> then <code class="reqn">\omega_t = t-1</code>.</p>
</td></tr>
<tr><td><code id="foster.plot_+3A_statistic">statistic</code></td>
<td>
<p>A character string indicating the type of statistic to be 
calculated, i.e., one of <code>"D"</code>, <code>"d"</code>, <code>"S"</code>, <code>"s"</code>,
<code>"U"</code>, <code>"L"</code> or <code>"W"</code> (see <code><a href="#topic+foster.test">foster.test</a></code>).</p>
</td></tr>
<tr><td><code id="foster.plot_+3A_point.col">point.col</code>, <code id="foster.plot_+3A_point.shape">point.shape</code></td>
<td>
<p>Value with the colour and shape of the points.</p>
</td></tr>
<tr><td><code id="foster.plot_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical. Indicates if the RIs are also shown.</p>
</td></tr>
<tr><td><code id="foster.plot_+3A_conf.level">conf.level</code></td>
<td>
<p>(If <code>conf.int == TRUE</code>) Confidence level of the RIs.</p>
</td></tr>
<tr><td><code id="foster.plot_+3A_conf.aes">conf.aes</code></td>
<td>
<p>(If <code>conf.int == TRUE</code>) A character string indicating 
the aesthetic to display for the RIs, <code>"ribbon"</code> (grey area) or 
<code>"errorbar"</code> (vertical lines).</p>
</td></tr>
<tr><td><code id="foster.plot_+3A_conf.col">conf.col</code></td>
<td>
<p>Colour used to plot the expected value and (if 
<code>conf.int == TRUE</code>) RIs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots the observed values of the statistic selected with 
<code>statistic</code>, obtained with the series up to time <code class="reqn">t</code> for 
<code class="reqn">t=1,\ldots,T</code>. The plot also includes the expected values and 
reference intervals (RIs) based on the asymptotic normal distribution 
of the statistics under the null hypothesis.
</p>
<p>This function implements the same ideas that <code><a href="#topic+N.plot">N.plot</a></code>, but with
the statistics computed in <code><a href="#topic+foster.test">foster.test</a></code>. 
</p>
<p>These plots are useful to see the evolution in the record occurrence 
and to follow the evolution of the trend. The plot was proposed by 
Cebrián, Castillo-Mateo, Asín (2022) where its application is shown.
</p>


<h3>Value</h3>

<p>A ggplot graph object.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Cebrián AC, Castillo-Mateo J, Asín J (2022).
“Record Tests to Detect Non Stationarity in the Tails with an Application to Climate Change.”
<em>Stochastic Environmental Research and Risk Assessment</em>, <strong>36</strong>(2), 313-330. 
<a href="https://doi.org/10.1007/s00477-021-02122-w">doi:10.1007/s00477-021-02122-w</a>.
</p>
<p>Diersen J, Trenkler G (1996). “Records Tests for Trend in Location.”
<em>Statistics</em>, <strong>28</strong>(1), 1-12.
<a href="https://doi.org/10.1080/02331889708802543">doi:10.1080/02331889708802543</a>.
</p>
<p>Diersen J, Trenkler G (2001). 
“Weighted Records Tests for Splitted Series of Observations.”
In J Kunert, G Trenkler (eds.), 
<em>Mathematical Statistics with Applications in Biometry: Festschrift in Honour of Prof. Dr. Siegfried Schach</em>, 
pp. 163–178. Lohmar: Josef Eul Verlag.
</p>
<p>Foster FG, Stuart A (1954). 
“Distribution-Free Tests in Time-Series Based on the Breaking of Records.”
<em>Journal of the Royal Statistical Society B</em>, 
<strong>16</strong>(1), 1-22.
<a href="https://doi.org/10.1111/j.2517-6161.1954.tb00143.x">doi:10.1111/j.2517-6161.1954.tb00143.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foster.test">foster.test</a></code>, <code><a href="#topic+N.plot">N.plot</a></code>, 
<code><a href="#topic+N.test">N.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># D-statistic
foster.plot(ZaragozaSeries)
# D-statistic with linear weights
foster.plot(ZaragozaSeries, weights = function(t) t-1)
# S-statistic with linear weights
foster.plot(ZaragozaSeries, statistic = "S", weights = function(t) t-1)
# U-statistic with weights (upper tail)
foster.plot(ZaragozaSeries, statistic = "U", weights = function(t) t-1)
# L-statistic with weights (lower tail)
foster.plot(ZaragozaSeries, statistic = "L", weights = function(t) t-1)

</code></pre>

<hr>
<h2 id='foster.test'>Foster-Stuart and Diersen-Trenkler Tests</h2><span id='topic+foster.test'></span>

<h3>Description</h3>

<p>Performs Foster-Stuart, Diersen-Trenkler and 
Cebrián-Castillo-Asín records tests for trend in location, variation or 
the tails. The hypothesis of the classical record model (i.e., 
of IID continuous RVs) is tested against the alternative hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foster.test(
  X,
  weights = function(t) 1,
  statistic = c("D", "d", "S", "s", "U", "L", "W"),
  distribution = c("normal", "t"),
  alternative = c("greater", "less"),
  correct = FALSE,
  permutation.test = FALSE,
  simulate.p.value = FALSE,
  B = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="foster.test_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="foster.test_+3A_weights">weights</code></td>
<td>
<p>A function indicating the weight given to the different 
records according to their position in the series,
e.g., if <code>function(t) t - 1</code> then <code class="reqn">\omega_t = t - 1</code>.</p>
</td></tr>
<tr><td><code id="foster.test_+3A_statistic">statistic</code></td>
<td>
<p>A character string indicating the type of statistic to be 
calculated, i.e., one of <code>"D"</code>, <code>"d"</code>, <code>"S"</code>, <code>"s"</code>,
<code>"U"</code>, <code>"L"</code> or <code>"W"</code> (see Details).</p>
</td></tr>
<tr><td><code id="foster.test_+3A_distribution">distribution</code></td>
<td>
<p>A character string indicating the asymptotic 
distribution of the statistic, <code>"normal"</code> or Student's
<code>"t"</code> distribution.</p>
</td></tr>
<tr><td><code id="foster.test_+3A_alternative">alternative</code></td>
<td>
<p>A character string indicating the type of alternative 
hypothesis, <code>"greater"</code> number of records or <code>"less"</code> number of
records.</p>
</td></tr>
<tr><td><code id="foster.test_+3A_correct">correct</code></td>
<td>
<p>Logical. Indicates, whether a continuity correction 
should be done; defaults to <code>FALSE</code>. No correction is done if
<code>simulate.p.value = TRUE</code>.</p>
</td></tr>
<tr><td><code id="foster.test_+3A_permutation.test">permutation.test</code></td>
<td>
<p>Logical. Indicates whether to compute p-values by
permutation simulation (Castillo-Mateo et al. 2023). It does not require 
that the columns of <code>X</code> be independent. If <code>TRUE</code> and 
<code>simulate.p.value = TRUE</code>, permutations take precedence and 
permutations are performed.</p>
</td></tr>
<tr><td><code id="foster.test_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>Logical. Indicates whether to compute p-values by
Monte Carlo simulation. If <code>permutation.test = TRUE</code>, permutations
take precedence and permutations are performed.</p>
</td></tr>
<tr><td><code id="foster.test_+3A_b">B</code></td>
<td>
<p>If <code>permutation.test = TRUE</code> or <code>simulate.p.value = TRUE</code>, 
an integer specifying the number of replicates used in the permutation or
Monte Carlo estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, the tests are implemented as given by Foster and Stuart
(1954), Diersen and Trenkler (1996, 2001) and some modifications in the
standardisation of the previous statistics given by Cebrián, 
Castillo-Mateo and Asín (2022). The null hypothesis is that the data come
from a population with independent and identically distributed
realisations. The one-sided alternative hypothesis is that the chosen
statistic is greater (or less) than under the null hypothesis. The
different statistics are calculated according to:
</p>
<p>If <code>statistic == "d"</code>, 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{m=1}^{M} \sum_{t=1}^{T} \omega_t \left( I_{tm}^{(FU)} - I_{tm}^{(FL)}\right).</code>
</p>

<p>If <code>statistic == "D"</code>, 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{m=1}^{M} \sum_{t=1}^{T} \omega_t \left( I_{tm}^{(FU)} - I_{tm}^{(FL)} - I_{tm}^{(BU)} + I_{tm}^{(BL)}\right).</code>
</p>

<p>If <code>statistic == "s"</code>, 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{m=1}^{M} \sum_{t=1}^{T} \omega_t \left( I_{tm}^{(FU)} + I_{tm}^{(FL)}\right).</code>
</p>

<p>If <code>statistic == "S"</code>, 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{m=1}^{M} \sum_{t=1}^{T} \omega_t \left( I_{tm}^{(FU)} + I_{tm}^{(FL)} - I_{tm}^{(BU)} - I_{tm}^{(BL)}\right).</code>
</p>

<p>If <code>statistic == "U"</code>, 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{m=1}^{M} \sum_{t=1}^{T} \omega_t \left( I_{tm}^{(FU)} - I_{tm}^{(BU)}\right).</code>
</p>

<p>If <code>statistic == "L"</code>, 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{m=1}^{M} \sum_{t=1}^{T} \omega_t \left( I_{tm}^{(BL)} - I_{tm}^{(FL)}\right).</code>
</p>

<p>If <code>statistic == "W"</code>, 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{m=1}^{M} \sum_{t=1}^{T} \omega_t \left( I_{tm}^{(FU)} + I_{tm}^{(BL)}\right).</code>
</p>

<p>Where <code class="reqn">\omega_t</code> are weights given to the different records
according to their position in the series, <code class="reqn">I_{tm}</code> are the record
indicators (see <code><a href="#topic+I.record">I.record</a></code>), and <code class="reqn">(FU)</code>, <code class="reqn">(FL)</code>, 
<code class="reqn">(BU)</code>, and <code class="reqn">(BL)</code> represent forward upper, forward lower,
backward upper and backward lower records, respectively. The statistics 
<code class="reqn">d</code>, <code class="reqn">D</code> and <code class="reqn">W</code> may be used for trend in location;
<code class="reqn">s</code> and <code class="reqn">S</code> may be used for trend in variation; and <code class="reqn">U</code> and
<code class="reqn">L</code> may be used for trend in the upper and lower tails of the 
distribution respectively.
</p>
<p>The statistics, say <code class="reqn">X</code>, are approximately normally distributed, with
</p>
<p style="text-align: center;"><code class="reqn">Z = \frac{X - \mu}{\sigma},</code>
</p>

<p>while the mean <code class="reqn">\mu</code> of the particular statistic considered is simple
to calculate, its variance <code class="reqn">\sigma^2</code> become a cumbersome expression
and some are given by Diersen and Trenkler (2001) and all of them can be
easily computed out of the expression of the covariances given by Cebrián, 
Castillo-Mateo and Asín (2022). 
</p>
<p>If <code>correct = TRUE</code>, then a continuity correction will be employed:
</p>
<p style="text-align: center;"><code class="reqn">Z = \frac{X \pm 0.5 - \mu}{\sigma},</code>
</p>

<p>with &ldquo;<code class="reqn">-</code>&rdquo; if the alternative is greater and &ldquo;<code class="reqn">+</code>&rdquo; if the 
alternative is less. Not recommended for the statistics with <code class="reqn">\mu=0</code>.
</p>
<p>When <code class="reqn">M&gt;1</code>, the expression of the variance under the null hypothesis
can be substituted by the sample variance in the <code class="reqn">M</code> series, 
<code class="reqn">\hat{\sigma}^2</code>. In this case, the statistics are asymptotically
<code class="reqn">t</code> distributed, which is a more robust alternative against serial 
correlation.
</p>
<p>If <code>permutation.test = TRUE</code>, the p-value is estimated by permutation
simulations. This is the only method of calculating p-values that does not
require that the columns of <code>X</code> be independent.
</p>
<p>If <code>simulate.p.value = TRUE</code>, the p-value is estimated by Monte Carlo
simulations. If the normal asymptotic <code>statistic</code> <code>"D"</code>, 
<code>"S"</code> or <code>"W"</code> is used when the length of the 
series <code class="reqn">T</code> is greater than 1000 or 1500, permutations or this approach
are preferable due to the computational cost of calculating the variance
of the statistic under the null hypothesis. The exception is <code>"D"</code> 
without weights, which has an alternative algorithm implemented to 
calculate the variance quickly.
</p>


<h3>Value</h3>

<p>A <code>"htest"</code> object with elements:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>Value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>(If <code>distribution = "t"</code>) Degrees of freedom of
the <code class="reqn">t</code> statistic (equal to <code class="reqn">M-1</code>).</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>The alternative hypothesis.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>(If <code>distribution = "normal"</code>) A vector with the
value of the statistic, <code class="reqn">\mu</code> and <code class="reqn">\sigma^2</code>. <code class="reqn">\sigma^2</code>
is <code>NA</code> if <code>statistic</code> is one of <code>"D"</code>, <code>"S"</code> or 
<code>"W"</code> (with the exception of <code>"D"</code> without weights); the
p-value is computed with permutations or Monte Carlo simulations; and 
<code class="reqn">T &gt; 500</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string indicating the type of test performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Castillo-Mateo J, Cebrián AC, Asín J (2023).
“Statistical Analysis of Extreme and Record-Breaking Daily Maximum Temperatures in Peninsular Spain during 1960&ndash;2021.”
<em>Atmospheric Research</em>, <strong>293</strong>, 106934.
<a href="https://doi.org/10.1016/j.atmosres.2023.106934">doi:10.1016/j.atmosres.2023.106934</a>.
</p>
<p>Cebrián AC, Castillo-Mateo J, Asín J (2022).
“Record Tests to Detect Non Stationarity in the Tails with an Application to Climate Change.”
<em>Stochastic Environmental Research and Risk Assessment</em>, <strong>36</strong>(2), 313-330. 
<a href="https://doi.org/10.1007/s00477-021-02122-w">doi:10.1007/s00477-021-02122-w</a>.
</p>
<p>Diersen J, Trenkler G (1996). “Records Tests for Trend in Location.”
<em>Statistics</em>, <strong>28</strong>(1), 1-12.
<a href="https://doi.org/10.1080/02331889708802543">doi:10.1080/02331889708802543</a>.
</p>
<p>Diersen J, Trenkler G (2001). 
“Weighted Records Tests for Splitted Series of Observations.”
In J Kunert, G Trenkler (eds.), 
<em>Mathematical Statistics with Applications in Biometry: Festschrift in Honour of Prof. Dr. Siegfried Schach</em>, 
pp. 163–178. Lohmar: Josef Eul Verlag.
</p>
<p>Foster FG, Stuart A (1954). 
“Distribution-Free Tests in Time-Series Based on the Breaking of Records.”
<em>Journal of the Royal Statistical Society B</em>, 
<strong>16</strong>(1), 1-22.
<a href="https://doi.org/10.1111/j.2517-6161.1954.tb00143.x">doi:10.1111/j.2517-6161.1954.tb00143.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foster.plot">foster.plot</a></code>, <code><a href="#topic+N.plot">N.plot</a></code>, 
<code><a href="#topic+N.test">N.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># D-statistic
foster.test(ZaragozaSeries)
# D-statistic with linear weights
foster.test(ZaragozaSeries, weights = function(t) t - 1)
# S-statistic with linear weights
foster.test(ZaragozaSeries, statistic = "S", weights = function(t) t - 1)
# D-statistic with weights and t approach
foster.test(ZaragozaSeries, distribution = "t", weights = function(t) t - 1)
# U-statistic with weights (upper tail)
foster.test(ZaragozaSeries, statistic = "U", weights = function(t) t - 1)
# L-statistic with weights (lower tail)
foster.test(ZaragozaSeries, statistic = "L", weights = function(t) t - 1)

</code></pre>

<hr>
<h2 id='global.test'>Global Statistic for Two-Sided Tests</h2><span id='topic+global.test'></span>

<h3>Description</h3>

<p>Performs a more powerful generalisation of the 
two-sided tests in this package by means of the sum of the statistics of 
upper and lower records in the forward and backward directions to study 
the hypothesis of the classical record model (i.e., of IID continuous 
RVs). The tests considered are the chi-square goodness-of-fit test
<code><a href="#topic+p.chisq.test">p.chisq.test</a></code>, the regression test 
<code><a href="#topic+p.regression.test">p.regression.test</a></code>,
the likelihood-ratio test <code><a href="#topic+lr.test">lr.test</a></code>, and the score test
<code><a href="#topic+score.test">score.test</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global.test(X, FUN, record = c(FU = 1, FL = 1, BU = 1, BL = 1), B = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global.test_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="global.test_+3A_fun">FUN</code></td>
<td>
<p>One of the functions whose statistic is going to be used. One of
<code><a href="#topic+p.chisq.test">p.chisq.test</a></code>, <code><a href="#topic+p.regression.test">p.regression.test</a></code>, 
<code><a href="#topic+lr.test">lr.test</a></code> or <code><a href="#topic+score.test">score.test</a></code>.</p>
</td></tr>
<tr><td><code id="global.test_+3A_record">record</code></td>
<td>
<p>Logical vector. Vector with four elements indicating if 
forward upper, forward lower, backward upper and backward lower are going
to be shown, respectively. Logical values or 0,1 values are accepted.</p>
</td></tr>
<tr><td><code id="global.test_+3A_b">B</code></td>
<td>
<p>An integer specifying the number of replicates used in the 
Monte Carlo approach.</p>
</td></tr>
<tr><td><code id="global.test_+3A_...">...</code></td>
<td>
<p>Further arguments in the <code>FUN</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistics, say <code class="reqn">X</code>, of the tests <code><a href="#topic+p.chisq.test">p.chisq.test</a></code>,
<code><a href="#topic+p.regression.test">p.regression.test</a></code>, <code><a href="#topic+lr.test">lr.test</a></code> or
<code><a href="#topic+score.test">score.test</a></code> applied to the series of the forward upper, 
forward lower, backward upper and backward lower records are summed to 
develop a more powerful statistic:
</p>
<p style="text-align: center;"><code class="reqn">X^{(FU)} + X^{(FL)} + X^{(BU)} + X^{(BL)}.</code>
</p>

<p>Other sums of statistics are allowed.
</p>
<p>The distribution of this global statistics is unknown, 
but the p-value can be estimated with Monte Carlo simulations
</p>


<h3>Value</h3>

<p>A list of class <code>"htest"</code>  with the following elements:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>Value of the  statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>Simulated p-value.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string indicating the type of test.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p.chisq.test">p.chisq.test</a></code>, <code><a href="#topic+p.regression.test">p.regression.test</a></code>, 
<code><a href="#topic+lr.test">lr.test</a></code>, <code><a href="#topic+score.test">score.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run because the simulations take a while if B &gt; 1000
## global statistic with 4 types of record for p.chisq.test
#global.test(ZaragozaSeries, FUN = p.chisq.test)
## global statistic with 4 types of record for p.regression.test
#global.test(ZaragozaSeries, FUN = p.regression.test)
## global statistic with 4 types of record for score.test with restricted alternative
#global.test(ZaragozaSeries, FUN = score.test, probabilities = "equal")
## global statistic with 4 types of record for lr.test with restricted alternative
#global.test(ZaragozaSeries, FUN = lr.test, probabilities = "equal")
## global statistic with 2 types of 'almost' independent records for lr.test
#global.test(ZaragozaSeries, FUN = lr.test, record = c(1,0,0,1), probabilities = "different")

</code></pre>

<hr>
<h2 id='I.record'>Record Indicators</h2><span id='topic+I.record'></span><span id='topic+I.record.default'></span><span id='topic+I.record.numeric'></span><span id='topic+I.record.matrix'></span>

<h3>Description</h3>

<p>Returns the record indicators of the values in a vector.
The record indicator for each value in a vector is a binary variable which
takes the value 1 if the corresponding value in the vector is a record and
0 otherwise. 
</p>
<p>If the argument <code>X</code> is a matrix, then each column is treated as a 
different vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>I.record(X, record = c("upper", "lower"), weak = FALSE)

## Default S3 method:
I.record(X, record = c("upper", "lower"), weak = FALSE)

## S3 method for class 'numeric'
I.record(X, record = c("upper", "lower"), weak = FALSE)

## S3 method for class 'matrix'
I.record(X, record = c("upper", "lower"), weak = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="I.record_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="I.record_+3A_record">record</code></td>
<td>
<p>A character string indicating the type of record to be 
calculated, &quot;upper&quot; or &quot;lower&quot;.</p>
</td></tr>
<tr><td><code id="I.record_+3A_weak">weak</code></td>
<td>
<p>Logical. If <code>TRUE</code>, weak records are also counted. Default
to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\{X_1,\ldots,X_T\}</code> be a vector of random variables of 
size <code class="reqn">T</code>. An observation <code class="reqn">X_t</code> will be called an upper record 
value if its value exceeds that of all previous observations. An 
analogous definition deals with lower record values.
Here, <code class="reqn">X_1</code> is referred to as the reference value or the trivial record.
Then, the sequence of record indicator random variables 
<code class="reqn">\{I_1,\ldots,I_T\}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">I_t = \left\{ 
        \begin{array}{ll} 
          1 &amp; \mbox{if } X_t \mbox{ is a record,} \\ 
          0 &amp; \mbox{if } X_t \mbox{ is not a record.} 
        \end{array} \right.</code>
</p>
 
<p>The method <code>I.record</code> calculates the sample sequence above if the 
argument <code>X</code> is a numeric vector. If the argument <code>X</code> is a 
matrix (or data frame) with <code class="reqn">M</code> columns, the method <code>I.record</code> 
calculates the sample sequence above for each column of the object as if 
all columns were different sequences.
</p>
<p>In summary:
</p>
<p style="text-align: center;"><code class="reqn">\code{I.record}: \code{X} = \left(
                 \begin{array}{cccc} 
                   X_{1,1} &amp; X_{1,2} &amp; \cdots &amp; X_{1,M} \\ 
                   X_{2,1} &amp; X_{2,2} &amp; \cdots &amp; X_{2,M} \\ 
                   \vdots &amp; \vdots &amp;  &amp; \vdots \\ 
                   X_{T,1} &amp; X_{T,2} &amp; \cdots &amp; X_{T,M} \\ 
                 \end{array} \right) 
                 \longrightarrow
                 \left(
                 \begin{array}{cccc} 
                   I_{1,1} &amp; I_{1,2} &amp; \cdots &amp; I_{1,M} \\ 
                   I_{2,1} &amp; I_{2,2} &amp; \cdots &amp; I_{2,M} \\ 
                   \vdots &amp; \vdots &amp;  &amp; \vdots \\ 
                   I_{T,1} &amp; I_{T,2} &amp; \cdots &amp; I_{T,M} \\ 
                 \end{array} \right).</code>
</p>

<p>Indicators of record occurrence can be calculated for both upper and 
lower records.
</p>
<p>All the procedure above can be extended to weak records, which also count
the ties as a new (weak) record. Ties are possible in discrete variables
or if a continuous variable has been rounded. Weak records can be computed
if <code>weak = TRUE</code>.
</p>
<p><code>NA</code> values in <code>X</code> are assigned <code>-Inf</code> for upper records
and <code>Inf</code> for lower records, so they are records only if they are 
placed at <code class="reqn">t = 1</code>.
</p>


<h3>Value</h3>

<p>A binary matrix of the same length or dimension as <code>X</code>, 
indicating the record occurrence.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Arnold BC, Balakrishnan N, Nagaraja HN (1998). 
<em>Records</em>. 
Wiley Series in Probability and Statistics. Wiley, New York.
<a href="https://doi.org/10.1002/9781118150412">doi:10.1002/9781118150412</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L.record">L.record</a></code>, 
<code><a href="#topic+N.record">N.record</a></code>, <code><a href="#topic+Nmean.record">Nmean.record</a></code>, 
<code><a href="#topic+p.record">p.record</a></code>, <code><a href="#topic+R.record">R.record</a></code>,
<code><a href="#topic+records">records</a></code>, <code><a href="#topic+S.record">S.record</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- c(1, 5, 3, 6, 6, 9, 2, 11, 17, 8)
I.record(X)
I.record(X, weak = TRUE)

I.record(ZaragozaSeries)
# record argument can be shortened
I.record(ZaragozaSeries, record = "l")

</code></pre>

<hr>
<h2 id='L.plot'>Times of Record Plot</h2><span id='topic+L.plot'></span>

<h3>Description</h3>

<p>This function builds a ggplot object to display the upper 
and lower record times for both forward and backward directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L.plot(
  X,
  all = TRUE,
  record = c("upper", "lower"),
  point.col = "grey23",
  point.alpha = 0.8,
  line.col = "grey95"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L.plot_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="L.plot_+3A_all">all</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default) the four types of record
are displayed.</p>
</td></tr>
<tr><td><code id="L.plot_+3A_record">record</code></td>
<td>
<p>If <code>all = FALSE</code>, a character string indicating the type
of record to be calculated, &quot;upper&quot; or &quot;lower&quot;.</p>
</td></tr>
<tr><td><code id="L.plot_+3A_point.col">point.col</code>, <code id="L.plot_+3A_point.alpha">point.alpha</code></td>
<td>
<p>Colour and transparency of the points.</p>
</td></tr>
<tr><td><code id="L.plot_+3A_line.col">line.col</code></td>
<td>
<p>Colour to plot lines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be applied to plot the record times in a vector 
(if argument <code>X</code> is a vector) or to plot and compare the record 
times in a set of vectors (if argument <code>X</code> is a matrix). In the 
latter case, the approach to obtain the record times is applied to each 
column of the matrix.
</p>
<p>If <code>all = TRUE</code>, a matrix of four panels is displayed for upper and
lower records, and for the forward and backward (<code><a href="#topic+series_rev">series_rev</a></code>)
directions. Otherwise, only one type of forward record is displayed.
</p>
<p>An example of use of a plot with similar ideas is shown in Benestad 
(2004, Figures 3 and 8).
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Benestad RE (2004). “Record-Values, Nonstationarity Tests and Extreme Value Distributions.”
<em>Global and Planetary Change</em>, <strong>44</strong>(1-4), 11-26.
<a href="https://doi.org/10.1016/j.gloplacha.2004.06.002">doi:10.1016/j.gloplacha.2004.06.002</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L.record">L.record</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- c(1, 5, 3, 6, 6, 9, 2, 11, 17, 8)
L.plot(Y, all = FALSE)

L.plot(ZaragozaSeries, point.col = 1)

</code></pre>

<hr>
<h2 id='L.record'>Record Times</h2><span id='topic+L.record'></span>

<h3>Description</h3>

<p>Returns the record times of the values in a vector.
The record times are the positions in a vector where a record occurs. 
</p>
<p>If the argument <code>X</code> is a matrix, then each column is treated as a 
different vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L.record(X, record = c("upper", "lower"), weak = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L.record_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="L.record_+3A_record">record</code></td>
<td>
<p>A character string indicating the type of record to be 
calculated, &quot;upper&quot; or &quot;lower&quot;.</p>
</td></tr>
<tr><td><code id="L.record_+3A_weak">weak</code></td>
<td>
<p>Logical. If <code>TRUE</code>, weak records are also counted. Default
to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence of record times <code class="reqn">\{L_1,\ldots,L_I\}</code> can be 
expressed in terms of the record indicator random variables 
<code><a href="#topic+I.record">I.record</a></code> by
</p>
<p style="text-align: center;"><code class="reqn">L_i = \min\{ t \mid I_1 + I_2 + \ldots + I_t = i \}.</code>
</p>

<p>Record times can be calculated for both upper and lower records.
</p>


<h3>Value</h3>

<p>If <code>X</code> is a vector, the function returns a list containing the 
vector of record times. If <code>X</code> is a matrix, the function returns a 
list where each element is a vector indicating the record times of the 
corresponding <code>X</code> column.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Arnold BC, Balakrishnan N, Nagaraja HN (1998). 
<em>Records</em>. 
Wiley Series in Probability and Statistics. Wiley, New York.
<a href="https://doi.org/10.1002/9781118150412">doi:10.1002/9781118150412</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+I.record">I.record</a></code>, <code><a href="#topic+N.record">N.record</a></code>,
<code><a href="#topic+Nmean.record">Nmean.record</a></code>, <code><a href="#topic+p.record">p.record</a></code>, 
<code><a href="#topic+R.record">R.record</a></code>, <code><a href="#topic+records">records</a></code>, <code><a href="#topic+S.record">S.record</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y1 &lt;- c( 1,  5,  3,  6,  6,  9,  2)
Y2 &lt;- c(10,  5,  3,  6,  6,  9,  2)
Y3 &lt;- c( 5,  7,  3,  6, 19,  2, 20)
Y  &lt;- cbind(Y1, Y2, Y3)

L.record(Y1)
L.record(Y)

</code></pre>

<hr>
<h2 id='lr.test'>Likelihood-Ratio Test for the Likelihood of the Record Indicators</h2><span id='topic+lr.test'></span>

<h3>Description</h3>

<p>This function performs likelihood-ratio tests
for the likelihood of the record indicators <code class="reqn">I_t</code> to study the 
hypothesis of the classical record model (i.e., of IID continuous RVs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lr.test(
  X,
  record = c("upper", "lower"),
  alternative = c("two.sided", "greater", "less"),
  probabilities = c("different", "equal"),
  simulate.p.value = FALSE,
  B = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lr.test_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="lr.test_+3A_record">record</code></td>
<td>
<p>A character string indicating the type of record, 
&quot;upper&quot; or &quot;lower&quot;.</p>
</td></tr>
<tr><td><code id="lr.test_+3A_alternative">alternative</code></td>
<td>
<p>A character indicating the alternative hypothesis 
(<code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>). 
Different statistics are used in the one-sided and two-sided alternatives
(see Details).</p>
</td></tr>
<tr><td><code id="lr.test_+3A_probabilities">probabilities</code></td>
<td>
<p>A character indicating if the alternative hypothesis 
assume all series with <code>"equal"</code> or <code>"different"</code> probabilities
of record.</p>
</td></tr>
<tr><td><code id="lr.test_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>Logical. Indicates whether to compute p-values by
Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="lr.test_+3A_b">B</code></td>
<td>
<p>An integer specifying the number of replicates used in the Monte 
Carlo estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis of the likelihood-ratio tests is that in every vector 
(columns of the matrix <code>X</code>), the probability of record at 
time <code class="reqn">t</code> is <code class="reqn">1 / t</code> as in the classical record model, and 
the alternative depends on the <code>alternative</code> and <code>probabilities</code>
arguments. The probability at time <code class="reqn">t</code> is any value, but equal in the
<code class="reqn">M</code> series if <code>probabilities = "equal"</code>  or different in the 
<code class="reqn">M</code> series if <code>probabilities = "different"</code>. The alternative 
hypothesis is more specific in the first case than in the second one.
Furthermore, the <code>"two.sided"</code> <code>alternative</code> is tested with 
the usual likelihood ratio statistic, while the one-sided 
<code>alternatives</code> use specific statistics based on likelihoods
(see Cebrián, Castillo-Mateo and Asín, 2022, for the details).
</p>
<p>If <code>alternative = "two.sided" &amp; probabilities = "equal"</code>, under the
null, the likelihood ratio statistic has an asymptotic <code class="reqn">\chi^2</code> 
distribution with <code class="reqn">T-1</code> degrees of freedom. It has been seen that for
the approximation to be adequate <code class="reqn">M</code> must be between 4 and 5 times 
greater than <code class="reqn">T</code>. Otherwise, a <code>simulate.p.value</code> is recommended.
</p>
<p>If <code>alternative = "two.sided" &amp; probabilities = "different"</code>, the 
asymptotic behaviour is not fulfilled, but the Monte Carlo approach to 
simulate the p-value is applied. This statistic is the same as <code class="reqn">\ell</code> 
below multiplied by a factor of 2, so the p-value is the same.
</p>
<p>If <code>alternative</code> is one-sided and <code>probabilities = "equal"</code>,
the statistic of the test is
</p>
<p style="text-align: center;"><code class="reqn">-2 \sum_{t=2}^T \left\{-S_t \log\left(\frac{tS_t}{M}\right)+(M-S_t)\left( \log\left(1-\frac{1}{t}\right) - \log\left(1-\frac{S_t}{M}\right) I_{\{S_t&lt;M\}} \right) \right\} I_{\{S_t &gt; M/t\}}.</code>
</p>

<p>The p-value of this test is estimated with Monte Carlo simulations,
because the computation of its exact distribution is very expensive.   
</p>
<p>If <code>alternative</code> is one-sided and <code>probabilities = "different"</code>,
the statistic of the test is
</p>
<p style="text-align: center;"><code class="reqn">\ell = \sum_{t=2}^T  S_{t} \log(t-1) - M \log\left(1-\frac{1}{t}\right).</code>
</p>

<p>The p-value of this test is estimated with Monte Carlo simulations. 
However, it is equivalent to the statistic of the weighted number of 
records <code><a href="#topic+N.test">N.test</a></code> with weights <code class="reqn">\omega_t = \log(t-1)</code> 
<code class="reqn">(t=2,\ldots,T)</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>"htest"</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>Value of the statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>Degrees of freedom of the approximate <code class="reqn">\chi^2</code> 
distribution.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>(Estimated) P-value.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string indicating the type of test.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the name of the data.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>A character string indicating the alternative
hypothesis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Cebrián AC, Castillo-Mateo J, Asín J (2022).
“Record Tests to Detect Non Stationarity in the Tails with an Application to Climate Change.”
<em>Stochastic Environmental Research and Risk Assessment</em>, <strong>36</strong>(2): 313-330. 
<a href="https://doi.org/10.1007/s00477-021-02122-w">doi:10.1007/s00477-021-02122-w</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+global.test">global.test</a></code>, <code><a href="#topic+score.test">score.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(23)
# two-sided and different probabilities of record, always simulated the p-value
lr.test(ZaragozaSeries, probabilities = "different")
# equal probabilities
lr.test(ZaragozaSeries, probabilities = "equal")
# equal probabilities with simulated p-value
lr.test(ZaragozaSeries, probabilities = "equal", simulate.p.value = TRUE)

# one-sided and different probabilities of record
lr.test(ZaragozaSeries, alternative = "greater", probabilities = "different")
# different probabilities with simulated p-value
lr.test(ZaragozaSeries, alternative = "greater", probabilities = "different", 
  simulate.p.value = TRUE)
# equal probabilities, always simulated the p-value
lr.test(ZaragozaSeries, alternative = "greater", probabilities = "equal")
</code></pre>

<hr>
<h2 id='N.plot'>Number of Records Plot</h2><span id='topic+N.plot'></span>

<h3>Description</h3>

<p>This function builds a ggplot object to compare the sample
means of the (weighted) number of records in a vector up to time <code class="reqn">t</code>, 
<code class="reqn">\bar N_{t}^\omega</code>, and the expected values 
<code class="reqn">\textrm{E}(N_t^{\omega})</code> 
under the classical record model (i.e., of IID continuous RVs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>N.plot(
  X,
  weights = function(t) 1,
  record = c(FU = 1, FL = 1, BU = 1, BL = 1),
  backward = c("T", "t"),
  point.col = c(FU = "red", FL = "blue", BU = "red", BL = "blue"),
  point.shape = c(FU = 19, FL = 19, BU = 4, BL = 4),
  conf.int = TRUE,
  conf.level = 0.9,
  conf.aes = c("ribbon", "errorbar"),
  conf.col = "grey69"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="N.plot_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="N.plot_+3A_weights">weights</code></td>
<td>
<p>A function indicating the weight given to the different 
records according to their position in the series,
e.g., if <code>function(t) t-1</code> then <code class="reqn">\omega_t = t-1</code>.</p>
</td></tr>
<tr><td><code id="N.plot_+3A_record">record</code></td>
<td>
<p>Logical vector. Vector with four elements indicating if 
forward upper, forward lower, backward upper and backward lower are going
to be shown, respectively. Logical values or 0,1 values are accepted.</p>
</td></tr>
<tr><td><code id="N.plot_+3A_backward">backward</code></td>
<td>
<p>A character string <code>"T"</code> or <code>"t"</code> indicating if 
the backward number of records shown are calculated up to time <code class="reqn">t</code> in 
the backward series <code class="reqn">\{X_T,\ldots,X_1\}</code> or in the series 
<code class="reqn">\{X_t,\ldots,X_1\}</code>. While the first option considers the evolution 
of a series of records observed up to time <code class="reqn">T</code>, the second considers 
that until each time <code class="reqn">t</code> the series has only been observed up to 
<code class="reqn">t</code>.</p>
</td></tr>
<tr><td><code id="N.plot_+3A_point.col">point.col</code>, <code id="N.plot_+3A_point.shape">point.shape</code></td>
<td>
<p>Vector with four elements indicating the colour
and shape of the points. Every one of the four elements represents forward
upper, forward lower, backward upper and backward lower, respectively.</p>
</td></tr>
<tr><td><code id="N.plot_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical. Indicates if the RIs are also shown.</p>
</td></tr>
<tr><td><code id="N.plot_+3A_conf.level">conf.level</code></td>
<td>
<p>(If <code>conf.int == TRUE</code>) Confidence level of the RIs.</p>
</td></tr>
<tr><td><code id="N.plot_+3A_conf.aes">conf.aes</code></td>
<td>
<p>(If <code>conf.int == TRUE</code>) A character string indicating 
the aesthetic to display for the RIs, <code>"ribbon"</code> (grey area) or 
<code>"errorbar"</code> (vertical lines).</p>
</td></tr>
<tr><td><code id="N.plot_+3A_conf.col">conf.col</code></td>
<td>
<p>Colour used to plot the expected value and (if 
<code>conf.int == TRUE</code>) RIs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot is associated to the test <code><a href="#topic+N.test">N.test</a></code>.
It calculates the sample means of the number of records in a set of
vectors up to every time <code class="reqn">t</code> (see <code><a href="#topic+Nmean.record">Nmean.record</a></code>). 
These sample means <code class="reqn">\bar N_{t}^\omega</code> are calculated from the sample of
<code class="reqn">M</code> values obtained from <code class="reqn">M</code> vectors, the columns of matrix 
<code>X</code>. Then, these values are plotted and compared with the expected 
values <code class="reqn">\textrm{E}(N_t^{\omega})</code> and their reference intervals (RIs), under
the hypothesis of the classical record model. The RIs of 
<code class="reqn">\bar N_{t}^\omega</code> uses the fact that, under the classical record 
model, the statistic is asymptotically Normal.
</p>
<p>The plot can show the four types of record at the same time (i.e., 
forward upper, forward lower, backward upper and backward lower).
In their interpretations one must be careful, for forward records 
each time <code class="reqn">t</code> corresponds to the same year of observation, but for 
the backward series, time <code class="reqn">t</code> corresponds to the year of observation
<code class="reqn">T-t+1</code> where <code class="reqn">T</code> is the total number of observations in every 
series. Two types of backward records can be considered (see argument
<code>backward</code>).
</p>
<p>More details of this plot are shown in Cebrián, Castillo-Mateo, Asín 
(2022).
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Cebrián AC, Castillo-Mateo J, Asín J (2022).
“Record Tests to Detect Non Stationarity in the Tails with an Application to Climate Change.”
<em>Stochastic Environmental Research and Risk Assessment</em>, <strong>36</strong>(2): 313-330. 
<a href="https://doi.org/10.1007/s00477-021-02122-w">doi:10.1007/s00477-021-02122-w</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+N.record">N.record</a></code>, <code><a href="#topic+N.test">N.test</a></code>, 
<code><a href="#topic+foster.test">foster.test</a></code>, <code><a href="#topic+foster.plot">foster.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot at Zaragoza, with linear weights and error bar as RIs aesthetic
N.plot(ZaragozaSeries, weights = function(t) t-1, conf.aes = "errorbar")

# Plot only upper records
N.plot(ZaragozaSeries, record = c(1, 0, 1, 0))

# Change point colour and shape
Zplot &lt;- N.plot(ZaragozaSeries, 
  point.col = c("red", "red", "blue", "blue"), 
  point.shape = c(19, 4, 19, 4))

## Not run: Load package ggplot2 to change the plot
#library("ggplot2")
## Remove legend
#Zplot + ggplot2::theme(legend.position = "none")
## Fancy axis
# Zplot + 
#   ggplot2::scale_x_continuous(name = "Year (forward)",
#     breaks = c(10, 30, 50, 70), 
#     labels=c("1960", "1980", "2000", "2020"), 
#     sec.axis = ggplot2::sec_axis(~ 2021 - ., name = "Year (backward)",
#                                  breaks = 1950 + c(10, 30, 50, 70))) +
#   ggplot2::theme(axis.title.x = ggplot2::element_text(colour = "red"), 
#     axis.text.x = ggplot2::element_text(colour = "red"),
#     axis.title.x.top = ggplot2::element_text(colour = "blue"), 
#     axis.text.x.top = ggplot2::element_text(colour = "blue"))
</code></pre>

<hr>
<h2 id='N.record'>Number of Records</h2><span id='topic+N.record'></span><span id='topic+Nmean.record'></span>

<h3>Description</h3>

<p>Returns the number of records up to time <code class="reqn">t</code> of the
values in a vector.
</p>
<p>If the argument <code>X</code> is a matrix, then each column is treated as a 
different vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>N.record(X, record = c("upper", "lower"), weak = FALSE)

Nmean.record(X, record = c("upper", "lower"), weak = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="N.record_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="N.record_+3A_record">record</code></td>
<td>
<p>A character string indicating the type of record to be 
calculated, &quot;upper&quot; or &quot;lower&quot;.</p>
</td></tr>
<tr><td><code id="N.record_+3A_weak">weak</code></td>
<td>
<p>Logical. If <code>TRUE</code>, weak records are also counted. Default
to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The record counting process <code class="reqn">\{N_1,\ldots,N_T\}</code> is defined by 
the number of records up to time <code class="reqn">t</code>, and can be expressed in terms of 
the record indicator random variables <code><a href="#topic+I.record">I.record</a></code> by
</p>
<p style="text-align: center;"><code class="reqn">N_t = I_1 + I_2 + \ldots + I_t.</code>
</p>

<p>If <code>X</code> is a matrix with <code class="reqn">M &gt; 1</code> columns, each column is treated
as a vector and <code>Nmean.record</code> calculates for each <code class="reqn">t</code>,
</p>
<p style="text-align: center;"><code class="reqn">\bar N_t = \frac{N_{t1}+ \ldots + N_{tM}}{M}.</code>
</p>

<p>In summary:
</p>
<p style="text-align: center;"><code class="reqn">\code{N.record}: \code{X} = \left(
                 \begin{array}{cccc} 
                   X_{1,1} &amp; X_{1,2} &amp; \cdots &amp; X_{1,M} \\ 
                   X_{2,1} &amp; X_{2,2} &amp; \cdots &amp; X_{2,M} \\ 
                   \vdots &amp; \vdots &amp;  &amp; \vdots \\ 
                   X_{T,1} &amp; X_{T,2} &amp; \cdots &amp; X_{T,M} \\ 
                 \end{array} \right) 
                 \longrightarrow
                 \left(
                 \begin{array}{cccc} 
                   N_{1,1} &amp; N_{1,2} &amp; \cdots &amp; N_{1,M} \\ 
                   N_{2,1} &amp; N_{2,2} &amp; \cdots &amp; N_{2,M} \\ 
                   \vdots &amp; \vdots &amp;  &amp; \vdots \\ 
                   N_{T,1} &amp; N_{T,2} &amp; \cdots &amp; N_{T,M} \\ 
                 \end{array} \right)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\code{Nmean.record}: \code{X} 
        \longrightarrow
        \big( \bar{N}_1, \bar{N}_2, \cdots, \bar{N}_T \big).</code>
</p>

<p>Number and mean number of records for both upper and lower records can be 
calculated.
</p>


<h3>Value</h3>

<p><code>N.record</code> returns a numeric matrix with the number of records 
up to each time (row) <code class="reqn">t</code> for a vector or each column in <code>X</code>. 
<code>Nmean.record</code> returns a numeric vector with the mean number of 
records in <code class="reqn">M</code> series (columns) up to each time (row) <code class="reqn">t</code>.
</p>


<h3>Note</h3>

<p>If <code>X</code> is a vector both functions return the same values, 
<code>N.record</code> as a matrix and <code>Nmean.record</code> as a vector.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Arnold BC, Balakrishnan N, Nagaraja HN (1998). 
<em>Records</em>. 
Wiley Series in Probability and Statistics. Wiley, New York.
<a href="https://doi.org/10.1002/9781118150412">doi:10.1002/9781118150412</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+I.record">I.record</a></code>, <code><a href="#topic+L.record">L.record</a></code>, 
<code><a href="#topic+p.record">p.record</a></code>, <code><a href="#topic+R.record">R.record</a></code>,
<code><a href="#topic+records">records</a></code>, <code><a href="#topic+S.record">S.record</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y1 &lt;- c( 1,  5,  3,  6,  6,  9,  2)
Y2 &lt;- c(10,  5,  3,  6,  6,  9,  2)
Y3 &lt;- c( 5,  7,  3,  6, 19,  2, 20)
Y  &lt;- cbind(Y1, Y2, Y3)

N.record(Y)
Nmean.record(Y)

N.record(ZaragozaSeries)
Nmean.record(ZaragozaSeries, record = 'l')

</code></pre>

<hr>
<h2 id='N.test'>Number of Records Test</h2><span id='topic+N.test'></span>

<h3>Description</h3>

<p>Performs tests based on the (weighted) number of records, 
<code class="reqn">N^\omega</code>. The hypothesis of the classical record model (i.e., of IID
continuous RVs) is tested against the alternative hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>N.test(
  X,
  weights = function(t) 1,
  record = c("upper", "lower"),
  distribution = c("normal", "t", "poisson-binomial"),
  alternative = c("greater", "less"),
  correct = TRUE,
  method = c("mixed", "dft", "butler"),
  permutation.test = FALSE,
  simulate.p.value = FALSE,
  B = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="N.test_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="N.test_+3A_weights">weights</code></td>
<td>
<p>A function indicating the weight given to the different 
records according to their position in the series,
e.g., if <code>function(t) t - 1</code> then <code class="reqn">\omega_t = t - 1</code>.</p>
</td></tr>
<tr><td><code id="N.test_+3A_record">record</code></td>
<td>
<p>A character string indicating the type of record to be 
calculated, <code>"upper"</code> or <code>"lower"</code>.</p>
</td></tr>
<tr><td><code id="N.test_+3A_distribution">distribution</code></td>
<td>
<p>A character string indicating the asymptotic 
distribution of the statistic, <code>"normal"</code> distribution, Student's
<code>"t"</code>-distribution or exact <code>"poisson-binomial"</code> distribution.</p>
</td></tr>
<tr><td><code id="N.test_+3A_alternative">alternative</code></td>
<td>
<p>A character string indicating the type of alternative 
hypothesis, <code>"greater"</code> number of records or <code>"less"</code> number of
records.</p>
</td></tr>
<tr><td><code id="N.test_+3A_correct">correct</code></td>
<td>
<p>Logical. Indicates, whether a continuity correction
should be done; defaults to <code>TRUE</code>. No correction is done if    
<code>permutation.test = TRUE</code>, <code>simulate.p.value = TRUE</code> or     
<code>distribution = "poisson-binomial"</code>.</p>
</td></tr>
<tr><td><code id="N.test_+3A_method">method</code></td>
<td>
<p>(If <code>distribution = "poisson-binomial"</code>.) A character 
string that indicates the method by which the cdf
of the Poisson binomial distribution is calculated and therefore the 
p-value. <code>"mixed"</code> is the preferred (and default) method, it is a 
more efficient combination of the later algorithms. <code>"dft"</code> uses the 
discrete Fourier transform which algorithm is given in Hong (2013). 
<code>"butler"</code> use the algorithm given by Butler and Stephens (2016).</p>
</td></tr>
<tr><td><code id="N.test_+3A_permutation.test">permutation.test</code></td>
<td>
<p>Logical. Indicates whether to compute p-values by
permutation simulation (Castillo-Mateo et al. 2023). It does not require 
that the columns of <code>X</code> be independent. If <code>TRUE</code> and 
<code>simulate.p.value = TRUE</code>, permutations take precedence and 
permutations are performed. No simulation is done if 
<code>distribution = "poisson-binomial"</code>.</p>
</td></tr>
<tr><td><code id="N.test_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>Logical. Indicates whether to compute p-values by
Monte Carlo simulation. If <code>permutation.test = TRUE</code>, permutations    
take precedence and permutations are performed. No simulation is done if     
<code>distribution = "poisson-binomial"</code>.</p>
</td></tr>
<tr><td><code id="N.test_+3A_b">B</code></td>
<td>
<p>If <code>permutation.test = TRUE</code> or <code>simulate.p.value = TRUE</code>,
an integer specifying the number of replicates used in the permutation or    
Monte Carlo estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis is that the data come from a population with 
independent and identically distributed continuous realisations. The 
one-sided alternative hypothesis is that the (weighted) number of records
is greater (or less) than under the null hypothesis. The 
(weighted)-number-of-records statistic is calculated according to:
</p>
<p style="text-align: center;"><code class="reqn">N^\omega = \sum_{m=1}^M \sum_{t=1}^T \omega_t I_{tm},</code>
</p>
 
<p>where <code class="reqn">\omega_t</code> are weights given to the different records
according to their position in the series and <code class="reqn">I_{tm}</code> are the record
indicators (see <code><a href="#topic+I.record">I.record</a></code>).
</p>
<p>The statistic <code class="reqn">N^\omega</code> is exact Poisson binomial distributed
when the <code class="reqn">\omega_t</code>'s only take values in <code class="reqn">\{0,1\}</code>. In any case,
it is also approximately normally distributed, with
</p>
<p style="text-align: center;"><code class="reqn">Z = \frac{N^\omega - \mu}{\sigma},</code>
</p>

<p>where its mean and variance are
</p>
<p style="text-align: center;"><code class="reqn">\mu = M \sum_{t=1}^T \omega_t \frac{1}{t},</code>
</p>
 
<p style="text-align: center;"><code class="reqn">\sigma^2 = M \sum_{t=2}^T \omega_t^2 \frac{1}{t} \left(1-\frac{1}{t}\right).</code>
</p>
 
<p>If <code>correct = TRUE</code>, then a continuity correction will be employed:
</p>
<p style="text-align: center;"><code class="reqn">Z = \frac{N^\omega \pm 0.5 - \mu}{\sigma},</code>
</p>

<p>with &ldquo;<code class="reqn">-</code>&rdquo; if the alternative is greater and &ldquo;<code class="reqn">+</code>&rdquo; if the 
alternative is less.
</p>
<p>When <code class="reqn">M&gt;1</code>, the expression of the variance under the null hypothesis
can be substituted by the sample variance in the <code class="reqn">M</code> series, 
<code class="reqn">\hat{\sigma}^2</code>. In this case, the statistic <code class="reqn">N_{S}^\omega</code>
is asymptotically <code class="reqn">t</code> distributed, which is a more robust alternative
against serial correlation.
</p>
<p>If <code>permutation.test = TRUE</code>, the p-value is estimated by permutation	
simulations. This is the only method of calculating p-values that does not	
require that the columns of <code>X</code> be independent.	
</p>
<p>If <code>simulate.p.value = TRUE</code>, the p-value is estimated by Monte Carlo
simulations.
</p>
<p>The size of the tests is adequate for any values of <code class="reqn">T</code> and <code class="reqn">M</code>.
Some comments and a power study are given by Cebrián, Castillo-Mateo and
Asín (2022).
</p>


<h3>Value</h3>

<p>A <code>"htest"</code> object with elements:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>Value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>(If <code>distribution = "t"</code>.) Degrees of freedom of
the <code class="reqn">t</code> statistic (equal to <code class="reqn">M-1</code>).</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>The alternative hypothesis.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>(If <code>distribution = "normal"</code>) A vector with the
value of <code class="reqn">N^\omega</code>, <code class="reqn">\mu</code> and <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string indicating the type of test performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Butler K, Stephens MA (2017).
“The Distribution of a Sum of Independent Binomial Random Variables.”
<em>Methodology and Computing in Applied Probability</em>, <strong>19</strong>(2), 557-571.
<a href="https://doi.org/10.1007/s11009-016-9533-4">doi:10.1007/s11009-016-9533-4</a>.
</p>
<p>Castillo-Mateo J, Cebrián AC, Asín J (2023).
“Statistical Analysis of Extreme and Record-Breaking Daily Maximum Temperatures in Peninsular Spain during 1960&ndash;2021.”
<em>Atmospheric Research</em>, <strong>293</strong>, 106934.
<a href="https://doi.org/10.1016/j.atmosres.2023.106934">doi:10.1016/j.atmosres.2023.106934</a>.
</p>
<p>Cebrián AC, Castillo-Mateo J, Asín J (2022).
“Record Tests to Detect Non Stationarity in the Tails with an Application to Climate Change.”
<em>Stochastic Environmental Research and Risk Assessment</em>, <strong>36</strong>(2): 313-330. 
<a href="https://doi.org/10.1007/s00477-021-02122-w">doi:10.1007/s00477-021-02122-w</a>.
</p>
<p>Hong Y (2013). 
“On Computing the Distribution Function for the Poisson Binomial Distribution.”
<em>Computational Statistics &amp; Data Analysis</em>, <strong>59</strong>(1), 41-51.
<a href="https://doi.org/10.1016/j.csda.2012.10.006">doi:10.1016/j.csda.2012.10.006</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+N.record">N.record</a></code>, <code><a href="#topic+N.plot">N.plot</a></code>, 
<code><a href="#topic+foster.test">foster.test</a></code>, <code><a href="#topic+foster.plot">foster.plot</a></code>,
<code><a href="#topic+brown.method">brown.method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Forward Upper records
N.test(ZaragozaSeries)
# Forward Lower records
N.test(ZaragozaSeries, record = "lower", alternative = "less")
# Forward Upper records
N.test(series_rev(ZaragozaSeries), alternative = "less")
# Forward Upper records
N.test(series_rev(ZaragozaSeries), record = "lower")

# Exact test
N.test(ZaragozaSeries, distribution = "poisson-binom")
# Exact test for records in the last decade
N.test(ZaragozaSeries, weights = function(t) ifelse(t &lt; 61, 0, 1), distribution = "poisson-binom")
# Linear weights for a more powerful test (without continuity correction)
N.test(ZaragozaSeries, weights = function(t) t - 1, correct = FALSE)

</code></pre>

<hr>
<h2 id='Olympic_records_200m'>200-Meter Olympic Records from 1900 to 2020</h2><span id='topic+Olympic_records_200m'></span>

<h3>Description</h3>

<p>A data set containing the record times and record values of the
200-meter competition at the Olympic games, from 1900 to 2020.
The variables are the following:
</p>

<ul>
<li><p> year  : Year of the record time
</p>
</li>
<li><p> time  : Record time
</p>
</li>
<li><p> value : Record value in seconds
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(Olympic_records_200m)
</code></pre>


<h3>Format</h3>

<p>A data frame with 12 rows and 3 variables.
</p>


<h3>Note</h3>

<p>In this data set, the interest lies in the lower records. Although 
the Olympic Games are held every 4 years, not all of these occasions have
been held, so only the games that have taken place are considered in the 
definition of time.
</p>


<h3>Source</h3>

<p><a href="https://olympics.com/en/">https://olympics.com/en/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+series_record">series_record</a></code>
</p>

<hr>
<h2 id='p.chisq.test'>Pearson's Chi-Square Test for Probabilities of Record</h2><span id='topic+p.chisq.test'></span>

<h3>Description</h3>

<p>This function performs a chi-square goodness-of-fit test
based on the record probabiliteis <code class="reqn">p_t</code> to study the hypothesis
of the classical record model (i.e., of IID continuous RVs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.chisq.test(
  X,
  record = c("upper", "lower"),
  simulate.p.value = FALSE,
  B = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p.chisq.test_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="p.chisq.test_+3A_record">record</code></td>
<td>
<p>A character string indicating the type of record to be 
calculated, &quot;upper&quot; or &quot;lower&quot;.</p>
</td></tr>
<tr><td><code id="p.chisq.test_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>Logical. Indicates whether to compute p-values by
Monte Carlo simulation. It is recommended if the function returns a 
warning (see Details).</p>
</td></tr>
<tr><td><code id="p.chisq.test_+3A_b">B</code></td>
<td>
<p>If <code>simulate.p.value = TRUE</code>, an integer specifying the 
number of replicates used in the Monte Carlo estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis of this chi-square test is that in every vector 
(columns of the matrix <code>X</code>), the probability of record at 
time <code class="reqn">t</code> is <code class="reqn">1/t</code> as in the classical record model, 
and the alternative that the probabilities are not equal to those values. 
First, the chi-square goodness-of-fit statistics to study the  null 
hypothesis <code class="reqn">H_0:\,p_t = 1/t</code> are calculated for each time 
<code class="reqn">t=2,\ldots,T</code>, where the observed value is the number of records at 
time <code class="reqn">t</code> in the <code class="reqn">M</code> vectors and the expected value under the null
is <code class="reqn">M / t</code>. The test statistic is the sum of the previous <code class="reqn">T-1</code> 
statistics and its distribution under the null 
is approximately <code class="reqn">\chi^2_{T-1}</code>.
</p>
<p>The chi-square approximation may not be valid with low <code class="reqn">M</code>, since it
requires expected values <code class="reqn">&gt; 5</code> or up to <code class="reqn">20\%</code> of the expected 
values are between 1 and 5. If this condition is not satisfied, a warning 
is displayed. In order to avoid this problem, a <code>simulate.p.value</code>
can be made by means of Monte Carlo simulations.
</p>


<h3>Value</h3>

<p>A <code>"htest"</code> object  with elements:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>Value of the chi-squared statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string indicating the type of test performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Benestad RE (2003). 
“How Often Can We Expect a Record Event?” 
<em>Climate Research</em>, <strong>25</strong>(1), 3-13.
<a href="https://doi.org/10.3354/cr025003">doi:10.3354/cr025003</a>.
</p>
<p>Benestad RE (2004). 
“Record-Values, Nonstationarity Tests and Extreme Value Distributions.” 
<em>Global and Planetary Change</em>, <strong>44</strong>(1-4), 11–26. 
<a href="https://doi.org/10.1016/j.gloplacha.2004.06.002">doi:10.1016/j.gloplacha.2004.06.002</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+global.test">global.test</a></code>, <code><a href="#topic+score.test">score.test</a></code>,
<code><a href="#topic+p.record">p.record</a></code>, <code><a href="#topic+p.regression.test">p.regression.test</a></code>, 
<code><a href="#topic+lr.test">lr.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Warning, M = 76 small for the value of T = 70
p.chisq.test(ZaragozaSeries)
# Simulate p-value
p.chisq.test(ZaragozaSeries, simulate.p.value = TRUE, B = 10000)

</code></pre>

<hr>
<h2 id='p.plot'>Probabilities of Record Plots</h2><span id='topic+p.plot'></span>

<h3>Description</h3>

<p>This function builds a ggplot object to display different 
functions of the record probabilities at time <code class="reqn">t</code>, <code class="reqn">p_t</code>.
A graphical tool to study the hypothesis of the classical record model 
(i.e., of IID continuous RVs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.plot(
  X,
  plot = c("1", "2", "3"),
  record = c(FU = 1, FL = 1, BU = 1, BL = 1),
  point.col = c(FU = "red", FL = "blue", BU = "red", BL = "blue"),
  point.shape = c(FU = 19, FL = 19, BU = 4, BL = 4),
  conf.int = TRUE,
  conf.level = 0.9,
  conf.aes = c("ribbon", "errorbar"),
  conf.col = "grey69",
  smooth = TRUE,
  smooth.formula = y ~ x,
  smooth.method = stats::lm,
  smooth.weight = TRUE,
  smooth.linetype = c(FU = 1, FL = 1, BU = 2, BL = 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p.plot_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="p.plot_+3A_plot">plot</code></td>
<td>
<p>One of the values &quot;1&quot;, &quot;2&quot; or &quot;3&quot; (character or numeric class 
are both allowed). It determines the type of plot to be displayed (see 
Details).</p>
</td></tr>
<tr><td><code id="p.plot_+3A_record">record</code></td>
<td>
<p>Logical vector. Vector with four elements indicating if 
forward upper, forward lower, backward upper and backward lower are going
to be shown, respectively. Logical values or 0,1 values are accepted.</p>
</td></tr>
<tr><td><code id="p.plot_+3A_point.col">point.col</code>, <code id="p.plot_+3A_point.shape">point.shape</code></td>
<td>
<p>Vector with four elements indicating the colour
and shape of the points. Every one of the four elements represents forward
upper, forward lower, backward upper and backward lower, respectively.</p>
</td></tr>
<tr><td><code id="p.plot_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical. Indicates if the RIs are also shown.</p>
</td></tr>
<tr><td><code id="p.plot_+3A_conf.level">conf.level</code></td>
<td>
<p>(If <code>conf.int == TRUE</code>) Confidence level of the RIs.</p>
</td></tr>
<tr><td><code id="p.plot_+3A_conf.aes">conf.aes</code></td>
<td>
<p>(If <code>conf.int == TRUE</code>) A character string indicating 
the aesthetic to display for the RIs, <code>"ribbon"</code> (grey area) or 
<code>"errorbar"</code> (vertical lines).</p>
</td></tr>
<tr><td><code id="p.plot_+3A_conf.col">conf.col</code></td>
<td>
<p>Colour used to plot the expected value and (if 
<code>conf.int == TRUE</code>) RIs.</p>
</td></tr>
<tr><td><code id="p.plot_+3A_smooth">smooth</code></td>
<td>
<p>(If <code>plot = 1</code> or <code>3</code>) Logical. If <code>TRUE</code>, a
smoothing in the probabilities is also plotted.</p>
</td></tr>
<tr><td><code id="p.plot_+3A_smooth.formula">smooth.formula</code></td>
<td>
<p>(<code>smooth = TRUE</code>) <code><a href="stats.html#topic+formula">formula</a></code> to use 
in the smooth function, e.g., <code>y ~ x</code>, 
<code>y ~ poly(x, 2, raw = TRUE)</code>, <code>y ~ log(x)</code>.</p>
</td></tr>
<tr><td><code id="p.plot_+3A_smooth.method">smooth.method</code></td>
<td>
<p>(If <code>smooth = TRUE</code>) Smoothing method (function) 
to use, e.g., <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+loess">loess</a></code>.</p>
</td></tr>
<tr><td><code id="p.plot_+3A_smooth.weight">smooth.weight</code></td>
<td>
<p>(If <code>smooth = TRUE</code>) Logical. If <code>TRUE</code> 
(the default) the smoothing is estimated with weights.</p>
</td></tr>
<tr><td><code id="p.plot_+3A_smooth.linetype">smooth.linetype</code></td>
<td>
<p>(If <code>smooth = TRUE</code>) Vector with four elements 
indicating the line type of the smoothing. Every one of the four elements
represents forward upper, forward lower, backward upper and backward
lower, respectively.</p>
</td></tr>
<tr><td><code id="p.plot_+3A_...">...</code></td>
<td>
<p>Further arguments to pass through the smooth 
(see <code>ggplot2::geom_smooth</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three different types of plots which aim to analyse the hypothesis
of the classical record model using the record probabilities are 
implemented. Estimations of the record probabilities <code class="reqn">\hat p_t</code> used
in the plots are obtained as the proportion of records at time <code class="reqn">t</code>
in <code class="reqn">M</code> vectors (columns of matrix <code>X</code>) (see 
<code><a href="#topic+p.record">p.record</a></code>).
</p>
<p>Type 1 is the plot of the observed values <code class="reqn">t \hat p_t</code> versus time 
<code class="reqn">t</code> (see <code><a href="#topic+p.regression.test">p.regression.test</a></code> for its associated test and
details). 
The expected values under the classical record model are <code class="reqn">1</code> for any
value <code class="reqn">t</code>, so that a cloud of points around <code class="reqn">1</code> and with no trend
should be expected. The estimated values are plotted, together with 
binomial reference intervals (RIs). In addition, a smoothing function
can be fitted to the cloud of points.
</p>
<p>Type 2 is the plot of the estimated record probabilities <code class="reqn">p_t</code> versus
time <code class="reqn">t</code>. The expected probabilities under the classical record model, 
<code class="reqn">p_t=1/t</code>, are also plotted, together with binomial RIs. 
</p>
<p>Type 3 is the same plot but on a logarithmic scale, so that the
expected value is <code class="reqn">-\log(t)</code>. In this case, another smoothing 
function can be fitted to the cloud of points.
</p>
<p>Type 1 plot was proposed by Cebrián, Castillo-Mateo, Asín (2022), while 
type 2 and 3 appear in Benestad (2003, Figures 8 and 9, 2004, Figure 4).
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Benestad RE (2003). 
“How Often Can We Expect a Record Event?” 
<em>Climate Research</em>, <strong>25</strong>(1), 3-13.
<a href="https://doi.org/10.3354/cr025003">doi:10.3354/cr025003</a>.
</p>
<p>Benestad RE (2004). 
“Record-Values, Nonstationarity Tests and Extreme Value Distributions.” 
<em>Global and Planetary Change</em>, <strong>44</strong>(1-4), 11–26. 
<a href="https://doi.org/10.1016/j.gloplacha.2004.06.002">doi:10.1016/j.gloplacha.2004.06.002</a>.
</p>
<p>Cebrián AC, Castillo-Mateo J, Asín J (2022).
“Record Tests to Detect Non Stationarity in the Tails with an Application to Climate Change.”
<em>Stochastic Environmental Research and Risk Assessment</em>, <strong>36</strong>(2), 313-330. 
<a href="https://doi.org/10.1007/s00477-021-02122-w">doi:10.1007/s00477-021-02122-w</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p.regression.test">p.regression.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three plots available
p.plot(ZaragozaSeries, plot = 1)
p.plot(ZaragozaSeries, plot = 2)
p.plot(ZaragozaSeries, plot = 3)

# Posible fits (plot 1):
#fit a line
p.plot(ZaragozaSeries, record = c(1,0,0,0))
# fit a second order polynomial
p.plot(ZaragozaSeries, record = c(1,0,0,0), 
  smooth.formula = y ~ poly(x, degree = 2))
# force the line to pass by E(t*p_t) = 1 when t = 1, i.e., E(t*p_t) = 1 + beta_1 * (t-1)
p.plot(ZaragozaSeries, record = c(1,0,0,0), 
  smooth.formula = y ~ I(x-1) - 1 + offset(rep(1, length(x))))
# force the second order polynomial pass by E(t*p_t) = 1 when t = 1
p.plot(ZaragozaSeries, record = c(1,0,0,0), 
  smooth.formula = y ~ I(x-1) + I(x^2-1) - 1 + offset(rep(1, length(x))))
# fit a loess
p.plot(ZaragozaSeries, record = c(1,0,0,0), 
  smooth.method = stats::loess, span = 0.25)
</code></pre>

<hr>
<h2 id='p.record'>Probabilities of Record</h2><span id='topic+p.record'></span><span id='topic+S.record'></span>

<h3>Description</h3>

<p><code>S.record</code> and <code>p.record</code> return the sample number of 
records and mean number of records at each time <code class="reqn">t</code> in a set of <code class="reqn">M</code>
vectors (columns of <code>X</code>), respectively. In particular, 
<code>p.record</code> is the estimated record probability at each time <code class="reqn">t</code>.
</p>
<p>(For the introduccion to records see Details in <code><a href="#topic+I.record">I.record</a></code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.record(X, record = c("upper", "lower"), weak = FALSE)

S.record(X, record = c("upper", "lower"), weak = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p.record_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="p.record_+3A_record">record</code></td>
<td>
<p>A character string indicating the type of record to be 
calculated, &quot;upper&quot; or &quot;lower&quot;.</p>
</td></tr>
<tr><td><code id="p.record_+3A_weak">weak</code></td>
<td>
<p>Logical. If <code>TRUE</code>, weak records are also counted. Default
to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a matrix formed by <code class="reqn">M</code> vectors (columns), measured at 
<code class="reqn">T</code> times (rows), <code>M.record</code> calculates the number of records in 
the <code class="reqn">M</code> vectors at each observed time <code class="reqn">t</code>, <code class="reqn">S_t</code>.
</p>
<p>The function <code>p.record</code> is equivalent, but calculates the proportion 
of records at each time <code class="reqn">t</code>, that is the ratio:
</p>
<p style="text-align: center;"><code class="reqn">\hat p_t = \frac{S_t}{M} = \frac{I_{t,1} + \ldots + I_{t,M}}{M},</code>
</p>

<p>this proportion is an estimation of the probability of record at that time.
</p>
<p>Following the notation in <code><a href="#topic+I.record">I.record</a></code>, in summary:
</p>
<p style="text-align: center;"><code class="reqn">\code{X} = \left(
                 \begin{array}{cccc} 
                   X_{1,1} &amp; X_{1,2} &amp; \cdots &amp; X_{1,M} \\ 
                   X_{2,1} &amp; X_{2,2} &amp; \cdots &amp; X_{2,M} \\ 
                   \vdots &amp; \vdots &amp;  &amp; \vdots \\ 
                   X_{T,1} &amp; X_{T,2} &amp; \cdots &amp; X_{T,M} \\ 
                 \end{array} \right) 
                 \begin{array}{lc} 
                 \stackrel{\code{S.record}}{\longrightarrow} &amp;
                 \Big( S_1, S_2, \cdots, S_T \Big) \\ \\ 
                 \stackrel{\code{p.record}}{\longrightarrow} &amp;
                 \Big( \hat p_1, \hat p_2, \cdots, \hat p_T \Big) \\
                 \end{array}</code>
</p>

<p>Summaries for both upper and lower records can be calculated.
</p>


<h3>Value</h3>

<p>A vector with the number (or proportion in the case of 
<code>p.record</code>) of records at each time <code class="reqn">t</code> (row).
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Cebrián AC, Castillo-Mateo J, Asín J (2022).
“Record Tests to Detect Non Stationarity in the Tails with an Application to Climate Change.”
<em>Stochastic Environmental Research and Risk Assessment</em>, <strong>36</strong>(2), 313-330. 
<a href="https://doi.org/10.1007/s00477-021-02122-w">doi:10.1007/s00477-021-02122-w</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+I.record">I.record</a></code>, <code><a href="#topic+L.record">L.record</a></code>, 
<code><a href="#topic+N.record">N.record</a></code>, <code><a href="#topic+Nmean.record">Nmean.record</a></code>, 
<code><a href="#topic+R.record">R.record</a></code>, <code><a href="#topic+records">records</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y1 &lt;- c( 1,  5,  3,  6,  6,  9,  2)
Y2 &lt;- c(10,  5,  3,  6,  6,  9,  2)
Y3 &lt;- c( 5,  7,  3,  6, 19,  2, 20)
Y  &lt;- cbind(Y1, Y2, Y3)

S.record(Y)
p.record(Y)

S.record(ZaragozaSeries)
p.record(ZaragozaSeries, record = "l")

</code></pre>

<hr>
<h2 id='p.regression.test'>Probabilities of Record Regression Test</h2><span id='topic+p.regression.test'></span>

<h3>Description</h3>

<p>This function performs a linear hypothesis test based on a
regression for the record probabilities <code class="reqn">p_t</code> to study the hypothesis
of the classical record model (i.e., of IID continuous RVs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.regression.test(
  X,
  record = c("upper", "lower"),
  formula = y ~ x,
  simulate.p.value = FALSE,
  B = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p.regression.test_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="p.regression.test_+3A_record">record</code></td>
<td>
<p>A character string indicating the type of records to be 
calculated, &quot;upper&quot; or &quot;lower&quot;.</p>
</td></tr>
<tr><td><code id="p.regression.test_+3A_formula">formula</code></td>
<td>
<p>&quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; to use in <code><a href="stats.html#topic+lm">lm</a></code> function, 
e.g., <code>y ~ x</code>, <code>y ~ poly(x, 2, raw = TRUE)</code>, <code>y ~ log(x)</code>.
By default <code>formula = y ~ x</code>. See Note for a caveat.</p>
</td></tr>
<tr><td><code id="p.regression.test_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>Logical. Indicates whether to compute p-values by
Monte Carlo simulation. It is recommended if the number of columns of
<code>X</code> (i.e., the number of series) is equal or lower than 10, since 
for low values the size of the test is not fulfilled.</p>
</td></tr>
<tr><td><code id="p.regression.test_+3A_b">B</code></td>
<td>
<p>If <code>simulate.p.value = TRUE</code>, an integer specifying the 
number of replicates used in the Monte Carlo estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis is that the data come from a population with 
independent and identically distributed realisations. This implies that
in all the vectors (columns in matrix <code>X</code>), the sample probability 
of record at time <code class="reqn">t</code> (<code><a href="#topic+p.record">p.record</a></code>) is <code class="reqn">1/t</code>, so that
</p>
<p style="text-align: center;"><code class="reqn">t \, \textrm{E}(\hat p_t) = 1.</code>
</p>
 
<p>Then, 
</p>
<p style="text-align: center;"><code class="reqn">H_0:\,p_t = 1/t, \, t=2, ..., T \iff H_0:\,\beta_0 = 1, \, \beta_1 = 0,</code>
</p>
 
<p>where <code class="reqn">\beta_0</code> and <code class="reqn">\beta_1</code> are the coefficients of the 
regression model 
</p>
<p style="text-align: center;"><code class="reqn">t \, \textrm{E}(\hat p_t) = \beta_0 + \beta_1 t.</code>
</p>
 
<p>The  model has to be estimated by weighted least squares since the 
response is heteroskedastic.
</p>
<p>Other models can be considered with the <code>formula</code> argument. 
However, for the test to be correct, the model must leave the intercept 
free or fix it to 1 (see Examples for possible models).
</p>
<p>The <code class="reqn">F</code> statistic is computed for carrying out a
comparison between the restricted model under the null hypothesis and
the more general model (e.g., the alterantive hypothesis where 
<code class="reqn">t \, \textrm{E}(\hat p_t)</code> is a linear function of time <code class="reqn">t</code>). 
This alternative hypothesis may be reasonable in many real examples, 
but not always.
</p>
<p>If the sample size (i.e., the number of series or columns of <code>X</code>)
is lower than 8 or 12 the <code>simulate.p.value</code> option is recommended.
</p>


<h3>Value</h3>

<p>A <code>"htest"</code> object with elements:
</p>
<table role = "presentation">
<tr><td><code>null.value</code></td>
<td>
<p>Value of the coefficients under the null hypothesis
when more than one coefficient is fitted.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Character string indicating the type of alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string indicating the type of test performed.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Value of the fitted coefficients.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the name of the data.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Value of the <code class="reqn">F</code> statistic.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Degrees of freedom of the <code class="reqn">F</code> statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>IMPORTANT: In <code>formula</code> the intercept has to be free or fixed
to 1 so that the test is correct.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Castillo-Mateo J, Cebrián AC, Asín J (2023).
“<strong>RecordTest</strong>: An <code>R</code> Package to Analyze Non-Stationarity in the Extremes Based on Record-Breaking Events.”
<em>Journal of Statistical Software</em>, <strong>106</strong>(5), 1-28. 
<a href="https://doi.org/10.18637/jss.v106.i05">doi:10.18637/jss.v106.i05</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p.chisq.test">p.chisq.test</a></code>, <code><a href="#topic+p.plot">p.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple test for upper records (p-value = 0.01202)
p.regression.test(ZaragozaSeries)
# Simple test for lower records (p-value = 0.006175)
p.regression.test(ZaragozaSeries, record = "lower")

# Fit a 2nd term polynomial for upper records (p-value = 0.0003933)
p.regression.test(ZaragozaSeries, formula = y ~ I(x^2))
# Fit a 2nd term polynomial for lower records (p-value = 0.005108)
p.regression.test(ZaragozaSeries, record = "lower", formula = y ~ I(x^2))

# Fix the intercept to 1 for upper records (p-value = 0.01416)
p.regression.test(ZaragozaSeries, formula = y ~ I(x-1) - 1 + offset(rep(1, length(x))))
# Fix the intercept to 1 for lower records (p-value = 0.00138)
p.regression.test(ZaragozaSeries, record = "lower", 
  formula = y ~ I(x-1) - 1 + offset(rep(1, length(x))))

# Simulate p-value when the number of series is small
TxZ &lt;- apply(series_split(TX_Zaragoza$TX), 1, max, na.rm = TRUE)
p.regression.test(TxZ, simulate.p.value = TRUE)
</code></pre>

<hr>
<h2 id='Poisson-Binomial'>The Poisson Binomial Distribution</h2><span id='topic+Poisson-Binomial'></span><span id='topic+dpoisbinom'></span><span id='topic+qpoisbinom'></span><span id='topic+ppoisbinom'></span><span id='topic+rpoisbinom'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the Poisson binomial distribution with parameters 
<code>size</code> and <code>prob</code>.
</p>
<p>This is conventionally interpreted as the number of successes in 
<code>size * length(prob)</code> trials with success probabilities <code>prob</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpoisbinom(x, size = 1, prob, log = FALSE)

ppoisbinom(q, size = 1, prob, lower.tail = TRUE, log.p = FALSE)

qpoisbinom(p, size = 1, prob, lower.tail = TRUE, log.p = FALSE)

rpoisbinom(n, size = 1, prob)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Poisson-Binomial_+3A_x">x</code>, <code id="Poisson-Binomial_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="Poisson-Binomial_+3A_size">size</code></td>
<td>
<p>The Poisson binomial distribution has <code>size</code> times the
vector of probabilities <code>prob</code>.</p>
</td></tr>
<tr><td><code id="Poisson-Binomial_+3A_prob">prob</code></td>
<td>
<p>Vector with the probabilities of success on each trial.</p>
</td></tr>
<tr><td><code id="Poisson-Binomial_+3A_log">log</code>, <code id="Poisson-Binomial_+3A_log.p">log.p</code></td>
<td>
<p>Logical. If <code>TRUE</code>, probabilities <code class="reqn">p</code> are given as 
<code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="Poisson-Binomial_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), probabilities are
<code class="reqn">P(X \le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="Poisson-Binomial_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="Poisson-Binomial_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Poisson binomial distribution with <code>size = 1</code> and 
<code>prob</code> <code class="reqn">= (p_1,p_2,\ldots,p_n)</code> has density
</p>
<p style="text-align: center;"><code class="reqn">p(x) = \sum_{A \in F_x} \prod_{i \in A} p_i \prod_{j \in A^c} (1-p_j)</code>
</p>

<p>for <code class="reqn">x=0,1,\ldots,n</code>; where <code class="reqn">F_x</code> is the set of all subsets of 
<code class="reqn">x</code> integers that can be selected from <code class="reqn">\{1,2,\ldots,n\}</code>.
</p>
<p><code class="reqn">p(x)</code> is computed using Hong (2013) algorithm, see the reference 
below. 
</p>
<p>The quantile is defined as the smallest value <code class="reqn">x</code> such that 
<code class="reqn">F(x) \ge p</code>, where <code class="reqn">F</code> is the cumulative distribution function.
</p>


<h3>Value</h3>

<p><code>dpoisbinom</code> gives the density, <code>ppoisbinom</code> gives the 
distribution function, <code>qpoisbinom</code> gives the quantile function
and <code>rpoisbinom</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>x</code>, <code>q</code>, <code>p</code>
or <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Hong Y (2013). 
“On Computing the Distribution Function for the Poisson Binomial Distribution.”
<em>Computational Statistics &amp; Data Analysis</em>, <strong>59</strong>(1), 41-51.
<a href="https://doi.org/10.1016/j.csda.2012.10.006">doi:10.1016/j.csda.2012.10.006</a>.
</p>

<hr>
<h2 id='R.record'>Record Values</h2><span id='topic+R.record'></span>

<h3>Description</h3>

<p>Returns the record values of the values in a vector.
A record value is the magnitude of a record observation. 
</p>
<p>If the argument <code>X</code> is a matrix, then each column is treated as a 
different vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R.record(X, record = c("upper", "lower"), weak = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R.record_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="R.record_+3A_record">record</code></td>
<td>
<p>A character string indicating the type of record to be 
calculated, &quot;upper&quot; or &quot;lower&quot;.</p>
</td></tr>
<tr><td><code id="R.record_+3A_weak">weak</code></td>
<td>
<p>Logical. If <code>TRUE</code>, weak records are also counted. Default
to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence of record values <code class="reqn">\{R_1,\ldots,R_I\}</code> can be 
expressed in terms of the record times 
<code><a href="#topic+L.record">L.record</a></code> by
</p>
<p style="text-align: center;"><code class="reqn">R_i = X_{L_i}.</code>
</p>

<p>Record values can be calculated for both upper and lower records.
</p>


<h3>Value</h3>

<p>If <code>X</code> is a vector, the function returns a list containing the 
vector of record values. If <code>X</code> is a matrix, the function returns a 
list where each element is a vector indicating the record values of the 
corresponding <code>X</code> column.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Arnold BC, Balakrishnan N, Nagaraja HN (1998). 
<em>Records</em>. 
Wiley Series in Probability and Statistics. Wiley, New York.
<a href="https://doi.org/10.1002/9781118150412">doi:10.1002/9781118150412</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+I.record">I.record</a></code>, <code><a href="#topic+L.record">L.record</a></code>, 
<code><a href="#topic+N.record">N.record</a></code>, <code><a href="#topic+Nmean.record">Nmean.record</a></code>, 
<code><a href="#topic+p.record">p.record</a></code>, <code><a href="#topic+R.record">R.record</a></code>, 
<code><a href="#topic+records">records</a></code>, <code><a href="#topic+S.record">S.record</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y1 &lt;- c( 1,  5,  3,  6,  6,  9,  2)
Y2 &lt;- c(10,  5,  3,  6,  6,  9,  2)
Y3 &lt;- c( 5,  7,  3,  6, 19,  2, 20)
Y  &lt;- cbind(Y1, Y2, Y3)

R.record(Y1)
R.record(Y)

</code></pre>

<hr>
<h2 id='rcrm'>The Classical Record Model</h2><span id='topic+rcrm'></span>

<h3>Description</h3>

<p>Random generation for the classical record model, i.e.,
sequences of independent and identically distributed (IID) continuous
random variables (RVs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcrm(Trows = 50, Mcols = 100, rdist = stats::rnorm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcrm_+3A_trows">Trows</code>, <code id="rcrm_+3A_mcols">Mcols</code></td>
<td>
<p>Integers indicating the number of rows and columns of the
returned matrix, i.e., the length and number of series for the record 
analysis.</p>
</td></tr>
<tr><td><code id="rcrm_+3A_rdist">rdist</code></td>
<td>
<p>A function that simulates continuous random variables, 
e.g., <code><a href="stats.html#topic+runif">runif</a></code> (fastest in <code>stats</code> package), 
<code><a href="stats.html#topic+rnorm">rnorm</a></code> or <code><a href="stats.html#topic+rexp">rexp</a></code>.</p>
</td></tr>
<tr><td><code id="rcrm_+3A_...">...</code></td>
<td>
<p>Further arguments to introduce in the <code>rdist</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of draws of IID continuous RVs with common distribution 
<code>rdist</code>.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Arnold BC, Balakrishnan N, Nagaraja HN (1998). 
<em>Records</em>. 
Wiley Series in Probability and Statistics. Wiley, New York.
<a href="https://doi.org/10.1002/9781118150412">doi:10.1002/9781118150412</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L.record">L.record</a></code>, <code><a href="#topic+S.record">S.record</a></code>, 
<code><a href="#topic+N.record">N.record</a></code>, <code><a href="#topic+Nmean.record">Nmean.record</a></code>, 
<code><a href="#topic+p.record">p.record</a></code>, <code><a href="#topic+records">records</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># By default, draw a sample of 100 series of length 50 
# with observations coming from a standard normal distribution 
X &lt;- rcrm()
# Compute its record indicators
I &lt;- I.record(X)
# Implement some tests
N.test(X, distribution = "poisson-binomial")
foster.test(X, weights = function(t) t-1, statistic = "D")

</code></pre>

<hr>
<h2 id='records'>Record Values and Record Times</h2><span id='topic+records'></span>

<h3>Description</h3>

<p>This function identifies (and plots if argument 
<code>plot = TRUE</code>) the record values (<code class="reqn">R_i</code>), and the record times 
(<code class="reqn">L_i</code>) in a vector, for all upper and lower records in forward and
backward directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>records(
  X,
  plot = TRUE,
  direction = c("forward", "backward", "both"),
  variable,
  type = c("lines", "points"),
  col = c(T = "black", U = "salmon", L = "skyblue", O = "black"),
  alpha = c(T = 1, U = 1, L = 1, O = 1),
  shape = c(F = 19, B = 4, O = 19),
  linetype = c(F = 1, B = 2)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="records_+3A_x">X</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="records_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default) the records are plotted.</p>
</td></tr>
<tr><td><code id="records_+3A_direction">direction</code></td>
<td>
<p>A character string indicating the type of record to show 
in the plot if <code>plot == TRUE</code>: <code>"forward"</code>, <code>"backward"</code> or
<code>"both"</code> (see Details).</p>
</td></tr>
<tr><td><code id="records_+3A_variable">variable</code></td>
<td>
<p>Optional. A vector, containing other variable related 
to <code>X</code> and measured at the same times. Only used if 
<code>plot = FALSE</code>.</p>
</td></tr>
<tr><td><code id="records_+3A_type">type</code></td>
<td>
<p>Character string indicating if <code>X</code> is shown with 
<code>"lines"</code> or <code>"points"</code>.</p>
</td></tr>
<tr><td><code id="records_+3A_col">col</code>, <code id="records_+3A_alpha">alpha</code></td>
<td>
<p>Character and numeric vectors of length four, respectively.
These arguments represent respectively the colour and transparency of the
points or lines: trivial record, upper records, lower records and 
observations respectively. 
Vector names in the default are only indicative.</p>
</td></tr>
<tr><td><code id="records_+3A_shape">shape</code></td>
<td>
<p>If <code>type == "points"</code>. 
Integer vector of length 3 indicating the shape of the points
for forward records, backward records and observations.
Vector names in the default are only indicative.</p>
</td></tr>
<tr><td><code id="records_+3A_linetype">linetype</code></td>
<td>
<p>Integer vector of length 2 indicating the line type of the
step functions in the forward and backward records, respectively.
Vector names in the default are only indicative.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Customarily, the records in a time series <code class="reqn">(X_t)</code> observed in <code class="reqn">T</code> 
instances <code class="reqn">t = 1, 2, \ldots, T</code> can be obtained using chronological 
order. Besides, we could also compute the records in similar sequences of 
random variables if we consider reversed chronological order starting 
from the last observation, i.e., <code class="reqn">t' = T, \ldots, 2, 1</code>. The analysis 
of series with reversed order is customarily referred to as backward, as 
opposed to a forward analysis.
</p>


<h3>Value</h3>

<p>If <code>plot = TRUE</code> a ggplot object, otherwise a list with four 
data frames where the first column are the record times, the second the 
record values and, if <code>variable</code> is not null, the third column are 
their values at the record times, respectively for upper and lower records
in forward and backward series.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+I.record">I.record</a></code>, <code><a href="#topic+series_double">series_double</a></code>, 
<code><a href="#topic+series_rev">series_rev</a></code>, <code><a href="#topic+series_split">series_split</a></code>, 
<code><a href="#topic+series_uncor">series_uncor</a></code>, <code><a href="#topic+series_untie">series_untie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- c(5, 7, 3, 6, 19, 2, 20)
records(Y, plot = FALSE, variable = seq_along(Y))

# Show the whole series and its upper and lower records
records(TX_Zaragoza$TX)
# Compute tables for the whole series
TxZ.record &lt;- records(TX_Zaragoza$TX, plot = FALSE, variable = TX_Zaragoza$DATE)
TxZ.record
names(TxZ.record)
# To show the Forward Upper records
TxZ.record[[1]]
plot(TxZ.record[[1]]$Times, TxZ.record[[1]]$Values)

# Annual maximum daily maximum temperatures
TxZ &lt;- apply(series_split(TX_Zaragoza$TX), 1, max)
# Plot for the records in forward and backward directions
records(TxZ, direction = "both")
# Compute tables for the annual maximum 
records(TxZ, plot = FALSE, variable = 1951:2020)

</code></pre>

<hr>
<h2 id='score.test'>Score Test for the Likelihood of the Record Indicators</h2><span id='topic+score.test'></span>

<h3>Description</h3>

<p>This function performs score (or Lagrange multiplier) tests
for the likelihood of the record indicators <code class="reqn">I_t</code> to study the 
hypothesis of the classical record model (i.e., of IID continuous RVs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score.test(
  X,
  record = c("upper", "lower"),
  alternative = c("two.sided", "greater", "less"),
  probabilities = c("different", "equal"),
  simulate.p.value = FALSE,
  B = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.test_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="score.test_+3A_record">record</code></td>
<td>
<p>A character string indicating the type of record, 
&quot;upper&quot; or &quot;lower&quot;.</p>
</td></tr>
<tr><td><code id="score.test_+3A_alternative">alternative</code></td>
<td>
<p>A character indicating the alternative hypothesis 
(<code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>). 
Different statistics are used in the one-sided and two-sided alternatives
(see Details).</p>
</td></tr>
<tr><td><code id="score.test_+3A_probabilities">probabilities</code></td>
<td>
<p>A character indicating if the alternative hypothesis 
assume all series with <code>"equal"</code> or <code>"different"</code> probabilities
of record.</p>
</td></tr>
<tr><td><code id="score.test_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>Logical. Indicates whether to compute p-values by
Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="score.test_+3A_b">B</code></td>
<td>
<p>An integer specifying the number of replicates used in the Monte 
Carlo estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis of the score tests is that in every vector 
(columns of the matrix <code>X</code>), the probability of record at 
time <code class="reqn">t</code> is <code class="reqn">1/t</code> as in the classical record model, and 
the alternative depends on the <code>alternative</code> and <code>probabilities</code>
arguments. The probability at time <code class="reqn">t</code> is any value, but equal in the
<code class="reqn">M</code> series if <code>probabilities = "equal"</code>  or different in the 
<code class="reqn">M</code> series if <code>probabilities = "different"</code>. The alternative 
hypothesis is more specific in the first case than in the second one.
Furthermore, the <code>"two.sided"</code> <code>alternative</code> is tested with 
the usual Lagrange multiplier statistic, while the one-sided 
<code>alternatives</code> use specific statistics based on scores. 
(See Cebrián, Castillo-Mateo and Asín (2022) for details on these tests.)
</p>
<p>If <code>alternative = "two.sided" &amp; probabilities = "equal"</code>, under the
null, the Lagrange multiplier statistic has an asymptotic <code class="reqn">\chi^2</code> 
distribution with <code class="reqn">T-1</code> degrees of freedom. It has been seen that for
the approximation to be adequate <code class="reqn">M</code> should be greater than <code class="reqn">T</code>. 
Otherwise, a <code>simulate.p.value</code> can be computed.
</p>
<p>If <code>alternative = "two.sided" &amp; probabilities = "different"</code>, the 
asymptotic behaviour of the Lagrange multiplier statistic is not 
fulfilled, but the Monte Carlo approach to simulate the p-value is 
applied.
</p>
<p>If <code>alternative</code> is one-sided and <code>probabilities = "equal"</code>,
the statistic of the test is
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{T} = \sum_{t=2}^T \frac{(t S_t-M)^2}{M(t-1)} I_{\{S_t &gt; M/t\}}.</code>
</p>

<p>The p-value of this test is estimated with Monte Carlo simulations,
since the compute the exact distribution of <code class="reqn">\mathcal{T}</code> is very 
expensive.   
</p>
<p>If <code>alternative</code> is one-sided and <code>probabilities = "different"</code>,
the statistic of the test is
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{S} = \frac{\sum_{t=2}^T t (t S_t - M) / (t - 1)}{\sqrt{M \sum_{t=2}^T t^2 / (t - 1)}},</code>
</p>

<p>which is asymptotically standard normal distributed in <code class="reqn">M</code>. It is 
equivalent to the statistic of the weighted number of records 
<code><a href="#topic+N.test">N.test</a></code> with weights <code class="reqn">\omega_t = t^2 / (t-1)</code>  
<code class="reqn">(t=2,\ldots,T)</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>"htest"</code>  with the following elements:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>Value of the  statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>Degrees of freedom of the approximate <code class="reqn">\chi^2</code> 
distribution.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string indicating the type of test.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the name of the data.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>A character string indicating the alternative
hypothesis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Cebrián AC, Castillo-Mateo J, Asín J (2022).
“Record Tests to Detect Non Stationarity in the Tails with an Application to Climate Change.”
<em>Stochastic Environmental Research and Risk Assessment</em>, <strong>36</strong>(2), 313-330. 
<a href="https://doi.org/10.1007/s00477-021-02122-w">doi:10.1007/s00477-021-02122-w</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lr.test">lr.test</a></code>, <code><a href="#topic+global.test">global.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(23)
# two-sided and different probabilities of record, always simulated the p-value
score.test(ZaragozaSeries, probabilities = "different")
# equal probabilities
score.test(ZaragozaSeries, probabilities = "equal")
# equal probabilities with simulated p-value
score.test(ZaragozaSeries, probabilities = "equal", simulate.p.value = TRUE)

# one-sided and different probabilities of record
score.test(ZaragozaSeries, alternative = "greater", probabilities = "different")
# different probabilities with simulated p-value
score.test(ZaragozaSeries, alternative = "greater", probabilities = "different", 
  simulate.p.value = TRUE)
# equal probabilities, always simulated the p-value
score.test(ZaragozaSeries, alternative = "greater", probabilities = "equal")
</code></pre>

<hr>
<h2 id='series_double'>Double the Number of Series</h2><span id='topic+series_double'></span>

<h3>Description</h3>

<p>This function changes the format of a matrix transforming a
<code class="reqn">T \times M</code> matrix in a 
<code class="reqn">\lfloor T/\code{k} \rfloor \times \code{k}\,M</code> matrix in the 
following way.
</p>
<p>First, the matrix is divided into <code>k</code> matrices 
<code class="reqn">\lfloor T/\code{k} \rfloor \times M</code>, containing the rows whose 
remainder of the division of the row number by <code>k</code> is 
<code class="reqn">1,2,\ldots,\code{k}-1,0</code>, respectively;
and secondly those matrices are <code>cbind</code>ed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series_double(X, k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="series_double_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="series_double_+3A_k">k</code></td>
<td>
<p>Integer <code class="reqn">&gt; 1</code>, times to increase the number of columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in the data preparation (or pre-processing) 
often required to apply the exploratory and inference tools based on 
theory of records within this package.
</p>
<p>Most of the record inference tools require a high number of independent 
series <code class="reqn">M</code> (number of columns) to be applied.
If <code class="reqn">M</code> is low and the time period of observation, <code class="reqn">T</code>, is high 
enough, the following procedure can be applied in order to multiply by
<code>k</code> the value <code class="reqn">M</code>.
The approach  consists of considering that the observations at two 
(or more) consecutive times, <code class="reqn">t</code> and <code class="reqn">t+1</code> (or <code class="reqn">t+\code{k}-1</code>),
are independent observations measured at the same time unit.
That means that we are doubling (or multiplying by <code>k</code>) the original 
time unit of the records, so that the length of the observation period 
will be <code class="reqn">\lfloor T/\code{k} \rfloor</code>.
This function rearranges the original data matrix into the new format.
</p>
<p>If the number of rows of the original matrix is not divisible by <code>k</code>,
the first <code>nrow(X) %% k</code> rows are deleted.
</p>


<h3>Value</h3>

<p>A <code class="reqn">\lfloor T/\code{k} \rfloor \times \code{k}\,M</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+series_record">series_record</a></code>, <code><a href="#topic+series_rev">series_rev</a></code>,
<code><a href="#topic+series_split">series_split</a></code>, <code><a href="#topic+series_ties">series_ties</a></code>
<code><a href="#topic+series_uncor">series_uncor</a></code>, <code><a href="#topic+series_untie">series_untie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>series_double(matrix(1:100, 10, 10))

series_double(ZaragozaSeries, k = 4)

</code></pre>

<hr>
<h2 id='series_record'>From Record Times to Time Series</h2><span id='topic+series_record'></span>

<h3>Description</h3>

<p>If only the record times are available (upper or lower, or 
both) and not the complete series, <code>series_record</code> builds a complete 
series with the same record occurrence as specified in the arguments. 
This function is useful to apply the plots and tests within
<code><a href="#topic+RecordTest-package">RecordTest-package</a></code> to a vector of record times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series_record(L_upper, R_upper, L_lower, R_lower, Trows = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="series_record_+3A_l_upper">L_upper</code>, <code id="series_record_+3A_l_lower">L_lower</code></td>
<td>
<p>A vector of (increasing) integers denoting the upper 
or/and lower record times.</p>
</td></tr>
<tr><td><code id="series_record_+3A_r_upper">R_upper</code>, <code id="series_record_+3A_r_lower">R_lower</code></td>
<td>
<p>(Optional) A vector of (increasing/decreasing)
values denoting the upper or/and lower record values.</p>
</td></tr>
<tr><td><code id="series_record_+3A_trows">Trows</code></td>
<td>
<p>Integer indicating the actual length of the series. If it is 
not specified, then the length of the series is assumed equal to the last
record occurrence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>Trows</code> with <code>L_upper</code> upper or/and 
<code>L_lower</code> lower record times and <code>R_upper</code> upper or/and 
<code>R_lower</code> lower record values.
</p>


<h3>Note</h3>

<p>Remember that the first observation in a series is always a record 
time.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+series_double">series_double</a></code>, <code><a href="#topic+series_rev">series_rev</a></code>, 
<code><a href="#topic+series_split">series_split</a></code>, <code><a href="#topic+series_ties">series_ties</a></code>,
<code><a href="#topic+series_uncor">series_uncor</a></code>, <code><a href="#topic+series_untie">series_untie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upper record times observed in a 100 length time series
L &lt;- c(1, 4, 14, 40, 45, 90)
X &lt;- series_record(L_upper = L, Trows = 100)

# now you can apply plots and tests for upper records to the X series
#N.plot(X)
#N_normal.test(X)

# if you also have lower record times
L_lower &lt;- c(1, 2, 12, 56, 57, 78, 91)
X &lt;- series_record(L_upper = L, L_lower = L_lower, Trows = 100)

# now you can apply plots and tests to the X series with both types of record times
#foster.plot(X, statistic = 'd')
#foster.test(X, statistic = 'd')

# apply to the 200-meter Olympic records from 1900 to 2020
or200m &lt;- series_record(L_lower = Olympic_records_200m$t, 
                        R_lower = Olympic_records_200m$value,
                        Trows = 27)
# some plots and tests                    
N.plot(or200m, record = c(0,1,0,0))                         
N.test(or200m, record = "lower", distribution = "poisson-binomial")
</code></pre>

<hr>
<h2 id='series_rev'>Reverse Elements by Columns</h2><span id='topic+series_rev'></span>

<h3>Description</h3>

<p>Result of applying <code><a href="base.html#topic+rev">rev</a></code> function by columns
to the matrix. This allows the study of the series backwards and not only 
forward.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series_rev(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="series_rev_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+series_double">series_double</a></code>, <code><a href="#topic+series_record">series_record</a></code>, 
<code><a href="#topic+series_split">series_split</a></code>, <code><a href="#topic+series_ties">series_ties</a></code>,
<code><a href="#topic+series_uncor">series_uncor</a></code>, <code><a href="#topic+series_untie">series_untie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>series_rev(matrix(1:100, 10, 10))

series_rev(ZaragozaSeries)

</code></pre>

<hr>
<h2 id='series_split'>Split Series</h2><span id='topic+series_split'></span>

<h3>Description</h3>

<p>The vector <code>X</code> of length <code class="reqn">T</code> is broken into 
<code>Mcols</code> blocks, each part containing <code class="reqn">T/\code{Mcols}</code> elements.
</p>
<p>If the vector <code>X</code> represents consecutive daily values in a year, then 
<code>Mcols = 365</code> is preferred. This function rearranges <code>X</code> into a 
matrix format, where each column is the vector of values at the same day 
of the year. For monthly data in a year, <code>Mcols = 12</code> should be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series_split(X, Mcols = 365)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="series_split_+3A_x">X</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="series_split_+3A_mcols">Mcols</code></td>
<td>
<p>An integer number, giving the number of columns in the 
final matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in the data preparation (or pre-processing) 
often required to apply the exploratory and inference tools based on 
theory of records within this package when the time series presents 
seasonality.
</p>
<p>This function transforms a vector into a matrix, applying the 
following procedure: the first row of the matrix is built of the first 
<code>Mcols</code> elements of the vector, the second row by the <code>Mcols</code> 
following elements, and so on.
The length of the vector must be a multiple of <code>Mcols</code> 
(see Note otherwise).
</p>
<p>In the case of a vector of daily values, <code>Mcols</code> is usually 365,
so that the first column corresponds to all the values observed at the  
1st of January, the second to the 2nd of January, etc.
</p>
<p>If <code class="reqn">X_{t,m}</code> represents the value in day <code class="reqn">m</code> of year <code class="reqn">t</code>, then if
</p>
<p style="text-align: center;"><code class="reqn">\code{X} = (X_{1,1},X_{1,2},\ldots,X_{1,365},X_{2,1},X_{2,2},\ldots,X_{T,365}),</code>
</p>

<p>applying <code>series_split</code> to <code>X</code> returns the following matrix:
</p>
<p style="text-align: center;"><code class="reqn">
  \left( \begin{array}{cccc}
       X_{1,1} &amp; X_{1,2} &amp; \cdots &amp; X_{1,365} \\ 
       X_{2,1} &amp; X_{2,2} &amp; \cdots &amp; X_{2,365} \\
       \vdots &amp; \vdots &amp;  &amp; \vdots \\
       X_{T,1} &amp; X_{T,2} &amp; \cdots &amp; X_{T,365}
       \end{array} \right)_{T \times 365}. 
  </code>
</p>



<h3>Value</h3>

<p>A matrix with <code>Mcols</code> columns.
</p>


<h3>Note</h3>

<p><code><a href="#topic+series_double">series_double</a></code> can be implemented for the same purpose as 
this function but without requiring that the length of <code>X</code> be 
divisible by <code>Mcols</code>. It removes the first elements of <code>X</code> until
its length is divisible by <code>Mcols</code>.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Cebrián AC, Castillo-Mateo J, Asín J (2022).
“Record Tests to Detect Non Stationarity in the Tails with an Application to Climate Change.”
<em>Stochastic Environmental Research and Risk Assessment</em>, <strong>36</strong>(2), 313-330. 
<a href="https://doi.org/10.1007/s00477-021-02122-w">doi:10.1007/s00477-021-02122-w</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+series_double">series_double</a></code>, <code><a href="#topic+series_record">series_record</a></code>, 
<code><a href="#topic+series_rev">series_rev</a></code>, <code><a href="#topic+series_ties">series_ties</a></code>,
<code><a href="#topic+series_uncor">series_uncor</a></code>, <code><a href="#topic+series_untie">series_untie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>series_split(1:100, Mcols = 10)

TxZ &lt;- series_split(TX_Zaragoza$TX)
dim(TxZ)

</code></pre>

<hr>
<h2 id='series_ties'>Summary of Record Ties</h2><span id='topic+series_ties'></span>

<h3>Description</h3>

<p>This function compares the number of strog and weak records
to quantify whether rounding effects could greatly skew the conclusions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series_ties(X, record = c("upper", "lower"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="series_ties_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
<tr><td><code id="series_ties_+3A_record">record</code></td>
<td>
<p>A character string indicating the type of record to be 
assessed, &quot;upper&quot; or &quot;lower&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in the data preparation (or pre-processing) 
often required to apply the exploratory and inference tools based on 
theory of records within this package.
</p>
<p>The theory of records on which the hypothesis tests are based assumes 
that the random variables are continuous, proving that the probability 
that two observations take the same value is zero. Most of the data 
collected is rounded, giving a certain probability to the tie between 
records, thereby reducing the number of new records(see, e.g., Wergen 
et al. 2012). 
</p>
<p>This function summarises the difference between the number of observed 
strong records and the weak records.
</p>


<h3>Value</h3>

<p>A <code>list</code> object with elements:
</p>
<table role = "presentation">
<tr><td><code>number</code></td>
<td>
<p>Number of records: A vector containing the observed total, 
strong and weak number of records and the expected under IID.</p>
</td></tr>
<tr><td><code>percentage</code></td>
<td>
<p>% of weak records: Percentage of weak records within
the total.</p>
</td></tr>
<tr><td><code>percentage.position</code></td>
<td>
<p>% of weak records by position: A vector with
the percentage of weak records with <code>names</code> corresponding to its
observed instant.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Wergen G, Volovik D, Redner S, Krug J (2012). 
“Rounding Effects in Record Statistics.”
<em>Physical Review Letters</em>, <strong>109</strong>(16), 164102. 
<a href="https://doi.org/10.1103/physrevlett.109.164102">doi:10.1103/physrevlett.109.164102</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+series_double">series_double</a></code>, <code><a href="#topic+series_record">series_record</a></code>, 
<code><a href="#topic+series_rev">series_rev</a></code>, <code><a href="#topic+series_split">series_split</a></code>, 
<code><a href="#topic+series_uncor">series_uncor</a></code>, <code><a href="#topic+series_untie">series_untie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>series_ties(ZaragozaSeries)

</code></pre>

<hr>
<h2 id='series_uncor'>Subset of Uncorrelated Series</h2><span id='topic+series_uncor'></span>

<h3>Description</h3>

<p>Given a matrix this function extracts a subset of uncorrelated
columns (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series_uncor(
  X,
  test.fun = stats::cor.test,
  return.value = c("series", "indexes"),
  type = c("adjacent", "all"),
  first.last = TRUE,
  m = 1,
  alpha = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="series_uncor_+3A_x">X</code></td>
<td>
<p>A numeric matrix (or data frame) where the uncorrelated vectors 
are extracted from.</p>
</td></tr>
<tr><td><code id="series_uncor_+3A_test.fun">test.fun</code></td>
<td>
<p>A function that tests the correlation (it could also
test dependence or other feature that is desired to test on the columns). 
It must take as arguments two numeric vectors of the same length to apply 
the test to. The alternative hypothesis between both vectors is that the 
true correlation is not equal to 0 (or that they are dependent, etc). The 
return value should be a list object with a component <code>p.value</code> with 
the p-value of the test. Default is <code><a href="stats.html#topic+cor.test">cor.test</a></code>. Other 
function to test tail dependence is found in the package <code>extRemes</code>
as <code>taildep.test</code>.</p>
</td></tr>
<tr><td><code id="series_uncor_+3A_return.value">return.value</code></td>
<td>
<p>A character string indicating the return of the function,
<code>"series"</code> for a matrix with uncorrelated columns or <code>"indexes"</code>
for a vector with the position of the uncorrelated columns in <code>X</code>.</p>
</td></tr>
<tr><td><code id="series_uncor_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of uncorrelation wanted
between the extracted series (or columns), <code>"adjacent"</code> or 
<code>"all"</code> (see Details).</p>
</td></tr>
<tr><td><code id="series_uncor_+3A_first.last">first.last</code></td>
<td>
<p>Logical. Indicates if the first and last columns have also
to be uncorrelated (when <code>type = "adjacent"</code>).</p>
</td></tr>
<tr><td><code id="series_uncor_+3A_m">m</code></td>
<td>
<p>Integer value giving the starting column.</p>
</td></tr>
<tr><td><code id="series_uncor_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value in <code class="reqn">(0,1)</code>. It gives the significance level. 
For <code><a href="stats.html#topic+cor.test">cor.test</a></code> the alternative hypothesis is that the 
true correlation is not equal to 0.</p>
</td></tr>
<tr><td><code id="series_uncor_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>test.fun</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in the data preparation (or pre-processing) 
often required to apply the exploratory and inference tools based on 
theory of records within this package.
</p>
<p>Given a matrix <code>X</code> considered as a set of <code class="reqn">M^*</code> vectors, which
are the columns of <code>X</code>, this function extracts a subset 
of uncorrelated vectors (columns), using the following procedure: starting
from column <code>m</code>, the test <code>test.fun</code> is applied to
study the correlation between columns depending on argument <code>type</code>.
</p>
<p>If <code>type = "adjacent"</code>, the test is computed between <code>m</code>
and <code class="reqn">\code{m} + 1, \code{m} + 2, \ldots</code> and so on up to find a column 
<code class="reqn">\code{m} + k</code> which is not significantly correlated with column 
<code>m</code>. Then, the process is repeated starting at column 
<code class="reqn">\code{m} + k</code>. All columns are checked. 
</p>
<p>When the first and last columns may not have a significant correlation, 
where <code>m</code> is the first column, the parameter <code>first.last</code> should
be <code>FALSE</code>. When the first and last columns could be correlated, 
the function requires <code>first.last = TRUE</code>.
</p>
<p>If <code>type = "all"</code>, the procedure is similar as above but the new kept
column cannot be significantly correlated with any other column already 
kept, not only the previous one. So this option results in a fewer number
of columns.
</p>


<h3>Value</h3>

<p>A matrix or a vector as specified by <code>return.value</code>.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Cebrián AC, Castillo-Mateo J, Asín J (2022).
“Record Tests to Detect Non Stationarity in the Tails with an Application to Climate Change.”
<em>Stochastic Environmental Research and Risk Assessment</em>, <strong>36</strong>(2), 313-330. 
<a href="https://doi.org/10.1007/s00477-021-02122-w">doi:10.1007/s00477-021-02122-w</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+series_double">series_double</a></code>, <code><a href="#topic+series_record">series_record</a></code>,
<code><a href="#topic+series_rev">series_rev</a></code>, <code><a href="#topic+series_split">series_split</a></code>,
<code><a href="#topic+series_ties">series_ties</a></code>, <code><a href="#topic+series_untie">series_untie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Split Zaragoza series
TxZ &lt;- series_split(TX_Zaragoza$TX)

# Index of uncorrelated columns depending on the criteria
series_uncor(TxZ, return.value = "indexes", type = "adjacent")
series_uncor(TxZ, return.value = "indexes", type = "all")

# Return the set of uncorrelated vectors
ZaragozaSeries &lt;- series_uncor(TxZ)

</code></pre>

<hr>
<h2 id='series_untie'>Breaking Record Ties</h2><span id='topic+series_untie'></span>

<h3>Description</h3>

<p>Breaks record ties when observations have been rounded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series_untie(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="series_untie_+3A_x">X</code></td>
<td>
<p>A numeric vector, matrix (or data frame).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in the data preparation (or pre-processing) 
often required to apply the exploratory and inference tools based on 
theory of records within this package.
</p>
<p>The theory of records on which the hypothesis tests are based assumes 
that the random variables are continuous, so that the probability 
that two observations take the same value is zero. Most of the data 
collected is rounded, giving a certain probability to the tie between 
records, thereby reducing the number of new records (see, e.g., Wergen 
et al. 2012). 
</p>
<p>This function breaks ties by adding a uniform random variable 
to each element of <code>X</code>. The function computes the maximum number of 
decimal digits (let it be <code class="reqn">n</code>) for any element in <code>X</code>. Then the
uniform variable is sampled in the interval 
<code class="reqn">(-5 \times 10^{-(n+1)}, 5 \times 10^{-(n+1)})</code>, so the records in the
original (rounded) series are also records in the new series.
</p>


<h3>Value</h3>

<p>A matrix equal to <code>X</code> whose elements have been added a 
sample from a uniform variable, different for each element.
</p>


<h3>Author(s)</h3>

<p>Jorge Castillo-Mateo
</p>


<h3>References</h3>

<p>Wergen G, Volovik D, Redner S, Krug J (2012). 
“Rounding Effects in Record Statistics.”
<em>Physical Review Letters</em>, <strong>109</strong>(16), 164102.
<a href="https://doi.org/10.1103/physrevlett.109.164102">doi:10.1103/physrevlett.109.164102</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+series_double">series_double</a></code>, <code><a href="#topic+series_record">series_record</a></code>, 
<code><a href="#topic+series_rev">series_rev</a></code>, <code><a href="#topic+series_split">series_split</a></code>, 
<code><a href="#topic+series_ties">series_ties</a></code>, <code><a href="#topic+series_uncor">series_uncor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(23)
X &lt;- matrix(round(stats::rnorm(100), digits = 1), nrow = 10, ncol = 10)
series_untie(X)

series_untie(ZaragozaSeries)

</code></pre>

<hr>
<h2 id='TX_Zaragoza'>Time Series of Daily Maximum Temperature at Zaragoza (Spain)</h2><span id='topic+TX_Zaragoza'></span><span id='topic+TX_Zaragoza29F'></span>

<h3>Description</h3>

<p>A dataset containing the non-blended series of daily maximum
temperatures at Zaragoza Aeropuerto (Spain), from 1951-01-01 to 
2020-12-31. The variables are the following:
</p>

<ul>
<li><p> DATE  : Date <code>"%Y-%m-%d"</code>
</p>
</li>
<li><p> TX    : Maximum temperature in 0.1<code class="reqn">^\circ</code>C
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data("TX_Zaragoza29F")
data("TX_Zaragoza")
</code></pre>


<h3>Format</h3>


<ul>
<li> <p><code>TX_Zaragoza29F</code> is a data frame with 25568 rows and 2 variables.
</p>
</li>
<li> <p><code>TX_Zaragoza</code> is a data frame with 25550 rows and 2 variables.
</p>
</li></ul>



<h3>Details</h3>

<p>This series is obtained from the ECA&amp;D series Station identifier (STAID)
238 and Source identifier (SOUID) 100734. Zaragoza is located at the 
north-east (+41:39:42 N, -001:00:29 W) of the Iberian Peninsula at 247 m.
</p>
<p><code>TX_Zaragoza29F</code> is the original series. <code>TX_Zaragoza</code> is the
same but it does not include data for 29th of February, since when the 
series is split these days would yield a four-year time series
that is difficult to join to the analysis of the other yearly time series. 
</p>
<p>The series has three <code>NA</code> missing observations corresponding 
to 1951-03-31, 1965-01-04, and 1965-10-05.
</p>


<h3>Source</h3>

<p><a href="https://www.ecad.eu">EUROPEAN CLIMATE ASSESSMENT &amp; DATASET (ECA&amp;D)</a>
</p>


<h3>References</h3>

<p>Klein Tank AMG and Coauthors (2002). 
Daily Dataset of 20th-Century Surface Air Temperature and Precipitation 
Series for the European Climate Assessment.
<em>International Journal of Climatology</em>, <strong>22</strong>(12), 1441-1453.
<a href="https://doi.org/10.1002/joc.773">doi:10.1002/joc.773</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ZaragozaSeries">ZaragozaSeries</a></code>
</p>

<hr>
<h2 id='ZaragozaSeries'>Split and Uncorrelated Time Series <code><a href="#topic+TX_Zaragoza">TX_Zaragoza</a></code></h2><span id='topic+ZaragozaSeries'></span>

<h3>Description</h3>

<p>The matrix resulting from the data preparation (or 
pre-processing) of <code><a href="#topic+TX_Zaragoza">TX_Zaragoza</a>$TX</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ZaragozaSeries")
</code></pre>


<h3>Format</h3>

<p>A matrix with 70 rows and 76 columns.
</p>


<h3>Details</h3>

<p>The matrix is the result from applying:
<code><a href="#topic+series_uncor">series_uncor</a>(<a href="#topic+series_split">series_split</a>(<a href="#topic+TX_Zaragoza">TX_Zaragoza</a>$TX))</code>.
</p>
<p>The data matrix corresponds to the 70 years with observations in 
<code><a href="#topic+TX_Zaragoza">TX_Zaragoza</a>$TX</code> and to the 76 days in the year where adjacent
daily maximum temperature subseries are uncorrelated. By coincidence, 
none of the subseries 4, 90 or 278 with missing observations is kept 
within the 76 uncorrelated days.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TX_Zaragoza">TX_Zaragoza</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
