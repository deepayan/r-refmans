<!DOCTYPE html><html><head><title>Help for package forecastHybrid</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {forecastHybrid}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accuracy.cvts'><p>Accuracy measures for cross-validated time series</p></a></li>
<li><a href='#accuracy.hybridModel'><p>Accuracy measures for hybridModel objects</p></a></li>
<li><a href='#checkCVArguments'><p>Validate that CV window parameters are valid</p></a></li>
<li><a href='#checkModelArgs'><p>Helper function to test all the model arguments (e.g. a.args, e.args, etc)</p></a></li>
<li><a href='#checkParallelArguments'><p>Helper function to check the that the parallel arguments are valid</p></a></li>
<li><a href='#cvts'><p>Cross validation for time series</p></a></li>
<li><a href='#extractForecasts'><p>Extract cross validated rolling forecasts</p></a></li>
<li><a href='#fitted.hybridModel'><p>Extract Model Fitted Values</p></a></li>
<li><a href='#forecast.hybridModel'><p>Hybrid forecast</p></a></li>
<li><a href='#forecast.thetam'><p>Forecast using a Theta model</p></a></li>
<li><a href='#getModel'><p>Return a forecast model function for a given model character</p></a></li>
<li><a href='#getModelName'><p>Translate character to model name</p></a></li>
<li><a href='#hybridModel'><p>Hybrid time series modeling</p></a></li>
<li><a href='#is.hybridModel'><p>Test if the object is a hybridModel object</p></a></li>
<li><a href='#plot.hybridModel'><p>Plot a hybridModel object</p></a></li>
<li><a href='#plot.thetam'><p>Plot components from Theta model</p></a></li>
<li><a href='#plotFitted'><p>Plot the fitted values of a hybridModel object</p></a></li>
<li><a href='#plotModelObjects'><p>Plot the component models of a hybridModel object</p></a></li>
<li><a href='#prepareTimeseries'><p>Helper function to validate and clean the input time series</p></a></li>
<li><a href='#print.hybridModel'><p>Print information about the hybridModel object</p></a></li>
<li><a href='#removeModels'><p>Helper function to remove models that require more data</p></a></li>
<li><a href='#residuals.hybridModel'><p>Extract Model Residuals</p></a></li>
<li><a href='#summary.hybridModel'><p>Print a summary of the hybridModel object</p></a></li>
<li><a href='#thetam'><p>Theta method 'model'</p></a></li>
<li><a href='#thiefModel'><p>Forecast ensemble using THieF</p></a></li>
<li><a href='#tsCombine'><p>Combine multiple sequential time series</p></a></li>
<li><a href='#tsPartition'><p>Generate training and test indices for time series cross validation</p></a></li>
<li><a href='#tsSubsetWithIndices'><p>Subset time series with provided indices</p></a></li>
<li><a href='#unwrapParallelModels'><p>Helper function used to unpack the fitted model objects from a list</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Convenient Functions for Ensemble Time Series Forecasts</td>
</tr>
<tr>
<td>Version:</td>
<td>5.0.19</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-08-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Convenient functions for ensemble forecasts in R combining
    approaches from the 'forecast' package. Forecasts generated from auto.arima(), ets(),
    thetaf(), nnetar(), stlm(), tbats(), and snaive() can be combined with equal weights, weights
    based on in-sample errors (introduced by Bates &amp; Granger (1969) &lt;<a href="https://doi.org/10.1057%2Fjors.1969.103">doi:10.1057/jors.1969.103</a>&gt;),
    or cross-validated weights. Cross validation for time series data with user-supplied models
    and forecasting functions is also supported to evaluate model accuracy.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1), forecast (&ge; 8.12), thief</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel (&ge; 1.0.10), foreach (&ge; 1.4.3), ggplot2 (&ge;
2.2.0), purrr (&ge; 0.2.5), zoo (&ge; 1.7)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>GMDH, knitr, rmarkdown, roxygen2, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/dashaub/forecastHybrid">https://gitlab.com/dashaub/forecastHybrid</a>,
<a href="https://github.com/ellisp/forecastHybrid">https://github.com/ellisp/forecastHybrid</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ellisp/forecastHybrid/issues">https://github.com/ellisp/forecastHybrid/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-27 17:42:55 UTC; dashaub</td>
</tr>
<tr>
<td>Author:</td>
<td>David Shaub [aut, cre],
  Peter Ellis [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Shaub &lt;davidshaub@gmx.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-28 06:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='accuracy.cvts'>Accuracy measures for cross-validated time series</h2><span id='topic+accuracy.cvts'></span>

<h3>Description</h3>

<p>Returns range of summary measures of the cross-validated forecast accuracy
for <code>cvts</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cvts'
accuracy(object, ..., f = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy.cvts_+3A_object">object</code></td>
<td>
<p>a <code>cvts</code> objected created by <code><a href="#topic+cvts">cvts</a></code>.</p>
</td></tr>
<tr><td><code id="accuracy.cvts_+3A_...">...</code></td>
<td>
<p>other arguments (ignored).</p>
</td></tr>
<tr><td><code id="accuracy.cvts_+3A_f">f</code></td>
<td>
<p>Deprecated. Please use 'object' instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the method only implements <code>ME</code>, <code>RMSE</code>, and <code>MAE</code>. The accuracy
measures <code>MPE</code>, <code>MAPE</code>, and <code>MASE</code> are not calculated. The accuracy
is calculated for each forecast horizon up to <code>maxHorizon</code>
</p>


<h3>Author(s)</h3>

<p>David Shaub
</p>

<hr>
<h2 id='accuracy.hybridModel'>Accuracy measures for hybridModel objects</h2><span id='topic+accuracy.hybridModel'></span>

<h3>Description</h3>

<p>Accuracy measures for hybridModel
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hybridModel'
accuracy(object, individual = FALSE, ..., f = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy.hybridModel_+3A_object">object</code></td>
<td>
<p>the input hybridModel.</p>
</td></tr>
<tr><td><code id="accuracy.hybridModel_+3A_individual">individual</code></td>
<td>
<p>if <code>TRUE</code>, return the accuracy of the component models instead
of the accuracy for the whole ensemble model.</p>
</td></tr>
<tr><td><code id="accuracy.hybridModel_+3A_...">...</code></td>
<td>
<p>other arguments (ignored).</p>
</td></tr>
<tr><td><code id="accuracy.hybridModel_+3A_f">f</code></td>
<td>
<p>Deprecated. Please use 'object' instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Return the in-sample accuracy measures for the component models of the hybridModel
</p>


<h3>Value</h3>

<p>The accuracy of the ensemble or individual component models.
</p>


<h3>Author(s)</h3>

<p>David Shaub
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>

<hr>
<h2 id='checkCVArguments'>Validate that CV window parameters are valid</h2><span id='topic+checkCVArguments'></span>

<h3>Description</h3>

<p>Validate that CV window parameters are valid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkCVArguments(x, windowSize, maxHorizon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkCVArguments_+3A_x">x</code></td>
<td>
<p>the input time series.</p>
</td></tr>
<tr><td><code id="checkCVArguments_+3A_windowsize">windowSize</code></td>
<td>
<p>length of the window to build each model. When <code>rolling == FALSE</code>,
the each model will be fit to a time series of this length, and when <code>rolling == TRUE</code>
the first model will be fit to a series of this length and grow by one each iteration.</p>
</td></tr>
<tr><td><code id="checkCVArguments_+3A_maxhorizon">maxHorizon</code></td>
<td>
<p>maximum length of the forecast horizon to use for computing errors.</p>
</td></tr>
</table>

<hr>
<h2 id='checkModelArgs'>Helper function to test all the model arguments (e.g. a.args, e.args, etc)</h2><span id='topic+checkModelArgs'></span>

<h3>Description</h3>

<p>Helper function to test all the model arguments (e.g. a.args, e.args, etc)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkModelArgs(modelArguments, models)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkModelArgs_+3A_modelarguments">modelArguments</code></td>
<td>
<p>A list of containing the model arguments</p>
</td></tr>
<tr><td><code id="checkModelArgs_+3A_models">models</code></td>
<td>
<p>A character vector containing all the model codes</p>
</td></tr>
</table>

<hr>
<h2 id='checkParallelArguments'>Helper function to check the that the parallel arguments are valid</h2><span id='topic+checkParallelArguments'></span>

<h3>Description</h3>

<p>Helper function to check the that the parallel arguments are valid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkParallelArguments(parallel, num.cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkParallelArguments_+3A_parallel">parallel</code></td>
<td>
<p>A logic to indicate if parallel processing should be used</p>
</td></tr>
<tr><td><code id="checkParallelArguments_+3A_num.cores">num.cores</code></td>
<td>
<p>An integer for the number of threads to use</p>
</td></tr>
</table>

<hr>
<h2 id='cvts'>Cross validation for time series</h2><span id='topic+cvts'></span>

<h3>Description</h3>

<p>Perform cross validation on a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvts(
  x,
  FUN = NULL,
  FCFUN = NULL,
  rolling = FALSE,
  windowSize = 84,
  maxHorizon = 5,
  horizonAverage = FALSE,
  xreg = NULL,
  saveModels = ifelse(length(x) &gt; 500, FALSE, TRUE),
  saveForecasts = ifelse(length(x) &gt; 500, FALSE, TRUE),
  verbose = TRUE,
  num.cores = 2L,
  extraPackages = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvts_+3A_x">x</code></td>
<td>
<p>the input time series.</p>
</td></tr>
<tr><td><code id="cvts_+3A_fun">FUN</code></td>
<td>
<p>the model function used. Custom functions are allowed. See details and examples.</p>
</td></tr>
<tr><td><code id="cvts_+3A_fcfun">FCFUN</code></td>
<td>
<p>a function that process point forecasts for the model function. This defaults
to <code><a href="forecast.html#topic+forecast">forecast</a></code>. Custom functions are allowed. See details and examples. See details.</p>
</td></tr>
<tr><td><code id="cvts_+3A_rolling">rolling</code></td>
<td>
<p>should a rolling procedure be used? If TRUE, non-overlapping windows
of size <code>maxHorizon</code> will be used for fitting each model. If FALSE, the size
of the dataset used for training will grow by one each iteration.</p>
</td></tr>
<tr><td><code id="cvts_+3A_windowsize">windowSize</code></td>
<td>
<p>length of the window to build each model. When <code>rolling == FALSE</code>,
the each model will be fit to a time series of this length, and when <code>rolling == TRUE</code>
the first model will be fit to a series of this length and grow by one each iteration.</p>
</td></tr>
<tr><td><code id="cvts_+3A_maxhorizon">maxHorizon</code></td>
<td>
<p>maximum length of the forecast horizon to use for computing errors.</p>
</td></tr>
<tr><td><code id="cvts_+3A_horizonaverage">horizonAverage</code></td>
<td>
<p>should the final errors be an average over all forecast horizons
up to <code>maxHorizon</code> instead of producing
metrics for each individual horizon?</p>
</td></tr>
<tr><td><code id="cvts_+3A_xreg">xreg</code></td>
<td>
<p>External regressors to be used to fit the model. Only used if FUN accepts xreg
as an argument. FCFUN is also expected to accept it (see details)</p>
</td></tr>
<tr><td><code id="cvts_+3A_savemodels">saveModels</code></td>
<td>
<p>should the individual models be saved? Set this to <code>FALSE</code> on long
time series to save memory.</p>
</td></tr>
<tr><td><code id="cvts_+3A_saveforecasts">saveForecasts</code></td>
<td>
<p>should the individual forecast from each model be saved? Set this
to <code>FALSE</code> on long time series to save memory.</p>
</td></tr>
<tr><td><code id="cvts_+3A_verbose">verbose</code></td>
<td>
<p>should the current progress be printed to the console?</p>
</td></tr>
<tr><td><code id="cvts_+3A_num.cores">num.cores</code></td>
<td>
<p>the number of cores to use for parallel fitting. If the underlying model
that is being fit also utilizes parallelization, the number of cores it is using multiplied
by 'num.cores' should not exceed the number of cores available on your machine.</p>
</td></tr>
<tr><td><code id="cvts_+3A_extrapackages">extraPackages</code></td>
<td>
<p>on Windows if a custom 'FUN' or 'FCFUN' is being used that requires
loaded, these can be passed here so that they can be passed to parallel socket workers</p>
</td></tr>
<tr><td><code id="cvts_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the model function FUN</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cross validation of time series data is more complicated than regular
k-folds or leave-one-out cross validation of datasets
without serial correlation since observations <code class="reqn">x_t</code> and <code class="reqn">x_{t+n}</code>
are not independent. The <code>cvts()</code> function overcomes
this obstacle using two methods: 1) rolling cross validation where an initial training window
is used along with a forecast horizon
and the initial window used for training grows by one observation each round until the training
window and the forecast horizon capture the
entire series or 2) a non-rolling approach where a fixed training length is used that
is shifted forward by the forecast horizon after each iteration.
</p>
<p>For the rolling approach, training points are heavily recycled, both in terms of used for fitting
and in generating forecast errors at each of the forecast horizons from <code>1:maxHorizon</code>.
In contrast, the models fit with
the non-rolling approach share less overlap, and the predicted forecast values are also
only compared to the actual values once.
The former approach is similar to leave-one-out cross validation while the latter resembles
k-fold cross validation. As a result,
rolling cross validation requires far more iterations and computationally takes longer
to complete, but a disadvantage of the
non-rolling approach is the greater variance and general instability of cross-validated errors.
</p>
<p>The <code>FUN</code> and <code>FCFUN</code> arguments specify which function to use
for generating a model and forecasting, respectively. While the functions
from the &quot;forecast&quot; package can be used, user-defined functions can also
be tested, but the object returned by <code>FCFUN</code> must
accept the argument <code>h</code> and contain the point forecasts out to
this horizon <code>h</code> in slot <code>$mean</code> of the returned object. An example is given with
a custom model and forecast.
</p>
<p>For small time series (default <code>length &lt;= 500</code>), all of the individual fit models
are included in the final
<code>cvts</code> object that is returned. This can grow quite large since functions
such as <code>auto.arima</code> will
save fitted values, residual values, summary statistics, coefficient matrices, etc.
Setting <code>saveModels = FALSE</code>
can be safely done if there is no need to examine individual models fit at every stage
of cross validation since the
forecasts from each fold and the associated residuals are always saved.
</p>
<p>External regressors are allowed via the <code>xreg</code> argument. It is assumed that both
<code>FUN</code> and <code>FCFUN</code> accept the <code>xreg</code> parameter if <code>xreg</code> is not <code>NULL</code>.
If <code>FUN</code> does not accept the <code>xreg</code> parameter a warning will be given.
No warning is provided if <code>FCFUN</code> does not use the <code>xreg</code> parameter.
</p>


<h3>Author(s)</h3>

<p>David Shaub
</p>


<h3>See Also</h3>

<p><code><a href="#topic+accuracy.cvts">accuracy.cvts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>series &lt;- subset(AirPassengers, end = 50)
cvmod1 &lt;- cvts(series, FUN = snaive,
               windowSize = 25, maxHorizon = 12)
accuracy(cvmod1)

# We can also use custom model functions for modeling/forecasting
stlmClean &lt;- function(x) stlm(tsclean(x))
series &lt;- subset(austres, end = 38)
cvmodCustom &lt;- cvts(series, FUN = stlmClean, windowSize = 26, maxHorizon = 6)
accuracy(cvmodCustom)


# Use the rwf() function from the "forecast" package.
# This function does not have a modeling function and
# instead calculates a forecast on the time series directly
series &lt;- subset(AirPassengers, end = 26)
rwcv &lt;- cvts(series, FCFUN = rwf, windowSize = 24, maxHorizon = 1)

# Don't return the model or forecast objects
cvmod2 &lt;- cvts(USAccDeaths, FUN = stlm,
               saveModels = FALSE, saveForecasts = FALSE,
               windowSize = 36, maxHorizon = 12)

# If we don't need prediction intervals and are using the nnetar model, turning off PI
# will make the forecasting much faster
series &lt;- subset(AirPassengers, end=40)
cvmod3 &lt;- cvts(series, FUN = hybridModel,
               FCFUN = function(mod, h) forecast(mod, h = h, PI = FALSE),
               rolling = FALSE, windowSize = 36,
               maxHorizon = 2)

</code></pre>

<hr>
<h2 id='extractForecasts'>Extract cross validated rolling forecasts</h2><span id='topic+extractForecasts'></span>

<h3>Description</h3>

<p>Obtain cross validated forecasts when rolling cross validation is used. The object is not
inspected to see if it was fit using a rolling origin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractForecasts(cv, horizon = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractForecasts_+3A_cv">cv</code></td>
<td>
<p>An object of class cvts</p>
</td></tr>
<tr><td><code id="extractForecasts_+3A_horizon">horizon</code></td>
<td>
<p>The forecast horizon from each fold to extract</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Combine the cross validated forecasts fit with a rolling origin. This may be useful
to visualize and investigate the cross validated performance of the model
</p>


<h3>Value</h3>

<p>Forecasts computed via a rolling origin
</p>


<h3>Author(s)</h3>

<p>Ganesh Krishnan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cv &lt;- cvts(AirPassengers, FUN = stlm, FCFUN = forecast,
        rolling = TRUE, windowSize = 134, horizon = 2)

extractForecasts(cv)

</code></pre>

<hr>
<h2 id='fitted.hybridModel'>Extract Model Fitted Values</h2><span id='topic+fitted.hybridModel'></span>

<h3>Description</h3>

<p>Extract the model fitted values from the <code>hybridModel</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hybridModel'
fitted(object, individual = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.hybridModel_+3A_object">object</code></td>
<td>
<p>the input hybridModel.</p>
</td></tr>
<tr><td><code id="fitted.hybridModel_+3A_individual">individual</code></td>
<td>
<p>if <code>TRUE</code>, return the fitted values of the component models instead
of the fitted values for the whole ensemble model.</p>
</td></tr>
<tr><td><code id="fitted.hybridModel_+3A_...">...</code></td>
<td>
<p>other arguments (ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The fitted values of the ensemble or individual component models.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>

<hr>
<h2 id='forecast.hybridModel'>Hybrid forecast</h2><span id='topic+forecast.hybridModel'></span>

<h3>Description</h3>

<p>Forecast method for hybrid models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hybridModel'
forecast(
  object,
  h = ifelse(object$frequency &gt; 1, 2 * object$frequency, 10),
  xreg = NULL,
  level = c(80, 95),
  PI = TRUE,
  fan = FALSE,
  PI.combination = c("extreme", "mean"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.hybridModel_+3A_object">object</code></td>
<td>
<p>a hybrid time series model fit with <a href="#topic+hybridModel">hybridModel</a>.</p>
</td></tr>
<tr><td><code id="forecast.hybridModel_+3A_h">h</code></td>
<td>
<p>number of periods for forecasting. If <code>xreg</code> is used, <code>h</code> is ignored
and the number of forecast periods is set to the number of rows of <code>xreg</code>.</p>
</td></tr>
<tr><td><code id="forecast.hybridModel_+3A_xreg">xreg</code></td>
<td>
<p>future values of regression variables (for use if one of the ensemble methods used
in creating the hybrid forecast was <code>auto.arima</code>, <code>nnetar</code>, or <code>stlm</code>
and the model(s) used <code>xreg</code> in the fit).
It should be supplied as a matrix.</p>
</td></tr>
<tr><td><code id="forecast.hybridModel_+3A_level">level</code></td>
<td>
<p>confidence level for prediction intervals. This can be expressed as a decimal
between 0.0 and 1.0 or numeric between 0 and 100.</p>
</td></tr>
<tr><td><code id="forecast.hybridModel_+3A_pi">PI</code></td>
<td>
<p>should prediction intervals be produced? If a <code>nnetar</code> model is in the ensemble,
this can be quite slow, so disabling prediction intervals will speed up the forecast generation.
If <code>FALSE</code>, the arguments <code>level</code> and <code>fan</code> are ignored.</p>
</td></tr>
<tr><td><code id="forecast.hybridModel_+3A_fan">fan</code></td>
<td>
<p>if <code>TRUE</code>, level is set to <code>seq(51, 99, by = 3)</code>. This is suitable
for fan plots.</p>
</td></tr>
<tr><td><code id="forecast.hybridModel_+3A_pi.combination">PI.combination</code></td>
<td>
<p>Method for combining the prediction intervals from each of the
forecasts. Supplying <code>"mean"</code>
will simply average each of the lower/upper intervals from each model without using the model
weights used for the point forecasts. The default value <code>"extreme"</code> will take
the most pessimistic intervals (i.e. the highest upper interval from all the component models
and the lowest prediction interval from all of the component models').</p>
</td></tr>
<tr><td><code id="forecast.hybridModel_+3A_...">...</code></td>
<td>
<p>other arguments passed to the individual <code>forecast</code> generic methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code>xreg</code> was used in constructing the <code>hybridModel</code>,
it must also be passed into <code>forecast.hybridModel</code>.
<br />
<br />
While prediction intervals are produced for the
final ensemble forecast model, these should be viewed conservatively as insights
to the forecast's uncertainty. Currently these are constructed using the most extreme interval
from each component model for each horizon, so the composite prediction intervals do not
have statistical guarantees of asymptotic efficiency. More sophisticated
and rigorous techniques are planned, however, particularly when cross validation
approaches are used.
</p>


<h3>Value</h3>

<p>An object of class <a href="forecast.html#topic+forecast">forecast</a>.
</p>


<h3>Author(s)</h3>

<p>David Shaub
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hybridModel">hybridModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mod &lt;- hybridModel(AirPassengers)
fc &lt;- forecast(mod)

# View the point forecasts
fc$mean

# View the upper prediction interval
fc$upper

# View the lower prediction interval
fc$lower

# Plot the forecast
plot(fc)

## End(Not run)
</code></pre>

<hr>
<h2 id='forecast.thetam'>Forecast using a Theta model</h2><span id='topic+forecast.thetam'></span>

<h3>Description</h3>

<p>Returns forecasts and other information for univariate Theta &quot;models&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'thetam'
forecast(
  object,
  h = ifelse(object$m &gt; 1, 2 * object$m, 10),
  level = c(80, 95),
  fan = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.thetam_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>thetam</code>.  Usually the result of a call
to <code>link{thetam}</code>.</p>
</td></tr>
<tr><td><code id="forecast.thetam_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting</p>
</td></tr>
<tr><td><code id="forecast.thetam_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals</p>
</td></tr>
<tr><td><code id="forecast.thetam_+3A_fan">fan</code></td>
<td>
<p>If TRUE, level is set to <code>seq(51, 99, by = 3)</code>. This is suitable for fan plots.</p>
</td></tr>
<tr><td><code id="forecast.thetam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>forecast</code>
</p>


<h3>Author(s)</h3>

<p>Peter Ellis
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thetam">thetam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod1 &lt;- thetam(Nile)
fc1 &lt;- forecast(mod1)
plot(fc1)
</code></pre>

<hr>
<h2 id='getModel'>Return a forecast model function for a given model character</h2><span id='topic+getModel'></span>

<h3>Description</h3>

<p>Convert the single-letter representation used in the &quot;forecastHybrid&quot; package to the
corresponding model function from the &quot;forecast&quot; package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModel(modelCharacter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getModel_+3A_modelcharacter">modelCharacter</code></td>
<td>
<p>a single character representing one of the models from the <code>models</code>
argument passed to <a href="#topic+hybridModel">hybridModel</a></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+hybridModel">hybridModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>forecastHybrid:::getModel("a")
forecastHybrid:::getModel("s")
forecastHybrid:::getModel("z")
</code></pre>

<hr>
<h2 id='getModelName'>Translate character to model name</h2><span id='topic+getModelName'></span>

<h3>Description</h3>

<p>Convert the single-letter representation used in the &quot;forecastHybrid&quot; package to the
corresponding function name from the &quot;forecast&quot; package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModelName(modelCharacter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getModelName_+3A_modelcharacter">modelCharacter</code></td>
<td>
<p>a single character representing one of the models from the <code>models</code>
argument passed to <a href="#topic+hybridModel">hybridModel</a></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+hybridModel">hybridModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>forecastHybrid:::getModelName("a")
forecastHybrid:::getModelName("s")
forecastHybrid:::getModelName("z")
</code></pre>

<hr>
<h2 id='hybridModel'>Hybrid time series modeling</h2><span id='topic+hybridModel'></span>

<h3>Description</h3>

<p>Create a hybrid time series model with two to five component models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hybridModel(
  y,
  models = "aefnst",
  lambda = NULL,
  a.args = NULL,
  e.args = NULL,
  n.args = NULL,
  s.args = NULL,
  t.args = NULL,
  z.args = NULL,
  weights = c("equal", "insample.errors", "cv.errors"),
  errorMethod = c("RMSE", "MAE", "MASE"),
  rolling = FALSE,
  cvHorizon = frequency(y),
  windowSize = 84,
  horizonAverage = FALSE,
  parallel = FALSE,
  num.cores = 2L,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hybridModel_+3A_y">y</code></td>
<td>
<p>A numeric vector or time series.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_models">models</code></td>
<td>
<p>A character string of up to seven characters indicating which contributing
models to use:
a (<code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>), e (<code><a href="forecast.html#topic+ets">ets</a></code>),
f (<code><a href="#topic+thetam">thetam</a></code>), n (<code><a href="forecast.html#topic+nnetar">nnetar</a></code>),
s (<code><a href="forecast.html#topic+stlm">stlm</a></code>), t (<code><a href="forecast.html#topic+tbats">tbats</a></code>),
and z (<code><a href="forecast.html#topic+snaive">snaive</a></code>).</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter.
Ignored if NULL. Otherwise, data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_a.args">a.args</code></td>
<td>
<p>an optional <code>list</code> of arguments to pass to <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>.
See details.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_e.args">e.args</code></td>
<td>
<p>an optional <code>list</code> of arguments to pass to <code><a href="forecast.html#topic+ets">ets</a></code>.
See details.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_n.args">n.args</code></td>
<td>
<p>an optional <code>list</code> of arguments to pass to <code><a href="forecast.html#topic+nnetar">nnetar</a></code>.
See details.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_s.args">s.args</code></td>
<td>
<p>an optional <code>list</code> of arguments to pass to <code><a href="forecast.html#topic+stlm">stlm</a></code>.
See details.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_t.args">t.args</code></td>
<td>
<p>an optional <code>list</code> of arguments to pass to <code><a href="forecast.html#topic+tbats">tbats</a></code>.
See details.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_z.args">z.args</code></td>
<td>
<p>an optional <code>list</code> of arguments to pass to <code><a href="forecast.html#topic+snaive">snaive</a></code>.
See details.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_weights">weights</code></td>
<td>
<p>method for weighting the forecasts of the various contributing
models.  Defaults to <code>equal</code>, which has shown to be robust and better
in many cases than giving more weight to models with better in-sample performance.
Cross validated errors&ndash;implemented with <code>link{cvts}</code>
should produce the best forecast, but the model estimation is also the slowest. Note that
extra arguments
passed in <code>a.args</code>, <code>e.args</code>, <code>n.args</code>, <code>s.args</code>, and <code>t.args</code> are
not used during cross validation. See further explanation in <code><a href="#topic+cvts">cvts</a></code>.
Weights utilizing in-sample errors are also available but not recommended.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_errormethod">errorMethod</code></td>
<td>
<p>method of measuring accuracy to use if weights are not
to be equal.
Root mean square error (<code>RMSE</code>), mean absolute error (<code>MAE</code>)
and mean absolute scaled error (<code>MASE</code>)
are supported.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_rolling">rolling</code></td>
<td>
<p>If <code>weights = "cv.errors"</code>, this controls the use of rolling cross validation
in <code>cvts()</code></p>
</td></tr>
<tr><td><code id="hybridModel_+3A_cvhorizon">cvHorizon</code></td>
<td>
<p>If <code>weights = "cv.errors"</code>, this controls which forecast to horizon to use
for the error calculations.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_windowsize">windowSize</code></td>
<td>
<p>length of the window to build each model, only used when
<code>weights = "cv.errors"</code>.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_horizonaverage">horizonAverage</code></td>
<td>
<p>If <code>weights = "cv.errors"</code>, setting this to <code>TRUE</code> will average
all forecast horizons up to <code>cvHorizon</code> for calculating the errors instead of using
the single horizon given in <code>cvHorizon</code>.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_parallel">parallel</code></td>
<td>
<p>a boolean indicating if parallel processing should be used between models.
Parallelization will still occur within individual models that support it and can be controlled
using <code>a.args</code> and <code>t.args</code>.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_num.cores">num.cores</code></td>
<td>
<p>If <code>parallel=TRUE</code>, how many cores to use.</p>
</td></tr>
<tr><td><code id="hybridModel_+3A_verbose">verbose</code></td>
<td>
<p>Should the status of which model is being fit/cross validated be printed
to the terminal?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>hybridModel</code> function fits multiple individual model specifications
to allow easy creation of ensemble forecasts. While default settings for the individual
component models work quite well in most cases, fine control can be exerted by passing detailed
arguments to the component models in the
<code>a.args</code>, <code>e.args</code>, <code>n.args</code>, <code>s.args</code>, and <code>t.args</code> lists.
Note that if <code>xreg</code> is passed to the <code>a.args</code>, <code>n.args</code>, or
<code>s.args</code> component models it must now be passed as a matrix. In &quot;forecastHybrid&quot;
versions earlier than 4.0.15 it would instead be passed in as a dataframe, but for consistency
with &quot;forecast&quot; v8.5 we now require a matrix with colnames
<br />
<br />
Characteristics of the input series can cause problems for certain types of models
and parameters. For example, <code><a href="forecast.html#topic+stlm">stlm</a></code> models require that the input
series be seasonal; furthermore, the data must include at least two seasons
of data (i.e. <code>length(y) &gt;= 2 * frequency(y)</code>) for the decomposition to succeed.
If this is not the case, <code>hybridModel()</code>
will remove the <code>stlm</code> model so an error does not occur.
Similarly, <code>nnetar</code> models require that
<code>length(y) &gt;= 2 * frequency(y)</code>, so these models will be removed if the condition
is not satisfied. The <code><a href="forecast.html#topic+ets">ets</a></code> model does not handle
a series well with a seasonal period longer than 24 and will ignore the seasonality.
In this case, <code>hybridModel()</code> will also drop the <code>ets</code> model from the ensemble.
</p>


<h3>Value</h3>

<p>An object of class hybridModel.
The individual component models are stored inside of the object
and can be accessed for all the regular manipulations available in the forecast package.
</p>


<h3>Author(s)</h3>

<p>David Shaub
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast.hybridModel">forecast.hybridModel</a></code>, <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>,
<code><a href="forecast.html#topic+ets">ets</a></code>, <code><a href="#topic+thetam">thetam</a></code>, <code><a href="forecast.html#topic+nnetar">nnetar</a></code>,
<code><a href="forecast.html#topic+stlm">stlm</a></code>, <code><a href="forecast.html#topic+tbats">tbats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Fit an auto.arima, ets, thetam, nnetar, stlm, and tbats model
# on the time series with equal weights
mod1 &lt;- hybridModel(AirPassengers)
plot(forecast(mod1))

# Use an auto.arima, ets, and tbats model with weights
# set by the MASE in-sample errors
mod2 &lt;- hybridModel(AirPassengers, models = "aet",
weights = "insample.errors", errorMethod = "MASE")

# Pass additional arguments to auto.arima() to control its fit
mod3 &lt;- hybridModel(AirPassengers, models = "aens",
a.args = list(max.p = 7, max.q = 7, approximation = FALSE))

# View the component auto.arima() and stlm() models
mod3$auto.arima
mod3$stlm

## End(Not run)

</code></pre>

<hr>
<h2 id='is.hybridModel'>Test if the object is a hybridModel object</h2><span id='topic+is.hybridModel'></span>

<h3>Description</h3>

<p>Test if the object is a <code>hybridModel</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.hybridModel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.hybridModel_+3A_x">x</code></td>
<td>
<p>the input object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean indicating if the object is a <code>hybridModel</code> is returned.
</p>

<hr>
<h2 id='plot.hybridModel'>Plot a hybridModel object</h2><span id='topic+plot.hybridModel'></span>

<h3>Description</h3>

<p>Plot a representation of the hybridModel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hybridModel'
plot(x, type = c("fit", "models"), ggplot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hybridModel_+3A_x">x</code></td>
<td>
<p>an object of class hybridModel to plot.</p>
</td></tr>
<tr><td><code id="plot.hybridModel_+3A_type">type</code></td>
<td>
<p>if <code>type = "fit"</code>, plot the original series and the individual fitted models.
If <code>type = "models"</code>, use the regular plot methods from the component models, i.e.
<code><a href="forecast.html#topic+plot.Arima">plot.Arima</a></code>, <code><a href="forecast.html#topic+plot.ets">plot.ets</a></code>,
<code><a href="forecast.html#topic+plot.tbats">plot.tbats</a></code>. Note: no plot
methods exist for <code>nnetar</code> and <code>stlm</code> objects, so these will not be plotted with
<code>type = "models"</code>.</p>
</td></tr>
<tr><td><code id="plot.hybridModel_+3A_ggplot">ggplot</code></td>
<td>
<p>should the <code><a href="forecast.html#topic+autoplot">autoplot</a></code> function
be used (when available) for the plots?</p>
</td></tr>
<tr><td><code id="plot.hybridModel_+3A_...">...</code></td>
<td>
<p>other arguments passed to <a href="graphics.html#topic+plot">plot</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>type = "fit"</code>, the original series is plotted in black.
Fitted values for the individual component models are plotted in other colors.
For <code>type = "models"</code>, each individual component model is plotted. Since
there is not plot method for <code>stlm</code> or <code>nnetar</code> objects, these component
models are not plotted.
</p>


<h3>Value</h3>

<p>None. Function produces a plot.
</p>


<h3>Author(s)</h3>

<p>David Shaub
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hybridModel">hybridModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
hm &lt;- hybridModel(woolyrnq, models = "aenst")
plot(hm, type = "fit")
plot(hm, type = "models")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.thetam'>Plot components from Theta model</h2><span id='topic+plot.thetam'></span>

<h3>Description</h3>

<p>Produces a plot of the level components from the ETS model underlying a Theta model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'thetam'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.thetam_+3A_x">x</code></td>
<td>
<p>Object of class &quot;thetam&quot;.</p>
</td></tr>
<tr><td><code id="plot.thetam_+3A_...">...</code></td>
<td>
<p>Other plotting parameters passed through to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;state&quot; component of the plot comes from the model <code>ets(..., model = "ANN")</code>
that was fit as part of the theta method.  The &quot;seasonal&quot; component is the multipliers
from multiplicative classical
decomposition seasonal adjustment that is performed before the <code>ets</code> model is fit.
The &quot;linear&quot; component shows the direction and slope of drift that is used in the forecasting
to come.
</p>


<h3>Value</h3>

<p>None.  Function produces a plot.
</p>


<h3>Author(s)</h3>

<p>Peter Ellis
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thetam">thetam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- thetam(wineind)
plot(model)
</code></pre>

<hr>
<h2 id='plotFitted'>Plot the fitted values of a hybridModel object</h2><span id='topic+plotFitted'></span>

<h3>Description</h3>

<p>Plot a fitted values of the hybridModel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFitted(x, ggplot, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFitted_+3A_x">x</code></td>
<td>
<p>an object of class hybridModel to plot.</p>
</td></tr>
<tr><td><code id="plotFitted_+3A_ggplot">ggplot</code></td>
<td>
<p>should the <code><a href="forecast.html#topic+autoplot">autoplot</a></code> function be used (when available) for the plots?</p>
</td></tr>
<tr><td><code id="plotFitted_+3A_...">...</code></td>
<td>
<p>other arguments passed to <a href="graphics.html#topic+plot">plot</a>.</p>
</td></tr>
</table>

<hr>
<h2 id='plotModelObjects'>Plot the component models of a hybridModel object</h2><span id='topic+plotModelObjects'></span>

<h3>Description</h3>

<p>Plot a representation of the hybridModel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotModelObjects(x, ggplot, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotModelObjects_+3A_x">x</code></td>
<td>
<p>an object of class hybridModel to plot.</p>
</td></tr>
<tr><td><code id="plotModelObjects_+3A_ggplot">ggplot</code></td>
<td>
<p>should the <code><a href="forecast.html#topic+autoplot">autoplot</a></code> function be used (when available) for the plots?</p>
</td></tr>
<tr><td><code id="plotModelObjects_+3A_...">...</code></td>
<td>
<p>other arguments passed to <a href="graphics.html#topic+plot">plot</a>.</p>
</td></tr>
</table>

<hr>
<h2 id='prepareTimeseries'>Helper function to validate and clean the input time series</h2><span id='topic+prepareTimeseries'></span>

<h3>Description</h3>

<p>Helper function to validate and clean the input time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareTimeseries(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareTimeseries_+3A_y">y</code></td>
<td>
<p>The input time series</p>
</td></tr>
</table>

<hr>
<h2 id='print.hybridModel'>Print information about the hybridModel object</h2><span id='topic+print.hybridModel'></span>

<h3>Description</h3>

<p>Print information about the <code>hybridModel</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hybridModel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hybridModel_+3A_x">x</code></td>
<td>
<p>the input <code>hybridModel</code> object.</p>
</td></tr>
<tr><td><code id="print.hybridModel_+3A_...">...</code></td>
<td>
<p>other arguments (ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Print the names of the individual component models and their weights.
</p>

<hr>
<h2 id='removeModels'>Helper function to remove models that require more data</h2><span id='topic+removeModels'></span>

<h3>Description</h3>

<p>Helper function to remove models that require more data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeModels(y, models)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeModels_+3A_y">y</code></td>
<td>
<p>The input time series</p>
</td></tr>
<tr><td><code id="removeModels_+3A_models">models</code></td>
<td>
<p>The model codes to test</p>
</td></tr>
</table>

<hr>
<h2 id='residuals.hybridModel'>Extract Model Residuals</h2><span id='topic+residuals.hybridModel'></span>

<h3>Description</h3>

<p>Extract the model residuals from the <code>hybridModel</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hybridModel'
residuals(object, individual = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.hybridModel_+3A_object">object</code></td>
<td>
<p>The input hybridModel.</p>
</td></tr>
<tr><td><code id="residuals.hybridModel_+3A_individual">individual</code></td>
<td>
<p>If <code>TRUE</code>, return the residuals of the component models instead
of the residuals for the whole ensemble model.</p>
</td></tr>
<tr><td><code id="residuals.hybridModel_+3A_...">...</code></td>
<td>
<p>Other arguments (ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The residuals of the ensemble or individual component models.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>

<hr>
<h2 id='summary.hybridModel'>Print a summary of the hybridModel object</h2><span id='topic+summary.hybridModel'></span>

<h3>Description</h3>

<p>Print a summary of the hybridModel object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hybridModel'
summary(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.hybridModel_+3A_x">x</code></td>
<td>
<p>the input <code>hybridModel</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Print the names of the individual component models and their weights.
</p>

<hr>
<h2 id='thetam'>Theta method 'model'</h2><span id='topic+thetam'></span>

<h3>Description</h3>

<p>Create a model object as an interim step to a theta method forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thetam(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thetam_+3A_y">y</code></td>
<td>
<p>A numeric vector or time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This fits an exponential smoothing state space model with
<code>model = 'ANN'</code> to <code>y</code>, having first performed classic multiplicative
seasonal adjustment.  A drift value is also calculated by
<code>lsfit(0:(length(y) - 1), y)$coef[2] / 2</code>.  In combination with <code>forecast.thetam()</code>,
this provides identical results to <code>forecast::thetaf(...)</code>.  The  purpose of splitting
it into a 'model' and 'forecast' functions is to make the approach consistent with other
modeling / forecasting approaches used in <code>hybridModel()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>thetam</code>
</p>


<h3>Author(s)</h3>

<p>Peter Ellis
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast.thetam">forecast.thetam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod1 &lt;- thetam(Nile)
plot(mod1)
</code></pre>

<hr>
<h2 id='thiefModel'>Forecast ensemble using THieF</h2><span id='topic+thiefModel'></span>

<h3>Description</h3>

<p>Create a forecast ensemble using the theif() model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thiefModel(
  y,
  models = "aefnt",
  h = 2 * frequency(y),
  comb = c("struc", "mse", "ols", "bu", "shr", "sam"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thiefModel_+3A_y">y</code></td>
<td>
<p>the input time series</p>
</td></tr>
<tr><td><code id="thiefModel_+3A_models">models</code></td>
<td>
<p>the models to use. These are specified the same way as <code><a href="#topic+hybridModel">hybridModel</a></code></p>
</td></tr>
<tr><td><code id="thiefModel_+3A_h">h</code></td>
<td>
<p>the forecast horizon</p>
</td></tr>
<tr><td><code id="thiefModel_+3A_comb">comb</code></td>
<td>
<p>the combination method to use by <code><a href="thief.html#topic+thief">thief</a></code></p>
</td></tr>
<tr><td><code id="thiefModel_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, report the fitting status</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use the &quot;thief&quot; package method for reconciling forecasts across the temporal hierarchy.
The base models to be included in the ensemble are the same as those in <code>hybridModel</code>, but
the <code>stlm</code> model cannot be included since it requires seasonal data.
</p>


<h3>Author(s)</h3>

<p>David Shaub
</p>


<h3>See Also</h3>

<p><code><a href="thief.html#topic+thief">thief</a></code>
</p>
<p><code><a href="#topic+hybridModel">hybridModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>series &lt;- subset(woolyrnq, end = 8)
thiefModel(series, models = "fz")
</code></pre>

<hr>
<h2 id='tsCombine'>Combine multiple sequential time series</h2><span id='topic+tsCombine'></span>

<h3>Description</h3>

<p>Combine multiple ts objects into a single ts object. It is assumed that the ts objects provided
are sequential. In other words, it is assumed that a valid time series object can actually
be constructed from the provided objects. The start time and frequency of the combined object
will correspond to the start time and frequency of the first provided object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsCombine(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsCombine_+3A_...">...</code></td>
<td>
<p>ts objects to combine</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Combine sequential time series objects into a single time series object. This might
be useful, for example, when you want to combine the training and validation time series objects
for plotting. The function assumes that the provided objects have no overlap.
For example, a valid argument set would have two time series with periods from Jan-Dec 2015
and Jan-Dec 2016. An invalid set would be two time series t1 and t2 with periods from
Jan-Dec 2015 and Aug 2015-Dec 2016 respectively. In that case, there is overlap between
t1 and t2. The return value will depend on the order in which the arguments are provided.
If the function call is tsCombine(t1, t2), the overlapping portion of t1 and t2
(Aug-Dec 2015 in this example), would have values from t1 as long as they are not NA.
If the call is tsCombine(t2, t1), it will have values from t2 as long as they are not NA.
</p>


<h3>Value</h3>

<p>A combined ts object generated from the individual ts objects
</p>


<h3>Author(s)</h3>

<p>Ganesh Krishnan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsCombine(window(AirPassengers, end = c(1951, 12)), window(AirPassengers, start = c(1952, 1)))
</code></pre>

<hr>
<h2 id='tsPartition'>Generate training and test indices for time series cross validation</h2><span id='topic+tsPartition'></span>

<h3>Description</h3>

<p>Training and test indices are generated for time series cross validation.
Generated indices are based on the training windowSize, forecast horizons
and whether a rolling or non-rolling cross validation procedure is desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsPartition(x, rolling, windowSize, maxHorizon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsPartition_+3A_x">x</code></td>
<td>
<p>A time series</p>
</td></tr>
<tr><td><code id="tsPartition_+3A_rolling">rolling</code></td>
<td>
<p>Should indices be generated for a rolling or non-rolling procedure?</p>
</td></tr>
<tr><td><code id="tsPartition_+3A_windowsize">windowSize</code></td>
<td>
<p>Size of window for training</p>
</td></tr>
<tr><td><code id="tsPartition_+3A_maxhorizon">maxHorizon</code></td>
<td>
<p>Maximum forecast horizon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing train and test indices for each fold
</p>


<h3>Author(s)</h3>

<p>Ganesh Krishnan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsPartition(AirPassengers, rolling = TRUE, windowSize = 10, maxHorizon = 2)

</code></pre>

<hr>
<h2 id='tsSubsetWithIndices'>Subset time series with provided indices</h2><span id='topic+tsSubsetWithIndices'></span>

<h3>Description</h3>

<p>Use provided indices to subset a time series. The provided indices must be contiguous
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsSubsetWithIndices(x, indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsSubsetWithIndices_+3A_x">x</code></td>
<td>
<p>A time series object</p>
</td></tr>
<tr><td><code id="tsSubsetWithIndices_+3A_indices">indices</code></td>
<td>
<p>A contiguous vector of indices to use for subsetting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A time series object appropriately subsetted using provided indices
</p>


<h3>Author(s)</h3>

<p>Ganesh Krishnan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsSubsetWithIndices(AirPassengers, c(3:10))
</code></pre>

<hr>
<h2 id='unwrapParallelModels'>Helper function used to unpack the fitted model objects from a list</h2><span id='topic+unwrapParallelModels'></span>

<h3>Description</h3>

<p>Helper function used to unpack the fitted model objects from a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unwrapParallelModels(fitModels, expandedModels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unwrapParallelModels_+3A_fitmodels">fitModels</code></td>
<td>
<p>A list containing the models to include in the ensemble</p>
</td></tr>
<tr><td><code id="unwrapParallelModels_+3A_expandedmodels">expandedModels</code></td>
<td>
<p>A character vector from the <code>models</code> argument of <a href="#topic+hybridModel">hybridModel</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See usage inside the <code>hybridModel</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hybridModel">hybridModel</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
