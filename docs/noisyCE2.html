<!DOCTYPE html><html lang="en"><head><title>Help for package noisyCE2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {noisyCE2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#noisyCE2-package'><p>Cross-Entropy Optimisation of Noisy Functions</p></a></li>
<li><a href='#geweke'><p>Geweke's test stopping rule</p></a></li>
<li><a href='#noisyCE2'><p>Cross-Entropy Optimisation of Noisy Functions</p></a></li>
<li><a href='#smooth_dec'><p>Decreasing first-order smoothing rule</p></a></li>
<li><a href='#smooth_lin'><p>Linear first-order smoothing rule</p></a></li>
<li><a href='#ts_change'><p>Time series change stopping rule</p></a></li>
<li><a href='#type_variable'><p>Functions for defining the types of variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cross-Entropy Optimisation of Noisy Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Flavio Santi <a href="https://orcid.org/0000-0002-2014-1981"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Flavio Santi &lt;flavio.santi@univr.it&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.flaviosanti.it/software/noisyCE2">https://www.flaviosanti.it/software/noisyCE2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/f-santi/noisyCE2/issues">https://github.com/f-santi/noisyCE2/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Cross-Entropy optimisation of unconstrained deterministic and noisy
    functions illustrated in Rubinstein and Kroese (2004, ISBN:
    978-1-4419-1940-3) through a highly flexible and customisable function which 
    allows user to define custom variable domains, sampling distributions,
    updating and smoothing rules, and stopping criteria. Several built-in
    methods and settings make the package very easy-to-use under standard
    optimisation problems.</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>coda, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-03 21:46:26 UTC; flavio</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-09 13:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='noisyCE2-package'>Cross-Entropy Optimisation of Noisy Functions</h2><span id='topic+noisyCE2-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>The package <code>noisyCE2</code> implements the cross-entropy algorithm (Rubinstein and
Kroese, 2004) for the optimisation of unconstrained deterministic and noisy
functions through a highly flexible and customisable function which allows
user to define custom variable domains, sampling distributions, updating and
smoothing rules, and stopping criteria. Several built-in methods and settings
make the package very easy-to-use under standard optimisation problems.
</p>


<h3>Details</h3>

<p>The package permits a noisy function to be maximised by means of the
cross-entropy algorithm. Formally, problems in the form
</p>
<p style="text-align: center;"><code class="reqn">\max_{x\in\Theta}\textbf{E}(f(x))</code>
</p>

<p>are tackled for a noisy function
<code class="reqn">f\colon\Theta\subseteq\textbf{R}^m\to\textbf{R}</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Flavio Santi <a href="mailto:flavio.santi@univr.it">flavio.santi@univr.it</a> (<a href="https://orcid.org/0000-0002-2014-1981">ORCID</a>)
</p>


<h3>References</h3>

<p>Bee M., G. Espa, D. Giuliani, F. Santi (2017) &quot;A cross-entropy approach to
the estimation of generalised linear multilevel models&quot;, <em>Journal of
Computational and Graphical Statistics</em>, <strong>26</strong> (3), pp. 695-708.
<a href="https://doi.org/10.1080/10618600.2016.1278003">https://doi.org/10.1080/10618600.2016.1278003</a>
</p>
<p>Rubinstein, R. Y., and Kroese, D. P. (2004), <em>The Cross-Entropy Method</em>,
Springer, New York. ISBN: 978-1-4419-1940-3
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://www.flaviosanti.it/software/noisyCE2">https://www.flaviosanti.it/software/noisyCE2</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/f-santi/noisyCE2/issues">https://github.com/f-santi/noisyCE2/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1
# The negative 4-dimensional paraboloid can be maximised as follows:
negparaboloid &lt;- function(x) { -sum((x - (1:4))^2) }
sol &lt;- noisyCE2(negparaboloid, domain = rep('real', 4))

# EXAMPLE 2
# The 10-dimensional Rosenbrock's function can be minimised as follows:
rosenbrock &lt;- function(x) {
  sum(100 * (tail(x, -1) - head(x, -1)^2)^2 + (head(x, -1) - 1)^2)
}

newvar &lt;- type_real(
  init = c(0, 2),
  smooth = list(
    quote(smooth_lin(x, xt, 1)),
    quote(smooth_dec(x, xt, 0.7, 5))
  )
)

sol &lt;- noisyCE2(
  rosenbrock, domain = rep(list(newvar), 10),
  maximise = FALSE, N = 2000, maxiter = 10000
)

# EXAMPLE 3
# The negative 4-dimensional paraboloid with additive Gaussian noise can be
# maximised as follows:
noisyparaboloid &lt;- function(x) { -sum((x - (1:4))^2) + rnorm(1) }
sol &lt;- noisyCE2(noisyparaboloid, domain = rep('real', 4), stoprule = geweke(x))
# where the stopping criterion based on the Geweke's test has been adopted
# according to Bee et al. (2017).


</code></pre>

<hr>
<h2 id='geweke'>Geweke's test stopping rule</h2><span id='topic+geweke'></span>

<h3>Description</h3>

<p><code>geweke</code> tests the convergence of <code>x</code> through the Geweke's test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geweke(x, frac1 = 0.3, frac2 = 0.4, pvalue = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geweke_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector of last <code class="reqn">\gamma_n</code> values, as selected by the
function passed to <code><a href="#topic+noisyCE2">noisyCE2()</a></code> through the argument <code>stopwindow</code>.</p>
</td></tr>
<tr><td><code id="geweke_+3A_frac1">frac1</code>, <code id="geweke_+3A_frac2">frac2</code></td>
<td>
<p>fraction arguments of the Geweke's test according to
<code><a href="coda.html#topic+geweke.diag">coda::geweke.diag()</a></code>.</p>
</td></tr>
<tr><td><code id="geweke_+3A_pvalue">pvalue</code></td>
<td>
<p>threshold of the <code class="reqn">p</code>-value which triggers the stop of the
algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> indicating whether the algorithm has converged:
</p>
<table role = "presentation">
<tr><td><code>0</code></td>
<td>
<p>the algorithm has converged.</p>
</td></tr>
<tr><td><code>1</code></td>
<td>
<p>the algorithm has not converged.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other stopping rules: 
<code><a href="#topic+ts_change">ts_change</a>()</code>
</p>

<hr>
<h2 id='noisyCE2'>Cross-Entropy Optimisation of Noisy Functions</h2><span id='topic+noisyCE2'></span><span id='topic+print.noisyCE2'></span><span id='topic+summary.noisyCE2'></span><span id='topic+plot.noisyCE2'></span><span id='topic+coef.noisyCE2'></span>

<h3>Description</h3>

<p>Unconstraint optimisation of noisy functions through the cross-entropy
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noisyCE2(
  f,
  domain,
  ...,
  rho = 0.05,
  N = 1000,
  smooth = NULL,
  stopwindow = tail(gam, (n &gt; 20) * n/2),
  stoprule = ts_change(x),
  maxiter = 1000,
  maximise = TRUE,
  verbose = "v"
)

## S3 method for class 'noisyCE2'
print(x, ...)

## S3 method for class 'noisyCE2'
summary(object, ...)

## S3 method for class 'noisyCE2'
plot(x, what = c("x", "gam", "param"), start = NULL, end = NULL, ...)

## S3 method for class 'noisyCE2'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noisyCE2_+3A_f">f</code></td>
<td>
<p>objective function which takes the vector of optimisation variables
as first argument.</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_domain">domain</code></td>
<td>
<p>a <code>list</code> (or other coercible objects) where each component
specifies the domain of each variable of the objective function <code>f</code>.
The components of the list may be either objects of <code>typevar</code> class (see
<a href="#topic+type_variable">type_variable</a>) or strings identifying one of <a href="#topic+type_variable">type_variable</a> functions
(for example <code>"real"</code> for function <code><a href="#topic+type_real">type_real()</a></code>). See ยง Examples.</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code>f</code> or to other methods (for
<code>print</code> and <code>plot</code>).</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_rho">rho</code></td>
<td>
<p>parameter <code class="reqn">\rho</code> of the Cross-Entropy algorithm. This argument
may be passed either as a numeric value in <code class="reqn">(0,1)</code> or as an unevaluated
expression which may include the number of current iteration <code>n</code>, or the
argument <code>N</code>.</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_n">N</code></td>
<td>
<p>parameter <code class="reqn">N</code> of the Cross-Entropy algorithm. This argument
may be passed either as a positive integer or as an unevaluated expression
which may include the number of current iteration <code>n</code>.</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_smooth">smooth</code></td>
<td>
<p>list of unevaluated expressions to be used as smoothing rules
for the parameters of the sampling probability distributions of <strong>all
variables</strong>. If not <code>NULL</code>, all default or set smoothing rules of all
variables will be overwritten. See <a href="#topic+type_variable">type_variable</a> for details and examples.</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_stopwindow">stopwindow</code></td>
<td>
<p>unevaluated expression returning the object to be passed to
the stopping rule. Symbol <code>gam</code> permits the time series <code class="reqn">\gamma_t</code> to
be used (as a <code>numeric</code> vector).</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_stoprule">stoprule</code></td>
<td>
<p>stopping rule passed as an unevaluated expression including
<code>x</code> as the object returned by evaluation of argument <code>stopwindow</code>. The
algorithm is stopped when zero is returned by the evaluation of <code>stoprule</code>.
If returned object has attribute <code>mess</code>, this is used as a message.
Currently, built-in stopping rules are <code><a href="#topic+ts_change">ts_change()</a></code> and <code><a href="#topic+geweke">geweke()</a></code>, others
may be defined by user.</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iteration. When it is reached, algorithm is
stopped whether or not the stopping criterion is satisfied. If the maximum
number of iteration is reached, the <code>code</code> and the <code>message</code> components of
<code>noisyCE</code> object are overwritten.</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_maximise">maximise</code></td>
<td>
<p>if <code>TRUE</code> (default) <code>f</code> is maximised, otherwise a
minimisation of <code>f</code> is performed.</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_verbose">verbose</code></td>
<td>
<p>algorithm verbosity (values <code>v</code>, <code>vv</code> and <code>vvv</code> are admitted).</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_x">x</code>, <code id="noisyCE2_+3A_object">object</code></td>
<td>
<p>object of class <code>noisyCE2</code>, as returned by <code>noisyCE2</code>.</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_what">what</code></td>
<td>
<p>type of plot should be drawn. If <code>what = "x"</code> (default), values
of the variables are plotted as time series; if <code>what = "gam"</code>, time series
of statistics <code class="reqn">\gamma</code> is plotted; if <code>what = "param"</code>, time series of
parameters of the sampling distributions are plotted.</p>
</td></tr>
<tr><td><code id="noisyCE2_+3A_start">start</code>, <code id="noisyCE2_+3A_end">end</code></td>
<td>
<p>first and last value to be plotted. If <code>NULL</code>, all values
are plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>noisyCE2</code> structured as a list with the following
components:
</p>
<table role = "presentation">
<tr><td><code>f</code></td>
<td>
<p>argument <code>f</code>.</p>
</td></tr>
<tr><td><code>fobj</code></td>
<td>
<p>objective function <code>f</code> where possible arguments passed through
argument <code>...</code> have been substituted. Thus, the value of the objective
function maximised by <code>noisyCE</code> in <code>x0</code> can be computed as <code>fobj(x0)</code>. If
a minimisation has been performed, <code>fobj</code> returns <code>f</code> with sign inverted.</p>
</td></tr>
<tr><td><code>xopt</code></td>
<td>
<p><code>numeric</code> vector with solution.</p>
</td></tr>
<tr><td><code>hxopt</code></td>
<td>
<p>matrix of <code>niter</code> rows and <code>length(xopt)</code> columns with values of
variables generated by the optimisation algorithm.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p><code>list</code> of <code>length(xopt)</code> components where time series of
parameters (vectors <code class="reqn">v_t</code>) are stored for each variable as <code>data.frame</code>
objects with <code>niter+1</code> rows (the first rows are the starting values set
through function <code>noisyCEcontrol</code>).</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>vector of values <code class="reqn">\gamma_t</code>.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
<tr><td><code>code</code></td>
<td>
<p>convergence code of the algorithm. Value <code>0</code> means that algorithm
has converged; other values are defined according to the stopping rule.</p>
</td></tr>
<tr><td><code>convMess</code></td>
<td>
<p>textual message associated to the convergence code (if any).</p>
</td></tr>
<tr><td><code>compTimes</code></td>
<td>
<p>named vector computation times of each phase.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print</code>: display synthetic information about a <code>noisyCE2</code> object
</p>
</li>
<li> <p><code>summary</code>: display summary information about a <code>noisyCE2</code> object
</p>
</li>
<li> <p><code>plot</code>: plot various components of a <code>noisyCE2</code> object
</p>
</li>
<li> <p><code>coef</code>: get the solution of the optimisation
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
# Optimisation of the 4-dimensional function:
# f(x1,x2,x3,x4)=-(x1-1)^2-(x2-2)^2-(x3-3)^2-(x4-4)^2
sol &lt;- noisyCE2(function(x) -sum((x - (1:4))^2), domain = rep('real', 4))
# Representation of the convergence process:
plot(sol, what = 'x')
plot(sol, what = 'gam')

</code></pre>

<hr>
<h2 id='smooth_dec'>Decreasing first-order smoothing rule</h2><span id='topic+smooth_dec'></span>

<h3>Description</h3>

<p>Decreasing smoothing rule
</p>
<p style="text-align: center;"><code class="reqn">x_{t+1}:=a_t\,x_t + (1-a_t)\,x_{t-1}</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">a_t:= b\,\left(1-\left(1-\frac{1}{t}\right)^q\right)</code>
</p>

<p>for some <code class="reqn">0.7\leq b\leq1</code> and some <code class="reqn">5\leq q\leq10</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_dec(x, xt, b, qu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_dec_+3A_x">x</code></td>
<td>
<p><code>numeric</code> value of the last value of the parameter.</p>
</td></tr>
<tr><td><code id="smooth_dec_+3A_xt">xt</code></td>
<td>
<p><code>numeric</code> vector of past values of the parameter (time series).</p>
</td></tr>
<tr><td><code id="smooth_dec_+3A_b">b</code></td>
<td>
<p>smoothing parameter <code class="reqn">b</code>.</p>
</td></tr>
<tr><td><code id="smooth_dec_+3A_qu">qu</code></td>
<td>
<p>smoothing parameter <code class="reqn">q</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector of updated parameters.
</p>


<h3>See Also</h3>

<p>Other smoothing rules: 
<code><a href="#topic+smooth_lin">smooth_lin</a>()</code>
</p>

<hr>
<h2 id='smooth_lin'>Linear first-order smoothing rule</h2><span id='topic+smooth_lin'></span>

<h3>Description</h3>

<p>Linear smoothing rule
</p>
<p style="text-align: center;"><code class="reqn">x_{t+1}:=a\,x_t + (1-a)\,x_{t-1}</code>
</p>

<p>for some <code class="reqn">a\in[0,1]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_lin(x, xt, a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth_lin_+3A_x">x</code></td>
<td>
<p><code>numeric</code> value of the last value of the parameter.</p>
</td></tr>
<tr><td><code id="smooth_lin_+3A_xt">xt</code></td>
<td>
<p><code>numeric</code> vector of past values of the parameter (time series).</p>
</td></tr>
<tr><td><code id="smooth_lin_+3A_a">a</code></td>
<td>
<p>smoothing parameter <code class="reqn">a</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector of updated parameters.
</p>


<h3>See Also</h3>

<p>Other smoothing rules: 
<code><a href="#topic+smooth_dec">smooth_dec</a>()</code>
</p>

<hr>
<h2 id='ts_change'>Time series change stopping rule</h2><span id='topic+ts_change'></span>

<h3>Description</h3>

<p>Deterministic stopping rule based on the last change in the value of
<code class="reqn">\gamma_n</code>. Changes smaller than <code>tol</code>, or relative changes
smaller than <code>reltol</code> stop the algorithm. This criterion is suitable
only in case of deterministic objective functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_change(x, reltol = 1e-04, tol = 1e-12)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ts_change_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector of last <code class="reqn">\gamma_n</code> values, as selected by the
function passed to <code><a href="#topic+noisyCE2">noisyCE2()</a></code> through the argument <code>stopwindow</code>.</p>
</td></tr>
<tr><td><code id="ts_change_+3A_reltol">reltol</code></td>
<td>
<p>relative changes smaller than <code>tol</code> stop the algorithm.</p>
</td></tr>
<tr><td><code id="ts_change_+3A_tol">tol</code></td>
<td>
<p>changes smaller than <code>tol</code> stop the algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> indicating whether the algorithm has converged:
</p>
<table role = "presentation">
<tr><td><code>0</code></td>
<td>
<p>the algorithm has converged.</p>
</td></tr>
<tr><td><code>1</code></td>
<td>
<p>the algorithm has not converged.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other stopping rules: 
<code><a href="#topic+geweke">geweke</a>()</code>
</p>

<hr>
<h2 id='type_variable'>Functions for defining the types of variables</h2><span id='topic+type_variable'></span><span id='topic+type_custom'></span><span id='topic+type_real'></span><span id='topic+type_positive'></span><span id='topic+type_negative'></span>

<h3>Description</h3>

<p>All functions permit fully-customised types of variable to be defined.
Functions other than <code>type_custom</code> already include standard default values
which make the definition of standard variable types easier and quicker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type_custom(
  type = "custom",
  init = c(0, 10),
  randomXj = function(n, v) {     rnorm(n, v[1], v[2]) },
  x2v = function(x) {     c(mean(x), sd(x)) },
  v2x = function(v) {     v[1] },
  smooth = list(quote(smooth_lin(x, xt, 1)), quote(smooth_dec(x, xt, 0.9, 10))),
  ...
)

type_real(...)

type_positive(...)

type_negative(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type_variable_+3A_type">type</code></td>
<td>
<p>label for identifying the type of variable. The name is not
used internally in any case.</p>
</td></tr>
<tr><td><code id="type_variable_+3A_init">init</code></td>
<td>
<p><code>numeric</code> vector of starting values of parameters of the
sampling distribution.</p>
</td></tr>
<tr><td><code id="type_variable_+3A_randomxj">randomXj</code></td>
<td>
<p>function for randomly generating variable values according
to the sampling distribution. The function should take the number of
observations to be generated as a first argument, and the vector of
parameters as a second argument; a vector of random values should be
returned.</p>
</td></tr>
<tr><td><code id="type_variable_+3A_x2v">x2v</code></td>
<td>
<p>function for updating the parameters of the sampling distribution.
<em>No smoothing is needed.</em> The function should take a single argument to be
used for updating the parameters.</p>
</td></tr>
<tr><td><code id="type_variable_+3A_v2x">v2x</code></td>
<td>
<p>function for obtaining point values of variable from the
parameters of the sampling distribution.</p>
</td></tr>
<tr><td><code id="type_variable_+3A_smooth">smooth</code></td>
<td>
<p>list of unevaluated expressions of smoothing functions for each
parameter of the sampling distribution.</p>
</td></tr>
<tr><td><code id="type_variable_+3A_...">...</code></td>
<td>
<p>further arguments to be included into the <code>typevar</code> object. In
case of function for predefined types, it is possible to use ellipsis for
overwriting default values (see ยง Examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>type</code> and <code>typevar</code>, where <code>type</code> is the value of the
argument <code>type</code> passed to <code>type_custom</code>, or predefined lables (if not
overwritten) in case of other functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a new type of real variable where the first parameter of the
# sampling distribution is updated through the median (instead of the
# mean):
type_real(
  type = 'real2', 
  x2v = function(x) { c(median(x), sd(x)) }
)

# Define a new type of real variable whith different smoothing
# parameters:
type_real(
  type = 'real3', 
  smooth = list(
    quote(smooth_lin(x, xt, 0.8)),
    quote(smooth_dec(x, xt, 0.99, 15))
  )
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
