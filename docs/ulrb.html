<!DOCTYPE html><html><head><title>Help for package ulrb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ulrb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_avgSil'><p>Check average Silhouette score index</p></a></li>
<li><a href='#check_CH'><p>Check Calinsky-Harabasz index</p></a></li>
<li><a href='#check_DB'><p>Check Davies-Bouldin Index</p></a></li>
<li><a href='#define_rb'><p>Define Rare Biosphere</p></a></li>
<li><a href='#evaluate_k'><p>Evaluate k from all samples in a dataset</p></a></li>
<li><a href='#evaluate_sample_k'><p>Evaluate sample k</p></a></li>
<li><a href='#nice'><p>V4-V5 16S rRNA gene amplicons, clean OTU table (N-ICE, 2015)</p></a></li>
<li><a href='#nice_env'><p>Metadata of samples from OTU tables (N-ICE, 2015)</p></a></li>
<li><a href='#nice_raw'><p>V4-V5 16S rRNA gene amplicons, raw OTU table (N-ICE, 2015)</p></a></li>
<li><a href='#nice_tidy'><p>V4-V5 16S rRNA gene amplicons, clean OTU table in tidy/long format (N-ICE, 2015)</p></a></li>
<li><a href='#plot_ulrb'><p>Plot ulrb clustering results and silhouette scores</p></a></li>
<li><a href='#plot_ulrb_clustering'><p>Plot Rank Abundance Curve of classification results</p></a></li>
<li><a href='#plot_ulrb_silhouette'><p>Plot silhouette scores from clustering results</p></a></li>
<li><a href='#prepare_tidy_data'><p>Prepare data in tidy format</p></a></li>
<li><a href='#suggest_k'><p>Suggest k</p></a></li>
<li><a href='#ulrb-package'>
<p>ulrb: Unsupervised Learning Based Definition of Microbial Rare Biosphere</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Unsupervised Learning Based Definition of Microbial Rare
Biosphere</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francisco Pascoal &lt;fpascoal1996@gmail.com&gt;</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-13</td>
</tr>
<tr>
<td>Description:</td>
<td>A tool to define rare biosphere. 'ulrb' solves the problem of the 
    definition of rarity by replacing human decision with an unsupervised machine 
    learning algorithm (partitioning around medoids, or k-medoids). This algorithm 
    works for any type of microbiome data, provided there is an abundance score 
    for each phylogenetic unit. For validation of this method to several kinds of 
    molecular data and environments, please see Pascoal et al, 2023 (in preparation).
    Preliminary data suggest this method also works well for non-microbiome data, 
    if there is a species abundance table.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, stringr, testthat (&ge; 3.0.0), vegan</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, dplyr, ggplot2, purrr, rlang, stats, tidyr,
clusterSim, gridExtra</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pascoalf.github.io/ulrb/">https://pascoalf.github.io/ulrb/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pascoalf/ulrb/issues">https://github.com/pascoalf/ulrb/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-17 09:30:19 UTC; fpascoal</td>
</tr>
<tr>
<td>Author:</td>
<td>Francisco Pascoal <a href="https://orcid.org/0000-0003-2315-358X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Paula Branco <a href="https://orcid.org/0000-0002-9917-3694"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Luís Torgo <a href="https://orcid.org/0000-0002-6892-8871"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Rodrigo Costa <a href="https://orcid.org/0000-0002-5932-4101"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Catarina Magalhães
    <a href="https://orcid.org/0000-0002-5932-4101"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-17 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_avgSil'>Check average Silhouette score index</h2><span id='topic+check_avgSil'></span>

<h3>Description</h3>

<p>Calculates average Silhouette score for a given sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_avgSil(
  data,
  sample_id = NULL,
  samples_col = "Sample",
  abundance_col = "Abundance",
  range = 3:10,
  with_plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_avgSil_+3A_data">data</code></td>
<td>
<p>A tibble with, at least, a column for Abundance and Sample. Additional columns are allowed.</p>
</td></tr>
<tr><td><code id="check_avgSil_+3A_sample_id">sample_id</code></td>
<td>
<p>String with name of the sample to apply this function.</p>
</td></tr>
<tr><td><code id="check_avgSil_+3A_samples_col">samples_col</code></td>
<td>
<p>String with name of column with sample names.</p>
</td></tr>
<tr><td><code id="check_avgSil_+3A_abundance_col">abundance_col</code></td>
<td>
<p>String with name of column with abundance values.</p>
</td></tr>
<tr><td><code id="check_avgSil_+3A_range">range</code></td>
<td>
<p>The range of values of k to test, default is from 3 to 10.</p>
</td></tr>
<tr><td><code id="check_avgSil_+3A_with_plot">with_plot</code></td>
<td>
<p>If FALSE (default) returns a vector, but if TRUE will return a plot with the scores.</p>
</td></tr>
<tr><td><code id="check_avgSil_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average Silhouette score index provides a sense of cluster definition and separation.
It varies between -1 (complete cluster overlap) and 1 (no cluster overlap),
the closest to 1, the better. Thus,
<strong>the k value with highest average Silhouette score is the best k</strong>.
This is the standard metric used by the <strong>ulrb</strong> package for automation of the decision
of k, in functions <code><a href="#topic+suggest_k">suggest_k()</a></code> and <code><a href="#topic+define_rb">define_rb()</a></code>.
</p>
<p><strong>Note</strong>: The average Silhouette score is different from the common calculation of
the Silhouette index, which provides a score for each observation in a clustering result.
Just like the name says, we are taking the average of all silhouette scores
obtained in a clustering result. In this way we can have a single, comparable
value for each k we test.
</p>
<p><strong>Data input</strong>
</p>
<p>This function takes a data.frame with a column for samples and a column for abundance
(minimum), but can take any number of other columns. It will then filter the specific sample
that you want to analyze. You can also pre-filter for your specific sample, but you still need to
provide the sample ID (sample_id) and the table always needs a column for Sample and another for Abundance
(indicate how you name them with the arguments samples_col and abundance_col).
</p>
<p><strong>Output options</strong>
</p>
<p>The default option returns a vector with CH scores for each k. This is a simple output that can then be used
for other analysis. However, we also provide the option to show a plot (set <code>with_plot = TRUE</code>) with
the CH score for each k.
</p>
<p>Note that this function does not plot the classical Silhouette plot of a clustering result.
To do that particular plot, use the function <code><a href="#topic+plot_ulrb_silhouette">plot_ulrb_silhouette()</a></code> instead.
</p>
<p><strong>Explanation of average Silhouette score</strong>
</p>
<p>To calculate the Silhouette score for a single observation, let:
</p>

<ul>
<li> <p><code class="reqn">a</code> be the mean distance between an observation and all other
observations from the same cluster; and
</p>
</li>
<li> <p><code class="reqn">b</code> be the mean distance between all observations in a cluster and the
centroid of the nearest cluster.
</p>
</li></ul>

<p>The silhouette score (Sil), is given by:
</p>
<p style="text-align: center;"><code class="reqn">Sil = \frac{(b-a)}{max(a,b)}</code>
</p>

<p>Once you have the Silhouette score for all observations in a clustering result, just
take the simple mean and get the average Silhouette score.
</p>
<p><strong>Silhouette score intuition</strong>
</p>
<p>From the above formula, <code class="reqn">Sil = \frac{(b-a)}{max(a,b)}</code>, it is clear that,
for a given observation:
</p>

<ul>
<li><p> if <code class="reqn">a &gt; b</code>, the Silhouette score approaches <strong>1</strong>; this means that the
distance between an observation and its own cluster is larger than the
distance to the nearest different cluster. This is the distance that must be
maximized so that all points in a cluster are more similar with each other,
than they are with other clusters.
</p>
</li>
<li><p> if <code class="reqn">a = b</code>, then the Silhouette score is <strong>0</strong>; this means that the distance
between the observation and its own cluster is equivalent to distance between
the nearest different cluster.
</p>
</li>
<li><p> if <code class="reqn">a &lt; b</code>, then the Silhouette score approaches <strong>-1</strong>; in this
situation, an observation is nearer the nearest different cluster,
than it is to its own cluster. Thus, a negative score indicates that the observation
is not in the correct cluster.
</p>
</li></ul>

<p><strong>average Silhouette score intuition</strong>
</p>
<p>If we take the average of the Silhouette score obtained for each observation in
a clustering result, then we have the ability to compare the overall success of that
clustering with another clustering. Thus, if we compare the average Silhouette
score across different k values, i.e. different number of clusters, we can
select the k with highest average Silhouette score.
</p>


<h3>Value</h3>

<p>Vector with average Silhouette score index for each pre-specified k.
</p>


<h3>References</h3>

<p>Rousseeuw, P. J. (1987). Silhouettes: A graphical aid to the interpretation and validation of cluster analysis. Journal of Computational and Applied Mathematics, 20(C), 53–65.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+define_rb">define_rb()</a></code>, <code><a href="#topic+suggest_k">suggest_k()</a></code>, <code><a href="cluster.html#topic+pam">cluster::pam()</a></code>, <code><a href="cluster.html#topic+silhouette">cluster::silhouette()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
# Just scores
check_avgSil(nice_tidy, sample_id = "ERR2044662")

# To change range
check_avgSil(nice_tidy, sample_id = "ERR2044662", range = 4:11)

# To see a simple plot
check_avgSil(nice_tidy, sample_id = "ERR2044662", range = 4:11, with_plot=TRUE)

</code></pre>

<hr>
<h2 id='check_CH'>Check Calinsky-Harabasz index</h2><span id='topic+check_CH'></span>

<h3>Description</h3>

<p>Calculates Calinsky-Harabasz pseudo F-statistic (CH) for a given sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_CH(
  data,
  sample_id,
  samples_col = "Sample",
  abundance_col = "Abundance",
  range = 3:10,
  with_plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_CH_+3A_data">data</code></td>
<td>
<p>A tibble with, at least, a column for Abundance and Sample. Additional columns are allowed.</p>
</td></tr>
<tr><td><code id="check_CH_+3A_sample_id">sample_id</code></td>
<td>
<p>String with name of the sample to apply this function.</p>
</td></tr>
<tr><td><code id="check_CH_+3A_samples_col">samples_col</code></td>
<td>
<p>String with name of column with sample names.</p>
</td></tr>
<tr><td><code id="check_CH_+3A_abundance_col">abundance_col</code></td>
<td>
<p>String with name of column with abundance values.</p>
</td></tr>
<tr><td><code id="check_CH_+3A_range">range</code></td>
<td>
<p>The range of values of k to test, default is from 3 to 10.</p>
</td></tr>
<tr><td><code id="check_CH_+3A_with_plot">with_plot</code></td>
<td>
<p>If FALSE (default) returns a vector, but if TRUE will return a plot with the scores.</p>
</td></tr>
<tr><td><code id="check_CH_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CH is an index used to decide the number of clusters in a clustering algorithm.
This function, <code><a href="#topic+check_CH">check_CH()</a></code>, calculates the CH index for every k in a pre-specified range
of values. Thus providing a score for each number of clusters tested (k). The default
range of cluster values (k) is <code>range = 3:10</code> (see why this is in Pascoal et al., 2023).
However, this function may calculate the CH index for all possible k's.
</p>
<p>Note that CH index is not an absolute value that indicates the quality of a single clustering.
Instead, it allows the comparison of clustering results. Thus, if you have several clusterings, the
best one will be the one with higher CH index.
</p>
<p><strong>Data input</strong>
</p>
<p>This function takes a data.frame with a column for samples and a column for abundance
(minimum), but can take any number of other columns. It will then filter the specific sample
that you want to analyze. You can also pre-filter for your specific sample, but you still need to
provide the sample ID (sample_id) and the table always needs a column for Sample and another for Abundance
(indicate how you name them with the arguments samples_col and abundance_col).
</p>
<p><strong>Output options</strong>
</p>
<p>The default option returns a vector with CH scores for each k. This is a simple output that can then be used
for other analysis. However, we also provide the option to show a plot (set <code>with_plot = TRUE</code>) with
the CH score for each k.
</p>
<p><strong>Explanation of Calinsky-Harabasz index</strong>
</p>
<p>The CH index is a <strong>variance ratio criterion</strong>, it measures both <strong>separation</strong> and <strong>density</strong> of the clusters.
The higher, the better, because it means that the points within the same cluster are close to each other; and
the different clusters are well separated.
</p>
<p>You can see CH index as:
</p>
<p style="text-align: center;"><code class="reqn">CH = \frac{inter-cluster dispersion}{intra-cluster dispersion}</code>
</p>

<p>To calculate inter-cluster:
</p>
<p>Let <code class="reqn">k</code> be the number of clusters and BGSS be the Between-group sum of squares,
</p>
<p>inter-cluster dispersion is </p>
<p style="text-align: center;"><code class="reqn">\frac{BGSS}{(k-1)}</code>
</p>

<p>To calculate BGSS:
</p>
<p>Let <code class="reqn">n_k</code> be the number of observations in a cluster,
<code class="reqn">C</code> be the centroid of the dataset (barycenter) and <code class="reqn">C_k</code> the centroid of
a cluster,
</p>
<p style="text-align: center;"><code class="reqn">BGSS = \sum_{k = 1}^{k}{n_k * \left\lvert C_k-C \right\rvert^2}</code>
</p>

<p>Thus, the BGSS multiplies the distance between the cluster centroid and
the centroid of the whole dataset, by all observations in a given cluster,
for all clusters.
</p>
<p>To calculate intra-cluster dispersion:
</p>
<p>Let <code class="reqn">WGSS</code> be the Within Group Sum of Squares and <code class="reqn">N</code> be the total
number of observations in the dataset.
</p>
<p>intra-cluster dispersion
</p>
<p style="text-align: center;"><code class="reqn">\frac{WGSS}{(N-1)}</code>
</p>

<p>Let <code class="reqn">X_ik</code> be i'th observation of a cluster and
<code class="reqn">n_k</code> be the number of observations in a cluster.
</p>
<p style="text-align: center;"><code class="reqn">WGSS = \sum_{k=1}^{k}\sum_{i=1}^{n_k}\left\lvert X_ik - C_k \right\rvert</code>
</p>

<p>Thus, WGSS measures the distance between observations and their cluster center; if divided by the
total number of observations, then gives a sense of intra-dispersion.
</p>
<p>Finally, the CH index can be given by:
</p>
<p style="text-align: center;"><code class="reqn">CH = \frac{\sum_{k = 1}^{k}{n_k * \left\lvert C_k-C \right\rvert^2}}
 {\sum_{k=1}^{k}\sum_{i=1}^{n_k}\left\lvert X_ik - C_k \right\rvert}
 \frac{(N-k)}{(k-1)}</code>
</p>



<h3>Value</h3>

<p>Vector or plot with Calinsky-Harabasz index for each pre-specified k.
</p>


<h3>References</h3>

<p>Calinski, T., &amp; Harabasz, J. (1974). A dendrite method for cluster analysis. Communications in Statistics - Theory and Methods, 3(1), 1–27.
</p>
<p>Pascoal et al., 2023 (manuscript in preparation)
</p>


<h3>See Also</h3>

<p><a href="clusterSim.html#topic+index.G1">clusterSim::index.G1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
# Just scores
check_CH(nice_tidy, sample_id = "ERR2044662")

# To change range
check_CH(nice_tidy, sample_id = "ERR2044662", range = 4:11)

# To see a simple plot
check_CH(nice_tidy, sample_id = "ERR2044662", range = 4:11, with_plot=TRUE)


</code></pre>

<hr>
<h2 id='check_DB'>Check Davies-Bouldin Index</h2><span id='topic+check_DB'></span>

<h3>Description</h3>

<p>Calculates Davies-Bouldin (DB)Index for a given sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_DB(
  data,
  sample_id,
  samples_col = "Sample",
  abundance_col = "Abundance",
  range = 3:10,
  with_plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_DB_+3A_data">data</code></td>
<td>
<p>A tibble with, at least, a column for Abundance and Sample. Additional columns are allowed.</p>
</td></tr>
<tr><td><code id="check_DB_+3A_sample_id">sample_id</code></td>
<td>
<p>String with name of the sample to apply this function.</p>
</td></tr>
<tr><td><code id="check_DB_+3A_samples_col">samples_col</code></td>
<td>
<p>String with name of column with sample names.</p>
</td></tr>
<tr><td><code id="check_DB_+3A_abundance_col">abundance_col</code></td>
<td>
<p>String with name of column with abundance values.</p>
</td></tr>
<tr><td><code id="check_DB_+3A_range">range</code></td>
<td>
<p>The range of values of k to test, default is from 3 to 10.</p>
</td></tr>
<tr><td><code id="check_DB_+3A_with_plot">with_plot</code></td>
<td>
<p>If FALSE (default) returns a vector, but if TRUE will return a plot with the scores.</p>
</td></tr>
<tr><td><code id="check_DB_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DB is an index used to decide the number of clusters in a clustering algorithm.
This function, <code><a href="#topic+check_DB">check_DB()</a></code>, calculates the DB index for every k in a pre-specified range
of values. Thus providing a score for each number of clusters tested (k). The default
range of cluster values (k) is <code>range = 3:10</code> (see why this is in Pascoal et al., 2023).
However, this function may calculate the DB index for all possible k's.
</p>
<p>Note that DB index is not an absolute value that indicates the quality of a single clustering.
Instead, it allows the comparison of clustering results. Thus, if you have several clusterings, the
best one will be the one with higher DB index.
</p>
<p><strong>Data input</strong>
</p>
<p>This function takes a data.frame with a column for samples and a column for abundance
(minimum), but can take any number of other columns. It will then filter the specific sample
that you want to analyze. You can also pre-filter for your specific sample, but you still need to
provide the sample ID (sample_id) and the table always needs a column for Sample and another for Abundance
(indicate how you name them with the arguments samples_col and abundance_col).
</p>
<p><strong>Output options</strong>
</p>
<p>The default option returns a vector with DB scores for each k. This is a simple output that can then be used
for other analysis. However, we also provide the option to show a plot (set <code>with_plot = TRUE</code>) with
the DB score for each k.
</p>
<p><strong>Explanation of Davies-Bouldin index</strong>
</p>
<p>The DB index (Davies and Bouldin, 1979) is an averaged measure of cluster
similarity to the closest cluster. This provides a sense of how separated the clusters are.
</p>
<p>Lower DB scores are better, because they represent more distinct clusters.
Higher values of DB indicate overlapping clusters.
</p>
<p>Let <code class="reqn">N</code> be the number of clusters and <code class="reqn">R_i</code> the similarity between the i'th cluster and
the cluster most similar to it.
The DB index is calculated as the mean similarity between each cluster and the most similar cluster,
</p>
<p style="text-align: center;"><code class="reqn">DB = \frac{1}{N}\sum_{i=1}^{N}R_i</code>
</p>

<p>Thus, <code class="reqn">R_i</code> is the maximum similarity among all possible combinations of
<code class="reqn">R_ij</code>, with <code class="reqn">i \neq j</code>.
</p>
<p>To get <code class="reqn">R_ij</code>, let <code class="reqn">S_i</code> be the intra-cluster dispersion of <code class="reqn">i</code>,
<code class="reqn">S_j</code> be the intra-cluster dispersion of cluster <code class="reqn">j</code> and <code class="reqn">M_ij</code> be the
distance between clusters <code class="reqn">i</code> and <code class="reqn">j</code>.
</p>
<p>The similarity between any two clusters, <code class="reqn">i</code> and <code class="reqn">j</code>, is:
</p>
<p style="text-align: center;"><code class="reqn"> R_{ij} = \frac{S_i + S_j}{M_ij}</code>
</p>

<p>The distance between any two clusters, <code class="reqn">M_ij</code>, is measured as the
distance between the
centroids of both clusters, <code class="reqn">\left\lvert C_i - C_j \right\rvert</code>.
</p>
<p>The dispersion of clusters, <code class="reqn">S_i</code>, provides a sense of intra-dispersion
of a given cluster.
</p>
<p>To calculate <code class="reqn">S_i</code>, let <code class="reqn">T_i</code> and <code class="reqn">T_j</code> be the number of
observations in <code class="reqn">i</code> and <code class="reqn">j</code>, respectively; let <code class="reqn">X_j</code> be the value for
j'th observation (again, <code class="reqn">i \neq j</code>).
</p>
<p style="text-align: center;"><code class="reqn">S_i = \sqrt{\frac{1}{T_i}\sum_{j=1}^{T_i}\left\lvert X_j - C_i \right\rvert}</code>
</p>

<p><strong>Note</strong> that this is the case for euclidean distances.
</p>


<h3>Value</h3>

<p>A vector or plot with Davies-Bouldin index for each pre-specified k in a given sample.
</p>


<h3>References</h3>

<p>Davies, D. L., &amp; Bouldin, D. W. (1979). A Cluster Separation Measure. IEEE Transactions on Pattern Analysis and Machine Intelligence, PAMI-1(2).
</p>


<h3>See Also</h3>

<p><code><a href="clusterSim.html#topic+index.DB">clusterSim::index.DB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
# Just scores
check_DB(nice_tidy, sample_id = "ERR2044662")

# To change range
check_DB(nice_tidy, sample_id = "ERR2044662", range = 4:11)

# To see a simple plot
check_DB(nice_tidy, sample_id = "ERR2044662", range = 4:11, with_plot=TRUE)


</code></pre>

<hr>
<h2 id='define_rb'>Define Rare Biosphere</h2><span id='topic+define_rb'></span>

<h3>Description</h3>

<p>Classifies species in each sample into either &quot;Rare&quot;, &quot;Undetermined&quot; or &quot;Abundant&quot;. Other classifications are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_rb(
  data,
  classification_vector = c("Rare", "Undetermined", "Abundant"),
  samples_col = "Sample",
  abundance_col = "Abundance",
  simplified = FALSE,
  automatic = FALSE,
  index = "Average Silhouette Score",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_rb_+3A_data">data</code></td>
<td>
<p>A tibble with, at least, a column for Abundance and Sample. Additional columns are allowed.</p>
</td></tr>
<tr><td><code id="define_rb_+3A_classification_vector">classification_vector</code></td>
<td>
<p>A vector of strings with the names for each cluster, from lower to higher abundance. Default is c(&quot;Rare&quot;, &quot;Undetermined&quot;, &quot;Abundance&quot;).</p>
</td></tr>
<tr><td><code id="define_rb_+3A_samples_col">samples_col</code></td>
<td>
<p>String with name of column with sample names.</p>
</td></tr>
<tr><td><code id="define_rb_+3A_abundance_col">abundance_col</code></td>
<td>
<p>String with name of column with abundance values.</p>
</td></tr>
<tr><td><code id="define_rb_+3A_simplified">simplified</code></td>
<td>
<p>Can be TRUE/FALSE. Default (FALSE) provides an additional column with detailed pam() results
and Silhouette scores. If TRUE, only the Classification result is added to the original input data.</p>
</td></tr>
<tr><td><code id="define_rb_+3A_automatic">automatic</code></td>
<td>
<p>By default (FALSE), will assume a classification into &quot;Rare&quot;, &quot;Undetermined&quot; or &quot;Abundant&quot;. If TRUE, then it will automatically select the number of classifications (or k),
based on the index argument.</p>
</td></tr>
<tr><td><code id="define_rb_+3A_index">index</code></td>
<td>
<p>Index used to select best k. Can be one of: &quot;Average Silhouette Score&quot;, &quot;Davies-Bouldin&quot; or &quot;Calinsky-Harabasz&quot;.</p>
</td></tr>
<tr><td><code id="define_rb_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Overview</strong>
</p>
<p>Function to cluster species abundance with partition around medoids algorithm (Kaufman and Rousseuw. 1991).
By default, we propose the division into three clusters (k = 3),
which can have the convenient description of: &quot;rare&quot;, &quot;undetermined&quot; and &quot;abundant&quot;.
The phylogenetic units from the cluster with lowest median abundance is considered
to be the &quot;rare biosphere&quot;.
</p>
<p><strong>The classification vector</strong>
</p>
<p>The classification vector (argument classification_vector) represents the
different clusters to be used, by ascending order of median abundance.
To change the number of clusters, change the number of elements in the
classification vector, <strong>but order matters!</strong> Depending on the number of clusters used,
you can change the meaning that best applies to your research.
</p>
<p>For example, you can use a classification vector with the designations: &quot;very rare&quot;, &quot;rare&quot;,
&quot;abundant&quot; and &quot;very abundant&quot;; which would apply a k = 4 underneath.
It is possible to use any number of clusters, as long as they are within 2 and
the maximum possible k.
</p>
<p>The maximum possible k is the number of different abundance scores observed in a single sample. Note, however,
that we do not recommend any clustering for k &gt; 10
and we also don't recommend k = 2 (we explain in more detail in Pascoal et al., 2023;
and in the vignette <code>vignette("explore-classifications")</code>.
</p>
<p><strong>Automatic selection of the number of clusters</strong>
</p>
<p>To automatically decide the number of clusters (i.e., the value of k), it is possible to do so with the argument <strong>automatic=TRUE</strong>. For details on
complete automation of <code><a href="#topic+define_rb">define_rb()</a></code>, please see the documentation for <code><a href="#topic+suggest_k">suggest_k()</a></code>. Briefly, the k with best average Silhouette score
is selected from a range of k values between 3 and 10. It is possible to decide k based on other indices (&quot;Davies-Bouldin&quot; or &quot;Calinsky-Harabasz&quot;).
</p>
<p>If you want a more fine grained analysis of k values, we provide several functions:
</p>

<ul>
<li> <p><code><a href="#topic+evaluate_k">evaluate_k()</a></code>;
</p>
</li>
<li> <p><code><a href="#topic+check_avgSil">check_avgSil()</a></code>;
</p>
</li>
<li> <p><code><a href="#topic+check_DB">check_DB()</a></code>;
</p>
</li>
<li> <p><code><a href="#topic+check_CH">check_CH()</a></code>.
</p>
</li></ul>

<p><strong>Verify clustering results</strong>
</p>
<p>If half of the taxa of any cluster got a Silhouette score below 0.5 in any sample, then a warning is provided.
The warning provides the number of times this issue occurred.
You can inspect other alternatives to reduce the occurrences of a bad clustering,
but it is possible that, in some situations, you just can't find an optimal clustering.
</p>
<p>The detailed output gives you access to all of the clustering results:
</p>

<ul>
<li> <p><code>pam_object</code> is a list with the original results from the k-medoids clustering,
see <code><a href="cluster.html#topic+pam">cluster::pam()</a></code> documentation.
</p>
</li>
<li> <p><code>Level</code> is an integer indicating the specific cluster attributed by the <code><a href="cluster.html#topic+pam">cluster::pam()</a></code>
function for each observation. Its order is random.
</p>
</li>
<li> <p><code>Silhouette_scores</code> provides the Silhouette score obtained for each
observation, i.e. a score for each taxa.
</p>
</li>
<li> <p><code>Cluster_median_abundance</code> provides the median taxa abundance of each cluster.
</p>
</li>
<li> <p><code>median_Silhouette</code> provides the median Silhouette score obtained for each cluster.
</p>
</li>
<li> <p><code>Evaluation</code> indicates if the silhouette score obtained for a given observation
is below the median Silhouette of its cluster and sample.
</p>
</li></ul>

<p>You can make your own plots and analysis, but we also provide another function,
<code><a href="#topic+plot_ulrb">plot_ulrb()</a></code>, which illustrates the results obtained.
</p>
<p><strong>Partition around medoids (pam)</strong>
</p>
<p>To calculate k-medoids, we used the partition around medoids (pam)
algorithm, which was described in Chapter 2 of &quot;Finding Groups in Data: An Introduction to Cluster Analysis.&quot;
(Kaufman and Rousseeuw, 1991) and implemented by the cluster package with the <code><a href="cluster.html#topic+pam">cluster::pam()</a></code> function.
</p>
<p>Briefly, the pam algorithm is divided into two main phases: <strong>build</strong> and <strong>swap</strong>.
</p>
<p>The first phase (<strong>build</strong>) selects k observations as cluster representatives. The first
observation selected as representative is the one that minimizes the sum of the dissimilarities to the
remaining observations. The second, third and so on repeat the same process, until k clusters have
been formed.
</p>
<p>The <strong>build</strong> steps are:
</p>
<p>1 - Propose a centroid with observation, <code class="reqn">i</code>, which has not been selected as a centroid yet
</p>
<p>2 - Calculate the distance between another observation, <code class="reqn">j</code>, and its most similar
observation, <code class="reqn">D_j</code>; and calculate the difference with the proposed centroid,
<code class="reqn">i</code>, i.e., <code class="reqn">d(j,i)</code>
</p>
<p>3 - If <code class="reqn">d(j,i) &gt; 0</code>, then calculate its contribution to the centroid:
</p>
<p style="text-align: center;"><code class="reqn">max(D_j - d(j,i),0)</code>
</p>

<p>4 - Calculate the total gain obtained by <code class="reqn">i</code>, </p>
<p style="text-align: center;"><code class="reqn">\sum_{j}C_{ji}</code>
</p>

<p>5 - From all possible centroids, select the one that maximizes the previous total gain obtained,
</p>
<p style="text-align: center;"><code class="reqn">max_i \sum_jC_{ji}</code>
</p>

<p>6 - Repeat until k observations have been selected as cluster representatives.
</p>
<p>The purpose of the next phase, <strong>swap</strong>, is to improve the representatives
for the clusters. The principle is to swap the cluster representative between
all possibilities and calculate the value sum of dissimilarities between each
observation and the closest centroid. The swapping continues until no more improvement is
possible, i.e., when the minimum sum of dissimilarities of the clusters is reached.
</p>
<p><strong>Notes</strong>:
</p>
<p>Understand that <strong>ulrb</strong> package considers each sample as an independent
community of phylogenetic units, which means clustering is also independent across
different samples.
Thus, be aware that you will have clustering results and metrics for each
single sample,
which is why we also provide some functions to analyze results across
any number of samples (see: <code><a href="#topic+plot_ulrb">plot_ulrb()</a></code> for clustering results
and <code><a href="#topic+evaluate_k">evaluate_k()</a></code> for k selection).
</p>


<h3>Value</h3>

<p>The input data.frame with extra columns containing the classification and additional metrics (if detailed = TRUE).
</p>


<h3>References</h3>

<p>Kaufman, L., &amp; Rousseuw, P. J. (1991). Chapter 2 in book Finding Groups in Data: An Introduction to Cluster Analysis. Biometrics, 47(2), 788.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+suggest_k">suggest_k()</a></code>, <code><a href="#topic+evaluate_k">evaluate_k()</a></code>, <code><a href="#topic+plot_ulrb">plot_ulrb()</a></code>, <code><a href="cluster.html#topic+pam">cluster::pam()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
# Sample ID's
sample_names &lt;- c("ERR2044662", "ERR2044663", "ERR2044664",
                   "ERR2044665", "ERR2044666", "ERR2044667",
                   "ERR2044668", "ERR2044669", "ERR2044670")

# If data is in wide format, with samples in cols
nice_tidy &lt;- prepare_tidy_data(nice,
                               sample_names = sample_names,
                               samples_in = "cols")

# Straightforward with tidy format
define_rb(nice_tidy)

#Closer look
classified_table &lt;- define_rb(nice_tidy)
classified_table %&gt;%
select(Sample, Abundance, Classification) %&gt;%
head()


# Automatic decision, instead of a predefined definition
define_rb(nice_tidy, automatic = TRUE) %&gt;% select(Sample, Abundance, Classification)

# Automatic decision, using Davies-Bouldin index,
# instead of average Silhouette score (default)
define_rb(nice_tidy, automatic = TRUE, index = "Davies-Bouldin") %&gt;%
select(Sample, Abundance, Classification)

# User defined classifications
user_classifications &lt;- c("very rare",
                          "rare",
                          "undetermined",
                          "abundant",
                          "very abundant")

define_rb(nice_tidy, classification_vector = user_classifications) %&gt;%
select(Sample, Abundance, Classification)

# Easy to incorporate in big pipes
# Remove Archaea
# Remove taxa below 10 reads
# Classify according to a different set of classifications
nice_tidy %&gt;%
 filter(Domain != "sk__Archaea") %&gt;%
 filter(Abundance &gt; 10) %&gt;%
 define_rb(classification_vector = c("very rare",
                                     "rare",
                                     "abundant",
                                     "very abundant")) %&gt;%
 select(Sample, Abundance, Classification)

 # An example that summarises results
nice_tidy %&gt;%
 filter(Domain != "sk__Archaea") %&gt;%
 filter(Abundance &gt; 10) %&gt;%
 define_rb(classification_vector = c("very rare",
                                     "rare",
                                     "abundant",
                                     "very abundant")) %&gt;%
 select(Sample, Abundance, Classification) %&gt;%
 group_by(Sample, Classification) %&gt;%
 summarise(totalAbundance = sum(Abundance))

</code></pre>

<hr>
<h2 id='evaluate_k'>Evaluate k from all samples in a dataset</h2><span id='topic+evaluate_k'></span>

<h3>Description</h3>

<p>This function extends <code><a href="#topic+evaluate_sample_k">evaluate_sample_k()</a></code> for any number of samples in a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_k(
  data,
  range = 3:10,
  samples_col = "Sample",
  abundance_col = "Abundance",
  with_plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_k_+3A_data">data</code></td>
<td>
<p>a data.frame with, at least, the classification, abundance and sample information for each phylogenetic unit.</p>
</td></tr>
<tr><td><code id="evaluate_k_+3A_range">range</code></td>
<td>
<p>The range of values of k to test, default is from 3 to 10.</p>
</td></tr>
<tr><td><code id="evaluate_k_+3A_samples_col">samples_col</code></td>
<td>
<p>String with name of column with sample names.</p>
</td></tr>
<tr><td><code id="evaluate_k_+3A_abundance_col">abundance_col</code></td>
<td>
<p>string with name of column with abundance values. Default is &quot;Abundance&quot;.</p>
</td></tr>
<tr><td><code id="evaluate_k_+3A_with_plot">with_plot</code></td>
<td>
<p>If FALSE (default) returns a vector, but if TRUE will return a plot with the scores.</p>
</td></tr>
<tr><td><code id="evaluate_k_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot option (with_plot = TRUE) provides centrality metrics for all samples used.
</p>
<p>For more details on indices calculation, please see the documentation for <code><a href="#topic+evaluate_sample_k">evaluate_sample_k()</a></code>, <code><a href="#topic+check_DB">check_DB()</a></code>,
<code><a href="#topic+check_CH">check_CH()</a></code> and <code><a href="#topic+check_avgSil">check_avgSil()</a></code>.
</p>


<h3>Value</h3>

<p>A nested data.frame (or a plot) with three indices for each k and for each sample.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate_sample_k">evaluate_sample_k()</a></code>, <code><a href="#topic+check_DB">check_DB()</a></code>, <code><a href="#topic+check_CH">check_CH()</a></code>, <code><a href="#topic+check_avgSil">check_avgSil()</a></code>, <code><a href="#topic+suggest_k">suggest_k()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

#' evaluate_k(nice_tidy)


# To make simple plot
evaluate_k(nice_tidy, range = 4:11, with_plot =TRUE)


</code></pre>

<hr>
<h2 id='evaluate_sample_k'>Evaluate sample k</h2><span id='topic+evaluate_sample_k'></span>

<h3>Description</h3>

<p>This functions calculates three indices (Davies-Bouldin, Calinsky-Harabasz and average Silhouette score) for each k.
Calculations are made for a single sample and for a default range of k that goes from 3 to 10.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_sample_k(
  data,
  sample_id,
  samples_col = "Sample",
  abundance_col = "Abundance",
  range = 3:10,
  with_plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_sample_k_+3A_data">data</code></td>
<td>
<p>a data.frame with, at least, the classification, abundance and sample information for each phylogenetic unit.</p>
</td></tr>
<tr><td><code id="evaluate_sample_k_+3A_sample_id">sample_id</code></td>
<td>
<p>String with name of the sample to apply this function.</p>
</td></tr>
<tr><td><code id="evaluate_sample_k_+3A_samples_col">samples_col</code></td>
<td>
<p>String with name of column with sample names.</p>
</td></tr>
<tr><td><code id="evaluate_sample_k_+3A_abundance_col">abundance_col</code></td>
<td>
<p>string with name of column with abundance values. Default is &quot;Abundance&quot;.</p>
</td></tr>
<tr><td><code id="evaluate_sample_k_+3A_range">range</code></td>
<td>
<p>The range of values of k to test, default is from 3 to 10.</p>
</td></tr>
<tr><td><code id="evaluate_sample_k_+3A_with_plot">with_plot</code></td>
<td>
<p>If FALSE (default) returns a vector, but if TRUE will return a plot with the scores.</p>
</td></tr>
<tr><td><code id="evaluate_sample_k_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Note</strong>: To get the indices for all samples, use <code><a href="#topic+evaluate_k">evaluate_k()</a></code> instead.
</p>
<p><strong>Data input</strong>
</p>
<p>This function takes a data.frame with a column for samples and a column for abundance
(minimum), but can take any number of other columns. It will then filter the specific sample
that you want to analyze. You can also pre-filter for your specific sample, but you still need to
provide the sample ID (sample_id) and the table always needs a column for Sample and another for Abundance
(indicate how you name them with the arguments samples_col and abundance_col).
</p>
<p><strong>Output options</strong>
</p>
<p>The default option returns a data.frame with Davies-Bouldin, Calinsky-Harabasz and
average Silhouette scores for each k. This is a simple output that can then be used
for other analysis. However, we also provide the option to show a plot (set <code>with_plot = TRUE</code>).
</p>
<p><strong>Three indices are calculated by this function:</strong>
</p>

<ul>
<li><p> Davies-Bouldin with <code><a href="#topic+check_DB">check_DB()</a></code>;
</p>
</li>
<li><p> Calinsky-Harabasz with <code><a href="#topic+check_DB">check_DB()</a></code>;
</p>
</li>
<li><p> average Silhouette score <code><a href="#topic+check_avgSil">check_avgSil()</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A data.frame (or plot) with several indices for each number of clusters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_CH">check_CH()</a></code>, <code><a href="#topic+check_DB">check_DB()</a></code>, <code><a href="#topic+check_avgSil">check_avgSil()</a></code>, <code><a href="#topic+suggest_k">suggest_k()</a></code>, <code><a href="#topic+evaluate_k">evaluate_k()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
#
evaluate_sample_k(nice_tidy, sample_id = "ERR2044662")

# To change range
evaluate_sample_k(nice_tidy, sample_id = "ERR2044662", range = 4:11)

# To make simple plot
evaluate_sample_k(nice_tidy, sample_id = "ERR2044662", range = 4:11, with_plot =TRUE)

</code></pre>

<hr>
<h2 id='nice'>V4-V5 16S rRNA gene amplicons, clean OTU table (N-ICE, 2015)</h2><span id='topic+nice'></span>

<h3>Description</h3>

<p>Table in &quot;wide&quot; format with abundance and taxonomic classification of each OTU.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nice
</code></pre>


<h3>Format</h3>



<h4><code>nice</code></h4>

<p>A data frame with 524 rows and 17 columns:
</p>

<dl>
<dt>ERR2044662,
ERR2044663,
ERR2044664,
ERR2044665,
ERR2044666,
ERR2044667,
ERR2044668,
ERR2044669 and
ERR2044670</dt><dd><p>Sample ID</p>
</dd>
<dt>OTU</dt><dd><p>OTU ID</p>
</dd>
<dt>Domain</dt><dd><p>Domain level classification of OTU</p>
</dd>
<dt>Phylum</dt><dd><p>Phylum level classification of OTU</p>
</dd>
<dt>Class</dt><dd><p>Class level classification of OTU</p>
</dd>
<dt>Order</dt><dd><p>Order level classification of OTU</p>
</dd>
<dt>Family</dt><dd><p>Family level classification of OTU</p>
</dd>
<dt>Genus</dt><dd><p>Genus level classification of OTU</p>
</dd>
<dt>Species</dt><dd><p>Species level classification of OTU</p>
</dd>
</dl>
<p>...

</p>



<h3>Details</h3>

<p>This OTU table was cleaned so that it only includes samples from 16S rRNA amplicon sequencing
and no eukaryotes (similarly to Pascoal et al., 2022). Additionally, we added a column with a ID for each OTU.
</p>
<p>For details on raw data, see <a href="#topic+nice_raw">nice_raw</a>
</p>


<h3>Source</h3>

<p><a href="https://www.ebi.ac.uk/metagenomics/studies/MGYS00001922#analysis">https://www.ebi.ac.uk/metagenomics/studies/MGYS00001922#analysis</a>
</p>


<h3>References</h3>


<ul>
<li><p> Pascoal, F., Costa, R., Assmy, P., Duarte, P., &amp; Magalhães, C. (2022). Exploration of the Types of Rarity in the Arctic Ocean from the Perspective of Multiple Methodologies. Microbial Ecology, 84(1), 59–72. https://doi.org/10.1007/s00248-021-01821-9
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+nice_tidy">nice_tidy()</a></code>, <a href="#topic+nice_raw">nice_raw</a>, <a href="#topic+nice_env">nice_env</a>
</p>

<hr>
<h2 id='nice_env'>Metadata of samples from OTU tables (N-ICE, 2015)</h2><span id='topic+nice_env'></span>

<h3>Description</h3>

<p>This dataset provides information on the samples used for the N-ICE dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nice_env
</code></pre>


<h3>Format</h3>



<h4><code>nice_tidy</code></h4>

<p>A data frame with 4716 rows and 10 columns:
</p>

<dl>
<dt>Sample</dt><dd><p>Sample ID used in the original study</p>
</dd>
<dt>ENA_ID</dt><dd><p>Sample ID equivalent to Sample in the OTU table</p>
</dd>
<dt>Month</dt><dd><p>Month of sampling</p>
</dd>
<dt>Region</dt><dd><p>Ocean region of sampling event</p>
</dd>
<dt>Water.mass</dt><dd><p>Water mass of sampling event</p>
</dd>
<dt>Latitude</dt><dd><p>Latitude of sampling event</p>
</dd>
<dt>Longitude</dt><dd><p>Longitude of sampling event</p>
</dd>
</dl>




<h3>Details</h3>

<p>Based on de Sousa et al., 2019.
</p>


<h3>Source</h3>

<p><a href="https://link.springer.com/article/10.1007/s00248-021-01821-9">https://link.springer.com/article/10.1007/s00248-021-01821-9</a>
</p>


<h3>References</h3>


<ul>
<li><p> de Sousa, A. G. G., Tomasino, M. P., Duarte, P., Fernández-Méndez, M., Assmy, P., Ribeiro, H., Surkont, J., Leite, R. B., Pereira-Leal, J. B., Torgo, L., &amp; Magalhães, C. (2019). Diversity and Composition of Pelagic Prokaryotic and Protist Communities in a Thin Arctic Sea-Ice Regime. Microbial Ecology, 78(2), 388–408.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+nice">nice</a>, <a href="#topic+nice_raw">nice_raw</a>, <a href="#topic+nice_tidy">nice_tidy</a>
</p>

<hr>
<h2 id='nice_raw'>V4-V5 16S rRNA gene amplicons, raw OTU table (N-ICE, 2015)</h2><span id='topic+nice_raw'></span>

<h3>Description</h3>

<p>This is the &quot;raw&quot; data for the N-ICE dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nice_raw
</code></pre>


<h3>Format</h3>



<h4><code>nice_raw</code></h4>

<p>A data frame with 524 rows and 17 columns:
</p>

<dl>
<dt>ERR2044662,
ERR2044663,
ERR2044664,
ERR2044665,
ERR2044666,
ERR2044667,
ERR2044668,
ERR2044669 and
ERR2044670</dt><dd><p>Sample ID</p>
</dd>
<dt>OTU</dt><dd><p>OTU ID</p>
</dd>
<dt>Domain</dt><dd><p>Domain level classification of OTU</p>
</dd>
<dt>Phylum</dt><dd><p>Phylum level classification of OTU</p>
</dd>
<dt>Class</dt><dd><p>Class level classification of OTU</p>
</dd>
<dt>Order</dt><dd><p>Order level classification of OTU</p>
</dd>
<dt>Family</dt><dd><p>Family level classification of OTU</p>
</dd>
<dt>Genus</dt><dd><p>Genus level classification of OTU</p>
</dd>
<dt>Species</dt><dd><p>Species level classification of OTU</p>
</dd>
</dl>
<p>...

</p>



<h3>Details</h3>

<p>The original sequencing results are available at European Nucleotide Archive
(accession number: PRJEB15043). Those reads were processed into OTUs
by MGnify platform (Study: MGYS00001922). The later study accession provides the
table used in here.
</p>
<p>This table contains the taxonomy and an abundance score for each taxonomic lineage, which
we will refer to as &quot;OTU&quot; (Operational OTU) for simplicity sake.
</p>
<p>For details on the sampling campaign in the Arctic ocean, sequencing protocols and
bioinformatic processing, please see ref (de Sousa et al., 2019).
</p>


<h3>Source</h3>

<p><a href="https://www.ebi.ac.uk/metagenomics/studies/MGYS00001922#analysis">https://www.ebi.ac.uk/metagenomics/studies/MGYS00001922#analysis</a>
</p>


<h3>References</h3>


<ul>
<li><p> de Sousa, A. G. G., Tomasino, M. P., Duarte, P., Fernández-Méndez, M., Assmy, P., Ribeiro, H., Surkont, J., Leite, R. B., Pereira-Leal, J. B., Torgo, L., &amp; Magalhães, C. (2019). Diversity and Composition of Pelagic Prokaryotic and Protist Communities in a Thin Arctic Sea-Ice Regime. Microbial Ecology, 78(2), 388–408. https://doi.org/10.1007/s00248-018-01314-2
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+nice">nice()</a></code>, <a href="#topic+nice_tidy">nice_tidy</a>, <a href="#topic+nice_env">nice_env</a>
</p>

<hr>
<h2 id='nice_tidy'>V4-V5 16S rRNA gene amplicons, clean OTU table in tidy/long format (N-ICE, 2015)</h2><span id='topic+nice_tidy'></span>

<h3>Description</h3>

<p>Original OTU table (<a href="#topic+nice">nice</a>) in &quot;long&quot; format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nice_tidy
</code></pre>


<h3>Format</h3>



<h4><code>nice_tidy</code></h4>

<p>A data frame with 4716 rows and 10 columns:
</p>

<dl>
<dt>Sample</dt><dd><p>Sample ID</p>
</dd>
<dt>Abundance</dt><dd><p>Abundance</p>
</dd>
<dt>OTU</dt><dd><p>OTU ID</p>
</dd>
<dt>Domain</dt><dd><p>Domain level classification of OTU</p>
</dd>
<dt>Phylum</dt><dd><p>Domain level classification of OTU</p>
</dd>
<dt>Class</dt><dd><p>Domain level classification of OTU</p>
</dd>
<dt>Order</dt><dd><p>Domain level classification of OTU</p>
</dd>
<dt>Family</dt><dd><p>Domain level classification of OTU</p>
</dd>
<dt>Genus</dt><dd><p>Domain level classification of OTU</p>
</dd>
<dt>Species</dt><dd><p>Domain level classification of OTU</p>
</dd>
</dl>
<p>...

</p>



<h3>Details</h3>

<p>A new column (Sample) includes the sample identifiers and a new column
(Abundance) includes the abundance for each OTU.
For details on OTU table processing see help pages for <a href="#topic+nice">nice</a> and <a href="#topic+nice_raw">nice_raw</a>.
</p>
<p>Some details on N-ICE dataset:
</p>
<p>This dataset resulted from the Norwegian Young Sea Ice expedition (N-ICE)
in 2015 (Granskog et al., 2018). The sample processing and DNA sequencing
were described in de Sousa et al., 2019, the bioinformatic processing was
performed by the MGnify platform (v5) (Mitchell et al., 2020).
</p>
<p>Since the purpose of this dataset if for creating examples and testing the package,
we did not apply strict quality control to the final OTU table. Thus, we
didn't remove singletons, etc. However, we did remove any
non-prokarotic OTUs and organelles, if any (Pascoal et al., 2022).
</p>


<h3>Source</h3>

<p><a href="https://www.ebi.ac.uk/metagenomics/studies/MGYS00001922#analysis">https://www.ebi.ac.uk/metagenomics/studies/MGYS00001922#analysis</a>
</p>


<h3>References</h3>


<ul>
<li><p> Mitchell, A. L., Almeida, A., Beracochea, M., Boland, M., Burgin, J., Cochrane, G., Crusoe, M. R., Kale, V., Potter, S. C., Richardson, L. J., Sakharova, E., Scheremetjew, M., Korobeynikov, A., Shlemov, A., Kunyavskaya, O., Lapidus, A., &amp; Finn, R. D. (2019). MGnify: the microbiome analysis resource in 2020. Nucleic Acids Research, 48(D1), D570–D578.
</p>
</li>
<li><p> Granskog, M. A., Fer, I., Rinke, A., &amp; Steen, H. (2018). Atmosphere-Ice-Ocean-Ecosystem Processes in a Thinner Arctic Sea Ice Regime: The Norwegian Young Sea ICE (N-ICE2015) Expedition. Journal of Geophysical Research: Oceans, 123(3), 1586–1594.
</p>
</li>
<li><p> de Sousa, A. G. G., Tomasino, M. P., Duarte, P., Fernández-Méndez, M., Assmy, P., Ribeiro, H., Surkont, J., Leite, R. B., Pereira-Leal, J. B., Torgo, L., &amp; Magalhães, C. (2019). Diversity and Composition of Pelagic Prokaryotic and Protist Communities in a Thin Arctic Sea-Ice Regime. Microbial Ecology, 78(2), 388–408.
</p>
</li>
<li><p> Pascoal, F., Costa, R., Assmy, P., Duarte, P., &amp; Magalhães, C. (2022). Exploration of the Types of Rarity in the Arctic Ocean from the Perspective of Multiple Methodologies. Microbial Ecology, 84(1), 59–72.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+nice">nice()</a></code>, <a href="#topic+nice_raw">nice_raw</a>, <a href="#topic+nice_env">nice_env</a>
</p>

<hr>
<h2 id='plot_ulrb'>Plot ulrb clustering results and silhouette scores</h2><span id='topic+plot_ulrb'></span>

<h3>Description</h3>

<p>Function to help access clustering results from ulrb.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ulrb(
  data,
  sample_id = NULL,
  taxa_col,
  plot_all = FALSE,
  silhouette_score = "Silhouette_scores",
  classification_col = "Classification",
  abundance_col = "Abundance",
  log_scaled = FALSE,
  colors = c("#009E73", "#F0E442", "#CC79A7"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ulrb_+3A_data">data</code></td>
<td>
<p>a data.frame with, at least, the classification, abundance and sample information for each phylogenetic unit.</p>
</td></tr>
<tr><td><code id="plot_ulrb_+3A_sample_id">sample_id</code></td>
<td>
<p>string with name of selected sample.</p>
</td></tr>
<tr><td><code id="plot_ulrb_+3A_taxa_col">taxa_col</code></td>
<td>
<p>string with name of column with phylogenetic units. Usually OTU or ASV.</p>
</td></tr>
<tr><td><code id="plot_ulrb_+3A_plot_all">plot_all</code></td>
<td>
<p>If TRUE, will make a plot for all samples with mean and standard deviation. If FALSE (default), then the plot will illustrate a single sample, that you have to specifiy in sample_id argument.</p>
</td></tr>
<tr><td><code id="plot_ulrb_+3A_silhouette_score">silhouette_score</code></td>
<td>
<p>string with column name with silhouette score values. Default is &quot;Silhouette_scores&quot;</p>
</td></tr>
<tr><td><code id="plot_ulrb_+3A_classification_col">classification_col</code></td>
<td>
<p>string with name of column with classification for each row. Default value is &quot;Classification&quot;.</p>
</td></tr>
<tr><td><code id="plot_ulrb_+3A_abundance_col">abundance_col</code></td>
<td>
<p>string with name of column with abundance values. Default is &quot;Abundance&quot;.</p>
</td></tr>
<tr><td><code id="plot_ulrb_+3A_log_scaled">log_scaled</code></td>
<td>
<p>if TRUE then abundance scores will be shown in Log10 scale. Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot_ulrb_+3A_colors">colors</code></td>
<td>
<p>vector with colors. Should have the same lenght as the number of classifications.</p>
</td></tr>
<tr><td><code id="plot_ulrb_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combined <code><a href="#topic+plot_ulrb_clustering">plot_ulrb_clustering()</a></code> and <code><a href="#topic+plot_ulrb_silhouette">plot_ulrb_silhouette()</a></code>.
The plots can be done for a single sample or for all samples.
</p>
<p>The results from the main function of ulrb package, <code><a href="#topic+define_rb">define_rb()</a></code>, will include the classification of
each species (OTU, ASVs, etc) and the silhouette score obtained for each observation. Thus, to access the clustering results, there are two main plots to check:
</p>

<ul>
<li><p> the rank abundance curve obtained after ulrb classification;
</p>
</li>
<li><p> and the silhouette plot.
</p>
</li></ul>

<p><strong>Interpretation of Silhouette plot</strong>
</p>
<p>Based on chapter 2 of &quot;Finding Groups in Data: An Introduction to Cluster Analysis.&quot;
(Kaufman and Rousseeuw, 1991); a possible (<strong>subjective</strong>) interpretation of the clustering structure based
on the Silhouette plot is:
</p>

<ul>
<li><p> 0.71-1.00 (A strong structure has been found);
</p>
</li>
<li><p> 0.51-0.70 (A reasonable structure has been found);
</p>
</li>
<li><p> 0.26-0.50 (The structure is weak and could be artificial);
</p>
</li>
<li><p> &lt;0.26 (No structure has been found).
</p>
</li></ul>



<h3>Value</h3>

<p>A grid of ggplot objects with clustering results and
silhouette plot obtained from <code><a href="#topic+define_rb">define_rb()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+define_rb">define_rb()</a></code>, <code><a href="#topic+check_avgSil">check_avgSil()</a></code>, <code><a href="#topic+plot_ulrb_clustering">plot_ulrb_clustering()</a></code>, <code><a href="#topic+plot_ulrb_silhouette">plot_ulrb_silhouette()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
classified_species &lt;- define_rb(nice_tidy)

# Default parameters for a single sample ERR2044669
plot_ulrb(classified_species,
          sample_id = "ERR2044669",
          taxa_col = "OTU",
          abundance_col = "Abundance")

# All samples in a dataset
plot_ulrb(classified_species,
          taxa_col = "OTU",
          abundance_col = "Abundance",
          plot_all = TRUE)

# All samples with a log scale
plot_ulrb(classified_species,
          taxa_col = "OTU",
          abundance_col = "Abundance",
          plot_all = TRUE,
          log_scaled = TRUE)

</code></pre>

<hr>
<h2 id='plot_ulrb_clustering'>Plot Rank Abundance Curve of classification results</h2><span id='topic+plot_ulrb_clustering'></span>

<h3>Description</h3>

<p>Plots the clustering results from <code><a href="#topic+define_rb">define_rb()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ulrb_clustering(
  data,
  sample_id = NULL,
  taxa_col,
  plot_all = FALSE,
  samples_col = "Sample",
  classification_col = "Classification",
  abundance_col = "Abundance",
  log_scaled = FALSE,
  colors = c("#009E73", "#F0E442", "#CC79A7"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ulrb_clustering_+3A_data">data</code></td>
<td>
<p>a data.frame with, at least, the classification, abundance and sample information for each phylogenetic unit.</p>
</td></tr>
<tr><td><code id="plot_ulrb_clustering_+3A_sample_id">sample_id</code></td>
<td>
<p>string with name of selected sample.</p>
</td></tr>
<tr><td><code id="plot_ulrb_clustering_+3A_taxa_col">taxa_col</code></td>
<td>
<p>string with name of column with phylogenetic units. Usually OTU or ASV.</p>
</td></tr>
<tr><td><code id="plot_ulrb_clustering_+3A_plot_all">plot_all</code></td>
<td>
<p>If TRUE, will make a plot for all samples with mean and standard deviation. If FALSE (default), then the plot will illustrate a single sample, that you have to specifiy in sample_id argument.</p>
</td></tr>
<tr><td><code id="plot_ulrb_clustering_+3A_samples_col">samples_col</code></td>
<td>
<p>name of column with sample ID's.</p>
</td></tr>
<tr><td><code id="plot_ulrb_clustering_+3A_classification_col">classification_col</code></td>
<td>
<p>string with name of column with classification for each row. Default value is &quot;Classification&quot;.</p>
</td></tr>
<tr><td><code id="plot_ulrb_clustering_+3A_abundance_col">abundance_col</code></td>
<td>
<p>string with name of column with abundance values. Default is &quot;Abundance&quot;.</p>
</td></tr>
<tr><td><code id="plot_ulrb_clustering_+3A_log_scaled">log_scaled</code></td>
<td>
<p>if TRUE then abundance scores will be shown in Log10 scale. Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot_ulrb_clustering_+3A_colors">colors</code></td>
<td>
<p>vector with colors. Should have the same lenght as the number of classifications.</p>
</td></tr>
<tr><td><code id="plot_ulrb_clustering_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This works as a sanity check of the results obtained by the unsupervised learning method used
to classify species. This is specially important if you used an automatic number of clusters.
</p>
<p>The function works for either a single sample (that you specify with sample_id argument), or
it can apply a centrality metric for species across all your samples (plot_all = TRUE).
</p>


<h3>Value</h3>

<p>A ggplot object with clustering results from <code><a href="#topic+define_rb">define_rb()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+define_rb">define_rb()</a></code>, <code><a href="#topic+plot_ulrb">plot_ulrb()</a></code>, <code><a href="#topic+plot_ulrb_silhouette">plot_ulrb_silhouette()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>classified_species &lt;- define_rb(nice_tidy)

# Standard plot for a single sample
plot_ulrb_clustering(classified_species,
                       sample_id = "ERR2044669",
                       taxa_col = "OTU",
                       abundance_col = "Abundance")
# All samples in a dataset
plot_ulrb_clustering(classified_species,
          taxa_col = "OTU",
          abundance_col = "Abundance",
          plot_all = TRUE)

# All samples with a log scale
plot_ulrb_clustering(classified_species,
          taxa_col = "OTU",
          abundance_col = "Abundance",
          plot_all = TRUE,
          log_scaled = TRUE)

</code></pre>

<hr>
<h2 id='plot_ulrb_silhouette'>Plot silhouette scores from clustering results</h2><span id='topic+plot_ulrb_silhouette'></span>

<h3>Description</h3>

<p>Plots the Silhouette scores from the clustering results of <code><a href="#topic+define_rb">define_rb()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ulrb_silhouette(
  data,
  sample_id = NULL,
  taxa_col,
  samples_col = "Sample",
  plot_all = FALSE,
  classification_col = "Classification",
  silhouette_score = "Silhouette_scores",
  colors = c("#009E73", "#F0E442", "#CC79A7"),
  log_scaled = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ulrb_silhouette_+3A_data">data</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="plot_ulrb_silhouette_+3A_sample_id">sample_id</code></td>
<td>
<p>string with name of selected sample.</p>
</td></tr>
<tr><td><code id="plot_ulrb_silhouette_+3A_taxa_col">taxa_col</code></td>
<td>
<p>string with name of column with phylogenetic units. Usually OTU or ASV.</p>
</td></tr>
<tr><td><code id="plot_ulrb_silhouette_+3A_samples_col">samples_col</code></td>
<td>
<p>name of column with sample ID's.</p>
</td></tr>
<tr><td><code id="plot_ulrb_silhouette_+3A_plot_all">plot_all</code></td>
<td>
<p>If TRUE, will make a plot for all samples with mean and standard deviation. If FALSE (default), then the plot will illustrate a single sample, that you have to specifiy in sample_id argument.</p>
</td></tr>
<tr><td><code id="plot_ulrb_silhouette_+3A_classification_col">classification_col</code></td>
<td>
<p>string with name of column with classification for each row. Default value is &quot;Classification&quot;.</p>
</td></tr>
<tr><td><code id="plot_ulrb_silhouette_+3A_silhouette_score">silhouette_score</code></td>
<td>
<p>string with column name with silhouette score values. Default is &quot;Silhouette_scores&quot;</p>
</td></tr>
<tr><td><code id="plot_ulrb_silhouette_+3A_colors">colors</code></td>
<td>
<p>vector with colors. Should have the same lenght as the number of classifications.</p>
</td></tr>
<tr><td><code id="plot_ulrb_silhouette_+3A_log_scaled">log_scaled</code></td>
<td>
<p>if TRUE then abundance scores will be shown in Log10 scale. Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot_ulrb_silhouette_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This works as a sanity check of the results obtained by the unsupervised learning method used
to classify species. This is specially important if you used an automatic number of clusters.
</p>
<p>The function works for either a single sample (that you specify with sample_id argument), or
it can apply a centrality metric for species across all your samples (plot_all = TRUE).
</p>
<p>For more details on Silhouette score, see <code><a href="#topic+check_avgSil">check_avgSil()</a></code> and <code><a href="cluster.html#topic+silhouette">cluster::silhouette()</a></code>.
</p>
<p><strong>Interpretation of Silhouette plot</strong>
</p>
<p>Based on chapter 2 of &quot;Finding Groups in Data: An Introduction to Cluster Analysis.&quot;
(Kaufman and Rousseeuw, 1991); a possible (<strong>subjective</strong>) interpretation of the clustering structure based
on the Silhouette plot is:
</p>

<ul>
<li><p> 0.71-1.00 (A strong structure has been found);
</p>
</li>
<li><p> 0.51-0.70 (A reasonable structure has been found);
</p>
</li>
<li><p> 0.26-0.50 (The structure is weak and could be artificial);
</p>
</li>
<li><p> &lt; 0.26 (No structure has been found).
</p>
</li></ul>



<h3>Value</h3>

<p>A ggplot object of Silhouette plot obtained from the selected sample.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+define_rb">define_rb()</a></code>, <code><a href="#topic+check_avgSil">check_avgSil()</a></code>, <code><a href="#topic+plot_ulrb_clustering">plot_ulrb_clustering()</a></code>,
<code><a href="#topic+plot_ulrb">plot_ulrb()</a></code>, <code><a href="cluster.html#topic+silhouette">cluster::silhouette()</a></code>, <code><a href="cluster.html#topic+pam">cluster::pam()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
classified_species &lt;- define_rb(nice_tidy)

# Standard plot for a single sample
plot_ulrb_silhouette(classified_species,
                       sample_id = "ERR2044669",
                       taxa_col = "OTU",
                       abundance_col = "Abundance")
# All samples in a dataset
plot_ulrb_silhouette(classified_species,
          taxa_col = "OTU",
          abundance_col = "Abundance",
          plot_all = TRUE)

# All samples with a log scale
plot_ulrb_silhouette(classified_species,
          taxa_col = "OTU",
          abundance_col = "Abundance",
          plot_all = TRUE,
          log_scaled = TRUE)

</code></pre>

<hr>
<h2 id='prepare_tidy_data'>Prepare data in tidy format</h2><span id='topic+prepare_tidy_data'></span>

<h3>Description</h3>

<p>Function to transforms common abundance table formats into a &quot;long&quot; format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_tidy_data(data, sample_names, samples_in = "cols", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_tidy_data_+3A_data">data</code></td>
<td>
<p>a data.frame in &quot;wide&quot; format, with samples in either columns or rows. This data.frame should not include any data besides abundance values per sample, per taxonomic unit. Additional data (e.g. taxonomy details) should be added afterwards.</p>
</td></tr>
<tr><td><code id="prepare_tidy_data_+3A_sample_names">sample_names</code></td>
<td>
<p>a vector with the name of all samples.</p>
</td></tr>
<tr><td><code id="prepare_tidy_data_+3A_samples_in">samples_in</code></td>
<td>
<p>a vector specifying the location of the samples. It can either be &quot;cols&quot; (default) if samples are in columns, or &quot;rows&quot; if samples are in rows.</p>
</td></tr>
<tr><td><code id="prepare_tidy_data_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function guarantees that the abundance table includes one column with sample ID's and
one column with abundance.
</p>
<p><strong>Common species table formats</strong>
</p>
<p>There are two common formats for abundance tables:
</p>

<ul>
<li><p> samples as rows and phylogenetic units as columns;
</p>
</li>
<li><p> phylogenetic units as rows and samples as columns.
</p>
</li></ul>

<p>However, both formats are not tidy, because they include several columns with the same variable. They
are in a &quot;wide format&quot; instead of a &quot;long format&quot;.
</p>
<p>This function re-organizes samples and phylogenetic units so that there is a single column with the samples ID's and
another with the abundance scores; Extra columns are allowed.
</p>


<h3>Value</h3>

<p>An abundance table in long format, compatible with dplyr pipes and <strong>ulrb</strong> package functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+define_rb">define_rb()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
#
sample_names &lt;- c("ERR2044662", "ERR2044663", "ERR2044664",
                   "ERR2044665", "ERR2044666", "ERR2044667",
                   "ERR2044668", "ERR2044669", "ERR2044670")

# Example for samples in cols and with additional data available
prepare_tidy_data(nice, sample_names = sample_names, samples_in = "cols")

# Example for samples in rows
# Select columns with samples from nice
nice_rows &lt;- nice %&gt;% select(all_of(sample_names))

# Change columns to rows
nice_rows &lt;- nice_rows %&gt;% t() %&gt;% as.data.frame()

# Turn colnames into phylogenetic units ID
colnames(nice_rows) &lt;- paste0("OTU_", seq_along(colnames(nice_rows)))

prepare_tidy_data(nice_rows, sample_names = sample_names, samples_in = "rows")

</code></pre>

<hr>
<h2 id='suggest_k'>Suggest k</h2><span id='topic+suggest_k'></span>

<h3>Description</h3>

<p>Tool to help decide how many clusters to use for partition around medoids algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suggest_k(
  data,
  range = 3:10,
  samples_col = "Sample",
  abundance_col = "Abundance",
  index = "Average Silhouette Score",
  detailed = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suggest_k_+3A_data">data</code></td>
<td>
<p>a data.frame with, at least, the classification, abundance and sample information for each phylogenetic unit.</p>
</td></tr>
<tr><td><code id="suggest_k_+3A_range">range</code></td>
<td>
<p>The range of values of k to test, default is from 3 to 10.</p>
</td></tr>
<tr><td><code id="suggest_k_+3A_samples_col">samples_col</code></td>
<td>
<p>String with name of column with sample names.</p>
</td></tr>
<tr><td><code id="suggest_k_+3A_abundance_col">abundance_col</code></td>
<td>
<p>string with name of column with abundance values. Default is &quot;Abundance&quot;.</p>
</td></tr>
<tr><td><code id="suggest_k_+3A_index">index</code></td>
<td>
<p>Index used to select best k. Can be one of: &quot;Average Silhouette Score&quot;, &quot;Davies-Bouldin&quot; or &quot;Calinsky-Harabasz&quot;.</p>
</td></tr>
<tr><td><code id="suggest_k_+3A_detailed">detailed</code></td>
<td>
<p>If False (default) returns an integer with best overall k. If TRUE, returns a list with full details.</p>
</td></tr>
<tr><td><code id="suggest_k_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The best k is selected for each sample, based on the selected index.
If different k's are obtained for different samples (probable) then we
calculate the mean value of k and return it as an integer. Alternatively, we can
return a more detailed result in the form of a list.
</p>
<p><strong>Note</strong>: this function is used within <code><a href="#topic+define_rb">define_rb()</a></code>, with default parameters, for the
optional automatic selection of k.
</p>
<p><strong>Detailed option</strong>
</p>
<p>If <code>detailed = TRUE</code>, then the output is a list with information to help decide for k.
More specifically, the list will include:
</p>

<ul>
<li><p> A data.frame summarizing what information each index provides and how to interpret the value.
</p>
</li>
<li><p> A brief summary indicating the number of samples in the dataset and the range of k values used.
</p>
</li>
<li><p> A data.frame with the best k for each sample, based on each index.
</p>
</li></ul>

<p><strong>Automatic k selection</strong>
</p>
<p>If <code>detailed = FALSE</code>, this function will provide a single integer with the best k.
The <strong>default</strong> decision is based on the maximum average Silhouette score obtained
for the values of k between 3 and 10. To better understand why the average Silhouette score and
this range of k's were selected, we refer to Pascoal et al., 2023 (manuscript in preparation) and to
vignette(&quot;explore-classifications&quot;).
</p>
<p>Alternatively, this function can also provide the best k, as an integer, based on another index
(Davies-Bouldin and Calinsky-Harabasz) and can compare the entire of possible k's.
</p>


<h3>Value</h3>

<p>Integer indicating best k from selected index. Optionally, can return a list with details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate_k">evaluate_k()</a></code>, <code><a href="#topic+evaluate_sample_k">evaluate_sample_k()</a></code>, <code><a href="#topic+check_DB">check_DB()</a></code>, <code><a href="#topic+check_CH">check_CH()</a></code>, <code><a href="#topic+check_avgSil">check_avgSil()</a></code>, <code><a href="cluster.html#topic+pam">cluster::pam()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Get the best k with default parameters
suggest_k(nice_tidy)


# Get detailed results to decide for yourself
suggest_k(nice_tidy, detailed = TRUE, range = 2:7)

# Get best k, based on Davies-Bouldin index
suggest_k(nice_tidy, detailed = FALSE, index = "Davies-Bouldin")


</code></pre>

<hr>
<h2 id='ulrb-package'>
ulrb: Unsupervised Learning Based Definition of Microbial Rare Biosphere
</h2><span id='topic+ulrb-package'></span>

<h3>Description</h3>

<p>The R package ulrb stands for Unsupervised Machine Learning definition of the
Rare Biosphere. As the name suggests, it applies unsupervised learning principles
to define the rare biosphere.
</p>
<p>More specifically, the partitioning around medoids (k-medoids) algorithm is used
to divide phylogenetic units (ASVs, OTUs, Species, …) within a microbial community
(usually, a sample) into clusters. The clusters are then ordered based on a user-defined
classification vector. By default, our method classifies all phylogenetic units in one
of these: “rare”, “undetermined” or “abundant”. In alternative, we provide functions
to help the user decide the number of clusters and we also provide a fully automated
option. Besides clustering, we have functions to help you evaluate the clustering
quality (e.g. silhouette scores).
</p>
<p>For detailed theory behind our reasoning for this definition of the microbial rare biosphere,
results and applications, see our paper Pascoal et al., 2023 (in preparation).
For more details on the R functions used and data wrangling please see the package documentation.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Name: </td><td style="text-align: left;"> ulrb</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 0.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
    
      Date: </td><td style="text-align: left;"> 2023-11-13</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL 3</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p> Francisco Pascoal <a href="mailto:fpascoal1996@gmail.com">fpascoal1996@gmail.com</a>, Paula Branco
<a href="mailto:paobranco@gmail.com">paobranco@gmail.com</a>, Luis Torgo, Rodrigo Costa <a href="mailto:rodrigoscosta@tecnico.ulisboa.pt">rodrigoscosta@tecnico.ulisboa.pt</a>, Catarina Magalhães <a href="mailto:catarinamagalhaes1972@gmail.com">catarinamagalhaes1972@gmail.com</a>
</p>
<p>Maintainer:
Francisco Pascoal</p>


<h3>References</h3>

<p>Pascoal, F., Paula, B., Torgo, L., Costa, R., Magalhães, C. (2023) <em>Unsupervised machine learning definition of the microbial rare biosphere</em> Manuscript in preparation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
    library(ulrb)
    # nice is an OTU table in wide format
    head(nice)

    # first, we tidy the "nice" OTU table
    sample_names &lt;- c("ERR2044662", "ERR2044663", "ERR2044664",
                      "ERR2044665", "ERR2044666", "ERR2044667",
                      "ERR2044668", "ERR2044669", "ERR2044670")

    # If data is in wide format, with samples in cols
    nice_tidy &lt;- prepare_tidy_data(nice,
                                   sample_names = sample_names,
                                   samples_in = "cols")

    # second, we apply ulrb algorithm in automatic setting
    nice_classification_results &lt;- define_rb(nice_tidy)

    # third, we plot microbial community and the quality of k-medoids clustering
    plot_ulrb(nice_classification_results, taxa_col = "OTU", plot_all = TRUE)

    # In case you want to inspect the result of a particular sample, do:
    plot_ulrb(nice_classification_results, taxa_col = "OTU", sample_id = "ERR2044662")
        
  </code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
