<!DOCTYPE html><html lang="en"><head><title>Help for package potions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {potions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#potions'><p>potions: simple options management</p></a></li>
<li><a href='#brew'><p>Set up potions for easy data retrieval</p></a></li>
<li><a href='#drain'><p>Clear package options</p></a></li>
<li><a href='#potions-class'><p>Methods for <code>potions</code> data</p></a></li>
<li><a href='#pour'><p>Retrieve information stored using <code>potions::brew()</code></p></a></li>
<li><a href='#read_config'><p>Handle configuration data from a file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Easy Options Management</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Store and retrieve data from options() using syntax derived from
    the 'here' package. 'potions' makes it straightforward to update and 
    retrieve options, either in the workspace or during package development, 
    without overwriting global options.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>jsonlite, lobstr, purrr, rrapply, rlang, stringi, yaml</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, pkgload, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL-2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://potions.ala.org.au">https://potions.ala.org.au</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AtlasOfLivingAustralia/potions/issues">https://github.com/AtlasOfLivingAustralia/potions/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-23 03:01:41 UTC; wes186</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Westgate [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Westgate &lt;martin.westgate@csiro.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-23 04:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='potions'>potions: simple options management</h2><span id='topic+potions'></span><span id='topic+potions-package'></span>

<h3>Description</h3>

<p>Often it is useful to set bespoke options for a single workflow, or within
a single package, without altering global options that influence other
users or packages. This is possible <code>base::options()</code> and related functions,
however doing so requires some bespoke knowledge. <code>potions</code> makes options
management as easy as possible, by decreasing programmers' cognitive burden
while storing and retrieving information. It does this by following three
guiding principles:
</p>

<ul>
<li><p>minimalist: <code>potions</code> has only three core functions
</p>
</li>
<li><p>laconic: functions use as few characters as possible
</p>
</li>
<li><p>familiar: uses a UI for data retrieval based on the <code>{here}</code> package
</p>
</li></ul>

<p>In combination, these features should make it easy for users and developers
to manage options using <code>potions</code>.
</p>


<h3>Functions</h3>


<ul>
<li><p><code><a href="#topic+brew">brew()</a></code>: store data in <code>options()</code>
</p>
</li>
<li><p><code><a href="#topic+pour">pour()</a></code>: retrieve data from <code>options()</code>
</p>
</li>
<li><p><code><a href="#topic+drain">drain()</a></code>: remove data stored using <code><a href="#topic+brew">brew()</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin Westgate <a href="mailto:martin.westgate@csiro.au">martin.westgate@csiro.au</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://potions.ala.org.au">https://potions.ala.org.au</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/AtlasOfLivingAustralia/potions/issues">https://github.com/AtlasOfLivingAustralia/potions/issues</a>
</p>
</li></ul>


<hr>
<h2 id='brew'>Set up potions for easy data retrieval</h2><span id='topic+brew'></span><span id='topic+brew_package'></span><span id='topic+brew_interactive'></span>

<h3>Description</h3>

<p>Function to place a list into <code>options()</code>, or to update previously-stored
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brew(
  ...,
  file,
  .slot,
  .pkg,
  method = c("modify", "merge", "overwrite", "leaves")
)

brew_package(..., file, .pkg, method)

brew_interactive(..., file, .slot, method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brew_+3A_...">...</code></td>
<td>
<p>One or named arguments giving attributes to be stored; or
alternatively a <code>list</code> containing the same.</p>
</td></tr>
<tr><td><code id="brew_+3A_file">file</code></td>
<td>
<p>string: optional file containing data to be stored via <code>options()</code>.
Valid formats are <code>.yml</code> or <code>.json</code>.</p>
</td></tr>
<tr><td><code id="brew_+3A_.slot">.slot</code></td>
<td>
<p>string: optional name to mandate where data is stored. Defaults
to a random string generated by <code>stringi::stri_rand_strings()</code>.</p>
</td></tr>
<tr><td><code id="brew_+3A_.pkg">.pkg</code></td>
<td>
<p>string: package name that <code>potions</code> is being used within.
Typically only used during <code>onLoad()</code>, after which later calls do not
require this argument to be set.</p>
</td></tr>
<tr><td><code id="brew_+3A_method">method</code></td>
<td>
<p>string: How should new data be written to <code>options()</code>? See
details for specifics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method is to use <code>brew</code> without setting either <code>.pkg</code> or <code>.slot</code>
(but not both), and letting <code>potions</code> determine which slot to use. If greater
control is needed, you can use <code>brew_package()</code> or <code>brew_interactive()</code>.
Note that if neither <code>.slot</code> or <code>.pkg</code> are set, <code>potions</code> defaults to <code>.slot</code>
, unless <code>.pkg</code> information has previously been supplied (and <code>.slot</code>
information has not). This might be undesirable in a package development
situation.
</p>
<p>If both <code>...</code> and <code>file</code> arguments are empty, this function sets up an
empty <code>potions</code> object in <code>options("potions-pkg")</code>; See <code>potions-class</code> for
more information on this data type. If <code>...</code> and <code>file</code> arguments
are provided, they will be amalgamated using <code>purrr::list_modify()</code>. If there
are identical names in both lists, those in <code>...</code> are chosen.
</p>
<p>If the user repeatedly calls <code>brew()</code>, later list entries overwrite early
entries. Whole lists are not overwritten unless all top-level entry names
match, or <code>method</code> is set to <code>"overwrite"</code>, which is a shortcut to using
<code>drain()</code> before <code>brew()</code>. The default behaviour is <code>method = "modify"</code>,
which uses <code>purrr::list_modify()</code> to do the joining. Similarly <code>"merge"</code> uses
<code>purrr::list_merge()</code>. <code>method = "leaves"</code> only overwrites terminal nodes,
leaving the structure of the list otherwise unaffected. For non-nested lists,
this behaviour is identical to <code>"modify"</code>, but for nested lists it can be a
useful shortcut.
</p>


<h3>Value</h3>

<p>This function never returns an object; it is called for its' side-
effect of caching data using <code>options()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># basic usage is to pass arguments using `=`
brew(x = 1)

# lists are also permitted
list(x = 2) |&gt; brew()

# as are passing lists as objects
my_list &lt;- list(x = 3)
my_list |&gt; brew()

# or within a function
my_fun &lt;- function(){list(x = 1, y = 2)}
my_fun() |&gt; brew()

# optional clean-up
drain()
</code></pre>

<hr>
<h2 id='drain'>Clear package options</h2><span id='topic+drain'></span><span id='topic+drain_package'></span><span id='topic+drain_interactive'></span>

<h3>Description</h3>

<p>Clear options of previously specified content. In most cases, calling <code>drain</code>
with no arguments will be sufficient, but the arguments <code>.slot</code> and <code>.pkg</code>,
and their corresponding functions <code>drain_interactive()</code> and <code>drain_package()</code>
are provided in case greater control is needed. This is rarely needed for
packages, but it is possible to manually specify the use of multiple slots
when using <code>potions::brew()</code> interactively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drain(.slot, .pkg)

drain_package(.pkg)

drain_interactive(.slot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drain_+3A_.slot">.slot</code></td>
<td>
<p>(optional) slot to clear from <code>options()</code></p>
</td></tr>
<tr><td><code id="drain_+3A_.pkg">.pkg</code></td>
<td>
<p>(optional) package to clear from <code>options()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function is not vectorized, so passing multiple
values to <code>.slot</code> or <code>.pkg</code> will fail (e.g. <code>drain(.slot = c("x", "y"))</code>).
Similarly, passing arguments to both <code>.slot</code> and <code>.pkg</code> will fail.
</p>


<h3>Value</h3>

<p>This function never returns an object; it is called for its' side-
effect of removing data from <code>options()</code>.
</p>

<hr>
<h2 id='potions-class'>Methods for <code>potions</code> data</h2><span id='topic+potions-class'></span><span id='topic+create_potions'></span><span id='topic+print.potions'></span>

<h3>Description</h3>

<p>This package stores data in a list-like format, named class <code>potions</code>. It
contains three entries: <code>slots</code> contains data stored in 'interactive' mode;
<code>packages</code> contains data from packages built using <code>potions</code>; and <code>mapping</code>
stores data to understand the contents of the other two slots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_potions()

## S3 method for class 'potions'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="potions-class_+3A_x">x</code></td>
<td>
<p>An object of class <code>potions</code></p>
</td></tr>
<tr><td><code id="potions-class_+3A_...">...</code></td>
<td>
<p>Any further arguments to <code>print()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the case of <code>create_potions()</code>, an empty <code>potions</code> object.
<code>print.potions()</code> displays a <code>potions</code> object using <code>lobstr::tree()</code>.
</p>

<hr>
<h2 id='pour'>Retrieve information stored using <code>potions::brew()</code></h2><span id='topic+pour'></span><span id='topic+pour_package'></span><span id='topic+pour_interactive'></span><span id='topic+pour_all'></span>

<h3>Description</h3>

<p>This is the main function that most users will call on. It retrieves data
from a <code>potions</code> object stored using <code>brew()</code>. The UI for this function is
based on the <code>here</code> package, in that it uses list names separated by commas
to navigate through nested content. It differs from <code>here</code> in not requiring
those names to be quoted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pour(..., .slot, .pkg)

pour_package(..., .pkg)

pour_interactive(..., .slot)

pour_all()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pour_+3A_...">...</code></td>
<td>
<p>string: what slots should be returned</p>
</td></tr>
<tr><td><code id="pour_+3A_.slot">.slot</code></td>
<td>
<p>string: Optional manual override to default slot</p>
</td></tr>
<tr><td><code id="pour_+3A_.pkg">.pkg</code></td>
<td>
<p>string: Optional manual override to default package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Providing multiple arguments to <code>...</code> brings back nested values,
i.e. <code>pour("x", "y")</code> is for the case of an object structured as
<code>list(x = list(y = 1))</code>, rather than <code>list(x = 1, y = 2)</code>. For the latter
case it would be necessary to call with either no arguments
(<code>unlist(pour())</code>), or for greater control, call pour multiple times
specifying different entries each time (e.g. <code>z &lt;- c(pour("x"), pour("y"))</code>).
</p>
<p>Additional functions are provided in case greater specificity is required.
<code>pour_interactive(.slot = ...)</code> is synonymous with <code>pour(.slot = ...)</code>, while
<code>pour_package(.pkg = ...)</code> is synonymous with <code>pour(.pkg = ...)</code>.
<code>pour_all()</code> is a shortcut for <code>getOption("potions-pkg")</code>; i.e. to show all
data stored using <code>potions</code> by any package or slot, and does not accept any
arguments.
</p>


<h3>Value</h3>

<p>If no arguments are passed to <code>...</code>, returns a <code>list</code> from the
default slot. If <code>...</code> is supplied (correctly), then returns a <code>vector</code> of
values matching those names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first import some data
brew(x = 1, y = list(a = 2, b = 3))

# get all data
pour()

# get only data from slot x
pour("x")

# get nested data
pour("y", "a")

# optional clean-up
drain()
</code></pre>

<hr>
<h2 id='read_config'>Handle configuration data from a file</h2><span id='topic+read_config'></span>

<h3>Description</h3>

<p>This is primarily an internal function for importing configuration
information from a file. It is called by <code>brew()</code>, and detects <code>.yml</code> or
<code>.json</code> files by their file extentions; all the actual work is done by
<code>yaml::read_yaml</code> and <code>jsonlite::read_json</code> respectively. It is available as
an exported function so that users can check their data is being imported
correctly, and for developers who may wish to intercept configuration files
for checking purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_config(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_config_+3A_file">file</code></td>
<td>
<p>string: path to file. Readable formats are <code>.yml</code> and <code>.json</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing data from the specified file.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
