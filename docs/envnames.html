<!DOCTYPE html><html lang="en"><head><title>Help for package envnames</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {envnames}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#envnames-package'><p>Track user-defined environment names</p></a></li>
<li><a href='#address'><p>Call the C function address() that retrieves the memory address of an R object</p></a></li>
<li><a href='#check_environment'><p>Check whether a string corresponds to the name of an environment</p></a></li>
<li><a href='#check_object_exists'><p>Check if an object exists in a given environment</p></a></li>
<li><a href='#check_object_with_path'><p>Check if an object name contains a valid environment path</p></a></li>
<li><a href='#clean_up_matching_environments'><p>Clean up the list of environments matching a memory address in an environment map.</p></a></li>
<li><a href='#collapse_root_and_member'><p>Put together a root name with a member name</p></a></li>
<li><a href='#crawl_envs'><p>Crawl environments in search of user environments</p></a></li>
<li><a href='#crawl_envs_in_env'><p>Crawl an environment in search of user environments</p></a></li>
<li><a href='#destandardize_env_name'><p>De-standardize the name of an environment</p></a></li>
<li><a href='#environment_name'><p>Retrieve the name of an environment</p></a></li>
<li><a href='#extract_root_and_last_member'><p>Extract the last member in a string representing an object</p></a></li>
<li><a href='#get_env_names'><p>Create a lookup table with address-name pairs of environments</p></a></li>
<li><a href='#get_environment_name'><p>Get the name of an environment when the address-name lookup table has not yet been constructed</p></a></li>
<li><a href='#get_envs_in_env'><p>Find user environments inside another user environment</p></a></li>
<li><a href='#get_fun_calling'><p>Return the name of a calling function with its context or path</p></a></li>
<li><a href='#get_fun_calling_chain'><p>Return the chain of calling functions</p></a></li>
<li><a href='#get_fun_env'><p>Return the execution environment of a function</p></a></li>
<li><a href='#get_fun_name'><p>Return the name of the current function or a calling function in the chain</p></a></li>
<li><a href='#get_namespace_addresses'><p>Return the memory address of namespace environments in the search() list</p></a></li>
<li><a href='#get_namespace_names'><p>Return the names that can be used to load all the namespace environments in the search() list</p></a></li>
<li><a href='#get_obj_address'><p>Return the memory address of an object</p></a></li>
<li><a href='#get_obj_addresses_from_obj_names'><p>Get the object addresses given their object names</p></a></li>
<li><a href='#get_obj_name'><p>Return the name of an object at a given parent generation from an environment</p></a></li>
<li><a href='#get_obj_value'><p>Return the value of the object at a given parent generation leading to the specified object</p></a></li>
<li><a href='#get_objects_in_package'><p>Get the objects defined in a given package's namespace</p></a></li>
<li><a href='#get_searchpath_environment_addresses'><p>Return the system and package environments in the search path</p></a></li>
<li><a href='#get_user_environment_names_in_env'><p>Look for user environments defined inside an environment</p></a></li>
<li><a href='#get_user_environment_names_in_search_path'><p>Look for user environments defined inside any of the system/package environments</p>
of the search path</a></li>
<li><a href='#get_user_environments_in_user_envs_recursively'><p>Get the user environments defined recursively within the given user environments</p></a></li>
<li><a href='#is_logical'><p>Check whether an object contains a valid logical value</p></a></li>
<li><a href='#is_memory_address'><p>Check whether a string is a memory address</p></a></li>
<li><a href='#is_null_or_na'><p>Check whether an object is NULL or NA.</p></a></li>
<li><a href='#is_string'><p>Check whether an object is a string.</p></a></li>
<li><a href='#obj_find'><p>Find an object in the workspace including user-defined environments</p></a></li>
<li><a href='#parse_memory_address'><p>Parse a string that represents a memory address</p></a></li>
<li><a href='#reset_option_warn'><p>Resets the &quot;warn&quot; option to the value stored in the hidden variable .option_warn</p>
(set in global_definitions.r to the original value of the &quot;warn&quot; option when the package is loaded).</a></li>
<li><a href='#set_option_warn_to_nowarning'><p>Set the &quot;warn&quot; options to -1 to avoid warning messages. The hidden variable .option_warn</p>
defined in global_definitions.r has already been set to the original value of the &quot;warn&quot; option,
at the moment when the package is loaded, so that we can reset it later.</a></li>
<li><a href='#standardize_env_name'><p>Standardize the name of a named environment</p></a></li>
<li><a href='#testenv'><p>Environment used in testing the package</p></a></li>
<li><a href='#unlist_with_names'><p>Call unlist and preserve the names</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Keep Track of User-Defined Environment Names</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-12-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Mastropietro</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Mastropietro &lt;mastropi@uwalumni.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of functions to keep track and find objects in user-defined environments
    by identifying environments by name &ndash;which cannot be retrieved with the built-in function environmentName().
    The package also provides functionality to obtain simplified information about function calling chains
    and to get an object's memory address.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mastropi/envnames">https://github.com/mastropi/envnames</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mastropi/envnames/issues">https://github.com/mastropi/envnames/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-12-07 21:11:36 UTC; lundinmatlab</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-12-08 06:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='envnames-package'>Track user-defined environment names</h2><span id='topic+envnames-package'></span><span id='topic+envnames'></span>

<h3>Description</h3>

<p>The main goal of this package is to overcome the limitation of the built-in <code><a href="base.html#topic+environmentName">environmentName</a></code> function of the base package which cannot retrieve the name of an environment unless it is a package or the global environment. This implies that all user-defined environments don't have a &quot;name assigned&quot; that can be retrieved and refer to the environment.
</p>
<p>The envnames package solves this problem by creating a lookup table that maps environment names to their memory addresses. Using this lookup table, it is possible to retrieve the name of any environment where an object resides or, from within a function, to retrieve the calling stack showing the function names and their enclosing environment name, i.e. the environment where the functions have been defined. The latter can be done with just a function call which returns a string that can directly be used inside a <code>cat()</code> call to display the function name (as opposed to using the R function <code><a href="base.html#topic+sys.call">sys.call</a></code> which does not return a string, but a more complicated object, namely a <code>call</code> object from where the string with the function name is still to be extracted to be used inside <code>cat()</code>).
</p>
<p>Package conventions: all functions in this package follow the underscore-separated and all-lower-case naming convention (e.g. <code>environment_name()</code>, <code>get_obj_address()</code>, etc.).
</p>


<h3>Details</h3>

<p>The package currently contains 12 visible functions. Following is an overview on how to use the main functions of the package. Please refer to the vignette for further information.
</p>
<p>1) Use <code><a href="#topic+get_obj_address">get_obj_address</a></code> to retrieve the memory address of any object, including environments.
</p>
<p>2) Use <code><a href="#topic+environment_name">environment_name</a></code> to retrieve the name of an environment created with <code><a href="base.html#topic+new.env">new.env</a></code>. The environment can be given as a string containing its 16-digit memory address.
</p>
<p>3) Use <code><a href="#topic+obj_find">obj_find</a></code> to find the environments where a given object is defined.
</p>
<p>4) Use <code><a href="#topic+get_fun_calling">get_fun_calling</a>(n)</code> from within a function to retrieve the name of the calling function <code>n</code> levels up in the calling stack together with their enclosing environment name.
</p>
<p>5) Use <code><a href="#topic+get_fun_calling_chain">get_fun_calling_chain</a></code> from within a function to get the calling functions stack.
</p>


<h3>Author(s)</h3>

<p>Daniel Mastropietro
</p>
<p>Maintainer: Daniel Mastropietro &lt;mastropi@uwalumni.com&gt;
</p>


<h3>References</h3>

<p>Motivation for developing this package:  
</p>
<p>- A comment by Quantide's instructor Andrea Spano during his &quot;R for developers&quot; course (<a href="http://www.quantide.com/courses-overview/r-for-developers">http://www.quantide.com/courses-overview/r-for-developers</a>) about the impossibility of retrieving the name of user-defined environments.  
</p>
<p>- A question posted by Gabor Grothendieck at the R-Help forum (<a href="https://stat.ethz.ch/pipermail/r-help/2010-July/245646.html">https://stat.ethz.ch/pipermail/r-help/2010-July/245646.html</a>)
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+environmentName">environmentName</a></code> in the base package for the built-in function that retrieves environment names of packages.
</p>
<p><code><a href="base.html#topic+exists">exists</a></code> and <code><a href="utils.html#topic+find">find</a></code> for alternatives of looking for objects in the workspace.
</p>
<p><code><a href="base.html#topic+sys.call">sys.call</a></code> for other alternatives for retrieving the function calling stack.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(envnames)
rm(list=ls())

### Example 1: Retrieve the names of user-defined environments (created with new.env())
# Create new environments
env1 &lt;- new.env()                      # Environment in .GlobalEnv
env2 &lt;- new.env()                      # Environment in .GlobalEnv
env3 &lt;- new.env(parent=baseenv())      # Environment whose enclosure or parent environment
                                       # is the base environment
                                       # (as opposed to the global environment)
env_of_envs &lt;- new.env()               # User-defined environment that contains other environments
with(env_of_envs, env11 &lt;- new.env()) # Environment defined inside environment env_of_envs

# Retrieve the environment name
environment_name(env1)                       # named array with value "env1" and name "R_GlobalEnv"
environment_name(env3)                       # named array with value "env3" and name "R_GlobalEnv"
environment_name(env9)                       # NULL (env9 does not exist)
environment_name(env_of_envs)                # named array with value "env_of_envs" and name
                                             # "R_GlobalEnv"
# (2018/11/19) THE FOLLOWING IS AN IMPORTANT TEST BECAUSE IT TESTS THE CASE WHERE THE ADDRESS-NAME
# LOOKUP TABLE CONTAINS ONLY ONE ROW (namely the row for the env11 environment present in
# env_of_envs), WHICH CANNOT BE TESTED VIA TESTS USING THE testthat PACKAGE BECAUSE IN THAT CONTEXT
# THE LOOKUP TABLE NEVER HAS ONLY ONE ROW!
# (for more info about this limitation see the test commented out at the beginning of
# test-get_env_names.r.
environment_name(env11, envir=env_of_envs)   # "env11"
environment_name(env11)                      # named array with value "env11" and name
                                             # "R_GlobalEnv$env_of_envs"


### Example 2: Retrieve calling functions and their environments
### Note in particular the complicated use of sys.call() to retrieve the call as a string... 
# Define two environments
env1 &lt;- new.env()
env2 &lt;- new.env()
# Define function g() in environment env2 to be called by function f() below
# Function g() prints the name of the calling function.
with(env2,
     g &lt;- function(x) {
       # Current function name
       fun_current_name = get_fun_name()

       # Get the name of the calling environment and function
			 fun_calling_name = get_fun_calling()

       # Show calling environment using and not using the envnames package
       cat("Now inside function", fun_current_name, "\n")
       cat("Calling environment name (using environmentName(parent.frame())):  \"",
            environmentName(parent.frame()), "\"\n", sep="")
       cat("Calling environment name (using sys.call(1) inside
           'as.character( as.list(sys.call(1))[[1]]) ))':", " \"",
            as.character( as.list(sys.call(1))[[1]]), "\"\n", sep="")
       cat("Calling environment name (using envnames::get_fun_calling()): \"",
           fun_calling_name, "\"\n", sep="")

       # Start process
       x = x + 2;
       return(invisible(x))
     }
)

# Calling function whose name should be printed when g() is run
with(env1,
     f &lt;- function(x) {
       # Start
       gval = env2$g(x)
       return(invisible(gval))
     }
)

# Run function f to show the difference between using and
# not using the envnames package to retrieve the function calling stack.
env1$f(7)


### Example 3: find the location of an object
# This differs from the R function exists() because it also searches
# in user-defined environments and any environments wihin.
obj_find(f)                   # "env1"
obj_find("f")                 # Same thing: "env1"
obj_find("f", silent=FALSE)   # Same result, but run verbosely

env2$x &lt;- 2
obj_find(x)                   # "env2"

obj_find(nonexistent)         # NULL


</code></pre>

<hr>
<h2 id='address'>Call the C function address() that retrieves the memory address of an R object</h2><span id='topic+address'></span>

<h3>Description</h3>

<p>Call the C function address() that retrieves the memory address of an R object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>address(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="address_+3A_x">x</code></td>
<td>
<p>object whose memory address is of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the memory address of object <code>x</code> or <code>NULL</code> if the object does not exist in the R workspace.
</p>

<hr>
<h2 id='check_environment'>Check whether a string corresponds to the name of an environment</h2><span id='topic+check_environment'></span>

<h3>Description</h3>

<p>The input string is checked as a valid environment name. The environment can be a named environment
(system or package) or a user environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_environment(x, envir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_environment_+3A_x">x</code></td>
<td>
<p>string to evaluate that may represent an environment</p>
</td></tr>
<tr><td><code id="check_environment_+3A_envir">envir</code></td>
<td>
<p>environment where <code>x</code> should be evaluated first. If it is not found there
it still searched for in the whole workspace.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>

<ul>
<li><p><code>found</code> whether the string contained in <code>x</code> is the name of an existing environment
in the workspace
</p>
</li>
<li><p><code>env_name</code> the name of the environment (after stripping out any system environments such
as globalenv(), baseenv() or a package environment) (for instance &quot;globalenv()$env$env1&quot; is returned
as &quot;env$env1&quot;), or NULL if no environment was found corresponding to the name given in <code>x</code>.
</p>
</li></ul>


<hr>
<h2 id='check_object_exists'>Check if an object exists in a given environment</h2><span id='topic+check_object_exists'></span>

<h3>Description</h3>

<p>Check if an object exists in a given environment or any parent environment from the given environment in
the way that the <a href="base.html#topic+eval">eval</a> function does by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_object_exists(obj, envir = globalenv())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_object_exists_+3A_obj">obj</code></td>
<td>
<p>object to check. It can be given as a symbol or as a string.</p>
</td></tr>
<tr><td><code id="check_object_exists_+3A_envir">envir</code></td>
<td>
<p>environment where the existence of <code>object</code> is checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object is not found in the <code>envir</code> environment it is searched in any parent environment
of <code>envir</code>.
</p>


<h3>Value</h3>

<p>A list containing three elements:
</p>

<ul>
<li><p><code>found</code> flag indicating whether the object was found
</p>
</li>
<li><p><code>eval</code> result of the evaluation of <code>obj</code> either in <code>envir</code> or in a parent environment
where it was found.
</p>
</li>
<li><p><code>address</code> memory address of the object found. IMPORTANT: This memory address is NOT the object's memory
address when the object is given as a string, as in that case the memory address contains the memory address of the
string! (which varies every time, even if the string is the same, because every time the string allocates a different
memory address)
</p>
</li></ul>


<hr>
<h2 id='check_object_with_path'>Check if an object name contains a valid environment path</h2><span id='topic+check_object_with_path'></span>

<h3>Description</h3>

<p>Check if a string may represent a valid object name with full environment path to the object
as in <code>globalenv()$env$x</code>. The string should <em>not</em> end with <code>]</code> or <code>)</code> because
that makes the whole expression an invalid name and therefore it should not be considered as a name
(e.g. <code>globalenv()$v[1]</code> refers to element 1 of array v and such thing is not the name of an object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_object_with_path(x, checkenv = FALSE, envir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_object_with_path_+3A_x">x</code></td>
<td>
<p>string to be checked.</p>
</td></tr>
<tr><td><code id="check_object_with_path_+3A_checkenv">checkenv</code></td>
<td>
<p>flag indicating whether the environment path should be checked for valid environment
as well. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="check_object_with_path_+3A_envir">envir</code></td>
<td>
<p>environment where <code>x</code> should be evaluated when also checking the environment.
Only used when <code>checkenv=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optionally a check of whether the path points to a valid environment inside a given environment
is performed by calling .
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<p>When <code>checkenv=FALSE</code>:
</p>

<ul>
<li><p><code>ok</code> boolean indicating whether the string may be a valid object name
</p>
</li>
<li><p><code>path</code> path to the name
</p>
</li>
<li><p><code>name</code> the name itself with no path.
</p>
</li></ul>

<p>When <code>checkenv=TRUE</code> and when the string given in <code>x</code> is deemed to be a possible valid object,
the following additional elements:
</p>

<ul>
<li><p><code>env_found</code> flag indicating whether the string indicating the path to the object name
referenced by <code>x</code> is the name of an existing environment in the workspace
</p>
</li>
<li><p><code>env_name</code> the name of the environment (after stripping out any system environments such
as globalenv(), baseenv() or a package environment) (for instance &quot;globalenv()$env$env1&quot; is returned
as &quot;env$env1&quot;), or NULL if no environment is found corresponding to the path given in <code>x</code>.
</p>
</li></ul>


<hr>
<h2 id='clean_up_matching_environments'>Clean up the list of environments matching a memory address in an environment map.</h2><span id='topic+clean_up_matching_environments'></span>

<h3>Description</h3>

<p>Clean up the list of environments matching a memory address in an environment map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_up_matching_environments(envmap, indfound)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_up_matching_environments_+3A_envmap">envmap</code></td>
<td>
<p>data frame with the name-address pairs of environments having at least a column
called &quot;type&quot; that specifies the type of environment, for which &quot;function&quot; is used to indicate
a function execution environment.</p>
</td></tr>
<tr><td><code id="clean_up_matching_environments_+3A_indfound">indfound</code></td>
<td>
<p>array containing the indices in envmap giving the environments to clean up
(typically these are the environments that match a given memory address).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A clean list of matched environments from <code>envmap</code> should either:
</p>

<ul>
<li><p> contain ONLY ONE function execution environment,
</p>
</li>
<li><p> contain one ore more user or named environments.
</p>
</li></ul>

<p>If none of the above is the case, all function execution environments are removed from the list
of matching environments, i.e. removed from the <code>indfound</code> array.
</p>


<h3>Value</h3>

<p>an array containing the indices in <code>indfound</code> after cleanup.
</p>

<hr>
<h2 id='collapse_root_and_member'>Put together a root name with a member name</h2><span id='topic+collapse_root_and_member'></span>

<h3>Description</h3>

<p>This is the opposite operation of <code>extract_root_and_last_member()</code>:
the <code>root</code> and its supposed <code>member</code> are put together using the
<code>$</code> separator, as in <code>env_of_envs$env1$x</code>, where the root and
the member could be either <code>env_of_envs$env1</code> and <code>x</code> or
<code>env_of_envs</code> and <code>env1$x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_root_and_member(root, member)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_root_and_member_+3A_root">root</code></td>
<td>
<p>String containing the root name to concatenate. It may be NULL or empty.</p>
</td></tr>
<tr><td><code id="collapse_root_and_member_+3A_member">member</code></td>
<td>
<p>String containing the member name to concatenate. It may be NULL or empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string concatenating the root and the member names with the
<code>$</code> symbol. If any of them is empty or <code>NULL</code>, the other name is returned
or <code>""</code> if the other name is also empty or <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code>extract_root_and_last_member()</code>
</p>

<hr>
<h2 id='crawl_envs'>Crawl environments in search of user environments</h2><span id='topic+crawl_envs'></span>

<h3>Description</h3>

<p>Function that crawls a set of environments to search for user environments
defined within each of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crawl_envs(env_names, path, path_to_envs_found, rootenvir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crawl_envs_+3A_env_names">env_names</code></td>
<td>
<p>array with the environment names where the search for environments is wished
(careful: should not contain the environment *objects* but their *names*!).</p>
</td></tr>
<tr><td><code id="crawl_envs_+3A_path">path</code></td>
<td>
<p>array with user environment names leading to the current set of
environments listed in <code>env_names</code>. Ex: <code>c("env_of_envs", "env11")</code> which means that the
the environments listed in <code>env_names</code> exist in environment <code>env_of_envs$env11</code>.</p>
</td></tr>
<tr><td><code id="crawl_envs_+3A_path_to_envs_found">path_to_envs_found</code></td>
<td>
<p>array of user environment names found so far including their path
where the path is allowed to include ONLY user environments.
(e.g. an element of the <code>path_to_envs_found</code> array could be <code>"env1$env2$env"</code>, but NOT
<code>"R_GlobalEnv$env1$env2"</code>, because &quot;R_GobalEnv&quot; is the name of a system environment, NOT a
user environment).
The first time this function is called it should contain the empty array.</p>
</td></tr>
<tr><td><code id="crawl_envs_+3A_rootenvir">rootenvir</code></td>
<td>
<p>environment used as starting point for the user environment
search process. If <code>NULL</code>, the environment is taken from the names attribute of
the <code>env_names</code> parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function crawls the user environments defined in the <code>rootenvir</code> environment and
any user environments within those user environments until no user environment
has been left without visit, making up a tree of nested user environments.
The path to each user environment found is stored using the <code>$</code> notation as in
<code>env1$env12$envx</code>.
</p>
<p>Instead of setting the <code>rootenvir</code> parameter to the root environment where the search should start,
a similar result is obtained by setting the <code>path</code> variable to the environment chain leading to
the environments passed in <code>env_names</code>, as in e.g. <code>c("env_of_envs", "env11")</code>.
The difference is that such environment will appear as part of the paths to the environments passed,
and in addition, it is assumed that such environment is an actual environment.
</p>


<h3>Value</h3>

<p>An array containing the path to each user environment found inside the <code>rootenvir</code>
environment and all the nested user environments found within each of them.
This array is concatenated to whatever paths are already listed in the <code>path_to_envs_found</code>
parameter passed to the function.
</p>

<hr>
<h2 id='crawl_envs_in_env'>Crawl an environment in search of user environments</h2><span id='topic+crawl_envs_in_env'></span>

<h3>Description</h3>

<p>Crawl an environment in search of user environments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crawl_envs_in_env(envir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crawl_envs_in_env_+3A_envir">envir</code></td>
<td>
<p>environment to search in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array containing strings that represent the path to each environment found inside the
<code>envir</code> environment and any user environments nested within.
</p>

<hr>
<h2 id='destandardize_env_name'>De-standardize the name of an environment</h2><span id='topic+destandardize_env_name'></span>

<h3>Description</h3>

<p>This function inverts the process performed by <a href="#topic+standardize_env_name">standardize_env_name</a> that is, it converts
the standardized names &quot;R_GlobalEnv&quot;, &quot;R_EmptyEnv&quot;, and &quot;base&quot; back to names that are recognized by R as actual
environments when using function <a href="base.html#topic+as.environment">as.environment</a>, namely to <code>".GlobalEnv"</code>, <code>".EmptyEnv"</code>,
and <code>"package:base"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>destandardize_env_name(env_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="destandardize_env_name_+3A_env_name">env_name</code></td>
<td>
<p>environment name to de-standardize.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the environment, where the global environment is represented as &quot;.GlobalEnv&quot;, the empty
environment as &quot;.EmptyEnv&quot;, and the base environment as &quot;package:base&quot;.
</p>

<hr>
<h2 id='environment_name'>Retrieve the name of an environment</h2><span id='topic+environment_name'></span><span id='topic+get_env_name'></span>

<h3>Description</h3>

<p>Retrieve the name of an environment as the <code><a href="base.html#topic+environmentName">environmentName</a></code> function of the base package does,
but extending its functionality to retrieving the names of user-defined environments and function
execution environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>environment_name(
  env = parent.frame(),
  envir = NULL,
  envmap = NULL,
  matchname = FALSE,
  ignore = NULL,
  include_functions = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="environment_name_+3A_env">env</code></td>
<td>
<p>environment whose name is of interest.
It can be given as an object of class environment, as a string with the name of the environment,
or as a string with the memory address of the environment.
The latter is useful to find out if a given memory address is the reference of an environment object.
Note that the variable passed may or may <em>not</em> exist in the calling environment, as the purpose
of this function is also to search for it (and return its name if it is an environment).
It defaults to parent.frame(), meaning that the name of the environment that calls this function is retrieved.</p>
</td></tr>
<tr><td><code id="environment_name_+3A_envir">envir</code></td>
<td>
<p>environment where <code>env</code> should be searched for. When <code>NULL</code>, <code>env</code> is searched in
the whole workspace, including packages and user-defined environments, recursively.</p>
</td></tr>
<tr><td><code id="environment_name_+3A_envmap">envmap</code></td>
<td>
<p>data frame containing a lookup table with name-address pairs of environment names and
addresses to be used when searching for environment <code>env</code>. It defaults to <code>NULL</code> which means that the
lookup table is constructed on the fly with the environments defined in the <code>envir</code> environment
&ndash;if not <code>NULL</code>&ndash;, or in the whole workspace if <code>envir=NULL</code>.
See the details section for more information on its structure.</p>
</td></tr>
<tr><td><code id="environment_name_+3A_matchname">matchname</code></td>
<td>
<p>flag indicating whether the match for <code>env</code> is based on its name or on its
memory address. In the latter case all environments sharing the same memory address of the given
environment are returned. Such scenario happens when, for instance, different
environment objects have been defined equal to another environment (as in <code>env1 &lt;- env</code>).
It defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="environment_name_+3A_ignore">ignore</code></td>
<td>
<p>one or more environment names to ignore if found during the search. These environments
are removed from the output. It should be given as a character array if more than one environments
should be ignored. See the details section for more information.</p>
</td></tr>
<tr><td><code id="environment_name_+3A_include_functions">include_functions</code></td>
<td>
<p>flag indicating whether to look for user-defined environments inside function
execution environments. This should be used with care because in a complicated function chain, some function
execution environments may contain environments that point to other environments (e.g. the 'envclos' environment
in the <code>eval()</code> function when running tests using the <code>test_that</code> package).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>env</code> is an environment it is searched for in the <code>envir</code> environment using its memory address.
If <code>env</code> is a string containing a valid 16-digit memory address (enclosed in &lt; &gt;), the memory address
itself is searched for among the defined environments in the <code>envir</code> environment.
In both cases, if <code>envir=NULL</code> the search is carried out in the whole workspace. 
</p>
<p>It may happen that more than one environment exist with the same memory address (for instance
if an environment is a copy of another environment). In such case, if <code>matchname=FALSE</code>,
the names of ALL the environments matching <code>env</code>'s memory address are returned. Otherwise,
only the environments matching the given name are returned.
</p>
<p>If <code>envmap</code> is passed it should be a data frame providing an address-name pair lookup table
of environments and should contain at least the following columns:
</p>

<ul>
<li><p><code>location</code> for user-defined environments, the name of the environment where the environment
is located; otherwise <code>NA</code>.
</p>
</li>
<li><p><code>pathname</code> the full <em>environment path</em> to reach the environment separated by <code>$</code>
(e.g. <code>"env1$env$envx"</code>)
</p>
</li>
<li><p><code>address</code> an 8-digit (32-bit architectures) thru 16-digit (64-bit architectures) memory address
of the environment given in <code>pathname</code> enclosed in &lt; &gt; (e.g. <code>"&lt;0000000007DCFB38&gt;"</code>
(64-bit architectures))
Be ware that Linux Debian distributions may have a 12-digit memory address representation.
So the best way to know is to check a memory address by calling e.g. 'address(&quot;x&quot;)'.
</p>
</li></ul>

<p>Passing an <code>envmap</code> lookup table is useful for speedup purposes, in case several calls to this
function will be performed in the context of an unchanged set of defined environments.
Such <code>envmap</code> data frame can be created by calling <a href="#topic+get_env_names">get_env_names</a>.
Use this parameter with care, as the matrix passed may not correspond to the actual mapping of existing
environments to their addresses and in that case results may be different from those expected.
</p>
<p>The following example illustrates the use of the <code>ignore</code> parameter:
</p>
<p><code>for (e in c(globalenv(), baseenv())) { print(environment_name(e, ignore="e")) }</code>
</p>
<p>That is, we iterate on a set of environments and we don't want the loop variable (an environment itself)
to show up as part of the output generated by the call to <code>environment_name()</code>.
</p>


<h3>Value</h3>

<p>If <code>matchname=FALSE</code> (the default), an array containing the names of all the environments
(defined in the <code>envir</code> environment if <code>envir</code> is not <code>NULL</code>) having the same memory address
as the <code>env</code> environment.
</p>
<p>If <code>matchname=TRUE</code>, the environment name contained in <code>env</code> is used in addition to the memory
address to check the matched environments (potentially many if they have the same memory address)
so that only the environments having the same name and address as the <code>env</code> environment are returned.
Note that several environments may be found if environments with the same name are defined in
different environments.
WARNING: in this case, the name is matched exactly as the expression given in <code>env</code>. So for instance,
if <code>env=globalenv()$env1</code> the name <code>"globalenv()$env1"</code> is checked and this will not return any
environments since no environment can be called like that. For such scenario call the function with
parameter <code>env=env1</code> instead, or optionally with <code>env=env1</code> and <code>envir=globalenv()</code>
if the <code>env1</code> environment should be searched for just in the global environment.
</p>
<p>If <code>env</code> is not found or it is not an environment, <code>NULL</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Retrieve name of a user-defined environment
env1 &lt;- new.env()
environment_name(env1)                   		# "env1"

# Retrieve the name of an environment given as a memory address
env1_address = get_obj_address(globalenv()$env1)
environment_name(env1_address)           		# "env1"

# Create a copy of the above environment
env1_copy &lt;- env1
environment_name(env1)                   		# "env1" "env1_copy"
# Retrieve just the env1 environment name
environment_name(env1, matchname=TRUE)   		# "env1"

# Retrieve the name of an environment defined within another environment
with(env1, envx &lt;- new.env())
environment_name(env1$envx)              		# "env1$envx" "env1_copy$envx"
environment_name(env1$envx, matchname=TRUE)
  ## NULL, because the environment name is "envx", NOT "env1$envx"

# Get a function's execution environment name
with(env1, f &lt;- function() { cat("We are inside function", environment_name()) })  
    ## "We are inside function env1$f"
</code></pre>

<hr>
<h2 id='extract_root_and_last_member'>Extract the last member in a string representing an object</h2><span id='topic+extract_root_and_last_member'></span>

<h3>Description</h3>

<p>Function that extracts the last name in a string representing an object as in e.g. <code>obj$x$y</code>.
It returns a list containing both the piece before the last occurrence of <code>$</code> and the name coming after it.
The object may or may not exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_root_and_last_member(full_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_root_and_last_member_+3A_full_name">full_name</code></td>
<td>
<p>character scalar from which we should keep the piece that comes after the last <code>$</code> sign.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two members: <code>root</code> containing the path to the last name of the object expression
and <code>name</code>, containing the last name in the object expression.
The <code>root</code> is empty when there is no <code>$</code> in the input string.
Ex: <code>extract_root_and_last_member("obj$x$y")</code> returns <code>list(root="obj$x", name="y")</code>.
</p>

<hr>
<h2 id='get_env_names'>Create a lookup table with address-name pairs of environments</h2><span id='topic+get_env_names'></span>

<h3>Description</h3>

<p>Return a data frame containing the address-name pairs of system, package, namespace, user-defined,
and function execution environments in the whole workspace or within a given environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_env_names(envir = NULL, include_functions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_env_names_+3A_envir">envir</code></td>
<td>
<p>environment where environments are searched for to construct the lookup table.
It defaults to <code>NULL</code> which means that all environments in the whole workspace should be searched for
and all packages in the <code>search()</code> path should be returned including their namespace environments.</p>
</td></tr>
<tr><td><code id="get_env_names_+3A_include_functions">include_functions</code></td>
<td>
<p>flag indicating whether to include in the returned data frame 
user-defined environments defined inside function execution environments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The table includes the empty environment as well when the address-name pairs map is constructed
on the whole workspace.
</p>
<p>The search for environments is recursive, meaning that a search is carried out for environments defined
within other user-defined environments and, when <code>include_functions=TRUE</code> within function execution
environments.
</p>
<p>The search within packages is always on <em>exported objects</em> only.
</p>
<p>If <code>envir=NULL</code> the lookup table includes all system, package, and namespace environments
in the <code>search()</code> path, as well as all user-defined found in <em>any</em> of those environments
(with recursive search), and all function execution environments.
</p>
<p>If <code>envir</code> is not <code>NULL</code> the lookup table includes just the user-defined and
function execution environments found inside the given environment (with recursive search).
</p>


<h3>Value</h3>

<p>A data frame containing the following seven columns:
</p>

<ul>
<li><p><code>type</code> type of environment (&quot;user&quot; for user-defined environments,
&quot;function&quot; for function execution environments, &quot;system/package&quot; for system or package environments,
&quot;namespace&quot; for namespace environments, and &quot;empty&quot; for empty environments such as emptyenv()).
</p>
</li>
<li><p><code>location</code> location of the environment, which is only non-<code>NA</code> for user-defined
and function execution environments: 
</p>

<ul>
<li><p> for a user-defined environment, the location is the system environment or package where
the environment resides (note that this may be different from the parent environment if the
parent environment was set during creation with the <code>parent=</code> option of the <code>new.env()</code>
function or using the <code>parent.env()</code> function)
</p>
</li>
<li><p> for a function execution environment, the location is the function's enclosing environment, i.e. the environment
where the function is defined.
</p>
</li></ul>

</li>
<li><p><code>locationaddress</code> the memory address of the <code>location</code> environment.
</p>
</li>
<li><p><code>address</code> memory address of the environment. This is the key piece of information used
by the package to retrieve the environment name with the <code>environment_name()</code> function.
For functions, this is the address of the function's execution environment.
</p>
</li>
<li><p><code>pathname</code> path to the environment and its name. This is the combination of columns
<code>path</code> and <code>name</code> whose values are put together separated by <code>$</code>.
</p>
</li>
<li><p><code>path</code> path to the environment (i.e. all environments that need to be traversed in order
to reach the environment).
</p>
</li>
<li><p><code>name</code> name of the environment.
</p>
</li></ul>

<p>The <code>type</code> column is used to distinguish between user-defined environments, function execution
environments, package or system environments, namespace environments, and empty environments.
</p>
<p>The data frame is empty if no environments are found in the given <code>envir</code> environment.
</p>
<p><code>NULL</code> is returned when an error occurs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create example of chained environments
env1 &lt;- new.env()
with(env1, env11 &lt;- new.env())
with(env1$env11, envx &lt;- new.env())

# Address-name pairs of all environments defined in the workspace,
# including environments in the search path
get_env_names()  # returns a data frame with at least the following user environments:
                 # "env1", "env1$env11", "env1$env11$envx"  

# Address-name pairs of the environments defined in a given user-defined environment
get_env_names(env1)  # returns a data frame with the following user environments:
                     # "env11", "env11$envx"

# Address-name pairs of the environments defined in a given package
get_env_names(as.environment("package:stats")) # should return an empty data frame
                                               # (since the stats package does not
                                               # have any environments defined)
</code></pre>

<hr>
<h2 id='get_environment_name'>Get the name of an environment when the address-name lookup table has not yet been constructed</h2><span id='topic+get_environment_name'></span>

<h3>Description</h3>

<p>Get the name of an environment when the address-name lookup table has not yet been constructed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_environment_name(env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_environment_name_+3A_env">env</code></td>
<td>
<p>environment whose name is of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the name of the environment as given by <code>environmentName()</code> if it is a named environment
or the name of the environment as given by <code>deparse(substitute())</code> otherwise.
This will result in a string representing an expression when 'env' is given as an expression as in
<code>parent.env(env1)</code>.
</p>

<hr>
<h2 id='get_envs_in_env'>Find user environments inside another user environment</h2><span id='topic+get_envs_in_env'></span>

<h3>Description</h3>

<p>Function that looks for user environments defined within a given user environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_envs_in_env(env_name, path, path_to_envs_found, rootenvir = .GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_envs_in_env_+3A_env_name">env_name</code></td>
<td>
<p>name of the user environment where the search for other user environments
should be carried out.</p>
</td></tr>
<tr><td><code id="get_envs_in_env_+3A_path">path</code></td>
<td>
<p>array containing the user environment names leading to the <code>env_name</code> environment.</p>
</td></tr>
<tr><td><code id="get_envs_in_env_+3A_path_to_envs_found">path_to_envs_found</code></td>
<td>
<p>array of environment names found so far including their path 
(as in <code>testenv$env1</code>). Note that the path does NOT include the *location* of the user
environments which is actually the system or package environment where the crawling starts
defined by parameter <code>rootenvir</code>.</p>
</td></tr>
<tr><td><code id="get_envs_in_env_+3A_rootenvir">rootenvir</code></td>
<td>
<p>root environment specifying the location where the crawl of user environmnts
starts. This is needed for the <code>eval()</code> to work when resolving the name of the input environment
<code>env_name</code> into an enviroment. Ex: if we are crawling the environments defined in the envnames package,
<code>rootenvir</code> should be equal to the &quot;package:envnames&quot; environment, and here is where we are going to
find all the user environments that are crawled by this process as e.g.:
<code>testenv</code>
<code>testenv$env1</code>
<code>...</code>
i.e. all these environments will be <code>eval</code>uated in the <code>rootenvir</code> environment which
in this case is the &quot;package:envnames&quot; environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either an updated <code>path_to_envs_found</code> with the user environments found so far
in the user environments tree or <code>TRUE</code>, which indicates that a leaf in the user
environments tree hanging from <code>rootenvir</code> has been reached.
</p>

<hr>
<h2 id='get_fun_calling'>Return the name of a calling function with its context or path</h2><span id='topic+get_fun_calling'></span>

<h3>Description</h3>

<p>This is a wrapper for <code>get_fun_calling_chain(n)</code> and returns the name of the calling function
including the environment where it is defined <code>n</code> levels up. The two pieces of information are
separated by the <code>$</code> sign.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fun_calling(n = 1, showParameters = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_fun_calling_+3A_n">n</code></td>
<td>
<p>non-negative integer indicating the number of levels to go up from the calling function
to retrieve the function in the calling chain.
It defaults to 1, which means &quot;return the last function in the calling chain&quot;.</p>
</td></tr>
<tr><td><code id="get_fun_calling_+3A_showparameters">showParameters</code></td>
<td>
<p>flag indicating whether the parameters of the function call should also be shown
in the output.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+get_fun_name">get_fun_name</a> to retrieve *just* the name of the function, without its context (e.g. <code>"f"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Prepare environments
env1 &lt;- new.env()
env2 &lt;- new.env()
with(env2, env21 &lt;- new.env())

# Function that shows the names of calling functions in the chain and their environments
f &lt;- function(x) {
 cat("Now in function:", get_fun_calling(0), "\n")
 cat("\tName of the calling function:", get_fun_calling(), "\n")
 cat("\tName of the calling function two levels up:", get_fun_calling(2), "\n")
 cat("\tName of the calling function three levels up:", get_fun_calling(3), "\n")
 cat("\tName of the calling function four levels up:", get_fun_calling(4), "\n")
}

# Prepare a calling chain  
with(env1, g &lt;- function() { f(3) })
with(env2, h &lt;- function() { env1$g() })
with(env2$env21, hh &lt;- function() { env2$h() })

# Run the different functions defined to show the different calling chains
env1$g()
env2$h()
env2$env21$hh()
</code></pre>

<hr>
<h2 id='get_fun_calling_chain'>Return the chain of calling functions</h2><span id='topic+get_fun_calling_chain'></span>

<h3>Description</h3>

<p>Return a data frame with the stack or chain of function calls, or optionally the information on one
particular function in this chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fun_calling_chain(n = NULL, showParameters = FALSE, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_fun_calling_chain_+3A_n">n</code></td>
<td>
<p>non-negative integer specifying the level of interest in the function calling chain,
where 0 means the function calling <code>get_fun_calling_chain</code>.
It defaults to <code>NULL</code>, in which case the full chain is returned.</p>
</td></tr>
<tr><td><code id="get_fun_calling_chain_+3A_showparameters">showParameters</code></td>
<td>
<p>flag indicating whether the parameters of the function call should also be shown
in the output.</p>
</td></tr>
<tr><td><code id="get_fun_calling_chain_+3A_silent">silent</code></td>
<td>
<p>whether to run in silent mode. If FALSE, the calling chain is shown in an intuitive way.
It defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>n=NULL</code> (the default) a data frame with the function calling chain information, 
with the following columns:
</p>

<ul>
<li><p><code>fun</code>: the function name (including parameters if <code>showParameters=TRUE</code>)
</p>
</li>
<li><p><code>env</code>: the function's enclosing enviroment, i.e. the environment where the function is defined
as returned by <code>environment(&lt;function&gt;)</code>
</p>
</li>
<li><p><code>envfun</code>: the environment where the function is defined together with the function name (and its parameters
if <code>showParameters=TRUE</code>) separated by a <code>$</code> sign. Ex: <code>env1$f()</code>
</p>
</li></ul>

<p>The rownames of the data frame are the stack level of the function calls in the chain,
from 0 up to the number of functions in the chain, where 0 indicates the current function
(i.e. the function that called <code>get_fun_calling_chain</code>).
</p>
<p>The functions in the data frame are sorted from most recent to least recent call, much like the common
way of displaying the function stack in debug mode.
</p>
<p>If the function is NOT called from within a function, <code>NULL</code> is returned.
</p>
<p>If <code>n</code> is not NULL and is non-negative, the environment and the function name (including parameters
if <code>showParameters=TRUE</code>) separated by a <code>$</code> sign are returned (ex: <code>env1$f(x = 3, n = 1)</code>).
</p>
<p>if <code>n &lt; 0</code> or if <code>n</code> is larger than the function calling chain length, <code>NULL</code> is returned.
</p>

<hr>
<h2 id='get_fun_env'>Return the execution environment of a function</h2><span id='topic+get_fun_env'></span>

<h3>Description</h3>

<p>Return the execution environment of a function by going over the execution environments of all functions
in the calling chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fun_env(fun_name_or_address)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_fun_env_+3A_fun_name_or_address">fun_name_or_address</code></td>
<td>
<p>string containing either the name of the function of interest or the
memory address of the execution environment to retrieve (N.B. this sould not be the memory address
of the <em>function itself</em>, but the memory address of its <em>execution environment</em>).
When the function name is given, it should be given with its full path, i.e. including
the environment where it is defined (e.g. &quot;env1$f&quot;) and with no arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is expected to be called from within a function. Otherwise, the function calling chain
is empty and the function returns <code>NULL</code>.
</p>


<h3>Value</h3>

<p>When the input parameter is a memory address, the execution environment of the function
whose memory address (of the execution environment) equals the given memory address.
</p>
<p>When the input parameter is a function name, a list of ALL the execution environments belonging
to a function whose name coincides with the given name (including any given path).
Note that these may be many environments as the same function may be called several times in the
function calling chain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define the function that is called to show the behaviour of get_fun_env()
h &lt;- function(x) {
  # Get the value of parameter 'x' in the execution environment of function 'env1$g'
  # If function 'env1$g' is not found, 'x' is evaluated in the current environment or function
  xval = evalq(x, get_fun_env("env1$g")[[1]])
  return(xval)
}
# Define the function that calls h() in a user-defined environment 
env1 &lt;- new.env()
with(env1, 
  g &lt;- function(y) {
    x = 2
    return( h(y) )
  }
)
# Call env1$g()
cat("The value of variable 'x' inside env1$g is", env1$g(3), "\n") 
  ## Prints '2', because the value of x inside env1$g() is 2
  ## ('3' is the value of variable 'y' in env1$g(), not of variable 'x')

# When get_fun_env() is called from outside a function, it returns NULL
get_fun_env("env1$g")  # NULL, even if function 'g' exists,
                       # but we are not calling get_fun_env() from a function

</code></pre>

<hr>
<h2 id='get_fun_name'>Return the name of the current function or a calling function in the chain</h2><span id='topic+get_fun_name'></span>

<h3>Description</h3>

<p>Return the name of the function that has been called <code>n</code> levels up from a given function's body.
This function is intended to be called only within a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fun_name(n = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_fun_name_+3A_n">n</code></td>
<td>
<p>number of levels to go up in the calling chain in search of the calling function name.
Defaults to <code>n=0</code>, meaning that the name returned is the name of the function that calls
<code>get_fun_name</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the name of the function that has been called <code>n</code> levels up
from the function calling <code>get_env_name</code>. The function name is returned without context,
that is the enclosing environment of the function is not part of the returned value.
(e.g. if the function is <code>env1$f</code> or <code>env1$env2$f</code> only <code>"f"</code> will be returned).
</p>


<h3>See Also</h3>

<p><a href="#topic+get_fun_calling">get_fun_calling</a> to retrieve the name of the function with its context (e.g. <code>"env1$f"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Show the name of the active function
f &lt;- function() { cat("We are in function:", get_fun_name(), "\n") }
f()

# Show the name of the calling function
f &lt;- function(x) { cat("Calling function name is:", get_fun_name(1), "\n") }
env1 &lt;- new.env()
with(env1, g &lt;- function() { f(3) })
env1$g()
</code></pre>

<hr>
<h2 id='get_namespace_addresses'>Return the memory address of namespace environments in the search() list</h2><span id='topic+get_namespace_addresses'></span>

<h3>Description</h3>

<p>This function returns the memory address of all the namespace environments of the packages found
in the <code>search()</code> path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_namespace_addresses()
</code></pre>


<h3>Value</h3>

<p>Array containing the namespace addresses as values and the package names as names (in the form
of e.g. &quot;package:base&quot;)
</p>

<hr>
<h2 id='get_namespace_names'>Return the names that can be used to load all the namespace environments in the search() list</h2><span id='topic+get_namespace_names'></span>

<h3>Description</h3>

<p>This function returns the names of all the namespace environments of the packages found
in the <code>search()</code> path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_namespace_names()
</code></pre>


<h3>Value</h3>

<p>Array containing the names of the namespace environments as values and the package names as names
(in the form of e.g. &quot;package:base&quot;). The names of the namespace environments are the result of splitting
the name in the search list by &quot;:&quot; and taking the second part of the string 
(e.g. &quot;base&quot; from &quot;package:base&quot; or &quot;rstudio&quot; from &quot;tools:rstudio&quot;).
The idea is that this name gives the namespace enviroment when used as <code>asNamespace(&lt;name&gt;)</code> or
<code>getNamespace(&lt;name&gt;)</code>, as in e.g. <code>asNamespace("base")</code>.
</p>

<hr>
<h2 id='get_obj_address'>Return the memory address of an object</h2><span id='topic+get_obj_address'></span>

<h3>Description</h3>

<p>Return the memory address of an object after recursively searching for the object in all the environments defined
in a specified environment or in all the environments defined in the whole workspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_obj_address(
  obj,
  envir = NULL,
  envmap = NULL,
  n = 0,
  include_functions = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_obj_address_+3A_obj">obj</code></td>
<td>
<p>object whose memory address is requested. It can be given as a variable name or an expression.
Strings representing object names are not interpreted and return <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_obj_address_+3A_envir">envir</code></td>
<td>
<p>environment where the object should be searched for. All parent environments of
<code>envir</code> are searched as well. It defaults to <code>NULL</code> which means that it should be searched in the
whole workspace (including packages, namespaces, and user-defined environments).</p>
</td></tr>
<tr><td><code id="get_obj_address_+3A_envmap">envmap</code></td>
<td>
<p>data frame containing a lookup table with name-address pairs of environment names and
addresses to be used when searching for environment <code>env</code>. It defaults to <code>NULL</code> which means that the
lookup table is constructed on the fly with the environments defined in the <code>envir</code> environment
&ndash;if not <code>NULL</code>&ndash;, or in the whole workspace if <code>envir=sNULL</code>.
See the details section for more information on its structure.</p>
</td></tr>
<tr><td><code id="get_obj_address_+3A_n">n</code></td>
<td>
<p>number of levels to go up from the calling function environment to resolve the name
of <code>obj</code>. It defaults to 0 which implies the calling environment.</p>
</td></tr>
<tr><td><code id="get_obj_address_+3A_include_functions">include_functions</code></td>
<td>
<p>whether to include funtion execution environments as environments where the object
is searched for. Set this flag to <code>TRUE</code> with caution because there may be several functions where the
same object is defined, for instance functions that are called as part of the object searching process!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object is first searched recursively in all environments defined in the specified environment (if any),
by calling <code>obj_find</code>.
If no environment is specified, the object is searched recursively in the whole workspace.
</p>
<p>The memory address is then retrieved for every object found in those environments having the same name
as the given object <code>obj</code>.
</p>
<p>Strings return <code>NULL</code> but strings can be the result of an expression passed as argument to this function.
In that case, the string is interpreted as an object and its memory address is returned as long as
the object exists.
</p>
<p>If <code>envmap</code> is passed it should be a data frame providing an address-name pair lookup table
of environments and should contain at least the following columns:
</p>

<ul>
<li><p><code>location</code> for user-defined environments, the name of the environment where the environment
is located; otherwise <code>NA</code>.
</p>
</li>
<li><p><code>pathname</code> the full <em>environment path</em> to reach the environment separated by <code>$</code>
(e.g. <code>"env1$env$envx"</code>)
</p>
</li>
<li><p><code>address</code> an 8-digit (32-bit architectures) thru 16-digit (64-bit architectures) memory address
of the environment given in <code>pathname</code> enclosed in &lt; &gt; (e.g. <code>"&lt;0000000007DCFB38&gt;"</code>
(64-bit architectures))
Be ware that Linux Debian distributions may have a 12-digit memory address representation.
So the best way to know is to check a memory address by calling e.g. 'address(&quot;x&quot;)'.
</p>
</li></ul>

<p>Passing an <code>envmap</code> lookup table is useful for speedup purposes, in case several calls to this
function will be performed in the context of an unchanged set of defined environments.
Such <code>envmap</code> data frame can be created by calling <a href="#topic+get_env_names">get_env_names</a>.
Use this parameter with care, as the matrix passed may not correspond to the actual mapping of existing
environments to their addresses and in that case results may be different from those expected.
</p>


<h3>Value</h3>

<p>The 8-digit (32-bit architectures) thru 16-digit (64-bit architectures) memory address of
the input object given as a string enclosed in &lt;&gt;  (e.g. <code>"&lt;0000000005E90988&gt;"</code>)
(note that Ubuntu Debian may use 12-digit memory addresses),
or <code>NULL</code> under any of the following situations:
</p>

<ul>
<li><p> the object is <code>NULL</code>, <code>NA</code>, or a string, or any other object whose memory address changes every
time the object is referred to (for instance for <code>alist[1]</code> &ndash;as opposed to <code>alist[[1]]</code>&ndash;
where <code>alist</code> is a list.
</p>
</li>
<li><p> the object is a constant (e.g. <code>TRUE</code>, <code>3</code>, etc.)
</p>
</li>
<li><p> the object does not exist in the given environment.
</p>
</li>
<li><p> the object is an expression that cannot be evaluated in the given environment.
</p>
</li></ul>

<p>Note that for the last case, although constants have a memory address, this address is meaningless as
it changes with every invocation of the function. For instance, running
<code>address(3)</code> several times will show a different memory address each time, and that is why
<code>get_obj_address</code> returns <code>NULL</code> in those cases.
</p>
<p>When <code>envir=NULL</code> (the default) or when an object exists in several environments,
the memory address is returned for all of the environments where the object is found. In that case, the addresses are
stored in an array whose names attribute shows the environments where the object is found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env1 = new.env()
env1$x = 3                       # x defined in environment 'env1'
x = 4                            # x defined in the Global Environment
get_obj_address(env1$x)          # returns the memory address of the object 'x'
                                 # defined in the 'env1' environment
get_obj_address(x, envir=env1)   # same as above
get_obj_address(x)               # Searches for object 'x' everywhere in the workspace and
                                 # returns a named array with the memory address of all its
                                 # occurrences, where the names are the names of the
                                 # environments where x was found.

# Memory addresses of objects whose names are stored in an array and retrieved using sapply()
env1$y &lt;- 2;
objects &lt;- c("x", "y")
sapply(objects, FUN=get_obj_address, envir=env1)	# Note that the address of object "x"
                                                 # is the same as the one returned above
                                                 # by get_obj_address(x, envir=env1)

# Memory address of elements of a list
alist &lt;- list("x")
get_obj_address(alist[[1]])      # memory address of object 'x'
get_obj_address(alist[1])        # NULL because alist[1] has a memory address
                                 # that changes every time alist[1] is referred to.
</code></pre>

<hr>
<h2 id='get_obj_addresses_from_obj_names'>Get the object addresses given their object names</h2><span id='topic+get_obj_addresses_from_obj_names'></span>

<h3>Description</h3>

<p>Get the object addresses given their object names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_obj_addresses_from_obj_names(obj_names, envir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_obj_addresses_from_obj_names_+3A_obj_names">obj_names</code></td>
<td>
<p>array containing the name of the objects to retrieve.
They can be given as full path names (e.g. &quot;env1$x&quot;) and they can also be
system or package environments given as e.g. &quot;.GlobalEnv&quot; or &quot;R_GlobalEnv&quot; or
&quot;baseenv()&quot; or &quot;package:base&quot; or &quot;package:stats&quot;, etc.</p>
</td></tr>
<tr><td><code id="get_obj_addresses_from_obj_names_+3A_envir">envir</code></td>
<td>
<p>environment where the objects exist (considering the
object names are given with their full path to the object), or <code>NULL</code>
if they exist in the global environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array containing the memory address of the objects given in <code>obj_names</code>
or NULL if there is a problem evaluating the corresponding object in the given environment
with <code>eval()</code>.
</p>

<hr>
<h2 id='get_obj_name'>Return the name of an object at a given parent generation from an environment</h2><span id='topic+get_obj_name'></span>

<h3>Description</h3>

<p>A practical use of this function is to retrieve the name of the object leading to
a function's parameter in the function calling chain, at any parent generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_obj_name(obj, n = 0, eval = FALSE, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_obj_name_+3A_obj">obj</code></td>
<td>
<p>object whose name at a given parent generation is of interest.</p>
</td></tr>
<tr><td><code id="get_obj_name_+3A_n">n</code></td>
<td>
<p>number of parent generations to go back from the calling environment
to retrieve the name of the object that leads to <code>obj</code>
in the function calling chain. See details for more information.</p>
</td></tr>
<tr><td><code id="get_obj_name_+3A_eval">eval</code></td>
<td>
<p>whether to evaluate <code>obj</code> in the <code>n</code>-th parent generation before
getting the object's name in that environment. See details for more information.</p>
</td></tr>
<tr><td><code id="get_obj_name_+3A_silent">silent</code></td>
<td>
<p>when <code>FALSE</code>, the names of the environments and objects in those environments are printed
as those environments are traversed by this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In particular, it provides a handy way of retrieving the name of a function's parameter
and use it in e.g. messages to the user describing the arguments received by the function.
In this context, it is a shortcut to calling <code>as.list(environment())</code>, which returns
a list of parameter names and parameter values.
See the Examples section for an illustration.
</p>
<p>This function goes back to each parent generation from the calling function's environment
and at each of those parent generations it retrieves the name of the object that is part of
the parameter chain leading to the calling function's parameter.
</p>
<p>To illustrate: suppose we call a function <code>f &lt;- function(x)</code> by running the piece of code <code>f(z)</code>,
and that <code>f</code> calls another function <code>g &lt;- function(y)</code> by running the piece of code <code>g(x)</code>.  
</p>
<p>That is, we have the parameter chain:  
<code>z -&gt; x -&gt; y</code>
</p>
<p>If, inside function <code>g()</code>, we call <code>get_obj_name()</code> as follows, we obtain respectively:  
<code>get_obj_name(y, n=1)</code> yields <code>"x"</code>
<code>get_obj_name(y, n=2)</code> yields <code>"z"</code>
</p>
<p>because these calls are telling &quot;give me the name of object <code>y</code> as it was called
<code>n</code> levels up from the calling environment &ndash;i.e. from the environment of <code>g()</code>.
</p>
<p>Note that the results of these two calls are different from making the following two
<code>deparse(substitute())</code> calls:  
<code>deparse(substitute(y, parent.frame(n=1)))</code>   
<code>deparse(substitute(y, parent.frame(n=2)))</code>
because these calls simply <code>substitute</code> or evaluate <code>y</code> at the <code>n</code>-th parent generation.
If <code>y</code> is not defined at those parent generations, the <code>substitute()</code> calls return
simply <code>"y"</code>.
</p>
<p>On the contrary, the previous two calls to <code>get_obj_name()</code> return the name of the object
in the parameter chain (<code>z -&gt; x -&gt; y</code>) <em>leading</em> to <code>y</code>, which is a quite different
piece of information.
</p>
<p>When eval=TRUE, the result is the same as the result of <code>deparse()</code>
except for the following three cases:
</p>

<ul>
<li><p> if the object passed to <code>get_obj_name()</code> evaluates to a name, it returns that name,
without any added quotes. For example, if <code>v = "x"</code> then <code>get_obj_name(v, eval=TRUE)</code> returns <code>"x"</code>
while <code>deparse(v)</code> returns <code>"\"x\""</code>.
</p>
</li>
<li><p> the result of <code>NULL</code> is <code>NULL</code> instead of <code>"NULL"</code> which is the case with <code>deparse()</code>.
</p>
</li>
<li><p> the result of a non-existent object is <code>NULL</code>, while <code>deparse()</code> returns an error stating
that the object does not exist.
</p>
</li></ul>

<p>When <code>get_obj_name</code> operates on non-existent objects it works at follows:
</p>

<ul>
<li><p> when <code>eval=FALSE</code> it returns the name of the non-existent object
enclosed in quotes (e.g. <code>get_obj_name(nonexistent)</code> returns <code>"nonexistent"</code>, assuming <code>nonexistent</code>
does not exist).
</p>
</li>
<li><p> when <code>eval=TRUE</code> it returns NULL.
</p>
</li></ul>

<p>Finally <code>get_obj_name(NULL)</code> returns <code>NULL</code>, while <code>as.character(NULL)</code> returns <code>as.character(0)</code>.
</p>


<h3>Value</h3>

<p>The name of the object in the <code>n</code>-th parent generation environment.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_obj_value">get_obj_value</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1:
# This example shows the difference between using get_obj_name() and deparse(substitute())
g &lt;- function(y) { return(list(obj_name=get_obj_name(y, n=2, silent=FALSE), 
                               substitute=deparse(substitute(y, parent.frame(n=2))) )) }
f &lt;- function(x) { g(x) }
z = 3; 
f(z)           # After showing the names of objects as they
               # are traversed in the parameter chain (silent=FALSE),
               # this function returns a list where
               # the first element (result of get_obj_name()) is "z"
               # and the second element (result of deparse(substitute())) is "y".
               # Note that 'z' is the object leading to object 'y'
               # inside function g() if we follow the parameter names
               # leading to 'y' in the function calling chain.

# Example 2:
# When eval=TRUE, get_obj_name() behaves the same way as deparse()
# (except for the cases noted in the Details section)
# because the values of all objects linked by the parameter chain
# are ALL the same.
g &lt;- function(y) { return(list(obj_name=get_obj_name(y, n=2, eval=TRUE),
                               deparse=deparse(y))) }
f &lt;- function(x) { g(x) }
z = 3 
f(z)           # Returns a list where both elements are equal to "3"
               # because the output of get_obj_name() with eval=TRUE
               # and deparse() are the same.

# Example 3:
# This example shows how we can use get_obj_name() to get the parameter names
# of non '...' parameters, which are then used in messages to the user.
# The advantage of using get_obj_name() as opposed to the hard-coded parameter name
# is that an error is raised if the parameter does not exist.
# An example is also shown that uses as.list(environment()), which clearly is more
# general... get_obj_name() should be used when referring to a couple of specific
# parameters.
f &lt;- function(x, y, ...) {
  cat("Arguments received by the function (using get_obj_name()) (explicit listing):\n")
  cat(get_obj_name(x), ":", x, "\n")
  cat(get_obj_name(y), ":", y, "\n")
  cat("Arguments received by the function (using as.list(environment())) (automatic listing):\n")
  paramsList = as.list(environment())
  paramsNames = names(paramsList)
  sapply(paramsNames, get_obj_name)
  for (p in paramsNames) {
    cat(p, ":", paramsList[[p]], "\n")
  }
}
z = 5
extra_param = "a '...' parameter" 
  ## Note: this exra parameter is NOT shown neither by get_obj_name()
  ## nor by as.list(environment())
f("test", z, extra_param)
</code></pre>

<hr>
<h2 id='get_obj_value'>Return the value of the object at a given parent generation leading to the specified object</h2><span id='topic+get_obj_value'></span>

<h3>Description</h3>

<p>This function is mostly useful in debugging contexts to query the value of a variable in
specific environments of the calling stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_obj_value(obj, n = 0, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_obj_value_+3A_obj">obj</code></td>
<td>
<p>object whose value should be returned. The object can be passed either as a variable name or
as a string representing the object whose value is of interest.</p>
</td></tr>
<tr><td><code id="get_obj_value_+3A_n">n</code></td>
<td>
<p>number of parent generations to go back to retrieve the value of the object that leads to <code>obj</code>
in the function calling chain. See details for more information.</p>
</td></tr>
<tr><td><code id="get_obj_value_+3A_silent">silent</code></td>
<td>
<p>when <code>FALSE</code>, the names of the environments and objects in those environments are printed,
as those environments are traversed by this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result of this function is similar to using <code>eval()</code> or <code>evalq()</code> but not
quite the same. Refer to the Details and Examples sections for explantion and illustration
of the differences.
</p>
<p>The purpose of this function is to get the value of object <code>obj</code> in a given parent environment.
</p>
<p>Note that conceptually this is NOT the same as calling <code>evalq(obj, parent.frame(n))</code>,
because of the following:
</p>

<ul>
<li> <p><code>evalq()</code> evaluates the object named <code>obj</code> in the environment that is at the
<code>n</code>-th parent generation. (Note the use of <code>evalq()</code> and not <code>eval()</code> because 
the latter evaluates the object at the calling environment first, before passing it
for evaluation to the given parent environment.)
</p>
</li>
<li> <p><code>get_obj_value()</code> first looks for the object in the <code>n</code>-th parent generation
that <em>led</em> to the <code>obj</code> object in the calling environment (i.e. the environment
that calls <code>get_obj_value()</code> and only <em>then</em> evaluates it at the <code>n</code>-th parent generation.
</p>
</li></ul>

<p>The job performed by <code>get_obj_value()</code> is done as follows:
at each parent generation, there is a pair of &quot;object name&quot; &lt;-&gt; &quot;object value&quot;.
The task of this function is to retrieve the object name at a given parent generation
and then its value based on the &quot;path&quot; (of variable names) that leads to the variable
in the function that calls <code>get_obj_value()</code>.
</p>
<p>In practice though the result of <code>get_obj_value()</code> is the same as the value
of the queried object at the calling function, since the value of the variables leading
to that object are all the same through the calling stack.
But using <code>get_obj_value()</code> can provide additional information if we set parameter
<code>silent=FALSE</code>: in such case the function shows the name of the different
variables that lead to the queried object in the calling function. An example is given
in the Examples section.
</p>
<p>The function can also be used to query the value of any object in a particular environment,
i.e. not necessarily the value of an object <em>leading</em> to an object existing in
the calling environment. This can be done somewhat with less writing than using <code>evalq()</code>.
</p>
<p>If the <code>obj</code> is given as a string, it also evaluates to the object value when an object
with that name exists in the given parent generation. However, the object should be passed
with no explicit reference to the environment where it is defined.
For instance we should use <code>with(env1, get_obj_value("z"))</code> and
<em>not</em> <code>get_obj_value("env1$z")</code>, which returns simply <code>"env1$z"</code>.
</p>


<h3>Value</h3>

<p>The value of the object in the <code>n</code>-th parent generation from the calling
environment, as described in the Details section.
</p>


<h3>See Also</h3>

<p><code>get_obj_name()</code> which returns the <em>name</em> of the object in the calling stack
leading to the queried object in the calling environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of using get_obj_value() from within a function
# The value returned by get_obj_value() is compared to the values returned by eval() and evalq()
compareResultsOfDiferentEvaluations &lt;- function(x) {
  cat("Looking at the path of variables leading to parameter 'x':\n")
  xval = get_obj_value(x, n=1, silent=FALSE)
  cat("Value of 'x' at parent generation 1 using get_obj_value():", xval, "\n")
  cat("Value of 'x' at parent generation 1 using eval():", eval(x, parent.frame(1)), "\n")
  cat("Value of 'x' at parent generation 1 using evalq():", evalq(x, parent.frame(1)), "\n")
}
g &lt;- function(y) {
  x = 2
  compareResultsOfDiferentEvaluations(y)
}
z = 3
g(z) 
   ## Note how the result of get_obj_value() is the same as eval() (=3)
   ## but not the same as evalq() (=2) because the queried object (x)
   ## exists in the queried parent generation (g()) with value 2.
   ## The results of eval() and get_obj_value() are the same but
   ## obtained in two different ways:
   ## - eval() returns the value of 'x' in the calling function (even though
   ## the evaluation environment is parent.frame(1), because eval() first
   ## evaluates the object in the calling environment)
   ## - get_obj_value() returns the value of 'y' in the parent generation
   ## of the calling function (which is the execution environment of g())
   ## since 'y' is the variable leading to variable 'x' in the calling function.
   ##
   ## NOTE however, that using get_obj_value() does NOT provide any new
   ## information to the result of eval(), since the variable values are
   ## transmitted UNTOUCHED through the different generations in the
   ## function calling chain.
   ## FURTHERMORE, the same value is returned by simply referencing 'x'
   ## so we don't need neither the use of get_obj_value() nor eval().
   ## The only interesting result would be provided by the evalq() call
   ## which looks for variable 'x' at the parent generation and evaluates it.

# Example of calling get_obj_value() from outside a function
x = 3
v = c(4, 2)
get_obj_value(x)         # 3
get_obj_value("x")       # 3
get_obj_value(3)         # 3
get_obj_value(v[1])      # 4

</code></pre>

<hr>
<h2 id='get_objects_in_package'>Get the objects defined in a given package's namespace</h2><span id='topic+get_objects_in_package'></span>

<h3>Description</h3>

<p>Get the objects defined in a given package's namespace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_objects_in_package(package_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_objects_in_package_+3A_package_name">package_name</code></td>
<td>
<p>string containing the package name (e.g. &quot;envnames&quot;) of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array containing the objects defined in a package namespace, as obtained
by <code>ls(asNamespace(package_name))</code>, or NULL if the package does not exist.
</p>

<hr>
<h2 id='get_searchpath_environment_addresses'>Return the system and package environments in the search path</h2><span id='topic+get_searchpath_environment_addresses'></span>

<h3>Description</h3>

<p>Return the system and package environments in the search path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_searchpath_environment_addresses()
</code></pre>


<h3>Value</h3>

<p>a named array containing the addresses of the system and package environments
found in the <code>search()</code> path with the environment names as its names attribute.
</p>

<hr>
<h2 id='get_user_environment_names_in_env'>Look for user environments defined inside an environment</h2><span id='topic+get_user_environment_names_in_env'></span>

<h3>Description</h3>

<p>Look for user environments defined inside an environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_user_environment_names_in_env(envir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_user_environment_names_in_env_+3A_envir">envir</code></td>
<td>
<p>environment where the search should be carried out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array containing the names of the user environments found
in the <code>envir</code> environment or NULL if <code>envir</code> is not an environment.
</p>

<hr>
<h2 id='get_user_environment_names_in_search_path'>Look for user environments defined inside any of the system/package environments
of the search path</h2><span id='topic+get_user_environment_names_in_search_path'></span>

<h3>Description</h3>

<p>Look for user environments defined inside any of the system/package environments
of the search path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_user_environment_names_in_search_path()
</code></pre>


<h3>Value</h3>

<p>an array containing the names of the user environments found
inside any of the system/package environments in the search path (retrieved by <code>search()</code>).
The names attribute of the array is the system/package environment where the
environment is found.
<code>NULL</code> is returned if the process fails or no environments are found.
</p>

<hr>
<h2 id='get_user_environments_in_user_envs_recursively'>Get the user environments defined recursively within the given user environments</h2><span id='topic+get_user_environments_in_user_envs_recursively'></span>

<h3>Description</h3>

<p>Get the user environments defined recursively within the given user environments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_user_environments_in_user_envs_recursively(env_user_names, envir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_user_environments_in_user_envs_recursively_+3A_env_user_names">env_user_names</code></td>
<td>
<p>names of the user environments where the recursive search is carried out.</p>
</td></tr>
<tr><td><code id="get_user_environments_in_user_envs_recursively_+3A_envir">envir</code></td>
<td>
<p>user environment where ALL environments in <code>env_user_names</code> live,
or <code>NULL</code> if those environments may live in different environments. In this case
the names of the environment where each <code>env_user_names</code> live is taken
from its names attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following elements:
</p>

<ul>
<li><p>fullnames the full names of the environments
</p>
</li>
<li><p>addresses the addresses of the environments
</p>
</li>
<li><p>locationaddresses the addresses of the locations of the environments
</p>
</li></ul>


<hr>
<h2 id='is_logical'>Check whether an object contains a valid logical value</h2><span id='topic+is_logical'></span>

<h3>Description</h3>

<p>Check whether an object contains a valid logical value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_logical(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_logical_+3A_x">x</code></td>
<td>
<p>object to check. A scalar is assumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function silently handles special cases for which is.null() and is.na() (called by this function)
may return a warning, such as functions objects or environments.
(e.g. the warning &quot;Warning message: In is.na(g) : is.na() applied to non-(list or vector) of type 'closure')&quot;
</p>


<h3>Value</h3>

<p>boolean indicating whether the scalar object contains a valid logical value (i.e. TRUE or FALSE)
and is not NA nor NULL, and has positive length.
FALSE is returned if the object does not exist.
</p>

<hr>
<h2 id='is_memory_address'>Check whether a string is a memory address</h2><span id='topic+is_memory_address'></span>

<h3>Description</h3>

<p>Check whether an object represents a valid memory address. If the object does not exist or is not of the
correct type FALSE is returned, no error is raised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_memory_address(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_memory_address_+3A_x">x</code></td>
<td>
<p>object to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Valid memory addresses depend on the architecture. For instance:
- for Windows 32-bit systems, an 8-bit representation (since 2^32 = 16^8)
- for Windows 64-bit systems, a 16-bit representation (since 2^64 = 16^16)
- for Linux Debian 64-bit systems, a 12-bit representation seems to be the case...
(ref: Ubuntu 18.04 LTS on Windows)
</p>
<p>Example of valid memory addresses for Windows 64-bit systems:
&quot;&lt;(16-digit-code)&gt;&quot; (e.g. &quot;&lt;000000000974E880&gt;&quot;)
&quot;&lt;0x(16-digit-code)&gt;&quot; (e.g. &quot;&lt;0x000000000974E880&gt;&quot;)
&quot;&lt;environment: 0x(16-digit-code)&gt;&quot; (e.g. &quot;&lt;environment: 0x000000000974E880&gt;&quot;)
</p>


<h3>Value</h3>

<p>boolean indicating whether the given object represents a valid memory address.
</p>

<hr>
<h2 id='is_null_or_na'>Check whether an object is NULL or NA.</h2><span id='topic+is_null_or_na'></span>

<h3>Description</h3>

<p>This function silently handles special cases for which is.null() and is.na() may return a warning,
such as functions objects or environments.
(e.g. the warning &quot;Warning message: In is.na(g) : is.na() applied to non-(list or vector) of type 'closure')&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_null_or_na(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_null_or_na_+3A_x">x</code></td>
<td>
<p>object to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean indicating whether the object is NULL or NA.
FALSE is returned if the object does not exist.
</p>

<hr>
<h2 id='is_string'>Check whether an object is a string.</h2><span id='topic+is_string'></span>

<h3>Description</h3>

<p>WARNING: This function fails when the value of x is &quot;x&quot;!! (i.e. it returns TRUE even when object 'x' is NOT a string per se &ndash;i.e. it was not passed as &quot;x&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_string(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_string_+3A_x">x</code></td>
<td>
<p>object to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result of this function is different from is.character(x) since this function returns TRUE
for an array of character values!
</p>


<h3>Value</h3>

<p>boolean indicating whether the object is a string.
</p>

<hr>
<h2 id='obj_find'>Find an object in the workspace including user-defined environments</h2><span id='topic+obj_find'></span>

<h3>Description</h3>

<p>Look for an object in the whole workspace including all environments defined within it
(possibly recursively) and return ALL the environment(s) where the object is found.
User-defined environments are also searched.
Note that both the &quot;recursive search&quot; and the &quot;user-defined environments search&quot; makes this function
quite different from functions <a href="utils.html#topic+find">find</a> and <a href="base.html#topic+exists">exists</a> of the base package.
Optionally, the search can be limited to a specified environment, as opposed to carrying it out in the whole workspace.
Still, all user-defined environments defined inside the specified environment are searched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj_find(
  obj,
  envir = NULL,
  envmap = NULL,
  globalsearch = TRUE,
  n = 0,
  return_address = FALSE,
  include_functions = FALSE,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obj_find_+3A_obj">obj</code></td>
<td>
<p>object to be searched given as the object itself or as a character string. If given as an object,
expressions are accepted (see details on how expressions are handled).</p>
</td></tr>
<tr><td><code id="obj_find_+3A_envir">envir</code></td>
<td>
<p>environment where the search for <code>obj</code> should be carried out.
It defaults to <code>NULL</code> which means <code>obj</code> is searched in the calling environment
(i.e. in the environment calling this function), unless <code>globalsearch=TRUE</code> in which case
it is searched in the whole workspace.</p>
</td></tr>
<tr><td><code id="obj_find_+3A_envmap">envmap</code></td>
<td>
<p>data frame containing a lookup table with name-address pairs of environment names and
addresses to be used when searching for environment <code>env</code>. It defaults to <code>NULL</code> which means that the
lookup table is constructed on the fly with the environments defined in the <code>envir</code> environment
&ndash;if not <code>NULL</code>&ndash;, or in the whole workspace if <code>envir=NULL</code>.
See the details section for more information on its structure.</p>
</td></tr>
<tr><td><code id="obj_find_+3A_globalsearch">globalsearch</code></td>
<td>
<p>when <code>envir=NULL</code> it specifies whether the search for <code>obj</code> should be done
globally, i.e. in the whole workspace, or just within the calling environment.</p>
</td></tr>
<tr><td><code id="obj_find_+3A_n">n</code></td>
<td>
<p>non-negative integer indicating the number of levels to go up from the calling function environment
to evaluate <code>obj</code>. It defaults to 0 which implies that <code>obj</code> is evaluated in the environment
of the calling function (i.e. the function that calls <code>obj_find()</code>).</p>
</td></tr>
<tr><td><code id="obj_find_+3A_return_address">return_address</code></td>
<td>
<p>whether to return the address of the environments where the object is found in addition
to their names.</p>
</td></tr>
<tr><td><code id="obj_find_+3A_include_functions">include_functions</code></td>
<td>
<p>whether to include funtion execution environments as environments where the object
is searched for. Set this flag to <code>TRUE</code> with caution because there may be several functions where the
same object is defined, for instance functions that are called as part of the object searching process!</p>
</td></tr>
<tr><td><code id="obj_find_+3A_silent">silent</code></td>
<td>
<p>run in silent mode? If not, the search history is shown,
listing all the environments that are searched for object <code>obj</code>. It defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object is found in an environment if it is reachable from within that environment. An object is considered
reachable in an environment if either one of the following occurs:
</p>

<ul>
<li><p> it exists in the given environment
</p>
</li>
<li><p> it exists in a user-defined environment defined inside the given environment or in any environment
recursively defined inside them
</p>
</li></ul>

<p>Note that <code>obj_find</code> differs from base functions <code>find</code> and <code>exists</code> in that <code>obj_find</code>
searches for the object inside user-defined environments within any given environment in a <em>recursive</em> way.
</p>
<p>In particular, compared to:
</p>

<ul>
<li><p><code>find</code>: <code>obj_find</code> searches for objects inside user-defined environments while <code>find</code> is not
able to do so (see examples).
</p>
</li>
<li><p><code>exists</code>: <code>obj_find</code> <em>never</em> searches for objects in the parent environment of <code>envir</code>
when <code>envir</code> is not <code>NULL</code>, as is the case with the <code>exists</code> function when its <code>inherits</code>
parameter is set to <code>TRUE</code> (the default).
If it is wished to search for objects in parent environments, simply set <code>envir=NULL</code>
and <code>globalsearch=TRUE</code>, in which case the object will be searched in the whole workspace
and the environments where it is found will be returned.
</p>
</li></ul>

<p>When the object is found, an array containing the names of all the environments where the object is found is
returned.
</p>
<p>When <code>envir</code> is not <code>NULL</code> attached packages are not included in the search for <code>obj</code>,
unless of course <code>envir</code> is itself a package environment.
</p>
<p>When given as an object, <code>obj</code> can be an expression. If the expression is an attribute of a list
or an array element, the object contained therein is searched for.
Ex: if <code>alist$var = "x"</code> then object <code>x</code> is searched.
</p>
<p>If <code>envmap</code> is passed it should be a data frame providing an address-name pair lookup table
of environments and should contain at least the following columns:
</p>

<ul>
<li><p><code>location</code> for user-defined environments, the name of the environment where the environment
is located; otherwise <code>NA</code>.
</p>
</li>
<li><p><code>pathname</code> the full <em>environment path</em> to reach the environment separated by <code>$</code>
(e.g. <code>"env1$env$envx"</code>)
</p>
</li>
<li><p><code>address</code> the 8-digit (32-bit architectures) thru 16-digit (64-bit architectures) memory address
of the environment given in <code>pathname</code> enclosed in &lt; &gt; (e.g. <code>"&lt;0000000007DCFB38&gt;"</code>
(64-bit architectures))
Be ware that Linux Debian distributions may have a 12-digit memory address representation.
So the best way to know is to check a memory address by calling e.g. 'address(&quot;x&quot;)'.
</p>
</li></ul>

<p>Passing an <code>envmap</code> lookup table is useful for speedup purposes, in case several calls to this
function will be performed in the context of an unchanged set of defined environments.
Such <code>envmap</code> data frame can be created by calling <a href="#topic+get_env_names">get_env_names</a>.
Use this parameter with care, as the matrix passed may not correspond to the actual mapping of existing
environments to their addresses and in that case results may be different from those expected.
</p>


<h3>Value</h3>

<p>The return value depends on the value of parameter <code>return_address</code>: when <code>FALSE</code>
(the default) it returns an array containing the names of the environments where the object <code>obj</code>
is found; when <code>TRUE</code> it returns a list with two attributes: <code>"env_full_names"</code> and
<code>"env_addresses"</code> with respectively the environment names and addresses where the object is found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a variable in the global environment
x = 4
# Create new environments, some nested
env1 = new.env()
with(env1, envx &lt;- new.env())
env1$x = 3
env1$envx$x = 2
env1$y = 5

# Look for objects (crawling environments recursively)
obj_find(x)                  # "env1" "env1$envx" "R_GlobalEnv"
obj_find("x")                # "env1" "env1$envx" "R_GlobalEnv"
obj_find("x", envir=env1)    # "env1" "envx" (as the search is limited to the env1 environment)
obj_find("y")                # "env1"
obj_find(nonexistent)        # NULL (note that NO error is raised even if the object does not exist)
</code></pre>

<hr>
<h2 id='parse_memory_address'>Parse a string that represents a memory address</h2><span id='topic+parse_memory_address'></span>

<h3>Description</h3>

<p>Parse a string representing a memory address so that the address is returned in the way it is stored
in the 'address' column of the data frame returned by get_env_names().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_memory_address(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_memory_address_+3A_x">x</code></td>
<td>
<p>string to parse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string containing the memory address represented by the input string after stripping any
extraneous pieces of string, namely : &quot;0x&quot; and &quot;environment: &quot; and after enclosing it in '&lt;&gt;'.
For 32-bit architecture the string would be of the form &quot;&lt;xxxxxxxx&gt;&quot; where x represents
digits between 0 and 9 and letters between &quot;a&quot; and &quot;f&quot;. Ex: &quot;&lt;07830f40&gt;&quot;
For 64-bit architecture the string would be of the form &quot;&lt;xxxxxxxxxxxxxxxx&gt;&quot; where x represents
digits between 0 and 9 and letters between &quot;a&quot; and &quot;f&quot;. Ex: &quot;&lt;07830f40&gt;&quot;
</p>

<hr>
<h2 id='reset_option_warn'>Resets the &quot;warn&quot; option to the value stored in the hidden variable .option_warn
(set in global_definitions.r to the original value of the &quot;warn&quot; option when the package is loaded).</h2><span id='topic+reset_option_warn'></span>

<h3>Description</h3>

<p>Resets the &quot;warn&quot; option to the value stored in the hidden variable .option_warn
(set in global_definitions.r to the original value of the &quot;warn&quot; option when the package is loaded).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_option_warn()
</code></pre>

<hr>
<h2 id='set_option_warn_to_nowarning'>Set the &quot;warn&quot; options to -1 to avoid warning messages. The hidden variable .option_warn
defined in global_definitions.r has already been set to the original value of the &quot;warn&quot; option,
at the moment when the package is loaded, so that we can reset it later.</h2><span id='topic+set_option_warn_to_nowarning'></span>

<h3>Description</h3>

<p>Set the &quot;warn&quot; options to -1 to avoid warning messages. The hidden variable .option_warn
defined in global_definitions.r has already been set to the original value of the &quot;warn&quot; option,
at the moment when the package is loaded, so that we can reset it later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_option_warn_to_nowarning()
</code></pre>

<hr>
<h2 id='standardize_env_name'>Standardize the name of a named environment</h2><span id='topic+standardize_env_name'></span>

<h3>Description</h3>

<p>This function standardizes the name of a named environment so it is consistent
with the output of the base function <a href="base.html#topic+environmentName">environmentName</a>.
For instance <code>globalenv()</code>, <code>.GlobalEnv</code> becomes <code>"R_GlobalEnv"</code>
<code>emptyenv()</code> becomes <code>"R_EmptyEnv"</code>
<code>baseenv()</code> or <code>as.environment("package:base")</code> becomes <code>"base"</code>.
All other named environments such as packages and namespaces are also converted
to the standard name used by R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_env_name(env_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_env_name_+3A_env_name">env_name</code></td>
<td>
<p>environment name to standardize.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standardized name of the environment. If the environment is NOT a named
environment and it does not contain an expression that resolves to a named environment
it returns the input name as is. This includes strings that represent non-existing objects.
</p>

<hr>
<h2 id='testenv'>Environment used in testing the package</h2><span id='topic+testenv'></span>

<h3>Description</h3>

<p>Environment used in testing the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testenv
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 1.</p>

<hr>
<h2 id='unlist_with_names'>Call unlist and preserve the names</h2><span id='topic+unlist_with_names'></span>

<h3>Description</h3>

<p>Function <code>unlist</code> is called so that the output is an array (whenever possible) whose names
attribute contains the names of the elements of the list (unchanged, i.e. without adding a number
to identify them as the regular <code>unlist()</code> function does).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unlist_with_names(alist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unlist_with_names_+3A_alist">alist</code></td>
<td>
<p>list to unlist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Whenever possible, an array whose names attribute is set to the names of the elements of the list.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
