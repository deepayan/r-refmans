<!DOCTYPE html><html lang="en"><head><title>Help for package OPSR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OPSR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#OPSR-package'><p>OPSR: Ordinal Probit Switching Regression</p></a></li>
<li><a href='#anova.opsr'><p>ANOVA for OPSR Model Fits</p></a></li>
<li><a href='#extract+2Copsr-method'><p>Extract Method for OPSR Model Fits</p></a></li>
<li><a href='#loglik_cpp'><p>Interface to C++ Log-Likelihood Implementation</p></a></li>
<li><a href='#loglik_R'><p>R-based Log-Likelihood Implementation</p></a></li>
<li><a href='#model.frame.opsr'><p>Extracting the Model Frame from OPSR Model Fits</p></a></li>
<li><a href='#model.matrix.opsr'><p>Construct Design Matrices for OPSR Model Fits</p></a></li>
<li><a href='#opsr'><p>Fitting Ordinal Probit Switching Regression Models</p></a></li>
<li><a href='#opsr_2step'><p>Heckman Two-Step Estimation</p></a></li>
<li><a href='#opsr_check_omp'><p>Check Whether <code>OpenMP</code> is Available</p></a></li>
<li><a href='#opsr_check_start'><p>Check the User-Specified Starting Values</p></a></li>
<li><a href='#opsr_max_threads'><p>Check Maximum Number of Threads Available</p></a></li>
<li><a href='#opsr_null_model'><p>Null Model for OPSR Model fits</p></a></li>
<li><a href='#opsr_prepare_coefs'><p>Prepares Coefficients for Likelihood Function</p></a></li>
<li><a href='#opsr_simulate'><p>Simulate Data from an OPSR Process</p></a></li>
<li><a href='#opsr.fit'><p>Fitter Function for Ordinal Probit Switching Regression Models</p></a></li>
<li><a href='#predict.opsr'><p>Predict Method for OPSR Model Fits</p></a></li>
<li><a href='#print.anova.opsr'><p>Print Method for ANOVA OPSR Objects</p></a></li>
<li><a href='#print.summary.opsr'><p>Print Method for Summary OPSR Objects</p></a></li>
<li><a href='#summary.opsr'><p>Summarizing OPSR Model Fits</p></a></li>
<li><a href='#telework_data'><p>Telework data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Ordinal Probit Switching Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates ordinal probit switching regression models - a Heckman
    type selection model with an ordinal selection and continuous outcomes.
    Different model specifications are allowed for each treatment/regime. For
    more details on the method, see Wang &amp; Mokhtarian (2024) &lt;<a href="https://doi.org/10.1016%2Fj.tra.2024.104072">doi:10.1016/j.tra.2024.104072</a>&gt;
    or Chiburis &amp; Lokshin (2007) &lt;<a href="https://doi.org/10.1177%2F1536867X0700700202">doi:10.1177/1536867X0700700202</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>car, Formula, MASS, maxLik, methods, mvtnorm, Rcpp, Rdpack (&ge;
0.7), sandwich, stats, texreg, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dheimgartner/OPSR">https://github.com/dheimgartner/OPSR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dheimgartner/OPSR/issues">https://github.com/dheimgartner/OPSR/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-29 13:43:33 UTC; daniel</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Heimgartner
    <a href="https://orcid.org/0000-0002-0643-8690"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Xinyi Wang <a href="https://orcid.org/0000-0002-3564-9147"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Heimgartner &lt;d.heimgartners@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-01 14:30:23 UTC</td>
</tr>
</table>
<hr>
<h2 id='OPSR-package'>OPSR: Ordinal Probit Switching Regression</h2><span id='topic+OPSR'></span><span id='topic+OPSR-package'></span>

<h3>Description</h3>

<p>Estimates ordinal probit switching regression models - a Heckman type selection model with an ordinal selection and continuous outcomes. Different model specifications are allowed for each treatment/regime. For more details on the method, see Wang &amp; Mokhtarian (2024) <a href="https://doi.org/10.1016/j.tra.2024.104072">doi:10.1016/j.tra.2024.104072</a> or Chiburis &amp; Lokshin (2007) <a href="https://doi.org/10.1177/1536867X0700700202">doi:10.1177/1536867X0700700202</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Daniel Heimgartner <a href="mailto:d.heimgartners@gmail.com">d.heimgartners@gmail.com</a> (<a href="https://orcid.org/0000-0002-0643-8690">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Xinyi Wang <a href="mailto:xinyi174@mit.edu">xinyi174@mit.edu</a> (<a href="https://orcid.org/0000-0002-3564-9147">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/dheimgartner/OPSR">https://github.com/dheimgartner/OPSR</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/dheimgartner/OPSR/issues">https://github.com/dheimgartner/OPSR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='anova.opsr'>ANOVA for OPSR Model Fits</h2><span id='topic+anova.opsr'></span>

<h3>Description</h3>

<p>Conducts likelihood ratio tests for one or more OPSR model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'opsr'
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.opsr_+3A_object">object</code></td>
<td>
<p>an object of class <code>"opsr"</code>.</p>
</td></tr>
<tr><td><code id="anova.opsr_+3A_...">...</code></td>
<td>
<p>additional objects of class <code>"opsr"</code>. See also the 'Details' section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If only a single object is passed then the model is compared to the null model
(<code><a href="#topic+opsr_null_model">opsr_null_model</a></code>). If more than one object is specified, a likelihood ratio
test is conducted for each pair of neighboring models. It is conventional to
list the models from smallest to largest, but this is up to the user.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova.opsr"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+anova">stats::anova</a></code>, <code><a href="#topic+print.anova.opsr">print.anova.opsr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_dat &lt;- opsr_simulate()
dat &lt;- sim_dat$data
model &lt;- ys | yo ~ xs1 + xs2 | xo1 + xo2
fit &lt;- opsr(model, dat)
fit_null &lt;- opsr_null_model(fit)
fit_intercept &lt;- update(fit, ~ . | 1)

anova(fit)
anova(fit_null, fit_intercept, fit)
</code></pre>

<hr>
<h2 id='extract+2Copsr-method'>Extract Method for OPSR Model Fits</h2><span id='topic+extract+2Copsr-method'></span><span id='topic+extract.opsr'></span>

<h3>Description</h3>

<p>This is the main method called when using functions from the <code>texreg-package</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'opsr'
extract(
  model,
  beside = FALSE,
  include.structural = TRUE,
  include.selection = TRUE,
  include.outcome = TRUE,
  include.pseudoR2 = FALSE,
  include.R2 = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract+2B2Copsr-method_+3A_model">model</code></td>
<td>
<p>an object of class <code>"opsr"</code>.</p>
</td></tr>
<tr><td><code id="extract+2B2Copsr-method_+3A_beside">beside</code></td>
<td>
<p>if <code>TRUE</code>, prints structural, selection and outcome coefficients side-by-side.</p>
</td></tr>
<tr><td><code id="extract+2B2Copsr-method_+3A_include.structural">include.structural</code></td>
<td>
<p>whether or not structural coefficients should be printed.</p>
</td></tr>
<tr><td><code id="extract+2B2Copsr-method_+3A_include.selection">include.selection</code></td>
<td>
<p>whether or not selection coefficients should be printed.</p>
</td></tr>
<tr><td><code id="extract+2B2Copsr-method_+3A_include.outcome">include.outcome</code></td>
<td>
<p>whether or not outcome coefficients should be printed.</p>
</td></tr>
<tr><td><code id="extract+2B2Copsr-method_+3A_include.pseudor2">include.pseudoR2</code></td>
<td>
<p>whether or not the pseudo R2 statistic for the selection
component should be printed. See also the 'Details' section.</p>
</td></tr>
<tr><td><code id="extract+2B2Copsr-method_+3A_include.r2">include.R2</code></td>
<td>
<p>whether or not the R2 statistic for the outcome component
should be printed.</p>
</td></tr>
<tr><td><code id="extract+2B2Copsr-method_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+summary.opsr">summary.opsr</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>extract</code> method is called internally. Higher-level functions from the
<code>texreg-package</code> pass arguments via <code>...</code> to <code>extract</code>.
</p>
<p><code>include.pseudoR2</code> reports both the &quot;equally likely&quot; (EL) and &quot;market share&quot; (MS)
pseudo R2.
</p>


<h3>Value</h3>

<p>A <code>texreg-class</code> object representing the statistical model.
</p>


<h3>See Also</h3>

<p><code>texreg-package</code>, <code><a href="texreg.html#topic+texreg">texreg::texreg</a></code>, <code><a href="texreg.html#topic+screenreg">texreg::screenreg</a></code> and related functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_dat &lt;- opsr_simulate()
dat &lt;- sim_dat$data
model &lt;- ys | yo ~ xs1 + xs2 | xo1 + xo2
fit &lt;- opsr(model, dat)
fit_null &lt;- opsr_null_model(fit)
fit_intercept &lt;- update(fit, ~ . | 1)

texreg::screenreg(fit)
texreg::screenreg(fit, beside = TRUE)
texreg::screenreg(fit, beside = TRUE, include.pseudoR2 = TRUE, include.R2 = TRUE)
texreg::screenreg(list(fit_null, fit_intercept, fit))
</code></pre>

<hr>
<h2 id='loglik_cpp'>Interface to C++ Log-Likelihood Implementation</h2><span id='topic+loglik_cpp'></span>

<h3>Description</h3>

<p>This is the main computation engine wrapped by <code><a href="#topic+opsr.fit">opsr.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik_cpp(theta, W, X, Y, weights, nReg, nThreads)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik_cpp_+3A_theta">theta</code></td>
<td>
<p>named coefficient vector as parsed from formula interface <code><a href="#topic+opsr">opsr</a></code>.</p>
</td></tr>
<tr><td><code id="loglik_cpp_+3A_w">W</code></td>
<td>
<p>list of matrices with explanatory variables for selection process for each regime.</p>
</td></tr>
<tr><td><code id="loglik_cpp_+3A_x">X</code></td>
<td>
<p>list of matrices with expalanatory varialbes for outcome process for each regime.</p>
</td></tr>
<tr><td><code id="loglik_cpp_+3A_y">Y</code></td>
<td>
<p>list of vectors with continuous outcomes for each regime.</p>
</td></tr>
<tr><td><code id="loglik_cpp_+3A_weights">weights</code></td>
<td>
<p>vector of weights. See also <code><a href="#topic+opsr">opsr</a></code>.</p>
</td></tr>
<tr><td><code id="loglik_cpp_+3A_nreg">nReg</code></td>
<td>
<p>integer number of regimes.</p>
</td></tr>
<tr><td><code id="loglik_cpp_+3A_nthreads">nThreads</code></td>
<td>
<p>number of threads to be used by <code>OpenMP</code> (should be max. <code>nReg</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of (weighted) log-likelihood contributions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opsr.fit">opsr.fit</a></code>, <code><a href="#topic+loglik_R">loglik_R</a></code>
</p>

<hr>
<h2 id='loglik_R'>R-based Log-Likelihood Implementation</h2><span id='topic+loglik_R'></span>

<h3>Description</h3>

<p>R-based Log-Likelihood Implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik_R(theta, W, X, Y, weights, nReg, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+loglik_cpp">loglik_cpp</a></code>, <code><a href="#topic+opsr.fit">opsr.fit</a></code>
</p>

<hr>
<h2 id='model.frame.opsr'>Extracting the Model Frame from OPSR Model Fits</h2><span id='topic+model.frame.opsr'></span>

<h3>Description</h3>

<p>Extracting the Model Frame from OPSR Model Fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'opsr'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.frame.opsr_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"opsr"</code>.</p>
</td></tr>
<tr><td><code id="model.frame.opsr_+3A_...">...</code></td>
<td>
<p>a mix of further arguments such as <code>data</code>, <code>na.action</code> or <code>subset</code>,
passed to the default method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the variables used in <code>formula$formula</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.frame">stats::model.frame</a></code>
</p>

<hr>
<h2 id='model.matrix.opsr'>Construct Design Matrices for OPSR Model Fits</h2><span id='topic+model.matrix.opsr'></span>

<h3>Description</h3>

<p>Construct Design Matrices for OPSR Model Fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'opsr'
model.matrix(object, data, .filter = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.matrix.opsr_+3A_object">object</code></td>
<td>
<p>an object of class <code>"opsr"</code>.</p>
</td></tr>
<tr><td><code id="model.matrix.opsr_+3A_data">data</code></td>
<td>
<p>a data frame containing the terms from <code>object$formula</code>. Passed to
<code><a href="#topic+model.frame.opsr">model.frame.opsr</a></code>. Can be omitted.</p>
</td></tr>
<tr><td><code id="model.matrix.opsr_+3A_.filter">.filter</code></td>
<td>
<p>used internally in <code><a href="#topic+predict.opsr">predict.opsr</a></code> for counterfactual predictions.</p>
</td></tr>
<tr><td><code id="model.matrix.opsr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists with the design matrices <code>W</code> (selection process) and
<code>X</code> (outcome process). Both of these lists have <code>object$nReg</code> elements (a
separate design matrix for each regime).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model.frame.opsr">model.frame.opsr</a></code>, <code><a href="stats.html#topic+model.matrix">stats::model.matrix</a></code>
</p>

<hr>
<h2 id='opsr'>Fitting Ordinal Probit Switching Regression Models</h2><span id='topic+opsr'></span>

<h3>Description</h3>

<p>High-level formula interface to the workhorse <code><a href="#topic+opsr.fit">opsr.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opsr(
  formula,
  data,
  subset,
  weights,
  na.action,
  start = NULL,
  fixed = NULL,
  method = "BFGS",
  iterlim = 1000,
  printLevel = 2,
  nThreads = 1,
  .get2step = FALSE,
  .useR = FALSE,
  .censorRho = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opsr_+3A_formula">formula</code></td>
<td>
<p>an object of class <code style="white-space: pre;">&#8288;"Formula" "formula"&#8288;</code>: A symbolic description
of the model to be fitted. The details of model specification are given under
'Details'.</p>
</td></tr>
<tr><td><code id="opsr_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If
not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>opsr</code> is called.</p>
</td></tr>
<tr><td><code id="opsr_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used
in the fitting process. (See additional details in the 'Details' section of
the <code><a href="stats.html#topic+model.frame">model.frame</a></code> documentation.).</p>
</td></tr>
<tr><td><code id="opsr_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting process.
Should be <code>NULL</code> or a numeric vector. If non-NULL, then observation-specific
log-likelihood contributions are multiplied by their corresponding weight
before summing.</p>
</td></tr>
<tr><td><code id="opsr_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s. The default is set by the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>,
and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset. The 'factory-fresh' default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.
Another possible value is <code>NULL</code>, no action. Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="opsr_+3A_start">start</code></td>
<td>
<p>a numeric vector with the starting values (passed to <code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>).
If no starting values are provided, reasonable values are auto-generated via
the Heckman 2-step procedure <code><a href="#topic+opsr_2step">opsr_2step</a></code>. The structure of <code>start</code> has to
conform with <code>opsr</code>'s expectations. See <code><a href="#topic+opsr_check_start">opsr_check_start</a></code> for further details.</p>
</td></tr>
<tr><td><code id="opsr_+3A_fixed">fixed</code></td>
<td>
<p>parameters to be treated as constants at their <code>start</code> values. If
present, it is treated as an index vector of <code>start</code> parameters (passed to
<code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>).</p>
</td></tr>
<tr><td><code id="opsr_+3A_method">method</code></td>
<td>
<p>maximzation method (passed to <code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>).</p>
</td></tr>
<tr><td><code id="opsr_+3A_iterlim">iterlim</code></td>
<td>
<p>maximum number of iterations (passed to <code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>).</p>
</td></tr>
<tr><td><code id="opsr_+3A_printlevel">printLevel</code></td>
<td>
<p>larger number prints more working information (passed to <code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>).</p>
</td></tr>
<tr><td><code id="opsr_+3A_nthreads">nThreads</code></td>
<td>
<p>number of threads to be used. Do not pass higher number than
number of ordinal outcomes. See also <code><a href="#topic+opsr_check_omp">opsr_check_omp</a></code> and <code><a href="#topic+opsr_max_threads">opsr_max_threads</a></code>.</p>
</td></tr>
<tr><td><code id="opsr_+3A_.get2step">.get2step</code></td>
<td>
<p>if <code>TRUE</code>, returns starting values as generated by <code><a href="#topic+opsr_2step">opsr_2step</a></code>. Will
not proceed with the maximum likelihood estimation.</p>
</td></tr>
<tr><td><code id="opsr_+3A_.user">.useR</code></td>
<td>
<p>if <code>TRUE</code> usese <code><a href="#topic+loglik_R">loglik_R</a></code>. Go grab a coffe.</p>
</td></tr>
<tr><td><code id="opsr_+3A_.censorrho">.censorRho</code></td>
<td>
<p>if <code>TRUE</code>, rho starting values are censored to lie in the
interval [-0.85, 0.85].</p>
</td></tr>
<tr><td><code id="opsr_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models for <code>opsr</code> are specified symbolically. A typical model has the form
<code>ys | yo ~ terms_s | terms_o1 | terms_o2 | ...</code>. <code>ys</code> is the ordered (numeric)
response vector (starting from 1, in integer-increasing fashion). For the <code>terms</code>
specification the rules of the regular formula interface apply (see also <a href="stats.html#topic+lm">stats::lm</a>).
The intercept in the <code>terms_s</code> (selection process) is excluded automatically
(no need to specify <code>-1</code>). If the user wants to specify the same process for
all continuous outcomes, two processes are enough (<code>ys | yo ~ terms_s | terms_o</code>).
Note that the model is poorly identifiable if <code>terms_s == terms_o</code> (same regressors
are used in selection and outcome processes).
</p>


<h3>Value</h3>

<p>An object of class <code style="white-space: pre;">&#8288;"opsr" "maxLik" "maxim"&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulated data
sim_dat &lt;- opsr_simulate()
dat &lt;- sim_dat$data  # 1000 observations
sim_dat$sigma  # cov matrix of errors
sim_dat$params  # ground truth

## specify a model
model &lt;- ys | yo ~ xs1 + xs2 | xo1 + xo2 | xo1 + xo2 | xo1 + xo2
model &lt;- ys | yo ~ xs1 + xs2 | xo1 + xo2  # since we use the same specification...

## estimate
fit &lt;- opsr(model, dat)

## inference
summary(fit)

## using update and model comparison
fit_updated &lt;- update(fit, ~ . | 1)  # only intercepts for the continuous outcomes
## null model
fit_null &lt;- opsr_null_model(fit)

## likelihood ratio test
anova(fit_null, fit_updated, fit)

## predict
p1 &lt;- predict(fit, group = 1, type = "response")
p2 &lt;- predict(fit, group = 1, counterfact = 2, type = "response")
plot(p1, p2)
abline(a = 0, b = 1, col = "red")

## produce formatted tables
texreg::screenreg(fit, beside = TRUE, include.pseudoR2 = TRUE, include.R2 = TRUE)

</code></pre>

<hr>
<h2 id='opsr_2step'>Heckman Two-Step Estimation</h2><span id='topic+opsr_2step'></span>

<h3>Description</h3>

<p>This is a utility function, used in <code><a href="#topic+opsr">opsr</a></code> and should not be used directly.
Tow-step estimation procedure to generate reasonable starting values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opsr_2step(W, Xs, Z, Ys)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opsr_2step_+3A_w">W</code></td>
<td>
<p>matrix with explanatory variables for selection process.</p>
</td></tr>
<tr><td><code id="opsr_2step_+3A_xs">Xs</code></td>
<td>
<p>list of matrices with expalanatory varialbes for outcome process for each regime.</p>
</td></tr>
<tr><td><code id="opsr_2step_+3A_z">Z</code></td>
<td>
<p>vector with ordinal outcomes (in integer increasing fashion).</p>
</td></tr>
<tr><td><code id="opsr_2step_+3A_ys">Ys</code></td>
<td>
<p>list of vectors with continuous outcomes for each regime.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These estimates can be retrieved by specifying <code>.get2step = TRUE</code> in <code><a href="#topic+opsr">opsr</a></code>.
</p>


<h3>Value</h3>

<p>Named vector with starting values passed to <code><a href="#topic+opsr.fit">opsr.fit</a></code>.
</p>


<h3>Remark</h3>

<p>Since the Heckman two-step estimator includes an estimate in the second step
regression, the resulting OLS standard errors and heteroskedasticity-robust
standard errors are incorrect (Greene 2002).
</p>


<h3>References</h3>

<p>Greene WH (2002).
<em>LIMDEP Version 8.0 Econometric Modeling Guide, vol. 2.</em>.
Econometric Software, Plainview, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opsr.fit">opsr.fit</a></code>, <code><a href="#topic+opsr_prepare_coefs">opsr_prepare_coefs</a></code>
</p>

<hr>
<h2 id='opsr_check_omp'>Check Whether <code>OpenMP</code> is Available</h2><span id='topic+opsr_check_omp'></span>

<h3>Description</h3>

<p>Check Whether <code>OpenMP</code> is Available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opsr_check_omp()
</code></pre>


<h3>Value</h3>

<p>boolean
</p>

<hr>
<h2 id='opsr_check_start'>Check the User-Specified Starting Values</h2><span id='topic+opsr_check_start'></span>

<h3>Description</h3>

<p>This is a utility function, used in <code><a href="#topic+opsr">opsr</a></code> and should not be used directly.
It is included here to document the expected structure of <code><a href="#topic+opsr">opsr</a></code>'s <code>start</code> argument.
Makes sure, the start vector conforms to the expected structure. Adds the
expected parameter names to the numeric vector. Therefore the user has to
conform to the expected order. See 'Details' for further explanation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opsr_check_start(start, W, Xs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opsr_check_start_+3A_start">start</code></td>
<td>
<p>vector of starting values.</p>
</td></tr>
<tr><td><code id="opsr_check_start_+3A_w">W</code></td>
<td>
<p>matrix with explanatory variables for selection process.</p>
</td></tr>
<tr><td><code id="opsr_check_start_+3A_xs">Xs</code></td>
<td>
<p>list of matrices with expalanatory varialbes for outcome process for each regime.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expected order: 1. kappa threshold parameters (for ordinal probit model),
2. parameters of the selection process (names starting with <code>s_</code>), 3. parameters
of the outcome processes (names starting with <code style="white-space: pre;">&#8288;o[0-9]_&#8288;</code>), 4. sigma, 5. rho.
If the same outcome process specification is used in the <code>formula</code>, the starting
values have to be repeated (i.e., the length of the <code>start</code> vector has to
correspond to the total number of estimated parameters in the model).
</p>


<h3>Value</h3>

<p>Named numeric vector conforming to the expected structure.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opsr_2step">opsr_2step</a></code>
</p>

<hr>
<h2 id='opsr_max_threads'>Check Maximum Number of Threads Available</h2><span id='topic+opsr_max_threads'></span>

<h3>Description</h3>

<p>Check Maximum Number of Threads Available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opsr_max_threads()
</code></pre>


<h3>Value</h3>

<p>integer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opsr_check_omp">opsr_check_omp</a></code>
</p>

<hr>
<h2 id='opsr_null_model'>Null Model for OPSR Model fits</h2><span id='topic+opsr_null_model'></span>

<h3>Description</h3>

<p>Intercept-only model with no error correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opsr_null_model(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opsr_null_model_+3A_object">object</code></td>
<td>
<p>an object of class <code>"opsr"</code>.</p>
</td></tr>
<tr><td><code id="opsr_null_model_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+opsr">opsr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code style="white-space: pre;">&#8288;"opsr.null" "opsr"&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_dat &lt;- opsr_simulate()
dat &lt;- sim_dat$data
model &lt;- ys | yo ~ xs1 + xs2 | xo1 + xo2
fit &lt;- opsr(model, dat)
fit_null &lt;- opsr_null_model(fit)
summary(fit_null)
</code></pre>

<hr>
<h2 id='opsr_prepare_coefs'>Prepares Coefficients for Likelihood Function</h2><span id='topic+opsr_prepare_coefs'></span>

<h3>Description</h3>

<p>Extracts the coefficients for each regime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opsr_prepare_coefs(theta, nReg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opsr_prepare_coefs_+3A_theta">theta</code></td>
<td>
<p>named coefficient vector as parsed from formula interface <code><a href="#topic+opsr">opsr</a></code>.</p>
</td></tr>
<tr><td><code id="opsr_prepare_coefs_+3A_nreg">nReg</code></td>
<td>
<p>integer number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of length <code>nReg</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_dat &lt;- opsr_simulate()
dat &lt;- sim_dat$data
model &lt;- ys | yo ~ xs1 + xs2 | xo1 + xo2
start &lt;- opsr(model, dat, .get2step = TRUE)
opsr_prepare_coefs(start, 3)
</code></pre>

<hr>
<h2 id='opsr_simulate'>Simulate Data from an OPSR Process</h2><span id='topic+opsr_simulate'></span>

<h3>Description</h3>

<p>Simulates data from an ordinal probit process and separate (for each regime)
OLS process where the errors follow a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opsr_simulate(nobs = 1000, sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opsr_simulate_+3A_nobs">nobs</code></td>
<td>
<p>number of observations to simulate.</p>
</td></tr>
<tr><td><code id="opsr_simulate_+3A_sigma">sigma</code></td>
<td>
<p>the covariance matrix of the multivariate normal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three ordinal outcomes are simulated and the distinct design matrices (<code>W</code> and
<code>X</code>) are used (if <code>W == X</code> the model is poorely identified). Variables <code>ys</code> and
<code>xs</code> in <code>data</code> correspond to the selection process and <code>yo</code>, <code>xo</code> to the outcome
process.
</p>


<h3>Value</h3>

<p>Named list:
</p>
<table role = "presentation">
<tr><td><code>params</code></td>
<td>
<p>ground truth parameters.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>simulated data (as observed by the researcher). See also 'Details' section.</p>
</td></tr>
<tr><td><code>errors</code></td>
<td>
<p>error draws from the multivariate normal (as used in the latent
process).</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>assumed covariance matrix (to generate <code>errors</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='opsr.fit'>Fitter Function for Ordinal Probit Switching Regression Models</h2><span id='topic+opsr.fit'></span>

<h3>Description</h3>

<p>This is the basic computing engine called by <code><a href="#topic+opsr">opsr</a></code> used to fit ordinal
probit switching regression models. Should usually <em>not</em> be used directly.
The log-likelihood function is implemented in C++ which yields a considerable
speed-up. Parallel computation is implemented using <code>OpenMP</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opsr.fit(
  Ws,
  Xs,
  Ys,
  start,
  fixed,
  weights,
  method,
  iterlim,
  printLevel,
  nThreads,
  .useR = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opsr.fit_+3A_ws">Ws</code></td>
<td>
<p>list of matrices with explanatory variables for selection process for each regime.</p>
</td></tr>
<tr><td><code id="opsr.fit_+3A_xs">Xs</code></td>
<td>
<p>list of matrices with expalanatory varialbes for outcome process for each regime.</p>
</td></tr>
<tr><td><code id="opsr.fit_+3A_ys">Ys</code></td>
<td>
<p>list of vectors with continuous outcomes for each regime.</p>
</td></tr>
<tr><td><code id="opsr.fit_+3A_start">start</code></td>
<td>
<p>a numeric vector with the starting values (passed to <code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>).</p>
</td></tr>
<tr><td><code id="opsr.fit_+3A_fixed">fixed</code></td>
<td>
<p>parameters to be treated as constants at their <code>start</code> values. If
present, it is treated as an index vector of <code>start</code> parameters (passed to <code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>).</p>
</td></tr>
<tr><td><code id="opsr.fit_+3A_weights">weights</code></td>
<td>
<p>a vector of weights to be used in the fitting process. Has to
conform with order (<code>w &lt;- weights[order(Z)]</code>, where Z is the ordinal
outcome).</p>
</td></tr>
<tr><td><code id="opsr.fit_+3A_method">method</code></td>
<td>
<p>maximzation method (passed to <code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>).</p>
</td></tr>
<tr><td><code id="opsr.fit_+3A_iterlim">iterlim</code></td>
<td>
<p>maximum number of iterations (passed to <code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>).</p>
</td></tr>
<tr><td><code id="opsr.fit_+3A_printlevel">printLevel</code></td>
<td>
<p>larger number prints more working information (passed to <code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>).</p>
</td></tr>
<tr><td><code id="opsr.fit_+3A_nthreads">nThreads</code></td>
<td>
<p>number of threads to be used. Do not pass higher number than
number of ordinal outcomes. See also <code><a href="#topic+opsr_check_omp">opsr_check_omp</a></code> and <code><a href="#topic+opsr_max_threads">opsr_max_threads</a></code>.</p>
</td></tr>
<tr><td><code id="opsr.fit_+3A_.user">.useR</code></td>
<td>
<p>if <code>TRUE</code>, usese <code><a href="#topic+loglik_R">loglik_R</a></code>. Go grab a coffe.</p>
</td></tr>
<tr><td><code id="opsr.fit_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code style="white-space: pre;">&#8288;"maxLik" "maxim"&#8288;</code>.
</p>


<h3>See Also</h3>

<p><code><a href="maxLik.html#topic+maxLik">maxLik::maxLik</a></code>, <code><a href="#topic+loglik_cpp">loglik_cpp</a></code>, <code><a href="#topic+opsr">opsr</a></code>
</p>

<hr>
<h2 id='predict.opsr'>Predict Method for OPSR Model Fits</h2><span id='topic+predict.opsr'></span>

<h3>Description</h3>

<p>Obtains predictions for the selection process (probabilities), the outcome process,
or returns the inverse mills ratio. Handles also log-transformed outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'opsr'
predict(
  object,
  newdata,
  group,
  counterfact = NULL,
  type = c("response", "unlog-response", "prob", "mills"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.opsr_+3A_object">object</code></td>
<td>
<p>an object of class <code>"opsr"</code>.</p>
</td></tr>
<tr><td><code id="predict.opsr_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables used in
<code>object$formula</code>. See also <code><a href="#topic+model.matrix.opsr">model.matrix.opsr</a></code>.</p>
</td></tr>
<tr><td><code id="predict.opsr_+3A_group">group</code></td>
<td>
<p>predict outcome of this group (regime).</p>
</td></tr>
<tr><td><code id="predict.opsr_+3A_counterfact">counterfact</code></td>
<td>
<p>counterfactual group.</p>
</td></tr>
<tr><td><code id="predict.opsr_+3A_type">type</code></td>
<td>
<p>type of prediction. Can be abbreviated. See 'Details' section for
more information.</p>
</td></tr>
<tr><td><code id="predict.opsr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elements are <code>NA_real_</code> if the <code>group</code> does not correspond to the observed
regime (selection outcome). This ensures consistent output length.
</p>
<p>If the <code>type</code> argument is <code>"response"</code> then the continuous outcome is predicted.
Use <code>"unlog-response"</code> if the outcome response was log-transformed during estimation.
<code>"prob"</code> returns the probability vector of belonging to <code>group</code> and <code>"mills"</code>
returns the inverse mills ratio.
</p>


<h3>Value</h3>

<p>a vector of length <code>nrow(newdata)</code> (or data used during estimation).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">stats::predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_dat &lt;- opsr_simulate()
dat &lt;- sim_dat$data
model &lt;- ys | yo ~ xs1 + xs2 | xo1 + xo2
fit &lt;- opsr(model, dat)
p &lt;- predict(fit, group = 1, type = "response")

fit_log &lt;- update(fit, . | log(yo) ~ .)
p_unlog &lt;- predict(fit, group = 1, type = "unlog-response")
</code></pre>

<hr>
<h2 id='print.anova.opsr'>Print Method for ANOVA OPSR Objects</h2><span id='topic+print.anova.opsr'></span>

<h3>Description</h3>

<p>Print Method for ANOVA OPSR Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'anova.opsr'
print(
  x,
  digits = max(getOption("digits") - 2L, 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.anova.opsr_+3A_x">x</code></td>
<td>
<p>an object of class <code>"anova.opsr"</code>.</p>
</td></tr>
<tr><td><code id="print.anova.opsr_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.anova.opsr_+3A_signif.stars">signif.stars</code></td>
<td>
<p>if <code>TRUE</code>, P-values are additionally encoded visually
as 'significance stars' in order to help scanning of long coefficient tables.
It defaults to the <code>show.signif.stars</code> slot of <code><a href="base.html#topic+options">options</a></code>.</p>
</td></tr>
<tr><td><code id="print.anova.opsr_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="stats.html#topic+printCoefmat">stats::printCoefmat</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints tables in a 'pretty' form and returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+printCoefmat">stats::printCoefmat</a></code>, <code><a href="#topic+anova.opsr">anova.opsr</a></code>
</p>

<hr>
<h2 id='print.summary.opsr'>Print Method for Summary OPSR Objects</h2><span id='topic+print.summary.opsr'></span>

<h3>Description</h3>

<p>Print Method for Summary OPSR Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.opsr'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.opsr_+3A_x">x</code></td>
<td>
<p>and object of class <code>"summary.opsr"</code></p>
</td></tr>
<tr><td><code id="print.summary.opsr_+3A_digits">digits</code></td>
<td>
<p>minimum number of significant digits to be used for most numbers (passed to <code><a href="stats.html#topic+printCoefmat">stats::printCoefmat</a></code>).</p>
</td></tr>
<tr><td><code id="print.summary.opsr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints summary in 'pretty' form and returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+printCoefmat">stats::printCoefmat</a></code>, <code><a href="#topic+summary.opsr">summary.opsr</a></code>
</p>

<hr>
<h2 id='summary.opsr'>Summarizing OPSR Model Fits</h2><span id='topic+summary.opsr'></span>

<h3>Description</h3>

<p>Follows the convention that <code><a href="#topic+opsr">opsr</a></code> does the bare minimum model fitting and
inference is performed in <code>summary</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'opsr'
summary(object, rob = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.opsr_+3A_object">object</code></td>
<td>
<p>an object of class <code>"opsr"</code>.</p>
</td></tr>
<tr><td><code id="summary.opsr_+3A_rob">rob</code></td>
<td>
<p>if <code>TRUE</code>, the <code><a href="sandwich.html#topic+sandwich">sandwich::sandwich</a></code> covariance matrix extimator is used.</p>
</td></tr>
<tr><td><code id="summary.opsr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"summary.opsr"</code>.
In particular the elements <code>GOF</code>, <code>GOFcomponents</code> and <code>wald</code> require further
explanation:
</p>
<table role = "presentation">
<tr><td><code>GOF</code></td>
<td>
<p>Contains the conventional <em>goodness of fit</em> indicators for the full
model. <code>LL2step</code> is the log-likelihood of the Heckman two-step solution (if
the default starting values were used). <code>LLfinal</code> is the log-likelihood at
final convergence and <code>AIC</code>, <code>BIC</code> the corresponding information critereon.</p>
</td></tr>
<tr><td><code>GOFcomponents</code></td>
<td>
<p>Contains the <em>goodness of fit</em>  for the model components.
<code>LLprobit</code> is the log-likelihood (LL) contribution of the ordinal probit model.
<code>LLprobitEl</code> the LL of the &quot;equally likely&quot; and <code>LLprobitMs</code> the LL of the
&quot;market share&quot; model. With these three metrics the pseudo R2 is computed and
returned as <code>pseudoR2el</code> and <code>pseudoR2ms</code>. <code>R2</code> reports the usual coefficient
of determination (for the continuous outcomes jointly and for each regime
separately).</p>
</td></tr>
<tr><td><code>wald</code></td>
<td>
<p>Contains the results of two <em>Wald-tests</em> as conducted with help
of <code><a href="car.html#topic+linearHypothesis">car::linearHypothesis</a></code>. The two H0 hypothesis are 1. All coefficients
of the explanatory variables are 0 and 2. The rho parameters (capturing error
correlation) are zero.</p>
</td></tr>
</table>

<hr>
<h2 id='telework_data'>Telework data</h2><span id='topic+telework_data'></span>

<h3>Description</h3>

<p>Telework data as used in Wang and Mokhtarian (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>telework_data
</code></pre>


<h3>Format</h3>

<p>Data frame with numeric columns
</p>

<dl>
<dt>id</dt><dd><p>Respondent ID</p>
</dd>
<dt>weight</dt><dd><p>Sample weight</p>
</dd>
<dt>vmd</dt><dd><p>Weekly vehicle-miles traveled</p>
</dd>
<dt>vmd_ln</dt><dd><p>Log-transformed VMD, the dependent variable of the outcome model</p>
</dd>
<dt>twing_status</dt><dd><p>Teleworking status: 1=Non-TWer, 2=Non-usual TWer, 3=Usual TWer</p>
</dd>
<dt>female</dt><dd><p>Sex: female</p>
</dd>
<dt>age_mean</dt><dd><p>Mean-centered age</p>
</dd>
<dt>age_mean_sq</dt><dd><p>Sqaure of mean-centered age</p>
</dd>
<dt>race_white</dt><dd><p>Race: white only</p>
</dd>
<dt>race_black</dt><dd><p>Race: black only</p>
</dd>
<dt>race_other</dt><dd><p>Race: other</p>
</dd>
<dt>edu_1</dt><dd><p>Education: high school or lower</p>
</dd>
<dt>edu_2</dt><dd><p>Education: some college</p>
</dd>
<dt>edu_3</dt><dd><p>Education: BA or higher</p>
</dd>
<dt>hhincome_1</dt><dd><p>Household income: less than $50,000</p>
</dd>
<dt>hhincome_2</dt><dd><p>Household income: $50,000 to $99,999</p>
</dd>
<dt>hhincome_3</dt><dd><p>Household income: $100,000 or more</p>
</dd>
<dt>flex_work</dt><dd><p>Flexible work schedule</p>
</dd>
<dt>work_fulltime</dt><dd><p>Full-time worker</p>
</dd>
<dt>twing_feasibility</dt><dd><p>Teleworking feasibility (days/month)</p>
</dd>
<dt>vehicle</dt><dd><p>Number of household vehicles</p>
</dd>
<dt>child</dt><dd><p>Number of children</p>
</dd>
<dt>urban</dt><dd><p>Residential location: urban</p>
</dd>
<dt>suburban</dt><dd><p>Residential location: suburban</p>
</dd>
<dt>smalltown</dt><dd><p>Residential location: small town</p>
</dd>
<dt>rural</dt><dd><p>Residential location: rural</p>
</dd>
<dt>att_prolargehouse</dt><dd><p>Attitude: pro-large-house</p>
</dd>
<dt>att_proactivemode</dt><dd><p>Attitude: pro-active-mode</p>
</dd>
<dt>att_procarowning</dt><dd><p>Attitude: pro-car-owning</p>
</dd>
<dt>att_wif</dt><dd><p>Attitude: work-interferes-with-family</p>
</dd>
<dt>att_proteamwork</dt><dd><p>Attitude: pro-teamwork</p>
</dd>
<dt>att_tw_effective_teamwork</dt><dd><p>Attitude: TW effective teamwork</p>
</dd>
<dt>att_tw_enthusiasm</dt><dd><p>Attitude: TW enthusiasm</p>
</dd>
<dt>att_tw_location_flex</dt><dd><p>Attitude: TW location flexibility</p>
</dd>
<dt>region_waa</dt><dd><p>Region indicator: respondents from WAA MSA</p>
</dd>
</dl>



<h3>References</h3>

<p>Wang X, Mokhtarian PL (2024).
&ldquo;Examining the Treatment Effect of Teleworking on Vehicle-Miles Driven: Applying an Ordered Probit Selection Model and Incorporating the Role of Travel Stress.&rdquo;
<em>Transportatikon Research Part A</em>, <b>186</b>, 104072.
<a href="https://doi.org/10.1016/j.tra.2024.104072">doi:10.1016/j.tra.2024.104072</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## model as in Xinyi &amp; Mokhtarian (2024)
f &lt;-
  ## ordinal and continuous outcome
  twing_status | vmd_ln ~
  ## selection model
  edu_2 + edu_3 + hhincome_2 + hhincome_3 +
  flex_work + work_fulltime + twing_feasibility +
  att_proactivemode + att_procarowning +
  att_wif + att_proteamwork +
  att_tw_effective_teamwork + att_tw_enthusiasm + att_tw_location_flex |
  ## outcome model NTW
  female + age_mean + age_mean_sq +
  race_black + race_other +
  vehicle + suburban + smalltown + rural +
  work_fulltime +
  att_prolargehouse + att_procarowning +
  region_waa |
  ## outcome model NUTW
  edu_2 + edu_3 + suburban + smalltown + rural +
  work_fulltime +
  att_prolargehouse + att_proactivemode + att_procarowning |
  ## outcome model UTW
  female + hhincome_2 + hhincome_3 +
  child + suburban + smalltown + rural +
  att_procarowning +
  region_waa

fit &lt;- opsr(f, telework_data)
texreg::screenreg(fit, beside = TRUE, include.pseudoR2 = TRUE, include.R2 = TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
