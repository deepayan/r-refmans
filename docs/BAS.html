<!DOCTYPE html><html lang="en"><head><title>Help for package BAS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BAS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BAS'><p>BAS: Bayesian Model Averaging using Bayesian Adaptive Sampling</p></a></li>
<li><a href='#bas.glm'><p>Bayesian Adaptive Sampling Without Replacement for Variable Selection in</p>
Generalized Linear Models</a></li>
<li><a href='#bas.lm'><p>Bayesian Adaptive Sampling for Bayesian Model Averaging and Variable Selection in</p>
Linear Models</a></li>
<li><a href='#Bayes.outlier'><p>Bayesian Outlier Detection</p></a></li>
<li><a href='#bayesglm.fit'><p>Fitting Generalized Linear Models and Bayesian marginal likelihood</p>
evaluation</a></li>
<li><a href='#Bernoulli'><p>Independent Bernoulli Prior Distribution for Models</p></a></li>
<li><a href='#Bernoulli.heredity'><p>Independent Bernoulli prior on models that with constraints for</p>
model hierarchy induced by interactions</a></li>
<li><a href='#beta.binomial'><p>Beta-Binomial Prior Distribution for Models</p></a></li>
<li><a href='#beta.prime'><p>Beta-Prime Prior Distribution for Coefficients in BMA Model</p></a></li>
<li><a href='#bodyfat'><p>Bodyfat Data</p></a></li>
<li><a href='#CCH'><p>Generalized g-Prior Distribution for Coefficients in BMA Models</p></a></li>
<li><a href='#climate'><p>Climate Data</p></a></li>
<li><a href='#coef.bas'><p>Coefficients of a Bayesian Model Average object</p></a></li>
<li><a href='#confint.coef.bas'><p>Compute Credible Intervals for BAS regression coefficients from BAS objects</p></a></li>
<li><a href='#confint.pred.bas'><p>Compute Credible (Bayesian Confidence) Intervals for a BAS predict object</p></a></li>
<li><a href='#cv.summary.bas'><p>Summaries for Out of Sample Prediction</p></a></li>
<li><a href='#diagnostics'><p>BAS MCMC diagnostic plot</p></a></li>
<li><a href='#EB.global'><p>Find the global Empirical Bayes estimates for BMA</p></a></li>
<li><a href='#EB.local'><p>Empirical Bayes Prior Distribution for Coefficients in BMA Model</p></a></li>
<li><a href='#eplogprob'><p>eplogprob - Compute approximate marginal inclusion probabilities from</p>
pvalues</a></li>
<li><a href='#eplogprob.marg'><p>eplogprob.marg - Compute approximate marginal inclusion probabilities from</p>
pvalues</a></li>
<li><a href='#fitted.bas'><p>Fitted values for a BAS BMA objects</p></a></li>
<li><a href='#force.heredity.bas'><p>Post processing function to force constraints on interaction inclusion bas BMA objects</p></a></li>
<li><a href='#g.prior'><p>Families of G-Prior Distribution for Coefficients in BMA Models</p></a></li>
<li><a href='#Hald'><p>Hald Data</p></a></li>
<li><a href='#hyper.g'><p>Hyper-g-Prior Distribution for Coefficients in BMA Models</p></a></li>
<li><a href='#hyper.g.n'><p>Generalized hyper-g/n Prior Distribution for g for mixtures of g-priors on</p>
Coefficients in BMA Models</a></li>
<li><a href='#hypergeometric1F1'><p>Confluent hypergeometric1F1 function</p></a></li>
<li><a href='#hypergeometric2F1'><p>Gaussian hypergeometric2F1 function</p></a></li>
<li><a href='#IC.prior'><p>Information Criterion Families of Prior Distribution for Coefficients in BMA</p>
Models</a></li>
<li><a href='#image.bas'><p>Images of models used in Bayesian model averaging</p></a></li>
<li><a href='#intrinsic'><p>Intrinsic Prior Distribution for Coefficients in BMA Models</p></a></li>
<li><a href='#Jeffreys'><p>Jeffreys Prior Distribution for $g$ for Mixtures of g-Priors for</p>
Coefficients in BMA Models</a></li>
<li><a href='#list2matrix.bas'><p>Coerce a BAS list object into a matrix.</p></a></li>
<li><a href='#list2matrix.which'><p>Coerce a BAS list object into a matrix.</p></a></li>
<li><a href='#phi1'><p>Compound Confluent hypergeometric function of two variables</p></a></li>
<li><a href='#plot.bas'><p>Plot Diagnostics for an BAS Object</p></a></li>
<li><a href='#plot.coef.bas'><p>Plots the posterior distributions of coefficients derived from Bayesian</p>
model averaging</a></li>
<li><a href='#plot.confint.bas'><p>Plot Bayesian Confidence Intervals</p></a></li>
<li><a href='#predict.bas'><p>Prediction Method for an object of class BAS</p></a></li>
<li><a href='#predict.basglm'><p>Prediction Method for an Object of Class basglm</p></a></li>
<li><a href='#print.bas'><p>Print a Summary of Bayesian Model Averaging objects from BAS</p></a></li>
<li><a href='#protein'><p>Protein Activity Data</p></a></li>
<li><a href='#robust'><p>Robust-Prior Distribution for Coefficients in BMA Model</p></a></li>
<li><a href='#summary.bas'><p>Summaries of Bayesian Model Averaging objects from BAS</p></a></li>
<li><a href='#tCCH'><p>Generalized tCCH g-Prior Distribution for Coefficients in BMA Models</p></a></li>
<li><a href='#testBF.prior'><p>Test based Bayes Factors for BMA Models</p></a></li>
<li><a href='#TG'><p>Generalized g-Prior Distribution for Coefficients in BMA Models</p></a></li>
<li><a href='#tr.beta.binomial'><p>Truncated Beta-Binomial Prior Distribution for Models</p></a></li>
<li><a href='#tr.poisson'><p>Truncated Poisson Prior Distribution for Models</p></a></li>
<li><a href='#tr.power.prior'><p>Truncated Power Prior Distribution for Models</p></a></li>
<li><a href='#trCCH'><p>Truncated Compound Confluent Hypergeometric function</p></a></li>
<li><a href='#uniform'><p>Uniform Prior Distribution for Models</p></a></li>
<li><a href='#update.bas'><p>Update BAS object using a new prior</p></a></li>
<li><a href='#variable.names.pred.bas'><p>Extract the variable names for a model from a BAS prediction object</p></a></li>
<li><a href='#which.matrix'><p>Coerce a BAS list object of models into a matrix.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.7.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-26</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Variable Selection and Model Averaging using Bayesian
Adaptive Sampling</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, utils, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, knitr, ggplot2, GGally, rmarkdown, roxygen2, dplyr,
glmbb, testthat, covr, faraway</td>
</tr>
<tr>
<td>Description:</td>
<td>Package for Bayesian Variable Selection and  Model Averaging 
    in linear models and generalized linear models using stochastic or
    deterministic sampling without replacement from posterior
    distributions.  Prior distributions on coefficients are
    from Zellner's g-prior or mixtures of g-priors
    corresponding to the Zellner-Siow Cauchy Priors or the
    mixture of g-priors from Liang et al (2008)
    &lt;<a href="https://doi.org/10.1198%2F016214507000001337">doi:10.1198/016214507000001337</a>&gt;
    for linear models or mixtures of g-priors from  Li and Clyde
    (2019) &lt;<a href="https://doi.org/10.1080%2F01621459.2018.1469992">doi:10.1080/01621459.2018.1469992</a>&gt; in generalized linear models.
    Other model selection criteria include AIC, BIC and Empirical Bayes 
    estimates of g. Sampling probabilities may be updated based on the sampled
    models using sampling w/out replacement or an efficient MCMC algorithm which
    samples models using a tree structure of the model space 
    as an efficient hash table.  See  Clyde, Ghosh and Littman (2010) 
    &lt;<a href="https://doi.org/10.1198%2Fjcgs.2010.09049">doi:10.1198/jcgs.2010.09049</a>&gt; for  details on the sampling algorithms.
    Uniform priors over all models or beta-binomial prior distributions on
    model size are allowed, and for large p truncated priors on the model
    space may be used to enforce sampling models that are full rank.  
    The user may force variables to always be included in addition to imposing
    constraints that higher order interactions are included only if their 
    parents are included in the model.
    This material is based upon work supported by the National Science
    Foundation under Division of Mathematical Sciences grant 1106891.
    Any opinions, findings, and
    conclusions or recommendations expressed in this material are those of
    the author(s) and do not necessarily reflect the views of the
    National Science Foundation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://merliseclyde.github.io/BAS/">https://merliseclyde.github.io/BAS/</a>,
<a href="https://github.com/merliseclyde/BAS">https://github.com/merliseclyde/BAS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/merliseclyde/BAS/issues">https://github.com/merliseclyde/BAS/issues</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-27 14:56:41 UTC; clyde</td>
</tr>
<tr>
<td>Author:</td>
<td>Merlise Clyde [aut, cre, cph] (ORCID=0000-0002-3595-1872),
  Michael Littman [ctb],
  Joyee Ghosh [ctb],
  Yingbo Li [ctb],
  Betsy Bersson [ctb],
  Don van de Bergh [ctb],
  Quanli Wang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Merlise Clyde &lt;clyde@duke.edu&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-28 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BAS'>BAS: Bayesian Model Averaging using Bayesian Adaptive Sampling</h2><span id='topic+BAS'></span>

<h3>Description</h3>

<p>Implementation of  Bayesian Model Averaging in linear models using stochastic or
deterministic sampling without replacement from posterior distributions.
Prior distributions on coefficients are of the form of Zellner's g-prior or
mixtures of g-priors. Options include the Zellner-Siow Cauchy Priors, the
Liang et al hyper-g priors, Local and Global Empirical Bayes estimates of g,
and other default model selection criteria such as AIC and BIC. Sampling
probabilities may be updated based on the sampled models.
</p>


<h3>Details</h3>

<p>_PACKAGE
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde, <br /> Maintainer: Merlise Clyde &lt;clyde@stat.duke.edu&gt;
</p>


<h3>References</h3>

<p>Clyde, M. Ghosh, J. and Littman, M. (2010) Bayesian Adaptive
Sampling for Variable Selection and Model Averaging. Journal of
Computational Graphics and Statistics.  20:80-101 <br />
<a href="https://doi.org/10.1198/jcgs.2010.09049">doi:10.1198/jcgs.2010.09049</a>
</p>
<p>Clyde, M. and George, E. I. (2004) Model uncertainty. Statist. Sci., 19,
81-94. <br /> <a href="https://doi.org/10.1214/088342304000000035">doi:10.1214/088342304000000035</a>
</p>
<p>Clyde, M. (1999) Bayesian Model Averaging and Model Search Strategies (with
discussion). In Bayesian Statistics 6. J.M. Bernardo, A.P. Dawid, J.O.
Berger, and A.F.M. Smith eds. Oxford University Press, pages 157-185.
</p>
<p>Li, Y. and Clyde, M. (2018) Mixtures of g-priors in Generalized Linear
Models. Journal of the American Statistical Association, 113:524, 1828-1845 <a href="https://doi.org/10.1080/01621459.2018.1469992">doi:10.1080/01621459.2018.1469992</a>
</p>
<p>Liang, F., Paulo, R., Molina, G., Clyde, M. and Berger, J.O. (2008) Mixtures
of g-priors for Bayesian Variable Selection. Journal of the American
Statistical Association. 103:410-423.  <br />
</p>
<p><a href="https://doi.org/10.1198/016214507000001337">doi:10.1198/016214507000001337</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas.lm">bas.lm</a></code> <code><a href="#topic+bas.glm">bas.glm</a></code>
</p>
<p>Other bas methods: 
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Hald")
hald.gprior =  bas.lm(Y ~ ., data=Hald, alpha=13, prior="g-prior")

# more complete demos

demo(BAS.hald)
## Not run: 
demo(BAS.USCrime)

## End(Not run)

</code></pre>

<hr>
<h2 id='bas.glm'>Bayesian Adaptive Sampling Without Replacement for Variable Selection in
Generalized Linear Models</h2><span id='topic+bas.glm'></span>

<h3>Description</h3>

<p>Sample with or without replacement from a posterior distribution on GLMs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bas.glm(
  formula,
  family = binomial(link = "logit"),
  data,
  weights,
  subset,
  contrasts = NULL,
  offset,
  na.action = "na.omit",
  n.models = NULL,
  betaprior = CCH(alpha = 0.5, beta = as.numeric(nrow(data)), s = 0),
  modelprior = beta.binomial(1, 1),
  initprobs = "Uniform",
  include.always = ~1,
  method = "MCMC",
  update = NULL,
  bestmodel = NULL,
  prob.rw = 0.5,
  MCMC.iterations = NULL,
  thin = 1,
  control = glm.control(),
  laplace = FALSE,
  renormalize = FALSE,
  force.heredity = FALSE,
  bigmem = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bas.glm_+3A_formula">formula</code></td>
<td>
<p>generalized linear model formula for the full model with all
predictors, Y ~ X.  All code assumes that an intercept will be included in
each model.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function for
exponential family; currently only 'binomial()' with the logistic link and
'poisson()' and 'Gamma()'with the log link are available.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_weights">weights</code></td>
<td>
<p>optional vector of weights to be used in the fitting process.
May be missing in which case weights are 1.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_subset">subset</code></td>
<td>
<p>subset of data used in fitting</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the contrasts.arg of 'model.matrix.default()'.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_offset">offset</code></td>
<td>
<p>a priori known component to be included in the linear
predictor; by default 0.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain NAs. The default is &quot;na.omit&quot;.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_n.models">n.models</code></td>
<td>
<p>number of unique models to keep. If NULL, BAS will attempt
to enumerate unless p &gt; 35 or method=&quot;MCMC&quot;. For any of methods using MCMC
algorithms that sample with replacement, sampling will stop when the number
of iterations exceeds the min of 'n.models' or 'MCMC.iterations' and on exit
'n.models' is updated to reflect the unique number of models that have been
sampled.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_betaprior">betaprior</code></td>
<td>
<p>Prior on coefficients for model coefficients (except
intercept).  Options include 
<code><a href="#topic+g.prior">g.prior</a></code>, 
<code><a href="#topic+CCH">CCH</a></code>,
<code><a href="#topic+robust">robust</a></code>, 
<code><a href="#topic+intrinsic">intrinsic</a></code>, 
<code><a href="#topic+beta.prime">beta.prime</a></code>,
<code><a href="#topic+EB.local">EB.local</a></code>, 
<code><a href="stats.html#topic+AIC">AIC</a></code>, and 
<code><a href="stats.html#topic+BIC">BIC</a></code>.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_modelprior">modelprior</code></td>
<td>
<p>Family of prior distribution on the models.  Choices
include <code><a href="#topic+uniform">uniform</a></code>, <code><a href="#topic+Bernoulli">Bernoulli</a></code>,
<code><a href="#topic+beta.binomial">beta.binomial</a></code>, truncated Beta-Binomial,
<code><a href="#topic+tr.beta.binomial">tr.beta.binomial</a></code>, and truncated power family
<code><a href="#topic+tr.power.prior">tr.power.prior</a></code>.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_initprobs">initprobs</code></td>
<td>
<p>vector of length p with the initial inclusion probabilities
used for sampling without replacement (the intercept will be included with
probability one and does not need to be added here) or a character string
giving the method used to construct the sampling probabilities if &quot;Uniform&quot;
each predictor variable is equally likely to be sampled (equivalent to
random sampling without replacement). If &quot;eplogp&quot;, use the
<code><a href="#topic+eplogprob">eplogprob</a></code> function to approximate the Bayes factor using
p-values to find initial marginal inclusion probabilities and sample
without replacement using these inclusion probabilities, which may be
updated using estimates of the marginal inclusion probabilities. &quot;eplogp&quot;
assumes that MLEs from the full model exist; for problems where that is not
the case or 'p' is large, initial sampling probabilities may be obtained
using <code><a href="#topic+eplogprob.marg">eplogprob.marg</a></code> which fits a model to each predictor
separately.  To run a Markov Chain to provide initial
estimates of marginal inclusion probabilities, use method=&quot;MCMC+BAS&quot; below.
While the initprobs are not used in sampling for method=&quot;MCMC&quot;, this
determines the order of the variables in the lookup table and affects memory
allocation in large problems where enumeration is not feasible.  For
variables that should always be included set the corresponding initprobs to
1, to override the 'modelprior' or use 'include.always' to force these variables
to always be included in the model.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_include.always">include.always</code></td>
<td>
<p>A formula with terms that should always be included
in the model with probability one.  By default this is '~ 1' meaning that the
intercept is always included.  
This will also override any of the values in 'initprobs'
above by setting them to 1.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_method">method</code></td>
<td>
<p>A character variable indicating which sampling method to use:
method=&quot;BAS&quot; uses Bayesian Adaptive Sampling (without replacement) using the
sampling probabilities given in initprobs and updates using the marginal
inclusion probabilities to direct the search/sample; method=&quot;MCMC&quot; combines
a random walk Metropolis Hastings (as in MC3 of Raftery et al 1997) with a
random swap of a variable included with a variable that is currently
excluded (see Clyde, Ghosh, and Littman (2010) for details);
method=&quot;MCMC+BAS&quot; runs an initial MCMC as above to calculate marginal
inclusion probabilities and then samples without replacement as in BAS;
method = &quot;deterministic&quot; runs an deterministic sampling using the initial
probabilities (no updating); this is recommended for fast enumeration or if a
model of independence is a good approximation to the joint posterior
distribution of the model indicators.  For BAS, the sampling probabilities
can be updated as more models are sampled. (see 'update' below).  We
recommend &quot;MCMC+BAS&quot; or &quot;MCMC&quot; for high dimensional problems.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_update">update</code></td>
<td>
<p>number of iterations between potential updates of the sampling
probabilities in the &quot;BAS&quot; method. If NULL do not update, otherwise the
algorithm will update using the marginal inclusion probabilities as they
change while sampling takes place.  For large model spaces, updating is
recommended. If the model space will be enumerated, leave at the default.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_bestmodel">bestmodel</code></td>
<td>
<p>optional binary vector representing a model to initialize
the sampling. If NULL sampling starts with the null model</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_prob.rw">prob.rw</code></td>
<td>
<p>For any of the MCMC methods, probability of using the
random-walk proposal; otherwise use a random &quot;flip&quot; move to propose a new
model.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_mcmc.iterations">MCMC.iterations</code></td>
<td>
<p>Number of models to sample when using any of the MCMC
options; should be greater than 'n.models'. By default 10*n.models.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_thin">thin</code></td>
<td>
<p>oFr &quot;MCMC&quot;, thin the MCMC chain every &quot;thin&quot; iterations; default 
is no
thinning.  For large p, thinning can be used to significantly reduce memory
requirements as models and associated summaries are saved only every thin 
iterations.  For thin = p, the  model and associated output are recorded 
every p iterations,similar to the Gibbs sampler in SSVS.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_control">control</code></td>
<td>
<p>a list of parameters that control convergence in the fitting
process.  See the documentation for <code>glm.control()</code></p>
</td></tr>
<tr><td><code id="bas.glm_+3A_laplace">laplace</code></td>
<td>
<p>logical variable for whether to use a Laplace approximate for
integration with respect to g to obtain the marginal likelihood.  If FALSE
the Cephes library is used which may be inaccurate for large n or large
values of the Wald Chisquared statistic.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_renormalize">renormalize</code></td>
<td>
<p>logical variable for whether posterior probabilities
should be based on renormalizing marginal likelihoods times prior
probabilities or use Monte Carlo frequencies. Applies only to MCMC sampling.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_force.heredity">force.heredity</code></td>
<td>
<p>Logical variable to force all levels of a factor to be
included together and to include higher order interactions only if lower
order terms are included.  Currently only supported with &lsquo;method=&rsquo;MCMC''
and &lsquo;method=&rsquo;BAS'' (experimental) on non-Solaris platforms.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="bas.glm_+3A_bigmem">bigmem</code></td>
<td>
<p>Logical variable to indicate that there is access to
large amounts of memory (physical or virtual) for enumeration
with large model spaces, e.g. &gt; 2^25.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BAS provides several search algorithms to find high probability models for
use in Bayesian Model Averaging or Bayesian model selection. For p less than
20-25, BAS can enumerate all models depending on memory availability, for
larger p, BAS samples without replacement using random or deterministic
sampling. The Bayesian Adaptive Sampling algorithm of Clyde, Ghosh, Littman
(2010) samples models without replacement using the initial sampling
probabilities, and will optionally update the sampling probabilities every
&quot;update&quot; models using the estimated marginal inclusion probabilities. BAS
uses different methods to obtain the <code>initprobs</code>, which may impact the
results in high-dimensional problems. The deterministic sampler provides a
list of the top models in order of an approximation of independence using
the provided <code>initprobs</code>.  This may be effective after running the
other algorithms to identify high probability models and works well if the
correlations of variables are small to modest.  The priors on coefficients
are mixtures of g-priors that provide approximations to the power prior.
</p>


<h3>Value</h3>

<p><code>bas.glm</code> returns an object of class <code>basglm</code>
</p>
<p>An object of class <code>basglm</code> is a list containing at least the following
components:
</p>
<table role = "presentation">
<tr><td><code>postprobs</code></td>
<td>
<p>the posterior probabilities of the models selected</p>
</td></tr>
<tr><td><code>priorprobs</code></td>
<td>
<p>the prior probabilities of the models selected</p>
</td></tr>
<tr><td><code>logmarg</code></td>
<td>
<p>values of the log of the marginal likelihood for the models</p>
</td></tr>
<tr><td><code>n.vars</code></td>
<td>
<p>total number of independent variables in the full model,
including the intercept</p>
</td></tr> 
<tr><td><code>size</code></td>
<td>
<p>the number of independent variables in
each of the models, includes the intercept</p>
</td></tr> 
<tr><td><code>which</code></td>
<td>
<p>a list of lists
with one list per model with variables that are included in the model</p>
</td></tr>
<tr><td><code>probne0</code></td>
<td>
<p>the posterior probability that each variable is non-zero</p>
</td></tr>
<tr><td><code>mle</code></td>
<td>
<p>list of lists with one list per model giving the GLM
estimate of each (nonzero) coefficient for each model.</p>
</td></tr> 
<tr><td><code>mle.se</code></td>
<td>
<p>list of
lists with one list per model giving the GLM standard error of each
coefficient for each model</p>
</td></tr> 
<tr><td><code>deviance</code></td>
<td>
<p>the GLM deviance for each model</p>
</td></tr>
<tr><td><code>modelprior</code></td>
<td>
<p>the prior distribution on models that created the BMA 
object</p>
</td></tr> 
<tr><td><code>Q</code></td>
<td>
<p>the Q statistic for each model used in the marginal
likelihood approximation</p>
</td></tr> 
<tr><td><code>Y</code></td>
<td>
<p>response</p>
</td></tr> 
<tr><td><code>X</code></td>
<td>
<p>matrix of predictors</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>family object from the original call</p>
</td></tr> 
<tr><td><code>betaprior</code></td>
<td>
<p>family object for prior on coefficients, including
hyperparameters</p>
</td></tr>
<tr><td><code>modelprior</code></td>
<td>
<p>family object for prior on the models</p>
</td></tr>
<tr><td><code>include.always</code></td>
<td>
<p>indices of variables that are forced into the model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Merlise Clyde (<a href="mailto:clyde@duke.edu">clyde@duke.edu</a>), Quanli Wang and Yingbo
Li
</p>


<h3>References</h3>

<p>Li, Y. and Clyde, M. (2018) Mixtures of g-priors in Generalized
Linear Models. 
Journal of the American Statistical Association. 113:1828-1845 <br />
<a href="https://doi.org/10.1080/01621459.2018.1469992">doi:10.1080/01621459.2018.1469992</a> <br />
Clyde, M. Ghosh, J. and Littman, M. (2010) Bayesian Adaptive Sampling for
Variable Selection and Model Averaging. Journal of Computational Graphics
and Statistics.  20:80-101 <br />
<a href="https://doi.org/10.1198/jcgs.2010.09049">doi:10.1198/jcgs.2010.09049</a> <br />
Raftery, A.E, Madigan, D. and Hoeting, J.A. (1997) Bayesian Model Averaging
for Linear Regression Models. Journal of the American Statistical
Association.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)
data(Pima.tr)


# enumeration  with default method="BAS"
pima.cch = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
              method="BAS",
              betaprior=CCH(a=1, b=532/2, s=0), family=binomial(),
              modelprior=beta.binomial(1,1))

summary(pima.cch)
image(pima.cch)

# Note MCMC.iterations are set to 2500 for illustration purposes due to time
# limitations for running examples on CRAN servers.
# Please check convergence diagnostics and run longer in practice

pima.robust = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
              method="MCMC", MCMC.iterations=2500,
              betaprior=robust(), family=binomial(),
              modelprior=beta.binomial(1,1))

pima.BIC = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
              method="BAS+MCMC", MCMC.iterations=2500,
              betaprior=bic.prior(), family=binomial(),
              modelprior=uniform())
# Poisson example
if(requireNamespace("glmbb", quietly=TRUE)) {
  data(crabs, package='glmbb')
  #short run for illustration
  crabs.bas = bas.glm(satell ~ color*spine*width + weight, data=crabs,
                      family=poisson(),
                      betaprior=EB.local(), modelprior=uniform(),
                      method='MCMC', n.models=2^10, MCMC.iterations=2500,
                      prob.rw=.95)
  
 # Gamma example
 if(requireNamespace("faraway", quietly=TRUE)) {
    data(wafer, package='faraway')
                      
    wafer_bas = bas.glm(resist~ ., data=wafer,  include.always = ~ .,
                        betaprior = bic.prior() ,
                        family = Gamma(link = "log"))
  }
}
</code></pre>

<hr>
<h2 id='bas.lm'>Bayesian Adaptive Sampling for Bayesian Model Averaging and Variable Selection in
Linear Models</h2><span id='topic+bas.lm'></span><span id='topic+bas'></span>

<h3>Description</h3>

<p>Sample without replacement from a posterior distribution on models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bas.lm(
  formula,
  data,
  subset,
  weights,
  contrasts = NULL,
  na.action = "na.omit",
  n.models = NULL,
  prior = "ZS-null",
  alpha = NULL,
  modelprior = beta.binomial(1, 1),
  initprobs = "Uniform",
  include.always = ~1,
  method = "BAS",
  update = NULL,
  bestmodel = NULL,
  prob.local = 0,
  prob.rw = 0.5,
  burnin.iterations = NULL,
  MCMC.iterations = NULL,
  lambda = NULL,
  delta = 0.025,
  thin = 1,
  renormalize = FALSE,
  importance.sampling = FALSE,
  force.heredity = FALSE,
  pivot = TRUE,
  tol = 1e-07,
  bigmem = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bas.lm_+3A_formula">formula</code></td>
<td>
<p>linear model formula for the full model with all predictors,
Y ~ X.  All code assumes that an intercept will be included in each model
and that the X's will be centered.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_data">data</code></td>
<td>
<p>a data frame.  Factors will be converted to numerical vectors based on
the using 'model.matrix'.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process. Should be NULL or a numeric vector. If non-NULL, Bayes estimates
are obtained assuming that <code class="reqn">Y_i \sim N(x^T_i\beta, \sigma^2/w_i)</code>.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the contrasts.arg of 'model.matrix.default()'.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain NAs. The default is &quot;na.omit&quot;.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_n.models">n.models</code></td>
<td>
<p>number of models to sample either without replacement
(method=&quot;BAS&quot; or &quot;MCMC+BAS&quot;) or with replacement (method=&quot;MCMC&quot;). If NULL,
BAS with method=&quot;BAS&quot; will try to enumerate all 2^p models. If enumeration
is not possible (memory or time) then a value should be supplied which
controls the number of sampled models using 'n.models'.  With method=&quot;MCMC&quot;,
sampling will stop once the min(n.models, MCMC.iterations) occurs so
MCMC.iterations be significantly larger than n.models in order to explore the model space.
On exit for method= &quot;MCMC&quot; this is the number of unique models that have
been sampled with counts stored in the output as &quot;freq&quot;.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_prior">prior</code></td>
<td>
<p>prior distribution for regression coefficients.  Choices
include
</p>

<ul>
<li><p> &quot;AIC&quot;
</p>
</li>
<li><p> &quot;BIC&quot;
</p>
</li>
<li><p> &quot;g-prior&quot;, Zellner's g prior where 'g' is specified using the argument 'alpha'
</p>
</li>
<li><p> &quot;JZS&quot;  Jeffreys-Zellner-Siow prior which uses the Jeffreys
prior on sigma and the Zellner-Siow Cauchy prior on the coefficients.
The optional parameter 'alpha' can be used to control
the squared scale of the prior, where the default is alpha=1. Setting
'alpha' is equal to rscale^2 in the BayesFactor package of Morey.
This uses QUADMATH for numerical integration of g.
</p>
</li>
<li><p>  &quot;ZS-null&quot;, a Laplace approximation to the 'JZS' prior
for integration of g.  alpha = 1 only. We recommend
using 'JZS' for accuracy and compatibility
with the BayesFactor package, although it is
slower.
</p>
</li>
<li><p> &quot;ZS-full&quot; (to be deprecated)
</p>
</li>
<li><p> &quot;hyper-g&quot;, a mixture of g-priors where the prior on
g/(1+g) is a Beta(1, alpha/2) as in Liang et al (2008).  This
uses the Cephes library for evaluation of the marginal
likelihoods and may be numerically unstable for
large n or R2 close to 1.  Default choice of alpha is 3.
</p>
</li>
<li><p> &quot;hyper-g-laplace&quot;, Same as above but using a Laplace
approximation to integrate over the prior on g.
</p>
</li>
<li><p> &quot;hyper-g-n&quot;, a mixture of g-priors that where
u = g/n and u ~ Beta(1, alpha/2)  to provide consistency
when the null model is true.
</p>
</li>
<li><p> &quot;EB-local&quot;, use the MLE of g from the marginal likelihood
within each model
</p>
</li>
<li><p> &quot;EB-global&quot; uses an EM algorithm to find a common or
global estimate of g, averaged over all models.  When it is not possible to
enumerate all models, the EM algorithm uses only the
models sampled under EB-local.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bas.lm_+3A_alpha">alpha</code></td>
<td>
<p>optional hyperparameter in g-prior or hyper g-prior.  For
Zellner's g-prior, alpha = g, for the Liang et al hyper-g or hyper-g-n
method, recommended choice is alpha are between (2 &lt; alpha &lt; 4), with alpha
= 3 the default.  For the Zellner-Siow prior alpha = 1 by default, but can be used
to modify the rate parameter in the gamma prior on g,  
</p>
<p style="text-align: center;"><code class="reqn">1/g \sim G(1/2, n*\alpha/2)</code>
</p>
<p> so that
</p>
<p style="text-align: center;"><code class="reqn">\beta \sim C(0, \sigma^2 \alpha (X'X/n)^{-1})</code>
</p>
<p>.
If alpha = NULL, then the following defaults are used currently:
</p>

<ul>
<li><p>  &quot;g-prior&quot; = n,
</p>
</li>
<li><p> &quot;hyper-g&quot; = 3,
</p>
</li>
<li><p> &quot;EB-local&quot; = 2,
</p>
</li>
<li><p> &quot;BIC&quot; = n,
</p>
</li>
<li><p> &quot;ZS-null&quot; = 1,
</p>
</li>
<li><p> &quot;ZS-full&quot; = n,
</p>
</li>
<li><p> &quot;hyper-g-laplace&quot; = 3,
</p>
</li>
<li><p> &quot;AIC&quot; = 0,
</p>
</li>
<li><p> &quot;EB-global&quot; = 2,
</p>
</li>
<li><p> &quot;hyper-g-n&quot; = 3,
</p>
</li>
<li><p> &quot;JZS&quot; = 1,
</p>
</li></ul>

<p>Note that Porwal &amp; Raftery (2022) recommend alpha = sqrt(n) for the g-prior
based on extensive range of simulations and examples for comparing BMA.
This will become the default in the future.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_modelprior">modelprior</code></td>
<td>
<p>A function for a family of prior distribution on the models.  Choices
include <code><a href="#topic+uniform">uniform</a></code> <code><a href="#topic+Bernoulli">Bernoulli</a></code> or
<code><a href="#topic+beta.binomial">beta.binomial</a></code>, <code><a href="#topic+tr.beta.binomial">tr.beta.binomial</a></code>,
(with truncation) <code><a href="#topic+tr.poisson">tr.poisson</a></code> (a truncated Poisson), and
<code><a href="#topic+tr.power.prior">tr.power.prior</a></code> (a truncated power family),
with the default being a
<code>beta.binomial(1,1)</code>.  Truncated versions are useful for p &gt; n.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_initprobs">initprobs</code></td>
<td>
<p>Vector of length p or a character string specifying which
method is used to create the vector. This is used to order variables for
sampling all methods for potentially more efficient storage while sampling
and provides the initial inclusion probabilities used for sampling without
replacement with method=&quot;BAS&quot;.  Options for the character string giving the
method are: &quot;Uniform&quot; or &quot;uniform&quot; where each predictor variable is equally
likely to be sampled (equivalent to random sampling without replacement);
&quot;eplogp&quot; uses the <code><a href="#topic+eplogprob">eplogprob</a></code> function to approximate the Bayes
factor from p-values from the full model to find initial marginal inclusion
probabilities; &quot;marg-eplogp&quot; uses<code><a href="#topic+eplogprob.marg">eplogprob.marg</a></code> function to
approximate the Bayes factor from p-values from the full model each simple
linear regression.  To run a Markov Chain to provide initial estimates of
marginal inclusion probabilities for &quot;BAS&quot;, use method=&quot;MCMC+BAS&quot; below.
While the initprobs are not used in sampling for method=&quot;MCMC&quot;, this
determines the order of the variables in the lookup table and affects memory
allocation in large problems where enumeration is not feasible.  For
variables that should always be included set the corresponding initprobs to
1, to override the 'modelprior' or use 'include.always' to force these variables
to always be included in the model.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_include.always">include.always</code></td>
<td>
<p>A formula with terms that should always be included
in the model with probability one.  By default this is '~ 1' meaning that the
intercept is always included.  This will also override any of the values in 'initprobs'
above by setting them to 1.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_method">method</code></td>
<td>
<p>A character variable indicating which sampling method to use:
</p>

<ul>
<li><p>  &quot;deterministic&quot; uses the &quot;top k&quot; algorithm described in Ghosh and Clyde (2011)
to sample models in order of approximate probability under conditional independence
using the &quot;initprobs&quot;.  This is the most efficient algorithm for enumeration.
</p>
</li>
<li><p>  &quot;BAS&quot; uses Bayesian Adaptive Sampling (without replacement) using the
sampling probabilities given in initprobs under a model of conditional independence.
These can be updated based on estimates of the marginal inclusion probabilities.
</p>
</li>
<li><p>  &quot;MCMC&quot; samples with
replacement via a MCMC algorithm that combines the birth/death random walk
in Hoeting et al (1997) of MC3 with a random swap move to interchange a
variable in the model with one currently excluded as described in Clyde,
Ghosh and Littman (2010).
</p>
</li>
<li><p>  &quot;MCMC+BAS&quot; runs an initial MCMC to
calculate marginal inclusion probabilities and then samples without
replacement as in BAS.  For BAS, the sampling probabilities can be updated
as more models are sampled. (see update below).
</p>
</li>
<li><p>  &quot;AMCMC&quot; uses an adaptive proposal 
based on factoring the proposal distribution as a product conditional probabilities
estimated from the past draws. If 
'importance.sampling = FALSE' this uses an adaptive independent Metropolis-Hasting
algorithm, with if 'importance.sampling = TRUE'  uses importance sampline 
combined with Horiwitz-Thompson estimates of posterior model and inclusion
probabilities.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bas.lm_+3A_update">update</code></td>
<td>
<p>number of iterations between potential updates of the sampling
probabilities for method &quot;BAS&quot; or &quot;MCMC+BAS&quot;. If NULL do not update, otherwise the
algorithm will update using the marginal inclusion probabilities as they
change while sampling takes place.  For large model spaces, updating is
recommended. If the model space will be enumerated, leave at the default.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_bestmodel">bestmodel</code></td>
<td>
<p>optional binary vector representing a model to initialize
the sampling. If NULL sampling starts with the null model</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_prob.local">prob.local</code></td>
<td>
<p>A future option to allow sampling of models &quot;near&quot; the
median probability model.  Not used at this time.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_prob.rw">prob.rw</code></td>
<td>
<p>For any of the MCMC methods, probability of using the
random-walk Metropolis proposal; otherwise use a random &quot;flip&quot; move
to propose swap a variable that is excluded with a variable in the model.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_burnin.iterations">burnin.iterations</code></td>
<td>
<p>Number of burnin iterations for the MCMC sampler; the
default is n.models*10 if not set by the user.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_mcmc.iterations">MCMC.iterations</code></td>
<td>
<p>Number of iterations for the MCMC sampler; the
default is n.models*10 if not set by the user.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_lambda">lambda</code></td>
<td>
<p>Parameter in the AMCMC algorithm to insure positive definite 
covariance of gammas for adaptive conditional probabilities prior based on prior degrees of freedom pseudo
in Inverse-Wishart.  Default is set to p + 2.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_delta">delta</code></td>
<td>
<p>truncation parameter to prevent sampling probabilities to
degenerate to 0 or 1 prior to enumeration for sampling without replacement.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_thin">thin</code></td>
<td>
<p>For &quot;MCMC&quot; or &quot;MCMC+BAS&quot;, thin the MCMC chain every &quot;thin&quot; iterations; default is no
thinning.  For large p, thinning can be used to significantly reduce memory
requirements as models and associated summaries are saved only every thin iterations.  For thin = p, the  model and associated output are recorded every p iterations,
similar to the Gibbs sampler in SSVS.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_renormalize">renormalize</code></td>
<td>
<p>For MCMC sampling, should posterior probabilities be
based on renormalizing the marginal likelihoods times prior probabilities
(TRUE) or frequencies from MCMC.  The latter are unbiased in long runs,
while the former may have less variability.  May be compared via the
diagnostic plot function <code><a href="#topic+diagnostics">diagnostics</a></code>.
See details in Clyde and Ghosh (2012).</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_importance.sampling">importance.sampling</code></td>
<td>
<p>whether to use importance sampling or an independent
Metropolis-Hastings algorithm with sampling method=&quot;AMCMC&quot; (see above).</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_force.heredity">force.heredity</code></td>
<td>
<p>Logical variable to force all levels of a factor to be
included together and to include higher order interactions only if lower
order terms are included.  Currently supported with &lsquo;method=&rsquo;MCMC''
and experimentally with &lsquo;method=&rsquo;BAS'' on non-Solaris platforms. This is not
compatible currently for enforcing hierachical constraints with orthogonal 
polynomials, poly(x, degree = 3). Without hereditary constraints the number of 
possible models with all possible interactions is 2^2^k where k is the number 
of factors with more than 2 levels.  With hereditary constraints the number of
models is much less, but computing this for k can be quite expensive 
for large k. For the model y ~ x1*x2*x3*x4*x5*x6) there are 7828353 models, 
which is more than 2^22.  With n.models given, this will limit the number of
models to the min(n.models, # models under the heredity constraints)
Default is FALSE currently.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_pivot">pivot</code></td>
<td>
<p>Logical variable to allow pivoting of columns when obtaining the
OLS estimates of a model so that models that are not full rank can be fit.
Defaults to TRUE.
Currently coefficients that are not estimable are set to zero.  Use caution with
interpreting BMA estimates of parameters.</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_tol">tol</code></td>
<td>
<p>1e-7 as</p>
</td></tr>
<tr><td><code id="bas.lm_+3A_bigmem">bigmem</code></td>
<td>
<p>Logical variable to indicate that there is access to
large amounts of memory (physical or virtual) for enumeration
with large model spaces, e.g. &gt; 2^25. default; used in determining rank of 
X^TX in cholesky decomposition with pivoting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BAS provides several algorithms to sample from posterior distributions
of models for
use in Bayesian Model Averaging or Bayesian variable selection. For p less than
20-25, BAS can enumerate all models depending on memory availability.  As BAS saves all
models, MLEs, standard errors, log marginal likelihoods, prior and posterior and  probabilities
memory requirements grow linearly with M*p where M is the number of models
and p is the number of predictors.  For example, enumeration with p=21 with 2,097,152 takes just under
2 Gigabytes on a 64 bit machine to store all summaries that would be needed for model averaging.
(A future version will likely include an option to not store all summaries if
users do not plan on using  model averaging or model selection on Best Predictive models.)
For larger p, BAS samples without replacement using random or deterministic
sampling. The Bayesian Adaptive Sampling algorithm of Clyde, Ghosh, Littman
(2010) samples models without replacement using the initial sampling
probabilities, and will optionally update the sampling probabilities every
&quot;update&quot; models using the estimated marginal inclusion probabilities. BAS
uses different methods to obtain the <code>initprobs</code>, which may impact the
results in high-dimensional problems. The deterministic sampler provides a
list of the top models in order of an approximation of independence using
the provided <code>initprobs</code>.  This may be effective after running the
other algorithms to identify high probability models and works well if the
correlations of variables are small to modest.
We recommend &quot;MCMC&quot; for
problems where enumeration is not feasible (memory or time constrained)
or even modest p if the number of
models sampled is not close to the number of possible models and/or there are significant
correlations among the predictors as the bias in estimates of inclusion
probabilities from &quot;BAS&quot; or &quot;MCMC+BAS&quot; may be large relative to the reduced
variability from using the normalized model probabilities as shown in Clyde and Ghosh, 2012.
Diagnostic plots with MCMC can be used to assess convergence.
For large problems we recommend thinning with MCMC to reduce memory requirements.
The priors on coefficients
include Zellner's g-prior, the Hyper-g prior (Liang et al 2008, the
Zellner-Siow Cauchy prior, Empirical Bayes (local and global) g-priors.  AIC
and BIC are also included, while a range of priors on the model space are available.
</p>


<h3>Value</h3>

<p><code>bas</code> returns an object of class <code>bas</code>
</p>
<p>An object of class <code>BAS</code> is a list containing at least the following
components:
</p>
<table role = "presentation">
<tr><td><code>postprob</code></td>
<td>
<p>the posterior probabilities of the models selected</p>
</td></tr>
<tr><td><code>priorprobs</code></td>
<td>
<p>the prior probabilities of the models selected</p>
</td></tr>
<tr><td><code>namesx</code></td>
<td>
<p>the names of the variables</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>R2 values for the
models</p>
</td></tr>
<tr><td><code>logmarg</code></td>
<td>
<p>values of the log of the marginal likelihood for the
models.  This is equivalent to the log Bayes Factor for comparing
each model to a base model with intercept only.</p>
</td></tr>
<tr><td><code>n.vars</code></td>
<td>
<p>total number of independent variables in the full
model, including the intercept</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>the number of independent
variables in each of the models, includes the intercept</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the rank of the design matrix; if 'pivot = FALSE', this is the same as size
as no checking of rank is conducted.</p>
</td></tr>
<tr><td><code>which</code></td>
<td>
<p>a list
of lists with one list per model with variables that are included in the
model</p>
</td></tr>
<tr><td><code>probne0</code></td>
<td>
<p>the posterior probability that each variable is
non-zero computed using the renormalized marginal likelihoods of sampled
models.  This may be biased if the number of sampled models is much smaller
than the total number of models. Unbiased estimates may be obtained using
method &quot;MCMC&quot;.</p>
</td></tr>
<tr><td><code>mle</code></td>
<td>
<p>list of lists with one list per model giving the
MLE (OLS) estimate of each (nonzero) coefficient for each model. NOTE: The
intercept is the mean of Y as each column of X has been centered by
subtracting its mean.</p>
</td></tr>
<tr><td><code>mle.se</code></td>
<td>
<p>list of lists with one list per model
giving the MLE (OLS) standard error of each coefficient for each model</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>the name of the prior that created the BMA object</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>value of hyperparameter in coefficient prior used to create the BMA
object. </p>
</td></tr>
<tr><td><code>modelprior</code></td>
<td>
<p>the prior distribution on models that created the
BMA object</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>response</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>matrix of predictors</p>
</td></tr>
<tr><td><code>mean.x</code></td>
<td>
<p>vector of means for each column of X (used in
<code><a href="#topic+predict.bas">predict.bas</a></code>)</p>
</td></tr>
<tr><td><code>include.always</code></td>
<td>
<p>indices of variables that are forced into the model</p>
</td></tr>
</table>
<p>The function <code><a href="#topic+summary.bas">summary.bas</a></code>, is used to print a summary of the
results. The function <code><a href="#topic+plot.bas">plot.bas</a></code> is used to plot posterior
distributions for the coefficients and <code><a href="#topic+image.bas">image.bas</a></code> provides an
image of the distribution over models.  Posterior summaries of coefficients
can be extracted using <code><a href="#topic+coefficients.bas">coefficients.bas</a></code>.  Fitted values and
predictions can be obtained using the S3 functions <code><a href="#topic+fitted.bas">fitted.bas</a></code>
and <code><a href="#topic+predict.bas">predict.bas</a></code>.  BAS objects may be updated to use a
different prior (without rerunning the sampler) using the function
<code><a href="#topic+update.bas">update.bas</a></code>. For MCMC sampling <code><a href="#topic+diagnostics">diagnostics</a></code> can be used
to assess whether the MCMC has run long enough so that the posterior probabilities
are stable. For more details see the associated demos and vignette.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde (<a href="mailto:clyde@duke.edu">clyde@duke.edu</a>) and Michael Littman
</p>


<h3>References</h3>

<p>Clyde, M. Ghosh, J. and Littman, M. (2010) Bayesian Adaptive
Sampling for Variable Selection and Model Averaging. Journal of
Computational Graphics and Statistics.  20:80-101 <br />
<a href="https://doi.org/10.1198/jcgs.2010.09049">doi:10.1198/jcgs.2010.09049</a>
</p>
<p>Clyde, M. and Ghosh. J. (2012) Finite population estimators in stochastic search variable selection.
Biometrika, 99 (4), 981-988. <a href="https://doi.org/10.1093/biomet/ass040">doi:10.1093/biomet/ass040</a>
</p>
<p>Clyde, M. and George, E. I. (2004) Model Uncertainty. Statist. Sci., 19,
81-94. <br /> <a href="https://doi.org/10.1214/088342304000000035">doi:10.1214/088342304000000035</a>
</p>
<p>Clyde, M. (1999) Bayesian Model Averaging and Model Search Strategies (with
discussion). In Bayesian Statistics 6. J.M. Bernardo, A.P. Dawid, J.O.
Berger, and A.F.M. Smith eds. Oxford University Press, pages 157-185.
</p>
<p>Hoeting, J. A., Madigan, D., Raftery, A. E. and Volinsky, C. T. (1999)
Bayesian model averaging: a tutorial (with discussion). Statist. Sci., 14,
382-401. <br />
<a href="https://doi.org/10.1214/ss/1009212519">doi:10.1214/ss/1009212519</a>
</p>
<p>Liang, F., Paulo, R., Molina, G., Clyde, M. and Berger, J.O. (2008) Mixtures
of g-priors for Bayesian Variable Selection. Journal of the American
Statistical Association.  103:410-423.  <br />
<a href="https://doi.org/10.1198/016214507000001337">doi:10.1198/016214507000001337</a>
</p>
<p>Porwal, A. and Raftery, A. E. (2022) Comparing methods for statistical inference with model uncertainty
PNAS 119 (16) e2120737119
<a href="https://doi.org/10.1073/pnas.2120737119">doi:10.1073/pnas.2120737119</a> 
</p>
<p>Zellner, A. (1986) On assessing prior distributions and Bayesian regression
analysis with g-prior distributions. In Bayesian Inference and Decision
Techniques: Essays in Honor of Bruno de Finetti, pp. 233-243.
North-Holland/Elsevier.
</p>
<p>Zellner, A. and Siow, A. (1980) Posterior odds ratios for selected
regression hypotheses. In Bayesian Statistics: Proceedings of the First
International Meeting held in Valencia (Spain), pp. 585-603.
</p>
<p>Rouder, J. N., Speckman, P. L., Sun, D., Morey, R. D., and Iverson, G.
(2009). Bayesian t-tests for accepting and rejecting the null hypothesis.
Psychonomic Bulletin &amp; Review, 16, 225-237
</p>
<p>Rouder, J. N., Morey, R. D., Speckman, P. L., Province, J. M., (2012)
Default Bayes Factors for ANOVA Designs. Journal of Mathematical Psychology.
56.  p. 356-374.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.bas">summary.bas</a></code>, <code><a href="#topic+coefficients.bas">coefficients.bas</a></code>,
<code><a href="#topic+print.bas">print.bas</a></code>, <code><a href="#topic+predict.bas">predict.bas</a></code>, <code><a href="#topic+fitted.bas">fitted.bas</a></code>
<code><a href="#topic+plot.bas">plot.bas</a></code>, <code><a href="#topic+image.bas">image.bas</a></code>, <code><a href="#topic+eplogprob">eplogprob</a></code>,
<code><a href="#topic+update.bas">update.bas</a></code>
</p>
<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)
data(UScrime)

# pivot=FALSE is faster, but should only be used in full rank case
# default is pivot = TRUE
crime.bic &lt;- bas.lm(log(y) ~ log(M) + So + log(Ed) +
  log(Po1) + log(Po2) +
  log(LF) + log(M.F) + log(Pop) + log(NW) +
  log(U1) + log(U2) + log(GDP) + log(Ineq) +
  log(Prob) + log(Time),
  data = UScrime, n.models = 2^15, prior = "BIC",
  modelprior = beta.binomial(1, 1),
  initprobs = "eplogp", pivot = FALSE
)


# use MCMC rather than enumeration
crime.mcmc &lt;- bas.lm(log(y) ~ log(M) + So + log(Ed) +
  log(Po1) + log(Po2) +
  log(LF) + log(M.F) + log(Pop) + log(NW) +
  log(U1) + log(U2) + log(GDP) + log(Ineq) +
 log(Prob) + log(Time),
  data = UScrime,
  method = "MCMC",
  MCMC.iterations = 20000, prior = "BIC",
  modelprior = beta.binomial(1, 1),
  initprobs = "eplogp", pivot = FALSE
)

summary(crime.bic)
plot(crime.bic)
image(crime.bic, subset = -1)

# example with two-way interactions and hierarchical constraints
data(ToothGrowth)
ToothGrowth$dose &lt;- factor(ToothGrowth$dose)
levels(ToothGrowth$dose) &lt;- c("Low", "Medium", "High")
TG.bas &lt;- bas.lm(len ~ supp * dose,
  data = ToothGrowth,
  modelprior = uniform(), method = "BAS",
  force.heredity = TRUE
)
summary(TG.bas)
image(TG.bas)


# don't run the following due to time limits on CRAN 

## Not run: 

# exmple with non-full rank case

loc &lt;- system.file("testdata", package = "BAS")
d &lt;- read.csv(paste(loc, "JASP-testdata.csv", sep = "/"))
fullModelFormula &lt;- as.formula("contNormal ~  contGamma * contExpon +
                                contGamma * contcor1 + contExpon * contcor1")

# should trigger a warning (default is to use pivoting, so use pivot=FALSE 
# only for full rank case)

 out = bas.lm(fullModelFormula,
              data = d,
              alpha = 0.125316,
              prior = "JZS",
              weights = facFifty, force.heredity = FALSE, pivot = FALSE)


# use pivot = TRUE to fit non-full rank case  (default)
# This is slower but safer

out =  bas.lm(fullModelFormula,
              data = d,
              alpha = 0.125316,
              prior = "JZS",
              weights = facFifty, force.heredity = FALSE, pivot = TRUE)

## End(Not run)
# more complete demo's
demo(BAS.hald)
## Not run: 
demo(BAS.USCrime)

## End(Not run)

</code></pre>

<hr>
<h2 id='Bayes.outlier'>Bayesian Outlier Detection</h2><span id='topic+Bayes.outlier'></span>

<h3>Description</h3>

<p>Calculate the posterior  probability that the absolute value of
error exceeds more than k standard deviations
P(|epsilon_j| &gt; k sigma | data)
under the model Y = X B + epsilon,
with epsilon ~ N(0, sigma^2 I)
based on the paper
by Chaloner &amp; Brant Biometrika (1988). Either k or the prior
probability of there being no outliers must be provided.
This only uses the reference prior p(B, sigma) = 1;
other priors and model averaging to come.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bayes.outlier(lmobj, k, prior.prob)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bayes.outlier_+3A_lmobj">lmobj</code></td>
<td>
<p>An object of class 'lm'</p>
</td></tr>
<tr><td><code id="Bayes.outlier_+3A_k">k</code></td>
<td>
<p>number of standard deviations used in calculating
probability of an individual case being an outlier,
P(|error| &gt; k sigma | data)</p>
</td></tr>
<tr><td><code id="Bayes.outlier_+3A_prior.prob">prior.prob</code></td>
<td>
<p>The prior probability of there being no
outliers in the sample of size n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of three items:
</p>
<table role = "presentation">
<tr><td><code>e</code></td>
<td>
<p>residuals</p>
</td></tr>
<tr><td><code>hat</code></td>
<td>
<p>leverage values</p>
</td></tr>
<tr><td><code>prob.outlier</code></td>
<td>
<p>posterior probabilities of a point being an outlier</p>
</td></tr>
<tr><td><code>prior.prob</code></td>
<td>
<p>prior probability of a point being an outlier</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chaloner &amp; Brant (1988)
A Bayesian Approach to Outlier Detection and Residual Analysis
Biometrika (1988) 75, 651-659
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("stackloss")
stack.lm &lt;- lm(stack.loss ~ ., data = stackloss)
stack.outliers &lt;- Bayes.outlier(stack.lm, k = 3)
plot(stack.outliers$prob.outlier, type = "h", ylab = "Posterior Probability")
# adjust for sample size for calculating prior prob that a
# a case is an outlier
stack.outliers &lt;- Bayes.outlier(stack.lm, prior.prob = 0.95)
# cases where posterior probability exceeds prior probability
which(stack.outliers$prob.outlier &gt; stack.outliers$prior.prob)
</code></pre>

<hr>
<h2 id='bayesglm.fit'>Fitting Generalized Linear Models and Bayesian marginal likelihood
evaluation</h2><span id='topic+bayesglm.fit'></span>

<h3>Description</h3>

<p>A version of glm.fit rewritten in C; also returns marginal likelihoods for
Bayesian model comparison
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesglm.fit(
  x,
  y,
  weights = rep(1, nobs),
  start = NULL,
  etastart = NULL,
  mustart = NULL,
  offset = rep(0, nobs),
  family = binomial(),
  coefprior = bic.prior(nobs),
  control = glm.control(),
  intercept = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesglm.fit_+3A_x">x</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="bayesglm.fit_+3A_y">y</code></td>
<td>
<p>response</p>
</td></tr>
<tr><td><code id="bayesglm.fit_+3A_weights">weights</code></td>
<td>
<p>optional vector of weights to be used in the fitting process.
Should be NULL or a numeric vector.</p>
</td></tr>
<tr><td><code id="bayesglm.fit_+3A_start">start</code></td>
<td>
<p>starting value for coefficients in the linear predictor</p>
</td></tr>
<tr><td><code id="bayesglm.fit_+3A_etastart">etastart</code></td>
<td>
<p>starting values for the linear predictor</p>
</td></tr>
<tr><td><code id="bayesglm.fit_+3A_mustart">mustart</code></td>
<td>
<p>starting values for the vectors of means</p>
</td></tr>
<tr><td><code id="bayesglm.fit_+3A_offset">offset</code></td>
<td>
<p>a priori known component to be included in the linear
predictor</p>
</td></tr>
<tr><td><code id="bayesglm.fit_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function for
exponential family; currently only binomial(), poisson(), and Gamma() with canonical
links are implemented.</p>
</td></tr>
<tr><td><code id="bayesglm.fit_+3A_coefprior">coefprior</code></td>
<td>
<p>function specifying prior distribution on coefficients with
optional hyperparameters leading to marginal likelihood calculations;
options include <code>bic.prior()</code>,<code> aic.prior()</code>, and
<code>ic.prior()</code></p>
</td></tr>
<tr><td><code id="bayesglm.fit_+3A_control">control</code></td>
<td>
<p>a list of parameters that control convergence in the fitting
process.  See the documentation for <code>glm.control()</code></p>
</td></tr>
<tr><td><code id="bayesglm.fit_+3A_intercept">intercept</code></td>
<td>
<p>should an intercept be included in the null model?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>C version of glm-fit.  For different prior choices returns, marginal
likelihood of model using a Laplace approximation.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>MLEs</p>
</td></tr> <tr><td><code>se</code></td>
<td>
<p>Standard errors of coefficients
based on the sqrt of the diagonal of the inverse information matrix</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>fitted mean</p>
</td></tr> <tr><td><code>rank</code></td>
<td>
<p>numeric rank of the fitted linear model</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>minus twice the log likelihood evaluated at the MLEs</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>value of g in g-priors</p>
</td></tr> <tr><td><code>shrinkage</code></td>
<td>
<p>shrinkage factor for
coefficients in linear predictor</p>
</td></tr> <tr><td><code>RegSS</code></td>
<td>
<p>quadratic form
beta'I(beta)beta used in shrinkage</p>
</td></tr> <tr><td><code>logmarglik</code></td>
<td>
<p>the log marginal or
integrated log likelihood (up to a constant)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Merlise Clyde translated the <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> from R base into
C using the .Call interface
</p>


<h3>References</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bic.prior">bic.prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Pima.tr, package="MASS")
Y &lt;- as.numeric(Pima.tr$type) - 1
X &lt;- cbind(1, as.matrix(Pima.tr[,1:7]))
out &lt;- bayesglm.fit(X, Y, family=binomial(),coefprior=bic.prior(n=length(Y)))
out$coef
out$se
# using built in function
glm(type ~ ., family=binomial(), data=Pima.tr)

</code></pre>

<hr>
<h2 id='Bernoulli'>Independent Bernoulli Prior Distribution for Models</h2><span id='topic+Bernoulli'></span><span id='topic+bernoulli'></span>

<h3>Description</h3>

<p>Creates an object representing the prior distribution on models for BAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bernoulli(probs = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bernoulli_+3A_probs">probs</code></td>
<td>
<p>a scalar or vector of prior inclusion probabilities. If a
scalar, the values is replicated for all variables ans a 1 is added for the
intercept. BAS checks to see if the length is equal to the dimension of the
parameter vector for the full model and adds a 1 to include the intercept.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The independent Bernoulli prior distribution is a commonly used prior in
BMA, with the Uniform distribution a special case with probs=.5.  If all
indicator variables have a independent Bernoulli distributions with common
probability probs, the distribution on model size binomial(p, probs)
distribution.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyperparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas.lm">bas.lm</a></code>,
<code><a href="#topic+beta.binomial">beta.binomial</a></code>,<code><a href="#topic+uniform">uniform</a> </code>
</p>
<p>Other priors modelpriors: 
<code><a href="#topic+Bernoulli.heredity">Bernoulli.heredity</a>()</code>,
<code><a href="#topic+beta.binomial">beta.binomial</a>()</code>,
<code><a href="#topic+tr.beta.binomial">tr.beta.binomial</a>()</code>,
<code><a href="#topic+tr.poisson">tr.poisson</a>()</code>,
<code><a href="#topic+tr.power.prior">tr.power.prior</a>()</code>,
<code><a href="#topic+uniform">uniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Bernoulli(.9)
</code></pre>

<hr>
<h2 id='Bernoulli.heredity'>Independent Bernoulli prior on models that with constraints for
model hierarchy induced by interactions</h2><span id='topic+Bernoulli.heredity'></span>

<h3>Description</h3>

<p>Independent Bernoulli prior on models that with constraints for
model hierarchy induced by interactions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bernoulli.heredity(pi = 0.5, parents)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bernoulli.heredity_+3A_pi">pi</code></td>
<td>
<p>Bernoulli probability that term is included</p>
</td></tr>
<tr><td><code id="Bernoulli.heredity_+3A_parents">parents</code></td>
<td>
<p>matrix of terms and parents with indicators of which terms
are parents for each term</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Not implemented yet for use with bas.lm or bas.glm
</p>


<h3>See Also</h3>

<p>Other priors modelpriors: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+beta.binomial">beta.binomial</a>()</code>,
<code><a href="#topic+tr.beta.binomial">tr.beta.binomial</a>()</code>,
<code><a href="#topic+tr.poisson">tr.poisson</a>()</code>,
<code><a href="#topic+tr.power.prior">tr.power.prior</a>()</code>,
<code><a href="#topic+uniform">uniform</a>()</code>
</p>

<hr>
<h2 id='beta.binomial'>Beta-Binomial Prior Distribution for Models</h2><span id='topic+beta.binomial'></span><span id='topic+Beta.Binomial'></span>

<h3>Description</h3>

<p>Creates an object representing the prior distribution on models for BAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.binomial(alpha = 1, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beta.binomial_+3A_alpha">alpha</code></td>
<td>
<p>parameter in the beta prior distribution</p>
</td></tr>
<tr><td><code id="beta.binomial_+3A_beta">beta</code></td>
<td>
<p>parameter in the beta prior distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta-binomial distribution on model size is obtained by assigning each
variable inclusion indicator independent Bernoulli distributions with
probability w, and then giving w a beta(alpha,beta) distribution.
Marginalizing over w leads to the distribution on model size having the
beta-binomial distribution. The default hyperparameters lead to a uniform
distribution over model size.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyperparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas.lm">bas.lm</a></code>, <code><a href="#topic+Bernoulli">Bernoulli</a></code>,<code><a href="#topic+uniform">uniform</a></code>
</p>
<p>Other priors modelpriors: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Bernoulli.heredity">Bernoulli.heredity</a>()</code>,
<code><a href="#topic+tr.beta.binomial">tr.beta.binomial</a>()</code>,
<code><a href="#topic+tr.poisson">tr.poisson</a>()</code>,
<code><a href="#topic+tr.power.prior">tr.power.prior</a>()</code>,
<code><a href="#topic+uniform">uniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beta.binomial(1, 10) #' @family priors modelpriors
</code></pre>

<hr>
<h2 id='beta.prime'>Beta-Prime Prior Distribution for Coefficients in BMA Model</h2><span id='topic+beta.prime'></span>

<h3>Description</h3>

<p>Creates an object representing the Beta-Prime prior that is mixture of
g-priors on coefficients for BAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.prime(n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beta.prime_+3A_n">n</code></td>
<td>
<p>the sample size; if NULL, the value derived from the data in the
call to 'bas.glm' will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a structure used for <code><a href="#topic+bas.glm">bas.glm</a></code>.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyerparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CCH">CCH</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+CCH">CCH</a>()</code>,
<code><a href="#topic+EB.local">EB.local</a>()</code>,
<code><a href="#topic+IC.prior">IC.prior</a>()</code>,
<code><a href="#topic+Jeffreys">Jeffreys</a>()</code>,
<code><a href="#topic+TG">TG</a>()</code>,
<code><a href="#topic+g.prior">g.prior</a>()</code>,
<code><a href="#topic+hyper.g">hyper.g</a>()</code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a>()</code>,
<code><a href="#topic+intrinsic">intrinsic</a>()</code>,
<code><a href="#topic+robust">robust</a>()</code>,
<code><a href="#topic+tCCH">tCCH</a>()</code>,
<code><a href="#topic+testBF.prior">testBF.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beta.prime(n = 100)
</code></pre>

<hr>
<h2 id='bodyfat'>Bodyfat Data</h2><span id='topic+bodyfat'></span><span id='topic+Bodyfat'></span>

<h3>Description</h3>

<p>Lists estimates of the percentage of body fat determined by underwater
weighing and various body circumference measurements for 252 men.  Accurate
measurement of body fat is inconvenient/costly and it is desirable to have
easy methods of estimating body fat that are not inconvenient/costly.
</p>


<h3>Format</h3>

<p>A data frame with 252 observations on the following 15 variables.
</p>
 <dl>
<dt>Density</dt><dd><p>a numeric vector for the density
determined from underwater weighing</p>
</dd> <dt>Bodyfat</dt><dd><p>percent body fat
from Siri's (1956) equation</p>
</dd> <dt>Age</dt><dd><p>age of individual in years</p>
</dd>
<dt>Weight</dt><dd><p>weight of the individual in pounds</p>
</dd>
<dt>Height</dt><dd><p>height of individual in inches</p>
</dd>
<dt>Neck</dt><dd><p>neck circumference in centimeters (cm)</p>
</dd>
<dt>Chest</dt><dd><p>chest circumference (cm)</p>
</dd>
<dt>Abdomen</dt><dd><p>abdomen circumference (cm)</p>
</dd> <dt>Hip</dt><dd><p>hip
circumference (cm)</p>
</dd> <dt>&quot;Thigh&quot;</dt><dd><p>thigh circumference (cm)</p>
</dd>
<dt>&quot;Knee&quot;</dt><dd><p>knee circumference (cm)</p>
</dd> <dt>Ankle</dt><dd><p>ankle
circumference (cm)</p>
</dd> <dt>Biceps</dt><dd><p>bicep (extended) circumference
(cm)</p>
</dd> <dt>Forearm</dt><dd><p>forearm circumference (cm)</p>
</dd>
<dt>Wrist</dt><dd><p>wrist circumference (cm)</p>
</dd> </dl>



<h3>Details</h3>

<p>A variety of popular health books suggest that the readers assess their
health, at least in part, by estimating their percentage of body fat. In
Bailey (1994), for instance, the reader can estimate body fat from tables
using their age and various skin-fold measurements obtained by using a
caliper. Other texts give predictive equations for body fat using body
circumference measurements (e.g. abdominal circumference) and/or skin-fold
measurements. See, for instance, Behnke and Wilmore (1974), pp. 66-67;
Wilmore (1976), p. 247; or Katch and McArdle (1977), pp. 120-132).#
</p>
<p>Percentage of body fat for an individual can be estimated once body density
has been determined. Folks (e.g. Siri (1956)) assume that the body consists
of two components - lean body tissue and fat tissue. Letting
</p>
<p>D = Body Density (gm/cm^3) A = proportion of lean body tissue B = proportion
of fat tissue (A+B=1) a = density of lean body tissue (gm/cm^3) b = density
of fat tissue (gm/cm^3)
</p>
<p>we have D = 1/[(A/a) + (B/b)] and solving for B we find B = (1/D)*[ab/(a-b)]
- [b/(a-b)].
</p>
<p>Using the estimates a=1.10 gm/cm^3 and b=0.90 gm/cm^3 (see Katch and McArdle
(1977), p. 111 or Wilmore (1976), p. 123) we come up with &quot;Siri's equation&quot;:
</p>
<p>Percentage of Body Fat (i.e. 100*B) = 495/D - 450.#
</p>
<p>Volume, and hence body density, can be accurately measured a variety of
ways. The technique of underwater weighing &quot;computes body volume as the
difference between body weight measured in air and weight measured during
water submersion. In other words, body volume is equal to the loss of weight
in water with the appropriate temperature correction for the water's
density&quot; (Katch and McArdle (1977), p. 113). Using this technique,
</p>
<p>Body Density = WA/[(WA-WW)/c.f. - LV]
</p>
<p>where WA = Weight in air (kg) WW = Weight in water (kg) c.f. = Water
correction factor (=1 at 39.2 deg F as one-gram of water occupies exactly
one cm^3 at this temperature, =.997 at 76-78 deg F) LV = Residual Lung
Volume (liters)
</p>
<p>(Katch and McArdle (1977), p. 115). Other methods of determining body volume
are given in Behnke and Wilmore (1974), p. 22 ff.
</p>
<p>Measurement standards are apparently those listed in Behnke and Wilmore
(1974), pp. 45-48 where, for instance, the abdomen circumference is measured
&quot;laterally, at the level of the iliac crests, and anteriorly, at the
umbilicus&quot;.)
</p>


<h3>Source</h3>

<p>These data are used to produce the predictive equations for lean
body weight given in the abstract &quot;Generalized body composition prediction
equation for men using simple measurement techniques&quot;, K.W. Penrose, A.G.
Nelson, A.G. Fisher, FACSM, Human Performance Research Center, Brigham Young
University, Provo, Utah 84602 as listed in _Medicine and Science in Sports
and Exercise_, vol. 17, no. 2, April 1985, p. 189. (The predictive equations
were obtained from the first 143 of the 252 cases that are listed below).
The data were generously supplied by Dr. A. Garth Fisher who gave permission
to freely distribute the data and use for non-commercial purposes.
</p>


<h3>References</h3>

<p>Bailey, Covert (1994). Smart Exercise: Burning Fat, Getting Fit,
Houghton-Mifflin Co., Boston, pp. 179-186.
</p>
<p>Behnke, A.R. and Wilmore, J.H. (1974). Evaluation and Regulation of Body
Build and Composition, Prentice-Hall, Englewood Cliffs, N.J.
</p>
<p>Siri, W.E. (1956), &quot;Gross composition of the body&quot;, in Advances in
Biological and Medical Physics, vol. IV, edited by J.H. Lawrence and C.A.
Tobias, Academic Press, Inc., New York.
</p>
<p>Katch, Frank and McArdle, William (1977). Nutrition, Weight Control, and
Exercise, Houghton Mifflin Co., Boston.
</p>
<p>Wilmore, Jack (1976). Athletic Training and Physical Fitness: Physiological
Principles of the Conditioning Process, Allyn and Bacon, Inc., Boston.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bodyfat)
bodyfat.bas = bas.lm(Bodyfat ~ Abdomen, data=bodyfat, prior="ZS-null")
summary(bodyfat.bas)
plot(Bodyfat ~ Abdomen, data=bodyfat, xlab="abdomen circumference (cm)")
betas = coef(bodyfat.bas)$postmean   # current version has that intercept is ybar
betas[1] = betas[1] - betas[2]*bodyfat.bas$mean.x
abline(betas)
abline(coef(lm(Bodyfat ~ Abdomen, data=bodyfat)), col=2, lty=2)

</code></pre>

<hr>
<h2 id='CCH'>Generalized g-Prior Distribution for Coefficients in BMA Models</h2><span id='topic+CCH'></span>

<h3>Description</h3>

<p>Creates an object representing the CCH mixture of g-priors on coefficients
for BAS .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCH(alpha, beta, s = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CCH_+3A_alpha">alpha</code></td>
<td>
<p>a scalar &gt; 0, recommended alpha=.5 (betaprime) or 1 for CCH.
The hyper.g(alpha) is equivalent to CCH(alpha -2, 2, 0). Liang et al
recommended values in the range 2 &lt; alpha_h &lt;= 4</p>
</td></tr>
<tr><td><code id="CCH_+3A_beta">beta</code></td>
<td>
<p>a scalar &gt; 0.  The value is not updated by the data; beta should
be a function of n for consistency under the null model.  The hyper-g
corresponds to b = 2</p>
</td></tr>
<tr><td><code id="CCH_+3A_s">s</code></td>
<td>
<p>a scalar, recommended s=0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a structure used for <code><a href="#topic+bas.glm">bas.glm</a></code>.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyperparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise A Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC.prior">IC.prior</a></code>, <code><a href="#topic+bic.prior">bic.prior</a></code>,
<code><a href="#topic+bas.glm">bas.glm</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+EB.local">EB.local</a>()</code>,
<code><a href="#topic+IC.prior">IC.prior</a>()</code>,
<code><a href="#topic+Jeffreys">Jeffreys</a>()</code>,
<code><a href="#topic+TG">TG</a>()</code>,
<code><a href="#topic+beta.prime">beta.prime</a>()</code>,
<code><a href="#topic+g.prior">g.prior</a>()</code>,
<code><a href="#topic+hyper.g">hyper.g</a>()</code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a>()</code>,
<code><a href="#topic+intrinsic">intrinsic</a>()</code>,
<code><a href="#topic+robust">robust</a>()</code>,
<code><a href="#topic+tCCH">tCCH</a>()</code>,
<code><a href="#topic+testBF.prior">testBF.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CCH(alpha = .5, beta = 100, s = 0)
</code></pre>

<hr>
<h2 id='climate'>Climate Data</h2><span id='topic+climate'></span>

<h3>Description</h3>

<p>Climate Data
</p>


<h3>Format</h3>

<p>Scientists are interested in the Earth's temperature change since the last
glacial maximum, about 20,000 years ago. The first study to estimate the
temperature change was published in 1980, and estimated a change of -1.5 degrees
C, +/- 1.2 degrees C in tropical sea surface temperatures.
The negative value means that the Earth was colder then than now.
Since 1980 there have been many other studies.
<code>climate</code> is a dataset with 63 measurements on 5 variables:
</p>
<dl>
<dt><em>deltaT</em></dt><dd><p> the response variables, which is the change in temperature
in degrees Celsius;</p>
</dd>
<dt><em>sdev</em></dt><dd><p>a standard deviation for the calculated <em>deltaT</em>;</p>
</dd>
<dt><em>proxy</em></dt><dd><p>a number 1-8 reflecting which type of measurement system was used to derive
deltaT. Some proxies can be used over land, others over water.
The proxies are coded as<br />
1 &quot;Mg/Ca&quot;         <br />
2 &quot;alkenone&quot;      <br />
3 &quot;Faunal&quot;        <br />
4 &quot;Sr/Ca&quot;         <br />
5 &quot;del 180&quot;       <br />
6 &quot;Ice Core&quot;      <br />
7 &quot;Pollen&quot;        <br />
8 &quot;Noble Gas&quot;     <br />
</p>
</dd>
<dt><em>T/M</em></dt><dd><p>, an indicator of whether it was a terrestrial or marine study (T/M),
which is coded as 0 for Terrestrial, 1 for Marine;</p>
</dd>
<dt> <em>latitude</em></dt><dd><p>the latitude where the data were collected.</p>
</dd></dl>



<h3>Source</h3>

<p>Data provided originally by Michael Lavine
</p>

<hr>
<h2 id='coef.bas'>Coefficients of a Bayesian Model Average object</h2><span id='topic+coef.bas'></span><span id='topic+coef'></span><span id='topic+coefficients'></span><span id='topic+coefficients.bas'></span><span id='topic+print.coef.bas'></span>

<h3>Description</h3>

<p>Extract conditional posterior means and standard deviations, marginal
posterior means and standard deviations, posterior probabilities, and
marginal inclusions probabilities under Bayesian Model Averaging from an
object of class 'bas'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bas'
coef(object, n.models, estimator = "BMA", ...)

## S3 method for class 'coef.bas'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.bas_+3A_object">object</code></td>
<td>
<p>object of class 'bas' created by BAS</p>
</td></tr>
<tr><td><code id="coef.bas_+3A_n.models">n.models</code></td>
<td>
<p>Number of top models to report in the printed summary, for
coef the default is to use all models.  To extract summaries for the Highest
Probability Model, use n.models=1 or estimator=&quot;HPM&quot;.</p>
</td></tr>
<tr><td><code id="coef.bas_+3A_estimator">estimator</code></td>
<td>
<p>return summaries for a selected model, rather than using
BMA.  Options are 'HPM' (highest posterior probability model) ,'MPM' (median
probability model), and 'BMA'</p>
</td></tr>
<tr><td><code id="coef.bas_+3A_...">...</code></td>
<td>
<p>other optional arguments</p>
</td></tr>
<tr><td><code id="coef.bas_+3A_x">x</code></td>
<td>
<p>object of class 'coef.bas' to print</p>
</td></tr>
<tr><td><code id="coef.bas_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates posterior means and (approximate) standard deviations of the
regression coefficients under Bayesian Model averaging using g-priors and
mixtures of g-priors.  Print returns overall summaries. For fully Bayesian
methods that place a prior on g, the posterior standard deviations do not
take into account full uncertainty regarding g. Will be updated in future
releases.
</p>


<h3>Value</h3>

<p><code>coefficients</code> returns an object of class coef.bas with the
following:
</p>
<table role = "presentation">
<tr><td><code>conditionalmeans</code></td>
<td>
<p>a matrix with conditional posterior means
for each model</p>
</td></tr>
<tr><td><code>conditionalsd</code></td>
<td>
<p> standard deviations for each model </p>
</td></tr>
<tr><td><code>postmean</code></td>
<td>
<p>marginal posterior means of each regression coefficient
using BMA</p>
</td></tr>
<tr><td><code>postsd</code></td>
<td>
<p>marginal posterior standard deviations using BMA</p>
</td></tr>
<tr><td><code>postne0</code></td>
<td>
<p>vector of posterior inclusion probabilities, marginal
probability that a coefficient is non-zero</p>
</td></tr>
</table>


<h3>Note</h3>

<p>With highly correlated variables, marginal summaries may not be
representative of the joint distribution. Use <code><a href="#topic+plot.coef.bas">plot.coef.bas</a></code> to
view distributions.  The value reported for the intercept is
under the centered parameterization.  Under the  Gaussian error
model it will be centered at the sample mean of Y.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@duke.edu">clyde@duke.edu</a>
</p>


<h3>References</h3>

<p>Liang, F., Paulo, R., Molina, G., Clyde, M. and Berger, J.O.
(2005) Mixtures of g-priors for Bayesian Variable Selection.  Journal of the
American Statistical Association.  103:410-423.  <br />
<a href="https://doi.org/10.1198/016214507000001337">doi:10.1198/016214507000001337</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas">bas</a></code>, <code><a href="#topic+confint.coef.bas">confint.coef.bas</a></code>
</p>
<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Hald")
hald.gprior =  bas.lm(Y~ ., data=Hald, n.models=2^4, alpha=13,
                      prior="ZS-null", initprobs="Uniform", update=10)
coef.hald.gprior = coefficients(hald.gprior)
coef.hald.gprior
plot(coef.hald.gprior)
confint(coef.hald.gprior)

#Estimation under Median Probability Model
coef.hald.gprior = coefficients(hald.gprior, estimator="MPM")
coef.hald.gprior
plot(coef.hald.gprior)
plot(confint(coef.hald.gprior))


coef.hald.gprior = coefficients(hald.gprior, estimator="HPM")
coef.hald.gprior
plot(coef.hald.gprior)
confint(coef.hald.gprior)

# To add estimation under Best Predictive Model


</code></pre>

<hr>
<h2 id='confint.coef.bas'>Compute Credible Intervals for BAS regression coefficients from BAS objects</h2><span id='topic+confint.coef.bas'></span><span id='topic+confint'></span>

<h3>Description</h3>

<p>Uses Monte Carlo simulations using posterior means and standard deviations
of coefficients to generate draws from the posterior distributions and
returns highest posterior density (HPD) credible intervals.  If the number
of models equals one, then use the t distribution to find intervals.  These
currently condition on the estimate of $g$. 
than the description above ~~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coef.bas'
confint(object, parm, level = 0.95, nsim = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.coef.bas_+3A_object">object</code></td>
<td>
<p>a coef.bas object</p>
</td></tr>
<tr><td><code id="confint.coef.bas_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given credible
intervals, either a vector of numbers or a vector of names. If missing, all
parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.coef.bas_+3A_level">level</code></td>
<td>
<p>the probability coverage required</p>
</td></tr>
<tr><td><code id="confint.coef.bas_+3A_nsim">nsim</code></td>
<td>
<p>number of Monte Carlo draws from the posterior distribution.
Used when number of models is greater than 1.</p>
</td></tr>
<tr><td><code id="confint.coef.bas_+3A_...">...</code></td>
<td>
<p>other arguments to passed; none currently</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper HPD
credible limits for each parameter. These will be labeled as 1-level)/2 and
1 - (1-level)/2 in percent (by default 2.5 and 97.5).
</p>


<h3>Note</h3>

<p>For mixture of g-priors these are approximate.  This uses Monte Carlo
sampling so results may be subject to Monte Carlo variation and larger values
of nsim may be needed to reduce variability. 
</p>


<h3>Author(s)</h3>

<p>Merlise A Clyde
</p>


<h3>See Also</h3>

<p>Other CI methods: 
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>
</p>
<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("Hald")
hald_gprior &lt;-  bas.lm(Y~ ., data=Hald, alpha=13,
                            prior="g-prior")
coef_hald &lt;- coef(hald_gprior)
confint(coef_hald)
confint(coef_hald, approx=FALSE, nsim=5000)
# extract just the coefficient of X4
confint(coef_hald, parm="X4")


</code></pre>

<hr>
<h2 id='confint.pred.bas'>Compute Credible (Bayesian Confidence) Intervals for a BAS predict object</h2><span id='topic+confint.pred.bas'></span>

<h3>Description</h3>

<p>Compute credible intervals for in-sample or out of sample prediction or for
the regression function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pred.bas'
confint(object, parm, level = 0.95, nsim = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.pred.bas_+3A_object">object</code></td>
<td>
<p>an object created by <code><a href="#topic+predict.bas">predict.bas</a></code></p>
</td></tr>
<tr><td><code id="confint.pred.bas_+3A_parm">parm</code></td>
<td>
<p>character variable, &quot;mean&quot; or &quot;pred&quot;.  If missing parm='pred'.</p>
</td></tr>
<tr><td><code id="confint.pred.bas_+3A_level">level</code></td>
<td>
<p>the nominal level of the (point-wise) credible interval</p>
</td></tr>
<tr><td><code id="confint.pred.bas_+3A_nsim">nsim</code></td>
<td>
<p>number of Monte Carlo simulations for sampling methods with BMA</p>
</td></tr>
<tr><td><code id="confint.pred.bas_+3A_...">...</code></td>
<td>
<p>optional arguments to pass on to next function call; none at this
time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This constructs approximate 95 percent Highest Posterior Density intervals
for 'pred.bas' objects.  If the estimator is based on model selection, the
intervals use a Student t distribution using the estimate of g.  If the
estimator is based on BMA, then nsim draws from the mixture of Student t
distributions are obtained with the HPD interval obtained from the Monte
Carlo draws. 
</p>


<h3>Value</h3>

<p>a matrix with lower and upper level * 100 percent credible intervals
for either the mean of the regression function or predicted values.  
</p>


<h3>Author(s)</h3>

<p>Merlise A Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.bas">predict.bas</a></code>
</p>
<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>
<p>Other CI methods: 
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Hald")
hald.gprior =  bas.lm(Y~ ., data=Hald, alpha=13, prior="g-prior")
hald.pred = predict(hald.gprior, estimator="BPM", predict=FALSE, se.fit=TRUE)
confint(hald.pred, parm="mean")
confint(hald.pred)  #default
hald.pred = predict(hald.gprior, estimator="BMA", predict=FALSE, se.fit=TRUE)
confint(hald.pred)


</code></pre>

<hr>
<h2 id='cv.summary.bas'>Summaries for Out of Sample Prediction</h2><span id='topic+cv.summary.bas'></span>

<h3>Description</h3>

<p>Compute average prediction error from out of sample predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.summary.bas(pred, ytrue, score = "squared-error")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.summary.bas_+3A_pred">pred</code></td>
<td>
<p>fitted or predicted value from the output from
<code><a href="#topic+predict.bas">predict.bas</a></code></p>
</td></tr>
<tr><td><code id="cv.summary.bas_+3A_ytrue">ytrue</code></td>
<td>
<p>vector of left out response values</p>
</td></tr>
<tr><td><code id="cv.summary.bas_+3A_score">score</code></td>
<td>
<p>function used to summarize error rate.  Either &quot;squared-error&quot;,
or &quot;miss-class&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For squared error, the average prediction error for the Bayesian
estimator error = sqrt(sum(ytrue - yhat)^2/npred) while for binary data the
misclassification rate is more appropriate.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@duke.edu">clyde@duke.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.bas">predict.bas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(foreign)
cognitive &lt;- read.dta("https://www.stat.columbia.edu/~gelman/arm/examples/child.iq/kidiq.dta")
cognitive$mom_work &lt;- as.numeric(cognitive$mom_work &gt; 1)
cognitive$mom_hs &lt;- as.numeric(cognitive$mom_hs &gt; 0)
colnames(cognitive) &lt;- c("kid_score", "hs", "iq", "work", "age")

set.seed(42)
n &lt;- nrow(cognitive)
test &lt;- sample(1:n, size = round(.20 * n), replace = FALSE)
testdata &lt;- cognitive[test, ]
traindata &lt;- cognitive[-test, ]
cog_train &lt;- bas.lm(kid_score ~ ., prior = "BIC", modelprior = uniform(), data = traindata)
yhat &lt;- predict(cog_train, newdata = testdata, estimator = "BMA", se = F)
cv.summary.bas(yhat$fit, testdata$kid_score)

## End(Not run)
</code></pre>

<hr>
<h2 id='diagnostics'>BAS MCMC diagnostic plot</h2><span id='topic+diagnostics'></span>

<h3>Description</h3>

<p>Function to help assess convergence of MCMC sampling for bas objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostics(obj, type = c("pip", "model"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnostics_+3A_obj">obj</code></td>
<td>
<p>an object created by bas.lm or bas.glm</p>
</td></tr>
<tr><td><code id="diagnostics_+3A_type">type</code></td>
<td>
<p>type of diagnostic plot.  If &quot;pip&quot; the marginal inclusion
probabilities are used, while if &quot;model&quot;, plot posterior model probabilities</p>
</td></tr>
<tr><td><code id="diagnostics_+3A_...">...</code></td>
<td>
<p>additional graphics parameters to be passed to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BAS calculates posterior model probabilities in two ways when method=&quot;MCMC&quot;.
The first is using the relative Monte Carlo frequencies of sampled models.
The second is to renormalize the marginal likelihood times prior
probabilities over the sampled models.  If the Markov chain has converged,
these two quantities should be the same and fall on a 1-1 line.  If not,
running longer may be required.  If the chain has not converged, the Monte
Carlo frequencies may have less bias, although may exhibit more
variability on repeated runs.
</p>


<h3>Value</h3>

<p>a plot with of the marginal inclusion probabilities (pip) estimated
by MCMC and renormalized marginal likelihoods times prior probabilities or
model probabilities.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde (<a href="mailto:clyde@duke.edu">clyde@duke.edu</a>)
</p>


<h3>See Also</h3>

<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)
data(UScrime)
UScrime[, -2] &lt;- log(UScrime[, -2])
crime.ZS &lt;- bas.lm(y ~ .,
  data = UScrime,
  prior = "ZS-null",
  modelprior = uniform(),
  method = "MCMC",
  MCMC.iter = 1000
) # short run for the example
diagnostics(crime.ZS)
</code></pre>

<hr>
<h2 id='EB.global'>Find the global Empirical Bayes estimates for BMA</h2><span id='topic+EB.global'></span><span id='topic+EB.global.bas'></span>

<h3>Description</h3>

<p>Finds the global Empirical Bayes estimates of g in Zellner's g-prior and
model probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EB.global(object, tol = 0.1, g.0 = NULL, max.iterations = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EB.global_+3A_object">object</code></td>
<td>
<p>A 'bas' object created by <code><a href="#topic+bas">bas</a></code></p>
</td></tr>
<tr><td><code id="EB.global_+3A_tol">tol</code></td>
<td>
<p>tolerance for estimating g</p>
</td></tr>
<tr><td><code id="EB.global_+3A_g.0">g.0</code></td>
<td>
<p>initial value for g</p>
</td></tr>
<tr><td><code id="EB.global_+3A_max.iterations">max.iterations</code></td>
<td>
<p>Maximum number of iterations for the EM algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the EM algorithm in Liang et al to estimate the type II MLE of g in
Zellner's g prior
</p>


<h3>Value</h3>

<p>An object of class 'bas' using Zellner's g prior with an estimate of
g based on all models
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@stat.duke.edu">clyde@stat.duke.edu</a>
</p>


<h3>References</h3>

<p>Liang, F., Paulo, R., Molina, G., Clyde, M. and Berger, J.O.
(2008) Mixtures of g-priors for Bayesian Variable Selection. Journal of the
American Statistical Association. 103:410-423.  <br />
<a href="https://doi.org/10.1198/016214507000001337">doi:10.1198/016214507000001337</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas">bas</a></code>, <code><a href="#topic+update">update</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)
data(UScrime)
UScrime[,-2] = log(UScrime[,-2])
# EB local uses a different g within each model
crime.EBL =  bas.lm(y ~ ., data=UScrime, n.models=2^15,
                    prior="EB-local", initprobs= "eplogp")
# use a common (global) estimate of g
crime.EBG = EB.global(crime.EBL)


</code></pre>

<hr>
<h2 id='EB.local'>Empirical Bayes Prior Distribution for Coefficients in BMA Model</h2><span id='topic+EB.local'></span><span id='topic+EB'></span>

<h3>Description</h3>

<p>Creates an object representing the EB prior for BAS GLM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EB.local()
</code></pre>


<h3>Details</h3>

<p>Creates a structure used for <code><a href="#topic+bas.glm">bas.glm</a></code>.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyerparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CCH">CCH</a></code> and <code><a href="#topic+bas.glm">bas.glm</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+CCH">CCH</a>()</code>,
<code><a href="#topic+IC.prior">IC.prior</a>()</code>,
<code><a href="#topic+Jeffreys">Jeffreys</a>()</code>,
<code><a href="#topic+TG">TG</a>()</code>,
<code><a href="#topic+beta.prime">beta.prime</a>()</code>,
<code><a href="#topic+g.prior">g.prior</a>()</code>,
<code><a href="#topic+hyper.g">hyper.g</a>()</code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a>()</code>,
<code><a href="#topic+intrinsic">intrinsic</a>()</code>,
<code><a href="#topic+robust">robust</a>()</code>,
<code><a href="#topic+tCCH">tCCH</a>()</code>,
<code><a href="#topic+testBF.prior">testBF.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EB.local()
</code></pre>

<hr>
<h2 id='eplogprob'>eplogprob - Compute approximate marginal inclusion probabilities from
pvalues</h2><span id='topic+eplogprob'></span>

<h3>Description</h3>

<p><code>eplogprob</code> calculates approximate marginal posterior inclusion
probabilities from p-values computed from a linear model using a lower bound
approximation to Bayes factors.  Used to obtain initial inclusion
probabilities for sampling using Bayesian Adaptive Sampling <code>bas.lm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eplogprob(lm.obj, thresh = 0.5, max = 0.99, int = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eplogprob_+3A_lm.obj">lm.obj</code></td>
<td>
<p>a linear model object</p>
</td></tr>
<tr><td><code id="eplogprob_+3A_thresh">thresh</code></td>
<td>
<p>the value of the inclusion probability when if the p-value &gt;
1/exp(1), where the lower bound approximation is not valid.</p>
</td></tr>
<tr><td><code id="eplogprob_+3A_max">max</code></td>
<td>
<p>maximum value of the inclusion probability; used for the
<code>bas.lm</code> function to keep initial inclusion probabilities away from 1.</p>
</td></tr>
<tr><td><code id="eplogprob_+3A_int">int</code></td>
<td>
<p>If the Intercept is included in the linear model, set the
marginal inclusion probability corresponding to the intercept to 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sellke, Bayarri and Berger (2001) provide a simple calibration of p-values
</p>
<p>BF(p) = -e p log(p)
</p>
<p>which provide a lower bound to a Bayes factor for comparing H0: beta = 0
versus H1: beta not equal to 0, when the p-value p is less than 1/e.  Using
equal prior odds on the hypotheses H0 and H1, the approximate marginal
posterior inclusion probability
</p>
<p>p(beta != 0 | data ) = 1/(1 + BF(p))
</p>
<p>When p &gt; 1/e, we set the marginal inclusion probability to 0.5 or the value
given by <code>thresh</code>.
</p>


<h3>Value</h3>

<p><code>eplogprob</code> returns a vector of marginal posterior inclusion
probabilities for each of the variables in the linear model. If int = TRUE,
then the inclusion probability for the intercept is set to 1.  If the model
is not full rank, variables that are linearly dependent base on the QR
factorization will have NA for their p-values.  In bas.lm, where the
probabilities are used for sampling, the inclusion probability is set to 0.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@stat.duke.edu">clyde@stat.duke.edu</a>
</p>


<h3>References</h3>

<p>Sellke, Thomas, Bayarri, M. J., and Berger, James O.  (2001),
&ldquo;Calibration of p-values for testing precise null hypotheses&rdquo;, The
American Statistician, 55, 62-71.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas">bas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)
data(UScrime)
UScrime[,-2] = log(UScrime[,-2])
eplogprob(lm(y ~ ., data=UScrime))


</code></pre>

<hr>
<h2 id='eplogprob.marg'>eplogprob.marg - Compute approximate marginal inclusion probabilities from
pvalues</h2><span id='topic+eplogprob.marg'></span>

<h3>Description</h3>

<p><code>eplogprob.marg</code> calculates approximate marginal posterior inclusion
probabilities from p-values computed from a series of simple linear
regression models using a lower bound approximation to Bayes factors.  Used
to order variables and if appropriate obtain initial inclusion probabilities
for sampling using Bayesian Adaptive Sampling <code>bas.lm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eplogprob.marg(Y, X, thresh = 0.5, max = 0.99, int = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eplogprob.marg_+3A_y">Y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="eplogprob.marg_+3A_x">X</code></td>
<td>
<p>design matrix with a column of ones for the intercept</p>
</td></tr>
<tr><td><code id="eplogprob.marg_+3A_thresh">thresh</code></td>
<td>
<p>the value of the inclusion probability when if the p-value &gt;
1/exp(1), where the lower bound approximation is not valid.</p>
</td></tr>
<tr><td><code id="eplogprob.marg_+3A_max">max</code></td>
<td>
<p>maximum value of the inclusion probability; used for the
<code>bas.lm</code> function to keep initial inclusion probabilities away from 1.</p>
</td></tr>
<tr><td><code id="eplogprob.marg_+3A_int">int</code></td>
<td>
<p>If the Intercept is included in the linear model, set the
marginal inclusion probability corresponding to the intercept to 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sellke, Bayarri and Berger (2001) provide a simple calibration of p-values
</p>
<p>BF(p) = -e p log(p)
</p>
<p>which provide a lower bound to a Bayes factor for comparing H0: beta = 0
versus H1: beta not equal to 0, when the p-value p is less than 1/e.  Using
equal prior odds on the hypotheses H0 and H1, the approximate marginal
posterior inclusion probability
</p>
<p>p(beta != 0 | data ) = 1/(1 + BF(p))
</p>
<p>When p &gt; 1/e, we set the marginal inclusion probability to 0.5 or the value
given by <code>thresh</code>. For the eplogprob.marg the marginal p-values are
obtained using statistics from the p simple linear regressions
</p>
<p>P(F &gt; (n-2) R2/(1 - R2)) where F ~ F(1, n-2) where R2 is the square of the
correlation coefficient between y and X_j.
</p>


<h3>Value</h3>

<p><code>eplogprob.prob</code> returns a vector of marginal posterior
inclusion probabilities for each of the variables in the linear model. If
int = TRUE, then the inclusion probability for the intercept is set to 1.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@stat.duke.edu">clyde@stat.duke.edu</a>
</p>


<h3>References</h3>

<p>Sellke, Thomas, Bayarri, M. J., and Berger, James O.  (2001),
&ldquo;Calibration of p-values for testing precise null hypotheses&rdquo;, The
American Statistician, 55, 62-71.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas">bas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)
data(UScrime)
UScrime[,-2] = log(UScrime[,-2])
eplogprob(lm(y ~ ., data=UScrime))
</code></pre>

<hr>
<h2 id='fitted.bas'>Fitted values for a BAS BMA objects</h2><span id='topic+fitted.bas'></span><span id='topic+fitted'></span>

<h3>Description</h3>

<p>Calculate fitted values for a BAS BMA object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bas'
fitted(
  object,
  type = "link",
  estimator = "BMA",
  top = NULL,
  na.action = na.pass,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.bas_+3A_object">object</code></td>
<td>
<p>An object of class 'bas' as created by <code><a href="#topic+bas">bas</a></code></p>
</td></tr>
<tr><td><code id="fitted.bas_+3A_type">type</code></td>
<td>
<p>type equals &quot;response&quot; or &quot;link&quot; in the case of GLMs (default is 'link')</p>
</td></tr>
<tr><td><code id="fitted.bas_+3A_estimator">estimator</code></td>
<td>
<p>estimator type of fitted value to return. Default is to use
BMA with all models. Options include <br /> 'HPM' the highest probability model
<br /> 'BMA' Bayesian model averaging, using optionally only the 'top' models
<br /> 'MPM' the median probability model of Barbieri and Berger.  'BPM' the
model that is closest to BMA predictions under squared error loss</p>
</td></tr>
<tr><td><code id="fitted.bas_+3A_top">top</code></td>
<td>
<p>optional argument specifying that the 'top' models will be used
in constructing the BMA prediction, if NULL all models will be used.  If
top=1, then this is equivalent to 'HPM'</p>
</td></tr>
<tr><td><code id="fitted.bas_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values in newdata. The default is to predict NA.</p>
</td></tr>
<tr><td><code id="fitted.bas_+3A_...">...</code></td>
<td>
<p>optional arguments, not used currently</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates fitted values at observed design matrix using either the highest
probability model, 'HPM', the posterior mean (under BMA) 'BMA', the median
probability model 'MPM' or the best predictive model 'BPM&quot;.  The median
probability model is defined by including variable where the marginal
inclusion probability is greater than or equal to 1/2. For type=&quot;BMA&quot;, the
weighted average may be based on using a subset of the highest probability
models if an optional argument is given for top.  By default BMA uses all
sampled models, which may take a while to compute if the number of variables
or number of models is large.  The &quot;BPM&quot; is found be computing the squared
distance of the vector of fitted values for a model and the fitted values
under BMA and returns the model with the smallest distance.  In the presence
of multicollinearity this may be quite different from the MPM, with extreme
collinearity may drop relevant predictors.
</p>


<h3>Value</h3>

<p>A vector of length n of fitted values.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@duke.edu">clyde@duke.edu</a>
</p>


<h3>References</h3>

<p>Barbieri, M.  and Berger, J.O. (2004) Optimal predictive model
selection. Annals of Statistics. 32, 870-897. <br />
<a href="https://projecteuclid.org/euclid.aos/1085408489&amp;url=/UI/1.0/Summarize/euclid.aos/1085408489">https://projecteuclid.org/euclid.aos/1085408489&amp;url=/UI/1.0/Summarize/euclid.aos/1085408489</a>
</p>
<p>Clyde, M. Ghosh, J. and Littman, M. (2010) Bayesian Adaptive Sampling for
Variable Selection and Model Averaging. Journal of Computational Graphics
and Statistics.  20:80-101 <br />
<a href="https://doi.org/10.1198/jcgs.2010.09049">doi:10.1198/jcgs.2010.09049</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.bas">predict.bas</a></code>  <code><a href="#topic+predict.basglm">predict.basglm</a></code>
</p>
<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>
<p>Other predict methods: 
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Hald)
hald.gprior =  bas.lm(Y~ ., data=Hald, prior="ZS-null", initprobs="Uniform")
plot(Hald$Y, fitted(hald.gprior, estimator="HPM"))
plot(Hald$Y, fitted(hald.gprior, estimator="BMA", top=3))
plot(Hald$Y, fitted(hald.gprior, estimator="MPM"))
plot(Hald$Y, fitted(hald.gprior, estimator="BPM"))

</code></pre>

<hr>
<h2 id='force.heredity.bas'>Post processing function to force constraints on interaction inclusion bas BMA objects</h2><span id='topic+force.heredity.bas'></span>

<h3>Description</h3>

<p>This function takes the output of a bas object and allows higher
order interactions to be included only if their parent
lower order interactions terms are in the model, by
assigning zero prior probability, and hence posterior
probability, to models that do not include their respective
parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force.heredity.bas(object, prior.prob = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="force.heredity.bas_+3A_object">object</code></td>
<td>
<p>a bas linear model or generalized linear model object</p>
</td></tr>
<tr><td><code id="force.heredity.bas_+3A_prior.prob">prior.prob</code></td>
<td>
<p>prior probability that a term is included conditional on parents being included</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a bas object with updated models, coefficients and summaries obtained removing all models with   zero prior and posterior probabilities.
</p>


<h3>Note</h3>

<p>Currently prior probabilities are computed using conditional Bernoulli distributions, i.e.  P(gamma_j = 1 | Parents(gamma_j) = 1) = prior.prob.  This is not very efficient for models with a large number of levels.  Future updates will force this at the time of sampling.
</p>


<h3>Author(s)</h3>

<p>Merlise A Clyde
</p>


<h3>See Also</h3>

<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("chickwts")
bas.chk &lt;- bas.lm(weight ~ feed, data = chickwts)
#  summary(bas.chk)  # 2^5 = 32 models
bas.chk.int &lt;- force.heredity.bas(bas.chk)
#  summary(bas.chk.int)  # two models now


data(Hald)
bas.hald &lt;- bas.lm(Y ~ .^2, data = Hald)
bas.hald.int &lt;- force.heredity.bas(bas.hald)
image(bas.hald.int)

image(bas.hald.int)

# two-way interactions
data(ToothGrowth)
ToothGrowth$dose &lt;- factor(ToothGrowth$dose)
levels(ToothGrowth$dose) &lt;- c("Low", "Medium", "High")
TG.bas &lt;- bas.lm(len ~ supp * dose, data = ToothGrowth, modelprior = uniform())
TG.bas.int &lt;- force.heredity.bas(TG.bas)
image(TG.bas.int)
</code></pre>

<hr>
<h2 id='g.prior'>Families of G-Prior Distribution for Coefficients in BMA Models</h2><span id='topic+g.prior'></span>

<h3>Description</h3>

<p>Creates an object representing the g-prior distribution on coefficients for
BAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.prior(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="g.prior_+3A_g">g</code></td>
<td>
<p>a scalar used in the covariance of Zellner's g-prior, Cov(beta) =
sigma^2 g (X'X)^-1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a structure used for BAS.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyerparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IC.prior">IC.prior</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+CCH">CCH</a>()</code>,
<code><a href="#topic+EB.local">EB.local</a>()</code>,
<code><a href="#topic+IC.prior">IC.prior</a>()</code>,
<code><a href="#topic+Jeffreys">Jeffreys</a>()</code>,
<code><a href="#topic+TG">TG</a>()</code>,
<code><a href="#topic+beta.prime">beta.prime</a>()</code>,
<code><a href="#topic+hyper.g">hyper.g</a>()</code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a>()</code>,
<code><a href="#topic+intrinsic">intrinsic</a>()</code>,
<code><a href="#topic+robust">robust</a>()</code>,
<code><a href="#topic+tCCH">tCCH</a>()</code>,
<code><a href="#topic+testBF.prior">testBF.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g.prior(100)
</code></pre>

<hr>
<h2 id='Hald'>Hald Data</h2><span id='topic+Hald'></span><span id='topic+hald'></span>

<h3>Description</h3>

<p>The Hald data have been used in many books and papers to illustrate variable
selection. The data relate to an engineering application that was concerned
with the effect of the composition of cement on heat evolved during
hardening. The response variable <em>Y</em> is the <em>heat evolved</em> in a
cement mix. The four explanatory variables are ingredients of the mix, X1:
<em>tricalcium aluminate</em>, X2: <em>tricalcium silicate</em>, X3:
<em>tetracalcium alumino ferrite</em>, X4: <em>dicalcium silicate</em>. An
important feature of these data is that the variables X1 and X3 are highly
correlated, as well as the variables X2 and X4.  Thus we should expect any
subset of (X1,X2,X3,X4) that includes one variable from highly correlated
pair to do as any subset that also includes the other member.
</p>


<h3>Format</h3>

<p><code>hald</code> is a dataframe with 13 observations and 5 variables
(columns),
</p>
<p>Y: Heat evolved per gram of cement (in calories) X1: Amount of tricalcium
aluminate X2: Amount of tricalcium silicate X3: Amount of tetracalcium
alumino ferrite X4: Amount of dicalcium silicate
</p>


<h3>Source</h3>

<p>Wood, H., Steinour, H.H., and Starke, H.R. (1932). &quot;Effect of
Composition of Portland cement on Heat Evolved During Hardening&quot;, Industrial
and Engineering Chemistry, 24, 1207-1214.
</p>

<hr>
<h2 id='hyper.g'>Hyper-g-Prior Distribution for Coefficients in BMA Models</h2><span id='topic+hyper.g'></span>

<h3>Description</h3>

<p>Creates an object representing the hyper-g mixture of g-priors on
coefficients for BAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper.g(alpha = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyper.g_+3A_alpha">alpha</code></td>
<td>
<p>a scalar &gt; 0. The hyper.g(alpha) is equivalent to CCH(alpha -2,
2, 0). Liang et al recommended values in the range 2 &lt; alpha_h &lt;= 3</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a structure used for <code><a href="#topic+bas.glm">bas.glm</a></code>.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyerparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CCH">CCH</a></code> <code><a href="#topic+bas.glm">bas.glm</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+CCH">CCH</a>()</code>,
<code><a href="#topic+EB.local">EB.local</a>()</code>,
<code><a href="#topic+IC.prior">IC.prior</a>()</code>,
<code><a href="#topic+Jeffreys">Jeffreys</a>()</code>,
<code><a href="#topic+TG">TG</a>()</code>,
<code><a href="#topic+beta.prime">beta.prime</a>()</code>,
<code><a href="#topic+g.prior">g.prior</a>()</code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a>()</code>,
<code><a href="#topic+intrinsic">intrinsic</a>()</code>,
<code><a href="#topic+robust">robust</a>()</code>,
<code><a href="#topic+tCCH">tCCH</a>()</code>,
<code><a href="#topic+testBF.prior">testBF.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hyper.g(alpha = 3)
</code></pre>

<hr>
<h2 id='hyper.g.n'>Generalized hyper-g/n Prior Distribution for g for mixtures of g-priors on
Coefficients in BMA Models</h2><span id='topic+hyper.g.n'></span>

<h3>Description</h3>

<p>Creates an object representing the hyper-g/n mixture of g-priors on
coefficients for BAS. This is a special case of the tCCH prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper.g.n(alpha = 3, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyper.g.n_+3A_alpha">alpha</code></td>
<td>
<p>a scalar &gt; 0, recommended 2 &lt; alpha &lt;= 3</p>
</td></tr>
<tr><td><code id="hyper.g.n_+3A_n">n</code></td>
<td>
<p>The sample size; if NULL, the value derived from the data in the
call to 'bas.glm' will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a structure used for <code><a href="#topic+bas.glm">bas.glm</a></code>.  This is a special case
of the <code><a href="#topic+tCCH">tCCH</a></code>, where <code>hyper.g.n(alpha=3, n)</code> is equivalent
to <code> tCCH(alpha=1, beta=2, s=0, r=1.5, v = 1, theta=1/n) </code>
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyerparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tCCH">tCCH</a></code>, <code><a href="#topic+robust">robust</a></code>, <code><a href="#topic+hyper.g">hyper.g</a></code>,
<code><a href="#topic+CCH">CCH</a></code><code><a href="#topic+bas.glm">bas.glm</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+CCH">CCH</a>()</code>,
<code><a href="#topic+EB.local">EB.local</a>()</code>,
<code><a href="#topic+IC.prior">IC.prior</a>()</code>,
<code><a href="#topic+Jeffreys">Jeffreys</a>()</code>,
<code><a href="#topic+TG">TG</a>()</code>,
<code><a href="#topic+beta.prime">beta.prime</a>()</code>,
<code><a href="#topic+g.prior">g.prior</a>()</code>,
<code><a href="#topic+hyper.g">hyper.g</a>()</code>,
<code><a href="#topic+intrinsic">intrinsic</a>()</code>,
<code><a href="#topic+robust">robust</a>()</code>,
<code><a href="#topic+tCCH">tCCH</a>()</code>,
<code><a href="#topic+testBF.prior">testBF.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
hyper.g.n(alpha = 3, n = n)
</code></pre>

<hr>
<h2 id='hypergeometric1F1'>Confluent hypergeometric1F1 function</h2><span id='topic+hypergeometric1F1'></span>

<h3>Description</h3>

<p>Compute the Confluent Hypergeometric function: 1F1(a,b,c,t) =
Gamma(b)/(Gamma(b-a)Gamma(a)) Int_0^1 t^(a-1) (1 - t)^(b-a-1) exp(c t) dt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergeometric1F1(a, b, c, laplace = FALSE, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hypergeometric1F1_+3A_a">a</code></td>
<td>
<p>arbitrary</p>
</td></tr>
<tr><td><code id="hypergeometric1F1_+3A_b">b</code></td>
<td>
<p>Must be greater 0</p>
</td></tr>
<tr><td><code id="hypergeometric1F1_+3A_c">c</code></td>
<td>
<p>arbitrary</p>
</td></tr>
<tr><td><code id="hypergeometric1F1_+3A_laplace">laplace</code></td>
<td>
<p>The default is to use the Cephes library; for large a or s
this may return an NA, Inf or negative values,, in which case you should use
the Laplace approximation.</p>
</td></tr>
<tr><td><code id="hypergeometric1F1_+3A_log">log</code></td>
<td>
<p>if TRUE, return log(1F1)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Merlise Clyde (<a href="mailto:clyde@stat.duke.edu">clyde@stat.duke.edu</a>)
</p>


<h3>References</h3>

<p>Cephes library hyp1f1.c
</p>


<h3>See Also</h3>

<p>Other special functions: 
<code><a href="#topic+hypergeometric2F1">hypergeometric2F1</a>()</code>,
<code><a href="#topic+phi1">phi1</a>()</code>,
<code><a href="#topic+trCCH">trCCH</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hypergeometric1F1(11.14756, 0.5, 0.00175097)


</code></pre>

<hr>
<h2 id='hypergeometric2F1'>Gaussian hypergeometric2F1 function</h2><span id='topic+hypergeometric2F1'></span>

<h3>Description</h3>

<p>Compute the Gaussian Hypergeometric2F1 function: 2F1(a,b,c,z) = Gamma(b-c)
Int_0^1 t^(b-1) (1 - t)^(c -b -1) (1 - t z)^(-a) dt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergeometric2F1(a, b, c, z, method = "Cephes", log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hypergeometric2F1_+3A_a">a</code></td>
<td>
<p>arbitrary</p>
</td></tr>
<tr><td><code id="hypergeometric2F1_+3A_b">b</code></td>
<td>
<p>Must be greater 0</p>
</td></tr>
<tr><td><code id="hypergeometric2F1_+3A_c">c</code></td>
<td>
<p>Must be greater than b if |z| &lt; 1, and c &gt; b + a if z = 1</p>
</td></tr>
<tr><td><code id="hypergeometric2F1_+3A_z">z</code></td>
<td>
<p>|z| &lt;= 1</p>
</td></tr>
<tr><td><code id="hypergeometric2F1_+3A_method">method</code></td>
<td>
<p>The default is to use the Cephes library routine.  This
sometimes is unstable for large a or z near one returning Inf or negative
values.  In this case, try method=&quot;Laplace&quot;, which use a Laplace
approximation for tau = exp(t/(1-t)).</p>
</td></tr>
<tr><td><code id="hypergeometric2F1_+3A_log">log</code></td>
<td>
<p>if TRUE, return log(2F1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default is to use the routine hyp2f1.c from the Cephes library.  If that
return a negative value or Inf, one should try method=&quot;Laplace&quot; which is
based on the Laplace approximation as described in Liang et al JASA 2008.
This is used in the hyper-g prior to calculate marginal likelihoods.
</p>


<h3>Value</h3>

<p>if log=T returns the log of the 2F1 function; otherwise the 2F1
function.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde (<a href="mailto:clyde@duke.edu">clyde@duke.edu</a>)
</p>


<h3>References</h3>

<p>Cephes library hyp2f1.c
</p>
<p>Liang, F., Paulo, R., Molina, G., Clyde, M. and Berger, J.O. (2005) Mixtures
of g-priors for Bayesian Variable Selection.  Journal of the American
Statistical Association.  103:410-423.  <br />
<a href="https://doi.org/10.1198/016214507000001337">doi:10.1198/016214507000001337</a>
</p>


<h3>See Also</h3>

<p>Other special functions: 
<code><a href="#topic+hypergeometric1F1">hypergeometric1F1</a>()</code>,
<code><a href="#topic+phi1">phi1</a>()</code>,
<code><a href="#topic+trCCH">trCCH</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hypergeometric2F1(12, 1, 2, .65)
</code></pre>

<hr>
<h2 id='IC.prior'>Information Criterion Families of Prior Distribution for Coefficients in BMA
Models</h2><span id='topic+IC.prior'></span><span id='topic+aic.prior'></span><span id='topic+AIC.prior'></span><span id='topic+bic.prior'></span><span id='topic+BIC.prior'></span>

<h3>Description</h3>

<p>Creates an object representing the prior distribution on coefficients for
BAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC.prior(penalty)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IC.prior_+3A_penalty">penalty</code></td>
<td>
<p>a scalar used in the penalized loglikelihood of the form
penalty*dimension</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log marginal likelihood is approximated as -2*(deviance +
penalty*dimension).  Allows alternatives to AIC (penalty = 2) and BIC
(penalty = log(n)).  For BIC, the argument may be missing, in which case the
sample size is determined from the call to 'bas.glm' and used to determine
the penalty.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyerparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+g.prior">g.prior</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+CCH">CCH</a>()</code>,
<code><a href="#topic+EB.local">EB.local</a>()</code>,
<code><a href="#topic+Jeffreys">Jeffreys</a>()</code>,
<code><a href="#topic+TG">TG</a>()</code>,
<code><a href="#topic+beta.prime">beta.prime</a>()</code>,
<code><a href="#topic+g.prior">g.prior</a>()</code>,
<code><a href="#topic+hyper.g">hyper.g</a>()</code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a>()</code>,
<code><a href="#topic+intrinsic">intrinsic</a>()</code>,
<code><a href="#topic+robust">robust</a>()</code>,
<code><a href="#topic+tCCH">tCCH</a>()</code>,
<code><a href="#topic+testBF.prior">testBF.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>IC.prior(2)
aic.prior()
bic.prior(100)
</code></pre>

<hr>
<h2 id='image.bas'>Images of models used in Bayesian model averaging</h2><span id='topic+image.bas'></span><span id='topic+image'></span>

<h3>Description</h3>

<p>Creates an image of the models selected using <code><a href="#topic+bas">bas</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bas'
image(
  x,
  top.models = 20,
  intensity = TRUE,
  prob = TRUE,
  log = TRUE,
  rotate = TRUE,
  color = "rainbow",
  subset = NULL,
  drop.always.included = FALSE,
  offset = 0.75,
  digits = 3,
  vlas = 2,
  plas = 0,
  rlas = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image.bas_+3A_x">x</code></td>
<td>
<p>A BMA object of type 'bas' created by BAS</p>
</td></tr>
<tr><td><code id="image.bas_+3A_top.models">top.models</code></td>
<td>
<p>Number of the top ranked models to plot</p>
</td></tr>
<tr><td><code id="image.bas_+3A_intensity">intensity</code></td>
<td>
<p>Logical variable, when TRUE image intensity is proportional
to the probability or log(probability) of the model, when FALSE, intensity
is binary indicating just presence (light) or absence (dark) of a variable.</p>
</td></tr>
<tr><td><code id="image.bas_+3A_prob">prob</code></td>
<td>
<p>Logical variable for whether the area in the image for each
model should be proportional to the posterior probability (or log
probability) of the model (TRUE) or with equal area (FALSE).</p>
</td></tr>
<tr><td><code id="image.bas_+3A_log">log</code></td>
<td>
<p>Logical variable indicating whether the intensities should be
based on log posterior odds (TRUE) or posterior probabilities (FALSE).  The
log of the posterior odds is for comparing the each model to the worst model
in the top.models.</p>
</td></tr>
<tr><td><code id="image.bas_+3A_rotate">rotate</code></td>
<td>
<p>Should the image of models be rotated so that models are on
the y-axis and variables are on the x-axis (TRUE)</p>
</td></tr>
<tr><td><code id="image.bas_+3A_color">color</code></td>
<td>
<p>The color scheme for image intensities. The value &quot;rainbow&quot;
uses the rainbow palette. The value &quot;blackandwhite&quot; produces a black and
white image (greyscale image)</p>
</td></tr>
<tr><td><code id="image.bas_+3A_subset">subset</code></td>
<td>
<p>indices of variables to include/exclude in plot</p>
</td></tr>
<tr><td><code id="image.bas_+3A_drop.always.included">drop.always.included</code></td>
<td>
<p>logical variable to drop variables that are
always forced into the model.  FALSE by default.</p>
</td></tr>
<tr><td><code id="image.bas_+3A_offset">offset</code></td>
<td>
<p>numeric value to add to intensity</p>
</td></tr>
<tr><td><code id="image.bas_+3A_digits">digits</code></td>
<td>
<p>number of digits in posterior probabilities to keep</p>
</td></tr>
<tr><td><code id="image.bas_+3A_vlas">vlas</code></td>
<td>
<p>las parameter for placing variable names; see par</p>
</td></tr>
<tr><td><code id="image.bas_+3A_plas">plas</code></td>
<td>
<p>las parameter for posterior probability axis</p>
</td></tr>
<tr><td><code id="image.bas_+3A_rlas">rlas</code></td>
<td>
<p>las parameter for model ranks</p>
</td></tr>
<tr><td><code id="image.bas_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to the <code>image</code> and <code>axis</code>
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates an image of the model space sampled using <code><a href="#topic+bas">bas</a></code>.  If a
subset of the top models are plotted, then probabilities are renormalized
over the subset.
</p>


<h3>Note</h3>

<p>Suggestion to allow area of models be proportional to posterior
probability due to Thomas Lumley
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@stat.duke.edu">clyde@stat.duke.edu</a>
</p>


<h3>References</h3>

<p>Clyde, M. (1999) Bayesian Model Averaging and Model Search
Strategies (with discussion). In Bayesian Statistics 6. J.M. Bernardo, A.P.
Dawid, J.O. Berger, and A.F.M. Smith eds. Oxford University Press, pages
157-185.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas">bas</a></code>
</p>
<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>
<p>Other bas plots: 
<code><a href="#topic+plot.bas">plot.bas</a>()</code>,
<code><a href="#topic+plot.coef.bas">plot.coef.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(graphics)
data("Hald")
hald.ZSprior &lt;- bas.lm(Y ~ ., data = Hald, prior = "ZS-null")
image(hald.ZSprior, drop.always.included = TRUE) # drop the intercept
</code></pre>

<hr>
<h2 id='intrinsic'>Intrinsic Prior Distribution for Coefficients in BMA Models</h2><span id='topic+intrinsic'></span>

<h3>Description</h3>

<p>Creates an object representing the intrinsic prior on g, a special case of
the tCCH mixture of g-priors on coefficients for BAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intrinsic(n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intrinsic_+3A_n">n</code></td>
<td>
<p>the sample size; if NULL, the value derived from the data in the
call to 'bas.glm' will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a structure used for <code><a href="#topic+bas.glm">bas.glm</a></code>.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family &quot;intrinsic&quot; of
class &quot;TCCH&quot; and hyperparameters alpha = 1, beta = 1, s = 0, r = 1, n = n
for the tCCH prior where theta in the tCCH prior is determined by the model
size and sample size.
</p>


<h3>Author(s)</h3>

<p>Merlise A Clyde
</p>


<h3>References</h3>

<p>Womack, A., Novelo,L.L., Casella, G. (2014). &quot;Inference From
Intrinsic Bayes' Procedures Under Model Selection and Uncertainty&quot;. Journal
of the American Statistical Association.  109:1040-1053.
<a href="https://doi.org/10.1080/01621459.2014.880348">doi:10.1080/01621459.2014.880348</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tCCH">tCCH</a></code>, <code><a href="#topic+robust">robust</a></code>, <code><a href="#topic+hyper.g">hyper.g</a></code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a></code><code><a href="#topic+bas.glm">bas.glm</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+CCH">CCH</a>()</code>,
<code><a href="#topic+EB.local">EB.local</a>()</code>,
<code><a href="#topic+IC.prior">IC.prior</a>()</code>,
<code><a href="#topic+Jeffreys">Jeffreys</a>()</code>,
<code><a href="#topic+TG">TG</a>()</code>,
<code><a href="#topic+beta.prime">beta.prime</a>()</code>,
<code><a href="#topic+g.prior">g.prior</a>()</code>,
<code><a href="#topic+hyper.g">hyper.g</a>()</code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a>()</code>,
<code><a href="#topic+robust">robust</a>()</code>,
<code><a href="#topic+tCCH">tCCH</a>()</code>,
<code><a href="#topic+testBF.prior">testBF.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tCCH(alpha = 1, beta = 2, s = 0, r = 1.5, v = 1, theta = 1 / n)
</code></pre>

<hr>
<h2 id='Jeffreys'>Jeffreys Prior Distribution for $g$ for Mixtures of g-Priors for
Coefficients in BMA Models</h2><span id='topic+Jeffreys'></span>

<h3>Description</h3>

<p>Creates an object representing the Jeffrey's Prior on g mixture of g-priors
on coefficients for BAS. This is equivalent to a limiting version of the
CCH(a, 2, 0) with a = 0 or they hyper-g(a = 2) and is an improper prior.  As
$g$ does not appear in the Null Model, Bayes Factors and model probabilities
are not well-defined because of arbitrary normalizing constants, and for
this reason the null model is excluded and the same constants are used
across other models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jeffreys()
</code></pre>


<h3>Details</h3>

<p>Creates a structure used for <code><a href="#topic+bas.glm">bas.glm</a></code>.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyerparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CCH">CCH</a></code> <code><a href="#topic+bas.glm">bas.glm</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+CCH">CCH</a>()</code>,
<code><a href="#topic+EB.local">EB.local</a>()</code>,
<code><a href="#topic+IC.prior">IC.prior</a>()</code>,
<code><a href="#topic+TG">TG</a>()</code>,
<code><a href="#topic+beta.prime">beta.prime</a>()</code>,
<code><a href="#topic+g.prior">g.prior</a>()</code>,
<code><a href="#topic+hyper.g">hyper.g</a>()</code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a>()</code>,
<code><a href="#topic+intrinsic">intrinsic</a>()</code>,
<code><a href="#topic+robust">robust</a>()</code>,
<code><a href="#topic+tCCH">tCCH</a>()</code>,
<code><a href="#topic+testBF.prior">testBF.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Jeffreys()
</code></pre>

<hr>
<h2 id='list2matrix.bas'>Coerce a BAS list object into a matrix.</h2><span id='topic+list2matrix.bas'></span><span id='topic+list2matrix'></span>

<h3>Description</h3>

<p>Models, coefficients, and standard errors in objects of class 'bas' are
represented as a list of lists to reduce storage by omitting the zero
entries.  These functions coerce the list object to a matrix and fill in the
zeros to facilitate other computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2matrix.bas(x, what, which.models = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list2matrix.bas_+3A_x">x</code></td>
<td>
<p>a 'bas' object</p>
</td></tr>
<tr><td><code id="list2matrix.bas_+3A_what">what</code></td>
<td>
<p>name of bas list to coerce</p>
</td></tr>
<tr><td><code id="list2matrix.bas_+3A_which.models">which.models</code></td>
<td>
<p>a vector of indices use to extract a subset</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>list2matrix.bas(x, which)</code> is equivalent to
<code>list2matrix.which(x)</code>, however, the latter uses sapply rather than a
loop.
<code>list2matrix.which</code> and <code>which.matrix</code> both coerce
<code>x$which</code> into a matrix.
</p>


<h3>Value</h3>

<p>a matrix representation of <code>x$what</code>, with number of rows equal
to the length of which.models or total number of models and number of
columns <code>x$n.vars</code>
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@duke.edu">clyde@duke.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas">bas</a></code>
</p>
<p>Other as.matrix methods: 
<code><a href="#topic+list2matrix.which">list2matrix.which</a>()</code>,
<code><a href="#topic+which.matrix">which.matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Hald)
hald.bic &lt;-  bas.lm(Y ~ ., data=Hald, prior="BIC",
                    initprobs= "eplogp")
coef &lt;- list2matrix.bas(hald.bic, "mle")  # extract all coefficients
se &lt;- list2matrix.bas(hald.bic, "mle.se")
models &lt;- list2matrix.which(hald.bic)     #matrix of model indicators
models &lt;- which.matrix(hald.bic$which, hald.bic$n.vars)     #matrix of model indicators

</code></pre>

<hr>
<h2 id='list2matrix.which'>Coerce a BAS list object into a matrix.</h2><span id='topic+list2matrix.which'></span>

<h3>Description</h3>

<p>Models, coefficients, and standard errors in objects of class 'bas' are
represented as a list of lists to reduce storage by omitting the zero
entries.  These functions coerce the list object to a matrix and fill in the
zeros to facilitate other computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2matrix.which(x, which.models = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list2matrix.which_+3A_x">x</code></td>
<td>
<p>a 'bas' object</p>
</td></tr>
<tr><td><code id="list2matrix.which_+3A_which.models">which.models</code></td>
<td>
<p>a vector of indices use to extract a subset</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>list2matrix.bas(x, which)</code> is equivalent to
<code>list2matrix.which(x)</code>, however, the latter uses sapply rather than a
loop.
<code>list2matrix.which</code> and <code>which.matrix</code> both coerce
<code>x$which</code> into a matrix.
</p>


<h3>Value</h3>

<p>a matrix representation of <code>x$what</code>, with number of rows equal
to the length of which.models or total number of models and number of
columns <code>x$n.vars</code>
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@duke.edu">clyde@duke.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas">bas</a></code>
</p>
<p>Other as.matrix methods: 
<code><a href="#topic+list2matrix.bas">list2matrix.bas</a>()</code>,
<code><a href="#topic+which.matrix">which.matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Hald)
Hald.bic &lt;-  bas.lm(Y ~ ., data=Hald, prior="BIC", initprobs="eplogp")
coef &lt;- list2matrix.bas(Hald.bic, "mle")  # extract all ols coefficients
se &lt;- list2matrix.bas(Hald.bic, "mle.se")
models &lt;- list2matrix.which(Hald.bic)     #matrix of model indicators
models &lt;- which.matrix(Hald.bic$which, Hald.bic$n.vars)     #matrix of model indicators

</code></pre>

<hr>
<h2 id='phi1'>Compound Confluent hypergeometric function of two variables</h2><span id='topic+phi1'></span>

<h3>Description</h3>

<p>Compute the Confluent Hypergeometric function of two variables, also know as
a Horn hypergeometric function or Humbert's hypergeometric used in Gordy
(1998) with integral representation:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi1(a, b, c, x, y, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phi1_+3A_a">a</code></td>
<td>
<p>a &gt; 0</p>
</td></tr>
<tr><td><code id="phi1_+3A_b">b</code></td>
<td>
<p>arbitrary</p>
</td></tr>
<tr><td><code id="phi1_+3A_c">c</code></td>
<td>
<p>c &gt; 0</p>
</td></tr>
<tr><td><code id="phi1_+3A_x">x</code></td>
<td>
<p>x &gt; 0</p>
</td></tr>
<tr><td><code id="phi1_+3A_y">y</code></td>
<td>
<p>y &gt; 0</p>
</td></tr>
<tr><td><code id="phi1_+3A_log">log</code></td>
<td>
<p>logical indicating whether to return phi1 on the log scale</p>
</td></tr>
</table>


<h3>Details</h3>

<p>phi_1(a,b,c,x,y) =  [(Gamma(c)/Gamma(a) Gamma(a-c))] Int_0^1
t^(a-1) (1 - t)^(c-a-1) (1 - yt)^(-b) exp(x t) dt
<a href="https://en.wikipedia.org/wiki/Humbert_series">https://en.wikipedia.org/wiki/Humbert_series</a> Note that Gordy's
arguments for x and y are reversed in the reference above.
</p>
<p>The original 'phi1' function in 'BAS' was based on 'C' code provided by 
Gordy.  This function returns NA's 
when x is greater than 'log(.Machine$double.xmax)/2'.   A more 
stable method for calculating the &lsquo;phi1' function using R&rsquo;s 'integrate' 
was suggested by Daniel Heemann and is now an option whenever $x$ is too 
large.  For calculating Bayes factors that use the 'phi1' function we 
recommend using the 'log=TRUE' option to compute log Bayes factors.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde (<a href="mailto:clyde@duke.edu">clyde@duke.edu</a>)
</p>
<p>Daniel Heemann (<a href="mailto:df.heemann@gmail.com">df.heemann@gmail.com</a>)
</p>


<h3>References</h3>

<p>Gordy 1998
</p>


<h3>See Also</h3>

<p>Other special functions: 
<code><a href="#topic+hypergeometric1F1">hypergeometric1F1</a>()</code>,
<code><a href="#topic+hypergeometric2F1">hypergeometric2F1</a>()</code>,
<code><a href="#topic+trCCH">trCCH</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# special cases
# phi1(a, b, c, x=0, y) is the same as 2F1(b, a; c, y)
phi1(1, 2, 1.5, 0, 1 / 100, log=FALSE)
hypergeometric2F1(2, 1, 1.5, 1 / 100, log = FALSE)

# phi1(a,0,c,x,y) is the same as 1F1(a,c,x)
phi1(1, 0, 1.5, 3, 1 / 100)
hypergeometric1F1(1, 1.5, 3, log = FALSE)

# use direct integration
phi1(1, 2, 1.5, 1000, 0, log=TRUE)
</code></pre>

<hr>
<h2 id='plot.bas'>Plot Diagnostics for an BAS Object</h2><span id='topic+plot.bas'></span>

<h3>Description</h3>

<p>Four plots (selectable by 'which') are currently available: a plot of
residuals against fitted values, Cumulative Model Probabilities, log
marginal likelihoods versus model dimension, and marginal inclusion
probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bas'
plot(
  x,
  which = c(1:4),
  caption = c("Residuals vs Fitted", "Model Probabilities", "Model Complexity",
    "Inclusion Probabilities"),
  panel = if (add.smooth) panel.smooth else points,
  sub.caption = NULL,
  main = "",
  ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(),
  col.in = 2,
  col.ex = 1,
  col.pch = 1,
  cex.lab = 1,
  ...,
  id.n = 3,
  labels.id = NULL,
  cex.id = 0.75,
  add.smooth = getOption("add.smooth"),
  label.pos = c(4, 2),
  subset = NULL,
  drop.always.included = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bas_+3A_x">x</code></td>
<td>
<p><code>bas</code> BMA object result of 'bas'</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_which">which</code></td>
<td>
<p>if a subset of the plots is required, specify a subset of the
numbers '1:4'</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_caption">caption</code></td>
<td>
<p>captions to appear above the plots</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_panel">panel</code></td>
<td>
<p>panel function.  The useful alternative to 'points',
'panel.smooth' can be chosen by 'add.smooth = TRUE'</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_sub.caption">sub.caption</code></td>
<td>
<p>common title-above figures if there are multiple; used as
'sub' (s.'title') otherwise.  If 'NULL', as by default, a possible shortened
version of <code>deparse(x$call)</code> is used</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_main">main</code></td>
<td>
<p>title to each plot-in addition to the above 'caption'</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_ask">ask</code></td>
<td>
<p>logical; if 'TRUE', the user is asked before each plot, see
'par(ask=.)'</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_col.in">col.in</code></td>
<td>
<p>color for the included variables</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_col.ex">col.ex</code></td>
<td>
<p>color for the excluded variables</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_col.pch">col.pch</code></td>
<td>
<p>color for points in panels 1-3</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_cex.lab">cex.lab</code></td>
<td>
<p>graphics parameter to control size of variable names</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_id.n">id.n</code></td>
<td>
<p>number of points to be labeled in each plot, starting with the
most extreme</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_labels.id">labels.id</code></td>
<td>
<p>vector of labels, from which the labels for extreme points
will be chosen.  'NULL' uses observation numbers</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_cex.id">cex.id</code></td>
<td>
<p>magnification of point labels.</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_add.smooth">add.smooth</code></td>
<td>
<p>logical indicating if a smoother should be added to most
plots; see also 'panel' above</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_label.pos">label.pos</code></td>
<td>
<p>positioning of labels, for the left half and right half of
the graph respectively, for plots 1-4</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_subset">subset</code></td>
<td>
<p>indices of variables to include/exclude in plot of marginal posterior
inclusion probabilities (NULL).</p>
</td></tr>
<tr><td><code id="plot.bas_+3A_drop.always.included">drop.always.included</code></td>
<td>
<p>logical variable to drop marginal posterior inclusion
probabilities
for variables that are always forced into the model.  FALSE by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This provides a panel of 4 plots: the first is a plot of the residuals
versus fitted values under BMA. The second is a plot of the cumulative
marginal likelihoods of models; if the model space cannot be enumerated then
this provides some indication of whether the probabilities are leveling off.
The third is a plot of log marginal likelihood versus model dimension and
the fourth plot show the posterior marginal inclusion probabilities.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde, based on plot.lm by John Maindonald and Martin
Maechler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.coef.bas">plot.coef.bas</a></code> and <code><a href="#topic+image.bas">image.bas</a></code>.
</p>
<p>Other bas plots: 
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.coef.bas">plot.coef.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Hald)
hald.gprior =  bas.lm(Y~ ., data=Hald, prior="g-prior", alpha=13,
                      modelprior=beta.binomial(1,1),
                      initprobs="eplogp")

plot(hald.gprior)


</code></pre>

<hr>
<h2 id='plot.coef.bas'>Plots the posterior distributions of coefficients derived from Bayesian
model averaging</h2><span id='topic+plot.coef.bas'></span>

<h3>Description</h3>

<p>Displays plots of the posterior distributions of the coefficients generated
by Bayesian model averaging over linear regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coef.bas'
plot(x, e = 1e-04, subset = 1:x$n.vars, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.coef.bas_+3A_x">x</code></td>
<td>
<p>object of class coef.bas</p>
</td></tr>
<tr><td><code id="plot.coef.bas_+3A_e">e</code></td>
<td>
<p>optional numeric value specifying the range over which the
distributions are to be graphed.</p>
</td></tr>
<tr><td><code id="plot.coef.bas_+3A_subset">subset</code></td>
<td>
<p>optional numerical vector specifying which variables to graph
(including the intercept)</p>
</td></tr>
<tr><td><code id="plot.coef.bas_+3A_ask">ask</code></td>
<td>
<p>Prompt for next plot</p>
</td></tr>
<tr><td><code id="plot.coef.bas_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to <code>plot</code> and <code>lines</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces plots of the posterior distributions of the coefficients under
model averaging.  The posterior probability that the coefficient is zero is
represented by a solid line at zero, with height equal to the probability.
The nonzero part of the distribution is scaled so that the maximum height is
equal to the probability that the coefficient is nonzero.
</p>
<p>The parameter <code>e</code> specifies the range over which the distributions are
to be graphed by specifying the tail probabilities that dictate the range to
plot over.
</p>


<h3>Note</h3>

<p>For mixtures of g-priors, uncertainty in g is not incorporated at this
time, thus results are approximate
</p>


<h3>Author(s)</h3>

<p>based on function <code>plot.bic</code> by Ian Painter in package BMA;
adapted for 'bas' class by Merlise Clyde <a href="mailto:clyde@stat.duke.edu">clyde@stat.duke.edu</a>
</p>


<h3>References</h3>

<p>Hoeting, J.A., Raftery, A.E. and Madigan, D. (1996). A method
for simultaneous variable selection and outlier identification in linear
regression. Computational Statistics and Data Analysis, 22, 251-270.
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+coef.bas">coef.bas</a></code>
</p>
<p>Other bas plots: 
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.bas">plot.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: library(MASS)
data(UScrime)
UScrime[,-2] &lt;- log(UScrime[,-2])
crime_bic &lt;- bas.lm(y ~ ., data=UScrime, n.models=2^15, prior="BIC")
plot(coefficients(crime_bic), ask=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.confint.bas'>Plot Bayesian Confidence Intervals</h2><span id='topic+plot.confint.bas'></span>

<h3>Description</h3>

<p>Function takes the the output of functions that return credible intervals
from BAS objects, and creates a plot of the posterior mean with segments
representing the credible interval.  
of what the function does. ~~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'confint.bas'
plot(x, horizontal = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.confint.bas_+3A_x">x</code></td>
<td>
<p>the output from <code><a href="#topic+confint.coef.bas">confint.coef.bas</a></code> or
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a></code> containing credible intervals and estimates.</p>
</td></tr>
<tr><td><code id="plot.confint.bas_+3A_horizontal">horizontal</code></td>
<td>
<p>orientation of the plot</p>
</td></tr>
<tr><td><code id="plot.confint.bas_+3A_...">...</code></td>
<td>
<p>optional graphical arguments to pass on to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the HPD intervals or credible intervals created by
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a></code> or <code><a href="#topic+confint.pred.bas">confint.pred.bas</a></code> from BAS
objects, and creates a plot of the posterior mean with segments representing
the credible interval.  BAS tries to return HPD intervals, and under model
averaging these may not be symmetric.  
the description above ~~
</p>


<h3>Value</h3>

<p>A plot of the credible intervals.
</p>


<h3>Author(s)</h3>

<p>Merlise A Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.coef.bas">confint.coef.bas</a></code>, <code><a href="#topic+confint.pred.bas">confint.pred.bas</a></code>,
<code><a href="#topic+coef.bas">coef.bas</a></code>, <code><a href="#topic+predict.bas">predict.bas</a></code>, <code>link{bas.lm}</code>
</p>
<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>
<p>Other CI methods: 
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Hald)
hald.ZS = bas.lm(Y ~ ., data=Hald, prior="ZS-null", modelprior=uniform())
hald.coef = confint(coef(hald.ZS), parm=2:5)
plot(hald.coef)
plot(hald.coef, horizontal=TRUE)
plot(confint(predict(hald.ZS, se.fit=TRUE), parm="mean"))

</code></pre>

<hr>
<h2 id='predict.bas'>Prediction Method for an object of class BAS</h2><span id='topic+predict.bas'></span><span id='topic+predict'></span>

<h3>Description</h3>

<p>Predictions under model averaging or other estimators from a BMA object of
class inheriting from 'bas'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bas'
predict(
  object,
  newdata,
  se.fit = FALSE,
  type = "link",
  top = NULL,
  estimator = "BMA",
  na.action = na.pass,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.bas_+3A_object">object</code></td>
<td>
<p>An object of class BAS, created by <code>bas</code></p>
</td></tr>
<tr><td><code id="predict.bas_+3A_newdata">newdata</code></td>
<td>
<p>dataframe for predictions. If missing, then use the dataframe
used for fitting for obtaining fitted and predicted values.</p>
</td></tr>
<tr><td><code id="predict.bas_+3A_se.fit">se.fit</code></td>
<td>
<p>indicator for whether to compute se of fitted and predicted
values</p>
</td></tr>
<tr><td><code id="predict.bas_+3A_type">type</code></td>
<td>
<p>Type of predictions required. &quot;link&quot; which is on the scale of
the linear predictor is the only option currently for linear models, which for the normal model
is equivalent to type='response'.</p>
</td></tr>
<tr><td><code id="predict.bas_+3A_top">top</code></td>
<td>
<p>a scalar integer M.  If supplied, subset the top M models, based
on posterior probabilities for model predictions and BMA.</p>
</td></tr>
<tr><td><code id="predict.bas_+3A_estimator">estimator</code></td>
<td>
<p>estimator used for predictions.  Currently supported
options include: <br /> 'HPM' the highest probability model <br /> 'BMA' Bayesian
model averaging, using optionally only the 'top' models <br /> 'MPM' the median
probability model of Barbieri and Berger. <br /> 'BPM' the model that is
closest to BMA predictions under squared error loss. BMA may be computed
using only the 'top' models if supplied</p>
</td></tr>
<tr><td><code id="predict.bas_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values in newdata.
The default is to predict NA.</p>
</td></tr>
<tr><td><code id="predict.bas_+3A_...">...</code></td>
<td>
<p>optional extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use BMA and/or model selection to form predictions using the top highest
probability models.
</p>


<h3>Value</h3>

<p>a list of
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>fitted values based on the selected estimator</p>
</td></tr>
<tr><td><code>Ybma</code></td>
<td>
<p>predictions using BMA, the same as fit for non-BMA methods for
compatibility; will be deprecated</p>
</td></tr>
<tr><td><code>Ypred</code></td>
<td>
<p>matrix of predictions under
each model for BMA</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>se of fitted values; in the case of BMA
this will be a matrix</p>
</td></tr>
<tr><td><code>se.pred</code></td>
<td>
<p>se for predicted values; in the case
of BMA this will be a matrix</p>
</td></tr>
<tr><td><code>se.bma.fit</code></td>
<td>
<p>vector of posterior sd under
BMA for posterior mean of the regression function.
This will be NULL if estimator is not 'BMA'</p>
</td></tr>
<tr><td><code>se.bma.pred</code></td>
<td>
<p>vector of posterior sd under BMA
for posterior predictive values.  this will be NULL if estimator is not
'BMA'</p>
</td></tr>
<tr><td><code>best</code></td>
<td>
<p>index of top models included</p>
</td></tr>
<tr><td><code>bestmodels</code></td>
<td>
<p>subset of
bestmodels used for fitting or prediction</p>
</td></tr>
<tr><td><code>best.vars</code></td>
<td>
<p>names of variables in the top model; NULL if estimator='BMA'</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>scalar or vector of
degrees of freedom for models</p>
</td></tr>
<tr><td><code>estimator</code></td>
<td>
<p>estimator upon which 'fit'
is based.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas">bas</a></code>, <code><a href="#topic+fitted.bas">fitted.bas</a></code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a></code>,  <code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a></code>
</p>
<p>Other predict methods: 
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>
<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Hald")
hald.gprior =  bas.lm(Y ~ ., data=Hald, alpha=13, prior="g-prior")

predict(hald.gprior, newdata=Hald, estimator="BPM", se.fit=TRUE)
# same as fitted
fitted(hald.gprior,estimator="BPM")
# default is BMA and estimation of mean vector
hald.bma = predict(hald.gprior, top=5, se.fit=TRUE)
confint(hald.bma)

hald.bpm = predict(hald.gprior, newdata=Hald[1,],
                    se.fit=TRUE,
                    estimator="BPM")
confint(hald.bpm)
# extract variables
variable.names(hald.bpm)

hald.hpm = predict(hald.gprior, newdata=Hald[1,],
                    se.fit=TRUE,
                    estimator="HPM")
confint(hald.hpm)
variable.names(hald.hpm)

hald.mpm = predict(hald.gprior, newdata=Hald[1,],
                    se.fit=TRUE,
                    estimator="MPM")
confint(hald.mpm)
variable.names(hald.mpm)

</code></pre>

<hr>
<h2 id='predict.basglm'>Prediction Method for an Object of Class basglm</h2><span id='topic+predict.basglm'></span>

<h3>Description</h3>

<p>Predictions under model averaging from a BMA (BAS) object for GLMs
under different loss functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basglm'
predict(
  object,
  newdata,
  se.fit = FALSE,
  type = c("response", "link"),
  top = NULL,
  estimator = "BMA",
  na.action = na.pass,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.basglm_+3A_object">object</code></td>
<td>
<p>An object of class &quot;basglm&quot;, created by <code>bas.glm</code></p>
</td></tr>
<tr><td><code id="predict.basglm_+3A_newdata">newdata</code></td>
<td>
<p>dataframe, new matrix or vector of data for predictions. May
include a column for the intercept or just the predictor variables.  If a
dataframe, the variables are extracted using model.matrix using the call
that created 'object'.  May be missing in which case the data used for
fitting will be used for prediction.</p>
</td></tr>
<tr><td><code id="predict.basglm_+3A_se.fit">se.fit</code></td>
<td>
<p>indicator for whether to compute se of fitted and predicted
values</p>
</td></tr>
<tr><td><code id="predict.basglm_+3A_type">type</code></td>
<td>
<p>Type of predictions required. The default is  &quot;response&quot; is on the scale of the
response variable, with the alternative being on the linear predictor
scale, &lsquo;type =&rsquo;link''. Thus for a default binomial model
&lsquo;type = &rsquo;response'' gives
the predicted probabilities, while with ''link'', the estimates
are of log-odds (probabilities on logit scale).</p>
</td></tr>
<tr><td><code id="predict.basglm_+3A_top">top</code></td>
<td>
<p>A scalar integer M.  If supplied, calculate results using the subset of the top M models
based on posterior probabilities.</p>
</td></tr>
<tr><td><code id="predict.basglm_+3A_estimator">estimator</code></td>
<td>
<p>estimator used for predictions.  Currently supported
options include: <br /> 'HPM' the highest probability model <br /> 'BMA' Bayesian
model averaging, using optionally only the 'top' models <br /> 'MPM' the median
probability model of Barbieri and Berger. <br /> 'BPM' the model that is
closest to BMA predictions under squared error loss. BMA may be computed
using only the 'top' models if supplied</p>
</td></tr>
<tr><td><code id="predict.basglm_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values in newdata.
The default is to predict NA.</p>
</td></tr>
<tr><td><code id="predict.basglm_+3A_...">...</code></td>
<td>
<p>optional extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first calls the predict method for class bas
(linear models) to form predictions on the linear predictor
scale for 'BMA', 'HPM', 'MPM' etc. If the estimator is 'BMA'
and &lsquo;type=&rsquo;response'' then the
inverse link is applied to fitted values for type equal ''link''
and model averaging takes place in the 'response' scale. Thus applying
the inverse link to BMA estimate with &lsquo;type = &rsquo;link'' is
not equal to the fitted values for &lsquo;type = &rsquo;response'' under
BMA due to the  nonlinear transformation under the inverse link.
</p>


<h3>Value</h3>

<p>a list of
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>predictions using BMA or other estimators</p>
</td></tr>
<tr><td><code>Ypred</code></td>
<td>
<p>matrix of predictions under model(s)</p>
</td></tr>
<tr><td><code>postprobs</code></td>
<td>
<p>renormalized probabilities of
the top models</p>
</td></tr>
<tr><td><code>best</code></td>
<td>
<p>index of top models included</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas.glm">bas.glm</a></code>, <code><a href="#topic+predict.bas">predict.bas</a></code>,
<code><a href="#topic+fitted.bas">fitted.bas</a></code>
</p>
<p>Other predict methods: 
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>
<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(Pima.tr, package="MASS")
data(Pima.te, package="MASS")
Pima.bas = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7, method="BAS",
           betaprior=CCH(a=1, b=nrow(Pima.tr)/2, s=0), family=binomial(),
           modelprior=uniform())
pred = predict(Pima.bas, newdata=Pima.te, top=1)  # Highest Probability model
cv.summary.bas(pred$fit, Pima.te$type, score="miss-class")

</code></pre>

<hr>
<h2 id='print.bas'>Print a Summary of Bayesian Model Averaging objects from BAS</h2><span id='topic+print.bas'></span><span id='topic+print'></span>

<h3>Description</h3>

<p><code>summary</code> and <code>print</code> methods for Bayesian model averaging objects
created by <code>bas</code> Bayesian Adaptive Sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bas'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bas_+3A_x">x</code></td>
<td>
<p>object of class 'bas'</p>
</td></tr>
<tr><td><code id="print.bas_+3A_digits">digits</code></td>
<td>
<p>optional number specifying the number of digits to display</p>
</td></tr>
<tr><td><code id="print.bas_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to <code>print.default</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print methods display a view similar to <code>print.lm</code> .  The summary
methods display a view specific to Bayesian model averaging giving the top 5
highest probability models represented by their inclusion indicators.
Summaries of the models include the Bayes Factor (BF) of each model to the
model with the largest marginal likelihood, the posterior probability of the
models, R2, dim (which includes the intercept) and the log of the marginal
likelihood.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@stat.duke.edu">clyde@stat.duke.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.bas">coef.bas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)
data(UScrime)
UScrime[, -2] &lt;- log(UScrime[, -2])
crime.bic &lt;- bas.lm(y ~ ., data = UScrime, n.models = 2^15, prior = "BIC", initprobs = "eplogp")
print(crime.bic)
summary(crime.bic)
</code></pre>

<hr>
<h2 id='protein'>Protein Activity Data</h2><span id='topic+protein'></span>

<h3>Description</h3>

<p>This data sets includes several predictors of protein activity from an
experiment run at Glaxo.
</p>


<h3>Format</h3>

<p><code>protein</code> is a dataframe with 96 observations and 8 predictor
variables of protein activity: </p>

<table>
<tr>
 <td style="text-align: left;"> [,1] </td><td style="text-align: left;"> buf </td><td style="text-align: left;"> factor </td><td style="text-align: left;">
Buffer </td>
</tr>
<tr>
 <td style="text-align: left;"> [,2] </td><td style="text-align: left;"> pH </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> [,3] </td><td style="text-align: left;"> NaCl </td><td style="text-align: left;"> numeric
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> [,4] </td><td style="text-align: left;"> con </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> protein concentration</td>
</tr>
<tr>
 <td style="text-align: left;"> [,5] </td><td style="text-align: left;">
ra </td><td style="text-align: left;"> factor </td><td style="text-align: left;"> reducing agent</td>
</tr>
<tr>
 <td style="text-align: left;"> [,6] </td><td style="text-align: left;"> det </td><td style="text-align: left;"> factor </td><td style="text-align: left;">
detergent</td>
</tr>
<tr>
 <td style="text-align: left;"> [,7] </td><td style="text-align: left;"> MgCl2 </td><td style="text-align: left;"> numeric</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> [,8] </td><td style="text-align: left;"> temp </td><td style="text-align: left;">
numeric</td><td style="text-align: left;"> (temperature)</td>
</tr>
<tr>
 <td style="text-align: left;"> [,9] </td><td style="text-align: left;"> prot.act1 </td><td style="text-align: left;"> numeric</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> [,10]
</td><td style="text-align: left;"> prot.act2 </td><td style="text-align: left;"> numeric</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> [,11] </td><td style="text-align: left;"> prot.act3 </td><td style="text-align: left;"> numeric</td><td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;"> [,12] </td><td style="text-align: left;"> prot.act4 </td><td style="text-align: left;"> numeric</td><td style="text-align: left;"> protein activity </td>
</tr>

</table>



<h3>Source</h3>

<p>Clyde, M. A. and Parmigiani, G. (1998), Protein Construct Storage:
Bayesian Variable Selection and Prediction with Mixtures, Journal of
Biopharmaceutical Statistics, 8, 431-443
</p>

<hr>
<h2 id='robust'>Robust-Prior Distribution for Coefficients in BMA Model</h2><span id='topic+robust'></span>

<h3>Description</h3>

<p>Creates an object representing the robust prior of Bayarri et al (2012) that
is mixture of g-priors on coefficients for BAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust(n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust_+3A_n">n</code></td>
<td>
<p>the sample size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a prior structure used for <code><a href="#topic+bas.glm">bas.glm</a></code>.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyerparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CCH">CCH</a></code> and<code><a href="#topic+bas.glm">bas.glm</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+CCH">CCH</a>()</code>,
<code><a href="#topic+EB.local">EB.local</a>()</code>,
<code><a href="#topic+IC.prior">IC.prior</a>()</code>,
<code><a href="#topic+Jeffreys">Jeffreys</a>()</code>,
<code><a href="#topic+TG">TG</a>()</code>,
<code><a href="#topic+beta.prime">beta.prime</a>()</code>,
<code><a href="#topic+g.prior">g.prior</a>()</code>,
<code><a href="#topic+hyper.g">hyper.g</a>()</code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a>()</code>,
<code><a href="#topic+intrinsic">intrinsic</a>()</code>,
<code><a href="#topic+tCCH">tCCH</a>()</code>,
<code><a href="#topic+testBF.prior">testBF.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>robust(100)
</code></pre>

<hr>
<h2 id='summary.bas'>Summaries of Bayesian Model Averaging objects from BAS</h2><span id='topic+summary.bas'></span><span id='topic+summary'></span>

<h3>Description</h3>

<p><code>summary</code> and <code>print</code> methods for Bayesian model averaging objects
created by <code>bas</code> Bayesian Adaptive Sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bas'
summary(object, n.models = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bas_+3A_object">object</code></td>
<td>
<p>object of class 'bas'</p>
</td></tr>
<tr><td><code id="summary.bas_+3A_n.models">n.models</code></td>
<td>
<p>optional number specifying the number of best models to
display in summary</p>
</td></tr>
<tr><td><code id="summary.bas_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to <code>summary.default</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print methods display a view similar to <code>print.lm</code> .  The summary
methods display a view specific to Bayesian model averaging giving the top 5
highest probability models represented by their inclusion indicators.
Summaries of the models include the Bayes Factor (BF) of each model to the
model with the largest marginal likelihood, the posterior probability of the
models, R2, dim (which includes the intercept) and the log of the marginal
likelihood.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@duke.edu">clyde@duke.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.bas">coef.bas</a></code>
</p>
<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(UScrime, package = "MASS")
UScrime[, -2] &lt;- log(UScrime[, -2])
crime.bic &lt;- bas.lm(y ~ ., data = UScrime, n.models = 2^15, prior = "BIC", initprobs = "eplogp")
print(crime.bic)
summary(crime.bic)
</code></pre>

<hr>
<h2 id='tCCH'>Generalized tCCH g-Prior Distribution for Coefficients in BMA Models</h2><span id='topic+tCCH'></span>

<h3>Description</h3>

<p>Creates an object representing the tCCH mixture of g-priors on coefficients
for BAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tCCH(alpha = 1, beta = 2, s = 0, r = 3/2, v = 1, theta = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tCCH_+3A_alpha">alpha</code></td>
<td>
<p>a scalar &gt; 0, recommended alpha=.5 (betaprime) or 1.</p>
</td></tr>
<tr><td><code id="tCCH_+3A_beta">beta</code></td>
<td>
<p>a scalar &gt; 0.  The value is not updated by the data; beta should
be a function of n for consistency under the null model.</p>
</td></tr>
<tr><td><code id="tCCH_+3A_s">s</code></td>
<td>
<p>a scalar, recommended s=0 a priori</p>
</td></tr>
<tr><td><code id="tCCH_+3A_r">r</code></td>
<td>
<p>r arbitrary; in the hyper-g-n prior sets r = (alpha + 2)</p>
</td></tr>
<tr><td><code id="tCCH_+3A_v">v</code></td>
<td>
<p>0 &lt; v</p>
</td></tr>
<tr><td><code id="tCCH_+3A_theta">theta</code></td>
<td>
<p>theta &gt; 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a structure used for <code><a href="#topic+bas.glm">bas.glm</a></code>.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyerparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CCH">CCH</a></code>, <code><a href="#topic+robust">robust</a></code>, <code><a href="#topic+hyper.g">hyper.g</a></code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a></code><code><a href="#topic+bas.glm">bas.glm</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+CCH">CCH</a>()</code>,
<code><a href="#topic+EB.local">EB.local</a>()</code>,
<code><a href="#topic+IC.prior">IC.prior</a>()</code>,
<code><a href="#topic+Jeffreys">Jeffreys</a>()</code>,
<code><a href="#topic+TG">TG</a>()</code>,
<code><a href="#topic+beta.prime">beta.prime</a>()</code>,
<code><a href="#topic+g.prior">g.prior</a>()</code>,
<code><a href="#topic+hyper.g">hyper.g</a>()</code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a>()</code>,
<code><a href="#topic+intrinsic">intrinsic</a>()</code>,
<code><a href="#topic+robust">robust</a>()</code>,
<code><a href="#topic+testBF.prior">testBF.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tCCH(alpha = 1, beta = 2, s = 0, r = 1.5, v = 1, theta = 1 / n)
</code></pre>

<hr>
<h2 id='testBF.prior'>Test based Bayes Factors for BMA Models</h2><span id='topic+testBF.prior'></span>

<h3>Description</h3>

<p>Creates an object representing the prior distribution on coefficients for
BAS that corresponds to the test-based Bayes Factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testBF.prior(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testBF.prior_+3A_g">g</code></td>
<td>
<p>a scalar used in the covariance of Zellner's g-prior, Cov(beta) =
sigma^2 g (X'X)^-</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a prior object structure used for BAS in 'bas.glm'.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyerparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+g.prior">g.prior</a></code>, <code><a href="#topic+bas.glm">bas.glm</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+CCH">CCH</a>()</code>,
<code><a href="#topic+EB.local">EB.local</a>()</code>,
<code><a href="#topic+IC.prior">IC.prior</a>()</code>,
<code><a href="#topic+Jeffreys">Jeffreys</a>()</code>,
<code><a href="#topic+TG">TG</a>()</code>,
<code><a href="#topic+beta.prime">beta.prime</a>()</code>,
<code><a href="#topic+g.prior">g.prior</a>()</code>,
<code><a href="#topic+hyper.g">hyper.g</a>()</code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a>()</code>,
<code><a href="#topic+intrinsic">intrinsic</a>()</code>,
<code><a href="#topic+robust">robust</a>()</code>,
<code><a href="#topic+tCCH">tCCH</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
testBF.prior(100)
library(MASS)
data(Pima.tr)

# use g = n
bas.glm(type ~ .,
  data = Pima.tr, family = binomial(),
  betaprior = testBF.prior(nrow(Pima.tr)),
  modelprior = uniform(), method = "BAS"
)
</code></pre>

<hr>
<h2 id='TG'>Generalized g-Prior Distribution for Coefficients in BMA Models</h2><span id='topic+TG'></span>

<h3>Description</h3>

<p>Creates an object representing the Truncated Gamma (tCCH) mixture of
g-priors on coefficients for BAS, where u = 1/(1+g) has a Gamma distribution
supported on (0, 1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TG(alpha = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TG_+3A_alpha">alpha</code></td>
<td>
<p>a scalar &gt; 0, recommended alpha=.5 (betaprime) or 1.  alpha=2
corresponds to the uniform prior on the shrinkage factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a structure used for <code><a href="#topic+bas.glm">bas.glm</a></code>.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyerparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CCH">CCH</a></code> <code><a href="#topic+bas.glm">bas.glm</a></code>
</p>
<p>Other beta priors: 
<code><a href="#topic+CCH">CCH</a>()</code>,
<code><a href="#topic+EB.local">EB.local</a>()</code>,
<code><a href="#topic+IC.prior">IC.prior</a>()</code>,
<code><a href="#topic+Jeffreys">Jeffreys</a>()</code>,
<code><a href="#topic+beta.prime">beta.prime</a>()</code>,
<code><a href="#topic+g.prior">g.prior</a>()</code>,
<code><a href="#topic+hyper.g">hyper.g</a>()</code>,
<code><a href="#topic+hyper.g.n">hyper.g.n</a>()</code>,
<code><a href="#topic+intrinsic">intrinsic</a>()</code>,
<code><a href="#topic+robust">robust</a>()</code>,
<code><a href="#topic+tCCH">tCCH</a>()</code>,
<code><a href="#topic+testBF.prior">testBF.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
TG(alpha = 2)
CCH(alpha = 2, beta = 100, s = 0)
</code></pre>

<hr>
<h2 id='tr.beta.binomial'>Truncated Beta-Binomial Prior Distribution for Models</h2><span id='topic+tr.beta.binomial'></span><span id='topic+tr.Beta.Binomial'></span>

<h3>Description</h3>

<p>Creates an object representing the prior distribution on models for BAS
using a truncated Beta-Binomial Distribution on the Model Size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr.beta.binomial(alpha = 1, beta = 1, trunc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tr.beta.binomial_+3A_alpha">alpha</code></td>
<td>
<p>parameter in the beta prior distribution</p>
</td></tr>
<tr><td><code id="tr.beta.binomial_+3A_beta">beta</code></td>
<td>
<p>parameter in the beta prior distribution</p>
</td></tr>
<tr><td><code id="tr.beta.binomial_+3A_trunc">trunc</code></td>
<td>
<p>parameter that determines truncation in the distribution i.e.
P(M; alpha, beta, trunc) = 0 if M &gt; trunc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta-binomial distribution on model size is obtained by assigning each
variable inclusion indicator independent Bernoulli distributions with
probability w, and then giving w a beta(alpha,beta) distribution.
Marginalizing over w leads to the number of included
predictors having a beta-binomial distribution. The default hyperparameters
lead to a uniform distribution over model size.  The Truncated version
assigns zero probability to all models of size &gt; trunc.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyperparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas.lm">bas.lm</a></code>, <code><a href="#topic+Bernoulli">Bernoulli</a></code>,<code><a href="#topic+uniform">uniform</a></code>
</p>
<p>Other priors modelpriors: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Bernoulli.heredity">Bernoulli.heredity</a>()</code>,
<code><a href="#topic+beta.binomial">beta.binomial</a>()</code>,
<code><a href="#topic+tr.poisson">tr.poisson</a>()</code>,
<code><a href="#topic+tr.power.prior">tr.power.prior</a>()</code>,
<code><a href="#topic+uniform">uniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tr.beta.binomial(1, 10, 5)
library(MASS)
data(UScrime)
UScrime[, -2] &lt;- log(UScrime[, -2])
crime.bic &lt;- bas.lm(y ~ .,
  data = UScrime, n.models = 2^15, prior = "BIC",
  modelprior = tr.beta.binomial(1, 1, 8),
  initprobs = "eplogp"
)
</code></pre>

<hr>
<h2 id='tr.poisson'>Truncated Poisson Prior Distribution for Models</h2><span id='topic+tr.poisson'></span><span id='topic+tr.Poisson'></span>

<h3>Description</h3>

<p>Creates an object representing the prior distribution on models for BAS
using a truncated Poisson Distribution on the Model Size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr.poisson(lambda, trunc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tr.poisson_+3A_lambda">lambda</code></td>
<td>
<p>parameter in the Poisson distribution representing expected
model size with infinite predictors</p>
</td></tr>
<tr><td><code id="tr.poisson_+3A_trunc">trunc</code></td>
<td>
<p>parameter that determines truncation in the distribution i.e.
P(M; lambda, trunc) = 0 if M &gt; trunc</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Poisson prior distribution on model size is obtained by assigning each
variable inclusion indicator independent Bernoulli distributions with
probability w, and then taking a limit as p goes to infinity and w goes to
zero, such that p*w converges to lambda.  The Truncated version assigns zero
probability to all models of size M &gt; trunc.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyperparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas.lm">bas.lm</a></code>, <code><a href="#topic+Bernoulli">Bernoulli</a></code>,<code><a href="#topic+uniform">uniform</a></code>
</p>
<p>Other priors modelpriors: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Bernoulli.heredity">Bernoulli.heredity</a>()</code>,
<code><a href="#topic+beta.binomial">beta.binomial</a>()</code>,
<code><a href="#topic+tr.beta.binomial">tr.beta.binomial</a>()</code>,
<code><a href="#topic+tr.power.prior">tr.power.prior</a>()</code>,
<code><a href="#topic+uniform">uniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tr.poisson(10, 50)
</code></pre>

<hr>
<h2 id='tr.power.prior'>Truncated Power Prior Distribution for Models</h2><span id='topic+tr.power.prior'></span><span id='topic+tr.Power.Prior'></span>

<h3>Description</h3>

<p>Creates an object representing the prior distribution on models for BAS
using a truncated Distribution on the Model Size where the probability of
gamma = p^-kappa |gamma| where gamma is the vector of model indicators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr.power.prior(kappa = 2, trunc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tr.power.prior_+3A_kappa">kappa</code></td>
<td>
<p>parameter in the prior distribution that controls sparsity</p>
</td></tr>
<tr><td><code id="tr.power.prior_+3A_trunc">trunc</code></td>
<td>
<p>parameter that determines truncation in the distribution i.e.
P(gamma; alpha, beta, trunc) = 0 if |gamma| &gt; trunc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The beta-binomial distribution on model size is obtained by assigning each
variable inclusion indicator independent Bernoulli distributions with
probability w, and then giving w a beta(alpha,beta) distribution.
Marginalizing over w leads to the number of included
predictors having a beta-binomial distribution. The default hyperparameters
lead to a uniform distribution over model size.  The Truncated version
assigns zero probability to all models of size &gt; trunc.
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family and
hyperparameters.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas.lm">bas.lm</a></code>, <code><a href="#topic+Bernoulli">Bernoulli</a></code>,<code><a href="#topic+uniform">uniform</a></code>
</p>
<p>Other priors modelpriors: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Bernoulli.heredity">Bernoulli.heredity</a>()</code>,
<code><a href="#topic+beta.binomial">beta.binomial</a>()</code>,
<code><a href="#topic+tr.beta.binomial">tr.beta.binomial</a>()</code>,
<code><a href="#topic+tr.poisson">tr.poisson</a>()</code>,
<code><a href="#topic+uniform">uniform</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tr.power.prior(2, 8)
library(MASS)
data(UScrime)
UScrime[, -2] &lt;- log(UScrime[, -2])
crime.bic &lt;- bas.lm(y ~ .,
  data = UScrime, n.models = 2^15, prior = "BIC",
  modelprior = tr.power.prior(2, 8),
  initprobs = "eplogp"
)
</code></pre>

<hr>
<h2 id='trCCH'>Truncated Compound Confluent Hypergeometric function</h2><span id='topic+trCCH'></span><span id='topic+trunc.CCH'></span>

<h3>Description</h3>

<p>Compute the Truncated Confluent Hypergeometric function from Li and Clyde
(2018) which is the normalizing constant in the tcch density of Gordy
(1998) with integral representation:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trCCH(a, b, r, s, v, k, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trCCH_+3A_a">a</code></td>
<td>
<p>a &gt; 0</p>
</td></tr>
<tr><td><code id="trCCH_+3A_b">b</code></td>
<td>
<p>b &gt; 0</p>
</td></tr>
<tr><td><code id="trCCH_+3A_r">r</code></td>
<td>
<p>r  &gt;= 0</p>
</td></tr>
<tr><td><code id="trCCH_+3A_s">s</code></td>
<td>
<p>arbitrary</p>
</td></tr>
<tr><td><code id="trCCH_+3A_v">v</code></td>
<td>
<p>0 &lt; v</p>
</td></tr>
<tr><td><code id="trCCH_+3A_k">k</code></td>
<td>
<p>arbitrary</p>
</td></tr>
<tr><td><code id="trCCH_+3A_log">log</code></td>
<td>
<p>logical indicating whether to return values on the log scale; 
useful for Bayes Factor calculations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tr.cch(a,b,r,s,v,k) =  Int_0^1/v
u^(a-1) (1 - vu)^(b -1) (k + (1 - k)vu)^(-r) exp(-s u) du
</p>
<p>This uses a more 
stable method for calculating the normalizing constant using R's 'integrate' 
function rather than the version in Gordy 1998. For calculating Bayes factors 
that use the 'trCCH' function we 
recommend using the 'log=TRUE' option to compute log Bayes factors.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde (<a href="mailto:clyde@duke.edu">clyde@duke.edu</a>)
</p>


<h3>References</h3>

<p>Gordy 1998 Li &amp; Clyde 2018
</p>


<h3>See Also</h3>

<p>Other special functions: 
<code><a href="#topic+hypergeometric1F1">hypergeometric1F1</a>()</code>,
<code><a href="#topic+hypergeometric2F1">hypergeometric2F1</a>()</code>,
<code><a href="#topic+phi1">phi1</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# special cases
# trCCH(a, b, r, s=0, v = 1, k) is the same as
# 2F1(a, r, a + b, 1 - 1/k)*beta(a, b)/k^r

k = 10; a = 1.5; b = 2; r = 2;  
trCCH(a, b, r, s=0, v = 1, k=k) *k^r/beta(a,b)
hypergeometric2F1(a, r, a + b, 1 - 1/k, log = FALSE)

# trCCH(a,b,0,s,1,1) is the same as 
# beta(a, b) 1F1(a, a + b, -s, log=FALSE)
s = 3; r = 0; v = 1; k = 1
beta(a, b)*hypergeometric1F1(a, a+b, -s, log = FALSE)
trCCH(a, b, r, s, v, k)

# Equivalence with the Phi1 function 
a = 1.5; b = 3; k = 1.25; s = 400;  r = 2;  v = 1; 

phi1(a, r,  a + b, -s, 1 - 1/k,  log=FALSE)*(k^-r)*gamma(a)*gamma(b)/gamma(a+b)
trCCH(a,b,r,s,v,k)
</code></pre>

<hr>
<h2 id='uniform'>Uniform Prior Distribution for Models</h2><span id='topic+uniform'></span><span id='topic+Uniform'></span>

<h3>Description</h3>

<p>Creates an object representing the prior distribution on models for BAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform()
</code></pre>


<h3>Details</h3>

<p>The Uniform prior distribution is a commonly used prior in BMA, and is a
special case of the independent Bernoulli prior with probs=.5. The implied
prior distribution on model size is binomial(p, .5).
</p>


<h3>Value</h3>

<p>returns an object of class &quot;prior&quot;, with the family name Uniform.
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas.lm">bas.lm</a></code>,
<code><a href="#topic+beta.binomial">beta.binomial</a></code>,<code><a href="#topic+Bernoulli">Bernoulli</a></code>,
</p>
<p>Other priors modelpriors: 
<code><a href="#topic+Bernoulli">Bernoulli</a>()</code>,
<code><a href="#topic+Bernoulli.heredity">Bernoulli.heredity</a>()</code>,
<code><a href="#topic+beta.binomial">beta.binomial</a>()</code>,
<code><a href="#topic+tr.beta.binomial">tr.beta.binomial</a>()</code>,
<code><a href="#topic+tr.poisson">tr.poisson</a>()</code>,
<code><a href="#topic+tr.power.prior">tr.power.prior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uniform()
</code></pre>

<hr>
<h2 id='update.bas'>Update BAS object using a new prior</h2><span id='topic+update.bas'></span><span id='topic+update'></span>

<h3>Description</h3>

<p>Update a BMA object using a new prior distribution on the coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bas'
update(object, newprior, alpha = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.bas_+3A_object">object</code></td>
<td>
<p>BMA object to update</p>
</td></tr>
<tr><td><code id="update.bas_+3A_newprior">newprior</code></td>
<td>
<p>Update posterior model probabilities, probne0, shrinkage,
logmarg, etc, using prior based on newprior.  See <code><a href="#topic+bas">bas</a></code> for
available methods</p>
</td></tr>
<tr><td><code id="update.bas_+3A_alpha">alpha</code></td>
<td>
<p>optional new value of hyperparameter in prior for method</p>
</td></tr>
<tr><td><code id="update.bas_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recomputes the marginal likelihoods for the new methods for models already
sampled in current object.
</p>


<h3>Value</h3>

<p>A new object of class BMA
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@stat.duke.edu">clyde@stat.duke.edu</a>
</p>


<h3>References</h3>

<p>Clyde, M. Ghosh, J. and Littman, M. (2010) Bayesian Adaptive
Sampling for Variable Selection and Model Averaging. Journal of
Computational Graphics and Statistics.  20:80-101 <br />
<a href="https://doi.org/10.1198/jcgs.2010.09049">doi:10.1198/jcgs.2010.09049</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas">bas</a></code> for available methods and choices of alpha
</p>
<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+variable.names.pred.bas">variable.names.pred.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(MASS)
data(UScrime)
UScrime[,-2] &lt;- log(UScrime[,-2])
crime.bic &lt;-  bas.lm(y ~ ., data=UScrime, n.models=2^10, prior="BIC",initprobs= "eplogp")
crime.ebg &lt;- update(crime.bic, newprior="EB-global")
crime.zs &lt;- update(crime.bic, newprior="ZS-null")


</code></pre>

<hr>
<h2 id='variable.names.pred.bas'>Extract the variable names for a model from a BAS prediction object</h2><span id='topic+variable.names.pred.bas'></span><span id='topic+variable.names'></span>

<h3>Description</h3>

<p>S3 method for class 'pred.bas'.  Simple utility
function to extract the variable names.  Used to print names
for the selected models using estimators for 'HPM', 'MPM' or 'BPM&quot;.
for the selected model created by <code>predict</code> for BAS
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pred.bas'
variable.names(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variable.names.pred.bas_+3A_object">object</code></td>
<td>
<p>a BAS object created by <code>predict</code> from a BAS
'bas.lm' or 'bas.glm' object</p>
</td></tr>
<tr><td><code id="variable.names.pred.bas_+3A_...">...</code></td>
<td>
<p>other arguments to pass on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector with the names of the variables
included in the selected model; in the case of 'BMA' this will
be all variables
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.bas">predict.bas</a></code>
</p>
<p>Other predict methods: 
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>
</p>
<p>Other bas methods: 
<code><a href="#topic+BAS">BAS</a></code>,
<code><a href="#topic+bas.lm">bas.lm</a>()</code>,
<code><a href="#topic+coef.bas">coef.bas</a>()</code>,
<code><a href="#topic+confint.coef.bas">confint.coef.bas</a>()</code>,
<code><a href="#topic+confint.pred.bas">confint.pred.bas</a>()</code>,
<code><a href="#topic+diagnostics">diagnostics</a>()</code>,
<code><a href="#topic+fitted.bas">fitted.bas</a>()</code>,
<code><a href="#topic+force.heredity.bas">force.heredity.bas</a>()</code>,
<code><a href="#topic+image.bas">image.bas</a>()</code>,
<code><a href="#topic+plot.confint.bas">plot.confint.bas</a>()</code>,
<code><a href="#topic+predict.bas">predict.bas</a>()</code>,
<code><a href="#topic+predict.basglm">predict.basglm</a>()</code>,
<code><a href="#topic+summary.bas">summary.bas</a>()</code>,
<code><a href="#topic+update.bas">update.bas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Hald)
hald.gprior =  bas.lm(Y~ ., data=Hald, prior="ZS-null", modelprior=uniform())
hald.bpm = predict(hald.gprior, newdata=Hald[1,],
                   se.fit=TRUE,
                   estimator="BPM")
variable.names(hald.bpm)
</code></pre>

<hr>
<h2 id='which.matrix'>Coerce a BAS list object of models into a matrix.</h2><span id='topic+which.matrix'></span>

<h3>Description</h3>

<p>This function coerces the list object of models to a matrix and fill in the
zeros to facilitate other computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.matrix(which, n.vars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which.matrix_+3A_which">which</code></td>
<td>
<p>a 'bas' model object  <code>x$which</code></p>
</td></tr>
<tr><td><code id="which.matrix_+3A_n.vars">n.vars</code></td>
<td>
<p>the total number of predictors, <code>x$n.vars</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>which.matrix</code>  coerces
<code>x$which</code> into a matrix.
</p>


<h3>Value</h3>

<p>a matrix representation of <code>x$which</code>, with number of rows equal
to the length of which.models or total number of models and number of
columns <code>x$n.vars</code>
</p>


<h3>Author(s)</h3>

<p>Merlise Clyde <a href="mailto:clyde@duke.edu">clyde@duke.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bas">bas</a></code>
</p>
<p>Other as.matrix methods: 
<code><a href="#topic+list2matrix.bas">list2matrix.bas</a>()</code>,
<code><a href="#topic+list2matrix.which">list2matrix.which</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Hald)
Hald.bic &lt;-  bas.lm(Y ~ ., data=Hald, prior="BIC", initprobs="eplogp")
# matrix of model indicators
models &lt;- which.matrix(Hald.bic$which, Hald.bic$n.vars)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
