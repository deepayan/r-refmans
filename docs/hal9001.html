<!DOCTYPE html><html><head><title>Help for package hal9001</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hal9001}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+2B.formula_hal9001'><p>HAL Formula addition: Adding formula term object together into a single</p>
formula object term.</a></li>
<li><a href='#apply_copy_map'><p>Apply copy map</p></a></li>
<li><a href='#as_dgCMatrix'><p>Fast Coercion to Sparse Matrix</p></a></li>
<li><a href='#basis_list_cols'><p>List Basis Functions</p></a></li>
<li><a href='#basis_of_degree'><p>Compute Degree of Basis Functions</p></a></li>
<li><a href='#calc_pnz'><p>Calculate Proportion of Nonzero Entries</p></a></li>
<li><a href='#calc_xscale'><p>Calculating Centered and Scaled Matrices</p></a></li>
<li><a href='#enumerate_basis'><p>Enumerate Basis Functions</p></a></li>
<li><a href='#enumerate_edge_basis'><p>Enumerate Basis Functions at Generalized Edges</p></a></li>
<li><a href='#evaluate_basis'><p>Generate Basis Functions</p></a></li>
<li><a href='#fit_hal'><p>HAL: The Highly Adaptive Lasso</p></a></li>
<li><a href='#formula_hal'><p>HAL Formula: Convert formula or string to <code>formula_HAL</code> object.</p></a></li>
<li><a href='#generate_all_rules'><p>Generates rules based on knot points of the fitted HAL basis functions with</p>
non-zero coefficients.</a></li>
<li><a href='#h'><p>HAL Formula term: Generate a single term of the HAL basis</p></a></li>
<li><a href='#hal_quotes'><p>HAL9000 Quotes from &quot;2001: A Space Odyssey&quot;</p></a></li>
<li><a href='#hal9000'><p>HAL 9000 Quotes</p></a></li>
<li><a href='#hal9001'><p>hal9001</p></a></li>
<li><a href='#index_first_copy'><p>Find Copies of Columns</p></a></li>
<li><a href='#make_basis_list'><p>Sort Basis Functions</p></a></li>
<li><a href='#make_copy_map'><p>Build Copy Maps</p></a></li>
<li><a href='#make_design_matrix'><p>Build HAL Design Matrix</p></a></li>
<li><a href='#make_reduced_basis_map'><p>Mass-based reduction of basis functions</p></a></li>
<li><a href='#meets_basis'><p>Compute Values of Basis Functions</p></a></li>
<li><a href='#num_knots_generator'><p>A default generator for the <code>num_knots</code> argument for each degree of</p>
interactions and the smoothness orders.</a></li>
<li><a href='#predict.hal9001'><p>Prediction from HAL fits</p></a></li>
<li><a href='#predict.SL.hal9001'><p>predict.SL.hal9001</p></a></li>
<li><a href='#print.formula_hal9001'><p>Print formula_hal9001 object</p></a></li>
<li><a href='#print.summary.hal9001'><p>Print Method for Summary Class of HAL fits</p></a></li>
<li><a href='#quantizer'><p>Discretize Variables into Number of Bins by Unique Values</p></a></li>
<li><a href='#SL.hal9001'><p>Wrapper for Classic SuperLearner</p></a></li>
<li><a href='#squash_hal_fit'><p>Squash HAL objects</p></a></li>
<li><a href='#summary.hal9001'><p>Summary Method for HAL fit objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>The Scalable Highly Adaptive Lasso</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.6</td>
</tr>
<tr>
<td>Description:</td>
<td>A scalable implementation of the highly adaptive lasso algorithm,
  including routines for constructing sparse matrices of basis functions of the
  observed data, as well as a custom implementation of Lasso regression tailored
  to enhance efficiency when the matrix of predictors is composed exclusively of
  indicator functions. For ease of use and increased flexibility, the Lasso
  fitting routines invoke code from the 'glmnet' package by default. The highly
  adaptive lasso was first formulated and described by MJ van der Laan (2017)
  &lt;<a href="https://doi.org/10.1515%2Fijb-2015-0097">doi:10.1515/ijb-2015-0097</a>&gt;, with practical demonstrations of its performance
  given by Benkeser and van der Laan (2016) &lt;<a href="https://doi.org/10.1109%2FDSAA.2016.93">doi:10.1109/DSAA.2016.93</a>&gt;. This
  implementation of the highly adaptive lasso algorithm was described by Hejazi,
  Coyle, and van der Laan (2020) &lt;<a href="https://doi.org/10.21105%2Fjoss.02526">doi:10.21105/joss.02526</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), Rcpp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tlverse/hal9001">https://github.com/tlverse/hal9001</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tlverse/hal9001/issues">https://github.com/tlverse/hal9001/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, stats, utils, methods, assertthat, origami (&ge; 1.0.3),
glmnet, data.table, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, microbenchmark, future, ggplot2,
dplyr, tidyr, survival, SuperLearner</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-13 21:27:19 UTC; jrcoyle</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeremy Coyle <a href="https://orcid.org/0000-0002-9874-6649"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Nima Hejazi <a href="https://orcid.org/0000-0002-7127-2789"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Rachael Phillips <a href="https://orcid.org/0000-0002-8474-591X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Lars van der Laan [aut],
  David Benkeser <a href="https://orcid.org/0000-0002-1019-8343"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Oleg Sofrygin [ctb],
  Weixin Cai <a href="https://orcid.org/0000-0003-2680-3066"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Mark van der Laan <a href="https://orcid.org/0000-0003-1432-5511"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeremy Coyle &lt;jeremyrcoyle@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-14 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2B.formula_hal9001'>HAL Formula addition: Adding formula term object together into a single
formula object term.</h2><span id='topic++2B.formula_hal9001'></span>

<h3>Description</h3>

<p>HAL Formula addition: Adding formula term object together into a single
formula object term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula_hal9001'
x + y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.formula_hal9001_+3A_x">x</code></td>
<td>
<p>A <code>formula_hal9001</code> object as outputted by <code>h</code>.</p>
</td></tr>
<tr><td><code id="+2B2B.formula_hal9001_+3A_y">y</code></td>
<td>
<p>A <code>formula_hal9001</code> object as outputted by <code>h</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='apply_copy_map'>Apply copy map</h2><span id='topic+apply_copy_map'></span>

<h3>Description</h3>

<p>OR duplicate training set columns together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_copy_map(X, copy_map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_copy_map_+3A_x">X</code></td>
<td>
<p>Sparse matrix containing columns of indicator functions.</p>
</td></tr>
<tr><td><code id="apply_copy_map_+3A_copy_map">copy_map</code></td>
<td>
<p>the copy map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dgCMatrix</code> sparse matrix corresponding to the design matrix
for a zero-th order highly adaptive lasso, but with all duplicated columns
(basis functions) removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gendata &lt;- function(n) {
  W1 &lt;- runif(n, -3, 3)
  W2 &lt;- rnorm(n)
  W3 &lt;- runif(n)
  W4 &lt;- rnorm(n)
  g0 &lt;- plogis(0.5 * (-0.8 * W1 + 0.39 * W2 + 0.08 * W3 - 0.12 * W4))
  A &lt;- rbinom(n, 1, g0)
  Q0 &lt;- plogis(0.15 * (2 * A + 2 * A * W1 + 6 * A * W3 * W4 - 3))
  Y &lt;- rbinom(n, 1, Q0)
  data.frame(A, W1, W2, W3, W4, Y)
}
set.seed(1234)
data &lt;- gendata(100)
covars &lt;- setdiff(names(data), "Y")
X &lt;- as.matrix(data[, covars, drop = FALSE])
basis_list &lt;- enumerate_basis(X)
x_basis &lt;- make_design_matrix(X, basis_list)
copy_map &lt;- make_copy_map(x_basis)
x_basis_uniq &lt;- apply_copy_map(x_basis, copy_map)


</code></pre>

<hr>
<h2 id='as_dgCMatrix'>Fast Coercion to Sparse Matrix</h2><span id='topic+as_dgCMatrix'></span>

<h3>Description</h3>

<p>Fast and efficient coercion of standard matrix objects to sparse matrices.
Borrowed from http://gallery.rcpp.org/articles/sparse-matrix-coercion/.
INTERNAL USE ONLY.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_dgCMatrix(XX_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_dgCMatrix_+3A_xx_">XX_</code></td>
<td>
<p>An object of class <code>Matrix</code> that has a sparse structure
suitable for coercion to a sparse matrix format of <code>dgCMatrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>dgCMatrix</code>, coerced from input <code>XX_</code>.
</p>

<hr>
<h2 id='basis_list_cols'>List Basis Functions</h2><span id='topic+basis_list_cols'></span>

<h3>Description</h3>

<p>Build a list of basis functions from a set of columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis_list_cols(
  cols,
  x,
  smoothness_orders,
  include_zero_order,
  include_lower_order = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_list_cols_+3A_cols">cols</code></td>
<td>
<p>Index or indices (as <code>numeric</code>) of covariates (columns) of
interest in the data matrix <code>x</code> for which basis functions ought to be
generated. Note that basis functions for interactions of these columns are
computed automatically.</p>
</td></tr>
<tr><td><code id="basis_list_cols_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> containing observations in the rows and covariates
in the columns. Basis functions are computed for these covariates.</p>
</td></tr>
<tr><td><code id="basis_list_cols_+3A_smoothness_orders">smoothness_orders</code></td>
<td>
<p>An integer vector of length <code>ncol(x)</code>
specifying the desired smoothness of the function in each covariate. k = 0
is no smoothness (indicator basis), k = 1 is first order smoothness, and so
on. For an additive model, the component function for each covariate will
have the degree of smoothness as specified by smoothness_orders. For
non-additive components (tensor products of univariate basis functions),
the univariate basis functions in each tensor product have smoothness
degree as specified by smoothness_orders.</p>
</td></tr>
<tr><td><code id="basis_list_cols_+3A_include_zero_order">include_zero_order</code></td>
<td>
<p>A <code>logical</code>, indicating whether the zeroth
order basis functions are included for each covariate (if <code>TRUE</code>), in
addition to the smooth basis functions given by <code>smoothness_orders</code>.
This allows the algorithm to data-adaptively choose the appropriate degree
of smoothness.</p>
</td></tr>
<tr><td><code id="basis_list_cols_+3A_include_lower_order">include_lower_order</code></td>
<td>
<p>A <code>logical</code>, like <code>include_zero_order</code>,
except including all basis functions of lower smoothness degrees than
specified via <code>smoothness_orders</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the basis functions generated from a set of
input columns.
</p>

<hr>
<h2 id='basis_of_degree'>Compute Degree of Basis Functions</h2><span id='topic+basis_of_degree'></span>

<h3>Description</h3>

<p>Find the full list of basis functions up to a particular degree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis_of_degree(
  x,
  degree,
  smoothness_orders,
  include_zero_order,
  include_lower_order
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_of_degree_+3A_x">x</code></td>
<td>
<p>An input <code>matrix</code> containing observations and covariates
following standard conventions in problems of statistical learning.</p>
</td></tr>
<tr><td><code id="basis_of_degree_+3A_degree">degree</code></td>
<td>
<p>The highest order of interaction terms for which the basis
functions ought to be generated. The default (<code>NULL</code>) corresponds to
generating basis functions for the full dimensionality of the input matrix.</p>
</td></tr>
<tr><td><code id="basis_of_degree_+3A_smoothness_orders">smoothness_orders</code></td>
<td>
<p>An integer vector of length <code>ncol(x)</code>
specifying the desired smoothness of the function in each covariate. k = 0
is no smoothness (indicator basis), k = 1 is first order smoothness, and so
on. For an additive model, the component function for each covariate will
have the degree of smoothness as specified by smoothness_orders. For
non-additive components (tensor products of univariate basis functions),
the univariate basis functions in each tensor product have smoothness
degree as specified by smoothness_orders.</p>
</td></tr>
<tr><td><code id="basis_of_degree_+3A_include_zero_order">include_zero_order</code></td>
<td>
<p>A <code>logical</code>, indicating whether the zeroth
order basis functions are included for each covariate (if <code>TRUE</code>), in
addition to the smooth basis functions given by <code>smoothness_orders</code>.
This allows the algorithm to data-adaptively choose the appropriate degree
of smoothness.</p>
</td></tr>
<tr><td><code id="basis_of_degree_+3A_include_lower_order">include_lower_order</code></td>
<td>
<p>A <code>logical</code>, like <code>include_zero_order</code>,
except including all basis functions of lower smoothness degrees than
specified via <code>smoothness_orders</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing  basis functions and cutoffs generated from
a set of input columns up to a particular pre-specified degree.
</p>

<hr>
<h2 id='calc_pnz'>Calculate Proportion of Nonzero Entries</h2><span id='topic+calc_pnz'></span>

<h3>Description</h3>

<p>Calculate Proportion of Nonzero Entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_pnz(X)
</code></pre>

<hr>
<h2 id='calc_xscale'>Calculating Centered and Scaled Matrices</h2><span id='topic+calc_xscale'></span>

<h3>Description</h3>

<p>Calculating Centered and Scaled Matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_xscale(X, xcenter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_xscale_+3A_x">X</code></td>
<td>
<p>A sparse matrix, to be centered.</p>
</td></tr>
<tr><td><code id="calc_xscale_+3A_xcenter">xcenter</code></td>
<td>
<p>A vector of column means to be used for centering X.</p>
</td></tr>
</table>

<hr>
<h2 id='enumerate_basis'>Enumerate Basis Functions</h2><span id='topic+enumerate_basis'></span>

<h3>Description</h3>

<p>Generate basis functions for all covariates and interaction terms thereof up
to a specified order/degree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enumerate_basis(
  x,
  max_degree = NULL,
  smoothness_orders = rep(0, ncol(x)),
  include_zero_order = FALSE,
  include_lower_order = FALSE,
  num_knots = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enumerate_basis_+3A_x">x</code></td>
<td>
<p>An input <code>matrix</code> containing observations and covariates
following standard conventions in problems of statistical learning.</p>
</td></tr>
<tr><td><code id="enumerate_basis_+3A_max_degree">max_degree</code></td>
<td>
<p>The highest order of interaction terms for which the basis
functions ought to be generated. The default (<code>NULL</code>) corresponds to
generating basis functions for the full dimensionality of the input matrix.</p>
</td></tr>
<tr><td><code id="enumerate_basis_+3A_smoothness_orders">smoothness_orders</code></td>
<td>
<p>An integer vector of length <code>ncol(x)</code>
specifying the desired smoothness of the function in each covariate. k = 0
is no smoothness (indicator basis), k = 1 is first order smoothness, and so
on. For an additive model, the component function for each covariate will
have the degree of smoothness as specified by smoothness_orders. For
non-additive components (tensor products of univariate basis functions),
the univariate basis functions in each tensor product have smoothness
degree as specified by smoothness_orders.</p>
</td></tr>
<tr><td><code id="enumerate_basis_+3A_include_zero_order">include_zero_order</code></td>
<td>
<p>A <code>logical</code>, indicating whether the zeroth
order basis functions are included for each covariate (if <code>TRUE</code>), in
addition to the smooth basis functions given by <code>smoothness_orders</code>.
This allows the algorithm to data-adaptively choose the appropriate degree
of smoothness.</p>
</td></tr>
<tr><td><code id="enumerate_basis_+3A_include_lower_order">include_lower_order</code></td>
<td>
<p>A <code>logical</code>, like <code>include_zero_order</code>,
except including all basis functions of lower smoothness degrees than
specified via <code>smoothness_orders</code>.</p>
</td></tr>
<tr><td><code id="enumerate_basis_+3A_num_knots">num_knots</code></td>
<td>
<p>A vector of length <code>max_degree</code>, which determines how
granular the knot points to generate basis functions should be for each
degree of basis function. The first entry of <code>num_knots</code> determines
the number of knot points to be used for each univariate basis function.
More generally, The kth entry of <code>num_knots</code> determines the number of
knot points to be used for the kth degree basis functions. Specifically,
for a kth degree basis function, which is the tensor product of k
univariate basis functions, this determines the number of knot points to be
used for each univariate basis function in the tensor product.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of basis functions generated for all covariates and
interaction thereof up to a pre-specified degree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gendata &lt;- function(n) {
  W1 &lt;- runif(n, -3, 3)
  W2 &lt;- rnorm(n)
  W3 &lt;- runif(n)
  W4 &lt;- rnorm(n)
  g0 &lt;- plogis(0.5 * (-0.8 * W1 + 0.39 * W2 + 0.08 * W3 - 0.12 * W4))
  A &lt;- rbinom(n, 1, g0)
  Q0 &lt;- plogis(0.15 * (2 * A + 2 * A * W1 + 6 * A * W3 * W4 - 3))
  Y &lt;- rbinom(n, 1, Q0)
  data.frame(A, W1, W2, W3, W4, Y)
}
set.seed(1234)
data &lt;- gendata(100)
covars &lt;- setdiff(names(data), "Y")
X &lt;- as.matrix(data[, covars, drop = FALSE])
basis_list &lt;- enumerate_basis(X)


</code></pre>

<hr>
<h2 id='enumerate_edge_basis'>Enumerate Basis Functions at Generalized Edges</h2><span id='topic+enumerate_edge_basis'></span>

<h3>Description</h3>

<p>For degrees of smoothness greater than 1, we must generate the lower order
smoothness basis functions using the knot points at the &quot;edge&quot; of the
hypercube. For example, consider f(x) = x^2 + x, which is second-order
smooth, but will not be generated by purely quadratic basis functions. We
also need to include the y = x function (which corresponds to first-order
HAL basis functions at the left most value/edge of x).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enumerate_edge_basis(
  x,
  max_degree = 3,
  smoothness_orders = rep(0, ncol(x)),
  include_zero_order = FALSE,
  include_lower_order = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enumerate_edge_basis_+3A_x">x</code></td>
<td>
<p>An input <code>matrix</code> containing observations and covariates
following standard conventions in problems of statistical learning.</p>
</td></tr>
<tr><td><code id="enumerate_edge_basis_+3A_max_degree">max_degree</code></td>
<td>
<p>The highest order of interaction terms for which the basis
functions ought to be generated. The default (<code>NULL</code>) corresponds to
generating basis functions for the full dimensionality of the input matrix.</p>
</td></tr>
<tr><td><code id="enumerate_edge_basis_+3A_smoothness_orders">smoothness_orders</code></td>
<td>
<p>An integer vector of length <code>ncol(x)</code>
specifying the desired smoothness of the function in each covariate. k = 0
is no smoothness (indicator basis), k = 1 is first order smoothness, and so
on. For an additive model, the component function for each covariate will
have the degree of smoothness as specified by smoothness_orders. For
non-additive components (tensor products of univariate basis functions),
the univariate basis functions in each tensor product have smoothness
degree as specified by smoothness_orders.</p>
</td></tr>
<tr><td><code id="enumerate_edge_basis_+3A_include_zero_order">include_zero_order</code></td>
<td>
<p>A <code>logical</code>, indicating whether the zeroth
order basis functions are included for each covariate (if <code>TRUE</code>), in
addition to the smooth basis functions given by <code>smoothness_orders</code>.
This allows the algorithm to data-adaptively choose the appropriate degree
of smoothness.</p>
</td></tr>
<tr><td><code id="enumerate_edge_basis_+3A_include_lower_order">include_lower_order</code></td>
<td>
<p>A <code>logical</code>, like <code>include_zero_order</code>,
except including all basis functions of lower smoothness degrees than
specified via <code>smoothness_orders</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='evaluate_basis'>Generate Basis Functions</h2><span id='topic+evaluate_basis'></span>

<h3>Description</h3>

<p>Populates a column (indexed by basis_col) of x_basis with basis indicators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_basis(basis, X, x_basis, basis_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_basis_+3A_basis">basis</code></td>
<td>
<p>The basis function.</p>
</td></tr>
<tr><td><code id="evaluate_basis_+3A_x">X</code></td>
<td>
<p>The design matrix, containing the original data.</p>
</td></tr>
<tr><td><code id="evaluate_basis_+3A_x_basis">x_basis</code></td>
<td>
<p>The HAL design matrix, containing indicator functions.</p>
</td></tr>
<tr><td><code id="evaluate_basis_+3A_basis_col">basis_col</code></td>
<td>
<p>Numeric indicating which column to populate.</p>
</td></tr>
</table>

<hr>
<h2 id='fit_hal'>HAL: The Highly Adaptive Lasso</h2><span id='topic+fit_hal'></span>

<h3>Description</h3>

<p>Estimation procedure for HAL, the Highly Adaptive Lasso
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hal(
  X,
  Y,
  formula = NULL,
  X_unpenalized = NULL,
  max_degree = ifelse(ncol(X) &gt;= 20, 2, 3),
  smoothness_orders = 1,
  num_knots = num_knots_generator(max_degree = max_degree, smoothness_orders =
    smoothness_orders, base_num_knots_0 = 200, base_num_knots_1 = 50),
  reduce_basis = NULL,
  family = c("gaussian", "binomial", "poisson", "cox", "mgaussian"),
  lambda = NULL,
  id = NULL,
  weights = NULL,
  offset = NULL,
  fit_control = list(cv_select = TRUE, use_min = TRUE, lambda.min.ratio = 1e-04,
    prediction_bounds = "default"),
  basis_list = NULL,
  return_lasso = TRUE,
  return_x_basis = FALSE,
  yolo = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hal_+3A_x">X</code></td>
<td>
<p>An input <code>matrix</code> with dimensions number of observations -by-
number of covariates that will be used to derive the design matrix of basis
functions.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_y">Y</code></td>
<td>
<p>A <code>numeric</code> vector of observations of the outcome variable. For
<code>family="mgaussian"</code>, <code>Y</code> is a matrix of observations of the
outcome variables.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_formula">formula</code></td>
<td>
<p>A character string formula to be used in
<code><a href="#topic+formula_hal">formula_hal</a></code>. See its documentation for details.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_x_unpenalized">X_unpenalized</code></td>
<td>
<p>An input <code>matrix</code> with the same number of rows as
<code>X</code>, for which no L1 penalization will be performed. Note that
<code>X_unpenalized</code> is directly appended to the design matrix; no basis
expansion is performed on <code>X_unpenalized</code>.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_max_degree">max_degree</code></td>
<td>
<p>The highest order of interaction terms for which basis
functions ought to be generated.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_smoothness_orders">smoothness_orders</code></td>
<td>
<p>An <code>integer</code>, specifying the smoothness of the
basis functions. See details for <code>smoothness_orders</code> for more
information.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_num_knots">num_knots</code></td>
<td>
<p>An <code>integer</code> vector of length 1 or <code>max_degree</code>,
specifying the maximum number of knot points (i.e., bins) for any covariate
for generating basis functions. If <code>num_knots</code> is a unit-length
vector, then the same <code>num_knots</code> are used for each degree (this is
not recommended). The default settings for <code>num_knots</code> are
recommended, and these defaults decrease <code>num_knots</code> with increasing
<code>max_degree</code> and <code>smoothness_orders</code>, which prevents (expensive)
combinatorial explosions in the number of higher-degree and higher-order
basis functions generated. This allows the complexity of the optimization
problem to grow scalably. See details of <code>num_knots</code> more information.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_reduce_basis">reduce_basis</code></td>
<td>
<p>Am optional <code>numeric</code> value bounded in the open
unit interval indicating the minimum proportion of 1's in a basis function
column needed for the basis function to be included in the procedure to fit
the lasso. Any basis functions with a lower proportion of 1's than the
cutoff will be removed. Defaults to 1 over the square root of the number of
observations. Only applicable for models fit with zero-order splines, i.e.
<code>smoothness_orders = 0</code>.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_family">family</code></td>
<td>
<p>A <code>character</code> or a <code><a href="stats.html#topic+family">family</a></code> object
(supported by <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>) specifying the error/link
family for a generalized linear model. <code>character</code> options are limited
to &quot;gaussian&quot; for fitting a standard penalized linear model, &quot;binomial&quot; for
penalized logistic regression, &quot;poisson&quot; for penalized Poisson regression,
&quot;cox&quot; for a penalized proportional hazards model, and &quot;mgaussian&quot; for
multivariate penalized linear model. Note that passing in
family objects leads to slower performance relative to passing in a
character family (if supported). For example, one should set
<code>family = "binomial"</code> instead of <code>family = binomial()</code> when
calling <code>fit_hal</code>.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_lambda">lambda</code></td>
<td>
<p>User-specified sequence of values of the regularization
parameter for the lasso L1 regression. If <code>NULL</code>, the default sequence
in <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code> will be used. The cross-validated
optimal value of this regularization parameter will be selected with
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>. If <code>fit_control</code>'s <code>cv_select</code>
argument is set to <code>FALSE</code>, then the lasso model will be fit via
<code><a href="glmnet.html#topic+glmnet">glmnet</a></code>, and regularized coefficient values for each
lambda in the input array will be returned.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_id">id</code></td>
<td>
<p>A vector of ID values that is used to generate cross-validation
folds for <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>. This argument is ignored when
<code>fit_control</code>'s <code>cv_select</code> argument is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_weights">weights</code></td>
<td>
<p>observation weights; defaults to 1 per observation.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_offset">offset</code></td>
<td>
<p>a vector of offset values, used in fitting.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_fit_control">fit_control</code></td>
<td>
<p>List of arguments, including the following, and any
others to be passed to <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code> or
<code><a href="glmnet.html#topic+glmnet">glmnet</a></code>.
</p>

<ul>
<li> <p><code>cv_select</code>: A <code>logical</code> specifying if the sequence of
specified <code>lambda</code> values should be passed to
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code> in order for a single, optimal value of
<code>lambda</code> to be selected according to cross-validation. When
<code>cv_select = FALSE</code>, a <code><a href="glmnet.html#topic+glmnet">glmnet</a></code> model will be
used to fit the sequence of (or single) <code>lambda</code>.
</p>
</li>
<li> <p><code>use_min</code>: Specify the choice of lambda to be selected by
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>. When <code>TRUE</code>, <code>"lambda.min"</code> is
used; otherwise, <code>"lambda.1se"</code>. Only used when
<code>cv_select = TRUE</code>.
</p>
</li>
<li> <p><code>lambda.min.ratio</code>: A <code><a href="glmnet.html#topic+glmnet">glmnet</a></code> argument
specifying the smallest value for <code>lambda</code>, as a fraction of
<code>lambda.max</code>, the (data derived) entry value (i.e. the smallest value
for which all coefficients are zero). We've seen that not setting
<code>lambda.min.ratio</code> can lead to no <code>lambda</code> values that fit the
data sufficiently well.
</p>
</li>
<li> <p><code>prediction_bounds</code>: An optional vector of size two that provides
the lower and upper bounds predictions; not used when
<code>family = "cox"</code>. When <code>prediction_bounds = "default"</code>, the
predictions are bounded between <code>min(Y) - sd(Y)</code> and
<code>max(Y) + sd(Y)</code> for each outcome (when <code>family = "mgaussian"</code>,
each outcome can have different bounds). Bounding ensures that there is
no extrapolation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_hal_+3A_basis_list">basis_list</code></td>
<td>
<p>The full set of basis functions generated from <code>X</code>.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_return_lasso">return_lasso</code></td>
<td>
<p>A <code>logical</code> indicating whether or not to return
the <code><a href="glmnet.html#topic+glmnet">glmnet</a></code> fit object of the lasso model.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_return_x_basis">return_x_basis</code></td>
<td>
<p>A <code>logical</code> indicating whether or not to return
the matrix of (possibly reduced) basis functions used in <code>fit_hal</code>.</p>
</td></tr>
<tr><td><code id="fit_hal_+3A_yolo">yolo</code></td>
<td>
<p>A <code>logical</code> indicating whether to print one of a curated
selection of quotes from the HAL9000 computer, from the critically
acclaimed epic science-fiction film &quot;2001: A Space Odyssey&quot; (1968).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure uses a custom C++ implementation to generate a design
matrix of spline basis functions of covariates and interactions of
covariates. The lasso regression is fit to this design matrix via
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code> or a custom implementation derived from
<span class="pkg">origami</span>. The maximum dimension of the design matrix is <code class="reqn">n</code> -by-
<code class="reqn">(n * 2^(d-1))</code>, where where <code class="reqn">n</code> is the number of observations and
<code class="reqn">d</code> is the number of covariates.
</p>
<p>For <code>smoothness_orders = 0</code>, only zero-order splines (piece-wise
constant) are generated, which assume the true regression function has no
smoothness or continuity. When <code>smoothness_orders = 1</code>, first-order
splines (piece-wise linear) are generated, which assume continuity of the
true regression function. When <code>smoothness_orders = 2</code>, second-order
splines (piece-wise quadratic and linear terms) are generated, which assume
a the true regression function has a single order of differentiability.
</p>
<p><code>num_knots</code> argument specifies the number of knot points for each
covariate and for each <code>max_degree</code>. Fewer knot points can
significantly decrease runtime, but might be overly simplistic. When
considering <code>smoothness_orders = 0</code>, too few knot points (e.g., &lt; 50)
can significantly reduce performance. When <code>smoothness_orders = 1</code> or
higher, then fewer knot points (e.g., 10-30) is actually better for
performance. We recommend specifying <code>num_knots</code> with respect to
<code>smoothness_orders</code>, and as a vector of length <code>max_degree</code> with
values decreasing exponentially. This prevents combinatorial explosions in
the number of higher-degree basis functions generated. The default behavior
of <code>num_knots</code> follows this logic &mdash; for <code>smoothness_orders = 0</code>,
<code>num_knots</code> is set to <code class="reqn">500 / 2^{j-1}</code>, and for
<code>smoothness_orders = 1</code> or higher, <code>num_knots</code> is set to
<code class="reqn">200 / 2^{j-1}</code>, where <code class="reqn">j</code> is the interaction degree. We also
include some other suitable settings for <code>num_knots</code> below, all of
which are less complex than default <code>num_knots</code> and will thus result
in a faster runtime:
</p>

<ul>
<li><p> Some good settings for little to no cost in performance:
</p>

<ul>
<li><p> If <code>smoothness_orders = 0</code> and <code>max_degree = 3</code>,
<code>num_knots = c(400, 200, 100)</code>.
</p>
</li>
<li><p> If <code>smoothness_orders = 1+</code> and <code>max_degree = 3</code>,
<code>num_knots = c(100, 75, 50)</code>.
</p>
</li></ul>

</li>
<li><p> Recommended settings for fairly fast runtime:
</p>

<ul>
<li><p> If <code>smoothness_orders = 0</code> and <code>max_degree = 3</code>,
<code>num_knots = c(200, 100, 50)</code>.
</p>
</li>
<li><p> If <code>smoothness_orders = 1+</code> and <code>max_degree = 3</code>,
<code>num_knots = c(50, 25, 15)</code>.
</p>
</li></ul>

</li>
<li><p> Recommended settings for fast runtime:
</p>

<ul>
<li><p> If <code>smoothness_orders = 0</code> and <code>max_degree = 3</code>,
<code>num_knots = c(100, 50, 25)</code>.
</p>
</li>
<li><p> If <code>smoothness_orders = 1+</code> and <code>max_degree = 3</code>,
<code>num_knots = c(40, 15, 10)</code>.
</p>
</li></ul>

</li>
<li><p> Recommended settings for very fast runtime:
</p>

<ul>
<li><p> If <code>smoothness_orders = 0</code> and <code>max_degree = 3</code>,
<code>num_knots = c(50, 25, 10)</code>.
</p>
</li>
<li><p> If <code>smoothness_orders = 1+</code> and <code>max_degree = 3</code>,
<code>num_knots = c(25, 10, 5)</code>.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>Object of class <code>hal9001</code>, containing a list of basis
functions, a copy map, coefficients estimated for basis functions, and
timing results (for assessing computational efficiency).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 3
x &lt;- xmat &lt;- matrix(rnorm(n * p), n, p)
y_prob &lt;- plogis(3 * sin(x[, 1]) + sin(x[, 2]))
y &lt;- rbinom(n = n, size = 1, prob = y_prob)
hal_fit &lt;- fit_hal(X = x, Y = y, family = "binomial")
preds &lt;- predict(hal_fit, new_data = x)
</code></pre>

<hr>
<h2 id='formula_hal'>HAL Formula: Convert formula or string to <code>formula_HAL</code> object.</h2><span id='topic+formula_hal'></span>

<h3>Description</h3>

<p>HAL Formula: Convert formula or string to <code>formula_HAL</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_hal(formula, smoothness_orders, num_knots, X = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula_hal_+3A_formula">formula</code></td>
<td>
<p>A <code>formula_hal9001</code> object as outputted by <code>h</code>.</p>
</td></tr>
<tr><td><code id="formula_hal_+3A_smoothness_orders">smoothness_orders</code></td>
<td>
<p>A default value for <code>s</code> if not provided
explicitly to the function <code>h</code>.</p>
</td></tr>
<tr><td><code id="formula_hal_+3A_num_knots">num_knots</code></td>
<td>
<p>A default value for <code>k</code> if not provided explicitly to
the function <code>h</code>.</p>
</td></tr>
<tr><td><code id="formula_hal_+3A_x">X</code></td>
<td>
<p>Controls inheritance of the variable <code>X</code> from parent environment.
When <code>NULL</code> (the default), such a variable is inherited.</p>
</td></tr>
</table>

<hr>
<h2 id='generate_all_rules'>Generates rules based on knot points of the fitted HAL basis functions with
non-zero coefficients.</h2><span id='topic+generate_all_rules'></span>

<h3>Description</h3>

<p>Generates rules based on knot points of the fitted HAL basis functions with
non-zero coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_all_rules(basis_list, coefs, X_colnames)
</code></pre>

<hr>
<h2 id='h'>HAL Formula term: Generate a single term of the HAL basis</h2><span id='topic+h'></span>

<h3>Description</h3>

<p>HAL Formula term: Generate a single term of the HAL basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h(
  ...,
  k = NULL,
  s = NULL,
  pf = 1,
  monotone = c("none", "i", "d"),
  . = NULL,
  dot_args_as_string = FALSE,
  X = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_+3A_...">...</code></td>
<td>
<p>Variables for which to generate multivariate interaction basis
function where the variables can be found in a matrix <code>X</code> in a parent
environment/frame. Note, just like standard <code>formula</code> objects, the
variables should not be characters (e.g. do h(W1,W2) not h(&quot;W1&quot;, &quot;W2&quot;))
h(W1,W2,W3) will generate three-way HAL basis functions between W1, W2, and
W3. It will <code>not</code> generate the lower dimensional basis functions.</p>
</td></tr>
<tr><td><code id="h_+3A_k">k</code></td>
<td>
<p>The number of knots for each univariate basis function used to
generate the tensor product basis functions. If a single value then this
value is used for the univariate basis functions for each variable.
Otherwise, this should be a variable named list that specifies for each
variable how many knots points should be used.
<code>h(W1,W2,W3, k = list(W1 = 3, W2 = 2, W3=1))</code> is equivalent to first
binning the variables <code>W1</code>, <code>W2</code> and <code>W3</code> into <code>3</code>, <code>2</code> and <code>1</code> unique
values and then calling <code>h(W1,W2,W3)</code>. This coarsening of the data ensures
that fewer basis functions are generated, which can lead to substantial
computational speed-ups. If not provided and the variable <code>num_knots</code>
is in the parent environment, then <code>s</code> will be set to
<code>num_knots</code>'.</p>
</td></tr>
<tr><td><code id="h_+3A_s">s</code></td>
<td>
<p>The <code>smoothness_orders</code> for the basis functions. The possible
values are <code>0</code> for piece-wise constant zero-order splines or <code>1</code> for
piece-wise linear first-order splines. If not provided and the variable
<code>smoothness_orders</code> is in the parent environment, then <code>s</code> will
be set to <code>smoothness_orders</code>.</p>
</td></tr>
<tr><td><code id="h_+3A_pf">pf</code></td>
<td>
<p>A <code>penalty.factor</code> value the generated basis functions that is
used by <code>glmnet</code> in the LASSO penalization procedure. <code>pf = 1</code>
(default) is the standard penalization factor used by <code>glmnet</code> and
<code>pf = 0</code> means the generated basis functions are unpenalized.</p>
</td></tr>
<tr><td><code id="h_+3A_monotone">monotone</code></td>
<td>
<p>Whether the basis functions should enforce monotonicity of
the interaction term. If <code style="white-space: pre;">&#8288;\code{s} = 0&#8288;</code>, this is monotonicity of the
function, and, if <code style="white-space: pre;">&#8288;\code{s} = 1&#8288;</code>, this is monotonicity of its derivative
(e.g., enforcing a convex fit). Set <code>"none"</code> for no constraints, <code>"i"</code> for
a monotone increasing constraint, and <code>"d"</code> for a monotone decreasing
constraint. Using <code>"i"</code> constrains the basis functions to have positive
coefficients in the fit, and <code>"d"</code> constrains the basis functions to have
negative coefficients.</p>
</td></tr>
<tr><td><code id="h_+3A_.">.</code></td>
<td>
<p>Just like with <code>formula</code>, <code>.</code> as in <code>h(.)</code> or <code>h(.,.)</code> is
treated as a wildcard variable that generates terms using all variables in
the data. The argument <code>.</code> should be a character vector of variable
names that <code>.</code> iterates over. Specifically,
<code>h(., k=1, . = c("W1", "W2", "W3"))</code> is equivalent to
<code>h(W1, k=1) + h(W2, k=1) + h(W3, k=1)</code>, and
<code>h(., .,  k=1, . = c("W1", "W2", "W3"))</code> is equivalent to
<code>h(W1,W2, k=1) + h(W2,W3, k=1) + h(W1, W3, k=1)</code></p>
</td></tr>
<tr><td><code id="h_+3A_dot_args_as_string">dot_args_as_string</code></td>
<td>
<p>Whether the arguments <code>...</code> are characters or
character vectors and should thus be evaluated directly. When <code>TRUE</code>, the
expression h(&quot;W1&quot;, &quot;W2&quot;) can be used.</p>
</td></tr>
<tr><td><code id="h_+3A_x">X</code></td>
<td>
<p>An optional design matrix where the variables given in <code>...</code>
can be found. Otherwise, <code>X</code> is taken from the parent environment.</p>
</td></tr>
</table>

<hr>
<h2 id='hal_quotes'>HAL9000 Quotes from &quot;2001: A Space Odyssey&quot;</h2><span id='topic+hal_quotes'></span>

<h3>Description</h3>

<p>Curated selection of quotes from the HAL9000 computer, from the critically
acclaimed epic science-fiction film &quot;2001: A Space Odyssey&quot; (1968).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hal_quotes
</code></pre>


<h3>Format</h3>

<p>A vector of quotes.
</p>

<hr>
<h2 id='hal9000'>HAL 9000 Quotes</h2><span id='topic+hal9000'></span>

<h3>Description</h3>

<p>Prints a quote from the HAL 9000 robot from 2001: A Space Odyssey
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hal9000()
</code></pre>

<hr>
<h2 id='hal9001'>hal9001</h2><span id='topic+hal9001'></span>

<h3>Description</h3>

<p>Package for fitting the Highly Adaptive LASSO (HAL) estimator
</p>

<hr>
<h2 id='index_first_copy'>Find Copies of Columns</h2><span id='topic+index_first_copy'></span>

<h3>Description</h3>

<p>Index vector that, for each column in X, indicates the index of the first
copy of that column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_first_copy(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_first_copy_+3A_x">X</code></td>
<td>
<p>Sparse matrix containing columns of indicator functions.</p>
</td></tr>
</table>

<hr>
<h2 id='make_basis_list'>Sort Basis Functions</h2><span id='topic+make_basis_list'></span>

<h3>Description</h3>

<p>Build a sorted list of unique basis functions based on columns, where each
basis function is a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_basis_list(X_sub, cols, order_map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_basis_list_+3A_x_sub">X_sub</code></td>
<td>
<p>A subset of the columns of X, the original design matrix.</p>
</td></tr>
<tr><td><code id="make_basis_list_+3A_cols">cols</code></td>
<td>
<p>An index of the columns that were reduced to by sub-setting.</p>
</td></tr>
<tr><td><code id="make_basis_list_+3A_order_map">order_map</code></td>
<td>
<p>A vector with length the original unsubsetted matrix X which specifies the smoothness of the function in each covariate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that sorting of columns is performed such that the basis order
equals cols.length() and each basis function is a list(cols, cutoffs).
</p>

<hr>
<h2 id='make_copy_map'>Build Copy Maps</h2><span id='topic+make_copy_map'></span>

<h3>Description</h3>

<p>Build Copy Maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_copy_map(x_basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_copy_map_+3A_x_basis">x_basis</code></td>
<td>
<p>A design matrix consisting of basis (indicator) functions for
covariates (X) and terms for interactions thereof.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of <code>numeric</code> vectors indicating indices of basis
functions that are identical in the training set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gendata &lt;- function(n) {
  W1 &lt;- runif(n, -3, 3)
  W2 &lt;- rnorm(n)
  W3 &lt;- runif(n)
  W4 &lt;- rnorm(n)
  g0 &lt;- plogis(0.5 * (-0.8 * W1 + 0.39 * W2 + 0.08 * W3 - 0.12 * W4))
  A &lt;- rbinom(n, 1, g0)
  Q0 &lt;- plogis(0.15 * (2 * A + 2 * A * W1 + 6 * A * W3 * W4 - 3))
  Y &lt;- rbinom(n, 1, Q0)
  data.frame(A, W1, W2, W3, W4, Y)
}
set.seed(1234)
data &lt;- gendata(100)
covars &lt;- setdiff(names(data), "Y")
X &lt;- as.matrix(data[, covars, drop = FALSE])
basis_list &lt;- enumerate_basis(X)
x_basis &lt;- make_design_matrix(X, basis_list)
copy_map &lt;- make_copy_map(x_basis)


</code></pre>

<hr>
<h2 id='make_design_matrix'>Build HAL Design Matrix</h2><span id='topic+make_design_matrix'></span>

<h3>Description</h3>

<p>Make a HAL design matrix based on original design matrix X and a list of
basis functions in argument blist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_design_matrix(X, blist, p_reserve = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_design_matrix_+3A_x">X</code></td>
<td>
<p>Matrix of covariates containing observed data in the columns.</p>
</td></tr>
<tr><td><code id="make_design_matrix_+3A_blist">blist</code></td>
<td>
<p>List of basis functions with which to build HAL design matrix.</p>
</td></tr>
<tr><td><code id="make_design_matrix_+3A_p_reserve">p_reserve</code></td>
<td>
<p>Sparse matrix pre-allocation proportion. Default value is 0.5.
If one expects a dense HAL design matrix, it is useful to set p_reserve to a higher value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dgCMatrix</code> sparse matrix of indicator basis functions
corresponding to the design matrix in a zero-order highly adaptive lasso.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gendata &lt;- function(n) {
  W1 &lt;- runif(n, -3, 3)
  W2 &lt;- rnorm(n)
  W3 &lt;- runif(n)
  W4 &lt;- rnorm(n)
  g0 &lt;- plogis(0.5 * (-0.8 * W1 + 0.39 * W2 + 0.08 * W3 - 0.12 * W4))
  A &lt;- rbinom(n, 1, g0)
  Q0 &lt;- plogis(0.15 * (2 * A + 2 * A * W1 + 6 * A * W3 * W4 - 3))
  Y &lt;- rbinom(n, 1, Q0)
  data.frame(A, W1, W2, W3, W4, Y)
}
set.seed(1234)
data &lt;- gendata(100)
covars &lt;- setdiff(names(data), "Y")
X &lt;- as.matrix(data[, covars, drop = FALSE])
basis_list &lt;- enumerate_basis(X)
x_basis &lt;- make_design_matrix(X, basis_list)


</code></pre>

<hr>
<h2 id='make_reduced_basis_map'>Mass-based reduction of basis functions</h2><span id='topic+make_reduced_basis_map'></span>

<h3>Description</h3>

<p>A helper function that finds which basis functions to keep (and equivalently
which to discard) based on the proportion of 1's (observations, i.e.,
&quot;mass&quot;) included in a given basis function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_reduced_basis_map(x_basis, reduce_basis_crit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_reduced_basis_map_+3A_x_basis">x_basis</code></td>
<td>
<p>A matrix of basis functions with all redundant basis
functions already removed.</p>
</td></tr>
<tr><td><code id="make_reduced_basis_map_+3A_reduce_basis_crit">reduce_basis_crit</code></td>
<td>
<p>A scalar <code>numeric</code> value bounded in the open
interval (0,1) indicating the minimum proportion of 1's in a basis function
column needed for the basis function to be included in the procedure to fit
the Lasso. Any basis functions with a lower proportion of 1's than the
specified cutoff will be removed. This argument defaults to <code>NULL</code>, in
which case all basis functions are used in the lasso-fitting stage of the
HAL algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary <code>numeric</code> vector indicating which columns of the
matrix of basis functions to keep (given a one) and which to discard (given
a zero).
</p>

<hr>
<h2 id='meets_basis'>Compute Values of Basis Functions</h2><span id='topic+meets_basis'></span>

<h3>Description</h3>

<p>Computes and returns the indicator value for the basis described by
cols and cutoffs for a given row of X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meets_basis(X, row_num, cols, cutoffs, orders)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meets_basis_+3A_x">X</code></td>
<td>
<p>The design matrix, containing the original data.</p>
</td></tr>
<tr><td><code id="meets_basis_+3A_row_num">row_num</code></td>
<td>
<p>Numeri for  a row index over which to evaluate.</p>
</td></tr>
<tr><td><code id="meets_basis_+3A_cols">cols</code></td>
<td>
<p>Numeric for the column indices of the basis function.</p>
</td></tr>
<tr><td><code id="meets_basis_+3A_cutoffs">cutoffs</code></td>
<td>
<p>Numeric providing thresholds.</p>
</td></tr>
<tr><td><code id="meets_basis_+3A_orders">orders</code></td>
<td>
<p>Numeric providing smoothness orders</p>
</td></tr>
</table>

<hr>
<h2 id='num_knots_generator'>A default generator for the <code>num_knots</code> argument for each degree of
interactions and the smoothness orders.</h2><span id='topic+num_knots_generator'></span>

<h3>Description</h3>

<p>A default generator for the <code>num_knots</code> argument for each degree of
interactions and the smoothness orders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_knots_generator(
  max_degree,
  smoothness_orders,
  base_num_knots_0 = 500,
  base_num_knots_1 = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_knots_generator_+3A_max_degree">max_degree</code></td>
<td>
<p>interaction degree.</p>
</td></tr>
<tr><td><code id="num_knots_generator_+3A_smoothness_orders">smoothness_orders</code></td>
<td>
<p>see <code><a href="#topic+fit_hal">fit_hal</a></code>.</p>
</td></tr>
<tr><td><code id="num_knots_generator_+3A_base_num_knots_0">base_num_knots_0</code></td>
<td>
<p>The base number of knots for zeroth-order smoothness
basis functions. The number of knots by degree interaction decays as
<code>base_num_knots_0/2^(d-1)</code> where <code>d</code> is the interaction degree of the basis
function.</p>
</td></tr>
<tr><td><code id="num_knots_generator_+3A_base_num_knots_1">base_num_knots_1</code></td>
<td>
<p>The base number of knots for 1 or greater order
smoothness basis functions. The number of knots by degree interaction
decays as <code>base_num_knots_1/2^(d-1)</code> where <code>d</code> is the interaction degree of
the basis function.</p>
</td></tr>
</table>

<hr>
<h2 id='predict.hal9001'>Prediction from HAL fits</h2><span id='topic+predict.hal9001'></span>

<h3>Description</h3>

<p>Prediction from HAL fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hal9001'
predict(
  object,
  new_data,
  new_X_unpenalized = NULL,
  offset = NULL,
  type = c("response", "link"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hal9001_+3A_object">object</code></td>
<td>
<p>An object of class <code>hal9001</code>, containing the results of
fitting the Highly Adaptive Lasso, as produced by <code><a href="#topic+fit_hal">fit_hal</a></code>.</p>
</td></tr>
<tr><td><code id="predict.hal9001_+3A_new_data">new_data</code></td>
<td>
<p>A <code>matrix</code> or <code>data.frame</code> containing new data
(i.e., observations not used for fitting the <code>hal9001</code> object that's
passed in via the <code>object</code> argument) for which the <code>hal9001</code>
object will compute predicted values.</p>
</td></tr>
<tr><td><code id="predict.hal9001_+3A_new_x_unpenalized">new_X_unpenalized</code></td>
<td>
<p>If the user supplied <code>X_unpenalized</code> during
training, then user should also supply this matrix with the same number of
observations as <code>new_data</code>.</p>
</td></tr>
<tr><td><code id="predict.hal9001_+3A_offset">offset</code></td>
<td>
<p>A vector of offsets. Must be provided if provided at training.</p>
</td></tr>
<tr><td><code id="predict.hal9001_+3A_type">type</code></td>
<td>
<p>Either &quot;response&quot; for predictions of the response, or &quot;link&quot; for
un-transformed predictions (on the scale of the link function).</p>
</td></tr>
<tr><td><code id="predict.hal9001_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>predict</code> as necessary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method for computing and extracting predictions from fits of the
Highly Adaptive Lasso estimator, returned as a single S3 objects of class
<code>hal9001</code>.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> vector of predictions from a <code>hal9001</code> object.
</p>


<h3>Note</h3>

<p>This prediction method does not function similarly to the equivalent
method from <span class="pkg">glmnet</span>. In particular, this procedure will not return a
subset of lambdas originally specified in calling <code><a href="#topic+fit_hal">fit_hal</a></code>
nor result in re-fitting. Instead, it will return predictions for all of
the lambdas specified in the call to <code><a href="#topic+fit_hal">fit_hal</a></code> that constructs
<code>object</code>, when <code>fit_control</code>'s <code>cv_select</code> is set to
<code>FALSE</code>. When <code>fit_control</code>'s <code>cv_select</code> is set to
<code>TRUE</code>, predictions will only be returned for the value of lambda
selected by cross-validation.
</p>

<hr>
<h2 id='predict.SL.hal9001'>predict.SL.hal9001</h2><span id='topic+predict.SL.hal9001'></span>

<h3>Description</h3>

<p>Predict method for objects of class <code>SL.hal9001</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SL.hal9001'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.SL.hal9001_+3A_object">object</code></td>
<td>
<p>A fitted object of class <code>hal9001</code>.</p>
</td></tr>
<tr><td><code id="predict.SL.hal9001_+3A_newdata">newdata</code></td>
<td>
<p>A matrix of new observations on which to obtain predictions.</p>
</td></tr>
<tr><td><code id="predict.SL.hal9001_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector of predictions from a <code>SL.hal9001</code>
object based on the provide <code>newdata</code>.
</p>

<hr>
<h2 id='print.formula_hal9001'>Print formula_hal9001 object</h2><span id='topic+print.formula_hal9001'></span>

<h3>Description</h3>

<p>Print formula_hal9001 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula_hal9001'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.formula_hal9001_+3A_x">x</code></td>
<td>
<p>A formula_hal9001 object.</p>
</td></tr>
<tr><td><code id="print.formula_hal9001_+3A_...">...</code></td>
<td>
<p>Other arguments (ignored).</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.hal9001'>Print Method for Summary Class of HAL fits</h2><span id='topic+print.summary.hal9001'></span>

<h3>Description</h3>

<p>Print Method for Summary Class of HAL fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.hal9001'
print(x, length = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.hal9001_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.hal9001</code>.</p>
</td></tr>
<tr><td><code id="print.summary.hal9001_+3A_length">length</code></td>
<td>
<p>The number of ranked coefficients to be summarized.</p>
</td></tr>
<tr><td><code id="print.summary.hal9001_+3A_...">...</code></td>
<td>
<p>Other arguments (ignored).</p>
</td></tr>
</table>

<hr>
<h2 id='quantizer'>Discretize Variables into Number of Bins by Unique Values</h2><span id='topic+quantizer'></span>

<h3>Description</h3>

<p>Discretize Variables into Number of Bins by Unique Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantizer(X, bins)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantizer_+3A_x">X</code></td>
<td>
<p>A <code>numeric</code> vector to be discretized.</p>
</td></tr>
<tr><td><code id="quantizer_+3A_bins">bins</code></td>
<td>
<p>A <code>numeric</code> scalar indicating the number of bins into which
<code>X</code> should be discretized..</p>
</td></tr>
</table>

<hr>
<h2 id='SL.hal9001'>Wrapper for Classic SuperLearner</h2><span id='topic+SL.hal9001'></span>

<h3>Description</h3>

<p>Wrapper for <span class="pkg">SuperLearner</span> for objects of class <code>hal9001</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SL.hal9001(
  Y,
  X,
  newX,
  family,
  obsWeights,
  id,
  max_degree = 2,
  smoothness_orders = 1,
  num_knots = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SL.hal9001_+3A_y">Y</code></td>
<td>
<p>A <code>numeric</code> vector of observations of the outcome variable.</p>
</td></tr>
<tr><td><code id="SL.hal9001_+3A_x">X</code></td>
<td>
<p>An input <code>matrix</code> with dimensions number of observations -by-
number of covariates that will be used to derive the design matrix of basis
functions.</p>
</td></tr>
<tr><td><code id="SL.hal9001_+3A_newx">newX</code></td>
<td>
<p>A matrix of new observations on which to obtain predictions. The
default of <code>NULL</code> computes predictions on training inputs <code>X</code>.</p>
</td></tr>
<tr><td><code id="SL.hal9001_+3A_family">family</code></td>
<td>
<p>A <code><a href="stats.html#topic+family">family</a></code> object (one that is supported
by <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>) specifying the error/link family for a
generalized linear model.</p>
</td></tr>
<tr><td><code id="SL.hal9001_+3A_obsweights">obsWeights</code></td>
<td>
<p>A <code>numeric</code> vector of observational-level weights.</p>
</td></tr>
<tr><td><code id="SL.hal9001_+3A_id">id</code></td>
<td>
<p>A <code>numeric</code> vector of IDs.</p>
</td></tr>
<tr><td><code id="SL.hal9001_+3A_max_degree">max_degree</code></td>
<td>
<p>The highest order of interaction terms for which basis
functions ought to be generated.</p>
</td></tr>
<tr><td><code id="SL.hal9001_+3A_smoothness_orders">smoothness_orders</code></td>
<td>
<p>An <code>integer</code> vector of length 1 or greater,
specifying the smoothness of the basis functions. See the argument
<code>smoothness_orders</code> of <code><a href="#topic+fit_hal">fit_hal</a></code> for more information.</p>
</td></tr>
<tr><td><code id="SL.hal9001_+3A_num_knots">num_knots</code></td>
<td>
<p>An <code>integer</code> vector of length 1 or <code>max_degree</code>,
specifying the maximum number of knot points (i.e., bins) for each
covariate for generating basis functions. See <code>num_knots</code> argument in
<code><a href="#topic+fit_hal">fit_hal</a></code> for more information.</p>
</td></tr>
<tr><td><code id="SL.hal9001_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+fit_hal">fit_hal</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SL.hal9001</code> with a fitted <code>hal9001</code>
object and corresponding predictions based on the input data.
</p>

<hr>
<h2 id='squash_hal_fit'>Squash HAL objects</h2><span id='topic+squash_hal_fit'></span>

<h3>Description</h3>

<p>Reduce footprint by dropping basis functions with coefficients of zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>squash_hal_fit(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="squash_hal_fit_+3A_object">object</code></td>
<td>
<p>An object of class <code>hal9001</code>, containing the results of
fitting the Highly Adaptive LASSO, as produced by a call to <code>fit_hal</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>hal9001</code>, similar to the input object but
reduced such that coefficients belonging to bases with coefficients equal
to zero removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate simple test data
n &lt;- 100
p &lt;- 3
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- sin(x[, 1]) * sin(x[, 2]) + rnorm(n, mean = 0, sd = 0.2)

# fit HAL model and squash resulting object to reduce footprint
hal_fit &lt;- fit_hal(X = x, Y = y, yolo = FALSE)
squashed &lt;- squash_hal_fit(hal_fit)

</code></pre>

<hr>
<h2 id='summary.hal9001'>Summary Method for HAL fit objects</h2><span id='topic+summary.hal9001'></span>

<h3>Description</h3>

<p>Summary Method for HAL fit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hal9001'
summary(
  object,
  lambda = NULL,
  only_nonzero_coefs = TRUE,
  include_redundant_terms = FALSE,
  round_cutoffs = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.hal9001_+3A_object">object</code></td>
<td>
<p>An object of class <code>hal9001</code>, containing the results of
fitting the Highly Adaptive Lasso, as produced by <code><a href="#topic+fit_hal">fit_hal</a></code>.</p>
</td></tr>
<tr><td><code id="summary.hal9001_+3A_lambda">lambda</code></td>
<td>
<p>Optional <code>numeric</code> value of the lambda tuning
parameter, for which corresponding coefficient values will be summarized.
Defaults to <code><a href="#topic+fit_hal">fit_hal</a></code>'s optimal value, <code>lambda_star</code>, or
the minimum value of <code>lambda_star</code>.</p>
</td></tr>
<tr><td><code id="summary.hal9001_+3A_only_nonzero_coefs">only_nonzero_coefs</code></td>
<td>
<p>A <code>logical</code> specifying whether the summary
should include only terms with non-zero coefficients.</p>
</td></tr>
<tr><td><code id="summary.hal9001_+3A_include_redundant_terms">include_redundant_terms</code></td>
<td>
<p>A <code>logical</code> specifying whether the
summary should remove so-called &quot;redundant terms&quot;. We define a redundant
term (say x1) as a term (1) with basis function corresponding to an
existing basis function, a duplicate; and (2) the duplicate contains the
x1 term as part of its term, so that x1 terms inclusion would be redundant.
For example, say the same coefficient corresponds to these three terms:
(1) &quot;I(age &gt;= 50)*I(bmi &gt;= 18)&quot;, (2) &quot;I(age &gt;= 50)&quot;, and (3)
&quot;I(education &gt;= 16)&quot;. When <code>include_redundant_terms</code> is
<code>FALSE</code> (default), the second basis function is omitted.</p>
</td></tr>
<tr><td><code id="summary.hal9001_+3A_round_cutoffs">round_cutoffs</code></td>
<td>
<p>An <code>integer</code> indicating the number of decimal
places to be used for rounding cutoff values in the term. For example, if
&quot;bmi&quot; was numeric that was rounded to the third decimal, in the example
above we would have needed to specify <code>round_cutoffs = 0</code> in order to
yield a term like &quot;I(bmi &gt;= 18)&quot; opposed to something like
&quot;I(bmi &gt;= 18.111)&quot;. This rounding is intended to simplify the term-wise
part of the output and only rounds the basis cutoffs, the <code>hal9001</code>
model's coefficients are not rounded.</p>
</td></tr>
<tr><td><code id="summary.hal9001_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>summary</code>, not supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method for summarizing the coefficients of the Highly Adaptive
Lasso estimator in terms of the basis functions corresponding to covariates
and interactions of covariates, returned as a single S3 object of class
<code>hal9001</code>.
</p>
<p>Due to the nature of the basis function terms, the summary tables can be
extremely wide. The R environment might not be the optimal location to view
the summary. Tables can be exported from R to LaTeX with <span class="pkg">xtable</span>
package (or similar). Here's an example:
<code>print(xtable(summary(fit)$table, type = "latex"), file = "dt.tex")</code>.
</p>


<h3>Value</h3>

<p>A list summarizing a <code>hal9001</code> object's coefficients.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
