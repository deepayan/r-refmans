<!DOCTYPE html><html lang="en"><head><title>Help for package ggvis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggvis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe graphics</p></a></li>
<li><a href='#add_axis'><p>Add a vega axis specification to a ggvis plot</p></a></li>
<li><a href='#add_data'><p>Add dataset to a visualisation</p></a></li>
<li><a href='#add_guide_axis'><p>Defunct function for adding an axis</p></a></li>
<li><a href='#add_guide_legend'><p>Defunct function for adding a legend</p></a></li>
<li><a href='#add_legend'><p>Add a vega legend specification to a ggvis plot</p></a></li>
<li><a href='#add_props'><p>Add visual properties to a visualisation</p></a></li>
<li><a href='#add_relative_scales'><p>Add x_rel and y_rel scales</p></a></li>
<li><a href='#add_scale'><p>Add arbitrary scales to ggvis.</p></a></li>
<li><a href='#add_tooltip'><p>Add tooltips to a plot.</p></a></li>
<li><a href='#as.vega'><p>Coerce an ggvis object to a vega list.</p></a></li>
<li><a href='#auto_group'><p>Automatically group data by grouping variables</p></a></li>
<li><a href='#axis_props'><p>Create an axis_props object for controlling axis properties.</p></a></li>
<li><a href='#band'><p>A band</p></a></li>
<li><a href='#bin_vector'><p>Bin vectors</p></a></li>
<li><a href='#cocaine'><p>Cocaine seizures in the US.</p></a></li>
<li><a href='#compute_align'><p>Align positions using length.</p></a></li>
<li><a href='#compute_bin'><p>Bin data along a continuous variable</p></a></li>
<li><a href='#compute_boxplot'><p>Calculate boxplot values</p></a></li>
<li><a href='#compute_count'><p>Count data at each location</p></a></li>
<li><a href='#compute_density'><p>Compute density of data.</p></a></li>
<li><a href='#compute_model_prediction'><p>Create a model of a data set and compute predictions.</p></a></li>
<li><a href='#compute_stack'><p>Stack overlapping data.</p></a></li>
<li><a href='#compute_tabulate'><p>Count data at each location of a categorical variable</p></a></li>
<li><a href='#create_broker'><p>Create a broker object</p></a></li>
<li><a href='#create_input'><p>Create a new interactive &quot;input&quot; object.</p></a></li>
<li><a href='#default_options'><p>Default options</p></a></li>
<li><a href='#dplyr-ggvis'><p>Dplyr verbs for ggvis.</p></a></li>
<li><a href='#explain'><p>Explain details of an object</p></a></li>
<li><a href='#explain.ggvis'><p>Print out the structure of a ggvis object in a friendly format</p></a></li>
<li><a href='#export_png'><p>Export a PNG or SVG from a ggvis object</p></a></li>
<li><a href='#fullseq'><p>Generate sequence of fixed size intervals covering range.</p></a></li>
<li><a href='#get_data'><p>Get data from a ggvis object</p></a></li>
<li><a href='#ggvis'><p>Visualise a data set with a ggvis graphic.</p></a></li>
<li><a href='#ggvis_message'><p>Send a message to ggvis running on client</p></a></li>
<li><a href='#ggvis_scale'><p>Create a new ggvis_scale object.</p></a></li>
<li><a href='#ggvisControlOutput'><p>Create a ggvis control output element in UI</p></a></li>
<li><a href='#ggvisOutputElements'><p>Create HTML elements for ggvis output</p></a></li>
<li><a href='#group_by'><p>Divide data into groups.</p></a></li>
<li><a href='#handle_brush'><p>Handle brush events on a visualisation.</p></a></li>
<li><a href='#handle_click'><p>Handle mouse actions on marks.</p></a></li>
<li><a href='#handle_resize'><p>Handlers and interactive inputs for plot sizing.</p></a></li>
<li><a href='#input_checkbox'><p>Create an interactive checkbox.</p></a></li>
<li><a href='#input_select'><p>Create interactive control to select one (or more options) from a list.</p></a></li>
<li><a href='#input_slider'><p>Create an interactive slider.</p></a></li>
<li><a href='#input_text'><p>Create an interactive text or numeric input box.</p></a></li>
<li><a href='#is.axis_props'><p>Tests whether an object is an axis_props object</p></a></li>
<li><a href='#is.broker'><p>Determine if an object is a broker object</p></a></li>
<li><a href='#is.dynamic'><p>Determine if an ggvis is dynamic (i.e. needs to be run in a shiny app)</p></a></li>
<li><a href='#is.ggvis'><p>Is an object a ggvis object?</p></a></li>
<li><a href='#is.legend_props'><p>Tests whether an object is a legend_props object</p></a></li>
<li><a href='#is.scaled_value'><p>Tests whether an object is a scaled_value object</p></a></li>
<li><a href='#knit_print.ggvis'><p>Knit print method for ggvis plots.</p></a></li>
<li><a href='#layer_bars'><p>Display data with bars (a barchart).</p></a></li>
<li><a href='#layer_boxplots'><p>Display data with a boxplot.</p></a></li>
<li><a href='#layer_densities'><p>Transformation: density estimate</p></a></li>
<li><a href='#layer_f'><p>Create a new layering function.</p></a></li>
<li><a href='#layer_guess'><p>Guess the right type of layer based on current properties.</p></a></li>
<li><a href='#layer_histograms'><p>Display binned data</p></a></li>
<li><a href='#layer_lines'><p>Layer lines on a plot.</p></a></li>
<li><a href='#layer_model_predictions'><p>Overlay model predictions or a smooth curve.</p></a></li>
<li><a href='#left_right'><p>Interactive inputs bound to arrow keys.</p></a></li>
<li><a href='#legend_props'><p>Create an axis_props object for controlling legend properties.</p></a></li>
<li><a href='#linked_brush'><p>Create a linked brush object.</p></a></li>
<li><a href='#mark'><p>Create a new &quot;mark&quot; object.</p></a></li>
<li><a href='#marks'><p>Vega marks.</p></a></li>
<li><a href='#new_prop'><p>Create new prop object</p></a></li>
<li><a href='#padding'><p>Define padding.</p></a></li>
<li><a href='#print.ggvis'><p>View in a ggvis plot in the browser.</p></a></li>
<li><a href='#prop'><p>Create a property.</p></a></li>
<li><a href='#prop_domain'><p>Property domain.</p></a></li>
<li><a href='#propname_to_scale'><p>Convert the name of a property to the name of its default scale.</p></a></li>
<li><a href='#props'><p>Manage a list of properties.</p></a></li>
<li><a href='#resolution'><p>Compute the &quot;resolution&quot; of a data vector.</p></a></li>
<li><a href='#save_spec'><p>Tools to save and view static specs.</p></a></li>
<li><a href='#scale_datetime'><p>Add a date-time scale to a ggvis object.</p></a></li>
<li><a href='#scale_numeric'><p>Add a numeric scale to a ggvis object.</p></a></li>
<li><a href='#scale_ordinal'><p>Add a ordinal, nominal, or logical scale to a ggvis object.</p></a></li>
<li><a href='#scaled_value'><p>Create a scaled_value object</p></a></li>
<li><a href='#scales'><p>Add a scale to a ggvis plot</p></a></li>
<li><a href='#scaletype_to_vega_scaletype'><p>Given the type of a ggvis scale, get the name of its corresponding vega scale</p></a></li>
<li><a href='#set_options'><p>Set options for a ggvis plot</p></a></li>
<li><a href='#set_scale_label'><p>Set the label for a scale</p></a></li>
<li><a href='#shiny-ggvis'><p>Connect a ggvis graphic to a shiny app.</p></a></li>
<li><a href='#show_spec'><p>Print out the vega plot specification</p></a></li>
<li><a href='#show_tooltip'><p>Send a message to the client to show or hide a tooltip</p></a></li>
<li><a href='#sidebarBottomPage'><p>Create a page with a sidebar</p></a></li>
<li><a href='#singular'><p>singular.</p></a></li>
<li><a href='#subvis'><p>Create a subvisualisation.</p></a></li>
<li><a href='#vector_type'><p>Determine the &quot;type&quot; of a vector</p></a></li>
<li><a href='#vega_data_parser'><p>Determine the vega data type for a vector</p></a></li>
<li><a href='#waggle'><p>Waggle back and forth between two numbers</p></a></li>
<li><a href='#zero_range'><p>Determine if range of vector is close to zero, with a specified tolerance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Interactive Grammar of Graphics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.9</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of an interactive grammar of graphics,
    taking the best parts of 'ggplot2', combining them with the reactive
    framework of 'shiny' and drawing web graphics using 'vega'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ggvis.rstudio.com/">https://ggvis.rstudio.com/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, dplyr (&ge; 0.5.0), htmltools (&ge; 0.2.4), jsonlite
(&ge; 0.9.11), magrittr, methods, rlang, shiny (&ge; 0.11.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.6), lubridate, MASS, mgcv, rmarkdown, testthat
(&ge; 0.8.1)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 16:06:23 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre],
  Winston Chang [aut],
  Posit [cph],
  jQuery Foundation [cph] (jQuery library and jQuery UI library),
  jQuery contributors [ctb, cph] (jQuery library; authors listed in
    inst/www/lib/jquery/AUTHORS.txt),
  jQuery UI contributors [ctb, cph] (jQuery UI library; authors listed in
    inst/www/lib/jquery-ui/AUTHORS.txt),
  Mike Bostock [ctb, cph] (D3 library),
  D3 contributors [ctb] (D3 library; authors listed at
    https://github.com/d3/d3/graphs/contributors),
  Trifacta Inc. [cph] (Vega library),
  Vega contributors [ctb] (Vega library; authors listed at
    https://github.com/trifacta/vega/graphs/contributors),
  Sebastián Décima [ctb, cph] (javascript-detect-element-resize library)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 22:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe graphics</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Like dplyr, ggvis also uses the pipe function, <code>%&gt;%</code> to turn
function composition into a series of imperative statements.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code>, <code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A visualisation and a function to apply to it</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Instead of
layer_points(ggvis(mtcars, ~mpg, ~wt))
# you can write
mtcars %&gt;% ggvis(~mpg, ~wt) %&gt;% layer_points()
</code></pre>

<hr>
<h2 id='add_axis'>Add a vega axis specification to a ggvis plot</h2><span id='topic+add_axis'></span><span id='topic+hide_axis'></span>

<h3>Description</h3>

<p>Axis specifications allow you to either override the default axes,
or additional axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_axis(
  vis,
  type,
  scale = NULL,
  orient = NULL,
  title = NULL,
  title_offset = NULL,
  format = NULL,
  ticks = NULL,
  values = NULL,
  subdivide = NULL,
  tick_padding = NULL,
  tick_size_major = NULL,
  tick_size_minor = tick_size_major,
  tick_size_end = tick_size_major,
  offset = NULL,
  layer = "back",
  grid = TRUE,
  properties = NULL
)

hide_axis(vis, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_axis_+3A_vis">vis</code></td>
<td>
<p>A ggvis object.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_type">type</code></td>
<td>
<p>The type of axis. Either x or y.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_scale">scale</code></td>
<td>
<p>The name of the scale backing the axis component. Defaults to
the scale type - you will need to specify if you want (e.g.) a scale
for a secondary y-axis.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_orient">orient</code></td>
<td>
<p>The orientation of the axis. One of top, bottom, left or right.
The orientation can be used to further specialize the axis type (e.g., a y
axis oriented for the right edge of the chart) - defaults to bottom for
x axes, and left for y axes.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_title">title</code></td>
<td>
<p>A title for the axis. By default, it uses the name of the field
in the first data set used by the scale. Use <code>""</code> to suppress the
title.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_title_offset">title_offset</code></td>
<td>
<p>The offset (in pixels) from the axis at which to place
the title.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_format">format</code></td>
<td>
<p>The formatting pattern for axis labels. Vega uses D3's format
pattern.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_ticks">ticks</code></td>
<td>
<p>A desired number of ticks. The resulting number may be different
so that values are &quot;nice&quot; (multiples of 2, 5, 10) and lie within the
underlying scale's range.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_values">values</code></td>
<td>
<p>Explicitly set the visible axis tick values.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_subdivide">subdivide</code></td>
<td>
<p>If provided, sets the number of minor ticks between major
ticks (the value 9 results in decimal subdivision).</p>
</td></tr>
<tr><td><code id="add_axis_+3A_tick_padding">tick_padding</code></td>
<td>
<p>The padding, in pixels, between ticks and text labels.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_tick_size_major">tick_size_major</code>, <code id="add_axis_+3A_tick_size_minor">tick_size_minor</code>, <code id="add_axis_+3A_tick_size_end">tick_size_end</code></td>
<td>
<p>The size, in pixels, of major, minor and end ticks.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_offset">offset</code></td>
<td>
<p>The offset, in pixels, by which to displace the axis from the
edge of the enclosing group or data rectangle.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_layer">layer</code></td>
<td>
<p>A string indicating if the axis (and any gridlines) should be
placed above or below the data marks. One of &quot;front&quot; or &quot;back&quot; (default).</p>
</td></tr>
<tr><td><code id="add_axis_+3A_grid">grid</code></td>
<td>
<p>A flag indicating if gridlines should be created in addition to
ticks.</p>
</td></tr>
<tr><td><code id="add_axis_+3A_properties">properties</code></td>
<td>
<p>Optional mark property definitions for custom axis styling.
Should be an object created by <code><a href="#topic+axis_props">axis_props</a></code>, with properties
for ticks, majorTicks, minorTicks, grid, labels, title, and axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More information about axes can be found in the &quot;axes and legends&quot; vignettes.
</p>


<h3>Compared to ggplot2</h3>

<p>In ggplot2, axis (and legend) properties are part of the scales
specification. In vega, they are separate, which allows the specification
of multiple axes, and more flexible linkage between scales and axes.
</p>


<h3>See Also</h3>

<p>Vega axis documentation:
<a href="https://vega.github.io/vega/docs/axes/">https://vega.github.io/vega/docs/axes/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% ggvis(x = ~wt, y = ~mpg, fill = ~cyl) %&gt;%
  layer_points() %&gt;%
  add_axis("x", title = "Weight", orient = "top")

# Suppress axis with hide_axis
mtcars %&gt;% ggvis(x = ~wt, y = ~mpg, fill = ~cyl) %&gt;%
  layer_points() %&gt;%
  hide_axis("x") %&gt;% hide_axis("y")

mtcars %&gt;% ggvis(x = ~wt, y = ~mpg) %&gt;% layer_points() %&gt;%
  add_axis("x", title = "Weight", ticks = 40,
    properties = axis_props(
      ticks = list(stroke = "red"),
      majorTicks = list(strokeWidth = 2),
      grid = list(stroke = "red"),
      labels = list(
        fill = "steelblue",
        angle = 50,
        fontSize = 14,
        align = "left",
        baseline = "middle",
        dx = 3
      ),
      title = list(fontSize = 16),
      axis = list(stroke = "#333", strokeWidth = 1.5)
    )
  )
</code></pre>

<hr>
<h2 id='add_data'>Add dataset to a visualisation</h2><span id='topic+add_data'></span>

<h3>Description</h3>

<p>Add dataset to a visualisation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_data(vis, data, name = deparse2(substitute(data)), add_suffix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_data_+3A_vis">vis</code></td>
<td>
<p>Visualisation to modify.</p>
</td></tr>
<tr><td><code id="add_data_+3A_data">data</code></td>
<td>
<p>Data set to add.</p>
</td></tr>
<tr><td><code id="add_data_+3A_name">name</code></td>
<td>
<p>Data of data - optional, but helps produce informative
error messages.</p>
</td></tr>
<tr><td><code id="add_data_+3A_add_suffix">add_suffix</code></td>
<td>
<p>Should a unique suffix be added to the data object's ID?
This should only be FALSE when the spec requires a data set with a
specific name.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% ggvis(~mpg, ~wt) %&gt;% layer_points()
NULL %&gt;% ggvis(~mpg, ~wt) %&gt;% add_data(mtcars) %&gt;% layer_points()
</code></pre>

<hr>
<h2 id='add_guide_axis'>Defunct function for adding an axis</h2><span id='topic+add_guide_axis'></span>

<h3>Description</h3>

<p>This function has been replaced with <code><a href="#topic+add_axis">add_axis</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_guide_axis(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_guide_axis_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='add_guide_legend'>Defunct function for adding a legend</h2><span id='topic+add_guide_legend'></span>

<h3>Description</h3>

<p>This function has been replaced with <code><a href="#topic+add_legend">add_legend</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_guide_legend(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_guide_legend_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='add_legend'>Add a vega legend specification to a ggvis plot</h2><span id='topic+add_legend'></span><span id='topic+hide_legend'></span>

<h3>Description</h3>

<p>Axis specifications allow you to either override the default legends,
or supply additional legends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_legend(
  vis,
  scales = NULL,
  orient = "right",
  title = NULL,
  format = NULL,
  values = NULL,
  properties = NULL
)

hide_legend(vis, scales)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_legend_+3A_vis">vis</code></td>
<td>
<p>A ggvis object.</p>
</td></tr>
<tr><td><code id="add_legend_+3A_scales">scales</code></td>
<td>
<p>The name of one or more scales for which to add a legend.
Typically one of &quot;size&quot;, &quot;shape&quot;, &quot;fill&quot;, &quot;stroke&quot;, although custom scale
names may also be used. Multiple names can also be used, like
<code>c("fill", "shape")</code>.</p>
</td></tr>
<tr><td><code id="add_legend_+3A_orient">orient</code></td>
<td>
<p>The orientation of the legend. One of &quot;left&quot; or &quot;right&quot;. This
determines how the legend is positioned within the scene. The default is
&quot;right&quot;.</p>
</td></tr>
<tr><td><code id="add_legend_+3A_title">title</code></td>
<td>
<p>A title for the legend. By default, it uses the name the fields
used in the legend. Use <code>""</code> to suppress the title.</p>
</td></tr>
<tr><td><code id="add_legend_+3A_format">format</code></td>
<td>
<p>The formatting pattern for axis labels. Vega uses D3's format
pattern.</p>
</td></tr>
<tr><td><code id="add_legend_+3A_values">values</code></td>
<td>
<p>Explicitly set the visible legend values.</p>
</td></tr>
<tr><td><code id="add_legend_+3A_properties">properties</code></td>
<td>
<p>Optional mark property definitions for custom legend
styling. Should be an object created by <code><a href="#topic+legend_props">legend_props</a></code>, with
properties for title, label, symbols, gradient, legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More information about axes can be found in the &quot;axes and legends&quot; vignettes.
</p>


<h3>Compared to ggplot2</h3>

<p>In ggplot2, legend (and axis) properties are part of the scales
specification. In vega, they are separate, which allows the specification
of multiple legends, and more flexible linkage between scales and legends.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% ggvis(x = ~wt, y = ~mpg, fill = ~cyl) %&gt;%
  layer_points() %&gt;%
  add_legend("fill", title = "Cylinders")

# Suppress legend with hide_legend
mtcars %&gt;% ggvis(x = ~wt, y = ~mpg, fill = ~cyl) %&gt;%
  layer_points() %&gt;%
  hide_legend("fill")

# Combining two properties in one legend
mtcars %&gt;%
  ggvis(x = ~wt, y = ~mpg, fill = ~factor(cyl), shape = ~factor(cyl)) %&gt;%
  layer_points() %&gt;%
  add_legend(c("fill", "shape"))

# Control legend properties with a continuous legend, with x and y position
# in pixels.
mtcars %&gt;% ggvis(x = ~wt, y = ~mpg, fill = ~cyl) %&gt;%
  layer_points() %&gt;%
  add_legend("fill", title = "Cylinders",
    properties = legend_props(
      title = list(fontSize = 16),
      labels = list(fontSize = 12, fill = "#00F"),
      gradient = list(stroke = "red", strokeWidth = 2),
      legend = list(x = 500, y = 50)
    )
  )

# Control legend properties with a categorical legend, with x and y position
# in the scaled data space.
mtcars %&gt;% ggvis(x = ~wt, y = ~mpg, fill = ~factor(cyl)) %&gt;%
  layer_points() %&gt;%
  add_legend("fill", title = "Cylinders",
    properties = legend_props(
      title = list(fontSize = 16),
      labels = list(fontSize = 14, dx = 5),
      symbol = list(stroke = "black", strokeWidth = 2,
        shape = "square", size = 200),
      legend = list(
        x = scaled_value("x", 4.5),
        y = scaled_value("y", 30)
      )
    )
  )

# Control legend position using x_rel and y_rel which specify relative
# position, going from 0 to 1. (0, 0) is the bottom-left corner, and
# (1, 1) is the upper-right corner. The values control the position of
# the upper-left corner of the legend.
mtcars %&gt;% ggvis(x = ~wt, y = ~mpg, fill = ~cyl) %&gt;%
  layer_points() %&gt;%
  add_relative_scales() %&gt;%
  add_legend("fill", title = "Cylinders",
    properties = legend_props(
      legend = list(
        x = scaled_value("x_rel", 0.8),
        y = scaled_value("y_rel", 1)
      )
    )
  )
</code></pre>

<hr>
<h2 id='add_props'>Add visual properties to a visualisation</h2><span id='topic+add_props'></span>

<h3>Description</h3>

<p>Add visual properties to a visualisation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_props(vis, ..., .props = NULL, inherit = NULL, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_props_+3A_vis">vis</code></td>
<td>
<p>Visualisation to modify.</p>
</td></tr>
<tr><td><code id="add_props_+3A_...">...</code></td>
<td>
<p>A set of name-value pairs. The name should be a valid vega
property.
</p>
<p>The first two unnamed components are taken to be <code>x</code> and <code>y</code>.
Any additional unnamed components will raise an error.</p>
</td></tr>
<tr><td><code id="add_props_+3A_.props">.props</code></td>
<td>
<p>When calling <code>props</code> from other functions, you'll
often have a list of quoted function functions. You can pass that function
to the <code>.props</code> argument instead of messing around with
substitute. In other words, <code>.props</code> lets you opt out of the
non-standard evaluation that <code>props</code> does.</p>
</td></tr>
<tr><td><code id="add_props_+3A_inherit">inherit</code></td>
<td>
<p>If <code>TRUE</code>, the defaults, will inherit from properties
from the parent layer If <code>FALSE</code>, it will start from nothing.</p>
</td></tr>
<tr><td><code id="add_props_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate variable properties.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;% layer_points()
mtcars %&gt;% ggvis() %&gt;% add_props(~wt, ~mpg) %&gt;% layer_points()
mtcars %&gt;% ggvis(~wt) %&gt;% add_props(y = ~mpg) %&gt;% layer_points()
</code></pre>

<hr>
<h2 id='add_relative_scales'>Add x_rel and y_rel scales</h2><span id='topic+add_relative_scales'></span>

<h3>Description</h3>

<p>This function adds scales named <code>x_rel</code> and <code>y_rel</code>, each of which
has a domain of 0 to 1, and the range is the plot's width or height.
These scales are useful for positioning visual elements relative to the
plotting area. For example, with legends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_relative_scales(vis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_relative_scales_+3A_vis">vis</code></td>
<td>
<p>A ggvis object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+add_legend">add_legend</a></code> for a usage example.
</p>

<hr>
<h2 id='add_scale'>Add arbitrary scales to ggvis.</h2><span id='topic+add_scale'></span>

<h3>Description</h3>

<p>Add arbitrary scales to ggvis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_scale(vis, scale, data_domain = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_scale_+3A_vis">vis</code></td>
<td>
<p>Visualisation to modify.</p>
</td></tr>
<tr><td><code id="add_scale_+3A_scale">scale</code></td>
<td>
<p>Scale object</p>
</td></tr>
<tr><td><code id="add_scale_+3A_data_domain">data_domain</code></td>
<td>
<p>Should the domain be controlled by a data set which is
added to the spec? Should only be set to FALSE in special cases.</p>
</td></tr>
</table>

<hr>
<h2 id='add_tooltip'>Add tooltips to a plot.</h2><span id='topic+add_tooltip'></span>

<h3>Description</h3>

<p>Add tooltips to a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_tooltip(vis, html, on = c("hover", "click"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_tooltip_+3A_vis">vis</code></td>
<td>
<p>Visualisation to add tooltips to.</p>
</td></tr>
<tr><td><code id="add_tooltip_+3A_html">html</code></td>
<td>
<p>A function that takes a single argument as input. This argument
will be a list containing the data in the mark currently under the
mouse. It should return a string containing HTML or <code>NULL</code> to
hide tooltip for the current element.</p>
</td></tr>
<tr><td><code id="add_tooltip_+3A_on">on</code></td>
<td>
<p>Should tooltips appear on hover, or on click?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Run these examples only in interactive R sessions
if (interactive()) {

all_values &lt;- function(x) {
  if(is.null(x)) return(NULL)
  paste0(names(x), ": ", format(x), collapse = "&lt;br /&gt;")
}

base &lt;- mtcars %&gt;% ggvis(x = ~wt, y = ~mpg) %&gt;%
  layer_points()
base %&gt;% add_tooltip(all_values, "hover")
base %&gt;% add_tooltip(all_values, "click")

# The data sent from client to the server contains only the data columns that
# are used in the plot. If you want to get other columns of data, you should
# to use a key to line up the item from the plot with a row in the data.
mtc &lt;- mtcars
mtc$id &lt;- 1:nrow(mtc)  # Add an id column to use ask the key

all_values &lt;- function(x) {
  if(is.null(x)) return(NULL)
  row &lt;- mtc[mtc$id == x$id, ]
  paste0(names(row), ": ", format(row), collapse = "&lt;br /&gt;")
}

mtc %&gt;% ggvis(x = ~wt, y = ~mpg, key := ~id) %&gt;%
  layer_points() %&gt;%
  add_tooltip(all_values, "hover")

}
</code></pre>

<hr>
<h2 id='as.vega'>Coerce an ggvis object to a vega list.</h2><span id='topic+as.vega'></span><span id='topic+as.vega.ggvis'></span>

<h3>Description</h3>

<p>This generic function powers the coercion of ggvis objects to vega
compatible data structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.vega(x, ...)

## S3 method for class 'ggvis'
as.vega(x, session = NULL, dynamic = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.vega_+3A_x">x</code></td>
<td>
<p>an object to convert to vega</p>
</td></tr>
<tr><td><code id="as.vega_+3A_session">session</code></td>
<td>
<p>a session object from shiny</p>
</td></tr>
<tr><td><code id="as.vega_+3A_dynamic">dynamic</code></td>
<td>
<p>whether to generate dynamic or static spec</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list. When converted to JSON, will be the type of structure
that vega expects.
</p>

<hr>
<h2 id='auto_group'>Automatically group data by grouping variables</h2><span id='topic+auto_group'></span>

<h3>Description</h3>

<p>Use <code>auto_group</code> to group up a dataset on all categorical variables
specified by props, and have each piece rendered by the same mark.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_group(vis, exclude = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_group_+3A_vis">vis</code></td>
<td>
<p>The ggvis visualisation to modify.</p>
</td></tr>
<tr><td><code id="auto_group_+3A_exclude">exclude</code></td>
<td>
<p>A vector containing names of props to exclude from auto grouping.
It is often useful to exclude <code>c("x", "y")</code>, when one of those variables
is categorical.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>To manually specify grouping variables, see <code><a href="#topic+group_by">group_by</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One line
mtcars %&gt;% ggvis(~disp, ~mpg, stroke = ~factor(cyl)) %&gt;% layer_paths()
# One line for each level of cyl
mtcars %&gt;% ggvis(~disp, ~mpg, stroke = ~factor(cyl)) %&gt;% group_by(cyl) %&gt;%
  layer_paths()
mtcars %&gt;% ggvis(~disp, ~mpg, stroke = ~factor(cyl)) %&gt;% auto_group() %&gt;%
  layer_paths()

# The grouping column can already be stored as a factor
mtcars2 &lt;- mtcars
mtcars2$cyl &lt;- factor(mtcars2$cyl)
mtcars2 %&gt;% ggvis(~disp, ~mpg, stroke = ~cyl) %&gt;% auto_group() %&gt;%
  layer_paths()
</code></pre>

<hr>
<h2 id='axis_props'>Create an axis_props object for controlling axis properties.</h2><span id='topic+axis_props'></span>

<h3>Description</h3>

<p>The items in each of the lists can be a literal value, like <code>5</code> or
&quot;blue&quot;, or they can be a <code><a href="#topic+scaled_value">scaled_value</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis_props(
  ticks = NULL,
  majorTicks = NULL,
  minorTicks = NULL,
  grid = NULL,
  labels = NULL,
  title = NULL,
  axis = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axis_props_+3A_ticks">ticks</code></td>
<td>
<p>A named list of line properties for ticks.</p>
</td></tr>
<tr><td><code id="axis_props_+3A_majorticks">majorTicks</code></td>
<td>
<p>A named list of line properties for major ticks.</p>
</td></tr>
<tr><td><code id="axis_props_+3A_minorticks">minorTicks</code></td>
<td>
<p>A named list of line properties for minor ticks.</p>
</td></tr>
<tr><td><code id="axis_props_+3A_grid">grid</code></td>
<td>
<p>A named list of line properties for grid lines.</p>
</td></tr>
<tr><td><code id="axis_props_+3A_labels">labels</code></td>
<td>
<p>A named list of text properties for axis labels.</p>
</td></tr>
<tr><td><code id="axis_props_+3A_title">title</code></td>
<td>
<p>A named list of text properties for the axis title.</p>
</td></tr>
<tr><td><code id="axis_props_+3A_axis">axis</code></td>
<td>
<p>A named list of line properties for the axis line.</p>
</td></tr>
</table>

<hr>
<h2 id='band'>A band</h2><span id='topic+band'></span><span id='topic+is.prop_band'></span>

<h3>Description</h3>

<p>Bands are used to set the width or height on categorical scales - a band
represent the height or width allocated for one level of a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>band(offset = NULL, mult = NULL)

is.prop_band(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="band_+3A_offset">offset</code>, <code id="band_+3A_mult">mult</code></td>
<td>
<p>Additive and multiplicate offsets used to adjust the
band size. For example, use <code>mult = 0.9</code> to make a bar take up
90% of the space allocated for its category.</p>
</td></tr>
<tr><td><code id="band_+3A_x">x</code></td>
<td>
<p>object to test for band-ness</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(label = c("a", "b", "c"), n = c(10, 9, 4))

base &lt;- df %&gt;% ggvis(~label, y2 = 0, y = ~n)
base %&gt;% layer_rects(width = band())
base %&gt;% layer_rects(width = band(offset = -1))
base %&gt;% layer_rects(width = band(mult = 0.9))

# A nominal scale with padding is more symmetrical than band with a mult
base %&gt;% layer_rects(width = band(mult = 0.75))
base %&gt;% layer_rects(width = band()) %&gt;%
  scale_nominal("x", padding = 0.25, points = FALSE)
</code></pre>

<hr>
<h2 id='bin_vector'>Bin vectors</h2><span id='topic+bin_vector'></span><span id='topic+bin_vector.numeric'></span>

<h3>Description</h3>

<p>A generic and several implementations for binning vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_vector(x, weight = NULL, ...)

## S3 method for class 'numeric'
bin_vector(
  x,
  weight = NULL,
  ...,
  width = 1,
  origin = 0,
  closed = c("right", "left"),
  pad = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bin_vector_+3A_x">x</code></td>
<td>
<p>A vector to bin</p>
</td></tr>
<tr><td><code id="bin_vector_+3A_weight">weight</code></td>
<td>
<p>If specified, an integer vector of the same length as <code>x</code>
representing the number of occurances of each value in <code>x</code></p>
</td></tr>
<tr><td><code id="bin_vector_+3A_...">...</code></td>
<td>
<p>additional arguments passed through to methods.</p>
</td></tr>
<tr><td><code id="bin_vector_+3A_width">width</code></td>
<td>
<p>The width of a bin</p>
</td></tr>
<tr><td><code id="bin_vector_+3A_origin">origin</code></td>
<td>
<p>The left-most value for bins.</p>
</td></tr>
<tr><td><code id="bin_vector_+3A_closed">closed</code></td>
<td>
<p>One of <code>"right"</code> or <code>"left"</code> indicating whether
right or left edges of bins are included in the bin.</p>
</td></tr>
<tr><td><code id="bin_vector_+3A_pad">pad</code></td>
<td>
<p>A logical indicating whether the bins should be padded to include
an empty bin on each side.</p>
</td></tr>
</table>

<hr>
<h2 id='cocaine'>Cocaine seizures in the US.</h2><span id='topic+cocaine'></span>

<h3>Description</h3>

<p>This dataset comes from STRIDE, the System to Retrieve Information from Drug
Evidence. It contains all concaine seizures in the US from 2007 that have
a known weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocaine
</code></pre>


<h3>Format</h3>

<p>Data frame with 3380 observations of 5 variables.
</p>


<h3>Variables</h3>


<dl>
<dt>state</dt><dd><p>State where seizure occured.</p>
</dd>
<dt>potency</dt><dd><p>Purity of cocaine, as percentage (100% = pure cocaine,
0% = all filler)</p>
</dd>
<dt>weight</dt><dd><p>Weight, in grams.</p>
</dd>
<dt>month</dt><dd><p>Month in which seizure occured.</p>
</dd>
<dt>price</dt><dd><p>Estimated value in USD.</p>
</dd>
</dl>



<h3>Use</h3>

<p>Use of this data requires your agreement to refer to your analyses as
&quot;unvalidated DEA data and to claim authorship and responsibility for any
inferences and/or conclusions you may draw from this information.&quot;
</p>

<hr>
<h2 id='compute_align'>Align positions using length.</h2><span id='topic+compute_align'></span>

<h3>Description</h3>

<p>This compute function is often used in conjunction with
<code><a href="#topic+compute_count">compute_count</a></code>, when used on data with a continuous x variable.
By default, the computed width will be equal to the resolution of the data,
or, in other words the smallest difference between two values in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_align(x, var, length = NULL, align = 0.5, dir = "x")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_align_+3A_x">x</code></td>
<td>
<p>Dataset-like object to align. Built-in methods for data frames,
grouped data frames and ggvis visualisations.</p>
</td></tr>
<tr><td><code id="compute_align_+3A_var">var</code></td>
<td>
<p>Name of variable to compute width of.</p>
</td></tr>
<tr><td><code id="compute_align_+3A_length">length</code></td>
<td>
<p>An absolute length to use. If <code>NULL</code> (the default), the
width will be equivalent to the resolution of the data.</p>
</td></tr>
<tr><td><code id="compute_align_+3A_align">align</code></td>
<td>
<p>Where does the existing variable fall on the new bins?
0 = left edge, 0.5 = center, 1 = right edge.</p>
</td></tr>
<tr><td><code id="compute_align_+3A_dir">dir</code></td>
<td>
<p>Direction, i.e. <code>"x"</code> or <code>"y"</code>. Used to generate
variable names in output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An absolute width for each x can be specified by using the <code>width</code>
argument. If <code>width</code> is NULL (the default), it will use the resolution
of the data as the width.
</p>


<h3>Value</h3>

<p>The original data frame, with additional columns:
</p>
<table role = "presentation">
<tr><td><code>'dir'min_</code></td>
<td>
<p>left boundary of bin</p>
</td></tr>
<tr><td><code>'dir'max_</code></td>
<td>
<p>right boundary of bin</p>
</td></tr>
<tr><td><code>'dir'len_</code></td>
<td>
<p>width of bin</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+compute_bin">compute_bin</a></code> For counting cases within ranges of
a continuous variable.
</p>
<p><code><a href="#topic+compute_count">compute_count</a></code> For counting cases at specific values
of a variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% compute_count(~disp) %&gt;% compute_align(~x_)
mtcars %&gt;% compute_count(~mpg) %&gt;% compute_align(~x_)

# Use a specific width
pressure %&gt;% compute_count(~temperature) %&gt;% compute_align(~x_)
pressure %&gt;% compute_count(~temperature) %&gt;% compute_align(~x_, length = 5)

# It doesn't matter whether you transform inside or outside of a vis
mtcars %&gt;% compute_count(~cyl, ~wt) %&gt;%
  compute_align(~x_, length = .5) %&gt;%
  ggvis(x = ~xmin_, x2 = ~xmax_, y = ~count_, y2 = 0) %&gt;%
  layer_rects()

mtcars %&gt;%
  ggvis(x = ~xmin_, x2 = ~xmax_, y = ~count_, y2 = 0) %&gt;%
  compute_count(~cyl, ~wt) %&gt;%
  compute_align(~x_) %&gt;%
  layer_rects()

# Varying align
mtcars %&gt;%
  ggvis(x = ~xmin_, x2 = ~xmax_, y = ~count_, y2 = 0) %&gt;%
  compute_count(~cyl, ~wt) %&gt;%
  compute_align(~x_, length = 0.5, align = input_slider(0, 1)) %&gt;%
  layer_rects()
</code></pre>

<hr>
<h2 id='compute_bin'>Bin data along a continuous variable</h2><span id='topic+compute_bin'></span>

<h3>Description</h3>

<p>Bin data along a continuous variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_bin(
  x,
  x_var,
  w_var = NULL,
  width = NULL,
  center = NULL,
  boundary = NULL,
  closed = c("right", "left"),
  pad = FALSE,
  binwidth
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_bin_+3A_x">x</code></td>
<td>
<p>Dataset-like object to bin. Built-in methods for data frames,
grouped data frames and ggvis visualisations.</p>
</td></tr>
<tr><td><code id="compute_bin_+3A_x_var">x_var</code>, <code id="compute_bin_+3A_w_var">w_var</code></td>
<td>
<p>Names of x and weight variables. The x variable must be
continuous.</p>
</td></tr>
<tr><td><code id="compute_bin_+3A_width">width</code></td>
<td>
<p>The width of the bins. The default is <code>NULL</code>, which yields
30 bins that cover the range of the data. You should always override this
value, exploring multiple widths to find the best to illustrate the stories
in your data.</p>
</td></tr>
<tr><td><code id="compute_bin_+3A_center">center</code></td>
<td>
<p>The center of one of the bins.  Note that if center is above or
below the range of the data, things will be shifted by an appropriate
number of <code>width</code>s. To center on integers, for example, use
<code>width=1</code> and <code>center=0</code>, even if <code>0</code> is outside the range
of the data.  At most one of <code>center</code> and <code>boundary</code> may be
specified.</p>
</td></tr>
<tr><td><code id="compute_bin_+3A_boundary">boundary</code></td>
<td>
<p>A boundary between two bins. As with <code>center</code>, things
are shifted when <code>boundary</code> is outside the range of the data. For
example, to center on integers, use <code>width = 1</code> and <code>boundary =
0.5</code>, even if <code>1</code> is outside the range of the data.  At most one of
<code>center</code> and <code>boundary</code> may be specified.</p>
</td></tr>
<tr><td><code id="compute_bin_+3A_closed">closed</code></td>
<td>
<p>One of <code>"right"</code> or <code>"left"</code> indicating whether right
or left edges of bins are included in the bin.</p>
</td></tr>
<tr><td><code id="compute_bin_+3A_pad">pad</code></td>
<td>
<p>If <code>TRUE</code>, adds empty bins at either end of x. This ensures
frequency polygons touch 0. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compute_bin_+3A_binwidth">binwidth</code></td>
<td>
<p>Deprecated; use <code>width</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns:
</p>
<table role = "presentation">
<tr><td><code>count_</code></td>
<td>
<p>the number of points</p>
</td></tr>
<tr><td><code>x_</code></td>
<td>
<p>mid-point of bin</p>
</td></tr>
<tr><td><code>xmin_</code></td>
<td>
<p>left boundary of bin</p>
</td></tr>
<tr><td><code>xmax_</code></td>
<td>
<p>right boundary of bin</p>
</td></tr>
<tr><td><code>width_</code></td>
<td>
<p>width of bin</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+compute_count">compute_count</a></code> For counting cases at specific locations
of a continuous variable. This is useful when the variable is continuous
but the data is granular.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% compute_bin(~mpg)
mtcars %&gt;% compute_bin(~mpg, width = 10)
mtcars %&gt;% group_by(cyl) %&gt;% compute_bin(~mpg, width = 10)

# It doesn't matter whether you transform inside or outside of a vis
mtcars %&gt;% compute_bin(~mpg) %&gt;% ggvis(~x_, ~count_) %&gt;% layer_paths()
mtcars %&gt;% ggvis(~ x_, ~ count_) %&gt;% compute_bin(~mpg) %&gt;% layer_paths()

# Missing values get own bin
mtcars2 &lt;- mtcars
mtcars2$mpg[sample(32, 5)] &lt;- NA
mtcars2 %&gt;% compute_bin(~mpg, width = 10)

# But are currently silently dropped in histograms
mtcars2 %&gt;% ggvis() %&gt;% layer_histograms(~mpg)
</code></pre>

<hr>
<h2 id='compute_boxplot'>Calculate boxplot values</h2><span id='topic+compute_boxplot'></span>

<h3>Description</h3>

<p>Calculate boxplot values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_boxplot(x, var = NULL, coef = 1.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_boxplot_+3A_x">x</code></td>
<td>
<p>Dataset-like object to compute boxplot values. There are built-in
methods for data frames, grouped data frames, and ggvis visualisations.</p>
</td></tr>
<tr><td><code id="compute_boxplot_+3A_var">var</code></td>
<td>
<p>Name of variable for which to compute boxplot values. The variable
must be continuous.</p>
</td></tr>
<tr><td><code id="compute_boxplot_+3A_coef">coef</code></td>
<td>
<p>The maximum length of the whiskers as multiple of the
inter-quartile range. Default value is 1.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns:
</p>
<table role = "presentation">
<tr><td><code>min_</code></td>
<td>
<p>Lower whisker = smallest observation greater than or equal to lower hinge - 1.5 * IQR</p>
</td></tr>
<tr><td><code>lower_</code></td>
<td>
<p>Lower hinge (25th percentile)</p>
</td></tr>
<tr><td><code>median_</code></td>
<td>
<p>Median (50th percentile)</p>
</td></tr>
<tr><td><code>upper_</code></td>
<td>
<p>Upper hinge (75th percentile)</p>
</td></tr>
<tr><td><code>max_</code></td>
<td>
<p>Upper whisker = largest observation less than or equal to upper hinge + 1.5 * IQR</p>
</td></tr>
<tr><td><code>outliers_</code></td>
<td>
<p>A vector of values that are outside of the min and max</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+layer_boxplots">layer_boxplots</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% compute_boxplot(~mpg)
mtcars %&gt;% group_by(cyl) %&gt;% compute_boxplot(~mpg)
</code></pre>

<hr>
<h2 id='compute_count'>Count data at each location</h2><span id='topic+compute_count'></span>

<h3>Description</h3>

<p>Count data at each location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_count(x, x_var, w_var = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_count_+3A_x">x</code></td>
<td>
<p>Dataset-like object to count. Built-in methods for data frames,
grouped data frames and ggvis visualisations.</p>
</td></tr>
<tr><td><code id="compute_count_+3A_x_var">x_var</code>, <code id="compute_count_+3A_w_var">w_var</code></td>
<td>
<p>Names of x and weight variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns:
</p>
<table role = "presentation">
<tr><td><code>count_</code></td>
<td>
<p>the number of points</p>
</td></tr>
<tr><td><code>x_</code></td>
<td>
<p>the x value where the count was made</p>
</td></tr>
</table>
<p>The width of each &quot;bin&quot; is set to the resolution of the data &ndash; that is, the
smallest difference between two x values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_bin">compute_bin</a></code> For counting cases within ranges of
a continuous variable.
</p>
<p><code><a href="#topic+compute_align">compute_align</a></code> For calculating the &quot;width&quot; of data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% compute_count(~cyl)

# Weight the counts by car weight value
mtcars %&gt;% compute_count(~cyl, ~wt)

# If there's one weight value at each x, it effectively just renames columns.
pressure %&gt;% compute_count(~temperature, ~pressure)
# Also get the width of each bin
pressure %&gt;% compute_count(~temperature, ~pressure) %&gt;% compute_align(~x_)

# It doesn't matter whether you transform inside or outside of a vis
mtcars %&gt;% compute_count(~cyl, ~wt) %&gt;%
  compute_align(~x_) %&gt;%
  ggvis(x = ~xmin_, x2 = ~xmax_, y = ~count_, y2 = 0) %&gt;%
  layer_rects()

mtcars %&gt;%
  ggvis(x = ~xmin_, x2 = ~xmax_, y = ~count_, y2 = 0) %&gt;%
  compute_count(~cyl, ~wt) %&gt;%
  compute_align(~x_) %&gt;%
  layer_rects()
</code></pre>

<hr>
<h2 id='compute_density'>Compute density of data.</h2><span id='topic+compute_density'></span>

<h3>Description</h3>

<p>Compute density of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_density(
  x,
  x_var,
  w_var = NULL,
  kernel = "gaussian",
  trim = FALSE,
  n = 256L,
  na.rm = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_density_+3A_x">x</code></td>
<td>
<p>Dataset (data frame, <code>grouped_df</code> or ggvis) object to work
with.</p>
</td></tr>
<tr><td><code id="compute_density_+3A_x_var">x_var</code>, <code id="compute_density_+3A_w_var">w_var</code></td>
<td>
<p>Names of variables to use for x position, and for
weights.</p>
</td></tr>
<tr><td><code id="compute_density_+3A_kernel">kernel</code></td>
<td>
<p>Smoothing kernel. See <code><a href="stats.html#topic+density">density</a></code> for details.</p>
</td></tr>
<tr><td><code id="compute_density_+3A_trim">trim</code></td>
<td>
<p>If <code>TRUE</code>, the default, density estimates are trimmed to the
actual range of the data.  If <code>FALSE</code>, they are extended by the
default 3 bandwidths (as specified by the <code>cut</code> parameter to
<code><a href="stats.html#topic+density">density</a></code>).</p>
</td></tr>
<tr><td><code id="compute_density_+3A_n">n</code></td>
<td>
<p>Number of points (along x) to use in the density estimate.</p>
</td></tr>
<tr><td><code id="compute_density_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code> missing values will be silently removed,
otherwise they will be removed with a warning.</p>
</td></tr>
<tr><td><code id="compute_density_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns:
</p>
<table role = "presentation">
<tr><td><code>pred_</code></td>
<td>
<p>regularly spaced grid of <code>n</code> locations</p>
</td></tr>
<tr><td><code>resp_</code></td>
<td>
<p>density estimate</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% compute_density(~mpg, n = 5)
mtcars %&gt;% group_by(cyl) %&gt;% compute_density(~mpg, n = 5)
mtcars %&gt;% ggvis(~mpg) %&gt;% compute_density(~mpg, n = 5) %&gt;%
  layer_points(~pred_, ~resp_)
</code></pre>

<hr>
<h2 id='compute_model_prediction'>Create a model of a data set and compute predictions.</h2><span id='topic+compute_model_prediction'></span><span id='topic+compute_smooth'></span>

<h3>Description</h3>

<p>Fit a 1d model, then compute predictions and (optionally) standard errors
over an evenly spaced grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_model_prediction(
  x,
  formula,
  ...,
  model = NULL,
  se = FALSE,
  level = 0.95,
  n = 80L,
  domain = NULL,
  method
)

compute_smooth(x, formula, ..., span = 0.75, se = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_model_prediction_+3A_x">x</code></td>
<td>
<p>Dataset-like object to model and predict. Built-in methods for data
frames, grouped data frames and ggvis visualisations.</p>
</td></tr>
<tr><td><code id="compute_model_prediction_+3A_formula">formula</code></td>
<td>
<p>Formula passed to modelling function. Can use any variables
from data.</p>
</td></tr>
<tr><td><code id="compute_model_prediction_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code>model</code> function</p>
</td></tr>
<tr><td><code id="compute_model_prediction_+3A_model">model</code></td>
<td>
<p>Model fitting function to use - it must support R's standard
modelling interface, taking a formula and data frame as input, and
returning predictions with <code><a href="stats.html#topic+predict">predict</a></code>. If not supplied, will use
<code><a href="stats.html#topic+loess">loess</a></code> for &lt;= 1000 points, otherwise it will use
<code><a href="mgcv.html#topic+gam">gam</a></code>. Other modelling functions that will work include
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="MASS.html#topic+rlm">rlm</a></code>.</p>
</td></tr>
<tr><td><code id="compute_model_prediction_+3A_se">se</code></td>
<td>
<p>include standard errors in output? Requires appropriate method of
<code>predict_grid</code>, since the interface for returning predictions with
standard errors is not consistent acrossing modelling frameworks.</p>
</td></tr>
<tr><td><code id="compute_model_prediction_+3A_level">level</code></td>
<td>
<p>the confidence level of the standard errors.</p>
</td></tr>
<tr><td><code id="compute_model_prediction_+3A_n">n</code></td>
<td>
<p>the number of grid points to use in the prediction</p>
</td></tr>
<tr><td><code id="compute_model_prediction_+3A_domain">domain</code></td>
<td>
<p>If <code>NULL</code> (the default), the domain of the predicted
values will be the same as the domain of the prediction variable in the
data. It can also be a two-element numeric vector specifying the min and
max.</p>
</td></tr>
<tr><td><code id="compute_model_prediction_+3A_method">method</code></td>
<td>
<p>Deprecated. Please use <code>model</code> instead.</p>
</td></tr>
<tr><td><code id="compute_model_prediction_+3A_span">span</code></td>
<td>
<p>Smoothing span used for loess model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>compute_model_prediction</code> fits a model to the data and makes
predictions with it. <code>compute_smooth</code> is a special case of model
predictions where the model is a smooth loess curve whose smoothness is
controlled by the <code>span</code> parameter.
</p>


<h3>Value</h3>

<p>A data frame with columns: </p>
<table role = "presentation">
<tr><td><code>resp_</code></td>
<td>
<p>regularly spaced grid
of <code>n</code> locations</p>
</td></tr> <tr><td><code>pred_</code></td>
<td>
<p>predicted value from model</p>
</td></tr>
<tr><td><code>pred_lwr_ and pred_upr_</code></td>
<td>
<p>upper and lower bounds of
confidence interval (if <code>se = TRUE</code>)</p>
</td></tr> <tr><td><code>pred_se_</code></td>
<td>
<p>the
standard error (width of the confidence interval) (if <code>se = TRUE</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Use a small value of n for these examples
mtcars %&gt;% compute_model_prediction(mpg ~ wt, n = 10)
mtcars %&gt;% compute_model_prediction(mpg ~ wt, n = 10, se = TRUE)
mtcars %&gt;% group_by(cyl) %&gt;% compute_model_prediction(mpg ~ wt, n = 10)

# compute_smooth defaults to loess
mtcars %&gt;% compute_smooth(mpg ~ wt)

# Override model to suppress message or change approach
mtcars %&gt;% compute_model_prediction(mpg ~ wt, n = 10, model = "loess")
mtcars %&gt;% compute_model_prediction(mpg ~ wt, n = 10, model = "lm")

# Set the domain manually
mtcars %&gt;%
  compute_model_prediction(mpg ~ wt, n = 20, model = "lm", domain = c(0, 8))

# Plot the results
mtcars %&gt;% compute_model_prediction(mpg ~ wt) %&gt;%
  ggvis(~pred_, ~resp_) %&gt;%
  layer_paths()
mtcars %&gt;% ggvis() %&gt;%
  compute_model_prediction(mpg ~ wt) %&gt;%
  layer_paths(~pred_, ~resp_)
</code></pre>

<hr>
<h2 id='compute_stack'>Stack overlapping data.</h2><span id='topic+compute_stack'></span>

<h3>Description</h3>

<p>Stack overlapping data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_stack(x, stack_var = NULL, group_var = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_stack_+3A_x">x</code></td>
<td>
<p>A data object</p>
</td></tr>
<tr><td><code id="compute_stack_+3A_stack_var">stack_var</code></td>
<td>
<p>A string specifying the stacking variable.</p>
</td></tr>
<tr><td><code id="compute_stack_+3A_group_var">group_var</code></td>
<td>
<p>A string specifying the grouping variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns:
</p>
<table role = "presentation">
<tr><td><code>stack_upr_</code></td>
<td>
<p>the lower y coordinate for a stack bar</p>
</td></tr>
<tr><td><code>stack_lwr_</code></td>
<td>
<p>the upper y coordinate for a stack bar</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% cbind(count = 1) %&gt;% compute_stack(~count, ~cyl)

# Shouldn't use or affect existing grouping
mtcars %&gt;% cbind(count = 1) %&gt;% group_by(am) %&gt;% compute_stack(~count, ~cyl)

# If given a ggvis object, will use x variable for stacking by default
mtcars %&gt;% ggvis(x = ~cyl, y = ~wt) %&gt;%
  compute_stack(stack_var = ~wt, group_var = ~cyl) %&gt;%
  layer_rects(x = ~cyl - 0.5, x2 = ~cyl + 0.5, y = ~stack_upr_,
    y2 = ~stack_lwr_)

# Collapse across hair &amp; eye colour data across sex
hec &lt;- as.data.frame(xtabs(Freq ~ Hair + Eye, HairEyeColor))
hec %&gt;% compute_stack(~Freq, ~Hair)

# Without stacking - bars overlap
hec %&gt;% ggvis(~Hair, ~Freq, fill = ~Eye, fillOpacity := 0.5) %&gt;%
  layer_rects(y2 = 0, width = band())

# With stacking
hec %&gt;% ggvis(x = ~Hair, y = ~Freq, fill = ~Eye, fillOpacity := 0.5) %&gt;%
  compute_stack(~Freq, ~Hair) %&gt;%
  layer_rects(y = ~stack_lwr_, y2 = ~stack_upr_, width = band())

# layer_bars stacks automatically:
hec %&gt;% ggvis(~Hair, ~Freq, fill = ~Eye, fillOpacity := 0.5) %&gt;%
  group_by(Eye) %&gt;%
  layer_bars(width = 1)
</code></pre>

<hr>
<h2 id='compute_tabulate'>Count data at each location of a categorical variable</h2><span id='topic+compute_tabulate'></span>

<h3>Description</h3>

<p>Count data at each location of a categorical variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_tabulate(x, x_var, w_var = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_tabulate_+3A_x">x</code></td>
<td>
<p>Dataset-like object to count. Built-in methods for data frames,
grouped data frames and ggvis visualisations.</p>
</td></tr>
<tr><td><code id="compute_tabulate_+3A_x_var">x_var</code>, <code id="compute_tabulate_+3A_w_var">w_var</code></td>
<td>
<p>Names of x and weight variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns:
</p>
<table role = "presentation">
<tr><td><code>count_</code></td>
<td>
<p>the number of points</p>
</td></tr>
<tr><td><code>x_</code></td>
<td>
<p>value of bin</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+compute_bin">compute_bin</a></code> For counting cases within ranges of
a continuous variable.
</p>
<p><code><a href="#topic+compute_count">compute_count</a></code> For counting cases at specific locations
of a continuous variable. This is useful when the variable is continuous
but the data is granular.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
# The tabulated column must be countable (not numeric)
## Not run: mtcars %&gt;% compute_tabulate(~cyl)
mtcars %&gt;% mutate(cyl = factor(cyl)) %&gt;% compute_tabulate(~cyl)

# Or equivalently:
mtcars %&gt;% compute_tabulate(~factor(cyl))

# If there's one weight value at each x, it effectively just renames columns.
pressure %&gt;% compute_tabulate(~factor(temperature), ~pressure)

# It doesn't matter whether you transform inside or outside of a vis
mtcars %&gt;% compute_tabulate(~factor(cyl)) %&gt;%
  ggvis(x = ~x_, y = ~count_, y2 = 0) %&gt;%
  layer_rects(width = band())

mtcars %&gt;%
  ggvis(x = ~x_, y = ~count_, y2 = 0) %&gt;%
  compute_tabulate(~factor(cyl)) %&gt;%
  layer_rects(width = band())

# compute_tabulate is used automatically in layer_bars when no y prop
# is supplied.
mtcars %&gt;% ggvis(x = ~factor(cyl)) %&gt;% layer_bars()
</code></pre>

<hr>
<h2 id='create_broker'>Create a broker object</h2><span id='topic+create_broker'></span>

<h3>Description</h3>

<p>A broker is a subclass of reactive. It can hold extra information to
facilitate (or broker) communication between the client and the server.
For example, an input broker may contain HTML controls to be emitted on the
client web page, as well as a function to connect the inputs from the client
to the reactive expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_broker(r, controls = NULL, connect = NULL, spec = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_broker_+3A_r">r</code></td>
<td>
<p>A reactive expression.</p>
</td></tr>
<tr><td><code id="create_broker_+3A_controls">controls</code></td>
<td>
<p>An HTML control, or a list of HTML controls.</p>
</td></tr>
<tr><td><code id="create_broker_+3A_connect">connect</code></td>
<td>
<p>A function to run at render time. This function takes the
Shiny <code>session</code> object as its only argument, and is used to connect
the session with the broker object.</p>
</td></tr>
<tr><td><code id="create_broker_+3A_spec">spec</code></td>
<td>
<p>Object to put in the Vega spec.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Other types of brokers are possible. Another broker may create reactive
observers and add information to the Vega spec, instead of having HTML
controls. In this case, a reactive expression is still needed, although
it can be a dummy value, like <code>reactive(NULL)</code>.
</p>

<hr>
<h2 id='create_input'>Create a new interactive &quot;input&quot; object.</h2><span id='topic+create_input'></span>

<h3>Description</h3>

<p>An interactive input object is a reactive expression which wraps a reactive
value. When the plot is rendered, an observer is created which pushes values
into the reactive value in response to changes of an input object. Those
changes invalidate the reactive expression, which will return the value,
optionally passed through a mapping function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_input(
  id = rand_id("input_"),
  default = NULL,
  map = identity,
  controls = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_input_+3A_id">id</code></td>
<td>
<p>The name of the input object in the Shiny app, such as
&quot;slider_1338869&quot;.</p>
</td></tr>
<tr><td><code id="create_input_+3A_default">default</code></td>
<td>
<p>The default (starting) value for the input.</p>
</td></tr>
<tr><td><code id="create_input_+3A_map">map</code></td>
<td>
<p>A mapping function. Defaults to <code>identity</code>, which simply
returns the value unchanged.</p>
</td></tr>
<tr><td><code id="create_input_+3A_controls">controls</code></td>
<td>
<p>A Shiny HTML tag object representing the UI for the controls.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to be used by authors of new types of interactive
inputs. If you are a ggvis user, please use one of the more specific input
functions starting with the <code>input_</code>.
</p>

<hr>
<h2 id='default_options'>Default options</h2><span id='topic+default_options'></span>

<h3>Description</h3>

<p>This returns an object containing the default options for ggvis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_options()
</code></pre>

<hr>
<h2 id='dplyr-ggvis'>Dplyr verbs for ggvis.</h2><span id='topic+dplyr-ggvis'></span><span id='topic+groups.ggvis'></span><span id='topic+group_by.ggvis'></span><span id='topic+ungroup.ggvis'></span><span id='topic+summarise.ggvis'></span><span id='topic+mutate.ggvis'></span><span id='topic+arrange.ggvis'></span><span id='topic+select.ggvis'></span><span id='topic+filter.ggvis'></span><span id='topic+distinct.ggvis'></span><span id='topic+slice.ggvis'></span><span id='topic+rename.ggvis'></span><span id='topic+transmute.ggvis'></span><span id='topic+groups.reactive'></span><span id='topic+ungroup.reactive'></span><span id='topic+group_by.reactive'></span><span id='topic+summarise.reactive'></span><span id='topic+mutate.reactive'></span><span id='topic+arrange.reactive'></span><span id='topic+select.reactive'></span><span id='topic+filter.reactive'></span><span id='topic+distinct.reactive'></span><span id='topic+slice.reactive'></span><span id='topic+rename.reactive'></span><span id='topic+transmute.reactive'></span>

<h3>Description</h3>

<p>Applying a dplyr verb to a ggvis object creates a reactive transformation:
whenever the underlying data changes the transformation will be recomputed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggvis'
groups(x)

## S3 method for class 'ggvis'
group_by(.data, ..., .add = FALSE)

## S3 method for class 'ggvis'
ungroup(x, ...)

## S3 method for class 'ggvis'
summarise(.data, ...)

## S3 method for class 'ggvis'
mutate(.data, ...)

## S3 method for class 'ggvis'
arrange(.data, ...)

## S3 method for class 'ggvis'
select(.data, ...)

filter.ggvis(.data, ...)

## S3 method for class 'ggvis'
distinct(.data, ...)

## S3 method for class 'ggvis'
slice(.data, ...)

## S3 method for class 'ggvis'
rename(.data, ...)

## S3 method for class 'ggvis'
transmute(.data, ...)

## S3 method for class 'reactive'
groups(x)

## S3 method for class 'reactive'
ungroup(x, ...)

## S3 method for class 'reactive'
group_by(.data, ..., add = FALSE)

## S3 method for class 'reactive'
summarise(.data, ...)

## S3 method for class 'reactive'
mutate(.data, ...)

## S3 method for class 'reactive'
arrange(.data, ...)

## S3 method for class 'reactive'
select(.data, ...)

filter.reactive(.data, ...)

## S3 method for class 'reactive'
distinct(.data, ...)

## S3 method for class 'reactive'
slice(.data, ...)

## S3 method for class 'reactive'
rename(.data, ...)

## S3 method for class 'reactive'
transmute(.data, ...)
</code></pre>


<h3>Non-standard evaluation</h3>

<p>Both dplyr and shiny do non-standard evaluation, so to help each package
figure out when it should evaluate its code, reactive components in
these functions must be wrapped in <code>eval()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
base &lt;- mtcars %&gt;% ggvis(~mpg, ~cyl) %&gt;% layer_points()
base %&gt;% group_by(cyl) %&gt;% summarise(mpg = mean(mpg)) %&gt;%
  layer_points(fill := "red", size := 100)

base %&gt;% filter(mpg &gt; 25) %&gt;% layer_points(fill := "red")

base %&gt;% mutate(cyl = jitter(cyl)) %&gt;% layer_points(fill := "red")

## Not run: 
# Dynamically restrict range using filter
mtcars %&gt;% ggvis(~disp, ~mpg) %&gt;%
   filter(cyl &gt; eval(input_slider(0, 10))) %&gt;%
   layer_points()

# Dynamically compute box-cox transformation with mutate
bc &lt;- function(x, lambda) {
  if (abs(lambda) &lt; 1e-6) log(x) else (x ^ lambda - 1) / lambda
}
bc_slider &lt;- input_slider(-2, 2, 1, step = 0.1)
mtcars %&gt;%
 ggvis(~disp, ~mpg) %&gt;%
 mutate(disp = bc(disp, eval(bc_slider))) %&gt;%
 layer_points()

## End(Not run)
</code></pre>

<hr>
<h2 id='explain'>Explain details of an object</h2><span id='topic+explain'></span>

<h3>Description</h3>

<p>This is a generic function which gives more details about an object than
print, and is more focussed on human readable output than str.
</p>


<h3>See Also</h3>

<p><code>dplyr::<a href="dplyr.html#topic+explain">explain</a></code> for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- mtcars %&gt;% ggvis(x = ~cyl) %&gt;% layer_bars()
explain(p)
</code></pre>

<hr>
<h2 id='explain.ggvis'>Print out the structure of a ggvis object in a friendly format</h2><span id='topic+explain.ggvis'></span>

<h3>Description</h3>

<p>Print out the structure of a ggvis object in a friendly format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggvis'
explain(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="explain.ggvis_+3A_x">x</code></td>
<td>
<p>Visualisation to explain</p>
</td></tr>
<tr><td><code id="explain.ggvis_+3A_...">...</code></td>
<td>
<p>Needed for compatibility with generic. Ignored by this method.</p>
</td></tr>
</table>

<hr>
<h2 id='export_png'>Export a PNG or SVG from a ggvis object</h2><span id='topic+export_png'></span><span id='topic+export_svg'></span>

<h3>Description</h3>

<p>This requires that the external program <code>vg2png</code> is installed. This is
part of the <code>vega</code> node.js module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_png(vis, file = NULL)

export_svg(vis, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_png_+3A_vis">vis</code></td>
<td>
<p>A ggvis object.</p>
</td></tr>
<tr><td><code id="export_png_+3A_file">file</code></td>
<td>
<p>Output file name. If NULL, defaults to &quot;plot.svg&quot; or &quot;plot.png&quot;.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://github.com/trifacta/vega">https://github.com/trifacta/vega</a> for information on installing
<code>vg2png</code> and <code>vg2svg</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mtcars %&gt;% ggvis(x = ~wt) %&gt;% export_png()

## End(Not run)
</code></pre>

<hr>
<h2 id='fullseq'>Generate sequence of fixed size intervals covering range.</h2><span id='topic+fullseq'></span>

<h3>Description</h3>

<p>Generate sequence of fixed size intervals covering range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fullseq(range, size, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fullseq_+3A_range">range</code></td>
<td>
<p>range</p>
</td></tr>
<tr><td><code id="fullseq_+3A_size">size</code></td>
<td>
<p>interval size</p>
</td></tr>
<tr><td><code id="fullseq_+3A_...">...</code></td>
<td>
<p>other arguments passed on to methods</p>
</td></tr>
</table>

<hr>
<h2 id='get_data'>Get data from a ggvis object</h2><span id='topic+get_data'></span>

<h3>Description</h3>

<p>This function is useful for inspecting the data in a ggvis object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(vis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_data_+3A_vis">vis</code></td>
<td>
<p>A ggvis object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- cocaine %&gt;% ggvis(~price) %&gt;% layer_bars()
get_data(p)

</code></pre>

<hr>
<h2 id='ggvis'>Visualise a data set with a ggvis graphic.</h2><span id='topic+ggvis'></span>

<h3>Description</h3>

<p><code>ggvis</code> is used to turn a dataset into a visualisation, setting up
default mappings between variables in the dataset and visual properties.
Nothing will be displayed until you add additional layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggvis(data = NULL, ..., env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggvis_+3A_data">data</code></td>
<td>
<p>A data object.</p>
</td></tr>
<tr><td><code id="ggvis_+3A_...">...</code></td>
<td>
<p>Property mappings. If not named, the first two mappings are
taken to be <code>x</code> and <code>y</code>. Common properties are <code>x</code>,
<code>y</code>, <code>stroke</code>, <code>fill</code>, <code>opacity</code>, <code>shape</code></p>
</td></tr>
<tr><td><code id="ggvis_+3A_env">env</code></td>
<td>
<p>Environment in which to evaluate properties.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># If you don't supply a layer, ggvis uses layer_guess() to guess at
# an appropriate type:
mtcars %&gt;% ggvis(~mpg, ~wt)
mtcars %&gt;% ggvis(~mpg, ~wt, fill = ~cyl)
mtcars %&gt;% ggvis(~mpg, ~wt, fill := "red")
mtcars %&gt;% ggvis(~mpg)

# ggvis has a functional interface: every ggvis function takes a ggvis
# an input and returns a modified ggvis as output.
layer_points(ggvis(mtcars, ~mpg, ~wt))

# To make working with this interface more natural, ggvis imports the
# pipe operator from magrittr. x %&gt;% f(y) is equivalent to f(x, y) so
# we can rewrite the previous command as
mtcars %&gt;% ggvis(~mpg, ~wt) %&gt;% layer_points()

# For more complicated plots, add a line break after %&gt;%
mtcars %&gt;%
  ggvis(~mpg, ~wt) %&gt;%
  layer_points() %&gt;%
  layer_smooths()
</code></pre>

<hr>
<h2 id='ggvis_message'>Send a message to ggvis running on client</h2><span id='topic+ggvis_message'></span>

<h3>Description</h3>

<p>This will be sent to the client and passed to a handler in ggvis.messages on
the client side. The handler is specified by <code>type</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggvis_message(session, type, data = NULL, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggvis_message_+3A_session">session</code></td>
<td>
<p>A session object.</p>
</td></tr>
<tr><td><code id="ggvis_message_+3A_type">type</code></td>
<td>
<p>A string representing the type of the message.</p>
</td></tr>
<tr><td><code id="ggvis_message_+3A_data">data</code></td>
<td>
<p>An object (typically a list) containing information for the client.</p>
</td></tr>
<tr><td><code id="ggvis_message_+3A_id">id</code></td>
<td>
<p>A unique identifier for ggvis message handler (optional).</p>
</td></tr>
</table>

<hr>
<h2 id='ggvis_scale'>Create a new ggvis_scale object.</h2><span id='topic+ggvis_scale'></span><span id='topic+is.ggvis_scale'></span>

<h3>Description</h3>

<p>A scale object is a close mapping to a vega mark object. Vega scales
are documented in <a href="https://vega.github.io/vega/docs/scales/">https://vega.github.io/vega/docs/scales/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggvis_scale(
  property,
  name = property,
  label = name,
  type = NULL,
  domain = NULL,
  range = NULL,
  reverse = NULL,
  round = NULL,
  ...,
  subclass = NULL,
  override = NULL
)

is.ggvis_scale(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggvis_scale_+3A_property">property</code></td>
<td>
<p>The property to which the scale applies, such as &quot;x&quot;, &quot;y&quot;,
&quot;fill&quot;, etc.</p>
</td></tr>
<tr><td><code id="ggvis_scale_+3A_name">name</code></td>
<td>
<p>Name of the scale, such as &quot;x&quot;, &quot;y&quot;, &quot;fill&quot;, etc. Can also be an
arbitrary name like &quot;foo&quot;.</p>
</td></tr>
<tr><td><code id="ggvis_scale_+3A_label">label</code></td>
<td>
<p>Label for the scale. Used for axis or legend titles.</p>
</td></tr>
<tr><td><code id="ggvis_scale_+3A_type">type</code></td>
<td>
<p>Type of scale. Should be one of &quot;linear&quot;, &quot;ordinal&quot;, &quot;time&quot;,
&quot;utc&quot;, &quot;linear&quot;, &quot;log&quot;, &quot;pow&quot;, &quot;sqrt&quot;, &quot;quantile&quot;, &quot;quantize&quot;, &quot;threshold&quot;.</p>
</td></tr>
<tr><td><code id="ggvis_scale_+3A_domain">domain</code></td>
<td>
<p>The domain of the scale, representing the set of data values.
For ordinal scales, a character vector; for quantitative scales, a numeric
vector of length two. Either value (but not both) may be NA, in which
case <code>domainMin</code> or <code>domainMax</code> is set. For dynamic scales, this
can also be a reactive which returns the appropriate type of vector.</p>
</td></tr>
<tr><td><code id="ggvis_scale_+3A_range">range</code></td>
<td>
<p>The range of the scale, representing the set of visual values.
For numeric values, the range can take the form of a two-element array with
minimum and maximum values. For ordinal data, the range may by an array of
desired output values, which are mapped to elements in the specified
domain. The following range literals are also available: &quot;width&quot;, &quot;height&quot;,
&quot;shapes&quot;, &quot;category10&quot;, &quot;category20&quot;.</p>
</td></tr>
<tr><td><code id="ggvis_scale_+3A_reverse">reverse</code></td>
<td>
<p>If true, flips the scale range.</p>
</td></tr>
<tr><td><code id="ggvis_scale_+3A_round">round</code></td>
<td>
<p>If true, rounds numeric output values to integers. This can be
helpful for snapping to the pixel grid.</p>
</td></tr>
<tr><td><code id="ggvis_scale_+3A_...">...</code></td>
<td>
<p>other named arguments.</p>
</td></tr>
<tr><td><code id="ggvis_scale_+3A_subclass">subclass</code></td>
<td>
<p>Class name for subclass.  Will have <code>scale_</code> prepended.</p>
</td></tr>
<tr><td><code id="ggvis_scale_+3A_override">override</code></td>
<td>
<p>Should the domain specified by this ggvis_scale object
override other ggvis_scale objects for the same scale? Useful when domain is
manually specified. For example, by default, the domain of the scale
will contain the range of the data, but when this is TRUE, the specified
domain will override, and the domain can be smaller than the range of the
data. If <code>FALSE</code>, the <code>domain</code> will not behave this way. If
left <code>NULL</code>, then it will be treated as <code>TRUE</code> whenever
<code>domain</code> is non-NULL.</p>
</td></tr>
<tr><td><code id="ggvis_scale_+3A_x">x</code></td>
<td>
<p>object to test for scale-ness</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to be used by authors of new types of scale.
If you are a ggvis user, please use one of the more specific scale
functions starting with the <code>scale_</code>.
</p>
<p>This is very close, but not exactly a vega scale object. Instead of being a
named list with a set of values, the domain can be  a vector of values, or a
reactive that returns such values.
</p>


<h3>See Also</h3>

<p><a href="https://vega.github.io/vega/docs/scales/">https://vega.github.io/vega/docs/scales/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggvis_scale("x", type = "linear")
ggvis_scale("x", "ord")
</code></pre>

<hr>
<h2 id='ggvisControlOutput'>Create a ggvis control output element in UI</h2><span id='topic+ggvisControlOutput'></span>

<h3>Description</h3>

<p>This is effectively the same as <code><a href="shiny.html#topic+uiOutput">uiOutput</a></code>, except that
on the client side it may call some plot resizing functions after new
controls are drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggvisControlOutput(outputId, plotId = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggvisControlOutput_+3A_outputid">outputId</code></td>
<td>
<p>The output variable to read the value from.</p>
</td></tr>
<tr><td><code id="ggvisControlOutput_+3A_plotid">plotId</code></td>
<td>
<p>An optional plot ID or vector of plot IDs. The plots will
have their .onControlOutput functions called after the controls are drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggvisControlOutput</code> is intended to be used with
<code><a href="#topic+bind_shiny">bind_shiny</a></code> on the server side.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggvisControlOutput("plot1")
</code></pre>

<hr>
<h2 id='ggvisOutputElements'>Create HTML elements for ggvis output</h2><span id='topic+ggvisOutputElements'></span>

<h3>Description</h3>

<p>This is an internal-facing function similar to ggvisOutput, but with more
options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggvisOutputElements(plot_id = rand_id("plot_id"), spec = NULL, shiny = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggvisOutputElements_+3A_plot_id">plot_id</code></td>
<td>
<p>Unique identifier to use for the div containing the ggvis plot.</p>
</td></tr>
<tr><td><code id="ggvisOutputElements_+3A_spec">spec</code></td>
<td>
<p>Plot specification, used internally.</p>
</td></tr>
<tr><td><code id="ggvisOutputElements_+3A_shiny">shiny</code></td>
<td>
<p>Should this include headers for Shiny? For dynamic and
interactive plots, this should be TRUE; otherwise FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='group_by'>Divide data into groups.</h2><span id='topic+group_by'></span>

<h3>Description</h3>

<p>Divide data into groups.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_by_+3A_x">x</code></td>
<td>
<p>a visualisation</p>
</td></tr>
<tr><td><code id="group_by_+3A_...">...</code></td>
<td>
<p>variables to group by.</p>
</td></tr>
<tr><td><code id="group_by_+3A_add">add</code></td>
<td>
<p>By default, when <code>add = FALSE</code>, <code>group_by</code> will
override existing groups. To instead add to the existing groups,
use <code>add = TRUE</code></p>
</td></tr>
</table>

<hr>
<h2 id='handle_brush'>Handle brush events on a visualisation.</h2><span id='topic+handle_brush'></span>

<h3>Description</h3>

<p>Currently for brush events to be triggered on a visualisation, you must
use a <code>.brush</code> property. This limitation will be lifted in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_brush(vis, on_move = NULL, fill = "black")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_brush_+3A_vis">vis</code></td>
<td>
<p>Visualisation to listen to.</p>
</td></tr>
<tr><td><code id="handle_brush_+3A_on_move">on_move</code></td>
<td>
<p>Callback function with arguments:
</p>

<dl>
<dt>items</dt><dd><p>A data frame containing information about the items
under the plot. An empty data.frame if no points under the brush.</p>
</dd>
<dt>page_loc</dt><dd><p>Location of the brush with repsect to the page</p>
</dd>
<dt>plot_loc</dt><dd><p>Location of the brush with respect to the plot</p>
</dd>
<dt>session</dt><dd><p>The session, used to communicate with the browser</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="handle_brush_+3A_fill">fill</code></td>
<td>
<p>Colour of the brush.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Display tooltip when objects are brushed
mtcars %&gt;%
  ggvis(x = ~wt, y = ~mpg, size.brush := 400) %&gt;%
  layer_points() %&gt;%
  handle_brush(function(items, page_loc, session, ...) {
    show_tooltip(session, page_loc$r + 5, page_loc$t, html = nrow(items))
  })
</code></pre>

<hr>
<h2 id='handle_click'>Handle mouse actions on marks.</h2><span id='topic+handle_click'></span><span id='topic+handle_hover'></span>

<h3>Description</h3>

<p>Handle mouse actions on marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_click(vis, on_click = NULL)

handle_hover(vis, on_mouse_over = NULL, on_mouse_out = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_click_+3A_vis">vis</code></td>
<td>
<p>Visualisation to listen to.</p>
</td></tr>
<tr><td><code id="handle_click_+3A_on_click">on_click</code>, <code id="handle_click_+3A_on_mouse_over">on_mouse_over</code></td>
<td>
<p>Callback function with arguments:
</p>

<dl>
<dt>data</dt><dd><p>A data frame with one row</p>
</dd>
<dt>location</dt><dd><p>A named list with components x and y</p>
</dd>
<dt>session</dt><dd><p>The session, used to communicate with the browser</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="handle_click_+3A_on_mouse_out">on_mouse_out</code></td>
<td>
<p>Callback function with argument:
</p>

<dl>
<dt>session</dt><dd><p>The session, used to communicate with the browser</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>location &lt;- function(location, ...) cat(location$x, "x", location$y, "\n")
mtcars %&gt;% ggvis(~mpg, ~wt) %&gt;% layer_points() %&gt;%
  handle_click(location)
mtcars %&gt;% ggvis(~mpg, ~wt) %&gt;% layer_points() %&gt;%
  handle_hover(function(...) cat("over\n"), function(...) cat("off\n"))
mtcars %&gt;% ggvis(~mpg, ~wt) %&gt;% layer_points() %&gt;%
  handle_hover(function(data, ...) str(data))
</code></pre>

<hr>
<h2 id='handle_resize'>Handlers and interactive inputs for plot sizing.</h2><span id='topic+handle_resize'></span><span id='topic+plot_width'></span><span id='topic+plot_height'></span>

<h3>Description</h3>

<p>Handlers and interactive inputs for plot sizing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_resize(vis, on_resize)

plot_width(vis)

plot_height(vis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_resize_+3A_vis">vis</code></td>
<td>
<p>Visualisation to listen to.</p>
</td></tr>
<tr><td><code id="handle_resize_+3A_on_resize">on_resize</code></td>
<td>
<p>Callback function with arguments:
</p>

<dl>
<dt>width,height</dt><dd><p>Width and height in pixels</p>
</dd>
<dt>padding</dt><dd><p>A named list of four components giving the padding in
each direction</p>
</dd>
<dt>session</dt><dd><p>The session, used to communicate with the browser</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># This example just prints out the current dimensions to the console
mtcars %&gt;% ggvis(~mpg, ~wt) %&gt;%
  layer_points() %&gt;%
  handle_resize(function(width, height, ...) cat(width, "x", height, "\n"))

# Use plot_width() and plot_height() to dynamically get the plot size
# inside the plot.
mtcars %&gt;% ggvis(~mpg, ~wt) %&gt;% layer_text(text := plot_width())
mtcars %&gt;% ggvis(~mpg, ~wt) %&gt;% layer_text(text := plot_height())
</code></pre>

<hr>
<h2 id='input_checkbox'>Create an interactive checkbox.</h2><span id='topic+input_checkbox'></span>

<h3>Description</h3>

<p>Create an interactive checkbox.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>input_checkbox(
  value = FALSE,
  label = "",
  id = rand_id("checkbox_"),
  map = identity
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="input_checkbox_+3A_value">value</code></td>
<td>
<p>Initial value (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="input_checkbox_+3A_label">label</code></td>
<td>
<p>Display label for the control, or <code>NULL</code> for no label.</p>
</td></tr>
<tr><td><code id="input_checkbox_+3A_id">id</code></td>
<td>
<p>A unique identifier for this input. Usually generated
automatically.</p>
</td></tr>
<tr><td><code id="input_checkbox_+3A_map">map</code></td>
<td>
<p>A function with single argument <code>x</code>, the value of the
control on the client. Returns a modified value.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other interactive input: 
<code><a href="#topic+input_select">input_select</a>()</code>,
<code><a href="#topic+input_slider">input_slider</a>()</code>,
<code><a href="#topic+input_text">input_text</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
input_checkbox(label = "Confidence interval")
input_checkbox(label = "Confidence interval", value = TRUE)

# Used in layer_smooths
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;%
  layer_smooths(se = input_checkbox(label = "Confidence interval"))

# Used with a map function, to convert the boolean to another type of value
model_type &lt;- input_checkbox(label = "Use flexible curve",
  map = function(val) if(val) "loess" else "lm")
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;%
  layer_model_predictions(model = model_type)
</code></pre>

<hr>
<h2 id='input_select'>Create interactive control to select one (or more options) from a list.</h2><span id='topic+input_select'></span><span id='topic+input_radiobuttons'></span><span id='topic+input_checkboxgroup'></span>

<h3>Description</h3>


<ul>
<li> <p><code>input_radiobuttons</code> only ever selects one value
</p>
</li>
<li> <p><code>input_checkboxgroup</code> can alway select multiple values
</p>
</li>
<li> <p><code>input_select</code> can select only one if <code>multiple = FALSE</code>,
otherwise the user can select multiple by using modifier keys
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>input_select(
  choices,
  selected = NULL,
  multiple = FALSE,
  label = "",
  id = rand_id("select_"),
  map = identity,
  selectize = FALSE
)

input_radiobuttons(
  choices,
  selected = NULL,
  label = "",
  id = rand_id("radio_"),
  map = identity
)

input_checkboxgroup(
  choices,
  selected = NULL,
  label = "",
  id = rand_id("radio_"),
  map = identity
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="input_select_+3A_choices">choices</code></td>
<td>
<p>List of values to select from. If elements of the list are
named, then that name &mdash; rather than the value &mdash; is displayed to the
user. It's also possible to group related inputs by providing a named list
whose elements are (either named or unnamed) lists, vectors, or factors. In
this case, the outermost names will be used as the group labels (leveraging
the <code style="white-space: pre;">&#8288;&lt;optgroup&gt;&#8288;</code> HTML tag) for the elements in the respective sublist. See
the example section for a small demo of this feature.</p>
</td></tr>
<tr><td><code id="input_select_+3A_selected">selected</code></td>
<td>
<p>The initially selected value (or multiple values if <code>multiple = TRUE</code>). If not specified then defaults to the first value for
single-select lists and no values for multiple select lists.</p>
</td></tr>
<tr><td><code id="input_select_+3A_multiple">multiple</code></td>
<td>
<p>Is selection of multiple items allowed?</p>
</td></tr>
<tr><td><code id="input_select_+3A_label">label</code></td>
<td>
<p>Display label for the control, or <code>NULL</code> for no label.</p>
</td></tr>
<tr><td><code id="input_select_+3A_id">id</code></td>
<td>
<p>A unique identifier for this input. Usually generated
automatically.</p>
</td></tr>
<tr><td><code id="input_select_+3A_map">map</code></td>
<td>
<p>A function with single argument <code>x</code>, the value of the
control on the client. Returns a modified value.</p>
</td></tr>
<tr><td><code id="input_select_+3A_selectize">selectize</code></td>
<td>
<p>Whether to use <span class="pkg">selectize.js</span> or not.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other interactive input: 
<code><a href="#topic+input_checkbox">input_checkbox</a>()</code>,
<code><a href="#topic+input_slider">input_slider</a>()</code>,
<code><a href="#topic+input_text">input_text</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Dropdown
input_select(c("a", "b", "c"))
input_select(c("a", "b", "c"), multiple = TRUE)
input_select(c("a", "b", "c"), selected = "c")

# If you want to select variable names, you need to convert
# the output of the input to a name with map so that they get
# computed correctly
input_select(names(mtcars), map = as.name)

# Radio buttons
input_radiobuttons(choices = c("Linear" = "lm", "LOESS" = "loess"),
                   label = "Model type")
input_radiobuttons(choices = c("Linear" = "lm", "LOESS" = "loess"),
                   selected = "loess",
                   label = "Model type")

# Used in layer_model_predictions
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;%
  layer_model_predictions(model = input_radiobuttons(
    choices = c("Linear" = "lm", "LOESS" = "loess"),
    selected = "loess",
    label = "Model type"))

# Checkbox group
mtcars %&gt;% ggvis(x = ~wt, y = ~mpg) %&gt;%
  layer_points(
    fill := input_checkboxgroup(
      choices = c("Red" = "r", "Green" = "g", "Blue" = "b"),
      label = "Point color components",
      map = function(val) {
        rgb(0.8 * "r" %in% val, 0.8 * "g" %in% val, 0.8 * "b" %in% val)
      }
    )
  )
</code></pre>

<hr>
<h2 id='input_slider'>Create an interactive slider.</h2><span id='topic+input_slider'></span>

<h3>Description</h3>

<p>Create an interactive slider.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>input_slider(
  min,
  max,
  value = (min + max)/2,
  step = NULL,
  round = FALSE,
  format = NULL,
  locale = "us",
  ticks = TRUE,
  animate = FALSE,
  sep = ",",
  pre = NULL,
  post = NULL,
  label = "",
  id = rand_id("slider_"),
  map = identity
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="input_slider_+3A_min">min</code>, <code id="input_slider_+3A_max">max</code></td>
<td>
<p>The minimum and maximum values (inclusive) that can be
selected.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_value">value</code></td>
<td>
<p>The initial value of the slider, either a number, a date
(class Date), or a date-time (class POSIXt). A length one vector will
create a regular slider; a length two vector will create a double-ended
range slider. Must lie between <code>min</code> and <code>max</code>.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_step">step</code></td>
<td>
<p>Specifies the interval between each selectable value on the
slider. Either <code>NULL</code>, the default, which uses a heuristic to determine the
step size or a single number. If the values are dates, <code>step</code> is in days;
if the values are date-times, <code>step</code> is in seconds.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_round">round</code></td>
<td>
<p><code>TRUE</code> to round all values to the nearest integer;
<code>FALSE</code> if no rounding is desired; or an integer to round to that
number of digits (for example, 1 will round to the nearest 10, and -2 will
round to the nearest .01). Any rounding will be applied after snapping to
the nearest step.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_format">format</code></td>
<td>
<p>A string specifying how to format the value.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_locale">locale</code></td>
<td>
<p>A string specifying the locale to use for formatting.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_ticks">ticks</code></td>
<td>
<p><code>FALSE</code> to hide tick marks, <code>TRUE</code> to show them
according to some simple heuristics.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_animate">animate</code></td>
<td>
<p><code>TRUE</code> to show simple animation controls with default
settings; <code>FALSE</code> not to; or a custom settings list, such as those
created using <code><a href="shiny.html#topic+animationOptions">animationOptions()</a></code>.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_sep">sep</code></td>
<td>
<p>Separator between thousands places in numbers.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_pre">pre</code></td>
<td>
<p>A prefix string to put in front of the value.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_post">post</code></td>
<td>
<p>A suffix string to put after the value.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_label">label</code></td>
<td>
<p>Display label for the control, or <code>NULL</code> for no label.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_id">id</code></td>
<td>
<p>A unique identifier for this input. Usually generated
automatically.</p>
</td></tr>
<tr><td><code id="input_slider_+3A_map">map</code></td>
<td>
<p>A function with single argument <code>x</code>, the value of the
control on the client. Returns a modified value.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other interactive input: 
<code><a href="#topic+input_checkbox">input_checkbox</a>()</code>,
<code><a href="#topic+input_select">input_select</a>()</code>,
<code><a href="#topic+input_text">input_text</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_slider(0, 100)
input_slider(0, 100, label = "binwidth")
input_slider(0, 100, value = 50)

# Supply two values to value to make a double-ended sliders
input_slider(0, 100, c(25, 75))

# You can use map to transform the outputs
input_slider(-5, 5, label = "Log scale", map = function(x) 10 ^ x)
</code></pre>

<hr>
<h2 id='input_text'>Create an interactive text or numeric input box.</h2><span id='topic+input_text'></span><span id='topic+input_numeric'></span>

<h3>Description</h3>

<p><code>input_numeric</code> only allows numbers and comes with a spin box control.
<code>input_text</code> allows any type of input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>input_text(value, label = "", id = rand_id("text_"), map = identity)

input_numeric(value, label = "", id = rand_id("numeric_"), map = identity)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="input_text_+3A_value">value</code></td>
<td>
<p>Initial value.</p>
</td></tr>
<tr><td><code id="input_text_+3A_label">label</code></td>
<td>
<p>Display label for the control, or <code>NULL</code> for no label.</p>
</td></tr>
<tr><td><code id="input_text_+3A_id">id</code></td>
<td>
<p>A unique identifier for this input. Usually generated
automatically.</p>
</td></tr>
<tr><td><code id="input_text_+3A_map">map</code></td>
<td>
<p>A function with single argument <code>x</code>, the value of the
control on the client. Returns a modified value.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other interactive input: 
<code><a href="#topic+input_checkbox">input_checkbox</a>()</code>,
<code><a href="#topic+input_select">input_select</a>()</code>,
<code><a href="#topic+input_slider">input_slider</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fill_text &lt;- input_text(label = "Point color", value = "red")
mtcars %&gt;% ggvis(~wt, ~mpg, fill := fill_text) %&gt;% layer_bars()

size_num &lt;- input_numeric(label = "Point size", value = 25)
mtcars %&gt;% ggvis(~wt, ~mpg, size := size_num) %&gt;% layer_points()
</code></pre>

<hr>
<h2 id='is.axis_props'>Tests whether an object is an axis_props object</h2><span id='topic+is.axis_props'></span>

<h3>Description</h3>

<p>Tests whether an object is an axis_props object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.axis_props(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.axis_props_+3A_x">x</code></td>
<td>
<p>an object to test</p>
</td></tr>
</table>

<hr>
<h2 id='is.broker'>Determine if an object is a broker object</h2><span id='topic+is.broker'></span>

<h3>Description</h3>

<p>Determine if an object is a broker object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.broker(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.broker_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>

<hr>
<h2 id='is.dynamic'>Determine if an ggvis is dynamic (i.e. needs to be run in a shiny app)</h2><span id='topic+is.dynamic'></span>

<h3>Description</h3>

<p>Determine if an ggvis is dynamic (i.e. needs to be run in a shiny app)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dynamic(x)
</code></pre>

<hr>
<h2 id='is.ggvis'>Is an object a ggvis object?</h2><span id='topic+is.ggvis'></span>

<h3>Description</h3>

<p>Is an object a ggvis object?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ggvis(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.ggvis_+3A_x">x</code></td>
<td>
<p>an object to test</p>
</td></tr>
</table>

<hr>
<h2 id='is.legend_props'>Tests whether an object is a legend_props object</h2><span id='topic+is.legend_props'></span>

<h3>Description</h3>

<p>Tests whether an object is a legend_props object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.legend_props(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.legend_props_+3A_x">x</code></td>
<td>
<p>an object to test</p>
</td></tr>
</table>

<hr>
<h2 id='is.scaled_value'>Tests whether an object is a scaled_value object</h2><span id='topic+is.scaled_value'></span>

<h3>Description</h3>

<p>Tests whether an object is a scaled_value object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.scaled_value(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.scaled_value_+3A_x">x</code></td>
<td>
<p>an object to test</p>
</td></tr>
</table>

<hr>
<h2 id='knit_print.ggvis'>Knit print method for ggvis plots.</h2><span id='topic+knit_print.ggvis'></span>

<h3>Description</h3>

<p>Knit print method for ggvis plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_print.ggvis(x, options = list(), inline = FALSE, ...)
</code></pre>

<hr>
<h2 id='layer_bars'>Display data with bars (a barchart).</h2><span id='topic+layer_bars'></span>

<h3>Description</h3>

<p>This will add bars to a plot. The exact behavior is complicated because
the term bar chart is used to describe four important variations on a theme.
The action of <code>layer_bars</code> depends on two factors: whether or not a
<code>y</code> prop has been specified, and whether the <code>x</code> props is
continuous or categorical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_bars(vis, ..., stack = TRUE, width = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layer_bars_+3A_vis">vis</code></td>
<td>
<p>Visualisation to modify</p>
</td></tr>
<tr><td><code id="layer_bars_+3A_...">...</code></td>
<td>
<p>Visual properties used to override defaults.</p>
</td></tr>
<tr><td><code id="layer_bars_+3A_stack">stack</code></td>
<td>
<p>If there are multiple bars to be drawn at an x location, should
the bars be stacked? If FALSE, the bars will be overplotted on each other.</p>
</td></tr>
<tr><td><code id="layer_bars_+3A_width">width</code></td>
<td>
<p>Width of each bar. When x is continuous, this controls the width
in the same units as x. When x is categorical, this controls the width as a
proportion of the spacing between items (default is 0.9).</p>
</td></tr>
</table>


<h3>Visualisations</h3>

<p>If no y prop has been specified, then this will count the number of entries
at each unique x value. There will be one bar at each unique x value, and
the y value (or height) of each bar will represent the count at that x value.
</p>
<p>If a y prop has been specified, then those y values will be used as weights
for a weighted count at each unique x value. If no x values appear more than
once in the data, then the end result is a plot where the height of the bar
at each x value is simply the y value. However, if an x value appear more
than once in the data, then this will sum up the y values at each x.
</p>
<p>If the x variable is continuous, then a continuous x axis will be used, and
the width of each bar is by default equal to the resolution of the data &ndash;
that is, the smallest difference between any two x values.
</p>
<p>If the x variable is categorical, then a categorical x axis will be used. By
default, the width of each bar is 0.9 times the space between the items.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layer_histograms">layer_histograms</a></code> For bar graphs of counts at each unique
x value, in contrast to a histogram's bins along x ranges.
</p>
<p><code><a href="#topic+compute_count">compute_count</a></code> and <code><a href="#topic+compute_tabulate">compute_tabulate</a></code> for
more information on how data is transformed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Discrete x: bar graph of counts at each x value
cocaine %&gt;% ggvis(~state) %&gt;% layer_bars()
# Continuous x: bar graph of counts at unique locations
cocaine %&gt;% ggvis(~month) %&gt;% layer_bars()

# Use y prop to weight by additional variable. This is also useful
# if you have pretabulated data
cocaine %&gt;% ggvis(~state, ~weight) %&gt;% layer_bars()
cocaine %&gt;% ggvis(~month, ~weight) %&gt;% layer_bars()

# For continuous x, layer_bars is useful when the variable has a few
# unique values that you want to preserve. If you have many unique
# values and you want to bin, use layer_histogram
cocaine %&gt;% ggvis(~price) %&gt;% layer_bars()
cocaine %&gt;% ggvis(~price) %&gt;% layer_histograms(width = 100)

# If you have unique x values, you can use layer_bars() as an alternative
# to layer_points()
pressure %&gt;% ggvis(~temperature, ~pressure) %&gt;% layer_points()
pressure %&gt;% ggvis(~temperature, ~pressure) %&gt;% layer_bars()

# When x is continuous, width controls the width in x units
pressure %&gt;% ggvis(~temperature, ~pressure) %&gt;% layer_bars(width = 10)
# When x is categorical, width is proportional to spacing between bars
pressure %&gt;% ggvis(~factor(temperature), ~pressure) %&gt;%
  layer_bars(width = 0.5)

# Stacked bars
# If grouping var is continuous, you need to manually specify grouping
ToothGrowth %&gt;% group_by(dose) %&gt;%
  ggvis(x = ~supp, y = ~len, fill = ~dose) %&gt;% layer_bars()
# If grouping var is categorical, grouping is done automatically
cocaine %&gt;% ggvis(x = ~state, fill = ~as.factor(month)) %&gt;%
  layer_bars()
</code></pre>

<hr>
<h2 id='layer_boxplots'>Display data with a boxplot.</h2><span id='topic+layer_boxplots'></span>

<h3>Description</h3>

<p>This will add boxplots to a plot. The action of <code>layer_boxplots</code> depends
on whether the <code>x</code> prop is continuous or categorical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_boxplots(vis, ..., coef = 1.5, width = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layer_boxplots_+3A_vis">vis</code></td>
<td>
<p>Visualisation to modify</p>
</td></tr>
<tr><td><code id="layer_boxplots_+3A_...">...</code></td>
<td>
<p>Visual properties used to override defaults.</p>
</td></tr>
<tr><td><code id="layer_boxplots_+3A_coef">coef</code></td>
<td>
<p>The maximum length of the whiskers as multiple of the
inter-quartile range. Default value is 1.5.</p>
</td></tr>
<tr><td><code id="layer_boxplots_+3A_width">width</code></td>
<td>
<p>Width of each bar. When x is continuous, this controls the width
in the same units as x. When x is categorical, this controls the width as a
proportion of the spacing between items (default is 0.9).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The upper and lower &quot;hinges&quot; correspond to the first and third quartiles (the
25th and 75th percentiles). This differs slightly from the method used by the
<code>boxplot</code> function, and may be apparent with small samples. See
<code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a></code> for more information on how hinge positions are
calculated for <code>boxplot</code>.
</p>
<p>The upper whisker extends from the hinge to the highest value that is within
1.5 * IQR of the hinge, where IQR is the inter-quartile range, or distance
between the first and third quartiles. The lower whisker extends from the
hinge to the lowest value within 1.5 * IQR of the hinge. Data beyond the end
of the whiskers are outliers and plotted as points (as specified by Tukey).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_boxplot">compute_boxplot</a></code> for more information on how data is
transformed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

mtcars %&gt;% ggvis(~factor(cyl), ~mpg) %&gt;% layer_boxplots()
# Set the width of the boxes to half the space between tick marks
mtcars %&gt;% ggvis(~factor(cyl), ~mpg) %&gt;% layer_boxplots(width = 0.5)

# Continuous x: boxes fill width between data values
mtcars %&gt;% ggvis(~cyl, ~mpg) %&gt;% layer_boxplots()
# Setting width=0.5 makes it 0.5 wide in the data space, which is 1/4 of the
# distance between data values in this particular case.
mtcars %&gt;% ggvis(~cyl, ~mpg) %&gt;% layer_boxplots(width = 0.5)

# Smaller outlier points
mtcars %&gt;% ggvis(~factor(cyl), ~mpg) %&gt;% layer_boxplots(size := 20)
</code></pre>

<hr>
<h2 id='layer_densities'>Transformation: density estimate</h2><span id='topic+layer_densities'></span>

<h3>Description</h3>

<p><code>transform_density</code> is a data transformation that computes a kernel
density estimate from a dataset. <code>layer_density</code> combines
<code>transform_density</code> with <code>mark_path</code> and <code>mark_area</code>
to display a smooth line and its standard errror.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_densities(
  vis,
  ...,
  kernel = "gaussian",
  adjust = 1,
  density_args = list(),
  area = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layer_densities_+3A_vis">vis</code></td>
<td>
<p>The visualisation to modify</p>
</td></tr>
<tr><td><code id="layer_densities_+3A_...">...</code></td>
<td>
<p>Visual properties, passed on to <code><a href="#topic+props">props</a></code>.</p>
</td></tr>
<tr><td><code id="layer_densities_+3A_kernel">kernel</code></td>
<td>
<p>Smoothing kernel. See <code><a href="stats.html#topic+density">density</a></code> for details.</p>
</td></tr>
<tr><td><code id="layer_densities_+3A_adjust">adjust</code></td>
<td>
<p>Multiple the default bandwidth by this amount. Useful for
controlling wiggliness of density.</p>
</td></tr>
<tr><td><code id="layer_densities_+3A_density_args">density_args</code></td>
<td>
<p>Other arguments passed on to
<code><a href="#topic+compute_density">compute_density</a></code> and thence to <code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
<tr><td><code id="layer_densities_+3A_area">area</code></td>
<td>
<p>Should there be a shaded region drawn under the curve?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Basic density estimate
faithful %&gt;% ggvis(~waiting) %&gt;% layer_densities()
faithful %&gt;% ggvis(~waiting) %&gt;% layer_densities(area = FALSE)

# Control bandwidth with adjust
faithful %&gt;% ggvis(~waiting) %&gt;% layer_densities(adjust = .25)
faithful %&gt;% ggvis(~waiting) %&gt;%
  layer_densities(adjust = input_slider(0.1, 5))

# Control stroke and fill
faithful %&gt;% ggvis(~waiting) %&gt;%
  layer_densities(stroke := "red", fill := "red")

# With groups
PlantGrowth %&gt;% ggvis(~weight, fill = ~group) %&gt;% group_by(group) %&gt;%
  layer_densities()
PlantGrowth %&gt;% ggvis(~weight, stroke = ~group) %&gt;% group_by(group) %&gt;%
  layer_densities(strokeWidth := 3, area = FALSE)
</code></pre>

<hr>
<h2 id='layer_f'>Create a new layering function.</h2><span id='topic+layer_f'></span>

<h3>Description</h3>

<p>The layer function is run, and then the state before the code was run
is restored - this allows layers to be effectively isolated from
the rest of the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_f(vis, fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layer_f_+3A_vis">vis</code></td>
<td>
<p>The ggvis visualisation to modify.</p>
</td></tr>
<tr><td><code id="layer_f_+3A_fun">fun</code></td>
<td>
<p>A function that takes a single argument, the current
visualisation as input, and returns a modified visualisation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% ggvis(~mpg) %&gt;%
  layer_f(function(v) {
     v %&gt;% compute_bin(~mpg) %&gt;% layer_points(x = ~x_, y = ~count_)
  }) %&gt;%
  layer_points(y = ~wt)
</code></pre>

<hr>
<h2 id='layer_guess'>Guess the right type of layer based on current properties.</h2><span id='topic+layer_guess'></span>

<h3>Description</h3>

<p><code>layer_guess</code> provides the magic behind the default behaviour of
<code><a href="#topic+ggvis">ggvis</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_guess(vis, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layer_guess_+3A_vis">vis</code></td>
<td>
<p>The visualisation to add the new layer to.</p>
</td></tr>
<tr><td><code id="layer_guess_+3A_...">...</code></td>
<td>
<p>Other arguments passed on individual layers.</p>
</td></tr>
</table>


<h3>Defaults</h3>


<ul>
<li><p> Continuous x, <code><a href="#topic+layer_histograms">layer_histograms</a></code>
</p>
</li>
<li><p> Categorical x, <code><a href="#topic+layer_bars">layer_bars</a></code>
</p>
</li>
<li><p> Continuous x and y, <code><a href="#topic+layer_points">layer_points</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># A scatterplot:
mtcars %&gt;% ggvis(~mpg, ~wt)
mtcars %&gt;% ggvis(~mpg, ~wt) %&gt;% layer_guess()

# A histogram:
mtcars %&gt;% ggvis(~mpg)
mtcars %&gt;% ggvis(~mpg) %&gt;% layer_guess()
</code></pre>

<hr>
<h2 id='layer_histograms'>Display binned data</h2><span id='topic+layer_histograms'></span><span id='topic+layer_freqpolys'></span>

<h3>Description</h3>

<p>Display binned data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_histograms(
  vis,
  ...,
  width = NULL,
  center = NULL,
  boundary = NULL,
  closed = c("right", "left"),
  stack = TRUE,
  binwidth
)

layer_freqpolys(
  vis,
  ...,
  width = NULL,
  center = NULL,
  boundary = NULL,
  closed = c("right", "left"),
  binwidth
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layer_histograms_+3A_vis">vis</code></td>
<td>
<p>Visualisation to modify</p>
</td></tr>
<tr><td><code id="layer_histograms_+3A_...">...</code></td>
<td>
<p>Visual properties used to override defaults.</p>
</td></tr>
<tr><td><code id="layer_histograms_+3A_width">width</code></td>
<td>
<p>The width of the bins. The default is <code>NULL</code>, which yields
30 bins that cover the range of the data. You should always override this
value, exploring multiple widths to find the best to illustrate the stories
in your data.</p>
</td></tr>
<tr><td><code id="layer_histograms_+3A_center">center</code></td>
<td>
<p>The center of one of the bins.  Note that if center is above or
below the range of the data, things will be shifted by an appropriate
number of <code>width</code>s. To center on integers, for example, use
<code>width=1</code> and <code>center=0</code>, even if <code>0</code> is outside the range
of the data.  At most one of <code>center</code> and <code>boundary</code> may be
specified.</p>
</td></tr>
<tr><td><code id="layer_histograms_+3A_boundary">boundary</code></td>
<td>
<p>A boundary between two bins. As with <code>center</code>, things
are shifted when <code>boundary</code> is outside the range of the data. For
example, to center on integers, use <code>width = 1</code> and <code>boundary =
0.5</code>, even if <code>1</code> is outside the range of the data.  At most one of
<code>center</code> and <code>boundary</code> may be specified.</p>
</td></tr>
<tr><td><code id="layer_histograms_+3A_closed">closed</code></td>
<td>
<p>One of <code>"right"</code> or <code>"left"</code> indicating whether right
or left edges of bins are included in the bin.</p>
</td></tr>
<tr><td><code id="layer_histograms_+3A_stack">stack</code></td>
<td>
<p>If <code>TRUE</code>, will automatically stack overlapping bars.</p>
</td></tr>
<tr><td><code id="layer_histograms_+3A_binwidth">binwidth</code></td>
<td>
<p>Deprecated; use <code>width</code> instead.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+layer_bars">layer_bars</a></code> For bar graphs of counts at each unique
x value, in contrast to a histogram's bins along x ranges.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create histograms and frequency polygons with layers
mtcars %&gt;% ggvis(~mpg) %&gt;% layer_histograms()
mtcars %&gt;% ggvis(~mpg) %&gt;% layer_histograms(width = 2)
mtcars %&gt;% ggvis(~mpg) %&gt;% layer_freqpolys(width = 2)

# These are equivalent to combining compute_bin with the corresponding
# mark
mtcars %&gt;% compute_bin(~mpg) %&gt;% ggvis(~x_, ~count_) %&gt;% layer_paths()

# With grouping
mtcars %&gt;% ggvis(~mpg, fill = ~factor(cyl)) %&gt;% group_by(cyl) %&gt;%
  layer_histograms(width = 2)
mtcars %&gt;% ggvis(~mpg, stroke = ~factor(cyl)) %&gt;% group_by(cyl) %&gt;%
  layer_freqpolys(width = 2)
</code></pre>

<hr>
<h2 id='layer_lines'>Layer lines on a plot.</h2><span id='topic+layer_lines'></span>

<h3>Description</h3>

<p><code>layer_lines</code> differs from <code>layer_paths</code> in that <code>layer_lines</code>
sorts the data on the x variable, so the line will always proceed from left
to right, whereas <code>layer_paths</code> will draw a line in whatever order
appears in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_lines(vis, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layer_lines_+3A_vis">vis</code></td>
<td>
<p>Visualisation to modify.</p>
</td></tr>
<tr><td><code id="layer_lines_+3A_...">...</code></td>
<td>
<p>Visual properties.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+layer_paths">layer_paths</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% ggvis(~wt, ~mpg, stroke = ~factor(cyl)) %&gt;% layer_lines()

# Equivalent to
mtcars %&gt;% ggvis(~wt, ~mpg, stroke = ~factor(cyl)) %&gt;%
  group_by(cyl) %&gt;% dplyr::arrange(wt) %&gt;% layer_paths()
</code></pre>

<hr>
<h2 id='layer_model_predictions'>Overlay model predictions or a smooth curve.</h2><span id='topic+layer_model_predictions'></span><span id='topic+layer_smooths'></span>

<h3>Description</h3>

<p><code>layer_model_predictions</code> fits a model to the data and draw it with
<code>layer_paths</code> and, optionally, <code>layer_ribbons</code>.
<code>layer_smooths</code> is a special case of layering model predictions where
the model is a smooth loess curve whose smoothness is controlled by the
<code>span</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer_model_predictions(
  vis,
  ...,
  model,
  formula = NULL,
  model_args = NULL,
  se = FALSE,
  domain = NULL
)

layer_smooths(vis, ..., span = 0.75, se = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layer_model_predictions_+3A_vis">vis</code></td>
<td>
<p>Visualisation to modify</p>
</td></tr>
<tr><td><code id="layer_model_predictions_+3A_...">...</code></td>
<td>
<p>Visual properties. Stroke properties control only affect line,
fill properties only affect standard error band.</p>
</td></tr>
<tr><td><code id="layer_model_predictions_+3A_model">model</code></td>
<td>
<p>Name of the model as a string, e.g. <code>"loess"</code>, <code>"lm"</code>,
or <code>"MASS::rlm"</code>. Must be the name of a function that produces a
standard model object with a <code><a href="stats.html#topic+predict">predict</a></code> method. For
<code>layer_smooth</code> this is always &quot;loess&quot;.</p>
</td></tr>
<tr><td><code id="layer_model_predictions_+3A_formula">formula</code></td>
<td>
<p>Model formula. If not supplied, guessed from the visual
properties, constructing <code>y ~ x</code>.</p>
</td></tr>
<tr><td><code id="layer_model_predictions_+3A_model_args">model_args</code></td>
<td>
<p>A list of additional arguments passed on to the
<code>model</code> function.</p>
</td></tr>
<tr><td><code id="layer_model_predictions_+3A_se">se</code></td>
<td>
<p>Also display a point-wise standard error band? Defaults to
<code>FALSE</code> because interpretation is non-trivial.</p>
</td></tr>
<tr><td><code id="layer_model_predictions_+3A_domain">domain</code></td>
<td>
<p>If <code>NULL</code> (the default), the domain of the predicted
values will be the same as the domain of the prediction variable in the
data. It can also be a two-element numeric vector specifying the min and
max.</p>
</td></tr>
<tr><td><code id="layer_model_predictions_+3A_span">span</code></td>
<td>
<p>For <code>layer_smooth</code>, the span of the loess smoother.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;% layer_smooths()
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;% layer_smooths(se = TRUE)

# Use group by to display multiple smoothes
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;% group_by(cyl) %&gt;% layer_smooths()

# Control appearance with props
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;%
  layer_smooths(se = TRUE, stroke := "red", fill := "red", strokeWidth := 5)

# Control the wiggliness with span. Default is 0.75
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;% layer_points() %&gt;%
  layer_smooths(span = 0.2)
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;% layer_points() %&gt;%
  layer_smooths(span = 1)
# Map to an input to modify interactively
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;% layer_points() %&gt;%
  layer_smooths(span = input_slider(0.2, 1))

# Use other modelling functions with layer_model_predictions
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;%
  layer_points() %&gt;%
  layer_model_predictions(model = "lm") %&gt;%
  layer_model_predictions(model = "MASS::rlm", stroke := "red")

# Custom domain for predictions
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;% layer_points() %&gt;%
  layer_model_predictions(model = "lm", domain = c(0, 8))
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;% layer_points() %&gt;%
  layer_model_predictions(model = "lm",
    domain = input_slider(0, 10, value = c(1, 4)))

# layer_smooths() is just compute_smooth() + layer_paths()
# Run loess or other model outside of a visualisation to see what variables
# you get.
mtcars %&gt;% compute_smooth(mpg ~ wt)
mtcars %&gt;% compute_model_prediction(mpg ~ wt, model = "lm")

mtcars %&gt;%
  ggvis(~wt, ~mpg) %&gt;%
  layer_points() %&gt;%
  compute_smooth(mpg ~ wt) %&gt;%
  layer_paths(~pred_, ~resp_, strokeWidth := 2)
</code></pre>

<hr>
<h2 id='left_right'>Interactive inputs bound to arrow keys.</h2><span id='topic+left_right'></span><span id='topic+up_down'></span>

<h3>Description</h3>

<p>Interactive inputs bound to arrow keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>left_right(min, max, value = (min + max)/2, step = (max - min)/40)

up_down(min, max, value = (min + max)/2, step = (max - min)/40)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="left_right_+3A_min">min</code></td>
<td>
<p>A minimum value.</p>
</td></tr>
<tr><td><code id="left_right_+3A_max">max</code></td>
<td>
<p>A maximum value.</p>
</td></tr>
<tr><td><code id="left_right_+3A_value">value</code></td>
<td>
<p>The initial value before any keys are pressed. Defaults to
half-way between <code>min</code> and <code>max</code>.</p>
</td></tr>
<tr><td><code id="left_right_+3A_step">step</code></td>
<td>
<p>How much each key press changes <code>value</code>. Defaults to
40 steps along range</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>size &lt;- left_right(1, 801, value = 51, step = 50)
opacity &lt;- up_down(0, 1, value = 0.9, step = 0.05)

mtcars %&gt;% ggvis(~mpg, ~wt, size := size, opacity := opacity) %&gt;%
  layer_points()
</code></pre>

<hr>
<h2 id='legend_props'>Create an axis_props object for controlling legend properties.</h2><span id='topic+legend_props'></span>

<h3>Description</h3>

<p>The items in each of the lists can be a literal value, like <code>5</code> or
&quot;blue&quot;, or they can be a <code><a href="#topic+scaled_value">scaled_value</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legend_props(
  title = NULL,
  labels = NULL,
  symbols = NULL,
  gradient = NULL,
  legend = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="legend_props_+3A_title">title</code></td>
<td>
<p>A named list of text properties for the legend title.</p>
</td></tr>
<tr><td><code id="legend_props_+3A_labels">labels</code></td>
<td>
<p>A named list of text properties for legend labels.</p>
</td></tr>
<tr><td><code id="legend_props_+3A_symbols">symbols</code></td>
<td>
<p>A named list of line properties for symbols (for discrete
legend items).</p>
</td></tr>
<tr><td><code id="legend_props_+3A_gradient">gradient</code></td>
<td>
<p>A named list of line properties a continuous color gradient.</p>
</td></tr>
<tr><td><code id="legend_props_+3A_legend">legend</code></td>
<td>
<p>A named list of line properties for the overall legend. The
x and y position can be set here, which will override automatic
positioning.</p>
</td></tr>
</table>

<hr>
<h2 id='linked_brush'>Create a linked brush object.</h2><span id='topic+linked_brush'></span>

<h3>Description</h3>

<p>A linked brush has two sides: input and output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linked_brush(keys, fill = "red")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linked_brush_+3A_keys">keys</code></td>
<td>
<p>vector of all possible keys, if known.</p>
</td></tr>
<tr><td><code id="linked_brush_+3A_fill">fill</code></td>
<td>
<p>brush colour</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>input</code></td>
<td>
<p>A function that takes a visualisation as an argument and
adds an input brush to that plot</p>
</td></tr>
<tr><td><code>selected</code></td>
<td>
<p>A reactive providing a logical vector that describes
which points are under the brush</p>
</td></tr>
<tr><td><code>fill</code></td>
<td>
<p>A reactive that gives the fill colour of points under the
brush</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>linked_brush</code> is very new and is likely to change substantially
in the future
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lb &lt;- linked_brush(keys = 1:nrow(mtcars), "red")

# Change the colour of the points
mtcars %&gt;%
 ggvis(~disp, ~mpg) %&gt;%
 layer_points(fill := lb$fill, size.brush := 400) %&gt;%
 lb$input()

# Display one layer with all points and another layer with selected points
library(shiny)
mtcars %&gt;%
 ggvis(~disp, ~mpg) %&gt;%
 layer_points(size.brush := 400) %&gt;%
 lb$input() %&gt;%
 layer_points(fill := "red", data = reactive(mtcars[lb$selected(), ]))
</code></pre>

<hr>
<h2 id='mark'>Create a new &quot;mark&quot; object.</h2><span id='topic+mark'></span><span id='topic+is.mark'></span>

<h3>Description</h3>

<p>A mark object is a close mapping to a vega mark object. Vega marks
are documented in <a href="https://vega.github.io/vega/docs/marks/">https://vega.github.io/vega/docs/marks/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark(type, props, data)

is.mark(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark_+3A_type">type</code></td>
<td>
<p>A string with the vega type.</p>
</td></tr>
<tr><td><code id="mark_+3A_props">props</code></td>
<td>
<p>A list of properties, created by <code><a href="#topic+props">props</a></code>.</p>
</td></tr>
<tr><td><code id="mark_+3A_data">data</code></td>
<td>
<p>A reactive data object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to be used by authors of new types of mark.
</p>

<hr>
<h2 id='marks'>Vega marks.</h2><span id='topic+marks'></span><span id='topic+emit_points'></span><span id='topic+layer_points'></span><span id='topic+emit_images'></span><span id='topic+layer_images'></span><span id='topic+emit_arcs'></span><span id='topic+layer_arcs'></span><span id='topic+emit_ribbons'></span><span id='topic+layer_ribbons'></span><span id='topic+emit_paths'></span><span id='topic+layer_paths'></span><span id='topic+emit_rects'></span><span id='topic+layer_rects'></span><span id='topic+emit_text'></span><span id='topic+layer_text'></span>

<h3>Description</h3>

<p>These functions create mark objects, corresponding to vega marks. Marks
are leaves in the plot tree, and control the details of the final rendering.
Marks are equivalent to the basic geoms in ggplot2 (e.g. point, line,
polygon), where ggvis layers correspond to combinations of geoms and
statistical transforms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emit_points(vis, props)

layer_points(vis, ..., data = NULL)

emit_images(vis, props)

layer_images(vis, ..., data = NULL)

emit_arcs(vis, props)

layer_arcs(vis, ..., data = NULL)

emit_ribbons(vis, props)

layer_ribbons(vis, ..., data = NULL)

emit_paths(vis, props)

layer_paths(vis, ..., data = NULL)

emit_rects(vis, props)

layer_rects(vis, ..., data = NULL)

emit_text(vis, props)

layer_text(vis, ..., data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marks_+3A_vis">vis</code></td>
<td>
<p>Visualisation to modify</p>
</td></tr>
<tr><td><code id="marks_+3A_props">props</code>, <code id="marks_+3A_...">...</code></td>
<td>
<p>A <code><a href="#topic+props">props</a></code> object, named according to the
properties listed below.</p>
</td></tr>
<tr><td><code id="marks_+3A_data">data</code></td>
<td>
<p>An optional dataset, if you want to override the usual data
inheritance for this mark.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that by supplying a fill property to <code>mark_path</code> will produce
a filled property. <code>mark_point</code> is an alias to <code>mark_symbol</code>.
</p>


<h3>Properties</h3>

<p>You can set the following mark properties:
</p>

<ul>
<li><p>  x  The first (typically left-most) x-coordinate.
</p>
</li>
<li><p>  x2 The second (typically right-most) x-coordinate.
</p>
</li>
<li><p>  width The width of the mark (if supported).
</p>
</li>
<li><p>  y The first (typically top-most) y-coordinate.
</p>
</li>
<li><p>  y2 The second (typically bottom-most) y-coordinate.
</p>
</li>
<li><p>  height The height of the mark (if supported).
</p>
</li>
<li><p>  opacity The overall opacity.
</p>
</li>
<li><p>  fill The fill color.
</p>
</li>
<li><p>  fillOpacity The fill opacity
</p>
</li>
<li><p>  stroke The stroke color.
</p>
</li>
<li><p>  strokeWidth The stroke width, in pixels.
</p>
</li>
<li><p>  strokeOpacity The stroke opacity.
</p>
</li>
<li><p>  size [symbol] The pixel area of the symbol. For example in the case
of circles, the radius is determined in part by the square root of the size
value.
</p>
</li>
<li><p>  shape [symbol] The symbol shape to use. One of circle (default),
square, cross, diamond, triangle-up, or triangle-down (symbol only)
</p>
</li>
<li><p>  innerRadius [arc] The inner radius of the arc, in pixels.
</p>
</li>
<li><p>  outerRadius [arc] The outer radius of the arc, in pixels.
</p>
</li>
<li><p>  startAngle [arc] The start angle of the arc, in radians.
</p>
</li>
<li><p>  endAngle [arc] The end angle of the arc, in radians.
</p>
</li>
<li><p>  interpolate [area, line] The line interpolation method to use. One
of linear, step-before, step-after, basis, basis-open, cardinal,
cardinal-open, monotone.
</p>
</li>
<li><p>  tension [area, line] Depending on the interpolation type, sets the
tension parameter.
</p>
</li>
<li><p>  url [image] The URL from which to retrieve the image.
</p>
</li>
<li><p>  align [image, text] The horizontal alignment of the object. One of
left, right, center.
</p>
</li>
<li><p>  baseline [image, text] The vertical alignment of the object. One of
top, middle, bottom.
</p>
</li>
<li><p>  text [text] The text to display.
</p>
</li>
<li><p>  dx [text] The horizontal margin, in pixels, between the text label
and its anchor point. The value is ignored if the align property is center.
</p>
</li>
<li><p>  dy [text] The vertical margin, in pixels, between the text label
and its anchor point. The value is ignored if the baseline property is
middle.
</p>
</li>
<li><p>  angle [text] The rotation angle of the text, in degrees.
</p>
</li>
<li><p>  font [text] The typeface to set the text in (e.g., Helvetica Neue).
</p>
</li>
<li><p>  fontSize [text] The font size, in pixels.
</p>
</li>
<li><p>  fontWeight [text] The font weight (e.g., bold).
</p>
</li>
<li><p>  fontStyle [text] The font style (e.g., italic).
</p>
</li></ul>

<p>To each property, you can assign any property object (<code><a href="#topic+prop">prop</a></code>)
either locally (i.e. in the mark), or in a parent <code>layer</code>.
</p>

<hr>
<h2 id='new_prop'>Create new prop object</h2><span id='topic+new_prop'></span>

<h3>Description</h3>

<p>The resulting object has the following fields:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_prop(x, property, scale, offset, mult, env, event, label)
</code></pre>


<h3>Details</h3>


<ul>
<li><p> property The name of a visual property, like &quot;x&quot;, &quot;x2&quot;, &quot;width&quot;, &quot;y&quot;,
&quot;fill&quot;.
</p>
</li>
<li><p> value A value. Can be a constant, reactive, or quoted expression.
</p>
</li>
<li><p> scale A string with name of a scale. Typically something like &quot;x&quot;,
&quot;y&quot;, &quot;fill&quot;, but can also be a custom name like &quot;foo&quot;.
</p>
</li>
<li><p> offset Additive pixel offset used to adjust scaled values.
</p>
</li>
<li><p> mult Multiplicative pixel offset used to adjust scaled values.
</p>
</li>
<li><p> event A event like &quot;update&quot;, &quot;enter&quot;, &quot;exit&quot;, &quot;hover&quot;, &quot;brush&quot;.
</p>
</li>
<li><p> env An environment in which to evaluate a variable or reactive value.
</p>
</li></ul>


<hr>
<h2 id='padding'>Define padding.</h2><span id='topic+padding'></span>

<h3>Description</h3>

<p>Define padding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padding(top = NULL, right = NULL, bottom = NULL, left = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="padding_+3A_top">top</code>, <code id="padding_+3A_right">right</code>, <code id="padding_+3A_bottom">bottom</code>, <code id="padding_+3A_left">left</code></td>
<td>
<p>Amount of padding on each border. Can either
be a single number, &quot;auto&quot;, or &quot;strict&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;% layer_points()
p %&gt;% set_options(padding = padding())
p %&gt;% set_options(padding = padding(10, 10, 10, 10))
</code></pre>

<hr>
<h2 id='print.ggvis'>View in a ggvis plot in the browser.</h2><span id='topic+print.ggvis'></span><span id='topic+view_static'></span><span id='topic+view_dynamic'></span>

<h3>Description</h3>

<p><code>view_static</code> creates a static web page in a temporary directory;
<code>view_dynamic</code> generate a dynamic shiny app and launches it.
<code>print</code> automatically picks between the two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggvis'
print(x, dynamic = NA, launch = interactive(), ...)

view_static(x, plot_id = rand_id("plot_"), dest = NULL)

view_dynamic(x, plot_id = rand_id("plot_"), port = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ggvis_+3A_x">x</code></td>
<td>
<p>A ggvis object.</p>
</td></tr>
<tr><td><code id="print.ggvis_+3A_dynamic">dynamic</code></td>
<td>
<p>Uses <code>view_dynamic</code> if <code>TRUE</code>, <code>view_static</code> if
<code>FALSE</code>. The default, <code>NA</code>, chooses automatically based on the
presence of reactives or interactive inputs in <code>x</code>.</p>
</td></tr>
<tr><td><code id="print.ggvis_+3A_launch">launch</code></td>
<td>
<p>If <code>TRUE</code>, will launch plot in a viewer/browser. If
<code>FALSE</code> returns an object that you can <code>print()</code> to launch.</p>
</td></tr>
<tr><td><code id="print.ggvis_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code>view_dynamic</code> and
<code>view_static</code> ?from <code>print</code>.</p>
</td></tr>
<tr><td><code id="print.ggvis_+3A_plot_id">plot_id</code></td>
<td>
<p>Unique identifier used to identify the plot on the page.</p>
</td></tr>
<tr><td><code id="print.ggvis_+3A_dest">dest</code></td>
<td>
<p>Deprecated (this no longer works).</p>
</td></tr>
<tr><td><code id="print.ggvis_+3A_port">port</code></td>
<td>
<p>the port on which to start the shiny app. If NULL (the default),
Shiny will select a random port.</p>
</td></tr>
<tr><td><code id="print.ggvis_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code> show status messages from Shiny. (Default is
<code>FALSE</code>.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>view_static</code> is used on a ggvis object that has dynamic components,
it will output a static plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Run these examples only in interactive R sessions
if (interactive()) {
# In most cases view_static is unnecessary; these will do the same thing:
mtcars %&gt;% ggvis(~wt, ~mpg)
mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;% view_static()

# Can find the output file with view_static() and html_print()
outfile &lt;- mtcars %&gt;% ggvis(~wt, ~mpg) %&gt;%
  view_static() %&gt;% htmltools::html_print(viewer = NULL)
}
</code></pre>

<hr>
<h2 id='prop'>Create a property.</h2><span id='topic+prop'></span><span id='topic+is.prop'></span><span id='topic+is.prop_constant'></span><span id='topic+is.prop_variable'></span><span id='topic+is.prop_reactive'></span>

<h3>Description</h3>

<p>Properties are used to describe the visual properties of <a href="#topic+marks">marks</a>.
You create a single property defintion with <code>prop</code>, and manage
sets of named properties with <code><a href="#topic+props">props</a></code> (which also provides
shortcuts for creating the most common kind of properties)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop(
  property,
  x,
  scale = NULL,
  offset = NULL,
  mult = NULL,
  env = parent.frame(),
  event = NULL,
  label = NULL
)

is.prop(x)

is.prop_constant(x)

is.prop_variable(x)

is.prop_reactive(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_+3A_property">property</code></td>
<td>
<p>A property, like &quot;x&quot;, &quot;x2&quot;, &quot;y&quot;, &quot;fill&quot;, and so on.</p>
</td></tr>
<tr><td><code id="prop_+3A_x">x</code></td>
<td>
<p>The value of the property. This can be an atomic vector
(a constant), a name or quoted call (a variable), a single-sided
formula (a constant or variable depending on its contents), or a delayed
reactive (which can be either variable or constant).</p>
</td></tr>
<tr><td><code id="prop_+3A_scale">scale</code></td>
<td>
<p>If <code>NULL</code>, automatically determine behavior by the kind of
value (constant, variable, or reactive).
If <code>TRUE</code> use the default scale associated with property.
If <code>FALSE</code>, do not scale the value.
Otherwise supply a string to select a custom scale.
If <code>x</code> is an interactive input, then this defaults to the scale
parameter of the input.</p>
</td></tr>
<tr><td><code id="prop_+3A_offset">offset</code>, <code id="prop_+3A_mult">mult</code></td>
<td>
<p>Additive and multiplicate pixel offset used to adjust
scaled values. These are useful if you want to place labels offset from
points.</p>
</td></tr>
<tr><td><code id="prop_+3A_env">env</code></td>
<td>
<p>If <code>x</code> is a quoted call this provides the environment in
which to look for variables not in the data. You should not need this in
ordinary operation.</p>
</td></tr>
<tr><td><code id="prop_+3A_event">event</code></td>
<td>
<p>An event to which this property applies. One of &quot;update&quot;,
&quot;enter&quot;, &quot;exit&quot;, &quot;hover&quot;, &quot;brush&quot;.</p>
</td></tr>
<tr><td><code id="prop_+3A_label">label</code></td>
<td>
<p>A label for this prop to use for reporting errors.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+props">props</a></code> to manage multiple properties and to
succintly create the most common types.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prop("x", 1)
prop("x", ~1)
prop("fill", quote(cyl))
prop("fill", ~cyl)
prop("x", input_slider(0, 100))

# If you have a variable name as a string
var &lt;- "cyl"
prop("x", as.name(var))

# Use a custom scale
prop("y", quote(cyl), scale = "y-2")

# Don't scale variable (i.e. it already makes sense in the visual space)
prop("fill", ~colour, scale = FALSE)

# Use a constant, but scaled
prop("x", 5, scale = TRUE)

# Use other events
prop("y", quote(cyl), scale = "y-2")

</code></pre>

<hr>
<h2 id='prop_domain'>Property domain.</h2><span id='topic+prop_domain'></span>

<h3>Description</h3>

<p>Property domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_domain(x, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_domain_+3A_x">x</code></td>
<td>
<p>property to dispatch on</p>
</td></tr>
<tr><td><code id="prop_domain_+3A_data">data</code></td>
<td>
<p>name of data set</p>
</td></tr>
</table>

<hr>
<h2 id='propname_to_scale'>Convert the name of a property to the name of its default scale.</h2><span id='topic+propname_to_scale'></span>

<h3>Description</h3>

<p>This is mainly used to ensure that similar properties share the same
scale by default - e.g. <code>x</code> and <code>x2</code> should use the same
scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propname_to_scale(prop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="propname_to_scale_+3A_prop">prop</code></td>
<td>
<p>character vector of property names. Any unrecognised names
are left unchanged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of default scale names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>propname_to_scale(c("x", "x2"))
propname_to_scale(c("foo", "bar"))
propname_to_scale(c("opacity", "fillOpacity", "strokeOpacity"))
</code></pre>

<hr>
<h2 id='props'>Manage a list of properties.</h2><span id='topic+props'></span><span id='topic+is.ggvis_props'></span>

<h3>Description</h3>

<p><code>props()</code> provides a tool for concise creation of <code>prop</code> objects
using a set of conventions designed to capture the most common use cases.
If you need something less common, you'll need to use <code><a href="#topic+prop">prop</a></code> to
access all possible options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>props(..., .props = NULL, inherit = TRUE, env = parent.frame())

is.ggvis_props(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="props_+3A_...">...</code></td>
<td>
<p>A set of name-value pairs. The name should be a valid vega
property.
</p>
<p>The first two unnamed components are taken to be <code>x</code> and <code>y</code>.
Any additional unnamed components will raise an error.</p>
</td></tr>
<tr><td><code id="props_+3A_.props">.props</code></td>
<td>
<p>When calling <code>props</code> from other functions, you'll
often have a list of quoted function functions. You can pass that function
to the <code>.props</code> argument instead of messing around with
substitute. In other words, <code>.props</code> lets you opt out of the
non-standard evaluation that <code>props</code> does.</p>
</td></tr>
<tr><td><code id="props_+3A_inherit">inherit</code></td>
<td>
<p>If <code>TRUE</code>, the defaults, will inherit from properties
from the parent layer If <code>FALSE</code>, it will start from nothing.</p>
</td></tr>
<tr><td><code id="props_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate variable properties.</p>
</td></tr>
<tr><td><code id="props_+3A_x">x</code></td>
<td>
<p>an object to test for props-ness.</p>
</td></tr>
</table>


<h3>Heuristics</h3>

<p>If the values are not already objects of class <code>prop</code>, <code>props</code>
uses the following heuristics to when creating the prop:
</p>

<ul>
<li><p> atomic vectors, e.g. <code>x = 1</code>: scaled = FALSE
</p>
</li>
<li><p> an interative input, e.g. <code>x = input_slider</code>:
scaled = FALSE
</p>
</li>
<li><p> a formula containing a single value, e.g. <code>x ~ 1</code>:
scaled = TRUE
</p>
</li>
<li><p> a formula containing a name or expression, <code>x ~ mpg</code>:
scaled = TRUE
</p>
</li></ul>



<h3>Non-standard evaluation</h3>

<p><code>props</code> uses non-standard evaluation in a slightly unusual way:
if you provide a formula input, the LHS of the formula will provide the
name of the component. In otherwise, <code>props(x = y ~ 1)</code> is the
same as <code>props(y ~ 1)</code>.
</p>
<p>You can combine variables from the dataset and variables defined in the
local environment: expressions will be evaluated in the environment which
the formula was defined.
</p>
<p>If you have the name of a variable in a string, see the
props vignette for how to create the needed property mapping.
</p>


<h3>Enter, exit, hover, and update events</h3>

<p>There are four different property events that the marks
can use. These can, for example, be used to change the appearance of a mark
when the mouse cursor is hovering over it: when the mark is hovered over, it
uses the hover event, and when the mark isn't hovered over, it uses the
update event
</p>

<ul>
<li><p> enter: This event is used by marks when they are added to a plot.
</p>
</li>
<li><p> update: This event is used by marks after they have entered, and
also after they have been hovered over.
</p>
</li>
<li><p> exit: This event is used by marks as they are removed from a plot.
</p>
</li>
<li><p> hover: This event is used when the mouse cursor is over the mark.
</p>
</li></ul>

<p>You can specify the event for a property, by putting a period and the
event after the property name. For example,
<code>props(fill.update := "black", fill.hover := "red")</code> will make a mark
have a black fill normally, and red fill when it is hovered over.
</p>
<p>The default event is update, so if you run <code>props(fill := "red")</code>,
this is equivalent to <code>props(fill.update := "red")</code>.
</p>
<p>In practice, the enter and exit events are useful only when the update has
a duration (and is therefore not instantaneous). The update event can be
thought of as the &quot;default&quot; state.
</p>


<h3>Key property</h3>

<p>In addition to the standard properties, there is a special optional property
called <code>key</code>. This is useful for plots with dynamic data and smooth
transitions: as the data changes, the key is used to tell the plot how the
new data rows should be matched to the old data rows. Note that the key must
be an unscaled value. Additionally, the key property doesn't have a event,
since it is independent of enter, update, exit, and hover events.
</p>


<h3>Properties</h3>

<p>You can set the following mark properties:
</p>

<ul>
<li><p>  x  The first (typically left-most) x-coordinate.
</p>
</li>
<li><p>  x2 The second (typically right-most) x-coordinate.
</p>
</li>
<li><p>  width The width of the mark (if supported).
</p>
</li>
<li><p>  y The first (typically top-most) y-coordinate.
</p>
</li>
<li><p>  y2 The second (typically bottom-most) y-coordinate.
</p>
</li>
<li><p>  height The height of the mark (if supported).
</p>
</li>
<li><p>  opacity The overall opacity.
</p>
</li>
<li><p>  fill The fill color.
</p>
</li>
<li><p>  fillOpacity The fill opacity
</p>
</li>
<li><p>  stroke The stroke color.
</p>
</li>
<li><p>  strokeWidth The stroke width, in pixels.
</p>
</li>
<li><p>  strokeOpacity The stroke opacity.
</p>
</li>
<li><p>  size [symbol] The pixel area of the symbol. For example in the case
of circles, the radius is determined in part by the square root of the size
value.
</p>
</li>
<li><p>  shape [symbol] The symbol shape to use. One of circle (default),
square, cross, diamond, triangle-up, or triangle-down (symbol only)
</p>
</li>
<li><p>  innerRadius [arc] The inner radius of the arc, in pixels.
</p>
</li>
<li><p>  outerRadius [arc] The outer radius of the arc, in pixels.
</p>
</li>
<li><p>  startAngle [arc] The start angle of the arc, in radians.
</p>
</li>
<li><p>  endAngle [arc] The end angle of the arc, in radians.
</p>
</li>
<li><p>  interpolate [area, line] The line interpolation method to use. One
of linear, step-before, step-after, basis, basis-open, cardinal,
cardinal-open, monotone.
</p>
</li>
<li><p>  tension [area, line] Depending on the interpolation type, sets the
tension parameter.
</p>
</li>
<li><p>  url [image] The URL from which to retrieve the image.
</p>
</li>
<li><p>  align [image, text] The horizontal alignment of the object. One of
left, right, center.
</p>
</li>
<li><p>  baseline [image, text] The vertical alignment of the object. One of
top, middle, bottom.
</p>
</li>
<li><p>  text [text] The text to display.
</p>
</li>
<li><p>  dx [text] The horizontal margin, in pixels, between the text label
and its anchor point. The value is ignored if the align property is center.
</p>
</li>
<li><p>  dy [text] The vertical margin, in pixels, between the text label
and its anchor point. The value is ignored if the baseline property is
middle.
</p>
</li>
<li><p>  angle [text] The rotation angle of the text, in degrees.
</p>
</li>
<li><p>  font [text] The typeface to set the text in (e.g., Helvetica Neue).
</p>
</li>
<li><p>  fontSize [text] The font size, in pixels.
</p>
</li>
<li><p>  fontWeight [text] The font weight (e.g., bold).
</p>
</li>
<li><p>  fontStyle [text] The font style (e.g., italic).
</p>
</li></ul>

<p>To each property, you can assign any property object (<code><a href="#topic+prop">prop</a></code>)
either locally (i.e. in the mark), or in a parent <code>layer</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set to constant values
props(x := 1, y := 2)
# Map to variables in the dataset
props(x = ~mpg, y = ~cyl)
# Set to a constant value in the data space
props(x = 1, y = 1)
# Use an interactive slider
props(opacity := input_slider(0, 1))

# To control other settings (like custom scales, mult and offset)
# use a prop object
props(prop("x", "old", scale = "x", offset = -1))

# Red when hovered over, black otherwise (these are equivalent)
props(fill := "black", fill.hover := "red")
props(fill.update := "black", fill.hover := "red")

# Use a column called id as the key (for dynamic data)
props(key := ~id)

# Explicitly create prop objects. The following are equivalent:
props(fill = ~cyl)
props(fill.update = ~cyl)
props(prop("fill", ~cyl))
props(prop("fill", ~cyl, scale = "fill", event = "update"))

# Prop objects can be programmatically created and added:
property &lt;- "fill"
expr &lt;- parse(text = "wt/mpg")[[1]]
p &lt;- prop(property, expr)
props(p)

# Using .props
props(.props = list(x = 1, y = 2))
props(.props = list(x = ~mpg, y = ~cyl))
props(.props = list(quote(x := ~mpg)))
</code></pre>

<hr>
<h2 id='resolution'>Compute the &quot;resolution&quot; of a data vector.</h2><span id='topic+resolution'></span>

<h3>Description</h3>

<p>The resolution is is the smallest non-zero distance between adjacent
values.  If there is only one unique value, then the resolution is defined
to be one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolution(x, zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resolution_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="resolution_+3A_zero">zero</code></td>
<td>
<p>should a zero value be automatically included in the
computation of resolution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If x is an integer vector, then it is assumed to represent a discrete
variable, and the resolution is 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resolution(1:10)
resolution((1:10) - 0.5)
resolution((1:10) - 0.5, FALSE)
resolution(c(1,2, 10, 20, 50))
resolution(as.integer(c(1, 10, 20, 50)))  # Returns 1
</code></pre>

<hr>
<h2 id='save_spec'>Tools to save and view static specs.</h2><span id='topic+save_spec'></span><span id='topic+view_spec'></span>

<h3>Description</h3>

<p>These functions are mainly useful for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_spec(x, path, ...)

view_spec(path, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_spec_+3A_x">x</code></td>
<td>
<p>a ggvis object</p>
</td></tr>
<tr><td><code id="save_spec_+3A_path">path</code></td>
<td>
<p>location to save spec to, or load spec from</p>
</td></tr>
<tr><td><code id="save_spec_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>as.vega</code></p>
</td></tr>
</table>

<hr>
<h2 id='scale_datetime'>Add a date-time scale to a ggvis object.</h2><span id='topic+scale_datetime'></span>

<h3>Description</h3>

<p>A date/time scale controls the mapping of date and time variables to
visual properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_datetime(
  vis,
  property,
  domain = NULL,
  range = NULL,
  reverse = NULL,
  round = NULL,
  utc = NULL,
  clamp = NULL,
  nice = NULL,
  expand = NULL,
  name = property,
  label = NULL,
  override = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_datetime_+3A_vis">vis</code></td>
<td>
<p>A ggvis object.</p>
</td></tr>
<tr><td><code id="scale_datetime_+3A_property">property</code></td>
<td>
<p>The name of a property, such as &quot;x&quot;, &quot;y&quot;, &quot;fill&quot;, &quot;stroke&quot;, etc.</p>
</td></tr>
<tr><td><code id="scale_datetime_+3A_domain">domain</code></td>
<td>
<p>The domain of the scale, representing the set of data values.
For ordinal scales, a character vector; for quantitative scales, a numeric
vector of length two. Either value (but not both) may be NA, in which
case <code>domainMin</code> or <code>domainMax</code> is set. For dynamic scales, this
can also be a reactive which returns the appropriate type of vector.</p>
</td></tr>
<tr><td><code id="scale_datetime_+3A_range">range</code></td>
<td>
<p>The range of the scale, representing the set of visual values.
For numeric values, the range can take the form of a two-element array with
minimum and maximum values. For ordinal data, the range may by an array of
desired output values, which are mapped to elements in the specified
domain. The following range literals are also available: &quot;width&quot;, &quot;height&quot;,
&quot;shapes&quot;, &quot;category10&quot;, &quot;category20&quot;.</p>
</td></tr>
<tr><td><code id="scale_datetime_+3A_reverse">reverse</code></td>
<td>
<p>If true, flips the scale range.</p>
</td></tr>
<tr><td><code id="scale_datetime_+3A_round">round</code></td>
<td>
<p>If true, rounds numeric output values to integers. This can be
helpful for snapping to the pixel grid.</p>
</td></tr>
<tr><td><code id="scale_datetime_+3A_utc">utc</code></td>
<td>
<p>if <code>TRUE</code>, uses UTC times. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scale_datetime_+3A_clamp">clamp</code></td>
<td>
<p>If <code>TRUE</code>, values that exceed the data domain are clamped
to either the minimum or maximum range value. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scale_datetime_+3A_nice">nice</code></td>
<td>
<p>If specified, modifies the scale domain to use a more
human-friendly value range. Should be a string indicating the desired time
interval; legal values are &quot;second&quot;, &quot;minute&quot;, &quot;hour&quot;, &quot;day&quot;, &quot;week&quot;,
&quot;month&quot;, or &quot;year&quot;.</p>
</td></tr>
<tr><td><code id="scale_datetime_+3A_expand">expand</code></td>
<td>
<p>A multiplier for how much the scale should be expanded beyond
the domain of the data. For example, if the data goes from 10 to 110, and
<code>expand</code> is 0.05, then the resulting domain of the scale is 5 to 115.
Set to 0 and use <code>nice=FALSE</code> if you want exact control over the
domain.</p>
</td></tr>
<tr><td><code id="scale_datetime_+3A_name">name</code></td>
<td>
<p>Name of the scale, such as &quot;x&quot;, &quot;y&quot;, &quot;fill&quot;, etc. Can also be an
arbitrary name like &quot;foo&quot;.</p>
</td></tr>
<tr><td><code id="scale_datetime_+3A_label">label</code></td>
<td>
<p>Label for the scale. Used for axis or legend titles.</p>
</td></tr>
<tr><td><code id="scale_datetime_+3A_override">override</code></td>
<td>
<p>Should the domain specified by this ggvis_scale object
override other ggvis_scale objects for the same scale? Useful when domain is
manually specified. For example, by default, the domain of the scale
will contain the range of the data, but when this is TRUE, the specified
domain will override, and the domain can be smaller than the range of the
data. If <code>FALSE</code>, the <code>domain</code> will not behave this way. If
left <code>NULL</code>, then it will be treated as <code>TRUE</code> whenever
<code>domain</code> is non-NULL.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+scales">scales</a></code>, <code><a href="#topic+scale_numeric">scale_numeric</a></code>,
<a href="https://vega.github.io/vega/docs/scales/#time">https://vega.github.io/vega/docs/scales/#time</a>
</p>
<p>Other scales: 
<code><a href="#topic+scale_numeric">scale_numeric</a>()</code>,
<code><a href="#topic+scale_ordinal">scale_ordinal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2934)
dat &lt;- data.frame(
  time = as.Date("2013-07-01") + 1:100,
  value = seq(1, 10, length.out = 100) + rnorm(100)
)
p &lt;- dat %&gt;% ggvis(~time, ~value) %&gt;% layer_points()

# Start and end on month boundaries
p %&gt;% scale_datetime("x", nice = "month")


dist &lt;- data.frame(times = as.POSIXct("2013-07-01", tz = "GMT") +
                           rnorm(200) * 60 * 60 * 24 * 7)
p &lt;- dist %&gt;% ggvis(x = ~times) %&gt;% layer_histograms()
p

# Start and end on month boundaries
p %&gt;% scale_datetime("x", nice = "month")

p %&gt;% scale_datetime("x", utc = TRUE)
</code></pre>

<hr>
<h2 id='scale_numeric'>Add a numeric scale to a ggvis object.</h2><span id='topic+scale_numeric'></span>

<h3>Description</h3>

<p>A numeric (quantitative) scale controls the mapping of continuous variables
to visual properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_numeric(
  vis,
  property,
  domain = NULL,
  range = NULL,
  reverse = NULL,
  round = NULL,
  trans = NULL,
  clamp = NULL,
  exponent = NULL,
  nice = NULL,
  zero = NULL,
  expand = NULL,
  name = property,
  label = NULL,
  override = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_numeric_+3A_vis">vis</code></td>
<td>
<p>A ggvis object.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_property">property</code></td>
<td>
<p>The name of a visual property, such as &quot;x&quot;, &quot;y&quot;, &quot;fill&quot;,
&quot;stroke&quot;. Note both x and x2 use the &quot;x&quot; scale (similarly for y and y2).
fillOpacity, opacity and strokeOpacity use the &quot;opacity&quot; scale.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_domain">domain</code></td>
<td>
<p>The domain of the scale, representing the set of data values.
For ordinal scales, a character vector; for quantitative scales, a numeric
vector of length two. Either value (but not both) may be NA, in which
case <code>domainMin</code> or <code>domainMax</code> is set. For dynamic scales, this
can also be a reactive which returns the appropriate type of vector.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_range">range</code></td>
<td>
<p>The range of the scale, representing the set of visual values.
For numeric values, the range can take the form of a two-element array with
minimum and maximum values. For ordinal data, the range may by an array of
desired output values, which are mapped to elements in the specified
domain. The following range literals are also available: &quot;width&quot;, &quot;height&quot;,
&quot;shapes&quot;, &quot;category10&quot;, &quot;category20&quot;.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_reverse">reverse</code></td>
<td>
<p>If true, flips the scale range.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_round">round</code></td>
<td>
<p>If true, rounds numeric output values to integers. This can be
helpful for snapping to the pixel grid.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_trans">trans</code></td>
<td>
<p>A scale transformation: one of &quot;linear&quot;, &quot;log&quot;, &quot;pow&quot;, &quot;sqrt&quot;,
&quot;quantile&quot;, &quot;quantize&quot;, &quot;threshold&quot;. Default is &quot;linear&quot;.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_clamp">clamp</code></td>
<td>
<p>If <code>TRUE</code>, values that exceed the data domain are clamped
to either the minimum or maximum range value. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_exponent">exponent</code></td>
<td>
<p>Sets the exponent of the scale transformation. For pow
transform only.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_nice">nice</code></td>
<td>
<p>If <code>TRUE</code>, modifies the scale domain to use a more
human-friendly number range (e.g., 7 instead of 6.96). Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_zero">zero</code></td>
<td>
<p>If <code>TRUE</code>, ensures that a zero baseline value is included
in the scale domain. This option is ignored for non-quantitative scales.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_expand">expand</code></td>
<td>
<p>A multiplier for how much the scale should be expanded beyond
the domain of the data. For example, if the data goes from 10 to 110, and
<code>expand</code> is 0.05, then the resulting domain of the scale is 5 to 115.
Set to 0 and use <code>nice=FALSE</code> if you want exact control over the
domain. If left <code>NULL</code>, behavior will depend on the scale type. For
positional scales (x and y), <code>expand</code> will default to 0.05. For other
scales, it will default to 0.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_name">name</code></td>
<td>
<p>Name of the scale, such as &quot;x&quot;, &quot;y&quot;, &quot;fill&quot;, etc. Can also be an
arbitrary name like &quot;foo&quot;.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_label">label</code></td>
<td>
<p>Label for the scale. Used for axis or legend titles.</p>
</td></tr>
<tr><td><code id="scale_numeric_+3A_override">override</code></td>
<td>
<p>Should the domain specified by this ggvis_scale object
override other ggvis_scale objects for the same scale? Useful when domain is
manually specified. For example, by default, the domain of the scale
will contain the range of the data, but when this is TRUE, the specified
domain will override, and the domain can be smaller than the range of the
data. If <code>FALSE</code>, the <code>domain</code> will not behave this way. If
left <code>NULL</code>, then it will be treated as <code>TRUE</code> whenever
<code>domain</code> is non-NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default values for most of the arguments is NULL. When the plot is
created, these NULL values will be replaced with default values, as indicated
below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scales">scales</a></code>, <code><a href="#topic+scale_ordinal">scale_ordinal</a></code>,
<a href="https://vega.github.io/vega/docs/scales/#quantitative">https://vega.github.io/vega/docs/scales/#quantitative</a>
</p>
<p>Other scales: 
<code><a href="#topic+scale_datetime">scale_datetime</a>()</code>,
<code><a href="#topic+scale_ordinal">scale_ordinal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- mtcars %&gt;% ggvis(~wt, ~mpg, fill = ~hp) %&gt;% layer_points()

p %&gt;% scale_numeric("y")

p %&gt;% scale_numeric("y", trans = "pow", exponent = 0.5)

p %&gt;% scale_numeric("y", trans = "log")

# Can control other properties other than x and y
p %&gt;% scale_numeric("fill", domain = c(0, 120), clamp = TRUE)

# Set range of data from 0 to 3
p %&gt;% scale_numeric("x", domain = c(0, 3), clamp = TRUE, expand = 0,
                     nice = FALSE)

# Lower bound is set to lower limit of data, upper bound set to 3.
p %&gt;% scale_numeric("x", domain = c(NA, 3), clamp = TRUE, nice = FALSE)
</code></pre>

<hr>
<h2 id='scale_ordinal'>Add a ordinal, nominal, or logical scale to a ggvis object.</h2><span id='topic+scale_ordinal'></span><span id='topic+scale_nominal'></span><span id='topic+scale_logical'></span>

<h3>Description</h3>

<p>Ordinal, nominal, and logical scales are all categorical, and are treated
similarly by ggvis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_ordinal(
  vis,
  property,
  domain = NULL,
  range = NULL,
  reverse = NULL,
  round = NULL,
  points = NULL,
  padding = NULL,
  sort = NULL,
  name = property,
  label = NULL,
  override = NULL
)

scale_nominal(
  vis,
  property,
  domain = NULL,
  range = NULL,
  reverse = NULL,
  round = NULL,
  points = NULL,
  padding = NULL,
  sort = NULL,
  name = property,
  label = NULL,
  override = NULL
)

scale_logical(
  vis,
  property,
  domain = NULL,
  range = NULL,
  reverse = NULL,
  round = NULL,
  points = NULL,
  padding = NULL,
  sort = NULL,
  name = property,
  label = NULL,
  override = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_ordinal_+3A_vis">vis</code></td>
<td>
<p>A ggvis object.</p>
</td></tr>
<tr><td><code id="scale_ordinal_+3A_property">property</code></td>
<td>
<p>The name of a property, such as &quot;x&quot;, &quot;y&quot;, &quot;fill&quot;, &quot;stroke&quot;, etc.</p>
</td></tr>
<tr><td><code id="scale_ordinal_+3A_domain">domain</code></td>
<td>
<p>The domain of the scale, representing the set of data values.
For ordinal scales, a character vector; for quantitative scales, a numeric
vector of length two. Either value (but not both) may be NA, in which
case <code>domainMin</code> or <code>domainMax</code> is set. For dynamic scales, this
can also be a reactive which returns the appropriate type of vector.</p>
</td></tr>
<tr><td><code id="scale_ordinal_+3A_range">range</code></td>
<td>
<p>The range of the scale, representing the set of visual values.
For numeric values, the range can take the form of a two-element array with
minimum and maximum values. For ordinal data, the range may by an array of
desired output values, which are mapped to elements in the specified
domain. The following range literals are also available: &quot;width&quot;, &quot;height&quot;,
&quot;shapes&quot;, &quot;category10&quot;, &quot;category20&quot;.</p>
</td></tr>
<tr><td><code id="scale_ordinal_+3A_reverse">reverse</code></td>
<td>
<p>If true, flips the scale range.</p>
</td></tr>
<tr><td><code id="scale_ordinal_+3A_round">round</code></td>
<td>
<p>If true, rounds numeric output values to integers. This can be
helpful for snapping to the pixel grid.</p>
</td></tr>
<tr><td><code id="scale_ordinal_+3A_points">points</code></td>
<td>
<p>If <code>TRUE</code> (default), distributes the ordinal values over a
quantitative range at uniformly spaced points. The spacing of the points
can be adjusted using the padding property. If <code>FALSE</code>, the ordinal
scale will construct evenly-spaced bands, rather than points. Note that
if any mark is added with a <code><a href="#topic+band">band</a>()</code> prop, then the scale for
that prop will automatically have <code>points</code> set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scale_ordinal_+3A_padding">padding</code></td>
<td>
<p>Applies spacing among ordinal elements in the scale range.
The actual effect depends on how the scale is configured. If the points
parameter is true, the padding value is interpreted as a multiple of the
spacing between points. A reasonable value is 1.0, such that the first and
last point will be offset from the minimum and maximum value by half the
distance between points. Otherwise, padding is typically in the range
[0, 1] and corresponds to the fraction of space in the range interval to
allocate to padding. A value of 0.5 means that the range band width will
be equal to the padding width. For positional (x and y) scales, the default
padding is 0.1. For other scales, the default padding is 0.5.</p>
</td></tr>
<tr><td><code id="scale_ordinal_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, the values in the scale domain will be sorted
according to their natural order. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scale_ordinal_+3A_name">name</code></td>
<td>
<p>Name of the scale, such as &quot;x&quot;, &quot;y&quot;, &quot;fill&quot;, etc. Can also be an
arbitrary name like &quot;foo&quot;.</p>
</td></tr>
<tr><td><code id="scale_ordinal_+3A_label">label</code></td>
<td>
<p>Label for the scale. Used for axis or legend titles.</p>
</td></tr>
<tr><td><code id="scale_ordinal_+3A_override">override</code></td>
<td>
<p>Should the domain specified by this ggvis_scale object
override other ggvis_scale objects for the same scale? Useful when domain is
manually specified. For example, by default, the domain of the scale
will contain the range of the data, but when this is TRUE, the specified
domain will override, and the domain can be smaller than the range of the
data. If <code>FALSE</code>, the <code>domain</code> will not behave this way. If
left <code>NULL</code>, then it will be treated as <code>TRUE</code> whenever
<code>domain</code> is non-NULL.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+scales">scales</a></code>, <code><a href="#topic+scale_numeric">scale_numeric</a></code>,
<a href="https://vega.github.io/vega/docs/scales/#ordinal">https://vega.github.io/vega/docs/scales/#ordinal</a>.
</p>
<p>Other scales: 
<code><a href="#topic+scale_datetime">scale_datetime</a>()</code>,
<code><a href="#topic+scale_numeric">scale_numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- PlantGrowth %&gt;% ggvis(~group, ~weight) %&gt;% layer_points()

p
p %&gt;% scale_nominal("x", padding = 0)
p %&gt;% scale_nominal("x", padding = 1)

p %&gt;% scale_nominal("x", reverse = TRUE)

p &lt;- ToothGrowth %&gt;% group_by(supp) %&gt;%
  ggvis(~len, fill = ~supp) %&gt;%
  layer_histograms(width = 4, stack = TRUE)

# Control range of fill scale
p %&gt;% scale_nominal("fill", range = c("pink", "lightblue"))

# There's no default range when the data is categorical but the output range
# is continuous, as in the case of opacity. In these cases, you can
# manually specify the range for the scale.
mtcars %&gt;% ggvis(x = ~wt, y = ~mpg, opacity = ~factor(cyl)) %&gt;%
  layer_points() %&gt;%
  scale_nominal("opacity", range = c(0.2, 1))
</code></pre>

<hr>
<h2 id='scaled_value'>Create a scaled_value object</h2><span id='topic+scaled_value'></span>

<h3>Description</h3>

<p>These are for use with legends and axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaled_value(scale, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaled_value_+3A_scale">scale</code></td>
<td>
<p>The name of a scale, e.g., &quot;x&quot;, &quot;fill&quot;.</p>
</td></tr>
<tr><td><code id="scaled_value_+3A_value">value</code></td>
<td>
<p>A value which will be transformed using the scale.</p>
</td></tr>
</table>

<hr>
<h2 id='scales'>Add a scale to a ggvis plot</h2><span id='topic+scales'></span><span id='topic+set_default_scale'></span><span id='topic+set_dscale'></span>

<h3>Description</h3>

<p>This creates a scale object for a given scale and variable type, and adds it
to a ggvis plot. The scale object is populated with default settings, which
depend on the scale (e.g. fill, x, opacity) and the type of variable (e.g.
numeric, nominal, ordinal). Any settings that are passed in as arguments
will override the defaults.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scales_+3A_vis">vis</code></td>
<td>
<p>A ggvis object.</p>
</td></tr>
<tr><td><code id="scales_+3A_scale">scale</code></td>
<td>
<p>The name of a scale, such as &quot;x&quot;, &quot;y&quot;, &quot;fill&quot;, &quot;stroke&quot;, etc.</p>
</td></tr>
<tr><td><code id="scales_+3A_type">type</code></td>
<td>
<p>A variable type. One of &quot;numeric&quot;, &quot;nominal&quot;, &quot;ordinal&quot;,
&quot;logical&quot;, &quot;datetime&quot;.</p>
</td></tr>
<tr><td><code id="scales_+3A_...">...</code></td>
<td>
<p>other arguments passed to the scale function. See the help for
<code><a href="#topic+scale_numeric">scale_numeric</a></code>, <code><a href="#topic+scale_ordinal">scale_ordinal</a></code> and
<code><a href="#topic+scale_datetime">scale_datetime</a></code> for more details. For example, you might
supply <code>trans = "log"</code> to create a log scale.</p>
</td></tr>
<tr><td><code id="scales_+3A_name">name</code></td>
<td>
<p>If <code>NULL</code>, the default, the scale name is the same as
<code>scale</code>. Set this to a custom name to create multiple scales for
stroke or fill, or (god forbid) a secondary y scale.</p>
</td></tr>
</table>


<h3>Scale selection</h3>

<p>ggvis supports the following types of scales. Typical uses for each scale
type are listed below:
</p>

<ul>
<li><p> numeric For continuous numeric values.
</p>
</li>
<li><p> nominal For character vectors and factors.
</p>
</li>
<li><p> ordinal For ordered factors (these presently behave the same as
nominal).
</p>
</li>
<li><p> logical For logical (TRUE/FALSE) values.
</p>
</li>
<li><p> datetime For dates and date-times.
</p>
</li></ul>

<p>Each type has a corresponding function: <code>scale_numeric</code>,
<code>scale_nominal</code>, and so on.
</p>
<p>The scale types for ggvis are mapped to scale types for Vega, which include
&quot;ordinal&quot;, &quot;quantitative&quot;, and &quot;time&quot;. See <code><a href="#topic+ggvis_scale">ggvis_scale</a></code> for more
details.
</p>
<p>Given a scale and type, the range is selected based on the combination of the
<code>scale</code> and <code>type</code>. For example, you get a different range of
colours depending on whether the data is numeric, ordinal, or nominal. Some
scales also set other properties. For example, nominal/ordinal position
scales also add some padding so that points are spaced away from plot edges.
</p>
<p>Not all combinations have an existing default scale. If you use a
combination that does not have an existing combination, it may suggest
you're displaying the data in a suboptimal way. For example, there is
no default for a numeric shape scale, because there's no obvious way to
map continuous values to discrete shapes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- mtcars %&gt;%
  ggvis(x = ~wt, y = ~mpg, fill = ~factor(cyl), stroke = ~hp) %&gt;%
  layer_points()

p %&gt;% scale_numeric("x")
p %&gt;% scale_numeric("stroke")
p %&gt;% scale_nominal("fill")

# You can also supply additional arguments or override the defaults
p %&gt;% scale_numeric("x", trans = "log")
p %&gt;% scale_numeric("stroke", range = c("red", "blue"))
</code></pre>

<hr>
<h2 id='scaletype_to_vega_scaletype'>Given the type of a ggvis scale, get the name of its corresponding vega scale</h2><span id='topic+scaletype_to_vega_scaletype'></span>

<h3>Description</h3>

<p>Given the type of a ggvis scale, get the name of its corresponding vega scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaletype_to_vega_scaletype(type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaletype_to_vega_scaletype_+3A_type">type</code></td>
<td>
<p>property type: numeric, ordinal, nominal, logical or datetime.</p>
</td></tr>
</table>

<hr>
<h2 id='set_options'>Set options for a ggvis plot</h2><span id='topic+set_options'></span>

<h3>Description</h3>

<p>Set options for a ggvis plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_options(
  vis,
  width = NULL,
  height = NULL,
  keep_aspect = NULL,
  resizable = NULL,
  padding = NULL,
  duration = NULL,
  renderer = NULL,
  hover_duration = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_options_+3A_vis">vis</code></td>
<td>
<p>Visualisation to modify</p>
</td></tr>
<tr><td><code id="set_options_+3A_width">width</code>, <code id="set_options_+3A_height">height</code></td>
<td>
<p>Width and height of plot, in pixels. Default is 600x400.
<code>width</code> or <code>height</code> can also be <code>"auto"</code>, in which case the
plot will size to fit in the containing div. This is useful only in a Shiny
app or custom HTML output. Note that <code>height="auto"</code> should only be
used when the plot is placed within a div that has a fixed height; if not,
automatic height will not work, due to the way that web browsers do
vertical layout.</p>
</td></tr>
<tr><td><code id="set_options_+3A_keep_aspect">keep_aspect</code></td>
<td>
<p>Should the aspect ratio be preserved? The default value is
<code>FALSE</code>, or the value of <code>getOption("ggvis.keep_aspect")</code>, if it
is set.</p>
</td></tr>
<tr><td><code id="set_options_+3A_resizable">resizable</code></td>
<td>
<p>If TRUE, allow the user to resize the plot. The default
value is <code>TRUE</code>, or the value of <code>getOption("ggvis.resizable")</code>,
if it is set. Not compatible when <code>width</code> or <code>height</code> is
<code>"auto"</code>.</p>
</td></tr>
<tr><td><code id="set_options_+3A_padding">padding</code></td>
<td>
<p>A padding object specifying padding on the top, right, left,
and bottom. See <code><a href="#topic+padding">padding</a></code>.</p>
</td></tr>
<tr><td><code id="set_options_+3A_duration">duration</code></td>
<td>
<p>Duration of transitions, in milliseconds.</p>
</td></tr>
<tr><td><code id="set_options_+3A_renderer">renderer</code></td>
<td>
<p>The renderer to use in the browser. Can be <code>"canvas"</code> or
<code>"svg"</code> (the default).</p>
</td></tr>
<tr><td><code id="set_options_+3A_hover_duration">hover_duration</code></td>
<td>
<p>The amount of time for hover transitions, in
milliseconds.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+getOption">getOption</a></code> and <code><a href="base.html#topic+options">options</a></code>, for getting and
setting global options.
</p>
<p><code><a href="#topic+default_options">default_options</a></code> to see the default options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;%
  ggvis(~wt, ~mpg) %&gt;%
  layer_points() %&gt;%
  set_options(width = 300, height = 200, padding = padding(10, 10, 10, 10))

# Display the default options
str(default_options())

</code></pre>

<hr>
<h2 id='set_scale_label'>Set the label for a scale</h2><span id='topic+set_scale_label'></span>

<h3>Description</h3>

<p>Set the label for a scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_scale_label(vis, scale, label)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_scale_label_+3A_vis">vis</code></td>
<td>
<p>A ggvis object.</p>
</td></tr>
<tr><td><code id="set_scale_label_+3A_scale">scale</code></td>
<td>
<p>The name of a scale, like &quot;x&quot;.</p>
</td></tr>
<tr><td><code id="set_scale_label_+3A_label">label</code></td>
<td>
<p>Text to use for the label.</p>
</td></tr>
</table>

<hr>
<h2 id='shiny-ggvis'>Connect a ggvis graphic to a shiny app.</h2><span id='topic+shiny-ggvis'></span><span id='topic+bind_shiny'></span><span id='topic+bind_shiny_ui'></span><span id='topic+ggvisOutput'></span>

<h3>Description</h3>

<p>Embedding ggvis in a shiny app is easy. You need to make a place for it in
your <code>ui.r</code> with <code>ggvisOutput</code>, and tell your <code>server.r</code>
where to draw it with <code>bind_shiny</code>. It's easiest to learn by example:
there are many shiny apps in <code>demo/apps/</code> that you can learn from.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_shiny(
  vis,
  plot_id,
  controls_id = NULL,
  ...,
  session = shiny::getDefaultReactiveDomain()
)

bind_shiny_ui(vis, controls_id, session = shiny::getDefaultReactiveDomain())

ggvisOutput(plot_id = rand_id("plot_id"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shiny-ggvis_+3A_vis">vis</code></td>
<td>
<p>A ggvis object, or a reactive expression that returns a ggvis
object.</p>
</td></tr>
<tr><td><code id="shiny-ggvis_+3A_plot_id">plot_id</code></td>
<td>
<p>unique identifier to use for the div containing the ggvis plot.</p>
</td></tr>
<tr><td><code id="shiny-ggvis_+3A_controls_id">controls_id</code></td>
<td>
<p>Unique identifier for controls div.</p>
</td></tr>
<tr><td><code id="shiny-ggvis_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>as.vega</code>.</p>
</td></tr>
<tr><td><code id="shiny-ggvis_+3A_session">session</code></td>
<td>
<p>A Shiny session object.</p>
</td></tr>
</table>


<h3>Client-side</h3>

<p>In your UI, use <code>ggvisOutput()</code> in <code>ui.r</code> to insert an html
placeholder for the plot.
</p>
<p>If you're going to be using interactive controls generated by ggvis,
use <code><a href="shiny.html#topic+renderUI">renderUI</a>()</code> to add a place holder. By convention,
if the id of plot placehold is called &quot;plot&quot;, call the controls placeholder
&quot;plot_ui&quot;.
</p>


<h3>Server-side</h3>

<p>When you run ggvis plot interactively, it is automatically plotted because
it triggers the default print method. In shiny apps, you need to
explicitly render the plot to a specific placeholder with
<code>bind_shiny</code>:
</p>
<p><code>p %&gt;% bind_shiny("plot")</code>
</p>
<p>If the plot has controls, and you've reserved space for them in the UI,
supply the name of the placeholder as the third argument:
</p>
<p><code>p %&gt;% bind_shiny("plot", "plot_ui")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Run these examples only in interactive R sessions
if (interactive()) {

# Simplest possible app:
library(shiny)
runApp(list(
  ui = bootstrapPage(
    ggvisOutput("p"),
    uiOutput("p_ui")
  ),
  server = function(..., session) {
    mtcars %&gt;%
      ggvis(~wt, ~mpg) %&gt;%
      layer_points() %&gt;%
      layer_smooths(span = input_slider(0, 1)) %&gt;%
      bind_shiny("p", "p_ui")
  }
))

}
</code></pre>

<hr>
<h2 id='show_spec'>Print out the vega plot specification</h2><span id='topic+show_spec'></span>

<h3>Description</h3>

<p>Print out the vega plot specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_spec(vis, pieces = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_spec_+3A_vis">vis</code></td>
<td>
<p>Visualisation to print</p>
</td></tr>
<tr><td><code id="show_spec_+3A_pieces">pieces</code></td>
<td>
<p>Optional, a character or numeric vector used to
pull out selected pieces of the spec</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>base &lt;- mtcars %&gt;% ggvis(~mpg, ~wt) %&gt;% layer_points()
base %&gt;% show_spec()
base %&gt;% show_spec("scales")
</code></pre>

<hr>
<h2 id='show_tooltip'>Send a message to the client to show or hide a tooltip</h2><span id='topic+show_tooltip'></span><span id='topic+hide_tooltip'></span>

<h3>Description</h3>

<p>Send a message to the client to show or hide a tooltip
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_tooltip(session, l = 0, t = 0, html = "")

hide_tooltip(session)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_tooltip_+3A_session">session</code></td>
<td>
<p>A Shiny session object.</p>
</td></tr>
<tr><td><code id="show_tooltip_+3A_l">l</code></td>
<td>
<p>Pixel location of left edge of tooltip (relative to page)</p>
</td></tr>
<tr><td><code id="show_tooltip_+3A_t">t</code></td>
<td>
<p>Pixel location of top edge of tooltip (relative to page)</p>
</td></tr>
<tr><td><code id="show_tooltip_+3A_html">html</code></td>
<td>
<p>HTML to display in the tooltip box.</p>
</td></tr>
</table>

<hr>
<h2 id='sidebarBottomPage'>Create a page with a sidebar</h2><span id='topic+sidebarBottomPage'></span><span id='topic+sidebarBottomPanel'></span><span id='topic+mainTopPanel'></span>

<h3>Description</h3>

<p>This creates a page with a sidebar, where the sidebar moves to the bottom
when the width goes below a particular value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sidebarBottomPage(sidebarPanel, mainPanel, shiny_headers = TRUE)

sidebarBottomPanel(...)

mainTopPanel(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sidebarBottomPage_+3A_sidebarpanel">sidebarPanel</code></td>
<td>
<p>The <code><a href="#topic+sidebarBottomPanel">sidebarBottomPanel</a></code> containing input
controls.</p>
</td></tr>
<tr><td><code id="sidebarBottomPage_+3A_mainpanel">mainPanel</code></td>
<td>
<p>The <code><a href="#topic+mainTopPanel">mainTopPanel</a></code> containing the main content.</p>
</td></tr>
<tr><td><code id="sidebarBottomPage_+3A_shiny_headers">shiny_headers</code></td>
<td>
<p>Should Shiny headers be embedded in the page? This
should be TRUE for interactive/dynamic pages, FALSE for static pages.</p>
</td></tr>
<tr><td><code id="sidebarBottomPage_+3A_...">...</code></td>
<td>
<p>Additional tags.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sidebarBottomPage(sidebarBottomPanel(), mainTopPanel())
</code></pre>

<hr>
<h2 id='singular'>singular.</h2><span id='topic+singular'></span><span id='topic+scale_singular'></span>

<h3>Description</h3>

<p>Use singular when you want constant x or y position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singular()

scale_singular(
  vis,
  property,
  name = property,
  label = name,
  points = TRUE,
  domain = NULL,
  override = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="singular_+3A_vis">vis</code></td>
<td>
<p>A ggvis object.</p>
</td></tr>
<tr><td><code id="singular_+3A_property">property</code></td>
<td>
<p>The name of a property, such as &quot;x&quot;, &quot;y&quot;, &quot;fill&quot;, &quot;stroke&quot;, etc.</p>
</td></tr>
<tr><td><code id="singular_+3A_name">name</code></td>
<td>
<p>Name of the scale, such as &quot;x&quot;, &quot;y&quot;, &quot;fill&quot;, etc. Can also be an
arbitrary name like &quot;foo&quot;.</p>
</td></tr>
<tr><td><code id="singular_+3A_label">label</code></td>
<td>
<p>Label for the scale. Used for axis or legend titles.</p>
</td></tr>
<tr><td><code id="singular_+3A_points">points</code></td>
<td>
<p>If <code>TRUE</code> (default), distributes the ordinal values over a
quantitative range at uniformly spaced points. The spacing of the points
can be adjusted using the padding property. If <code>FALSE</code>, the ordinal
scale will construct evenly-spaced bands, rather than points. Note that
if any mark is added with a <code><a href="#topic+band">band</a>()</code> prop, then the scale for
that prop will automatically have <code>points</code> set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="singular_+3A_domain">domain</code></td>
<td>
<p>The domain of the scale, representing the set of data values.
For ordinal scales, a character vector; for quantitative scales, a numeric
vector of length two. Either value (but not both) may be NA, in which
case <code>domainMin</code> or <code>domainMax</code> is set. For dynamic scales, this
can also be a reactive which returns the appropriate type of vector.</p>
</td></tr>
<tr><td><code id="singular_+3A_override">override</code></td>
<td>
<p>Should the domain specified by this ggvis_scale object
override other ggvis_scale objects for the same scale? Useful when domain is
manually specified. For example, by default, the domain of the scale
will contain the range of the data, but when this is TRUE, the specified
domain will override, and the domain can be smaller than the range of the
data. If <code>FALSE</code>, the <code>domain</code> will not behave this way. If
left <code>NULL</code>, then it will be treated as <code>TRUE</code> whenever
<code>domain</code> is non-NULL.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% ggvis("", ~mpg) %&gt;%
  layer_points() %&gt;%
  scale_nominal("x") %&gt;%
  add_axis("x", title = "", tick_size_major = 0)

# OR
mtcars %&gt;% ggvis("", ~mpg) %&gt;%
  layer_points() %&gt;%
  scale_singular("x")

# OR, even simpler
mtcars %&gt;% ggvis(singular(), ~mpg) %&gt;% layer_points()

# In the other direction:
mtcars %&gt;% ggvis(~mpg, singular()) %&gt;% layer_points()
</code></pre>

<hr>
<h2 id='subvis'>Create a subvisualisation.</h2><span id='topic+subvis'></span>

<h3>Description</h3>

<p>Create a subvisualisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subvis(vis, ..., data = NULL, width = NULL, height = NULL)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'># Examples don't work yet
## Not run: 
library(dplyr, warn.conflicts = FALSE)

small &lt;- nasaweather::atmos %&gt;%
  filter(lat &lt;= -11.217391, long &lt;= -106.287, year == 1995) %&gt;%
  group_by(long, lat)
small %&gt;%
  ggvis(~long, ~lat) %&gt;%
  layer_points()

small %&gt;%
  ggvis(~long, ~lat) %&gt;%
  subvis(width := 100, height := 100, stroke := "red") %&gt;%
    layer_points(~month, ~ozone)

small %&gt;%
  ggvis(~long, ~lat) %&gt;%
  subvis(width := 100, height := 100, stroke := "red") %&gt;%
    layer_points(~month, ~ozone) %&gt;%
    add_axis("x", ticks = 3) %&gt;%
    add_axis("y", ticks = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='vector_type'>Determine the &quot;type&quot; of a vector</h2><span id='topic+vector_type'></span>

<h3>Description</h3>

<p>The <code>vector_type</code> collapses down the class of base vectors into
something useful more for visualisation, yielding one of &quot;datetime&quot;,
&quot;numeric&quot;, &quot;ordinal&quot;, &quot;nominal&quot; or &quot;logical&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_type(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector_type_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>default_scale</code>, which uses this when picking the default
scale.
</p>

<hr>
<h2 id='vega_data_parser'>Determine the vega data type for a vector</h2><span id='topic+vega_data_parser'></span>

<h3>Description</h3>

<p>This is used to specify the data type so that the appropriate parser is used
when Vega receives the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vega_data_parser(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vega_data_parser_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>

<hr>
<h2 id='waggle'>Waggle back and forth between two numbers</h2><span id='topic+waggle'></span>

<h3>Description</h3>

<p>Waggle back and forth between two numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waggle(min, max, value = (min + max)/2, step = (max - min)/50, fps = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="waggle_+3A_min">min</code></td>
<td>
<p>A minimum value.</p>
</td></tr>
<tr><td><code id="waggle_+3A_max">max</code></td>
<td>
<p>A maximum value.</p>
</td></tr>
<tr><td><code id="waggle_+3A_value">value</code></td>
<td>
<p>Starting value. Defaults to half-way between <code>min</code> and
<code>max</code>.</p>
</td></tr>
<tr><td><code id="waggle_+3A_step">step</code></td>
<td>
<p>How much value changes at each frame. Defaults to 50 steps
between min and max so it takes 5 seconds to waggle once.</p>
</td></tr>
<tr><td><code id="waggle_+3A_fps">fps</code></td>
<td>
<p>number of frames per second.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>span &lt;- waggle(0.2, 1)
mtcars %&gt;% ggvis(~mpg, ~wt) %&gt;%
 layer_points() %&gt;%
 layer_smooths(span = span)
</code></pre>

<hr>
<h2 id='zero_range'>Determine if range of vector is close to zero, with a specified tolerance</h2><span id='topic+zero_range'></span>

<h3>Description</h3>

<p>The machine epsilon is the difference between 1.0 and the next number
that can be represented by the machine. By default, this function
uses epsilon * 100 as the tolerance. First it scales the values so that
they have a mean of 1, and then it checks if the difference between
them is larger than the tolerance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_range(x, tol = .Machine$double.eps * 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zero_range_+3A_x">x</code></td>
<td>
<p>numeric range: vector of length 2</p>
</td></tr>
<tr><td><code id="zero_range_+3A_tol">tol</code></td>
<td>
<p>A value specifying the tolerance. Defaults to
<code>.Machine$double.eps * 100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical <code>TRUE</code> if the relative difference of the endpoints of
the range are not distinguishable from 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eps &lt;- .Machine$double.eps
zero_range(c(1, 1 + eps))       # TRUE
zero_range(c(1, 1 + 99 * eps))  # TRUE
zero_range(c(1, 1 + 101 * eps)) # FALSE - Crossed the tol threshold
zero_range(c(1, 1 + 2 * eps), tol = eps) # FALSE - Changed tol

# Scaling up or down all the values has no effect since the values
# are rescaled to 1 before checking against tol
zero_range(100000 * c(1, 1 + eps))        # TRUE
zero_range(100000 * c(1, 1 + 200 * eps))  # FALSE
zero_range(.00001 * c(1, 1 + eps))        # TRUE
zero_range(.00001 * c(1, 1 + 200 * eps))  # FALSE

# NA values
zero_range(c(1, NA))   # NA
zero_range(c(1, NaN))  # NA

# Infinite values
zero_range(c(1, Inf))     # FALSE
zero_range(c(-Inf, Inf))  # FALSE
zero_range(c(Inf, Inf))   # TRUE

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
