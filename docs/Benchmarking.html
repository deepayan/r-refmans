<!DOCTYPE html><html><head><title>Help for package Benchmarking</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Benchmarking}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Benchmarking-package'><p> Data Envelopment Analyses (DEA) and Stochastic Frontier</p>
Analyses (SFA) &ndash; Model Estimations and Efficiency Measuring</a></li>
<li><a href='#charnes1981'><p> Data: Charnes et al. (1981): Program follow through</p></a></li>
<li><a href='#cost.opt'><p>DEA optimal cost, revenue, and profit</p></a></li>
<li><a href='#critValue'><p>Critical values from bootstrapped DEA models</p></a></li>
<li><a href='#dea'><p>DEA efficiency</p></a></li>
<li><a href='#dea.add'><p>Additive DEA model</p></a></li>
<li><a href='#dea.boot'><p> Bootstrap DEA models</p></a></li>
<li><a href='#dea.direct'><p> Directional efficiency</p></a></li>
<li><a href='#dea.dual'><p> Dual DEA models and assurance regions</p></a></li>
<li><a href='#dea.merge'><p> Estimate potential merger gains and their decompositions</p></a></li>
<li><a href='#dea.plot'><p>Plot of DEA technologies</p></a></li>
<li><a href='#eff, efficiencies'><p> Calculate efficiencies for Farrell and sfa object</p></a></li>
<li><a href='#eff.dens'>
<p>Estimate and plot density of efficiencies</p></a></li>
<li><a href='#eladder'><p>Efficiency ladder for a single firm</p></a></li>
<li><a href='#excess'>
<p>Excess input compared over frontier input</p></a></li>
<li><a href='#lambda'><p>Lambdas or the weight of the peers</p></a></li>
<li><a href='#make.merge'><p> Make an aggregation matrix to perform mergers</p></a></li>
<li><a href='#malmq'><p>Malmquist index</p></a></li>
<li><a href='#malmquist'><p>Malmquist index for firms in a panel</p></a></li>
<li><a href='#mea'><p> MEA multi-directional efficiency analysis</p></a></li>
<li><a href='#milkProd'><p> Data: Milk producers</p></a></li>
<li><a href='#norWood2004'>
<p>Data: Forestry in Norway</p></a></li>
<li><a href='#outlier.ap'>
<p>Detection of outliers in benchmark models</p></a></li>
<li><a href='#peers'>
<p>Find peer firms and units</p></a></li>
<li><a href='#pigdata'><p> Data: Multi-output pig producers</p></a></li>
<li><a href='#projekt'>
<p>Data:  Milk producers</p></a></li>
<li><a href='#sdea'><p> Super efficiency</p></a></li>
<li><a href='#sfa'><p>Stochastic frontier estimation</p></a></li>
<li><a href='#slack'>
<p>Calculate slack in an efficiency analysis</p></a></li>
<li><a href='#stoned'><p>Convex nonparametric least squares</p></a></li>
<li><a href='#typeIerror'><p>Probability of type I error for test in a bootstrap DEA model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Benchmark and Frontier Analysis Using DEA and SFA</td>
</tr>
<tr>
<td>Version:</td>
<td>0.32</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Bogetoft and Lars Otto</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lars Otto &lt;larsot23@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>lpSolveAPI, ucminf, quadprog</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, graphics, grDevices, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for frontier
    analysis, Data Envelopment Analysis (DEA), under different
    technology assumptions (fdh, vrs, drs, crs, irs, add/frh, and fdh+),
    and using different efficiency measures (input based, output based,
    hyperbolic graph, additive, super, and directional efficiency). Peers
    and slacks are available, partial price information can be included,
    and optimal cost, revenue and profit can be calculated. Evaluation of
    mergers is also supported.  Methods for graphing the technology sets
    are also included. There is also support for comparative methods based
    on Stochastic Frontier Analyses (SFA) and for convex nonparametric 
    least squares of convex functions (STONED). In general, the methods 
    can be used to solve not only standard models, but also many other 
    model variants. It complements the book, Bogetoft and Otto,
    Benchmarking with DEA, SFA, and R, Springer-Verlag, 2011, but can of
    course also be used as a stand-alone package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-13 14:34:15 UTC; larso</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-13 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Benchmarking-package'> Data Envelopment Analyses (DEA) and Stochastic Frontier
Analyses (SFA) &ndash; Model Estimations and Efficiency Measuring </h2><span id='topic+Benchmarking-package'></span><span id='topic+Benchmarking'></span>

<h3>Description</h3>

<p>The Benchmarking package contains methods to estimate technologies and
measure efficiencies using DEA and SFA. Data Envelopment Analysis (DEA)
are supported under different technology assumptions (fdh, vrs, drs, crs,
irs, add), and using different efficiency measures (input based, output
based, hyperbolic graph, additive, super, directional). Peers are
available, partial price information can be included, and optimal cost,
revenue and profit can be calculated. Evaluation of mergers are also 
supported. Comparative methods for estimating stochastic frontier function
(SFA) efficiencies and for convex nonparametric least squares here for
convex functions (StoNED) are also included. The methods can solve not
only standard models, but also many other model variants, and they can
be modified to solve new models.
</p>
<p>The package also support simple plots of DEA technologies with two
goods; either as a transformation curve (2 outputs), an isoquant (2
inputs), or a production function (1 input and 1 output). When more
inputs and outputs are available they are aggregated using weights
(prices, relative prices).
</p>
<p>The package complements the book, Bogetoft and Otto,
<em>Benchmarking with DEA, SFA, and R</em>, Springer-Verlag 2011, but
can of course also be used as a stand-alone package.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Benchmarking</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.30 ($Revision: 233 $)</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> $Date: 2020-08-10 18:43:17 +0200 (ma, 10 aug 2020) $</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> Copyright</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: left;">
<code>dea</code> </td><td style="text-align: left;"> DEA input or output efficience measures, peers,
     lambdas and slacks </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>dea.dual</code> </td><td style="text-align: left;"> Dual weights (prices), including restrictions on
      weights </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>dea.direct</code> </td><td style="text-align: left;"> Directional efficiency </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>sdea</code> </td><td style="text-align: left;"> Super efficiency. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>dea.add</code> </td><td style="text-align: left;"> Additive efficiency; sum of slacks in DEA
     technology. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>mea</code> </td><td style="text-align: left;"> Multidirectional efficiency analysis or potential
     improvements. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>eff</code> </td><td style="text-align: left;"> Efficiency from an object returned from any of the dea
     or sfa functions. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>slack</code> </td><td style="text-align: left;"> Slacks in DEA models </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>excess</code> </td><td style="text-align: left;"> Calculates excess input or output compared to DEA
     frontier. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>peers</code> </td><td style="text-align: left;">  get the peers for each firm. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>dea.boot</code> </td><td style="text-align: left;"> Bootstrap DEA models </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>cost.opt</code> </td><td style="text-align: left;"> Optimal input for given output and prices. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>revenue.opt</code> </td><td style="text-align: left;"> Optimal output for given input and prices. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>profit.opt</code> </td><td style="text-align: left;"> Optimal input and output for given input and
     output prices.  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>dea.plot</code> </td><td style="text-align: left;"> Graphs of DEA technologies under alternative
     technology assumptions. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>dea.plot.frontier</code> </td><td style="text-align: left;"> Specialized for 1 input and 1
     output. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>dea.plot.isoquant</code> </td><td style="text-align: left;"> Specialized for 2 inputs. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>dea.plot.transform</code> </td><td style="text-align: left;"> Specialized for 2 outputs. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>eladder</code> </td><td style="text-align: left;"> Efficiency ladder for a single firm.  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>eladder.plot</code> </td><td style="text-align: left;"> Plot efficiency ladder for a single firm.  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>make.merge</code> </td><td style="text-align: left;"> Make an aggregation matrix to perform mergers.  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>dea.merge</code> </td><td style="text-align: left;"> Decompose efficiency from a merger of firms </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>sfa</code> </td><td style="text-align: left;"> Stochastic frontier analysis, production, distance,
     and cost function (SFA) </td>
</tr>
<tr>
 <td style="text-align: left;">
     
<code>stoned</code> </td><td style="text-align: left;"> Convex nonparametric least squares here for convex 
    function function </td>
</tr>
<tr>
 <td style="text-align: left;">     

<code>outlierC.ap, outlier.ap</code> </td><td style="text-align: left;"> Detection of outliers  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>eff.dens</code> </td><td style="text-align: left;"> Estimate and plot kernel density of efficiencies </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>critValue</code> </td><td style="text-align: left;"> Critical values calculated from bootstrap DEA
     models.  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>typeIerror</code> </td><td style="text-align: left;"> Probability of a type I error for a test in
      bootstrap DEA models.  </td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>



<h3>Note</h3>

 
<p>The interface for the methods are very much like the interface to the
methods in the package <span class="pkg">FEAR</span> (Wilson 2008). One change is that
the data now are transposed to reflect how data is usually available
in applications, i.e. we have firms on rows, and inputs and output in
the columns. Also, the argument for the options <code>RTS</code> and
<code>ORIENTATION</code> can be given as memotechnical strings, and there
are more options to control output.
</p>
<p>The input and output matrices can contain negative numbers, and the
methods can thereby manage restricted or fixed input or output.
</p>
<p>The return is not just the efficiency, but also slacks, dual values
(shadow prices), peers, and lambdas (weights). 
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p>Bogetoft and Otto; <em>Benchmarking with DEA, SFA, and R</em>; Springer
2011
</p>
<p>Paul W. Wilson (2008), &ldquo;FEAR 1.0: A Software Package for
Frontier Efficiency Analysis with R,&rdquo; <em>Socio-Economic Planning
Sciences</em> 42, 247&ndash;254
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot of different technologies
x &lt;- matrix(c(100,200,300,500),ncol=1,dimnames=list(LETTERS[1:4],"x"))
y &lt;- matrix(c(75,100,300,400),ncol=1,dimnames=list(LETTERS[1:4],"y"))
dea.plot(x,y,RTS="vrs",ORIENTATION="in-out",txt=rownames(x))
dea.plot(x,y,RTS="drs",ORIENTATION="in-out",add=TRUE,lty="dashed",lwd=2)
dea.plot(x,y,RTS="crs",ORIENTATION="in-out",add=TRUE,lty="dotted")
                      
dea.plot(x,y,RTS="fdh",ORIENTATION="in-out",txt=rownames(x),main="fdh")
dea.plot(x,y,RTS="irs",ORIENTATION="in-out",txt=TRUE,main="irs")
dea.plot(x,y,RTS="irs2",ORIENTATION="in-out",txt=rownames(x),main="irs2")
dea.plot(x,y,RTS="add",ORIENTATION="in-out",txt=rownames(x),main="add")

#  A quick frontier with 1 input and 1 output
dea.plot(x,y, main="Basic plot of frontier")

# Calculating efficiency
dea(x,y, RTS="vrs", ORIENTATION="in")
e &lt;- dea(x,y, RTS="vrs", ORIENTATION="in")
e
eff(e)
peers(e)
peers(e, NAMES=TRUE)
print(peers(e, NAMES=TRUE), quote=FALSE)
lambda(e)
summary(e)


# Calculating super efficiency
esuper &lt;- sdea(x,y, RTS="vrs", ORIENTATION="in")
esuper
print(peers(esuper,NAMES=TRUE),quote=FALSE)
# Technology for super efficiency for firm number 3/C 
# Note that drop=FALSE is necessary for XREF and YREF to be matrices
# when one of the dimensions is or is reduced to 1.
e3 &lt;- dea(x,y, XREF=x[-3,,drop=FALSE], YREF=y[-3,,drop=FALSE])
dea.plot(x[-3],y[-3],RTS="vrs",ORIENTATION="in-out",txt=LETTERS[c(1,2,4)])
points(x[3],y[3],cex=2)
text(x[3],y[3],LETTERS[3],adj=c(-.75,.75))
e3 &lt;- dea(x,y, XREF=x[-3,,drop=FALSE], YREF=y[-3,,drop=FALSE])
eff(e3)
peers(e3)
print(peers(e3,NAMES=TRUE),quote=FALSE)
lambda(e3)
e3$lambda

# Taking care of slacks
x &lt;- matrix(c(100,200,300,500,100,600),ncol=1,
        dimnames=list(LETTERS[1:6],"x"))
y &lt;- matrix(c(75,100,300,400,50,400),ncol=1,
        dimnames=list(LETTERS[1:6],"y"))

# Phase one, calculate efficiency
e &lt;- dea(x,y)
print(e)
peers(e)
lambda(e)
# Phase two, calculate slacks (maximize sum of slacks)
sl &lt;- slack(x,y,e)
data.frame(sl$sx,sl$sy)
peers(sl)
lambda(sl)
sl$lambda
summary(sl)

# The two phases in one function call
e2 &lt;- dea(x,y,SLACK=TRUE)
print(e2)
data.frame(eff(e2),e2$slack,e2$sx,e2$sy,lambda(e2))
peers(e2)
lambda(e2)
e2$lambda
</code></pre>

<hr>
<h2 id='charnes1981'> Data: Charnes et al. (1981): Program follow through </h2><span id='topic+charnes1981'></span>

<h3>Description</h3>

<p>The data set is from an US federally sponsored program for providing
remedial assistance to disadvantaged primary school students. The
firms are 70 school sites, and data are from entire sites. The
variables consists of results from three different kind of tests, a
reading score, <code>y1</code>, a math score, <code>y2</code>, and a self&ndash;esteem
score, <code>y3</code>, which are considered outputs in the model, and five
different variables considered to be inputs, the education level of
the mother, <code>x1</code>, the highest occupation of a family member,
<code>x2</code>, parental visits to school, <code>x3</code>, time spent with
children in school-related topics, <code>x4</code>, and the number of
teachers at the site, <code>x5</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(charnes1981) </code></pre>


<h3>Format</h3>

<p>A data frame with 70 school sites with the following variables.
</p>

<dl>
<dt><code>firm</code></dt><dd><p>school site number</p>
</dd>
<dt><code>x1</code></dt><dd><p>education level of the mother</p>
</dd>
<dt><code>x2</code></dt><dd><p>highest occupation of a family member</p>
</dd>
<dt><code>x3</code></dt><dd><p>parental visits to school</p>
</dd>
<dt><code>x4</code></dt><dd><p>time spent with children in school-related topics</p>
</dd>
<dt><code>x5</code></dt><dd><p>the number of teachers at the site</p>
</dd>
<dt><code>y1</code></dt><dd><p>reading score</p>
</dd>
<dt><code>y2</code></dt><dd><p>math score</p>
</dd>
<dt><code>y3</code></dt><dd><p>self&ndash;esteem score</p>
</dd>
<dt><code>pft</code></dt><dd><p>=1 if in program (program follow through) and 
=0 if not in program</p>
</dd>
<dt><code>name</code></dt><dd><p>Site name</p>
</dd>
</dl>



<h3>Details</h3>

<p> The command <code>data(charnes1981)</code> will create a data
frame named <code>charnes1981</code> with the above data.
</p>
<p>Beside input and output varianles there is further information in the
data set, that the first 50 school sites followed the program and that
the last 20 are the results for sites not following the program. This
is showed by the variable <code>pft</code>.  </p>


<h3>Note</h3>

<p> Data as <code>.csv</code> are loaded by the command <code>data</code> using
<code> read.table(..., header=TRUE, sep=";")</code> such that this file
is a semicolon separated file and not a comma separated file.
</p>
<p>Therefore, to read the file from a script the command must be
<code>read.csv("charnes1981.csv", sep=";")</code> or
<code>read.csv2("charnes1981.csv")</code>.
</p>
<p>Thus the data can be read either as <code>charnes1981 &lt;-</code>
<br /><code>read.csv2(paste(.Library, "Benchmarking/data",
"charnes1981.csv",  sep ="/"))</code> <br /> or as <code>data(charnes1981)</code> if
the package <span class="pkg">Benchmarking</span> is loaded. In both cases the data will
be in the data frame <code>charnes1981</code>.
</p>


<h3>Source</h3>

<p> Charnes, Cooper, and Rhodes, &ldquo;Evaluating Program and
Managerial Efficiency: An Application of Data Envelopment Analysis to
Program Follow Through&rdquo;, <em>Management Science</em>, volume 27, number
6, June 1981, pages 668&ndash;697.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(charnes1981)
x &lt;- with(charnes1981, cbind(x1,x2,x3,x4,x5))
y &lt;- with(charnes1981, cbind(y1,y2,y3))

# Farrell inpout efficiency; vrs technology
e &lt;- dea(x,y)
# The number of times each peer is a peer
np &lt;- get.number.peers(e) 
# Peers that are peers for more than 20 schools, and the number of
# times they are peers
np[which(np[,2]&gt;20),]

# Plot first input against first output and emphasize the peers that
# are peers for more than 20 schools in the model with five inputs and
# three outputs
inp &lt;- np[which(np[,2]&gt;20),1]
dea.plot(x[,1],y[,1])
points(x[inp,1], y[inp,1], pch=16, col="red")
</code></pre>

<hr>
<h2 id='cost.opt'>DEA optimal cost, revenue, and profit</h2><span id='topic+cost.opt'></span><span id='topic+print.cost.opt'></span><span id='topic+summary.cost.opt'></span><span id='topic+revenue.opt'></span><span id='topic+print.revenue.opt'></span><span id='topic+summary.revenue.opt'></span><span id='topic+profit.opt'></span><span id='topic+print.profit.opt'></span><span id='topic+summary.profit.opt'></span>

<h3>Description</h3>

<p>Estimates the input and/or output vector(s) that minimize
cost, maximize revenue or maximize profit in the context of a DEA
technology</p>


<h3>Usage</h3>

<pre><code class='language-R'>cost.opt(XREF, YREF, W, YOBS=NULL, RTS="vrs", param=NULL,
         TRANSPOSE=FALSE, LP=FALSE, CONTROL=NULL, LPK = NULL)  

revenue.opt(XREF, YREF, P, XOBS=NULL, RTS="vrs",  param=NULL,
            TRANSPOSE = FALSE, LP = FALSE, CONTROL=NULL, LPK = NULL)

profit.opt(XREF, YREF, W, P, RTS = "vrs",  param=NULL,
           TRANSPOSE = FALSE, LP = FALSE, CONTROL=NULL, LPK = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cost.opt_+3A_xref">XREF</code></td>
<td>
<p>Input of the firms defining the technology, a K x m matrix
of observations of K firms with m inputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the input matrix is transposed as input x
firm. </p>
</td></tr>
<tr><td><code id="cost.opt_+3A_yref">YREF</code></td>
<td>
<p>output of the firms defining the technology, a K x n
matrix of observations of K firms with n outputs (firm x input).  In
case <code>TRANSPOSE=TRUE</code> the output matrix is transposed as output
x firm. </p>
</td></tr>
<tr><td><code id="cost.opt_+3A_w">W</code></td>
<td>
<p>Input prices as a matrix. Either same prices for all firms or
individual prices for all firms, i.e. either a 1 x m or a K x m
matrix for K firms and m inputs </p>
</td></tr>
<tr><td><code id="cost.opt_+3A_p">P</code></td>
<td>
<p>Output prices as a matrix. Either same prices for all firms
or individual prices for all firms, i.e. either a 1 x n or K x n
matrix for K firms and n outputs </p>
</td></tr>
<tr><td><code id="cost.opt_+3A_xobs">XOBS</code></td>
<td>
<p>The input for which an optimal, revenue maximizing, output
vector is to be calculated. Defaults is <code>XREF</code>.  Same form as
<code>XREF</code></p>
</td></tr>
<tr><td><code id="cost.opt_+3A_yobs">YOBS</code></td>
<td>
<p>The output for which an optimal, cost minimizing input
vector is to be calculated. Defaults is <code>YREF</code>.  Same form as
<code>YREF</code></p>
</td></tr>
<tr><td><code id="cost.opt_+3A_rts">RTS</code></td>
<td>

<p>A text string or a number defining the underlying DEA technology /
returns to scale assumption.
</p>

<table>
<tr>
 <td style="text-align: right;">
0 </td><td style="text-align: left;"> fdh </td><td style="text-align: left;"> Free disposability hull, no convexity assumption </td>
</tr>
<tr>
 <td style="text-align: right;">
1 </td><td style="text-align: left;"> vrs </td><td style="text-align: left;"> Variable returns to scale, convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
2 </td><td style="text-align: left;"> drs </td><td style="text-align: left;"> Decreasing returns to scale, convexity, downscaling and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
3 </td><td style="text-align: left;"> crs </td><td style="text-align: left;"> Constant returns to scale, convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
4 </td><td style="text-align: left;"> irs </td><td style="text-align: left;"> Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
5 </td><td style="text-align: left;"> add </td><td style="text-align: left;"> Additivity (scaling up and down, but only with integers), and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
6 </td><td style="text-align: left;"> fdh+ </td><td style="text-align: left;"> A combination of free disposability and restricted
 or local constant return to scale
</td>
</tr>

</table>

</td></tr>
<tr><td><code id="cost.opt_+3A_param">param</code></td>
<td>
<p>Possible parameters. Now only used for
RTS=&quot;fdh+&quot; to set low and high values for restrictions on lambda;
see the section details and examples in <code><a href="#topic+dea">dea</a></code> for its
use. Future versions might also use <code>param</code> for other
purposes.</p>
</td></tr>
<tr><td><code id="cost.opt_+3A_transpose">TRANSPOSE</code></td>
<td>
<p>Input and output matrices are treated as firms times
goods for the default value <code>TRANSPOSE=FALSE</code> corresponding
to the standard in R for statistical models.  When <code>TRUE</code>
data matrices, quantities and prices, are transposed to goods times
firms matrices.</p>
</td></tr>
<tr><td><code id="cost.opt_+3A_lp">LP</code></td>
<td>
<p>Only for debugging. If <code>LP=TRUE</code> then input and output
for the LP program are written to standard output for each unit.</p>
</td></tr>
<tr><td><code id="cost.opt_+3A_control">CONTROL</code></td>
<td>
<p>Possible controls to <span class="pkg">lpSolveAPI</span>, see the
documentation for that package. For examples of use see the
function <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="cost.opt_+3A_lpk">LPK</code></td>
<td>
<p>When <code>LPK=k</code> then a mps file is written for firm
<code>k</code>; it can be used as input to an alternative LP solver
to check the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Input and output matrices are in the same form as for the
method <code><a href="#topic+dea">dea</a></code>.
</p>
<p>The LP optimization problem is formulated in Bogetoft and
Otto (2011, pp 35 and 102) and is solved by the LP method in the
package <span class="pkg">lpSolveAPI</span>.
</p>
<p>The methods <code>print</code> and <code>summary</code> are working for
<code>cost.opt</code>, <code>revenue.opt</code>, and <code>profit.opt</code>
</p>


<h3>Value</h3>

<p> The values returned are the optimal input, and/or optimal
output. When saved in an object the following components are
available:
</p>
<table>
<tr><td><code>xopt</code></td>
<td>
<p>The optimal input, returned as a matrix by
<code>cost.opt</code> and <code>profit.cost</code>.</p>
</td></tr>
<tr><td><code>yopt</code></td>
<td>
<p>The optimal output, returned as a matrix by
<code>revenue.opt</code> and <code>profit.cost</code>.</p>
</td></tr>
<tr><td><code>cost</code></td>
<td>
<p>The optimal/minimal cost.</p>
</td></tr>
<tr><td><code>revenue</code></td>
<td>
<p>The optimal/maximal revenue</p>
</td></tr>
<tr><td><code>profit</code></td>
<td>
<p>The optimal/maximal profit</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The peer weights that determines the technology, a
matrix. Each row is the lambdas for the firm corresponding to that
row; for the vrs technology the rows sum to 1. A column shows for
a given firm how other firms are compared to this firm, i.e. peers
are firms with a positive element in their columns.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The index for peer units can be returned by the method <code>peers</code>
and the weights are returned in <code>lambda</code>.  Note that the peers
now are the firms for the optimal input and/or output allocation, not
just the technical efficient firms.
</p>
<p>If a numerical problem occurs, status=5, or if no solution can be found,
the best solution is often to scale the input <code>X</code> and output
<code>Y</code> yourself or use the option <code>CONTROL</code> to change scaling in
the program itself, as described in the notes for <code><a href="#topic+dea">dea</a></code>.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p>Bogetoft and Otto; <em>Benchmarking with DEA, SFA, and R</em>; Springer
2011
</p>


<h3>See Also</h3>

<p>Paul W. Wilson (2008), &ldquo;FEAR 1.0: A Software Package for Frontier
Efficiency Analysis with R,&rdquo; <em>Socio-Economic Planning Sciences</em>
42, 247&ndash;254
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(c(2,12, 2,8, 5,5, 10,4, 10,6, 3,13), ncol=2, byrow=TRUE)
y &lt;- matrix(1,nrow=dim(x)[1],ncol=1)
w &lt;- matrix(c(1.5, 1),ncol=2)

txt &lt;- LETTERS[1:dim(x)[1]]
dea.plot(x[,1],x[,2], ORIENTATION="in",  cex=1.25)
text(x[,1],x[,2],txt,adj=c(-.7,-.2),cex=1.25)

# technical efficiency
te &lt;- dea(x,y,RTS="vrs")
xopt &lt;- cost.opt(x,y,w,RTS=1)
cobs &lt;- x %*% t(w)
copt &lt;- xopt$x %*% t(w)
# cost efficiency
ce &lt;- copt/cobs
# allocaltive efficiency
ae &lt;- ce/te$eff
data.frame("ce"=ce,"te"=te$eff,"ae"=ae)
print(cbind("ce"=c(ce),"te"=te$eff,"ae"=c(ae)),digits=2)

# isocost line in the technology plot
abline(a=copt[1]/w[2], b=-w[1]/w[2], lty="dashed")
</code></pre>

<hr>
<h2 id='critValue'>Critical values from bootstrapped DEA models</h2><span id='topic+critValue'></span>

<h3>Description</h3>

<p>Calculates critical value for test using bootstrap output
in DEA models

</p>


<h3>Usage</h3>

<pre><code class='language-R'> critValue(s, alpha=0.05) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="critValue_+3A_s">s</code></td>
<td>
<p>Vector with calculated values of the statistic for each of
the <code>NREP</code> bootstraps; NREP is from <code>boot.sw98</code> </p>
</td></tr>
<tr><td><code id="critValue_+3A_alpha">alpha</code></td>
<td>
<p>The size of the test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Needs bootstrapped values of the test statistic</p>


<h3>Value</h3>

<p>Returns the critical value</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>See Also</h3>

<p><code>boot.sw98</code> in <span class="pkg">FEAR</span>, Paul W. Wilson (2008),
&ldquo;FEAR 1.0: A Software Package for Frontier Efficiency Analysis
with R,&rdquo; <em>Socio-Economic Planning Sciences</em> 42, 247&ndash;254 </p>


<h3>Examples</h3>

<pre><code class='language-R'># The critical value for two-sided test in normal distribution found
# by simulation.
x &lt;- rnorm(1000000)
critValue(x,.975)
</code></pre>

<hr>
<h2 id='dea'>DEA efficiency</h2><span id='topic+dea'></span><span id='topic+print.Farrell'></span><span id='topic+summary.Farrell'></span>

<h3>Description</h3>

<p>Estimates a DEA frontier and calculates efficiency
measures a la Farrell.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dea(X, Y, RTS="vrs", ORIENTATION="in", XREF=NULL, YREF=NULL,
    FRONT.IDX=NULL, SLACK=FALSE, DUAL=FALSE, DIRECT=NULL, param=NULL,
    TRANSPOSE=FALSE, FAST=FALSE, LP=FALSE, CONTROL=NULL, LPK=NULL)

## S3 method for class 'Farrell'
print(x, digits=4, ...) 
## S3 method for class 'Farrell'
summary(object, digits=4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dea_+3A_x">X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix
of observations of K firms with m inputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the input matrix is transposed to input x
firm.</p>
</td></tr>
<tr><td><code id="dea_+3A_y">Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix
of observations of K firms with n outputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the output matrix is transposed to output x
firm.</p>
</td></tr>
<tr><td><code id="dea_+3A_rts">RTS</code></td>
<td>
<p> Text string or a number defining the underlying DEA
technology / returns to scale assumption.
</p>

<table>
<tr>
 <td style="text-align: right;">

0 </td><td style="text-align: left;"> fdh </td><td style="text-align: left;"> Free disposability hull, no convexity assumption </td>
</tr>
<tr>
 <td style="text-align: right;">

1 </td><td style="text-align: left;"> vrs </td><td style="text-align: left;"> Variable returns to scale, convexity and free
disposability </td>
</tr>
<tr>
 <td style="text-align: right;">

2 </td><td style="text-align: left;"> drs </td><td style="text-align: left;"> Decreasing returns to scale, convexity, down-scaling
and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">

3 </td><td style="text-align: left;"> crs </td><td style="text-align: left;"> Constant returns to scale, convexity and free
disposability </td>
</tr>
<tr>
 <td style="text-align: right;">

4 </td><td style="text-align: left;"> irs </td><td style="text-align: left;"> Increasing returns to scale, (up-scaling, but not
down-scaling), convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">

5 </td><td style="text-align: left;"> irs2 </td><td style="text-align: left;"> Increasing returns to scale (up-scaling, but not
down-scaling), additivity, and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">

6 </td><td style="text-align: left;"> add </td><td style="text-align: left;"> Additivity (scaling up and down, but only with
integers), and free disposability; also known af replicability and 
free disposability, the free disposability and replicability hull 
(frh) -- no convexity assumption </td>
</tr>
<tr>
 <td style="text-align: right;">

7 </td><td style="text-align: left;"> fdh+ </td><td style="text-align: left;"> A combination of free disposability and restricted
 or local constant return to scale </td>
</tr>
<tr>
 <td style="text-align: right;">
 






10 </td><td style="text-align: left;"> vrs+ </td><td style="text-align: left;"> As vrs, but with restrictions on the individual lambdas 
via <code>param</code>

</td>
</tr>

</table>

</td></tr>
<tr><td><code id="dea_+3A_orientation">ORIENTATION</code></td>
<td>
<p>Input efficiency &quot;in&quot; (1), output efficiency &quot;out&quot;
(2), and graph efficiency &quot;graph&quot; (3). For use with <code>DIRECT</code>,
an additional option is &quot;in-out&quot; (0).</p>
</td></tr>
<tr><td><code id="dea_+3A_xref">XREF</code></td>
<td>
<p>Inputs of the firms determining the technology, defaults
to <code>X</code></p>
</td></tr>
<tr><td><code id="dea_+3A_yref">YREF</code></td>
<td>
<p>Outputs of the firms determining the technology, defaults
to <code>Y</code></p>
</td></tr>
<tr><td><code id="dea_+3A_front.idx">FRONT.IDX</code></td>
<td>
<p>Index for firms determining the technology</p>
</td></tr>
<tr><td><code id="dea_+3A_slack">SLACK</code></td>
<td>
<p>Calculate slack in a phase II calculation by an intern 
call of the function <code><a href="#topic+slack">slack</a></code>. Note that the precision
for calculating slacks for orientation graph is low.</p>
</td></tr>
<tr><td><code id="dea_+3A_dual">DUAL</code></td>
<td>
<p>Calculate dual variables, i.e. shadow prices; not
calculated for orientation graph as that is not an LP problem.</p>
</td></tr>
<tr><td><code id="dea_+3A_direct">DIRECT</code></td>
<td>
<p>Directional efficiency, <code>DIRECT</code> is either a
scalar, an array, or a matrix with non-negative elements.
</p>
<p>If the argument is a scalar, the direction is (1,1,...,1) times
the scalar; the value of the efficiency depends on the scalar as
well as on the unit of measurements.
</p>
<p>If the argument is an array, this is used for the direction for every
firm; the length of the array must correspond to the number of
inputs and/or outputs depending on the <code>ORIENTATION</code>.
</p>
<p>If the argument is a matrix then different directions are used for
each firm. The dimensions depends on the <code>ORIENTATION</code> (and
<code>TRANSPOSE</code>), the number of firms must correspond to the
number of firms in <code>X</code> and <code>Y</code>.
</p>
<p><code>DIRECT</code> must not be used in connection with
<code>ORIENTATION="graph"</code>.
</p>
</td></tr>
<tr><td><code id="dea_+3A_param">param</code></td>
<td>
<p>Possible parameters. At the moment only used for
RTS=&quot;fdh+&quot; to set low and high values for restrictions on lambda;
see the section details and examples for its use. Future versions
might also use <code>param</code> for other purposes.</p>
</td></tr>
<tr><td><code id="dea_+3A_transpose">TRANSPOSE</code></td>
<td>
<p>Input and output matrices are treated as firms
times goods matrices for the default value <code>TRANSPOSE=FALSE</code>
corresponding to the standard in R for statistical models.  When
<code>TRUE</code> data matrices are transposed to good times firms
matrices as is normally used in LP formulation of the problem.</p>
</td></tr>
<tr><td><code id="dea_+3A_lp">LP</code></td>
<td>
<p>Only for debugging. If <code>LP=TRUE</code> then input and
output for the LP program are written to standard output for each
unit.</p>
</td></tr>
<tr><td><code id="dea_+3A_fast">FAST</code></td>
<td>
<p>Only calculate efficiencies and just return them as a
vector, i.e. no lambda or other output. The return when using
FAST cannot be used as input for <code>slack</code> and <code>peers</code>.</p>
</td></tr>
<tr><td><code id="dea_+3A_control">CONTROL</code></td>
<td>
<p>Possible controls to <span class="pkg">lpSolveAPI</span>, see the
documentation for that package; use <code>?lp.control.options</code></p>
</td></tr>
<tr><td><code id="dea_+3A_...">...</code></td>
<td>
<p>Optional parameters for the print and summary methods.</p>
</td></tr>
<tr><td><code id="dea_+3A_object">object</code>, <code id="dea_+3A_x">x</code></td>
<td>
<p>An object of class Farrell (returned by the
function <code>dea</code>) &ndash; R code uses &lsquo;<code>object</code>&rsquo; and
&lsquo;<code>x</code>&rsquo; alternating for generic methods.</p>
</td></tr>
<tr><td><code id="dea_+3A_digits">digits</code></td>
<td>
<p>digits in printed output, handled by format in print.</p>
</td></tr>
<tr><td><code id="dea_+3A_lpk">LPK</code></td>
<td>
<p>when <code>LPK=k</code> then a mps file is written for firm
<code>k</code>; it can be used as input to an alternative LP solver
to check the results.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The return from <code>dea</code> and <code>sdea</code> is an object of class
Farrell.  The efficiency in <code>dea</code> is calculated by the LP method
in the package <span class="pkg">lpSolveAPI</span>.  Slacks can be calculated either in
the call of <code>dea</code> using the option <code>SLACK=TRUE</code> or in a
following call to the function <code><a href="#topic+slack">slack</a></code>.
</p>
<p>The directional efficiency when the argument <code>DIRECT</code> is used,
depends on the unit of measurement and is not restricted to be less
than 1 (or greater than 1 for output efficiency) and is therefore
completely different from the Farrell efficiency.
</p>
<p>The crs factor in RTS=&quot;fdh+&quot; that sets the lower and upper bound can
be changed by the argument <code>param</code> that will set the lower and
upper bound to 1-param and 1+param; the default value is
param=.15. The value must be greater than or equal to 0 and strictly
less than 1. A value of 0 corresponds to RTS=&quot;fdh&quot;.  To get an
asymmetric interval set param to a 2 dimensional array with values for
the low and high end for interval, for instance
<code>param=c(.8,1.15)</code>.  The FDH+ technology set is described in
Bogetoft and Otto (2011) pages 73&ndash;74.
</p>
<p>The technology RTS=&quot;vrs+&quot; uses the parameter <code>param</code> to set 
restrictions on lambda, the convexity parameters. The elements of param 
are <code>param=(low, high, sum_low, sum_high)</code> where &quot;low&quot; and &quot;high&quot;
are restrictions on the individual lambda and &quot;sum_low&quot; and &quot;sum_high&quot; are 
restrictions on the sum of lambdas. The individual lambda must be in the 
interval from low to high or be zero. With one parameter the restrictions 
set are <code>(param, 1+1-(param),1,1)</code>, with two parameters 
<code>(param[1], param[2],1,1)</code>, and with four parameters 
<code>(param[1], param[2],param[3], param[4])</code>. The resulting technology set is 
not necessarily convex.
</p>




<p>The graph orientated efficiency is calculated by bisection between
feasible and infeasible values of G. The precision in the result is
less than for the other orientations.
</p>
<p>When the argument <code>DIRECT=d</code> is used then the returned value
<code>e</code> for input orientation is the exces input measured in <code>d</code>
units of measurements, i.e. <code class="reqn">x-e d</code>, and for output orientation
<code class="reqn">y+e d</code>.  The directional efficency can be restricted to inputs
(<code>ORIENTAION="in"</code>), restricted to outputs
(<code>ORIENTAION="out"</code>), or both include inputs and output
directions (<code>ORIENTAION="in-out"</code>). Directional efficiency is
discussed on pages 31&ndash;35 and 121&ndash;127 in Bogetoft and Otto (2011).
</p>


<h3>Value</h3>

<p> The results are returned in a Farrell object with the
following components.  The last three components in the list are
only part of the object when <code>SLACK=TRUE</code>.
</p>
<table>
<tr><td><code>eff</code></td>
<td>
<p>The efficiencies.  Note when DIRECT is used then the
efficencies are not Farrell efficiencies but rather exces values
in DIRECT units of measurement</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The lambdas, i.e. the weight of the peers, for each firm</p>
</td></tr>
<tr><td><code>objval</code></td>
<td>
<p>The objective value as returned from the LP program;
normally the same as eff, but for <code>slack</code> it is the the sum
of the slacks</p>
</td></tr>
<tr><td><code>RTS</code></td>
<td>
<p>The return to scale assumption as in the option <code>RTS</code>
in the call</p>
</td></tr>
<tr><td><code>ORIENTATION</code></td>
<td>
<p>The efficiency orientation as in the call</p>
</td></tr>
<tr><td><code>TRANSPOSE</code></td>
<td>
<p>As in the call</p>
</td></tr>
<tr><td><code>slack</code></td>
<td>
<p>A logical vector where the component for a firm is
<code>TRUE</code> if the sums of slacks for the corresponding firm is
positive. Only calculated in dea when option <code>SLACK=TRUE</code></p>
</td></tr>
<tr><td><code>sum</code></td>
<td>
<p>A vector with sums of the slacks for each firm. Only
calculated in dea when option <code>SLACK=TRUE</code></p>
</td></tr>
<tr><td><code>sx</code></td>
<td>
<p>A matrix for input slacks for each firm, only calculated if
the option <code>SLACK</code> is <code>TRUE</code> or returned from the
method <code>slack</code></p>
</td></tr>
<tr><td><code>sy</code></td>
<td>
<p>A matrix for output slack, see <code>sx</code></p>
</td></tr>
<tr><td><code>ux</code></td>
<td>
<p>Dual variable for input, only calculated if <code>DUAL</code> is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code>vy</code></td>
<td>
<p>Dual variable for output, only calculated if <code>DUAL</code> is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>The arguments <code>X</code>, <code>Y</code>, <code>XREF</code>, and <code>YREF</code> are
supposed to be matrices or numerical data frames that in the function
will be converted to matrices. When subsetting a matrix or data frame
to just one column then the class of the resulting object/variable is
no longer a matrix or a data frame, but just a numeric (array,
vector). Therefore, in this case a numeric input that is not a matrix
nor a data frame is transformed to a 1 column matrix, and here the use
of the argument <code>TRANSPOSE=TRUE</code> gives an error.
</p>
<p>The dual values are not unique for extreme points (firms on the
boundary with an efficiency of 1) and therefore the calculated dual
values for these firms can depend on the order of firms in the
reference technology. The same lack of uniqueness also makes the peers
for some firms depend on the order of firms in the reference
technology.
</p>
<p>To calucalte slack use the argument <code>SLACK=TRUE</code> or use the
function <code><a href="#topic+slack">slack</a></code> directly.
</p>
<p>When there is slack, and slack is not taken into consideration, then
the peers for a firm with slack might depend on the order of firms in
the data set; this is a property of the LP algorithm used to solve the
problem.
</p>
<p>To handle fixed, non-discretionary inputs, one can let it appear as
negative output in an input-based mode, and reversely for fixed,
non-discretionary outputs. Fixed inputs (outputs) can also be handled
by directional efficiency; set the direction, the argument
<code>DIRECT</code>, equal to the variable, discretionary inputs (outputs)
and 0 for the fixed inputs (outputs).
</p>
<p>When the the argument <code>DIRECT=X</code> is used the then the returned
effiency is equal to 1 minus the Farrell efficiency for input
orientation and to the Farrell effiency minus 1 for output
orientation.
</p>
<p>To use matrices <code>X</code> and <code>Y</code> prepared for the methods in the
package <span class="pkg">FEAR</span> (Wilson 2008) set the options
<code>TRANSPOSE=TRUE</code>; for consistency with <span class="pkg">FEAR</span> the options
<code>RTS</code> and <code>ORIENTATION</code> also accepts numbers as in
<span class="pkg">FEAR</span>.
</p>
<p>The tolerance that lambda is zero or one is 1e-7, the default value of
'epsint' in the package <code>lpSolveAPI</code>, i.e. values closer than
1e-7 from zero or one are set to respective integer value. The 'epsint'
is the tolerance that is used to determine whether a floating-point
number is in fact an in teger. The same tolerance is used for
efficiency value near one.
</p>
<p>Some scaling is done in the function, but this does not always work 
satisfactory, i.e. sometime, a solution cannot always be found &ndash; the 
program prints a warning and the efficiency for the firm is set to NA. 
Often this is due to a bad scaling of the data. Either the user can try 
a different scaling of data when calling the function or one can use the
option <code>CONTROL</code> to try a different scaling by the program. For 
instance one can insert <code>CONTROL=list(scaling=c("geometric", "equilibrate")</code>
or <code>CONTROL=list(scaling=c("curtisreid", "equilibrate", "dynupdate")</code> 
in the option list for the function call. The full list of possible 
scaling options can be found found from <code>?lp.control.options</code> under
&quot;scaling&quot;.
</p>
<p>If a numerical problem occurs, status=5, the best solution is probably to
scale the input <code>X</code> and output <code>Y</code> yourself or use a different
scaling option as desribed above. The best results are obtained when the 
variables are close to 1. If some variable are in the millions, then let
the unit of measure be a million.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Peter Bogetoft and Lars Otto; <em>Benchmarking with
DEA, SFA, and R</em>; Springer 2011 </p>


<h3>See Also</h3>

<p>Paul W. Wilson (2008), &ldquo;FEAR 1.0: A Software Package for Frontier
Efficiency Analysis with R,&rdquo; <em>Socio-Economic Planning Sciences</em>
42, 247&ndash;254
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(100,200,300,500,100,200,600),ncol=1)
y &lt;- matrix(c(75,100,300,400,25,50,400),ncol=1)
dea.plot.frontier(x,y,txt=TRUE)

e &lt;- dea(x,y)
eff(e)
print(e)
summary(e)
lambda(e)

# Input savings potential for each firm
(1-eff(e)) * x
(1-e$eff) * x

# calculate slacks
el &lt;- dea(x,y,SLACK=TRUE)
data.frame(e$eff,el$eff,el$slack,el$sx,el$sy)

# Fully efficient units, eff==1 and no slack
which(eff(e) == 1 &amp; !el$slack)

# fdh+ with limits in the interval [.7, 1.2]
dea(x,y,RTS="fdh+", param=c(.7,1.2))
</code></pre>

<hr>
<h2 id='dea.add'>Additive DEA model</h2><span id='topic+dea.add'></span>

<h3>Description</h3>

<p> Calculates additive efficiency as sum of input and
output slacks within different DEA models </p>


<h3>Usage</h3>

<pre><code class='language-R'>
dea.add(X, Y, RTS="vrs", XREF=NULL, YREF=NULL, 
        FRONT.IDX=NULL, param=NULL, TRANSPOSE=FALSE, LP=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dea.add_+3A_x">X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix
of observations of K firms with m inputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the input matrix is transposed to input x
firm. </p>
</td></tr>
<tr><td><code id="dea.add_+3A_y">Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix
of observations of K firms with n outputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the output matrix is transposed to output x
firm. </p>
</td></tr>
<tr><td><code id="dea.add_+3A_rts">RTS</code></td>
<td>
<p> Text string or a number defining the underlying DEA
technology / returns to scale assumption.
</p>

<table>
<tr>
 <td style="text-align: right;">
0 </td><td style="text-align: left;"> fdh </td><td style="text-align: left;"> Free disposability hull, no convexity assumption </td>
</tr>
<tr>
 <td style="text-align: right;">
1 </td><td style="text-align: left;"> vrs </td><td style="text-align: left;"> Variable returns to scale, convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
2 </td><td style="text-align: left;"> drs </td><td style="text-align: left;"> Decreasing returns to scale, convexity, down-scaling and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
3 </td><td style="text-align: left;"> crs </td><td style="text-align: left;"> Constant returns to scale, convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
4 </td><td style="text-align: left;"> irs </td><td style="text-align: left;"> Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
5 </td><td style="text-align: left;"> add </td><td style="text-align: left;"> Additivity (scaling up and down, but only with integers), and free disposability
</td>
</tr>

</table>

</td></tr>
<tr><td><code id="dea.add_+3A_xref">XREF</code></td>
<td>
<p>Inputs of the firms determining the technology, defaults
to <code>X</code></p>
</td></tr>
<tr><td><code id="dea.add_+3A_yref">YREF</code></td>
<td>
<p>Outputs of the firms determining the technology, defaults
to <code>Y</code></p>
</td></tr>
<tr><td><code id="dea.add_+3A_front.idx">FRONT.IDX</code></td>
<td>
<p>Index for firms determining the technology</p>
</td></tr>
<tr><td><code id="dea.add_+3A_param">param</code></td>
<td>
<p>Possible parameters. At the moment only used for
RTS=&quot;fdh+&quot; to set low and high values for restrictions on lambda;
see the section details and examples for its use. Future versions
might also use <code>param</code> for other purposes.</p>
</td></tr>
<tr><td><code id="dea.add_+3A_transpose">TRANSPOSE</code></td>
<td>
<p>Input and output matrices are treated as firms
times goods matrices for the default value <code>TRANSPOSE=FALSE</code>
corresponding to the standard in R for statistical models.  When
<code>TRUE</code> data matrices are transposed to good times firms
matrices as is normally used in LP formulation of the problem.</p>
</td></tr>
<tr><td><code id="dea.add_+3A_lp">LP</code></td>
<td>
<p>Only for debugging. If <code>LP=TRUE</code> then input and output
for the LP program are written to standard output for each unit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The sum of the slacks is maximized in a LP formulation of
the DEA technology. The sum of the slacks can be seen as distance to
the frontier when you only move parallel to the axes of inputs and
outputs, i.e. not a usual Euclidean distance, but what is also known
as an L1 norm.
</p>
<p>Since it is the sum of slacks that is calculated, there is no
exogenous ORIENTATION in the problem. Rather, there is generally
both an input and an output direction in the slacks. The model
considers the input excess and output shortfall simultaneously and
finds a point on the frontier that is most distant to the point
being evaluated.
</p>


<h3>Value</h3>

<table>
<tr><td><code>sum</code></td>
<td>
<p>Sum of all slacks for each firm,
<code>sum=sum(sx)+sum(sy)</code>.</p>
</td></tr>
<tr><td><code>slack</code></td>
<td>
<p>A non-NULL vector of logical variables, <code>TRUE</code> if
there is slack for the corresponding firm, and <code>FALSE</code> if
the there is no slack, i.e. the sum of slacks is zero.</p>
</td></tr>
<tr><td><code>sx</code></td>
<td>
<p>A matrix of input slacks for each firm</p>
</td></tr>
<tr><td><code>sy</code></td>
<td>
<p>A matrix of output slack for each firm</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The lambdas, i.e. the weights of the peers for each firm</p>
</td></tr>
</table>


<h3>Note</h3>

<p> This is neither a Farrell nor a Shephard like efficiency.
</p>
<p>The value of the slacks depends on the scaling of the different
inputs and outputs.  Therefore the values are not independent of how
the input and output are measured.</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>Source</h3>

<p>Corresponds to Eqs. 4.34-4.38 in Cooper et al. (2007)
</p>


<h3>References</h3>

<p>Bogetoft and Otto; <em>Benchmarking with DEA, SFA, and R</em>; Springer
2011
</p>
<p>Cooper, Seiford, and Tone; <em>Data Envelopment Analysis: A
Comprehensive Text with Models, Applications, References and
DEA-Solver Software</em>; Second edition, Springer 2007
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(2,3,2,4,6,5,6,8),ncol=1)
y &lt;- matrix(c(1,3,2,3,5,2,3,5),ncol=1)
dea.plot.frontier(x,y,txt=1:dim(x)[1])

sb &lt;- dea.add(x,y,RTS="vrs")
data.frame("sx"=sb$sx,"sy"=sb$sy,"sum"=sb$sum,"slack"=sb$slack)
</code></pre>

<hr>
<h2 id='dea.boot'> Bootstrap DEA models </h2><span id='topic+dea.boot'></span><span id='topic+boot.fear'></span>

<h3>Description</h3>

<p> The function <code>dea.boot</code> bootstrap DEA models and
returns bootstrap of Farrell efficiencies. This function is slower than the 
<code>boot.sw89</code> from the package <span class="pkg">FEAR</span>. 
The faster function <code>boot.fear</code> is a wrapper for <code>boot.sw89</code> from 
the package <span class="pkg">FEAR</span> returning results directly as Farrell measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dea.boot(X, Y, NREP = 200, EFF = NULL, RTS = "vrs", ORIENTATION="in", 
         alpha = 0.05, XREF = NULL, YREF = NULL, FRONT.IDX=NULL, 
         EREF = NULL, DIRECT = NULL, TRANSPOSE = FALSE, 
         SHEPHARD.INPUT = TRUE, LP, CONTROL=NULL)

boot.fear(X, Y, NREP = 200, EFF = NULL, RTS = "vrs", ORIENTATION = "in", 
         alpha = 0.05, XREF = NULL, YREF = NULL, EREF = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dea.boot_+3A_x">X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix of
observations of K firms with m inputs (firm x input) </p>
</td></tr>
<tr><td><code id="dea.boot_+3A_y">Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix of
observations of K firms with n outputs (firm x input). </p>
</td></tr>
<tr><td><code id="dea.boot_+3A_nrep">NREP</code></td>
<td>
<p>Number of bootstrap replications</p>
</td></tr>
<tr><td><code id="dea.boot_+3A_eff">EFF</code></td>
<td>
<p>Efficiencies for (X,Y) relative to the technology
generated from (XREF,YREF).</p>
</td></tr>
<tr><td><code id="dea.boot_+3A_rts">RTS</code></td>
<td>
<p>The returns to scale assumptions as in <code><a href="#topic+dea">dea</a></code>,
only works for &quot;vrs&quot;, &quot;drs&quot;, and &quot;crs&quot;; more to come.</p>
</td></tr>
<tr><td><code id="dea.boot_+3A_orientation">ORIENTATION</code></td>
<td>
<p>Input efficiency &quot;in&quot; (1), output
efficiency &quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3). </p>
</td></tr>
<tr><td><code id="dea.boot_+3A_alpha">alpha</code></td>
<td>
<p>One minus the size of the confidence interval for the
bias corrected efficiencies</p>
</td></tr>
<tr><td><code id="dea.boot_+3A_xref">XREF</code></td>
<td>
<p>Inputs of the firms determining the technology, defaults
to <code>X</code>. </p>
</td></tr>
<tr><td><code id="dea.boot_+3A_yref">YREF</code></td>
<td>
<p>Outputs of the firms determining the technology,
defaults to <code>Y</code>. </p>
</td></tr>
<tr><td><code id="dea.boot_+3A_front.idx">FRONT.IDX</code></td>
<td>
<p>Index for firms determining the technology.</p>
</td></tr>
<tr><td><code id="dea.boot_+3A_eref">EREF</code></td>
<td>
<p>Efficiencies for the firms in XREF, YREF.</p>
</td></tr>
<tr><td><code id="dea.boot_+3A_direct">DIRECT</code></td>
<td>
<p>Does not yet work and is therefore not used.</p>
</td></tr>
<tr><td><code id="dea.boot_+3A_transpose">TRANSPOSE</code></td>
<td>
<p>Input and output matrices are K x m and K x n for
the default value <code>TRANSPOSE=FALSE</code>; this is standard in R
for statistical models.  When <code>TRANSPOSE=TRUE</code> data
matrices are m x K and n x K.</p>
</td></tr>
<tr><td><code id="dea.boot_+3A_shephard.input">SHEPHARD.INPUT</code></td>
<td>
<p>The bootstrap of the Farrell input
efficiencies is done as a Shephard input distance function,
the inverse Farrell input efficiency. The option is only
relevant for input and graph directions. </p>
</td></tr>
<tr><td><code id="dea.boot_+3A_lp">LP</code></td>
<td>
<p>Only for debugging purposes.</p>
</td></tr>
<tr><td><code id="dea.boot_+3A_control">CONTROL</code></td>
<td>
<p>Possible controls to <span class="pkg">lpSolveAPI</span>, see the
documentation for that package. For examples of use see the
function <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The details are lightly explained in Bogetoft and Otto
(2011) Chap. 6, and with more mathematical details in Dario and
Simar (2007) Sect. 3.4 and in Simar and Wilson (1998).
</p>
<p>The bootstrap at the moment does not work for any kind of
directional efficiency.  
</p>
<p>The returned confidence intervals are for the bias corrected
efficiencies; to get confidence intervals for the uncorrected
efficiencies add the biases to both upper and lower values for the
intervals.
</p>
<p>Under the default option <code>SHEPHARD.INPUT=TRUE</code> bias and bias
corrected efficiencies are calculated for Shephard input distance
function and then transformed to Farrell input efficiencies to
avoid possible negative biased corrected input efficiencies. If
this is not wanted use the option <code>SHEPHARD.INPUT=FALSE</code>. This
option is only relevant for input and graph oriented directions.</p>


<h3>Value</h3>

<p> The returned values from both functions are as follows:
</p>
<table>
<tr><td><code>eff</code></td>
<td>
<p>Efficiencies</p>
</td></tr>
<tr><td><code>eff.bc</code></td>
<td>
<p>Bias-corrected efficiencies</p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p>An array of bootstrap bias estimates for the K firms</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p><code>K x 2</code> matrix with confidence interval for the
estimated efficiencies</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>An array of bootstrap variance estimates for the K firms</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p> The replica bootstrap estimates of the Farrell
efficiencies, a <code>K x NREP</code> matrix </p>
</td></tr>
</table>


<h3>Note</h3>

 





<p>The function <code>dea.boot</code> does not depend on the FEAR package
and can therefore be used on computers where the package FEAR is
not available. This, however, comes with a time penalty as it takes
around 4 times longer to run compared to using FEAR directly


</p>
<p>The returned bootstrap estimates from <code>FEAR::boot.sw98</code> 
of efficiencies are sorted for each firm individually. 

Unfortunately, this means that the component of replicas is not the efficiencies for
the same bootstrap replica, but could easily be from different
bootstrap replicas. This also means that this function can
<em>not</em> be used to bootstrap tests for statistical hypotheses
where the statistics involves summing of firm's efficiencies.
</p>
<p>If a numerical problem occurs, status=5, or if no solution can be found,
the best solution is often to scale the input <code>X</code> and output
<code>Y</code> yourself or use the option <code>CONTROL</code> to change scaling in
the program itself, as described in the notes for <code><a href="#topic+dea">dea</a></code>.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Peter Bogetoft and Lars Otto; <em>Benchmarking with
DEA, SFA, and R</em>; Springer 2011.
</p>
<p>Cinzia Dario and L. Simar; <em>Advanced Robust and Nonparametric
Methods in Efficiency Analysis</em>.  Methodology and Applications;
Springer 2007.
</p>
<p>Leopold Simar and Paul .W. Wilson (1998), &ldquo;Sensitivity
analysis of efficiency scores: How to bootstrap in nonparametric
frontier models&rdquo;, <em>Management Science</em> 44, 49&ndash;61.
</p>
<p>Paul W. Wilson (2008), &ldquo;FEAR 1.0: A Software Package for
Frontier Efficiency Analysis with R,&rdquo; <em>Socio-Economic Planning
Sciences</em> 42, 247&ndash;254
</p>


<h3>See Also</h3>

<p> The documentation for <code>boot.sw98</code> in the package
<span class="pkg">FEAR</span>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(100,200,300,500,100,200,600),ncol=1)
y &lt;- matrix(c( 75,100,300,400, 25, 50,400),ncol=1)

e &lt;- dea(x,y)
eff(e)

dea.plot.frontier(x,y,txt=TRUE)

#  To bootstrap for real, NREP should be at least 2000. Run the
#  following lines a couple of times with nrep=100 and see how the
#  bootstrap frontier changes from one run to the next. Try the same
#  with NREP=2000 even though is does take a longer time to run,
#  especially for dea.boot.
nrep &lt;- 5
# nrep &lt;- 2000

# if ( "FEAR" %in% .packages(TRUE) )  {
##  The following only works if the package FEAR is installed; it does
##  not have to be loaded.
#  b &lt;- boot.fear(x,y, NREP=nrep)
# } else {
  b &lt;- dea.boot(x,y, NREP=nrep)
# }

#  bias corrected frontier
dea.plot.frontier(b$eff.bc*x, y, add=TRUE, lty="dashed")
#  outer 95% confidence interval frontier for uncorrected frontier
dea.plot.frontier((b$conf.int[,1]+b$bias)*x, y, add=TRUE, lty="dotted")


## Test of hypothesis in DEA model
# Null hypothesis is that technology is CRS and the alternative is VRS
# Bogetoft and Otto (2011) pages 183--185.
ec &lt;- dea(x,y, RTS="crs")
Ec &lt;- eff(ec)
ev &lt;- dea(x,y, RTS="vrs")
Ev &lt;- eff(ev)
# The test statistic; equation (6.1)
S &lt;- sum(Ec)/sum(Ev)

# To calculate CRS and VRS efficiencies in the same bootstrap replicas
# we reset the random number generator before each call of the
# function dea.boot.

# To get the an initial value for the random number generating process
# we save its state (seed)
save.seed &lt;- sample.int(1e9,1)

# The bootstrap and calculate CRS and VRS under the assumption that
# the true technology is CRS (the null hypothesis) and such that the
# results corresponds to the case where CRS and VRS are calculated for
# the same reference set of firms; to make this happen we set the
# random number generator to the same state before the calls.
set.seed(save.seed)
bc &lt;- dea.boot(x,y, nrep,, RTS="crs")
set.seed(save.seed)
bv &lt;- dea.boot(x,y, nrep,, RTS="vrs", XREF=x,YREF=y, EREF=ec$eff)

# Calculate the statistic for each bootstrap replica
bs &lt;- colSums(bc$boot)/colSums(bv$boot)
# The critical value for the test (default size \code{alpha} of test is 5%)
critValue(bs, alpha=.1)
S
# Accept the hypothesis at 10% level?
critValue(bs, alpha=.1) &lt;= S

# The probability of observing a smaller value of S when the
# hypothesis is true; the p--value.
typeIerror(S, bs)
# Accept the hypothesis at size level 10%?
typeIerror(S, bs) &gt;= .10
</code></pre>

<hr>
<h2 id='dea.direct'> Directional efficiency </h2><span id='topic+dea.direct'></span>

<h3>Description</h3>

<p> Directional efficiency rescaled to an interpretation a la
Farrell efficiency and the corresponding peer importance
(lambda). </p>


<h3>Usage</h3>

<pre><code class='language-R'>dea.direct(X, Y, DIRECT, RTS = "vrs", ORIENTATION = "in", 
          XREF = NULL, YREF = NULL, FRONT.IDX = NULL, 
          SLACK = FALSE, param=NULL, TRANSPOSE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dea.direct_+3A_x">X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix of
observations of K firms with m inputs (firm x input) </p>
</td></tr>
<tr><td><code id="dea.direct_+3A_y">Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix of
observations of K firms with n outputs (firm x input). </p>
</td></tr>
<tr><td><code id="dea.direct_+3A_direct">DIRECT</code></td>
<td>
<p> Directional efficiency, <code>DIRECT</code> is either a
scalar, an array, or a matrix with non-negative elements.
</p>
<p>If the argument is a scalar, the direction is (1,1,...,1) times
the scalar; the value of the efficiency depends on the scalar as
well as on the unit of measurements.
</p>
<p>If the argument an array, this is used for the direction for
every firm; the length of the array must correspond to the
number of inputs and/or outputs depending on the
<code>ORIENTATION</code>.
</p>
<p>If the argument is a matrix then different directions are used
for each firm. The dimensions depends on the <code>ORIENTATION</code>
(and <code>TRANSPOSE</code>), the number of firms must correspond to
the number of firms in <code>X</code> and <code>Y</code>.
</p>
<p><code>DIRECT</code> must not be used in connection with
<code>DIRECTION="graph"</code>.
</p>
</td></tr>
<tr><td><code id="dea.direct_+3A_rts">RTS</code></td>
<td>
<p>Text string or a number defining the underlying DEA
technology / returns to scale assumption.
</p>

<table>
<tr>
 <td style="text-align: right;">
0 </td><td style="text-align: left;"> fdh </td><td style="text-align: left;"> Free disposability hull, no convexity assumption </td>
</tr>
<tr>
 <td style="text-align: right;">
1 </td><td style="text-align: left;"> vrs </td><td style="text-align: left;"> Variable returns to scale, convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
2 </td><td style="text-align: left;"> drs </td><td style="text-align: left;"> Decreasing returns to scale (down-scaling, but not up-scaling), convexity, and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
3 </td><td style="text-align: left;"> crs </td><td style="text-align: left;"> Constant returns to scale, convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
4 </td><td style="text-align: left;"> irs </td><td style="text-align: left;"> Increasing returns to scale (up-scaling, but not down-scaling), convexity, and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
6 </td><td style="text-align: left;"> add </td><td style="text-align: left;"> Additivity (scaling up and down, but only with integers), and free disposability</td>
</tr>
<tr>
 <td style="text-align: right;">
7 </td><td style="text-align: left;"> fdh+ </td><td style="text-align: left;"> A combination of free disposability and restricted
 or local constant return to scale
</td>
</tr>

</table>

</td></tr>
<tr><td><code id="dea.direct_+3A_orientation">ORIENTATION</code></td>
<td>
<p>Input efficiency &quot;in&quot; (1), output
efficiency &quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3). For use
with <code>DIRECT</code>, an additional option is &quot;in-out&quot; (0). </p>
</td></tr>
<tr><td><code id="dea.direct_+3A_xref">XREF</code></td>
<td>
<p>Inputs of the firms determining the technology, defaults
to <code>X</code>. </p>
</td></tr>
<tr><td><code id="dea.direct_+3A_yref">YREF</code></td>
<td>
<p>Outputs of the firms determining the technology,
defaults to <code>Y</code>. </p>
</td></tr>
<tr><td><code id="dea.direct_+3A_front.idx">FRONT.IDX</code></td>
<td>
<p>Index for firms determining the technology. </p>
</td></tr>
<tr><td><code id="dea.direct_+3A_slack">SLACK</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code> and <code><a href="#topic+slack">slack</a></code>. </p>
</td></tr>
<tr><td><code id="dea.direct_+3A_param">param</code></td>
<td>
<p>Possible parameters. At the moment only used for
RTS=&quot;fdh+&quot; to set low and high values for restrictions on lambda;
see the section details and examples in <code><a href="#topic+dea">dea</a></code> for its
use. Future versions might also use <code>param</code> for other
purposes.</p>
</td></tr>
<tr><td><code id="dea.direct_+3A_transpose">TRANSPOSE</code></td>
<td>
<p> see <code><a href="#topic+dea">dea</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the argument <code>DIRECT=d</code> is used then component
<code>objval</code> of the returned object for input orientation is the
maximum value of e where for input orientation <code class="reqn">x-e d</code>, and for
output orientation <code class="reqn">y+e d</code> are in the generated technology
set. The returned component <code>eff</code> is for input <code class="reqn">1-e d/X</code>
and for output <code class="reqn">1+e d /Y</code> to make the interpretation as for a
Farrell efficiency.  Note that when the direction is not
proportional to <code>X</code> or <code>Y</code> the returned <code>eff</code> are
different for different inputs or outputs and <code>eff</code> is a matrix
and not just an array.  The directional efficiency can be restricted
to inputs (<code>ORIENTATION="in"</code>), restricted to outputs
(<code>ORIENTATION="out"</code>), or both include inputs and output
directions (<code>ORIENTATION="in-out"</code>). Directional efficiency is
discussed on pages 31&ndash;35 and 121&ndash;127 in Bogetoft and Otto (2011).
</p>
<p>The Farrell efficiency interpretation is the ratio by which a firm
can proportionally reduce all inputs (or expand all outputs) without
producing less outputs (using more inputs). The directional
efficiencies have the same interpretation expect that the direction is
not proportional to the inputs (or outputs) and therefore the
different inputs may have different reduction ratios, the
efficiency is an array and not just a number.
</p>


<h3>Value</h3>

<p>The results are returned in a Farrell object with the following
components.  The method <code>slack</code> only returns the three
components in the list relevant for slacks.
</p>
<table>
<tr><td><code>eff</code></td>
<td>
<p>The Farrell efficiencies.  Note that the efficiencies
are calculated to have the same interpretations as Farrell
efficiencies. <code>eff</code> is a matrix if there are more than 1
good.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The lambdas, i.e. the weight of the peers, for each firm</p>
</td></tr>
<tr><td><code>objval</code></td>
<td>
<p>The objective value as returned from the LP program; the
<code>objval</code> are excess values in DIRECT units of measurement.</p>
</td></tr>
<tr><td><code>RTS</code></td>
<td>
<p>The return to scale assumption as in the option <code>RTS</code>
in the call</p>
</td></tr>
<tr><td><code>ORIENTATION</code></td>
<td>
<p>The efficiency orientation as in the call</p>
</td></tr>
<tr><td><code>TRANSPOSE</code></td>
<td>
<p>As in the call</p>
</td></tr>
<tr><td><code>slack</code></td>
<td>
<p>A vector with sums of the slacks for each firm. Only
calculated in dea when option <code>SLACK=TRUE</code></p>
</td></tr>
<tr><td><code>sx</code></td>
<td>
<p>A matrix for input slacks for each firm, only calculated if
the option <code>SLACK</code> is <code>TRUE</code> or returned from the
method <code>slack</code></p>
</td></tr>
<tr><td><code>sy</code></td>
<td>
<p>A matrix for output slack, see <code>sx</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p> To handle fixed, non-discretionary inputs, one can let it
appear as negative output in an input-based mode, and reversely for
fixed, non-discretionary outputs. Fixed inputs (outputs) can also be
handled by directional efficiency; set the direction, the argument
<code>DIRECT</code>, equal to the variable, discretionary inputs (outputs)
and 0 for the fixed inputs (outputs).
</p>
<p>When the argument <code>DIRECT=X</code> is used the then the returned
efficiency is equal to 1 minus the Farrell efficiency for input
orientation and equal to the Farrell efficiency minus 1 for output
orientation.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a> </p>


<h3>References</h3>

<p> Directional efficiency is discussed on pages 31&ndash;35 and
121&ndash;127 in Bogetoft and Otto (2011).
</p>
<p>Peter Bogetoft and Lars Otto; <em>Benchmarking with DEA, SFA, and
R</em>; Springer 2011 </p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Directional efficiency
x &lt;- matrix(c(2,5 , 1,2 , 2,2 , 3,2 , 3,1 , 4,1), ncol=2,byrow=TRUE)
y &lt;- matrix(1,nrow=dim(x)[1])
dea.plot.isoquant(x[,1], x[,2],txt=1:dim(x)[1])

E &lt;- dea(x,y)
z &lt;- c(1,1)
e &lt;- dea.direct(x,y,DIRECT=z)
data.frame(Farrell=E$eff, Perform=e$eff, objval=e$objval)
# The direction
arrows(x[,1], x[,2], (x-z)[,1], (x-z)[,2], lty="dashed")
# The efficiency (e$objval) along the direction
segments(x[,1], x[,2], (x-e$objval*z)[,1], (x-e$objval*z)[,2], lwd=2)



# Different directions
x1 &lt;- c(.5, 1, 2, 4, 3, 1)
x2 &lt;- c(4,  2, 1,.5, 2, 4)
x &lt;- cbind(x1,x2)
y &lt;- matrix(1,nrow=dim(x)[1])
dir1 &lt;- c(1,.25)
dir2 &lt;- c(.25, 4)
dir3 &lt;- c(1,4)
e &lt;- dea(x,y)
e1 &lt;- dea.direct(x,y,DIRECT=dir1)
e2 &lt;- dea.direct(x,y,DIRECT=dir2)
e3 &lt;- dea.direct(x,y,DIRECT=dir3)
data.frame(e=eff(e),e1=e1$eff,e2=e2$eff,e3=e3$eff)[6,]

# Technology and directions for all firms
dea.plot.isoquant(x[,1], x[,2],txt=1:dim(x)[1])
arrows(x[,1], x[,2],  x[,1]-dir1[1], x[,2]-dir1[2],lty="dashed")
segments(x[,1], x[,2],  
    x[,1]-e1$objval*dir1[1], x[,2]-e1$objval*dir1[2],lwd=2)
# slack for direction 1
dsl1 &lt;- slack(x,y,e1)
cbind(E=e$eff,e1$eff,dsl1$sx,dsl1$sy, sum=dsl1$sum)



# Technology and directions for firm 6, 
# Figure 2.6 page 32 in Bogetoft &amp; Otto (2011)
dea.plot.isoquant(x1,x2,lwd=1.5, txt=TRUE)
arrows(x[6,1], x[6,2],  x[6,1]-dir1[1], x[6,2]-dir1[2],lty="dashed")
arrows(x[6,1], x[6,2],  x[6,1]-dir2[1], x[6,2]-dir2[2],lty="dashed")
arrows(x[6,1], x[6,2],  x[6,1]-dir3[1], x[6,2]-dir3[2],lty="dashed")
segments(x[6,1], x[6,2],  
    x[6,1]-e1$objval[6]*dir1[1], x[6,2]-e1$objval[6]*dir1[2],lwd=2)
segments(x[6,1], x[6,2],  
    x[6,1]-e2$objval[6]*dir2[1], x[6,2]-e2$objval[6]*dir2[2],lwd=2)
segments(x[6,1], x[6,2],  
    x[6,1]-e3$objval[6]*dir3[1], x[6,2]-e3$objval[6]*dir3[2],lwd=2)
</code></pre>

<hr>
<h2 id='dea.dual'> Dual DEA models and assurance regions </h2><span id='topic+dea.dual'></span>

<h3>Description</h3>

<p> Solution of dual DEA models, possibly with partial value
information given as restrictions on the ratios (assurance regions) </p>


<h3>Usage</h3>

<pre><code class='language-R'>dea.dual(X, Y, RTS = "vrs", ORIENTATION = "in", 
         XREF = NULL, YREF = NULL, 
         FRONT.IDX = NULL, DUAL = NULL, DIRECT=NULL,
         TRANSPOSE = FALSE, LP = FALSE, CONTROL=NULL, LPK=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dea.dual_+3A_x">X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix of
observations of K firms with m inputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the input matrix is transposed to input x
firm. </p>
</td></tr>
<tr><td><code id="dea.dual_+3A_y">Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix of
observations of K firms with n outputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the output matrix is transposed to output x
firm. </p>
</td></tr>
<tr><td><code id="dea.dual_+3A_rts">RTS</code></td>
<td>
<p> A text string or a number defining the underlying DEA
technology / returns to scale assumption.
</p>

<table>
<tr>
 <td style="text-align: right;">

1 </td><td style="text-align: left;"> vrs </td><td style="text-align: left;"> Variable returns to scale, convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
2 </td><td style="text-align: left;"> drs </td><td style="text-align: left;"> Decreasing returns to scale, convexity, down-scaling and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
3 </td><td style="text-align: left;"> crs </td><td style="text-align: left;"> Constant returns to scale, convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
4 </td><td style="text-align: left;"> irs </td><td style="text-align: left;"> Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability.
</td>
</tr>

</table>

</td></tr>
<tr><td><code id="dea.dual_+3A_orientation">ORIENTATION</code></td>
<td>
<p>Input efficiency &quot;in&quot; (1), output efficiency &quot;out&quot;
(2), and graph efficiency &quot;graph&quot; (3) (not yet implemented). For
use with <code>DIRECT</code> an additional option is &quot;in-out&quot; (0). In
this case, &quot;graph&quot; is not feasible</p>
</td></tr>
<tr><td><code id="dea.dual_+3A_xref">XREF</code></td>
<td>
<p>Input of the firms determining the technology, defaults to
<code>X</code></p>
</td></tr>
<tr><td><code id="dea.dual_+3A_yref">YREF</code></td>
<td>
<p>Output of the firms determining the technology, defaults
to <code>Y</code></p>
</td></tr>
<tr><td><code id="dea.dual_+3A_front.idx">FRONT.IDX</code></td>
<td>
<p>Index for firms determining the technology</p>
</td></tr>
<tr><td><code id="dea.dual_+3A_dual">DUAL</code></td>
<td>

<p>Matrix of order &ldquo;number of inputs plus number of outputs minus
2&rdquo; times 2.  The first column is the lower bound and the second column is
the upper bound for the restrictions on the multiplier ratios. The ratios are relative to the first input and the first
output, respectively. This implies that there is no restriction for neither the first
input nor the first output so that the number of restrictions is two less
than the total number of inputs and outputs.
</p>
</td></tr>
<tr><td><code id="dea.dual_+3A_direct">DIRECT</code></td>
<td>
<p>Directional efficiency, <code>DIRECT</code> is either a
scalar, an array, or a matrix with non-negative elements.
</p>
<p>NB <em>Not yet implemented</em></p>
</td></tr>
<tr><td><code id="dea.dual_+3A_transpose">TRANSPOSE</code></td>
<td>
<p>Input and output matrices are treated as firms
times goods for the default value <code>TRANSPOSE=FALSE</code>
corresponding to the standard in R for statistical models.  When
<code>TRUE</code> data matrices shall be transposed to good times firms
matrices as is normally used in LP formulation of the problem.</p>
</td></tr>
<tr><td><code id="dea.dual_+3A_lp">LP</code></td>
<td>
<p>Only for debugging. If <code>LP=TRUE</code> then input and
output for the LP program are written to standard output for
each unit.</p>
</td></tr>
<tr><td><code id="dea.dual_+3A_control">CONTROL</code></td>
<td>
<p>Possible controls to lpSolveAPI, see the documentation
for that package.</p>
</td></tr>
<tr><td><code id="dea.dual_+3A_lpk">LPK</code></td>
<td>
<p>When <code>LPK=k</code> then a mps file is written for firm
<code>k</code>; it can be used as input to an alternative LP solver just
to check the our results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Solved as an LP program using the package lpSolveAPI. The
method <code>dea.dual.dea</code> calls the method <code>dea</code> with the option
<code>DUAL=TRUE</code>.  </p>


<h3>Value</h3>

<table>
<tr><td><code>eff</code></td>
<td>
<p> The efficiencies </p>
</td></tr>
<tr><td><code>objval</code></td>
<td>
<p> The objective value as returned from the LP problem, normally the same as eff </p>
</td></tr>
<tr><td><code>RTS</code></td>
<td>
<p>The return to scale assumption as in the option <code>RTS</code>
in the call</p>
</td></tr>
<tr><td><code>ORIENTATION</code></td>
<td>
<p> The efficiency orientation as in the call </p>
</td></tr>
<tr><td><code>TRANSPOSE</code></td>
<td>
<p> As in the call </p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>Dual values, prices, for inputs </p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Dual values, prices, for outputs </p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p> The values of gamma, the shadow price(s) for returns to
scale restriction </p>
</td></tr>
<tr><td><code>sol</code></td>
<td>
<p>Solution of all variables as one component, sol=c(u,v,gamma).</p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>Note that the dual values are not unique for extreme points in the
technology set. In this case the value of the calculated dual variable can
depend on the order of the complete efficient firms.
</p>
<p>If a numerical problem occurs, status=5, or if no solution can be found,
the best solution is often to scale the input <code>X</code> and output
<code>Y</code> yourself or use the option <code>CONTROL</code> to change scaling in
the program itself, as described in the notes for <code><a href="#topic+dea">dea</a></code>.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Bogetoft and Otto; <em>Benchmarking with DEA, SFA, and
R</em>; Springer 2011. Sect.  5.10: Partial value information </p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(c(2,5 , 1,2 , 2,2 , 3,2 , 3,1 , 4,1), ncol=2,byrow=TRUE)
y &lt;- matrix(1,nrow=dim(x)[1])
dea.plot.isoquant(x[,1],x[,2],txt=1:dim(x)[1])
segments(0,0, x[,1], x[,2], lty="dotted")


e &lt;- dea(x,y,RTS="crs",SLACK=TRUE)
ed &lt;- dea.dual(x,y,RTS="crs")
print(cbind("e"=e$eff,"ed"=ed$eff, peers(e), lambda(e), 
            e$sx, e$sy, ed$u, ed$v), digits=3)

dual &lt;- matrix(c(.5, 2.5), nrow=dim(x)[2]+dim(y)[2]-2, ncol=2, byrow=TRUE)
er &lt;- dea.dual(x,y,RTS="crs", DUAL=dual)
print(cbind("e"=e$eff,"ar"=er$eff, lambda(e), e$sx, e$sy, er$u, 
            "ratio"=er$u[,2]/er$u[,1],er$v),digits=3)


</code></pre>

<hr>
<h2 id='dea.merge'> Estimate potential merger gains and their decompositions </h2><span id='topic+dea.merge'></span>

<h3>Description</h3>

<p> Calculate and decompose potential gains from mergers of
similar firms (horizontal integration).  </p>


<h3>Usage</h3>

<pre><code class='language-R'>
dea.merge(X, Y, M, RTS = "vrs", ORIENTATION = "in",
          XREF = NULL, YREF = NULL, FRONT.IDX = NULL, TRANSPOSE=FALSE,
          CONTROL=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dea.merge_+3A_x">X</code></td>
<td>
<p> K times m matrix as in <code>dea</code> </p>
</td></tr>
<tr><td><code id="dea.merge_+3A_y">Y</code></td>
<td>
<p> K times n matrix as in <code>dea</code> </p>
</td></tr>
<tr><td><code id="dea.merge_+3A_m">M</code></td>
<td>
<p>Kg times K matrix where each row defines a merger by the
firms (columns) included in the matrix as returned from method
<code><a href="#topic+make.merge">make.merge</a></code></p>
</td></tr>
<tr><td><code id="dea.merge_+3A_rts">RTS</code></td>
<td>
<p>as in <code><a href="#topic+dea">dea</a></code> </p>
</td></tr>
<tr><td><code id="dea.merge_+3A_orientation">ORIENTATION</code></td>
<td>
<p> as in <code><a href="#topic+dea">dea</a></code> </p>
</td></tr>
<tr><td><code id="dea.merge_+3A_xref">XREF</code></td>
<td>
<p> as in <code>dea</code> </p>
</td></tr>
<tr><td><code id="dea.merge_+3A_yref">YREF</code></td>
<td>
<p> as in <code>dea</code> </p>
</td></tr>
<tr><td><code id="dea.merge_+3A_front.idx">FRONT.IDX</code></td>
<td>
<p> as in <code>dea</code> </p>
</td></tr>
<tr><td><code id="dea.merge_+3A_transpose">TRANSPOSE</code></td>
<td>
<p> as in <code>dea</code> </p>
</td></tr>
<tr><td><code id="dea.merge_+3A_control">CONTROL</code></td>
<td>
<p>Possible controls to <span class="pkg">lpSolveAPI</span>, see the
documentation for that package. For examples of use see the
function <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The K firms are merged into Kg new, merged firms.
</p>
<p>Most of the arguments correspond to the arguments in
<code><a href="#topic+dea">dea</a></code>, with K firms, m inputs, and n outputs.
</p>
<p>The decomposition is summarized on page 275 and in table 9.1 page 276
in Bogetoft and Otto (2011) and is based on Bogetoft and Wang (2005) </p>


<h3>Value</h3>

<table>
<tr><td><code>Eff</code></td>
<td>
<p>Overall efficiencies of mergers, Kg vector</p>
</td></tr>
<tr><td><code>Estar</code></td>
<td>
<p>Adjusted overall efficiencies of mergers after the
removal of individual learning, Kg vector</p>
</td></tr>
<tr><td><code>learning</code></td>
<td>
<p>Learning effects, Kg vector</p>
</td></tr>
<tr><td><code>harmony</code></td>
<td>
<p>Harmony (scope) effects, Kg vector</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>Size (scale) effects, Kg vector</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If a numerical problem occurs, status=5, or if no solution can be found,
the best solution is often to scale the input <code>X</code> and output
<code>Y</code> yourself or use the option <code>CONTROL</code> to change scaling in
the program itself, as described in the notes for <code><a href="#topic+dea">dea</a></code>.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Bogetoft and Otto; <em>Benchmarking with DEA, SFA, and
R</em>; chapter 9; Springer 2011.
</p>
<p>Bogetoft and Wang; &ldquo;Estimating the Potential Gains from
Mergers&rdquo;; <em>Journal of Productivity Ana-lysis</em>, 23, pp. 145-171,
2005. </p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code> and <code><a href="#topic+make.merge">make.merge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(100,200,300,500),ncol=1,dimnames=list(LETTERS[1:4],"x"))
y &lt;- matrix(c(75,100,300,400),ncol=1,dimnames=list(LETTERS[1:4], "y"))

dea.plot.frontier(x,y,RTS="vrs",txt=LETTERS[1:length(x)],
    xlim=c(0,1000),ylim=c(0,1000) )
dea.plot.frontier(x,y,RTS="drs", add=TRUE, lty="dashed", lwd=2)
dea.plot.frontier(x,y,RTS="crs", add=TRUE, lty="dotted")

dea(x,y,RTS="crs")
M &lt;- make.merge(list(c(1,2), c(3,4)), X=x)
xmer &lt;- M %*% x
ymer &lt;- M %*% y
points(xmer,ymer,pch=8)
text(xmer,ymer,labels=c("A+B","C+D"),pos=4)
dea.merge(x,y,M, RTS="vrs")
dea.merge(x,y,M, RTS="crs")
</code></pre>

<hr>
<h2 id='dea.plot'>Plot of DEA technologies</h2><span id='topic+dea.plot'></span><span id='topic+dea.plot.frontier'></span><span id='topic+dea.plot.isoquant'></span><span id='topic+dea.plot.transform'></span>

<h3>Description</h3>

<p>Draw a graph of a DEA technology. Designed for two goods
illustrations, either isoquant (2 inputs), transformation curve (2
outputs), or a production function (1 input and 1 output).  If the
number of good is larger than 2 then aggregation occur, either
simple or weighted.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
dea.plot(x, y, RTS="vrs", ORIENTATION="in-out", txt=NULL, add=FALSE, 
         wx=NULL, wy=NULL, TRANSPOSE=FALSE, fex=1, GRID=FALSE,
         RANGE=FALSE, param=NULL, ..., xlim, ylim, xlab, ylab)

dea.plot.frontier(x, y, RTS="vrs",...)

dea.plot.isoquant(x1, x2, RTS="vrs",...)

dea.plot.transform(y1, y2, RTS="vrs",...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dea.plot_+3A_x">x</code></td>
<td>
<p>The good illustrated on the first axis. If there are more
than 1 input then inputs are just summed or, if <code>wx</code> is
present, a weighted sum of inputs is used.</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_y">y</code></td>
<td>
<p>The good illustrated on the second axis. If there are more
than 1 output then outputs are just summed or, if <code>wy</code> is
present, a weighted sum of outputs is used.</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_x1">x1</code>, <code id="dea.plot_+3A_y1">y1</code></td>
<td>
<p>The good illustrated on the first axis</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_x2">x2</code>, <code id="dea.plot_+3A_y2">y2</code></td>
<td>
<p>The good illustrated on the  second axis</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_rts">RTS</code></td>
<td>
<p>Underlying DEA model / assumptions about returns to
scale: &quot;fdh&quot; (0), &quot;vrs&quot; (1), &quot;drs&quot; (2), &quot;crs&quot; (3), &quot;irs&quot; (4),
&quot;irs2&quot; (5) (irs without convexity), &quot;add&quot; (6), and &quot;fdh+&quot; (7).
Numbers in parenthesis can also be used as values for
<code>RTS</code></p>
</td></tr>
<tr><td><code id="dea.plot_+3A_orientation">ORIENTATION</code></td>
<td>
<p>Input-output graph of 1 input and 1 output is
&quot;in-out&quot; (0), graph of 2 inputs is &quot;in&quot; (1), and graph of 2
outputs is &quot;out&quot; (2). </p>
</td></tr>
<tr><td><code id="dea.plot_+3A_txt">txt</code></td>
<td>
<p><code>txt</code> is an array to label the observations. If
<code>txt=TRUE</code> the observations are labeled by the observation
number or rownames if there are any. </p>
</td></tr>
<tr><td><code id="dea.plot_+3A_add">add</code></td>
<td>
<p>For <code>add=T</code> the technology is drawn on top of an
existing graph. With the default <code>add=F</code>, a new graph is
made.</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_wx">wx</code></td>
<td>
<p>Weight to aggregate the first axis if there are more than
1 good behind the first axis.</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_wy">wy</code></td>
<td>
<p>Weights to aggregate for the second axis if there are more
than 1 good behind the second the second axis.</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_transpose">TRANSPOSE</code></td>
<td>
<p>Only relevant for more than 1 good for each axis,
see <code><a href="#topic+dea">dea</a></code> for a description of this option.</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_grid">GRID</code></td>
<td>
<p>If <code>GRIF=TRUE</code> a gray grid is put on the plot.</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_...">...</code></td>
<td>
<p>Usual options for the methods <code>plot</code>, <code>lines</code>, 
and <code>abline</code> etc.</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_fex">fex</code></td>
<td>
<p>Relative size of the text/labels on observations;
corresponds to <code>cex</code>, but only changes the size of the
text.</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_range">RANGE</code></td>
<td>
<p>A logical variable, if <code>RANGE=TRUE</code> the limits for
the graph is the range of the variables; zero is always
included. Default is <code>RANGE=FALSE</code> when the range is from
zero to the max values.  Relevant if some values are negative.</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_param">param</code></td>
<td>
<p>Possible parameters. At the moment only used for
RTS=&quot;fdh+&quot;; see the section details and examples for its
use. Future versions might also use <code>param</code> for other
purposes.</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_xlim">xlim</code></td>
<td>
<p>Possible limits <code>c(x1,x2)</code> for the first axis</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_ylim">ylim</code></td>
<td>
<p>Possible limits  <code>c(y1,y2)</code> for the second axis</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_xlab">xlab</code></td>
<td>
<p>Possible label for the x-axis</p>
</td></tr>
<tr><td><code id="dea.plot_+3A_ylab">ylab</code></td>
<td>
<p>Possible label for the y-axis</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The method <code>dea.plot</code> is the general plotting
method. The the 3 others are specialized versions for frontiers (1
input and 1 output), isoquant curves (2 inputs for given outputs),
and transformation curves (2 outputs for given inputs) obtained by
using the argument <code>ORIENTATION</code>.
</p>
<p>The crs factor in RTS=&quot;fdh+&quot; that sets the lower and upper bound
can be changed by the argument <code>param</code> that will set the lower
and upper bound to 1-param and 1+param; the default value is
param=.15. The value must be greater than or equal to 0 and
strictly less than 1. A value of 0 corresponds to RTS=&quot;fdh&quot;. The
FDH+ technology set is described in Bogetoft and Otto (2011) pages
72&ndash;73.</p>


<h3>Value</h3>

<p>No return, uses the original graphing system.  </p>


<h3>Note</h3>

<p>If there are more than 1 good for the arguments <code>x</code> and
<code>y</code> then the goods are just summed or, if <code>wx</code> or
<code>wy</code> are present, weighted sum of goods are used. In this
case the use of the command <code>identify</code> must be called as
<code>dea.plot(rowSums(x),rowSums(y))</code>. 
</p>
<p><em>Warning</em> If you use this facility to plot multi input and
multi output then the plot may deceive you as fully multi
efficient firms are not necessarily placed on the two dimensional
frontier. 
</p>
<p>Note that <code>RTS="add"</code> and <code>RTS="fdh+"</code> only works for
<code>ORIENTATION="in-out"</code> (0).  </p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Peter Bogetoft and Lars Otto; <em>Benchmarking with
DEA, SFA, and R</em>; Springer 2011 
</p>
<p>Paul Murrell; <em>R Graphics</em>; Chapman &amp; Hall 2006</p>


<h3>See Also</h3>

<p>The documentation for the function <code>plot</code> and Murrell
(2006) for further options and on customizing plots.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(c(100,200,300,500,600,100),ncol=1)
y &lt;- matrix(c(75,100,300,400,400,50),ncol=1)

dea.plot(x,y,RTS="vrs",ORIENTATION="in-out",txt=LETTERS[1:length(x)])
dea.plot(x,y,RTS="crs",ORIENTATION="in-out",add=TRUE,lty="dashed")

dea.plot.frontier(x,y,txt=1:dim(x)[1])

n &lt;- 10
x &lt;- matrix(1:n,,1)
y &lt;- matrix(x^(1.6) + abs(rnorm(n)),,1)
dea.plot.frontier(x,y,RTS="irs",txt=1:n)
dea.plot.frontier(x,y,RTS="irs2",add=TRUE,lty="dotted")

# Two different forms of irs: irs and irs2, and two different ways to
# make a frontier
id &lt;- sample(1:n,30,replace=TRUE)
dea.plot(x[id],y[id],RTS="irs",ORIENTATION="in-out")
dea.plot.frontier(x[id],y[id],RTS="irs2")

# Difference between the FDH technology and the additive 
# FRH technology
x &lt;- matrix(c(100,220,300,520,600,100),ncol=1)
y &lt;- matrix(c(75,100,300,400,400,50),ncol=1)
dea.plot(x,y,RTS="fdh",ORIENTATION="in-out",txt=LETTERS[1:length(x)])
dea.plot(x,y,RTS="add",ORIENTATION="in-out",add=TRUE,lty="dashed",lwd=2)
dea.plot(x,y,RTS="fdh+",ORIENTATION="in-out",add=TRUE,
                            lty="dotted",lwd=3,col="red")

# Use of parameter in FDH+
dea.plot(x,y,RTS="fdh",ORIENTATION="in-out",txt=LETTERS[1:length(x)])
dea.plot(x,y,RTS="fdh+",ORIENTATION="in-out",add=TRUE,lty="dashed")
dea.plot(x,y,RTS="fdh+",ORIENTATION="in-out",add=TRUE,lty="dotted",param=.5)
</code></pre>

<hr>
<h2 id='eff+2C+20efficiencies'> Calculate efficiencies for Farrell and sfa object </h2><span id='topic+eff'></span><span id='topic+efficiencies'></span><span id='topic+efficiencies.default'></span><span id='topic+eff.sfa'></span><span id='topic+eff.Farrell'></span><span id='topic+efficiencies.sfa'></span><span id='topic+efficiencies.Farrell'></span>

<h3>Description</h3>

<p> Calculate efficiencies for Farrell and sfa object. For a
sfa there are several types </p>


<h3>Usage</h3>

<pre><code class='language-R'>eff( object, ... )
efficiencies( object, ... )
## Default S3 method:
efficiencies( object, ... )
## S3 method for class 'Farrell'
efficiencies(object, type = "Farrell", ...)
## S3 method for class 'Farrell'
eff(object, type = "Farrell", ...)
## S3 method for class 'sfa'
efficiencies(object, type = "BC", ...)
## S3 method for class 'sfa'
eff(object, type = "BC", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eff+2B2C+2B20efficiencies_+3A_object">object</code></td>
<td>
<p> A Farrell object returned from a DEA function like
<a href="#topic+dea">dea</a>, <a href="#topic+sdea">sdea</a>, or <a href="#topic+mea">mea</a> or an sfa object returned
from the function <a href="#topic+sfa">sfa</a>.  </p>
</td></tr>
<tr><td><code id="eff+2B2C+2B20efficiencies_+3A_type">type</code></td>
<td>
<p> The type of efficiencies to be calculated. For a
Farrell object the possibilities are &ldquo;Farrell&rdquo; efficiency
or &ldquo;Shephard&rdquo; efficiency. For a sfa object the
possibilities are &ldquo;BC&rdquo;, &ldquo;Mode&rdquo;, &ldquo;J&rdquo;, or
&ldquo;add&rdquo;. </p>
</td></tr>
<tr><td><code id="eff+2B2C+2B20efficiencies_+3A_...">...</code></td>
<td>
<p>Further arguments ... </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The possible types for class <code>Farrell</code> (an object returned from
<code><a href="#topic+dea">dea</a></code> et al. are &ldquo;Farrell&rdquo; and &ldquo;Shephard&rdquo;.
</p>
<p>The possible types for class <code>sfa</code> efficiencies are
</p>

<dl>
<dt>BC</dt><dd><p> Efficiencies estimated by minimizing the mean square error;
Eq. (7.21) in Bogetoft and Otto (2011, 219) and Battese and
Coelli (1988, 392) </p>
</dd>
<dt>Mode</dt><dd><p> Efficiencies estimates using the conditional mode approach;
Bogetoft and Otto (2011, 219), Jondrow et al. (1982, 235). </p>
</dd>
<dt>J</dt><dd><p> Efficiencies estimates using the conditional mean approach
Jondrow et al. (1982, 235). </p>
</dd>
<dt>add</dt><dd><p> Efficiency in the additive model, Bogetoft and Otto (2011,
219) </p>
</dd>
</dl>



<h3>Value</h3>

<p>The efficiencies are returned as an array.
</p>


<h3>Note</h3>

<p> For the Farrell object the orientation is determined by the
calculations that led to the object and cannot be changed here.  </p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a> </p>


<h3>References</h3>

<p>Bogetoft and Otto; <em>Benchmarking with DEA, SFA, and R</em>, Springer
2011
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code> and <code><a href="#topic+sfa">sfa</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
</code></pre>

<hr>
<h2 id='eff.dens'>
Estimate and plot density of efficiencies
</h2><span id='topic+eff.dens'></span><span id='topic+eff.dens.plot'></span>

<h3>Description</h3>

<p> A method to estimate and plot kernel estimate of
(Farrell) efficiencies taken into consideration that efficiencies are
bounded either above (input direction) or below (output direction).  </p>


<h3>Usage</h3>

<pre><code class='language-R'>eff.dens(eff, bw = "nrd0")

eff.dens.plot(obj, bw = "nrd0", ..., xlim, ylim, xlab, ylab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eff.dens_+3A_eff">eff</code></td>
<td>
<p> Either a list of (Farrell) efficiencies or a Farrell
object returned from the method <code><a href="#topic+dea">dea</a></code>.  </p>
</td></tr>
<tr><td><code id="eff.dens_+3A_bw">bw</code></td>
<td>
<p> Bandwith, look at the documentation of <code>density</code> for
an explanation.  </p>
</td></tr>
<tr><td><code id="eff.dens_+3A_obj">obj</code></td>
<td>
<p>Either an array of efficiencies or a list returned from
<code>eff.dens</code>.</p>
</td></tr>
<tr><td><code id="eff.dens_+3A_...">...</code></td>
<td>
<p> Further arguments to the <code>plot</code> method like line
type and line width.  </p>
</td></tr>
<tr><td><code id="eff.dens_+3A_xlim">xlim</code></td>
<td>
<p> Range on the x-axis; usually not needed, just use the
defaults. </p>
</td></tr>
<tr><td><code id="eff.dens_+3A_ylim">ylim</code></td>
<td>
<p> Range on the x-axis; usually not needed, just use the
defaults. </p>
</td></tr>
<tr><td><code id="eff.dens_+3A_xlab">xlab</code></td>
<td>
<p> Label for the x-axis. </p>
</td></tr>
<tr><td><code id="eff.dens_+3A_ylab">ylab</code></td>
<td>
<p> Label for the y-axis. </p>
</td></tr>
</table>


<h3>Details</h3>

<p> The calculation is based on a reflection method (Silverman
1986, 30) using the default window kernel and default bandwidth (window
width) in the method <code>density</code>.  
</p>
<p>The method <code>eff.dens.plot</code> plot the density directly, and
<code>eff.dens</code> just estimate the numerical density, and the result
can then either be plotted by <code>plot</code>, corresponds to
<code>eff.dens.plot</code>, or by lines as an overlay on an existing plot.
</p>


<h3>Value</h3>

<p> The return from <code>eff.dens</code> is a list <code>list(x,y)</code>
with efficiencies and the corresponding density values.  </p>


<h3>Note</h3>

<p> The input efficiency is also bounded below by 0, but for normal
firms an efficiency at 0 will not happen, i.e. the boundary is not
effective, and therefore this boundary is not taken into
consideration.  </p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> B.W. Silverman (1986), <em>Density Estimation for Statistics
and Data Analysis</em>, Chapman and Hall, London.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- 1 - rnorm(100)
e[e&gt;1] &lt;- 1
e &lt;- e[e&gt;0]
eff.dens.plot(e)

hist(e, breaks=15, freq=FALSE, xlab="Efficiency", main="")
den &lt;- eff.dens(e)
lines(den,lw=2)
</code></pre>

<hr>
<h2 id='eladder'>Efficiency ladder for a single firm</h2><span id='topic+eladder'></span><span id='topic+eladder2'></span><span id='topic+eladder.plot'></span>

<h3>Description</h3>

<p>How the efficiency changes as the most influential peer is
removed sequentially one at a time. For <code>eladder</code> the removed peer it
is the one that have the largest change in efficiency when removed and for 
<code>eladder2</code> it is the peer with the largest weight (lambda).</p>


<h3>Usage</h3>

<pre><code class='language-R'>
eladder(n, X, Y, RTS="vrs", ORIENTATION="in", 
	XREF=NULL, YREF=NULL, DIRECT=NULL, param=NULL, MAXELAD=NULL)

eladder2(n, X, Y, RTS = "vrs", ORIENTATION = "in", 
	XREF=NULL, YREF=NULL, DIRECT = NULL, param=NULL, MAXELAD=NULL)

eladder.plot(elad, peer, TRIM = NULL, 
	xlab="Most influential peers", ylab="Efficiency", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eladder_+3A_n">n</code></td>
<td>
<p>The number of the firm where the ladder is calculated </p>
</td></tr>
<tr><td><code id="eladder_+3A_x">X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix of
observations of K firms with m inputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the input matrix is transposed to input x
firm. </p>
</td></tr>
<tr><td><code id="eladder_+3A_y">Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix of
observations of K firms with n outputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the output matrix is transposed to output
x firm. </p>
</td></tr>
<tr><td><code id="eladder_+3A_rts">RTS</code></td>
<td>
<p> Text string or a number defining the underlying DEA
technology / returns to scale assumption, se the possible values
for <code><a href="#topic+dea">dea</a></code>. </p>
</td></tr>
<tr><td><code id="eladder_+3A_orientation">ORIENTATION</code></td>
<td>
<p>Input efficiency &quot;in&quot; (1), output efficiency
&quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3). For use with
<code>DIRECT</code>, an additional option is &quot;in-out&quot; (0).</p>
</td></tr>
<tr><td><code id="eladder_+3A_xref">XREF</code></td>
<td>
<p>Inputs of the firms determining the technology, defaults
to <code>X</code></p>
</td></tr>
<tr><td><code id="eladder_+3A_yref">YREF</code></td>
<td>
<p>Outputs of the firms determining the technology, defaults
to <code>Y</code></p>
</td></tr>
<tr><td><code id="eladder_+3A_direct">DIRECT</code></td>
<td>
<p>Directional efficiency, <code>DIRECT</code> is either a
scalar, an array, or a matrix with non-negative elements. See
<code><a href="#topic+dea">dea</a></code> for a further description of this argument.</p>
</td></tr>
<tr><td><code id="eladder_+3A_param">param</code></td>
<td>
<p>Possible parameters. Now only used for
RTS=&quot;fdh+&quot; to set low and high values for restrictions on lambda;
see the section details and examples in <code><a href="#topic+dea">dea</a></code> for its
use. Future versions might also use <code>param</code> for other
purposes.</p>
</td></tr>
<tr><td><code id="eladder_+3A_maxelad">MAXELAD</code></td>
<td>
<p>The maximum number of influential peers to remove.</p>
</td></tr>
<tr><td><code id="eladder_+3A_elad">elad</code></td>
<td>
<p>The sequence of efficiencies returned from <code>eladder</code>. </p>
</td></tr>
<tr><td><code id="eladder_+3A_peer">peer</code></td>
<td>
<p>The sequence of peers returned from <code>eladder</code>. Also used
for annotations at the tick marks at the x-axis.</p>
</td></tr>
<tr><td><code id="eladder_+3A_trim">TRIM</code></td>
<td>
<p>The number of characters for the name of the peers on
the axis in the plot. </p>
</td></tr>
<tr><td><code id="eladder_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis</p>
</td></tr>
<tr><td><code id="eladder_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis</p>
</td></tr>
<tr><td><code id="eladder_+3A_...">...</code></td>
<td>
<p>Usual options for the method <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The function <code>eladder</code> calculates how the efficiency for a
firm changes when the most influential peer is removed sequentially one
at a time. For <code> eladder</code> the largest effect is the largest change
in efficiency and for <code> eladder2</code> the largest weight, lambda.
</p>
<p>Somewhere in the sequence the firm
becomes efficient and are itself removed from the set of firms
generating the technology (or the only firm left) and thereafter 
the efficiencies are super-efficiencies and the process stops.
</p>
<p>When it happens that there is no solution to the dea problem after
removing a series of peers then the program might stop before
<code>MAXELAD</code> peers have been removed.</p>


<h3>Value</h3>

<p>The object returned from <code>eladder</code> is a list with components
</p>
<table>
<tr><td><code>eff</code></td>
<td>
<p>The sequence of efficiencies when the peer with the largest
value of lambda has been removed.</p>
</td></tr>
<tr><td><code>peer</code></td>
<td>
<p>The sequence of removed peers corresponding to the largest
values of lambda as index in the <code>X</code> rows.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When the number of firms is large then the number of influential
peers will also be large and the names or numbers of the peers on
the x-axis might be squeeze together and be illegible. In this case
restrict the number of influential peers to be removed.
</p>
<p>The efficiency step ladder is discussed in Essay III of Dag Fjeld
Edvardsen's Ph.D. thesis from 2004.</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a> </p>


<h3>References</h3>

<p> Dag Fjeld Edvardsen; <em>Four Essays on the Measurement
of Productive Efficiency</em>; University of Gothenburg 2004;
<a href="http://hdl.handle.net/2077/2923">http://hdl.handle.net/2077/2923</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(charnes1981)
x &lt;- with(charnes1981, cbind(x1,x2,x3,x4,x5))
y &lt;- with(charnes1981, cbind(y1,y2,y3))

# Choose the firm for analysis, we choose 'Tacoma'
n &lt;- which(charnes1981$name=="Tacoma")[1]

el &lt;- eladder(n, x, y, RTS="crs")
eladder.plot(el$eff, el$peer)

# Restrict to 20 most influential peers for 'Tacoma' and use names
# instead of number
eladder.plot(el$eff[1:20], charnes1981$name[el$peer][1:20])

# Truncate the names of the peers and put a title on top
eladder.plot(el$eff[1:20], charnes1981$name[el$peer][1:20], TRIM=5)
title("Eladder for Tacoma")
</code></pre>

<hr>
<h2 id='excess'>
Excess input compared over frontier input
</h2><span id='topic+excess'></span>

<h3>Description</h3>

<p> Excess input compared over frontier input and/or less
output than frontier/transformation/optimal output.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>excess(object, X = NULL, Y = NULL)
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="excess_+3A_object">object</code></td>
<td>
<p> A Farrell object as returned from functions like
<a href="#topic+dea">dea</a>, <a href="#topic+dea.direct">dea.direct</a>, <a href="#topic+sdea">sdea</a>, and <a href="#topic+mea">mea</a>. </p>
</td></tr>
<tr><td><code id="excess_+3A_x">X</code></td>
<td>
<p> Input matrix, only necessary for ordinary input Farrell
efficiency </p>
</td></tr>
<tr><td><code id="excess_+3A_y">Y</code></td>
<td>
<p> Ouput matrix , only necessary for ordinary output Farrell
efficiency </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Farrell input efficiency E the exess input is <code class="reqn">(1-E) X</code> and
for Farrell ouput efficiency F the missing output is <code class="reqn">(F-1) Y</code>.
</p>
<p>Notice that the excess calculated does not include any slack values. In 
case slacks are present and calculated it might be more appropriate 
to add slack, i.e. to use <code>excess(object, X, Y) + slack(X, Y, object)</code>.
</p>
<p>For directional efficiency e in the direction D the excess input is
<code class="reqn">e D</code>.
</p>
<p>If a firm is outside the technology set, as could be the case when
calculating super-efficiencies, the Farrell input efficiency is
larger than 1, and then the excess values are negative.
</p>


<h3>Value</h3>

<p>Return a matrix with exces input and/or less output.
</p>


<h3>Author(s)</h3>

<p>Peter Bogeroft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a>
</p>


<h3>References</h3>

<p> Peter Bogetoft and Lars Otto; <em>Benchmarking with
DEA, SFA, and R</em>; Springer 2011 </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(100,200,300,500,100,200,600),ncol=1)
y &lt;- matrix(c(75,100,300,400,25,50,400),ncol=1)

e &lt;- dea(x,y)
excess(e,x)
x - eff(e) * x

e &lt;- dea(x,y, ORIENTATION="graph")
excess(e, x, y)
x - eff(e) * x
1/eff(e) * y -y

me &lt;- mea(x,y)
excess(me)
</code></pre>

<hr>
<h2 id='lambda'>Lambdas or the weight of the peers </h2><span id='topic+lambda'></span><span id='topic+lambda.print'></span>

<h3>Description</h3>

<p>The lambdas, i.e. the weight of the peers, for each firm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda(object, KEEPREF = FALSE)
lambda.print(x, KEEPREF = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_+3A_object">object</code>, <code id="lambda_+3A_x">x</code></td>
<td>
<p>A Farrell object as returned from <code><a href="#topic+dea">dea</a></code> et
al.</p>
</td></tr>
<tr><td><code id="lambda_+3A_keepref">KEEPREF</code></td>
<td>
<p>if <code>TRUE</code> then all firms are kept as reference
firms even though they have all zero weights (lambda); might
come handy if one needs to calculate <code>X</code> x <code>lambda</code>
such that the firms in <code>X</code> and <code>lambda</code> agree. If
<code>FALSE</code>, the default, then only weight for the peers are in
the matrix <code>lambda</code>. </p>
</td></tr>
<tr><td><code id="lambda_+3A_...">...</code></td>
<td>
<p>Optional parameters for the print method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Only returns the lambdas for firms that appear as a
peer, i.e. only lambdas for firms where at least one element of the
lambda is positive.  </p>


<h3>Value</h3>

<p> The return is a matrix with the firms as rows and the peers as
columns.  </p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+dea">dea</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

</code></pre>

<hr>
<h2 id='make.merge'> Make an aggregation matrix to perform mergers </h2><span id='topic+make.merge'></span>

<h3>Description</h3>

<p> Make an aggregation matrix to perform mergers of
firms. The matrix can be post multiplied (matrix multiplication) to
input and output matrices to make merged input and output matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.merge(grp, nFirm = NULL, X = NULL, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.merge_+3A_grp">grp</code></td>
<td>
<p> Either a list of length Kg for Kg firms after mergers;
each component of the list is a (named) list with the firm numbers or
names going into this merger.
</p>
<p>Or a factor of length K with Kg levels where each level
determines a merger; to exclude firms for mergers set the
factor value to NA. </p>
</td></tr>
<tr><td><code id="make.merge_+3A_nfirm">nFirm</code></td>
<td>
<p> Number of firms before the mergers </p>
</td></tr>
<tr><td><code id="make.merge_+3A_x">X</code></td>
<td>
<p>A matrix of inputs or outputs where the rows corresponds to
the number of original (starting) firms </p>
</td></tr>
<tr><td><code id="make.merge_+3A_names">names</code></td>
<td>
<p>A list with names of all firms, only needed if the
mergers are given as a list of names, i.e. <code>grp</code> is a list
of names.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Either <code>nFirm</code> or <code>X</code> must be present; if both are present
then <code>nFirm</code> must be equal to the number of rows in <code>X</code>, the
number of firms.
</p>
<p>When <code>X</code> is an input matrix of dimension <code>K x m</code>, <code>K</code>
firms and <code>m</code> inputs, and <code>M &lt;- make.merge(gr,K)</code> then
<code>M %*% X</code> is the input matrix for the merged firms.
</p>


<h3>Value</h3>

<p> Returns an aggregation matrix of dimension Kg times K where
rows corresponds to new merged firms and columns are 1 for firms to be
included and 0 for firms to be excluded in the given merger as
defined by the row. </p>


<h3>Note</h3>

<p> The argument <code>TRANSPOSE</code> has not been implemented for this
function. If you need transposed matrices you must transpose the
merger matrix yourself. If you define mergers via factors there is no
need to transpose in the arguments; just do not use <code>X</code> in the
arguments.  </p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+dea.merge">dea.merge</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># To merge firms 1,3, and 5; and 2 and 4 of 7 firms into 2 new firms
# the aggregation matrix is M; not all firms are involved in a merger.
M &lt;- make.merge(list(c(1,3,5), c(2,4)),7)
print(M)

# Merge 1 and 2, and 4 and 5, and leave 3 alone, total of 5 firms.
# Using a list
M1 &lt;- make.merge(list(c(1,2), c(4,5)), nFirm=5)
print(M1)

# Using a factor
fgr &lt;- factor(c("en","en",NA,"to","to"))
M2 &lt;- make.merge(fgr)
print(M2)

# Name of mergers
M3 &lt;- make.merge(list(AB=c("A","B"), DE=c("D","E")), names=LETTERS[1:5])
print(M3)

# No name of mergers
M4 &lt;- make.merge(list(c("A","B"), c("D","E")), names=LETTERS[1:5])
print(M4)
</code></pre>

<hr>
<h2 id='malmq'>Malmquist index</h2><span id='topic+malmq'></span>

<h3>Description</h3>

<p>Estimates Malmquist indices for productivity and its decomposition between two
periods. The units in the two periods does not have to be exactly the same, but
the Malmquist index is only calculated for units present in both periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>malmq(X0, Y0, ID0 = NULL, X1, Y1, ID1 = NULL, RTS = "vrs", ORIENTATION = "in", 
    SAMEREF=FALSE, SLACK = FALSE, DUAL = FALSE, DIRECT = NULL, param = NULL, 
    TRANSPOSE = FALSE, FAST = TRUE, LP = FALSE, CONTROL = NULL, LPK = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="malmq_+3A_x0">X0</code></td>
<td>
<p>Inputs of firms in period 0, a K0 x m matrix
of observations of K0 firms with m inputs (firm x input). </p>
</td></tr>
<tr><td><code id="malmq_+3A_y0">Y0</code></td>
<td>
<p>Outputs of firms in period 0, a K0 x n matrix
of observations of K0 firms with n outputs (firm x input). </p>
</td></tr>
<tr><td><code id="malmq_+3A_id0">ID0</code></td>
<td>
<p>Index for firms in period 0; could be numbers or labels. Length K0.</p>
</td></tr>
<tr><td><code id="malmq_+3A_x1">X1</code></td>
<td>
<p>Inputs of firms in period 1, a K1 x m matrix
of observations of K1 firms with m inputs (firm x input).</p>
</td></tr>
<tr><td><code id="malmq_+3A_y1">Y1</code></td>
<td>
<p>Outputs of firms in period 1, a K1 x n matrix
of observations of K1 firms with n outputs (firm x input). </p>
</td></tr>
<tr><td><code id="malmq_+3A_id1">ID1</code></td>
<td>
<p>Index for firms in period 0; could be numbers or labels. Length K0.</p>
</td></tr>
<tr><td><code id="malmq_+3A_rts">RTS</code></td>
<td>
<p>Returns to scale assumption as in <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmq_+3A_orientation">ORIENTATION</code></td>
<td>
<p>Input efficiency &quot;in&quot; (1), output
efficiency &quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3) as in <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmq_+3A_sameref">SAMEREF</code></td>
<td>
<p>Use the same units for reference technology when comparing 
two periods. This is not restricted to same units in several timpe periods, 
but only to pairwise periods comparisons for Malmquist.  Default is to use 
available and possible differnt units in pairwise periods.</p>
</td></tr>
<tr><td><code id="malmq_+3A_slack">SLACK</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmq_+3A_dual">DUAL</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmq_+3A_direct">DIRECT</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmq_+3A_param">param</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmq_+3A_transpose">TRANSPOSE</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmq_+3A_fast">FAST</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmq_+3A_lp">LP</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmq_+3A_control">CONTROL</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmq_+3A_lpk">LPK</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of the units in values is given by the returned value <code>id</code>. 
This is usefull if the order of units differ completely between <code>ID0</code> and <code>ID1</code>.
</p>
<p>The <em>index for technical changes</em> <code>tc</code> is calculated as <code>sqrt(e10/e11 * e00/e01)</code> 
where <code>e&lt;s&gt;&lt;t&gt;</code> is the efficiency for period <code>s</code> when the reference technology is
for period <code>t</code>, i.e. determined from the observations for period <code>t</code> and 
<code>XREF=X_t, YREF=Y_t</code>, as is the option for the function <code>dea</code>.
</p>
<p>The <em>Malmquist index for productivity</em> <code>mq</code> is calculates as <code>sqrt(e10/e00 * e11/e01)</code> and the 
<em>index for change in efficiency</em> <code>ec</code> is <code>e11/e00</code>.  Note that <code>mq = tc * ec</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>m</code></td>
<td>
<p>Malmquist index for productivity.</p>
</td></tr>
<tr><td><code>tc</code></td>
<td>
<p>Index for technology change.</p>
</td></tr>
<tr><td><code>ec</code></td>
<td>
<p>Index for efficiency change.</p>
</td></tr>
<tr><td><code>mq</code></td>
<td>
<p>Malmquist index for productivity; same as <code>m</code>.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>Index for firms present in both period 0 and period 1.</p>
</td></tr>
<tr><td><code>id0</code></td>
<td>
<p>Index for firms in period 0 that are also in period 1.</p>
</td></tr>
<tr><td><code>id1</code></td>
<td>
<p>Index for firms in period 1 that are also in period 0.</p>
</td></tr>
<tr><td><code>e00</code></td>
<td>
<p>The efficiencies for period 0 with reference technology from period 0.</p>
</td></tr>
<tr><td><code>e10</code></td>
<td>
<p>The efficiencies for period 1 with reference technology from period 0.</p>
</td></tr>
<tr><td><code>e11</code></td>
<td>
<p>The efficiencies for period 1 with reference technology from period 1.</p>
</td></tr>
<tr><td><code>e01</code></td>
<td>
<p>The efficiencies for period 0 with reference technology from period 1.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The calculations of efficiencies are only done for units present in both periods.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Peter Bogetoft and Lars Otto; <em>Benchmarking with
DEA, SFA, and R</em>; Springer 2011 </p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   x0 &lt;- matrix(c(10, 28, 30, 60),ncol=1)
   y0 &lt;- matrix(c(5, 7, 10, 15),ncol=1)
   x1 &lt;- matrix(c(12, 26, 16, 60 ),ncol=1)
   y1 &lt;- matrix(c(6, 8, 9, 15 ),ncol=1)

   dea.plot(x0, y0, RTS="vrs", txt=TRUE)
   dea.plot(x1, y1, RTS="vrs", add=TRUE, col="red")
   points(x1, y1, col="red", pch=16)
   text(x1, y1, 1:dim(x1)[1], col="red", adj=-1)

   m &lt;- malmq(x0,y0,,x1,y1,,RTS="vrs")
   print("Malmquist index for change in productivity, technology change:")
   print(m$mq)
   print("Index for change of frontier:")
   print(m$tc)
</code></pre>

<hr>
<h2 id='malmquist'>Malmquist index for firms in a panel</h2><span id='topic+malmquist'></span>

<h3>Description</h3>

<p>Estimate Malmquist index for firms in a panel data set. The data set does not
need to be balanced.</p>


<h3>Usage</h3>

<pre><code class='language-R'>malmquist(X, Y, ID, TIME, RTS = "vrs", ORIENTATION = "in", SAMEREF=FALSE, 
    SLACK = FALSE, DUAL = FALSE, DIRECT = NULL, param = NULL, 
    TRANSPOSE = FALSE, FAST = TRUE, LP = FALSE, CONTROL = NULL, LPK = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="malmquist_+3A_x">X</code></td>
<td>
<p>Inputs of firms in many periods, a (T*K) x m matrix
of observations of K firms with m outputs (firm x input) in at the most T periods.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_y">Y</code></td>
<td>
<p>Outputs of firms in many periods, a (T*K) x n matrix
of observations of K0 firms with n outputs (firm x input) in at the most T periods.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_id">ID</code></td>
<td>
<p>Identifier for the firms in rows of <code>X</code> and <code>Y</code>.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_time">TIME</code></td>
<td>
<p>Array with period number for each row in the input maxtrix <code>X</code> and output matrix<code>Y</code></p>
</td></tr>
<tr><td><code id="malmquist_+3A_rts">RTS</code></td>
<td>
<p>Returns to scale assumption as in <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_orientation">ORIENTATION</code></td>
<td>
<p>Input efficiency &quot;in&quot; (1), output
efficiency &quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3) as in <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_sameref">SAMEREF</code></td>
<td>
<p>Use the same units for reference technology when comparing 
two periods. This is not restricted to same units in several timpe periods, 
but only to pairwise periods comparisons for Malmquist. Default is to use 
available and possible differnt units in pairwise periods.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_slack">SLACK</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_dual">DUAL</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_direct">DIRECT</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_param">param</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_transpose">TRANSPOSE</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_fast">FAST</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_lp">LP</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_control">CONTROL</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
<tr><td><code id="malmquist_+3A_lpk">LPK</code></td>
<td>
<p>See <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Malmquist</code> uses <code><a href="#topic+malmq">malmq</a></code> for the calculations of the 
necessary efficiencies, and the returned indices are as in <code><a href="#topic+malmq">malmq</a></code>.
The data must be a long data set with regards to <code>TIME</code> and <code>ID</code>; se the example below.
</p>
<p>Note that the calculated index are index comparing a period and the previous period. To compare the 
development over time the indices must be turned into a chain index as shown in the example below.
</p>


<h3>Value</h3>

<table>
<tr><td><code>m</code></td>
<td>
<p>Malmquist indicies, an array of length T*K in the order of <code>ID</code> and <code>TIME</code>, 
i.e. the order of the rows of <code>X</code>.</p>
</td></tr>
<tr><td><code>tc</code></td>
<td>
<p>Technical change indices, an array of length T*K.</p>
</td></tr>
<tr><td><code>ec</code></td>
<td>
<p>Efficiency indices, an array of length T*K.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>Index for firms as <code>ID</code></p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Index for time as <code>TIME</code></p>
</td></tr>
<tr><td><code>e00</code></td>
<td>
<p>The efficiencies for period 0 with reference technology from period 0.</p>
</td></tr>
<tr><td><code>e10</code></td>
<td>
<p>The efficiencies for period 1 with reference technology from period 0.</p>
</td></tr>
<tr><td><code>e11</code></td>
<td>
<p>The efficiencies for period 1 with reference technology from period 1.</p>
</td></tr>
<tr><td><code>e01</code></td>
<td>
<p>The efficiencies for period 0 with reference technology from period 1.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The lagged values <code>e11</code> are not necessary equal to values of <code>e00</code>
as the reference technology for the two periods could be generated by
different units, if the units in different time periods are not the same.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Peter Bogetoft and Lars Otto; <em>Benchmarking with
DEA, SFA, and R</em>; Springer 2011 </p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code>, <code><a href="#topic+malmq">malmq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> x0 &lt;- matrix(c(10, 28, 30, 60),ncol=1)
 y0 &lt;- matrix(c(5, 7, 10, 15),ncol=1)
 x1 &lt;- matrix(c(12, 26, 16, 60 ),ncol=1)
 y1 &lt;- matrix(c(6, 8, 9, 15 ),ncol=1)
 x2 &lt;- matrix(c(13, 26, 15, 60 ),ncol=1)
 y2 &lt;- matrix(c(7, 9, 10, 15 ),ncol=1)
 
 dea.plot(x0, y0, RTS="vrs", txt=TRUE)
 dea.plot(x1, y1, RTS="vrs", add=TRUE, col="red")
 dea.plot(x2, y2, RTS="vrs", add=TRUE, col="blue")
 points(x1, y1, col="red", pch=16)
 # points(x2, y2, col="blue", pch=17)
 text(x1, y1, 1:dim(x1)[1], col="red", adj=-1)
 text(x2, y2, 1:dim(x1)[1], col="blue", adj=-1)
 legend("bottomright", legend=c("Period 0", "Period 1", "Period 2"),
    col=c("black", "red", "blue"), lty=1, pch=c(1,16, 17),  bty="n")
 
 X &lt;- rbind(x0, x1, x2)
 Y &lt;- rbind(y0, y1, y2)
 # Make ID and TIME variables one way or another
 ID &lt;- rep(1:dim(x1)[1], 3)
 # TIME &lt;- c(rep(0,dim(x1)[1]), rep(1,dim(x1)[1]), rep(2,dim(x1)[1]))
 TIME &lt;- gl(3, dim(x1)[1], labels=0:2)
 # This is how the data for Malmquist must look like
 data.frame(TIME, ID, X, Y)
 mq &lt;- malmquist(X,Y, ID, TIME=TIME) 
 data.frame(TIME, ID, X, Y, mq$e00, mq$e01, mq$e10, mq$e11, mq$m, mq$tc)[order(ID, TIME),]
 
 # How to make the Malmquist indices to a chain index
 # Make data.frame with indices
 DM &lt;- data.frame(TIME, ID, m=mq$m, tc=mq$tc, ec=mq$ec)
 # Set missing index for first period to 1, the base
 DM[DM$TIME==0, c("m","tc", "ec")] &lt;- 1
 # Make chain index of the individual indices
 AD &lt;- aggregate(cbind(m=DM$m), by=list(ID=DM$ID), cumprod)
 # Compare chain index to original index
 data.frame(ID, TIME, m=c(AD$m), DM$m)
 
</code></pre>

<hr>
<h2 id='mea'> MEA multi-directional efficiency analysis </h2><span id='topic+mea'></span><span id='topic+mea.lines'></span>

<h3>Description</h3>

<p> Potential improvements PI or multi-directional
efficiency analysis.  The result is an excess value measures by the
direction.
</p>
<p>The direction is determined by the direction corresponding to the
minimum input/maximum direction each good can be changed when they are
changed one at a time.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>mea(X, Y, RTS = "vrs", ORIENTATION = "in", XREF = NULL, YREF = NULL, 
    FRONT.IDX = NULL, param=NULL, TRANSPOSE = FALSE, 
    LP = FALSE, CONTROL = NULL, LPK = NULL)
mea.lines(N, X, Y, ORIENTATION="in")  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mea_+3A_x">X</code></td>
<td>
<p> K times m matrix with K firms and m inputs as in <code>dea</code> </p>
</td></tr>
<tr><td><code id="mea_+3A_y">Y</code></td>
<td>
<p> K times n matrix with K firms and n outputs as in <code>dea</code> </p>
</td></tr>
<tr><td><code id="mea_+3A_rts">RTS</code></td>
<td>
<p> Text string or a number defining the underlying DEA
technology / returns to scale assumption.
</p>

<table>
<tr>
 <td style="text-align: right;">
0 </td><td style="text-align: left;"> fdh </td><td style="text-align: left;"> Free disposability hull, no convexity assumption </td>
</tr>
<tr>
 <td style="text-align: right;">
1 </td><td style="text-align: left;"> vrs </td><td style="text-align: left;"> Variable returns to scale, convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
2 </td><td style="text-align: left;"> drs </td><td style="text-align: left;"> Decreasing returns to scale, convexity, down-scaling and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
3 </td><td style="text-align: left;"> crs </td><td style="text-align: left;"> Constant returns to scale, convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
4 </td><td style="text-align: left;"> irs </td><td style="text-align: left;"> Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
6 </td><td style="text-align: left;"> add </td><td style="text-align: left;"> Additivity (scaling up and down, but only with integers), and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">
7 </td><td style="text-align: left;"> fdh+ </td><td style="text-align: left;"> A combination of free disposability and restricted
 or local constant return to scale
</td>
</tr>

</table>

</td></tr>
<tr><td><code id="mea_+3A_orientation">ORIENTATION</code></td>
<td>
<p>Input efficiency &quot;in&quot; (1) or output efficiency
&quot;out&quot; (2), and also the additional option &quot;in-out&quot; (0) for 
both input and output direction. 
</p>
</td></tr>
<tr><td><code id="mea_+3A_xref">XREF</code></td>
<td>
<p>Inputs of the firms determining the technology, defaults
to <code>X</code></p>
</td></tr>
<tr><td><code id="mea_+3A_yref">YREF</code></td>
<td>
<p>Outputs of the firms determining the technology,
defaults to <code>Y</code></p>
</td></tr>
<tr><td><code id="mea_+3A_front.idx">FRONT.IDX</code></td>
<td>
<p>Index for firms determining the technology</p>
</td></tr>
<tr><td><code id="mea_+3A_param">param</code></td>
<td>
<p>Possible parameters. At the moment only used for
RTS=&quot;fdh+&quot; to set low and high values for restrictions on lambda;
see the section details and examples in <code><a href="#topic+dea">dea</a></code> for its
use. Future versions might also use <code>param</code> for other
purposes.</p>
</td></tr>
<tr><td><code id="mea_+3A_transpose">TRANSPOSE</code></td>
<td>
<p> as in <code>dea</code> </p>
</td></tr>
<tr><td><code id="mea_+3A_lp">LP</code></td>
<td>
<p> as in <code>dea</code> </p>
</td></tr>
<tr><td><code id="mea_+3A_control">CONTROL</code></td>
<td>
<p> as in <code>dea</code> </p>
</td></tr>
<tr><td><code id="mea_+3A_lpk">LPK</code></td>
<td>
<p> as in <code>dea</code> </p>
</td></tr>
<tr><td><code id="mea_+3A_n">N</code></td>
<td>
<p>Number of firms where directional lines are to be drawn on
an already existing frontier plot (<a href="#topic+dea.plot.frontier">dea.plot.frontier</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Details can be found in Bogetoft and Otto (2011, 121&ndash;124).
</p>
<p>This method is for input directional efficiency only interesting when
there are 2 or more inputs, and for output only when there are 2 or
more outputs.  </p>


<h3>Value</h3>

<p> The results are returned in a Farrell object with the
following components.
</p>
<table>
<tr><td><code>eff</code></td>
<td>
<p>Excess value in DIRECT units of measurement, this is
<em>not</em> Farrell efficiency </p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The lambdas, i.e. the weight of the peers, for each firm</p>
</td></tr>
<tr><td><code>objval</code></td>
<td>
<p>The objective value as returned from the LP program,
normally the same as eff</p>
</td></tr>
<tr><td><code>RTS</code></td>
<td>
<p>The return to scale assumption as in the option <code>RTS</code>
in the call</p>
</td></tr>
<tr><td><code>ORIENTATION</code></td>
<td>
<p>The efficiency orientation as in the call</p>
</td></tr>
<tr><td><code>direct</code></td>
<td>
<p> A K times m|n|m+n matrix with directions for each firm:
the number of columns depends on whether it is input, output or
in-out orientated.</p>
</td></tr>
<tr><td><code>TRANSPOSE</code></td>
<td>
<p>As in the call</p>
</td></tr>
</table>


<h3>Note</h3>

<p> The calculation is done in <code><a href="#topic+dea">dea</a></code> after a
calculation of the direction that then is used in the argument
<code>DIRECT</code>.  The calculation of the direction is done in a series
LP programs, one for each good in the direction. </p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a> </p>


<h3>References</h3>

<p> Peter Bogetoft and Lars Otto; <em>Benchmarking with
DEA, SFA, and R</em>; Springer 2011 </p>


<h3>See Also</h3>

 <p><code><a href="#topic+dea">dea</a></code> and the argument <code>DIRECT</code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(c(2, 2, 5, 10, 10, 3,    12, 8, 5, 4, 6,12), ncol=2)
Y &lt;- matrix(rep(1,dim(X)[1]), ncol=1)

dea.plot.isoquant(X[,1], X[,2],txt=1:dim(X)[1])
mea.lines(c(5,6),X,Y)

me &lt;- mea(X,Y)
me
peers(me)
# MEA potential saving in inputs, exces inputs
eff(me) * me$direct
me$eff *  me$direct

# Compare to traditionally Farrell efficiency
e &lt;- dea(X,Y)
e
peers(e)
# Farrell potential saving in inputs, excess inputs
(1-eff(e)) * X
</code></pre>

<hr>
<h2 id='milkProd'> Data: Milk producers </h2><span id='topic+milkProd'></span>

<h3>Description</h3>

<p>Data colected from Danish  milk producers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(milkProd)</code></pre>


<h3>Format</h3>

<p>A data frame with 108 observations on the following 5 variables.
</p>

<dl>
<dt><code>farmNo</code></dt><dd><p>farm number</p>
</dd>
<dt><code>milk</code></dt><dd><p>Output of milk, kg</p>
</dd>
<dt><code>energy</code></dt><dd><p>Energy expenses</p>
</dd>
<dt><code>vet</code></dt><dd><p>Veterinary expenses</p>
</dd>
<dt><code>cows</code></dt><dd><p>Number of cows</p>
</dd>
</dl>



<h3>Note</h3>

<p> Data as <code>.csv</code> are loaded by the command <code>data</code> using
<code> read.table(..., header = TRUE, sep = ";")</code> such that this file
is a semicolon separated file and not a comma separated file.  </p>


<h3>Source</h3>

<p>Accounting and business check data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milkProd)
y &lt;- with(milkProd, cbind(milk))
x &lt;- with(milkProd, cbind(energy, vet, cows))
</code></pre>

<hr>
<h2 id='norWood2004'>
Data: Forestry in Norway
</h2><span id='topic+norWood2004'></span>

<h3>Description</h3>

<p>A data set for 113 farmers in forestry in Norway.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(norWood2004)</code></pre>


<h3>Format</h3>

<p>A data frame with 113 observations on the following 7 variables.
</p>

<dl>
<dt><code>firm</code></dt><dd><p>firm number</p>
</dd>
<dt><code>m</code></dt><dd><p>Variable cost</p>
</dd>
<dt><code>x</code></dt><dd><p>Woodland, value of forest and land</p>
</dd>
<dt><code>y</code></dt><dd><p>Profit</p>
</dd>
<dt><code>z1</code></dt><dd><p>Secondary income from ordinary farming</p>
</dd>
<dt><code>z3</code></dt><dd><p>Age of forest owner</p>
</dd>
<dt><code>z6</code></dt><dd><p>Whether there is a long-term plan =1 or not =0</p>
</dd>
</dl>



<h3>Details</h3>

<p>Collected from farmers in forestry.
</p>


<h3>Note</h3>

<p> Data as <code>.csv</code> are loaded by the command <code>data</code> using
<code> read.table(..., header=TRUE, sep=";")</code> such that this file
is a semicolon separated file and not a comma separated file.  </p>


<h3>Source</h3>

<p>Norwegian Agricultural Economics Research Institute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(norWood2004)
## maybe str(norWood2004) ; plot(norWood2004) ...
</code></pre>

<hr>
<h2 id='outlier.ap'>
Detection of outliers in benchmark models
</h2><span id='topic+outlier.ap'></span><span id='topic+outlier.ap.plot'></span><span id='topic+outlierC.ap'></span>

<h3>Description</h3>

<p> The functions implements the Wilson (1993) outlier
detection method. One written entirely in R and another written in C++.</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlier.ap (X, Y, NDEL = 3, NLEN = 25, TRANSPOSE = FALSE)
outlierC.ap(X, Y, NDEL = 3, NLEN = 25, TRANSPOSE = FALSE)

outlier.ap.plot(ratio, NLEN = 25, xlab = "Number of firms deleted", 
                ylab = "Log ratio", ..., ylim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outlier.ap_+3A_x">X</code></td>
<td>
<p> Input as a firms times goods matrix, see <code>TRANSPOSE</code>.
</p>
</td></tr>
<tr><td><code id="outlier.ap_+3A_y">Y</code></td>
<td>
<p> Output as a firms times goods matrix, see
<code>TRANSPOSE</code>.  </p>
</td></tr>
<tr><td><code id="outlier.ap_+3A_ndel">NDEL</code></td>
<td>
<p> The maximum number of firms to be considered as a group
of outliers, i.e. the maximum number of firms to be deleted.  </p>
</td></tr>
<tr><td><code id="outlier.ap_+3A_nlen">NLEN</code></td>
<td>
<p> The number of ratios to save for each level
or removal, the number of rows in <code>ratio</code> used.  </p>
</td></tr>
<tr><td><code id="outlier.ap_+3A_transpose">TRANSPOSE</code></td>
<td>
<p>Input and output matrices are treated as firms
times goods matrices for the default value <code>TRANSPOSE=FALSE</code>
corresponding to the standard in R for statistical models.  When
<code>TRUE</code> data matrices are transposed to good times firms
matrices as is normally used in LP formulation of the problem.</p>
</td></tr>
<tr><td><code id="outlier.ap_+3A_ratio">ratio</code></td>
<td>
<p> The <code>ratio</code> component from the list as output
from <code>outlier.ap</code>.</p>
</td></tr> 
<tr><td><code id="outlier.ap_+3A_xlab">xlab</code></td>
<td>
<p> Label for the x-axis.  </p>
</td></tr>
<tr><td><code id="outlier.ap_+3A_ylab">ylab</code></td>
<td>
<p> Label for the y-axis </p>
</td></tr>
<tr><td><code id="outlier.ap_+3A_ylim">ylim</code></td>
<td>
<p> The y limits <code>(y1, y2)</code> of the plot, an
array/vector of length 2.  </p>
</td></tr>
<tr><td><code id="outlier.ap_+3A_...">...</code></td>
<td>
<p>Usual options for the methods <code>plot</code> and
<code>lines</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>An implementation of the method in Wilson (1993) using only R
functions and especially the function <code>det</code> to calculate
<code class="reqn">R^{(i)}_{\min}</code>. The alternative method <code>outlierC.ap</code> 
is written completely in C++ and is much faster, but still not
as fast at the method in <span class="pkg">FEAR</span>.
</p>
<p>An elementary presentation of the method is found in Bogetoft and Otto
(2011), Sect. 5.13 on outliers.
</p>
<p>For a data set with 10 firms and considering at the most 3 outliers there are
175 combinations of firms to delete. For 100 firms there are 166,750
combinations and for at most 5 outliers there are 79,375,495 combinatins, for
at most 8 outliers there are  203,366,882,995 combinations. For 200 firms whith
respectively 3,5 and 8 outliers there are  1,333,500, and 2,601,668,490, and 
a number we do not know what to call
57,467,902,686,615 combinations. Thus the number of combinations are increasing
exponentialy in both number of firms and number of firms to be deleted and so
is the computational time. Thus you should limit the numbers <code>NDEL</code> to a
very small number like at the most 3 or perhabs 5 depending of the number
of firms. Or you should use the extremely fast method <code>ap</code> from the
package <span class="pkg">FEAR</span> mentioned in the references.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ratio</code></td>
<td>
<p>A <code>min(NLEN,K) x NDEL</code> matrix with the log-ratios to
be plotted.</p>
</td></tr>
<tr><td><code>imat</code></td>
<td>
<p>A <code>NDEL x NDEL</code> matrix with indicies for deleted firms.</p>
</td></tr>
<tr><td><code>r0</code></td>
<td>
<p>A <code>NDEL</code> array with the minimum value <code class="reqn">R^{i}</code> of
the for each number of deleted firms. </p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>The function <code>outlier.ap</code> is extremely slow and for <code>NDEL</code>
larger than 3 or 4 it might be advisable to use the function <code>ap</code>
from the package <span class="pkg">FEAR</span>.
</p>
<p>The name of the returned components are the same as for <code>ap</code> in
the package <span class="pkg">FEAR</span>.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Bogetoft and Otto; <em>Benchmarking with DEA, SFA, and
R</em>; Springer 2011
</p>
<p>Wilson (1993), &ldquo;Detecing outliers in deterministic
nonparametric frontier models with multiple outputs,&rdquo; <em>Journal of
Business and Economic Statistics</em> 11, 319-323.
</p>
<p>Wilson (2008), &ldquo;FEAR 1.0: A Software Package for Frontier
Efficiency Analysis with R,&rdquo; <em>Socio-Economic Planning Sciences</em>
42, 247&ndash;254
</p>


<h3>See Also</h3>

<p>The function <code>ap</code> in the package <span class="pkg">FEAR</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 25
x &lt;- matrix(rnorm(n))
y &lt;- .5 + 2.5*x + 2*rnorm(25)
tap &lt;- outlier.ap(x,y, NDEL=2)
print(cbind(tap$imat,tap$rmin), na.print="", digit=2)
outlier.ap.plot(tap$ratio)
</code></pre>

<hr>
<h2 id='peers'>
Find peer firms and units
</h2><span id='topic+peers'></span><span id='topic+get.number.peers'></span><span id='topic+get.which.peers'></span><span id='topic+get.peers.lambda'></span>

<h3>Description</h3>

<p> The function <code>peers</code> finds for each firm its peers,
<code>get.number.peers</code> finds for each peer the number of times
this peer apears as a peer, and <code>get.which.peers</code> determines
for one or more peers the firms they appear as peers for.   Also
include a function <code>get.peers.lambda</code> to calculate for firms the 
importance (lambdas) of peers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  peers(object, NAMES = FALSE, N=1:dim(object$lambda)[1], LAMBDA=0)
  get.number.peers(object, NAMES = FALSE, N=1:dim(object$lambda)[2], LAMBDA=0)
  get.which.peers(object, N = 1:dim(object$lambda)[2], LAMBDA=0)
  get.peers.lambda(object,  N=1:dim(object$lambda)[1], LAMBDA=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peers_+3A_object">object</code></td>
<td>
<p>An object of class Farrell as returned by the functions
<code><a href="#topic+dea">dea</a></code>, <code><a href="#topic+dea.direct">dea.direct</a></code> et al.</p>
</td></tr>
<tr><td><code id="peers_+3A_names">NAMES</code></td>
<td>
<p>If true then names for the peers are returned if names
are available otherwise the unit index numbers are used. If <code>NAMES</code>
is a list of names with length equal to the number of units then it is 
used as names for peers. </p>
</td></tr>
<tr><td><code id="peers_+3A_n">N</code></td>
<td>
<p>The firm(s) or peer(s) for which to get the results.</p>
</td></tr>
<tr><td><code id="peers_+3A_lambda">LAMBDA</code></td>
<td>
<p>Minimum weight for extracted peers, i.e. the extracted peers have 
lambda values larger than <code>LAMBDA</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p> The returned values are index of the firms and can be used
by itself, but can also by used as an index for a variable with
names of the firms. 
</p>
<p>The <code>peers</code> returns a matrix with numbers for the peers for
each firm; for firms with efficiency 1 the peers are just the firm
itself.  If there is slack in the evaluation of a firm with
efficiency 1, this can be found with a call to <code><a href="#topic+slack">slack</a></code>,
either directly or by the argument <code>SLACK</code> when a function
<code><a href="#topic+dea">dea</a></code> was called to generate the Farrell <code>object</code>. 
</p>
<p>The <code>get.number.peers</code> returns the number of firms that a peer
serves as a peer for.
</p>
<p>The <code>get.peers.lambda</code> returns a list of firms with the peers 
and corresponding value of lambda.
</p>


<h3>Value</h3>

<p> The return values are firm numbers. If the argument
<code>NAMES=TRUE</code> is used in the function <code>peers</code> the return
is a list of names of the peers if names for the firms are available
as row names.</p>


<h3>Note</h3>

<p> Peers are defined as firms where the corresponding lambdas are
positive.
</p>
<p>Note that peers might change between a Farrell object return from
<code>dea</code> with <code>SLACK=FALSE</code> and a call with <code>SLACK=TRUE</code>
or a following call to the function <code>slack</code> because a peer on
the frontier with slack might by the call to <code>dea</code> be a
peer for itself whereas this will not happen when slacks are
calculated.  </p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a> </p>


<h3>References</h3>

<p> Peter Bogetoft and Lars Otto; <em>Benchmarking with
DEA, SFA, and R</em>; Springer 2011. Sect. 4.6 page 93 </p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(100,200,300,500,100,200,600),ncol=1)
y &lt;- matrix(c(75,100,300,400,25,50,400),ncol=1)

e &lt;- dea(x,y)
peers(e)
get.number.peers(e)

# Who are the firms that firm 1 and 4 is peers for
get.which.peers(e, c(1,4))
</code></pre>

<hr>
<h2 id='pigdata'> Data: Multi-output pig producers </h2><span id='topic+pigdata'></span>

<h3>Description</h3>

<p> Input and output data for 248 pig producers that
also produces crop, i.e. a multi&ndash;output data set.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pigdata)</code></pre>


<h3>Format</h3>

<p>A data frame with 248 observations on the following 16 variables.
</p>

<dl>
<dt><code>firm</code></dt><dd><p>Serial number for pig producer</p>
</dd>
<dt><code>x1</code></dt><dd><p>Input fertilizer</p>
</dd>
<dt><code>x2</code></dt><dd><p>Input feedstuf</p>
</dd>
<dt><code>x3</code></dt><dd><p>Input land</p>
</dd>
<dt><code>x4</code></dt><dd><p>Input labour</p>
</dd>
<dt><code>x5</code></dt><dd><p>Input machinery</p>
</dd>
<dt><code>x6</code></dt><dd><p>Input other capital</p>
</dd>
<dt><code>y2</code></dt><dd><p>Output crop</p>
</dd>
<dt><code>y4</code></dt><dd><p>Output pig</p>
</dd>
<dt><code>w1</code></dt><dd><p>Price of fertilizer</p>
</dd>
<dt><code>w2</code></dt><dd><p>Price of feedstuf</p>
</dd>
<dt><code>w3</code></dt><dd><p>Price of land</p>
</dd>
<dt><code>w4</code></dt><dd><p>Price of labour</p>
</dd>
<dt><code>w5</code></dt><dd><p>Price of michenery</p>
</dd>
<dt><code>w6</code></dt><dd><p>Price of other capital</p>
</dd>
<dt><code>p2</code></dt><dd><p>Price of crop</p>
</dd>
<dt><code>p4</code></dt><dd><p>Price of pig</p>
</dd>
<dt><code>cost</code></dt><dd><p>Total cost, w1*x1+...+w6*x6.</p>
</dd>
<dt><code>rev</code></dt><dd><p>Total revenue, p2*y2+p4*y4.</p>
</dd>
</dl>



<h3>Details</h3>

<p> In raising pigs, most farmers also produce crops to feed the
pigs. Labor and capital are used not just directly for pig-raising but
also on the field.  </p>


<h3>Note</h3>

<p> Data as <code>.csv</code> are loaded by the command <code>data</code> using
<code> read.table(..., header = TRUE, sep = ";")</code> as the file
is a semicolon separated file and not a comma separated file.  </p>


<h3>Source</h3>

<p> Farmers accounting data converted to index. </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pigdata)
## maybe str(pigdata) ; plot(pigdata) ...
</code></pre>

<hr>
<h2 id='projekt'>
Data:  Milk producers
</h2><span id='topic+projekt'></span>

<h3>Description</h3>

<p>Accounting and production data for 101 milk producing farmers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(projekt)</code></pre>


<h3>Format</h3>

<p>A data frame with 101 observations on the following 14 variables.
</p>

<dl>
<dt><code>numb</code></dt><dd><p>Serial number for the milk producer</p>
</dd>
<dt><code>cows</code></dt><dd><p>Number of cows</p>
</dd>
<dt><code>vet</code></dt><dd><p>Veterinary expenses</p>
</dd>
<dt><code>unitCost</code></dt><dd><p>Unit cost, variable cost</p>
</dd>
<dt><code>capCost</code></dt><dd><p>Capacity cost</p>
</dd>
<dt><code>fixedCost</code></dt><dd><p>Fixed cost</p>
</dd>
<dt><code>milkPerCow</code></dt><dd><p>Milk per cow, kg</p>
</dd>
<dt><code>quota</code></dt><dd><p>Milk quota</p>
</dd>
<dt><code>fatPct</code></dt><dd><p>Fat percent in milk</p>
</dd>
<dt><code>protPct</code></dt><dd><p>Protein percent in milk</p>
</dd>
<dt><code>cellCount</code></dt><dd><p>Cell count for milk</p>
</dd>
<dt><code>race</code></dt><dd><p>Race for cows, a factor with levels <code>jersey</code>, 
<code>large</code>, and <code>mixed</code></p>
</dd>
<dt><code>type</code></dt><dd><p>Type of production, conventional or organic, 
a factor with levels <code>conv</code> <code>orga</code></p>
</dd>
<dt><code>age</code></dt><dd><p>Age of the farmer</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data is a mix of accounting data and production controls.
</p>


<h3>Note</h3>

<p> Data as <code>.csv</code> are loaded by the command <code>data</code> using
<code> read.table(..., header = TRUE, sep = ";")</code> such that this file
is a semicolon separated file and not a comma separated file.  </p>


<h3>Source</h3>

<p>Collected from farmers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(projekt)
## maybe str(projekt) ; plot(projekt) ...
</code></pre>

<hr>
<h2 id='sdea'> Super efficiency </h2><span id='topic+sdea'></span>

<h3>Description</h3>

<p> The method <code>sdea</code> calculates super-efficiency and
returns the same class of object as <code><a href="#topic+dea">dea</a></code>.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>sdea(X, Y, RTS = "vrs", ORIENTATION = "in", DIRECT = NULL, param = NULL,
     TRANSPOSE = FALSE, LP = FALSE, CONTROL = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdea_+3A_x">X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix
of observations of K firms with m inputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the input matrix is transposed to input x
firm. </p>
</td></tr>
<tr><td><code id="sdea_+3A_y">Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix
of observations of K firms with n outputs (firm x input).  In case
<code>TRANSPOSE=TRUE</code> the output matrix is transposed to output x
firm. </p>
</td></tr>
<tr><td><code id="sdea_+3A_rts">RTS</code></td>
<td>
<p> Text string or a number defining the underlying DEA
technology / returns to scale assumption, the same values as for
<code><a href="#topic+dea">dea</a></code>.
</p>

<table>
<tr>
 <td style="text-align: right;">

0 </td><td style="text-align: left;"> fdh </td><td style="text-align: left;"> Free disposability hull, no convexity assumption </td>
</tr>
<tr>
 <td style="text-align: right;">

1 </td><td style="text-align: left;"> vrs </td><td style="text-align: left;"> Variable returns to scale, convexity and free
disposability </td>
</tr>
<tr>
 <td style="text-align: right;">

2 </td><td style="text-align: left;"> drs </td><td style="text-align: left;"> Decreasing returns to scale, convexity, down-scaling
and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">

3 </td><td style="text-align: left;"> crs </td><td style="text-align: left;"> Constant returns to scale, convexity and free
disposability </td>
</tr>
<tr>
 <td style="text-align: right;">

4 </td><td style="text-align: left;"> irs </td><td style="text-align: left;"> Increasing returns to scale, (up-scaling, but not
down-scaling), convexity and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">

5 </td><td style="text-align: left;"> irs2 </td><td style="text-align: left;"> Increasing returns to scale (up-scaling, but not
down-scaling), additivity, and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">

6 </td><td style="text-align: left;"> add </td><td style="text-align: left;"> Additivity (scaling up and down, but only with
integers), and free disposability </td>
</tr>
<tr>
 <td style="text-align: right;">

7 </td><td style="text-align: left;"> fdh+ </td><td style="text-align: left;"> A combination of free disposability and restricted
 or local constant return to scale

</td>
</tr>

</table>

</td></tr>
<tr><td><code id="sdea_+3A_orientation">ORIENTATION</code></td>
<td>
<p>Input efficiency &quot;in&quot; (1), output efficiency
&quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3). For use with
<code>DIRECT</code>, an additional option is &quot;in-out&quot; (0).</p>
</td></tr>
<tr><td><code id="sdea_+3A_direct">DIRECT</code></td>
<td>
<p>Directional efficiency, <code>DIRECT</code> is either a
scalar, an array, or a matrix with non-negative elements.
</p>
<p>If the argument is a scalar, the direction is (1,1,...,1) times
the scalar; the value of the efficiency depends on the scalar as
well as on the unit of measurements.
</p>
<p>If the argument an array, this is used for the direction for
every firm; the length of the array must correspond to the
number of inputs and/or outputs depending on the
<code>ORIENTATION</code>.
</p>
<p>If the argument is a matrix then different directions are used
for each firm. The dimensions depends on the <code>ORIENTATION</code>,
the number of firms must correspond to the number of firms in
<code>X</code> and <code>Y</code>.
</p>
<p><code>DIRECT</code> must not be used in connection with
<code>DIRECTION="graph"</code>.
</p>
</td></tr>
<tr><td><code id="sdea_+3A_param">param</code></td>
<td>
<p>Argument is at present only used when
<code>RTS="fdh+"</code>, see <code><a href="#topic+dea">dea</a></code> for a description.</p>
</td></tr>
<tr><td><code id="sdea_+3A_transpose">TRANSPOSE</code></td>
<td>
<p>See the description in <code><a href="#topic+dea">dea</a></code>. </p>
</td></tr>
<tr><td><code id="sdea_+3A_lp">LP</code></td>
<td>
<p>Only for debugging, see the description in
<code><a href="#topic+dea">dea</a></code>. </p>
</td></tr>
<tr><td><code id="sdea_+3A_control">CONTROL</code></td>
<td>
<p>Possible controls to <span class="pkg">lpSolveAPI</span>, see the
documentation for that package. For examples of use see the
function <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Super-efficiency measures are constructed by avoiding that
the evaluated firm can help span the technology, i.e. if the firm in
qestuen is a firm on the frontier in a normal dea approach then
this firm in super efficiency might be outside the technology set.
</p>


<h3>Value</h3>

<p> The object returned is a Farrell object with the component
described in <code><a href="#topic+dea">dea</a></code>.  The relevant components are
</p>
<table>
<tr><td><code>eff</code></td>
<td>
<p>The efficiencies.  Note when DIRECT is used then the
efficencies are not Farrell efficiencies but rather excess values
in DIRECT units of measurement. </p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The lambdas, i.e. the weight of the peers, for each
Firm.</p>
</td></tr>
<tr><td><code>objval</code></td>
<td>
<p>The objective value as returned from the LP program;
normally the same as eff. </p>
</td></tr>
<tr><td><code>RTS</code></td>
<td>
<p>The return to scale assumption as in the option
<code>RTS</code> in the call.</p>
</td></tr>
<tr><td><code>ORIENTATION</code></td>
<td>
<p>The efficiency orientation as in the call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p> Calculation of slacks for super efficiency should be done by
using the option <code>SLACK=TRUE</code> in the call of the method
<code>sdea</code>.  If the two phases are done in two steps as first a
call to <code>sdea</code> and then a call to <code>slacks</code> the user must
make sure to set the reference technology to the one corresponding
to super-efficiency in the call to <code>slack</code> and this requires a
loop with calls to <code>slack</code>.  </p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Peter Bogetoft and Lars Otto; <em>Benchmarking with
DEA, SFA, and R</em>; Springer 2011. Sect. 5.2 page 115
</p>
<p>P Andersen and NC Petersen; &ldquo;A procedure for ranking efficient
units in data envelopment analysis&rdquo;;  <em>Management Science</em> 1993
39(10):1261&ndash;1264</p>


<h3>See Also</h3>

<p><code><a href="#topic+dea">dea</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(100,200,300,500,100,200,600),ncol=1)
y &lt;- matrix(c(75,100,300,400,25,50,400),ncol=1)
se &lt;- sdea(x,y)
se

# Leave out firm 3 as a determining firm of the technology set
n &lt;- 3
dea.plot.frontier(x[-n], y[-n], txt=(1:dim(x)[1])[-n])
# Plot and label firm 3
points(x[n],y[n],cex=1.25,pch=16)
text(x[n],y[n],n,adj=c(-.75,.75))
</code></pre>

<hr>
<h2 id='sfa'>Stochastic frontier estimation</h2><span id='topic+sfa'></span><span id='topic+sfa.cost'></span><span id='topic+lambda.sfa'></span><span id='topic+logLik.sfa'></span><span id='topic+print.sfa'></span><span id='topic+residuals.sfa'></span><span id='topic+sigma2.sfa'></span><span id='topic+sigma2u.sfa'></span><span id='topic+sigma2v.sfa'></span><span id='topic+summary.sfa'></span><span id='topic+coef.sfa'></span><span id='topic+te.sfa'></span><span id='topic+teJ.sfa'></span><span id='topic+teBC.sfa'></span><span id='topic+teMode.sfa'></span><span id='topic+te.add.sfa'></span>

<h3>Description</h3>

<p>Estimate a stochastic frontier production or cost function using a maximum 
likelihood method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfa(x, y, beta0 = NULL, lambda0 = 1, resfun = ebeta, 
    TRANSPOSE = FALSE, DEBUG=FALSE,
    control=list(), hessian=2)

sfa.cost(W, Y, COST, beta0 = NULL, lambda0 = 1, resfun = ebeta, 
    TRANSPOSE = FALSE, DEBUG=FALSE,
    control=list(), hessian=2)



te.sfa(object)
teBC.sfa(object)
teMode.sfa(object)
teJ.sfa(object)

te.add.sfa(object, ...)

sigma2u.sfa(object)
sigma2v.sfa(object)
sigma2.sfa(object)

lambda.sfa(object)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfa_+3A_x">x</code></td>
<td>
<p>Input as a K x m matrix of observations on m inputs from K
firms; (firm x input); MUST be a matrix. No constant for the
intercept should be included in x as it is added by default.</p>
</td></tr>
<tr><td><code id="sfa_+3A_y">y</code></td>
<td>
<p>Output; K times 1 matrix (one output)  </p>
</td></tr>
<tr><td><code id="sfa_+3A_y">Y</code></td>
<td>
<p>Output; K times n matrix for m outputs; only to be used in cost function estimation.  </p>
</td></tr>
<tr><td><code id="sfa_+3A_w">W</code></td>
<td>
<p>Input prices as a K x m matrix.</p>
</td></tr>
<tr><td><code id="sfa_+3A_cost">COST</code></td>
<td>
<p>Cost as a K array for the K firms</p>
</td></tr>
<tr><td><code id="sfa_+3A_beta0">beta0</code></td>
<td>
<p>Optional initial parameter values</p>
</td></tr>

<tr><td><code id="sfa_+3A_lambda0">lambda0</code></td>
<td>
<p>Optional initial ratio of variances</p>
</td></tr>
<tr><td><code id="sfa_+3A_resfun">resfun</code></td>
<td>
<p>Function to calculate the residuals, default is a
linear model with an intercept. Must be called as
<code>resfun(x,y,parm)</code> where <code>parm=c(beta,lambda)</code> or
<code>parm=c(beta)</code>, and return the residuals as an array of length
corresponding to the length of output <code>y</code>.</p>
</td></tr>







<tr><td><code id="sfa_+3A_transpose">TRANSPOSE</code></td>
<td>
<p>If TRUE, data is transposed, i.e. input is now m x K matrix</p>
</td></tr>
<tr><td><code id="sfa_+3A_debug">DEBUG</code></td>
<td>
<p>Set to TRUE to get various debugging information written
on the console</p>
</td></tr>
<tr><td><code id="sfa_+3A_control">control</code></td>
<td>
<p>List of control parameters to <code>ucminf</code></p>
</td></tr>
<tr><td><code id="sfa_+3A_hessian">hessian</code></td>
<td>
<p>How the Hessian is delivered, see the ucminf
documentation</p>
</td></tr>
<tr><td><code id="sfa_+3A_object">object</code></td>
<td>
<p>Object of class &lsquo;sfa&rsquo; as output from the
function <code>sfa</code></p>
</td></tr> 
<tr><td><code id="sfa_+3A_...">...</code></td>
<td>
<p>Further arguments ... </p>
</td></tr>    
</table>


<h3>Details</h3>

<p> The optimization is done by the R method <code>ucminf</code> from
the package with the same name. The efficiency terms are assumed to
be half&ndash;normal distributed.
</p>
<p>Changing the maximum step length, the trust region, might be important,
and this can be done by the option 'control = list(stepmax=0.1)'. The
default value is 0.1 and that value is suitable for parameters
around 1; for smaller parameters a lower value should be used.
Notice that the step length is updated by the optimizing program and
thus, must be set for every call of the function sfa if it is to be
set.
</p>
<p>The generic functions <code>print.sfa</code>, <code>summary.sfa</code>,
<code>fitted.sfa</code>, <code>residuals.sfa</code>, <code>logLik.sfa</code>, and
<code>coef.sfa</code> all work as expected.
</p>
<p>The methods <code>te.sfa</code>, <code>teMode.sfa</code> etc. calculates the
efficiency corresponding to different methods
</p>


<h3>Value</h3>

<p>The values returned from <code>sfa</code> is the same as for <code>ucminf</code>,
i.e. a list with components plus some especially relevant for sfa:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>The best set of parameters found <code>c(beta,lambda)</code>.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of minus log-likelihood function corresponding to 'par'.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The parameters for the function</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>The estimate of the total variance</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The estimate of lambda</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>The number of observations</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The degrees of freedom for the model</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The residuals as a K times 1 matrix/vector, 
can also be obtained by <br /> <code>residuals(sfa-object)</code></p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Fitted values</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>The variance-covarians matrix for all estimated parameters
incl. lambda</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>An integer code. '0' indicates successful
convergence.  Some of the error codes taken from
<code>ucminf</code> are
</p>
<p>'1' Stopped by small gradient (grtol). 
</p>
<p>'2' Stopped by small step (xtol). 
</p>
<p>'3' Stopped by function evaluation limit (maxeval). 
</p>
<p>'4' Stopped by zero step from line search 
</p>
<p>More codes are found in <code><a href="ucminf.html#topic+ucminf">ucminf</a></code>
</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>A character string giving any additional information
returned by the optimizer, or 'NULL'.</p>
</td></tr>
<tr><td><code>o</code></td>
<td>
<p>The object returned by <code>ucminf</code>, for further information
on this see <code>ucminf</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p> Calculation of technical efficiencies for each unit can be done
by the method te.sfa as shown in the examples.
</p>
<p><code>te.sfa(sfaObject), teBC.sfa(sfaObject)</code>: Efficiencies estimated
by minimizing the mean square error; Eq. (7.21) in Bogetoft and
Otto (2011, 219) and Battese and Coelli (1988, 392)
</p>
<p><code>teMode.sfa(sfaObject), te1.sfa(sfaObject)</code>: Efficiencies
estimates using the conditional mode approach; Bogetoft and Otto
(2011, 219), Jondrow et al. (1982, 235).
</p>
<p><code>teJ.sfa(sfaObject), te2.sfa(sfaObject)</code>: Efficiencies estimates
using the conditional mean approach Jondrow et al. (1982, 235).
</p>
<p><code>te.add.sfa(sfaObject)</code> Efficiency in the additive model,
Bogetoft and Otto (2011, 219)
</p>
<p>The variance pf the distribution of efficiency can be calculated by
<code>sigma2u.sfa(sfaObject)</code>, the variance of the random
error by <code>sigma2v.sfa(sfaObject)</code>, and the total variance
(sum of variances of efficiency and random noise) by
<code>sigma2.sfa</code>.
</p>
<p>The ratio of variances of the efficiency and the random noise can be
found from the method <code>lambda.sfa</code>
</p>
<p>The generic method <code>summary</code> prints the parameters, standard
errors, t-values, and a few more statistics from the
optimization.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p>Bogetoft and Otto; <em>Benchmarking with DEA, SFA, and R</em>, Springer
2011; chapters 7 and 8.
</p>


<h3>See Also</h3>

<p> See the method <code>ucminf</code> for the possible optimization
methods and further options to use in the option <code>control</code>.
</p>
<p>The method <code>sfa</code> in the package <span class="pkg">frontier</span> gives another
way to estimate stochastic production functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from the book by Coelli et al.
# d &lt;- read.csv("c:/0work/rpack/front41Data.csv", header = TRUE, sep = ",")
# x &lt;- cbind(log(d$capital), log(d$labour))
# y &lt;- matrix(log(d$output))

n &lt;- 50
x1 &lt;- 1:50 + rnorm(n, 0, 10)
x2 &lt;- 100 + rnorm(n, 0, 10)
x &lt;- cbind(x1, x2)
y &lt;- 0.5 + 1.5*x1 + 2*x2 + rnorm(n, 0, 1) - pmax(0, rnorm(n, 0, 1))
sfa(x,y)
summary(sfa(x,y))


# Estimate efficiency for each unit
o &lt;- sfa(x,y)
eff(o)

te &lt;- te.sfa(o)
teM &lt;- teMode.sfa(o)
teJ &lt;- teJ.sfa(o)
cbind(eff(o),te,Mode=eff(o, type="Mode"),teM,teJ)[1:10,]


sigma2.sfa(o)       # Estimated varians
lambda.sfa(o)       # Estimated lambda
</code></pre>

<hr>
<h2 id='slack'>
Calculate slack in an efficiency analysis
</h2><span id='topic+slack'></span><span id='topic+print.slack'></span><span id='topic+summary.slack'></span>

<h3>Description</h3>

<p>Slacks are calculated after taking the efficiency into consideration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slack(X, Y, e, XREF = NULL, YREF = NULL, FRONT.IDX = NULL, LP = FALSE, CONTROL=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slack_+3A_x">X</code></td>
<td>
<p>Inputs of firms to be evaluated, a K x m matrix of
observations of K firms with m inputs (firm x input). </p>
</td></tr>
<tr><td><code id="slack_+3A_y">Y</code></td>
<td>
<p>Outputs of firms to be evaluated, a K x n matrix of
observations of K firms with n outputs (firm x input). </p>
</td></tr>
<tr><td><code id="slack_+3A_e">e</code></td>
<td>
<p>A Farrell object as returned from <code><a href="#topic+dea">dea</a></code> et al.</p>
</td></tr>
<tr><td><code id="slack_+3A_xref">XREF</code></td>
<td>
<p>Inputs of the firms determining the technology, defaults
to <code>X</code></p>
</td></tr>
<tr><td><code id="slack_+3A_yref">YREF</code></td>
<td>
<p>Outputs of the firms determining the technology,
defaults to <code>Y</code></p>
</td></tr>
<tr><td><code id="slack_+3A_front.idx">FRONT.IDX</code></td>
<td>
<p>Index for firms determining the technology</p>
</td></tr>
<tr><td><code id="slack_+3A_lp">LP</code></td>
<td>
<p>Set <code>TRUE</code> for debugging.</p>
</td></tr>
<tr><td><code id="slack_+3A_control">CONTROL</code></td>
<td>
<p>Possible controls to <span class="pkg">lpSolveAPI</span>, see the
documentation for that package. For examples of use see the
function <code><a href="#topic+dea">dea</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Slacks are calculated in a LP problem where the sum of all
slacks are maximised after correction for efficiency. 
The for calculating slacks for orientation graph is low because of the low precision in the calculated graph efficiency. </p>


<h3>Value</h3>

<p>The result is returned as the Farrell object used as the
argument in the call of the function with the following added
components:
</p>
<table>
<tr><td><code>slack</code></td>
<td>
<p>A logical vector where the component for a firm is
<code>TRUE</code> if the sums of slacks for the corresponding firm is
positive. Only calculated in dea when option <code>SLACK=TRUE</code></p>
</td></tr>
<tr><td><code>sum</code></td>
<td>
<p>A vector with sums of the slacks for each firm. Only
calculated in dea when option <code>SLACK=TRUE</code></p>
</td></tr>
<tr><td><code>sx</code></td>
<td>
<p>A matrix for input slacks for each firm, only calculated
if the option <code>SLACK</code> is <code>TRUE</code> or returned from the
method <code>slack</code></p>
</td></tr>
<tr><td><code>sy</code></td>
<td>
<p>A matrix for output slack, see <code>sx</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>If a numerical problem occurs, status=5, or if no solution can be found,
the best solution is often to scale the input <code>X</code> and output
<code>Y</code> yourself or use the option <code>CONTROL</code> to change scaling in
the program itself, as described in the notes for <code><a href="#topic+dea">dea</a></code>.
</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>References</h3>

<p> Peter Bogetoft and Lars Otto; <em>Benchmarking with
DEA, SFA, and R</em>; Springer 2011. Sect. 5.6 page 127.  
</p>
<p>WW Cooper, LM Seiford, and K Tone; <em>Data Envelopment Analysis: A
Comprehensive Text with Models, Applications, References and
DEA-Solver Software</em>, 2nd edn. Springer 2007 .  </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(100,200,300,500,100,200,600),ncol=1)
y &lt;- matrix(c(75,100,300,400,25,50,400),ncol=1)
dea.plot.frontier(x,y,txt=1:dim(x)[1])

e &lt;- dea(x,y)
eff(e)

# calculate slacks
sl &lt;- slack(x,y,e)
data.frame(e$eff,sl$slack,sl$sx,sl$sy)
</code></pre>

<hr>
<h2 id='stoned'>Convex nonparametric least squares</h2><span id='topic+stoned'></span>

<h3>Description</h3>

<p>Convex nonparametric least squares here for convex (Cost) function 
function or concave (Production) function with multiplicative or 
additive error term. the StoNED estimator combines the
axiomatic and non-parametric frontier (the DEA aspect) with
a stochastic noise term (the SFA aspect)</p>


<h3>Usage</h3>

<pre><code class='language-R'>stoned(X, Y, RTS = "vrs", COST = 0, MULT = 0, METHOD = "MM")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoned_+3A_x">X</code></td>
<td>
<p>Inputs (right hand side) of firms to be evaluated, a K x m matrix
of observations of K firms with m inputs (firm x input).</p>
</td></tr>
<tr><td><code id="stoned_+3A_y">Y</code></td>
<td>
<p>Output or cost (left hand side) of firms to be evaluated, a K x 1 matrix
of observations of K firms with 1 output or cost (firm x input).</p>
</td></tr>
<tr><td><code id="stoned_+3A_rts">RTS</code></td>
<td>
<p>RTS determines returns to scale assumption: RTS=&quot;vrs&quot;, 
&quot;drs&quot;, &quot;crs&quot;  and &quot;irs&quot; are possible for constant or variable returns
to scale; see <code><a href="#topic+dea">dea</a></code> for a verbal description and numbering scheme.</p>
</td></tr>
<tr><td><code id="stoned_+3A_cost">COST</code></td>
<td>
<p>COST specifies whether a cost function needs is 
estimated (COST=1) or a production function (COST=0).</p>
</td></tr>
<tr><td><code id="stoned_+3A_mult">MULT</code></td>
<td>
<p>MULT determines if multiplicative (MULT=1) or 
additive (MULT=0) model is estimated.</p>
</td></tr>
<tr><td><code id="stoned_+3A_method">METHOD</code></td>
<td>
<p>METHOD specifies the way efficiency is estimated: 
MM for Method of Moments and PSL for pseudo likelihood estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convex nonparametric least squares here for convex (cost)
function with multiplicative error term: Y=b*X*exp(e) or additive
error term: Y=b*X + e.</p>


<h3>Value</h3>

<p>The results are returned in a list with the components:
</p>
<table>
<tr><td><code>residualNorm</code></td>
<td>
<p>Norm of residual</p>
</td></tr>
<tr><td><code>solutionNorm</code></td>
<td>
<p>Norm of solution</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>Is there an error in the solution?</p>
</td></tr>

<tr><td><code>coef</code></td>
<td>
<p>beta_matrix, estimated coefficients as a Kxm matrix; if there 
is an intercept the first column is the intercept, and the matrix is Kx(1+m)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Fitted values</p>
</td></tr>
<tr><td><code>eff</code></td>
<td>
<p>Efficinecy score</p>
</td></tr>
<tr><td><code>front</code></td>
<td>
<p>Points on the frontier</p>
</td></tr>
<tr><td><code>sigma_u</code></td>
<td>
<p>sigma_u</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Convex nonparametric least squares here for convex (Cost) function
with multiplicative error term:
<code>Y=b*X*exp(e)</code> or additive error term: <code>Y=b*X + e</code>.
</p>
<p>The intercept is absent for the constant returns to scale assumption; all 
other technology assumptions do have an intercept.
</p>
<p>Note that the method <code>stoned</code> is a rather slow method and probably only 
works in a reasonable time for less than 3-400 units.
</p>


<h3>Author(s)</h3>

<p>Stefan Seifert <a href="mailto:s.seifert@ilr.uni-bonn.de">s.seifert@ilr.uni-bonn.de</a> and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a>
</p>


<h3>References</h3>

<p>Kuosmanen and Kortelainen, &quot;Stochastic non-smooth envelopment of data: 
semi-parametric frontier estimation subject to shape constraints&quot;, 
<em>Journal of Productivity Analysis</em> 2012
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example: Single Input Production Function
n=10

x1 &lt;- runif(n,10,20)
v &lt;- rnorm(n,0,0.01)
u &lt;- abs(rnorm(n,0,0.04))

y &lt;- (x1^0.8)*exp(-u)*exp(v)

sol_MM &lt;- stoned(x1, y)
sol_PSL &lt;- stoned(x1, y, METHOD="PSL")

plot(x1,y)
curve(x^0.8, add=TRUE)
points(x1,sol_MM$front, col="red")
points(x1,sol_PSL$front, col="blue", pch=16, cex=.6)
</code></pre>

<hr>
<h2 id='typeIerror'>Probability of type I error for test in a bootstrap DEA model</h2><span id='topic+typeIerror'></span>

<h3>Description</h3>

<p>Calculates the probability of a type I error for a test
in bootstrapped DEA models. 

</p>


<h3>Usage</h3>

<pre><code class='language-R'>typeIerror(shat,s) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="typeIerror_+3A_shat">shat</code></td>
<td>
<p>The value of the statistic for which the probability of a
type I error is to be calculated</p>
</td></tr>
<tr><td><code id="typeIerror_+3A_s">s</code></td>
<td>
<p>Vector with calculated values of the statistic for each of
the <code>NREP</code> bootstraps; NREP is from <code>dea.boot</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Needs bootstrapped values of the test statistic</p>


<h3>Value</h3>

<p>Returns the probability of a type I error</p>


<h3>Author(s)</h3>

<p> Peter Bogetoft and Lars Otto <a href="mailto:larsot23@gmail.com">larsot23@gmail.com</a></p>


<h3>See Also</h3>

<p><code>boot.sw98</code> in <span class="pkg">FEAR</span>, Paul W. Wilson (2008),
&ldquo;FEAR 1.0: A Software Package for Frontier Efficiency
Analysis with R,&rdquo; <em>Socio-Economic Planning Sciences</em> 42,
247&ndash;254 </p>


<h3>Examples</h3>

<pre><code class='language-R'># Probability of getting something larger than 1.96 in 10000 random
# standard normal variates.
x &lt;- rnorm(10000)
typeIerror(1.96,x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
