<!DOCTYPE html><html lang="en"><head><title>Help for package mappoly</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mappoly}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_marker'><p>Add a single marker to a map</p></a></li>
<li><a href='#add_md_markers'><p>Add markers to a pre-existing sequence using HMM analysis and evaluating difference in LOD</p></a></li>
<li><a href='#add_mrk_at_tail_ph_list'><p>add a single marker at the tail of a linkage phase list</p></a></li>
<li><a href='#aggregate_matrix'><p>Aggregate matrix cells (lower the resolution by a factor)</p></a></li>
<li><a href='#cache_counts_twopt'><p>Frequency of genotypes for two-point recombination fraction estimation</p></a></li>
<li><a href='#calc_genoprob'><p>Compute conditional probabilities of the genotypes</p></a></li>
<li><a href='#calc_genoprob_dist'><p>Compute conditional probabilities of the genotypes using probability distribution of dosages</p></a></li>
<li><a href='#calc_genoprob_error'><p>Compute conditional probabilities of the genotypes using global error</p></a></li>
<li><a href='#calc_genoprob_haplo'><p>Compute conditional probabilities of the genotypes given a sequence</p>
of block markers</a></li>
<li><a href='#calc_genoprob_single_parent'><p>Compute conditional probabilities of the genotype (one informative parent)</p></a></li>
<li><a href='#calc_homologprob'><p>Homolog probabilities</p></a></li>
<li><a href='#calc_prefpair_profiles'><p>Preferential pairing profiles</p></a></li>
<li><a href='#cat_phase'><p>cat for phase information</p></a></li>
<li><a href='#check_data_dist_sanity'><p>Checks the consistency of dataset (probability distribution)</p></a></li>
<li><a href='#check_data_dose_sanity'><p>Checks the consistency of dataset (dosage)</p></a></li>
<li><a href='#check_data_sanity'><p>Data sanity check</p></a></li>
<li><a href='#check_if_rf_is_possible'><p>Check if it is possible to estimate the recombination</p>
fraction between neighbor markers using two-point
estimation</a></li>
<li><a href='#check_ls_phase'><p>Compare a list of linkage phases and return the</p>
markers for which they are different.</a></li>
<li><a href='#check_pairwise'><p>Check if all pairwise combinations of elements of <code>input.seq</code></p>
are contained in <code>twopt</code></a></li>
<li><a href='#compare_haplotypes'><p>Compare two polyploid haplotypes stored in list format</p></a></li>
<li><a href='#compare_maps'><p>Compare a list of maps</p></a></li>
<li><a href='#concatenate_new_marker'><p>Concatenate new marker</p></a></li>
<li><a href='#concatenate_ph_list'><p>concatenate two linkage phase lists</p></a></li>
<li><a href='#create_map'><p>Create a map with pseudomarkers at a given step</p></a></li>
<li><a href='#cross_simulate'><p>Simulate an autopolyploid full-sib population</p></a></li>
<li><a href='#detect_info_par'><p>Detects which parent is informative</p></a></li>
<li><a href='#dist_prob_to_class'><p>Returns the class with the highest probability in</p>
a genotype probability distribution</a></li>
<li><a href='#draw_cross'><p>Draw simple parental linkage phase configurations</p></a></li>
<li><a href='#draw_phases'><p>Plot the linkage phase configuration given a list of homologous chromosomes</p></a></li>
<li><a href='#drop_marker'><p>Remove markers from a map</p></a></li>
<li><a href='#edit_order'><p>Edit sequence ordered by reference genome positions</p>
comparing to another set order</a></li>
<li><a href='#elim_conf_using_two_pts'><p>Eliminate configurations using two-point information</p></a></li>
<li><a href='#elim_equiv'><p>Eliminates equivalent linkage phase configurations</p></a></li>
<li><a href='#elim_redundant'><p>Eliminate redundant markers</p></a></li>
<li><a href='#est_full_hmm_with_global_error'><p>Re-estimate genetic map given a global genotyping error</p></a></li>
<li><a href='#est_full_hmm_with_prior_prob'><p>Re-estimate genetic map using dosage prior probability distribution</p></a></li>
<li><a href='#est_haplo_hmm'><p>Estimate a genetic map given a sequence of block markers</p></a></li>
<li><a href='#est_map_haplo_given_genoprob'><p>Estimate a genetic map given a sequence of block markers</p>
given the conditional probabilities of the genotypes</a></li>
<li><a href='#est_pairwise_rf'><p>Pairwise two-point analysis</p></a></li>
<li><a href='#est_pairwise_rf2'><p>Pairwise two-point analysis - RcppParallel version</p></a></li>
<li><a href='#est_rf_hmm'><p>Multipoint analysis using Hidden Markov Models in autopolyploids</p></a></li>
<li><a href='#est_rf_hmm_sequential'><p>Multipoint analysis using Hidden Markov Models: Sequential phase elimination</p></a></li>
<li><a href='#est_rf_hmm_single_phase'><p>Multipoint analysis using Hidden Markov Models (single phase)</p></a></li>
<li><a href='#est_rf_hmm_single_phase_single_parent'><p>Multilocus analysis using Hidden Markov Models (single parent, single phase)</p></a></li>
<li><a href='#export_data_to_polymapR'><p>Export data to <code>polymapR</code></p></a></li>
<li><a href='#export_map_list'><p>Export a genetic map to a CSV file</p></a></li>
<li><a href='#export_qtlpoly'><p>Export to QTLpoly</p></a></li>
<li><a href='#extract_map'><p>Extract the maker position from an object of class 'mappoly.map'</p></a></li>
<li><a href='#filter_aneuploid'><p>Filter aneuploid chromosomes from progeny individuals</p></a></li>
<li><a href='#filter_individuals'><p>Filter out individuals</p></a></li>
<li><a href='#filter_map_at_hmm_thres'><p>Filter MAPpoly Map Configurations by Loglikelihood Threshold</p></a></li>
<li><a href='#filter_missing'><p>Filter missing genotypes</p></a></li>
<li><a href='#filter_missing_ind'><p>Filter individuals based on missing genotypes</p></a></li>
<li><a href='#filter_missing_mrk'><p>Filter markers based on missing genotypes</p></a></li>
<li><a href='#filter_non_conforming_classes'><p>Filter non-conforming classes in F1, non double reduced population.</p></a></li>
<li><a href='#filter_segregation'><p>Filter markers based on chi-square test</p></a></li>
<li><a href='#find_blocks'><p>Allocate markers into linkage blocks</p></a></li>
<li><a href='#format_rf'><p>Format results from pairwise two-point estimation in C++</p></a></li>
<li><a href='#framework_map'><p>Design linkage map framework in two steps: i) estimating the recombination fraction with</p>
HMM approach for each parent separately using only markers segregating individually
(e.g. map 1 - P1:3 x P2:0, P1: 2x4; map 2 - P1:0 x P2:3, P1:4 x P2:2); ii) merging both
maps and re-estimate recombination fractions.</a></li>
<li><a href='#generate_all_link_phase_elim_equivalent'><p>Generate all possible linkage phases in matrix form given the dose</p>
and the number of shared alleles between a inserted marker and a
pre-computed linkage configuration.</a></li>
<li><a href='#generate_all_link_phases_elim_equivalent_haplo'><p>Eliminate equivalent linkage phases</p></a></li>
<li><a href='#genetic-mapping-functions'><p>Genetic Mapping Functions</p></a></li>
<li><a href='#genotyping_global_error'><p>Prior probability for genotyping error</p></a></li>
<li><a href='#get_cache_two_pts_from_web'><p>Access a remote server to get Counts for recombinant classes</p></a></li>
<li><a href='#get_counts'><p>Counts for recombinant classes</p></a></li>
<li><a href='#get_counts_all_phases'><p>Counts for recombinant classes</p></a></li>
<li><a href='#get_counts_single_parent'><p>Counts for recombinant classes in a polyploid parent.</p></a></li>
<li><a href='#get_counts_two_parents'><p>Counts for recombinant classes</p></a></li>
<li><a href='#get_dosage_type'><p>Get Dosage Type in a Sequence</p></a></li>
<li><a href='#get_full_info_tail'><p>Get the tail of a marker sequence up to the point where the markers</p>
provide no additional information.</a></li>
<li><a href='#get_genomic_order'><p>Get the genomic position of markers in a sequence</p></a></li>
<li><a href='#get_ij'><p>Given a pair of character indicating the numbers i and j : 'i-j',</p>
returns a numeric pair c(i,j)</a></li>
<li><a href='#get_indices_from_selected_phases'><p>Get the indices of selected linkage phases given a threshold</p></a></li>
<li><a href='#get_LOD'><p>Extract the LOD Scores in a <code>'mappoly.map'</code> object</p></a></li>
<li><a href='#get_ols_map'><p>Get weighted ordinary least squared map give a sequence and rf matrix</p></a></li>
<li><a href='#get_ph_conf_ret_sh'><p>Given a homology group in matrix form, it returns the number shared</p>
homologous for all pairs of markers in this group</a></li>
<li><a href='#get_ph_list_subset'><p>subset of a linkage phase list</p></a></li>
<li><a href='#get_rf_from_list'><p>Get the recombination fraction for a sequence of markers given an</p>
object of class <code>mappoly.twopt</code> and a list
containing the linkage phase configuration. This list can be found
in any object of class <code>two.pts.linkage.phases</code>, in
x$config.to.test$'Conf-i', where x is the object of class
<code>two.pts.linkage.phases</code> and i is one of the possible
configurations.</a></li>
<li><a href='#get_rf_from_mat'><p>Get recombination fraction from a matrix</p></a></li>
<li><a href='#get_states_and_emission_single_parent'><p>Get states and emission in one informative parent</p></a></li>
<li><a href='#get_submap'><p>Extract sub-map from map</p></a></li>
<li><a href='#get_tab_mrks'><p>Get table of dosage combinations</p></a></li>
<li><a href='#get_w_m'><p>Get the number of bivalent configurations</p></a></li>
<li><a href='#gg_color_hue'><p>Color pallet ggplot-like</p></a></li>
<li><a href='#group_mappoly'><p>Assign markers to linkage groups</p></a></li>
<li><a href='#hexafake'><p>Simulated autohexaploid dataset.</p></a></li>
<li><a href='#hexafake.geno.dist'><p>Simulated autohexaploid dataset with genotype probabilities.</p></a></li>
<li><a href='#import_data_from_polymapR'><p>Import data from polymapR</p></a></li>
<li><a href='#import_from_updog'><p>Import from updog</p></a></li>
<li><a href='#import_phased_maplist_from_polymapR'><p>Import phased map list from polymapR</p></a></li>
<li><a href='#is.prob.data'><p>Check if Object is a Probability Dataset in MAPpoly</p></a></li>
<li><a href='#loglike_hmm'><p>Multipoint log-likelihood computation</p></a></li>
<li><a href='#ls_linkage_phases'><p>List of linkage phases</p></a></li>
<li><a href='#make_mat_mappoly'><p>Subset recombination fraction matrices</p></a></li>
<li><a href='#make_pairs_mappoly'><p>Subset pairwise recombination fractions</p></a></li>
<li><a href='#make_seq_mappoly'><p>Create a Sequence of Markers</p></a></li>
<li><a href='#mappoly-color-palettes'><p>MAPpoly Color Palettes</p></a></li>
<li><a href='#maps.hexafake'><p>Resulting maps from <code>hexafake</code></p></a></li>
<li><a href='#mds_mappoly'><p>Estimates loci position using Multidimensional Scaling</p></a></li>
<li><a href='#merge_datasets'><p>Merge datasets</p></a></li>
<li><a href='#merge_maps'><p>Merge two maps</p></a></li>
<li><a href='#merge_parental_maps'><p>Build merged parental maps</p></a></li>
<li><a href='#mrk_chisq_test'><p>Chi-square test</p></a></li>
<li><a href='#msg'><p>Msg function</p></a></li>
<li><a href='#paralell_pairwise_discrete'><p>Parallel Pairwise Discrete Estimation</p></a></li>
<li><a href='#paralell_pairwise_discrete_rcpp'><p>Wrapper function to discrete-based pairwise two-point estimation in C++</p></a></li>
<li><a href='#paralell_pairwise_probability'><p>Parallel Pairwise Probability Estimation</p></a></li>
<li><a href='#parallel_block'><p>Auxiliary function to estimate a map in a block of markers using parallel</p>
processing</a></li>
<li><a href='#perm_pars'><p>N!/2 combination</p></a></li>
<li><a href='#perm_tot'><p>N! combination</p></a></li>
<li><a href='#ph_list_to_matrix'><p>Linkage phase format conversion: list to matrix</p></a></li>
<li><a href='#ph_matrix_to_list'><p>Linkage phase format conversion: matrix to list</p></a></li>
<li><a href='#plot_compare_haplotypes'><p>Plot Two Overlapped Haplotypes</p></a></li>
<li><a href='#plot_genome_vs_map'><p>Physical versus genetic distance</p></a></li>
<li><a href='#plot_GIC'><p>Genotypic information content</p></a></li>
<li><a href='#plot_map_list'><p>Plot a genetic map</p></a></li>
<li><a href='#plot_mappoly.map2'><p>Plot object mappoly.map2</p></a></li>
<li><a href='#plot_mrk_info'><p>Plot marker information</p></a></li>
<li><a href='#plot_one_map'><p>plot a single linkage group with no phase</p></a></li>
<li><a href='#plot_progeny_dosage_change'><p>Display genotypes imputed or changed by the HMM chain given a global genotypic error</p></a></li>
<li><a href='#plot.mappoly.homoprob'><p>Plots mappoly.homoprob</p></a></li>
<li><a href='#plot.mappoly.prefpair.profiles'><p>Plots mappoly.prefpair.profiles</p></a></li>
<li><a href='#poly_hmm_est'><p>Estimate genetic map using as input the probability distribution of</p>
genotypes (wrapper function to C++)</a></li>
<li><a href='#prepare_map'><p>prepare maps for plot</p></a></li>
<li><a href='#print_mrk'><p>Summary of a set of markers</p></a></li>
<li><a href='#print_ph'><p>cat for graphical representation of the phases</p></a></li>
<li><a href='#read_fitpoly'><p>Data Input in fitPoly format</p></a></li>
<li><a href='#read_geno'><p>Data Input</p></a></li>
<li><a href='#read_geno_csv'><p>Data Input in CSV format</p></a></li>
<li><a href='#read_geno_prob'><p>Data Input</p></a></li>
<li><a href='#read_vcf'><p>Data Input VCF</p></a></li>
<li><a href='#reest_rf'><p>Re-estimate the recombination fractions in a genetic map</p></a></li>
<li><a href='#rev_map'><p>Reverse map</p></a></li>
<li><a href='#rf_list_to_matrix'><p>Recombination fraction list to matrix</p></a></li>
<li><a href='#rf_snp_filter'><p>Remove markers that do not meet a LOD criteria</p></a></li>
<li><a href='#sample_data'><p>Random sampling of dataset</p></a></li>
<li><a href='#segreg_poly'><p>Polysomic segregation frequency</p></a></li>
<li><a href='#select_rf'><p>Select rf and lod based on thresholds</p></a></li>
<li><a href='#sim_cross_one_informative_parent'><p>Simulate mapping population (one parent)</p></a></li>
<li><a href='#sim_cross_two_informative_parents'><p>Simulate mapping population (tow parents)</p></a></li>
<li><a href='#sim_homologous'><p>Simulate homology groups</p></a></li>
<li><a href='#solcap.dose.map'><p>Resulting maps from <code>tetra.solcap</code></p></a></li>
<li><a href='#solcap.err.map'><p>Resulting maps from <code>tetra.solcap</code></p></a></li>
<li><a href='#solcap.mds.map'><p>Resulting maps from <code>tetra.solcap</code></p></a></li>
<li><a href='#solcap.prior.map'><p>Resulting maps from <code>tetra.solcap.geno.dist</code></p></a></li>
<li><a href='#split_and_rephase'><p>Divides map in sub-maps and re-phase them</p></a></li>
<li><a href='#split_mappoly'><p>Split map into sub maps given a gap threshold</p></a></li>
<li><a href='#summary_maps'><p>Summary maps</p></a></li>
<li><a href='#table_to_mappoly'><p>Conversion of data.frame to mappoly.data</p></a></li>
<li><a href='#tetra.solcap'><p>Autotetraploid potato dataset.</p></a></li>
<li><a href='#tetra.solcap.geno.dist'><p>Autotetraploid potato dataset with genotype probabilities.</p></a></li>
<li><a href='#update_framework_map'><p>Add markers that are informative in both parents using HMM approach and evaluating difference</p>
in LOD and gap size</a></li>
<li><a href='#update_map'><p>Update map</p></a></li>
<li><a href='#update_missing'><p>Update missing information</p></a></li>
<li><a href='#update_ph_list_at_hmm_thres'><p>makes a phase list from map, selecting only</p>
configurations under a certain threshold</a></li>
<li><a href='#v_2_m'><p>Conversion: vector to matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genetic Linkage Maps in Autopolyploids</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcelo Mollinari &lt;mmollin@ncsu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Construction of genetic maps in autopolyploid full-sib populations. 
             Uses pairwise recombination fraction estimation as the first 
             source of information to sequentially position allelic variants 
             in specific homologous chromosomes. For situations where pairwise 
             analysis has limited power, the algorithm relies on the multilocus 
             likelihood obtained through a hidden Markov model (HMM). 
             For more detail, please see  Mollinari and Garcia (2019) 
             &lt;<a href="https://doi.org/10.1534%2Fg3.119.400378">doi:10.1534/g3.119.400378</a>&gt; and Mollinari et al. (2020) 
             &lt;<a href="https://doi.org/10.1534%2Fg3.119.400620">doi:10.1534/g3.119.400620</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.6), RcppParallel, RCurl, fields, ggpubr, ggsci,
rstudioapi, plot3D, dplyr, crayon, cli, magrittr, reshape2,
ggplot2, smacof, princurve, dendextend, vcfR, zoo, plotly</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, updog, fitPoly, polymapR, AGHmatrix, gatepoints,
knitr, rmarkdown, stringr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mmollina/MAPpoly">https://github.com/mmollina/MAPpoly</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mmollina/MAPpoly/issues">https://github.com/mmollina/MAPpoly/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 03:10:56 UTC; mmollin</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcelo Mollinari <a href="https://orcid.org/0000-0002-7001-8498"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Gabriel Gesteira <a href="https://orcid.org/0000-0002-4106-7346"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Cristiane Taniguti
    <a href="https://orcid.org/0000-0002-2021-6883"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Jeekin Lau <a href="https://orcid.org/0000-0003-1114-6892"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Oscar Riera-Lizarazu
    <a href="https://orcid.org/0000-0002-7477-4063"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Guilhereme Pereira
    <a href="https://orcid.org/0000-0002-7106-8630"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Augusto Garcia <a href="https://orcid.org/0000-0003-0634-3277"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Zhao-Bang Zeng <a href="https://orcid.org/0000-0002-3115-1149"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Katharine Preedy [ctb, cph] (MDS ordering algorithm),
  Robert Gentleman [cph] (C code for MLE optimization in
    src/pairwise_estimation.cpp),
  Ross Ihaka [cph] (C code for MLE optimization in
    src/pairwise_estimation.cpp),
  R Foundation [cph] (C code for MLE optimization in
    src/pairwise_estimation.cpp),
  R-core [cph] (C code for MLE optimization in
    src/pairwise_estimation.cpp)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-06 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_marker'>Add a single marker to a map</h2><span id='topic+add_marker'></span>

<h3>Description</h3>

<p>Creates a new map by adding a marker in a given position in a pre-built map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_marker(
  input.map,
  mrk,
  pos,
  rf.matrix,
  genoprob = NULL,
  phase.config = "best",
  tol = 0.001,
  extend.tail = NULL,
  r.test = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_marker_+3A_input.map">input.map</code></td>
<td>
<p>an object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="add_marker_+3A_mrk">mrk</code></td>
<td>
<p>the name of the marker to be inserted</p>
</td></tr>
<tr><td><code id="add_marker_+3A_pos">pos</code></td>
<td>
<p>the name of the marker after which the new marker should be added.
One also can inform the numeric position (between markers) were the 
new marker should be added. To insert a marker at the beginning of a 
map, use <code>pos = 0</code></p>
</td></tr>
<tr><td><code id="add_marker_+3A_rf.matrix">rf.matrix</code></td>
<td>
<p>an object of class <code>mappoly.rf.matrix</code> containing the recombination
fractions and the number of homologues sharing alleles between pairwise 
markers on <code>input.map</code>. It is important that <code>shared.alleles = TRUE</code>
in function <code><a href="#topic+rf_list_to_matrix">rf_list_to_matrix</a></code> when computing <code>rf.matrix</code>.</p>
</td></tr>
<tr><td><code id="add_marker_+3A_genoprob">genoprob</code></td>
<td>
<p>an object of class <code>mappoly.genoprob</code> containing the genotype probabilities
for all marker positions on <code>input.map</code></p>
</td></tr>
<tr><td><code id="add_marker_+3A_phase.config">phase.config</code></td>
<td>
<p>which phase configuration should be used. &quot;best&quot; (default) 
will choose the maximum likelihood configuration</p>
</td></tr>
<tr><td><code id="add_marker_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (default = 10e-04)</p>
</td></tr>
<tr><td><code id="add_marker_+3A_extend.tail">extend.tail</code></td>
<td>
<p>the length of the chain's tail that should
be used to calculate the likelihood of the map. If <code>NULL</code> (default), 
the function uses all markers positioned.</p>
</td></tr>
<tr><td><code id="add_marker_+3A_r.test">r.test</code></td>
<td>
<p>for internal use only</p>
</td></tr>
<tr><td><code id="add_marker_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_marker</code> splits the input map into two sub-maps to the left and the 
right of the given position. Using the genotype probabilities, it computes 
the log-likelihood of all possible linkage phases under a two-point threshold
inherited from function <code><a href="#topic+rf_list_to_matrix">rf_list_to_matrix</a></code>.
</p>


<h3>Value</h3>

<p>A list of class <code>mappoly.map</code> with two elements: 
</p>
<p>i) info:  a list containing information about the map, regardless of the linkage phase configuration:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>number of markers</p>
</td></tr>
<tr><td><code>seq.num</code></td>
<td>
<p>a vector containing the (ordered) indices of markers in the map, 
according to the input file</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of markers in the map</p>
</td></tr>
<tr><td><code>seq.dose.p1</code></td>
<td>
<p>a vector containing the dosage in parent 1 for all markers in the map</p>
</td></tr>
<tr><td><code>seq.dose.p2</code></td>
<td>
<p>a vector containing the dosage in parent 2 for all markers in the map</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating the sequence (usually chromosome) each marker belongs 
as informed in the input file. If not available, 
<code>chrom = NULL</code></p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>physical position (usually in megabase) of the markers into the sequence</p>
</td></tr>
<tr><td><code>seq.ref</code></td>
<td>
<p>reference base used for each marker (i.e. A, T, C, G). If not available, 
<code>seq.ref = NULL</code></p>
</td></tr>                 
<tr><td><code>seq.alt</code></td>
<td>
<p>alternative base used for each marker (i.e. A, T, C, G). If not available, 
<code>seq.ref = NULL</code></p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>a vector containing p-values of the chi-squared test of Mendelian 
segregation for all markers in the map</p>
</td></tr>                 
<tr><td><code>data.name</code></td>
<td>
<p>name of the dataset of class <code>mappoly.data</code></p>
</td></tr>
<tr><td><code>ph.thres</code></td>
<td>
<p>the LOD threshold used to define the linkage phase configurations to test</p>
</td></tr>
</table>
<p>ii) a list of maps with possible linkage phase configuration. Each map in the list is also a 
list containing
</p>
<table role = "presentation">
<tr><td><code>seq.num</code></td>
<td>
<p>a vector containing the (ordered) indices of markers in the map, 
according to the input file</p>
</td></tr>
<tr><td><code>seq.rf</code></td>
<td>
<p>a vector of size (<code>n.mrk - 1</code>) containing a sequence of recombination 
fraction between the adjacent markers in the map</p>
</td></tr>
<tr><td><code>seq.ph</code></td>
<td>
<p>linkage phase configuration for all markers in both parents</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>the hmm-based multipoint likelihood</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sub.map &lt;- get_submap(maps.hexafake[[1]], 1:20, reestimate.rf = FALSE)
plot(sub.map, mrk.names = TRUE)
s &lt;- make_seq_mappoly(hexafake, sub.map$info$mrk.names)
tpt &lt;- est_pairwise_rf(s)
rf.matrix &lt;- rf_list_to_matrix(input.twopt = tpt,
                               thresh.LOD.ph = 3, 
                               thresh.LOD.rf = 3,
                               shared.alleles = TRUE)
###### Removing marker "M_1" (first) #######
mrk.to.remove &lt;- "M_1"
input.map &lt;- drop_marker(sub.map, mrk.to.remove)
plot(input.map, mrk.names = TRUE)
## Computing conditional probabilities using the resulting map
genoprob &lt;- calc_genoprob(input.map)
res.add.M_1 &lt;- add_marker(input.map = input.map,
                        mrk = "M_1",
                        pos = 0,
                        rf.matrix = rf.matrix,
                        genoprob = genoprob,
                        tol = 10e-4)  
 plot(res.add.M_1, mrk.names = TRUE)                       
 best.phase &lt;- res.add.M_1$maps[[1]]$seq.ph
 names.id &lt;- names(best.phase$P)
 plot_compare_haplotypes(ploidy = 6,
                         hom.allele.p1 = best.phase$P[names.id],
                         hom.allele.q1 = best.phase$Q[names.id],
                         hom.allele.p2 = sub.map$maps[[1]]$seq.ph$P[names.id],
                         hom.allele.q2 = sub.map$maps[[1]]$seq.ph$Q[names.id])
                         
###### Removing marker "M_10" (middle or last) #######
mrk.to.remove &lt;- "M_10"
input.map &lt;- drop_marker(sub.map, mrk.to.remove)
plot(input.map, mrk.names = TRUE)
# Computing conditional probabilities using the resulting map
genoprob &lt;- calc_genoprob(input.map)
res.add.M_10 &lt;- add_marker(input.map = input.map,
                        mrk = "M_10",
                        pos = "M_9",
                        rf.matrix = rf.matrix,
                        genoprob = genoprob,
                        tol = 10e-4)  
 plot(res.add.M_10, mrk.names = TRUE)                       
 best.phase &lt;- res.add.M_10$maps[[1]]$seq.ph
 names.id &lt;- names(best.phase$P)
 plot_compare_haplotypes(ploidy = 6,
                         hom.allele.p1 = best.phase$P[names.id],
                         hom.allele.q1 = best.phase$Q[names.id],
                         hom.allele.p2 = sub.map$maps[[1]]$seq.ph$P[names.id],
                         hom.allele.q2 = sub.map$maps[[1]]$seq.ph$Q[names.id]) 

</code></pre>

<hr>
<h2 id='add_md_markers'>Add markers to a pre-existing sequence using HMM analysis and evaluating difference in LOD</h2><span id='topic+add_md_markers'></span>

<h3>Description</h3>

<p>Add markers to a pre-existing sequence using HMM analysis and evaluating difference in LOD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_md_markers(
  input.map,
  mrk.to.include,
  input.seq,
  input.matrix,
  input.genoprob,
  input.data,
  input.mds = NULL,
  thresh = 500,
  extend.tail = 50,
  method = c("hmm", "wMDS_to_1D_pc"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_md_markers_+3A_input.map">input.map</code></td>
<td>
<p>An object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="add_md_markers_+3A_mrk.to.include">mrk.to.include</code></td>
<td>
<p>vector for marker names to be included</p>
</td></tr>
<tr><td><code id="add_md_markers_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code> containing all markers (the ones in the mappoly.map and also the ones to be included)</p>
</td></tr>
<tr><td><code id="add_md_markers_+3A_input.matrix">input.matrix</code></td>
<td>
<p>object of class <code>mappoly.rf.matrix</code></p>
</td></tr>
<tr><td><code id="add_md_markers_+3A_input.genoprob">input.genoprob</code></td>
<td>
<p>an object of class <code>mappoly.genoprob</code> obtained with calc_genoprob of the input.map object</p>
</td></tr>
<tr><td><code id="add_md_markers_+3A_input.data">input.data</code></td>
<td>
<p>an object of class <code>mappoly.data</code></p>
</td></tr>
<tr><td><code id="add_md_markers_+3A_input.mds">input.mds</code></td>
<td>
<p>An object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="add_md_markers_+3A_thresh">thresh</code></td>
<td>
<p>the LOD threshold used to determine if the marker will be included or not after hmm analysis  (default = 30)</p>
</td></tr>
<tr><td><code id="add_md_markers_+3A_extend.tail">extend.tail</code></td>
<td>
<p>the length of the chain's tail that should be used to calculate the likelihood of 
the map. If NULL (default), the function uses all markers positioned. Even if info.tail = TRUE, 
it uses at least extend.tail as the tail length</p>
</td></tr>
<tr><td><code id="add_md_markers_+3A_method">method</code></td>
<td>
<p>indicates whether to use 'hmm' (Hidden Markov Models), 'ols' (Ordinary Least Squares) or 'wMDS_to_1D_pc' 
(weighted MDS followed by fitting a one dimensional principal curve) to re-estimate the recombination fractions after adding markers</p>
</td></tr>
<tr><td><code id="add_md_markers_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE (default), current progress is shown; if FALSE, no output is produced</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a> with documentation and minor modifications by Cristiane Taniguti <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>

<hr>
<h2 id='add_mrk_at_tail_ph_list'>add a single marker at the tail of a linkage phase list</h2><span id='topic+add_mrk_at_tail_ph_list'></span>

<h3>Description</h3>

<p>add a single marker at the tail of a linkage phase list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_mrk_at_tail_ph_list(ph.list.1, ph.list.2, cor.index)
</code></pre>

<hr>
<h2 id='aggregate_matrix'>Aggregate matrix cells (lower the resolution by a factor)</h2><span id='topic+aggregate_matrix'></span>

<h3>Description</h3>

<p>Aggregate matrix cells (lower the resolution by a factor)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_matrix(M, fact)
</code></pre>

<hr>
<h2 id='cache_counts_twopt'>Frequency of genotypes for two-point recombination fraction estimation</h2><span id='topic+cache_counts_twopt'></span>

<h3>Description</h3>

<p>Returns the frequency of each genotype for two-point reduction
of dimensionality. The frequency is calculated for all pairwise
combinations and for all possible linkage phase configurations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_counts_twopt(
  input.seq,
  cached = FALSE,
  cache.prev = NULL,
  ncpus = 1L,
  verbose = TRUE,
  joint.prob = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cache_counts_twopt_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code></p>
</td></tr>
<tr><td><code id="cache_counts_twopt_+3A_cached">cached</code></td>
<td>
<p>If <code>TRUE</code>, access the counts for all
linkage phase configurations in a internal file (default = FALSE)</p>
</td></tr>
<tr><td><code id="cache_counts_twopt_+3A_cache.prev">cache.prev</code></td>
<td>
<p>an object of class <code>cache.info</code> containing
pre-computed genotype frequencies, obtained with
<code><a href="#topic+cache_counts_twopt">cache_counts_twopt</a></code> (optional, default = NULL)</p>
</td></tr>
<tr><td><code id="cache_counts_twopt_+3A_ncpus">ncpus</code></td>
<td>
<p>Number of parallel processes to spawn (default = 1)</p>
</td></tr>
<tr><td><code id="cache_counts_twopt_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), print the linkage phase
configurations. If <code>cached = TRUE</code>, nothing is
printed, since all linkage phase configurations will be cached.</p>
</td></tr>
<tr><td><code id="cache_counts_twopt_+3A_joint.prob">joint.prob</code></td>
<td>
<p>If <code>FALSE</code> (default), returns the frequency of
genotypes for transition probabilities (conditional
probabilities). If <code>TRUE</code> returns the frequency for joint
probabilities. The latter is especially important to compute the 
Fisher's Information for a pair of markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cache.info</code> which contains one (conditional probabilities)
or two (both conditional and joint probabilities) lists. Each list
contains all pairs of dosages between parents for all markers
in the sequence. The names in each list are of the form 'A-B-C-D', where: A
represents the dosage in parent 1, marker k; B represents the dosage in parent
1, marker k+1; C represents the dosage in parent 2, marker k;
and D represents the dosage in parent 2, marker k+1.  For each
list, the frequencies were computed for all possible linkage
phase configurations. The frequencies for each linkage phase
configuration are distributed in matrices whose names
represents the number of homologous chromosomes that share
alleles. The rows on these matrices represents the dosages in markers k
and k+1 for an individual in the offspring. See Table 3 of
S3 Appendix in Mollinari and Garcia (2019) for an example.
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a> with updates by Gabriel Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    all.mrk &lt;- make_seq_mappoly(tetra.solcap, 1:20)
    ## local computation
    counts &lt;- cache_counts_twopt(all.mrk, ncpus = 1)
    ## load from internal file or web-stored counts (especially important for high ploidy levels)
    counts.cached &lt;- cache_counts_twopt(all.mrk, cached = TRUE)

</code></pre>

<hr>
<h2 id='calc_genoprob'>Compute conditional probabilities of the genotypes</h2><span id='topic+calc_genoprob'></span>

<h3>Description</h3>

<p>Conditional genotype probabilities are calculated for each marker
position and each individual given a map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_genoprob(input.map, step = 0, phase.config = "best", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_genoprob_+3A_input.map">input.map</code></td>
<td>
<p>An object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="calc_genoprob_+3A_step">step</code></td>
<td>
<p>Maximum distance (in cM) between positions at which
the genotype probabilities are calculated, though for
step = 0, probabilities are calculated only at the
marker locations.</p>
</td></tr>
<tr><td><code id="calc_genoprob_+3A_phase.config">phase.config</code></td>
<td>
<p>which phase configuration should be used. &quot;best&quot; (default)
will choose the phase configuration associated with the
maximum likelihood</p>
</td></tr>
<tr><td><code id="calc_genoprob_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'mappoly.genoprob' which has two elements: a tridimensional
array containing the probabilities of all possible genotypes for each individual
in each marker position; and the marker sequence with it's recombination frequencies
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## tetraploid example
 probs.t &lt;- calc_genoprob(input.map = solcap.dose.map[[1]],
                        verbose = TRUE)
 probs.t
 ## displaying individual 1, 36 genotypic states
 ## (rows) across linkage group 1 (columns)                          
 image(t(probs.t$probs[,,1]))

</code></pre>

<hr>
<h2 id='calc_genoprob_dist'>Compute conditional probabilities of the genotypes using probability distribution of dosages</h2><span id='topic+calc_genoprob_dist'></span>

<h3>Description</h3>

<p>Conditional genotype probabilities are calculated for each marker
position and each individual given a map. In this function,
the probabilities are not calculated between markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_genoprob_dist(
  input.map,
  dat.prob = NULL,
  phase.config = "best",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_genoprob_dist_+3A_input.map">input.map</code></td>
<td>
<p>An object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="calc_genoprob_dist_+3A_dat.prob">dat.prob</code></td>
<td>
<p>an object of class <code>mappoly.data</code> containing the
probability distribution of the genotypes</p>
</td></tr>
<tr><td><code id="calc_genoprob_dist_+3A_phase.config">phase.config</code></td>
<td>
<p>which phase configuration should be used. &quot;best&quot; (default) 
will choose the phase configuration with the
maximum likelihood</p>
</td></tr>
<tr><td><code id="calc_genoprob_dist_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'mappoly.genoprob' which has two elements: a tridimensional
array containing the probabilities of all possible genotypes for each individual
in each marker position; and the marker sequence with it's recombination frequencies
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## tetraploid example
 probs.t &lt;- calc_genoprob_dist(input.map = solcap.prior.map[[1]],
                           dat.prob = tetra.solcap.geno.dist,
                           verbose = TRUE)
 probs.t
 ## displaying individual 1, 36 genotypic states 
 ## (rows) across linkage group 1 (columns)                          
 image(t(probs.t$probs[,,1]))

</code></pre>

<hr>
<h2 id='calc_genoprob_error'>Compute conditional probabilities of the genotypes using global error</h2><span id='topic+calc_genoprob_error'></span>

<h3>Description</h3>

<p>Conditional genotype probabilities are calculated for each marker
position and each individual given a map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_genoprob_error(
  input.map,
  step = 0,
  phase.config = "best",
  error = 0.01,
  th.prob = 0.95,
  restricted = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_genoprob_error_+3A_input.map">input.map</code></td>
<td>
<p>An object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="calc_genoprob_error_+3A_step">step</code></td>
<td>
<p>Maximum distance (in cM) between positions at which 
the genotype probabilities are calculated, though for 
step = 0, probabilities are calculated only at the 
marker locations.</p>
</td></tr>
<tr><td><code id="calc_genoprob_error_+3A_phase.config">phase.config</code></td>
<td>
<p>which phase configuration should be used. &quot;best&quot; (default) 
will choose the maximum likelihood configuration</p>
</td></tr>
<tr><td><code id="calc_genoprob_error_+3A_error">error</code></td>
<td>
<p>the assumed global error rate (default = 0.01)</p>
</td></tr>
<tr><td><code id="calc_genoprob_error_+3A_th.prob">th.prob</code></td>
<td>
<p>the threshold for using global error or genotype 
probability distribution contained in the dataset (default = 0.95)</p>
</td></tr>
<tr><td><code id="calc_genoprob_error_+3A_restricted">restricted</code></td>
<td>
<p>if <code>TRUE</code> (default), restricts the prior to the 
possible classes under Mendelian non double-reduced 
segregation given the parental dosages</p>
</td></tr>
<tr><td><code id="calc_genoprob_error_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'mappoly.genoprob' which has two elements: a tridimensional
array containing the probabilities of all possible genotypes for each individual
in each marker position; and the marker sequence with it's recombination frequencies
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
     probs.error &lt;- calc_genoprob_error(input.map = solcap.err.map[[1]],
                                error = 0.05,
                                verbose = TRUE)
 

</code></pre>

<hr>
<h2 id='calc_genoprob_haplo'>Compute conditional probabilities of the genotypes given a sequence 
of block markers</h2><span id='topic+calc_genoprob_haplo'></span>

<h3>Description</h3>

<p>Compute conditional probabilities of the genotypes given a sequence 
of block markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_genoprob_haplo(
  ploidy,
  n.mrk,
  n.ind,
  haplo,
  emit = NULL,
  rf_vec,
  ind.names,
  verbose = TRUE,
  highprec = FALSE
)
</code></pre>

<hr>
<h2 id='calc_genoprob_single_parent'>Compute conditional probabilities of the genotype (one informative parent)</h2><span id='topic+calc_genoprob_single_parent'></span>

<h3>Description</h3>

<p>Conditional genotype probabilities are calculated for each marker
position and each individual given a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_genoprob_single_parent(
  input.map,
  step = 0,
  info.parent = 1,
  uninfo.parent = 2,
  global.err = 0,
  phase.config = "best",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_genoprob_single_parent_+3A_input.map">input.map</code></td>
<td>
<p>An object of class <code>mappoly.map</code> (with exceptions)</p>
</td></tr>
<tr><td><code id="calc_genoprob_single_parent_+3A_step">step</code></td>
<td>
<p>Maximum distance (in cM) between positions at which
the genotype probabilities are calculated, though for
step = 0, probabilities are calculated only at the
marker locations.</p>
</td></tr>
<tr><td><code id="calc_genoprob_single_parent_+3A_info.parent">info.parent</code></td>
<td>
<p>index for informative parent</p>
</td></tr>
<tr><td><code id="calc_genoprob_single_parent_+3A_uninfo.parent">uninfo.parent</code></td>
<td>
<p>index for uninformative parent</p>
</td></tr>
<tr><td><code id="calc_genoprob_single_parent_+3A_global.err">global.err</code></td>
<td>
<p>the assumed global error rate (default = 0.0)</p>
</td></tr>
<tr><td><code id="calc_genoprob_single_parent_+3A_phase.config">phase.config</code></td>
<td>
<p>which phase configuration should be used. &quot;best&quot; (default)
will choose the phase configuration associated with the
maximum likelihood</p>
</td></tr>
<tr><td><code id="calc_genoprob_single_parent_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'mappoly.genoprob' which has two elements: a tridimensional
array containing the probabilities of all possible genotypes for each individual
in each marker position; and the marker sequence with it's recombination frequencies
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## tetraploid example
 s &lt;- make_seq_mappoly(tetra.solcap, 'seq12', info.parent = "p1")
 tpt &lt;- est_pairwise_rf(s)
 map &lt;- est_rf_hmm_sequential(input.seq = s,
                              twopt = tpt,
                               start.set = 10,
                               thres.twopt = 10, 
                               thres.hmm = 10,
                               extend.tail = 4,
                               info.tail = TRUE, 
                               sub.map.size.diff.limit = 8, 
                               phase.number.limit = 4,
                               reestimate.single.ph.configuration = TRUE,
                               tol = 10e-2,
                               tol.final = 10e-3)
 plot(map)                                     
 probs &lt;- calc_genoprob_single_parent(input.map = map, 
                                   info.parent = 1, 
                                   uninfo.parent = 2, 
                                   step = 1)
 probs
 ## displaying individual 1, 6 genotypic states
 ## (rows) across linkage group 1 (columns)                          
 image(t(probs$probs[,,2]))

</code></pre>

<hr>
<h2 id='calc_homologprob'>Homolog probabilities</h2><span id='topic+calc_homologprob'></span>

<h3>Description</h3>

<p>Compute homolog probabilities for all individuals in the full-sib
population given a map and conditional genotype probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_homologprob(input.genoprobs, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_homologprob_+3A_input.genoprobs">input.genoprobs</code></td>
<td>
<p>an object of class <code>mappoly.genoprob</code></p>
</td></tr>
<tr><td><code id="calc_homologprob_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari M., Olukolu B. A.,  Pereira G. da S., 
Khan A., Gemenet D., Yencho G. C., Zeng Z-B. (2020), 
Unraveling the Hexaploid Sweetpotato Inheritance 
Using Ultra-Dense Multilocus Mapping, 
_G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400620">doi:10.1534/g3.119.400620</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
     ## tetraploid example
     w1 &lt;- calc_genoprob(solcap.dose.map[[1]])
     h.prob &lt;- calc_homologprob(w1)
     print(h.prob)
     plot(h.prob, ind = 5, use.plotly = FALSE)
     ## using error modeling (removing noise)
     w2 &lt;- calc_genoprob_error(solcap.err.map[[1]])
     h.prob2 &lt;- calc_homologprob(w2)
     print(h.prob2)
     plot(h.prob2, ind = 5, use.plotly = FALSE)
  

</code></pre>

<hr>
<h2 id='calc_prefpair_profiles'>Preferential pairing profiles</h2><span id='topic+calc_prefpair_profiles'></span>

<h3>Description</h3>

<p>Given the genotype conditional probabilities for a map, this function
computes the probability profiles for all possible homolog pairing 
configurations in both parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_prefpair_profiles(input.genoprobs, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_prefpair_profiles_+3A_input.genoprobs">input.genoprobs</code></td>
<td>
<p>an object of class <code>mappoly.genoprob</code></p>
</td></tr>
<tr><td><code id="calc_prefpair_profiles_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a> and Guilherme Pereira, <a href="mailto:g.pereira@cgiar.org">g.pereira@cgiar.org</a>
</p>


<h3>References</h3>

<p>Mollinari M., Olukolu B. A.,  Pereira G. da S., 
Khan A., Gemenet D., Yencho G. C., Zeng Z-B. (2020), 
Unraveling the Hexaploid Sweetpotato Inheritance 
Using Ultra-Dense Multilocus Mapping, 
_G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400620">doi:10.1534/g3.119.400620</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## tetraploid example
  w1 &lt;- lapply(solcap.dose.map[1:12], calc_genoprob)
  x1 &lt;- calc_prefpair_profiles(w1)
  print(x1)
  plot(x1)


</code></pre>

<hr>
<h2 id='cat_phase'>cat for phase information</h2><span id='topic+cat_phase'></span>

<h3>Description</h3>

<p>cat for phase information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_phase(
  input.seq,
  input.ph,
  all.ph,
  ct,
  seq.num,
  twopt.phase.number,
  hmm.phase.number
)
</code></pre>

<hr>
<h2 id='check_data_dist_sanity'>Checks the consistency of dataset (probability distribution)</h2><span id='topic+check_data_dist_sanity'></span>

<h3>Description</h3>

<p>Checks the consistency of dataset (probability distribution)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data_dist_sanity(x)
</code></pre>

<hr>
<h2 id='check_data_dose_sanity'>Checks the consistency of dataset (dosage)</h2><span id='topic+check_data_dose_sanity'></span>

<h3>Description</h3>

<p>Checks the consistency of dataset (dosage)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data_dose_sanity(x)
</code></pre>

<hr>
<h2 id='check_data_sanity'>Data sanity check</h2><span id='topic+check_data_sanity'></span>

<h3>Description</h3>

<p>Checks the consistency of a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data_sanity(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_data_sanity_+3A_x">x</code></td>
<td>
<p>an object of class <code>mappoly.data</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>if consistent, returns 0. If not consistent, returns a 
vector with a number of tests, where <code>TRUE</code> indicates
a failed test.
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_data_sanity(tetra.solcap)
</code></pre>

<hr>
<h2 id='check_if_rf_is_possible'>Check if it is possible to estimate the recombination
fraction between neighbor markers using two-point
estimation</h2><span id='topic+check_if_rf_is_possible'></span>

<h3>Description</h3>

<p>Check if it is possible to estimate the recombination
fraction between neighbor markers using two-point
estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_if_rf_is_possible(input.seq)
</code></pre>

<hr>
<h2 id='check_ls_phase'>Compare a list of linkage phases and return the 
markers for which they are different.</h2><span id='topic+check_ls_phase'></span>

<h3>Description</h3>

<p>Compare a list of linkage phases and return the 
markers for which they are different.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ls_phase(ph)
</code></pre>

<hr>
<h2 id='check_pairwise'>Check if all pairwise combinations of elements of <code>input.seq</code>
are contained in <code>twopt</code></h2><span id='topic+check_pairwise'></span>

<h3>Description</h3>

<p>Check if all pairwise combinations of elements of <code>input.seq</code>
are contained in <code>twopt</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pairwise(input.seq, twopt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_pairwise_+3A_input.seq">input.seq</code></td>
<td>
<p>An object of class <code>mappoly.sequence</code></p>
</td></tr>
<tr><td><code id="check_pairwise_+3A_twopt">twopt</code></td>
<td>
<p>An object of class <code>mappoly.twopt</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all pairwise combinations of elements of
<code>input.seq</code> are contained in <code>twopt</code>, the function
returns 0. Otherwise, returns the missing pairs.
</p>

<hr>
<h2 id='compare_haplotypes'>Compare two polyploid haplotypes stored in list format</h2><span id='topic+compare_haplotypes'></span>

<h3>Description</h3>

<p>Compare two polyploid haplotypes stored in list format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_haplotypes(ploidy, h1, h2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_haplotypes_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy level</p>
</td></tr>
<tr><td><code id="compare_haplotypes_+3A_h1">h1</code></td>
<td>
<p>homology group 1</p>
</td></tr>
<tr><td><code id="compare_haplotypes_+3A_h2">h2</code></td>
<td>
<p>homology group 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of size <code>ploidy</code> indicating which
homolog in h2 represents the homolog in h1. If there is
no correspondence, i.e. different homolog, it returns NA for
that homolog.
</p>

<hr>
<h2 id='compare_maps'>Compare a list of maps</h2><span id='topic+compare_maps'></span>

<h3>Description</h3>

<p>Compare lengths, density, maximum gaps and log likelihoods in a list of maps.
In order to make the maps comparable, the function uses the intersection of 
markers among maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_maps(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_maps_+3A_...">...</code></td>
<td>
<p>a list of objects of class <code>mappoly.map</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where the lines correspond to the maps in the order provided in input list list
</p>

<hr>
<h2 id='concatenate_new_marker'>Concatenate new marker</h2><span id='topic+concatenate_new_marker'></span>

<h3>Description</h3>

<p>Inserts a new marker at the end of the sequence, taking into account
the two-point information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concatenate_new_marker(X = NULL, d, sh = NULL, seq.num = NULL, ploidy, mrk = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concatenate_new_marker_+3A_x">X</code></td>
<td>
<p>a list of matrices whose columns represent homologous
chromosomes and the rows represent markers</p>
</td></tr>
<tr><td><code id="concatenate_new_marker_+3A_d">d</code></td>
<td>
<p>the dosage of the inserted marker</p>
</td></tr>
<tr><td><code id="concatenate_new_marker_+3A_sh">sh</code></td>
<td>
<p>a list of shared alleles between all markers in the sequence</p>
</td></tr>
<tr><td><code id="concatenate_new_marker_+3A_seq.num">seq.num</code></td>
<td>
<p>a vector of integers containing the number of each marker in the raw data file</p>
</td></tr>
<tr><td><code id="concatenate_new_marker_+3A_ploidy">ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code id="concatenate_new_marker_+3A_mrk">mrk</code></td>
<td>
<p>the marker to be inserted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a unique list of matrices representing linkage phases
</p>

<hr>
<h2 id='concatenate_ph_list'>concatenate two linkage phase lists</h2><span id='topic+concatenate_ph_list'></span>

<h3>Description</h3>

<p>concatenate two linkage phase lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concatenate_ph_list(ph.list.1, ph.list.2)
</code></pre>

<hr>
<h2 id='create_map'>Create a map with pseudomarkers at a given step</h2><span id='topic+create_map'></span>

<h3>Description</h3>

<p>Create a map with pseudomarkers at a given step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_map(input.map, step = 0, phase.config = "best")
</code></pre>

<hr>
<h2 id='cross_simulate'>Simulate an autopolyploid full-sib population</h2><span id='topic+cross_simulate'></span>

<h3>Description</h3>

<p>Simulate an autopolyploid full-sib population with one or two 
informative parents under random chromosome segregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_simulate(
  parental.phases,
  map.length,
  n.ind,
  draw = FALSE,
  file = "output.pdf",
  prefix = NULL,
  seed = NULL,
  width = 12,
  height = 6,
  prob.P = NULL,
  prob.Q = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cross_simulate_+3A_parental.phases">parental.phases</code></td>
<td>
<p>a list containing the linkage phase information for both parents</p>
</td></tr>
<tr><td><code id="cross_simulate_+3A_map.length">map.length</code></td>
<td>
<p>the map length</p>
</td></tr>
<tr><td><code id="cross_simulate_+3A_n.ind">n.ind</code></td>
<td>
<p>number of individuals in the offspring</p>
</td></tr>
<tr><td><code id="cross_simulate_+3A_draw">draw</code></td>
<td>
<p>if <code>TRUE</code>, draws a graphical representation of the
parental map, including the linkage phase configuration, in a
pdf output (default = FALSE)</p>
</td></tr>
<tr><td><code id="cross_simulate_+3A_file">file</code></td>
<td>
<p>name of the output file. It is ignored if
<code>draw = TRUE</code></p>
</td></tr>
<tr><td><code id="cross_simulate_+3A_prefix">prefix</code></td>
<td>
<p>prefix used in all marker names.</p>
</td></tr>
<tr><td><code id="cross_simulate_+3A_seed">seed</code></td>
<td>
<p>random number generator seed (default = NULL)</p>
</td></tr>
<tr><td><code id="cross_simulate_+3A_width">width</code></td>
<td>
<p>the width of the graphics region in inches (default = 12)</p>
</td></tr>
<tr><td><code id="cross_simulate_+3A_height">height</code></td>
<td>
<p>the height of the graphics region in inches (default = 6)</p>
</td></tr>
<tr><td><code id="cross_simulate_+3A_prob.p">prob.P</code></td>
<td>
<p>a vector indicating the proportion of preferential
pairing in parent P (currently ignored)</p>
</td></tr>
<tr><td><code id="cross_simulate_+3A_prob.q">prob.Q</code></td>
<td>
<p>a vector indicating the proportion of preferential
pairing in parent Q (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>parental.phases.p</code> and <code>parental.phases.q</code> are lists of vectors
containing linkage phase configurations. Each vector contains the
numbers of the homologous chromosomes in which the alleles are
located. For instance, a vector containing <code class="reqn">(1,3,4)</code> means that
the marker has three doses located in the chromosomes 1, 3 and 4. For
zero doses, use 0.
For more sophisticated simulations, we strongly recommend using PedigreeSim V2.0
<a href="https://github.com/PBR/pedigreeSim">https://github.com/PBR/pedigreeSim</a>
</p>


<h3>Value</h3>

<p>an object of class <code>mappoly.data</code>. See
<code><a href="#topic+read_geno">read_geno</a></code> for more information
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    h.temp &lt;- sim_homologous(ploidy = 6, n.mrk = 20)
    fake.poly.dat &lt;- cross_simulate(h.temp, map.length = 100, n.ind = 200)
    plot(fake.poly.dat)
                                   
                                  
</code></pre>

<hr>
<h2 id='detect_info_par'>Detects which parent is informative</h2><span id='topic+detect_info_par'></span>

<h3>Description</h3>

<p>Detects which parent is informative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_info_par(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect_info_par_+3A_x">x</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code> or <code>mappoly.map</code></p>
</td></tr>
</table>

<hr>
<h2 id='dist_prob_to_class'>Returns the class with the highest probability in 
a genotype probability distribution</h2><span id='topic+dist_prob_to_class'></span>

<h3>Description</h3>

<p>Returns the class with the highest probability in 
a genotype probability distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_prob_to_class(geno, prob.thres = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_prob_to_class_+3A_geno">geno</code></td>
<td>
<p>the probabilistic genotypes contained in the object
<code>'mappoly.data'</code></p>
</td></tr>
<tr><td><code id="dist_prob_to_class_+3A_prob.thres">prob.thres</code></td>
<td>
<p>probability threshold to select the genotype. 
Values below this genotype are assumed as missing data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the doses of each genotype and
marker. Markers are disposed in rows and individuals are 
disposed in columns. Missing data are represented by NAs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
geno.dose &lt;- dist_prob_to_class(hexafake.geno.dist$geno)
geno.dose$geno.dose[1:10,1:10]
   
</code></pre>

<hr>
<h2 id='draw_cross'>Draw simple parental linkage phase configurations</h2><span id='topic+draw_cross'></span>

<h3>Description</h3>

<p>This function draws the parental map (including the linkage
phase configuration) in a pdf output. This function is not to
be directly called by the user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_cross(
  ploidy,
  dist.vec = NULL,
  hom.allele.p,
  hom.allele.q,
  file = NULL,
  width = 12,
  height = 6
)
</code></pre>

<hr>
<h2 id='draw_phases'>Plot the linkage phase configuration given a list of homologous chromosomes</h2><span id='topic+draw_phases'></span>

<h3>Description</h3>

<p>Plot the linkage phase configuration given a list of homologous chromosomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_phases(ploidy, hom.allele.p, hom.allele.q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_phases_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy level</p>
</td></tr>
<tr><td><code id="draw_phases_+3A_hom.allele.p">hom.allele.p</code></td>
<td>
<p>a <code>list</code> of vectors containing linkage
phase configuration for parent P. Each vector contains the
numbers of the homologous chromosomes in which the alleles are
located.</p>
</td></tr>
<tr><td><code id="draw_phases_+3A_hom.allele.q">hom.allele.q</code></td>
<td>
<p>same for parent Q</p>
</td></tr>
</table>

<hr>
<h2 id='drop_marker'>Remove markers from a map</h2><span id='topic+drop_marker'></span>

<h3>Description</h3>

<p>This function creates a new map by removing markers from an existing one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_marker(input.map, mrk, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_marker_+3A_input.map">input.map</code></td>
<td>
<p>an object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="drop_marker_+3A_mrk">mrk</code></td>
<td>
<p>a vector containing markers to be removed from the input map, 
identified by their names or positions</p>
</td></tr>
<tr><td><code id="drop_marker_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>mappoly.map</code>
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> sub.map &lt;- get_submap(maps.hexafake[[1]], 1:50, reestimate.rf = FALSE)
 plot(sub.map, mrk.names = TRUE)
 mrk.to.remove &lt;- c("M_1", "M_23", "M_34")
 red.map &lt;- drop_marker(sub.map, mrk.to.remove)
 plot(red.map, mrk.names = TRUE)

</code></pre>

<hr>
<h2 id='edit_order'>Edit sequence ordered by reference genome positions
comparing to another set order</h2><span id='topic+edit_order'></span>

<h3>Description</h3>

<p>Edit sequence ordered by reference genome positions
comparing to another set order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edit_order(input.seq, invert = NULL, remove = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edit_order_+3A_input.seq">input.seq</code></td>
<td>
<p>object of class mappoly.sequence with alternative order (not genomic order)</p>
</td></tr>
<tr><td><code id="edit_order_+3A_invert">invert</code></td>
<td>
<p>vector of marker names to be inverted</p>
</td></tr>
<tr><td><code id="edit_order_+3A_remove">remove</code></td>
<td>
<p>vector of marker names to be removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>mappoly.edit.order</code>: a list containing
vector of marker names ordered according to editions ('edited_order');
vector of removed markers names ('removed');
vector of inverted markers names ('inverted').
</p>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
  dat &lt;- filter_segregation(tetra.solcap, inter = FALSE)
  seq_dat &lt;- make_seq_mappoly(dat)
  seq_chr &lt;- make_seq_mappoly(seq_dat, arg = seq_dat$seq.mrk.names[which(seq_dat$chrom=="1")])

  tpt &lt;- est_pairwise_rf(seq_chr)
  seq.filt &lt;- rf_snp_filter(tpt, probs = c(0.05, 0.95))
  mat &lt;- rf_list_to_matrix(tpt)
  mat2 &lt;- make_mat_mappoly(mat, seq.filt)

  seq_test_mds &lt;- mds_mappoly(mat2)
  seq_mds &lt;- make_seq_mappoly(seq_test_mds)
  edit_seq &lt;- edit_order(input.seq = seq_mds)
 
 
</code></pre>

<hr>
<h2 id='elim_conf_using_two_pts'>Eliminate configurations using two-point information</h2><span id='topic+elim_conf_using_two_pts'></span>

<h3>Description</h3>

<p>Drops unlikely configuration phases given the two-point information
and a LOD threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elim_conf_using_two_pts(input.seq, twopt, thres)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elim_conf_using_two_pts_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code>.</p>
</td></tr>
<tr><td><code id="elim_conf_using_two_pts_+3A_twopt">twopt</code></td>
<td>
<p>an object of class <code>mappoly.twopt</code></p>
</td></tr>
<tr><td><code id="elim_conf_using_two_pts_+3A_thres">thres</code></td>
<td>
<p>threshold from which the linkage phases can be
discarded (if abs(ph_LOD) &gt; thres)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a unique list of matrices representing linkage phases
</p>

<hr>
<h2 id='elim_equiv'>Eliminates equivalent linkage phase configurations</h2><span id='topic+elim_equiv'></span>

<h3>Description</h3>

<p>Drop equivalent linkage phase configurations, i.e. the ones which
have permuted homologous chromosomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elim_equiv(Z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elim_equiv_+3A_z">Z</code></td>
<td>
<p>a list of matrices whose columns represent homologous
chromosomes and the rows represent markers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a unique list of matrices
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>

<hr>
<h2 id='elim_redundant'>Eliminate redundant markers</h2><span id='topic+elim_redundant'></span>

<h3>Description</h3>

<p>Eliminate markers with identical dosage information for all individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elim_redundant(input.seq, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elim_redundant_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code></p>
</td></tr>
<tr><td><code id="elim_redundant_+3A_data">data</code></td>
<td>
<p>name of the dataset that contains sequence markers (optional, default = NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mappoly.unique.seq</code> which
is a list  containing the following components:
</p>
<table role = "presentation">
<tr><td><code>unique.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code>
with the redundant markers removed</p>
</td></tr>
<tr><td><code>kept</code></td>
<td>
<p>a vector containing the name of the informative markers</p>
</td></tr>
<tr><td><code>eliminated</code></td>
<td>
<p>a vector containing the name of the non-informative (eliminated) markers</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>, with minor modifications by Gabriel Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    all.mrk &lt;- make_seq_mappoly(hexafake, 'all')
    red.mrk &lt;- elim_redundant(all.mrk)
    plot(red.mrk)
    unique.mrks &lt;- make_seq_mappoly(red.mrk)
   
</code></pre>

<hr>
<h2 id='est_full_hmm_with_global_error'>Re-estimate genetic map given a global genotyping error</h2><span id='topic+est_full_hmm_with_global_error'></span>

<h3>Description</h3>

<p>This function considers a global error when re-estimating
a genetic map using Hidden Markov models. Since this function 
uses the whole transition space in the HMM, its computation 
can take a while, especially for hexaploid maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_full_hmm_with_global_error(
  input.map,
  error = NULL,
  tol = 0.001,
  restricted = TRUE,
  th.prob = 0.95,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_full_hmm_with_global_error_+3A_input.map">input.map</code></td>
<td>
<p>an object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="est_full_hmm_with_global_error_+3A_error">error</code></td>
<td>
<p>the assumed global error rate (default = NULL)</p>
</td></tr>
<tr><td><code id="est_full_hmm_with_global_error_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (default = 10e-04)</p>
</td></tr>
<tr><td><code id="est_full_hmm_with_global_error_+3A_restricted">restricted</code></td>
<td>
<p>if <code>TRUE</code> (default), restricts the prior to the 
possible classes under Mendelian, non double-reduced segregation 
given dosage of the parents</p>
</td></tr>
<tr><td><code id="est_full_hmm_with_global_error_+3A_th.prob">th.prob</code></td>
<td>
<p>the threshold for using global error or genotype 
probability distribution if present in the dataset (default = 0.95)</p>
</td></tr>
<tr><td><code id="est_full_hmm_with_global_error_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, current progress is shown; if
<code>FALSE</code> (default), no output is produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>mappoly.map</code> with two elements: 
</p>
<p>i) info:  a list containing information about the map, regardless of the linkage phase configuration:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>number of markers</p>
</td></tr>
<tr><td><code>seq.num</code></td>
<td>
<p>a vector containing the (ordered) indices of markers in the map, 
according to the input file</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of markers in the map</p>
</td></tr>
<tr><td><code>seq.dose.p1</code></td>
<td>
<p>a vector containing the dosage in parent 1 for all markers in the map</p>
</td></tr>
<tr><td><code>seq.dose.p2</code></td>
<td>
<p>a vector containing the dosage in parent 2 for all markers in the map</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating the sequence (usually chromosome) each marker belongs 
as informed in the input file. If not available, 
<code>chrom = NULL</code></p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>physical position (usually in megabase) of the markers into the sequence</p>
</td></tr>
<tr><td><code>seq.ref</code></td>
<td>
<p>reference base used for each marker (i.e. A, T, C, G). If not available, 
<code>seq.ref = NULL</code></p>
</td></tr>                 
<tr><td><code>seq.alt</code></td>
<td>
<p>alternative base used for each marker (i.e. A, T, C, G). If not available, 
<code>seq.ref = NULL</code></p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>a vector containing p-values of the chi-squared test of Mendelian 
segregation for all markers in the map</p>
</td></tr>                 
<tr><td><code>data.name</code></td>
<td>
<p>name of the dataset of class <code>mappoly.data</code></p>
</td></tr>
<tr><td><code>ph.thres</code></td>
<td>
<p>the LOD threshold used to define the linkage phase configurations to test</p>
</td></tr>
</table>
<p>ii) a list of maps with possible linkage phase configuration. Each map in the list is also a 
list containing
</p>
<table role = "presentation">
<tr><td><code>seq.num</code></td>
<td>
<p>a vector containing the (ordered) indices of markers in the map, 
according to the input file</p>
</td></tr>
<tr><td><code>seq.rf</code></td>
<td>
<p>a vector of size (<code>n.mrk - 1</code>) containing a sequence of recombination 
fraction between the adjacent markers in the map</p>
</td></tr>
<tr><td><code>seq.ph</code></td>
<td>
<p>linkage phase configuration for all markers in both parents</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>the hmm-based multipoint likelihood</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    submap &lt;- get_submap(solcap.dose.map[[1]], mrk.pos = 1:20, verbose = FALSE)
    err.submap &lt;- est_full_hmm_with_global_error(submap, 
                                                 error = 0.01, 
                                                 tol = 10e-4, 
                                                 verbose = TRUE)
    err.submap
    plot_map_list(list(dose = submap, err = err.submap), 
                  title = "estimation procedure")

</code></pre>

<hr>
<h2 id='est_full_hmm_with_prior_prob'>Re-estimate genetic map using dosage prior probability distribution</h2><span id='topic+est_full_hmm_with_prior_prob'></span>

<h3>Description</h3>

<p>This function considers dosage prior distribution when re-estimating
a genetic map using Hidden Markov models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_full_hmm_with_prior_prob(
  input.map,
  dat.prob = NULL,
  phase.config = "best",
  tol = 0.001,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_full_hmm_with_prior_prob_+3A_input.map">input.map</code></td>
<td>
<p>an object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="est_full_hmm_with_prior_prob_+3A_dat.prob">dat.prob</code></td>
<td>
<p>an object of class <code>mappoly.data</code> containing the
probability distribution of the genotypes</p>
</td></tr>
<tr><td><code id="est_full_hmm_with_prior_prob_+3A_phase.config">phase.config</code></td>
<td>
<p>which phase configuration should be used. &quot;best&quot; (default) 
will choose the maximum likelihood configuration</p>
</td></tr>
<tr><td><code id="est_full_hmm_with_prior_prob_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (default = 10e-04)</p>
</td></tr>
<tr><td><code id="est_full_hmm_with_prior_prob_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, current progress is shown; if
<code>FALSE</code> (default), no output is produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>mappoly.map</code> with two elements: 
</p>
<p>i) info:  a list containing information about the map, regardless of the linkage phase configuration:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>number of markers</p>
</td></tr>
<tr><td><code>seq.num</code></td>
<td>
<p>a vector containing the (ordered) indices of markers in the map, 
according to the input file</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of markers in the map</p>
</td></tr>
<tr><td><code>seq.dose.p1</code></td>
<td>
<p>a vector containing the dosage in parent 1 for all markers in the map</p>
</td></tr>
<tr><td><code>seq.dose.p2</code></td>
<td>
<p>a vector containing the dosage in parent 2 for all markers in the map</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating the sequence (usually chromosome) each marker belongs 
as informed in the input file. If not available, 
<code>chrom = NULL</code></p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>physical position (usually in megabase) of the markers into the sequence</p>
</td></tr>
<tr><td><code>seq.ref</code></td>
<td>
<p>reference base used for each marker (i.e. A, T, C, G). If not available, 
<code>seq.ref = NULL</code></p>
</td></tr>                 
<tr><td><code>seq.alt</code></td>
<td>
<p>alternative base used for each marker (i.e. A, T, C, G). If not available, 
<code>seq.ref = NULL</code></p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>a vector containing p-values of the chi-squared test of Mendelian 
segregation for all markers in the map</p>
</td></tr>                 
<tr><td><code>data.name</code></td>
<td>
<p>name of the dataset of class <code>mappoly.data</code></p>
</td></tr>
<tr><td><code>ph.thres</code></td>
<td>
<p>the LOD threshold used to define the linkage phase configurations to test</p>
</td></tr>
</table>
<p>ii) a list of maps with possible linkage phase configuration. Each map in the list is also a 
list containing
</p>
<table role = "presentation">
<tr><td><code>seq.num</code></td>
<td>
<p>a vector containing the (ordered) indices of markers in the map, 
according to the input file</p>
</td></tr>
<tr><td><code>seq.rf</code></td>
<td>
<p>a vector of size (<code>n.mrk - 1</code>) containing a sequence of recombination 
fraction between the adjacent markers in the map</p>
</td></tr>
<tr><td><code>seq.ph</code></td>
<td>
<p>linkage phase configuration for all markers in both parents</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>the hmm-based multipoint likelihood</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    submap &lt;- get_submap(solcap.dose.map[[1]], mrk.pos = 1:20, verbose = FALSE)
    prob.submap &lt;- est_full_hmm_with_prior_prob(submap,
                                                dat.prob = tetra.solcap.geno.dist,
                                                tol = 10e-4, 
                                                verbose = TRUE)
    prob.submap
    plot_map_list(list(dose = submap, prob = prob.submap), 
                  title = "estimation procedure")

</code></pre>

<hr>
<h2 id='est_haplo_hmm'>Estimate a genetic map given a sequence of block markers</h2><span id='topic+est_haplo_hmm'></span>

<h3>Description</h3>

<p>Estimate a genetic map given a sequence of block markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_haplo_hmm(
  ploidy,
  n.mrk,
  n.ind,
  haplo,
  emit = NULL,
  rf_vec,
  verbose = TRUE,
  use_H0 = FALSE,
  highprec = FALSE,
  tol = 0.001
)
</code></pre>

<hr>
<h2 id='est_map_haplo_given_genoprob'>Estimate a genetic map given a sequence of block markers 
given the conditional probabilities of the genotypes</h2><span id='topic+est_map_haplo_given_genoprob'></span>

<h3>Description</h3>

<p>Estimate a genetic map given a sequence of block markers 
given the conditional probabilities of the genotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_map_haplo_given_genoprob(map.list, genoprob.list, tol = 1e-04)
</code></pre>

<hr>
<h2 id='est_pairwise_rf'>Pairwise two-point analysis</h2><span id='topic+est_pairwise_rf'></span>

<h3>Description</h3>

<p>Performs the two-point pairwise analysis between all markers in a sequence. 
For each pair, the function estimates the recombination fraction for all 
possible linkage phase configurations and associated LOD Scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_pairwise_rf(
  input.seq,
  count.cache = NULL,
  count.matrix = NULL,
  ncpus = 1L,
  mrk.pairs = NULL,
  n.batches = 1L,
  est.type = c("disc", "prob"),
  verbose = TRUE,
  memory.warning = TRUE,
  parallelization.type = c("PSOCK", "FORK"),
  tol = .Machine$double.eps^0.25,
  ll = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_pairwise_rf_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code></p>
</td></tr>
<tr><td><code id="est_pairwise_rf_+3A_count.cache">count.cache</code></td>
<td>
<p>an object of class <code>cache.info</code> containing
pre-computed genotype frequencies, obtained with
<code><a href="#topic+cache_counts_twopt">cache_counts_twopt</a></code>. If <code>NULL</code> (default),
genotype frequencies are internally loaded.</p>
</td></tr>
<tr><td><code id="est_pairwise_rf_+3A_count.matrix">count.matrix</code></td>
<td>
<p>similar to <code>count.cache</code>, but in matrix format. 
Mostly for internal use.</p>
</td></tr>
<tr><td><code id="est_pairwise_rf_+3A_ncpus">ncpus</code></td>
<td>
<p>Number of parallel processes (cores) to spawn (default = 1)</p>
</td></tr>
<tr><td><code id="est_pairwise_rf_+3A_mrk.pairs">mrk.pairs</code></td>
<td>
<p>a matrix of dimensions 2*N, containing N
pairs of markers to be analyzed. If <code>NULL</code> (default), all pairs are
considered</p>
</td></tr>
<tr><td><code id="est_pairwise_rf_+3A_n.batches">n.batches</code></td>
<td>
<p>deprecated. Not available on MAPpoly 0.3.0 or higher</p>
</td></tr>
<tr><td><code id="est_pairwise_rf_+3A_est.type">est.type</code></td>
<td>
<p>Indicates whether to use the discrete (&quot;disc&quot;) or the probabilistic (&quot;prob&quot;) dosage scoring 
when estimating the two-point recombination fractions.</p>
</td></tr>
<tr><td><code id="est_pairwise_rf_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
<tr><td><code id="est_pairwise_rf_+3A_memory.warning">memory.warning</code></td>
<td>
<p>if <code>TRUE</code>, prints a memory warning if the 
number of markers is greater than 10000 for ploidy levels up to 4, and 
3000 for ploidy levels &gt; 4.</p>
</td></tr>
<tr><td><code id="est_pairwise_rf_+3A_parallelization.type">parallelization.type</code></td>
<td>
<p>one of the supported cluster types. This should 
be either PSOCK (default) or FORK.</p>
</td></tr>
<tr><td><code id="est_pairwise_rf_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy. See <code>optimize()</code> for details</p>
</td></tr>
<tr><td><code id="est_pairwise_rf_+3A_ll">ll</code></td>
<td>
<p>will return log-likelihood instead of LOD scores. 
(for internal use)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mappoly.twopt</code> which is a list containing the following components:
</p>

<dl>
<dt><code>data.name</code></dt><dd><p>Name of the object of class <code>mappoly.data</code> containing the raw data.</p>
</dd>
<dt><code>n.mrk</code></dt><dd><p>Number of markers in the sequence.</p>
</dd>
<dt><code>seq.num</code></dt><dd><p>A <code>vector</code> containing the (ordered) indices of markers in the sequence, according to the input file.</p>
</dd>
<dt><code>pairwise</code></dt><dd><p>A list of size <code>choose(length(input.seq$seq.num), 2)</code>, where each element is a matrix. The rows are named in the format x-y, where x and y indicate how many homologues share the same allelic variant in parents P and Q, respectively (see Mollinari and Garcia, 2019 for notation). The first column indicates the LOD Score for the most likely linkage phase configuration. The second column shows the estimated recombination fraction for each configuration, and the third column indicates the LOD Score for comparing the likelihood under no linkage (r = 0.5) with the estimated recombination fraction (evidence of linkage).</p>
</dd>
<dt><code>chisq.pval.thres</code></dt><dd><p>Threshold used to perform the segregation tests.</p>
</dd>
<dt><code>chisq.pval</code></dt><dd><p>P-values associated with the performed segregation tests.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Tetraploid example (first 50 markers) 
  all.mrk &lt;- make_seq_mappoly(tetra.solcap, 1:50)
  red.mrk &lt;- elim_redundant(all.mrk)
  unique.mrks &lt;- make_seq_mappoly(red.mrk)
  all.pairs &lt;- est_pairwise_rf(input.seq = unique.mrks,
                               ncpus = 1, 
                               verbose = TRUE)
   all.pairs
   plot(all.pairs, 20, 21)
   mat &lt;- rf_list_to_matrix(all.pairs)
   plot(mat)
</code></pre>

<hr>
<h2 id='est_pairwise_rf2'>Pairwise two-point analysis - RcppParallel version</h2><span id='topic+est_pairwise_rf2'></span>

<h3>Description</h3>

<p>Performs the two-point pairwise analysis between all markers in a sequence. 
For each pair, the function estimates the recombination fraction for all 
possible linkage phase configurations and associated LOD Scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_pairwise_rf2(
  input.seq,
  ncpus = 1L,
  mrk.pairs = NULL,
  verbose = TRUE,
  tol = .Machine$double.eps^0.25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_pairwise_rf2_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code></p>
</td></tr>
<tr><td><code id="est_pairwise_rf2_+3A_ncpus">ncpus</code></td>
<td>
<p>Number of parallel processes (cores) to spawn (default = 1)</p>
</td></tr>
<tr><td><code id="est_pairwise_rf2_+3A_mrk.pairs">mrk.pairs</code></td>
<td>
<p>a matrix of dimensions 2*N, containing N
pairs of markers to be analyzed. If <code>NULL</code> (default), all pairs are
considered</p>
</td></tr>
<tr><td><code id="est_pairwise_rf2_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
<tr><td><code id="est_pairwise_rf2_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy. See <code>optimize()</code> for details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Differently from est_pairwise_rf this function returns only the values associated 
to the best linkage phase configuration.
</p>


<h3>Value</h3>

<p>An object of class <code>mappoly.twopt2</code>
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Tetraploid example  
  all.mrk &lt;- make_seq_mappoly(tetra.solcap, 100:200)
  all.pairs &lt;- est_pairwise_rf2(input.seq = all.mrk, ncpus = 2)
  m &lt;- rf_list_to_matrix(all.pairs)
  plot(m, fact = 2)
  
</code></pre>

<hr>
<h2 id='est_rf_hmm'>Multipoint analysis using Hidden Markov Models in autopolyploids</h2><span id='topic+est_rf_hmm'></span><span id='topic+print.mappoly.map'></span><span id='topic+plot.mappoly.map'></span>

<h3>Description</h3>

<p>Performs the multipoint analysis proposed by <cite>Mollinari and
Garcia (2019)</cite> in a sequence of markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_rf_hmm(
  input.seq,
  input.ph = NULL,
  thres = 0.5,
  twopt = NULL,
  verbose = FALSE,
  tol = 1e-04,
  est.given.0.rf = FALSE,
  reestimate.single.ph.configuration = TRUE,
  high.prec = TRUE
)

## S3 method for class 'mappoly.map'
print(x, detailed = FALSE, ...)

## S3 method for class 'mappoly.map'
plot(
  x,
  left.lim = 0,
  right.lim = Inf,
  phase = TRUE,
  mrk.names = FALSE,
  cex = 1,
  config = "best",
  P = "Parent 1",
  Q = "Parent 2",
  xlim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_rf_hmm_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code></p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_input.ph">input.ph</code></td>
<td>
<p>an object of class <code>two.pts.linkage.phases</code>. 
If not available (default = NULL), it will be computed</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_thres">thres</code></td>
<td>
<p>LOD Score threshold used to determine if the linkage phases
compared via two-point analysis should be considered. Smaller 
values will result in smaller number of linkage phase 
configurations to be evaluated by the multipoint algorithm.</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_twopt">twopt</code></td>
<td>
<p>an object of class <code>mappoly.twopt</code>
containing two-point information</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, current progress is shown; if
<code>FALSE</code> (default), no output is produced</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (default = 1e-04)</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_est.given.0.rf">est.given.0.rf</code></td>
<td>
<p>logical. If TRUE returns a map forcing all
recombination fractions equals to 0 (1e-5, for internal use only. 
Default = FALSE)</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_reestimate.single.ph.configuration">reestimate.single.ph.configuration</code></td>
<td>
<p>logical. If <code>TRUE</code>
returns a map without re-estimating the map parameters for cases
where there is only one possible linkage phase configuration. 
This argument is intended to be used in a sequential map construction</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_high.prec">high.prec</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) uses high precision 
long double numbers in the HMM procedure</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_x">x</code></td>
<td>
<p>an object of the class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_detailed">detailed</code></td>
<td>
<p>logical. if TRUE, prints the linkage phase configuration and the marker 
position for all maps. If FALSE (default), prints a map summary</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_left.lim">left.lim</code></td>
<td>
<p>the left limit of the plot (in cM, default = 0).</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_right.lim">right.lim</code></td>
<td>
<p>the right limit of the plot (in cM, default = Inf, i.e., 
will print the entire map)</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_phase">phase</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) plots the phase configuration
for both parents</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_mrk.names">mrk.names</code></td>
<td>
<p>if TRUE, marker names are displayed (default = FALSE)</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_cex">cex</code></td>
<td>
<p>The magnification to be used for marker names</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_config">config</code></td>
<td>
<p>should be <code>'best'</code> or the position of the
configuration to be plotted. If <code>'best'</code>, plot the configuration
with the highest likelihood</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_p">P</code></td>
<td>
<p>a string containing the name of parent P</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_q">Q</code></td>
<td>
<p>a string containing the name of parent Q</p>
</td></tr>
<tr><td><code id="est_rf_hmm_+3A_xlim">xlim</code></td>
<td>
<p>range of the x-axis. If <code>xlim = NULL</code> (default) it uses the 
map range.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first enumerates a set of linkage phase configurations
based on two-point recombination fraction information using a threshold
provided by the user (argument <code>thresh</code>). After that, for each
configuration, it reconstructs the genetic map using the
HMM approach described in Mollinari and Garcia (2019). As result, it returns 
the multipoint likelihood for each configuration in form of LOD Score comparing 
each configuration to the most likely one. It is recommended to use a small number 
of markers (e.g. 50 markers for hexaploids) since the possible linkage 
phase combinations bounded only by the two-point information can be huge. 
Also, it can be quite sensible to small changes in <code>'thresh'</code>. 
For a large number of markers, please see <code><a href="#topic+est_rf_hmm_sequential">est_rf_hmm_sequential</a></code>.
</p>


<h3>Value</h3>

<p>A list of class <code>mappoly.map</code> with two elements: 
</p>
<p>i) info:  a list containing information about the map, regardless of the linkage phase configuration:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>number of markers</p>
</td></tr>
<tr><td><code>seq.num</code></td>
<td>
<p>a vector containing the (ordered) indices of markers in the map, 
according to the input file</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of markers in the map</p>
</td></tr>
<tr><td><code>seq.dose.p1</code></td>
<td>
<p>a vector containing the dosage in parent 1 for all markers in the map</p>
</td></tr>
<tr><td><code>seq.dose.p2</code></td>
<td>
<p>a vector containing the dosage in parent 2 for all markers in the map</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating the sequence (usually chromosome) each marker belongs 
as informed in the input file. If not available, 
<code>chrom = NULL</code></p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>physical position (usually in megabase) of the markers into the sequence</p>
</td></tr>
<tr><td><code>seq.ref</code></td>
<td>
<p>reference base used for each marker (i.e. A, T, C, G). If not available, 
<code>seq.ref = NULL</code></p>
</td></tr>                 
<tr><td><code>seq.alt</code></td>
<td>
<p>alternative base used for each marker (i.e. A, T, C, G). If not available, 
<code>seq.ref = NULL</code></p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>a vector containing p-values of the chi-squared test of Mendelian 
segregation for all markers in the map</p>
</td></tr>                 
<tr><td><code>data.name</code></td>
<td>
<p>name of the dataset of class <code>mappoly.data</code></p>
</td></tr>
<tr><td><code>ph.thres</code></td>
<td>
<p>the LOD threshold used to define the linkage phase configurations to test</p>
</td></tr>
</table>
<p>ii) a list of maps with possible linkage phase configuration. Each map in the list is also a 
list containing
</p>
<table role = "presentation">
<tr><td><code>seq.num</code></td>
<td>
<p>a vector containing the (ordered) indices of markers in the map, 
according to the input file</p>
</td></tr>
<tr><td><code>seq.rf</code></td>
<td>
<p>a vector of size (<code>n.mrk - 1</code>) containing a sequence of recombination 
fraction between the adjacent markers in the map</p>
</td></tr>
<tr><td><code>seq.ph</code></td>
<td>
<p>linkage phase configuration for all markers in both parents</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>the hmm-based multipoint likelihood</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
https://doi.org/10.1534/g3.119.400378
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    mrk.subset &lt;- make_seq_mappoly(hexafake, 1:10)
    red.mrk &lt;- elim_redundant(mrk.subset)
    unique.mrks &lt;- make_seq_mappoly(red.mrk)
    subset.pairs &lt;- est_pairwise_rf(input.seq = unique.mrks,
                                  ncpus = 1,
                                  verbose = TRUE)

    ## Estimating subset map with a low tolerance for the E.M. procedure
    ## for CRAN testing purposes
    subset.map &lt;- est_rf_hmm(input.seq = unique.mrks,
                             thres = 2,
                             twopt = subset.pairs,
                             verbose = TRUE,
                             tol = 0.1,
                             est.given.0.rf = FALSE)
    subset.map
    ## linkage phase configuration with highest likelihood
    plot(subset.map, mrk.names = TRUE, config = "best")
    ## the second one
    plot(subset.map, mrk.names = TRUE, config = 2)

</code></pre>

<hr>
<h2 id='est_rf_hmm_sequential'>Multipoint analysis using Hidden Markov Models: Sequential phase elimination</h2><span id='topic+est_rf_hmm_sequential'></span>

<h3>Description</h3>

<p>Performs the multipoint analysis proposed by <cite>Mollinari and
Garcia (2019)</cite> in a sequence of markers removing unlikely phases
using sequential multipoint information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_rf_hmm_sequential(
  input.seq,
  twopt,
  start.set = 4,
  thres.twopt = 5,
  thres.hmm = 50,
  extend.tail = NULL,
  phase.number.limit = 20,
  sub.map.size.diff.limit = Inf,
  info.tail = TRUE,
  reestimate.single.ph.configuration = FALSE,
  tol = 0.1,
  tol.final = 0.001,
  verbose = TRUE,
  detailed.verbose = FALSE,
  high.prec = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_rf_hmm_sequential_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code></p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_twopt">twopt</code></td>
<td>
<p>an object of class <code>mappoly.twopt</code>
containing the two-point information</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_start.set">start.set</code></td>
<td>
<p>number of markers to start the phasing procedure (default = 4)</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_thres.twopt">thres.twopt</code></td>
<td>
<p>the LOD threshold used to determine if the linkage
phases compared via two-point analysis should be considered 
for the search space reduction (A.K.A. <code class="reqn">\eta</code> in 
<cite>Mollinari and Garcia (2019)</cite>, default = 5)</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_thres.hmm">thres.hmm</code></td>
<td>
<p>the LOD threshold used to determine if the linkage
phases compared via hmm analysis should be evaluated in the 
next round of marker inclusion (default = 50)</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_extend.tail">extend.tail</code></td>
<td>
<p>the length of the chain's tail that should
be used to calculate the likelihood of the map. If <code>NULL</code> (default), 
the function uses all markers positioned. Even if <code>info.tail = TRUE</code>, 
it uses at least <code>extend.tail</code> as the tail length</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_phase.number.limit">phase.number.limit</code></td>
<td>
<p>the maximum number of linkage phases of the sub-maps defined 
by arguments <code>info.tail</code> and <code>extend.tail</code>. Default is 20. If the
size exceeds this limit, the marker will not be inserted. If
<code>Inf</code>, then it will insert all markers.</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_sub.map.size.diff.limit">sub.map.size.diff.limit</code></td>
<td>
<p>the maximum accepted length
difference between the current and the previous sub-map defined 
by arguments <code>info.tail</code> and <code>extend.tail</code>. If the
size exceeds this limit, the marker will not be inserted. If
<code>NULL</code>(default), then it will insert all markers.</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_info.tail">info.tail</code></td>
<td>
<p>if <code>TRUE</code> (default), it uses the complete informative tail
of the chain (i.e. number of markers where all homologous 
(<code class="reqn">ploidy x 2</code>) can be distinguished) to calculate the map likelihood</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_reestimate.single.ph.configuration">reestimate.single.ph.configuration</code></td>
<td>
<p>logical. If <code>FALSE</code> (default)
returns a map without re-estimating the map parameters in cases
where there are only one possible linkage phase configuration</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy during the sequential phase (default = 10e-02)</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_tol.final">tol.final</code></td>
<td>
<p>the desired accuracy for the final map (default = 10e-04)</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_detailed.verbose">detailed.verbose</code></td>
<td>
<p>If <code>TRUE</code>, the expansion of the current 
submap is shown;</p>
</td></tr>
<tr><td><code id="est_rf_hmm_sequential_+3A_high.prec">high.prec</code></td>
<td>
<p>logical. If <code>TRUE</code> uses high precision 
(long double) numbers in the HMM procedure implemented in C++,
which can take a long time to perform (default = FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sequentially includes markers into a map given an
ordered sequence. It uses two-point information to eliminate
unlikely linkage phase configurations given <code>thres.twopt</code>. The
search is made within a window of size <code>extend.tail</code>. For the
remaining configurations, the HMM-based likelihood is computed and
the ones that pass the HMM threshold (<code>thres.hmm</code>) are eliminated.
</p>


<h3>Value</h3>

<p>A list of class <code>mappoly.map</code> with two elements: 
</p>
<p>i) info:  a list containing information about the map, regardless of the linkage phase configuration:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>number of markers</p>
</td></tr>
<tr><td><code>seq.num</code></td>
<td>
<p>a vector containing the (ordered) indices of markers in the map, 
according to the input file</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of markers in the map</p>
</td></tr>
<tr><td><code>seq.dose.p1</code></td>
<td>
<p>a vector containing the dosage in parent 1 for all markers in the map</p>
</td></tr>
<tr><td><code>seq.dose.p2</code></td>
<td>
<p>a vector containing the dosage in parent 2 for all markers in the map</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating the sequence (usually chromosome) each marker belongs 
as informed in the input file. If not available, 
<code>chrom = NULL</code></p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>physical position (usually in megabase) of the markers into the sequence</p>
</td></tr>
<tr><td><code>seq.ref</code></td>
<td>
<p>reference base used for each marker (i.e. A, T, C, G). If not available, 
<code>seq.ref = NULL</code></p>
</td></tr>
<tr><td><code>seq.alt</code></td>
<td>
<p>alternative base used for each marker (i.e. A, T, C, G). If not available, 
<code>seq.ref = NULL</code></p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>a vector containing p-values of the chi-squared test of Mendelian 
segregation for all markers in the map</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the dataset of class <code>mappoly.data</code></p>
</td></tr>
<tr><td><code>ph.thres</code></td>
<td>
<p>the LOD threshold used to define the linkage phase configurations to test</p>
</td></tr>
</table>
<p>ii) a list of maps with possible linkage phase configuration. Each map in the list is also a 
list containing
</p>
<table role = "presentation">
<tr><td><code>seq.num</code></td>
<td>
<p>a vector containing the (ordered) indices of markers in the map, 
according to the input file</p>
</td></tr>
<tr><td><code>seq.rf</code></td>
<td>
<p>a vector of size (<code>n.mrk - 1</code>) containing a sequence of recombination 
fraction between the adjacent markers in the map</p>
</td></tr>
<tr><td><code>seq.ph</code></td>
<td>
<p>linkage phase configuration for all markers in both parents</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>the hmm-based multipoint likelihood</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
    mrk.subset &lt;- make_seq_mappoly(hexafake, 1:20)
    red.mrk &lt;- elim_redundant(mrk.subset)
    unique.mrks &lt;- make_seq_mappoly(red.mrk)
    subset.pairs &lt;- est_pairwise_rf(input.seq = unique.mrks,
                                  ncpus = 1,
                                  verbose = TRUE)
    subset.map &lt;- est_rf_hmm_sequential(input.seq = unique.mrks,
                                        thres.twopt = 5,
                                        thres.hmm = 10,
                                        extend.tail = 10,
                                        tol = 0.1,
                                        tol.final = 10e-3,
                                        phase.number.limit = 5,
                                        twopt = subset.pairs,
                                        verbose = TRUE)
     print(subset.map, detailed = TRUE)
     plot(subset.map)
     plot(subset.map, left.lim = 0, right.lim = 1, mrk.names = TRUE)
     plot(subset.map, phase = FALSE)
     
     ## Retrieving simulated linkage phase
     ph.P &lt;- maps.hexafake[[1]]$maps[[1]]$seq.ph$P
     ph.Q &lt;- maps.hexafake[[1]]$maps[[1]]$seq.ph$Q
     ## Estimated linkage phase
     ph.P.est &lt;- subset.map$maps[[1]]$seq.ph$P
     ph.Q.est &lt;- subset.map$maps[[1]]$seq.ph$Q
     compare_haplotypes(ploidy = 6, h1 = ph.P[names(ph.P.est)], h2 = ph.P.est)
     compare_haplotypes(ploidy = 6, h1 = ph.Q[names(ph.Q.est)], h2 = ph.Q.est)
   

</code></pre>

<hr>
<h2 id='est_rf_hmm_single_phase'>Multipoint analysis using Hidden Markov Models (single phase)</h2><span id='topic+est_rf_hmm_single_phase'></span>

<h3>Description</h3>

<p>Multipoint analysis using Hidden Markov Models (single phase)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_rf_hmm_single_phase(
  input.seq,
  input.ph.single,
  rf.temp = NULL,
  tol,
  verbose = FALSE,
  ret.map.no.rf.estimation = FALSE,
  high.prec = TRUE,
  max.rf.to.break.EM = 0.5
)
</code></pre>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>

<hr>
<h2 id='est_rf_hmm_single_phase_single_parent'>Multilocus analysis using Hidden Markov Models (single parent, single phase)</h2><span id='topic+est_rf_hmm_single_phase_single_parent'></span>

<h3>Description</h3>

<p>Multilocus analysis using Hidden Markov Models (single parent, single phase)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_rf_hmm_single_phase_single_parent(
  input.seq,
  input.ph.single,
  info.parent = 1,
  uninfo.parent = 2,
  rf.vec = NULL,
  global.err = 0,
  tol = 0.001,
  verbose = FALSE,
  ret.map.no.rf.estimation = FALSE
)
</code></pre>

<hr>
<h2 id='export_data_to_polymapR'>Export data to <code>polymapR</code></h2><span id='topic+export_data_to_polymapR'></span>

<h3>Description</h3>

<p>See examples at <a href="https://rpubs.com/mmollin/tetra_mappoly_vignette">https://rpubs.com/mmollin/tetra_mappoly_vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_data_to_polymapR(data.in)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_data_to_polymapR_+3A_data.in">data.in</code></td>
<td>
<p>an object of class <code>mappoly.data</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dosage <code>matrix</code>
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>

<hr>
<h2 id='export_map_list'>Export a genetic map to a CSV file</h2><span id='topic+export_map_list'></span>

<h3>Description</h3>

<p>Function to export genetic linkage map(s) generated by <code>MAPpoly</code>.
The map(s) should be passed as a single object or a list of objects of class <code>mappoly.map</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_map_list(map.list, file = "map_output.csv")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_map_list_+3A_map.list">map.list</code></td>
<td>
<p>A list of objects or a single object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="export_map_list_+3A_file">file</code></td>
<td>
<p>either a character string naming a file or a connection open for writing. 
&quot;&quot; indicates output to the console.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> export_map_list(solcap.err.map[[1]], file = "")

</code></pre>

<hr>
<h2 id='export_qtlpoly'>Export to QTLpoly</h2><span id='topic+export_qtlpoly'></span>

<h3>Description</h3>

<p>Compute homolog probabilities for all individuals in the full-sib
population given a map and conditional genotype probabilities, and exports
the results to be used for QTL mapping in the QTLpoly package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_qtlpoly(input.genoprobs, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_qtlpoly_+3A_input.genoprobs">input.genoprobs</code></td>
<td>
<p>an object of class <code>mappoly.genoprob</code></p>
</td></tr>
<tr><td><code id="export_qtlpoly_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari M., Olukolu B. A.,  Pereira G. da S., 
Khan A., Gemenet D., Yencho G. C., Zeng Z-B. (2020), 
Unraveling the Hexaploid Sweetpotato Inheritance 
Using Ultra-Dense Multilocus Mapping, 
_G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400620">doi:10.1534/g3.119.400620</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
     ## tetraploid example
     w1 &lt;- calc_genoprob(solcap.dose.map[[1]])
     h.prob &lt;- export_qtlpoly(w1)
  

</code></pre>

<hr>
<h2 id='extract_map'>Extract the maker position from an object of class 'mappoly.map'</h2><span id='topic+extract_map'></span>

<h3>Description</h3>

<p>Extract the maker position from an object of class 'mappoly.map'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_map(input.map, phase.config = "best")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_map_+3A_input.map">input.map</code></td>
<td>
<p>An object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="extract_map_+3A_phase.config">phase.config</code></td>
<td>
<p>which phase configuration should be used. &quot;best&quot; (default) 
will choose the maximum likelihood configuration</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- maps.hexafake[[1]]$info$genome.pos/1e6
 y &lt;- extract_map(maps.hexafake[[1]])
 plot(y~x, ylab = "Map position (cM)", xlab = "Genome Position (Mbp)")
</code></pre>

<hr>
<h2 id='filter_aneuploid'>Filter aneuploid chromosomes from progeny individuals</h2><span id='topic+filter_aneuploid'></span>

<h3>Description</h3>

<p>Filter aneuploid chromosomes from progeny individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_aneuploid(input.data, aneuploid.info, ploidy, rm_missing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_aneuploid_+3A_input.data">input.data</code></td>
<td>
<p>name of input object (class <code>mappoly.data</code>)</p>
</td></tr>
<tr><td><code id="filter_aneuploid_+3A_aneuploid.info">aneuploid.info</code></td>
<td>
<p>data.frame with ploidy information by chromosome (columns) for each individual
in progeny (rows). The chromosome and individuals names must match the ones in the file used as input
in mappoly.</p>
</td></tr>
<tr><td><code id="filter_aneuploid_+3A_ploidy">ploidy</code></td>
<td>
<p>main ploidy</p>
</td></tr>
<tr><td><code id="filter_aneuploid_+3A_rm_missing">rm_missing</code></td>
<td>
<p>remove also genotype information from chromosomes with missing data (NA) in the aneuploid.info file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>mappoly.data</code>
</p>


<h3>Author(s)</h3>

<p>Cristiane Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     aneuploid.info &lt;- matrix(4, nrow=tetra.solcap$n.ind, ncol = 12)
     set.seed(8080)
     aneuploid.info[sample(1:length(aneuploid.info), round((4*length(aneuploid.info))/100),0)] &lt;- 3
     aneuploid.info[sample(1:length(aneuploid.info), round((4*length(aneuploid.info))/100),0)] &lt;- 5

     colnames(aneuploid.info) &lt;- paste0(1:12)
     aneuploid.info &lt;- cbind(inds = tetra.solcap$ind.names, aneuploid.info)

     filt.dat &lt;- filter_aneuploid(input.data = tetra.solcap, 
     aneuploid.info = aneuploid.info, ploidy = 4)

</code></pre>

<hr>
<h2 id='filter_individuals'>Filter out individuals</h2><span id='topic+filter_individuals'></span>

<h3>Description</h3>

<p>This function removes individuals from the data set. Individuals can be
user-defined or can be accessed via interactive kinship analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_individuals(
  input.data,
  ind.to.remove = NULL,
  inter = TRUE,
  type = c("Gmat", "PCA"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_individuals_+3A_input.data">input.data</code></td>
<td>
<p>name of input object (class <code>mappoly.data</code>)</p>
</td></tr>
<tr><td><code id="filter_individuals_+3A_ind.to.remove">ind.to.remove</code></td>
<td>
<p>individuals to be removed. If <code>NULL</code> it opens
an interactive graphic to proceed with the individual
selection</p>
</td></tr>
<tr><td><code id="filter_individuals_+3A_inter">inter</code></td>
<td>
<p>if <code>TRUE</code>, expects user-input to proceed with filtering</p>
</td></tr>
<tr><td><code id="filter_individuals_+3A_type">type</code></td>
<td>
<p>A character string specifying the procedure to be used for 
detecting outlier offspring. Options include &quot;Gmat&quot;, which 
utilizes the genomic kinship matrix, and &quot;PCA&quot;, which employs 
principal component analysis on the dosage matrix.
</p>
<p>coefficient (or covariance) is to be computed. One of &quot;pearson&quot; (default), &quot;kendall&quot;, or &quot;spearman&quot;: can be abbreviated.</p>
</td></tr>
<tr><td><code id="filter_individuals_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), shows the filtered out individuals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>

<hr>
<h2 id='filter_map_at_hmm_thres'>Filter MAPpoly Map Configurations by Loglikelihood Threshold</h2><span id='topic+filter_map_at_hmm_thres'></span>

<h3>Description</h3>

<p>This function filters configurations within a '&quot;mappoly.map&quot;' object based on a specified 
log-likelihood threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_map_at_hmm_thres(map, thres.hmm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_map_at_hmm_thres_+3A_map">map</code></td>
<td>
<p>An object of class '&quot;mappoly.map&quot;', which may contain several maps 
with different linkage phase configurations and their respective log-likelihoods.</p>
</td></tr>
<tr><td><code id="filter_map_at_hmm_thres_+3A_thres.hmm">thres.hmm</code></td>
<td>
<p>The threshold for filtering configurations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the modified '&quot;mappoly.map&quot;' object with configurations filtered 
based on the log-likelihood threshold.
</p>

<hr>
<h2 id='filter_missing'>Filter missing genotypes</h2><span id='topic+filter_missing'></span>

<h3>Description</h3>

<p>Excludes markers or individuals based on their proportion of missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_missing(
  input.data,
  type = c("marker", "individual"),
  filter.thres = 0.2,
  inter = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_missing_+3A_input.data">input.data</code></td>
<td>
<p>an object of class <code>mappoly.data</code>.</p>
</td></tr>
<tr><td><code id="filter_missing_+3A_type">type</code></td>
<td>
<p>one of the following options:
</p>

<ol>
<li> <p><code>"marker"</code>: filter out markers based on their percentage of missing data (default).
</p>
</li>
<li> <p><code>"individual"</code>: filter out individuals based on their percentage of missing data.
</p>
</li></ol>

<p>Please notice that removing individuals with certain amount of data can change some marker parameters
(such as depth), and can also change the estimated genotypes for other individuals.
So, be careful when removing individuals.</p>
</td></tr>
<tr><td><code id="filter_missing_+3A_filter.thres">filter.thres</code></td>
<td>
<p>maximum percentage of missing data (default = 0.2).</p>
</td></tr>
<tr><td><code id="filter_missing_+3A_inter">inter</code></td>
<td>
<p>if <code>TRUE</code>, expects user-input to proceed with filtering.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(tetra.solcap)
dat.filt.mrk &lt;- filter_missing(input.data = tetra.solcap,
                               type = "marker",
                               filter.thres = 0.1,
                               inter = TRUE)
plot(dat.filt.mrk)

</code></pre>

<hr>
<h2 id='filter_missing_ind'>Filter individuals based on missing genotypes</h2><span id='topic+filter_missing_ind'></span>

<h3>Description</h3>

<p>Filter individuals based on missing genotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_missing_ind(input.data, filter.thres = 0.2, inter = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_missing_ind_+3A_input.data">input.data</code></td>
<td>
<p>an object of class <code>"mappoly.data"</code></p>
</td></tr>
<tr><td><code id="filter_missing_ind_+3A_filter.thres">filter.thres</code></td>
<td>
<p>maximum percentage of missing data</p>
</td></tr>
<tr><td><code id="filter_missing_ind_+3A_inter">inter</code></td>
<td>
<p>if <code>TRUE</code>, expects user-input to proceed with filtering</p>
</td></tr>
</table>

<hr>
<h2 id='filter_missing_mrk'>Filter markers based on missing genotypes</h2><span id='topic+filter_missing_mrk'></span>

<h3>Description</h3>

<p>Filter markers based on missing genotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_missing_mrk(input.data, filter.thres = 0.2, inter = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_missing_mrk_+3A_input.data">input.data</code></td>
<td>
<p>an object of class <code>"mappoly.data"</code></p>
</td></tr>
<tr><td><code id="filter_missing_mrk_+3A_filter.thres">filter.thres</code></td>
<td>
<p>maximum percentage of missing data</p>
</td></tr>
<tr><td><code id="filter_missing_mrk_+3A_inter">inter</code></td>
<td>
<p>if <code>TRUE</code>, expects user-input to proceed with filtering</p>
</td></tr>
</table>

<hr>
<h2 id='filter_non_conforming_classes'>Filter non-conforming classes in F1, non double reduced population.</h2><span id='topic+filter_non_conforming_classes'></span>

<h3>Description</h3>

<p>Filter non-conforming classes in F1, non double reduced population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_non_conforming_classes(input.data, prob.thres = NULL)
</code></pre>

<hr>
<h2 id='filter_segregation'>Filter markers based on chi-square test</h2><span id='topic+filter_segregation'></span>

<h3>Description</h3>

<p>This function filter markers based on p-values of a chi-square test.
The chi-square test assumes that markers follow the expected segregation
patterns under Mendelian inheritance, random chromosome bivalent
pairing and no double reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_segregation(input.obj, chisq.pval.thres = NULL, inter = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_segregation_+3A_input.obj">input.obj</code></td>
<td>
<p>name of input object (class <code>mappoly.data</code>)</p>
</td></tr>
<tr><td><code id="filter_segregation_+3A_chisq.pval.thres">chisq.pval.thres</code></td>
<td>
<p>p-value threshold used for chi-square tests
(default = Bonferroni aproximation with global alpha of 0.05, i.e.,
0.05/n.mrk)</p>
</td></tr>
<tr><td><code id="filter_segregation_+3A_inter">inter</code></td>
<td>
<p>if TRUE (default), plots distorted vs. non-distorted markers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mappoly.chitest.seq</code> which contains a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>keep</code></td>
<td>
<p>markers that follow Mendelian segregation pattern</p>
</td></tr>
<tr><td><code>exclude</code></td>
<td>
<p>markers with distorted segregation</p>
</td></tr>
<tr><td><code>chisq.pval.thres</code></td>
<td>
<p>threshold p-value used for chi-square tests</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>input dataset used to perform the chi-square tests</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mrks.chi.filt &lt;- filter_segregation(input.obj = tetra.solcap,
                                    chisq.pval.thres = 0.05/tetra.solcap$n.mrk,
                                    inter = TRUE)
seq.init &lt;- make_seq_mappoly(mrks.chi.filt)

</code></pre>

<hr>
<h2 id='find_blocks'>Allocate markers into linkage blocks</h2><span id='topic+find_blocks'></span>

<h3>Description</h3>

<p>Function to allocate markers into linkage blocks.  This is an 
EXPERIMENTAL FUNCTION and should be used with caution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_blocks(
  input.seq,
  clustering.type = c("rf", "genome"),
  rf.limit = 1e-04,
  genome.block.threshold = 10000,
  rf.mat = NULL,
  ncpus = 1,
  ph.thres = 3,
  phase.number.limit = 10,
  error = 0.05,
  verbose = TRUE,
  tol = 0.01,
  tol.err = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_blocks_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code>.</p>
</td></tr>
<tr><td><code id="find_blocks_+3A_clustering.type">clustering.type</code></td>
<td>
<p>if <code>'rf'</code>, it uses UPGMA clusterization based on 
the recombination fraction matrix to assemble blocks. Linkage blocks are 
assembled by cutting the clusterization tree at <code>rf.limit</code>. 
If <code>'genome'</code>, it splits the marker sequence at neighbor markers morre than 
<code>'genome.block.threshold'</code> apart.</p>
</td></tr>
<tr><td><code id="find_blocks_+3A_rf.limit">rf.limit</code></td>
<td>
<p>the maximum value to consider linked markers in
case of <code>'clustering.type = rf'</code></p>
</td></tr>
<tr><td><code id="find_blocks_+3A_genome.block.threshold">genome.block.threshold</code></td>
<td>
<p>the threshold to assume markers are in the same linkage block.
to be considered when allocating markers into blocks in case of <code>'clustering.type = genomee'</code></p>
</td></tr>
<tr><td><code id="find_blocks_+3A_rf.mat">rf.mat</code></td>
<td>
<p>an object of class <code>mappoly.rf.matrix</code>.</p>
</td></tr>
<tr><td><code id="find_blocks_+3A_ncpus">ncpus</code></td>
<td>
<p>Number of parallel processes to spawn</p>
</td></tr>
<tr><td><code id="find_blocks_+3A_ph.thres">ph.thres</code></td>
<td>
<p>the threshold used to sequentially phase markers. 
Used in <code>thres.twopt</code> and <code>thres.hmm</code>. See <code><a href="#topic+est_rf_hmm_sequential">est_rf_hmm_sequential</a></code> 
for details.</p>
</td></tr>
<tr><td><code id="find_blocks_+3A_phase.number.limit">phase.number.limit</code></td>
<td>
<p>the maximum number of linkage phases of the sub-maps.
The default is 10. See <code><a href="#topic+est_rf_hmm_sequential">est_rf_hmm_sequential</a></code> for details.</p>
</td></tr>
<tr><td><code id="find_blocks_+3A_error">error</code></td>
<td>
<p>the assumed global genotyping error rate. If <code>NULL</code> (default) it does 
not include an error in the block estimation.</p>
</td></tr>
<tr><td><code id="find_blocks_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="find_blocks_+3A_tol">tol</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to
evaluate convergence.</p>
</td></tr>
<tr><td><code id="find_blocks_+3A_tol.err">tol.err</code></td>
<td>
<p>tolerance for the C routine, i.e., the value used to
evaluate convergence, including the global genotyping error in the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing 1: a list of blocks in form of <code>mappoly.map</code> objects;
2: a vector containing markers that were not included into blocks.
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  ## Selecting 50 markers in chromosome 5
  s5 &lt;- make_seq_mappoly(tetra.solcap, "seq5")
  s5 &lt;- make_seq_mappoly(tetra.solcap, s5$seq.mrk.names[1:50])
  tpt5 &lt;- est_pairwise_rf(s5)
  m5 &lt;- rf_list_to_matrix(tpt5, 3, 3)
  fb.rf &lt;- find_blocks(s5, rf.mat = m5, verbose = FALSE, ncpus = 2)
  bl.rf &lt;- fb.rf$blocks
  plot_map_list(bl.rf)
  
  ## Merging resulting maps
  map.merge &lt;- merge_maps(bl.rf, tpt5)
  plot(map.merge, mrk.names = T)
  
  ## Comparing linkage phases with pre assembled map
  id &lt;- na.omit(match(map.merge$info$mrk.names, solcap.err.map[[5]]$info$mrk.names))
  map.orig &lt;- get_submap(solcap.err.map[[5]], mrk.pos = id)
  p1.m&lt;-map.merge$maps[[1]]$seq.ph$P
  p2.m&lt;-map.merge$maps[[1]]$seq.ph$Q
  names(p1.m) &lt;- names(p2.m) &lt;- map.merge$info$mrk.names
  p1.o&lt;-map.orig$maps[[1]]$seq.ph$P
  p2.o&lt;-map.orig$maps[[1]]$seq.ph$Q
  names(p1.o) &lt;- names(p2.o) &lt;- map.orig$info$mrk.names
  n &lt;- intersect(names(p1.m), names(p1.o))
  plot_compare_haplotypes(4, p1.o[n], p2.o[n], p1.m[n], p2.m[n])
  
  ### Using genome
  fb.geno &lt;- find_blocks(s5, clustering.type = "genome", genome.block.threshold = 10^4)
  plot_map_list(fb.geno$blocks)
  splt &lt;- lapply(fb.geno$blocks, split_mappoly, 1)
  plot_map_list(splt)

## End(Not run)
</code></pre>

<hr>
<h2 id='format_rf'>Format results from pairwise two-point estimation in C++</h2><span id='topic+format_rf'></span>

<h3>Description</h3>

<p>Format results from pairwise two-point estimation in C++
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_rf(res)
</code></pre>

<hr>
<h2 id='framework_map'>Design linkage map framework in two steps: i) estimating the recombination fraction with 
HMM approach for each parent separately using only markers segregating individually 
(e.g. map 1 - P1:3 x P2:0, P1: 2x4; map 2 - P1:0 x P2:3, P1:4 x P2:2); ii) merging both 
maps and re-estimate recombination fractions.</h2><span id='topic+framework_map'></span>

<h3>Description</h3>

<p>Design linkage map framework in two steps: i) estimating the recombination fraction with 
HMM approach for each parent separately using only markers segregating individually 
(e.g. map 1 - P1:3 x P2:0, P1: 2x4; map 2 - P1:0 x P2:3, P1:4 x P2:2); ii) merging both 
maps and re-estimate recombination fractions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>framework_map(
  input.seq,
  twopt,
  start.set = 10,
  thres.twopt = 10,
  thres.hmm = 30,
  extend.tail = 30,
  inflation.lim.p1 = 5,
  inflation.lim.p2 = 5,
  phase.number.limit = 10,
  tol = 0.01,
  tol.final = 0.001,
  verbose = TRUE,
  method = "hmm"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="framework_map_+3A_input.seq">input.seq</code></td>
<td>
<p>object of class <code>mappoly.sequence</code></p>
</td></tr>
<tr><td><code id="framework_map_+3A_twopt">twopt</code></td>
<td>
<p>object of class <code>mappoly.twopt</code></p>
</td></tr>
<tr><td><code id="framework_map_+3A_start.set">start.set</code></td>
<td>
<p>number of markers to start the phasing procedure (default = 4)</p>
</td></tr>
<tr><td><code id="framework_map_+3A_thres.twopt">thres.twopt</code></td>
<td>
<p>the LOD threshold used to determine if the linkage phases compared via two-point 
analysis should be considered for the search space reduction (default = 5)</p>
</td></tr>
<tr><td><code id="framework_map_+3A_thres.hmm">thres.hmm</code></td>
<td>
<p>the LOD threshold used to determine if the linkage phases compared via hmm analysis 
should be evaluated in the next round of marker inclusion (default = 50)</p>
</td></tr>
<tr><td><code id="framework_map_+3A_extend.tail">extend.tail</code></td>
<td>
<p>the length of the chain's tail that should be used to calculate the likelihood of 
the map. If NULL (default), the function uses all markers positioned. Even if info.tail = TRUE, 
it uses at least extend.tail as the tail length</p>
</td></tr>
<tr><td><code id="framework_map_+3A_inflation.lim.p1">inflation.lim.p1</code></td>
<td>
<p>the maximum accepted length difference between the current and the previous 
parent 1 sub-map defined by arguments info.tail and extend.tail. If the size exceeds this limit, the marker will 
not be inserted. If NULL(default), then it will insert all markers.</p>
</td></tr>
<tr><td><code id="framework_map_+3A_inflation.lim.p2">inflation.lim.p2</code></td>
<td>
<p>same as 'inflation.lim.p1' but for parent 2 sub-map.</p>
</td></tr>
<tr><td><code id="framework_map_+3A_phase.number.limit">phase.number.limit</code></td>
<td>
<p>the maximum number of linkage phases of the sub-maps defined by arguments info.tail 
and extend.tail. Default is 20. If the size exceeds this limit, the marker will not be inserted. If Inf, 
then it will insert all markers.</p>
</td></tr>
<tr><td><code id="framework_map_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy during the sequential phase of each parental map (default = 10e-02)</p>
</td></tr>
<tr><td><code id="framework_map_+3A_tol.final">tol.final</code></td>
<td>
<p>the desired accuracy for the final parental map (default = 10e-04)</p>
</td></tr>
<tr><td><code id="framework_map_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE (default), current progress is shown; if FALSE, no output is produced</p>
</td></tr>
<tr><td><code id="framework_map_+3A_method">method</code></td>
<td>
<p>indicates whether to use 'hmm' (Hidden Markov Models), 'ols' (Ordinary Least Squares) 
to re-estimate the recombination fractions while merging the parental maps (default:hmm)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing three <code>mappoly.map</code> objects:1) map built with markers with segregation information from parent 1; 
2) map built with markers with segregation information from parent 2; 3) maps in 1 and 2 merged
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a> with documentation and minor modifications by Cristiane Taniguti <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>

<hr>
<h2 id='generate_all_link_phase_elim_equivalent'>Generate all possible linkage phases in matrix form given the dose
and the number of shared alleles between a inserted marker and a
pre-computed linkage configuration.</h2><span id='topic+generate_all_link_phase_elim_equivalent'></span>

<h3>Description</h3>

<p>Generate all possible linkage phases in matrix form given the dose
and the number of shared alleles between a inserted marker and a
pre-computed linkage configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_all_link_phase_elim_equivalent(X, d, sh, ploidy, k1, k2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_all_link_phase_elim_equivalent_+3A_x">X</code></td>
<td>
<p>a list of matrices whose columns represent homologous
chromosomes and the rows represent markers. Each element of the
list represents a linkage phase configuration.</p>
</td></tr>
<tr><td><code id="generate_all_link_phase_elim_equivalent_+3A_d">d</code></td>
<td>
<p>the dosage of the inserted marker</p>
</td></tr>
<tr><td><code id="generate_all_link_phase_elim_equivalent_+3A_sh">sh</code></td>
<td>
<p>the number of shared alleles between k1 (marker already
present on the sequence) and k2 (the inserted marker)</p>
</td></tr>
<tr><td><code id="generate_all_link_phase_elim_equivalent_+3A_ploidy">ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code id="generate_all_link_phase_elim_equivalent_+3A_k1">k1</code></td>
<td>
<p>marker already present on the sequence</p>
</td></tr>
<tr><td><code id="generate_all_link_phase_elim_equivalent_+3A_k2">k2</code></td>
<td>
<p>inserted marker</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a unique list of matrices representing linkage phases
</p>

<hr>
<h2 id='generate_all_link_phases_elim_equivalent_haplo'>Eliminate equivalent linkage phases</h2><span id='topic+generate_all_link_phases_elim_equivalent_haplo'></span>

<h3>Description</h3>

<p>Generates all possible linkage phases between two blocks of markers
(or a block and a marker), eliminating equivalent configurations, 
i.e. configurations with the same likelihood and also considering
the two-point information (shared alleles)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_all_link_phases_elim_equivalent_haplo(
  block1,
  block2,
  rf.matrix,
  ploidy,
  max.inc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_all_link_phases_elim_equivalent_haplo_+3A_block1">block1</code></td>
<td>
<p>submap with markers of the first block</p>
</td></tr>
<tr><td><code id="generate_all_link_phases_elim_equivalent_haplo_+3A_block2">block2</code></td>
<td>
<p>submap with markers of the second block, 
or just a single marker identified by its name</p>
</td></tr>
<tr><td><code id="generate_all_link_phases_elim_equivalent_haplo_+3A_rf.matrix">rf.matrix</code></td>
<td>
<p>matrix obtained with the function <code>rf_list_to_matrix</code>
using the parameter <code>shared.alleles = TRUE</code></p>
</td></tr>
<tr><td><code id="generate_all_link_phases_elim_equivalent_haplo_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy level (i.e. 4, 6 and so on)</p>
</td></tr>
<tr><td><code id="generate_all_link_phases_elim_equivalent_haplo_+3A_max.inc">max.inc</code></td>
<td>
<p>maximum number of allowed inconsistencies (default = NULL: don't check inconsistencies)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a> and Gabriel Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>

<hr>
<h2 id='genetic-mapping-functions'>Genetic Mapping Functions</h2><span id='topic+genetic-mapping-functions'></span><span id='topic+mf_k'></span><span id='topic+mf_h'></span><span id='topic+mf_m'></span><span id='topic+imf_k'></span><span id='topic+imf_h'></span><span id='topic+imf_m'></span>

<h3>Description</h3>

<p>These functions facilitate the conversion between recombination fractions (r) and genetic distances (d) 
using various mapping models. The functions starting with 'mf_' convert recombination fractions to genetic distances,
while those starting with 'imf_' convert genetic distances back into recombination fractions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mf_k(d)

mf_h(d)

mf_m(d)

imf_k(r)

imf_h(r)

imf_m(r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genetic-mapping-functions_+3A_d">d</code></td>
<td>
<p>Numeric or numeric vector, representing genetic distances in centiMorgans (cM) for direct functions (mf_k, mf_h, mf_m).</p>
</td></tr>
<tr><td><code id="genetic-mapping-functions_+3A_r">r</code></td>
<td>
<p>Numeric or numeric vector, representing recombination fractions for inverse functions (imf_k, imf_h, imf_m).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'mf_' prefixed functions apply different models to convert recombination fractions into genetic distances:
</p>

<ul>
<li> <p><code>mf_k</code>: Kosambi mapping function.
</p>
</li>
<li> <p><code>mf_h</code>: Haldane mapping function.
</p>
</li>
<li> <p><code>mf_m</code>: Morgan mapping function.
</p>
</li></ul>

<p>The 'imf_' prefixed functions convert genetic distances back into recombination fractions:
</p>

<ul>
<li> <p><code>imf_k</code>: Inverse Kosambi mapping function.
</p>
</li>
<li> <p><code>imf_h</code>: Inverse Haldane mapping function.
</p>
</li>
<li> <p><code>imf_m</code>: Inverse Morgan mapping function.
</p>
</li></ul>



<h3>References</h3>

<p>Kosambi, D.D. (1944). The estimation of map distances from recombination values. Ann Eugen., 12, 172-175.
Haldane, J.B.S. (1919). The combination of linkage values, and the calculation of distances between the loci of linked factors. J Genet, 8, 299-309.
Morgan, T.H. (1911). Random segregation versus coupling in Mendelian inheritance. Science, 34(873), 384.
</p>

<hr>
<h2 id='genotyping_global_error'>Prior probability for genotyping error</h2><span id='topic+genotyping_global_error'></span>

<h3>Description</h3>

<p>If <code>restricted = TRUE</code>, it restricts the prior to the 
possible classes under Mendelian, non double-reduced segregation 
given dosage of the parents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genotyping_global_error(
  x,
  ploidy,
  restricted = TRUE,
  error = 0.01,
  th.prob = 0.95
)
</code></pre>

<hr>
<h2 id='get_cache_two_pts_from_web'>Access a remote server to get Counts for recombinant classes</h2><span id='topic+get_cache_two_pts_from_web'></span>

<h3>Description</h3>

<p>Access a remote server to get Counts for recombinant classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cache_two_pts_from_web(
  ploidy,
  url.address = NULL,
  joint.prob = TRUE,
  verbose = FALSE
)
</code></pre>

<hr>
<h2 id='get_counts'>Counts for recombinant classes</h2><span id='topic+get_counts'></span>

<h3>Description</h3>

<p>Counts for recombinant classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_counts(
  ploidy,
  P.k = NULL,
  P.k1 = NULL,
  Q.k = NULL,
  Q.k1 = NULL,
  verbose = FALSE,
  make.names = FALSE,
  joint.prob = FALSE
)
</code></pre>

<hr>
<h2 id='get_counts_all_phases'>Counts for recombinant classes</h2><span id='topic+get_counts_all_phases'></span>

<h3>Description</h3>

<p>return the counts of each recombinant class (for two loci) in
polyploid cross. The results of this function contains several
matrices each one corresponding to one possible linkage phase. The
associated names in the matrices indicates the number of shared
homologous chromosomes. The row names indicates the dosage in loci
k and k+1 respectively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_counts_all_phases(
  x,
  ploidy,
  verbose = FALSE,
  make.names = FALSE,
  joint.prob = FALSE
)
</code></pre>

<hr>
<h2 id='get_counts_single_parent'>Counts for recombinant classes in a polyploid parent.</h2><span id='topic+get_counts_single_parent'></span>

<h3>Description</h3>

<p>The conditional probability of a genotype at locus <code class="reqn">k+1</code> given the genotype at locus
<code class="reqn">k</code> is ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_counts_single_parent(
  ploidy,
  gen.par.mk1,
  gen.par.mk2,
  gen.prog.mk1,
  gen.prog.mk2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_counts_single_parent_+3A_ploidy">ploidy</code></td>
<td>
<p>Ploidy level</p>
</td></tr>
<tr><td><code id="get_counts_single_parent_+3A_gen.par.mk1">gen.par.mk1</code></td>
<td>
<p>Genotype of marker mk1 (vector  <code class="reqn">x \in 0, \cdots, m</code>)</p>
</td></tr>
<tr><td><code id="get_counts_single_parent_+3A_gen.par.mk2">gen.par.mk2</code></td>
<td>
<p>Genotype of marker mk2 (vector  <code class="reqn">x \in 0, \cdots, m</code>)</p>
</td></tr>
<tr><td><code id="get_counts_single_parent_+3A_gen.prog.mk1">gen.prog.mk1</code></td>
<td>
<p>Dose of marker mk1 on progeny</p>
</td></tr>
<tr><td><code id="get_counts_single_parent_+3A_gen.prog.mk2">gen.prog.mk2</code></td>
<td>
<p>Dose of marker mk2 on progeny</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 object; a list consisting of
</p>
<table role = "presentation">
<tr><td><code>counts</code></td>
<td>
<p>counts for each one of the classes</p>
</td></tr>
</table>

<hr>
<h2 id='get_counts_two_parents'>Counts for recombinant classes</h2><span id='topic+get_counts_two_parents'></span>

<h3>Description</h3>

<p>Counts for recombinant classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_counts_two_parents(
  x = c(2, 2),
  ploidy,
  p.k,
  p.k1,
  q.k,
  q.k1,
  verbose = FALSE,
  joint.prob = FALSE
)
</code></pre>

<hr>
<h2 id='get_dosage_type'>Get Dosage Type in a Sequence</h2><span id='topic+get_dosage_type'></span>

<h3>Description</h3>

<p>Analyzes a genomic sequence object to categorize markers based on their dosage type.
The function calculates the dosage type by comparing the dosage of two parental sequences
(p1 and p2) against the ploidy level. It categorizes markers into simplex for parent 1 (simplex.p),
simplex for parent 2 (simplex.q), double simplex (ds), and multiplex based on the calculated dosages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dosage_type(input.seq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dosage_type_+3A_input.seq">input.seq</code></td>
<td>
<p>An object of class <code>"mappoly.sequence"</code>:</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with four components categorizing marker names into:
</p>

<dl>
<dt>simplex.p</dt><dd><p>Markers with a simplex dosage from parent 1.</p>
</dd>
<dt>simplex.q</dt><dd><p>Markers with a simplex dosage from parent 2.</p>
</dd>
<dt>double.simplex</dt><dd><p>Markers with a double simplex dosage.</p>
</dd>
<dt>multiplex</dt><dd><p>Markers not fitting into the above categories, indicating a multiplex dosage.</p>
</dd>
</dl>


<hr>
<h2 id='get_full_info_tail'>Get the tail of a marker sequence up to the point where the markers
provide no additional information.</h2><span id='topic+get_full_info_tail'></span>

<h3>Description</h3>

<p>Get the tail of a marker sequence up to the point where the markers
provide no additional information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_full_info_tail(input.obj, extend = NULL)
</code></pre>

<hr>
<h2 id='get_genomic_order'>Get the genomic position of markers in a sequence</h2><span id='topic+get_genomic_order'></span><span id='topic+print.mappoly.geno.ord'></span><span id='topic+plot.mappoly.geno.ord'></span>

<h3>Description</h3>

<p>This functions gets the genomic position of markers in a sequence and
return an ordered data frame with the name and position of each marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_genomic_order(input.seq, verbose = TRUE)

## S3 method for class 'mappoly.geno.ord'
print(x, ...)

## S3 method for class 'mappoly.geno.ord'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_genomic_order_+3A_input.seq">input.seq</code></td>
<td>
<p>a sequence object of class <code>mappoly.sequence</code></p>
</td></tr>
<tr><td><code id="get_genomic_order_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
<tr><td><code id="get_genomic_order_+3A_x">x</code></td>
<td>
<p>an object of the class mappoly.geno.ord</p>
</td></tr>
<tr><td><code id="get_genomic_order_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- make_seq_mappoly(tetra.solcap, "all")
o1 &lt;- get_genomic_order(s1)
plot(o1)
s.geno.ord &lt;- make_seq_mappoly(o1)
</code></pre>

<hr>
<h2 id='get_ij'>Given a pair of character indicating the numbers i and j : 'i-j',
returns a numeric pair c(i,j)</h2><span id='topic+get_ij'></span>

<h3>Description</h3>

<p>Given a pair of character indicating the numbers i and j : 'i-j',
returns a numeric pair c(i,j)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ij(w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_ij_+3A_w">w</code></td>
<td>
<p>a pair of characters 'i-j'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric pair c(i,j)
</p>

<hr>
<h2 id='get_indices_from_selected_phases'>Get the indices of selected linkage phases given a threshold</h2><span id='topic+get_indices_from_selected_phases'></span>

<h3>Description</h3>

<p>Get the indices of selected linkage phases given a threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_indices_from_selected_phases(x, thres)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_indices_from_selected_phases_+3A_x">x</code></td>
<td>
<p>a data frame containing information about two markers. In
this data frame, the lines indicate the possible configuration
phases and the columns indicate the LOD for configuration phase
(ph_LOD), the recombination fraction (rf), and the LOD for
recombination fraction (rf_LOD)</p>
</td></tr>
<tr><td><code id="get_indices_from_selected_phases_+3A_thres">thres</code></td>
<td>
<p>a threshold from which the linkage phases can be
discarded (if abs(ph_LOD) &gt; thres)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of indices for both parents
</p>

<hr>
<h2 id='get_LOD'>Extract the LOD Scores in a <code>'mappoly.map'</code> object</h2><span id='topic+get_LOD'></span>

<h3>Description</h3>

<p>Extract the LOD Scores in a <code>'mappoly.map'</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_LOD(x, sorted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_LOD_+3A_x">x</code></td>
<td>
<p>an object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="get_LOD_+3A_sorted">sorted</code></td>
<td>
<p>logical. if <code>TRUE</code>, the LOD Scores are displayed
in a decreasing order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector containing the LOD Scores
</p>

<hr>
<h2 id='get_ols_map'>Get weighted ordinary least squared map give a sequence and rf matrix</h2><span id='topic+get_ols_map'></span>

<h3>Description</h3>

<p>Get weighted ordinary least squared map give a sequence and rf matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ols_map(input.seq, input.mat, weight = TRUE)
</code></pre>

<hr>
<h2 id='get_ph_conf_ret_sh'>Given a homology group in matrix form, it returns the number shared
homologous for all pairs of markers in this group</h2><span id='topic+get_ph_conf_ret_sh'></span>

<h3>Description</h3>

<p>Given a homology group in matrix form, it returns the number shared
homologous for all pairs of markers in this group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ph_conf_ret_sh(M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_ph_conf_ret_sh_+3A_m">M</code></td>
<td>
<p>matrix whose columns represent homologous chromosomes and
the rows represent markers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the number of shared homologous for all
pairs of markers
</p>

<hr>
<h2 id='get_ph_list_subset'>subset of a linkage phase list</h2><span id='topic+get_ph_list_subset'></span>

<h3>Description</h3>

<p>subset of a linkage phase list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ph_list_subset(ph.list, seq.num, conf)
</code></pre>

<hr>
<h2 id='get_rf_from_list'>Get the recombination fraction for a sequence of markers given an
object of class <code>mappoly.twopt</code> and a list
containing the linkage phase configuration. This list can be found
in any object of class <code>two.pts.linkage.phases</code>, in
x$config.to.test$'Conf-i', where x is the object of class
<code>two.pts.linkage.phases</code> and i is one of the possible
configurations.</h2><span id='topic+get_rf_from_list'></span>

<h3>Description</h3>

<p>Get the recombination fraction for a sequence of markers given an
object of class <code>mappoly.twopt</code> and a list
containing the linkage phase configuration. This list can be found
in any object of class <code>two.pts.linkage.phases</code>, in
x$config.to.test$'Conf-i', where x is the object of class
<code>two.pts.linkage.phases</code> and i is one of the possible
configurations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rf_from_list(twopt, ph.list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_rf_from_list_+3A_twopt">twopt</code></td>
<td>
<p>an object of class <code>mappoly.twopt</code></p>
</td></tr>
<tr><td><code id="get_rf_from_list_+3A_ph.list">ph.list</code></td>
<td>
<p>a list containing the linkage phase configuration. This
list can be found in any object of class
<code>two.pts.linkage.phases</code>, in x$config.to.test$'Conf-i',
where x is the object of class <code>two.pts.linkage.phases</code>
and i is one of the possible configurations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the recombination fraction between markers
present in ph.list, for that specific order.
</p>

<hr>
<h2 id='get_rf_from_mat'>Get recombination fraction from a matrix</h2><span id='topic+get_rf_from_mat'></span>

<h3>Description</h3>

<p>Get recombination fraction from a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rf_from_mat(M)
</code></pre>

<hr>
<h2 id='get_states_and_emission_single_parent'>Get states and emission in one informative parent</h2><span id='topic+get_states_and_emission_single_parent'></span>

<h3>Description</h3>

<p>Get states and emission in one informative parent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_states_and_emission_single_parent(ploidy, ph, global.err, D, dose.notinf.P)
</code></pre>

<hr>
<h2 id='get_submap'>Extract sub-map from map</h2><span id='topic+get_submap'></span>

<h3>Description</h3>

<p>Given a pre-constructed map, it extracts a sub-map for a provided 
sequence of marker positions. Optionally, it can update the linkage phase
configurations and respective recombination fractions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_submap(
  input.map,
  mrk.pos,
  phase.config = "best",
  reestimate.rf = TRUE,
  reestimate.phase = FALSE,
  thres.twopt = 5,
  thres.hmm = 3,
  extend.tail = 50,
  tol = 0.1,
  tol.final = 0.001,
  use.high.precision = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_submap_+3A_input.map">input.map</code></td>
<td>
<p>An object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="get_submap_+3A_mrk.pos">mrk.pos</code></td>
<td>
<p>positions of the markers that should be considered in the new map. 
This can be in any order</p>
</td></tr>
<tr><td><code id="get_submap_+3A_phase.config">phase.config</code></td>
<td>
<p>which phase configuration should be used. &quot;best&quot; (default) 
will choose the configuration associated with the maximum 
likelihood</p>
</td></tr>
<tr><td><code id="get_submap_+3A_reestimate.rf">reestimate.rf</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) the recombination fractions 
between markers are re-estimated</p>
</td></tr>
<tr><td><code id="get_submap_+3A_reestimate.phase">reestimate.phase</code></td>
<td>
<p>logical. If <code>TRUE</code>, the linkage phase configurations are 
re-estimated (default = FALSE)</p>
</td></tr>
<tr><td><code id="get_submap_+3A_thres.twopt">thres.twopt</code></td>
<td>
<p>the LOD threshold used to determine if the linkage
phases compared via two-point analysis should be considered (default = 5)</p>
</td></tr>
<tr><td><code id="get_submap_+3A_thres.hmm">thres.hmm</code></td>
<td>
<p>the threshold used to determine if the linkage
phases compared via hmm analysis should be considered (default = 3)</p>
</td></tr>
<tr><td><code id="get_submap_+3A_extend.tail">extend.tail</code></td>
<td>
<p>the length of the tail of the chain that should
be used to calculate the likelihood of the linkage phases. If
<code>info.tail = TRUE</code>, the function uses at least <code>extend.tail</code>
as the length of the tail (default = 50)</p>
</td></tr>
<tr><td><code id="get_submap_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy during the sequential phase (default = 0.1)</p>
</td></tr>
<tr><td><code id="get_submap_+3A_tol.final">tol.final</code></td>
<td>
<p>the desired accuracy for the final map (default = 10e-04)</p>
</td></tr>
<tr><td><code id="get_submap_+3A_use.high.precision">use.high.precision</code></td>
<td>
<p>logical. If <code>TRUE</code> uses high precision 
(long double) numbers in the HMM procedure implemented in C++,
which can take a long time to perform (default = FALSE)</p>
</td></tr>
<tr><td><code id="get_submap_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
    ## selecting the six first markers in linkage group 1
    ## re-estimating the recombination fractions and linkage phases
    submap1.lg1 &lt;- get_submap(input.map = maps.hexafake[[1]], 
                           mrk.pos = 1:6, verbose = TRUE,
                           reestimate.phase = TRUE,  
                           tol.final = 10e-3)
   ## no recombination fraction re-estimation: first 20 markers
   submap2.lg1 &lt;- get_submap(input.map = maps.hexafake[[1]], 
                           mrk.pos = 1:20, reestimate.rf = FALSE,
                           verbose = TRUE, 
                           tol.final = 10e-3)
  plot(maps.hexafake[[1]])
  plot(submap1.lg1, mrk.names = TRUE, cex = .8)
  plot(submap2.lg1, mrk.names = TRUE, cex = .8)
  

</code></pre>

<hr>
<h2 id='get_tab_mrks'>Get table of dosage combinations</h2><span id='topic+get_tab_mrks'></span>

<h3>Description</h3>

<p>Internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tab_mrks(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_tab_mrks_+3A_x">x</code></td>
<td>
<p>an object of class <code>mappoly.map</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabriel Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>

<hr>
<h2 id='get_w_m'>Get the number of bivalent configurations</h2><span id='topic+get_w_m'></span>

<h3>Description</h3>

<p>Get the number of bivalent configurations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_w_m(ploidy)
</code></pre>

<hr>
<h2 id='gg_color_hue'>Color pallet ggplot-like</h2><span id='topic+gg_color_hue'></span>

<h3>Description</h3>

<p>Color pallet ggplot-like
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_color_hue(n)
</code></pre>

<hr>
<h2 id='group_mappoly'>Assign markers to linkage groups</h2><span id='topic+group_mappoly'></span>

<h3>Description</h3>

<p>Identifies linkage groups of markers using the results of two-point
(pairwise) analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_mappoly(
  input.mat,
  expected.groups = NULL,
  inter = TRUE,
  comp.mat = FALSE,
  LODweight = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_mappoly_+3A_input.mat">input.mat</code></td>
<td>
<p>an object of class <code>mappoly.rf.matrix</code></p>
</td></tr>
<tr><td><code id="group_mappoly_+3A_expected.groups">expected.groups</code></td>
<td>
<p>when available, inform the number of expected 
linkage groups (i.e. chromosomes) for the species</p>
</td></tr>
<tr><td><code id="group_mappoly_+3A_inter">inter</code></td>
<td>
<p>if <code>TRUE</code> (default), plots a dendrogram highlighting the
expected groups before continue</p>
</td></tr>
<tr><td><code id="group_mappoly_+3A_comp.mat">comp.mat</code></td>
<td>
<p>if <code>TRUE</code>, shows a comparison between the reference
based and the linkage based grouping, if the chromosome information is
available (default = FALSE)</p>
</td></tr>
<tr><td><code id="group_mappoly_+3A_lodweight">LODweight</code></td>
<td>
<p>if <code>TRUE</code>, clusterization is weighted by the square of the 
LOD Score</p>
</td></tr>
<tr><td><code id="group_mappoly_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), current progress is shown;
if <code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>mappoly.group</code>, which is a list
containing the following components:
</p>
<table role = "presentation">
<tr><td><code>data.name</code></td>
<td>
<p>the referred dataset name</p>
</td></tr>
<tr><td><code>hc.snp</code></td>
<td>
<p>a list containing information related to 
the UPGMA grouping method</p>
</td></tr>
<tr><td><code>expected.groups</code></td>
<td>
<p>the number of expected linkage groups</p>
</td></tr>
<tr><td><code>groups.snp</code></td>
<td>
<p>the groups to which each of the markers belong</p>
</td></tr>
<tr><td><code>seq.vs.grouped.snp</code></td>
<td>
<p>comparison between the genomic group information
(when available) and the groups provided by <code>group_mappoly</code></p>
</td></tr>
<tr><td><code>chisq.pval.thres</code></td>
<td>
<p>the threshold used on the segregation test when reading the dataset</p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>the p-values associated with the segregation test for all markers in the sequence</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## Getting first 20 markers from two linkage groups
    all.mrk &lt;- make_seq_mappoly(hexafake, c(1:20,601:620))
    red.mrk &lt;- elim_redundant(all.mrk)
    unique.mrks &lt;- make_seq_mappoly(red.mrk)
    counts &lt;- cache_counts_twopt(unique.mrks, cached = TRUE)
    all.pairs &lt;- est_pairwise_rf(input.seq = unique.mrks,
                                 count.cache = counts,
                                 ncpus = 1,
                                 verbose = TRUE)

    ## Full recombination fraction matrix
    mat.full &lt;- rf_list_to_matrix(input.twopt = all.pairs)
    plot(mat.full, index = FALSE)

    lgs &lt;- group_mappoly(input.mat = mat.full,
                         expected.groups = 2,
                         inter = TRUE,
                         comp.mat = TRUE, #this data has physical information
                         verbose = TRUE)
    lgs
    plot(lgs)
   
</code></pre>

<hr>
<h2 id='hexafake'>Simulated autohexaploid dataset.</h2><span id='topic+hexafake'></span>

<h3>Description</h3>

<p>A dataset of a hypothetical autohexaploid full-sib population 
containing three homology groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexafake
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mappoly.data</code> which contains a
list with the following components:
</p>

<dl>
<dt>plody</dt><dd><p>ploidy level = 6</p>
</dd>
<dt>n.ind</dt><dd><p>number individuals = 300</p>
</dd>
<dt>n.mrk</dt><dd><p>total number of markers = 1500</p>
</dd>
<dt>ind.names</dt><dd><p>the names of the individuals</p>
</dd>
<dt>mrk.names</dt><dd><p>the names of the markers</p>
</dd>
<dt>dosage.p1</dt><dd><p>a vector containing the dosage in
parent P for all <code>n.mrk</code> markers</p>
</dd>
<dt>dosage.p2</dt><dd><p>a vector containing the dosage in
parent Q for all <code>n.mrk</code> markers</p>
</dd>
<dt>chrom</dt><dd><p>a vector indicating the chromosome each marker
belongs. Zero indicates that the marker was not assigned to any
chromosome</p>
</dd>
<dt>genome.pos</dt><dd><p>Physical position of the markers into the
sequence</p>
</dd>
<dt>geno.dose</dt><dd><p>a matrix containing the dosage for each markers (rows) 
for each individual (columns). Missing data are represented by 
<code>ploidy_level + 1 = 7</code></p>
</dd>
<dt>n.phen</dt><dd><p>There are no phenotypes in this simulation</p>
</dd>
<dt>phen</dt><dd><p>There are no phenotypes in this simulation</p>
</dd>
<dt>chisq.pval</dt><dd><p>vector containing p-values for all markers associated to 
the chi-square test for the expected segregation patterns 
under Mendelian segregation</p>
</dd>
</dl>


<hr>
<h2 id='hexafake.geno.dist'>Simulated autohexaploid dataset with genotype probabilities.</h2><span id='topic+hexafake.geno.dist'></span>

<h3>Description</h3>

<p>A dataset of a hypothetical autohexaploid full-sib population 
containing three homology groups. This dataset contains the
probability distribution of the genotypes and 2% of missing data, 
but is essentially the same dataset found in <code><a href="#topic+hexafake">hexafake</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexafake.geno.dist
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mappoly.data</code> which contains a
list with the following components:
</p>

<dl>
<dt>ploidy</dt><dd><p>ploidy level = 6</p>
</dd>
<dt>n.ind</dt><dd><p>number individuals = 300</p>
</dd>
<dt>n.mrk</dt><dd><p>total number of markers = 1500</p>
</dd>
<dt>ind.names</dt><dd><p>the names of the individuals</p>
</dd>
<dt>mrk.names</dt><dd><p>the names of the markers</p>
</dd>
<dt>dosage.p1</dt><dd><p>a vector containing the dosage in
parent P for all <code>n.mrk</code> markers</p>
</dd>
<dt>dosage.p2</dt><dd><p>a vector containing the dosage in
parent Q for all <code>n.mrk</code> markers</p>
</dd>
<dt>chrom</dt><dd><p>a vector indicating which sequence each marker
belongs. Zero indicates that the marker was not assigned to any
sequence</p>
</dd>
<dt>genome.pos</dt><dd><p>Physical position of the markers into the
sequence</p>
</dd>
<dt>prob.thres = 0.95</dt><dd><p>probability threshold to associate a marker 
call to a dosage. Markers with maximum genotype 
probability smaller than 'prob.thres' are considered 
as missing data for the dosage calling purposes</p>
</dd>
<dt>geno</dt><dd><p>a data.frame 
containing the probability distribution for each combination of
marker and offspring. The first two columns represent the marker
and the offspring, respectively. The remaining elements represent
the probability associated to each one of the possible
dosages</p>
</dd>
<dt>geno.dose</dt><dd><p>a matrix containing the dosage for each markers (rows) 
for each individual (columns). Missing data are represented by 
<code>ploidy_level + 1 = 7</code></p>
</dd>
<dt>n.phen</dt><dd><p>There are no phenotypes in this simulation</p>
</dd>
<dt>phen</dt><dd><p>There are no phenotypes in this simulation</p>
</dd>
</dl>


<hr>
<h2 id='import_data_from_polymapR'>Import data from polymapR</h2><span id='topic+import_data_from_polymapR'></span>

<h3>Description</h3>

<p>Function to import datasets from polymapR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_data_from_polymapR(
  input.data,
  ploidy,
  parent1 = "P1",
  parent2 = "P2",
  input.type = c("discrete", "probabilistic"),
  prob.thres = 0.95,
  pardose = NULL,
  offspring = NULL,
  filter.non.conforming = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_data_from_polymapR_+3A_input.data">input.data</code></td>
<td>
<p>a <code>polymapR</code> dataset</p>
</td></tr>
<tr><td><code id="import_data_from_polymapR_+3A_ploidy">ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code id="import_data_from_polymapR_+3A_parent1">parent1</code></td>
<td>
<p>a character string containing the name (or pattern of genotype IDs) of parent 1</p>
</td></tr>
<tr><td><code id="import_data_from_polymapR_+3A_parent2">parent2</code></td>
<td>
<p>a character string containing the name (or pattern of genotype IDs) of parent 2</p>
</td></tr>
<tr><td><code id="import_data_from_polymapR_+3A_input.type">input.type</code></td>
<td>
<p>Indicates whether the input is discrete (&quot;disc&quot;) or probabilistic (&quot;prob&quot;)</p>
</td></tr>
<tr><td><code id="import_data_from_polymapR_+3A_prob.thres">prob.thres</code></td>
<td>
<p>threshold probability to assign a dosage to offspring. If the probability 
is smaller than <code>thresh.parent.geno</code>, the data point is converted to 'NA'.</p>
</td></tr>
<tr><td><code id="import_data_from_polymapR_+3A_pardose">pardose</code></td>
<td>
<p>matrix of dimensions (n.mrk x 3) containing the name of the markers in the first column, and the 
dosage of parents 1 and 2 in columns 2 and 3. (see polymapR vignette)</p>
</td></tr>
<tr><td><code id="import_data_from_polymapR_+3A_offspring">offspring</code></td>
<td>
<p>a character string containing the name (or pattern of genotype IDs) of the offspring 
individuals. If <code>NULL</code> (default) it considers all individuals as offsprings, except 
<code>parent1</code> and <code>parent2</code>.</p>
</td></tr>
<tr><td><code id="import_data_from_polymapR_+3A_filter.non.conforming">filter.non.conforming</code></td>
<td>
<p>if <code>TRUE</code> exclude samples with non 
expected genotypes under no double reduction. Since markers were already filtered in polymapR, the default is 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="import_data_from_polymapR_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples at <a href="https://rpubs.com/mmollin/tetra_mappoly_vignette">https://rpubs.com/mmollin/tetra_mappoly_vignette</a>.
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Bourke PM et al: (2019) PolymapR  linkage analysis and genetic map 
construction from F1 populations of outcrossing polyploids. 
_Bioinformatics_ 34:34963502.
<a href="https://doi.org/10.1093/bioinformatics/bty1002">doi:10.1093/bioinformatics/bty1002</a>
</p>
<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>

<hr>
<h2 id='import_from_updog'>Import from updog</h2><span id='topic+import_from_updog'></span>

<h3>Description</h3>

<p>Read objects with information related to genotype calling in polyploids.
Currently this function supports output objects created with the
<code>updog</code> (output of <code>multidog</code> function) package.
This function creates an object of class <code>mappoly.data</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_from_updog(
  object,
  prob.thres = 0.95,
  filter.non.conforming = TRUE,
  chrom = NULL,
  genome.pos = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_from_updog_+3A_object">object</code></td>
<td>
<p>the name of the object of class <code>multidog</code></p>
</td></tr>
<tr><td><code id="import_from_updog_+3A_prob.thres">prob.thres</code></td>
<td>
<p>probability threshold to associate a marker call to a 
dosage. Markers with maximum genotype probability smaller than 'prob.thres' 
are considered as missing data for the dosage calling purposes</p>
</td></tr>
<tr><td><code id="import_from_updog_+3A_filter.non.conforming">filter.non.conforming</code></td>
<td>
<p>if <code>TRUE</code> (default) exclude samples with non 
expected genotypes under random chromosome pairing and no double reduction</p>
</td></tr>
<tr><td><code id="import_from_updog_+3A_chrom">chrom</code></td>
<td>
<p>a vector indicating which sequence each marker
belongs. Zero indicates that the marker was not assigned to any
sequence</p>
</td></tr>
<tr><td><code id="import_from_updog_+3A_genome.pos">genome.pos</code></td>
<td>
<p>vector with physical position of the markers into the
sequence</p>
</td></tr>
<tr><td><code id="import_from_updog_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mappoly.data</code> which contains a
list with the following components:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>ploidy level</p>
</td></tr>
<tr><td><code>n.ind</code></td>
<td>
<p>number individuals</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>total number of markers</p>
</td></tr>
<tr><td><code>ind.names</code></td>
<td>
<p>the names of the individuals</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of the markers</p>
</td></tr>
<tr><td><code>dosage.p1</code></td>
<td>
<p>a vector containing the dosage in
parent P for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>dosage.p2</code></td>
<td>
<p>a vector containing the dosage in
parent Q for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating which sequence each marker
belongs. Zero indicates that the marker was not assigned to any
sequence</p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>physical position of the markers into the
sequence</p>
</td></tr>
<tr><td><code>prob.thres</code></td>
<td>
<p>probability threshold to associate a marker call to a 
dosage. Markers with maximum genotype probability smaller than 'prob.thres' 
were considered as missing data in the 'geno.dose' matrix</p>
</td></tr>
<tr><td><code>geno.dose</code></td>
<td>
<p>a matrix containing the dosage for each markers (rows) 
for each individual (columns). Missing data are represented by 
<code>ploidy_level + 1</code></p>
</td></tr>
<tr><td><code>geno</code></td>
<td>
<p>a data.frame 
containing the probability distribution for each combination of
marker and offspring. The first two columns represent the marker
and the offspring, respectively. The remaining elements represent
the probability associated to each one of the possible
dosages. Missing data are converted from <code>NA</code> to the expected
segregation ratio using function <code><a href="#topic+segreg_poly">segreg_poly</a></code></p>
</td></tr>
<tr><td><code>n.phen</code></td>
<td>
<p>number of phenotypic traits</p>
</td></tr>
<tr><td><code>phen</code></td>
<td>
<p>a matrix containing the phenotypic data. The rows
correspond to the traits and the columns correspond
to the individuals</p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>a vector containing p-values related to the chi-squared 
test of Mendelian segregation performed for all markers</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabriel Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("updog", quietly = TRUE)){
library("updog")
data("uitdewilligen")
mout = multidog(refmat = t(uitdewilligen$refmat), 
                sizemat = t(uitdewilligen$sizemat), 
                ploidy = uitdewilligen$ploidy, 
                model = "f1",
                p1_id = colnames(t(uitdewilligen$sizemat))[1],
                p2_id = colnames(t(uitdewilligen$sizemat))[2],
                nc = 2)
mydata = import_from_updog(mout)
mydata
plot(mydata)
}


</code></pre>

<hr>
<h2 id='import_phased_maplist_from_polymapR'>Import phased map list from polymapR</h2><span id='topic+import_phased_maplist_from_polymapR'></span>

<h3>Description</h3>

<p>Function to import phased map lists from polymapR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_phased_maplist_from_polymapR(maplist, mappoly.data, ploidy = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_phased_maplist_from_polymapR_+3A_maplist">maplist</code></td>
<td>
<p>a list of phased maps obtained using function 
<code>create_phased_maplist</code> from package <code>polymapR</code></p>
</td></tr>
<tr><td><code id="import_phased_maplist_from_polymapR_+3A_mappoly.data">mappoly.data</code></td>
<td>
<p>a dataset used to obtain <code>maplist</code>, 
converted into class <code>mappoly.data</code></p>
</td></tr>
<tr><td><code id="import_phased_maplist_from_polymapR_+3A_ploidy">ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples at <a href="https://rpubs.com/mmollin/tetra_mappoly_vignette">https://rpubs.com/mmollin/tetra_mappoly_vignette</a>.
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Bourke PM et al: (2019) PolymapR  linkage analysis and genetic map 
construction from F1 populations of outcrossing polyploids. 
_Bioinformatics_ 34:34963502.
<a href="https://doi.org/10.1093/bioinformatics/bty1002">doi:10.1093/bioinformatics/bty1002</a>
</p>
<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>

<hr>
<h2 id='is.prob.data'>Check if Object is a Probability Dataset in MAPpoly</h2><span id='topic+is.prob.data'></span>

<h3>Description</h3>

<p>Determines whether the specified object is a probability dataset
by checking for the existence of the 'geno' component within a
'&quot;mappoly.data&quot;' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.prob.data(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.prob.data_+3A_x">x</code></td>
<td>
<p>An object of class '&quot;mappoly.data&quot;'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value: &lsquo;TRUE' if the &rsquo;geno' component exists within 'x',
indicating it is a valid probability dataset for genetic analysis; 'FALSE'
otherwise.
</p>

<hr>
<h2 id='loglike_hmm'>Multipoint log-likelihood computation</h2><span id='topic+loglike_hmm'></span>

<h3>Description</h3>

<p>Update the multipoint log-likelihood of a given map 
using the method proposed by <cite>Mollinari and Garcia (2019)</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglike_hmm(input.map, input.data = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglike_hmm_+3A_input.map">input.map</code></td>
<td>
<p>An object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="loglike_hmm_+3A_input.data">input.data</code></td>
<td>
<p>An object of class <code>mappoly.data</code>, which was used to generate <code>input.map</code></p>
</td></tr>
<tr><td><code id="loglike_hmm_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, map information is shown; if
<code>FALSE</code>(default), no output is produced</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
  hexa.map &lt;- loglike_hmm(maps.hexafake[[1]])
  hexa.map
 
 
</code></pre>

<hr>
<h2 id='ls_linkage_phases'>List of linkage phases</h2><span id='topic+ls_linkage_phases'></span><span id='topic+print.two.pts.linkage.phases'></span><span id='topic+plot.two.pts.linkage.phases'></span>

<h3>Description</h3>

<p>Returns a list of possible linkage phase configurations using
the two-point information contained in the object <code>mappoly.twopt</code>
as elimination criteria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_linkage_phases(input.seq, thres, twopt, mrk.to.add = NULL, prev.info = NULL)

## S3 method for class 'two.pts.linkage.phases'
print(x, ...)

## S3 method for class 'two.pts.linkage.phases'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ls_linkage_phases_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code></p>
</td></tr>
<tr><td><code id="ls_linkage_phases_+3A_thres">thres</code></td>
<td>
<p>the LOD threshold used to determine whether linkage phases
compared via two-point analysis should be considered</p>
</td></tr>
<tr><td><code id="ls_linkage_phases_+3A_twopt">twopt</code></td>
<td>
<p>an object of class <code>mappoly.twopt</code>
containing the two-point information</p>
</td></tr>
<tr><td><code id="ls_linkage_phases_+3A_mrk.to.add">mrk.to.add</code></td>
<td>
<p>marker to be added to the end of the linkage
group. If <code>NULL</code> (default) adds all markers contained in
<code>input.seq</code>. Mostly for internal usage</p>
</td></tr>
<tr><td><code id="ls_linkage_phases_+3A_prev.info">prev.info</code></td>
<td>
<p>(optional) an object of class <code>two.pts.linkage.phases</code>
containing the previous info about linkage phase configuration.
Mostly for internal usage</p>
</td></tr>
<tr><td><code id="ls_linkage_phases_+3A_x">x</code></td>
<td>
<p>an object of the class <code>two.pts.linkage.phases</code></p>
</td></tr>
<tr><td><code id="ls_linkage_phases_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>two.pts.linkage.phases</code> which
contains the following structure: 
</p>
<table role = "presentation">
<tr><td><code>config.to.test</code></td>
<td>
<p>a matrix with all possible linkage phase configurations
for both parents, P and Q</p>
</td></tr> 
<tr><td><code>rec.frac</code></td>
<td>
<p>a matrix with all recombination fractions</p>
</td></tr>
<tr><td><code>ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code>seq.num</code></td>
<td>
<p>the sequence of markers</p>
</td></tr>
<tr><td><code>thres</code></td>
<td>
<p>the LOD threshold</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the dataset name</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq.all.mrk &lt;- make_seq_mappoly(hexafake, 'all')
id &lt;- get_genomic_order(seq.all.mrk)
s &lt;- make_seq_mappoly(id)
seq10 &lt;- make_seq_mappoly(hexafake, s$seq.mrk.names[1:10])
twopt &lt;- est_pairwise_rf(seq10)

## Using the first 10 markers 
l10.seq.3.0 &lt;- ls_linkage_phases(input.seq = seq10, thres = 3, twopt = twopt)
l10.seq.3.0
plot(l10.seq.3.0)
l10.seq.2.0 &lt;- ls_linkage_phases(input.seq = seq10, thres = 2.0, twopt = twopt)
l10.seq.2.0
plot(l10.seq.2.0)
l10.seq.1.0 &lt;- ls_linkage_phases(input.seq = seq10, thres = 1.0, twopt = twopt)
l10.seq.1.0
plot(l10.seq.1.0)

## Using the first 5 markers 
seq5 &lt;- make_seq_mappoly(hexafake, s$seq.mrk.names[1:5])
l5.seq.5.0 &lt;- ls_linkage_phases(input.seq = seq5, thres = 5, twopt = twopt)
l5.seq.5.0
plot(l5.seq.5.0)
l5.seq.3.0 &lt;- ls_linkage_phases(input.seq = seq5, thres = 3, twopt = twopt)
l5.seq.3.0
plot(l5.seq.3.0)
l5.seq.1.0 &lt;- ls_linkage_phases(input.seq = seq5, thres = 1, twopt = twopt)
l5.seq.1.0
plot(l5.seq.1.0)
</code></pre>

<hr>
<h2 id='make_mat_mappoly'>Subset recombination fraction matrices</h2><span id='topic+make_mat_mappoly'></span>

<h3>Description</h3>

<p>Get a subset of an object of class <code>mappoly.rf.matrix</code>, i.e.
recombination fraction and LOD score matrices based in a
sequence of markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mat_mappoly(input.mat, input.seq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_mat_mappoly_+3A_input.mat">input.mat</code></td>
<td>
<p>an object of class <code>mappoly.rf.matrix</code></p>
</td></tr>
<tr><td><code id="make_mat_mappoly_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code>, with 
a sequence of markers contained in <code>input.mat</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>mappoly.rf.matrix</code>,
which is a subset of <code>'input.mat'</code>. 
See <code><a href="#topic+rf_list_to_matrix">rf_list_to_matrix</a></code> for details
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # sequence with 20 markers
    mrk.seq &lt;- make_seq_mappoly(hexafake, 1:20)
    mrk.pairs &lt;- est_pairwise_rf(input.seq = mrk.seq,
                               verbose = TRUE)
    ## Full recombination fraction matrix
    mat &lt;- rf_list_to_matrix(input.twopt = mrk.pairs)
    plot(mat)
    ## Matrix subset
    id &lt;- make_seq_mappoly(hexafake, 1:10)
    mat.sub &lt;- make_mat_mappoly(mat, id)
    plot(mat.sub)
   
</code></pre>

<hr>
<h2 id='make_pairs_mappoly'>Subset pairwise recombination fractions</h2><span id='topic+make_pairs_mappoly'></span>

<h3>Description</h3>

<p>Get a subset of an object of class <code>mappoly.twopt</code> or <code>mappoly.twopt2</code> (i.e.
recombination fraction) and LOD score statistics for all possible linkage
phase combinations based on a sequence of markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_pairs_mappoly(input.twopt, input.seq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_pairs_mappoly_+3A_input.twopt">input.twopt</code></td>
<td>
<p>an object of class <code>mappoly.twopt</code></p>
</td></tr>
<tr><td><code id="make_pairs_mappoly_+3A_input.seq">input.seq</code></td>
<td>
<p>an object of class <code>mappoly.sequence</code>, with 
a sequence of markers contained in <code>input.twopt</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>mappoly.twopt</code> which is a
subset of <code>input.twopt</code>. 
See <code><a href="#topic+est_pairwise_rf">est_pairwise_rf</a></code> for details
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ## selecting some markers along the genome
    some.mrk &lt;- make_seq_mappoly(hexafake, seq(1, 1500, 30))
    all.pairs &lt;- est_pairwise_rf(input.seq = some.mrk)
    mat.full &lt;- rf_list_to_matrix(input.twopt = all.pairs)
    plot(mat.full)
    
    ## selecting two-point information for chromosome 1
    mrks.1 &lt;- make_seq_mappoly(hexafake, names(which(some.mrk$chrom == 1)))
    p1 &lt;- make_pairs_mappoly(input.seq = mrks.1, input.twopt = all.pairs)
    m1 &lt;- rf_list_to_matrix(input.twopt = p1)
    plot(m1, main.text = "LG1")
   
</code></pre>

<hr>
<h2 id='make_seq_mappoly'>Create a Sequence of Markers</h2><span id='topic+make_seq_mappoly'></span><span id='topic+print.mappoly.sequence'></span><span id='topic+plot.mappoly.sequence'></span>

<h3>Description</h3>

<p>Constructs a sequence of markers based on an object belonging to various specified classes. This
function is versatile, supporting multiple input types and configurations for generating marker sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_seq_mappoly(
  input.obj,
  arg = NULL,
  data.name = NULL,
  info.parent = c("all", "p1", "p2"),
  genomic.info = NULL
)

## S3 method for class 'mappoly.sequence'
print(x, ...)

## S3 method for class 'mappoly.sequence'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_seq_mappoly_+3A_input.obj">input.obj</code></td>
<td>
<p>An object belonging to one of the specified classes: <code>mappoly.data</code>,
<code>mappoly.map</code>, <code>mappoly.sequence</code>, <code>mappoly.group</code>, <code>mappoly.unique.seq</code>,
<code>mappoly.pcmap</code>, <code>mappoly.pcmap3d</code>, <code>mappoly.geno.ord</code>, or <code>mappoly.edit.order</code>.</p>
</td></tr>
<tr><td><code id="make_seq_mappoly_+3A_arg">arg</code></td>
<td>
<p>Specifies the markers to include in the sequence, accepting several formats: a string 'all' for all
markers; a string or vector of strings 'seqx' where x is the sequence number (0 for unassigned markers); a
vector of integers indicating specific markers; or a vector of integers representing linkage group numbers if
<code>input.obj</code> is of class <code>mappoly.group</code>. For certain classes (<code>mappoly.pcmap</code>, <code>mappoly.pcmap3d</code>,
<code>mappoly.unique.seq</code>, or <code>mappoly.geno.ord</code>), <code>arg</code> can be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="make_seq_mappoly_+3A_data.name">data.name</code></td>
<td>
<p>Name of the <code>mappoly.data</code> class object.</p>
</td></tr>
<tr><td><code id="make_seq_mappoly_+3A_info.parent">info.parent</code></td>
<td>
<p>Selection criteria based on parental information: <code>'all'</code> for all dosage combinations,
<code>'P1'</code> for markers informative in parent 1, or <code>'P2'</code> for markers informative in parent 2. Default
is <code>'all'</code>.</p>
</td></tr>
<tr><td><code id="make_seq_mappoly_+3A_genomic.info">genomic.info</code></td>
<td>
<p>Optional and applicable only to <code>mappoly.group</code> objects. Specifies the use of genomic
information in sequence creation. With <code>NULL</code> (default), all markers defined by the grouping function are
included. Numeric values indicate the use of specific sequences from genomic information, aiming to match the
maximum number of markers with the group. Supports single values or vectors for multiple sequence consideration.</p>
</td></tr>
<tr><td><code id="make_seq_mappoly_+3A_x">x</code></td>
<td>
<p>An object of class <code>mappoly.sequence</code>.</p>
</td></tr>
<tr><td><code id="make_seq_mappoly_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class 'mappoly.sequence', comprising:
</p>
<table role = "presentation">
<tr><td><code>"seq.num"</code></td>
<td>
<p>Ordered vector of marker indices according to the input.</p>
</td></tr>
<tr><td><code>"seq.phases"</code></td>
<td>
<p>List of linkage phases between markers; -1 for undefined phases.</p>
</td></tr>
<tr><td><code>"seq.rf"</code></td>
<td>
<p>Vector of recombination frequencies; -1 for not estimated frequencies.</p>
</td></tr>
<tr><td><code>"loglike"</code></td>
<td>
<p>Log-likelihood of the linkage map.</p>
</td></tr>
<tr><td><code>"data.name"</code></td>
<td>
<p>Name of the 'mappoly.data' object with raw data.</p>
</td></tr>
<tr><td><code>"twopt"</code></td>
<td>
<p>Name of the 'mappoly.twopt' object with 2-point analyses; -1 if not computed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>, with modifications by Gabriel Gesteira 
<a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A. A. F. (2019). Linkage analysis and haplotype phasing in experimental
autopolyploid populations with high ploidy level using hidden Markov models. _G3: Genes|Genomes|Genetics_,
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all.mrk &lt;- make_seq_mappoly(hexafake, 'all')
seq1.mrk &lt;- make_seq_mappoly(hexafake, 'seq1')
plot(seq1.mrk)
some.mrk.pos &lt;- c(1,4,28,32,45)
some.mrk.1 &lt;- make_seq_mappoly(hexafake, some.mrk.pos)
plot(some.mrk.1)

</code></pre>

<hr>
<h2 id='mappoly-color-palettes'>MAPpoly Color Palettes</h2><span id='topic+mappoly-color-palettes'></span><span id='topic+mp_pallet1'></span><span id='topic+mp_pallet2'></span><span id='topic+mp_pallet3'></span>

<h3>Description</h3>

<p>Provides a set of color palettes designed for use with MAPpoly, 
a package for genetic mapping in polyploids. These palettes are 
intended to enhance the visual representation of genetic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_pallet1(n)
</code></pre>


<h3>Details</h3>

<p>The available palettes are:
</p>

<dl>
<dt><code>mp_pallet1</code></dt><dd><p>A palette with warm colors ranging from yellow to dark red and brown.</p>
</dd>
<dt><code>mp_pallet2</code></dt><dd><p>A palette with cool colors, including purples, blues, and green.</p>
</dd>
<dt><code>mp_pallet3</code></dt><dd><p>A comprehensive palette that combines colors from both <code>mp_pallet1</code> and <code>mp_pallet2</code>, offering a broad range of colors.</p>
</dd>
</dl>

<p>Each palette function returns a function that can generate color vectors of variable length, suitable for mapping or plotting functions in R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a palette of 5 colors from mp_pallet1
pal1 &lt;- mp_pallet1(5)
plot(1:5, pch=19, col=pal1)

# Generate a palette of 10 colors from mp_pallet2
pal2 &lt;- mp_pallet2(10)
plot(1:10, pch=19, col=pal2)

# Generate a palette of 15 colors from mp_pallet3
pal3 &lt;- mp_pallet3(15)
plot(1:15, pch=19, col=pal3)
</code></pre>

<hr>
<h2 id='maps.hexafake'>Resulting maps from <code><a href="#topic+hexafake">hexafake</a></code></h2><span id='topic+maps.hexafake'></span>

<h3>Description</h3>

<p>A list containing three linkage groups estimated using the procedure available in  
[MAPpoly's tutorial](https://mmollina.github.io/MAPpoly/#estimating_the_map_for_a_given_order)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maps.hexafake
</code></pre>


<h3>Format</h3>

<p>A list containing three objects of class <code>mappoly.map</code>, each one 
representing one linkage group in the simulated data.
</p>

<hr>
<h2 id='mds_mappoly'>Estimates loci position using Multidimensional Scaling</h2><span id='topic+mds_mappoly'></span><span id='topic+print.mappoly.pcmap'></span><span id='topic+print.mappoly.pcmap3d'></span>

<h3>Description</h3>

<p>Estimates loci position using Multidimensional Scaling proposed by
<cite>Preedy and Hackett (2016)</cite>. The code is an adaptation from
the package <code>MDSmap</code>, available under GNU GENERAL PUBLIC LICENSE,
Version 3, at <a href="https://CRAN.R-project.org/package=MDSMap">https://CRAN.R-project.org/package=MDSMap</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mds_mappoly(
  input.mat,
  p = NULL,
  n = NULL,
  ndim = 2,
  weight.exponent = 2,
  verbose = TRUE
)

## S3 method for class 'mappoly.pcmap'
print(x, ...)

## S3 method for class 'mappoly.pcmap3d'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mds_mappoly_+3A_input.mat">input.mat</code></td>
<td>
<p>an object of class <code>mappoly.input.matrix</code></p>
</td></tr>
<tr><td><code id="mds_mappoly_+3A_p">p</code></td>
<td>
<p>integer. The smoothing parameter for the principal curve.
If <code>NULL</code> (default) this will be done using the leave-one-out cross validation</p>
</td></tr>
<tr><td><code id="mds_mappoly_+3A_n">n</code></td>
<td>
<p>vector of integers or strings containing loci to be omitted from the analysis</p>
</td></tr>
<tr><td><code id="mds_mappoly_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions to be considered in the multidimensional scaling procedure (default = 2)</p>
</td></tr>
<tr><td><code id="mds_mappoly_+3A_weight.exponent">weight.exponent</code></td>
<td>
<p>the exponent that should be used in the LOD score values to weight the
MDS procedure (default = 2)</p>
</td></tr>
<tr><td><code id="mds_mappoly_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), display information about the analysis</p>
</td></tr>
<tr><td><code id="mds_mappoly_+3A_x">x</code></td>
<td>
<p>an object of class <code>mappoly.mds</code></p>
</td></tr>
<tr><td><code id="mds_mappoly_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>M</code></td>
<td>
<p>the input distance map</p>
</td></tr>
<tr><td><code>sm</code></td>
<td>
<p>the unconstrained MDS results</p>
</td></tr>
<tr><td><code>pc</code></td>
<td>
<p>the principal curve results</p>
</td></tr>
<tr><td><code>distmap</code></td>
<td>
<p>a matrix of pairwise distances between
loci where the columns are in the estimated order</p>
</td></tr>
<tr><td><code>locimap</code></td>
<td>
<p>a data frame of the loci containing the name
and position of each locus in order of increasing distance</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>integer giving the total length of the segment</p>
</td></tr>
<tr><td><code>removed</code></td>
<td>
<p>a vector of the names of loci removed from the analysis</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the scaling factor from the MDS</p>
</td></tr>
<tr><td><code>locikey</code></td>
<td>
<p>a data frame showing the number associated with each
locus name for interpreting the MDS configuration plot</p>
</td></tr>
<tr><td><code>confplotno</code></td>
<td>
<p>a data frame showing locus name associated
with each number on the MDS configuration plots</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a> mostly adapted from MDSmap 
codes, written by Katharine F. Preedy, <a href="mailto:katharine.preedy@bioss.ac.uk">katharine.preedy@bioss.ac.uk</a>
</p>


<h3>References</h3>

<p>Preedy, K. F., &amp; Hackett, C. A. (2016). A rapid marker ordering approach for
high-density genetic linkage maps in experimental autotetraploid populations
using multidimensional scaling. _Theoretical and Applied Genetics_, 129(11),
2117-2132. <a href="https://doi.org/10.1007/s00122-016-2761-8">doi:10.1007/s00122-016-2761-8</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    s1 &lt;- make_seq_mappoly(hexafake, 1:20)
    t1 &lt;- est_pairwise_rf(s1, ncpus = 1)
    m1 &lt;- rf_list_to_matrix(t1)
    o1 &lt;- get_genomic_order(s1)
    s.go &lt;- make_seq_mappoly(o1)
    plot(m1, ord = s.go$seq.mrk.names)
    mds.ord &lt;- mds_mappoly(m1)
    plot(mds.ord)
    so &lt;- make_seq_mappoly(mds.ord)
    plot(m1, ord = so$seq.mrk.names)
    plot(so$seq.num ~ I(so$genome.pos/1e6), 
         xlab = "Genome Position",
         ylab = "MDS position")

</code></pre>

<hr>
<h2 id='merge_datasets'>Merge datasets</h2><span id='topic+merge_datasets'></span>

<h3>Description</h3>

<p>This function merges two datasets of class <code>mappoly.data</code>. This can be useful
when individuals of a population were genotyped using two or more techniques
and have datasets in different files or formats. Please notice that the datasets 
should contain the same number of individuals and they must be represented identically 
in both datasets  (e.g. <code>Ind_1</code> in both datasets, not <code>Ind_1</code>
in one dataset and <code>ind_1</code> or <code>Ind.1</code> in the other).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_datasets(dat.1 = NULL, dat.2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_datasets_+3A_dat.1">dat.1</code></td>
<td>
<p>the first dataset of class <code>mappoly.data</code> to be merged</p>
</td></tr>
<tr><td><code id="merge_datasets_+3A_dat.2">dat.2</code></td>
<td>
<p>the second dataset of class <code>mappoly.data</code> to be merged (default = NULL);
if <code>dat.2 = NULL</code>, the function returns <code>dat.1</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mappoly.data</code> which contains all markers
from both datasets. It will be a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>ploidy level</p>
</td></tr>
<tr><td><code>n.ind</code></td>
<td>
<p>number individuals</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>total number of markers</p>
</td></tr>
<tr><td><code>ind.names</code></td>
<td>
<p>the names of the individuals</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of the markers</p>
</td></tr>
<tr><td><code>dosage.p1</code></td>
<td>
<p>a vector containing the dosage in
parent P for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>dosage.p2</code></td>
<td>
<p>a vector containing the dosage in
parent Q for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating which sequence each marker
belongs. Zero indicates that the marker was not assigned to any
sequence</p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>Physical position of the markers into the
sequence</p>
</td></tr>
<tr><td><code>seq.ref</code></td>
<td>
<p>if one or both datasets originated from read_vcf, it keeps
reference alleles from sequencing platform, otherwise is NULL</p>
</td></tr>
<tr><td><code>seq.alt</code></td>
<td>
<p>if one or both datasets originated from read_vcf, it keeps
alternative alleles from sequencing platform, otherwise is NULL</p>
</td></tr>
<tr><td><code>all.mrk.depth</code></td>
<td>
<p>if one or both datasets originated from read_vcf, it keeps
marker read depths from sequencing, otherwise is NULL</p>
</td></tr>
<tr><td><code>prob.thres</code></td>
<td>
<p>(unused field)</p>
</td></tr>
<tr><td><code>geno.dose</code></td>
<td>
<p>a matrix containing the dosage for each markers (rows) 
for each individual (columns). Missing data are represented by 
<code>ploidy_level + 1</code></p>
</td></tr>
<tr><td><code>geno</code></td>
<td>
<p>if both datasets contain genotype distribution information,
the final object will contain 'geno'. This is set to NULL otherwise</p>
</td></tr>
<tr><td><code>nphen</code></td>
<td>
<p>(0)</p>
</td></tr>
<tr><td><code>phen</code></td>
<td>
<p>(NULL)</p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>a vector containing p-values related to the chi-squared 
test of Mendelian segregation performed for all markers in both datasets</p>
</td></tr>
<tr><td><code>kept</code></td>
<td>
<p>if elim.redundant = TRUE when reading any dataset, holds all non-redundant markers</p>
</td></tr>
<tr><td><code>elim.correspondence</code></td>
<td>
<p>if elim.redundant = TRUE when reading any dataset,
holds all non-redundant markers and its equivalence to the redundant ones</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabriel Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Loading a subset of SNPs from chromosomes 3 and 12 of sweetpotato dataset 
## (SNPs anchored to Ipomoea trifida genome)
dat &lt;- NULL
for(i in c(3, 12)){
  cat("Loading chromosome", i, "...\n")
    tempfl &lt;- tempfile(pattern = paste0("ch", i), fileext = ".vcf.gz")
    x &lt;- "https://github.com/mmollina/MAPpoly_vignettes/raw/master/data/sweet_sample_ch"
    address &lt;- paste0(x, i, ".vcf.gz")
    download.file(url = address, destfile = tempfl)
    dattemp &lt;- read_vcf(file = tempfl, parent.1 = "PARENT1", parent.2 = "PARENT2",
                        ploidy = 6, verbose = FALSE)
    dat &lt;- merge_datasets(dat, dattemp)
  cat("\n")
}
dat
plot(dat)


</code></pre>

<hr>
<h2 id='merge_maps'>Merge two maps</h2><span id='topic+merge_maps'></span>

<h3>Description</h3>

<p>Estimates the linkage phase and recombination fraction between pre-built maps 
and creates a new map by merging them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_maps(
  map.list,
  twopt,
  thres.twopt = 10,
  genoprob.list = NULL,
  thres.hmm = "best",
  tol = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_maps_+3A_map.list">map.list</code></td>
<td>
<p>a list of objects of class <code>mappoly.map</code> to be merged.</p>
</td></tr>
<tr><td><code id="merge_maps_+3A_twopt">twopt</code></td>
<td>
<p>an object of class <code>mappoly.twopt</code>
containing the two-point information for all pairs of markers
present in the original maps</p>
</td></tr>
<tr><td><code id="merge_maps_+3A_thres.twopt">thres.twopt</code></td>
<td>
<p>the threshold used to determine if the linkage
phases compared via two-point analysis should be considered 
for the search space reduction (default = 3)</p>
</td></tr>
<tr><td><code id="merge_maps_+3A_genoprob.list">genoprob.list</code></td>
<td>
<p>a list of objects of class <code>mappoly.genoprob</code> 
containing the genotype probabilities for the maps to be merged. 
If <code>NULL</code> (default), the probabilities are computed.</p>
</td></tr>
<tr><td><code id="merge_maps_+3A_thres.hmm">thres.hmm</code></td>
<td>
<p>the threshold used to determine which linkage 
phase configurations should be returned when merging two maps.
If &quot;best&quot; (default), returns only the best linkage phase 
configuration. NOTE: if merging multiple maps, it always uses 
the &quot;best&quot; linkage phase configuration at each block insertion.</p>
</td></tr>
<tr><td><code id="merge_maps_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (default = 10e-04)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>merge_maps</code> uses two-point information, under a given LOD threshold, to reduce the 
linkage phase search space. The remaining linkage phases are tested using the genotype 
probabilities.
</p>


<h3>Value</h3>

<p>A list of class <code>mappoly.map</code> with two elements: 
</p>
<p>i) info:  a list containing information about the map, regardless of the linkage phase configuration:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>number of markers</p>
</td></tr>
<tr><td><code>seq.num</code></td>
<td>
<p>a vector containing the (ordered) indices of markers in the map, 
according to the input file</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of markers in the map</p>
</td></tr>
<tr><td><code>seq.dose.p1</code></td>
<td>
<p>a vector containing the dosage in parent 1 for all markers in the map</p>
</td></tr>
<tr><td><code>seq.dose.p2</code></td>
<td>
<p>a vector containing the dosage in parent 2 for all markers in the map</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating the sequence (usually chromosome) each marker belongs 
as informed in the input file. If not available, 
<code>chrom = NULL</code></p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>physical position (usually in megabase) of the markers into the sequence</p>
</td></tr>
<tr><td><code>seq.ref</code></td>
<td>
<p>reference base used for each marker (i.e. A, T, C, G). If not available, 
<code>seq.ref = NULL</code></p>
</td></tr>                 
<tr><td><code>seq.alt</code></td>
<td>
<p>alternative base used for each marker (i.e. A, T, C, G). If not available, 
<code>seq.ref = NULL</code></p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>a vector containing p-values of the chi-squared test of Mendelian 
segregation for all markers in the map</p>
</td></tr>                 
<tr><td><code>data.name</code></td>
<td>
<p>name of the dataset of class <code>mappoly.data</code></p>
</td></tr>
<tr><td><code>ph.thres</code></td>
<td>
<p>the LOD threshold used to define the linkage phase configurations to test</p>
</td></tr>
</table>
<p>ii) a list of maps with possible linkage phase configuration. Each map in the list is also a 
list containing
</p>
<table role = "presentation">
<tr><td><code>seq.num</code></td>
<td>
<p>a vector containing the (ordered) indices of markers in the map, 
according to the input file</p>
</td></tr>
<tr><td><code>seq.rf</code></td>
<td>
<p>a vector of size (<code>n.mrk - 1</code>) containing a sequence of recombination 
fraction between the adjacent markers in the map</p>
</td></tr>
<tr><td><code>seq.ph</code></td>
<td>
<p>linkage phase configuration for all markers in both parents</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>the hmm-based multipoint likelihood</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Tetraploid example #####
map1 &lt;- get_submap(solcap.dose.map[[1]], 1:5)
map2 &lt;- get_submap(solcap.dose.map[[1]], 6:15)
map3 &lt;- get_submap(solcap.dose.map[[1]], 16:30)
full.map &lt;- get_submap(solcap.dose.map[[1]], 1:30)
s &lt;- make_seq_mappoly(tetra.solcap, full.map$maps[[1]]$seq.num)
twopt &lt;- est_pairwise_rf(input.seq = s)
merged.maps &lt;- merge_maps(map.list = list(map1, map2, map3), 
                        twopt = twopt,
                        thres.twopt = 3)
plot(merged.maps, mrk.names = TRUE)                       
plot(full.map, mrk.names = TRUE)                       
best.phase &lt;- merged.maps$maps[[1]]$seq.ph
names.id &lt;- names(best.phase$P)
compare_haplotypes(ploidy = 4, best.phase$P[names.id], 
                   full.map$maps[[1]]$seq.ph$P[names.id]) 
compare_haplotypes(ploidy = 4, best.phase$Q[names.id], 
                   full.map$maps[[1]]$seq.ph$Q[names.id])

</code></pre>

<hr>
<h2 id='merge_parental_maps'>Build merged parental maps</h2><span id='topic+merge_parental_maps'></span>

<h3>Description</h3>

<p>Build merged parental maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_parental_maps(
  map.p1,
  map.p2,
  full.seq,
  full.mat,
  method = c("ols", "hmm"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_parental_maps_+3A_map.p1">map.p1</code></td>
<td>
<p>object of class <code>mappoly.map</code> with parent 1 phased</p>
</td></tr>
<tr><td><code id="merge_parental_maps_+3A_map.p2">map.p2</code></td>
<td>
<p>object of class <code>mappoly.map</code> with parent 2 phased</p>
</td></tr>
<tr><td><code id="merge_parental_maps_+3A_full.seq">full.seq</code></td>
<td>
<p>object of class <code>mappoly.sequence</code> containing parent 1 and parent 2 markers</p>
</td></tr>
<tr><td><code id="merge_parental_maps_+3A_full.mat">full.mat</code></td>
<td>
<p>object of class <code>mappoly.rf.matrix</code> containing two-points recombination 
fraction estimations for parent 1 and parent 2 markers</p>
</td></tr>
<tr><td><code id="merge_parental_maps_+3A_method">method</code></td>
<td>
<p>indicates whether to use 'hmm' (Hidden Markov Models), 'ols' (Ordinary Least Squares) 
to re-estimate the recombination fractions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>mappoly.map</code> with both parents information
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a> with documentation and minor modifications by Cristiane Taniguti <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>

<hr>
<h2 id='mrk_chisq_test'>Chi-square test</h2><span id='topic+mrk_chisq_test'></span>

<h3>Description</h3>

<p>Chi-square test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrk_chisq_test(x, ploidy)
</code></pre>

<hr>
<h2 id='msg'>Msg function</h2><span id='topic+msg'></span>

<h3>Description</h3>

<p>Msg function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msg(text, line = 1)
</code></pre>

<hr>
<h2 id='paralell_pairwise_discrete'>Parallel Pairwise Discrete Estimation</h2><span id='topic+paralell_pairwise_discrete'></span>

<h3>Description</h3>

<p>This function performs parallel pairwise estimation of recombination fractions using discrete dosage scoring via a C++ backend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paralell_pairwise_discrete(
  mrk.pairs,
  input.seq,
  geno,
  dP,
  dQ,
  count.cache,
  tol = .Machine$double.eps^0.25,
  ll = ll
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paralell_pairwise_discrete_+3A_mrk.pairs">mrk.pairs</code></td>
<td>
<p>A matrix of dimensions 2*N, containing N pairs of markers to be analyzed.</p>
</td></tr>
<tr><td><code id="paralell_pairwise_discrete_+3A_input.seq">input.seq</code></td>
<td>
<p>An object of class <code>mappoly.sequence</code>.</p>
</td></tr>
<tr><td><code id="paralell_pairwise_discrete_+3A_geno">geno</code></td>
<td>
<p>Genotype matrix.</p>
</td></tr>
<tr><td><code id="paralell_pairwise_discrete_+3A_dp">dP</code></td>
<td>
<p>Vector of probabilities for the first allele.</p>
</td></tr>
<tr><td><code id="paralell_pairwise_discrete_+3A_dq">dQ</code></td>
<td>
<p>Vector of probabilities for the second allele.</p>
</td></tr>
<tr><td><code id="paralell_pairwise_discrete_+3A_count.cache">count.cache</code></td>
<td>
<p>An object of class <code>cache.info</code> containing pre-computed genotype frequencies.</p>
</td></tr>
<tr><td><code id="paralell_pairwise_discrete_+3A_tol">tol</code></td>
<td>
<p>The tolerance level for the estimation accuracy (default is <code>.Machine$double.eps^0.25</code>).</p>
</td></tr>
<tr><td><code id="paralell_pairwise_discrete_+3A_ll">ll</code></td>
<td>
<p>Logical; if TRUE, the function returns log-likelihood values instead of LOD scores. For internal use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the <code>ll</code> parameter, returns either log-likelihood values or formatted LOD scores from pairwise recombination fraction estimation.
</p>

<hr>
<h2 id='paralell_pairwise_discrete_rcpp'>Wrapper function to discrete-based pairwise two-point estimation in C++</h2><span id='topic+paralell_pairwise_discrete_rcpp'></span>

<h3>Description</h3>

<p>Wrapper function to discrete-based pairwise two-point estimation in C++
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paralell_pairwise_discrete_rcpp(
  mrk.pairs,
  m,
  geno,
  dP,
  dQ,
  count.vector,
  count.phases,
  count.matrix.rownames,
  count.matrix.number,
  count.matrix.pos,
  count.matrix.length,
  tol = .Machine$double.eps^0.25
)
</code></pre>

<hr>
<h2 id='paralell_pairwise_probability'>Parallel Pairwise Probability Estimation</h2><span id='topic+paralell_pairwise_probability'></span>

<h3>Description</h3>

<p>This function performs parallel pairwise estimation of recombination fractions using probability-based dosage scoring via a C++ backend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paralell_pairwise_probability(
  mrk.pairs,
  input.seq,
  geno,
  dP,
  dQ,
  count.cache,
  tol = .Machine$double.eps^0.25,
  ll = ll
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paralell_pairwise_probability_+3A_mrk.pairs">mrk.pairs</code></td>
<td>
<p>A matrix of dimensions 2*N, containing N pairs of markers to be analyzed.</p>
</td></tr>
<tr><td><code id="paralell_pairwise_probability_+3A_input.seq">input.seq</code></td>
<td>
<p>An object of class <code>mappoly.sequence</code>.</p>
</td></tr>
<tr><td><code id="paralell_pairwise_probability_+3A_geno">geno</code></td>
<td>
<p>Genotype matrix.</p>
</td></tr>
<tr><td><code id="paralell_pairwise_probability_+3A_dp">dP</code></td>
<td>
<p>Vector of probabilities for the first allele.</p>
</td></tr>
<tr><td><code id="paralell_pairwise_probability_+3A_dq">dQ</code></td>
<td>
<p>Vector of probabilities for the second allele.</p>
</td></tr>
<tr><td><code id="paralell_pairwise_probability_+3A_count.cache">count.cache</code></td>
<td>
<p>An object of class <code>cache.info</code> containing pre-computed genotype frequencies.</p>
</td></tr>
<tr><td><code id="paralell_pairwise_probability_+3A_tol">tol</code></td>
<td>
<p>The tolerance level for the estimation accuracy (default is <code>.Machine$double.eps^0.25</code>).</p>
</td></tr>
<tr><td><code id="paralell_pairwise_probability_+3A_ll">ll</code></td>
<td>
<p>Logical; if TRUE, the function returns log-likelihood values instead of LOD scores. For internal use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the <code>ll</code> parameter, returns either log-likelihood values or formatted LOD scores from pairwise recombination fraction estimation.
</p>

<hr>
<h2 id='parallel_block'>Auxiliary function to estimate a map in a block of markers using parallel 
processing</h2><span id='topic+parallel_block'></span>

<h3>Description</h3>

<p>Auxiliary function to estimate a map in a block of markers using parallel 
processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel_block(
  mrk.vec,
  dat.name,
  ph.thres = 3,
  tol = 0.01,
  phase.number.limit = 20,
  error = 0.05,
  tol.err = 0.001,
  verbose = FALSE
)
</code></pre>

<hr>
<h2 id='perm_pars'>N!/2 combination</h2><span id='topic+perm_pars'></span>

<h3>Description</h3>

<p>N!/2 combination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm_pars(v)
</code></pre>

<hr>
<h2 id='perm_tot'>N! combination</h2><span id='topic+perm_tot'></span>

<h3>Description</h3>

<p>N! combination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm_tot(v)
</code></pre>

<hr>
<h2 id='ph_list_to_matrix'>Linkage phase format conversion: list to matrix</h2><span id='topic+ph_list_to_matrix'></span>

<h3>Description</h3>

<p>This function converts linkage phase configurations from list
to matrix form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ph_list_to_matrix(L, ploidy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ph_list_to_matrix_+3A_l">L</code></td>
<td>
<p>a list of configuration phases</p>
</td></tr>
<tr><td><code id="ph_list_to_matrix_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix whose columns represent homologous chromosomes and
the rows represent markers
</p>

<hr>
<h2 id='ph_matrix_to_list'>Linkage phase format conversion: matrix to list</h2><span id='topic+ph_matrix_to_list'></span>

<h3>Description</h3>

<p>This function converts linkage phase configurations from matrix
form to list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ph_matrix_to_list(M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ph_matrix_to_list_+3A_m">M</code></td>
<td>
<p>matrix whose columns represent homologous chromosomes and
the rows represent markers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of linkage phase configurations
</p>

<hr>
<h2 id='plot_compare_haplotypes'>Plot Two Overlapped Haplotypes</h2><span id='topic+plot_compare_haplotypes'></span>

<h3>Description</h3>

<p>This function plots two sets of haplotypes for comparison, allowing for visual
inspection of homologous allele patterns across two groups or conditions.
It is designed to handle and display genetic data for organisms with varying ploidy levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_compare_haplotypes(
  ploidy,
  hom.allele.p1,
  hom.allele.q1,
  hom.allele.p2 = NULL,
  hom.allele.q2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_compare_haplotypes_+3A_ploidy">ploidy</code></td>
<td>
<p>Integer, specifying the ploidy level of the organism being represented.</p>
</td></tr>
<tr><td><code id="plot_compare_haplotypes_+3A_hom.allele.p1">hom.allele.p1</code></td>
<td>
<p>A list where each element represents the alleles for a marker in the first haplotype group, for 'p' parent.</p>
</td></tr>
<tr><td><code id="plot_compare_haplotypes_+3A_hom.allele.q1">hom.allele.q1</code></td>
<td>
<p>A list where each element represents the alleles for a marker in the first haplotype group, for 'q' parent.</p>
</td></tr>
<tr><td><code id="plot_compare_haplotypes_+3A_hom.allele.p2">hom.allele.p2</code></td>
<td>
<p>Optionally, a list where each element represents the alleles for a marker in the second haplotype group, for 'p' parent.</p>
</td></tr>
<tr><td><code id="plot_compare_haplotypes_+3A_hom.allele.q2">hom.allele.q2</code></td>
<td>
<p>Optionally, a list where each element represents the alleles for a marker in the second haplotype group, for 'q' parent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a graphical representation of haplotypes, where each marker's alleles are plotted
along a line for each parent ('p' and 'q'). If provided, the second set of haplotypes (for comparison) are overlaid
on the same plot. This allows for direct visual comparison of allele presence or absence across the two sets.
Different colors are used to distinguish between the first and second sets of haplotypes.
</p>
<p>The function uses several internal helper functions ('ph_list_to_matrix' and 'ph_matrix_to_list') to manipulate
haplotype data. These functions should correctly handle the conversion between list and matrix representations
of haplotype data.
</p>


<h3>Value</h3>

<p>Invisible. The function primarily generates a plot for visual analysis and does not return any data.
</p>

<hr>
<h2 id='plot_genome_vs_map'>Physical versus genetic distance</h2><span id='topic+plot_genome_vs_map'></span>

<h3>Description</h3>

<p>This function plots scatterplot(s) of physical distance (in Mbp) versus the genetic 
distance (in cM). Map(s) should be passed as a single object or a list of objects 
of class <code>mappoly.map</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_genome_vs_map(
  map.list,
  phase.config = "best",
  same.ch.lg = FALSE,
  alpha = 1/5,
  size = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_genome_vs_map_+3A_map.list">map.list</code></td>
<td>
<p>A list or a single object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="plot_genome_vs_map_+3A_phase.config">phase.config</code></td>
<td>
<p>A vector containing which phase configuration should be
plotted. If <code>'best'</code> (default), plots the configuration
with the highest likelihood for all elements in <code>'map.list'</code></p>
</td></tr>
<tr><td><code id="plot_genome_vs_map_+3A_same.ch.lg">same.ch.lg</code></td>
<td>
<p>Logical. If <code>TRUE</code> displays only the scatterplots between the 
chromosomes and linkage groups with the same number. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_genome_vs_map_+3A_alpha">alpha</code></td>
<td>
<p>transparency factor for SNPs points</p>
</td></tr>
<tr><td><code id="plot_genome_vs_map_+3A_size">size</code></td>
<td>
<p>size of the SNP points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot_genome_vs_map(solcap.mds.map, same.ch.lg = TRUE)
  plot_genome_vs_map(solcap.mds.map, same.ch.lg = FALSE, 
                     alpha = 1, size = 1/2)
 
</code></pre>

<hr>
<h2 id='plot_GIC'>Genotypic information content</h2><span id='topic+plot_GIC'></span>

<h3>Description</h3>

<p>This function plots the genotypic information content given 
an object of class <code>mappoly.homoprob</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_GIC(hprobs, P = "P1", Q = "P2")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_GIC_+3A_hprobs">hprobs</code></td>
<td>
<p>an object of class <code>mappoly.homoprob</code></p>
</td></tr>
<tr><td><code id="plot_GIC_+3A_p">P</code></td>
<td>
<p>a string containing the name of parent P</p>
</td></tr>
<tr><td><code id="plot_GIC_+3A_q">Q</code></td>
<td>
<p>a string containing the name of parent Q</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
     w &lt;- lapply(solcap.err.map[1:3], calc_genoprob)
     h.prob &lt;- calc_homologprob(w)
     plot_GIC(h.prob)


</code></pre>

<hr>
<h2 id='plot_map_list'>Plot a genetic map</h2><span id='topic+plot_map_list'></span>

<h3>Description</h3>

<p>This function plots a genetic linkage map(s) generated by <code>MAPpoly</code>.
The map(s) should be passed as a single object or a list of objects of class <code>mappoly.map</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_map_list(
  map.list,
  horiz = TRUE,
  col = "lightgray",
  title = "Linkage group"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_map_list_+3A_map.list">map.list</code></td>
<td>
<p>A list of objects or a single object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="plot_map_list_+3A_horiz">horiz</code></td>
<td>
<p>logical. If FALSE, the maps are plotted vertically with the first map to the left. 
If TRUE  (default), the maps are plotted horizontally with the first at the bottom</p>
</td></tr>
<tr><td><code id="plot_map_list_+3A_col">col</code></td>
<td>
<p>a vector of colors for each linkage group.  (default = 'lightgray')
<code>ggstyle</code> produces maps using the default <code>ggplot</code> color palette.</p>
</td></tr>
<tr><td><code id="plot_map_list_+3A_title">title</code></td>
<td>
<p>a title (string) for the maps (default = 'Linkage group')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> object containing the name of the markers and their genetic position
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## hexafake map
 plot_map_list(maps.hexafake, horiz = FALSE)
 plot_map_list(maps.hexafake, col = c("#999999", "#E69F00", "#56B4E9"))
 
 ## solcap map
 plot_map_list(solcap.dose.map, col = "ggstyle")
 plot_map_list(solcap.dose.map, col = "mp_pallet3", horiz = FALSE)
 
</code></pre>

<hr>
<h2 id='plot_mappoly.map2'>Plot object mappoly.map2</h2><span id='topic+plot_mappoly.map2'></span>

<h3>Description</h3>

<p>Plot object mappoly.map2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mappoly.map2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mappoly.map2_+3A_x">x</code></td>
<td>
<p>object of class <code>mappoly.map2</code></p>
</td></tr>
</table>

<hr>
<h2 id='plot_mrk_info'>Plot marker information</h2><span id='topic+plot_mrk_info'></span>

<h3>Description</h3>

<p>Plots summary statistics for a given marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mrk_info(input.data, mrk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mrk_info_+3A_input.data">input.data</code></td>
<td>
<p>an object of class <code>mappoly.data</code></p>
</td></tr>
<tr><td><code id="plot_mrk_info_+3A_mrk">mrk</code></td>
<td>
<p>marker name or position in the dataset</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> plot_mrk_info(tetra.solcap.geno.dist, 2680)
 plot_mrk_info(tetra.solcap.geno.dist, "solcap_snp_c2_23828")
    
</code></pre>

<hr>
<h2 id='plot_one_map'>plot a single linkage group with no phase</h2><span id='topic+plot_one_map'></span>

<h3>Description</h3>

<p>plot a single linkage group with no phase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_one_map(x, i = 0, horiz = FALSE, col = "lightgray")
</code></pre>

<hr>
<h2 id='plot_progeny_dosage_change'>Display genotypes imputed or changed by the HMM chain given a global genotypic error</h2><span id='topic+plot_progeny_dosage_change'></span>

<h3>Description</h3>

<p>Outputs a graphical representation ggplot with the percent of data changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_progeny_dosage_change(
  map_list,
  error,
  verbose = TRUE,
  output_corrected = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_progeny_dosage_change_+3A_map_list">map_list</code></td>
<td>
<p>a list of multiple <code>mappoly.map.list</code></p>
</td></tr>
<tr><td><code id="plot_progeny_dosage_change_+3A_error">error</code></td>
<td>
<p>error rate used in global error in the 'calc_genoprob_error()'</p>
</td></tr>
<tr><td><code id="plot_progeny_dosage_change_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE (default), current progress is shown; if FALSE, 
no output is produced</p>
</td></tr>
<tr><td><code id="plot_progeny_dosage_change_+3A_output_corrected">output_corrected</code></td>
<td>
<p>logical. if FALSE only the ggplot of the changed 
dosage is printed, if TRUE then a new corrected dosage matrix is output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot of the changed and imputed genotypic dosages
</p>


<h3>Author(s)</h3>

<p>Jeekin Lau, <a href="mailto:jzl0026@tamu.edu">jzl0026@tamu.edu</a>, with optimization by Cristiane 
Taniguti, <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>      x &lt;- get_submap(solcap.err.map[[1]], 1:30, reestimate.rf = FALSE)   
      plot_progeny_dosage_change(list(x), error=0.05, output_corrected=FALSE) 
      corrected_matrix &lt;- plot_progeny_dosage_change(list(x), error=0.05, 
      output_corrected=FALSE) #output corrected

</code></pre>

<hr>
<h2 id='plot.mappoly.homoprob'>Plots mappoly.homoprob</h2><span id='topic+plot.mappoly.homoprob'></span>

<h3>Description</h3>

<p>Plots mappoly.homoprob
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mappoly.homoprob'
plot(
  x,
  stack = FALSE,
  lg = NULL,
  ind = NULL,
  use.plotly = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mappoly.homoprob_+3A_x">x</code></td>
<td>
<p>an object of class <code>mappoly.homoprob</code></p>
</td></tr>
<tr><td><code id="plot.mappoly.homoprob_+3A_stack">stack</code></td>
<td>
<p>logical. If <code>TRUE</code>, probability profiles of all homologues
are stacked in the plot (default = FALSE)</p>
</td></tr>
<tr><td><code id="plot.mappoly.homoprob_+3A_lg">lg</code></td>
<td>
<p>indicates which linkage group should be plotted. If <code>NULL</code> 
(default), it plots the first linkage group. If 
<code>"all"</code>, it plots all linkage groups</p>
</td></tr>
<tr><td><code id="plot.mappoly.homoprob_+3A_ind">ind</code></td>
<td>
<p>indicates which individuals should be plotted. It can be the 
position of the individuals in the dataset or it's name. 
If <code>NULL</code> (default), the function plots the first 
individual</p>
</td></tr>
<tr><td><code id="plot.mappoly.homoprob_+3A_use.plotly">use.plotly</code></td>
<td>
<p>if <code>TRUE</code> (default), it uses plotly interactive graphic</p>
</td></tr>
<tr><td><code id="plot.mappoly.homoprob_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
<tr><td><code id="plot.mappoly.homoprob_+3A_...">...</code></td>
<td>
<p>unused arguments</p>
</td></tr>
</table>

<hr>
<h2 id='plot.mappoly.prefpair.profiles'>Plots mappoly.prefpair.profiles</h2><span id='topic+plot.mappoly.prefpair.profiles'></span>

<h3>Description</h3>

<p>Plots mappoly.prefpair.profiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mappoly.prefpair.profiles'
plot(
  x,
  type = c("pair.configs", "hom.pairs"),
  min.y.prof = 0,
  max.y.prof = 1,
  thresh = 0.01,
  P1 = "P1",
  P2 = "P2",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mappoly.prefpair.profiles_+3A_x">x</code></td>
<td>
<p>an object of class <code>mappoly.prefpair.profiles</code></p>
</td></tr>
<tr><td><code id="plot.mappoly.prefpair.profiles_+3A_type">type</code></td>
<td>
<p>a character string indicating which type of graphic is plotted:
<code>"pair.configs"</code> (default) plots the preferential pairing 
profile for the pairing configurations or <code>"hom.pairs"</code> plots 
the preferential pairing profile for the homolog pairs</p>
</td></tr>
<tr><td><code id="plot.mappoly.prefpair.profiles_+3A_min.y.prof">min.y.prof</code></td>
<td>
<p>lower bound for y axis on the probability profile graphic (default = 0)</p>
</td></tr>
<tr><td><code id="plot.mappoly.prefpair.profiles_+3A_max.y.prof">max.y.prof</code></td>
<td>
<p>upper bound for y axis on the probability profile graphic (default = 1)</p>
</td></tr>
<tr><td><code id="plot.mappoly.prefpair.profiles_+3A_thresh">thresh</code></td>
<td>
<p>threshold for chi-square test (default = 0.01)</p>
</td></tr>
<tr><td><code id="plot.mappoly.prefpair.profiles_+3A_p1">P1</code></td>
<td>
<p>a string containing the name of parent P1</p>
</td></tr>
<tr><td><code id="plot.mappoly.prefpair.profiles_+3A_p2">P2</code></td>
<td>
<p>a string containing the name of parent P2</p>
</td></tr>
<tr><td><code id="plot.mappoly.prefpair.profiles_+3A_...">...</code></td>
<td>
<p>unused arguments</p>
</td></tr>
</table>

<hr>
<h2 id='poly_hmm_est'>Estimate genetic map using as input the probability distribution of
genotypes (wrapper function to C++)</h2><span id='topic+poly_hmm_est'></span>

<h3>Description</h3>

<p>Estimate genetic map using as input the probability distribution of
genotypes (wrapper function to C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_hmm_est(
  ploidy,
  n.mrk,
  n.ind,
  p,
  dp,
  q,
  dq,
  g,
  rf,
  verbose = TRUE,
  tol = 0.001
)
</code></pre>

<hr>
<h2 id='prepare_map'>prepare maps for plot</h2><span id='topic+prepare_map'></span>

<h3>Description</h3>

<p>prepare maps for plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_map(input.map, config = "best")
</code></pre>

<hr>
<h2 id='print_mrk'>Summary of a set of markers</h2><span id='topic+print_mrk'></span>

<h3>Description</h3>

<p>Returns information related to a given set of markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_mrk(input.data, mrks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_mrk_+3A_input.data">input.data</code></td>
<td>
<p>an object <code>'mappoly.data'</code></p>
</td></tr>
<tr><td><code id="print_mrk_+3A_mrks">mrks</code></td>
<td>
<p>marker sequence index (integer vector)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> print_mrk(tetra.solcap.geno.dist, 1:5)
 print_mrk(hexafake, 256)
</code></pre>

<hr>
<h2 id='print_ph'>cat for graphical representation of the phases</h2><span id='topic+print_ph'></span>

<h3>Description</h3>

<p>cat for graphical representation of the phases
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_ph(input.ph)
</code></pre>

<hr>
<h2 id='read_fitpoly'>Data Input in fitPoly format</h2><span id='topic+read_fitpoly'></span>

<h3>Description</h3>

<p>Reads an external data file generated as output of <code><a href="fitPoly.html#topic+saveMarkerModels">saveMarkerModels</a></code>. 
This function creates an object of class <code>mappoly.data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fitpoly(
  file.in,
  ploidy,
  parent1,
  parent2,
  offspring = NULL,
  filter.non.conforming = TRUE,
  elim.redundant = TRUE,
  parent.geno = c("joint", "max"),
  thresh.parent.geno = 0.95,
  prob.thres = 0.95,
  file.type = c("table", "csv"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_fitpoly_+3A_file.in">file.in</code></td>
<td>
<p>a character string with the name of (or full path to) the input file</p>
</td></tr>
<tr><td><code id="read_fitpoly_+3A_ploidy">ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code id="read_fitpoly_+3A_parent1">parent1</code></td>
<td>
<p>a character string containing the name (or pattern of genotype IDs) of parent 1</p>
</td></tr>
<tr><td><code id="read_fitpoly_+3A_parent2">parent2</code></td>
<td>
<p>a character string containing the name (or pattern of genotype IDs) of parent 2</p>
</td></tr>
<tr><td><code id="read_fitpoly_+3A_offspring">offspring</code></td>
<td>
<p>a character string containing the name (or pattern of genotype IDs) of the offspring 
individuals. If <code>NULL</code> (default) it considers all individuals as offsprings, except 
<code>parent1</code> and <code>parent2</code>.</p>
</td></tr>
<tr><td><code id="read_fitpoly_+3A_filter.non.conforming">filter.non.conforming</code></td>
<td>
<p>if <code>TRUE</code> (default) converts data points with unexpected 
genotypes (i.e. no double reduction) to 'NA'. See function <code><a href="#topic+segreg_poly">segreg_poly</a></code> 
for information on expected classes and their respective frequencies.</p>
</td></tr>
<tr><td><code id="read_fitpoly_+3A_elim.redundant">elim.redundant</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), removes redundant markers
during map construction, keeping them annotated to in order to include them in the final map.</p>
</td></tr>
<tr><td><code id="read_fitpoly_+3A_parent.geno">parent.geno</code></td>
<td>
<p>indicates whether to use the joint probability <code>'joint'</code> (default) or the 
maximum probability of multiple replicates (if available) to assign dosage to parents. 
If there is one observation per parent, both options will yield the same results.</p>
</td></tr>
<tr><td><code id="read_fitpoly_+3A_thresh.parent.geno">thresh.parent.geno</code></td>
<td>
<p>threshold probability to assign a dosage to parents. If the probability 
is smaller than <code>thresh.parent.geno</code>, the marker is discarded.</p>
</td></tr>
<tr><td><code id="read_fitpoly_+3A_prob.thres">prob.thres</code></td>
<td>
<p>threshold probability to assign a dosage to offspring. If the probability 
is smaller than <code>prob.thres</code>, the data point is converted to 'NA'.</p>
</td></tr>
<tr><td><code id="read_fitpoly_+3A_file.type">file.type</code></td>
<td>
<p>indicates whether the characters in the input file are separated by 
'white spaces' (&quot;table&quot;) or by commas (&quot;csv&quot;).</p>
</td></tr>
<tr><td><code id="read_fitpoly_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mappoly.data</code> which contains a
list with the following components:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>ploidy level</p>
</td></tr>
<tr><td><code>n.ind</code></td>
<td>
<p>number individuals</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>total number of markers</p>
</td></tr>
<tr><td><code>ind.names</code></td>
<td>
<p>the names of the individuals</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of the markers</p>
</td></tr>
<tr><td><code>dosage.p1</code></td>
<td>
<p>a vector containing the dosage in
parent P for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>dosage.p2</code></td>
<td>
<p>a vector containing the dosage in
parent Q for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating which sequence each marker
belongs. Zero indicates that the marker was not assigned to any
sequence</p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>Physical position of the markers into the
sequence</p>
</td></tr>
<tr><td><code>seq.ref</code></td>
<td>
<p>NULL (unused in this type of data)</p>
</td></tr>
<tr><td><code>seq.alt</code></td>
<td>
<p>NULL (unused in this type of data)</p>
</td></tr>
<tr><td><code>all.mrk.depth</code></td>
<td>
<p>NULL (unused in this type of data)</p>
</td></tr>
<tr><td><code>geno.dose</code></td>
<td>
<p>a matrix containing the dosage for each markers (rows) 
for each individual (columns). Missing data are represented by 
<code>ploidy_level + 1</code></p>
</td></tr>
<tr><td><code>n.phen</code></td>
<td>
<p>number of phenotypic traits</p>
</td></tr>
<tr><td><code>phen</code></td>
<td>
<p>a matrix containing the phenotypic data. The rows
correspond to the traits and the columns correspond
to the individuals</p>
</td></tr>
<tr><td><code>kept</code></td>
<td>
<p>if elim.redundant = TRUE, holds all non-redundant markers</p>
</td></tr>
<tr><td><code>elim.correspondence</code></td>
<td>
<p>if elim.redundant = TRUE, holds all non-redundant markers and
its equivalence to the redundant ones</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Voorrips, R.E., Gort, G. &amp; Vosman, B. (2011) Genotype calling 
in tetraploid species from bi-allelic marker data using mixture 
models. _BMC Bioinformatics_.
<a href="https://doi.org/10.1186/1471-2105-12-172">doi:10.1186/1471-2105-12-172</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Tetraploid Example
ft &lt;- "https://raw.githubusercontent.com/mmollina/MAPpoly_vignettes/master/data/fitpoly.dat"
tempfl &lt;- tempfile()
download.file(ft, destfile = tempfl)
fitpoly.dat &lt;- read_fitpoly(file.in = tempfl, ploidy = 4, 
                            parent1 = "P1", parent2 = "P2", 
                            verbose = TRUE)
print(fitpoly.dat, detailed = TRUE)
plot(fitpoly.dat)
plot_mrk_info(fitpoly.dat, 37)


</code></pre>

<hr>
<h2 id='read_geno'>Data Input</h2><span id='topic+read_geno'></span><span id='topic+print.mappoly.data'></span><span id='topic+plot.mappoly.data'></span>

<h3>Description</h3>

<p>Reads an external data file. The format of the file is described in the <code>Details</code>
section. This function creates an object of class <code>mappoly.data</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_geno(
  file.in,
  filter.non.conforming = TRUE,
  elim.redundant = TRUE,
  verbose = TRUE
)

## S3 method for class 'mappoly.data'
print(x, detailed = FALSE, ...)

## S3 method for class 'mappoly.data'
plot(x, thresh.line = 1e-05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_geno_+3A_file.in">file.in</code></td>
<td>
<p>a character string with the name of (or full path to) the input file
which contains the data to be read</p>
</td></tr>
<tr><td><code id="read_geno_+3A_filter.non.conforming">filter.non.conforming</code></td>
<td>
<p>if <code>TRUE</code> (default) converts data points with unexpected 
genotypes (i.e. no double reduction) to 'NA'. See function <code><a href="#topic+segreg_poly">segreg_poly</a></code> 
for information on expected classes and their respective frequencies.</p>
</td></tr>
<tr><td><code id="read_geno_+3A_elim.redundant">elim.redundant</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), removes redundant markers
during map construction, keeping them annotated to export to the final map.</p>
</td></tr>
<tr><td><code id="read_geno_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
<tr><td><code id="read_geno_+3A_x">x</code></td>
<td>
<p>an object of class <code>mappoly.data</code></p>
</td></tr>
<tr><td><code id="read_geno_+3A_detailed">detailed</code></td>
<td>
<p>if available, print the number of markers per sequence (default = FALSE)</p>
</td></tr>
<tr><td><code id="read_geno_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="read_geno_+3A_thresh.line">thresh.line</code></td>
<td>
<p>position of a threshold line for p values of the segregation test (default = 10e-06)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first line of the input file contains the string <code>ploidy</code> followed by the ploidy level of the parents.
The second and third lines contain the strings <code>n.ind</code> and <code>n.mrk</code> followed by the number of individuals in 
the dataset and the total number of markers, respectively. Lines number 4 and 5 contain the strings
<code>mrk.names</code> and <code>ind.names</code> followed by a sequence of the names of the markers and the name of the individuals, 
respectively. Lines 6 and 7 contain the strings <code>dosageP</code> and <code>dosageQ</code> followed by a sequence of numbers 
containing the dosage of all markers in parent <code>P</code> and <code>Q</code>. Line 8, contains the string seq followed by 
a sequence of integer numbers indicating the chromosome each marker belongs. It can be any 'a priori' 
information regarding the physical distance between markers. For example, these numbers could refer 
to chromosomes, scaffolds or even contigs, in which the markers are positioned. If this information 
is not available for a particular marker, NA should be used. If this information is not available for 
any of the markers, the string <code>seq</code> should be followed by a single <code>NA</code>. Line number 9 contains the string 
<code>seqpos</code> followed by the physical position of the markers into the sequence. The physical position can be 
given in any unity of physical genomic distance (base pairs, for instance). However, the user should be 
able to make decisions based on these values, such as the occurrence of crossing overs, etc. Line number 10 
should contain the string <code>nphen</code> followed by the number of phenotypic traits. Line number 11 is skipped 
(Usually used as a spacer). The next elements are strings containing the name of the phenotypic trait with no space characters
followed by the phenotypic values. The number of lines should be the same number of phenotypic traits. 
<code>NA</code> represents missing values. The line number 12 + <code>nphen</code> is skipped. Finally, the last element is a table
containing the dosage for each marker (rows) for each individual (columns). <code>NA</code> represents missing values.
</p>


<h3>Value</h3>

<p>An object of class <code>mappoly.data</code> which contains a
list with the following components:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>ploidy level</p>
</td></tr>
<tr><td><code>n.ind</code></td>
<td>
<p>number individuals</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>total number of markers</p>
</td></tr>
<tr><td><code>ind.names</code></td>
<td>
<p>the names of the individuals</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of the markers</p>
</td></tr>
<tr><td><code>dosage.p1</code></td>
<td>
<p>a vector containing the dosage in
parent P for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>dosage.p2</code></td>
<td>
<p>a vector containing the dosage in
parent Q for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating which sequence each marker
belongs. Zero indicates that the marker was not assigned to any
sequence</p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>Physical position of the markers into the
sequence</p>
</td></tr>
<tr><td><code>seq.ref</code></td>
<td>
<p>NULL (unused in this type of data)</p>
</td></tr>
<tr><td><code>seq.alt</code></td>
<td>
<p>NULL (unused in this type of data)</p>
</td></tr>
<tr><td><code>all.mrk.depth</code></td>
<td>
<p>NULL (unused in this type of data)</p>
</td></tr>
<tr><td><code>geno.dose</code></td>
<td>
<p>a matrix containing the dosage for each markers (rows) 
for each individual (columns). Missing data are represented by 
<code>ploidy_level + 1</code></p>
</td></tr>
<tr><td><code>n.phen</code></td>
<td>
<p>number of phenotypic traits</p>
</td></tr>
<tr><td><code>phen</code></td>
<td>
<p>a matrix containing the phenotypic data. The rows
correspond to the traits and the columns correspond
to the individuals</p>
</td></tr>
<tr><td><code>kept</code></td>
<td>
<p>if elim.redundant = TRUE, holds all non-redundant markers</p>
</td></tr>
<tr><td><code>elim.correspondence</code></td>
<td>
<p>if elim.redundant = TRUE, holds all non-redundant markers and
its equivalence to the redundant ones</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari M., Olukolu B. A.,  Pereira G. da S., 
Khan A., Gemenet D., Yencho G. C., Zeng Z-B. (2020), 
Unraveling the Hexaploid Sweetpotato Inheritance 
Using Ultra-Dense Multilocus Mapping, 
_G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400620">doi:10.1534/g3.119.400620</a> 
</p>
<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Tetraploid Example
fl1 = "https://raw.githubusercontent.com/mmollina/MAPpoly_vignettes/master/data/SolCAP_dosage"
tempfl &lt;- tempfile()
download.file(fl1, destfile = tempfl)
SolCAP.dose &lt;- read_geno(file.in  = tempfl)
print(SolCAP.dose, detailed = TRUE)
plot(SolCAP.dose)

</code></pre>

<hr>
<h2 id='read_geno_csv'>Data Input in CSV format</h2><span id='topic+read_geno_csv'></span>

<h3>Description</h3>

<p>Reads an external comma-separated values (CSV) data file. The format of the file is described in the <code>Details</code>
section. This function creates an object of class <code>mappoly.data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_geno_csv(
  file.in,
  ploidy,
  filter.non.conforming = TRUE,
  elim.redundant = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_geno_csv_+3A_file.in">file.in</code></td>
<td>
<p>a character string with the name of (or full path to) the input file 
containing the data to be read</p>
</td></tr>
<tr><td><code id="read_geno_csv_+3A_ploidy">ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code id="read_geno_csv_+3A_filter.non.conforming">filter.non.conforming</code></td>
<td>
<p>if <code>TRUE</code> (default) converts data points with unexpected 
genotypes (i.e. no double reduction) to 'NA'. See function <code><a href="#topic+segreg_poly">segreg_poly</a></code> 
for information on expected classes and their respective frequencies.</p>
</td></tr>
<tr><td><code id="read_geno_csv_+3A_elim.redundant">elim.redundant</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), removes redundant markers
during map construction, keeping them annotated to export to the final map.</p>
</td></tr>
<tr><td><code id="read_geno_csv_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an alternative and a somewhat more straightforward version of the function 
<code><a href="#topic+read_geno">read_geno</a></code>. The input is a standard CSV file where the rows 
represent the markers, except for the first row which is used as a header. 
The first five columns contain the marker names, the dosage in parents 1 and 2, 
the chromosome information (i.e. chromosome,  scaffold, contig, etc) and the 
position of the marker within the sequence. The remaining columns contain 
the dosage of the full-sib population. A tetraploid example of such file 
can be found in the <code>Examples</code> section.
</p>


<h3>Value</h3>

<p>An object of class <code>mappoly.data</code> which contains a
list with the following components:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>ploidy level</p>
</td></tr>
<tr><td><code>n.ind</code></td>
<td>
<p>number individuals</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>total number of markers</p>
</td></tr>
<tr><td><code>ind.names</code></td>
<td>
<p>the names of the individuals</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of the markers</p>
</td></tr>
<tr><td><code>dosage.p1</code></td>
<td>
<p>a vector containing the dosage in
parent P for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>dosage.p2</code></td>
<td>
<p>a vector containing the dosage in
parent Q for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating which sequence each marker
belongs. Zero indicates that the marker was not assigned to any
sequence</p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>Physical position of the markers into the
sequence</p>
</td></tr>
<tr><td><code>seq.ref</code></td>
<td>
<p>NULL (unused in this type of data)</p>
</td></tr>
<tr><td><code>seq.alt</code></td>
<td>
<p>NULL (unused in this type of data)</p>
</td></tr>
<tr><td><code>all.mrk.depth</code></td>
<td>
<p>NULL (unused in this type of data)</p>
</td></tr>
<tr><td><code>geno.dose</code></td>
<td>
<p>a matrix containing the dosage for each markers (rows) 
for each individual (columns). Missing data are represented by 
<code>ploidy_level + 1</code></p>
</td></tr>
<tr><td><code>n.phen</code></td>
<td>
<p>number of phenotypic traits</p>
</td></tr>
<tr><td><code>phen</code></td>
<td>
<p>a matrix containing the phenotypic data. The rows
correspond to the traits and the columns correspond
to the individuals</p>
</td></tr>
<tr><td><code>kept</code></td>
<td>
<p>if elim.redundant = TRUE, holds all non-redundant markers</p>
</td></tr>
<tr><td><code>elim.correspondence</code></td>
<td>
<p>if elim.redundant = TRUE, holds all non-redundant markers and
its equivalence to the redundant ones</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>, with minor changes by Gabriel Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari M., Olukolu B. A.,  Pereira G. da S., 
Khan A., Gemenet D., Yencho G. C., Zeng Z-B. (2020), 
Unraveling the Hexaploid Sweetpotato Inheritance 
Using Ultra-Dense Multilocus Mapping, 
_G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400620">doi:10.1534/g3.119.400620</a> 
</p>
<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Tetraploid Example
ft = "https://raw.githubusercontent.com/mmollina/MAPpoly_vignettes/master/data/tetra_solcap.csv"
tempfl &lt;- tempfile()
download.file(ft, destfile = tempfl)
SolCAP.dose &lt;- read_geno_csv(file.in  = tempfl, ploidy = 4)
print(SolCAP.dose, detailed = TRUE)
plot(SolCAP.dose)

</code></pre>

<hr>
<h2 id='read_geno_prob'>Data Input</h2><span id='topic+read_geno_prob'></span>

<h3>Description</h3>

<p>Reads an external data file. The format of the file is described in the <code>Details</code>
section. This function creates an object of class <code>mappoly.data</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_geno_prob(
  file.in,
  prob.thres = 0.95,
  filter.non.conforming = TRUE,
  elim.redundant = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_geno_prob_+3A_file.in">file.in</code></td>
<td>
<p>a character string with the name of (or full path to) the input file which contains the data to
be read</p>
</td></tr>
<tr><td><code id="read_geno_prob_+3A_prob.thres">prob.thres</code></td>
<td>
<p>probability threshold to associate a marker call to a 
dosage. Markers with maximum genotype probability smaller than <code>prob.thres</code> 
are considered as missing data for the dosage calling purposes (default = 0.95)</p>
</td></tr>
<tr><td><code id="read_geno_prob_+3A_filter.non.conforming">filter.non.conforming</code></td>
<td>
<p>if <code>TRUE</code> (default) converts data points with unexpected 
genotypes (i.e. no double reduction) to 'NA'. See function <code><a href="#topic+segreg_poly">segreg_poly</a></code> 
for information on expected classes and their respective frequencies.</p>
</td></tr>
<tr><td><code id="read_geno_prob_+3A_elim.redundant">elim.redundant</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), removes redundant markers
during map construction, keeping them annotated to export to the final map.</p>
</td></tr>
<tr><td><code id="read_geno_prob_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first line of the input file contains the string <code>ploidy</code> followed by the ploidy level of the parents.
The second and third lines contains the strings <code>n.ind</code> and <code>n.mrk</code> followed by the number of individuals in 
the dataset and the total number of markers, respectively. Lines number 4 and 5 contain the string 
<code>mrk.names</code> and <code>ind.names</code> followed by a sequence of the names of the markers and the name of the individuals, 
respectively. Lines 6 and 7 contain the strings <code>dosageP</code> and <code>dosageQ</code> followed by a sequence of numbers 
containing the dosage of all markers in parent <code>P</code> and <code>Q</code>. Line 8, contains the string seq followed by 
a sequence of integer numbers indicating the chromosome each marker belongs. It can be any 'a priori' 
information regarding the physical distance between markers. For example, these numbers could refer 
to chromosomes, scaffolds or even contigs, in which the markers are positioned. If this information 
is not available for a particular marker, NA should be used. If this information is not available for 
any of the markers, the string <code>seq</code> should be followed by a single <code>NA</code>. Line number 9 contains the string 
<code>seqpos</code> followed by the physical position of the markers into the sequence. The physical position can be 
given in any unity of physical genomic distance (base pairs, for instance). However, the user should be 
able to make decisions based on these values, such as the occurrence of crossing overs, etc. Line number 10 
should contain the string <code>nphen</code> followed by the number of phenotypic traits. Line number 11 is skipped 
(Usually used as a spacer). The next elements are strings containing the name of the phenotypic trait with no space characters
followed by the phenotypic values. The number of lines should be the same number of phenotypic traits. 
<code>NA</code> represents missing values. The line number 12 + <code>nphen</code> is skipped. Finally, the last element is a table 
containing the probability distribution for each combination of marker and offspring. The first two columns 
represent the marker and the offspring, respectively. The remaining elements represent the probability 
associated with each one of the possible dosages. <code>NA</code> represents missing data.
</p>


<h3>Value</h3>

<p>an object of class <code>mappoly.data</code> which contains a
list with the following components:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>ploidy level</p>
</td></tr>
<tr><td><code>n.ind</code></td>
<td>
<p>number individuals</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>total number of markers</p>
</td></tr>
<tr><td><code>ind.names</code></td>
<td>
<p>the names of the individuals</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of the markers</p>
</td></tr>
<tr><td><code>dosage.p1</code></td>
<td>
<p>a vector containing the dosage in
parent P for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>dosage.p2</code></td>
<td>
<p>a vector containing the dosage in
parent Q for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating which sequence each marker
belongs. Zero indicates that the marker was not assigned to any
sequence</p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>physical position of the markers into the
sequence</p>
</td></tr>
<tr><td><code>seq.ref</code></td>
<td>
<p>NULL (unused in this type of data)</p>
</td></tr>
<tr><td><code>seq.alt</code></td>
<td>
<p>NULL (unused in this type of data)</p>
</td></tr>
<tr><td><code>all.mrk.depth</code></td>
<td>
<p>NULL (unused in this type of data)</p>
</td></tr>
<tr><td><code>prob.thres</code></td>
<td>
<p>probability threshold to associate a marker call to a 
dosage. Markers with maximum genotype probability smaller than 'prob.thres' 
were considered as missing data in the 'geno.dose' matrix</p>
</td></tr>
<tr><td><code>geno.dose</code></td>
<td>
<p>a matrix containing the dosage for each markers (rows) 
for each individual (columns). Missing data are represented by 
<code>ploidy_level + 1</code></p>
</td></tr>
<tr><td><code>geno</code></td>
<td>
<p>a data.frame 
containing the probability distribution for each combination of
marker and offspring. The first two columns represent the marker
and the offspring, respectively. The remaining elements represent
the probability associated to each one of the possible
dosages. Missing data are converted from NA to the expected
segregation ratio using function <code><a href="#topic+segreg_poly">segreg_poly</a></code></p>
</td></tr>
<tr><td><code>n.phen</code></td>
<td>
<p>number of phenotypic traits</p>
</td></tr>
<tr><td><code>phen</code></td>
<td>
<p>a matrix containing the phenotypic data. The rows
correspond to the traits and the columns correspond
to the individuals</p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>a vector containing p-values related to the chi-squared 
test of Mendelian segregation performed for all markers</p>
</td></tr>
<tr><td><code>kept</code></td>
<td>
<p>if elim.redundant = TRUE, holds all non-redundant markers</p>
</td></tr>
<tr><td><code>elim.correspondence</code></td>
<td>
<p>if elim.redundant = TRUE, holds all non-redundant markers and
its equivalence to the redundant ones</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari M., Olukolu B. A.,  Pereira G. da S., 
Khan A., Gemenet D., Yencho G. C., Zeng Z-B. (2020), 
Unraveling the Hexaploid Sweetpotato Inheritance 
Using Ultra-Dense Multilocus Mapping, 
_G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400620">doi:10.1534/g3.119.400620</a> 
</p>
<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Tetraploid Example
ft = "https://raw.githubusercontent.com/mmollina/MAPpoly_vignettes/master/data/hexa_sample"
tempfl &lt;- tempfile()
download.file(ft, destfile = tempfl)
SolCAP.dose.prob &lt;- read_geno_prob(file.in  = tempfl)
print(SolCAP.dose.prob, detailed = TRUE)
plot(SolCAP.dose.prob)


</code></pre>

<hr>
<h2 id='read_vcf'>Data Input VCF</h2><span id='topic+read_vcf'></span>

<h3>Description</h3>

<p>Reads an external VCF file and creates an object of class <code>mappoly.data</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_vcf(
  file.in,
  parent.1,
  parent.2,
  ploidy = NA,
  filter.non.conforming = TRUE,
  thresh.line = 0.05,
  min.gt.depth = 0,
  min.av.depth = 0,
  max.missing = 1,
  elim.redundant = TRUE,
  verbose = TRUE,
  read.geno.prob = FALSE,
  prob.thres = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_vcf_+3A_file.in">file.in</code></td>
<td>
<p>a character string with the name of (or full path to) the 
input file which contains the data (VCF format)</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_parent.1">parent.1</code></td>
<td>
<p>a character string containing the name of parent 1</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_parent.2">parent.2</code></td>
<td>
<p>a character string containing the name of parent 2</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_ploidy">ploidy</code></td>
<td>
<p>the species ploidy (optional, it will be automatically detected)</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_filter.non.conforming">filter.non.conforming</code></td>
<td>
<p>if <code>TRUE</code> (default) converts data points with unexpected 
genotypes (i.e. no double reduction) to 'NA'. See function <code><a href="#topic+segreg_poly">segreg_poly</a></code> 
for information on expected classes and their respective frequencies.</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_thresh.line">thresh.line</code></td>
<td>
<p>threshold used for p-values on segregation test (default = 0.05)</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_min.gt.depth">min.gt.depth</code></td>
<td>
<p>minimum genotype depth to keep information. 
If the genotype depth is below <code>min.gt.depth</code>,
it will be replaced with NA (default = 0)</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_min.av.depth">min.av.depth</code></td>
<td>
<p>minimum average depth to keep markers (default = 0)</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_max.missing">max.missing</code></td>
<td>
<p>maximum proportion of missing data to keep markers (range = 0-1; default = 1)</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_elim.redundant">elim.redundant</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), removes redundant markers
during map construction, keeping them annotated to export to the final map.</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_read.geno.prob">read.geno.prob</code></td>
<td>
<p>If genotypic probabilities are available (PL field),
generates a probability-based dataframe (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_prob.thres">prob.thres</code></td>
<td>
<p>probability threshold to associate a marker call to a 
dosage. Markers with maximum genotype probability smaller than <code>prob.thres</code> 
are considered as missing data for the dosage calling purposes (default = 0.95)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can handle .vcf files versions 4.0 or higher. The ploidy 
can be automatically detected, but it is highly recommended that you 
inform it to check for mismatches. All individual and marker names 
will be kept as they are in the .vcf file.
</p>


<h3>Value</h3>

<p>An object of class <code>mappoly.data</code> which contains a
list with the following components:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>ploidy level</p>
</td></tr>
<tr><td><code>n.ind</code></td>
<td>
<p>number individuals</p>
</td></tr>
<tr><td><code>n.mrk</code></td>
<td>
<p>total number of markers</p>
</td></tr>
<tr><td><code>ind.names</code></td>
<td>
<p>the names of the individuals</p>
</td></tr>
<tr><td><code>mrk.names</code></td>
<td>
<p>the names of the markers</p>
</td></tr>
<tr><td><code>dosage.p1</code></td>
<td>
<p>a vector containing the dosage in
parent P for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>dosage.p2</code></td>
<td>
<p>a vector containing the dosage in
parent Q for all <code>n.mrk</code> markers</p>
</td></tr>
<tr><td><code>chrom</code></td>
<td>
<p>a vector indicating which sequence each marker
belongs. Zero indicates that the marker was not assigned to any
sequence</p>
</td></tr>
<tr><td><code>genome.pos</code></td>
<td>
<p>Physical position of the markers into the
sequence</p>
</td></tr>
<tr><td><code>seq.ref</code></td>
<td>
<p>Reference base used for each marker (i.e. A, T, C, G)</p>
</td></tr>
<tr><td><code>seq.alt</code></td>
<td>
<p>Alternative base used for each marker (i.e. A, T, C, G)</p>
</td></tr>
<tr><td><code>prob.thres</code></td>
<td>
<p>(unused field)</p>
</td></tr>
<tr><td><code>geno.dose</code></td>
<td>
<p>a matrix containing the dosage for each markers (rows) 
for each individual (columns). Missing data are represented by 
<code>ploidy_level + 1</code></p>
</td></tr>
<tr><td><code>geno</code></td>
<td>
<p>a dataframe containing all genotypic probabilities columns for each
marker and individual combination (rows). Missing data are represented by 
<code>ploidy_level + 1</code></p>
</td></tr>
<tr><td><code>nphen</code></td>
<td>
<p>(unused field)</p>
</td></tr>
<tr><td><code>phen</code></td>
<td>
<p>(unused field)</p>
</td></tr>
<tr><td><code>all.mrk.depth</code></td>
<td>
<p>DP information for all markers on VCF file</p>
</td></tr>
<tr><td><code>chisq.pval</code></td>
<td>
<p>a vector containing p-values related to the chi-squared 
test of Mendelian segregation performed for all markers</p>
</td></tr>
<tr><td><code>kept</code></td>
<td>
<p>if elim.redundant = TRUE, holds all non-redundant markers</p>
</td></tr>
<tr><td><code>elim.correspondence</code></td>
<td>
<p>if elim.redundant = TRUE, holds all non-redundant markers and
its equivalence to the redundant ones</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabriel Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari M., Olukolu B. A.,  Pereira G. da S., 
Khan A., Gemenet D., Yencho G. C., Zeng Z-B. (2020), 
Unraveling the Hexaploid Sweetpotato Inheritance 
Using Ultra-Dense Multilocus Mapping, 
_G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400620">doi:10.1534/g3.119.400620</a> 
</p>
<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Hexaploid sweetpotato: Subset of chromosome 3
fl = "https://github.com/mmollina/MAPpoly_vignettes/raw/master/data/sweet_sample_ch3.vcf.gz"
tempfl &lt;- tempfile(pattern = 'chr3_', fileext = '.vcf.gz')
download.file(fl, destfile = tempfl)
dat.dose.vcf = read_vcf(file = tempfl, parent.1 = "PARENT1", parent.2 = "PARENT2")
print(dat.dose.vcf)
plot(dat.dose.vcf)


</code></pre>

<hr>
<h2 id='reest_rf'>Re-estimate the recombination fractions in a genetic map</h2><span id='topic+reest_rf'></span>

<h3>Description</h3>

<p>This function re-estimates the recombination fractions between all markers in a given map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reest_rf(
  input.map,
  input.mat = NULL,
  tol = 0.01,
  phase.config = "all",
  method = c("hmm", "ols", "wMDS_to_1D_pc"),
  weight = TRUE,
  verbose = TRUE,
  high.prec = FALSE,
  max.rf.to.break.EM = 0.5,
  input.mds = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reest_rf_+3A_input.map">input.map</code></td>
<td>
<p>An object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="reest_rf_+3A_input.mat">input.mat</code></td>
<td>
<p>An object of class <code>mappoly.rf.matrix</code></p>
</td></tr>
<tr><td><code id="reest_rf_+3A_tol">tol</code></td>
<td>
<p>tolerance for determining convergence (default = 10e-03)</p>
</td></tr>
<tr><td><code id="reest_rf_+3A_phase.config">phase.config</code></td>
<td>
<p>which phase configuration should be used. &quot;best&quot; (default) 
will choose the maximum likelihood configuration</p>
</td></tr>
<tr><td><code id="reest_rf_+3A_method">method</code></td>
<td>
<p>indicates whether to use <code>'hmm'</code> (Hidden Markov Models), 
<code>'ols'</code> (Ordinary Least Squares) or <code>'wMDS_to_1D_pc'</code> (weighted MDS 
followed by fitting a one dimensional principal curve) to re-estimate the 
recombination fractions.</p>
</td></tr>
<tr><td><code id="reest_rf_+3A_weight">weight</code></td>
<td>
<p>if <code>TRUE</code> (default), it uses the LOD scores to perform a weighted
regression when the Ordinary Least Squares is chosen</p>
</td></tr>
<tr><td><code id="reest_rf_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
<tr><td><code id="reest_rf_+3A_high.prec">high.prec</code></td>
<td>
<p>logical. If <code>TRUE</code> uses high precision 
(long double) numbers in the HMM procedure implemented in C++,
which can take a long time to perform (default = FALSE)</p>
</td></tr>
<tr><td><code id="reest_rf_+3A_max.rf.to.break.em">max.rf.to.break.EM</code></td>
<td>
<p>for internal use only.</p>
</td></tr>
<tr><td><code id="reest_rf_+3A_input.mds">input.mds</code></td>
<td>
<p>An object of class <code>mappoly.map</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated object of class <code>mappoly.pcmap</code> whose 
order was used in the <code>input.map</code>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>     
</p>
<p>Stam P (1993) Construction of integrated genetic-linkage maps 
by means of a new computer package: Joinmap. _Plant J_ 3:739744
<a href="https://doi.org/10.1111/j.1365-313X.1993.00739.x">doi:10.1111/j.1365-313X.1993.00739.x</a>
</p>

<hr>
<h2 id='rev_map'>Reverse map</h2><span id='topic+rev_map'></span>

<h3>Description</h3>

<p>Provides the reverse of a given map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rev_map(input.map)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rev_map_+3A_input.map">input.map</code></td>
<td>
<p>an object of class <code>mappoly.map</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_genome_vs_map(solcap.mds.map[[1]])
plot_genome_vs_map(rev_map(solcap.mds.map[[1]]))
</code></pre>

<hr>
<h2 id='rf_list_to_matrix'>Recombination fraction list to matrix</h2><span id='topic+rf_list_to_matrix'></span><span id='topic+print.mappoly.rf.matrix'></span><span id='topic+plot.mappoly.rf.matrix'></span>

<h3>Description</h3>

<p>Transforms the recombination fraction list contained in an object
of class <code>mappoly.twopt</code> or <code>mappoly.twopt2</code> into a recombination
fraction matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_list_to_matrix(
  input.twopt,
  thresh.LOD.ph = 0,
  thresh.LOD.rf = 0,
  thresh.rf = 0.5,
  ncpus = 1L,
  shared.alleles = FALSE,
  verbose = TRUE
)

## S3 method for class 'mappoly.rf.matrix'
print(x, ...)

## S3 method for class 'mappoly.rf.matrix'
plot(
  x,
  type = c("rf", "lod"),
  ord = NULL,
  rem = NULL,
  main.text = NULL,
  index = FALSE,
  fact = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rf_list_to_matrix_+3A_input.twopt">input.twopt</code></td>
<td>
<p>an object of class <code>mappoly.twopt</code> or <code>mappoly.twopt2</code></p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_thresh.lod.ph">thresh.LOD.ph</code></td>
<td>
<p>LOD score threshold for linkage phase configurations (default = 0)</p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_thresh.lod.rf">thresh.LOD.rf</code></td>
<td>
<p>LOD score threshold for recombination fractions (default = 0)</p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_thresh.rf">thresh.rf</code></td>
<td>
<p>the threshold used for recombination fraction filtering (default = 0.5)</p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_ncpus">ncpus</code></td>
<td>
<p>number of parallel processes (i.e. cores) to spawn (default = 1)</p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_shared.alleles">shared.alleles</code></td>
<td>
<p>if <code>TRUE</code>, computes two matrices (for both parents) indicating 
the number of homologues that share alleles (default = FALSE)</p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_x">x</code></td>
<td>
<p>an object of class <code>mappoly.rf.matrix</code></p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_type">type</code></td>
<td>
<p>type of matrix that should be printed. Can be one of the
following: <code>"rf"</code>, for recombination fraction or <code>"lod"</code>
for LOD Score</p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_ord">ord</code></td>
<td>
<p>the order in which the markers should be plotted (default = NULL)</p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_rem">rem</code></td>
<td>
<p>which markers should be removed from the heatmap (default = NULL)</p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_main.text">main.text</code></td>
<td>
<p>a character string as the title of the heatmap (default = NULL)</p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_index">index</code></td>
<td>
<p><code>logical</code> should the name of the markers be printed in the 
diagonal of the heatmap? (default = FALSE)</p>
</td></tr>
<tr><td><code id="rf_list_to_matrix_+3A_fact">fact</code></td>
<td>
<p>positive integer. factor expressed as number of cells to be aggregated 
(default = 1, no aggregation)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>thresh_LOD_ph</code> should be set in order to only select
recombination fractions that have LOD scores associated to the
linkage phase configuration higher than <code>thresh_LOD_ph</code>
when compared to the second most likely linkage phase configuration.
</p>


<h3>Value</h3>

<p>A list containing two matrices. The first one contains the
filtered recombination fraction and the second one contains the
information matrix
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    all.mrk &lt;- make_seq_mappoly(hexafake, 1:20)
    red.mrk &lt;- elim_redundant(all.mrk)
    unique.mrks &lt;- make_seq_mappoly(red.mrk)
    all.pairs &lt;- est_pairwise_rf(input.seq = unique.mrks,
                               ncpus = 1,
                               verbose = TRUE)

    ## Full recombination fraction matrix
    mat.full &lt;- rf_list_to_matrix(input.twopt = all.pairs)
    plot(mat.full)
    plot(mat.full, type = "lod")
 
</code></pre>

<hr>
<h2 id='rf_snp_filter'>Remove markers that do not meet a LOD criteria</h2><span id='topic+rf_snp_filter'></span>

<h3>Description</h3>

<p>Remove markers that do not meet a LOD and recombination fraction
criteria for at least a percentage of the pairwise marker
combinations. It also removes markers with strong evidence of
linkage across the whole linkage group (false positive).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_snp_filter(
  input.twopt,
  thresh.LOD.ph = 5,
  thresh.LOD.rf = 5,
  thresh.rf = 0.15,
  probs = c(0.05, 1),
  diag.markers = NULL,
  mrk.order = NULL,
  ncpus = 1L,
  diagnostic.plot = TRUE,
  breaks = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rf_snp_filter_+3A_input.twopt">input.twopt</code></td>
<td>
<p>an object of class <code>mappoly.twopt</code></p>
</td></tr>
<tr><td><code id="rf_snp_filter_+3A_thresh.lod.ph">thresh.LOD.ph</code></td>
<td>
<p>LOD score threshold for linkage phase configuration
(default = 5)</p>
</td></tr>
<tr><td><code id="rf_snp_filter_+3A_thresh.lod.rf">thresh.LOD.rf</code></td>
<td>
<p>LOD score threshold for recombination fraction
(default = 5)</p>
</td></tr>
<tr><td><code id="rf_snp_filter_+3A_thresh.rf">thresh.rf</code></td>
<td>
<p>threshold for recombination fractions (default = 0.15)</p>
</td></tr>
<tr><td><code id="rf_snp_filter_+3A_probs">probs</code></td>
<td>
<p>indicates the probability corresponding to the filtering
quantiles. (default = c(0.05, 1))</p>
</td></tr>
<tr><td><code id="rf_snp_filter_+3A_diag.markers">diag.markers</code></td>
<td>
<p>A window where marker pairs should be considered.
If NULL (default), all markers are considered.</p>
</td></tr>
<tr><td><code id="rf_snp_filter_+3A_mrk.order">mrk.order</code></td>
<td>
<p>marker order. Only has effect if 'diag.markers' is not NULL</p>
</td></tr>
<tr><td><code id="rf_snp_filter_+3A_ncpus">ncpus</code></td>
<td>
<p>number of parallel processes (i.e. cores) to spawn
(default = 1)</p>
</td></tr>
<tr><td><code id="rf_snp_filter_+3A_diagnostic.plot">diagnostic.plot</code></td>
<td>
<p>if <code>TRUE</code> produces a diagnostic plot</p>
</td></tr>
<tr><td><code id="rf_snp_filter_+3A_breaks">breaks</code></td>
<td>
<p>number of cells for the histogram</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>thresh.LOD.ph</code> should be set in order to only select
recombination fractions that have LOD scores associated to the
linkage phase configuration higher than <code>thresh_LOD_ph</code>
when compared to the second most likely linkage phase configuration.
That action usually eliminates markers that are unlinked to the
set of analyzed markers.
</p>


<h3>Value</h3>

<p>A filtered object of class <code>mappoly.sequence</code>.
See <code><a href="#topic+make_seq_mappoly">make_seq_mappoly</a></code> for details
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a> with updates by Gabriel Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_.
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    all.mrk &lt;- make_seq_mappoly(hexafake, 1:20)
    red.mrk &lt;- elim_redundant(all.mrk)
    unique.mrks &lt;- make_seq_mappoly(red.mrk)
    all.pairs &lt;- est_pairwise_rf(input.seq = unique.mrks,
                               ncpus = 1,
                               verbose = TRUE)

    ## Full recombination fraction matrix
    mat.full &lt;- rf_list_to_matrix(input.twopt = all.pairs)
    plot(mat.full)

    ## Removing disruptive SNPs
    tpt.filt &lt;- rf_snp_filter(all.pairs, 2, 2, 0.07, probs = c(0.15, 1))
    p1.filt &lt;- make_pairs_mappoly(input.seq = tpt.filt, input.twopt = all.pairs)
    m1.filt &lt;- rf_list_to_matrix(input.twopt = p1.filt)
    plot(mat.full, main.text = "LG1")
    plot(m1.filt, main.text = "LG1.filt")

</code></pre>

<hr>
<h2 id='sample_data'>Random sampling of dataset</h2><span id='topic+sample_data'></span>

<h3>Description</h3>

<p>Random sampling of dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_data(
  input.data,
  n = NULL,
  percentage = NULL,
  type = c("individual", "marker"),
  selected.ind = NULL,
  selected.mrk = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_data_+3A_input.data">input.data</code></td>
<td>
<p>an object  of class <code>mappoly.data</code></p>
</td></tr>
<tr><td><code id="sample_data_+3A_n">n</code></td>
<td>
<p>number of individuals or markers to be sampled</p>
</td></tr>
<tr><td><code id="sample_data_+3A_percentage">percentage</code></td>
<td>
<p>if <code>n == NULL</code>, the percentage of individuals or markers to be sampled</p>
</td></tr>
<tr><td><code id="sample_data_+3A_type">type</code></td>
<td>
<p>should sample individuals or markers?</p>
</td></tr>
<tr><td><code id="sample_data_+3A_selected.ind">selected.ind</code></td>
<td>
<p>a vector containing the name of the individuals to select. Only has effect 
if <code>type = "individual"</code>, <code>n = NULL</code> and <code>percentage = NULL</code></p>
</td></tr>
<tr><td><code id="sample_data_+3A_selected.mrk">selected.mrk</code></td>
<td>
<p>a vector containing the name of the markers to select. Only has effect 
if <code>type = "marker"</code>, <code>n = NULL</code> and <code>percentage = NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object  of class <code>mappoly.data</code>
</p>

<hr>
<h2 id='segreg_poly'>Polysomic segregation frequency</h2><span id='topic+segreg_poly'></span>

<h3>Description</h3>

<p>Computes the polysomic segregation frequency given a ploidy level
and the dosage of the locus in both parents. It does not consider
double reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segreg_poly(ploidy, dP, dQ)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segreg_poly_+3A_ploidy">ploidy</code></td>
<td>
<p>the ploidy level</p>
</td></tr>
<tr><td><code id="segreg_poly_+3A_dp">dP</code></td>
<td>
<p>the dosage in parent P</p>
</td></tr>
<tr><td><code id="segreg_poly_+3A_dq">dQ</code></td>
<td>
<p>the dosage in parent Q</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the expected segregation frequency for
all possible genotypic classes.
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>
<p>Serang O, Mollinari M, Garcia AAF (2012) Efficient Exact 
Maximum a Posteriori Computation for Bayesian SNP 
Genotyping in Polyploids. _PLoS ONE_ 7(2): 
e30906.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># autohexaploid with two and three doses in parents P and Q,
# respectively
seg &lt;- segreg_poly(ploidy = 6, dP = 2, dQ = 3)
barplot(seg, las = 2)

</code></pre>

<hr>
<h2 id='select_rf'>Select rf and lod based on thresholds</h2><span id='topic+select_rf'></span>

<h3>Description</h3>

<p>Select rf and lod based on thresholds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_rf(x, thresh.LOD.ph, thresh.LOD.rf, thresh.rf, shared.alleles = FALSE)
</code></pre>

<hr>
<h2 id='sim_cross_one_informative_parent'>Simulate mapping population (one parent)</h2><span id='topic+sim_cross_one_informative_parent'></span>

<h3>Description</h3>

<p>This function simulates a polyploid mapping population
under random chromosome segregation
with one informative parent. This function is not to be
directly called by the user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_cross_one_informative_parent(
  ploidy,
  n.mrk,
  rf.vec,
  hom.allele,
  n.ind,
  seed = NULL,
  prob = NULL
)
</code></pre>

<hr>
<h2 id='sim_cross_two_informative_parents'>Simulate mapping population (tow parents)</h2><span id='topic+sim_cross_two_informative_parents'></span>

<h3>Description</h3>

<p>Simulate mapping population (tow parents)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_cross_two_informative_parents(
  ploidy,
  n.mrk,
  rf.vec,
  n.ind,
  hom.allele.p,
  hom.allele.q,
  prob.P = NULL,
  prob.Q = NULL,
  seed = NULL
)
</code></pre>

<hr>
<h2 id='sim_homologous'>Simulate homology groups</h2><span id='topic+sim_homologous'></span>

<h3>Description</h3>

<p>Simulate two homology groups (one for each parent) and their
linkage phase configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_homologous(ploidy, n.mrk, prob.dose = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_homologous_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy level. Must be an even number</p>
</td></tr>
<tr><td><code id="sim_homologous_+3A_n.mrk">n.mrk</code></td>
<td>
<p>number of markers</p>
</td></tr>
<tr><td><code id="sim_homologous_+3A_prob.dose">prob.dose</code></td>
<td>
<p>a vector indicating the proportion of markers for
different dosage to be simulated (default = NULL)</p>
</td></tr>
<tr><td><code id="sim_homologous_+3A_seed">seed</code></td>
<td>
<p>random number generator seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prevents the simulation of linkage phase
configurations which are impossible to estimate via two point
methods
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>hom.allele.p</code></td>
<td>
<p> a list of vectors
containing linkage phase configurations. Each vector contains the
numbers of the homologous chromosomes in which the alleles are
located. For instance, a vector containing <code class="reqn">(1,3,4)</code> means that
the marker has three doses located in the chromosomes 1, 3 and 4. For
zero doses, use 0</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>contains the indices of the starting positions of the
dosages, considering that the vectors contained in <code>p</code> are
concatenated. Markers with no doses (zero doses are also
considered)</p>
</td></tr>
<tr><td><code>hom.allele.q</code></td>
<td>
<p>Analogously to <code>hom.allele.p</code></p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>Analogously to <code>p</code></p>
</td></tr>
<tr><td><code>ploidy</code></td>
<td>
<p>ploidy level</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    h.temp &lt;- sim_homologous(ploidy = 6, n.mrk = 20)

</code></pre>

<hr>
<h2 id='solcap.dose.map'>Resulting maps from <code><a href="#topic+tetra.solcap">tetra.solcap</a></code></h2><span id='topic+solcap.dose.map'></span>

<h3>Description</h3>

<p>A list containing 12 linkage groups estimated using genomic order and dosage call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solcap.dose.map
</code></pre>


<h3>Format</h3>

<p>A list containing 12 objects of class <code>mappoly.map</code>, each one 
representing one linkage group in the <code><a href="#topic+tetra.solcap">tetra.solcap</a></code> dataset.
</p>

<hr>
<h2 id='solcap.err.map'>Resulting maps from <code><a href="#topic+tetra.solcap">tetra.solcap</a></code></h2><span id='topic+solcap.err.map'></span>

<h3>Description</h3>

<p>A list containing 12 linkage groups estimated using genomic order, dosage call and global calling error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solcap.err.map
</code></pre>


<h3>Format</h3>

<p>A list containing 12 objects of class <code>mappoly.map</code>, each one 
representing one linkage group in the <code><a href="#topic+tetra.solcap">tetra.solcap</a></code> dataset.
</p>

<hr>
<h2 id='solcap.mds.map'>Resulting maps from <code><a href="#topic+tetra.solcap">tetra.solcap</a></code></h2><span id='topic+solcap.mds.map'></span>

<h3>Description</h3>

<p>A list containing 12 linkage groups estimated using <code><a href="#topic+mds_mappoly">mds_mappoly</a></code> order and dosage call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solcap.mds.map
</code></pre>


<h3>Format</h3>

<p>A list containing 12 objects of class <code>mappoly.map</code>, each one 
representing one linkage group in the <code><a href="#topic+tetra.solcap">tetra.solcap</a></code> dataset.
</p>

<hr>
<h2 id='solcap.prior.map'>Resulting maps from <code><a href="#topic+tetra.solcap.geno.dist">tetra.solcap.geno.dist</a></code></h2><span id='topic+solcap.prior.map'></span>

<h3>Description</h3>

<p>A list containing 12 linkage groups estimated using genomic order and prior probability distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solcap.prior.map
</code></pre>


<h3>Format</h3>

<p>A list containing 12 objects of class <code>mappoly.map</code>, each one 
representing one linkage group in the <code><a href="#topic+tetra.solcap.geno.dist">tetra.solcap.geno.dist</a></code> dataset.
</p>

<hr>
<h2 id='split_and_rephase'>Divides map in sub-maps and re-phase them</h2><span id='topic+split_and_rephase'></span>

<h3>Description</h3>

<p>The function splits the input map in sub-maps 
given a distance threshold of neighboring markers 
and evaluates alternative phases between the sub-maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_and_rephase(
  input.map,
  twopt,
  gap.threshold = 5,
  size.rem.cluster = 1,
  phase.config = "best",
  thres.twopt = 3,
  thres.hmm = "best",
  tol.merge = 0.001,
  tol.final = 0.001,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_and_rephase_+3A_input.map">input.map</code></td>
<td>
<p>an object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="split_and_rephase_+3A_twopt">twopt</code></td>
<td>
<p>an object of class <code>mappoly.twopt</code>
containing the two-point information for the markers contained 
in <code>input.map</code></p>
</td></tr>
<tr><td><code id="split_and_rephase_+3A_gap.threshold">gap.threshold</code></td>
<td>
<p>distance threshold of neighboring markers 
where the map should be spitted. The default 
value is 5 cM</p>
</td></tr>
<tr><td><code id="split_and_rephase_+3A_size.rem.cluster">size.rem.cluster</code></td>
<td>
<p>the size of the marker cluster (in number of markers) 
from which the cluster should be removed. The default 
value is 1</p>
</td></tr>
<tr><td><code id="split_and_rephase_+3A_phase.config">phase.config</code></td>
<td>
<p>which phase configuration should be used. &quot;best&quot; (default) 
will choose the maximum likelihood phase configuration</p>
</td></tr>
<tr><td><code id="split_and_rephase_+3A_thres.twopt">thres.twopt</code></td>
<td>
<p>the threshold used to determine if the linkage
phases compared via two-point analysis should be considered 
for the search space reduction (default = 3)</p>
</td></tr>
<tr><td><code id="split_and_rephase_+3A_thres.hmm">thres.hmm</code></td>
<td>
<p>the threshold used to determine which linkage 
phase configurations should be returned when merging two maps.
If &quot;best&quot; (default), returns only the best linkage phase 
configuration. NOTE: if merging multiple maps, it always uses 
the &quot;best&quot; linkage phase configuration at each block insertion.</p>
</td></tr>
<tr><td><code id="split_and_rephase_+3A_tol.merge">tol.merge</code></td>
<td>
<p>the desired accuracy for merging maps (default = 10e-04)</p>
</td></tr>
<tr><td><code id="split_and_rephase_+3A_tol.final">tol.final</code></td>
<td>
<p>the desired accuracy for the final map (default = 10e-04)</p>
</td></tr>
<tr><td><code id="split_and_rephase_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mappoly.map</code>
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari, M., and Garcia, A.  A. F. (2019) Linkage
analysis and haplotype phasing in experimental autopolyploid
populations with high ploidy level using hidden Markov
models, _G3: Genes, Genomes, Genetics_. 
<a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> map &lt;- get_submap(solcap.dose.map[[1]], 1:20, verbose = FALSE)
 tpt &lt;- est_pairwise_rf(make_seq_mappoly(map))
 new.map &lt;- split_and_rephase(map, tpt, 1, 1)
 map
 new.map
 plot_map_list(list(old.map = map, new.map = new.map), col = "ggstyle")

</code></pre>

<hr>
<h2 id='split_mappoly'>Split map into sub maps given a gap threshold</h2><span id='topic+split_mappoly'></span>

<h3>Description</h3>

<p>Split map into sub maps given a gap threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_mappoly(
  input.map,
  gap.threshold = 5,
  size.rem.cluster = 1,
  phase.config = "best",
  tol.final = 0.001,
  verbose = TRUE
)
</code></pre>

<hr>
<h2 id='summary_maps'>Summary maps</h2><span id='topic+summary_maps'></span>

<h3>Description</h3>

<p>This function generates a brief summary table of a list of <code>mappoly.map</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_maps(map.list, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_maps_+3A_map.list">map.list</code></td>
<td>
<p>a list of objects of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="summary_maps_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), the current progress is shown; if
<code>FALSE</code>, no output is produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing a brief summary of all maps contained in <code>map.list</code>
</p>


<h3>Author(s)</h3>

<p>Gabriel Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tetra.sum &lt;- summary_maps(solcap.err.map)
tetra.sum
</code></pre>

<hr>
<h2 id='table_to_mappoly'>Conversion of data.frame to mappoly.data</h2><span id='topic+table_to_mappoly'></span>

<h3>Description</h3>

<p>Conversion of data.frame to mappoly.data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_to_mappoly(
  dat,
  ploidy,
  filter.non.conforming = TRUE,
  elim.redundant = TRUE,
  verbose = TRUE
)
</code></pre>

<hr>
<h2 id='tetra.solcap'>Autotetraploid potato dataset.</h2><span id='topic+tetra.solcap'></span>

<h3>Description</h3>

<p>A dataset of the B2721 population which derived from a cross between 
two tetraploid potato varieties: Atlantic  B1829-5. The population comprises 160 
offsprings genotyped with the SolCAP Infinium 8303 potato array. The original data 
set can be found in [The Solanaceae Coordinated Agricultural Project (SolCAP) webpage](http://solcap.msu.edu/potato_infinium.shtml) 
The dataset also contains the genomic order of the SNPs from the Solanum 
tuberosum genome version 4.03. The genotype calling was performed using the
fitPoly R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tetra.solcap
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mappoly.data</code> which contains a
list with the following components:
</p>

<dl>
<dt>ploidy</dt><dd><p>ploidy level = 4</p>
</dd>
<dt>n.ind</dt><dd><p>number individuals = 160</p>
</dd>
<dt>n.mrk</dt><dd><p>total number of markers = 4017</p>
</dd>
<dt>ind.names</dt><dd><p>the names of the individuals</p>
</dd>
<dt>mrk.names</dt><dd><p>the names of the markers</p>
</dd>
<dt>dosage.p1</dt><dd><p>a vector containing the dosage in
parent P for all <code>n.mrk</code> markers</p>
</dd>
<dt>dosage.p2</dt><dd><p>a vector containing the dosage in
parent Q for all <code>n.mrk</code> markers</p>
</dd>
<dt>chrom</dt><dd><p>a vector indicating the chromosome each marker
belongs. Zero indicates that the marker was not assigned to any
sequence</p>
</dd>
<dt>genome.pos</dt><dd><p>Physical position of the markers into the
sequence</p>
</dd>
<dt>geno.dose</dt><dd><p>a matrix containing the dosage for each markers (rows) 
for each individual (columns). Missing data are represented by 
<code>ploidy_level + 1 = 5</code></p>
</dd>
<dt>n.phen</dt><dd><p>There are no phenotypes in this simulation</p>
</dd>
<dt>phen</dt><dd><p>There are no phenotypes in this simulation</p>
</dd>
<dt>chisq.pval</dt><dd><p>vector containing p-values for all markers associated to 
the chi-square test for the expected segregation patterns 
under Mendelian segregation</p>
</dd>
</dl>


<hr>
<h2 id='tetra.solcap.geno.dist'>Autotetraploid potato dataset with genotype probabilities.</h2><span id='topic+tetra.solcap.geno.dist'></span>

<h3>Description</h3>

<p>A dataset of the B2721 population which derived from a cross between 
two tetraploid potato varieties: Atlantic  B1829-5. The population comprises 160 
offsprings genotyped with the SolCAP Infinium 8303 potato array. The original data 
set can be found in [The Solanaceae Coordinated Agricultural Project (SolCAP) webpage](http://solcap.msu.edu/potato_infinium.shtml) 
The dataset also contains the genomic order of the SNPs from the Solanum 
tuberosum genome version 4.03. The genotype calling was performed using the
fitPoly R package. Although this dataset contains the
probability distribution of the genotypes, 
it is essentially the same dataset found in <code><a href="#topic+tetra.solcap">tetra.solcap</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tetra.solcap.geno.dist
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mappoly.data</code> which contains a
list with the following components:
</p>

<dl>
<dt>ploidy</dt><dd><p>ploidy level = 4</p>
</dd>
<dt>n.ind</dt><dd><p>number individuals = 160</p>
</dd>
<dt>n.mrk</dt><dd><p>total number of markers = 4017</p>
</dd>
<dt>ind.names</dt><dd><p>the names of the individuals</p>
</dd>
<dt>mrk.names</dt><dd><p>the names of the markers</p>
</dd>
<dt>dosage.p1</dt><dd><p>a vector containing the dosage in
parent P for all <code>n.mrk</code> markers</p>
</dd>
<dt>dosage.p2</dt><dd><p>a vector containing the dosage in
parent Q for all <code>n.mrk</code> markers</p>
</dd>
<dt>chrom</dt><dd><p>a vector indicating which sequence each marker
belongs. Zero indicates that the marker was not assigned to any
sequence</p>
</dd>
<dt>genome.pos</dt><dd><p>Physical position of the markers into the
sequence</p>
</dd>
<dt>prob.thres = 0.95</dt><dd><p>probability threshold to associate a marker 
call to a dosage. Markers with maximum genotype 
probability smaller than 'prob.thres' are considered 
as missing data for the dosage calling purposes</p>
</dd>
<dt>geno</dt><dd><p>a data.frame 
containing the probability distribution for each combination of
marker and offspring. The first two columns represent the marker
and the offspring, respectively. The remaining elements represent
the probability associated to each one of the possible
dosages</p>
</dd>
<dt>geno.dose</dt><dd><p>a matrix containing the dosage for each markers (rows) 
for each individual (columns). Missing data are represented by 
<code>ploidy_level + 1 = 5</code></p>
</dd>
<dt>n.phen</dt><dd><p>There are no phenotypes in this simulation</p>
</dd>
<dt>phen</dt><dd><p>There are no phenotypes in this simulation</p>
</dd>
</dl>


<hr>
<h2 id='update_framework_map'>Add markers that are informative in both parents using HMM approach and evaluating difference 
in LOD and gap size</h2><span id='topic+update_framework_map'></span>

<h3>Description</h3>

<p>Add markers that are informative in both parents using HMM approach and evaluating difference 
in LOD and gap size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_framework_map(
  input.map.list,
  input.seq,
  twopt,
  thres.twopt = 10,
  init.LOD = 30,
  verbose = TRUE,
  method = "hmm",
  input.mds = NULL,
  max.rounds = 50,
  size.rem.cluster = 2,
  gap.threshold = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_framework_map_+3A_input.map.list">input.map.list</code></td>
<td>
<p>list containing three <code>mappoly.map</code> objects:1) map built with markers with segregation information from parent 1; 
2) map built with markers with segregation information from parent 2; 3) maps in 1 and 2 merged</p>
</td></tr>
<tr><td><code id="update_framework_map_+3A_input.seq">input.seq</code></td>
<td>
<p>object of class <code>mappoly.sequence</code> containing all markers for specific group</p>
</td></tr>
<tr><td><code id="update_framework_map_+3A_twopt">twopt</code></td>
<td>
<p>object of class <code>mappoly.twopt</code></p>
</td></tr>
<tr><td><code id="update_framework_map_+3A_thres.twopt">thres.twopt</code></td>
<td>
<p>the LOD threshold used to determine if the linkage phases compared via two-point 
analysis should be considered for the search space reduction (default = 5)</p>
</td></tr>
<tr><td><code id="update_framework_map_+3A_init.lod">init.LOD</code></td>
<td>
<p>the LOD threshold used to determine if the marker will be included or not after hmm analysis  (default = 30)</p>
</td></tr>
<tr><td><code id="update_framework_map_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE (default), current progress is shown; if FALSE, no output is produced</p>
</td></tr>
<tr><td><code id="update_framework_map_+3A_method">method</code></td>
<td>
<p>indicates whether to use 'hmm' (Hidden Markov Models), 'ols' (Ordinary Least Squares) or 'wMDS_to_1D_pc' 
(weighted MDS followed by fitting a one dimensional principal curve) to re-estimate the recombination fractions after adding markers</p>
</td></tr>
<tr><td><code id="update_framework_map_+3A_input.mds">input.mds</code></td>
<td>
<p>An object of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="update_framework_map_+3A_max.rounds">max.rounds</code></td>
<td>
<p>integer defining number of times to try to fit the remaining markers in the sequence</p>
</td></tr>
<tr><td><code id="update_framework_map_+3A_size.rem.cluster">size.rem.cluster</code></td>
<td>
<p>threshold for number of markers that must contain in a segment after a gap is removed to keep this segment in the sequence</p>
</td></tr>
<tr><td><code id="update_framework_map_+3A_gap.threshold">gap.threshold</code></td>
<td>
<p>threshold for gap size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>mappoly.map2</code>
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a> with documentation and minor modifications by Cristiane Taniguti <a href="mailto:chtaniguti@tamu.edu">chtaniguti@tamu.edu</a>
</p>

<hr>
<h2 id='update_map'>Update map</h2><span id='topic+update_map'></span>

<h3>Description</h3>

<p>This function takes an object of class <code>mappoly.map</code> and checks for
removed redundant markers in the original dataset. Once redundant markers
are found, they are re-added to the map in their respective equivalent positions
and another HMM round is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_map(input.maps, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_map_+3A_input.maps">input.maps</code></td>
<td>
<p>a single map or a list of maps of class <code>mappoly.map</code></p>
</td></tr>
<tr><td><code id="update_map_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE (default), shows information about each update process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated map (or list of maps) of class <code>mappoly.map</code>, containing the original map(s) plus redundant markers
</p>


<h3>Author(s)</h3>

<p>Gabriel Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orig.map &lt;- solcap.err.map
up.map &lt;- lapply(solcap.err.map, update_map)
summary_maps(orig.map)
summary_maps(up.map)
</code></pre>

<hr>
<h2 id='update_missing'>Update missing information</h2><span id='topic+update_missing'></span>

<h3>Description</h3>

<p>Update missing information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_missing(input.data, prob.thres = 0.95)
</code></pre>

<hr>
<h2 id='update_ph_list_at_hmm_thres'>makes a phase list from map, selecting only 
configurations under a certain threshold</h2><span id='topic+update_ph_list_at_hmm_thres'></span>

<h3>Description</h3>

<p>makes a phase list from map, selecting only 
configurations under a certain threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_ph_list_at_hmm_thres(map, thres.hmm)
</code></pre>

<hr>
<h2 id='v_2_m'>Conversion: vector to matrix</h2><span id='topic+v_2_m'></span>

<h3>Description</h3>

<p>Conversion: vector to matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v_2_m(x, n)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
