<!DOCTYPE html><html><head><title>Help for package data.table</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {data.table}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#:='><p> Assignment by reference</p></a></li>
<li><a href='#.Last.updated'><p> Number of rows affected by last update</p></a></li>
<li><a href='#address'><p> Address in RAM of a variable</p></a></li>
<li><a href='#all.equal'><p> Equality Test Between Two Data Tables</p></a></li>
<li><a href='#as.data.table'><p>Coerce to data.table</p></a></li>
<li><a href='#as.data.table.xts'><p>Efficient xts to as.data.table conversion</p></a></li>
<li><a href='#as.matrix'><p>Convert a data.table to a matrix</p></a></li>
<li><a href='#as.xts.data.table'><p>Efficient data.table to xts conversion</p></a></li>
<li><a href='#between'><p> Convenience functions for range subsets.</p></a></li>
<li><a href='#cdt'><p> data.table exported C routines</p></a></li>
<li><a href='#chmatch'><p> Faster match of character vectors</p></a></li>
<li><a href='#copy'><p> Copy an entire object</p></a></li>
<li><a href='#data.table-class'><p>S4 Definition for data.table</p></a></li>
<li><a href='#data.table-package'><p> Enhanced data.frame</p></a></li>
<li><a href='#datatable.optimize'><p>Optimisations in data.table</p></a></li>
<li><a href='#dcast.data.table'><p>Fast dcast for data.table</p></a></li>
<li><a href='#duplicated'><p> Determine Duplicate Rows</p></a></li>
<li><a href='#fcase'><p>fcase</p></a></li>
<li><a href='#fcoalesce'><p> Coalescing missing values</p></a></li>
<li><a href='#fdroplevels'><p>Fast droplevels</p></a></li>
<li><a href='#fifelse'><p> Fast ifelse</p></a></li>
<li><a href='#foverlaps'><p>Fast overlap joins</p></a></li>
<li><a href='#frank'><p>Fast rank</p></a></li>
<li><a href='#fread'><p> Fast and friendly file finagler</p></a></li>
<li><a href='#fsort'><p>Fast parallel sort</p></a></li>
<li><a href='#fwrite'><p>Fast CSV writer</p></a></li>
<li><a href='#groupingsets'><p> Grouping Set aggregation for data tables</p></a></li>
<li><a href='#IDateTime'><p> Integer based date class</p></a></li>
<li><a href='#J'>
<p>Creates a join <code>data.table</code></p></a></li>
<li><a href='#key&lt;-'><p> Deprecated.</p></a></li>
<li><a href='#last'><p> First/last item of an object</p></a></li>
<li><a href='#like'><p> Convenience function for calling grep.</p></a></li>
<li><a href='#measure'><p>Specify measure.vars via regex or separator</p></a></li>
<li><a href='#melt.data.table'><p>Fast melt for data.table</p></a></li>
<li><a href='#merge'><p>Merge two data.tables</p></a></li>
<li><a href='#na.omit.data.table'><p> Remove rows with missing values on columns specified</p></a></li>
<li><a href='#nafill'><p>Fill missing values</p></a></li>
<li><a href='#notin'>
<p>Convenience operator for checking if an example is not in a set of elements</p></a></li>
<li><a href='#patterns'><p>Obtain matching indices corresponding to patterns</p></a></li>
<li><a href='#print.data.table'><p> data.table Printing Options</p></a></li>
<li><a href='#rbindlist'><p> Makes one data.table from a list of many</p></a></li>
<li><a href='#rleid'><p>Generate run-length type group id</p></a></li>
<li><a href='#roll'><p>Rolling functions</p></a></li>
<li><a href='#rowid'><p> Generate unique row ids within each group</p></a></li>
<li><a href='#setattr'><p> Set attributes of objects by reference</p></a></li>
<li><a href='#setcolorder'><p>Fast column reordering of a data.table by reference</p></a></li>
<li><a href='#setDF'><p>Coerce a data.table to data.frame by reference</p></a></li>
<li><a href='#setDT'><p>Coerce lists and data.frames to data.table by reference</p></a></li>
<li><a href='#setDTthreads'><p> Set or get number of threads that data.table should use</p></a></li>
<li><a href='#setkey'><p> Create key on a data.table</p></a></li>
<li><a href='#setNumericRounding'><p> Change or turn off numeric rounding</p></a></li>
<li><a href='#setops'><p> Set operations for data tables</p></a></li>
<li><a href='#setorder'><p>Fast row reordering of a data.table by reference</p></a></li>
<li><a href='#shift'><p>Fast lead/lag for vectors and lists</p></a></li>
<li><a href='#shouldPrint'><p> For use by packages that mimic/divert auto printing e.g. IRkernel and knitr</p></a></li>
<li><a href='#special-symbols'><p> Special symbols</p></a></li>
<li><a href='#split'><p> Split data.table into chunks in a list</p></a></li>
<li><a href='#subset.data.table'><p> Subsetting data.tables</p></a></li>
<li><a href='#substitute2'><p> Substitute expression</p></a></li>
<li><a href='#tables'><p>Display 'data.table' metadata</p></a></li>
<li><a href='#test'><p> Test assertions for equality, exceptions and console output</p></a></li>
<li><a href='#test.data.table'><p> Runs a set of tests.</p></a></li>
<li><a href='#timetaken'><p> Pretty print of time taken</p></a></li>
<li><a href='#transform.data.table'><p> Data table utilities</p></a></li>
<li><a href='#transpose'><p>Efficient transpose of list</p></a></li>
<li><a href='#truelength'><p> Over-allocation access</p></a></li>
<li><a href='#tstrsplit'><p>strsplit and transpose the resulting list efficiently</p></a></li>
<li><a href='#update_dev_pkg'><p>Perform update of development version of a package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.15.4</td>
</tr>
<tr>
<td>Title:</td>
<td>Extension of 'data.frame'</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bit64 (&ge; 4.0.0), bit (&ge; 4.0.4), R.utils, xts, zoo (&ge;
1.8-1), yaml, knitr, markdown</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast aggregation of large data (e.g. 100GB in RAM), fast ordered joins, fast add/modify/delete of columns by group using no copies at all, list columns, friendly and fast character-separated-value read/write. Offers a natural and flexible syntax, for faster development.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL-2.0</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-datatable.com">https://r-datatable.com</a>, <a href="https://Rdatatable.gitlab.io/data.table">https://Rdatatable.gitlab.io/data.table</a>,
<a href="https://github.com/Rdatatable/data.table">https://github.com/Rdatatable/data.table</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Rdatatable/data.table/issues">https://github.com/Rdatatable/data.table/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-28 05:25:20 UTC; tysonbarrett</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyson Barrett [aut, cre],
  Matt Dowle [aut],
  Arun Srinivasan [aut],
  Jan Gorecki [aut],
  Michael Chirico [aut],
  Toby Hocking <a href="https://orcid.org/0000-0002-3146-0865"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Pasha Stetsenko [ctb],
  Tom Short [ctb],
  Steve Lianoglou [ctb],
  Eduard Antonyan [ctb],
  Markus Bonsch [ctb],
  Hugh Parsonage [ctb],
  Scott Ritchie [ctb],
  Kun Ren [ctb],
  Xianying Tan [ctb],
  Rick Saporta [ctb],
  Otto Seiskari [ctb],
  Xianghui Dong [ctb],
  Michel Lang [ctb],
  Watal Iwasaki [ctb],
  Seth Wenchel [ctb],
  Karl Broman [ctb],
  Tobias Schmidt [ctb],
  David Arenburg [ctb],
  Ethan Smith [ctb],
  Francois Cocquemas [ctb],
  Matthieu Gomez [ctb],
  Philippe Chataignon [ctb],
  Nello Blaser [ctb],
  Dmitry Selivanov [ctb],
  Andrey Riabushenko [ctb],
  Cheng Lee [ctb],
  Declan Groves [ctb],
  Daniel Possenriede [ctb],
  Felipe Parages [ctb],
  Denes Toth [ctb],
  Mus Yaramaz-David [ctb],
  Ayappan Perumal [ctb],
  James Sams [ctb],
  Martin Morgan [ctb],
  Michael Quinn [ctb],
  @javrucebo [ctb],
  @marc-outins [ctb],
  Roy Storey [ctb],
  Manish Saraswat [ctb],
  Morgan Jacob [ctb],
  Michael Schubmehl [ctb],
  Davis Vaughan [ctb],
  Leonardo Silvestri [ctb],
  Jim Hester [ctb],
  Anthony Damico [ctb],
  Sebastian Freundt [ctb],
  David Simons [ctb],
  Elliott Sales de Andrade [ctb],
  Cole Miller [ctb],
  Jens Peder Meldgaard [ctb],
  Vaclav Tlapak [ctb],
  Kevin Ushey [ctb],
  Dirk Eddelbuettel [ctb],
  Benjamin Schwendinger [ctb],
  Tony Fischetti [ctb],
  Ofek Shilon [ctb],
  Vadim Khotilovich [ctb],
  Hadley Wickham [ctb],
  Bennet Becker [ctb],
  Kyle Haynes [ctb],
  Boniface Christian Kamgang [ctb],
  Olivier Delmarcell [ctb],
  Josh O'Brien [ctb],
  Dereck de Mezquita [ctb],
  Michael Czekanski [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyson Barrett &lt;t.barrett88@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-30 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+3A+3D'> Assignment by reference </h2><span id='topic++3A+3D'></span><span id='topic+set'></span><span id='topic+let'></span>

<h3>Description</h3>

<p>Fast add, remove and update subsets of columns, by reference. <code>:=</code> operator can be used in two ways: <code>LHS := RHS</code> form, and <code>Functional form</code>. See <code>Usage</code>.
</p>
<p><code>set</code> is a low-overhead loop-able version of <code>:=</code>. It is particularly useful for repetitively updating rows of certain columns by reference (using a for-loop). See <code>Examples</code>. It can not perform grouping operations.
</p>
<p><code>let</code> is an alias for the functional form and behaves exactly like <code>`:=`</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># 1. LHS := RHS form
# DT[i, LHS := RHS, by = ...]
# DT[i, c("LHS1", "LHS2") := list(RHS1, RHS2), by = ...]

# 2a. Functional form with `:=`
# DT[i, `:=`(LHS1 = RHS1,
#            LHS2 = RHS2,
#            ...), by = ...]

# 2b. Functional form with let
# DT[i, let(LHS1 = RHS1,
#            LHS2 = RHS2,
#            ...), by = ...]

set(x, i = NULL, j, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B3A+2B3D_+3A_lhs">LHS</code></td>
<td>
<p> A character vector of column names (or numeric positions) or a variable that evaluates as such. If the column doesn't exist, it is added, <em>by reference</em>. </p>
</td></tr>
<tr><td><code id="+2B3A+2B3D_+3A_rhs">RHS</code></td>
<td>
<p> A list of replacement values. It is recycled in the usual way to fill the number of rows satisfying <code>i</code>, if any.  To remove a column use <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="+2B3A+2B3D_+3A_x">x</code></td>
<td>
<p> A <code>data.table</code>. Or, <code>set()</code> accepts <code>data.frame</code>, too. </p>
</td></tr>
<tr><td><code id="+2B3A+2B3D_+3A_i">i</code></td>
<td>
<p> Optional. Indicates the rows on which the values must be updated with. If not provided, implies <em>all rows</em>. The <code>:=</code> form is more powerful as it allows <em>subsets</em> and <code>joins</code> based add/update columns by reference. See <code>Details</code>.
</p>
<p>In <code>set</code>, only integer type is allowed in <code>i</code> indicating which rows <code>value</code> should be assigned to. <code>NULL</code> represents all rows more efficiently than creating a vector such as <code>1:nrow(x)</code>. </p>
</td></tr>
<tr><td><code id="+2B3A+2B3D_+3A_j">j</code></td>
<td>
<p> Column name(s) (character) or number(s) (integer) to be assigned <code>value</code> when column(s) already exist, and only column name(s) if they are to be created. </p>
</td></tr>
<tr><td><code id="+2B3A+2B3D_+3A_value">value</code></td>
<td>
<p> A list of replacement values to assign by reference to <code>x[i, j]</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>:=</code> is defined for use in <code>j</code> only. It <em>adds</em> or <em>updates</em> or <em>removes</em> column(s) by reference. It makes no copies of any part of memory at all. Please read <a href="../doc/datatable-reference-semantics.html"><code>vignette("datatable-reference-semantics")</code></a> and follow with examples. Some typical usages are:
</p>
<pre>
    DT[, col := val]                              # update (or add at the end if doesn't exist) a column called "col" with value "val" (recycled if necessary).
    DT[i, col := val]                             # same as above, but only for those rows specified in i and (for new columns) NA elsewhere.
    DT[i, "col a" := val]                         # same. column is called "col a"
    DT[i, (3:6) := val]                           # update existing columns 3:6 with value. Aside: parens are not required here since : already makes LHS a call rather than a symbol.
    DT[i, colvector := val, with = FALSE]         # OLD syntax. The contents of "colvector" in calling scope determine the column(s).
    DT[i, (colvector) := val]                     # same (NOW PREFERRED) shorthand syntax. The parens are enough to stop the LHS being a symbol; same as c(colvector).
    DT[i, colC := mean(colB), by = colA]          # update (or add) column called "colC" by reference by group. A major feature of `:=`.
    DT[,`:=`(new1 = sum(colB), new2 = sum(colC))] # Functional form
    DT[, let(new1 = sum(colB), new2 = sum(colC))] # New alias for functional form.
</pre>
<p>The <code><a href="#topic+.Last.updated">.Last.updated</a></code> variable contains the number of rows updated by the most recent <code>:=</code> or <code>set</code> calls, which may be useful, for example, in production settings for testing assumptions about the number of rows affected by a statement; see <code><a href="#topic+.Last.updated">.Last.updated</a></code> for details.
</p>
<p>Note that for efficiency no check is performed for duplicate assignments, i.e. if multiple values are passed for assignment to the same index, assignment to this index will occur repeatedly and sequentially; for a given use case, consider whether it makes sense to create your own test for duplicates, e.g. in production code.
</p>
<p>All of the following result in a friendly error (by design) :
</p>
<pre>
    x := 1L
    DT[i, col] := val
    DT[i]$col := val
    DT[, {col1 := 1L; col2 := 2L}]                # Use the functional form, `:=`(), instead (see above).
</pre>
<p>For additional resources, please read <a href="../doc/datatable-faq.html"><code>vignette("datatable-faq")</code></a>. Also have a look at StackOverflow's <a href="https://stackoverflow.com/questions/tagged/data.table/">data.table tag</a>.
</p>
<p><code>:=</code> in <code>j</code> can be combined with all types of <code>i</code> (such as binary search), and all types of <code>by</code>. This a one reason why <code>:=</code> has been implemented in <code>j</code>. Please see <a href="../doc/datatable-reference-semantics"><code>vignette("datatable-reference-semantics")</code></a> and also <code>FAQ 2.16</code> for analogies to SQL.
</p>
<p>When <code>LHS</code> is a factor column and <code>RHS</code> is a character vector with items missing from the factor levels, the new level(s) are automatically added (by reference, efficiently), unlike base methods.
</p>
<p>Unlike <code>&lt;-</code> for <code>data.frame</code>, the (potentially large) LHS is not coerced to match the type of the (often small) RHS. Instead the RHS is coerced to match the type of the LHS, if necessary. Where this involves double precision values being coerced to an integer column, a warning is given when fractional data is truncated. It is best to get the column types correct up front and stick to them. Changing a column type is possible but deliberately harder: provide a whole column as the RHS. This RHS is then <em>plonked</em> into that column slot and we call this <em>plonk syntax</em>, or <em>replace column syntax</em> if you prefer. By needing to construct a full length vector of a new type, you as the user are more aware of what is happening and it is clearer to readers of your code that you really do intend to change the column type; e.g., <code>DT[, colA:=as.integer(colA)]</code>. A plonk occurs whenever you provide a RHS value to ':=' which is <code>nrow</code> long. When a column is <em>plonked</em>, the original column is not updated by reference because that would entail updating every single element of that column whereas the plonk is just one column pointer update.
</p>
<p><code>data.table</code>s are <em>not</em> copied-on-change by <code>:=</code>, <code>setkey</code> or any of the other <code>set*</code> functions. See <code><a href="#topic+copy">copy</a></code>.
</p>


<h3>Value</h3>

<p><code>DT</code> is modified by reference and returned invisibly. If you require a copy, take a <code><a href="#topic+copy">copy</a></code> first (using <code>DT2 = copy(DT)</code>).
</p>


<h3>Advanced (internals):</h3>

<p>It is easy to see how <em>sub-assigning</em> to existing columns is done internally. Removing columns by reference is also straightforward by modifying the vector of column pointers only (using memmove in C). However adding (new) columns is more tricky as to how the <code>data.table</code> can be grown <em>by reference</em>: the list vector of column pointers is <em>over-allocated</em>, see <code><a href="#topic+truelength">truelength</a></code>. By defining <code>:=</code> in <code>j</code> we believe update syntax is natural, and scales, but it also bypasses <code>[&lt;-</code> dispatch and allows <code>:=</code> to update by reference with no copies of any part of memory at all.
</p>
<p>Since <code>[.data.table</code> incurs overhead to check the existence and type of arguments (for example), <code>set()</code> provides direct (but less flexible) assignment by reference with low overhead, appropriate for use inside a <code>for</code> loop. See examples. <code>:=</code> is more powerful and flexible than <code>set()</code> because <code>:=</code> is intended to be combined with <code>i</code> and <code>by</code> in single queries on large datasets.
</p>


<h3>Note</h3>

<p><code>DT[a &gt; 4, b := c]</code> is different from <code>DT[a &gt; 4][, b := c]</code>. The first expression updates (or adds) column <code>b</code> with the value <code>c</code> on those rows where <code>a &gt; 4</code> evaluates to <code>TRUE</code>. <code>X</code> is updated <em>by reference</em>, therefore no assignment needed.
</p>
<p>The second expression on the other hand updates a <em>new</em> <code>data.table</code> that's returned by the subset operation. Since the subsetted data.table is ephemeral (it is not assigned to a symbol), the result would be lost; unless the result is assigned, for example, as follows: <code>ans &lt;- DT[a &gt; 4][, b := c]</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+copy">copy</a></code>, <code><a href="#topic+setalloccol">setalloccol</a></code>, <code><a href="#topic+truelength">truelength</a></code>, <code><a href="#topic+set">set</a></code>, <code><a href="#topic+.Last.updated">.Last.updated</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DT = data.table(a = LETTERS[c(3L,1:3)], b = 4:7)
DT[, c := 8]                # add a numeric column, 8 for all rows
DT[, d := 9L]               # add an integer column, 9L for all rows
DT[, c := NULL]             # remove column c
DT[2, d := -8L]             # subassign by reference to d; 2nd row is -8L now
DT                          # DT changed by reference
DT[2, d := 10L][]           # shorthand for update and print

DT[b &gt; 4, b := d * 2L]      # subassign to b with d*2L on those rows where b &gt; 4 is TRUE
DT[b &gt; 4][, b := d * 2L]    # different from above. [, := ] is performed on the subset
                            # which is an new (ephemeral) data.table. Result needs to be
                            # assigned to a variable (using `&lt;-`).

DT[, e := mean(d), by = a]  # add new column by group by reference
DT["A", b := 0L, on = "a"]  # ad-hoc update of column b for group "A" using
			    # joins-as-subsets with binary search and 'on='
# same as above but using keys
setkey(DT, a)
DT["A", b := 0L]            # binary search for group "A" and set column b using keys
DT["B", f := mean(d)]       # subassign to new column, NA initialized

# Adding multiple columns
## by name
DT[ , c('sin_d', 'log_e', 'cos_d') :=
   .(sin(d), log(e), cos(d))]
## by patterned name
DT[ , paste(c('sin', 'cos'), 'b', sep = '_') :=
   .(sin(b), cos(b))]
## using lapply &amp; .SD
DT[ , paste0('tan_', c('b', 'd', 'e')) :=
   lapply(.SD, tan), .SDcols = c('b', 'd', 'e')]
## using forced evaluation to disambiguate a vector of names
##   and overwrite existing columns with their squares
sq_cols = c('b', 'd', 'e')
DT[ , (sq_cols) := lapply(.SD, `^`, 2L), .SDcols = sq_cols]
## by integer (NB: for robustness, it is not recommended
##   to use explicit integers to update/define columns)
DT[ , c(2L, 3L, 4L) := .(sqrt(b), sqrt(d), sqrt(e))]
## by implicit integer
DT[ , grep('a$', names(DT)) := tolower(a)]
## by implicit integer, using forced evaluation
sq_col_idx = grep('d$', names(DT))
DT[ , (sq_col_idx) := lapply(.SD, dnorm),
   .SDcols = sq_col_idx]

## Not run: 
# Speed example:

m = matrix(1, nrow = 2e6L, ncol = 100L)
DF = as.data.frame(m)
DT = as.data.table(m)

system.time(for (i in 1:1000) DF[i, 1] = i)
# 15.856 seconds
system.time(for (i in 1:1000) DT[i, V1 := i])
# 0.279 seconds  (57 times faster)
system.time(for (i in 1:1000) set(DT, i, 1L, i))
# 0.002 seconds  (7930 times faster, overhead of [.data.table is avoided)

# However, normally, we call [.data.table *once* on *large* data, not many times on small data.
# The above is to demonstrate overhead, not to recommend looping in this way. But the option
# of set() is there if you need it.

## End(Not run)

</code></pre>

<hr>
<h2 id='.Last.updated'> Number of rows affected by last update </h2><span id='topic+.Last.updated'></span><span id='topic+Last.updated'></span>

<h3>Description</h3>

<p>Returns number of rows affected by last <code>:=</code> or <code>set()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    .Last.updated
</code></pre>


<h3>Details</h3>

<p>Be aware that in the case of duplicate indices, multiple updates occur (duplicates are overwritten);
<code>.Last.updated</code> will include <em>all</em> of the
updates performed, including duplicated ones. See examples.
</p>


<h3>Value</h3>

<p>Integer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++3A+3D">:=</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d = data.table(a=1:4, b=2:5)
d[2:3, z:=5L]
.Last.updated

# updated count takes duplicates into account #2837
DT = data.table(a = 1L)
DT[c(1L, 1L), a := 2:3]
.Last.updated
</code></pre>

<hr>
<h2 id='address'> Address in RAM of a variable </h2><span id='topic+address'></span>

<h3>Description</h3>

<p>Returns the pointer address of its argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    address(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="address_+3A_x">x</code></td>
<td>
<p> Anything. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes useful in determining whether a value has been copied or not, programmatically.
</p>


<h3>Value</h3>

<p>A character vector length 1.
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/a/10913296/403310">https://stackoverflow.com/a/10913296/403310</a> (but implemented in C without using <code>.Internal(inspect())</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+copy">copy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=1
address(x)
</code></pre>

<hr>
<h2 id='all.equal'> Equality Test Between Two Data Tables </h2><span id='topic+all.equal'></span><span id='topic+all.equal.data.table'></span>

<h3>Description</h3>

<p>Convenient test of data equality between <code>data.table</code> objects. Performs some factor level <em>stripping</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'data.table'
all.equal(target, current, trim.levels=TRUE, check.attributes=TRUE,
    ignore.col.order=FALSE, ignore.row.order=FALSE, tolerance=sqrt(.Machine$double.eps),
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal_+3A_target">target</code>, <code id="all.equal_+3A_current">current</code></td>
<td>

<p><code>data.table</code>s to compare. If <code>current</code> is not a <code>data.table</code>, but <code>check.attributes</code> is FALSE,
it will be coerced to one via <a href="#topic+as.data.table">as.data.table</a>.
</p>
</td></tr>
<tr><td><code id="all.equal_+3A_trim.levels">trim.levels</code></td>
<td>

<p>A logical indicating whether or not to remove all unused levels in columns
that are factors before running equality check. It effect only when <code>check.attributes</code> is TRUE and <code>ignore.row.order</code> is FALSE.
</p>
</td></tr>
<tr><td><code id="all.equal_+3A_check.attributes">check.attributes</code></td>
<td>

<p>A logical indicating whether or not to check attributes, will apply not only to data.table but also attributes of the columns. It will skip <code>c("row.names",".internal.selfref")</code> data.table attributes.
</p>
</td></tr>
<tr><td><code id="all.equal_+3A_ignore.col.order">ignore.col.order</code></td>
<td>

<p>A logical indicating whether or not to ignore columns order in <code>data.table</code>.
</p>
</td></tr>
<tr><td><code id="all.equal_+3A_ignore.row.order">ignore.row.order</code></td>
<td>

<p>A logical indicating whether or not to ignore rows order in <code>data.table</code>. This option requires datasets to use data types on which join can be made, so no support for <em>list, complex, raw</em>, but still supports <a href="bit64.html#topic+bit64-package">integer64</a>.
</p>
</td></tr>
<tr><td><code id="all.equal_+3A_tolerance">tolerance</code></td>
<td>

<p>A numeric value used when comparing numeric columns, by default <code>sqrt(.Machine$double.eps)</code>. Unless non-default value provided it will be forced to <code>0</code> if used together with <code>ignore.row.order</code> and duplicate rows detected or factor columns present.
</p>
</td></tr>
<tr><td><code id="all.equal_+3A_...">...</code></td>
<td>

<p>Passed down to internal call of <code><a href="base.html#topic+all.equal">all.equal</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For efficiency data.table method will exit on detected non-equality issues, unlike most <code><a href="base.html#topic+all.equal">all.equal</a></code> methods which process equality checks further. Besides that fact it also handles the most time consuming case of <code>ignore.row.order = TRUE</code> very efficiently.
</p>


<h3>Value</h3>

<p>Either <code>TRUE</code> or a vector of mode <code>"character"</code> describing the
differences between <code>target</code> and <code>current</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+all.equal">all.equal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt1 &lt;- data.table(A = letters[1:10], X = 1:10, key = "A")
dt2 &lt;- data.table(A = letters[5:14], Y = 1:10, key = "A")
isTRUE(all.equal(dt1, dt1))
is.character(all.equal(dt1, dt2))

# ignore.col.order
x &lt;- copy(dt1)
y &lt;- dt1[, .(X, A)]
all.equal(x, y)
all.equal(x, y, ignore.col.order = TRUE)

# ignore.row.order
x &lt;- setkeyv(copy(dt1), NULL)
y &lt;- dt1[sample(nrow(dt1))]
all.equal(x, y)
all.equal(x, y, ignore.row.order = TRUE)

# check.attributes
x = copy(dt1)
y = setkeyv(copy(dt1), NULL)
all.equal(x, y)
all.equal(x, y, check.attributes = FALSE)
x = data.table(1L)
y = 1L
all.equal(x, y)
all.equal(x, y, check.attributes = FALSE)

# trim.levels
x &lt;- data.table(A = factor(letters[1:10])[1:4]) # 10 levels
y &lt;- data.table(A = factor(letters[1:5])[1:4]) # 5 levels
all.equal(x, y, trim.levels = FALSE)
all.equal(x, y, trim.levels = FALSE, check.attributes = FALSE)
all.equal(x, y)
</code></pre>

<hr>
<h2 id='as.data.table'>Coerce to data.table</h2><span id='topic+as.data.table'></span><span id='topic+as.data.table.array'></span><span id='topic+as.data.table.matrix'></span><span id='topic+as.data.table.list'></span><span id='topic+as.data.table.data.frame'></span><span id='topic+as.data.table.data.table'></span><span id='topic+as.data.table.factor'></span><span id='topic+as.data.table.ordered'></span><span id='topic+as.data.table.integer'></span><span id='topic+as.data.table.numeric'></span><span id='topic+as.data.table.logical'></span><span id='topic+as.data.table.character'></span><span id='topic+as.data.table.Date'></span><span id='topic+is.data.table'></span>

<h3>Description</h3>

<p>Functions to check if an object is <code>data.table</code>, or coerce it if possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.data.table(x, keep.rownames=FALSE, ...)

## S3 method for class 'data.table'
as.data.table(x, ...)

## S3 method for class 'array'
as.data.table(x, keep.rownames=FALSE, key=NULL, sorted=TRUE,
              value.name="value", na.rm=TRUE, ...)

is.data.table(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.table_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
<tr><td><code id="as.data.table_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>Default is <code>FALSE</code>. If <code>TRUE</code>, adds the input object's names as a separate column named <code>"rn"</code>. <code>keep.rownames = "id"</code> names the column <code>"id"</code> instead.</p>
</td></tr>
<tr><td><code id="as.data.table_+3A_key">key</code></td>
<td>
<p> Character vector of one or more column names which is passed to <code><a href="#topic+setkeyv">setkeyv</a></code>. </p>
</td></tr>
<tr><td><code id="as.data.table_+3A_sorted">sorted</code></td>
<td>
<p>logical used in <em>array</em> method, default <code>TRUE</code> is overridden when <code>key</code> is provided. </p>
</td></tr>
<tr><td><code id="as.data.table_+3A_value.name">value.name</code></td>
<td>
<p>character scalar used in <em>array</em> method, default <code>"value"</code>.</p>
</td></tr>
<tr><td><code id="as.data.table_+3A_na.rm">na.rm</code></td>
<td>
<p>logical used in <em>array</em> method, default <code>TRUE</code> will remove rows with <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="as.data.table_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.data.table</code> is a generic function with many methods, and other packages can supply further methods.
</p>
<p>If a <code>list</code> is supplied, each element is converted to a column in the <code>data.table</code> with shorter elements recycled automatically. Similarly, each column of a <code>matrix</code> is converted separately.
</p>
<p><code>character</code> objects are <em>not</em> converted to <code>factor</code> types unlike <code>as.data.frame</code>.
</p>
<p>If a <code>data.frame</code> is supplied, all classes preceding <code>"data.frame"</code> are stripped. Similarly, for <code>data.table</code> as input, all classes preceding <code>"data.table"</code> are stripped. <code>as.data.table</code> methods returns a <em>copy</em> of original data. To modify by reference see <code><a href="#topic+setDT">setDT</a></code> and <code><a href="#topic+setDF">setDF</a></code>.
</p>
<p><code>keep.rownames</code> argument can be used to preserve the (row)names attribute in the resulting <code>data.table</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+setDT">setDT</a></code>, <code><a href="#topic+setDF">setDF</a></code>, <code><a href="#topic+copy">copy</a></code>, <code><a href="#topic+setkey">setkey</a></code>, <code><a href="#topic+J">J</a></code>, <code><a href="#topic+SJ">SJ</a></code>, <code><a href="#topic+CJ">CJ</a></code>, <code><a href="#topic+merge.data.table">merge.data.table</a></code>, <code><a href="#topic++3A+3D">:=</a></code>, <code><a href="#topic+setalloccol">setalloccol</a></code>, <code><a href="#topic+truelength">truelength</a></code>, <code><a href="#topic+rbindlist">rbindlist</a></code>, <code><a href="#topic+setNumericRounding">setNumericRounding</a></code>, <code><a href="#topic+datatable-optimize">datatable-optimize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nn = c(a=0.1, b=0.2, c=0.3, d=0.4)
as.data.table(nn)
as.data.table(nn, keep.rownames=TRUE)
as.data.table(nn, keep.rownames="rownames")

# char object not converted to factor
cc = c(X="a", Y="b", Z="c")
as.data.table(cc)
as.data.table(cc, keep.rownames=TRUE)
as.data.table(cc, keep.rownames="rownames")

mm = matrix(1:4, ncol=2, dimnames=list(c("r1", "r2"), c("c1", "c2")))
as.data.table(mm)
as.data.table(mm, keep.rownames=TRUE)
as.data.table(mm, keep.rownames="rownames")
as.data.table(mm, key="c1")

ll = list(a=1:2, b=3:4)
as.data.table(ll)
as.data.table(ll, keep.rownames=TRUE)
as.data.table(ll, keep.rownames="rownames")

DF = data.frame(x=rep(c("x","y","z"),each=2), y=c(1,3,6), row.names=LETTERS[1:6])
as.data.table(DF)
as.data.table(DF, keep.rownames=TRUE)
as.data.table(DF, keep.rownames="rownames")

DT = data.table(x=rep(c("x","y","z"),each=2), y=c(1:6))
as.data.table(DT)
as.data.table(DT, key='x')

ar = rnorm(27)
ar[sample(27, 15)] = NA
dim(ar) = c(3L,3L,3L)
as.data.table(ar)
</code></pre>

<hr>
<h2 id='as.data.table.xts'>Efficient xts to as.data.table conversion</h2><span id='topic+as.data.table.xts'></span>

<h3>Description</h3>

<p>Efficient conversion xts to data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xts'
as.data.table(x, keep.rownames = TRUE, key=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.table.xts_+3A_x">x</code></td>
<td>
<p>xts to convert to data.table</p>
</td></tr>
<tr><td><code id="as.data.table.xts_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>Default is <code>TRUE</code>. If <code>TRUE</code>, adds the xts input's index as a separate column named <code>"index"</code>. <code>keep.rownames = "id"</code> names the index column <code>"id"</code> instead.</p>
</td></tr>
<tr><td><code id="as.data.table.xts_+3A_key">key</code></td>
<td>
<p> Character vector of one or more column names which is passed to <code><a href="#topic+setkeyv">setkeyv</a></code>. </p>
</td></tr>
<tr><td><code id="as.data.table.xts_+3A_...">...</code></td>
<td>
<p>ignored, just for consistency with <code>as.data.table</code></p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+as.xts.data.table">as.xts.data.table</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("xts", quietly = TRUE)) {
  data(sample_matrix, package = "xts")
  sample.xts &lt;- xts::as.xts(sample_matrix) # xts might not be attached on search path
  # print head of xts
  print(head(sample.xts))
  # print data.table
  print(as.data.table(sample.xts))
}
</code></pre>

<hr>
<h2 id='as.matrix'>Convert a data.table to a matrix</h2><span id='topic+as.matrix'></span><span id='topic+as.matrix.data.table'></span>

<h3>Description</h3>

<p>Converts a <code>data.table</code> into a <code>matrix</code>, optionally using one
of the columns in the <code>data.table</code> as the <code>matrix</code> <code>rownames</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.table'
as.matrix(x, rownames=NULL, rownames.value=NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix_+3A_x">x</code></td>
<td>
<p>a <code>data.table</code></p>
</td></tr>
<tr><td><code id="as.matrix_+3A_rownames">rownames</code></td>
<td>
<p>optional, a single column name or column number to use as
the <code>rownames</code> in the returned <code>matrix</code>. If <code>TRUE</code> the
<code><a href="#topic+key">key</a></code> of the <code>data.table</code> will be used if it is a
single column, otherwise the first column in the <code>data.table</code> will
be used.</p>
</td></tr>
<tr><td><code id="as.matrix_+3A_rownames.value">rownames.value</code></td>
<td>
<p>optional, a vector of values to be used as the
<code>rownames</code> in the returned <code>matrix</code>. It must be the same length
as <code>nrow(x)</code>.</p>
</td></tr>
<tr><td><code id="as.matrix_+3A_...">...</code></td>
<td>
<p> Required to be present because the generic 'as.matrix' generic has it. Arguments here are not currently used or passed on by this method. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+as.matrix">as.matrix</a></code> is a generic function in base R. It dispatches to
<code>as.matrix.data.table</code> if its <code>x</code> argument is a <code>data.table</code>.
</p>
<p>The method for <code>data.table</code>s will return a character matrix if there
are only atomic columns and any non-(numeric/logical/complex) column,
applying <code><a href="base.html#topic+as.vector">as.vector</a></code> to factors and <code><a href="base.html#topic+format">format</a></code> to other
non-character columns. Otherwise, the usual coercion hierarchy (logical &lt;
integer &lt; double &lt; complex) will be used, e.g., all-logical data frames
will be coerced to a logical matrix, mixed logical-integer will give an
integer matrix, etc.
</p>


<h3>Value</h3>

<p>A new <code>matrix</code> containing the contents of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+as.matrix">as.matrix</a></code>, <code><a href="base.html#topic+data.matrix">data.matrix</a></code>
<code><a href="base.html#topic+array">array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DT &lt;- data.table(A = letters[1:10], X = 1:10, Y = 11:20)
as.matrix(DT) # character matrix
as.matrix(DT, rownames = "A")
as.matrix(DT, rownames = 1)
as.matrix(DT, rownames = TRUE)

setkey(DT, A)
as.matrix(DT, rownames = TRUE)
</code></pre>

<hr>
<h2 id='as.xts.data.table'>Efficient data.table to xts conversion</h2><span id='topic+as.xts.data.table'></span>

<h3>Description</h3>

<p>Efficient conversion of data.table to xts, data.table must have a time based type in first column.  See ?xts::timeBased for supported types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.xts.data.table(x, numeric.only = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.xts.data.table_+3A_x">x</code></td>
<td>
<p>data.table to convert to xts, must have a time based first column. As xts objects are indexed matrixes, all columns must be of the same type. If columns of multiple types are selected, standard as.matrix rules are applied during the conversion. </p>
</td></tr>
<tr><td><code id="as.xts.data.table_+3A_numeric.only">numeric.only</code></td>
<td>
<p>If TRUE, only include numeric columns in the conversion and all non-numeric columns will be omitted with warning</p>
</td></tr>
<tr><td><code id="as.xts.data.table_+3A_...">...</code></td>
<td>
<p>ignored, just for consistency with generic method.</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+as.data.table.xts">as.data.table.xts</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("xts", quietly = TRUE)) {
  sample.dt &lt;- data.table(date = as.Date((Sys.Date()-999):Sys.Date(),origin="1970-01-01"),
                          quantity = sample(10:50,1000,TRUE),
                          value = sample(100:1000,1000,TRUE))
  # print data.table
  print(sample.dt)
  # print head of xts
  print(head(as.xts.data.table(sample.dt))) # xts might not be attached on search path
}
</code></pre>

<hr>
<h2 id='between'> Convenience functions for range subsets. </h2><span id='topic+between'></span><span id='topic++between+'></span><span id='topic+inrange'></span><span id='topic++25inrange+25'></span>

<h3>Description</h3>

<p>Intended for use in <code>i</code> in <code>[.data.table</code>.
</p>
<p><code>between</code> is equivalent to <code>lower&lt;=x &amp; x&lt;=upper</code> when
<code>incbounds=TRUE</code>, or <code>lower&lt;x &amp; y&lt;upper</code> when <code>FALSE</code>. With a caveat that
<code>NA</code> in <code>lower</code> or <code>upper</code> are taken as unlimited bounds not <code>NA</code>.
This can be changed by setting <code>NAbounds</code> to <code>NA</code>.
</p>
<p><code>inrange</code> checks whether each value in <code>x</code> is in between any of
the intervals provided in <code>lower,upper</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>between(x, lower, upper, incbounds=TRUE, NAbounds=TRUE, check=FALSE)
x %between% y

inrange(x, lower, upper, incbounds=TRUE)
x %inrange% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="between_+3A_x">x</code></td>
<td>
<p> Any orderable vector, i.e., those with relevant methods for
<code>`&lt;=`</code>, such as <code>numeric</code>, <code>character</code>, <code>Date</code>, etc. in
case of <code>between</code> and a numeric vector in case of <code>inrange</code>.</p>
</td></tr>
<tr><td><code id="between_+3A_lower">lower</code></td>
<td>
<p> Lower range bound. Either length 1 or same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="between_+3A_upper">upper</code></td>
<td>
<p> Upper range bound. Either length 1 or same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="between_+3A_y">y</code></td>
<td>
<p> A length-2 <code>vector</code> or <code>list</code>, with <code>y[[1]]</code>
interpreted as <code>lower</code> and <code>y[[2]]</code> as <code>upper</code>.</p>
</td></tr>
<tr><td><code id="between_+3A_incbounds">incbounds</code></td>
<td>
 <p><code>TRUE</code> means inclusive bounds, i.e., [lower,upper].
<code>FALSE</code> means exclusive bounds, i.e., (lower,upper).
It is set to <code>TRUE</code> by default for infix notations.</p>
</td></tr>
<tr><td><code id="between_+3A_nabounds">NAbounds</code></td>
<td>
<p> If <code>lower</code> (<code>upper</code>) contains an <code>NA</code> what should <code>lower&lt;=x</code> (<code>x&lt;=upper</code>) return? By default <code>TRUE</code> so that a missing bound is interpreted as unlimited. </p>
</td></tr>
<tr><td><code id="between_+3A_check">check</code></td>
<td>
<p> Produce error if <code>any(lower&gt;upper)</code>? <code>FALSE</code> by default for efficiency, in particular type <code>character</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>non-equi</em> joins were implemented in <code>v1.9.8</code>. They extend
binary search based joins in <code>data.table</code> to other binary operators
including <code>&gt;=, &lt;=, &gt;, &lt;</code>. <code>inrange</code> makes use of this new
functionality and performs a range join.
</p>


<h3>Value</h3>

<p>Logical vector the same length as <code>x</code> with value <code>TRUE</code> for those
that lie within the specified range.
</p>


<h3>Note</h3>

<p> Current implementation does not make use of ordered keys for
<code>%between%</code>. </p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+like">like</a></code>, <code><a href="#topic++25chin+25">%chin%</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = data.table(a=1:5, b=6:10, c=c(5:1))
X[b %between% c(7,9)]
X[between(b, 7, 9)] # same as above
# NEW feature in v1.9.8, vectorised between
X[c %between% list(a,b)]
X[between(c, a, b)] # same as above
X[between(c, a, b, incbounds=FALSE)] # open interval

# inrange()
Y = data.table(a=c(8,3,10,7,-10), val=runif(5))
range = data.table(start = 1:5, end = 6:10)
Y[a %inrange% range]
Y[inrange(a, range$start, range$end)] # same as above
Y[inrange(a, range$start, range$end, incbounds=FALSE)] # open interval
</code></pre>

<hr>
<h2 id='cdt'> data.table exported C routines </h2><span id='topic+cdatatable'></span>

<h3>Description</h3>

<p>Some of internally used C routines are now exported. This interface should be considered experimental. List of exported C routines and their signatures are provided below in the usage section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># SEXP DT_subsetDT(SEXP x, SEXP rows, SEXP cols);
# p_DT_subsetDT = R_GetCCallable("data.table", "DT_subsetDT");
</code></pre>


<h3>Details</h3>

<p>Details how to use those can be found in <em>Writing R Extensions</em> manual <em>Linking to native routines in other packages</em> section.
An example use with <code>Rcpp</code>:
</p>
<pre>
  dt = data.table::as.data.table(iris)
  Rcpp::cppFunction("SEXP mysub2(SEXP x, SEXP rows, SEXP cols) { return DT_subsetDT(x,rows,cols); }",
    include="#include &lt;datatableAPI.h&gt;",
    depends="data.table")
  mysub2(dt, 1:4, 1:4)
</pre>


<h3>Note</h3>

<p>Be aware C routines are likely to have less input validation than their corresponding R interface. For example one should not expect <code>DT[-5L]</code> will be equal to <code>.Call(DT_subsetDT, DT, -5L, seq_along(DT))</code> because translation of <code>i=-5L</code> to <code>seq_len(nrow(DT))[-5L]</code> might be happening on R level. Moreover checks that <code>i</code> argument is in range of <code>1:nrow(DT)</code>, missingness, etc. might be happening on R level too.
</p>


<h3>References</h3>

<p><a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html">https://cran.r-project.org/doc/manuals/r-release/R-exts.html</a>
</p>

<hr>
<h2 id='chmatch'> Faster match of character vectors </h2><span id='topic+chmatch'></span><span id='topic++25chin+25'></span><span id='topic+chorder'></span><span id='topic+chgroup'></span>

<h3>Description</h3>

<p><code>chmatch</code> returns a vector of the positions of (first) matches of its first argument in its second. Both arguments must be character vectors.
</p>
<p><code>%chin%</code> is like <code>%in%</code>, but for character vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chmatch(x, table, nomatch=NA_integer_)
x %chin% table
chorder(x)
chgroup(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chmatch_+3A_x">x</code></td>
<td>
<p> character vector: the values to be matched, or the values to be ordered or grouped </p>
</td></tr>
<tr><td><code id="chmatch_+3A_table">table</code></td>
<td>
<p> character vector: the values to be matched against. </p>
</td></tr>
<tr><td><code id="chmatch_+3A_nomatch">nomatch</code></td>
<td>
<p> the value to be returned in the case when no match is found. Note that it is coerced to integer. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fast versions of <code>match</code>, <code>%in%</code> and <code>order</code>, optimised for character vectors. <code>chgroup</code> groups together duplicated values but retains the group order (according the first appearance order of each group), efficiently. They have been primarily developed for internal use by data.table, but have been exposed since that seemed appropriate.
</p>
<p>Strings are already cached internally by R (<code>CHARSXP</code>) and that is utilised by these functions. No hash table is built or cached, so the first call is the same speed as subsequent calls. Essentially, a counting sort (similar to <code>base::sort.list(x,method="radix")</code>, see <code><a href="#topic+setkey">setkey</a></code>) is implemented using the (almost) unused truelength of CHARSXP as the counter. <em>Where</em> R <em>has</em> used truelength of CHARSXP (where a character value is shared by a variable name), the non zero truelengths are stored first and reinstated afterwards. Each of the <code>ch*</code> functions implements a variation on this theme. Remember that internally in R, length of a CHARSXP is the nchar of the string and DATAPTR is the string itself.
</p>
<p>Methods that do build and cache a hash table (such as the <a href="https://cran.r-project.org/package=fastmatch">fastmatch package</a>) are <em>much</em> faster on subsequent calls (almost instant) but a little slower on the first. Therefore <code>chmatch</code> may be particularly suitable for ephemeral vectors (such as local variables in functions) or tasks that are only done once. Much depends on the length of <code>x</code> and <code>table</code>, how many unique strings each contains, and whether the position of the first match is all that is required.
</p>
<p>It may be possible to speed up fastmatch's hash table build time by using the technique in <code>data.table</code>, and we have suggested this to its author. If successful, fastmatch would then be fastest in all cases.
</p>


<h3>Value</h3>

<p>As <code>match</code> and <code>%in%</code>. <code>chorder</code> and <code>chgroup</code> return an integer index vector.
</p>


<h3>Note</h3>

<p> The name <code>charmatch</code> was taken by <code><a href="base.html#topic+charmatch">charmatch</a></code>, hence <code>chmatch</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+match">match</a></code>, <code><a href="base.html#topic++25in+25">%in%</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Please type 'example(chmatch)' to run this and see timings on your machine

N = 1e5
# N is set small here (1e5) to reduce runtime because every day CRAN runs and checks
# all documentation examples in addition to the package's test suite.
# The comments here apply when N has been changed to 1e8 and were run on 2018-05-13
# with R 3.5.0 and data.table 1.11.2.

u = as.character(as.hexmode(1:10000))
y = sample(u,N,replace=TRUE)
x = sample(u)
                                           #  With N=1e8 ...
system.time(a &lt;- match(x,y))               #  4.6s
system.time(b &lt;- chmatch(x,y))             #  1.8s
identical(a,b)

system.time(a &lt;- x %in% y)               #  4.5s
system.time(b &lt;- x %chin% y)             #  1.7s
identical(a,b)

# Different example with more unique strings ...
u = as.character(as.hexmode(1:(N/10)))
y = sample(u,N,replace=TRUE)
x = sample(u,N,replace=TRUE)
system.time(a &lt;- match(x,y))               # 46s
system.time(b &lt;- chmatch(x,y))             # 16s
identical(a,b)
</code></pre>

<hr>
<h2 id='copy'> Copy an entire object </h2><span id='topic+copy'></span>

<h3>Description</h3>

<p>In <code>data.table</code> parlance, all <code>set*</code> functions change their input <em>by reference</em>. That is, no copy is made at all, other than temporary working memory, which is as large as one column. The only other <code>data.table</code> operator that modifies input by reference is <code><a href="#topic++3A+3D">:=</a></code>. Check out the <code>See Also</code> section below for other <code>set*</code> function <code>data.table</code> provides.
</p>
<p><code>copy()</code> copies an entire object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_+3A_x">x</code></td>
<td>
<p> A <code>data.table</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data.table</code> provides functions that operate on objects <em>by reference</em> and minimise full object copies as much as possible. Still, it might be necessary in some situations to work on an object's copy which can be done using <code>DT.copy &lt;- copy(DT)</code>. It may also be sometimes useful before <code>:=</code> (or <code>set</code>) is used to subassign to a column by reference.
</p>
<p>A <code>copy()</code> may be required when doing <code>dt_names = names(DT)</code>. Due to R's <em>copy-on-modify</em>, <code>dt_names</code> still points to the same location in memory as <code>names(DT)</code>. Therefore modifying <code>DT</code> <em>by reference</em> now, say by adding a new column, <code>dt_names</code> will also get updated. To avoid this, one has to <em>explicitly</em> copy: <code>dt_names &lt;- copy(names(DT))</code>.
</p>


<h3>Value</h3>

<p>Returns a copy of the object.
</p>


<h3>Note</h3>

<p>To confirm precisely whether an object is a copy of another, compare their exact memory address with <code><a href="#topic+address">address</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+address">address</a></code>, <code><a href="#topic+setkey">setkey</a></code>, <code><a href="#topic+setDT">setDT</a></code>, <code><a href="#topic+setDF">setDF</a></code>, <code><a href="#topic+set">set</a></code> <code><a href="#topic++3A+3D">:=</a></code>, <code><a href="#topic+setorder">setorder</a></code>, <code><a href="#topic+setattr">setattr</a></code>, <code><a href="#topic+setnames">setnames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Type 'example(copy)' to run these at prompt and browse output

DT = data.table(A=5:1,B=letters[5:1])
DT2 = copy(DT)        # explicit copy() needed to copy a data.table
setkey(DT2,B)         # now just changes DT2
identical(DT,DT2)     # FALSE. DT and DT2 are now different tables

DT = data.table(A=5:1, B=letters[5:1])
nm1 = names(DT)
nm2 = copy(names(DT))
DT[, C := 1L]
identical(nm1, names(DT)) # TRUE, nm1 is also changed by reference
identical(nm2, names(DT)) # FALSE, nm2 is a copy, different from names(DT)
</code></pre>

<hr>
<h2 id='data.table-class'>S4 Definition for data.table</h2><span id='topic+class+3Adata.table'></span><span id='topic+data.table-class'></span>

<h3>Description</h3>

<p>A <code>data.table</code> can be used in S4 class definitions as either
a parent class (inside a <code>contains</code> argument of <code>setClass</code>),
or as an element of an S4 slot.
</p>


<h3>Author(s)</h3>

<p> Steve Lianoglou </p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Used in inheritance.
setClass('SuperDataTable', contains='data.table')

## Used in a slot
setClass('Something', representation(x='character', dt='data.table'))
x &lt;- new("Something", x='check', dt=data.table(a=1:10, b=11:20))
</code></pre>

<hr>
<h2 id='data.table-package'> Enhanced data.frame </h2><span id='topic+data.table-package'></span><span id='topic+data.table'></span><span id='topic+Ops.data.table'></span><span id='topic+is.na.data.table'></span><span id='topic++5B.data.table'></span><span id='topic+.'></span><span id='topic+.+28'></span><span id='topic+.+28+29'></span><span id='topic+..'></span>

<h3>Description</h3>

<p><code>data.table</code> <em>inherits</em> from <code>data.frame</code>. It offers fast and memory efficient: file reader and writer, aggregations, updates, equi, non-equi, rolling, range and interval joins, in a short and flexible syntax, for faster development.
</p>
<p>It is inspired by <code>A[B]</code> syntax in <span class="rlang"><b>R</b></span> where <code>A</code> is a matrix and <code>B</code> is a 2-column matrix. Since a <code>data.table</code> <em>is</em> a <code>data.frame</code>, it is compatible with <span class="rlang"><b>R</b></span> functions and packages that accept <em>only</em> <code>data.frame</code>s.
</p>
<p>Type <code>vignette(package="data.table")</code> to get started. The <a href="../doc/datatable-intro.html">Introduction to data.table</a> vignette introduces <code>data.table</code>'s <code>x[i, j, by]</code> syntax and is a good place to start. If you have read the vignettes and the help page below, please read the <a href="https://github.com/Rdatatable/data.table/wiki/Support">data.table support guide</a>.
</p>
<p>Please check the <a href="https://github.com/Rdatatable/data.table/wiki">homepage</a> for up to the minute live NEWS.
</p>
<p>Tip: one of the <em>quickest</em> ways to learn the features is to type <code>example(data.table)</code> and study the output at the prompt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.table(..., keep.rownames=FALSE, check.names=FALSE, key=NULL, stringsAsFactors=FALSE)

## S3 method for class 'data.table'
x[i, j, by, keyby, with = TRUE,
  nomatch = NA,
  mult = "all",
  roll = FALSE,
  rollends = if (roll=="nearest") c(TRUE,TRUE)
             else if (roll&gt;=0) c(FALSE,TRUE)
             else c(TRUE,FALSE),
  which = FALSE,
  .SDcols,
  verbose = getOption("datatable.verbose"),                   # default: FALSE
  allow.cartesian = getOption("datatable.allow.cartesian"),   # default: FALSE
  drop = NULL, on = NULL, env = NULL]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.table-package_+3A_...">...</code></td>
<td>
<p> Just as <code>...</code> in <code><a href="base.html#topic+data.frame">data.frame</a></code>. Usual recycling rules are applied to vectors of different lengths to create a list of equal length vectors.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p> If <code>...</code> is a <code>matrix</code> or <code>data.frame</code>, <code>TRUE</code> will retain the rownames of that object in a column named <code>rn</code>.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_check.names">check.names</code></td>
<td>
<p> Just as <code>check.names</code> in <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_key">key</code></td>
<td>
<p> Character vector of one or more column names which is passed to <code><a href="#topic+setkey">setkey</a></code>. It may be a single comma separated string such as <code>key="x,y,z"</code>, or a vector of names such as <code>key=c("x","y","z")</code>.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>Logical (default is <code>FALSE</code>). Convert all <code>character</code> columns to <code>factor</code>s?</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_x">x</code></td>
<td>
<p> A <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_i">i</code></td>
<td>
<p> Integer, logical or character vector, single column numeric <code>matrix</code>, expression of column names, <code>list</code>, <code>data.frame</code> or <code>data.table</code>.
</p>
<p><code>integer</code> and <code>logical</code> vectors work the same way they do in <code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code> except logical <code>NA</code>s are treated as FALSE.
</p>
<p><code>expression</code> is evaluated within the frame of the <code>data.table</code> (i.e. it sees column names as if they are variables) and can evaluate to any of the other types.
</p>
<p><code>character</code>, <code>list</code> and <code>data.frame</code> input to <code>i</code> is converted into a <code>data.table</code> internally using <code><a href="#topic+as.data.table">as.data.table</a></code>.
</p>
<p>If <code>i</code> is a <code>data.table</code>, the columns in <code>i</code> to be matched against <code>x</code> can be specified using one of these ways:
</p>

<ul>
<li> <p><code>on</code> argument (see below). It allows for both <code>equi-</code> and the newly implemented <code>non-equi</code> joins.
</p>
</li>
<li><p> If not, <code>x</code> <em>must be keyed</em>. Key can be set using <code><a href="#topic+setkey">setkey</a></code>. If <code>i</code> is also keyed, then first <em>key</em> column of <code>i</code> is matched against first <em>key</em> column of <code>x</code>, second against second, etc..
</p>
<p>If <code>i</code> is not keyed, then first column of <code>i</code> is matched against first <em>key</em> column of <code>x</code>, second column of <code>i</code> against second <em>key</em> column of <code>x</code>, etc...
</p>
<p>This is summarised in code as <code>min(length(key(x)), if (haskey(i)) length(key(i)) else ncol(i))</code>.
</p>
</li></ul>

<p>Using <code>on=</code> is recommended (even during keyed joins) as it helps understand the code better and also allows for <em>non-equi</em> joins.
</p>
<p>When the binary operator <code>==</code> alone is used, an <em>equi</em> join is performed. In SQL terms, <code>x[i]</code> then performs a <em>right join</em> by default. <code>i</code> prefixed with <code>!</code> signals a <em>not-join</em> or <em>not-select</em>.
</p>
<p>Support for <em>non-equi</em> join was recently implemented, which allows for other binary operators <code>&gt;=, &gt;, &lt;= and &lt;</code>.
</p>
<p>See <a href="../doc/datatable-keys-fast-subset.html"><code>vignette("datatable-keys-fast-subset")</code></a> and <a href="../doc/datatable-secondary-indices-and-auto-indexing.html"><code>vignette("datatable-secondary-indices-and-auto-indexing")</code></a>.
</p>
<p><em>Advanced:</em> When <code>i</code> is a single variable name, it is not considered an expression of column names and is instead evaluated in calling scope.
</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_j">j</code></td>
<td>
<p>When <code>with=TRUE</code> (default), <code>j</code> is evaluated within the frame of the data.table; i.e., it sees column names as if they are variables. This allows to not just <em>select</em> columns in <code>j</code>, but also <code>compute</code> on them e.g., <code>x[, a]</code> and <code>x[, sum(a)]</code> returns <code>x$a</code> and <code>sum(x$a)</code> as a vector respectively. <code>x[, .(a, b)]</code> and <code>x[, .(sa=sum(a), sb=sum(b))]</code> returns a two column data.table each, the first simply <em>selecting</em> columns <code>a, b</code> and the second <em>computing</em> their sums.
</p>
<p>As long as <code>j</code> returns a <code>list</code>, each element of the list becomes a column in the resulting <code>data.table</code>. When the output of <code>j</code> is not a <code>list</code>, the output is returned as-is (e.g. <code>x[ , a]</code> returns the column vector <code>a</code>), unless <code>by</code> is used, in which case it is implicitly wrapped in <code>list</code> for convenience (e.g. <code>x[ , sum(a), by=b]</code> will create a column named <code>V1</code> with value <code>sum(a)</code> for each group).
</p>
<p>The expression '.()' is a <em>shorthand</em> alias to <code>list()</code>; they both mean the same. (An exception is made for the use of <code>.()</code> within a call to <code><a href="base.html#topic+bquote">bquote</a></code>, where <code>.()</code> is left unchanged.)
</p>
<p>When <code>j</code> is a vector of column names or positions to select (as in <code>data.frame</code>). There is no need to use <code>with=FALSE</code> anymore. Note that <code>with=FALSE</code> is still necessary when using a logical vector with length <code>ncol(x)</code> to include/exclude columns. Note: if a logical vector with length <code>k &lt; ncol(x)</code> is passed, it will be filled to length <code>ncol(x)</code> with <code>FALSE</code>, which is different from <code>data.frame</code>, where the vector is recycled.
</p>
<p><em>Advanced:</em> <code>j</code> also allows the use of special <em>read-only</em> symbols: <code><a href="#topic+.SD">.SD</a></code>, <code><a href="#topic+.N">.N</a></code>, <code><a href="#topic+.I">.I</a></code>, <code><a href="#topic+.GRP">.GRP</a></code>, <code><a href="#topic+.BY">.BY</a></code>. See <code><a href="#topic+special-symbols">special-symbols</a></code> and the Examples below for more.
</p>
<p><em>Advanced:</em> When <code>i</code> is a <code>data.table</code>, the columns of <code>i</code> can be referred to in <code>j</code> by using the prefix <code>i.</code>, e.g., <code>X[Y, .(val, i.val)]</code>. Here <code>val</code> refers to <code>X</code>'s column and <code>i.val</code> <code>Y</code>'s.
</p>
<p><em>Advanced:</em> Columns of <code>x</code> can now be referred to using the prefix <code>x.</code> and is particularly useful during joining to refer to <code>x</code>'s <em>join</em> columns as they are otherwise masked by <code>i</code>'s. For example, <code>X[Y, .(x.a-i.a, b), on="a"]</code>.
</p>
<p>See <a href="../doc/datatable-intro.html"><code>vignette("datatable-intro")</code></a> and <code>example(data.table)</code>.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_by">by</code></td>
<td>
<p> Column names are seen as if they are variables (as in <code>j</code> when <code>with=TRUE</code>). The <code>data.table</code> is then grouped by the <code>by</code> and <code>j</code> is evaluated within each group. The order of the rows within each group is preserved, as is the order of the groups. <code>by</code> accepts:
</p>

<ul>
<li><p> A single unquoted column name: e.g., <code>DT[, .(sa=sum(a)), by=x]</code>
</p>
</li>
<li><p> a <code>list()</code> of expressions of column names: e.g., <code>DT[, .(sa=sum(a)), by=.(x=x&gt;0, y)]</code>
</p>
</li>
<li><p> a single character string containing comma separated column names (where spaces are significant since column names may contain spaces even at the start or end): e.g., <code>DT[, sum(a), by="x,y,z"]</code>
</p>
</li>
<li><p> a character vector of column names: e.g., <code>DT[, sum(a), by=c("x", "y")]</code>
</p>
</li>
<li><p> or of the form <code>startcol:endcol</code>: e.g., <code>DT[, sum(a), by=x:z]</code>
</p>
</li></ul>

<p><em>Advanced:</em> When <code>i</code> is a <code>list</code> (or <code>data.frame</code> or <code>data.table</code>), <code>DT[i, j, by=.EACHI]</code> evaluates <code>j</code> for the groups in 'DT' that each row in <code>i</code> joins to. That is, you can join (in <code>i</code>) and aggregate (in <code>j</code>) simultaneously. We call this <em>grouping by each i</em>. See <a href="https://stackoverflow.com/a/27004566/559784">this StackOverflow answer</a> for a more detailed explanation until we <a href="https://github.com/Rdatatable/data.table/issues/944">roll out vignettes</a>.
</p>
<p><em>Advanced:</em> In the <code>X[Y, j]</code> form of grouping, the <code>j</code> expression sees variables in <code>X</code> first, then <code>Y</code>. We call this <em>join inherited scope</em>. If the variable is not in <code>X</code> or <code>Y</code> then the calling frame is searched, its calling frame, and so on in the usual way up to and including the global environment.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_keyby">keyby</code></td>
<td>
<p> Same as <code>by</code>, but with an additional <code>setkey()</code> run on the <code>by</code> columns of the result, for convenience. It is common practice to use 'keyby=' routinely when you wish the result to be sorted. May also be <code>TRUE</code> or <code>FALSE</code> when <code>by</code> is provided as an alternative way to accomplish the same operation.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_with">with</code></td>
<td>
<p> By default <code>with=TRUE</code> and <code>j</code> is evaluated within the frame of <code>x</code>; column names can be used as variables. In case of overlapping variables names inside dataset and in parent scope you can use double dot prefix <code>..cols</code> to explicitly refer to '<code>cols</code> variable parent scope and not from your dataset.
</p>
<p>When <code>j</code> is a character vector of column names, a numeric vector of column positions to select or of the form <code>startcol:endcol</code>, and the value returned is always a <code>data.table</code>. <code>with=FALSE</code> is not necessary anymore to select columns dynamically. Note that <code>x[, cols]</code> is equivalent to <code>x[, ..cols]</code> and to <code>x[, cols, with=FALSE]</code> and to <code>x[, .SD, .SDcols=cols]</code>.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_nomatch">nomatch</code></td>
<td>
<p> When a row in <code>i</code> has no match to <code>x</code>, <code>nomatch=NA</code> (default) means <code>NA</code> is returned. <code>NULL</code> (or <code>0</code> for backward compatibility) means no rows will be returned for that row of <code>i</code>. </p>
</td></tr>
<tr><td><code id="data.table-package_+3A_mult">mult</code></td>
<td>
<p> When <code>i</code> is a <code>list</code> (or <code>data.frame</code> or <code>data.table</code>) and <em>multiple</em> rows in <code>x</code> match to the row in <code>i</code>, <code>mult</code> controls which are returned: <code>"all"</code> (default), <code>"first"</code> or <code>"last"</code>.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_roll">roll</code></td>
<td>
<p> When <code>i</code> is a <code>data.table</code> and its row matches to all but the last <code>x</code> join column, and its value in the last <code>i</code> join column falls in a gap (including after the last observation in <code>x</code> for that group), then:
</p>

<ul>
<li> <p><code>+Inf</code> (or <code>TRUE</code>) rolls the <em>prevailing</em> value in <code>x</code> forward. It is also known as last observation carried forward (LOCF).
</p>
</li>
<li> <p><code>-Inf</code> rolls backwards instead; i.e., next observation carried backward (NOCB).
</p>
</li>
<li><p> finite positive or negative number limits how far values are carried forward or backward.
</p>
</li>
<li><p> &quot;nearest&quot; rolls the nearest value instead.
</p>
</li></ul>

<p>Rolling joins apply to the last join column, generally a date but can be any variable. It is particularly fast using a modified binary search.
</p>
<p>A common idiom is to select a contemporaneous regular time series (<code>dts</code>) across a set of identifiers (<code>ids</code>):  <code>DT[CJ(ids,dts),roll=TRUE]</code> where <code>DT</code> has a 2-column key (id,date) and <code><a href="#topic+CJ">CJ</a></code> stands for <em>cross join</em>.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_rollends">rollends</code></td>
<td>
<p> A logical vector length 2 (a single logical is recycled) indicating whether values falling before the first value or after the last value for a group should be rolled as well.
</p>

<ul>
<li><p> If <code>rollends[2]=TRUE</code>, it will roll the last value forward. <code>TRUE</code> by default for LOCF and <code>FALSE</code> for NOCB rolls.
</p>
</li>
<li><p> If <code>rollends[1]=TRUE</code>, it will roll the first value backward. <code>TRUE</code> by default for NOCB and <code>FALSE</code> for LOCF rolls.
</p>
</li></ul>

<p>When <code>roll</code> is a finite number, that limit is also applied when rolling the ends.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_which">which</code></td>
<td>
<p><code>TRUE</code> returns the row numbers of <code>x</code> that <code>i</code> matches to. If <code>NA</code>, returns the row numbers of <code>i</code> that have no match in <code>x</code>. By default <code>FALSE</code> and the rows in <code>x</code> that match are returned.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_.sdcols">.SDcols</code></td>
<td>
<p> Specifies the columns of <code>x</code> to be included in the special symbol <code><a href="#topic+.SD">.SD</a></code> which stands for <code>Subset of data.table</code>. May be character column names, numeric positions, logical, a function name such as 'is.numeric', or a function call such as 'patterns()'. '.SDcols' is particularly useful for speed when applying a function through a subset of (possible very many) columns by group; e.g., <code>DT[, lapply(.SD, sum), by="x,y", .SDcols=301:350]</code>.
</p>
<p>For convenient interactive use, the form <code>startcol:endcol</code> is also allowed (as in <code>by</code>), e.g., <code>DT[, lapply(.SD, sum), by=x:y, .SDcols=a:f]</code>.
</p>
<p>Inversion (column dropping instead of keeping) can be accomplished be prepending the argument with <code>!</code> or <code>-</code> (there's no difference between these), e.g. <code>.SDcols = !c('x', 'y')</code>.
</p>
<p>Finally, you can filter columns to include in <code>.SD</code> based on their <em>names</em> according to regular expressions via <code>.SDcols=patterns(regex1, regex2, ...)</code>. The included columns will be the <em>intersection</em> of the columns identified by each pattern; pattern unions can easily be specified with <code>|</code> in a regex. You can filter columns on <code>values</code>  by passing a function, e.g. <code>.SDcols=<a href="base.html#topic+is.numeric">is.numeric</a></code>. You can also invert a pattern as usual with <code>.SDcols=!patterns(...)</code> or <code>.SDcols=!is.numeric</code>.
</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_verbose">verbose</code></td>
<td>
 <p><code>TRUE</code> turns on status and information messages to the console. Turn this on by default using <code>options(datatable.verbose=TRUE)</code>. The quantity and types of verbosity may be expanded in future.
</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_allow.cartesian">allow.cartesian</code></td>
<td>
 <p><code>FALSE</code> prevents joins that would result in more than <code>nrow(x)+nrow(i)</code> rows. This is usually caused by duplicate values in <code>i</code>'s join columns, each of which join to the same group in 'x' over and over again: a <em>misspecified</em> join. Usually this was not intended and the join needs to be changed. The word 'cartesian' is used loosely in this context. The traditional cartesian join is (deliberately) difficult to achieve in <code>data.table</code>: where every row in <code>i</code> joins to every row in <code>x</code> (a <code>nrow(x)*nrow(i)</code> row result). 'cartesian' is just meant in a 'large multiplicative' sense, so FALSE does not always prevent a traditional cartesian join. </p>
</td></tr>
<tr><td><code id="data.table-package_+3A_drop">drop</code></td>
<td>
<p> Never used by <code>data.table</code>. Do not use. It needs to be here because <code>data.table</code> inherits from <code>data.frame</code>. See <a href="../doc/datatable-faq.html"><code>vignette("datatable-faq")</code></a>.</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_on">on</code></td>
<td>
<p> Indicate which columns in <code>x</code> should be joined with which columns in <code>i</code> along with the type of binary operator to join with (see non-equi joins below on this). When specified, this overrides the keys set on <code>x</code> and <code>i</code>. When <code>.NATURAL</code> keyword provided then <em>natural join</em> is made (join on common columns). There are multiple ways of specifying the <code>on</code> argument:
</p>

<ul>
<li><p> As an unnamed character vector, e.g., <code>X[Y, on=c("a", "b")]</code>, used when columns <code>a</code> and <code>b</code> are common to both <code>X</code> and <code>Y</code>.
</p>
</li>
<li> <p><em>Foreign key joins</em>: As a <em>named</em> character vector when the join columns have different names in <code>X</code> and <code>Y</code>.
For example, <code>X[Y, on=c(x1="y1", x2="y2")]</code> joins <code>X</code> and <code>Y</code> by matching columns <code>x1</code> and <code>x2</code> in <code>X</code> with columns <code>y1</code> and <code>y2</code> in <code>Y</code>, respectively.
</p>
<p>From v1.9.8, you can also express foreign key joins using the binary operator <code>==</code>, e.g. <code>X[Y, on=c("x1==y1", "x2==y2")]</code>.
</p>
<p>NB: shorthand like <code>X[Y, on=c("a", V2="b")]</code> is also possible if, e.g., column <code>"a"</code> is common between the two tables.
</p>
</li>
<li><p> For convenience during interactive scenarios, it is also possible to use <code>.()</code> syntax as <code>X[Y, on=.(a, b)]</code>.
</p>
</li>
<li><p> From v1.9.8, (non-equi) joins using binary operators <code>&gt;=, &gt;, &lt;=, &lt;</code> are also possible, e.g., <code>X[Y, on=c("x&gt;=a", "y&lt;=b")]</code>, or for interactive use as <code>X[Y, on=.(x&gt;=a, y&lt;=b)]</code>.
</p>
</li></ul>

<p>See examples as well as <a href="../doc/datatable-secondary-indices-and-auto-indexing.html"><code>vignette("datatable-secondary-indices-and-auto-indexing")</code></a>.
</p>
</td></tr>
<tr><td><code id="data.table-package_+3A_env">env</code></td>
<td>
<p> List or an environment, passed to <code><a href="#topic+substitute2">substitute2</a></code> for substitution of parameters in <code>i</code>, <code>j</code> and <code>by</code> (or <code>keyby</code>). Use <code>verbose</code> to preview constructed expressions. For more details see <a href="../doc/datatable-programming.html"><code>vignette("datatable-programming")</code></a>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data.table</code> builds on base <span class="rlang"><b>R</b></span> functionality to reduce 2 types of time:<br />
</p>

<ol>
<li><p> programming time (easier to write, read, debug and maintain), and
</p>
</li>
<li><p> compute time (fast and memory efficient).
</p>
</li></ol>

<p>The general form of data.table syntax is:<br />
</p>
<pre>
    DT[ i,  j,  by ] # + extra arguments
        |   |   |
        |   |    -------&gt; grouped by what?
        |    -------&gt; what to do?
         ---&gt; on which rows?
</pre>
<p>The way to read this out loud is: &quot;Take <code>DT</code>, subset rows by <code>i</code>, <em>then</em> compute <code>j</code> grouped by <code>by</code>. Here are some basic usage examples expanding on this definition. See the vignette (and examples) for working examples.
</p>
<pre>
    X[, a]                      # return col 'a' from X as vector. If not found, search in parent frame.
    X[, .(a)]                   # same as above, but return as a data.table.
    X[, sum(a)]                 # return sum(a) as a vector (with same scoping rules as above)
    X[, .(sum(a)), by=c]        # get sum(a) grouped by 'c'.
    X[, sum(a), by=c]           # same as above, .() can be omitted in j and by on single expression for convenience
    X[, sum(a), by=c:f]         # get sum(a) grouped by all columns in between 'c' and 'f' (both inclusive)

    X[, sum(a), keyby=b]        # get sum(a) grouped by 'b', and sort that result by the grouping column 'b'
    X[, sum(a), by=b, keyby=TRUE] # same order as above, but using sorting flag
    X[, sum(a), by=b][order(b)] # same order as above, but by chaining compound expressions
    X[c&gt;1, sum(a), by=c]        # get rows where c&gt;1 is TRUE, and on those rows, get sum(a) grouped by 'c'
    X[Y, .(a, b), on="c"]       # get rows where Y$c == X$c, and select columns 'X$a' and 'X$b' for those rows
    X[Y, .(a, i.a), on="c"]     # get rows where Y$c == X$c, and then select 'X$a' and 'Y$a' (=i.a)
    X[Y, sum(a*i.a), on="c", by=.EACHI] # for *each* 'Y$c', get sum(a*i.a) on matching rows in 'X$c'

    X[, plot(a, b), by=c]       # j accepts any expression, generates plot for each group and returns no data
    # see ?assign to add/update/delete columns by reference using the same consistent interface
</pre>
<p>A <code>data.table</code> query may be invoked on a <code>data.frame</code> using functional form <code>DT(...)</code>, see examples. The class of the input is retained.
</p>
<p>A <code>data.table</code> is a <code>list</code> of vectors, just like a <code>data.frame</code>. However :
</p>

<ol>
<li><p> it never has or uses rownames. Rownames based indexing can be done by setting a <em>key</em> of one or more columns or done <em>ad-hoc</em> using the <code>on</code> argument (now preferred).
</p>
</li>
<li><p> it has enhanced functionality in <code>[.data.table</code> for fast joins of keyed tables, fast aggregation, fast last observation carried forward (LOCF) and fast add/modify/delete of columns by reference with no copy at all.
</p>
</li></ol>

<p>See the <code>see also</code> section for the several other <em>methods</em> that are available for operating on data.tables efficiently.
</p>


<h3>Note</h3>

<p> If <code>keep.rownames</code> or <code>check.names</code> are supplied they must be written in full because <span class="rlang"><b>R</b></span> does not allow partial argument names after <code>...</code>. For example, <code>data.table(DF, keep=TRUE)</code> will create a
column called <code>keep</code> containing <code>TRUE</code> and this is correct behaviour; <code>data.table(DF, keep.rownames=TRUE)</code> was intended.
</p>
<p><code>POSIXlt</code> is not supported as a column type because it uses 40 bytes to store a single datetime. They are implicitly converted to <code>POSIXct</code> type with <em>warning</em>. You may also be interested in <code><a href="#topic+IDateTime">IDateTime</a></code> instead; it has methods to convert to and from <code>POSIXlt</code>.
</p>


<h3>References</h3>

<p><a href="https://r-datatable.com">https://r-datatable.com</a> (<code>data.table</code> homepage)<br />
<a href="https://en.wikipedia.org/wiki/Binary_search">https://en.wikipedia.org/wiki/Binary_search</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+special-symbols">special-symbols</a></code>, <code><a href="base.html#topic+data.frame">data.frame</a></code>, <code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code>, <code><a href="#topic+as.data.table">as.data.table</a></code>, <code><a href="#topic+setkey">setkey</a></code>, <code><a href="#topic+setorder">setorder</a></code>, <code><a href="#topic+setDT">setDT</a></code>, <code><a href="#topic+setDF">setDF</a></code>, <code><a href="#topic+J">J</a></code>, <code><a href="#topic+SJ">SJ</a></code>, <code><a href="#topic+CJ">CJ</a></code>, <code><a href="#topic+merge.data.table">merge.data.table</a></code>, <code><a href="#topic+tables">tables</a></code>, <code><a href="#topic+test.data.table">test.data.table</a></code>, <code><a href="#topic+IDateTime">IDateTime</a></code>, <code><a href="#topic+unique.data.table">unique.data.table</a></code>, <code><a href="#topic+copy">copy</a></code>, <code><a href="#topic++3A+3D">:=</a></code>, <code><a href="#topic+setalloccol">setalloccol</a></code>, <code><a href="#topic+truelength">truelength</a></code>, <code><a href="#topic+rbindlist">rbindlist</a></code>, <code><a href="#topic+setNumericRounding">setNumericRounding</a></code>, <code><a href="#topic+datatable-optimize">datatable-optimize</a></code>, <code><a href="#topic+fsetdiff">fsetdiff</a></code>, <code><a href="#topic+funion">funion</a></code>, <code><a href="#topic+fintersect">fintersect</a></code>, <code><a href="#topic+fsetequal">fsetequal</a></code>, <code><a href="#topic+anyDuplicated">anyDuplicated</a></code>, <code><a href="#topic+uniqueN">uniqueN</a></code>, <code><a href="#topic+rowid">rowid</a></code>, <code><a href="#topic+rleid">rleid</a></code>, <code><a href="#topic+na.omit">na.omit</a></code>, <code><a href="#topic+frank">frank</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
example(data.table)  # to run these examples yourself

## End(Not run)
DF = data.frame(x=rep(c("b","a","c"),each=3), y=c(1,3,6), v=1:9)
DT = data.table(x=rep(c("b","a","c"),each=3), y=c(1,3,6), v=1:9)
DF
DT
identical(dim(DT), dim(DF))    # TRUE
identical(DF$a, DT$a)          # TRUE
is.list(DF)                    # TRUE
is.list(DT)                    # TRUE

is.data.frame(DT)              # TRUE

tables()

# basic row subset operations
DT[2]                          # 2nd row
DT[3:2]                        # 3rd and 2nd row
DT[order(x)]                   # no need for order(DT$x)
DT[order(x), ]                 # same as above. The ',' is optional
DT[y&gt;2]                        # all rows where DT$y &gt; 2
DT[y&gt;2 &amp; v&gt;5]                  # compound logical expressions
DT[!2:4]                       # all rows other than 2:4
DT[-(2:4)]                     # same

# select|compute columns data.table way
DT[, v]                        # v column (as vector)
DT[, list(v)]                  # v column (as data.table)
DT[, .(v)]                     # same as above, .() is a shorthand alias to list()
DT[, sum(v)]                   # sum of column v, returned as vector
DT[, .(sum(v))]                # same, but return data.table (column autonamed V1)
DT[, .(sv=sum(v))]             # same, but column named "sv"
DT[, .(v, v*2)]                # return two column data.table, v and v*2

# subset rows and select|compute data.table way
DT[2:3, sum(v)]                # sum(v) over rows 2 and 3, return vector
DT[2:3, .(sum(v))]             # same, but return data.table with column V1
DT[2:3, .(sv=sum(v))]          # same, but return data.table with column sv
DT[2:5, cat(v, "\n")]          # just for j's side effect

# select columns the data.frame way
DT[, 2]                        # 2nd column, returns a data.table always
colNum = 2
DT[, ..colNum]                 # same, .. prefix conveys one-level-up in calling scope
DT[["v"]]                      # same as DT[, v] but faster if called in a loop

# grouping operations - j and by
DT[, sum(v), by=x]             # ad hoc by, order of groups preserved in result
DT[, sum(v), keyby=x]          # same, but order the result on by cols
DT[, sum(v), by=x, keyby=TRUE] # same, but using sorting flag
DT[, sum(v), by=x][order(x)]   # same but by chaining expressions together

# fast ad hoc row subsets (subsets as joins)
DT["a", on="x"]                # same as x == "a" but uses binary search (fast)
DT["a", on=.(x)]               # same, for convenience, no need to quote every column
DT[.("a"), on="x"]             # same
DT[x=="a"]                     # same, single "==" internally optimised to use binary search (fast)
DT[x!="b" | y!=3]              # not yet optimized, currently vector scan subset
DT[.("b", 3), on=c("x", "y")]  # join on columns x,y of DT; uses binary search (fast)
DT[.("b", 3), on=.(x, y)]      # same, but using on=.()
DT[.("b", 1:2), on=c("x", "y")]             # no match returns NA
DT[.("b", 1:2), on=.(x, y), nomatch=NULL]   # no match row is not returned
DT[.("b", 1:2), on=c("x", "y"), roll=Inf]   # locf, nomatch row gets rolled by previous row
DT[.("b", 1:2), on=.(x, y), roll=-Inf]      # nocb, nomatch row gets rolled by next row
DT["b", sum(v*y), on="x"]                   # on rows where DT$x=="b", calculate sum(v*y)

# all together now
DT[x!="a", sum(v), by=x]                    # get sum(v) by "x" for each i != "a"
DT[!"a", sum(v), by=.EACHI, on="x"]         # same, but using subsets-as-joins
DT[c("b","c"), sum(v), by=.EACHI, on="x"]   # same
DT[c("b","c"), sum(v), by=.EACHI, on=.(x)]  # same, using on=.()

# joins as subsets
X = data.table(x=c("c","b"), v=8:7, foo=c(4,2))
X

DT[X, on="x"]                         # right join
X[DT, on="x"]                         # left join
DT[X, on="x", nomatch=NULL]           # inner join
DT[!X, on="x"]                        # not join
DT[X, on=c(y="v")]                    # join using column "y" of DT with column "v" of X
DT[X, on="y==v"]                      # same as above (v1.9.8+)

DT[X, on=.(y&lt;=foo)]                   # NEW non-equi join (v1.9.8+)
DT[X, on="y&lt;=foo"]                    # same as above
DT[X, on=c("y&lt;=foo")]                 # same as above
DT[X, on=.(y&gt;=foo)]                   # NEW non-equi join (v1.9.8+)
DT[X, on=.(x, y&lt;=foo)]                # NEW non-equi join (v1.9.8+)
DT[X, .(x,y,x.y,v), on=.(x, y&gt;=foo)]  # Select x's join columns as well

DT[X, on="x", mult="first"]           # first row of each group
DT[X, on="x", mult="last"]            # last row of each group
DT[X, sum(v), by=.EACHI, on="x"]      # join and eval j for each row in i
DT[X, sum(v)*foo, by=.EACHI, on="x"]  # join inherited scope
DT[X, sum(v)*i.v, by=.EACHI, on="x"]  # 'i,v' refers to X's v column
DT[X, on=.(x, v&gt;=v), sum(y)*foo, by=.EACHI] # NEW non-equi join with by=.EACHI (v1.9.8+)

# setting keys
kDT = copy(DT)                        # (deep) copy DT to kDT to work with it.
setkey(kDT,x)                         # set a 1-column key. No quotes, for convenience.
setkeyv(kDT,"x")                      # same (v in setkeyv stands for vector)
v="x"
setkeyv(kDT,v)                        # same
haskey(kDT)                           # TRUE
key(kDT)                              # "x"

# fast *keyed* subsets
kDT["a"]                              # subset-as-join on *key* column 'x'
kDT["a", on="x"]                      # same, being explicit using 'on=' (preferred)

# all together
kDT[!"a", sum(v), by=.EACHI]          # get sum(v) for each i != "a"

# multi-column key
setkey(kDT,x,y)                       # 2-column key
setkeyv(kDT,c("x","y"))               # same

# fast *keyed* subsets on multi-column key
kDT["a"]                              # join to 1st column of key
kDT["a", on="x"]                      # on= is optional, but is preferred
kDT[.("a")]                           # same, .() is an alias for list()
kDT[list("a")]                        # same
kDT[.("a", 3)]                        # join to 2 columns
kDT[.("a", 3:6)]                      # join 4 rows (2 missing)
kDT[.("a", 3:6), nomatch=NULL]        # remove missing
kDT[.("a", 3:6), roll=TRUE]           # locf rolling join
kDT[.("a", 3:6), roll=Inf]            # same as above
kDT[.("a", 3:6), roll=-Inf]           # nocb rolling join
kDT[!.("a")]                          # not join
kDT[!"a"]                             # same

# more on special symbols, see also ?"special-symbols"
DT[.N]                                  # last row
DT[, .N]                                # total number of rows in DT
DT[, .N, by=x]                          # number of rows in each group
DT[, .SD, .SDcols=x:y]                  # select columns 'x' through 'y'
DT[ , .SD, .SDcols = !x:y]              # drop columns 'x' through 'y'
DT[ , .SD, .SDcols = patterns('^[xv]')] # select columns matching '^x' or '^v'
DT[, .SD[1]]                            # first row of all columns
DT[, .SD[1], by=x]                      # first row of 'y' and 'v' for each group in 'x'
DT[, c(.N, lapply(.SD, sum)), by=x]     # get rows *and* sum columns 'v' and 'y' by group
DT[, .I[1], by=x]                       # row number in DT corresponding to each group
DT[, grp := .GRP, by=x]                 # add a group counter column
DT[ , dput(.BY), by=.(x,y)]             # .BY is a list of singletons for each group
X[, DT[.BY, y, on="x"], by=x]           # join within each group
DT[, {
  # write each group to a different file
  fwrite(.SD, file.path(tempdir(), paste0('x=', .BY$x, '.csv')))
}, by=x]
dir(tempdir())

# add/update/delete by reference (see ?assign)
print(DT[, z:=42L])                   # add new column by reference
print(DT[, z:=NULL])                  # remove column by reference
print(DT["a", v:=42L, on="x"])        # subassign to existing v column by reference
print(DT["b", v2:=84L, on="x"])       # subassign to new column by reference (NA padded)

DT[, m:=mean(v), by=x][]              # add new column by reference by group
                                      # NB: postfix [] is shortcut to print()
# advanced usage
DT = data.table(x=rep(c("b","a","c"),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1)

DT[, sum(v), by=.(y%%2)]              # expressions in by
DT[, sum(v), by=.(bool = y%%2)]       # same, using a named list to change by column name
DT[, .SD[2], by=x]                    # get 2nd row of each group
DT[, tail(.SD,2), by=x]               # last 2 rows of each group
DT[, lapply(.SD, sum), by=x]          # sum of all (other) columns for each group
DT[, .SD[which.min(v)], by=x]         # nested query by group

DT[, list(MySum=sum(v),
          MyMin=min(v),
          MyMax=max(v)),
    by=.(x, y%%2)]                    # by 2 expressions

DT[, .(a = .(a), b = .(b)), by=x]     # list columns
DT[, .(seq = min(a):max(b)), by=x]    # j is not limited to just aggregations
DT[, sum(v), by=x][V1&lt;20]             # compound query
DT[, sum(v), by=x][order(-V1)]        # ordering results
DT[, c(.N, lapply(.SD,sum)), by=x]    # get number of observations and sum per group
DT[, {tmp &lt;- mean(y);
      .(a = a-tmp, b = b-tmp)
      }, by=x]                        # anonymous lambda in 'j', j accepts any valid
                                      # expression. TO REMEMBER: every element of
                                      # the list becomes a column in result.
pdf("new.pdf")
DT[, plot(a,b), by=x]                 # can also plot in 'j'
dev.off()


# using rleid, get max(y) and min of all cols in .SDcols for each consecutive run of 'v'
DT[, c(.(y=max(y)), lapply(.SD, min)), by=rleid(v), .SDcols=v:b]

# Support guide and links:
# https://github.com/Rdatatable/data.table/wiki/Support

## Not run: 
if (interactive()) {
  vignette(package="data.table")  # 9 vignettes

  test.data.table()               # 6,000 tests

  # keep up to date with latest stable version on CRAN
  update.packages()

  # get the latest devel version that has passed all tests
  update_dev_pkg()
  # read more at:
  # https://github.com/Rdatatable/data.table/wiki/Installation
}

## End(Not run)</code></pre>

<hr>
<h2 id='datatable.optimize'>Optimisations in data.table</h2><span id='topic+datatable-optimize'></span><span id='topic+datatable.optimize'></span><span id='topic+data.table-optimize'></span><span id='topic+data.table.optimize'></span><span id='topic+gforce'></span><span id='topic+GForce'></span><span id='topic+autoindex'></span><span id='topic+autoindexing'></span><span id='topic+auto-index'></span><span id='topic+auto-indexing'></span><span id='topic+rounding'></span>

<h3>Description</h3>

<p><code>data.table</code> internally optimises certain expressions in order to improve
performance. This section briefly summarises those optimisations.
</p>
<p>Note that there's no additional input needed from the user to take advantage
of these optimisations. They happen automatically.
</p>
<p>Run the code under the <em>example</em> section to get a feel for the performance
benefits from these optimisations.
</p>
<p>Note that for all optimizations involving efficient sorts, the caveat mentioned
in <code><a href="#topic+setorder">setorder</a></code> applies &ndash; whenever data.table does the sorting,
it does so in &quot;C-locale&quot;. This has some subtle implications; see Examples.
</p>


<h3>Details</h3>

<p><code>data.table</code> reads the global option <code>datatable.optimize</code> to figure
out what level of optimisation is required. The default value <code>Inf</code>
activates <em>all</em> available optimisations.
</p>
<p>At optimisation level <code>&gt;= 1</code>, i.e., <code>getOption("datatable.optimize")</code>
&gt;= 1, these are the optimisations:
</p>

<ul>
<li><p> The base function <code>order</code> is internally replaced with
<code>data.table</code>'s <em>fast ordering</em>. That is, <code>DT[order(...)]</code>
gets internally optimised to <code>DT[forder(...)]</code>.
</p>
</li>
<li><p> The expression <code>DT[, lapply(.SD, fun), by=.]</code> gets optimised
to <code>DT[, list(fun(a), fun(b), ...), by=.]</code> where <code>a,b, ...</code> are
columns in <code>.SD</code>. This improves performance tremendously.
</p>
</li>
<li><p> Similarly, the expression <code>DT[, c(.N, lapply(.SD, fun)), by=.]</code>
gets optimised to <code>DT[, list(.N, fun(a), fun(b), ...)]</code>. <code>.N</code> is
just for example here.
</p>
</li>
<li> <p><code>base::mean</code> function is internally optimised to use
<code>data.table</code>'s <code>fastmean</code> function. <code>mean()</code> from <code>base</code>
is an S3 generic and gets slow with many groups.
</p>
</li></ul>

<p>At optimisation level <code>&gt;= 2</code>, i.e., <code>getOption("datatable.optimize")</code> &gt;= 2, additional optimisations are implemented on top of the optimisations already shown above.
</p>

<ul>
<li><p> Expressions in <code>j</code> which contain only the functions
<code>min, max, mean, median, var, sd, sum, prod, first, last, head, tail</code> (for example,
<code>DT[, list(mean(x), median(x), min(y), max(y)), by=z]</code>), they are very
effectively optimised using what we call <em>GForce</em>. These functions
are automatically replaced with a corresponding GForce version
with pattern <code>g*</code>, e.g., <code>prod</code> becomes <code>gprod</code>.
</p>
<p>Normally, once the rows belonging to each group are identified, the values
corresponding to the group are gathered and the <code>j</code>-expression is
evaluated. This can be improved by computing the result directly without
having to gather the values or evaluating the expression for each group
(which can get costly with large number of groups) by implementing it
specifically for a particular function. As a result, it is extremely fast.
</p>
</li>
<li><p> In addition to all the functions above, '.N' is also optimised to
use GForce, when used separately or when combined with the functions mentioned
above. Note further that GForce-optimized functions must be used separately,
i.e., code like <code>DT[ , max(x) - min(x), by=z]</code> will <em>not</em> currently
be optimized to use <code>gmax, gmin</code>.
</p>
</li>
<li><p> Expressions of the form <code>DT[i, j, by]</code> are also optimised when
<code>i</code> is a <em>subset</em> operation and <code>j</code> is any/all of the functions
discussed above.
</p>
</li></ul>

<p>At optimisation level <code>&gt;= 3</code>, i.e., <code>getOption("datatable.optimize")</code> &gt;= 3, additional optimisations for subsets in i are implemented on top of the optimisations already shown above. Subsetting operations are - if possible - translated into joins to make use of blazing fast binary search using indices and keys. The following queries are optimized:
</p>

<ul>
<li><p> Supported operators: <code>==</code>, <code>%in%</code>. Non-equi operators(&gt;, &lt;, etc.) are not supported yet because non-equi joins are slower than vector based subsets.
</p>
</li>
<li><p> Queries on multiple columns are supported, if the connector is '<code>&amp;</code>', e.g. <code>DT[x == 2 &amp; y == 3]</code> is supported, but <code>DT[x == 2 | y == 3]</code> is not.
</p>
</li>
<li><p> Optimization will currently be turned off when doing subset when cross product of elements provided to filter on exceeds &gt; 1e4. This most likely happens if multiple <code>%in%</code>, or <code>%chin%</code> queries are combined, e.g. <code>DT[x %in% 1:100 &amp; y %in% 1:200]</code> will not be optimized since <code>100 * 200 = 2e4 &gt; 1e4</code>.
</p>
</li>
<li><p> Queries with multiple criteria on one column are <em>not</em> supported, e.g. <code>DT[x == 2 &amp; x %in% c(2,5)]</code> is not supported.
</p>
</li>
<li><p> Queries with non-missing j are supported, e.g. <code>DT[x == 3 &amp; y == 5, .(new = x-y)]</code> or <code>DT[x == 3 &amp; y == 5, new := x-y]</code> are supported. Also extends to queries using <code>with = FALSE</code>.
</p>
</li>
<li><p> &quot;notjoin&quot; queries, i.e. queries that start with <code>!</code>, are only supported if there are no <code>&amp;</code> connections, e.g. <code>DT[!x==3]</code> is supported, but <code>DT[!x==3 &amp; y == 4]</code> is not.
</p>
</li></ul>

<p>If in doubt, whether your query benefits from optimization, call it with the <code>verbose = TRUE</code> argument. You should see &quot;Optimized subsetting...&quot;.
</p>
<p><b>Auto indexing:</b> In case a query is optimized, but no appropriate key or index is found, <code>data.table</code> automatically creates an <em>index</em> on the first run. Any successive subsets on the same
column then reuse this index to <em>binary search</em> (instead of
<em>vector scan</em>) and is therefore fast.
Auto indexing can be switched off with the global option
<code>options(datatable.auto.index = FALSE)</code>. To switch off using existing
indices set global option <code>options(datatable.use.index = FALSE)</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+setNumericRounding">setNumericRounding</a></code>, <code><a href="#topic+getNumericRounding">getNumericRounding</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
old = options(datatable.optimize = Inf)

# Generate a big data.table with a relatively many columns
set.seed(1L)
DT = lapply(1:20, function(x) sample(c(-100:100), 5e6L, TRUE))
setDT(DT)[, id := sample(1e5, 5e6, TRUE)]
print(object.size(DT), units="Mb") # 400MB, not huge, but will do

# 'order' optimisation
options(datatable.optimize = 1L) # optimisation 'on'
system.time(ans1 &lt;- DT[order(id)])
options(datatable.optimize = 0L) # optimisation 'off'
system.time(ans2 &lt;- DT[order(id)])
identical(ans1, ans2)

# optimisation of 'lapply(.SD, fun)'
options(datatable.optimize = 1L) # optimisation 'on'
system.time(ans1 &lt;- DT[, lapply(.SD, min), by=id])
options(datatable.optimize = 0L) # optimisation 'off'
system.time(ans2 &lt;- DT[, lapply(.SD, min), by=id])
identical(ans1, ans2)

# optimisation of 'mean'
options(datatable.optimize = 1L) # optimisation 'on'
system.time(ans1 &lt;- DT[, lapply(.SD, mean), by=id])
system.time(ans2 &lt;- DT[, lapply(.SD, base::mean), by=id])
identical(ans1, ans2)

# optimisation of 'c(.N, lapply(.SD, ))'
options(datatable.optimize = 1L) # optimisation 'on'
system.time(ans1 &lt;- DT[, c(.N, lapply(.SD, min)), by=id])
options(datatable.optimize = 0L) # optimisation 'off'
system.time(ans2 &lt;- DT[, c(N=.N, lapply(.SD, min)), by=id])
identical(ans1, ans2)

# GForce
options(datatable.optimize = 2L) # optimisation 'on'
system.time(ans1 &lt;- DT[, lapply(.SD, median), by=id])
system.time(ans2 &lt;- DT[, lapply(.SD, function(x) as.numeric(stats::median(x))), by=id])
identical(ans1, ans2)

# optimized subsets
options(datatable.optimize = 2L)
system.time(ans1 &lt;- DT[id == 100L]) # vector scan
system.time(ans2 &lt;- DT[id == 100L]) # vector scan
system.time(DT[id %in% 100:500])    # vector scan

options(datatable.optimize = 3L)
system.time(ans1 &lt;- DT[id == 100L]) # index + binary search subset
system.time(ans2 &lt;- DT[id == 100L]) # only binary search subset
system.time(DT[id %in% 100:500])    # only binary search subset again

# sensitivity to collate order
old_lc_collate = Sys.getlocale("LC_COLLATE")

if (old_lc_collate == "C") {
  Sys.setlocale("LC_COLLATE", "")
}
DT = data.table(
  grp = rep(1:2, each = 4L),
  var = c("A", "a", "0", "1", "B", "b", "0", "1")
)
options(datatable.optimize = Inf)
DT[, .(max(var), min(var)), by=grp]
# GForce is deactivated because of the ad-hoc column 'tolower(var)',
#   through which the result for 'max(var)' may also change
DT[, .(max(var), min(tolower(var))), by=grp]

Sys.setlocale("LC_COLLATE", old_lc_collate)
options(old)

## End(Not run)</code></pre>

<hr>
<h2 id='dcast.data.table'>Fast dcast for data.table</h2><span id='topic+dcast.data.table'></span><span id='topic+dcast'></span>

<h3>Description</h3>

<p><code>dcast.data.table</code> is <code>data.table</code>'s long-to-wide reshaping tool. In the spirit of <code>data.table</code>, it is very fast and memory efficient, making it well-suited to handling large data sets in RAM.  More importantly, it is capable of handling very large data quite efficiently in terms of memory usage. <code>dcast.data.table</code> can also cast multiple <code>value.var</code> columns and accepts multiple functions to <code>fun.aggregate</code>. See Examples for more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.table'
dcast(data, formula, fun.aggregate = NULL, sep = "_",
    ..., margins = NULL, subset = NULL, fill = NULL,
    drop = TRUE, value.var = guess(data),
    verbose = getOption("datatable.verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcast.data.table_+3A_data">data</code></td>
<td>
<p> A <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="dcast.data.table_+3A_formula">formula</code></td>
<td>
<p>A formula of the form LHS ~ RHS to cast, see Details.</p>
</td></tr>
<tr><td><code id="dcast.data.table_+3A_fun.aggregate">fun.aggregate</code></td>
<td>
<p>Should the data be aggregated before casting? If the formula doesn't identify a single observation for each cell, then aggregation defaults to <code>length</code> with a message.
</p>
<p>To use multiple aggregation functions, pass a <code>list</code>; see Examples. </p>
</td></tr>
<tr><td><code id="dcast.data.table_+3A_sep">sep</code></td>
<td>
<p>Character vector of length 1, indicating the separating character in variable names generated during casting. Default is <code>_</code> for backwards compatibility. </p>
</td></tr>
<tr><td><code id="dcast.data.table_+3A_...">...</code></td>
<td>
<p>Any other arguments that may be passed to the aggregating function.</p>
</td></tr>
<tr><td><code id="dcast.data.table_+3A_margins">margins</code></td>
<td>
<p>Not implemented yet. Should take variable names to compute margins on. A value of <code>TRUE</code> would compute all margins.</p>
</td></tr>
<tr><td><code id="dcast.data.table_+3A_subset">subset</code></td>
<td>
<p>Specified if casting should be done on a subset of the data. Ex: <code>subset = .(col1 &lt;= 5)</code> or <code>subset = .(variable != "January")</code>.</p>
</td></tr>
<tr><td><code id="dcast.data.table_+3A_fill">fill</code></td>
<td>
<p>Value with which to fill missing cells. If <code>fun.aggregate</code> is present, takes the value by applying the function on a 0-length vector.</p>
</td></tr>
<tr><td><code id="dcast.data.table_+3A_drop">drop</code></td>
<td>
<p><code>FALSE</code> will cast by including all missing combinations.
</p>
<p><code>c(FALSE, TRUE)</code> will only include all missing combinations of formula <code>LHS</code>; <code>c(TRUE, FALSE)</code> will only include all missing combinations of formula RHS. See Examples.</p>
</td></tr>
<tr><td><code id="dcast.data.table_+3A_value.var">value.var</code></td>
<td>
<p>Name of the column whose values will be filled to cast. Function <code>guess()</code> tries to, well, guess this column automatically, if none is provided.
</p>
<p>Cast multiple <code>value.var</code> columns simultaneously by passing their names as a <code>character</code> vector. See Examples. </p>
</td></tr>
<tr><td><code id="dcast.data.table_+3A_verbose">verbose</code></td>
<td>
<p>Not used yet. May be dropped in the future or used to provide informative messages through the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cast formula takes the form <code>LHS ~ RHS</code>, ex: <code>var1 + var2 ~ var3</code>. The order of entries in the formula is essential. There are two special variables: <code>.</code> represents no variable, while <code>...</code> represents all variables not otherwise mentioned in <code>formula</code>; see Examples.
</p>
<p>When not all combinations of LHS &amp; RHS values are present in the data, some or all (in accordance with <code>drop</code>) missing combinations will replaced with the value specified by <code>fill</code>. Note that <code>fill</code> will be converted to the class of <code>value.var</code>; see Examples.
</p>
<p><code>dcast</code> also allows <code>value.var</code> columns of type <code>list</code>.
</p>
<p>When variable combinations in <code>formula</code> don't identify a unique value, <code>fun.aggregate</code> will have to be specified, which defaults to <code>length</code>. For the formula <code>var1 ~ var2</code>, this means there are some <code>(var1, var2)</code> combinations in the data corresponding to multiple rows (i.e. <code>x</code> is not unique by <code>(var1, var2)</code>.
</p>
<p>The aggregating function should take a vector as input and return a single value (or a list of length one) as output. In cases where <code>value.var</code> is a list, the function should be able to handle a list input and provide a single value or list of length one as output.
</p>
<p>If the formula's LHS contains the same column more than once, ex: <code>dcast(DT, x+x~ y)</code>, then the answer will have duplicate names. In those cases, the duplicate names are renamed using <code>make.unique</code> so that key can be set without issues.
</p>
<p>Names for columns that are being cast are generated in the same order (separated by an underscore, <code>_</code>) from the (unique) values in each column mentioned in the formula RHS.
</p>
<p>From <code>v1.9.4</code>, <code>dcast</code> tries to preserve attributes wherever possible.
</p>
<p>From <code>v1.9.6</code>, it is possible to cast multiple <code>value.var</code> columns and also cast by providing multiple <code>fun.aggregate</code> functions. Multiple <code>fun.aggregate</code> functions should be provided as a <code>list</code>, for e.g., <code>list(mean, sum, function(x) paste(x, collapse="")</code>. <code>value.var</code> can be either a character vector or list of length one, or a list of length equal to <code>length(fun.aggregate)</code>. When <code>value.var</code> is a character vector or a list of length one, each function mentioned under <code>fun.aggregate</code> is applied to every column specified under <code>value.var</code> column. When <code>value.var</code> is a list of length equal to <code>length(fun.aggregate)</code> each element of <code>fun.aggregate</code> is applied to each element of <code>value.var</code> column.
</p>
<p>Historical note: <code>dcast.data.table</code> was originally designed as an enhancement to <code>reshape2::dcast</code> in terms of computing and memory efficiency. <code>reshape2</code> has since been superseded in favour of <code>tidyr</code>, and <code>dcast</code> has had a generic defined within <code>data.table</code> since <code>v1.9.6</code> in 2015, at which point the dependency between the packages became more etymological than programmatic. We thank the <code>reshape2</code> authors for the inspiration.
</p>


<h3>Value</h3>

<p>A keyed <code>data.table</code> that has been cast. The key columns are equal to the variables in the <code>formula</code> LHS in the same order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+melt.data.table">melt.data.table</a></code>, <code><a href="#topic+rowid">rowid</a></code>, <a href="https://cran.r-project.org/package=reshape">https://cran.r-project.org/package=reshape</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ChickWeight = as.data.table(ChickWeight)
setnames(ChickWeight, tolower(names(ChickWeight)))
DT &lt;- melt(as.data.table(ChickWeight), id.vars=2:4) # calls melt.data.table

# dcast is an S3 method in data.table from v1.9.6
dcast(DT, time ~ variable, fun.aggregate=mean)
dcast(DT, diet ~ variable, fun.aggregate=mean)
dcast(DT, diet+chick ~ time, drop=FALSE)
dcast(DT, diet+chick ~ time, drop=FALSE, fill=0)

# using subset
dcast(DT, chick ~ time, fun.aggregate=mean, subset=.(time &lt; 10 &amp; chick &lt; 20))

# drop argument, #1512
DT &lt;- data.table(v1 = c(1.1, 1.1, 1.1, 2.2, 2.2, 2.2),
                 v2 = factor(c(1L, 1L, 1L, 3L, 3L, 3L), levels=1:3),
                 v3 = factor(c(2L, 3L, 5L, 1L, 2L, 6L), levels=1:6),
                 v4 = c(3L, 2L, 2L, 5L, 4L, 3L))
# drop=TRUE
dcast(DT, v1+v2~v3, value.var='v4')                      # default is drop=TRUE
dcast(DT, v1+v2~v3, value.var='v4', drop=FALSE)          # all missing combinations of LHS and RHS
dcast(DT, v1+v2~v3, value.var='v4', drop=c(FALSE, TRUE)) # all missing combinations of LHS only
dcast(DT, v1+v2~v3, value.var='v4', drop=c(TRUE, FALSE)) # all missing combinations of RHS only

# using . and ...
DT &lt;- data.table(v1 = rep(1:2, each = 6),
                 v2 = rep(rep(1:3, 2), each = 2),
                 v3 = rep(1:2, 6),
                 v4 = rnorm(6))
dcast(DT, ... ~ v3, value.var="v4") # same as v1+v2 ~ v3, value.var="v4"
dcast(DT, v1+v2+v3 ~ ., value.var="v4")

## for each combination of (v1, v2), add up all values of v4
dcast(DT, v1+v2 ~ ., value.var="v4", fun.aggregate=sum)

# fill and types
dcast(DT, v2~v3, value.var='v1', fun.aggregate=length, fill=0L)  #  0L --&gt; 0
dcast(DT, v2~v3, value.var='v4', fun.aggregate=length, fill=1.1) # 1.1 --&gt; 1L

# multiple value.var and multiple fun.aggregate
DT = data.table(x=sample(5,20,TRUE), y=sample(2,20,TRUE),
                z=sample(letters[1:2], 20,TRUE), d1=runif(20), d2=1L)
# multiple value.var
dcast(DT, x+y ~ z, fun.aggregate=sum, value.var=c("d1","d2"))
# multiple fun.aggregate
dcast(DT, x+y ~ z, fun.aggregate=list(sum, mean), value.var="d1")
# multiple fun.agg and value.var (all combinations)
dcast(DT, x+y ~ z, fun.aggregate=list(sum, mean), value.var=c("d1", "d2"))
# multiple fun.agg and value.var (one-to-one)
dcast(DT, x+y ~ z, fun.aggregate=list(sum, mean), value.var=list("d1", "d2"))
</code></pre>

<hr>
<h2 id='duplicated'> Determine Duplicate Rows </h2><span id='topic+duplicated'></span><span id='topic+duplicated.data.table'></span><span id='topic+unique'></span><span id='topic+unique.data.table'></span><span id='topic+anyDuplicated'></span><span id='topic+anyDuplicated.data.table'></span><span id='topic+uniqueN'></span>

<h3>Description</h3>

<p><code>duplicated</code> returns a logical vector indicating which rows of a
<code>data.table</code> are duplicates of a row with smaller subscripts.
</p>
<p><code>unique</code> returns a <code>data.table</code> with duplicated rows removed, by
columns specified in <code>by</code> argument. When no <code>by</code> then duplicated
rows by all columns are removed.
</p>
<p><code>anyDuplicated</code> returns the <em>index</em> <code>i</code> of the first duplicated
entry if there is one, and 0 otherwise.
</p>
<p><code>uniqueN</code> is equivalent to <code>length(unique(x))</code> when x is an
<code>atomic vector</code>, and <code>nrow(unique(x))</code> when x is a <code>data.frame</code>
or <code>data.table</code>. The number of unique rows are computed directly without
materialising the intermediate unique data.table and is therefore faster and
memory efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.table'
duplicated(x, incomparables=FALSE, fromLast=FALSE, by=seq_along(x), ...)

## S3 method for class 'data.table'
unique(x, incomparables=FALSE, fromLast=FALSE,
by=seq_along(x), cols=NULL, ...)

## S3 method for class 'data.table'
anyDuplicated(x, incomparables=FALSE, fromLast=FALSE, by=seq_along(x), ...)

uniqueN(x, by=if (is.list(x)) seq_along(x) else NULL, na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicated_+3A_x">x</code></td>
<td>
<p> A data.table. <code>uniqueN</code> accepts atomic vectors and data.frames
as well.</p>
</td></tr>
<tr><td><code id="duplicated_+3A_...">...</code></td>
<td>
<p> Not used at this time. </p>
</td></tr>
<tr><td><code id="duplicated_+3A_incomparables">incomparables</code></td>
<td>
<p> Not used. Here for S3 method consistency. </p>
</td></tr>
<tr><td><code id="duplicated_+3A_fromlast">fromLast</code></td>
<td>
<p> logical indicating if duplication should be considered from
the reverse side, i.e., the last (or rightmost) of identical elements would
correspond to <code>duplicated = FALSE</code>.</p>
</td></tr>
<tr><td><code id="duplicated_+3A_by">by</code></td>
<td>
<p><code>character</code> or <code>integer</code> vector indicating which combinations
of columns from <code>x</code> to use for uniqueness checks. By default all columns
are being used. That was changed recently for consistency to data.frame methods.
In version <code>&lt; 1.9.8</code> default was <code>key(x)</code>.</p>
</td></tr>
<tr><td><code id="duplicated_+3A_cols">cols</code></td>
<td>
<p>Columns (in addition to <code>by</code>) from <code>x</code> to include in the
resulting <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="duplicated_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical (default is <code>FALSE</code>). Should missing values (including
<code>NaN</code>) be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because data.tables are usually sorted by key, tests for duplication are
especially quick when only the keyed columns are considered. Unlike
<code><a href="base.html#topic+unique">unique.data.frame</a></code>, <code>paste</code> is not used to ensure
equality of floating point data. It is instead accomplished directly and is
therefore quite fast. data.table provides <code><a href="#topic+setNumericRounding">setNumericRounding</a></code> to
handle cases where limitations in floating point representation is undesirable.
</p>
<p><code>v1.9.4</code> introduces <code>anyDuplicated</code> method for data.tables and is
similar to base in functionality. It also implements the logical argument
<code>fromLast</code> for all three functions, with default value
<code>FALSE</code>.
</p>
<p>Note: When <code>cols</code> is specified, the resulting table will have
columns <code>c(by, cols)</code>, in that order.
</p>


<h3>Value</h3>

<p><code>duplicated</code> returns a logical vector of length <code>nrow(x)</code>
indicating which rows are duplicates.
</p>
<p><code>unique</code> returns a data table with duplicated rows removed.
</p>
<p><code>anyDuplicated</code> returns a integer value with the index of first duplicate.
If none exists, 0L is returned.
</p>
<p><code>uniqueN</code> returns the number of unique elements in the vector,
<code>data.frame</code> or <code>data.table</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+setNumericRounding">setNumericRounding</a></code>, <code><a href="#topic+data.table">data.table</a></code>,
<code><a href="#topic+duplicated">duplicated</a></code>, <code><a href="#topic+unique">unique</a></code>, <code><a href="#topic+all.equal">all.equal</a></code>,
<code><a href="#topic+fsetdiff">fsetdiff</a></code>, <code><a href="#topic+funion">funion</a></code>, <code><a href="#topic+fintersect">fintersect</a></code>,
<code><a href="#topic+fsetequal">fsetequal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DT &lt;- data.table(A = rep(1:3, each=4), B = rep(1:4, each=3),
                  C = rep(1:2, 6), key = "A,B")
duplicated(DT)
unique(DT)

duplicated(DT, by="B")
unique(DT, by="B")

duplicated(DT, by=c("A", "C"))
unique(DT, by=c("A", "C"))

DT = data.table(a=c(2L,1L,2L), b=c(1L,2L,1L))   # no key
unique(DT)                   # rows 1 and 2 (row 3 is a duplicate of row 1)

DT = data.table(a=c(3.142, 4.2, 4.2, 3.142, 1.223, 1.223), b=rep(1,6))
unique(DT)                   # rows 1,2 and 5

DT = data.table(a=tan(pi*(1/4 + 1:10)), b=rep(1,10))   # example from ?all.equal
length(unique(DT$a))         # 10 strictly unique floating point values
all.equal(DT$a,rep(1,10))    # TRUE, all within tolerance of 1.0
DT[,which.min(a)]            # row 10, the strictly smallest floating point value
identical(unique(DT),DT[1])  # TRUE, stable within tolerance
identical(unique(DT),DT[10]) # FALSE

# fromLast=TRUE
DT &lt;- data.table(A = rep(1:3, each=4), B = rep(1:4, each=3),
                 C = rep(1:2, 6), key = "A,B")
duplicated(DT, by="B", fromLast=TRUE)
unique(DT, by="B", fromLast=TRUE)

# anyDuplicated
anyDuplicated(DT, by=c("A", "B"))    # 3L
any(duplicated(DT, by=c("A", "B")))  # TRUE

# uniqueN, unique rows on key columns
uniqueN(DT, by = key(DT))
# uniqueN, unique rows on all columns
uniqueN(DT)
# uniqueN while grouped by "A"
DT[, .(uN=uniqueN(.SD)), by=A]

# uniqueN's na.rm=TRUE
x = sample(c(NA, NaN, runif(3)), 10, TRUE)
uniqueN(x, na.rm = FALSE) # 5, default
uniqueN(x, na.rm=TRUE) # 3
</code></pre>

<hr>
<h2 id='fcase'>fcase</h2><span id='topic+fcase'></span>

<h3>Description</h3>

<p><code>fcase</code> is a fast implementation of SQL <code>CASE WHEN</code> statement for R. Conceptually, <code>fcase</code> is a nested version of <code><a href="#topic+fifelse">fifelse</a></code> (with smarter implementation than manual nesting). It is comparable to <code>dplyr::case_when</code> and supports <code>bit64</code>'s <code>integer64</code> and <code>nanotime</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fcase(..., default=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fcase_+3A_...">...</code></td>
<td>
<p> A sequence consisting of logical condition (<code>when</code>)-resulting value (<code>value</code>) <em>pairs</em> in the following order <code>when1, value1, when2, value2, ..., whenN, valueN</code>. Logical conditions <code>when1, when2, ..., whenN</code> must all have the same length, type and attributes. Each <code>value</code> may either share length with <code>when</code> or be length 1. Please see Examples section for further details.</p>
</td></tr>
<tr><td><code id="fcase_+3A_default">default</code></td>
<td>
<p> Default return value, <code>NA</code> by default, for when all of the logical conditions <code>when1, when2, ..., whenN</code> are <code>FALSE</code> or missing for some entries. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with the same length as the logical conditions (<code>when</code>) in <code>...</code>, filled with the corresponding values (<code>value</code>) from <code>...</code>, or eventually <code>default</code>. Attributes of output values <code>value1, value2, ...valueN</code> in <code>...</code> are preserved.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fifelse">fifelse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = 1:10
fcase(
	x &lt; 5L, 1L,
	x &gt; 5L, 3L
)

fcase(
	x &lt; 5L, 1L:10L,
	x &gt; 5L, 3L:12L
)

# Lazy evaluation example
fcase(
	x &lt; 5L, 1L,
	x &gt;= 5L, 3L,
	x == 5L, stop("provided value is an unexpected one!")
)

# fcase preserves attributes, example with dates
fcase(
	x &lt; 5L, as.Date("2019-10-11"),
	x &gt; 5L, as.Date("2019-10-14")
)

# fcase example with factor; note the matching levels
fcase(
	x &lt; 5L, factor("a", levels=letters[1:3]),
	x &gt; 5L, factor("b", levels=letters[1:3])
)

# Example of using the 'default' argument
fcase(
	x &lt; 5L, 1L,
	x &gt; 5L, 3L,
	default = 5L
)
</code></pre>

<hr>
<h2 id='fcoalesce'> Coalescing missing values </h2><span id='topic+fcoalesce'></span><span id='topic+setcoalesce'></span>

<h3>Description</h3>

<p>Fill in missing values in a vector by successively pulling from candidate vectors in order. As per the ANSI SQL function COALESCE, <code>dplyr::coalesce</code> and <code>hutils::coalesce</code>. Unlike <code>BBmisc::coalesce</code> which just returns the first non-NULL vector.
Written in C, and multithreaded for numeric and factor types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fcoalesce(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fcoalesce_+3A_...">...</code></td>
<td>
<p> A set of same-class vectors. These vectors can be supplied as separate arguments or as a single plain list, data.table or data.frame, see examples. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Factor type is supported only when the factor levels of each item are equal.
</p>
<p><code>NaN</code> is considered missing (note <code>is.na(NaN)</code> and <code>all.equal(NA_real_, NaN)</code> are both <code>TRUE</code>).
</p>


<h3>Value</h3>

<p>Atomic vector of the same type and length as the first vector, having <code>NA</code> values replaced by corresponding non-<code>NA</code> values from the other vectors.
If the first item is <code>NULL</code>, the result is <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fifelse">fifelse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(11L, NA, 13L, NA, 15L, NA)
y = c(NA, 12L, 5L, NA, NA, NA)
z = c(11L, NA, 1L, 14L, NA, NA)
fcoalesce(x, y, z)
fcoalesce(list(x,y,z))   # same
fcoalesce(x, list(y,z))  # same
</code></pre>

<hr>
<h2 id='fdroplevels'>Fast droplevels</h2><span id='topic+fdroplevels'></span><span id='topic+droplevels'></span><span id='topic+droplevels.data.table'></span>

<h3>Description</h3>

<p>Similar to <code>base::droplevels</code> but <em>much faster</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdroplevels(x, exclude = if (anyNA(levels(x))) NULL else NA, ...)

## S3 method for class 'data.table'
droplevels(x, except = NULL, exclude, in.place = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdroplevels_+3A_x">x</code></td>
<td>
 <p><code>factor</code> or <code>data.table</code> where unused levels should be dropped. </p>
</td></tr>
<tr><td><code id="fdroplevels_+3A_exclude">exclude</code></td>
<td>
<p> A <code>character</code> vector of factor levels which are dropped no matter of presented or not. </p>
</td></tr>
<tr><td><code id="fdroplevels_+3A_except">except</code></td>
<td>
<p> An <code>integer</code> vector of indices of data.table columns which are not modified by dropping levels. </p>
</td></tr>
<tr><td><code id="fdroplevels_+3A_in.place">in.place</code></td>
<td>
<p> logical (default is <code>FALSE</code>). If <code>TRUE</code> levels of factors of <code>data.table</code> are modified in-place. </p>
</td></tr>
<tr><td><code id="fdroplevels_+3A_...">...</code></td>
<td>
<p> further arguments passed to methods </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fdroplevels</code> returns a <code>factor</code>.
</p>
<p><code>droplevels</code> returns a <code>data.table</code> where levels are dropped at factor columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+duplicated">duplicated</a></code>, <code><a href="#topic+unique">unique</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># on vectors
x = factor(letters[1:10])
fdroplevels(x[1:5])
# exclude levels from drop
fdroplevels(x[1:5], exclude = c("a", "c"))

# on data.table
DT = data.table(a = factor(1:10), b = factor(letters[1:10]))
droplevels(head(DT))[["b"]]
# exclude levels
droplevels(head(DT), exclude = c("b", "c"))[["b"]]
# except columns from drop
droplevels(head(DT), except = 2)[["b"]]
droplevels(head(DT), except = 1)[["b"]]
</code></pre>

<hr>
<h2 id='fifelse'> Fast ifelse </h2><span id='topic+fifelse'></span><span id='topic+ifelse'></span>

<h3>Description</h3>

<p><code>fifelse</code> is a faster and more robust replacement of <code><a href="base.html#topic+ifelse">ifelse</a></code>. It is comparable to <code>dplyr::if_else</code> and <code>hutils::if_else</code>. It returns a value with the same length as <code>test</code> filled with corresponding values from <code>yes</code>, <code>no</code> or eventually <code>na</code>, depending on <code>test</code>. Supports <code>bit64</code>'s <code>integer64</code> and <code>nanotime</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fifelse(test, yes, no, na=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fifelse_+3A_test">test</code></td>
<td>
<p> A logical vector. </p>
</td></tr>
<tr><td><code id="fifelse_+3A_yes">yes</code>, <code id="fifelse_+3A_no">no</code></td>
<td>
<p> Values to return depending on <code>TRUE</code>/<code>FALSE</code> element of <code>test</code>. They must be the same type and be either length <code>1</code> or the same length of <code>test</code>. </p>
</td></tr>
<tr><td><code id="fifelse_+3A_na">na</code></td>
<td>
<p> Value to return if an element of <code>test</code> is <code>NA</code>. It must be the same type as <code>yes</code> and <code>no</code> and its length must be either <code>1</code> or the same length of <code>test</code>. Default value <code>NA</code>. <code>NULL</code> is treated as <code>NA</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In contrast to <code><a href="base.html#topic+ifelse">ifelse</a></code> attributes are copied from the first non-<code>NA</code> argument to the output. This is useful when returning <code>Date</code>, <code>factor</code> or other classes.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>test</code> and attributes as <code>yes</code>. Data values are taken from the values of <code>yes</code> and <code>no</code>, eventually <code>na</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fcoalesce">fcoalesce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(1:4, 3:2, 1:4)
fifelse(x &gt; 2L, x, x - 1L)

# unlike ifelse, fifelse preserves attributes, taken from the 'yes' argument
dates = as.Date(c("2011-01-01","2011-01-02","2011-01-03","2011-01-04","2011-01-05"))
ifelse(dates == "2011-01-01", dates - 1, dates)
fifelse(dates == "2011-01-01", dates - 1, dates)
yes = factor(c("a","b","c"))
no = yes[1L]
ifelse(c(TRUE,FALSE,TRUE), yes, no)
fifelse(c(TRUE,FALSE,TRUE), yes, no)

# Example of using the 'na' argument
fifelse(test = c(-5L:5L &lt; 0L, NA), yes = 1L, no = 0L, na = 2L)
</code></pre>

<hr>
<h2 id='foverlaps'>Fast overlap joins</h2><span id='topic+foverlaps'></span>

<h3>Description</h3>

<p>A <em>fast</em> binary-search based <em>overlap join</em> of two <code>data.table</code>s.
This is very much inspired by <code>findOverlaps</code> function from the Bioconductor
package <code>IRanges</code> (see link below under <code>See Also</code>).
</p>
<p>Usually, <code>x</code> is a very large data.table with small interval ranges, and
<code>y</code> is much smaller <em>keyed</em> <code>data.table</code> with relatively larger
interval spans. For a usage in <code>genomics</code>, see the examples section.
</p>
<p>NOTE: This is still under development, meaning it is stable, but some features
are yet to be implemented. Also, some arguments and/or the function name itself
could be changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foverlaps(x, y, by.x = if (!is.null(key(x))) key(x) else key(y),
    by.y = key(y), maxgap = 0L, minoverlap = 1L,
    type = c("any", "within", "start", "end", "equal"),
    mult = c("all", "first", "last"),
    nomatch = NA,
    which = FALSE, verbose = getOption("datatable.verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foverlaps_+3A_x">x</code>, <code id="foverlaps_+3A_y">y</code></td>
<td>
 <p><code>data.table</code>s. <code>y</code> needs to be keyed, but not necessarily
<code>x</code>. See examples. </p>
</td></tr>
<tr><td><code id="foverlaps_+3A_by.x">by.x</code>, <code id="foverlaps_+3A_by.y">by.y</code></td>
<td>
<p>A vector of column names (or numbers) to compute the overlap
joins. The last two columns in both <code>by.x</code> and <code>by.y</code> should each
correspond to the <code>start</code> and <code>end</code> interval columns in <code>x</code> and
<code>y</code> respectively. And the <code>start</code> column should always be &lt;= <code>end</code>
column. If <code>x</code> is keyed,  <code>by.x</code> is equal to <code>key(x)</code>, else
<code>key(y)</code>. <code>by.y</code> defaults to <code>key(y)</code>. </p>
</td></tr>
<tr><td><code id="foverlaps_+3A_maxgap">maxgap</code></td>
<td>
<p>It should be a non-negative integer value, &gt;= 0. Default is 0 (no
gap). For intervals <code>[a,b]</code> and <code>[c,d]</code>, where <code>a&lt;=b</code> and
<code>c&lt;=d</code>, when <code>c &gt; b</code> or <code>d &lt; a</code>, the two intervals don't overlap.
If the gap between these two intervals is <code>&lt;= maxgap</code>, these two intervals
are considered as overlapping. Note: This is not yet implemented.</p>
</td></tr>
<tr><td><code id="foverlaps_+3A_minoverlap">minoverlap</code></td>
<td>
<p> It should be a positive integer value, &gt; 0. Default is 1. For
intervals <code>[a,b]</code> and <code>[c,d]</code>, where <code>a&lt;=b</code> and <code>c&lt;=d</code>, when
<code>c&lt;=b</code> and <code>d&gt;=a</code>, the two intervals overlap. If the length of overlap
between these two intervals is <code>&gt;= minoverlap</code>, then these two intervals are
considered to be overlapping. Note: This is not yet implemented.</p>
</td></tr>
<tr><td><code id="foverlaps_+3A_type">type</code></td>
<td>
<p> Default value is <code>any</code>. Allowed values are <code>any</code>,
<code>within</code>, <code>start</code>, <code>end</code> and <code>equal</code>.
</p>
<p>The types shown here are identical in functionality to the function
<code>findOverlaps</code> in the bioconductor package <code>IRanges</code>. Let <code>[a,b]</code>
and <code>[c,d]</code> be intervals in <code>x</code> and <code>y</code> with <code>a&lt;=b</code> and
<code>c&lt;=d</code>. For <code>type="start"</code>, the intervals overlap iff <code>a == c</code>.
For <code>type="end"</code>, the intervals overlap iff <code>b == d</code>. For
<code>type="within"</code>, the intervals overlap iff <code>a&gt;=c and b&lt;=d</code>. For
<code>type="equal"</code>, the intervals overlap iff <code>a==c and b==d</code>. For
<code>type="any"</code>, as long as <code>c&lt;=b and d&gt;=a</code>, they overlap. In addition
to these requirements, they also have to satisfy the <code>minoverlap</code> argument
as explained above.
</p>
<p>NB: <code>maxgap</code> argument, when &gt; 0, is to be interpreted according to the type
of the overlap. This will be updated once <code>maxgap</code> is implemented.</p>
</td></tr>
<tr><td><code id="foverlaps_+3A_mult">mult</code></td>
<td>
<p> When multiple rows in <code>y</code> match to the row in <code>x</code>,
<code>mult=.</code> controls which values are returned - <code>"all"</code> (default),
<code>"first"</code> or <code>"last"</code>.</p>
</td></tr>
<tr><td><code id="foverlaps_+3A_nomatch">nomatch</code></td>
<td>
<p> When a row (with interval say, <code>[a,b]</code>) in <code>x</code> has no
match in <code>y</code>, <code>nomatch=NA</code> (default) means <code>NA</code> is returned for
<code>y</code>'s non-<code>by.y</code> columns for that row of <code>x</code>. <code>nomatch=NULL</code>
(or <code>0</code> for backward compatibility) means no rows will be returned for that
row of <code>x</code>. </p>
</td></tr>
<tr><td><code id="foverlaps_+3A_which">which</code></td>
<td>
<p> When <code>TRUE</code>, if <code>mult="all"</code> returns a two column
<code>data.table</code> with the first column corresponding to <code>x</code>'s row number
and the second corresponding to <code>y</code>'s. When <code>nomatch=NA</code>, no matches
return <code>NA</code> for <code>y</code>, and if <code>nomatch=NULL</code>, those rows where no
match is found will be skipped; if <code>mult="first" or "last"</code>, a vector of
length equal to the number of rows in <code>x</code> is returned, with no-match entries
filled with <code>NA</code> or <code>0</code> corresponding to the <code>nomatch</code> argument.
Default is <code>FALSE</code>, which returns a join with the rows in <code>y</code>.</p>
</td></tr>
<tr><td><code id="foverlaps_+3A_verbose">verbose</code></td>
<td>
 <p><code>TRUE</code> turns on status and information messages to the
console. Turn this on by default using <code>options(datatable.verbose=TRUE)</code>.
The quantity and types of verbosity may be expanded in future.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Very briefly, <code>foverlaps()</code> collapses the two-column interval in <code>y</code>
to one-column of <em>unique</em> values to generate a <code>lookup</code> table, and
then performs the join depending on the type of <code>overlap</code>, using the
already available <code>binary search</code> feature of <code>data.table</code>. The time
(and space) required to generate the <code>lookup</code> is therefore proportional
to the number of unique values present in the interval columns of <code>y</code>
when combined together.
</p>
<p>Overlap joins takes advantage of the fact that <code>y</code> is sorted to speed-up
finding overlaps. Therefore <code>y</code> has to be keyed (see <code>?setkey</code>)
prior to running <code>foverlaps()</code>. A key on <code>x</code> is not necessary,
although it <em>might</em> speed things further. The columns in <code>by.x</code>
argument should correspond to the columns specified in <code>by.y</code>. The last
two columns should be the <em>interval</em> columns in both <code>by.x</code> and
<code>by.y</code>. The first interval column in <code>by.x</code> should always be &lt;= the
second interval column in <code>by.x</code>, and likewise for <code>by.y</code>. The
<code><a href="base.html#topic+storage.mode">storage.mode</a></code> of the interval columns must be either <code>double</code>
or <code>integer</code>. It therefore works with <code>bit64::integer64</code> type as well.
</p>
<p>The <code>lookup</code> generation step could be quite time consuming if the number
of unique values in <code>y</code> are too large (ex: in the order of tens of millions).
There might be improvements possible by constructing lookup using RLE, which is
a pending feature request. However most scenarios will not have too many unique
values for <code>y</code>.
</p>


<h3>Value</h3>

<p>A new <code>data.table</code> by joining over the interval columns (along with other
additional identifier columns) specified in <code>by.x</code> and <code>by.y</code>.
</p>
<p>NB: When <code>which=TRUE</code>: <code>a)</code> <code>mult="first" or "last"</code> returns a
<code>vector</code> of matching row numbers in <code>y</code>, and <code>b)</code> when
<code>mult="all"</code> returns a data.table with two columns with the first
containing row numbers of <code>x</code> and the second column with corresponding
row numbers of <code>y</code>.
</p>
<p><code>nomatch=NA|NULL</code> also influences whether non-matching rows are returned
or not, as explained above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>,
<a href="https://www.bioconductor.org/packages/release/bioc/html/IRanges.html">https://www.bioconductor.org/packages/release/bioc/html/IRanges.html</a>,
<code><a href="#topic+setNumericRounding">setNumericRounding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(data.table)
## simple example:
x = data.table(start=c(5,31,22,16), end=c(8,50,25,18), val2 = 7:10)
y = data.table(start=c(10, 20, 30), end=c(15, 35, 45), val1 = 1:3)
setkey(y, start, end)
foverlaps(x, y, type="any", which=TRUE) ## return overlap indices
foverlaps(x, y, type="any") ## return overlap join
foverlaps(x, y, type="any", mult="first") ## returns only first match
foverlaps(x, y, type="within") ## matches iff 'x' is within 'y'

## with extra identifiers (ex: in genomics)
x = data.table(chr=c("Chr1", "Chr1", "Chr2", "Chr2", "Chr2"),
               start=c(5,10, 1, 25, 50), end=c(11,20,4,52,60))
y = data.table(chr=c("Chr1", "Chr1", "Chr2"), start=c(1, 15,1),
               end=c(4, 18, 55), geneid=letters[1:3])
setkey(y, chr, start, end)
foverlaps(x, y, type="any", which=TRUE)
foverlaps(x, y, type="any")
foverlaps(x, y, type="any", nomatch=NULL)
foverlaps(x, y, type="within", which=TRUE)
foverlaps(x, y, type="within")
foverlaps(x, y, type="start")

## x and y have different column names - specify by.x
x = data.table(seq=c("Chr1", "Chr1", "Chr2", "Chr2", "Chr2"),
               start=c(5,10, 1, 25, 50), end=c(11,20,4,52,60))
y = data.table(chr=c("Chr1", "Chr1", "Chr2"), start=c(1, 15,1),
               end=c(4, 18, 55), geneid=letters[1:3])
setkey(y, chr, start, end)
foverlaps(x, y, by.x=c("seq", "start", "end"),
            type="any", which=TRUE)
</code></pre>

<hr>
<h2 id='frank'>Fast rank</h2><span id='topic+frank'></span><span id='topic+frankv'></span><span id='topic+rank'></span>

<h3>Description</h3>

<p>Similar to <code>base::rank</code> but <em>much faster</em>. And it accepts vectors, lists, <code>data.frame</code>s or <code>data.table</code>s as input. In addition to the <code>ties.method</code> possibilities provided by <code>base::rank</code>, it also provides <code>ties.method="dense"</code>.
</p>
<p>Like <code><a href="#topic+forder">forder</a></code>, sorting is done in &quot;C-locale&quot;; in particular, this may affect how capital/lowercase letters are ranked. See Details on <code>forder</code> for more.
</p>
<p><code>bit64::integer64</code> type is also supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frank(x, ..., na.last=TRUE, ties.method=c("average",
  "first", "last", "random", "max", "min", "dense"))

frankv(x, cols=seq_along(x), order=1L, na.last=TRUE,
      ties.method=c("average", "first", "last", "random",
        "max", "min", "dense"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frank_+3A_x">x</code></td>
<td>
<p> A vector, or list with all its elements identical in length or <code>data.frame</code> or <code>data.table</code>. </p>
</td></tr>
<tr><td><code id="frank_+3A_...">...</code></td>
<td>
<p> Only for <code>list</code>s, <code>data.frame</code>s and <code>data.table</code>s. The columns to calculate ranks based on. Do not quote column names. If <code>...</code> is missing, all columns are considered by default. To sort by a column in descending order prefix <code>"-"</code>, e.g., <code>frank(x, a, -b, c)</code>. <code>-b</code> works when <code>b</code> is of type <code>character</code> as well.</p>
</td></tr>
<tr><td><code id="frank_+3A_cols">cols</code></td>
<td>
<p> A <code>character</code> vector of column names (or numbers) of <code>x</code>, for which to obtain ranks. </p>
</td></tr>
<tr><td><code id="frank_+3A_order">order</code></td>
<td>
<p> An <code>integer</code> vector with only possible values of 1 and -1, corresponding to ascending and descending order. The length of <code>order</code> must be either 1 or equal to that of <code>cols</code>. If <code>length(order) == 1</code>, it is recycled to <code>length(cols)</code>. </p>
</td></tr>
<tr><td><code id="frank_+3A_na.last">na.last</code></td>
<td>
<p> Control treatment of <code>NA</code>s. If <code>TRUE</code>, missing values in the data are put last; if <code>FALSE</code>, they are put first; if <code>NA</code>, they are removed; if <code>"keep"</code> they are kept with rank <code>NA</code>. </p>
</td></tr>
<tr><td><code id="frank_+3A_ties.method">ties.method</code></td>
<td>
<p> A character string specifying how ties are treated, see <code>Details</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>To be consistent with other <code>data.table</code> operations, <code>NA</code>s are considered identical to other <code>NA</code>s (and <code>NaN</code>s to other <code>NaN</code>s), unlike <code>base::rank</code>. Therefore, for <code>na.last=TRUE</code> and <code>na.last=FALSE</code>, <code>NA</code>s (and <code>NaN</code>s) are given identical ranks, unlike <code><a href="base.html#topic+rank">rank</a></code>.
</p>
<p><code>frank</code> is not limited to vectors. It accepts <code>data.table</code>s (and <code>list</code>s and <code>data.frame</code>s) as well. It accepts unquoted column names (with names preceded with a <code>-</code> sign for descending order, even on character vectors), for e.g., <code>frank(DT, a, -b, c, ties.method="first")</code> where <code>a,b,c</code> are columns in <code>DT</code>. The equivalent in <code>frankv</code> is the <code>order</code> argument.
</p>
<p>In addition to the <code>ties.method</code> values possible using base's <code><a href="base.html#topic+rank">rank</a></code>, it also provides another additional argument <code>"dense"</code> which returns the ranks without any gaps in the ranking. See examples.
</p>


<h3>Value</h3>

<p>A numeric vector of length equal to <code>NROW(x)</code> (unless <code>na.last = NA</code>, when missing values are removed). The vector is of integer type unless <code>ties.method = "average"</code> when it is of double type (irrespective of ties).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+setkey">setkey</a></code>, <code><a href="#topic+setorder">setorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># on vectors
x = c(4, 1, 4, NA, 1, NA, 4)
# NAs are considered identical (unlike base R)
# default is average
frankv(x) # na.last=TRUE
frankv(x, na.last=FALSE)

# ties.method = min
frankv(x, ties.method="min")
# ties.method = dense
frankv(x, ties.method="dense")

# on data.table
DT = data.table(x, y=c(1, 1, 1, 0, NA, 0, 2))
frankv(DT, cols="x") # same as frankv(x) from before
frankv(DT, cols="x", na.last="keep")
frankv(DT, cols="x", ties.method="dense", na.last=NA)
frank(DT, x, ties.method="dense", na.last=NA) # equivalent of above using frank
# on both columns
frankv(DT, ties.method="first", na.last="keep")
frank(DT, ties.method="first", na.last="keep") # equivalent of above using frank

# order argument
frank(DT, x, -y, ties.method="first")
# equivalent of above using frankv
frankv(DT, order=c(1L, -1L), ties.method="first")
</code></pre>

<hr>
<h2 id='fread'> Fast and friendly file finagler </h2><span id='topic+fread'></span>

<h3>Description</h3>

<p>Similar to <code>read.table</code> but faster and more convenient. All controls such as <code>sep</code>, <code>colClasses</code> and <code>nrows</code> are automatically detected.
</p>
<p><code>bit64::integer64</code>, <code><a href="#topic+IDate">IDate</a></code>, and <code><a href="base.html#topic+POSIXct">POSIXct</a></code> types are also detected and read directly without needing to read as character before converting.
</p>
<p><code>fread</code> is for <em>regular</em> delimited files; i.e., where every row has the same number of columns. In future, secondary separator (<code>sep2</code>) may be specified <em>within</em> each column. Such columns will be read as type <code>list</code> where each cell is itself a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fread(input, file, text, cmd, sep="auto", sep2="auto", dec=".", quote="\"",
nrows=Inf, header="auto",
na.strings=getOption("datatable.na.strings","NA"),  # due to change to ""; see NEWS
stringsAsFactors=FALSE, verbose=getOption("datatable.verbose", FALSE),
skip="__auto__", select=NULL, drop=NULL, colClasses=NULL,
integer64=getOption("datatable.integer64", "integer64"),
col.names,
check.names=FALSE, encoding="unknown",
strip.white=TRUE, fill=FALSE, blank.lines.skip=FALSE,
key=NULL, index=NULL,
showProgress=getOption("datatable.showProgress", interactive()),
data.table=getOption("datatable.fread.datatable", TRUE),
nThread=getDTthreads(verbose),
logical01=getOption("datatable.logical01", FALSE),  # due to change to TRUE; see NEWS
keepLeadingZeros = getOption("datatable.keepLeadingZeros", FALSE),
yaml=FALSE, autostart=NA, tmpdir=tempdir(), tz="UTC"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fread_+3A_input">input</code></td>
<td>
<p> A single character string. The value is inspected and deferred to either <code>file=</code> (if no \n present), <code>text=</code> (if at least one \n is present) or <code>cmd=</code> (if no \n is present, at least one space is present, and it isn't a file name). Exactly one of <code>input=</code>, <code>file=</code>, <code>text=</code>, or <code>cmd=</code> should be used in the same call. </p>
</td></tr>
<tr><td><code id="fread_+3A_file">file</code></td>
<td>
<p> File name in working directory, path to file (passed through <code><a href="base.html#topic+path.expand">path.expand</a></code> for convenience), or a URL starting http://, file://, etc. Compressed files with extension &lsquo;<span class="file">.gz</span>&rsquo; and &lsquo;<span class="file">.bz2</span>&rsquo; are supported if the <code>R.utils</code> package is installed. </p>
</td></tr>
<tr><td><code id="fread_+3A_text">text</code></td>
<td>
<p> The input data itself as a character vector of one or more lines, for example as returned by <code>readLines()</code>. </p>
</td></tr>
<tr><td><code id="fread_+3A_cmd">cmd</code></td>
<td>
<p> A shell command that pre-processes the file; e.g. <code>fread(cmd=paste("grep",word,"filename"))</code>. See Details. </p>
</td></tr>
<tr><td><code id="fread_+3A_sep">sep</code></td>
<td>
<p> The separator between columns. Defaults to the character in the set <code>[,\t |;:]</code> that separates the sample of rows into the most number of lines with the same number of fields. Use <code>NULL</code> or <code>""</code> to specify no separator; i.e. each line a single character column like <code>base::readLines</code> does.</p>
</td></tr>
<tr><td><code id="fread_+3A_sep2">sep2</code></td>
<td>
<p> The separator <em>within</em> columns. A <code>list</code> column will be returned where each cell is a vector of values. This is much faster using less working memory than <code>strsplit</code> afterwards or similar techniques. For each column <code>sep2</code> can be different and is the first character in the same set above [<code>,\t |;</code>], other than <code>sep</code>, that exists inside each field outside quoted regions in the sample. NB: <code>sep2</code> is not yet implemented. </p>
</td></tr>
<tr><td><code id="fread_+3A_nrows">nrows</code></td>
<td>
<p> The maximum number of rows to read. Unlike <code>read.table</code>, you do not need to set this to an estimate of the number of rows in the file for better speed because that is already automatically determined by <code>fread</code> almost instantly using the large sample of lines. <code>nrows=0</code> returns the column names and typed empty columns determined by the large sample; useful for a dry run of a large file or to quickly check format consistency of a set of files before starting to read any of them. </p>
</td></tr>
<tr><td><code id="fread_+3A_header">header</code></td>
<td>
<p> Does the first data line contain column names? Defaults according to whether every non-empty field on the first data line is type character. If so, or TRUE is supplied, any empty column names are given a default name. </p>
</td></tr>
<tr><td><code id="fread_+3A_na.strings">na.strings</code></td>
<td>
<p> A character vector of strings which are to be interpreted as <code>NA</code> values. By default, <code>",,"</code> for columns of all types, including type <code>character</code> is read as <code>NA</code> for consistency. <code>,"",</code> is unambiguous and read as an empty string. To read <code>,NA,</code> as <code>NA</code>, set <code>na.strings="NA"</code>. To read <code>,,</code> as blank string <code>""</code>, set <code>na.strings=NULL</code>. When they occur in the file, the strings in <code>na.strings</code> should not appear quoted since that is how the string literal <code>,"NA",</code> is distinguished from <code>,NA,</code>, for example, when <code>na.strings="NA"</code>. </p>
</td></tr>
<tr><td><code id="fread_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p> Convert all or some character columns to factors? Acceptable inputs are <code>TRUE</code>, <code>FALSE</code>, or a decimal value between 0.0 and 1.0. For <code>stringsAsFactors = FALSE</code>, all string columns are stored as <code>character</code> vs. all stored as <code>factor</code> when <code>TRUE</code>. When <code>stringsAsFactors = p</code> for <code>0 &lt;= p &lt;= 1</code>, string columns <code>col</code> are stored as <code>factor</code> if <code>uniqueN(col)/nrow &lt; p</code>. 
</p>
</td></tr>
<tr><td><code id="fread_+3A_verbose">verbose</code></td>
<td>
<p> Be chatty and report timings? </p>
</td></tr>
<tr><td><code id="fread_+3A_skip">skip</code></td>
<td>
<p> If 0 (default) start on the first line and from there finds the first row with a consistent number of columns. This automatically avoids irregular header information before the column names row. <code>skip&gt;0</code> means ignore the first <code>skip</code> rows manually. <code>skip="string"</code> searches for <code>"string"</code> in the file (e.g. a substring of the column names row) and starts on that line (inspired by read.xls in package gdata). </p>
</td></tr>
<tr><td><code id="fread_+3A_select">select</code></td>
<td>
<p> A vector of column names or numbers to keep, drop the rest. <code>select</code> may specify types too in the same way as <code>colClasses</code>; i.e., a vector of <code>colname=type</code> pairs, or a <code>list</code> of <code>type=col(s)</code> pairs. In all forms of <code>select</code>, the order that the columns are specified determines the order of the columns in the result. </p>
</td></tr>
<tr><td><code id="fread_+3A_drop">drop</code></td>
<td>
<p> Vector of column names or numbers to drop, keep the rest. </p>
</td></tr>
<tr><td><code id="fread_+3A_colclasses">colClasses</code></td>
<td>
<p> As in <code><a href="utils.html#topic+read.table">utils::read.csv</a></code>; i.e., an unnamed vector of types corresponding to the columns in the file, or a named vector specifying types for a subset of the columns by name. The default, <code>NULL</code> means types are inferred from the data in the file. Further, <code>data.table</code> supports a named <code>list</code> of vectors of column names <em>or numbers</em> where the <code>list</code> names are the class names; see examples. The <code>list</code> form makes it easier to set a batch of columns to be a particular class. When column numbers are used in the <code>list</code> form, they refer to the column number in the file not the column number after <code>select</code> or <code>drop</code> has been applied.
If type coercion results in an error, introduces <code>NA</code>s, or would result in loss of accuracy, the coercion attempt is aborted for that column with warning and the column's type is left unchanged. If you really desire data loss (e.g. reading <code>3.14</code> as <code>integer</code>) you have to truncate such columns afterwards yourself explicitly so that this is clear to future readers of your code.
</p>
</td></tr>
<tr><td><code id="fread_+3A_integer64">integer64</code></td>
<td>
<p> &quot;integer64&quot; (default) reads columns detected as containing integers larger than 2^31 as type <code>bit64::integer64</code>. Alternatively, <code>"double"|"numeric"</code> reads as <code>utils::read.csv</code> does; i.e., possibly with loss of precision and if so silently. Or, &quot;character&quot;. </p>
</td></tr>
<tr><td><code id="fread_+3A_dec">dec</code></td>
<td>
<p> The decimal separator as in <code>utils::read.csv</code>. If not &quot;.&quot; (default) then usually &quot;,&quot;. See details. </p>
</td></tr>
<tr><td><code id="fread_+3A_col.names">col.names</code></td>
<td>
<p> A vector of optional names for the variables (columns). The default is to use the header column if present or detected, or if not &quot;V&quot; followed by the column number. This is applied after <code>check.names</code> and before <code>key</code> and <code>index</code>. </p>
</td></tr>
<tr><td><code id="fread_+3A_check.names">check.names</code></td>
<td>
<p>default is <code>FALSE</code>. If <code>TRUE</code> then the names of the variables in the <code>data.table</code> are checked to ensure that they are syntactically valid variable names. If necessary they are adjusted (by <code><a href="base.html#topic+make.names">make.names</a></code>) so that they are, and also to ensure that there are no duplicates.</p>
</td></tr>
<tr><td><code id="fread_+3A_encoding">encoding</code></td>
<td>
<p> default is <code>"unknown"</code>. Other possible options are <code>"UTF-8"</code> and <code>"Latin-1"</code>.  Note: it is not used to re-encode the input, rather enables handling of encoded strings in their native encoding. </p>
</td></tr>
<tr><td><code id="fread_+3A_quote">quote</code></td>
<td>
<p> By default (<code>"\""</code>), if a field starts with a double quote, <code>fread</code> handles embedded quotes robustly as explained under <code>Details</code>. If it fails, then another attempt is made to read the field <em>as is</em>, i.e., as if quotes are disabled. By setting <code>quote=""</code>, the field is always read as if quotes are disabled. It is not expected to ever need to pass anything other than \&quot;\&quot; to quote; i.e., to turn it off. </p>
</td></tr>
<tr><td><code id="fread_+3A_strip.white">strip.white</code></td>
<td>
<p> default is <code>TRUE</code>. Strips leading and trailing whitespaces of unquoted fields. If <code>FALSE</code>, only header trailing spaces are removed. </p>
</td></tr>
<tr><td><code id="fread_+3A_fill">fill</code></td>
<td>
<p>logical (default is <code>FALSE</code>). If <code>TRUE</code> then in case the rows have unequal length, blank fields are implicitly filled.</p>
</td></tr>
<tr><td><code id="fread_+3A_blank.lines.skip">blank.lines.skip</code></td>
<td>
<p><code>logical</code>, default is <code>FALSE</code>. If <code>TRUE</code> blank lines in the input are ignored.</p>
</td></tr>
<tr><td><code id="fread_+3A_key">key</code></td>
<td>
<p>Character vector of one or more column names which is passed to <code><a href="#topic+setkey">setkey</a></code>. It may be a single comma separated string such as <code>key="x,y,z"</code>, or a vector of names such as <code>key=c("x","y","z")</code>. Only valid when argument <code>data.table=TRUE</code>. Where applicable, this should refer to column names given in <code>col.names</code>. </p>
</td></tr>
<tr><td><code id="fread_+3A_index">index</code></td>
<td>
<p> Character vector or list of character vectors of one or more column names which is passed to <code><a href="#topic+setindexv">setindexv</a></code>. As with <code>key</code>, comma-separated notation like <code>index="x,y,z"</code> is accepted for convenience. Only valid when argument <code>data.table=TRUE</code>. Where applicable, this should refer to column names given in <code>col.names</code>. </p>
</td></tr>
<tr><td><code id="fread_+3A_showprogress">showProgress</code></td>
<td>
 <p><code>TRUE</code> displays progress on the console if the ETA is greater than 3 seconds. It is produced in fread's C code where the very nice (but R level) txtProgressBar and tkProgressBar are not easily available. </p>
</td></tr>
<tr><td><code id="fread_+3A_data.table">data.table</code></td>
<td>
<p> TRUE returns a <code>data.table</code>. FALSE returns a <code>data.frame</code>. The default for this argument can be changed with <code>options(datatable.fread.datatable=FALSE)</code>.</p>
</td></tr>
<tr><td><code id="fread_+3A_nthread">nThread</code></td>
<td>
<p>The number of threads to use. Experiment to see what works best for your data on your hardware.</p>
</td></tr>
<tr><td><code id="fread_+3A_logical01">logical01</code></td>
<td>
<p>If TRUE a column containing only 0s and 1s will be read as logical, otherwise as integer.</p>
</td></tr>
<tr><td><code id="fread_+3A_keepleadingzeros">keepLeadingZeros</code></td>
<td>
<p>If TRUE a column containing numeric data with leading zeros will be read as character, otherwise leading zeros will be removed and converted to numeric.</p>
</td></tr>
<tr><td><code id="fread_+3A_yaml">yaml</code></td>
<td>
<p> If <code>TRUE</code>, <code>fread</code> will attempt to parse (using <code><a href="yaml.html#topic+yaml.load">yaml.load</a></code>) the top of the input as YAML, and further to glean parameters relevant to improving the performance of <code>fread</code> on the data itself. The entire YAML section is returned as parsed into a <code>list</code> in the <code>yaml_metadata</code> attribute. See <code>Details</code>. </p>
</td></tr>
<tr><td><code id="fread_+3A_autostart">autostart</code></td>
<td>
<p> Deprecated and ignored with warning. Please use <code>skip</code> instead. </p>
</td></tr>
<tr><td><code id="fread_+3A_tmpdir">tmpdir</code></td>
<td>
<p> Directory to use as the <code>tmpdir</code> argument for any <code>tempfile</code> calls, e.g. when the input is a URL or a shell command. The default is <code>tempdir()</code> which can be controlled by setting <code>TMPDIR</code> before starting the R session; see <code><a href="base.html#topic+tempfile">base::tempdir</a></code>. </p>
</td></tr>
<tr><td><code id="fread_+3A_tz">tz</code></td>
<td>
<p> Relevant to datetime values which have no Z or UTC-offset at the end, i.e. <em>unmarked</em> datetime, as written by <code><a href="utils.html#topic+write.table">utils::write.csv</a></code>. The default <code>tz="UTC"</code> reads unmarked datetime as UTC POSIXct efficiently. <code>tz=""</code> reads unmarked datetime as type character (slowly) so that <code>as.POSIXct</code> can interpret (slowly) the character datetimes in local timezone; e.g. by using <code>"POSIXct"</code> in <code>colClasses=</code>. Note that <code>fwrite()</code> by default writes datetime in UTC including the final Z and therefore <code>fwrite</code>'s output will be read by <code>fread</code> consistently and quickly without needing to use <code>tz=</code> or <code>colClasses=</code>. If the <code>TZ</code> environment variable is set to <code>"UTC"</code> (or <code>""</code> on non-Windows where unset vs &lsquo;&quot;&quot;' is significant) then the R session&rsquo;s timezone is already UTC and <code>tz=""</code> will result in unmarked datetimes being read as UTC POSIXct. For more information, please see the news items from v1.13.0 and v1.14.0. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sample of 10,000 rows is used for a very good estimate of column types. 100 contiguous rows are read from 100 equally spaced points throughout the file including the beginning, middle and the very end. This results in a better guess when a column changes type later in the file (e.g. blank at the beginning/only populated near the end, or 001 at the start but 0A0 later on). This very good type guess enables a single allocation of the correct type up front once for speed, memory efficiency and convenience of avoiding the need to set <code>colClasses</code> after an error. Even though the sample is large and jumping over the file, it is almost instant regardless of the size of the file because a lazy on-demand memory map is used. If a jump lands inside a quoted field containing newlines, each newline is tested until 5 lines are found following it with the expected number of fields. The lowest type for each column is chosen from the ordered list: <code>logical</code>, <code>integer</code>, <code>integer64</code>, <code>double</code>, <code>character</code>. Rarely, the file may contain data of a higher type in rows outside the sample (referred to as an out-of-sample type exception). In this event <code>fread</code> will <em>automatically</em> reread just those columns from the beginning so that you don't have the inconvenience of having to set <code>colClasses</code> yourself; particularly helpful if you have a lot of columns. Such columns must be read from the beginning to correctly distinguish &quot;00&quot; from &quot;000&quot; when those have both been interpreted as integer 0 due to the sample but 00A occurs out of sample. Set <code>verbose=TRUE</code> to see a detailed report of the logic deployed to read your file.
</p>
<p>There is no line length limit, not even a very large one. Since we are encouraging <code>list</code> columns (i.e. <code>sep2</code>) this has the potential to encourage longer line lengths. So the approach of scanning each line into a buffer first and then rescanning that buffer is not used. There are no buffers used in <code>fread</code>'s C code at all. The field width limit is limited by R itself: the maximum width of a character string (currently 2^31-1 bytes, 2GB).
</p>
<p>The filename extension (such as .csv) is irrelevant for &quot;auto&quot; <code>sep</code> and <code>sep2</code>. Separator detection is entirely driven by the file contents. This can be useful when loading a set of different files which may not be named consistently, or may not have the extension .csv despite being csv. Some datasets have been collected over many years, one file per day for example. Sometimes the file name format has changed at some point in the past or even the format of the file itself. So the idea is that you can loop <code>fread</code> through a set of files and as long as each file is regular and delimited, <code>fread</code> can read them all. Whether they all stack is another matter but at least each one is read quickly without you needing to vary <code>colClasses</code> in <code>read.table</code> or <code>read.csv</code>.
</p>
<p>If an empty line is encountered then reading stops there with warning if any text exists after the empty line such as a footer. The first line of any text discarded is included in the warning message. Unless, it is single-column input. In that case blank lines are significant (even at the very end) and represent NA in the single column. So that <code>fread(fwrite(DT))==DT</code>. This default behaviour can be controlled using <code>blank.lines.skip=TRUE|FALSE</code>.
</p>
<p><b>Line endings:</b> All known line endings are detected automatically: <code>\n</code> (*NIX including Mac), <code>\r\n</code> (Windows CRLF), <code>\r</code> (old Mac) and <code>\n\r</code> (just in case). There is no need to convert input files first. <code>fread</code> running on any architecture will read a file from any architecture. Both <code>\r</code> and <code>\n</code> may be embedded in character strings (including column names) provided the field is quoted.
</p>
<p><b>Decimal separator and locale:</b> <code>fread(...,dec=",")</code> should just work. <code>fread</code> uses C function <code>strtod</code> to read numeric data; e.g., <code>1.23</code> or <code>1,23</code>. <code>strtod</code> retrieves the decimal separator (<code>.</code> or <code>,</code> usually) from the locale of the R session rather than as an argument passed to the <code>strtod</code> function. So for <code>fread(...,dec=",")</code> to work, <code>fread</code> changes this (and only this) R session's locale temporarily to a locale which provides the desired decimal separator.
</p>
<p>On Windows, &quot;French_France.1252&quot; is tried which should be available as standard (any locale with comma decimal separator would suffice) and on unix &quot;fr_FR.utf8&quot; (you may need to install this locale on unix). <code>fread()</code> is very careful to set the locale back again afterwards, even if the function fails with an error. The choice of locale is determined by <code>options()$datatable.fread.dec.locale</code>. This may be a <em>vector</em> of locale names and if so they will be tried in turn until the desired <code>dec</code> is obtained; thus allowing more than two different decimal separators to be selected. This is a new feature in v1.9.6 and is experimental. In case of problems, turn it off with <code>options(datatable.fread.dec.experiment=FALSE)</code>.
</p>
<p><b>Quotes:</b>
</p>
<p>When <code>quote</code> is a single character,
</p>

<ul>
<li><p> Spaces and other whitespace (other than <code>sep</code> and <code>\n</code>) may appear in unquoted character fields, e.g., <code>...,2,Joe Bloggs,3.14,...</code>.
</p>
</li>
<li><p> When <code>character</code> columns are <em>quoted</em>, they must start and end with that quoting character immediately followed by <code>sep</code> or <code>\n</code>, e.g., <code>...,2,"Joe Bloggs",3.14,...</code>.
</p>
<p>In essence quoting character fields are <em>required</em> only if <code>sep</code> or <code>\n</code> appears in the string value. Quoting may be used to signify that numeric data should be read as text. Unescaped quotes may be present in a quoted field, e.g., <code>...,2,"Joe, "Bloggs"",3.14,...</code>, as well as escaped quotes, e.g., <code>...,2,"Joe \",Bloggs\"",3.14,...</code>.
</p>
<p>If an embedded quote is followed by the separator inside a quoted field, the embedded quotes up to that point in that field must be balanced; e.g. <code>...,2,"www.blah?x="one",y="two"",3.14,...</code>.
</p>
<p>On those fields that do not satisfy these conditions, e.g., fields with unbalanced quotes, <code>fread</code> re-attempts that field as if it isn't quoted. This is quite useful in reading files that contains fields with unbalanced quotes as well, automatically.
</p>
</li></ul>

<p>To read fields <em>as is</em> instead, use <code>quote = ""</code>.
</p>
<p><b>CSVY Support:</b>
</p>
<p>Currently, the <code>yaml</code> setting is somewhat inflexible with respect to incorporating metadata to facilitate file reading. Information on column classes should be stored at the top level under the heading <code>schema</code> and subheading <code>fields</code>; those with both a <code>type</code> and a <code>name</code> sub-heading will be merged into <code>colClasses</code>. Other supported elements are as follows:
</p>

<ul>
<li> <p><code>sep</code> (or alias <code>delimiter</code>) 
</p>
</li>
<li> <p><code>header</code> 
</p>
</li>
<li> <p><code>quote</code> (or aliases <code>quoteChar</code>, <code>quote_char</code>) 
</p>
</li>
<li> <p><code>dec</code> (or alias <code>decimal</code>) 
</p>
</li>
<li> <p><code>na.strings</code> 
</p>
</li></ul>

<p><b>File Download:</b>
</p>
<p>When <code>input</code> begins with http://, https://, ftp://, ftps://, or file://, <code>fread</code> detects this and <em>downloads</em> the target to a temporary file (at <code>tempfile()</code>) before proceeding to read the file as usual. URLS (ftps:// and https:// as well as ftp:// and http://) paths are downloaded with <code>download.file</code> and <code>method</code> set to <code>getOption("download.file.method")</code>, defaulting to <code>"auto"</code>; and file:// is downloaded with <code>download.file</code> with <code>method="internal"</code>. NB: this implies that for file://, even files found on the current machine will be &quot;downloaded&quot; (i.e., hard-copied) to a temporary file. See <code><a href="utils.html#topic+download.file">download.file</a></code> for more details.
</p>
<p><b>Shell commands:</b>
</p>
<p><code>fread</code> accepts shell commands for convenience. The input command is run and its output written to a file in <code>tmpdir</code> (<code><a href="base.html#topic+tempdir">tempdir</a>()</code> by default) to which <code>fread</code> is applied &quot;as normal&quot;. The details are platform dependent &ndash; <code>system</code> is used on UNIX environments, <code>shell</code> otherwise; see <code><a href="base.html#topic+system">system</a></code>.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> by default, otherwise a <code>data.frame</code> when argument <code>data.table=FALSE</code>.
</p>


<h3>References</h3>

<p>Background :<br />
<a href="https://cran.r-project.org/doc/manuals/R-data.html">https://cran.r-project.org/doc/manuals/R-data.html</a><br />
<a href="https://stackoverflow.com/questions/1727772/quickly-reading-very-large-tables-as-dataframes-in-r">https://stackoverflow.com/questions/1727772/quickly-reading-very-large-tables-as-dataframes-in-r</a><br />
<a href="https://cerebralmastication.com/2009/11/loading-big-data-into-r/">https://cerebralmastication.com/2009/11/loading-big-data-into-r/</a><br />
<a href="https://stackoverflow.com/questions/9061736/faster-than-scan-with-rcpp">https://stackoverflow.com/questions/9061736/faster-than-scan-with-rcpp</a><br />
<a href="https://stackoverflow.com/questions/415515/how-can-i-read-and-manipulate-csv-file-data-in-c">https://stackoverflow.com/questions/415515/how-can-i-read-and-manipulate-csv-file-data-in-c</a><br />
<a href="https://stackoverflow.com/questions/9352887/strategies-for-reading-in-csv-files-in-pieces">https://stackoverflow.com/questions/9352887/strategies-for-reading-in-csv-files-in-pieces</a><br />
<a href="https://stackoverflow.com/questions/11782084/reading-in-large-text-files-in-r">https://stackoverflow.com/questions/11782084/reading-in-large-text-files-in-r</a><br />
<a href="https://stackoverflow.com/questions/45972/mmap-vs-reading-blocks">https://stackoverflow.com/questions/45972/mmap-vs-reading-blocks</a><br />
<a href="https://stackoverflow.com/questions/258091/when-should-i-use-mmap-for-file-access">https://stackoverflow.com/questions/258091/when-should-i-use-mmap-for-file-access</a><br />
<a href="https://stackoverflow.com/a/9818473/403310">https://stackoverflow.com/a/9818473/403310</a><br />
<a href="https://stackoverflow.com/questions/9608950/reading-huge-files-using-memory-mapped-files">https://stackoverflow.com/questions/9608950/reading-huge-files-using-memory-mapped-files</a>
</p>
<p>finagler = &quot;to get or achieve by guile or manipulation&quot; <a href="https://dictionary.reference.com/browse/finagler">https://dictionary.reference.com/browse/finagler</a>
</p>
<p>On YAML, see <a href="https://yaml.org/">https://yaml.org/</a>; on csvy, see <a href="https://github.com/csvy">https://github.com/csvy</a>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.csv</a></code>, <code><a href="base.html#topic+connections">url</a></code>, <code><a href="base.html#topic+locales">Sys.setlocale</a></code>, <code><a href="#topic+setDTthreads">setDTthreads</a></code>, <code><a href="#topic+fwrite">fwrite</a></code>, <a href="https://CRAN.R-project.org/package=bit64"><code>bit64::integer64</code></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reads text input directly :
fread("A,B\n1,2\n3,4")

# Reads pasted input directly :
fread("A,B
1,2
3,4
")

# Finds the first data line automatically :
fread("
This is perhaps a banner line or two or ten.
A,B
1,2
3,4
")

# Detects whether column names are present automatically :
fread("
1,2
3,4
")

# Numerical precision :

DT = fread("A\n1.010203040506070809010203040506\n")
# TODO: add numerals=c("allow.loss", "warn.loss", "no.loss") from base::read.table, +"use.Rmpfr"
typeof(DT$A)=="double"   # currently "allow.loss" with no option

DT = fread("A\n1.46761e-313\n")   # read as 'numeric'
DT[,sprintf("%.15E",A)]   # beyond what double precision can store accurately to 15 digits
# For greater accuracy use colClasses to read as character, then package Rmpfr.

# colClasses
data = "A,B,C,D\n1,3,5,7\n2,4,6,8\n"
fread(data, colClasses=c(B="character",C="character",D="character"))  # as read.csv
fread(data, colClasses=list(character=c("B","C","D")))    # saves typing
fread(data, colClasses=list(character=2:4))     # same using column numbers

# drop
fread(data, colClasses=c("B"="NULL","C"="NULL"))   # as read.csv
fread(data, colClasses=list(NULL=c("B","C")))      #
fread(data, drop=c("B","C"))      # same but less typing, easier to read
fread(data, drop=2:3)             # same using column numbers

# select
# (in read.csv you need to work out which to drop)
fread(data, select=c("A","D"))    # less typing, easier to read
fread(data, select=c(1,4))        # same using column numbers

# select and types combined
fread(data, select=c(A="numeric", D="character"))
fread(data, select=list(numeric="A", character="D"))

# skip blank lines
fread("a,b\n1,a\n2,b\n\n\n3,c\n", blank.lines.skip=TRUE)
# fill
fread("a,b\n1,a\n2\n3,c\n", fill=TRUE)
fread("a,b\n\n1,a\n2\n\n3,c\n\n", fill=TRUE)

# fill with skip blank lines
fread("a,b\n\n1,a\n2\n\n3,c\n\n", fill=TRUE, blank.lines.skip=TRUE)

# check.names usage
fread("a b,a b\n1,2\n")
fread("a b,a b\n1,2\n", check.names=TRUE) # no duplicates + syntactically valid names

## Not run: 
# Demo speed-up
n = 1e6
DT = data.table( a=sample(1:1000,n,replace=TRUE),
                 b=sample(1:1000,n,replace=TRUE),
                 c=rnorm(n),
                 d=sample(c("foo","bar","baz","qux","quux"),n,replace=TRUE),
                 e=rnorm(n),
                 f=sample(1:1000,n,replace=TRUE) )
DT[2,b:=NA_integer_]
DT[4,c:=NA_real_]
DT[3,d:=NA_character_]
DT[5,d:=""]
DT[2,e:=+Inf]
DT[3,e:=-Inf]

write.table(DT,"test.csv",sep=",",row.names=FALSE,quote=FALSE)
cat("File size (MB):", round(file.info("test.csv")$size/1024^2),"\n")
# 50 MB (1e6 rows x 6 columns)

system.time(DF1 &lt;-read.csv("test.csv",stringsAsFactors=FALSE))
# 5.4 sec (first time in fresh R session)

system.time(DF1 &lt;- read.csv("test.csv",stringsAsFactors=FALSE))
# 3.9 sec (immediate repeat is faster, varies)

system.time(DF2 &lt;- read.table("test.csv",header=TRUE,sep=",",quote="",
    stringsAsFactors=FALSE,comment.char="",nrows=n,
    colClasses=c("integer","integer","numeric",
                 "character","numeric","integer")))
# 1.2 sec (consistently). All known tricks and known nrows, see references.

system.time(DT &lt;- fread("test.csv"))
# 0.1 sec (faster and friendlier)

identical(DF1, DF2)
all.equal(as.data.table(DF1), DT)

# Scaling up ...
l = vector("list",10)
for (i in 1:10) l[[i]] = DT
DTbig = rbindlist(l)
tables()
write.table(DTbig,"testbig.csv",sep=",",row.names=FALSE,quote=FALSE)
# 500MB csv (10 million rows x 6 columns)

system.time(DF &lt;- read.table("testbig.csv",header=TRUE,sep=",",
    quote="",stringsAsFactors=FALSE,comment.char="",nrows=1e7,
    colClasses=c("integer","integer","numeric",
                 "character","numeric","integer")))
# 17.0 sec (varies)

system.time(DT &lt;- fread("testbig.csv"))
#  0.8 sec

all(mapply(all.equal, DF, DT))

# Reads URLs directly :
fread("https://www.stats.ox.ac.uk/pub/datasets/csb/ch11b.dat")

# Decompresses .gz and .bz2 automatically :
fread("https://github.com/Rdatatable/data.table/raw/1.14.0/inst/tests/ch11b.dat.bz2")

fread("https://github.com/Rdatatable/data.table/raw/1.14.0/inst/tests/issue_785_fread.txt.gz")


## End(Not run)
</code></pre>

<hr>
<h2 id='fsort'>Fast parallel sort</h2><span id='topic+fsort'></span>

<h3>Description</h3>

<p>Similar to <code>base::sort</code> but fast using parallelism. Experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsort(x, decreasing = FALSE, na.last = FALSE, internal=FALSE, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsort_+3A_x">x</code></td>
<td>
<p> A vector. Type double, currently. </p>
</td></tr>
<tr><td><code id="fsort_+3A_decreasing">decreasing</code></td>
<td>
<p> Decreasing order? </p>
</td></tr>
<tr><td><code id="fsort_+3A_na.last">na.last</code></td>
<td>
<p> Control treatment of <code>NA</code>s. If <code>TRUE</code>, missing values in the data are put last; if <code>FALSE</code>, they are put first; if <code>NA</code>, they are removed; if <code>"keep"</code> they are kept with rank <code>NA</code>. </p>
</td></tr>
<tr><td><code id="fsort_+3A_internal">internal</code></td>
<td>
<p> Internal use only. Temporary variable. Will be removed. </p>
</td></tr>
<tr><td><code id="fsort_+3A_verbose">verbose</code></td>
<td>
<p> Print tracing information. </p>
</td></tr>
<tr><td><code id="fsort_+3A_...">...</code></td>
<td>
<p> Not sure yet. Should be consistent with base R.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Process will raise error if <code>x</code> contains negative values.
Unless <code>x</code> is already sorted <code>fsort</code> will redirect processing to slower single threaded <em>order</em> followed by <em>subset</em> in following cases:
</p>

<ul>
<li><p> data type other than <em>double</em> (<em>numeric</em>)
</p>
</li>
<li><p> data having <code>NA</code>s
</p>
</li>
<li> <p><code>decreasing==FALSE</code>
</p>
</li></ul>



<h3>Value</h3>

<p>The input in sorted order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = runif(1e6)
system.time(ans1 &lt;- sort(x, method="quick"))
system.time(ans2 &lt;- fsort(x))
identical(ans1, ans2)
</code></pre>

<hr>
<h2 id='fwrite'>Fast CSV writer</h2><span id='topic+fwrite'></span>

<h3>Description</h3>

<p>As <code>write.csv</code> but much faster (e.g. 2 seconds versus 1 minute) and just as flexible. Modern machines almost surely have more than one CPU so <code>fwrite</code> uses them; on all operating systems including Linux, Mac and Windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwrite(x, file = "", append = FALSE, quote = "auto",
  sep=getOption("datatable.fwrite.sep", ","),
  sep2 = c("","|",""),
  eol = if (.Platform$OS.type=="windows") "\r\n" else "\n",
  na = "", dec = ".", row.names = FALSE, col.names = TRUE,
  qmethod = c("double","escape"),
  logical01 = getOption("datatable.logical01", FALSE),  # due to change to TRUE; see NEWS
  logicalAsInt = logical01,  # deprecated
  scipen = getOption('scipen', 0L),
  dateTimeAs = c("ISO","squash","epoch","write.csv"),
  buffMB = 8L, nThread = getDTthreads(verbose),
  showProgress = getOption("datatable.showProgress", interactive()),
  compress = c("auto", "none", "gzip"),
  yaml = FALSE,
  bom = FALSE,
  verbose = getOption("datatable.verbose", FALSE),
  encoding = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fwrite_+3A_x">x</code></td>
<td>
<p>Any <code>list</code> of same length vectors; e.g. <code>data.frame</code> and <code>data.table</code>. If <code>matrix</code>, it gets internally coerced to <code>data.table</code> preserving col names but not row names</p>
</td></tr>
<tr><td><code id="fwrite_+3A_file">file</code></td>
<td>
<p>Output file name. <code>""</code> indicates output to the console. </p>
</td></tr>
<tr><td><code id="fwrite_+3A_append">append</code></td>
<td>
<p>If <code>TRUE</code>, the file is opened in append mode and column names (header row) are not written.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_quote">quote</code></td>
<td>
<p>When <code>"auto"</code>, character fields, factor fields and column names will only be surrounded by double quotes when they need to be; i.e., when the field contains the separator <code>sep</code>, a line ending <code>\n</code>, the double quote itself or (when <code>list</code> columns are present) <code>sep2[2]</code> (see <code>sep2</code> below). If <code>FALSE</code> the fields are not wrapped with quotes even if this would break the CSV due to the contents of the field. If <code>TRUE</code> double quotes are always included other than around numeric fields, as <code>write.csv</code>.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_sep">sep</code></td>
<td>
<p>The separator between columns. Default is <code>","</code>.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_sep2">sep2</code></td>
<td>
<p>For columns of type <code>list</code> where each item is an atomic vector, <code>sep2</code> controls how to separate items <em>within</em> the column. <code>sep2[1]</code> is written at the start of the output field, <code>sep2[2]</code> is placed between each item and <code>sep2[3]</code> is written at the end. <code>sep2[1]</code> and <code>sep2[3]</code> may be any length strings including empty <code>""</code> (default). <code>sep2[2]</code> must be a single character and (when <code>list</code> columns are present and therefore <code>sep2</code> is used) different from both <code>sep</code> and <code>dec</code>. The default (<code>|</code>) is chosen to visually distinguish from the default <code>sep</code>. In speaking, writing and in code comments we may refer to <code>sep2[2]</code> as simply &quot;sep2&quot;.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_eol">eol</code></td>
<td>
<p>Line separator. Default is <code>"\r\n"</code> for Windows and <code>"\n"</code> otherwise.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_na">na</code></td>
<td>
<p>The string to use for missing values in the data. Default is a blank string <code>""</code>.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_dec">dec</code></td>
<td>
<p>The decimal separator, by default <code>"."</code>. See link in references. Cannot be the same as <code>sep</code>.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_row.names">row.names</code></td>
<td>
<p>Should row names be written? For compatibility with <code>data.frame</code> and <code>write.csv</code> since <code>data.table</code> never has row names. Hence default <code>FALSE</code> unlike <code>write.csv</code>.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_col.names">col.names</code></td>
<td>
<p>Should the column names (header row) be written? The default is <code>TRUE</code> for new files and when overwriting existing files (<code>append=FALSE</code>). Otherwise, the default is <code>FALSE</code> to prevent column names appearing again mid-file when stacking a set of <code>data.table</code>s or appending rows to the end of a file.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_qmethod">qmethod</code></td>
<td>
<p>A character string specifying how to deal with embedded double quote characters when quoting strings.
</p>

<ul>
<li><p> &quot;escape&quot; - the quote character (as well as the backslash character) is escaped in C style by a backslash, or
</p>
</li>
<li><p> &quot;double&quot; (default, same as <code>write.csv</code>), in which case the double quote is doubled with another one.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fwrite_+3A_logical01">logical01</code></td>
<td>
<p>Should <code>logical</code> values be written as <code>1</code> and <code>0</code> rather than <code>"TRUE"</code> and <code>"FALSE"</code>?</p>
</td></tr>
<tr><td><code id="fwrite_+3A_logicalasint">logicalAsInt</code></td>
<td>
<p>Deprecated. Old name for 'logical01'. Name change for consistency with 'fread' for which 'logicalAsInt' would not make sense.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_scipen">scipen</code></td>
<td>
 <p><code>integer</code> In terms of printing width, how much of a bias should there be towards printing whole numbers rather than scientific notation? See Details. </p>
</td></tr>
<tr><td><code id="fwrite_+3A_datetimeas">dateTimeAs</code></td>
<td>
<p> How <code>Date</code>/<code>IDate</code>, <code>ITime</code> and <code>POSIXct</code> items are written.
</p>

<ul>
<li><p> &quot;ISO&quot; (default) - <code>2016-09-12</code>, <code>18:12:16</code> and <code>2016-09-12T18:12:16.999999Z</code>. 0, 3 or 6 digits of fractional seconds are printed if and when present for convenience, regardless of any R options such as <code>digits.secs</code>. The idea being that if milli and microseconds are present then you most likely want to retain them. R's internal UTC representation is written faithfully to encourage ISO standards, stymie timezone ambiguity and for speed. An option to consider is to start R in the UTC timezone simply with <code>"$ TZ='UTC' R"</code> at the shell (NB: it must be one or more spaces between <code>TZ='UTC'</code> and <code>R</code>, anything else will be silently ignored; this TZ setting applies just to that R process) or <code>Sys.setenv(TZ='UTC')</code> at the R prompt and then continue as if UTC were local time.
</p>
</li>
<li><p> &quot;squash&quot; - <code>20160912</code>, <code>181216</code> and <code>20160912181216999</code>. This option allows fast and simple extraction of <code>yyyy</code>, <code>mm</code>, <code>dd</code> and (most commonly to group by) <code>yyyymm</code> parts using integer div and mod operations. In R for example, one line helper functions could use <code>%/%10000</code>, <code>%/%100%%100</code>, <code>%%100</code> and <code>%/%100</code> respectively. POSIXct UTC is squashed to 17 digits (including 3 digits of milliseconds always, even if <code>000</code>) which may be read comfortably as <code>integer64</code> (automatically by <code>fread()</code>).
</p>
</li>
<li><p> &quot;epoch&quot; - <code>17056</code>, <code>65536</code> and <code>1473703936.999999</code>. The underlying number of days or seconds since the relevant epoch (1970-01-01, 00:00:00 and 1970-01-01T00:00:00Z respectively), negative before that (see <code>?Date</code>). 0, 3 or 6 digits of fractional seconds are printed if and when present.
</p>
</li>
<li><p> &quot;write.csv&quot; - this currently affects <code>POSIXct</code> only. It is written as <code>write.csv</code> does by using the <code>as.character</code> method which heeds <code>digits.secs</code> and converts from R's internal UTC representation back to local time (or the <code>"tzone"</code> attribute) as of that historical date. Accordingly this can be slow. All other column types (including <code>Date</code>, <code>IDate</code> and <code>ITime</code> which are independent of timezone) are written as the &quot;ISO&quot; option using fast C code which is already consistent with <code>write.csv</code>.
</p>
</li></ul>

<p>The first three options are fast due to new specialized C code. The epoch to date-part conversion uses a fast approach by Howard Hinnant (see references) using a day-of-year starting on 1 March. You should not be able to notice any difference in write speed between those three options. The date range supported for <code>Date</code> and <code>IDate</code> is [0000-03-01, 9999-12-31]. Every one of these 3,652,365 dates have been tested and compared to base R including all 2,790 leap days in this range. <br /> <br />
This option applies to vectors of date/time in list column cells, too. <br /> <br />
A fully flexible format string (such as <code>"%m/%d/%Y"</code>) is not supported. This is to encourage use of ISO standards and because that flexibility is not known how to make fast at C level. We may be able to support one or two more specific options if required.
</p>
</td></tr>
<tr><td><code id="fwrite_+3A_buffmb">buffMB</code></td>
<td>
<p>The buffer size (MB) per thread in the range 1 to 1024, default 8MB. Experiment to see what works best for your data on your hardware.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_nthread">nThread</code></td>
<td>
<p>The number of threads to use. Experiment to see what works best for your data on your hardware.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_showprogress">showProgress</code></td>
<td>
<p> Display a progress meter on the console? Ignored when <code>file==""</code>. </p>
</td></tr>
<tr><td><code id="fwrite_+3A_compress">compress</code></td>
<td>
<p>If <code>compress = "auto"</code> and if <code>file</code> ends in <code>.gz</code> then output format is gzipped csv else csv. If <code>compress = "none"</code>, output format is always csv. If <code>compress = "gzip"</code> then format is gzipped csv. Output to the console is never gzipped even if <code>compress = "gzip"</code>. By default, <code>compress = "auto"</code>.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_yaml">yaml</code></td>
<td>
<p>If <code>TRUE</code>, <code>fwrite</code> will output a CSVY file, that is, a CSV file with metadata stored as a YAML header, using <code><a href="yaml.html#topic+as.yaml">as.yaml</a></code>. See <code>Details</code>. </p>
</td></tr>
<tr><td><code id="fwrite_+3A_bom">bom</code></td>
<td>
<p>If <code>TRUE</code> a BOM (Byte Order Mark) sequence (EF BB BF) is added at the beginning of the file; format 'UTF-8 with BOM'.</p>
</td></tr>
<tr><td><code id="fwrite_+3A_verbose">verbose</code></td>
<td>
<p>Be chatty and report timings?</p>
</td></tr>
<tr><td><code id="fwrite_+3A_encoding">encoding</code></td>
<td>
<p> The encoding of the strings written to the CSV file. Default is <code>""</code>, which means writting raw bytes without considering the encoding. Other possible options are <code>"UTF-8"</code> and <code>"native"</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fwrite</code> began as a community contribution with <a href="https://github.com/Rdatatable/data.table/pull/1613">pull request #1613</a> by Otto Seiskari. This gave Matt Dowle the impetus to specialize the numeric formatting and to parallelize: <a href="https://h2o.ai/blog/2016/fast-csv-writing-for-r/">https://h2o.ai/blog/2016/fast-csv-writing-for-r/</a>. Final items were tracked in <a href="https://github.com/Rdatatable/data.table/issues/1664">issue #1664</a> such as automatic quoting, <code>bit64::integer64</code> support, decimal/scientific formatting exactly matching <code>write.csv</code> between 2.225074e-308 and 1.797693e+308 to 15 significant figures, <code>row.names</code>, dates (between 0000-03-01 and 9999-12-31), times and <code>sep2</code> for <code>list</code> columns where each cell can itself be a vector.
</p>
<p>To save space, <code>fwrite</code> prefers to write wide numeric values in scientific notation &ndash; e.g. <code>10000000000</code> takes up much more space than <code>1e+10</code>. Most file readers (e.g. <code><a href="#topic+fread">fread</a></code>) understand scientific notation, so there's no fidelity loss. Like in base R, users can control this by specifying the <code>scipen</code> argument, which follows the same rules as <code><a href="base.html#topic+options">options</a>('scipen')</code>. <code>fwrite</code> will see how much space a value will take to write in scientific vs. decimal notation, and will only write in scientific notation if the latter is more than <code>scipen</code> characters wider. For <code>10000000000</code>, then, <code>1e+10</code> will be written whenever <code>scipen&lt;6</code>.
</p>
<p><b>CSVY Support:</b>
</p>
<p>The following fields will be written to the header of the file and surrounded by <code>---</code> on top and bottom:
</p>

<ul>
<li> <p><code>source</code> - Contains the R version and <code>data.table</code> version used to write the file
</p>
</li>
<li> <p><code>creation_time_utc</code> - Current timestamp in UTC time just before the header is written
</p>
</li>
<li> <p><code>schema</code> with element <code>fields</code> giving <code>name</code>-<code>type</code> (<code>class</code>) pairs for the table; multi-class objects (e.g. <code>c('POSIXct', 'POSIXt')</code>) will have their first class written.
</p>
</li>
<li> <p><code>header</code> - same as <code>col.names</code> (which is <code>header</code> on input)
</p>
</li>
<li> <p><code>sep</code>
</p>
</li>
<li> <p><code>sep2</code>
</p>
</li>
<li> <p><code>eol</code>
</p>
</li>
<li> <p><code>na.strings</code> - same as <code>na</code>
</p>
</li>
<li> <p><code>dec</code>
</p>
</li>
<li> <p><code>qmethod</code>
</p>
</li>
<li> <p><code>logical01</code>
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://howardhinnant.github.io/date_algorithms.html">https://howardhinnant.github.io/date_algorithms.html</a><br />
<a href="https://en.wikipedia.org/wiki/Decimal_mark">https://en.wikipedia.org/wiki/Decimal_mark</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setDTthreads">setDTthreads</a></code>, <code><a href="#topic+fread">fread</a></code>, <code><a href="utils.html#topic+write.table">write.csv</a></code>, <code><a href="utils.html#topic+write.table">write.table</a></code>, <a href="https://CRAN.R-project.org/package=bit64"><code>bit64::integer64</code></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
DF = data.frame(A=1:3, B=c("foo","A,Name","baz"))
fwrite(DF)
write.csv(DF, row.names=FALSE, quote=FALSE)  # same

fwrite(DF, row.names=TRUE, quote=TRUE)
write.csv(DF)                                # same

DF = data.frame(A=c(2.1,-1.234e-307,pi), B=c("foo","A,Name","bar"))
fwrite(DF, quote='auto')        # Just DF[2,2] is auto quoted
write.csv(DF, row.names=FALSE)  # same numeric formatting

DT = data.table(A=c(2,5.6,-3),B=list(1:3,c("foo","A,Name","bar"),round(pi*1:3,2)))
fwrite(DT)
fwrite(DT, sep="|", sep2=c("{",",","}"))

## Not run: 

set.seed(1)
DT = as.data.table( lapply(1:10, sample,
         x=as.numeric(1:5e7), size=5e6))                            #     382MB
system.time(fwrite(DT, "/dev/shm/tmp1.csv"))                        #      0.8s
system.time(write.csv(DT, "/dev/shm/tmp2.csv",                      #     60.6s
                      quote=FALSE, row.names=FALSE))
system("diff /dev/shm/tmp1.csv /dev/shm/tmp2.csv")                  # identical

set.seed(1)
N = 1e7
DT = data.table(
  str1=sample(sprintf("%010d",sample(N,1e5,replace=TRUE)), N, replace=TRUE),
  str2=sample(sprintf("%09d",sample(N,1e5,replace=TRUE)), N, replace=TRUE),
  str3=sample(sapply(sample(2:30, 100, TRUE), function(n)
     paste0(sample(LETTERS, n, TRUE), collapse="")), N, TRUE),
  str4=sprintf("%05d",sample(sample(1e5,50),N,TRUE)),
  num1=sample(round(rnorm(1e6,mean=6.5,sd=15),2), N, replace=TRUE),
  num2=sample(round(rnorm(1e6,mean=6.5,sd=15),10), N, replace=TRUE),
  str5=sample(c("Y","N"),N,TRUE),
  str6=sample(c("M","F"),N,TRUE),
  int1=sample(ceiling(rexp(1e6)), N, replace=TRUE),
  int2=sample(N,N,replace=TRUE)-N/2
)                                                                   #     774MB
system.time(fwrite(DT,"/dev/shm/tmp1.csv"))                         #      1.1s
system.time(write.csv(DT,"/dev/shm/tmp2.csv",                       #     63.2s
                      row.names=FALSE, quote=FALSE))
system("diff /dev/shm/tmp1.csv /dev/shm/tmp2.csv")                  # identical

unlink("/dev/shm/tmp1.csv")
unlink("/dev/shm/tmp2.csv")

## End(Not run)

</code></pre>

<hr>
<h2 id='groupingsets'> Grouping Set aggregation for data tables </h2><span id='topic+rollup'></span><span id='topic+cube'></span><span id='topic+groupingsets'></span><span id='topic+rollup.data.table'></span><span id='topic+cube.data.table'></span><span id='topic+groupingsets.data.table'></span>

<h3>Description</h3>

<p>Calculate aggregates at various levels of groupings producing multiple (sub-)totals. Reflects SQLs <em>GROUPING SETS</em> operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollup(x, ...)
## S3 method for class 'data.table'
rollup(x, j, by, .SDcols, id = FALSE, ...)
cube(x, ...)
## S3 method for class 'data.table'
cube(x, j, by, .SDcols, id = FALSE, ...)
groupingsets(x, ...)
## S3 method for class 'data.table'
groupingsets(x, j, by, sets, .SDcols, id = FALSE, jj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupingsets_+3A_x">x</code></td>
<td>
<p><code>data.table</code>.</p>
</td></tr>
<tr><td><code id="groupingsets_+3A_...">...</code></td>
<td>
<p>argument passed to custom user methods. Ignored for <code>data.table</code> methods.</p>
</td></tr>
<tr><td><code id="groupingsets_+3A_j">j</code></td>
<td>
<p>expression passed to data.table <code>j</code>.</p>
</td></tr>
<tr><td><code id="groupingsets_+3A_by">by</code></td>
<td>
<p>character column names by which we are grouping.</p>
</td></tr>
<tr><td><code id="groupingsets_+3A_sets">sets</code></td>
<td>
<p>list of character vector reflecting grouping sets, used in <code>groupingsets</code> for flexibility.</p>
</td></tr>
<tr><td><code id="groupingsets_+3A_.sdcols">.SDcols</code></td>
<td>
<p>columns to be used in <code>j</code> expression in <code>.SD</code> object.</p>
</td></tr>
<tr><td><code id="groupingsets_+3A_id">id</code></td>
<td>
<p>logical default <code>FALSE</code>. If <code>TRUE</code> it will add leading column with bit mask of grouping sets.</p>
</td></tr>
<tr><td><code id="groupingsets_+3A_jj">jj</code></td>
<td>
<p>quoted version of <code>j</code> argument, for convenience. When provided function will ignore <code>j</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All three functions <code>rollup, cube, groupingsets</code> are generic methods, <code>data.table</code> methods are provided.
</p>


<h3>Value</h3>

<p>A data.table with various aggregates.
</p>


<h3>References</h3>

<p><a href="https://www.postgresql.org/docs/9.5/static/queries-table-expressions.html#QUERIES-GROUPING-SETS">https://www.postgresql.org/docs/9.5/static/queries-table-expressions.html#QUERIES-GROUPING-SETS</a>
<a href="https://www.postgresql.org/docs/9.5/static/functions-aggregate.html#FUNCTIONS-GROUPING-TABLE">https://www.postgresql.org/docs/9.5/static/functions-aggregate.html#FUNCTIONS-GROUPING-TABLE</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+rbindlist">rbindlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 24L
set.seed(25)
DT &lt;- data.table(
    color = sample(c("green","yellow","red"), n, TRUE),
    year = as.Date(sample(paste0(2011:2015,"-01-01"), n, TRUE)),
    status = as.factor(sample(c("removed","active","inactive","archived"), n, TRUE)),
    amount = sample(1:5, n, TRUE),
    value = sample(c(3, 3.5, 2.5, 2), n, TRUE)
)

# rollup
rollup(DT, j = sum(value), by = c("color","year","status")) # default id=FALSE
rollup(DT, j = sum(value), by = c("color","year","status"), id=TRUE)
rollup(DT, j = lapply(.SD, sum), by = c("color","year","status"), id=TRUE, .SDcols="value")
rollup(DT, j = c(list(count=.N), lapply(.SD, sum)), by = c("color","year","status"), id=TRUE)

# cube
cube(DT, j = sum(value), by = c("color","year","status"), id=TRUE)
cube(DT, j = lapply(.SD, sum), by = c("color","year","status"), id=TRUE, .SDcols="value")
cube(DT, j = c(list(count=.N), lapply(.SD, sum)), by = c("color","year","status"), id=TRUE)

# groupingsets
groupingsets(DT, j = c(list(count=.N), lapply(.SD, sum)), by = c("color","year","status"),
             sets = list("color", c("year","status"), character()), id=TRUE)
</code></pre>

<hr>
<h2 id='IDateTime'> Integer based date class </h2><span id='topic+IDate'></span><span id='topic+as.IDate'></span><span id='topic+ITime'></span><span id='topic+as.ITime'></span><span id='topic+IDateTime'></span><span id='topic+as.character.ITime'></span><span id='topic+as.Date.IDate'></span><span id='topic+as.IDate.Date'></span><span id='topic+as.IDate.default'></span><span id='topic+as.ITime.character'></span><span id='topic+as.ITime.default'></span><span id='topic+as.ITime.POSIXlt'></span><span id='topic+as.ITime.times'></span><span id='topic+as.list.IDate'></span><span id='topic+as.POSIXct.IDate'></span><span id='topic+as.POSIXct.ITime'></span><span id='topic+as.POSIXlt.ITime'></span><span id='topic+c.IDate'></span><span id='topic+c.ITime'></span><span id='topic+format.ITime'></span><span id='topic+IDateTime.default'></span><span id='topic+mean.IDate'></span><span id='topic+mean.ITime'></span><span id='topic+print.ITime'></span><span id='topic+rep.IDate'></span><span id='topic+rep.ITime'></span><span id='topic+round.IDate'></span><span id='topic+round.ITime'></span><span id='topic+trunc.ITime'></span><span id='topic+seq.IDate'></span><span id='topic+seq.ITime'></span><span id='topic+second'></span><span id='topic+minute'></span><span id='topic+hour'></span><span id='topic+yday'></span><span id='topic+wday'></span><span id='topic+mday'></span><span id='topic+week'></span><span id='topic+isoweek'></span><span id='topic+month'></span><span id='topic+quarter'></span><span id='topic+year'></span><span id='topic+yearmon'></span><span id='topic+yearqtr'></span><span id='topic+IDate-class'></span><span id='topic+ITime-class'></span>

<h3>Description</h3>

<p>Classes (<code>IDate</code> and <code>ITime</code>) with <em>integer</em> storage
for fast sorting and grouping.
</p>
<p><code>IDate</code> inherits from the base class <code>Date</code>; the main
difference is that the latter uses double storage, allowing e.g. for
fractional dates at the cost of storage &amp; sorting inefficiency.
</p>
<p>Using <code>IDate</code>, if sub-day granularity is needed, use a second
<code>ITime</code> column. <code>IDateTime()</code> facilitates building such
paired columns.
</p>
<p>Lastly, there are date-time helpers for extracting parts of dates as
integers, for example the year (<code>year()</code>), month
(<code>month()</code>), or day in the month (<code>mday()</code>); see Usage and Exampels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.IDate(x, ...)
## Default S3 method:
as.IDate(x, ..., tz = attr(x, "tzone", exact=TRUE))
## S3 method for class 'Date'
as.IDate(x, ...)
## S3 method for class 'IDate'
as.Date(x, ...)
## S3 method for class 'IDate'
as.POSIXct(x, tz = "UTC", time = 0, ...)
## S3 method for class 'IDate'
round(x, digits = c("weeks", "months", "quarters","years"), ...)

as.ITime(x, ...)
## Default S3 method:
as.ITime(x, ...)
## S3 method for class 'POSIXlt'
as.ITime(x, ms = 'truncate', ...)
## S3 method for class 'ITime'
round(x, digits = c("hours", "minutes"), ...)
## S3 method for class 'ITime'
trunc(x, units = c("hours", "minutes"), ...)

## S3 method for class 'ITime'
as.POSIXct(x, tz = "UTC", date = Sys.Date(), ...)
## S3 method for class 'ITime'
as.character(x, ...)
## S3 method for class 'ITime'
format(x, ...)

IDateTime(x, ...)
## Default S3 method:
IDateTime(x, ...)

second(x)
minute(x)
hour(x)
yday(x)
wday(x)
mday(x)
week(x)
isoweek(x)
month(x)
quarter(x)
year(x)
yearmon(x)
yearqtr(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IDateTime_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="IDateTime_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods. For
<code>as.IDate.default</code>, arguments are passed to <code>as.Date</code>. For
<code>as.ITime.default</code>, arguments are passed to <code>as.POSIXlt</code>.</p>
</td></tr>
<tr><td><code id="IDateTime_+3A_tz">tz</code></td>
<td>
<p>time zone (see <code>strptime</code>).</p>
</td></tr>
<tr><td><code id="IDateTime_+3A_date">date</code></td>
<td>
<p>date object convertible with <code>as.IDate</code>.</p>
</td></tr>
<tr><td><code id="IDateTime_+3A_time">time</code></td>
<td>
<p>time-of-day object convertible with <code>as.ITime</code>.</p>
</td></tr>
<tr><td><code id="IDateTime_+3A_digits">digits</code></td>
<td>
<p>really <code>units</code>; one of the units listed for
rounding. May be abbreviated. Named <code>digits</code> for consistency with
the S3 generic.</p>
</td></tr>
<tr><td><code id="IDateTime_+3A_units">units</code></td>
<td>
<p>one of the units listed for truncating. May be abbreviated.</p>
</td></tr>
<tr><td><code id="IDateTime_+3A_ms">ms</code></td>
<td>
<p> For <code>as.ITime</code> methods, what should be done with sub-second fractions of input? Valid values are <code>'truncate'</code> (floor), <code>'nearest'</code> (round), and <code>'ceil'</code> (ceiling). See Details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>IDate</code> is a date class derived from <code>Date</code>. It has the same
internal representation as the <code>Date</code> class, except the storage
mode is integer. <code>IDate</code> is a relatively simple wrapper, and it
should work in almost all situations as a replacement for
<code>Date</code>. The main limitations of integer storage are (1) fractional
dates are not supported (use <code>IDateTime()</code> instead) and (2) the
range of supported dates is bounded by <code>.Machine$integer.max</code>
dates away from January 1, 1970 (a rather impractical limitation as
these dates are roughly 6 million years in the future/past, but
consider this your caveat).
</p>
<p>Functions that use <code>Date</code> objects generally work for
<code>IDate</code> objects. This package provides specific methods for
<code>IDate</code> objects for <code>mean</code>, <code>cut</code>, <code>seq</code>, <code>c</code>,
<code>rep</code>, and <code>split</code> to return an <code>IDate</code> object.
</p>
<p><code>ITime</code> is a time-of-day class stored as the integer number of
seconds in the day. <code>as.ITime</code> does not allow days longer than 24
hours. Because <code>ITime</code> is stored in seconds, you can add it to a
<code>POSIXct</code> object, but you should not add it to a <code>Date</code>
object.
</p>
<p>We also provide S3 methods to convert to and from <code>Date</code> and <code>POSIXct</code>.
</p>
<p><code>ITime</code> is time zone-agnostic. When converting <code>ITime</code> and
<code>IDate</code> to POSIXct with <code>as.POSIXct</code>, a time zone may be specified.
</p>
<p>Inputs like <code>'2018-05-15 12:34:56.789'</code> are ambiguous from the perspective of an <code>ITime</code> object &ndash; the method of coercion of the 789 milliseconds is controlled by the <code>ms</code> argument to relevant methods. The default behavior (<code>ms = 'truncate'</code>) is to use <code>as.integer</code>, which has the effect of truncating anything after the decimal. Alternatives are to round to the nearest integer (<code>ms = 'nearest'</code>) or to round up (<code>ms = 'ceil'</code>).
</p>
<p>In <code>as.POSIXct</code> methods for <code>ITime</code> and <code>IDate</code>, the
second argument is required to be <code>tz</code> based on the generic
template, but to make converting easier, the second argument is
interpreted as a date instead of a time zone if it is of type
<code>IDate</code> or <code>ITime</code>. Therefore, you can use either of the
following: <code>as.POSIXct(time, date)</code> or <code>as.POSIXct(date,
time)</code>.
</p>
<p><code>IDateTime</code> takes a date-time input and returns a data table with
columns <code>date</code> and <code>time</code>.
</p>
<p>Using integer storage allows dates and/or times to be used as data table
keys. With positive integers with a range less than 100,000, grouping
and sorting is fast because radix sorting can be used (see
<code>sort.list</code>).
</p>
<p>Several convenience functions like <code>hour</code> and <code>quarter</code> are
provided to group or extract by hour, month, and other date-time
intervals. <code>as.POSIXlt</code> is also useful. For example,
<code>as.POSIXlt(x)$mon</code> is the integer month. The R base convenience
functions <code>weekdays</code>, <code>months</code>, and <code>quarters</code> can also
be used, but these return character values, so they must be converted to
factors for use with data.table. <code>isoweek</code> is ISO 8601-consistent.
</p>
<p>The <code>round</code> method for IDate's is useful for grouping and plotting.
It can round to weeks, months, quarters, and years. Similarly, the <code>round</code>
and <code>trunc</code> methods for ITime's are useful for grouping and plotting.
They can round or truncate to hours and minutes.
Note for ITime's with 30 seconds, rounding is inconsistent due to rounding off a 5.
See 'Details' in <code><a href="base.html#topic+round">round</a></code> for more information.
</p>


<h3>Value</h3>

<p>For <code>as.IDate</code>, a class of <code>IDate</code> and <code>Date</code> with the
date stored as the number of days since some origin.
</p>
<p>For <code>as.ITime</code>, a class of <code>ITime</code>
stored as the number of seconds in the day.
</p>
<p>For <code>IDateTime</code>, a data table with columns <code>idate</code> and
<code>itime</code> in <code>IDate</code> and <code>ITime</code> format.
</p>
<p><code>second</code>, <code>minute</code>, <code>hour</code>, <code>yday</code>, <code>wday</code>,
<code>mday</code>, <code>week</code>, <code>month</code>, <code>quarter</code>,
and <code>year</code> return integer values
for second, minute, hour, day of year, day of week,
day of month, week, month, quarter, and year, respectively.
<code>yearmon</code> and <code>yearqtr</code> return double values representing
respectively 'year + (month-1) / 12' and 'year + (quarter-1) / 4'.
</p>
<p><code>second</code>, <code>minute</code>, <code>hour</code> are taken directly from
the <code>POSIXlt</code> representation.
All other values are computed from the underlying integer representation
and comparable with the values of their <code>POSIXlt</code> representation
of <code>x</code>, with the notable difference that while <code>yday</code>, <code>wday</code>,
and <code>mon</code> are all 0-based, here they are 1-based.
</p>


<h3>Author(s)</h3>

<p> Tom Short, t.short@ieee.org </p>


<h3>References</h3>

<p>G. Grothendieck and T. Petzoldt, &ldquo;Date and Time Classes in R,&rdquo;
R News, vol. 4, no. 1, June 2004.
</p>
<p>H. Wickham, https://gist.github.com/10238.
</p>
<p>ISO 8601, https://www.iso.org/iso/home/standards/iso8601.htm
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+as.Date">as.Date</a></code>, <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>,
<code><a href="base.html#topic+strptime">strptime</a></code>, <code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create IDate:
(d &lt;- as.IDate("2001-01-01"))

# S4 coercion also works
identical(as.IDate("2001-01-01"), methods::as("2001-01-01", "IDate"))

# create ITime:
(t &lt;- as.ITime("10:45"))

# S4 coercion also works
identical(as.ITime("10:45"), methods::as("10:45", "ITime"))

(t &lt;- as.ITime("10:45:04"))

(t &lt;- as.ITime("10:45:04", format = "%H:%M:%S"))

as.POSIXct("2001-01-01") + as.ITime("10:45")

datetime &lt;- seq(as.POSIXct("2001-01-01"), as.POSIXct("2001-01-03"), by = "5 hour")
(af &lt;- data.table(IDateTime(datetime), a = rep(1:2, 5), key = "a,idate,itime"))

af[, mean(a), by = "itime"]
af[, mean(a), by = list(hour = hour(itime))]
af[, mean(a), by = list(wday = factor(weekdays(idate)))]
af[, mean(a), by = list(wday = wday(idate))]

as.POSIXct(af$idate)
as.POSIXct(af$idate, time = af$itime)
as.POSIXct(af$idate, af$itime)
as.POSIXct(af$idate, time = af$itime, tz = "GMT")

as.POSIXct(af$itime, af$idate)
as.POSIXct(af$itime) # uses today's date

(seqdates &lt;- seq(as.IDate("2001-01-01"), as.IDate("2001-08-03"), by = "3 weeks"))
round(seqdates, "months")

(seqtimes &lt;- seq(as.ITime("07:00"), as.ITime("08:00"), by = 20))
round(seqtimes, "hours")
trunc(seqtimes, "hours")

</code></pre>

<hr>
<h2 id='J'>
Creates a join <code>data.table</code>
</h2><span id='topic+J'></span><span id='topic+CJ'></span><span id='topic+SJ'></span>

<h3>Description</h3>

<p>Creates a <code>data.table</code> for use in <code>i</code> in a <code>[.data.table</code> join.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># DT[J(...)]                          # J() only for use inside DT[...]
# DT[.(...)]                          # .() only for use inside DT[...]
# DT[list(...)]                       # same; .(), list() and J() are identical
SJ(...)                             # DT[SJ(...)]
CJ(..., sorted=TRUE, unique=FALSE)  # DT[CJ(...)]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="J_+3A_...">...</code></td>
<td>
<p> Each argument is a vector. Generally each vector is the
same length, but if they are not then the usual silent recycling is applied. </p>
</td></tr>
<tr><td><code id="J_+3A_sorted">sorted</code></td>
<td>
<p> logical. Should <code>setkey()</code> be called on all the columns in the order they were passed to <code>CJ</code>? </p>
</td></tr>
<tr><td><code id="J_+3A_unique">unique</code></td>
<td>
<p> logical. When <code>TRUE</code>, only unique values of each vectors are used (automatically). </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SJ</code> and <code>CJ</code> are convenience functions to create a <code>data.table</code> to be used in <code>i</code> when performing a <code>data.table</code> 'query' on <code>x</code>.
</p>
<p><code>x[data.table(id)]</code> is the same as <code>x[J(id)]</code> but the latter is more readable. Identical alternatives are <code>x[list(id)]</code> and <code>x[.(id)]</code>.
</p>
<p>When using a join table in <code>i</code>, <code>x</code> must either be keyed or the <code>on</code> argument be used to indicate the columns in <code>x</code> and <code>i</code> which should be joined. See <code><a href="#topic++5B.data.table">[.data.table</a></code>.
</p>


<h3>Value</h3>


<p><code>J</code> : the same result as calling <code>list</code>, for which <code>J</code> is a direct alias.
</p>
<p><code>SJ</code> : <strong>S</strong>orted <strong>J</strong>oin. The same value as <code>J()</code> but additionally <code>setkey()</code> is called on all columns in the order they were passed to <code>SJ</code>. For efficiency, to invoke a binary merge rather than a repeated binary full search for each row of <code>i</code>.
</p>
<p><code>CJ</code> : <strong>C</strong>ross <strong>J</strong>oin. A <code>data.table</code> is formed from the cross product of the vectors. For example, <code>CJ</code> on 10 ids and 100 dates, returns a 1000 row table containing all dates for all ids. If <code>sorted = TRUE</code> (default), <code>setkey()</code> is called on all columns in the order they were passed in to <code>CJ</code>. If <code>sorted = FALSE</code>, the result is unkeyed and input order is retained.

</p>


<h3>See Also</h3>

 <p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+test.data.table">test.data.table</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>DT = data.table(A=5:1, B=letters[5:1])
setkey(DT, B)   # reorders table and marks it sorted
DT[J("b")]      # returns the 2nd row
DT[list("b")]   # same
DT[.("b")]      # same using the dot alias for list

# CJ usage examples
CJ(c(5, NA, 1), c(1, 3, 2))                 # sorted and keyed data.table
do.call(CJ, list(c(5, NA, 1), c(1, 3, 2)))  # same as above
CJ(c(5, NA, 1), c(1, 3, 2), sorted=FALSE)   # same order as input, unkeyed
# use for 'unique=' argument
x = c(1, 1, 2)
y = c(4, 6, 4)
CJ(x, y)              # output columns are automatically named 'x' and 'y'
CJ(x, y, unique=TRUE) # unique(x) and unique(y) are computed automatically

z = 0:1 + (0:1)*1i
CJ(x, z, sorted = FALSE) # support for sorting complex is not yet implemented
</code></pre>

<hr>
<h2 id='key+26lt+3B-'> Deprecated. </h2><span id='topic+key+3C-'></span>

<h3>Description</h3>

<p>This function is deprecated. It will be removed in future. Please use <code><a href="#topic+setkey">setkey</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>key(x) &lt;- value   #  warning since 2012; DEPRECATED since Mar 2019
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="key+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p> Deprecated. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># dummy example section to pass release check that all .Rd files have examples
</code></pre>

<hr>
<h2 id='last'> First/last item of an object </h2><span id='topic+first'></span><span id='topic+last'></span>

<h3>Description</h3>

<p>Returns the first/last item of a vector or list, or the first/last row of a data.frame
or data.table. The main difference to head/tail is that the default for <code>n</code> is 1
rather than 6.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first(x, n=1L, ...)
last(x, n=1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_+3A_x">x</code></td>
<td>
<p> A vector, list, data.frame or data.table. Otherwise the S3 method
of <code>xts::first</code> is deployed. </p>
</td></tr>
<tr><td><code id="last_+3A_n">n</code></td>
<td>
<p> A numeric vector length 1. How many items to select. </p>
</td></tr>
<tr><td><code id="last_+3A_...">...</code></td>
<td>
<p> Not applicable for <code>data.table</code> first/last. Any arguments here
are passed through to <code>xts</code>'s first/last. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If no other arguments are supplied it depends on the type of <code>x</code>. The first/last item
of a vector or list. The first/last row of a <code>data.frame</code> or <code>data.table</code>.
For other types, or if any argument is supplied in addition to <code>x</code> (such as <code>n</code>, or
<code>keep</code> in <code>xts</code>) regardless of <code>x</code>'s type, then <code>xts::first</code>/
<code>xts::last</code> is called if <code>xts</code> has been loaded, otherwise <code>utils::head</code>/<code>utils::tail</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+NROW">NROW</a></code>, <code><a href="utils.html#topic+head">head</a></code>, <code><a href="utils.html#topic+tail">tail</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>first(1:5) # [1] 1
x = data.table(x=1:5, y=6:10)
first(x) # same as head(x, 1)

last(1:5) # [1] 5
x = data.table(x=1:5, y=6:10)
last(x) # same as tail(x, 1)
</code></pre>

<hr>
<h2 id='like'> Convenience function for calling grep. </h2><span id='topic+like'></span><span id='topic++25like+25'></span><span id='topic++25ilike+25'></span><span id='topic++25flike+25'></span><span id='topic++25plike+25'></span>

<h3>Description</h3>

<p>Intended for use in <code>i</code> in <code><a href="#topic+data.table">[.data.table</a></code>, i.e., for subsetting/filtering.
</p>
<p>Syntax should be familiar to SQL users, with interpretation as regex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>like(vector, pattern, ignore.case = FALSE, fixed = FALSE, perl = FALSE)
vector %like% pattern
vector %ilike% pattern
vector %flike% pattern
vector %plike% pattern
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="like_+3A_vector">vector</code></td>
<td>
<p> Either a <code>character</code> or a <code>factor</code> vector. </p>
</td></tr>
<tr><td><code id="like_+3A_pattern">pattern</code></td>
<td>
<p> Pattern to be matched </p>
</td></tr>
<tr><td><code id="like_+3A_ignore.case">ignore.case</code></td>
<td>
 <p><code>logical</code>; is <code>pattern</code> case-sensitive? </p>
</td></tr>
<tr><td><code id="like_+3A_fixed">fixed</code></td>
<td>
 <p><code>logical</code>; should <code>pattern</code> be interpreted as a literal string (i.e., ignoring regular expressions)? </p>
</td></tr>
<tr><td><code id="like_+3A_perl">perl</code></td>
<td>
 <p><code>logical</code>; is <code>pattern</code> Perl-compatible regular expression? </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, <code>like</code> is essentially a wrapper around <code><a href="base.html#topic+grep">base::grepl</a></code>, except that it is smarter about handling <code>factor</code> input (<code>base::grep</code> uses slow <code>as.character</code> conversion).
</p>


<h3>Value</h3>

<p>Logical vector, <code>TRUE</code> for items that match <code>pattern</code>.
</p>


<h3>Note</h3>

<p> Current implementation does not make use of sorted keys. </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+grep">base::grepl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>DT = data.table(Name=c("Mary","George","Martha"), Salary=c(2,3,4))
DT[Name %like% "^Mar"]
DT[Name %ilike% "mar"]
DT[Name %flike% "Mar"]
DT[Name %plike% "(?=Ma)(?=.*y)"]
</code></pre>

<hr>
<h2 id='measure'>Specify measure.vars via regex or separator</h2><span id='topic+measure'></span><span id='topic+measurev'></span>

<h3>Description</h3>

<p>These functions compute an integer vector or list for use as
the <code>measure.vars</code> argument to <code>melt</code>.
Each measured variable name is converted into several groups that occupy
different columns in the output melted data.
<code>measure</code> allows specifying group names/conversions in R code
(each group and conversion specified as an argument)
whereas <code>measurev</code> allows specifying group names/conversions using
data values
(each group and conversion specified as a list element).
See
<a href="../doc/datatable-reshape.html"><code>vignette("datatable-reshape")</code></a>
for more info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure(..., sep, pattern, cols, multiple.keyword="value.name")
measurev(fun.list, sep, pattern, cols, multiple.keyword="value.name",
  group.desc="elements of fun.list")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measure_+3A_...">...</code></td>
<td>
<p>One or more (1) symbols (without argument name; symbol
is used for group name) or (2) functions to convert the groups
(with argument name that is used for group name).
Must have same number of arguments as groups that are
specified by either <code>sep</code> or <code>pattern</code> arguments.</p>
</td></tr>
<tr><td><code id="measure_+3A_fun.list">fun.list</code></td>
<td>
<p>Named list which must have the same number of
elements as groups that are specified by either <code>sep</code> or
<code>pattern</code> arguments. Each name used for a group
name, and each value must be either a function
(to convert the group from a character vector to an atomic vector of the
same size) or NULL (no conversion).</p>
</td></tr>
<tr><td><code id="measure_+3A_sep">sep</code></td>
<td>
<p>Separator to split each element of <code>cols</code> into
groups. Columns that result in the maximum number of groups
are considered measure variables.</p>
</td></tr>
<tr><td><code id="measure_+3A_pattern">pattern</code></td>
<td>
<p>Perl-compatible regex with capture groups to match to
<code>cols</code>. Columns that match the regex are considered measure variables.</p>
</td></tr>
<tr><td><code id="measure_+3A_cols">cols</code></td>
<td>
<p>A character vector of column names.</p>
</td></tr>
<tr><td><code id="measure_+3A_multiple.keyword">multiple.keyword</code></td>
<td>
<p>A string, if used as a group name, then
measure returns a list and melt returns multiple
value columns (with names defined by the unique values in that
group). Otherwise if the string not used as a group name, then
measure returns a vector and melt returns a single value column.</p>
</td></tr>
<tr><td><code id="measure_+3A_group.desc">group.desc</code></td>
<td>
<p>Internal, used in error messages.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+melt">melt</a></code>,
<a href="https://github.com/Rdatatable/data.table/wiki/Getting-started">https://github.com/Rdatatable/data.table/wiki/Getting-started</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(two.iris = data.table(datasets::iris)[c(1,150)])
# melt into a single value column.
melt(two.iris, measure.vars = measure(part, dim, sep="."))
# do the same, programmatically with measurev
my.list = list(part=NULL, dim=NULL)
melt(two.iris, measure.vars=measurev(my.list, sep="."))
# melt into two value columns, one for each part.
melt(two.iris, measure.vars = measure(value.name, dim, sep="."))
# melt into two value columns, one for each dim.
melt(two.iris, measure.vars = measure(part, value.name, sep="."))
# melt using sep, converting child number to integer.
(two.families = data.table(sex_child1="M", sex_child2="F", age_child1=10, age_child2=20))
print(melt(two.families, measure.vars = measure(
  value.name, child=as.integer,
  sep="_child"
)), class=TRUE)
# same melt using pattern.
print(melt(two.families, measure.vars = measure(
  value.name, child=as.integer,
  pattern="(.*)_child(.)"
)), class=TRUE)
# same melt with pattern and measurev function list.
print(melt(two.families, measure.vars = measurev(
  list(value.name=NULL, child=as.integer),
  pattern="(.*)_child(.)"
)), class=TRUE)
# inspired by data(who, package="tidyr")
(who &lt;- data.table(id=1, new_sp_m5564=2, newrel_f65=3))
# melt to three variable columns, all character.
melt(who, measure.vars = measure(diagnosis, gender, ages, pattern="new_?(.*)_(.)(.*)"))
# melt to five variable columns, two numeric (with custom conversion).
print(melt(who, measure.vars = measure(
  diagnosis, gender, ages,
  ymin=as.numeric,
  ymax=function(y)ifelse(y=="", Inf, as.numeric(y)),
  pattern="new_?(.*)_(.)(([0-9]{2})([0-9]{0,2}))"
)), class=TRUE)
</code></pre>

<hr>
<h2 id='melt.data.table'>Fast melt for data.table</h2><span id='topic+melt.data.table'></span><span id='topic+melt'></span>

<h3>Description</h3>

<p><code>melt</code> is <code>data.table</code>'s wide-to-long reshaping tool.
We provide an S3 method for melting <code>data.table</code>s. It is written in C for speed and memory
efficiency. Since <code>v1.9.6</code>, <code>melt.data.table</code> allows melting into
multiple columns simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## fast melt a data.table
## S3 method for class 'data.table'
melt(data, id.vars, measure.vars,
    variable.name = "variable", value.name = "value",
    ..., na.rm = FALSE, variable.factor = TRUE,
    value.factor = FALSE,
    verbose = getOption("datatable.verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt.data.table_+3A_data">data</code></td>
<td>
<p> A <code>data.table</code> object to melt.</p>
</td></tr>
<tr><td><code id="melt.data.table_+3A_id.vars">id.vars</code></td>
<td>
<p>vector of id variables. Can be integer (corresponding id
column numbers) or character (id column names) vector. If missing, all
non-measure columns will be assigned to it. If integer, must be positive; see Details. </p>
</td></tr>
<tr><td><code id="melt.data.table_+3A_measure.vars">measure.vars</code></td>
<td>
<p>Measure variables for <code>melt</code>ing. Can be missing, vector, list, or pattern-based.
</p>

<ul>
<li><p> When missing, <code>measure.vars</code> will become all columns outside <code>id.vars</code>. 
</p>
</li>
<li><p> Vector can be <code>integer</code> (implying column numbers) or <code>character</code> (column names). 
</p>
</li>
<li> <p><code>list</code> is a generalization of the vector version &ndash; each element of the list (which should be <code>integer</code> or <code>character</code> as above) will become a <code>melt</code>ed column. 
</p>
</li>
<li><p> Pattern-based column matching can be achieved with the regular expression-based <code><a href="#topic+patterns">patterns</a></code> syntax; multiple patterns will produce multiple columns. 
</p>
</li></ul>

<p>For convenience/clarity in the case of multiple <code>melt</code>ed columns, resulting column names can be supplied as names to the elements <code>measure.vars</code> (in the <code>list</code> and <code>patterns</code> usages). See also <code>Examples</code>. </p>
</td></tr>
<tr><td><code id="melt.data.table_+3A_variable.name">variable.name</code></td>
<td>
<p>name (default <code>'variable'</code>) of output column containing information about which input column(s) were melted. If <code>measure.vars</code> is an integer/character vector, then each entry of this column contains the name of a melted column from <code>data</code>. If <code>measure.vars</code> is a list of integer/character vectors, then each entry of this column contains an integer indicating an index/position in each of those vectors. If <code>measure.vars</code> has attribute <code>variable_table</code> then it must be a data table with nrow = length of <code>measure.vars</code> vector(s), each row describing the corresponding measured variables(s), (typically created via <code>measure</code>) and its columns will be output instead of the <code>variable.name</code> column.</p>
</td></tr>
<tr><td><code id="melt.data.table_+3A_value.name">value.name</code></td>
<td>
<p>name for the molten data values column(s). The default name is <code>'value'</code>. Multiple names can be provided here for the case when <code>measure.vars</code> is a <code>list</code>, though note well that the names provided in <code>measure.vars</code> take precedence. </p>
</td></tr>
<tr><td><code id="melt.data.table_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, <code>NA</code> values will be removed from the molten
data.</p>
</td></tr>
<tr><td><code id="melt.data.table_+3A_variable.factor">variable.factor</code></td>
<td>
<p>If <code>TRUE</code>, the <code>variable</code> column will be
converted to <code>factor</code>, else it will be a <code>character</code> column.</p>
</td></tr>
<tr><td><code id="melt.data.table_+3A_value.factor">value.factor</code></td>
<td>
<p>If <code>TRUE</code>, the <code>value</code> column will be converted
to <code>factor</code>, else the molten value type is left unchanged.</p>
</td></tr>
<tr><td><code id="melt.data.table_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> turns on status and information messages to the
console. Turn this on by default using <code>options(datatable.verbose=TRUE)</code>.
The quantity and types of verbosity may be expanded in future.</p>
</td></tr>
<tr><td><code id="melt.data.table_+3A_...">...</code></td>
<td>
<p>any other arguments to be passed to/from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>id.vars</code> and <code>measure.vars</code> are both missing, all
non-<code>numeric/integer/logical</code> columns are assigned as id variables and
the rest as measure variables. If only one of <code>id.vars</code> or
<code>measure.vars</code> is supplied, the rest of the columns will be assigned to
the other. Both <code>id.vars</code> and <code>measure.vars</code> can have the same column
more than once and the same column can be both as id and measure variables.
</p>
<p><code>melt.data.table</code> also accepts <code>list</code> columns for both id and measure
variables.
</p>
<p>When all <code>measure.vars</code> are not of the same type, they'll be coerced
according to the hierarchy <code>list</code> &gt; <code>character</code> &gt; <code>numeric &gt;
integer &gt; logical</code>. For example, if any of the measure variables is a
<code>list</code>, then entire value column will be coerced to a list. 
</p>
<p>From version <code>1.9.6</code>, <code>melt</code> gains a feature with <code>measure.vars</code>
accepting a list of <code>character</code> or <code>integer</code> vectors as well to melt
into multiple columns in a single function call efficiently.
If a vector in the list contains missing values, or is shorter than the
max length of the list elements, then the output will include runs of
missing values at the specified position, or at the end.
The function
<code><a href="#topic+patterns">patterns</a></code> can be used to provide regular expression patterns. When
used along with <code>melt</code>, if <code>cols</code> argument is not provided, the
patterns will be matched against <code>names(data)</code>, for convenience.
</p>
<p>Attributes are preserved if all <code>value</code> columns are of the same type. By
default, if any of the columns to be melted are of type <code>factor</code>, it'll
be coerced to <code>character</code> type. To get a <code>factor</code> column, set
<code>value.factor = TRUE</code>. <code>melt.data.table</code> also preserves
<code>ordered</code> factors.
</p>
<p>Historical note: <code>melt.data.table</code> was originally designed as an enhancement to <code>reshape2::melt</code> in terms of computing and memory efficiency. <code>reshape2</code> has since been superseded in favour of <code>tidyr</code>, and <code>melt</code> has had a generic defined within <code>data.table</code> since <code>v1.9.6</code> in 2015, at which point the dependency between the packages became more etymological than programmatic. We thank the <code>reshape2</code> authors for the inspiration.
</p>


<h3>Value</h3>

<p>An unkeyed <code>data.table</code> containing the molten data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dcast">dcast</a></code>, <a href="https://cran.r-project.org/package=reshape">https://cran.r-project.org/package=reshape</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(45)
require(data.table)
DT &lt;- data.table(
  i_1 = c(1:5, NA),
  n_1 = c(NA, 6, 7, 8, 9, 10),
  f_1 = factor(sample(c(letters[1:3], NA), 6L, TRUE)),
  f_2 = factor(c("z", "a", "x", "c", "x", "x"), ordered=TRUE),
  c_1 = sample(c(letters[1:3], NA), 6L, TRUE),
  c_2 = sample(c(LETTERS[1:2], NA), 6L, TRUE),
  d_1 = as.Date(c(1:3,NA,4:5), origin="2013-09-01"),
  d_2 = as.Date(6:1, origin="2012-01-01")
)
# add a couple of list cols
DT[, l_1 := DT[, list(c=list(rep(i_1, sample(5, 1L)))), by = i_1]$c]
DT[, l_2 := DT[, list(c=list(rep(c_1, sample(5, 1L)))), by = i_1]$c]

# id.vars, measure.vars as character/integer/numeric vectors
melt(DT, id.vars=1:2, measure.vars="f_1")
melt(DT, id.vars=c("i_1", "n_1"), measure.vars=3) # same as above
melt(DT, id.vars=1:2, measure.vars=3L, value.factor=TRUE) # same, but 'value' is factor
melt(DT, id.vars=1:2, measure.vars=3:4, value.factor=TRUE) # 'value' is *ordered* factor

# preserves attribute when types are identical, ex: Date
melt(DT, id.vars=3:4, measure.vars=c("d_1", "d_2"))
melt(DT, id.vars=3:4, measure.vars=c("n_1", "d_1")) # attribute not preserved

# on list
melt(DT, id.vars=1, measure.vars=c("l_1", "l_2")) # value is a list
suppressWarnings(
  melt(DT, id.vars=1, measure.vars=c("c_1", "l_1")) # c1 coerced to list, with warning
)

# on character
melt(DT, id.vars=1, measure.vars=c("c_1", "f_1")) # value is char
suppressWarnings(
  melt(DT, id.vars=1, measure.vars=c("c_1", "n_1")) # n_1 coerced to char, with warning
)

# on na.rm=TRUE. NAs are removed efficiently, from within C
melt(DT, id.vars=1, measure.vars=c("c_1", "c_2"), na.rm=TRUE) # remove NA

# measure.vars can be also a list
# melt "f_1,f_2" and "d_1,d_2" simultaneously, retain 'factor' attribute
# convenient way using internal function patterns()
melt(DT, id.vars=1:2, measure.vars=patterns("^f_", "^d_"), value.factor=TRUE)
# same as above, but provide list of columns directly by column names or indices
melt(DT, id.vars=1:2, measure.vars=list(3:4, c("d_1", "d_2")), value.factor=TRUE)
# same as above, but provide names directly:
melt(DT, id.vars=1:2, measure.vars=patterns(f="^f_", d="^d_"), value.factor=TRUE)

# na.rm=TRUE removes rows with NAs in any 'value' columns
melt(DT, id.vars=1:2, measure.vars=patterns("f_", "d_"), value.factor=TRUE, na.rm=TRUE)

# 'na.rm=TRUE' also works with list column, but note that is.na only
# returns TRUE if the list element is a length=1 vector with an NA.
is.na(list(one.NA=NA, two.NA=c(NA,NA)))
melt(DT, id.vars=1:2, measure.vars=patterns("l_", "d_"), na.rm=FALSE)
melt(DT, id.vars=1:2, measure.vars=patterns("l_", "d_"), na.rm=TRUE)

# measure list with missing/short entries results in output with runs of NA
DT.missing.cols &lt;- DT[, .(d_1, d_2, c_1, f_2)]
melt(DT.missing.cols, measure.vars=list(d=1:2, c="c_1", f=c(NA, "f_2")))

# specifying columns to melt via separator.
melt(DT.missing.cols, measure.vars=measure(value.name, number=as.integer, sep="_"))

# specifying columns to melt via regex.
melt(DT.missing.cols, measure.vars=measure(value.name, number=as.integer, pattern="(.)_(.)"))
</code></pre>

<hr>
<h2 id='merge'>Merge two data.tables</h2><span id='topic+merge'></span><span id='topic+merge.data.table'></span>

<h3>Description</h3>

<p>Fast merge of two <code>data.table</code>s. The <code>data.table</code> method behaves
similarly to <code>data.frame</code> except that row order is specified, and by
default the columns to merge on are chosen:
</p>

<ul>
<li><p> at first based on the shared key columns, and if there are none,
</p>
</li>
<li><p> then based on key columns of the first argument <code>x</code>, and if there
are none,
</p>
</li>
<li><p> then based on the common columns between the two <code>data.table</code>s.
</p>
</li></ul>

<p>Use the <code>by</code>, <code>by.x</code> and <code>by.y</code> arguments explicitly to override this default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.table'
merge(x, y, by = NULL, by.x = NULL, by.y = NULL, all = FALSE,
all.x = all, all.y = all, sort = TRUE, suffixes = c(".x", ".y"), no.dups = TRUE,
allow.cartesian=getOption("datatable.allow.cartesian"),  # default FALSE
incomparables = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_+3A_x">x</code>, <code id="merge_+3A_y">y</code></td>
<td>
<p><code>data table</code>s. <code>y</code> is coerced to a <code>data.table</code> if
it isn't one already.</p>
</td></tr>
<tr><td><code id="merge_+3A_by">by</code></td>
<td>
<p>A vector of shared column names in <code>x</code> and <code>y</code> to merge on.
This defaults to the shared key columns between the two tables.
If <code>y</code> has no key columns, this defaults to the key of <code>x</code>.</p>
</td></tr>
<tr><td><code id="merge_+3A_by.x">by.x</code>, <code id="merge_+3A_by.y">by.y</code></td>
<td>
<p>Vectors of column names in <code>x</code> and <code>y</code> to merge on.</p>
</td></tr>
<tr><td><code id="merge_+3A_all">all</code></td>
<td>
<p>logical; <code>all = TRUE</code> is shorthand to save setting both
<code>all.x = TRUE</code> and <code>all.y = TRUE</code>.</p>
</td></tr>
<tr><td><code id="merge_+3A_all.x">all.x</code></td>
<td>
<p>logical; if <code>TRUE</code>, rows from <code>x</code> which have no matching row
in <code>y</code> are included. These rows will have 'NA's in the columns that are usually
filled with values from <code>y</code>. The default is <code>FALSE</code> so that only rows with
data from both <code>x</code> and <code>y</code> are included in the output.</p>
</td></tr>
<tr><td><code id="merge_+3A_all.y">all.y</code></td>
<td>
<p>logical; analogous to <code>all.x</code> above.</p>
</td></tr>
<tr><td><code id="merge_+3A_sort">sort</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), the rows of the merged
<code>data.table</code> are sorted by setting the key to the <code>by / by.x</code> columns. If
<code>FALSE</code>, unlike base R's <code>merge</code> for which row order is unspecified, the
row order in <code>x</code> is retained (including retaining the position of missings when
<code>all.x=TRUE</code>), followed by <code>y</code> rows that don't match <code>x</code> (when <code>all.y=TRUE</code>)
retaining the order those appear in <code>y</code>.</p>
</td></tr>
<tr><td><code id="merge_+3A_suffixes">suffixes</code></td>
<td>
<p>A <code>character(2)</code> specifying the suffixes to be used for
making non-<code>by</code> column names unique. The suffix behaviour works in a similar
fashion as the <code><a href="base.html#topic+merge.data.frame">merge.data.frame</a></code> method does.</p>
</td></tr>
<tr><td><code id="merge_+3A_no.dups">no.dups</code></td>
<td>
<p>logical indicating that <code>suffixes</code> are also appended to
non-<code>by.y</code> column names in <code>y</code> when they have the same column name
as any <code>by.x</code>.</p>
</td></tr>
<tr><td><code id="merge_+3A_allow.cartesian">allow.cartesian</code></td>
<td>
<p>See <code>allow.cartesian</code> in <code><a href="#topic++5B.data.table">[.data.table</a></code>.</p>
</td></tr>
<tr><td><code id="merge_+3A_incomparables">incomparables</code></td>
<td>
<p>values which cannot be matched and therefore are excluded from by columns.</p>
</td></tr>
<tr><td><code id="merge_+3A_...">...</code></td>
<td>
<p>Not used at this time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+merge">merge</a></code> is a generic function in base R. It dispatches to either the
<code>merge.data.frame</code> method or <code>merge.data.table</code> method depending on
the class of its first argument. Note that, unlike <code>SQL</code> join, <code>NA</code> is
matched against <code>NA</code> (and <code>NaN</code> against <code>NaN</code>) while merging.
</p>
<p>For a more <code>data.table</code>-centric way of merging two <code>data.table</code>s, see
<code><a href="#topic++5B.data.table">[.data.table</a></code>; e.g., <code>x[y, ...]</code>. See FAQ 1.11 for a detailed
comparison of <code>merge</code> and <code>x[y, ...]</code>.
</p>


<h3>Value</h3>

<p>A new <code>data.table</code> based on the merged <code>data table</code>s, and sorted by the
columns set (or inferred for) the <code>by</code> argument if argument <code>sort</code> is
set to <code>TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+setkey">setkey</a></code>, <code><a href="#topic++5B.data.table">[.data.table</a></code>,
<code><a href="base.html#topic+merge.data.frame">merge.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(dt1 &lt;- data.table(A = letters[1:10], X = 1:10, key = "A"))
(dt2 &lt;- data.table(A = letters[5:14], Y = 1:10, key = "A"))
merge(dt1, dt2)
merge(dt1, dt2, all = TRUE)

(dt1 &lt;- data.table(A = letters[rep(1:3, 2)], X = 1:6, key = "A"))
(dt2 &lt;- data.table(A = letters[rep(2:4, 2)], Y = 6:1, key = "A"))
merge(dt1, dt2, allow.cartesian=TRUE)

(dt1 &lt;- data.table(A = c(rep(1L, 5), 2L), B = letters[rep(1:3, 2)], X = 1:6, key = "A,B"))
(dt2 &lt;- data.table(A = c(rep(1L, 5), 2L), B = letters[rep(2:4, 2)], Y = 6:1, key = "A,B"))
merge(dt1, dt2)
merge(dt1, dt2, by="B", allow.cartesian=TRUE)

# test it more:
d1 &lt;- data.table(a=rep(1:2,each=3), b=1:6, key="a,b")
d2 &lt;- data.table(a=0:1, bb=10:11, key="a")
d3 &lt;- data.table(a=0:1, key="a")
d4 &lt;- data.table(a=0:1, b=0:1, key="a,b")

merge(d1, d2)
merge(d2, d1)
merge(d1, d2, all=TRUE)
merge(d2, d1, all=TRUE)

merge(d3, d1)
merge(d1, d3)
merge(d1, d3, all=TRUE)
merge(d3, d1, all=TRUE)

merge(d1, d4)
merge(d1, d4, by="a", suffixes=c(".d1", ".d4"))
merge(d4, d1)
merge(d1, d4, all=TRUE)
merge(d4, d1, all=TRUE)

# setkey is automatic by default
set.seed(1L)
d1 &lt;- data.table(a=sample(rep(1:3,each=2)), z=1:6)
d2 &lt;- data.table(a=2:0, z=10:12)
merge(d1, d2, by="a")
merge(d1, d2, by="a", all=TRUE)

# using by.x and by.y
setnames(d2, "a", "b")
merge(d1, d2, by.x="a", by.y="b")
merge(d1, d2, by.x="a", by.y="b", all=TRUE)
merge(d2, d1, by.x="b", by.y="a")

# using incomparables values
d1 &lt;- data.table(a=c(1,2,NA,NA,3,1), z=1:6)
d2 &lt;- data.table(a=c(1,2,NA), z=10:12)
merge(d1, d2, by="a")
merge(d1, d2, by="a", incomparables=NA)
</code></pre>

<hr>
<h2 id='na.omit.data.table'> Remove rows with missing values on columns specified </h2><span id='topic+na.omit.data.table'></span><span id='topic+na.omit'></span>

<h3>Description</h3>

<p>This is a <code>data.table</code> method for the S3 generic <code>stats::na.omit</code>. The internals are written in C for speed. See examples for benchmark timings.
</p>
<p><code>bit64::integer64</code> type is also supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.table'
na.omit(object, cols=seq_along(object), invert=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.omit.data.table_+3A_object">object</code></td>
<td>
<p> A <code>data.table</code>. </p>
</td></tr>
<tr><td><code id="na.omit.data.table_+3A_cols">cols</code></td>
<td>
<p> A vector of column names (or numbers) on which to check for missing values. Default is all the columns. </p>
</td></tr>
<tr><td><code id="na.omit.data.table_+3A_invert">invert</code></td>
<td>
<p> logical. If <code>FALSE</code> omits all rows with any missing values (default). <code>TRUE</code> returns just those rows with missing values instead. </p>
</td></tr>
<tr><td><code id="na.omit.data.table_+3A_...">...</code></td>
<td>
<p> Further arguments special methods could require. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>data.table</code> method consists of an additional argument <code>cols</code>, which when specified looks for missing values in just those columns specified. The default value for <code>cols</code> is all the columns, to be consistent with the default behaviour of <code>stats::na.omit</code>.
</p>
<p>It does not add the attribute <code>na.action</code> as <code>stats::na.omit</code> does.
</p>


<h3>Value</h3>

<p>A data.table with just the rows where the specified columns have no missing value in any of them.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DT = data.table(x=c(1,NaN,NA,3), y=c(NA_integer_, 1:3), z=c("a", NA_character_, "b", "c"))
# default behaviour
na.omit(DT)
# omit rows where 'x' has a missing value
na.omit(DT, cols="x")
# omit rows where either 'x' or 'y' have missing values
na.omit(DT, cols=c("x", "y"))

## Not run: 
# Timings on relatively large data
set.seed(1L)
DT = data.table(x = sample(c(1:100, NA_integer_), 5e7L, TRUE),
                y = sample(c(rnorm(100), NA), 5e7L, TRUE))
system.time(ans1 &lt;- na.omit(DT)) ## 2.6 seconds
system.time(ans2 &lt;- stats:::na.omit.data.frame(DT)) ## 29 seconds
# identical? check each column separately, as ans2 will have additional attribute
all(sapply(1:2, function(i) identical(ans1[[i]], ans2[[i]]))) ## TRUE

## End(Not run)
</code></pre>

<hr>
<h2 id='nafill'>Fill missing values</h2><span id='topic+nafill'></span><span id='topic+fill'></span><span id='topic+setnafill'></span><span id='topic+locf'></span><span id='topic+nocb'></span><span id='topic+na.fill'></span>

<h3>Description</h3>

<p>Fast fill missing values using constant value, <em>last observation carried forward</em> or <em>next observation carried backward</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nafill(x, type=c("const","locf","nocb"), fill=NA, nan=NA)
setnafill(x, type=c("const","locf","nocb"), fill=NA, nan=NA, cols=seq_along(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nafill_+3A_x">x</code></td>
<td>
<p> vector, list, data.frame or data.table of numeric columns. </p>
</td></tr>
<tr><td><code id="nafill_+3A_type">type</code></td>
<td>
<p> character, one of <em>&quot;const&quot;</em>, <em>&quot;locf&quot;</em> or <em>&quot;nocb&quot;</em>. Defaults to <code>"const"</code>. </p>
</td></tr>
<tr><td><code id="nafill_+3A_fill">fill</code></td>
<td>
<p> numeric or integer, value to be used to fill. </p>
</td></tr>
<tr><td><code id="nafill_+3A_nan">nan</code></td>
<td>
<p> (numeric <code>x</code> only) Either <code>NaN</code> or <code>NA</code>; if the former, <code>NaN</code> is treated as distinct from <code>NA</code>, otherwise, they are treated the same during replacement? </p>
</td></tr>
<tr><td><code id="nafill_+3A_cols">cols</code></td>
<td>
<p> numeric or character vector specifying columns to be updated. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only <em>double</em> and <em>integer</em> data types are currently supported.
</p>
<p>Note that both <code>nafill</code> and <code>setnafill</code> provide some verbose output when <code>getOption('datatable.verbose')</code> is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A list except when the input is a <code>vector</code> in which case a <code>vector</code> is returned. For <code>setnafill</code> the input argument is returned, updated by reference.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shift">shift</a></code>, <code><a href="#topic+data.table">data.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = 1:10
x[c(1:2, 5:6, 9:10)] = NA
nafill(x, "locf")

dt = data.table(v1=x, v2=shift(x)/2, v3=shift(x, -1L)/2)
nafill(dt, "nocb")

setnafill(dt, "locf", cols=c("v2","v3"))
dt
</code></pre>

<hr>
<h2 id='notin'>
Convenience operator for checking if an example is not in a set of elements
</h2><span id='topic++25notin+25'></span>

<h3>Description</h3>

<p>Check whether an object is absent from a table, i.e., the logical inverse of <code><a href="base.html#topic+base">in</a></code>. See examples on how missing values are being handled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %notin% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="notin_+3A_x">x</code></td>
<td>
<p> Vector or <code>NULL</code>: the values to be matched. </p>
</td></tr>
<tr><td><code id="notin_+3A_table">table</code></td>
<td>
<p> Vector or <code>NULL</code>: the values to be matched against. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector, <code>TRUE</code> for each element of <code>x</code> <em>absent</em> from <code>table</code>, and <code>FALSE</code> for each element of <code>x</code> <em>present</em> in <code>table</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+match">match</a></code>, <code><a href="#topic+chmatch">chmatch</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  11 %notin% 1:10 # TRUE
  "a" %notin% c("a", "b") # FALSE

  ## NAs on the LHS
  NA %in% 1:2
  NA %notin% 1:2
  ## NAs on the RHS
  NA %in% c(1:2,NA)
  NA %notin% c(1:2,NA)
</code></pre>

<hr>
<h2 id='patterns'>Obtain matching indices corresponding to patterns</h2><span id='topic+patterns'></span>

<h3>Description</h3>

<p><code>patterns</code> returns the matching indices in the argument <code>cols</code>
corresponding to the regular expression patterns provided. The patterns must be
supported by <code><a href="base.html#topic+grep">grep</a></code>.
</p>
<p>From <code>v1.9.6</code>, <code><a href="#topic+melt.data.table">melt.data.table</a></code> has an enhanced functionality
in which <code>measure.vars</code> argument can accept a <em>list of column names</em>
and melt them into separate columns. See the <code>Efficient reshaping using
data.tables</code> vignette linked below to learn more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patterns(..., cols=character(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patterns_+3A_...">...</code></td>
<td>
<p>A set of regular expression patterns.</p>
</td></tr>
<tr><td><code id="patterns_+3A_cols">cols</code></td>
<td>
<p>A character vector of names to which each pattern is matched.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+melt">melt</a></code>,
<a href="https://github.com/Rdatatable/data.table/wiki/Getting-started">https://github.com/Rdatatable/data.table/wiki/Getting-started</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DT = data.table(x1 = 1:5, x2 = 6:10, y1 = letters[1:5], y2 = letters[6:10])
# melt all columns that begin with 'x' &amp; 'y', respectively, into separate columns
melt(DT, measure.vars = patterns("^x", "^y", cols=names(DT)))
# when used with melt, 'cols' is implicitly assumed to be names of input
# data.table, if not provided.
melt(DT, measure.vars = patterns("^x", "^y"))
</code></pre>

<hr>
<h2 id='print.data.table'> data.table Printing Options </h2><span id='topic+print.data.table'></span><span id='topic+format_col'></span><span id='topic+format_col.default'></span><span id='topic+format_col.POSIXct'></span><span id='topic+format_col.expression'></span><span id='topic+format_list_item'></span><span id='topic+format_list_item.default'></span>

<h3>Description</h3>

<p><code>print.data.table</code> extends the functionalities of <code>print.data.frame</code>.
</p>
<p>Key enhancements include automatic output compression of many observations and concise column-wise <code>class</code> summary.
</p>
<p><code>format_col</code> and <code>format_list_item</code> generics provide flexibility for end-users to define custom printing methods for generic classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'data.table'
print(x,
    topn=getOption("datatable.print.topn"),             # default: 5
    nrows=getOption("datatable.print.nrows"),           # default: 100
    class=getOption("datatable.print.class"),           # default: TRUE
    row.names=getOption("datatable.print.rownames"),    # default: TRUE
    col.names=getOption("datatable.print.colnames"),    # default: "auto"
    print.keys=getOption("datatable.print.keys"),       # default: TRUE
    trunc.cols=getOption("datatable.print.trunc.cols"), # default: FALSE
    quote=FALSE,
    timezone=FALSE, ...)

  format_col(x, ...)
  ## Default S3 method:
format_col(x, ...)
  ## S3 method for class 'POSIXct'
format_col(x, ..., timezone=FALSE)
  ## S3 method for class 'expression'
format_col(x, ...)

  format_list_item(x, ...)
  ## Default S3 method:
format_list_item(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.data.table_+3A_x">x</code></td>
<td>
<p> A <code>data.table</code>. </p>
</td></tr>
<tr><td><code id="print.data.table_+3A_topn">topn</code></td>
<td>
<p> The number of rows to be printed from the beginning and end of tables with more than <code>nrows</code> rows. </p>
</td></tr>
<tr><td><code id="print.data.table_+3A_nrows">nrows</code></td>
<td>
<p> The number of rows which will be printed before truncation is enforced. </p>
</td></tr>
<tr><td><code id="print.data.table_+3A_class">class</code></td>
<td>
<p> If <code>TRUE</code>, the resulting output will include above each column its storage class (or a self-evident abbreviation thereof). </p>
</td></tr>
<tr><td><code id="print.data.table_+3A_row.names">row.names</code></td>
<td>
<p> If <code>TRUE</code>, row indices will be printed alongside <code>x</code>. </p>
</td></tr>
<tr><td><code id="print.data.table_+3A_col.names">col.names</code></td>
<td>
<p> One of three flavours for controlling the display of column names in output. <code>"auto"</code> includes column names above the data, as well as below the table if <code>nrow(x) &gt; 20</code>. <code>"top"</code> excludes this lower register when applicable, and <code>"none"</code> suppresses column names altogether (as well as column classes if <code>class = TRUE</code>. </p>
</td></tr>
<tr><td><code id="print.data.table_+3A_print.keys">print.keys</code></td>
<td>
<p> If <code>TRUE</code>, any <code><a href="#topic+key">key</a></code> and/or <code><a href="#topic+indices">index</a></code> currently assigned to <code>x</code> will be printed prior to the preview of the data. </p>
</td></tr>
<tr><td><code id="print.data.table_+3A_trunc.cols">trunc.cols</code></td>
<td>
<p> If <code>TRUE</code>, only the columns that can be printed in the console without wrapping the columns to new lines will be printed (similar to <code>tibbles</code>). </p>
</td></tr>
<tr><td><code id="print.data.table_+3A_quote">quote</code></td>
<td>
<p> If <code>TRUE</code>, all output will appear in quotes, as in <code>print.default</code>. </p>
</td></tr>
<tr><td><code id="print.data.table_+3A_timezone">timezone</code></td>
<td>
<p> If <code>TRUE</code>, time columns of class POSIXct or POSIXlt will be printed with their timezones (if attribute is available). </p>
</td></tr>
<tr><td><code id="print.data.table_+3A_...">...</code></td>
<td>
<p> Other arguments ultimately passed to <code>format</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, with an eye to the typically large number of observations in a <code>data.table</code>, only the beginning and end of the object are displayed (specifically, <code>head(x, topn)</code> and <code>tail(x, topn)</code> are displayed unless <code>nrow(x) &lt; nrows</code>, in which case all rows will print).
</p>
<p><code>format_col</code> is applied at a column level; for example, <code>format_col.POSIXct</code> is used to tag the time zones of <code>POSIXct</code> columns. <code>format_list_item</code> is applied to the elements (rows) of <code>list</code> columns; see Examples. The default <code>format_col</code> method uses <code><a href="utils.html#topic+getS3method">getS3method</a></code> to test if a <code>format</code> method exists for the column, and if so uses it. Otherwise, the default <code>format_list_item</code> method uses the S3 format method (if one exists) for each item of a <code>list</code> column.
</p>


<h3>Value</h3>

<p><code>print.data.table</code> returns <code>x</code> invisibly.
</p>
<p><code>format_col</code> returns a <code>length(x)</code>-size <code>character</code> vector.
</p>
<p><code>format_list_item</code> returns a length-1 <code>character</code> scalar.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print.default">print.default</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  #output compression
  DT &lt;- data.table(a = 1:1000)
  print(DT, nrows = 100, topn = 4)

  #`quote` can be used to identify whitespace
  DT &lt;- data.table(blanks = c(" 12", " 34"),
                   noblanks = c("12", "34"))
  print(DT, quote = TRUE)

  #`class` provides handy column type summaries at a glance
  DT &lt;- data.table(a = vector("integer", 3),
                   b = vector("complex", 3),
                   c = as.IDate(paste0("2016-02-0", 1:3)))
  print(DT, class = TRUE)

  #`row.names` can be eliminated to save space
  DT &lt;- data.table(a = 1:3)
  print(DT, row.names = FALSE)

  #`print.keys` can alert which columns are currently keys
  DT &lt;- data.table(a=1:3, b=4:6, c=7:9, key="b,a")
  setindexv(DT, c("a", "b"))
  setindexv(DT, "a")
  print(DT, print.keys=TRUE)

  # `trunc.cols` will make it so only columns that fit in console will be printed
  #    with a message that states the variables not shown
  old_width = options("width" = 40)
  DT &lt;- data.table(thing_11 = vector("integer", 3),
                   thing_21 = vector("complex", 3),
                   thing_31 = as.IDate(paste0("2016-02-0", 1:3)),
                   thing_41 = "aasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf",
                   thing_51 = vector("integer", 3),
                   thing_61 = vector("complex", 3))
  print(DT, trunc.cols=TRUE)
  options(old_width)

  # Formatting customization
  format_col.complex = function(x, ...) sprintf('(%.1f, %.1fi)', Re(x), Im(x))
  x = data.table(z = c(1 + 3i, 2 - 1i, pi + 2.718i))
  print(x)

  iris = as.data.table(iris)
  iris_agg = iris[ , .(reg = list(lm(Sepal.Length ~ Petal.Length))), by = Species]
  format_list_item.lm = function(x, ...) sprintf('&lt;lm:%s&gt;', format(x$call$formula))
  print(iris_agg)
</code></pre>

<hr>
<h2 id='rbindlist'> Makes one data.table from a list of many </h2><span id='topic+rbindlist'></span><span id='topic+rbind.data.table'></span><span id='topic+rbind'></span>

<h3>Description</h3>

<p>Same as <code>do.call("rbind", l)</code> on <code>data.frame</code>s, but much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbindlist(l, use.names="check", fill=FALSE, idcol=NULL)
# rbind(..., use.names=TRUE, fill=FALSE, idcol=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbindlist_+3A_l">l</code></td>
<td>
<p> A list containing <code>data.table</code>, <code>data.frame</code> or <code>list</code> objects. <code>...</code> is the same but you pass the objects by name separately. </p>
</td></tr>
<tr><td><code id="rbindlist_+3A_use.names">use.names</code></td>
<td>
<p><code>TRUE</code> binds by matching column name, <code>FALSE</code> by position. &lsquo;check' (default) warns if all items don&rsquo;t have the same names in the same order and then currently proceeds as if 'use.names=FALSE' for backwards compatibility (<code>TRUE</code> in future); see news for v1.12.2.</p>
</td></tr>
<tr><td><code id="rbindlist_+3A_fill">fill</code></td>
<td>
<p><code>TRUE</code> fills missing columns with NAs. By default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rbindlist_+3A_idcol">idcol</code></td>
<td>
<p>Creates a column in the result showing which list item those rows came from. <code>TRUE</code> names this column <code>".id"</code>. <code>idcol="file"</code> names this column <code>"file"</code>. If the input list has names, those names are the values placed in this id column, otherwise the values are an integer vector <code>1:length(l)</code>. See <code>examples</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each item of <code>l</code> can be a <code>data.table</code>, <code>data.frame</code> or <code>list</code>, including <code>NULL</code> (skipped) or an empty object (0 rows). <code>rbindlist</code> is most useful when there are an unknown number of (potentially many) objects to stack, such as returned by <code>lapply(fileNames, fread)</code>. <code>rbind</code> is most useful to stack two or three objects which you know in advance. <code>...</code> should contain at least one <code>data.table</code> for <code>rbind(...)</code> to call the fast method and return a <code>data.table</code>, whereas <code>rbindlist(l)</code> always returns a <code>data.table</code> even when stacking a plain <code>list</code> with a <code>data.frame</code>, for example.
</p>
<p>Columns with duplicate names are bound in the order of occurrence, similar to base. The position (column number) that each duplicate name occurs is also retained.
</p>
<p>If column <code>i</code> does not have the same type in each of the list items; e.g, the column is <code>integer</code> in item 1 while others are <code>numeric</code>, they are coerced to the highest type.
</p>
<p>If a column contains factors then a factor is created. If any of the factors are also ordered factors then the longest set of ordered levels are found (the first if this is tied). Then the ordered levels from each list item are checked to be an ordered subset of these longest levels. If any ambiguities are found (e.g. <code>blue&lt;green</code> vs <code>green&lt;blue</code>), or any ordered levels are missing from the longest, then a regular factor is created with warning. Any strings in regular factor and character columns which are missing from the longest ordered levels are added at the end.
</p>


<h3>Value</h3>

<p>An unkeyed <code>data.table</code> containing a concatenation of all the items passed in.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+split.data.table">split.data.table</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># default case
DT1 = data.table(A=1:3,B=letters[1:3])
DT2 = data.table(A=4:5,B=letters[4:5])
l = list(DT1,DT2)
rbindlist(l)

# bind correctly by names
DT1 = data.table(A=1:3,B=letters[1:3])
DT2 = data.table(B=letters[4:5],A=4:5)
l = list(DT1,DT2)
rbindlist(l, use.names=TRUE)

# fill missing columns, and match by col names
DT1 = data.table(A=1:3,B=letters[1:3])
DT2 = data.table(B=letters[4:5],C=factor(1:2))
l = list(DT1,DT2)
rbindlist(l, use.names=TRUE, fill=TRUE)

# generate index column, auto generates indices
rbindlist(l, use.names=TRUE, fill=TRUE, idcol=TRUE)
# let's name the list
setattr(l, 'names', c("a", "b"))
rbindlist(l, use.names=TRUE, fill=TRUE, idcol="ID")

</code></pre>

<hr>
<h2 id='rleid'>Generate run-length type group id</h2><span id='topic+rleid'></span><span id='topic+rleidv'></span>

<h3>Description</h3>

<p>A convenience function for generating a <em>run-length</em> type <em>id</em> column to be used in grouping operations. It accepts atomic vectors, lists, data.frames or data.tables as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rleid(..., prefix=NULL)
rleidv(x, cols=seq_along(x), prefix=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rleid_+3A_x">x</code></td>
<td>
<p> A vector, list, data.frame or data.table. </p>
</td></tr>
<tr><td><code id="rleid_+3A_...">...</code></td>
<td>
<p> A sequence of numeric, integer64, character or logical vectors, all of same length. For interactive use.</p>
</td></tr>
<tr><td><code id="rleid_+3A_cols">cols</code></td>
<td>
<p> Only meaningful for lists, data.frames or data.tables. A character vector of column names (or numbers) of x. </p>
</td></tr>
<tr><td><code id="rleid_+3A_prefix">prefix</code></td>
<td>
<p> Either <code>NULL</code> (default) or a character vector of length=1 which is prefixed to the row ids, returning a character vector (instead of an integer vector).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At times aggregation (or grouping) operations need to be performed where consecutive runs of identical values should belong to the same group (See <code><a href="base.html#topic+rle">rle</a></code>). The use for such a function has come up repeatedly on StackOverflow, see the <code>See Also</code> section. This function allows to generate &quot;run-length&quot; groups directly.
</p>
<p><code>rleid</code> is designed for interactive use and accepts a sequence of vectors as arguments. For programming, <code>rleidv</code> might be more useful.
</p>


<h3>Value</h3>

<p>When <code>prefix = NULL</code>, an integer vector with same length as <code>NROW(x)</code>, else a character vector with the value in <code>prefix</code> prefixed to the ids obtained.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+rowid">rowid</a></code>, <a href="https://stackoverflow.com/q/21421047/559784">https://stackoverflow.com/q/21421047/559784</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DT = data.table(grp=rep(c("A", "B", "C", "A", "B"), c(2,2,3,1,2)), value=1:10)
rleid(DT$grp) # get run-length ids
rleidv(DT, "grp") # same as above

rleid(DT$grp, prefix="grp") # prefix with 'grp'

# get sum of value over run-length groups
DT[, sum(value), by=.(grp, rleid(grp))]
DT[, sum(value), by=.(grp, rleid(grp, prefix="grp"))]

</code></pre>

<hr>
<h2 id='roll'>Rolling functions</h2><span id='topic+roll'></span><span id='topic+froll'></span><span id='topic+rolling'></span><span id='topic+sliding'></span><span id='topic+moving'></span><span id='topic+rollmean'></span><span id='topic+frollmean'></span><span id='topic+rollsum'></span><span id='topic+frollsum'></span><span id='topic+rollapply'></span><span id='topic+frollapply'></span>

<h3>Description</h3>

<p>Fast rolling functions to calculate aggregates on sliding windows. Function name and arguments are experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frollmean(x, n, fill=NA, algo=c("fast", "exact"),
          align=c("right", "left", "center"), na.rm=FALSE, hasNA=NA, adaptive=FALSE)
frollsum(x, n, fill=NA, algo=c("fast","exact"),
         align=c("right", "left", "center"), na.rm=FALSE, hasNA=NA, adaptive=FALSE)
frollapply(x, n, FUN, ..., fill=NA, align=c("right", "left", "center"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_+3A_x">x</code></td>
<td>
<p> Vector, <code>data.frame</code> or <code>data.table</code> of integer, numeric or logical columns over which to calculate the windowed aggregations. May also be a list, in which case the rolling function is applied to each of its elements. </p>
</td></tr>
<tr><td><code id="roll_+3A_n">n</code></td>
<td>
<p> Integer vector giving rolling window size(s). This is the <em>total</em> number of included values. Adaptive rolling functions also accept a list of integer vectors. </p>
</td></tr>
<tr><td><code id="roll_+3A_fill">fill</code></td>
<td>
<p> Numeric; value to pad by. Defaults to <code>NA</code>. </p>
</td></tr>
<tr><td><code id="roll_+3A_algo">algo</code></td>
<td>
<p> Character, default <code>"fast"</code>. When set to <code>"exact"</code>, a slower (but more accurate) algorithm is used. It
suffers less from floating point rounding errors by performing an extra pass, and carefully handles all non-finite values.
It will use mutiple cores where available. See Details for more information. </p>
</td></tr>
<tr><td><code id="roll_+3A_align">align</code></td>
<td>
<p> Character, specifying the &quot;alignment&quot; of the rolling window, defaulting to <code>"right"</code>. <code>"right"</code> covers preceding rows (the window <em>ends</em> on the current value); <code>"left"</code> covers following rows (the window <em>starts</em> on the current value); <code>"center"</code> is halfway in between (the window is <em>centered</em> on the current value, biased towards <code>"left"</code> when <code>n</code> is even). </p>
</td></tr>
<tr><td><code id="roll_+3A_na.rm">na.rm</code></td>
<td>
<p> Logical, default <code>FALSE</code>. Should missing values be removed when
calculating window? For details on handling other non-finite values, see Details. </p>
</td></tr>
<tr><td><code id="roll_+3A_hasna">hasNA</code></td>
<td>
<p> Logical. If it is known that <code>x</code> contains <code>NA</code>
then setting this to <code>TRUE</code> will speed up calculation. Defaults to <code>NA</code>. </p>
</td></tr>
<tr><td><code id="roll_+3A_adaptive">adaptive</code></td>
<td>
<p> Logical, default <code>FALSE</code>. Should the rolling function be calculated adaptively? See Details below. </p>
</td></tr>
<tr><td><code id="roll_+3A_fun">FUN</code></td>
<td>
<p> The function to be applied to the rolling window; see Details for restrictions. </p>
</td></tr>
<tr><td><code id="roll_+3A_...">...</code></td>
<td>
<p> Extra arguments passed to <code>FUN</code> in <code>frollapply</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>froll*</code> functions accept vectors, lists, <code>data.frame</code>s or
<code>data.table</code>s. They always return a list except when the input is a
<code>vector</code> and <code>length(n)==1</code>, in which case a <code>vector</code>
is returned, for convenience. Thus, rolling functions can be used
conveniently within <code>data.table</code> syntax.
</p>
<p>Argument <code>n</code> allows multiple values to apply rolling functions on
multiple window sizes. If <code>adaptive=TRUE</code>, then <code>n</code> must be a list.
Each list element must be integer vector of window sizes corresponding
to every single observation in each column; see Examples.
</p>
<p>When <code>algo="fast"</code> an <em>&quot;on-line&quot;</em> algorithm is used, and
all of <code>NaN, +Inf, -Inf</code> are treated as <code>NA</code>.
Setting <code>algo="exact"</code> will make rolling functions to use a more
computationally-intensive algorithm that suffers less from floating point
rounding error (the same consideration applies to <code><a href="base.html#topic+mean">mean</a></code>).
<code>algo="exact"</code> also handles <code>NaN, +Inf, -Inf</code> consistently to
base R. In case of some functions (like <em>mean</em>), it will additionally
make extra pass to perform floating point error correction. Error
corrections might not be truly exact on some platforms (like Windows)
when using multiple threads.
</p>
<p>Adaptive rolling functions are a special case where each
observation has its own corresponding rolling window width. Due to the logic
of adaptive rolling functions, the following restrictions apply:
</p>

<ul>
<li> <p><code>align</code> only <code>"right"</code>. 
</p>
</li>
<li><p> if list of vectors is passed to <code>x</code>, then all
vectors within it must have equal length.
</p>
</li></ul>

<p>When multiple columns or multiple windows width are provided, then they
are run in parallel. The exception is for <code>algo="exact"</code>, which runs in
parallel already.
</p>
<p><code>frollapply</code> computes rolling aggregate on arbitrary R functions.
The input <code>x</code> (first argument) to the function <code>FUN</code>
is coerced to <em>numeric</em> beforehand and <code>FUN</code>
has to return a scalar <em>numeric</em> value. Checks for that are made only
during the first iteration when <code>FUN</code> is evaluated. Edge cases can be
found in examples below. Any R function is supported, but it is not optimized
using our own C implementation &ndash; hence, for example, using <code>frollapply</code>
to compute a rolling average is inefficient. It is also always single-threaded
because there is no thread-safe API to R's C <code>eval</code>. Nevertheless we've
seen the computation speed up vis-a-vis versions implemented in base R.
</p>


<h3>Value</h3>

<p>A list except when the input is a <code>vector</code> and
<code>length(n)==1</code> in which case a <code>vector</code> is returned.
</p>


<h3>Note</h3>

<p>Users coming from most popular package for rolling functions
<code>zoo</code> might expect following differences in <code>data.table</code>
implementation.
</p>

<ul>
<li><p> rolling function will always return result of the same length as input.
</p>
</li>
<li> <p><code>fill</code> defaults to <code>NA</code>. 
</p>
</li>
<li> <p><code>fill</code> accepts only constant values. It does not support
for <em>na.locf</em> or other functions.
</p>
</li>
<li> <p><code>align</code> defaults to <code>"right"</code>. 
</p>
</li>
<li> <p><code>na.rm</code> is respected, and other functions are not needed
when input contains <code>NA</code>.
</p>
</li>
<li><p> integers and logical are always coerced to double. 
</p>
</li>
<li><p> when <code>adaptive=FALSE</code> (default), then <code>n</code> must be a
numeric vector. List is not accepted.
</p>
</li>
<li><p> when <code>adaptive=TRUE</code>, then <code>n</code> must be vector of
length equal to <code>nrow(x)</code>, or list of such vectors.
</p>
</li>
<li> <p><code>partial</code> window feature is not supported, although it can
be accomplished by using <code>adaptive=TRUE</code>, see
examples. <code>NA</code> is always returned for incomplete windows. 
</p>
</li></ul>

<p>Be aware that rolling functions operates on the physical order of input.
If the intent is to roll values in a vector by a logical window, for
example an hour, or a day, one has to ensure that there are no gaps in
input. For details see <a href="https://github.com/Rdatatable/data.table/issues/3241">issue #3241</a>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Round-off_error">Round-off error</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shift">shift</a></code>, <code><a href="#topic+data.table">data.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d = as.data.table(list(1:6/2, 3:8/4))
# rollmean of single vector and single window
frollmean(d[, V1], 3)
# multiple columns at once
frollmean(d, 3)
# multiple windows at once
frollmean(d[, .(V1)], c(3, 4))
# multiple columns and multiple windows at once
frollmean(d, c(3, 4))
## three calls above will use multiple cores when available

# partial window using adaptive rolling function
an = function(n, len) c(seq.int(n), rep(n, len-n))
n = an(3, nrow(d))
frollmean(d, n, adaptive=TRUE)

# frollsum
frollsum(d, 3:4)

# frollapply
frollapply(d, 3:4, sum)
f = function(x, ...) if (sum(x, ...)&gt;5) min(x, ...) else max(x, ...)
frollapply(d, 3:4, f, na.rm=TRUE)

# performance vs exactness
set.seed(108)
x = sample(c(rnorm(1e3, 1e6, 5e5), 5e9, 5e-9))
n = 15
ma = function(x, n, na.rm=FALSE) {
  ans = rep(NA_real_, nx&lt;-length(x))
  for (i in n:nx) ans[i] = mean(x[(i-n+1):i], na.rm=na.rm)
  ans
}
fastma = function(x, n, na.rm) {
  if (!missing(na.rm)) stop("NAs are unsupported, wrongly propagated by cumsum")
  cs = cumsum(x)
  scs = shift(cs, n)
  scs[n] = 0
  as.double((cs-scs)/n)
}
system.time(ans1&lt;-ma(x, n))
system.time(ans2&lt;-fastma(x, n))
system.time(ans3&lt;-frollmean(x, n))
system.time(ans4&lt;-frollmean(x, n, algo="exact"))
system.time(ans5&lt;-frollapply(x, n, mean))
anserr = list(
  fastma = ans2-ans1,
  froll_fast = ans3-ans1,
  froll_exact = ans4-ans1,
  frollapply = ans5-ans1
)
errs = sapply(lapply(anserr, abs), sum, na.rm=TRUE)
sapply(errs, format, scientific=FALSE) # roundoff

# frollapply corner cases
f = function(x) head(x, 2)     ## FUN returns non length 1
try(frollapply(1:5, 3, f))
f = function(x) {              ## FUN sometimes returns non length 1
  n = length(x)
  # length 1 will be returned only for first iteration where we check length
  if (n==x[n]) x[1L] else range(x) # range(x)[2L] is silently ignored!
}
frollapply(1:5, 3, f)
options(datatable.verbose=TRUE)
x = c(1,2,1,1,1,2,3,2)
frollapply(x, 3, uniqueN)     ## FUN returns integer
numUniqueN = function(x) as.numeric(uniqueN(x))
frollapply(x, 3, numUniqueN)
x = c(1,2,1,1,NA,2,NA,2)
frollapply(x, 3, anyNA)       ## FUN returns logical
as.logical(frollapply(x, 3, anyNA))
options(datatable.verbose=FALSE)
f = function(x) {             ## FUN returns character
  if (sum(x)&gt;5) "big" else "small"
}
try(frollapply(1:5, 3, f))
f = function(x) {             ## FUN is not type-stable
  n = length(x)
  # double type will be returned only for first iteration where we check type
  if (n==x[n]) 1 else NA # NA logical turns into garbage without coercion to double
}
try(frollapply(1:5, 3, f))
</code></pre>

<hr>
<h2 id='rowid'> Generate unique row ids within each group</h2><span id='topic+rowid'></span><span id='topic+rowidv'></span>

<h3>Description</h3>

<p>Convenience functions for generating a unique row ids within each group. It accepts atomic vectors, lists, data.frames or data.tables as input.
</p>
<p><code>rowid</code> is intended for interactive use, particularly along with the function <code>dcast</code> to generate unique ids directly in the formula.
</p>
<p><code>rowidv(DT, cols=c("x", "y"))</code> is equivalent to column <code>N</code> in the code <code>DT[, N := seq_len(.N), by=c("x", "y")]</code>.
</p>
<p>See examples for more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowid(..., prefix=NULL)
rowidv(x, cols=seq_along(x), prefix=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowid_+3A_x">x</code></td>
<td>
<p> A vector, list, data.frame or data.table. </p>
</td></tr>
<tr><td><code id="rowid_+3A_...">...</code></td>
<td>
<p> A sequence of numeric, integer64, character or logical vectors, all of same length. For interactive use.</p>
</td></tr>
<tr><td><code id="rowid_+3A_cols">cols</code></td>
<td>
<p> Only meaningful for lists, data.frames or data.tables. A character vector of column names (or numbers) of x. </p>
</td></tr>
<tr><td><code id="rowid_+3A_prefix">prefix</code></td>
<td>
<p> Either <code>NULL</code> (default) or a character vector of length=1 which is prefixed to the row ids, returning a character vector (instead of an integer vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>prefix = NULL</code>, an integer vector with same length as <code>NROW(x)</code>, else a character vector with the value in <code>prefix</code> prefixed to the ids obtained.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dcast.data.table">dcast.data.table</a></code>, <code><a href="#topic+rleid">rleid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DT = data.table(x=c(20,10,10,30,30,20), y=c("a", "a", "a", "b", "b", "b"), z=1:6)

rowid(DT$x) # 1,1,2,1,2,2
rowidv(DT, cols="x") # same as above

rowid(DT$x, prefix="group") # prefixed with 'group'

rowid(DT$x, DT$y) # 1,1,2,1,2,1
rowidv(DT, cols=c("x","y")) # same as above
DT[, .(N=seq_len(.N)), by=.(x,y)]$N # same as above

# convenient usage with dcast
dcast(DT, x ~ rowid(x, prefix="group"), value.var="z")
#     x group1 group2
# 1: 10      2      3
# 2: 20      1      6
# 3: 30      4      5
</code></pre>

<hr>
<h2 id='setattr'> Set attributes of objects by reference </h2><span id='topic+setattr'></span><span id='topic+setnames'></span>

<h3>Description</h3>

<p>In <code>data.table</code>, all <code>set*</code> functions change their input <em>by reference</em>. That is, no copy is made at all, other than temporary working memory which is as large as one column. The only other <code>data.table</code> operator that modifies input by reference is <code><a href="#topic++3A+3D">:=</a></code>. Check out the <code>See Also</code> section below for other <code>set*</code> function that <code>data.table</code> provides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setattr(x,name,value)
setnames(x,old,new,skip_absent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setattr_+3A_x">x</code></td>
<td>
 <p><code>setnames</code> accepts <code>data.frame</code> and <code>data.table</code>. <code>setattr</code> accepts any input; e.g, list, columns of a <code>data.frame</code> or <code>data.table</code>. </p>
</td></tr>
<tr><td><code id="setattr_+3A_name">name</code></td>
<td>
<p> The character attribute name. </p>
</td></tr>
<tr><td><code id="setattr_+3A_value">value</code></td>
<td>
<p> The value to assign to the attribute or <code>NULL</code> removes the attribute, if present. </p>
</td></tr>
<tr><td><code id="setattr_+3A_old">old</code></td>
<td>
<p> When <code>new</code> is provided, character names or numeric positions of column names to change. When <code>new</code> is not provided, a function or the new column names (i.e., it's implicitly treated as <code>new</code>; excluding <code>old</code> and explicitly naming <code>new</code> is equivalent). If a function, it will be called with the current column names and is supposed to return the new column names. The new column names must be the same length as the number of columns. See examples. </p>
</td></tr>
<tr><td><code id="setattr_+3A_new">new</code></td>
<td>
<p> Optional. It can be a function or the new column names. If a function, it will be called with <code>old</code> and expected to return the new column names. The new column names must be the same length as columns provided to <code>old</code> argument. </p>
</td></tr>
<tr><td><code id="setattr_+3A_skip_absent">skip_absent</code></td>
<td>
<p> Skip items in <code>old</code> that are missing (i.e. absent) in 'names(x)'. Default <code>FALSE</code> halts with error if any are missing. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>setnames</code> operates on <code>data.table</code> and <code>data.frame</code> not other types like <code>list</code> and <code>vector</code>. It can be used to change names <em>by name</em> with built-in checks and warnings (e.g., if any old names are missing or appear more than once).
</p>
<p><code>setattr</code> is a more general function that allows setting of any attribute to an object <em>by reference</em>.
</p>
<p>A very welcome change in R 3.1+ was that 'names&lt;-' and 'colnames&lt;-' no longer copy the <em>entire</em> object as they used to (up to 4 times), see examples below. They now take a shallow copy. The &lsquo;set*' functions in data.table are still useful because they don&rsquo;t even take a shallow copy. This allows changing names and attributes of a (usually very large) <code>data.table</code> in the global environment <em>from within functions</em>. Like a database.
</p>


<h3>Value</h3>

<p>The input is modified by reference, and returned (invisibly) so it can be used in compound statements; e.g., <code>setnames(DT,"V1", "Y")[, .N, by=Y]</code>. If you require a copy, take a copy first (using <code>DT2=copy(DT)</code>). See <code>?copy</code>.
</p>
<p>Note that <code>setattr</code> is also in package <code>bit</code>. Both packages merely expose R's internal <code>setAttrib</code> function at C level but differ in return value. <code>bit::setattr</code> returns <code>NULL</code> (invisibly) to remind you the function is used for its side effect. <code>data.table::setattr</code> returns the changed object (invisibly) for use in compound statements.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+setkey">setkey</a></code>, <code><a href="#topic+setorder">setorder</a></code>, <code><a href="#topic+setcolorder">setcolorder</a></code>, <code><a href="#topic+set">set</a></code>, <code><a href="#topic++3A+3D">:=</a></code>, <code><a href="#topic+setDT">setDT</a></code>, <code><a href="#topic+setDF">setDF</a></code>, <code><a href="#topic+copy">copy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
DT &lt;- data.table(a = 1, b = 2, d = 3)

old &lt;- c("a", "b", "c", "d")
new &lt;- c("A", "B", "C", "D")

setnames(DT, old, new, skip_absent = TRUE) # skips old[3] because "c" is not a column name of DT

DF = data.frame(a=1:2,b=3:4)       # base data.frame to demo copies and syntax
if (capabilities()["profmem"])     # usually memory profiling is available but just in case
  tracemem(DF)
colnames(DF)[1] &lt;- "A"             # 4 shallow copies (R &gt;= 3.1, was 4 deep copies before)
names(DF)[1] &lt;- "A"                # 3 shallow copies
names(DF) &lt;- c("A", "b")           # 1 shallow copy
`names&lt;-`(DF,c("A","b"))           # 1 shallow copy

DT = data.table(a=1:2,b=3:4,c=5:6) # compare to data.table
if (capabilities()["profmem"])
  tracemem(DT)                     # by reference, no deep or shallow copies
setnames(DT,"b","B")               # by name, no match() needed (warning if "b" is missing)
setnames(DT,3,"C")                 # by position with warning if 3 &gt; ncol(DT)
setnames(DT,2:3,c("D","E"))        # multiple
setnames(DT,c("a","E"),c("A","F")) # multiple by name (warning if either "a" or "E" is missing)
setnames(DT,c("X","Y","Z"))        # replace all (length of names must be == ncol(DT))
setnames(DT,tolower)               # replace all names with their lower case
setnames(DT,2:3,toupper)           # replace the 2nd and 3rd names with their upper case

DT &lt;- data.table(x = 1:3, y = 4:6, z = 7:9)
setnames(DT, -2, c("a", "b"))      # NEW FR #1443, allows -ve indices in 'old' argument

DT = data.table(a=1:3, b=4:6)
f = function(...) {
    # ...
    setattr(DT,"myFlag",TRUE)  # by reference
    # ...
    localDT = copy(DT)
    setattr(localDT,"myFlag2",TRUE)
    # ...
    invisible()
}
f()
attr(DT,"myFlag")   # TRUE
attr(DT,"myFlag2")  # NULL

</code></pre>

<hr>
<h2 id='setcolorder'>Fast column reordering of a data.table by reference</h2><span id='topic+setcolorder'></span>

<h3>Description</h3>

<p>In <code>data.table</code> parlance, all <code>set*</code> functions change their input <em>by reference</em>. That is, no copy is made at all, other than temporary working memory, which is as large as one column. The only other <code>data.table</code> operator that modifies input by reference is <code><a href="#topic++3A+3D">:=</a></code>. Check out the <code>See Also</code> section below for other <code>set*</code> function <code>data.table</code> provides.
</p>
<p><code>setcolorder</code> reorders the columns of data.table, <em>by reference</em>, to the new order provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setcolorder(x, neworder=key(x), before=NULL, after=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setcolorder_+3A_x">x</code></td>
<td>
<p> A <code>data.table</code>. </p>
</td></tr>
<tr><td><code id="setcolorder_+3A_neworder">neworder</code></td>
<td>
<p> Character vector of the new column name ordering. May also be column numbers. If <code>length(neworder) &lt; length(x)</code>, the specified columns are moved in order to the &quot;front&quot; of <code>x</code>. By default, <code>setcolorder</code> without a specified <code>neworder</code> moves the key columns in order to the &quot;front&quot; of <code>x</code>. </p>
</td></tr>
<tr><td><code id="setcolorder_+3A_before">before</code>, <code id="setcolorder_+3A_after">after</code></td>
<td>
<p> If one of them (not both) was provided with a column name or number, <code>neworder</code> will be inserted before or after that column. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>To reorder <code>data.table</code> columns, the idiomatic way is to use <code>setcolorder(x, neworder)</code>, instead of doing <code>x &lt;- x[, ..neworder]</code> (or <code>x &lt;- x[, neworder, with=FALSE]</code>). This is because the latter makes an entire copy of the <code>data.table</code>, which maybe unnecessary in most situations. <code>setcolorder</code> also allows column numbers instead of names for <code>neworder</code> argument, although we recommend using names as a good programming practice.
</p>


<h3>Value</h3>

<p>The input is modified by reference, and returned (invisibly) so it can be used in compound statements. If you require a copy, take a copy first (using <code>DT2 = copy(DT)</code>). See <code>?copy</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+setkey">setkey</a></code>, <code><a href="#topic+setorder">setorder</a></code>, <code><a href="#topic+setattr">setattr</a></code>, <code><a href="#topic+setnames">setnames</a></code>, <code><a href="#topic+set">set</a></code>, <code><a href="#topic++3A+3D">:=</a></code>, <code><a href="#topic+setDT">setDT</a></code>, <code><a href="#topic+setDF">setDF</a></code>, <code><a href="#topic+copy">copy</a></code>, <code><a href="#topic+getNumericRounding">getNumericRounding</a></code>, <code><a href="#topic+setNumericRounding">setNumericRounding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(45L)
DT = data.table(A=sample(3, 10, TRUE),
         B=sample(letters[1:3], 10, TRUE), C=sample(10))

setcolorder(DT, c("C", "A", "B"))

#incomplete specification
setcolorder(DT, "A")

# insert new column as first column
set(DT, j="D", value=sample(10))
setcolorder(DT, "D", before=1)

# move column to last column place
setcolorder(DT, "A", after=ncol(DT))
</code></pre>

<hr>
<h2 id='setDF'>Coerce a data.table to data.frame by reference</h2><span id='topic+setDF'></span>

<h3>Description</h3>

<p>In <code>data.table</code> parlance, all <code>set*</code> functions change their input <em>by reference</em>. That is, no copy is made at all, other than temporary working memory, which is as large as one column. The only other <code>data.table</code> operator that modifies input by reference is <code><a href="#topic++3A+3D">:=</a></code>. Check out the <code>See Also</code> section below for other <code>set*</code> function <code>data.table</code> provides.
</p>
<p>A helper function to convert a <code>data.table</code> or <code>list</code> of equal length to <code>data.frame</code> by reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDF(x, rownames=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setDF_+3A_x">x</code></td>
<td>
<p> A <code>data.table</code>, <code>data.frame</code> or <code>list</code> of equal length. </p>
</td></tr>
<tr><td><code id="setDF_+3A_rownames">rownames</code></td>
<td>
<p> A <code>character</code> vector to assign as the row names of <code>x</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All <code>data.table</code> attributes including any keys and indices of the input data.table are stripped off.
</p>
<p>When using <code>rownames</code>, recall that the row names of a <code>data.frame</code> must be unique. By default, the assigned set of row names is simply the sequence 1, ..., <code>nrow(x)</code> (or <code>length(x)</code> for <code>list</code>s).
</p>


<h3>Value</h3>

<p>The input <code>data.table</code> is modified by reference to a <code>data.frame</code> and returned (invisibly). If you require a copy, take a copy first (using <code>DT2 = copy(DT)</code>). See <code>?copy</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+as.data.table">as.data.table</a></code>, <code><a href="#topic+setDT">setDT</a></code>, <code><a href="#topic+copy">copy</a></code>, <code><a href="#topic+setkey">setkey</a></code>, <code><a href="#topic+setcolorder">setcolorder</a></code>, <code><a href="#topic+setattr">setattr</a></code>, <code><a href="#topic+setnames">setnames</a></code>, <code><a href="#topic+set">set</a></code>, <code><a href="#topic++3A+3D">:=</a></code>, <code><a href="#topic+setorder">setorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = data.table(x=1:5, y=6:10)
## convert 'X' to data.frame, without any copy.
setDF(X)

X = data.table(x=1:5, y=6:10)
## idem, assigning row names
setDF(X, rownames = LETTERS[1:5])

X = list(x=1:5, y=6:10)
# X is converted to a data.frame without any copy.
setDF(X)
</code></pre>

<hr>
<h2 id='setDT'>Coerce lists and data.frames to data.table by reference</h2><span id='topic+setDT'></span>

<h3>Description</h3>

<p>In <code>data.table</code> parlance, all <code>set*</code> functions change their input <em>by reference</em>. That is, no copy is made at all, other than temporary working memory, which is as large as one column.. The only other <code>data.table</code> operator that modifies input by reference is <code><a href="#topic++3A+3D">:=</a></code>. Check out the <code>See Also</code> section below for other <code>set*</code> function <code>data.table</code> provides.
</p>
<p><code>setDT</code> converts lists (both named and unnamed) and data.frames to data.tables <em>by reference</em>. This feature was requested on <a href="https://stackoverflow.com/questions/20345022/convert-a-data-frame-to-a-data-table-without-copy">Stackoverflow</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDT(x, keep.rownames=FALSE, key=NULL, check.names=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setDT_+3A_x">x</code></td>
<td>
<p> A named or unnamed <code>list</code>, <code>data.frame</code> or <code>data.table</code>. </p>
</td></tr>
<tr><td><code id="setDT_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p> For <code>data.frame</code>s, <code>TRUE</code> retains the <code>data.frame</code>'s row names under a new column <code>rn</code>. <code>keep.rownames = "id"</code> names the column <code>"id"</code> instead. </p>
</td></tr> 
<tr><td><code id="setDT_+3A_key">key</code></td>
<td>
<p>Character vector of one or more column names which is passed to <code><a href="#topic+setkeyv">setkeyv</a></code>. It may be a single comma separated string such as <code>key="x,y,z"</code>, or a vector of names such as <code>key=c("x","y","z")</code>. </p>
</td></tr>
<tr><td><code id="setDT_+3A_check.names">check.names</code></td>
<td>
<p> Just as <code>check.names</code> in <code><a href="base.html#topic+data.frame">data.frame</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>When working on large <code>lists</code> or <code>data.frames</code>, it might be both time and memory consuming to convert them to a <code>data.table</code> using <code>as.data.table(.)</code>, as this will make a complete copy of the input object before to convert it to a <code>data.table</code>. The <code>setDT</code> function takes care of this issue by allowing to convert <code>lists</code> - both named and unnamed lists and <code>data.frames</code> <em>by reference</em> instead. That is, the input object is modified in place, no copy is being made.
</p>


<h3>Value</h3>

<p>The input is modified by reference, and returned (invisibly) so it can be used in compound statements; e.g., <code>setDT(X)[, sum(B), by=A]</code>. If you require a copy, take a copy first (using <code>DT2 = copy(DT)</code>). See <code>?copy</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+as.data.table">as.data.table</a></code>, <code><a href="#topic+setDF">setDF</a></code>, <code><a href="#topic+copy">copy</a></code>, <code><a href="#topic+setkey">setkey</a></code>, <code><a href="#topic+setcolorder">setcolorder</a></code>, <code><a href="#topic+setattr">setattr</a></code>, <code><a href="#topic+setnames">setnames</a></code>, <code><a href="#topic+set">set</a></code>, <code><a href="#topic++3A+3D">:=</a></code>, <code><a href="#topic+setorder">setorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(45L)
X = data.frame(A=sample(3, 10, TRUE),
         B=sample(letters[1:3], 10, TRUE),
         C=sample(10), stringsAsFactors=FALSE)

# Convert X to data.table by reference and
# get the frequency of each "A,B" combination
setDT(X)[, .N, by=.(A,B)]

# convert list to data.table
# autofill names
X = list(1:4, letters[1:4])
setDT(X)
# don't provide names
X = list(a=1:4, letters[1:4])
setDT(X, FALSE)

# setkey directly
X = list(a = 4:1, b=runif(4))
setDT(X, key="a")[]

# check.names argument
X = list(a=1:5, a=6:10)
setDT(X, check.names=TRUE)[]

</code></pre>

<hr>
<h2 id='setDTthreads'> Set or get number of threads that data.table should use </h2><span id='topic+setDTthreads'></span><span id='topic+getDTthreads'></span><span id='topic+openMP'></span><span id='topic+openmp'></span>

<h3>Description</h3>

<p>Set and get number of threads to be used in <code>data.table</code> functions that are parallelized with OpenMP. The number of threads is initialized when <code>data.table</code> is first loaded in the R session using optional environment variables. Thereafter, the number of threads may be changed by calling <code>setDTthreads</code>. If you change an environment variable using <code>Sys.setenv</code> you will need to call <code>setDTthreads</code> again to reread the environment variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  setDTthreads(threads = NULL, restore_after_fork = NULL, percent = NULL, throttle = NULL)
  getDTthreads(verbose = getOption("datatable.verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setDTthreads_+3A_threads">threads</code></td>
<td>
<p> NULL (default) rereads environment variables. 0 means to use all logical CPUs available. Otherwise a number &gt;= 1 </p>
</td></tr>
<tr><td><code id="setDTthreads_+3A_restore_after_fork">restore_after_fork</code></td>
<td>
<p> Should data.table be multi-threaded after a fork has completed? NULL leaves the current setting unchanged which by default is TRUE. See details below. </p>
</td></tr>
<tr><td><code id="setDTthreads_+3A_percent">percent</code></td>
<td>
<p> If provided it should be a number between 2 and 100; the percentage of logical CPUs to use. By default on startup, 50%. </p>
</td></tr>
<tr><td><code id="setDTthreads_+3A_throttle">throttle</code></td>
<td>
<p> 1024 (default) means that, roughly speaking, a single thread will be used when nrow(DT)&lt;=1024, 2 threads when nrow(DT)&lt;=2048, etc. The throttle is to speed up small data tasks (especially when repeated many times) by not incurring the overhead of managing multiple threads. Hence the number of threads is throttled (restricted) for small tasks. </p>
</td></tr>
<tr><td><code id="setDTthreads_+3A_verbose">verbose</code></td>
<td>
<p> Display the value of relevant OpenMP settings plus the <code>restore_after_fork</code> internal option. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data.table</code> automatically switches to single threaded mode upon fork (the mechanism used by <code>parallel::mclapply</code> and the foreach package). Otherwise, nested parallelism would very likely overload your CPUs and result in much slower execution. As <code>data.table</code> becomes more parallel internally, we expect explicit user parallelism to be needed less often. The <code>restore_after_fork</code> option controls what happens after the explicit fork parallelism completes. It needs to be at C level so it is not a regular R option using <code>options()</code>. By default <code>data.table</code> will be multi-threaded again; restoring the prior setting of <code>getDTthreads()</code>. But problems have been reported in the past on Mac with Intel OpenMP libraries whereas success has been reported on Linux. If you experience problems after fork, start a new R session and change the default behaviour by calling <code>setDTthreads(restore_after_fork=FALSE)</code> before retrying. Please raise issues on the data.table GitHub issues page.
</p>
<p>The number of logical CPUs is determined by the OpenMP function <code>omp_get_num_procs()</code> whose meaning may vary across platforms and OpenMP implementations. <code>setDTthreads()</code> will not allow more than this limit. Neither will it allow more than <code>omp_get_thread_limit()</code> nor the current value of <code>Sys.getenv("OMP_THREAD_LIMIT")</code>. Note that CRAN's daily test system (results for data.table <a href="https://cran.r-project.org/web/checks/check_results_data.table.html">here</a>) sets <code>OMP_THREAD_LIMIT</code> to 2 and should always be respected; e.g., if you have written a package that uses data.table and your package is to be released on CRAN, you should not change <code>OMP_THREAD_LIMIT</code> in your package to a value greater than 2.
</p>
<p>Some hardware allows CPUs to be removed and/or replaced while the server is running. If this happens, our understanding is that <code>omp_get_num_procs()</code> will reflect the new number of processors available. But if this happens after data.table started, <code>setDTthreads(...)</code> will need to be called again by you before data.table will reflect the change. If you have such hardware, please let us know your experience via GitHub issues / feature requests.
</p>
<p>Use <code>getDTthreads(verbose=TRUE)</code> to see the relevant environment variables, their values and the current number of threads data.table is using. For example, the environment variable <code>R_DATATABLE_NUM_PROCS_PERCENT</code> can be used to change the default number of logical CPUs from 50% to another value between 2 and 100. If you change these environment variables using 'Sys.setenv()' after data.table and/or OpenMP has initialized then you will need to call <code>setDTthreads(threads=NULL)</code> to reread their current values. <code>getDTthreads()</code> merely retrieves the internal value that was set by the last call to <code>setDTthreads()</code>. <code>setDTthreads(threads=NULL)</code> is called when data.table is first loaded and is not called again unless you call it.
</p>
<p><code>setDTthreads()</code> affects <code>data.table</code> only and does not change R itself or other packages using OpenMP. We have followed the advice of section 1.2.1.1 in the R-exts manual: &quot;... or, better, for the regions in your code as part of their specification... num_threads(nthreads)... That way you only control your own code and not that of other OpenMP users.&quot; Every parallel region in data.table contain a <code>num_threads(getDTthreads())</code> directive. This is mandated by a <code>grep</code> in data.table's quality control script.
</p>
<p><code>setDTthreads(0)</code> is the same as <code>setDTthreads(percent=100)</code>; i.e. use all logical CPUs, subject to <code>Sys.getenv("OMP_THREAD_LIMIT")</code>. Please note again that developers of CRAN packages should never change <code>OMP_THREAD_LIMIT</code> inside their package to a value greater than 2 as CRAN very strictly enforces limits on automated parallelism in packages.
</p>
<p>Internally parallelized code is used in the following places:
</p>

<ul>
<li><p>&lsquo;<span class="file">between.c</span>&rsquo; - <code><a href="#topic+between">between</a>()</code>
</p>
</li>
<li><p>&lsquo;<span class="file">cj.c</span>&rsquo; - <code><a href="#topic+CJ">CJ</a>()</code>
</p>
</li>
<li><p>&lsquo;<span class="file">coalesce.c</span>&rsquo; - <code><a href="#topic+fcoalesce">fcoalesce</a>()</code>
</p>
</li>
<li><p>&lsquo;<span class="file">fifelse.c</span>&rsquo; - <code><a href="#topic+fifelse">fifelse</a>()</code>
</p>
</li>
<li><p>&lsquo;<span class="file">fread.c</span>&rsquo; - <code><a href="#topic+fread">fread</a>()</code>
</p>
</li>
<li><p>&lsquo;<span class="file">forder.c</span>&rsquo;, &lsquo;<span class="file">fsort.c</span>&rsquo;, and &lsquo;<span class="file">reorder.c</span>&rsquo; - <code><a href="#topic+forder">forder</a>()</code> and related
</p>
</li>
<li><p>&lsquo;<span class="file">froll.c</span>&rsquo;, &lsquo;<span class="file">frolladaptive.c</span>&rsquo;, and &lsquo;<span class="file">frollR.c</span>&rsquo; - <code><a href="#topic+froll">froll</a>()</code> and family
</p>
</li>
<li><p>&lsquo;<span class="file">fwrite.c</span>&rsquo; - <code><a href="#topic+fwrite">fwrite</a>()</code>
</p>
</li>
<li><p>&lsquo;<span class="file">gsumm.c</span>&rsquo; - GForce in various places, see <a href="#topic+GForce">GForce</a>
</p>
</li>
<li><p>&lsquo;<span class="file">nafill.c</span>&rsquo; - <code><a href="#topic+nafill">nafill</a>()</code>
</p>
</li>
<li><p>&lsquo;<span class="file">subset.c</span>&rsquo; - Used in <code><a href="#topic+data.table">[.data.table</a></code> subsetting
</p>
</li>
<li><p>&lsquo;<span class="file">types.c</span>&rsquo; - Internal testing usage
</p>
</li></ul>



<h3>Value</h3>

<p>A length 1 <code>integer</code>. The old value is returned by <code>setDTthreads</code> so you can store that prior value and pass it to <code>setDTthreads()</code> again after the section of your code where you control the number of threads.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  getDTthreads(verbose=TRUE)
</code></pre>

<hr>
<h2 id='setkey'> Create key on a data.table </h2><span id='topic+setkey'></span><span id='topic+setkeyv'></span><span id='topic+key'></span><span id='topic+haskey'></span><span id='topic+setindex'></span><span id='topic+setindexv'></span><span id='topic+indices'></span>

<h3>Description</h3>

<p><code>setkey</code> sorts a <code>data.table</code> and marks it as sorted with an
attribute <code>"sorted"</code>. The sorted columns are the key. The key can be any
number of columns. The data is always sorted in <em>ascending</em> order with <code>NA</code>s
(if any) always first. The table is changed <em>by reference</em> and there is
no memory used for the key (other than marking which columns the data is sorted by).
</p>
<p>There are three reasons <code>setkey</code> is desirable:
</p>

<ul>
<li><p> binary search and joins are faster when they detect they can use an existing key
</p>
</li>
<li><p> grouping by a leading subset of the key columns is faster because the groups are already gathered contiguously in RAM
</p>
</li>
<li><p> simpler shorter syntax; e.g. <code>DT["id",]</code> finds the group &quot;id&quot; in the first column of <code>DT</code>'s key using binary search. It may be helpful to think of a key as super-charged rownames: multi-column and multi-type.
</p>
</li></ul>

<p><code>NA</code>s are always first because:
</p>

<ul>
<li> <p><code>NA</code> is internally <code>INT_MIN</code> (a large negative number) in R. Keys and indexes are always in increasing order so if <code>NA</code>s are first, no special treatment or branch is needed in many <code>data.table</code> internals involving binary search. It is not optional to place <code>NA</code>s last for speed, simplicity and rubustness of internals at C level.
</p>
</li>
<li><p> if any <code>NA</code>s are present then we believe it is better to display them up front (rather than hiding them at the end) to reduce the risk of not realizing <code>NA</code>s are present.
</p>
</li></ul>

<p>In <code>data.table</code> parlance, all <code>set*</code> functions change their input
<em>by reference</em>. That is, no copy is made at all other than for temporary
working memory, which is as large as one column. The only other <code>data.table</code>
operator that modifies input by reference is <code><a href="#topic++3A+3D">:=</a></code>. Check out the
<code>See Also</code> section below for other <code>set*</code> functions <code>data.table</code>
provides.
</p>
<p><code>setindex</code> creates an index for the provided columns. This index is simply an
ordering vector of the dataset's rows according to the provided columns. This order vector
is stored as an attribute of the <code>data.table</code> and the dataset retains the original order
of rows in memory. See the <a href="../doc/datatable-secondary-indices-and-auto-indexing.html"><code>vignette("datatable-secondary-indices-and-auto-indexing")</code></a> for more details.
</p>
<p><code>key</code> returns the <code>data.table</code>'s key if it exists; <code>NULL</code> if none exists.
</p>
<p><code>haskey</code> returns <code>TRUE</code>/<code>FALSE</code> if the <code>data.table</code> has a key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setkey(x, ..., verbose=getOption("datatable.verbose"), physical = TRUE)
setkeyv(x, cols, verbose=getOption("datatable.verbose"), physical = TRUE)
setindex(...)
setindexv(x, cols, verbose=getOption("datatable.verbose"))
key(x)
indices(x, vectors = FALSE)
haskey(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setkey_+3A_x">x</code></td>
<td>
<p> A <code>data.table</code>. </p>
</td></tr>
<tr><td><code id="setkey_+3A_...">...</code></td>
<td>
<p> The columns to sort by. Do not quote the column names. If <code>...</code> is missing (i.e. <code>setkey(DT)</code>), all the columns are used. <code>NULL</code> removes the key. </p>
</td></tr>
<tr><td><code id="setkey_+3A_cols">cols</code></td>
<td>
<p> A character vector of column names. For <code>setindexv</code>, this can be a <code>list</code> of character vectors, in which case each element will be applied as an index in turn. </p>
</td></tr>
<tr><td><code id="setkey_+3A_verbose">verbose</code></td>
<td>
<p> Output status and information. </p>
</td></tr>
<tr><td><code id="setkey_+3A_physical">physical</code></td>
<td>
 <p><code>TRUE</code> changes the order of the data in RAM. <code>FALSE</code> adds an index. </p>
</td></tr>
<tr><td><code id="setkey_+3A_vectors">vectors</code></td>
<td>
 <p><code>logical</code> scalar, default <code>FALSE</code>; when set to <code>TRUE</code>, a <code>list</code> of character vectors is returned, each referring to one index. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>setkey</code> reorders (i.e. sorts) the rows of a <code>data.table</code> by the columns
provided. The sort method used has developed over the years and we have contributed
to base R too; see <code><a href="base.html#topic+sort">sort</a></code>. Generally speaking we avoid any type
of comparison sort (other than insert sort for very small input) preferring instead
counting sort and forwards radix. We also avoid hash tables.
</p>
<p>Note that <code>setkey</code> always uses &quot;C-locale&quot;; see the Details in the help for <code><a href="#topic+setorder">setorder</a></code> for more on why.
</p>
<p>The sort is <em>stable</em>; i.e., the order of ties (if any) is preserved.
</p>
<p>For character vectors, <code>data.table</code> takes advantage of R's internal global string cache, also exported as <code><a href="#topic+chorder">chorder</a></code>.
</p>


<h3>Value</h3>

<p>The input is modified by reference and returned (invisibly) so it can be used
in compound statements; e.g., <code>setkey(DT,a)[.("foo")]</code>. If you require a
copy, take a copy first (using <code>DT2=copy(DT)</code>). <code><a href="#topic+copy">copy</a></code> may also
sometimes be useful before <code>:=</code> is used to subassign to a column by
reference.
</p>


<h3>Good practice</h3>

<p>In general, it's good practice to use column names rather than numbers. This is
why <code>setkey</code> and <code>setkeyv</code> only accept column names.
If you use column numbers then bugs (possibly silent) can more easily creep into
your code as time progresses if changes are made elsewhere in your code; e.g., if
you add, remove or reorder columns in a few months time, a <code>setkey</code> by column
number will then refer to a different column, possibly returning incorrect results
with no warning. (A similar concept exists in SQL, where <code>"select * from ..."</code> is considered poor programming style when a robust, maintainable system is
required.)
</p>
<p>If you really wish to use column numbers, it is possible but
deliberately a little harder; e.g., <code>setkeyv(DT,names(DT)[1:2])</code>.
</p>
<p>If you wanted to use <code><a href="base.html#topic+grep">grep</a></code> to select key columns according to
a pattern, note that you can just set <code>value = TRUE</code> to return a character vector instead of the default integer indices.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Radix_sort">https://en.wikipedia.org/wiki/Radix_sort</a><br />
<a href="https://en.wikipedia.org/wiki/Counting_sort">https://en.wikipedia.org/wiki/Counting_sort</a><br />
<a href="http://stereopsis.com/radix.html">http://stereopsis.com/radix.html</a><br />
<a href="https://codercorner.com/RadixSortRevisited.htm">https://codercorner.com/RadixSortRevisited.htm</a><br />
<a href="https://cran.r-project.org/package=bit64">https://cran.r-project.org/package=bit64</a><br />
<a href="https://github.com/Rdatatable/data.table/wiki/Presentations">https://github.com/Rdatatable/data.table/wiki/Presentations</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+tables">tables</a></code>, <code><a href="#topic+J">J</a></code>,
<code><a href="base.html#topic+order">sort.list</a></code>, <code><a href="#topic+copy">copy</a></code>, <code><a href="#topic+setDT">setDT</a></code>,
<code><a href="#topic+setDF">setDF</a></code>, <code><a href="#topic+set">set</a></code> <code><a href="#topic++3A+3D">:=</a></code>, <code><a href="#topic+setorder">setorder</a></code>,
<code><a href="#topic+setcolorder">setcolorder</a></code>, <code><a href="#topic+setattr">setattr</a></code>, <code><a href="#topic+setnames">setnames</a></code>,
<code><a href="#topic+chorder">chorder</a></code>, <code><a href="#topic+setNumericRounding">setNumericRounding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Type 'example(setkey)' to run these at the prompt and browse output

DT = data.table(A=5:1,B=letters[5:1])
DT # before
setkey(DT,B)          # re-orders table and marks it sorted.
DT # after
tables()              # KEY column reports the key'd columns
key(DT)
keycols = c("A","B")
setkeyv(DT,keycols)

DT = data.table(A=5:1,B=letters[5:1])
DT2 = DT              # does not copy
setkey(DT2,B)         # does not copy-on-write to DT2
identical(DT,DT2)     # TRUE. DT and DT2 are two names for the same keyed table

DT = data.table(A=5:1,B=letters[5:1])
DT2 = copy(DT)        # explicit copy() needed to copy a data.table
setkey(DT2,B)         # now just changes DT2
identical(DT,DT2)     # FALSE. DT and DT2 are now different tables

DT = data.table(A=5:1,B=letters[5:1])
setindex(DT)          # set indices
setindex(DT, A)
setindex(DT, B)
indices(DT)           # get indices single vector
indices(DT, vectors = TRUE) # get indices list
</code></pre>

<hr>
<h2 id='setNumericRounding'> Change or turn off numeric rounding </h2><span id='topic+setNumericRounding'></span><span id='topic+getNumericRounding'></span>

<h3>Description</h3>

<p>Change rounding to 0, 1 or 2 bytes when joining, grouping or ordering numeric
(i.e. double, POSIXct) columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setNumericRounding(x)
getNumericRounding()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setNumericRounding_+3A_x">x</code></td>
<td>
<p> integer or numeric vector: 0 (default), 1 or 2 byte rounding </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computers cannot represent some floating point numbers (such as 0.6)
precisely, using base 2. This leads to unexpected behaviour when joining or
grouping columns of type 'numeric'; i.e. 'double', see example below. In
cases where this is undesirable, data.table allows rounding such data up to
approximately 11 s.f. which is plenty of digits for many cases. This is
achieved by rounding the last 2 bytes off the significand. Other possible
values are 1 byte rounding, or no rounding (full precision, default).
</p>
<p>It is bytes rather than bits because it is tied in with the radix sort
algorithm for sorting numerics which sorts byte by byte. With the default
rounding of 0 bytes, at most 8 passes are needed. With rounding of 2 bytes, at
most 6 passes are needed (and therefore might be a tad faster).
</p>
<p>For large numbers (integers &gt; 2^31), we recommend using
<code>bit64::integer64</code>, even though the default is to round off 0 bytes (full
precision).
</p>


<h3>Value</h3>

<p><code>setNumericRounding</code> returns no value; the new value is applied.
<code>getNumericRounding</code> returns the current value: 0, 1 or 2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+datatable-optimize">datatable-optimize</a></code><br />
<a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">https://en.wikipedia.org/wiki/Double-precision_floating-point_format</a><br />
<a href="https://en.wikipedia.org/wiki/Floating_point">https://en.wikipedia.org/wiki/Floating_point</a><br />
<a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DT = data.table(a=seq(0,1,by=0.2),b=1:2, key="a")
DT
setNumericRounding(0)   # By default, rounding is turned off
DT[.(0.4)]   # works
DT[.(0.6)]   # no match, can be confusing since 0.6 is clearly there in DT
             # happens due to floating point representation limitations

setNumericRounding(2)   # round off last 2 bytes
DT[.(0.6)]   # works

# using type 'numeric' for integers &gt; 2^31 (typically ids)
DT = data.table(id = c(1234567890123, 1234567890124, 1234567890125), val=1:3)
print(DT, digits=15)
DT[,.N,by=id]   # 1 row, (last 2 bytes rounded)
setNumericRounding(0)
DT[,.N,by=id]   # 3 rows, (no rounding, default)
# better to use bit64::integer64 for such ids
</code></pre>

<hr>
<h2 id='setops'> Set operations for data tables </h2><span id='topic+setops'></span><span id='topic+intersect'></span><span id='topic+fintersect'></span><span id='topic+setdiff'></span><span id='topic+fsetdiff'></span><span id='topic+except'></span><span id='topic+fexcept'></span><span id='topic+union'></span><span id='topic+funion'></span><span id='topic+setequal'></span><span id='topic+fsetequal'></span>

<h3>Description</h3>

<p>Similar to base R set functions, <code>union</code>, <code>intersect</code>, <code>setdiff</code> and <code>setequal</code> but for <code>data.table</code>s. Additional <code>all</code> argument controls how duplicated rows are handled. Functions <code>fintersect</code>, <code>setdiff</code> (<code>MINUS</code> or <code>EXCEPT</code> in SQL) and <code>funion</code> are meant to provide functionality of corresponding SQL operators. Unlike SQL, data.table functions will retain row order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fintersect(x, y, all = FALSE)
fsetdiff(x, y, all = FALSE)
funion(x, y, all = FALSE)
fsetequal(x, y, all = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setops_+3A_x">x</code>, <code id="setops_+3A_y">y</code></td>
<td>
<p><code>data.table</code>s.</p>
</td></tr>
<tr><td><code id="setops_+3A_all">all</code></td>
<td>
<p>Logical. Default is <code>FALSE</code> and removes duplicate rows on the result. When <code>TRUE</code>, if there are <code>xn</code> copies of a particular row in <code>x</code> and <code>yn</code> copies of the same row in <code>y</code>, then:
</p>

<ul>
<li><p><code>fintersect</code> will return <code>min(xn, yn)</code> copies of that row.
</p>
</li>
<li><p><code>fsetdiff</code> will return <code>max(0, xn-yn)</code> copies of that row.
</p>
</li>
<li><p><code>funion</code> will return <code>xn+yn</code> copies of that row.
</p>
</li>
<li><p><code>fsetequal</code> will return <code>FALSE</code> unless <code>xn == yn</code>.
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p><code>bit64::integer64</code> columns are supported but not <code>complex</code> and <code>list</code>, except for <code>funion</code>.
</p>


<h3>Value</h3>

<p>A data.table in case of <code>fintersect</code>, <code>funion</code> and <code>fsetdiff</code>. Logical <code>TRUE</code> or <code>FALSE</code> for <code>fsetequal</code>.
</p>


<h3>References</h3>

<p><a href="https://db.apache.org/derby/papers/Intersect-design.html">https://db.apache.org/derby/papers/Intersect-design.html</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+rbindlist">rbindlist</a></code>, <code><a href="#topic+all.equal.data.table">all.equal.data.table</a></code>, <code><a href="#topic+unique">unique</a></code>, <code><a href="#topic+duplicated">duplicated</a></code>, <code><a href="#topic+uniqueN">uniqueN</a></code>, <code><a href="#topic+anyDuplicated">anyDuplicated</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = data.table(c(1,2,2,2,3,4,4))
x2 = data.table(c(1,2,3,4)) # same set of rows as x
y = data.table(c(2,3,4,4,4,5))
fintersect(x, y)            # intersect
fintersect(x, y, all=TRUE)  # intersect all
fsetdiff(x, y)              # except
fsetdiff(x, y, all=TRUE)    # except all
funion(x, y)                # union
funion(x, y, all=TRUE)      # union all
fsetequal(x, x2, all=FALSE) # setequal
fsetequal(x, x2)            # setequal all
</code></pre>

<hr>
<h2 id='setorder'>Fast row reordering of a data.table by reference</h2><span id='topic+setorder'></span><span id='topic+setorderv'></span><span id='topic+order'></span><span id='topic+fastorder'></span><span id='topic+forder'></span><span id='topic+forderv'></span>

<h3>Description</h3>

<p>In <code>data.table</code> parlance, all <code>set*</code> functions change their input
<em>by reference</em>. That is, no copy is made at all, other than temporary
working memory, which is as large as one column. The only other
<code>data.table</code> operator that modifies input by reference is <code><a href="#topic++3A+3D">:=</a></code>.
Check out the <code>See Also</code> section below for other <code>set*</code> function
<code>data.table</code> provides.
</p>
<p><code>setorder</code> (and <code>setorderv</code>) reorders the rows of a <code>data.table</code>
based on the columns (and column order) provided. It reorders the table
<em>by reference</em> and is therefore very memory efficient.
</p>
<p>Note that queries like <code>x[order(.)]</code> are optimised internally to use <code>data.table</code>'s fast order.
</p>
<p>Also note that <code>data.table</code> always reorders in &quot;C-locale&quot; (see Details). To sort by session locale, use <code>x[base::order(.)]</code>.
</p>
<p><code>bit64::integer64</code> type is also supported for reordering rows of a <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setorder(x, ..., na.last=FALSE)
setorderv(x, cols = colnames(x), order=1L, na.last=FALSE)
# optimised to use data.table's internal fast order
# x[order(., na.last=TRUE)]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setorder_+3A_x">x</code></td>
<td>
<p> A <code>data.table</code>. </p>
</td></tr>
<tr><td><code id="setorder_+3A_...">...</code></td>
<td>
<p> The columns to sort by. Do not quote column names. If <code>...</code>
is missing (ex: <code>setorder(x)</code>), <code>x</code> is rearranged based on all
columns in ascending order by default. To sort by a column in descending order
prefix the symbol <code>"-"</code> which means &quot;descending&quot; (<em>not</em> &quot;negative&quot;, in this context), i.e., <code>setorder(x, a, -b, c)</code>. The <code>-b</code> works
when <code>b</code> is of type <code>character</code> as well. </p>
</td></tr>
<tr><td><code id="setorder_+3A_cols">cols</code></td>
<td>
<p> A character vector of column names of <code>x</code> by which to order. By default, sorts over all columns; <code>cols = NULL</code> will return <code>x</code> untouched. Do not add <code>"-"</code> here. Use <code>order</code> argument instead. </p>
</td></tr>
<tr><td><code id="setorder_+3A_order">order</code></td>
<td>
<p> An integer vector with only possible values of <code>1</code> and
<code>-1</code>, corresponding to ascending and descending order. The length of
<code>order</code> must be either <code>1</code> or equal to that of <code>cols</code>. If
<code>length(order) == 1</code>, it is recycled to <code>length(cols)</code>. </p>
</td></tr>
<tr><td><code id="setorder_+3A_na.last">na.last</code></td>
<td>
 <p><code>logical</code>. If <code>TRUE</code>, missing values in the data are placed last; if <code>FALSE</code>, they are placed first; if <code>NA</code> they are removed.
<code>na.last=NA</code> is valid only for <code>x[order(., na.last)]</code> and its
default is <code>TRUE</code>. <code>setorder</code> and <code>setorderv</code> only accept
<code>TRUE</code>/<code>FALSE</code> with default <code>FALSE</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data.table</code> implements its own fast radix-based ordering. See the references for some exposition on the concept of radix sort.
</p>
<p><code>setorder</code> accepts unquoted column names (with names preceded with a
<code>-</code> sign for descending order) and reorders <code>data.table</code> rows
<em>by reference</em>, for e.g., <code>setorder(x, a, -b, c)</code>. We emphasize that
this means &quot;descending&quot; and not &quot;negative&quot; because the implementation simply
reverses the sort order, as opposed to sorting the opposite of the input
(which would be inefficient).
</p>
<p>Note that <code>-b</code> also works with columns of type <code>character</code> unlike
<code><a href="base.html#topic+order">order</a></code>, which requires <code>-xtfrm(y)</code> instead (which is slow).
<code>setorderv</code> in turn accepts a character vector of column names and an
integer vector of column order separately.
</p>
<p>Note that <code><a href="#topic+setkey">setkey</a></code> still requires and will always sort only in
ascending order, and is different from <code>setorder</code> in that it additionally
sets the <code>sorted</code> attribute.
</p>
<p><code>na.last</code> argument, by default, is <code>FALSE</code> for <code>setorder</code> and
<code>setorderv</code> to be consistent with <code>data.table</code>'s <code>setkey</code> and
is <code>TRUE</code> for <code>x[order(.)]</code> to be consistent with <code>base::order</code>.
Only <code>x[order(.)]</code> can have <code>na.last = NA</code> as it is a subset operation
as opposed to <code>setorder</code> or <code>setorderv</code> which reorders the data.table
by reference.
</p>
<p><code>data.table</code> always reorders in &quot;C-locale&quot;.
As a consequence, the ordering may be different to that obtained by <code>base::order</code>.
In English locales, for example, sorting is case-sensitive in C-locale.
Thus, sorting <code>c("c", "a", "B")</code> returns <code>c("B", "a", "c")</code> in <code>data.table</code>
but <code>c("a", "B", "c")</code> in <code>base::order</code>. Note this makes no difference in most cases
of data; both return identical results on ids where only upper-case or lower-case letters are present (<code>"AB123" &lt; "AC234"</code>
is true in both), or on country names and other proper nouns which are consistently capitalized.
For example, neither <code>"America" &lt; "Brazil"</code> nor
<code>"america" &lt; "brazil"</code> are affected since the first letter is consistently
capitalized.
</p>
<p>Using C-locale makes the behaviour of sorting in <code>data.table</code> more consistent across sessions and locales.
The behaviour of <code>base::order</code> depends on assumptions about the locale of the R session.
In English locales, <code>"america" &lt; "BRAZIL"</code> is true by default
but false if you either type <code>Sys.setlocale(locale="C")</code> or the R session has been started in a C locale
for you &ndash; which can happen on servers/services since the locale comes from the environment the R session
was started in. By contrast, <code>"america" &lt; "BRAZIL"</code> is always <code>FALSE</code> in <code>data.table</code> regardless of the way your R session was started.
</p>
<p>If <code>setorder</code> results in reordering of the rows of a keyed <code>data.table</code>,
then its key will be set to <code>NULL</code>.
</p>


<h3>Value</h3>

<p>The input is modified by reference, and returned (invisibly) so it can be used
in compound statements; e.g., <code>setorder(DT,a,-b)[, cumsum(c), by=list(a,b)]</code>.
If you require a copy, take a copy first (using <code>DT2 = copy(DT)</code>). See
<code><a href="#topic+copy">copy</a></code>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Radix_sort">https://en.wikipedia.org/wiki/Radix_sort</a><br />
<a href="https://en.wikipedia.org/wiki/Counting_sort">https://en.wikipedia.org/wiki/Counting_sort</a><br />
<a href="http://stereopsis.com/radix.html">http://stereopsis.com/radix.html</a><br />
<a href="https://codercorner.com/RadixSortRevisited.htm">https://codercorner.com/RadixSortRevisited.htm</a><br />
<a href="https://medium.com/basecs/getting-to-the-root-of-sorting-with-radix-sort-f8e9240d4224">https://medium.com/basecs/getting-to-the-root-of-sorting-with-radix-sort-f8e9240d4224</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setkey">setkey</a></code>, <code><a href="#topic+setcolorder">setcolorder</a></code>, <code><a href="#topic+setattr">setattr</a></code>,
<code><a href="#topic+setnames">setnames</a></code>, <code><a href="#topic+set">set</a></code>, <code><a href="#topic++3A+3D">:=</a></code>, <code><a href="#topic+setDT">setDT</a></code>,
<code><a href="#topic+setDF">setDF</a></code>, <code><a href="#topic+copy">copy</a></code>, <code><a href="#topic+setNumericRounding">setNumericRounding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(45L)
DT = data.table(A=sample(3, 10, TRUE),
         B=sample(letters[1:3], 10, TRUE), C=sample(10))

# setorder
setorder(DT, A, -B)

# same as above, but using setorderv
setorderv(DT, c("A", "B"), c(1, -1))
</code></pre>

<hr>
<h2 id='shift'>Fast lead/lag for vectors and lists</h2><span id='topic+shift'></span><span id='topic+lead'></span><span id='topic+lag'></span>

<h3>Description</h3>

<p><code>lead</code> or <code>lag</code> vectors, lists, data.frames or data.tables implemented in C for speed.
</p>
<p><code>bit64::integer64</code> is also supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift(x, n=1L, fill, type=c("lag", "lead", "shift", "cyclic"), give.names=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_+3A_x">x</code></td>
<td>
<p> A vector, list, data.frame or data.table. </p>
</td></tr>
<tr><td><code id="shift_+3A_n">n</code></td>
<td>
<p> integer vector denoting the offset by which to lead or lag the input. To create multiple lead/lag vectors, provide multiple values to <code>n</code>; negative values of <code>n</code> will &quot;flip&quot; the value of <code>type</code>, i.e., <code>n=-1</code> and <code>type='lead'</code> is the same as <code>n=1</code> and <code>type='lag'</code>. </p>
</td></tr>
<tr><td><code id="shift_+3A_fill">fill</code></td>
<td>
<p> default is <code>NA</code>. Value to use for padding when the window goes beyond the input length. </p>
</td></tr>
<tr><td><code id="shift_+3A_type">type</code></td>
<td>
<p> default is <code>"lag"</code> (look &quot;backwards&quot;). The other possible values <code>"lead"</code> (look &quot;forwards&quot;), <code>"shift"</code> (behave same as <code>"lag"</code> except given names) and <code>"cyclic"</code> where pushed out values are re-introduced at the front/back. </p>
</td></tr>
<tr><td><code id="shift_+3A_give.names">give.names</code></td>
<td>
<p> default is <code>FALSE</code> which returns an unnamed list. When <code>TRUE</code>, names are automatically generated corresponding to <code>type</code> and <code>n</code>. If answer is an atomic vector, then the argument is ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>shift</code> accepts vectors, lists, data.frames or data.tables. It always returns a list except when the input is a <code>vector</code> and <code>length(n) == 1</code> in which case a <code>vector</code> is returned, for convenience. This is so that it can be used conveniently within data.table's syntax. For example, <code>DT[, (cols) := shift(.SD, 1L), by=id]</code> would lag every column of <code>.SD</code> by 1 for each group and <code>DT[, newcol := colA + shift(colB)]</code> would assign the sum of two <em>vectors</em> to <code>newcol</code>.
</p>
<p>Argument <code>n</code> allows multiple values. For example, <code>DT[, (cols) := shift(.SD, 1:2), by=id]</code> would lag every column of <code>.SD</code> by <code>1</code> and <code>2</code> for each group. If <code>.SD</code> contained four columns, the first two elements of the list would correspond to <code>lag=1</code> and <code>lag=2</code> for the first column of <code>.SD</code>, the next two for second column of <code>.SD</code> and so on. Please see examples for more.
</p>
<p><code>shift</code> is designed mainly for use in data.tables along with <code>:=</code> or <code>set</code>. Therefore, it returns an unnamed list by default as assigning names for each group over and over can be quite time consuming with many groups. It may be useful to set names automatically in other cases, which can be done by setting <code>give.names</code> to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A list containing the lead/lag of input <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># on vectors, returns a vector as long as length(n) == 1, #1127
x = 1:5
# lag with n=1 and pad with NA (returns vector)
shift(x, n=1, fill=NA, type="lag")
# lag with n=1 and 2, and pad with 0 (returns list)
shift(x, n=1:2, fill=0, type="lag")
# getting a window by using positive and negative n:
shift(x, n = -1:1)
shift(x, n = -1:1, type = "shift", give.names = TRUE)
# cyclic shift where pad uses pushed out values
shift(x, n = -1:1, type = "cyclic")

# on data.tables
DT = data.table(year=2010:2014, v1=runif(5), v2=1:5, v3=letters[1:5])
# lag columns 'v1,v2,v3' DT by 1 and fill with 0
cols = c("v1","v2","v3")
anscols = paste("lead", cols, sep="_")
DT[, (anscols) := shift(.SD, 1, 0, "lead"), .SDcols=cols]

# return a new data.table instead of updating
# with names automatically set
DT = data.table(year=2010:2014, v1=runif(5), v2=1:5, v3=letters[1:5])
DT[, shift(.SD, 1:2, NA, "lead", TRUE), .SDcols=2:4]

# lag/lead in the right order
DT = data.table(year=2010:2014, v1=runif(5), v2=1:5, v3=letters[1:5])
DT = DT[sample(nrow(DT))]
# add lag=1 for columns 'v1,v2,v3' in increasing order of 'year'
cols = c("v1","v2","v3")
anscols = paste("lag", cols, sep="_")
DT[order(year), (cols) := shift(.SD, 1, type="lag"), .SDcols=cols]
DT[order(year)]

# while grouping
DT = data.table(year=rep(2010:2011, each=3), v1=1:6)
DT[, c("lag1", "lag2") := shift(.SD, 1:2), by=year]

# on lists
ll = list(1:3, letters[4:1], runif(2))
shift(ll, 1, type="lead")
shift(ll, 1, type="lead", give.names=TRUE)
shift(ll, 1:2, type="lead")

# fill using first or last by group
DT = data.table(x=1:6, g=rep(1:2, each=3))
DT[ , shift(x, fill=x[1L]), by=g]
DT[ , shift(x, fill=x[.N], type="lead"), by=g]

</code></pre>

<hr>
<h2 id='shouldPrint'> For use by packages that mimic/divert auto printing e.g. IRkernel and knitr </h2><span id='topic+shouldPrint'></span>

<h3>Description</h3>

<p>Not for use by users. Exported only for use by IRkernel (Jupyter) and knitr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  shouldPrint(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shouldPrint_+3A_x">x</code></td>
<td>
<p> A <code>data.table</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Should IRkernel/Jupyter print a data.table returned invisibly by DT[,:=] ?
This is a read-once function since it resets an internal flag. If you need the value more than once in your logic, store the value from the first call.
</p>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>References</h3>

<p><a href="https://github.com/IRkernel/IRkernel/issues/127">https://github.com/IRkernel/IRkernel/issues/127</a><br />
<a href="https://github.com/Rdatatable/data.table/issues/933">https://github.com/Rdatatable/data.table/issues/933</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dummy example section to pass release check that all .Rd files have examples
</code></pre>

<hr>
<h2 id='special-symbols'> Special symbols </h2><span id='topic+special-symbols'></span><span id='topic+datatable-symbols'></span><span id='topic+.SD'></span><span id='topic+.I'></span><span id='topic+.GRP'></span><span id='topic+.BY'></span><span id='topic+.N'></span><span id='topic+.EACHI'></span><span id='topic+.NGRP'></span>

<h3>Description</h3>

<p><code>.SD</code>, <code>.BY</code>, <code>.N</code>, <code>.I</code>, <code>.GRP</code>, and <code>.NGRP</code> are <em>read-only</em> symbols for use in <code>j</code>. <code>.N</code> can be used in <code>i</code> as well. <code>.I</code> can be used in <code>by</code> as well. See the vignettes, Details and Examples here and in <code><a href="#topic+data.table">data.table</a></code>.
<code>.EACHI</code> is a symbol passed to <code>by</code>; i.e. <code>by=.EACHI</code>.
</p>


<h3>Details</h3>

<p>The bindings of these variables are locked and attempting to assign to them will generate an error. If you wish to manipulate <code>.SD</code> before returning it, take a <code>copy(.SD)</code> first (see FAQ 4.5). Using <code>:=</code> in the <code>j</code> of <code>.SD</code> is reserved for future use as a (tortuously) flexible way to update <code>DT</code> by reference by group (even when groups are not contiguous in an ad hoc by).
</p>
<p>These symbols used in <code>j</code> are defined as follows.
</p>

<ul>
<li> <p><code>.SD</code> is a <code>data.table</code> containing the <b>S</b>ubset of <code>x</code>'s <b>D</b>ata for each group, excluding any columns used in <code>by</code> (or <code>keyby</code>).
</p>
</li>
<li> <p><code>.BY</code> is a <code>list</code> containing a length 1 vector for each item in <code>by</code>. This can be useful when <code>by</code> is not known in advance. The <code>by</code> variables are also available to <code>j</code> directly by name; useful for example for titles of graphs if <code>j</code> is a plot command, or to branch with <code>if()</code> depending on the value of a group variable.
</p>
</li>
<li> <p><code>.N</code> is an integer, length 1, containing the number of rows in the group. This may be useful when the column names are not known in advance and for convenience generally. When grouping by <code>i</code>, <code>.N</code> is the number of rows in <code>x</code> matched to, for each row of <code>i</code>, regardless of whether <code>nomatch</code> is <code>NA</code> or <code>NULL</code>. It is renamed to <code>N</code> (no dot) in the result (otherwise a column called <code>".N"</code> could conflict with the <code>.N</code> variable, see FAQ 4.6 for more details and example), unless it is explicitly named; e.g., <code>DT[,list(total=.N),by=a]</code>.
</p>
</li>
<li> <p><code>.I</code> is an integer vector equal to <code>seq_len(nrow(x))</code>. While grouping, it holds for each item in the group, its row location in <code>x</code>. This is useful to subset in <code>j</code>; e.g. <code>DT[, .I[which.max(somecol)], by=grp]</code>. If used in <code>by</code> it corresponds to applying a function rowwise. 
</p>
</li>
<li> <p><code>.GRP</code> is an integer, length 1, containing a simple group counter. 1 for the 1st group, 2 for the 2nd, etc.
</p>
</li>
<li> <p><code>.NGRP</code> is an integer, length 1, containing the number of groups. 
</p>
</li></ul>

<p><code>.EACHI</code> is defined as <code>NULL</code> but its value is not used. Its usage is <code>by=.EACHI</code> (or <code>keyby=.EACHI</code>) which invokes grouping-by-each-row-of-i; see <code><a href="#topic+data.table">data.table</a></code>'s <code>by</code> argument for more details.
</p>
<p>Note that <code>.N</code> in <code>i</code> is computed up-front, while that in <code>j</code> applies <em>after filtering in <code>i</code></em>. That means that even absent grouping, <code>.N</code> in <code>i</code> can be different from <code>.N</code> in <code>j</code>. See Examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic++3A+3D">:=</a></code>, <code><a href="#topic+set">set</a></code>, <code><a href="#topic+datatable-optimize">datatable-optimize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DT = data.table(x=rep(c("b","a","c"),each=3), v=c(1,1,1,2,2,1,1,2,2), y=c(1,3,6), a=1:9, b=9:1)
DT
X = data.table(x=c("c","b"), v=8:7, foo=c(4,2))
X

DT[.N]                                 # last row, only special symbol allowed in 'i'
DT[, .N]                               # total number of rows in DT
DT[, .N, by=x]                         # number of rows in each group
DT[, .SD, .SDcols=x:y]                 # select columns 'x' through 'y'
DT[, .SD[1]]                           # first row of all columns
DT[, .SD[1], by=x]                     # first row of all columns for each group in 'x'
DT[, c(.N, lapply(.SD, sum)), by=x]    # get rows *and* sum all columns by group
DT[, .I[1], by=x]                      # row number in DT corresponding to each group
DT[, .N, by=rleid(v)]                  # get count of consecutive runs of 'v'
DT[, c(.(y=max(y)), lapply(.SD, min)),
        by=rleid(v), .SDcols=v:b]      # compute 'j' for each consecutive runs of 'v'
DT[, grp := .GRP, by=x]                # add a group counter
DT[, grp_pct := .GRP/.NGRP, by=x]      # add a group "progress" counter
X[, DT[.BY, y, on="x"], by=x]          # join within each group

# .N can be different in i and j
DT[{cat(sprintf('in i, .N is %d\n', .N)); a &lt; .N/2},
   {cat(sprintf('in j, .N is %d\n', .N)); mean(a)}]

# .I can be different in j and by, enabling rowwise operations in by
DT[, .(.I, min(.SD[,-1]))]
DT[, .(min(.SD[,-1])), by=.I]
</code></pre>

<hr>
<h2 id='split'> Split data.table into chunks in a list </h2><span id='topic+split'></span><span id='topic+split.data.table'></span>

<h3>Description</h3>

<p>Split method for data.table. Faster and more flexible. Be aware that processing list of data.tables will be generally much slower than manipulation in single data.table by group using <code>by</code> argument, read more on <code><a href="#topic+data.table">data.table</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.table'
split(x, f, drop = FALSE,
      by, sorted = FALSE, keep.by = TRUE, flatten = TRUE,
      ..., verbose = getOption("datatable.verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_+3A_x">x</code></td>
<td>
<p>data.table </p>
</td></tr>
<tr><td><code id="split_+3A_f">f</code></td>
<td>
<p>factor or list of factors. Same as <code><a href="base.html#topic+split">split.data.frame</a></code>. Use <code>by</code> argument instead, this is just for consistency with data.frame method.</p>
</td></tr>
<tr><td><code id="split_+3A_drop">drop</code></td>
<td>
<p>logical. Default <code>FALSE</code> will not drop empty list elements caused by factor levels not referred by that factors. Works also with new arguments of split data.table method.</p>
</td></tr>
<tr><td><code id="split_+3A_by">by</code></td>
<td>
<p>character vector. Column names on which split should be made. For <code>length(by) &gt; 1L</code> and <code>flatten</code> FALSE it will result nested lists with data.tables on leafs.</p>
</td></tr>
<tr><td><code id="split_+3A_sorted">sorted</code></td>
<td>
<p>When default <code>FALSE</code> it will retain the order of groups we are splitting on. When <code>TRUE</code> then sorted list(s) are returned. Does not have effect for <code>f</code> argument.</p>
</td></tr>
<tr><td><code id="split_+3A_keep.by">keep.by</code></td>
<td>
<p>logical default <code>TRUE</code>. Keep column provided to <code>by</code> argument.</p>
</td></tr>
<tr><td><code id="split_+3A_flatten">flatten</code></td>
<td>
<p>logical default <code>TRUE</code> will unlist nested lists of data.tables. When using <code>f</code> results are always flattened to list of data.tables.</p>
</td></tr>
<tr><td><code id="split_+3A_...">...</code></td>
<td>
<p>passed to data.frame way of processing when using <code>f</code> argument.</p>
</td></tr>
<tr><td><code id="split_+3A_verbose">verbose</code></td>
<td>
<p>logical default <code>FALSE</code>. When <code>TRUE</code> it will print to console data.table split query used to split data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>f</code> is just for consistency in usage to data.frame method. Recommended is to use <code>by</code> argument instead, it will be faster, more flexible, and by default will preserve order according to order in data.
</p>


<h3>Value</h3>

<p>List of <code>data.table</code>s. If using <code>flatten</code> FALSE and <code>length(by) &gt; 1L</code> then recursively nested lists having <code>data.table</code>s as leafs of grouping according to <code>by</code> argument.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+rbindlist">rbindlist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
DT = data.table(x1 = rep(letters[1:2], 6),
                x2 = rep(letters[3:5], 4),
                x3 = rep(letters[5:8], 3),
                y = rnorm(12))
DT = DT[sample(.N)]
DF = as.data.frame(DT)

# split consistency with data.frame: `x, f, drop`
all.equal(
    split(DT, list(DT$x1, DT$x2)),
    lapply(split(DF, list(DF$x1, DF$x2)), setDT)
)

# nested list using `flatten` arguments
split(DT, by=c("x1", "x2"))
split(DT, by=c("x1", "x2"), flatten=FALSE)

# dealing with factors
fdt = DT[, c(lapply(.SD, as.factor), list(y=y)), .SDcols=x1:x3]
fdf = as.data.frame(fdt)
sdf = split(fdf, list(fdf$x1, fdf$x2))
all.equal(
    split(fdt, by=c("x1", "x2"), sorted=TRUE),
    lapply(sdf[sort(names(sdf))], setDT)
)

# factors having unused levels, drop FALSE, TRUE
fdt = DT[, .(x1 = as.factor(c(as.character(x1), "c"))[-13L],
             x2 = as.factor(c("a", as.character(x2)))[-1L],
             x3 = as.factor(c("a", as.character(x3), "z"))[c(-1L,-14L)],
             y = y)]
fdf = as.data.frame(fdt)
sdf = split(fdf, list(fdf$x1, fdf$x2))
all.equal(
    split(fdt, by=c("x1", "x2"), sorted=TRUE),
    lapply(sdf[sort(names(sdf))], setDT)
)
sdf = split(fdf, list(fdf$x1, fdf$x2), drop=TRUE)
all.equal(
    split(fdt, by=c("x1", "x2"), sorted=TRUE, drop=TRUE),
    lapply(sdf[sort(names(sdf))], setDT)
)
</code></pre>

<hr>
<h2 id='subset.data.table'> Subsetting data.tables </h2><span id='topic+subset'></span><span id='topic+subset.data.table'></span>

<h3>Description</h3>

<p>Returns subsets of a <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'data.table'
subset(x, subset, select, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.data.table_+3A_x">x</code></td>
<td>

<p><code>data.table</code> to subset.
</p>
</td></tr>
<tr><td><code id="subset.data.table_+3A_subset">subset</code></td>
<td>

<p>logical expression indicating elements or rows to keep
</p>
</td></tr>
<tr><td><code id="subset.data.table_+3A_select">select</code></td>
<td>

<p>expression indicating columns to select from <code>data.table</code>
</p>
</td></tr>
<tr><td><code id="subset.data.table_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to or from other methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>subset</code> argument works on the rows and will be evaluated
in the <code>data.table</code> so columns can be referred to (by name) as variables
in the expression.
</p>
<p>The <code>data.table</code> that is returned will maintain the original keys
as long as they are not <code>select</code>-ed out.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> containing the subset of rows and columns that are
selected.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+subset">subset</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
DT &lt;- data.table(a=sample(c('a', 'b', 'c'), 20, replace=TRUE),
                 b=sample(c('a', 'b', 'c'), 20, replace=TRUE),
                 c=sample(20), key=c('a', 'b'))

sub &lt;- subset(DT, a == 'a')
all.equal(key(sub), key(DT))
</code></pre>

<hr>
<h2 id='substitute2'> Substitute expression </h2><span id='topic+substitute2'></span><span id='topic+substitute'></span><span id='topic+I'></span>

<h3>Description</h3>

<p>Experimental, more robust, and more user-friendly version of base R <code><a href="base.html#topic+substitute">substitute</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  substitute2(expr, env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="substitute2_+3A_expr">expr</code></td>
<td>
<p> Unevaluated expression in which substitution has to take place. </p>
</td></tr>
<tr><td><code id="substitute2_+3A_env">env</code></td>
<td>
<p> List, or an environment that will be coerced to list, from which variables will be taken to inject into <code>expr</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For convenience function will turn any character elements of <code>env</code> argument into symbols. In case if character is of length 2 or more, it will raise an error. It will also turn any list elements into list calls instead. Behaviour can be changed by wrapping <code>env</code> into <code><a href="base.html#topic+I">I</a></code> call. In such case any symbols must be explicitly created, for example using <code>as.name</code> function. Alternatively it is possible to wrap particular elements of <code>env</code> into <code><a href="base.html#topic+I">I</a></code> call, then only those elements will retain their original class.
</p>
<p>Comparing to base R <code><a href="base.html#topic+substitute">substitute</a></code>, <code>substitute2</code> function:
</p>

<ol>
<li><p> substitutes calls argument names as well
</p>
</li>
<li><p> by default converts character elements of <code>env</code> argument to symbols
</p>
</li>
<li><p> by default converts list elements of <code>env</code> argument to list calls
</p>
</li>
<li><p> does not accept missing <code>env</code> argument
</p>
</li>
<li><p> evaluates elements of <code>env</code> argument
</p>
</li></ol>



<h3>Value</h3>

<p>Quoted expression having variables and call argument names substituted.
</p>


<h3>Note</h3>

<p>Conversion of <em>character to symbol</em> and <em>list to list call</em> works recursively for each list element in <code>env</code> list. If this behaviour is not desired for your use case, we would like to hear about that via our issue tracker. For the present moment there is an option to disable that: <code>options(datatable.enlist=FALSE)</code>. This option is provided only for debugging and will be removed in future. Please do not write code that depends on it, but use <code><a href="base.html#topic+I">I</a></code> calls instead.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+substitute">substitute</a></code>, <code><a href="base.html#topic+I">I</a></code>, <code><a href="base.html#topic+call">call</a></code>, <code><a href="base.html#topic+name">name</a></code>, <code><a href="base.html#topic+eval">eval</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## base R substitute vs substitute2
substitute(list(var1 = var2), list(var1 = "c1", var2 = 5L))
substitute2(list(var1 = var2), list(var1 = "c1", var2 = 5L)) ## works also on names

substitute(var1, list(var1 = "c1"))
substitute2(var1, list(var1 = I("c1"))) ## enforce character with I

substitute(var1, list(var1 = as.name("c1")))
substitute2(var1, list(var1 = "c1")) ## turn character into symbol, for convenience

## mix symbols and characters using 'I' function, both lines will yield same result
substitute2(list(var1 = var2), list(var1 = "c1", var2 = I("some_character")))
substitute2(list(var1 = var2), I(list(var1 = as.name("c1"), var2 = "some_character")))

## list elements are enlist'ed into list calls
(cl1 = substitute(f(lst), list(lst = list(1L, 2L))))
(cl2 = substitute2(f(lst), I(list(lst = list(1L, 2L)))))
(cl3 = substitute2(f(lst), list(lst = I(list(1L, 2L)))))
(cl4 = substitute2(f(lst), list(lst = quote(list(1L, 2L)))))
(cl5 = substitute2(f(lst), list(lst = list(1L, 2L))))
cl1[[2L]] ## base R substitute with list element
cl2[[2L]] ## same
cl3[[2L]] ## same
cl4[[2L]] ## desired
cl5[[2L]] ## automatically

## character to name and list into list calls works recursively
(cl1 = substitute2(f(lst), list(lst = list(1L, list(2L)))))
(cl2 = substitute2(f(lst), I(list(lst = list(1L, list(2L)))))) ## unless I() used
last(cl1[[2L]]) ## enlisted recursively
last(cl2[[2L]]) ## AsIs

## using substitute2 from another function
f = function(expr, env) {
  eval(substitute(
    substitute2(.expr, env),
    list(.expr = substitute(expr))
  ))
}
f(list(var1 = var2), list(var1 = "c1", var2 = 5L))
</code></pre>

<hr>
<h2 id='tables'>Display 'data.table' metadata </h2><span id='topic+tables'></span>

<h3>Description</h3>

<p>Convenience function for concisely summarizing some metadata of all <code>data.table</code>s in memory (or an optionally specified environment).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tables(mb=type_size, order.col="NAME", width=80,
       env=parent.frame(), silent=FALSE, index=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tables_+3A_mb">mb</code></td>
<td>
<p> a function which accepts a <code>data.table</code> and returns its size in bytes. By default, <code>type_size</code> (same as <code>TRUE</code>) provides a fast lower bound by excluding the size of character strings in R's global cache (which may be shared) and excluding the size of list column items (which also may be shared). A column <code>"MB"</code> is included in the output unless <code>FALSE</code> or <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="tables_+3A_order.col">order.col</code></td>
<td>
<p> Column name (<code>character</code>) by which to sort the output. </p>
</td></tr>
<tr><td><code id="tables_+3A_width">width</code></td>
<td>
 <p><code>integer</code>; number of characters beyond which the output for each of the columns <code>COLS</code>, <code>KEY</code>, and <code>INDICES</code> are truncated. </p>
</td></tr>
<tr><td><code id="tables_+3A_env">env</code></td>
<td>
<p> An <code>environment</code>, typically the <code>.GlobalEnv</code> by default, see Details. </p>
</td></tr>
<tr><td><code id="tables_+3A_silent">silent</code></td>
<td>
 <p><code>logical</code>; should the output be printed? </p>
</td></tr>
<tr><td><code id="tables_+3A_index">index</code></td>
<td>
 <p><code>logical</code>; if <code>TRUE</code>, the column <code>INDICES</code> is added to indicate the indices assorted with each object, see <code><a href="#topic+indices">indices</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually <code>tables()</code> is executed at the prompt, where <code>parent.frame()</code> returns <code>.GlobalEnv</code>. <code>tables()</code> may also be useful inside functions where <code>parent.frame()</code> is the local scope of the function; in such a scenario, simply set it to <code>.GlobalEnv</code> to get the same behaviour as at prompt.
</p>
<p>'mb = utils::object.size' provides a higher and more accurate estimate of size, but may take longer. Its default 'units=&quot;b&quot;' is appropriate.
</p>
<p>Setting <code>silent=TRUE</code> prints nothing; the metadata is returned as a <code>data.table</code> invisibly whether <code>silent</code> is <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> containing the information printed.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+setkey">setkey</a></code>, <code><a href="base.html#topic+ls">ls</a></code>, <code><a href="base.html#topic+objects">objects</a></code>, <code><a href="utils.html#topic+object.size">object.size</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>DT = data.table(A=1:10, B=letters[1:10])
DT2 = data.table(A=1:10000, ColB=10000:1)
setkey(DT,B)
tables()
</code></pre>

<hr>
<h2 id='test'> Test assertions for equality, exceptions and console output </h2><span id='topic+test'></span>

<h3>Description</h3>

<p>An internal testing function used in <code>data.table</code> test scripts that are run by <code><a href="#topic+test.data.table">test.data.table</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test(num, x, y = TRUE,
     error = NULL, warning = NULL, message = NULL,
     output = NULL, notOutput = NULL, ignore.warning = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_+3A_num">num</code></td>
<td>
<p> A unique identifier for a test, helpful in identifying the source of failure when testing is not working. Currently, we use a manually-incremented system with tests formatted as <code>n.m</code>, where essentially <code>n</code> indexes an issue and <code>m</code> indexes aspects of that issue. For the most part, your new PR should only have one value of <code>n</code> (scroll to the end of <code>inst/tests/tests.Rraw</code> to see the next available ID) and then index the tests within your PR by increasing <code>m</code>. Note &ndash; <code>n.m</code> is interpreted as a number, so <code>123.4</code> and <code>123.40</code> are actually the same &ndash; please <code>0</code>-pad as appropriate. Test identifiers are checked to be in increasing order at runtime to prevent duplicates being possible. </p>
</td></tr>
<tr><td><code id="test_+3A_x">x</code></td>
<td>
<p> An input expression to be evaluated. </p>
</td></tr>
<tr><td><code id="test_+3A_y">y</code></td>
<td>
<p> Pre-defined value to compare to <code>x</code>, by default <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="test_+3A_error">error</code></td>
<td>
<p> When you are testing behaviour of code that you expect to fail with an error, supply the expected error message to this argument. It is interpreted as a regular expression, so you can be abbreviated, but try to include the key portion of the error so as not to accidentally include a different error message. </p>
</td></tr>
<tr><td><code id="test_+3A_warning">warning</code></td>
<td>
<p> Same as <code>error</code>, in the case that you expect your code to issue a warning. Note that since the code evaluates successfully, you should still supply <code>y</code>. </p>
</td></tr>
<tr><td><code id="test_+3A_message">message</code></td>
<td>
<p> Same as <code>warning</code> but expects <code>message</code> exception. </p>
</td></tr>
<tr><td><code id="test_+3A_output">output</code></td>
<td>
<p> If you are testing the printing/console output behaviour; e.g. with <code>verbose=TRUE</code> or <code>options(datatable.verbose=TRUE)</code>. Again, regex-compatible and case sensitive. </p>
</td></tr>
<tr><td><code id="test_+3A_notoutput">notOutput</code></td>
<td>
<p> Or if you are testing that a feature does <em>not</em> print particular console output. Case insensitive (unlike output) so that the test does not incorrectly pass just because the string is not found due to case. </p>
</td></tr>
<tr><td><code id="test_+3A_ignore.warning">ignore.warning</code></td>
<td>
<p> A single character string. Any warnings emitted by <code>x</code> that contain this string are dropped. Remaining warnings are compared to the expected <code>warning</code> as normal. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical <code>TRUE</code> when test passes, <code>FALSE</code> when test fails. Invisibly.
</p>


<h3>Note</h3>

<p><code>NA_real_</code> and <code>NaN</code> are treated as equal, use <code>identical</code> if distinction is needed. See examples below.
</p>
<p>If <code>warning=</code> is not supplied then you are automatically asserting no warning is expected; the test will fail if any warning does occur. Similarly for <code>message=</code>.
</p>
<p>Multiple warnings are supported; supply a vector of strings to <code>warning=</code>. If <code>x</code> does not produce the correct number of warnings in the correct order, the test will fail.
</p>
<p>Strings passed to <code>notOutput=</code> should be minimal; e.g. pick out single words from the output that you desire to check does not occur. The reason being so that the test does not incorrectly pass just because the output has slightly changed. For example <code>notOutput="revised"</code> is better than <code>notOutput="revised flag to true"</code>. <code>notOutput=</code> is automatically case insensitive for this reason.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+test.data.table">test.data.table</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>test = data.table:::test
test(1, x = sum(1:5), y = 15L)
test(2, log(-1), NaN, warning="NaNs")
test(3, sum("a"), error="invalid.*character")
# test failure example
stopifnot(
  test(4, TRUE, FALSE) == FALSE
)
# NA_real_ vs NaN
test(5.01, NA_real_, NaN)
test(5.03, all.equal(NaN, NA_real_))
test(5.02, identical(NaN, NA_real_), FALSE)
</code></pre>

<hr>
<h2 id='test.data.table'> Runs a set of tests. </h2><span id='topic+test.data.table'></span>

<h3>Description</h3>

<p>Runs a set of tests to check data.table is working correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.data.table(script = "tests.Rraw", verbose = FALSE, pkg = ".",
                silent = FALSE,
                showProgress = interactive() &amp;&amp; !silent,
                memtest = Sys.getenv("TEST_DATA_TABLE_MEMTEST", 0),
                memtest.id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.data.table_+3A_script">script</code></td>
<td>
<p> Run arbitrary R test script. </p>
</td></tr>
<tr><td><code id="test.data.table_+3A_verbose">verbose</code></td>
<td>
 <p><code>TRUE</code> sets <code>options(datatable.verbose=TRUE)</code> for the duration of the tests. This tests there are no errors in the branches that produce the verbose output, and produces a lot of output. The output is normally used for tracing bugs or performance tuning. Tests which specifically test the verbose output is correct (typically looking for an expected substring) always run regardless of this option. </p>
</td></tr>
<tr><td><code id="test.data.table_+3A_pkg">pkg</code></td>
<td>
<p> Root directory name under which all package content (ex: DESCRIPTION, src/, R/, inst/ etc..) resides. Used only in <em>dev-mode</em>. </p>
</td></tr>
<tr><td><code id="test.data.table_+3A_silent">silent</code></td>
<td>
<p> Controls what happens if a test fails. Like <code>silent</code> in <code><a href="base.html#topic+try">try</a></code>, <code>TRUE</code> causes the error message to be suppressed and <code>FALSE</code> to be returned, otherwise the error is returned. </p>
</td></tr>
<tr><td><code id="test.data.table_+3A_showprogress">showProgress</code></td>
<td>
<p> Output 'Running test &lt;n&gt; ...\r' at the start of each test? </p>
</td></tr>
<tr><td><code id="test.data.table_+3A_memtest">memtest</code></td>
<td>
<p> Measure and report memory usage of tests (1:gc before ps, 2:gc after ps) rather than time taken (0) by default. Intended for and tested on Linux. See PR #5515 for more details. </p>
</td></tr>
<tr><td><code id="test.data.table_+3A_memtest.id">memtest.id</code></td>
<td>
<p> An id for which to print memory usage for every sub id. May be a range of ids. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs a series of tests. These can be used to see features and examples of usage, too. Running test.data.table will tell you the full location of the test file(s) to open.
</p>
<p>Setting <code>silent=TRUE</code> sets <code>showProgress=FALSE</code> too, via the default of <code>showProgress</code>.
</p>


<h3>Value</h3>

<p>If all tests were successful, <code>TRUE</code> is returned. Otherwise, see the <code>silent</code> argument above. <code>silent=TRUE</code> is intended for use at the start of production scripts; e.g. <code>stopifnot(test.data.table(silent=TRUE))</code> to check <code>data.table</code> is passing its own tests before proceeding.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+test">test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  test.data.table()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='timetaken'> Pretty print of time taken </h2><span id='topic+timetaken'></span>

<h3>Description</h3>

<p>Pretty print of time taken since last started.at.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timetaken(started.at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timetaken_+3A_started.at">started.at</code></td>
<td>
<p> The result of proc.time() taken some time earlier. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the form HH:MM:SS, or SS.MMMsec if under 60 seconds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>started.at=proc.time()
Sys.sleep(1)
cat("Finished in",timetaken(started.at),"\n")
</code></pre>

<hr>
<h2 id='transform.data.table'> Data table utilities </h2><span id='topic+transform'></span><span id='topic+transform.data.table'></span><span id='topic+within'></span><span id='topic+within.data.table'></span>

<h3>Description</h3>

<p>Utilities for <code>data.table</code> transformation.
</p>
<p><strong><code>transform</code> by group is particularly slow. Please use <code>:=</code> by group instead.</strong>
</p>
<p><code>within</code>, <code>transform</code> and other similar functions in <code>data.table</code> are not just provided for users who expect them to work, but for non-data.table-aware packages to retain keys, for example. Hopefully the (much) faster and more convenient <code>data.table</code> syntax will be used in time. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.table'
transform(`_data`, ...)
## S3 method for class 'data.table'
within(data, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform.data.table_+3A_data">data</code>, <code id="transform.data.table_+3A__data">_data</code></td>
<td>
<p> data.table to be transformed.</p>
</td></tr>
<tr><td><code id="transform.data.table_+3A_...">...</code></td>
<td>
<p> for <code>transform</code>, Further arguments of the form
<code>tag=value</code>. Ignored for <code>within</code>.</p>
</td></tr>
<tr><td><code id="transform.data.table_+3A_expr">expr</code></td>
<td>
<p> expression to be evaluated within the data.table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>within</code> is like <code>with</code>, but modifications (columns changed,
added, or removed) are updated in the returned data.table.
</p>
<p>Note that <code>transform</code> will keep the key of the
<code>data.table</code> provided the <em>targets</em> of the transform (i.e. the
columns that appear in ...) are not in the key of the data.table.
<code>within</code> also retains the key provided the key columns are not <em>touched</em>.
</p>


<h3>Value</h3>

<p>The modified value of a copy of <code>data</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+transform">transform</a></code>, <code><a href="base.html#topic+with">within</a></code> and <code><a href="#topic++3A+3D">:=</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>DT &lt;- data.table(a=rep(1:3, each=2), b=1:6)

DT2 &lt;- transform(DT, c = a^2)
DT[, c:=a^2]
identical(DT,DT2)

DT2 &lt;- within(DT, {
  b &lt;- rev(b)
  c &lt;- a*2
  rm(a)
})
DT[,`:=`(b = rev(b),
         c = a*2,
         a = NULL)]
identical(DT,DT2)

DT$d = ave(DT$b, DT$c, FUN=max)               # copies entire DT, even if it is 10GB in RAM
DT = DT[, transform(.SD, d=max(b)), by="c"]   # same, but even worse as .SD is copied for each group
DT[, d:=max(b), by="c"]                       # same result, but much faster, shorter and scales

# Multiple update by group. Convenient, fast, scales and easy to read.
DT[, `:=`(minb = min(b),
          meanb = mean(b),
          bplusd = sum(b+d)),  by=c%/%5]
DT

</code></pre>

<hr>
<h2 id='transpose'>Efficient transpose of list</h2><span id='topic+transpose'></span>

<h3>Description</h3>

<p><code>transpose</code> is an efficient way to transpose <code>lists</code>, <code>data frames</code> or <code>data tables</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transpose(l, fill=NA, ignore.empty=FALSE, keep.names=NULL, make.names=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transpose_+3A_l">l</code></td>
<td>
<p> A list, data.frame or data.table. </p>
</td></tr>
<tr><td><code id="transpose_+3A_fill">fill</code></td>
<td>
<p> Default is <code>NA</code>. It is used to fill shorter list elements so as to return each element of the transposed result of equal lengths. </p>
</td></tr>
<tr><td><code id="transpose_+3A_ignore.empty">ignore.empty</code></td>
<td>
<p>Default is <code>FALSE</code>. <code>TRUE</code> will ignore length-0 list elements.</p>
</td></tr>
<tr><td><code id="transpose_+3A_keep.names">keep.names</code></td>
<td>
<p>The name of the first column in the result containing the names of the input; e.g. <code>keep.names="rn"</code>. By default <code>NULL</code> and the names of the input are discarded.</p>
</td></tr>
<tr><td><code id="transpose_+3A_make.names">make.names</code></td>
<td>
<p>The name or number of a column in the input to use as names of the output; e.g. <code>make.names="rn"</code>. By default <code>NULL</code> and default names are given to the output columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list elements (or columns of <code>data.frame</code>/<code>data.table</code>) should be all <code>atomic</code>. If list elements are of unequal lengths, the value provided in <code>fill</code> will be used so that the resulting list always has all elements of identical lengths. The class of input object is also preserved in the transposed result.
</p>
<p>The <code>ignore.empty</code> argument can be used to skip or include length-0 elements.
</p>
<p>This is particularly useful in tasks that require splitting a character column and assigning each part to a separate column. This operation is quite common enough that a function <code><a href="#topic+tstrsplit">tstrsplit</a></code> is exported.
</p>
<p><code>factor</code> columns are converted to <code>character</code> type. Attributes are not preserved at the moment. This may change in the future.
</p>


<h3>Value</h3>

<p>A transposed <code>list</code>, <code>data.frame</code> or <code>data.table</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+tstrsplit">tstrsplit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ll = list(1:5, 6:8)
transpose(ll)
setDT(transpose(ll, fill=0))[]

DT = data.table(x=1:5, y=6:10)
transpose(DT)
</code></pre>

<hr>
<h2 id='truelength'> Over-allocation access </h2><span id='topic+truelength'></span><span id='topic+setalloccol'></span><span id='topic+alloc.col'></span>

<h3>Description</h3>

<p>These functions are experimental and somewhat advanced. By <em>experimental</em> we mean their names might change and perhaps the syntax, argument names and types. So if you write a lot of code using them, you have been warned! They should work and be stable, though, so please report problems with them. <code>alloc.col</code> is just an alias to <code>setalloccol</code>. We recommend to use <code>setalloccol</code> (though <code>alloc.col</code> will continue to be supported) because the <code>set*</code> prefix in <code>setalloccol</code> makes it clear that its input argument is modified in-place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truelength(x)
setalloccol(DT,
    n = getOption("datatable.alloccol"),        # default: 1024L
    verbose = getOption("datatable.verbose"))   # default: FALSE
alloc.col(DT,
    n = getOption("datatable.alloccol"),        # default: 1024L
    verbose = getOption("datatable.verbose"))   # default: FALSE
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truelength_+3A_x">x</code></td>
<td>
<p> Any type of vector, including <code>data.table</code> which is a <code>list</code> vector of column pointers. </p>
</td></tr>
<tr><td><code id="truelength_+3A_dt">DT</code></td>
<td>
<p> A <code>data.table</code>. </p>
</td></tr>
<tr><td><code id="truelength_+3A_n">n</code></td>
<td>
<p> The number of spare column pointer slots to ensure are available. If <code>DT</code> is a 1,000 column <code>data.table</code> with 24 spare slots remaining, <code>n=1024L</code> means grow the 24 spare slots to be 1024. <code>truelength(DT)</code> will then be 2024 in this example. </p>
</td></tr>
<tr><td><code id="truelength_+3A_verbose">verbose</code></td>
<td>
<p> Output status and information. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>When adding columns by reference using <code>:=</code>, we <em>could</em> simply create a new column list vector (one longer) and memcpy over the old vector, with no copy of the column vectors themselves. That requires negligible use of space and time, and is what v1.7.2 did.  However, that copy of the list vector of column pointers only (but not the columns themselves), a <em>shallow copy</em>, resulted in inconsistent behaviour in some circumstances. So, as from v1.7.3 data.table over allocates the list vector of column pointers so that columns can be added fully by reference, consistently.
</p>
<p>When the allocated column pointer slots are used up, to add a new column <code>data.table</code> must reallocate that vector. If two or more variables are bound to the same data.table this shallow copy may or may not be desirable, but we don't think this will be a problem very often (more discussion may be required on data.table issue tracker). Setting <code>options(datatable.verbose=TRUE)</code> includes messages if and when a shallow copy is taken. To avoid shallow copies there are several options: use <code><a href="#topic+copy">copy</a></code> to make a deep copy first, use <code>setalloccol</code> to reallocate in advance, or, change the default allocation rule (perhaps in your .Rprofile); e.g., <code>options(datatable.alloccol=10000L)</code>.
</p>
<p>Please note : over allocation of the column pointer vector is not for efficiency <em>per se</em>; it is so that <code>:=</code> can add columns by reference without a shallow copy.
</p>


<h3>Value</h3>

<p><code>truelength(x)</code> returns the length of the vector allocated in memory. <code>length(x)</code> of those items are in use. Currently, it is just the list vector of column pointers that is over-allocated (i.e. <code>truelength(DT)</code>), not the column vectors themselves, which would in future allow fast row <code>insert()</code>. For tables loaded from disk however, <code>truelength</code> is 0 in <span class="rlang"><b>R</b></span> 2.14.0+ (and random in <span class="rlang"><b>R</b></span> &lt;= 2.13.2), which is perhaps unexpected. <code>data.table</code> detects this state and over-allocates the loaded <code>data.table</code> when the next column addition occurs. All other operations on <code>data.table</code> (such as fast grouping and joins) do not need <code>truelength</code>.
</p>
<p><code>setalloccol</code> <em>reallocates</em> <code>DT</code> by reference. This may be useful for efficiency if you know you are about to going to add a lot of columns in a loop. It also returns the new <code>DT</code>, for convenience in compound queries.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+copy">copy</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>DT = data.table(a=1:3,b=4:6)
length(DT)                 # 2 column pointer slots used
truelength(DT)             # 1026 column pointer slots allocated
setalloccol(DT, 2048)
length(DT)                 # 2 used
truelength(DT)             # 2050 allocated, 2048 free
DT[,c:=7L]                 # add new column by assigning to spare slot
truelength(DT)-length(DT)  # 2047 slots spare
</code></pre>

<hr>
<h2 id='tstrsplit'>strsplit and transpose the resulting list efficiently</h2><span id='topic+tstrsplit'></span><span id='topic+strsplit'></span>

<h3>Description</h3>

<p>This is equivalent to <code>transpose(strsplit(...))</code>. This is a convenient wrapper function to split a column using <code>strsplit</code> and assign the transposed result to individual columns. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tstrsplit(x, ..., fill=NA, type.convert=FALSE, keep, names=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tstrsplit_+3A_x">x</code></td>
<td>
<p>The vector to split (and transpose).</p>
</td></tr>
<tr><td><code id="tstrsplit_+3A_...">...</code></td>
<td>
<p> All the arguments to be passed to <code><a href="base.html#topic+strsplit">strsplit</a></code>. </p>
</td></tr>
<tr><td><code id="tstrsplit_+3A_fill">fill</code></td>
<td>
<p> Default is <code>NA</code>. It is used to fill shorter list elements so as to return each element of the transposed result of equal lengths. </p>
</td></tr>
<tr><td><code id="tstrsplit_+3A_type.convert">type.convert</code></td>
<td>
<p><code>TRUE</code> calls <code><a href="utils.html#topic+type.convert">type.convert</a></code> with <code>as.is=TRUE</code> on the columns. May also be a function, list of functions, or named list of functions to apply to each part; see examples. </p>
</td></tr>
<tr><td><code id="tstrsplit_+3A_keep">keep</code></td>
<td>
<p>Specify indices corresponding to just those list elements to retain in the transposed result. Default is to return all.</p>
</td></tr>
<tr><td><code id="tstrsplit_+3A_names">names</code></td>
<td>
<p><code>TRUE</code> auto names the list with <code>V1, V2</code> etc. Default (<code>FALSE</code>) is to return an unnamed list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It internally calls <code>strsplit</code> first, and then <code><a href="#topic+transpose">transpose</a></code> on the result.
</p>
<p><code>names</code> argument can be used to return an auto named list, although this argument does not have any effect when used with <code>:=</code>, which requires names to be provided explicitly. It might be useful in other scenarios.
</p>


<h3>Value</h3>

<p>A transposed list after splitting by the pattern provided.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>, <code><a href="#topic+transpose">transpose</a></code>, <code><a href="utils.html#topic+type.convert">type.convert</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c("abcde", "ghij", "klmnopq")
strsplit(x, "", fixed=TRUE)
tstrsplit(x, "", fixed=TRUE)
tstrsplit(x, "", fixed=TRUE, fill="&lt;NA&gt;")

# using keep to return just 1,3,5
tstrsplit(x, "", fixed=TRUE, keep=c(1,3,5))

# names argument
tstrsplit(x, "", fixed=TRUE, keep=c(1,3,5), names=LETTERS[1:3])

DT = data.table(x=c("A/B", "A", "B"), y=1:3)
DT[, c("c1") := tstrsplit(x, "/", fixed=TRUE, keep=1L)][]
DT[, c("c1", "c2") := tstrsplit(x, "/", fixed=TRUE)][]

# type.convert argument
DT = data.table(
  w = c("Yes/F", "No/M"),
  x = c("Yes 2000-03-01 A/T", "No 2000-04-01 E/R"),
  y = c("1/1/2", "2/5/2.5"),
  z = c("Yes/1/2", "No/5/3.5"),
  v = c("Yes 10 30.5 2000-03-01 A/T", "No 20 10.2 2000-04-01 E/R"))

# convert each element in the transpose list to type factor
DT[, tstrsplit(w, "/", type.convert=as.factor)]

# convert part and leave any others
DT[, tstrsplit(z, "/", type.convert=list(as.numeric=2:3))]

# convert part with one function and any others with another
DT[, tstrsplit(z, "/", type.convert=list(as.factor=1L, as.numeric))]

# convert the remaining using 'type.convert(x, as.is=TRUE)' (i.e. what type.convert=TRUE does)
DT[, tstrsplit(v, " ", type.convert=list(as.IDate=4L, function(x) type.convert(x, as.is=TRUE)))]
</code></pre>

<hr>
<h2 id='update_dev_pkg'>Perform update of development version of a package</h2><span id='topic+update_dev_pkg'></span>

<h3>Description</h3>

<p>Downloads and installs latest development version, only when a new commit is available. Defaults are set to update <code>data.table</code>, other packages can be used as well. Repository of a package has to include git commit SHA information in PACKAGES file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_dev_pkg(pkg="data.table",
       repo="https://Rdatatable.gitlab.io/data.table",
       field="Revision", type=getOption("pkgType"), lib=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_dev_pkg_+3A_pkg">pkg</code></td>
<td>
<p> character scalar, package name. </p>
</td></tr>
<tr><td><code id="update_dev_pkg_+3A_repo">repo</code></td>
<td>
<p> character scalar, url of package devel repository. </p>
</td></tr>
<tr><td><code id="update_dev_pkg_+3A_field">field</code></td>
<td>
<p> character scalar, metadata field to use in PACKAGES file and
DESCRIPTION file, default <code>"Revision"</code>. </p>
</td></tr>
<tr><td><code id="update_dev_pkg_+3A_type">type</code></td>
<td>
<p> character scalar, default <code>getOption("pkgType")</code>, used
to define if package has to be installed from sources, binaries or both. </p>
</td></tr>
<tr><td><code id="update_dev_pkg_+3A_lib">lib</code></td>
<td>
<p> character scalar, library location where package is meant to
be upgraded. </p>
</td></tr>
<tr><td><code id="update_dev_pkg_+3A_...">...</code></td>
<td>
<p> passed to <code><a href="utils.html#topic+install.packages">install.packages</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case if a devel repository does not provide binaries user will need development tools installed for package compilation, like <em>Rtools</em> on Windows, or alternatively eventually set <code>type="source"</code>.
</p>


<h3>Value</h3>

<p>Invisibly <code>TRUE</code> if package was updated, otherwise <code>FALSE</code>.
</p>


<h3>data.table repositories</h3>

<p>By default the function uses our GitLab-hosted R repository at <code>https://Rdatatable.gitlab.io/data.table</code>. This repository is updated nightly. It runs multiple test jobs (on top of GitHub tests jobs run upstream) and publish the package (sources and binaries), even if GitLab test jobs are failing. Status of GitLab test jobs can be checked at <a href="https://rdatatable.gitlab.io/data.table/web/checks/check_results_data.table.html">Package Check Results</a>.<br />
We also publish bleeding edge version of the package on GitHub-hosted R repository at <code>https://Rdatatable.gitlab.io/data.table</code> (just minor change in url from <em>lab</em> to <em>hub</em>). GitHub version should be considered less stable than GitLab one. It publishes only package sources.<br />
There are also other repositories maintained by R community, for example <code>https://rdatatable.r-universe.dev</code>. Those can be used as well, but as they are unlikely to provide git commit SHA, the function will install the package even if latest version is already installed.
</p>


<h3>Note</h3>

<p>Package namespace is unloaded before attempting to install newer version.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.table">data.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if (FALSE) data.table::update_dev_pkg()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
