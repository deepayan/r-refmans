<!DOCTYPE html><html><head><title>Help for package ggm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjMatrix'><p>Adjacency matrix of a graph</p></a></li>
<li><a href='#AG'>
<p>Ancestral graph</p></a></li>
<li><a href='#allEdges'><p>All edges of a graph</p></a></li>
<li><a href='#anger'>
<p>Anger data</p></a></li>
<li><a href='#basiSet'><p>Basis set of a DAG</p></a></li>
<li><a href='#bfsearch'><p>Breadth first search</p></a></li>
<li><a href='#binve'>
<p>Inverts a marginal log-linear parametrization</p></a></li>
<li><a href='#blkdiag'>
<p>Block diagonal matrix</p></a></li>
<li><a href='#blodiag'>
<p>Block diagonal matrix</p></a></li>
<li><a href='#checkIdent'><p>Identifiability of a model with one latent variable</p></a></li>
<li><a href='#cmpGraph'><p>The complementary graph</p></a></li>
<li><a href='#conComp'><p>Connectivity components</p></a></li>
<li><a href='#correlations'><p>Marginal and partial correlations</p></a></li>
<li><a href='#cycleMatrix'><p>Fundamental cycles</p></a></li>
<li><a href='#DAG'><p>Directed acyclic graphs (DAGs)</p></a></li>
<li><a href='#derived'><p>Data on blood pressure body mass and age</p></a></li>
<li><a href='#DG'><p>Directed graphs</p></a></li>
<li><a href='#diagv'>
<p>Matrix product with a diagonal matrix</p></a></li>
<li><a href='#drawGraph'><p>Drawing a graph with a simple point and click interface.</p></a></li>
<li><a href='#dSep'><p>d-separation</p></a></li>
<li><a href='#edgematrix'><p>Edge matrix of a graph</p></a></li>
<li><a href='#essentialGraph'><p>Essential graph</p></a></li>
<li><a href='#findPath'><p>Finding paths</p></a></li>
<li><a href='#fitAncestralGraph'><p>Fitting of Gaussian Ancestral Graph Models</p></a></li>
<li><a href='#fitConGraph'><p>Fitting a Gaussian concentration graph model</p></a></li>
<li><a href='#fitCovGraph'><p>Fitting of Gaussian covariance graph models</p></a></li>
<li><a href='#fitDag'><p>Fitting of Gaussian DAG models</p></a></li>
<li><a href='#fitDagLatent'><p>Fitting Gaussian DAG models with one latent variable</p></a></li>
<li><a href='#fitmlogit'>
<p>Multivariate logistic models</p></a></li>
<li><a href='#fundCycles'><p>Fundamental cycles</p></a></li>
<li><a href='#ggm'>
<p>The package <code>ggm</code>: summary information</p></a></li>
<li><a href='#glucose'><p>Glucose control</p></a></li>
<li><a href='#grMAT'><p>Graph to adjacency matrix</p></a></li>
<li><a href='#icf'><p>Iterative conditional fitting</p></a></li>
<li><a href='#In'><p>Indicator matrix</p></a></li>
<li><a href='#InducedGraphs'><p>Graphs induced by marginalization or conditioning</p></a></li>
<li><a href='#isAcyclic'><p>Graph queries</p></a></li>
<li><a href='#isADMG'>
<p>Acyclic directed mixed graphs</p></a></li>
<li><a href='#isAG'>
<p>Ancestral graph</p></a></li>
<li><a href='#isGident'><p>G-identifiability of an UG</p></a></li>
<li><a href='#MAG'>
<p>Maximal ancestral graph</p></a></li>
<li><a href='#makeMG'><p>Mixed Graphs</p></a></li>
<li><a href='#marg.param'>
<p>Link function of marginal log-linear parameterization</p></a></li>
<li><a href='#MarkEqMag'>
<p>Markov equivalence of maximal ancestral graphs</p></a></li>
<li><a href='#MarkEqRcg'>
<p>Markov equivalence for regression chain graphs.</p></a></li>
<li><a href='#marks'><p>Mathematics marks</p></a></li>
<li><a href='#mat.mlogit'>
<p>Multivariate logistic parametrization</p></a></li>
<li><a href='#Max'>
<p>Maximisation for graphs</p></a></li>
<li><a href='#MRG'>
<p>Maximal ribbonless graph</p></a></li>
<li><a href='#msep'><p>The m-separation criterion</p></a></li>
<li><a href='#MSG'>
<p>Maximal summary graph</p></a></li>
<li><a href='#null'>
<p>Null space of a matrix</p></a></li>
<li><a href='#parcor'><p>Partial correlations</p></a></li>
<li><a href='#pcor'><p>Partial correlation</p></a></li>
<li><a href='#pcor.test'><p>Test for zero partial association</p></a></li>
<li><a href='#plotGraph'><p>Plot of a mixed graph</p></a></li>
<li><a href='#powerset'>
<p>Power set</p></a></li>
<li><a href='#rcorr'><p>Random correlation matrix</p></a></li>
<li><a href='#RepMarBG'>
<p>Representational Markov equivalence to bidirected graphs.</p></a></li>
<li><a href='#RepMarDAG'>
<p>Representational Markov equivalence to directed acyclic graphs.</p></a></li>
<li><a href='#RepMarUG'>
<p>Representational Markov equivalence to undirected graphs.</p></a></li>
<li><a href='#RG'>
<p>Ribbonless graph</p></a></li>
<li><a href='#rnormDag'><p>Random sample from a decomposable Gaussian model</p></a></li>
<li><a href='#rsphere'><p>Random vectors on a sphere</p></a></li>
<li><a href='#SG'>
<p>summary graph</p></a></li>
<li><a href='#shipley.test'><p>Test of all independencies implied by a given DAG</p></a></li>
<li><a href='#Simple Graph Operations'><p>Simple graph operations</p></a></li>
<li><a href='#stress'>
<p>Stress</p></a></li>
<li><a href='#surdata'>
<p>A simulated data set</p></a></li>
<li><a href='#swp'><p>Sweep operator</p></a></li>
<li><a href='#topSort'><p>Topological sort</p></a></li>
<li><a href='#transClos'><p>Transitive closure of a graph</p></a></li>
<li><a href='#triDec'><p>Triangular decomposition of a covariance matrix</p></a></li>
<li><a href='#UG'><p>Defining an undirected graph (UG)</p></a></li>
<li><a href='#unmakeMG'><p>Loopless mixed graphs components</p></a></li>
<li><a href='#Utility Functions'>
<p>Utility functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Graphical Markov Models with Mixed Graphs</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>BiocManager, graph, igraph</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for defining 
    mixed graphs containing three types of edges, directed, 
    undirected and bi-directed, with possibly multiple edges.
    These graphs are useful because they capture fundamental
    independence structures in multivariate distributions
    and in the induced distributions after marginalization 
    and conditioning.
    The package is especially concerned with Gaussian graphical
    models for
    (i) ML estimation for directed acyclic graphs, undirected and 
    bi-directed graphs and ancestral graph models
    (ii) testing several conditional independencies
    (iii) checking global identification of DAG Gaussian models
    with one latent variable
    (iv) testing Markov equivalences and generating Markov 
    equivalent graphs of specific types.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/StaThin/ggm">https://github.com/StaThin/ggm</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-25 14:00:11 UTC; gmm</td>
</tr>
<tr>
<td>Author:</td>
<td>Giovanni M. Marchetti [aut, cre],
  Mathias Drton [aut],
  Kayvan Sadeghi [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giovanni M. Marchetti &lt;giovanni.marchetti@unifi.it&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-25 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjMatrix'>Adjacency matrix of a graph</h2><span id='topic+adjMatrix'></span>

<h3>Description</h3>

<p>Transforms the &ldquo;edge matrix&rdquo; of a graph into
the adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjMatrix(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjMatrix_+3A_a">A</code></td>
<td>
<p>a square matrix representing the edge matrix of a graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the edge matrix <code class="reqn">A</code> of a graph, this can be transformed into
an adjacency matrix <code class="reqn">E</code> with the formula <code class="reqn">E = (A-I)^T</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>E</code></td>
<td>
<p>the adjacency matrix of the graph.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>See Also</h3>

<p><code><a href="#topic+edgematrix">edgematrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>amat &lt;- DAG(y ~ x+z, z~u+v)
E &lt;- edgematrix(amat)
adjMatrix(E)
</code></pre>

<hr>
<h2 id='AG'>
Ancestral graph
</h2><span id='topic+AG'></span>

<h3>Description</h3>

<p><code>AG</code> generates and plots ancestral graphs after marginalization
and conditioning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AG(amat,M=c(),C=c(),showmat=TRUE,plot=FALSE, plotfun = plotGraph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AG_+3A_amat">amat</code></td>
<td>

<p>An adjacency matrix, or a graph that can be of class <code>graphNEL-class</code>
or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object, or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code>
is the number of edges of the graph,
that is a sequence of triples (type, node1label, node2label). The type
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and
<code>"l"</code> (lines).</p>
</td></tr>
<tr><td><code id="AG_+3A_m">M</code></td>
<td>

<p>A subset of the node set of <code>a</code> that is going to be marginalized over</p>
</td></tr>
<tr><td><code id="AG_+3A_c">C</code></td>
<td>

<p>Another disjoint subset of the node set of <code>a</code> that is going to be
conditioned on.
</p>
</td></tr>
<tr><td><code id="AG_+3A_showmat">showmat</code></td>
<td>

<p>A logical value. <code>TRUE</code> (by default) to print the generated matrix.
</p>
</td></tr>
<tr><td><code id="AG_+3A_plot">plot</code></td>
<td>

<p>A logical value, <code>FALSE</code> (by default). <code>TRUE</code> to plot
the generated graph.
</p>
</td></tr>
<tr><td><code id="AG_+3A_plotfun">plotfun</code></td>
<td>

<p>Function to plot the graph when <code>plot == TRUE</code>. Can be <code>plotGraph</code> (the default) or <code>drawGraph</code>.
</p>
</td></tr>
<tr><td><code id="AG_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plotfun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that is the adjacency matrix of the generated graph.
It consists of 4 different integers as an <code class="reqn">ij</code>-element: 0 for a missing
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 10 for a full line between
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers are
added to be associated with multiple edges of different types. The matrix is
symmetric w.r.t full lines and bi-directed arrows.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Richardson, T.S. and Spirtes, P. (2002).  Ancestral graph Markov models. <em>Annals of Statistics</em>, 30(4), 962-1030.
</p>
<p>Sadeghi, K. (2013). Stable mixed graphs.
<em>Bernoulli</em> 19(5B), 2330â€“2358.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MAG">MAG</a></code>, <code><a href="#topic+RG">RG</a></code>, <code><a href="#topic+SG">SG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##The adjacency matrix of a DAG
ex&lt;-matrix(c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
             0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
             0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,
             1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
             0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0),16,16,byrow=TRUE)
M &lt;- c(3,5,6,15,16)
C &lt;- c(4,7)
AG(ex, M, C, plot = TRUE)
</code></pre>

<hr>
<h2 id='allEdges'>All edges of a graph</h2><span id='topic+allEdges'></span>

<h3>Description</h3>

<p>Finds the set of edges of a graph. That is
the set of undirected edges if the graph is undirected
and the set of arrows if the graph is directed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allEdges(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allEdges_+3A_amat">amat</code></td>
<td>
<p>a square Boolean matrix, with dimnames, the adjacency matrix of
a graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with two columns. Each row of the matrix is a pair of
indices indicating an edge of the graph. If the graph is undirected,
then only one of the pairs <code class="reqn">(i,j), (j,i)</code> is reported.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>See Also</h3>

<p><code><a href="#topic+cycleMatrix">cycleMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A UG graph
allEdges(UG(~ y*v*k +v*k*d+y*d))

## A DAG
allEdges(DAG(u~h+o+p, h~o, o~p))
</code></pre>

<hr>
<h2 id='anger'>
Anger data
</h2><span id='topic+anger'></span>

<h3>Description</h3>

<p>Anger data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(anger)</code></pre>


<h3>Format</h3>

<p>A covariance matrix for 4 variables measured on 684 female students. 
</p>

<dl>
<dt>X</dt><dd><p>anxiety state</p>
</dd>
<dt>Y</dt><dd><p>anger state</p>
</dd>
<dt>Z</dt><dd><p>anxiety trait</p>
</dd>
<dt>U</dt><dd><p>anger trait</p>
</dd>
</dl>
   


<h3>Details</h3>

<p> Trait variables are viewed as stable personality characteristics, and
state variables denote behaviour in specific situations. 
See Cox and Wermuth (1996).
</p>


<h3>References</h3>

<p>Cox, D. R. and Wermuth, N. (1996). <em>Multivariate
dependencies</em>. London: Chapman and Hall.
</p>
<p>Cox, D.R. and Wermuth, N. (1990). <em>An approximation to maximum likelihood
estimates in reduced models</em>. 77(4), 747-761. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Fit a chordless 4-cycle model 
data(anger) 
G = UG(~ Y*X + X*Z + Z*U + U*Y)
fitConGraph(G,anger, 684) 
</code></pre>

<hr>
<h2 id='basiSet'>Basis set of a DAG</h2><span id='topic+basiSet'></span>

<h3>Description</h3>

<p>Finds a basis set for the conditional independencies
implied by a directed acyclic graph, that is a minimal set of
independencies that imply all the other ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basiSet(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basiSet_+3A_amat">amat</code></td>
<td>
<p>a square matrix with dimnames representing the adjacency matrix
of a DAG.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a DAG and a pair of non adjacent nodes
<code class="reqn">(i,j)</code> such that <code class="reqn">j</code> has higher causal order than <code class="reqn">i</code>,
the set of independency statements <code class="reqn">i</code> independent of
<code class="reqn">j</code> given the union of the parents of both <code class="reqn">i</code> and <code class="reqn">j</code>
is a basis set (see Shipley, 2000). This basis set has the property
to lead to independent test statistics.
</p>


<h3>Value</h3>

<p>a list of vectors representing several conditional independence
statements. Each vector contains the names of two non adjacent
nodes followed by the names of nodes in the conditioning set (which
may be empty).
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Shipley, B. (2000). A new inferential test
for path models based on directed acyclic graphs. <em>Structural
Equation Modeling</em>, 7(2), 206&ndash;218.</p>


<h3>See Also</h3>

<p><code><a href="#topic+shipley.test">shipley.test</a></code>, <code><a href="#topic+dSep">dSep</a></code>, <code><a href="#topic+DAG">DAG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## See Shipley (2000), Figure 2, p. 213
A &lt;- DAG(x5~ x3+x4, x3~ x2, x4~x2, x2~ x1)
basiSet(A)
</code></pre>

<hr>
<h2 id='bfsearch'>Breadth first search</h2><span id='topic+bfsearch'></span>

<h3>Description</h3>

<p>Breadth-first search of a connected undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfsearch(amat, v = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bfsearch_+3A_amat">amat</code></td>
<td>
<p>a symmetric matrix with dimnames specifying the adjacency
matrix of the undirected graph</p>
</td></tr>
<tr><td><code id="bfsearch_+3A_v">v</code></td>
<td>
<p>an integer, indicating the starting node of the
search. Defaults to the first node.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Breadth-first search is a systematic method for exploring a graph.
The algorithm is taken from Aho, Hopcroft &amp; Ullman (1983).
</p>


<h3>Value</h3>

<table>
<tr><td><code>tree</code></td>
<td>
<p>the edge matrix of the resulting spanning tree</p>
</td></tr>
<tr><td><code>branches</code></td>
<td>
<p>a matrix with two columns, giving the indices of the
branches of the spanning tree</p>
</td></tr>
<tr><td><code>chords</code></td>
<td>
<p>a matrix with two columns, giving the indices of the
chords of the spanning tree</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Aho, A.V., Hopcrtoft, J.E. &amp; Ullman, J.D. (1983). <em>Data structures
and algorithms.</em> Reading: Addison-Wesley.
</p>
<p>Thulasiraman, K. &amp; Swamy, M.N.S. (1992). <em>Graphs: theory and algorithms</em>. New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UG">UG</a></code>, <code><a href="#topic+findPath">findPath</a></code>, <code><a href="#topic+cycleMatrix">cycleMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Finding a spanning tree of the butterfly graph
bfsearch(UG(~ a*b*o + o*u*j))
## Starting from another node
bfsearch(UG(~ a*b*o + o*u*j), v=3)
</code></pre>

<hr>
<h2 id='binve'>
Inverts a marginal log-linear parametrization
</h2><span id='topic+binve'></span>

<h3>Description</h3>

<p>Inverts a marginal log-linear parametrization.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binve(eta, C, M, G, maxit = 500, print = FALSE, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binve_+3A_eta">eta</code></td>
<td>

<p>a vector of dimension <code>t-1</code> where <code>t</code> is the number of cells
of a contingency table.  
</p>
</td></tr>
<tr><td><code id="binve_+3A_c">C</code></td>
<td>

<p>A contrast matrix. 
</p>
</td></tr>
<tr><td><code id="binve_+3A_m">M</code></td>
<td>

<p>A marginalization matrix.
</p>
</td></tr>
<tr><td><code id="binve_+3A_g">G</code></td>
<td>

<p>G is the model matrix of the loglinear parameterization with no constant term.
</p>
</td></tr>
<tr><td><code id="binve_+3A_maxit">maxit</code></td>
<td>

<p>an integer, specifying the maximum number of iterations. Default 500. 
</p>
</td></tr>
<tr><td><code id="binve_+3A_print">print</code></td>
<td>

<p>a logical value: if <code>TRUE</code>, prints the criterion after each cycle.  
</p>
</td></tr>
<tr><td><code id="binve_+3A_tol">tol</code></td>
<td>

<p>A small value specifying the tolerance for the convergence criterion. Default:
<code>1e-10</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A marginal log-linear link is defined by <code class="reqn">\eta = C  (M \log p)</code>. See 
Bartolucci et al. (2007).
</p>


<h3>Value</h3>

<p>A vector of probabilities <code>p</code>.
</p>


<h3>Note</h3>

<p>From a Matlab function by A. Forcina, University of Perugia, Italy.
</p>


<h3>Author(s)</h3>

<p>Antonio Forcina, Giovanni M. Marchetti
</p>


<h3>References</h3>

<p>Bartolucci, F., Colombi, R. and Forcina, A. (2007). An extended class 
of marginal link functions for modelling contingency tables 
by equality and inequality constraints. Statist. Sinica 17, 691-711.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.mlogit">mat.mlogit</a></code>
</p>

<hr>
<h2 id='blkdiag'>
Block diagonal matrix
</h2><span id='topic+blkdiag'></span>

<h3>Description</h3>

<p>Block diagonal concatenation of input arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blkdiag(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blkdiag_+3A_...">...</code></td>
<td>

<p>Variable number of matrices <code>M1, M2, ...</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A block diagonal matrix <code>diag(M1, M2, ...)</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diag">diag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- c(1,1,2,2); Z &lt;- c(10, 20, 30, 40); A &lt;- factor(c(1,2,2,2))
blkdiag(model.matrix(~X+Z), model.matrix(~A))
</code></pre>

<hr>
<h2 id='blodiag'>
Block diagonal matrix
</h2><span id='topic+blodiag'></span>

<h3>Description</h3>

<p>Split a vector x into a block diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blodiag(x, blo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blodiag_+3A_x">x</code></td>
<td>

<p>A vector of length <code>n</code>.
</p>
</td></tr>
<tr><td><code id="blodiag_+3A_blo">blo</code></td>
<td>

<p>A vector of positive integers such that <code>sum(blo) == n</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A block-diagonal matrix with as many row as elements of <code>blo</code> and <code>n</code> columns.
The vector <code>x</code> is split into <code>length(blo)</code> sub-vectors and these are the blocks  
of the resulting matrix.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blkdiag">blkdiag</a></code>, <code><a href="base.html#topic+diag">diag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>blodiag(1:10, blo = c(2, 3, 5)) 
blodiag(1:10, blo = c(3,4,0,1))
</code></pre>

<hr>
<h2 id='checkIdent'>Identifiability of a model with one latent variable</h2><span id='topic+checkIdent'></span>

<h3>Description</h3>

<p>Checks  four sufficient conditions for
identifiability of a Gaussian DAG model
with one latent variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIdent(amat, latent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkIdent_+3A_amat">amat</code></td>
<td>
<p>a square matrix with dimnames,
representing the adjacency matrix of a DAG.</p>
</td></tr>
<tr><td><code id="checkIdent_+3A_latent">latent</code></td>
<td>
<p>an integer representing the latent variables among the
nodes, or the name of the node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stanghellini and Wermuth (2005) give some
sufficient conditions for checking if a Gaussian
model that factorizes according to a DAG is identified
when there is one hidden node over which we marginalize.
Specifically, the function checks the conditions of
Theorem 1, (i) and (ii) and of Theorem 2 (i) and (ii).
</p>


<h3>Value</h3>

<p>a vector of length  four, indicating if the model is identified
according to the conditions of theorems 1 and 2 in Stanghellini
&amp; Wermuth (2005). The answer is <code>TRUE</code> if the  condition holds
and thus the model is globally identified or <code>FALSE</code> if the
condition fails, and thus we do not know if the model is identifiable.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Stanghellini, E. &amp; Wermuth, N. (2005). On the
identification of path-analysis models with one
hidden variable. <em>Biometrika</em>, 92(2), 337-350.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isGident">isGident</a></code>,  <code><a href="#topic+InducedGraphs">InducedGraphs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## See DAG in Figure 4 (a) in Stanghellini &amp; Wermuth (2005)
d &lt;- DAG(y1 ~ y3, y2 ~ y3 + y5, y3 ~ y4 + y5, y4 ~ y6)
checkIdent(d, "y3")  # Identifiable
checkIdent(d, "y4")  # Not identifiable?

## See DAG in Figure 5 (a) in Stanghellini &amp; Wermuth (2005)
d &lt;- DAG(y1 ~ y5+y4, y2 ~ y5+y4, y3 ~ y5+y4)
checkIdent(d, "y4")  # Identifiable
checkIdent(d, "y5")  # Identifiable

## A simple function to check identifiability for each node

is.ident &lt;- function(amat){
### Check suff. conditions on each node of a DAG.
   p &lt;- nrow(amat)
   ## Degrees of freedom
     df &lt;- p*(p+1)/2 - p  - sum(amat==1) - p + 1
   if(df &lt;= 0)
       warning(paste("The degrees of freedom are ", df))
    a &lt;- rownames(amat)
    for(i in a) {
      b &lt;- checkIdent(amat, latent=i)
      if(TRUE %in% b)
        cat("Node", i, names(b)[!is.na(b)], "\n")
      else
        cat("Unknown.\n")
    }
  }
</code></pre>

<hr>
<h2 id='cmpGraph'>The complementary graph</h2><span id='topic+cmpGraph'></span>

<h3>Description</h3>

<p>Finds the complementary graph of an undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmpGraph(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmpGraph_+3A_amat">amat</code></td>
<td>
<p>the adjacency matrix of an undirected graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The complementary graph of an UG is the graph that has the same set
of nodes and an undirected edge connecting <code class="reqn">i</code> and <code class="reqn">j</code>
whenever there is not an <code class="reqn">(i,j)</code> edge in the original UG.
</p>


<h3>Value</h3>

<p>the edge matrix of the complementary graph.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Lauritzen, S. (1996). <em>Graphical models</em>. Oxford:
Clarendon Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+UG">UG</a></code>, <code><a href="#topic+DAG">DAG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A chordless four-cycle
four &lt;- UG(~ a*b + b*d + d*e + e*a)
four
cmpGraph(four)
</code></pre>

<hr>
<h2 id='conComp'>Connectivity components</h2><span id='topic+conComp'></span>

<h3>Description</h3>

<p>Finds the connectivity components of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conComp(amat, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conComp_+3A_amat">amat</code></td>
<td>
<p>a square matrix with dimnames, the adjacency matrix of an UG.</p>
</td></tr>
<tr><td><code id="conComp_+3A_method">method</code></td>
<td>
<p>an integer 1 or 2 to choose the method used to find the components. Method 2 is more efficient for large graphs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector representing a partition of the set of nodes.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Lauritzen, S. (1996). <em>Graphical models</em>. Oxford:
Clarendon Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+UG">UG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## three connected components
conComp(UG(~a*c+c*d+e+g*o*u))
## a connected graph
conComp(UG(~ a*b+b*c+c*d+d*a))
</code></pre>

<hr>
<h2 id='correlations'>Marginal and partial correlations</h2><span id='topic+correlations'></span>

<h3>Description</h3>

<p>Computes a correlation matrix with ones along the
diagonal, marginal correlations in the lower triangle and
partial correlations given all remaining variables in the
upper triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlations(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlations_+3A_x">x</code></td>
<td>
<p>a square symmetric matrix, a covariance matrix, or a
data.frame for n observations and p variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square correlation matrix with marginal correlations (lower
triangle) and partial correlations (upper triangle).
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Cox, D. R. &amp; Wermuth, N. (1996). <em>Multivariate
dependencies</em>. London: Chapman &amp; Hall.</p>


<h3>See Also</h3>

<p><code><a href="#topic+parcor">parcor</a></code>,  <code><a href="stats.html#topic+cor">cor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## See Table 6.1 in Cox &amp; Wermuth (1996)
data(glucose)
correlations(glucose)
</code></pre>

<hr>
<h2 id='cycleMatrix'>Fundamental cycles</h2><span id='topic+cycleMatrix'></span>

<h3>Description</h3>

<p>Finds the matrix of fundamental cycles of a connected undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cycleMatrix(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cycleMatrix_+3A_amat">amat</code></td>
<td>
<p>a symmetric matrix with dimnames denoting the adjacency matrix
of the undirected graph. The graph must be connected, otherwise
the function returns an error message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the cycles in an UG can be obtained from combination (ring sum)
of the set of fundamental cycles. The matrix of fundamental cycles
is a Boolean matrix having as rows the fundamental cycles and as
columns the edges of the graph. If an entry is one then the edge
associated to that column belongs to the cycle associated to the row.
</p>


<h3>Value</h3>

<p>a Boolean matrix of the fundamental cycles of the undirected graph.
If   there is no cycle the function returns <code>NULL</code>.</p>


<h3>Note</h3>

<p>This function is used by <code>isGident</code>. The row sum of the
matrix gives the length of the cycles.</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Thulasiraman, K. &amp; Swamy, M.N.S. (1992). <em>Graphs: theory and
algorithms</em>. New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UG">UG</a></code>, <code><a href="#topic+findPath">findPath</a></code>,
<code><a href="#topic+fundCycles">fundCycles</a></code>, <code><a href="#topic+isGident">isGident</a></code>, <code><a href="#topic+bfsearch">bfsearch</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Three cycles
cycleMatrix(UG(~a*b*d+d*e+e*a*f))
## No cycle
 cycleMatrix(UG(~a*b))
## two cycles: the first is even and the second is odd
cm &lt;- cycleMatrix(UG(~a*b+b*c+c*d+d*a+a*u*v))
apply(cm, 1, sum)
</code></pre>

<hr>
<h2 id='DAG'>Directed acyclic graphs (DAGs)</h2><span id='topic+DAG'></span>

<h3>Description</h3>

<p>A simple way to define a DAG by means of regression model
formulae.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DAG(..., order = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DAG_+3A_...">...</code></td>
<td>
<p>a sequence of model formulae</p>
</td></tr>
<tr><td><code id="DAG_+3A_order">order</code></td>
<td>
<p>logical, defaulting to <code>FALSE</code>. If <code>TRUE</code> the nodes of the
DAG are permuted according to the topological order. If
<code>FALSE</code> the nodes are in the order they first appear in the model
formulae (from left to right).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DAG is defined by a sequence of recursive regression models.
Each regression is defined by a model formula.
For each formula the response defines a node of the graph and
the explanatory variables the parents of that node. If the
regressions are not recursive the function returns an error message.
</p>
<p>Some authors prefer the terminology acyclic directed graphs (ADG).
</p>


<h3>Value</h3>

<p>the adjacency matrix of the DAG, i.e. 
a square Boolean matrix of order equal to the number of nodes of the
graph and a one in position <code class="reqn">(i,j)</code> if there is an arrow from
<code class="reqn">i</code> to <code class="reqn">j</code> and zero otherwise.  The rownames of the adjacency
matrix are the nodes of the DAG. 
</p>
<p>If <code>order = TRUE</code> the
adjacency matrix is permuted to have  parents before  children.
This can always be done (in more than one way) for DAGs. The resulting
adjacency matrix is upper triangular. 
</p>


<h3>Note</h3>

<p>The model formulae may contain interactions, but they are
ignored in the graph.</p>


<h3>Author(s)</h3>

<p>G. M. Marchetti</p>


<h3>References</h3>

<p>Lauritzen, S. (1996). <em>Graphical models</em>. Oxford:
Clarendon Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UG">UG</a></code>, <code><a href="#topic+topSort">topSort</a></code>, <code><a href="#topic+edgematrix">edgematrix</a></code>, <code><a href="#topic+fitDag">fitDag</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A Markov chain
DAG(y ~ x, x ~ z, z ~ u)

## Another DAG
DAG(y ~ x + z + u, x ~ u, z ~ u)

## A DAG with an isolated node
DAG(v ~ v, y ~ x + z, z ~ w + u)

## There can be repetitions
DAG(y ~ x + u + v, y ~ z, u ~ v + z)

## Interactions are ignored
DAG(y ~ x*z + z*v, x ~ z)

## A cyclic graph returns an error!
## Not run: DAG(y ~ x, x ~ z, z ~ y)

## The order can be changed
DAG(y ~ z, y ~ x + u + v,  u ~ v + z)

## If you want to order the nodes (topological sort of the DAG)
DAG(y ~ z, y ~ x + u + v,  u ~ v + z, order=TRUE)
</code></pre>

<hr>
<h2 id='derived'>Data on blood pressure body mass and age
</h2><span id='topic+derived'></span>

<h3>Description</h3>

<p>Raw data on blood pressure, body mass and age on 44 
female patients, and covariance matrix for derived variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(derived)</code></pre>


<h3>Format</h3>

<p>A list containing a dataframe
<code>raw</code> with 44 lines and 5 columns and a
symmetric 4x4 covariance matrix <code>S</code>.
</p>
<p>The following is the description of the variables
in the dataframe <code>raw</code>
</p>

<dl>
<dt><code>Sys</code></dt><dd><p>Systolic blood pressure, in mm Hg</p>
</dd>
<dt><code>Dia</code></dt><dd><p>Diastolic blood pressure, in mm Hg</p>
</dd>
<dt><code>Age</code></dt><dd><p>Age of the patient, in years</p>
</dd>
<dt><code>Hei</code></dt><dd><p>Height, in cm</p>
</dd>
<dt><code>Wei</code></dt><dd><p>Weight, in kg</p>
</dd>  
</dl>

<p>The following is the description of the variables
for the covariance matrix <code>S</code>.  
</p>

<dl>
<dt><code>Y</code></dt><dd><p>Derived variable <code>Y=log(Sys/Dia)</code></p>
</dd>
<dt><code>X</code></dt><dd><p>Derived variables <code>X=log(Dia)</code></p>
</dd>
<dt><code>Z</code></dt><dd><p>Body mass index <code>Z=Wei/(Hei/100)^2</code></p>
</dd>
<dt><code>W</code></dt><dd><p>Age</p>
</dd>
</dl>



<h3>References</h3>

<p>Wermuth N. and Cox D.R. (1995). Derived 
variables calculated from similar joint responses:
some characteristics and examples. <em>Computational Statistics and Data
Analysis</em>, 19, 223-234.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A DAG model with a latent variable U
G = DAG(Y ~ Z + U, X ~ U + W, Z ~ W)

data(derived)

# The model fitted using the derived variables
out = fitDagLatent(G, derived$S, n = 44, latent = "U")

# An ancestral graph model marginalizing over U
H = AG(G, M = "U")

# The ancestral graph model fitted obtaining the 
# same result
out2 = fitAncestralGraph(H, derived$S, n = 44)
</code></pre>

<hr>
<h2 id='DG'>Directed graphs</h2><span id='topic+DG'></span>

<h3>Description</h3>

<p>Defines the adjacency of a directed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DG(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DG_+3A_...">...</code></td>
<td>
<p>a sequence of model formulae</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The directed graph is defined by a sequence of models formulae.
For each formula the response defines a node of the graph and
its parents. The graph contains no loops.  
</p>


<h3>Value</h3>

<p>the adjacency matrix of the directed graph, i.e., 
a square Boolean matrix of order equal to the number of nodes of the
graph and a one in position <code class="reqn">(i,j)</code> if there is an arrow from
<code class="reqn">i</code> to <code class="reqn">j</code> and zero otherwise.  The dimnames of the adjacency
matrix are the labels for the nodes of the graph. 
</p>


<h3>Author(s)</h3>

<p>G. M. Marchetti</p>


<h3>References</h3>

<p>Lauritzen, S. (1996). <em>Graphical models</em>. Oxford:
Clarendon Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DAG">DAG</a></code>, <code><a href="#topic+UG">UG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A DAG
DG(y ~ x, x ~ z, z ~ u)

## A cyclic directed graph
DG(y ~ x, x ~ z, z ~ y)

## A graph with two arrows between two nodes
DG(y ~ x, x ~ y)

## There can be isolated nodes
DG(y ~ x, x ~ x)
</code></pre>

<hr>
<h2 id='diagv'>
Matrix product with a diagonal matrix 
</h2><span id='topic+diagv'></span>

<h3>Description</h3>

<p>Computes faster the product of a diagonal matrix times a full matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagv(v, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagv_+3A_v">v</code></td>
<td>

<p>A numeric vector specifying the elements on the diagonal of a matrix.
</p>
</td></tr>
<tr><td><code id="diagv_+3A_m">M</code></td>
<td>

<p>A numeric matrix  compatible with the product <code class="reqn">D_v M</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes <code class="reqn">N = D_v M</code> where <code class="reqn">D_v</code> is diagonal 
avoiding the <code>diag</code> operator.
</p>


<h3>Value</h3>

<p>A matrix <code>N</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+diag">diag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- 1:1000
M &lt;- matrix(runif(3000), 1000, 3)
dim(diagv(v, M))
</code></pre>

<hr>
<h2 id='drawGraph'>Drawing a graph with a simple point and click interface.</h2><span id='topic+drawGraph'></span>

<h3>Description</h3>

<p>Draw a graph from its adjacency matrix representation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawGraph(amat, coor = NULL, adjust = FALSE, alpha = 1.5,
                beta = 3, lwd = 1, ecol = "blue", bda = 0.1, layout = layout.auto)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawGraph_+3A_amat">amat</code></td>
<td>
<p>the adjacency matrix representation of the graph. This
can be an undirected graph, a directed acyclic graph or a mixed
graph with at most a summary graph structure. See also <code><a href="#topic+plotGraph">plotGraph</a></code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="drawGraph_+3A_coor">coor</code></td>
<td>
<p>an optional matrix of dimensions <code>p</code> x 2 where
<code class="reqn">p</code> is the number of vertices of the graph. If <code>coor=NULL</code>
then the function chooses a default position for the nodes.</p>
</td></tr>
<tr><td><code id="drawGraph_+3A_adjust">adjust</code></td>
<td>
<p>a logical value, defaults to <code>FALSE</code>. If <code>TRUE</code> the graph is plotted and the system waits until the mouse button is pressed (same behaviour
of <code>locator</code> function.</p>
</td></tr>
<tr><td><code id="drawGraph_+3A_alpha">alpha</code></td>
<td>
<p>a positive value between controlling the
distance from the end of the edges to the nodes of the graph.</p>
</td></tr>
<tr><td><code id="drawGraph_+3A_beta">beta</code></td>
<td>
<p>a positive value controlling the distance of the labels of
the variables from the nodes.</p>
</td></tr>
<tr><td><code id="drawGraph_+3A_lwd">lwd</code></td>
<td>
<p>line width of the edges (default: 1).</p>
</td></tr>
<tr><td><code id="drawGraph_+3A_ecol">ecol</code></td>
<td>
<p>color of the edges (default: &quot;blue&quot;).</p>
</td></tr>
<tr><td><code id="drawGraph_+3A_bda">bda</code></td>
<td>
<p>bidirected edge arrow length (default: 0.1).</p>
</td></tr>
<tr><td><code id="drawGraph_+3A_layout">layout</code></td>
<td>
<p>The name of a function used to compute the (initial) layout of the graph. The default is <code>layout.auto</code>. This can be further adjusted if <code>adjust</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a very simple tool useful for displaying small graphs,
with a rudimentary interface for moving nodes and edges of a given
graph and  adjusting the final plot. For better displays use
<span class="pkg">dynamicGraph</span> or <span class="pkg">Rgraphviz</span> package in Bioconductor project.
</p>


<h3>Value</h3>

<p>The function plots the graph with a initial positioning of the nodes,
as  specified by  <code>coor</code> and remains in a waiting state.
The position of each node can be shifted
by pointing and clicking (with the first mouse button) close to the node.
When the mouse button is pressed the node which is closer to the
selected point is moved to that position.
Thus, one must be careful to click closer to
the selected node than to any other node.
The nodes can be moved to any position by repeating the
previous operation.
The adjustment process is terminated by pressing any mouse
button other than the first.
</p>
<p>At the end of the process, the function returns invisibly the
coordinates of the nodes. The coordinates may be used later to
redisplay the graph.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p><span class="pkg">dynamicGraph</span>, <span class="pkg">Rgraphwiz</span>, <a href="https://www.bioconductor.org">https://www.bioconductor.org</a>.
</p>
<p>GraphViz, Graph Visualization Project. AT&amp;T Research.
<a href="https://www.graphviz.org">https://www.graphviz.org</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UG">UG</a></code>, <code><a href="#topic+DAG">DAG</a></code>, <code><a href="#topic+makeMG">makeMG</a></code>, <code><a href="#topic+plotGraph">plotGraph</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A directed acyclic graph
d &lt;- DAG(y1 ~ y2+y6, y2 ~ y3, y3 ~ y5+y6, y4 ~ y5+y6)
## Not run: drawGraph(d)

## An undirected graph
g &lt;- UG(~giova*anto*armo + anto*arj*sara)
## Not run: drawGraph(d)

## An ancestral graph
ag &lt;- makeMG(ug=UG(~y0*y1), dg=DAG(y4~y2, y2~y1), bg=UG(~y2*y3+y3*y4))
drawGraph(ag, adjust = FALSE)
drawGraph(ag, adjust = FALSE)

## A more complex example with coordinates: the UNIX evolution
xy &lt;-
structure(c(5, 15, 23, 25, 26, 17, 8, 6, 6, 7, 39, 33, 23, 49,
19, 34, 13, 29, 50, 68, 70, 86, 89, 64, 81, 45, 64, 49, 64, 87,
65, 65, 44, 37, 64, 68, 73, 85, 83, 95, 84, 0, 7, 15, 27, 44,
37, 36, 20, 51, 65, 44, 64, 59, 73, 69, 78, 81, 90, 97, 89, 72,
85, 74, 62, 68, 59, 52, 48, 43, 50, 34, 21, 18, 5, 1, 10, 2,
11, 2, 1, 44), .Dim = c(41, 2), .Dimnames = list(NULL, c("x",
"y")))
Unix &lt;- DAG(
                SystemV.3 ~ SystemV.2,
                SystemV.2 ~ SystemV.0,
                SystemV.0 ~ TS4.0,
                TS4.0 ~ Unix.TS3.0 + Unix.TS.PP + CB.Unix.3,
                PDP11.SysV ~ CB.Unix.3,
                CB.Unix.3 ~ CB.Unix.2,
                CB.Unix.2 ~ CB.Unix.1,
                Unix.TS.PP ~ CB.Unix.3,
                Unix.TS3.0 ~ Unix.TS1.0 + PWB2.0 + USG3.0 + Interdata,
                USG3.0 ~ USG2.0,
                PWB2.0 ~ Interdata + PWB1.2,
                USG2.0 ~ USG1.0,
                CB.Unix.1 ~ USG1.0,
                PWB1.2 ~ PWB1.0,
                USG1.0 ~ PWB1.0,
                PWB1.0 ~ FifthEd,
                SixthEd ~ FifthEd,
                LSX ~ SixthEd,
                MiniUnix ~ SixthEd,
                Interdata ~ SixthEd,
                Wollongong ~ SixthEd,
                SeventhEd ~ Interdata,
                BSD1 ~ SixthEd,
                Xenix ~ SeventhEd,
                V32 ~ SeventhEd,
                Uniplus ~ SeventhEd,
                BSD3 ~ V32,
                BSD2 ~ BSD1,
                BSD4 ~ BSD3,
                BSD4.1 ~ BSD4,
                EigthEd ~ SeventhEd + BSD4.1,
                NinethEd ~ EigthEd,
                Ultrix32 ~ BSD4.2,
                BSD4.2 ~ BSD4.1,
                BSD4.3 ~ BSD4.2,
                BSD2.8 ~ BSD4.1 + BSD2,
                BSD2.9 ~ BSD2.8,
                Ultrix11 ~ BSD2.8 + V7M + SeventhEd,
                V7M ~ SeventhEd
                )
drawGraph(Unix, coor=xy, adjust=FALSE)
# dev.print(file="unix.fig", device=xfig) # Edit the graph with Xfig
</code></pre>

<hr>
<h2 id='dSep'>d-separation</h2><span id='topic+dSep'></span>

<h3>Description</h3>

<p>Determines if in a directed acyclic graph two set of nodes a d-separated
by a third set of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dSep(amat, first, second, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dSep_+3A_amat">amat</code></td>
<td>
<p>a Boolean matrix with dimnames, representing the adjacency matrix of a directed
acyclic graph. The function does not check if this is the case. See
the function <code>isAcyclic</code>. </p>
</td></tr>
<tr><td><code id="dSep_+3A_first">first</code></td>
<td>
<p>a vector representing  a subset of nodes of the DAG.
The vector should be a character vector of the
names of the variables matching the names of the nodes in
<code>rownames(A)</code>. It can be also a numeric vector of indices. </p>
</td></tr>
<tr><td><code id="dSep_+3A_second">second</code></td>
<td>
<p>a vector representing  another subset of nodes of the DAG.
The set <code>second</code> must be disjoint from <code>first</code>.
The mode of <code>second</code> must match the mode of <code>first</code>.</p>
</td></tr>
<tr><td><code id="dSep_+3A_cond">cond</code></td>
<td>
<p>a vector representing a conditioning subset of nodes.
The set <code>cond</code> must be disjoint from the other two sets and
must share the same mode.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>d-separation is a fundamental concept introduced by Pearl (1988). 
</p>


<h3>Value</h3>

<p>a logical value. <code>TRUE</code> if <code>first</code> and <code>second</code> are d-separated
by <code>cond</code>. 
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Pearl, J. (1988). <em>Probabilistic reasoning in intelligent
systems.</em> San Mateo: Morgan Kaufmann.
</p>
<p>Lauritzen, S. (1996). <em>Graphical models</em>. Oxford:
Clarendon Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DAG">DAG</a></code>, <code><a href="#topic+shipley.test">shipley.test</a></code>,
<code><a href="#topic+inducedCovGraph">inducedCovGraph</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Conditioning on a transition node
dSep(DAG(y ~ x, x ~ z), first="y", second="z", cond = "x")
## Conditioning on a collision node (collider)
dSep(DAG(y ~ x, y ~ z), first="x", second="z", cond = "y")
## Conditioning on a source node
dSep(DAG(y ~ x, z ~ x), first="y", second="z", cond = "x")
## Marginal independence
dSep(DAG(y ~ x, y ~ z), first="x", second="z", cond = NULL)
## The DAG defined on p.~47 of Lauritzen (1996)
dag &lt;- DAG(g ~ x, h ~ x+f, f ~ b, x ~ l+d, d ~ c, c ~ a, l ~ y, y ~ b)
dSep(dag, first="a", second="b", cond=c("x", "y"))
dSep(dag, first="a", second=c("b", "d"), cond=c("x", "y"))
</code></pre>

<hr>
<h2 id='edgematrix'>Edge matrix of a graph</h2><span id='topic+edgematrix'></span>

<h3>Description</h3>

<p>Transforms the adjacency matrix of a graph into
an &ldquo;edge matrix&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgematrix(E, inv=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgematrix_+3A_e">E</code></td>
<td>
<p>a square matrix, representing the adjacency matrix of a
graph.</p>
</td></tr>
<tr><td><code id="edgematrix_+3A_inv">inv</code></td>
<td>
<p>a logical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some matrix computations for graph objects the adjacency matrix
of the graph is transformed into an &ldquo;edge matrix&rdquo;. Briefly,
if <code class="reqn">E</code> is the adjacency matrix of the
graph, the edge matrix is <code class="reqn">A = sign(E+I)^T=[a_{ij}]</code>.
Thus, <code class="reqn">A</code> has ones along the diagonal
and if the graph has no edge between nodes <code class="reqn">i</code> and <code class="reqn">j</code> the entries
<code class="reqn">a_{i,j}</code> and <code class="reqn">a_{j,i}</code> are both zero.
If there is an arrow from <code class="reqn">j</code> to <code class="reqn">i</code>
<code class="reqn">a_{i,j}=1</code> and  <code class="reqn">a_{j,i} = 0</code>. If there is an undirected edge, both
<code class="reqn">a_{i,j}=a_{j,i}=1</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>A</code></td>
<td>
<p>the edge matrix of the graph.
If <code>TRUE</code> the nodes are sorted in
inverted topological order and the edge matrix is upper triangular.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Wermuth, N. (2003). Analysing social science data with
graphical Markov models. In: <em>Highly Structured Stochastic
Systems.</em> P. Green, N. Hjort &amp; T. Richardson (eds.),
47&ndash;52. Oxford: Oxford University Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjMatrix">adjMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>amat &lt;- DAG(y ~ x+z, z~u+v)
amat
edgematrix(amat)
edgematrix(amat, inv=TRUE)
</code></pre>

<hr>
<h2 id='essentialGraph'>Essential graph</h2><span id='topic+essentialGraph'></span>

<h3>Description</h3>

<p>Find the essential graph from a given directed acyclic graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>essentialGraph(dagx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="essentialGraph_+3A_dagx">dagx</code></td>
<td>
<p>a square binary matrix, the adjacency matrix of a directed
acyclic graph. The names of rows and of the columns
are the nodes of the DAG.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a DAG into the Essential Graph.
Is implemented by the algorithm by D.M.Chickering (1995).
</p>


<h3>Value</h3>

<p>returns the adjacency matrix of the essential graph.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti, from a MATLAB function
by Tomas Kocka, AAU</p>


<h3>References</h3>

<p>Chickering, D.M. (1995). A transformational characterization of equivalent Bayesian network structures. <em>Proceedings of Eleventh  Conference on Uncertainty in Artificial Intelligence</em>, Montreal, QU,  87-98. Morgan Kaufmann.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DAG">DAG</a></code>, <code><a href="#topic+InducedGraphs">InducedGraphs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dag = DAG(U ~ Y+Z, Y~X, Z~X)
essentialGraph(dag)
</code></pre>

<hr>
<h2 id='findPath'>Finding paths</h2><span id='topic+findPath'></span>

<h3>Description</h3>

<p>Finds one path between two nodes of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPath(amat, st, en, path = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPath_+3A_amat">amat</code></td>
<td>
<p>a square Boolean matrix with dimnames, the adjacency matrix of a graph.</p>
</td></tr>
<tr><td><code id="findPath_+3A_st">st</code></td>
<td>
<p>an integer, the starting node.</p>
</td></tr>
<tr><td><code id="findPath_+3A_en">en</code></td>
<td>
<p>an integer, the ending node.</p>
</td></tr>
<tr><td><code id="findPath_+3A_path">path</code></td>
<td>
<p>a vector of integers, used in recursive calls. At the
beginning is <code>NULL</code>. It should not be modified by the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of integers, the sequence of nodes of a path,
starting from <code>st</code> to <code>en</code>. In some graphs
(spanning trees) there is only one path between two nodes.
</p>


<h3>Note</h3>

<p>This function is not intended to be directly called by the user.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti, translating the original <span class="pkg">Python</span>
code (see references).</p>


<h3>References</h3>

<p>Python Softftware Foundation (2003). Python Patterns &mdash;   Implementing Graphs. <a href="https://www.python.org/doc/essays/graphs/">https://www.python.org/doc/essays/graphs/</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fundCycles">fundCycles</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A (single) path on a spanning tree
findPath(bfsearch(UG(~ a*b*c + b*d + d*e+ e*c))$tree, st=1, en=5)
</code></pre>

<hr>
<h2 id='fitAncestralGraph'>Fitting of Gaussian Ancestral Graph Models</h2><span id='topic+fitAncestralGraph'></span>

<h3>Description</h3>

<p>Iterative conditional fitting of Gaussian Ancestral Graph Models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitAncestralGraph(amat, S, n, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitAncestralGraph_+3A_amat">amat</code></td>
<td>
<p>a square matrix, representing the adjacency matrix of
an ancestral graph.</p>
</td></tr>
<tr><td><code id="fitAncestralGraph_+3A_s">S</code></td>
<td>
<p>a symmetric positive definite matrix with row and col names, the
sample covariance matrix.</p>
</td></tr>
<tr><td><code id="fitAncestralGraph_+3A_n">n</code></td>
<td>
<p>the sample size, a positive integer.</p>
</td></tr>
<tr><td><code id="fitAncestralGraph_+3A_tol">tol</code></td>
<td>
<p>a small positive number indicating the tolerance
used in convergence checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the Gaussian case, the models can be parameterized
using precision parameters, regression coefficients, and error
covariances (compare Richardson and Spirtes, 2002, Section 8). This
function finds the MLE <code class="reqn">\hat \Lambda</code> of the precision 
parameters by fitting a concentration  
graph model. The MLE <code class="reqn">\hat B</code> of the regression coefficients and
the MLE <code class="reqn">\hat\Omega</code> of the error covariances are obtained by
iterative conditional fitting (Drton and Richardson, 2003, 2004). The
three sets of parameters are 
combined to the MLE <code class="reqn">\hat\Sigma</code> of the covariance matrix by
matrix multiplication: 
</p>
<p style="text-align: center;"><code class="reqn">\hat\Sigma = \hat B^{-1}(\hat \Lambda+\hat\Omega)\hat
    B^{-T}.</code>
</p>

<p>Note that in Richardson and Spirtes (2002), the matrices <code class="reqn">\Lambda</code>
and <code class="reqn">\Omega</code> are defined as submatrices. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>Shat</code></td>
<td>
<p>the fitted covariance matrix.</p>
</td></tr>
<tr><td><code>Lhat</code></td>
<td>
<p>matrix of the fitted precisions associated with undirected
edges and vertices that do not have an arrowhead pointing at them.</p>
</td></tr>
<tr><td><code>Bhat</code></td>
<td>
<p>matrix of the fitted regression coefficients
associated to the directed edges.  Precisely said <code>Bhat</code>
contains ones on the diagonal and the off-diagonal entry
<code class="reqn">(i,j)</code> equals the <em>negated</em> MLE of the regression
coefficient for variable <code class="reqn">j</code> in the regression of variable
<code class="reqn">i</code> on its parents. Note that this <code class="reqn">(i,j)</code> entry
in <code>Bhat</code> corresponds to a directed edge <code class="reqn">j \to i</code>,
and thus to a one as <code class="reqn">(j,i)</code> entry in the adjacency matrix.</p>
</td></tr>
<tr><td><code>Ohat</code></td>
<td>
<p>matrix of the error covariances and variances of the residuals 
between regression equations associated with bi-directed edges and
vertices with an arrowhead pointing at them.</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>the &lsquo;deviance&rsquo; of the model.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom.</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>the iterations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mathias Drton</p>


<h3>References</h3>

 
<p>Drton, M. and Richardson, T. S. (2003). A new algorithm for
maximum likelihood estimation in Gaussian graphical models for
marginal independence. <em>Proceedings
of the Nineteenth Conference on Uncertainty in Artificial
Intelligence</em>, 184-191.
</p>
<p>Drton, M. and Richardson, T. S. (2004). Iterative Conditional Fitting
for Gaussian Ancestral Graph Models.  Proceedings
of the 20th Conference on Uncertainty in Artificial Intelligence,
Department of Statistics, 130-137.
</p>
<p>Richardson, T. S. and Spirtes, P. (2002). Ancestral Graph Markov
Models. <em>Annals of Statistics</em>. 30(4), 962-1030.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitCovGraph">fitCovGraph</a></code>, <code><a href="#topic+icf">icf</a></code>,
<code><a href="#topic+makeMG">makeMG</a></code>, <code><a href="#topic+fitDag">fitDag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A covariance matrix
"S" &lt;- structure(c(2.93, -1.7, 0.76, -0.06,
                  -1.7, 1.64, -0.78, 0.1,
                   0.76, -0.78, 1.66, -0.78,
                  -0.06, 0.1, -0.78, 0.81), .Dim = c(4,4),
                 .Dimnames = list(c("y", "x", "z", "u"), c("y", "x", "z", "u")))
## The following should give the same fit.   
## Fit an ancestral graph y -&gt; x &lt;-&gt; z &lt;- u
fitAncestralGraph(ag1 &lt;- makeMG(dg=DAG(x~y,z~u), bg = UG(~x*z)), S, n=100)

## Fit an ancestral graph y &lt;-&gt; x &lt;-&gt; z &lt;-&gt; u
fitAncestralGraph(ag2 &lt;- makeMG(bg= UG(~y*x+x*z+z*u)), S, n=100)

## Fit the same graph with fitCovGraph
fitCovGraph(ag2, S, n=100)    

## Another example for the mathematics marks data

data(marks)
S &lt;- var(marks)
mag1 &lt;- makeMG(bg=UG(~mechanics*vectors*algebra+algebra*analysis*statistics))
fitAncestralGraph(mag1, S, n=88)

mag2 &lt;- makeMG(ug=UG(~mechanics*vectors+analysis*statistics),
               dg=DAG(algebra~mechanics+vectors+analysis+statistics))
fitAncestralGraph(mag2, S, n=88) # Same fit as above
</code></pre>

<hr>
<h2 id='fitConGraph'>Fitting a Gaussian concentration graph model</h2><span id='topic+fitConGraph'></span>

<h3>Description</h3>

<p>Fits a concentration graph (a covariance selection model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitConGraph(amat, S, n, cli = NULL, alg = 3, pri = FALSE, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitConGraph_+3A_amat">amat</code></td>
<td>
<p>a square Boolean matrix representing
the adjacency matrix of an UG</p>
</td></tr>
<tr><td><code id="fitConGraph_+3A_s">S</code></td>
<td>
<p>the sample covariance matrix</p>
</td></tr>
<tr><td><code id="fitConGraph_+3A_n">n</code></td>
<td>
<p>an integer denoting the sample size</p>
</td></tr>
<tr><td><code id="fitConGraph_+3A_cli">cli</code></td>
<td>
<p>a list containing the cliques of the graph. The components
of the list are character vectors containing the names of the nodes in the
cliques. The names must match the names of the vertices. The
knowledge of the cliques is not needed. If the cliques are not specified
the function uses the algorithm
by Hastie et al. (2009, p. 446).</p>
</td></tr>
<tr><td><code id="fitConGraph_+3A_alg">alg</code></td>
<td>
<p>The algorithm used.</p>
</td></tr>
<tr><td><code id="fitConGraph_+3A_pri">pri</code></td>
<td>
<p>If TRUE is verbose</p>
</td></tr>
<tr><td><code id="fitConGraph_+3A_tol">tol</code></td>
<td>
<p>a small positive number indicating the tolerance
used in convergence tests.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithms for fitting concentration graph
models by maximum likelihood are discussed in Speed and Kiiveri (1986).
If the cliques are known
the function uses the iterative proportional
fitting algorithm described  by Whittaker (1990, p. 184).
If the cliques are not specified
the function uses the algorithm
by Hastie et al. (2009, p. 631ff).
</p>


<h3>Value</h3>

<table>
<tr><td><code>Shat</code></td>
<td>
<p>the fitted covariance matrix.</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>the &lsquo;deviance&rsquo; of the model.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom.</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>the iterations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Cox, D. R. &amp; Wermuth, N. (1996). <em>Multivariate
dependencies</em>. London: Chapman &amp; Hall.
</p>
<p>Hastie, T.,  Tibshirani, R. and Friedman, J. (2009).
<em>The elements of statistical learning.</em>  Springer Verlag: New York.
</p>
<p>Speed, T.P. and Kiiveri, H (1986). Gaussian
Markov distributions over finite graphs. <em>Annals of
Statistics</em>, 14, 138&ndash;150.
</p>
<p>Whittaker, J. (1990). <em>Graphical models in applied
multivariate statistics</em>. Chichester: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UG">UG</a></code>, <code><a href="#topic+fitDag">fitDag</a></code>,
<code><a href="#topic+marks">marks</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A model for the mathematics marks (Whittaker, 1990)
data(marks)
## A butterfly concentration graph
G &lt;- UG(~ mechanics*vectors*algebra + algebra*analysis*statistics)
fitConGraph(G, cov(marks), nrow(marks))
## Using the cliques

cl = list(c("mechanics", "vectors",   "algebra"), c("algebra", "analysis" ,  "statistics"))
fitConGraph(G, S = cov(marks), n = nrow(marks), cli = cl)
</code></pre>

<hr>
<h2 id='fitCovGraph'>Fitting of Gaussian covariance graph models</h2><span id='topic+fitCovGraph'></span>

<h3>Description</h3>

<p>Fits a Gaussian covariance graph model by maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitCovGraph(amat, S,n ,alg = "icf", dual.alg = 2, start.icf = NULL, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitCovGraph_+3A_amat">amat</code></td>
<td>
<p>A symmetric Booloean matrix with dimnames representing
the adjacency matrix of an UG.</p>
</td></tr>
<tr><td><code id="fitCovGraph_+3A_s">S</code></td>
<td>
<p>A symmetric positive definite matrix with dimnames, the
sample covariance matrix.</p>
</td></tr>
<tr><td><code id="fitCovGraph_+3A_n">n</code></td>
<td>
<p>A positive integer, the sample size.</p>
</td></tr>
<tr><td><code id="fitCovGraph_+3A_alg">alg</code></td>
<td>
<p>A character string, the algorithm used.
If  <code>alg="icf"</code> (the default) the algorithm is based on iterative
conditional fitting (see Drton and Richardson, 2003). In this case
the ML estimates are returned.
If  <code>alg="dual"</code> the algorithm is based on the dual
likelihood (see Kauermann, 1996). The fitted values are an approximation
of the ML estimates.
</p>
</td></tr>
<tr><td><code id="fitCovGraph_+3A_dual.alg">dual.alg</code></td>
<td>
<p>And integer equal to 1 or 2. It is used if
<code>alg="dual"</code>. In this case a concentration graph model
is fitted to the inverse of the sample covariance matrix, and
<code>dual.alg</code> is passed to <code>fitConGraph</code> to
specify the algorithm used in <code>fitConGraph</code>.
</p>
</td></tr>
<tr><td><code id="fitCovGraph_+3A_start.icf">start.icf</code></td>
<td>
<p>A symmetric matrix used as starting value
of the algorithm. If <code>start=NULL</code> the starting value
is a diagonal matrix with diagonal entries equal to sample
variances.</p>
</td></tr>
<tr><td><code id="fitCovGraph_+3A_tol">tol</code></td>
<td>
<p>A small positive number indicating the tolerance
used in convergence tests.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A covariance graph is an undirected graph  in which
the variables associated to two non-adjacent nodes
are marginally independent. The edges of these
models are represented by bi-directed edges
(Drton and Richardson, 2003) or by dashed lines
(Cox and Wermuth, 1996).
</p>
<p>By default, this function gives the ML estimates in the covariance
graph model, by iterative conditional fitting (Drton and
Richardson, 2003).  Otherwise, the estimates from a &ldquo;dual
likelihood&rdquo; estimator can be obtained (Kauermann, 1996; Edwards, 2000,
section 7.4).
</p>


<h3>Value</h3>

<table>
<tr><td><code>Shat</code></td>
<td>
<p>the fitted covariance matrix.</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>the &lsquo;deviance&rsquo; of the model.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom.</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>the iterations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mathias Drton</p>


<h3>References</h3>

<p>Cox, D. R. &amp; Wermuth, N. (1996). <em>Multivariate
dependencies</em>. London: Chapman &amp; Hall.
</p>
<p>Drton, M. and Richardson, T. S. (2003). A new algorithm for
maximum likelihood estimation in Gaussian graphical models for
marginal independence. <em>Proceedings
of the Nineteenth Conference on Uncertainty in Artificial
Intelligence</em>, 184&ndash;191.
</p>
<p>Kauermann, G. (1996). On a dualization of graphical
Gaussian models. <em>Scandinavian Journal of Statistics</em>.
23, 105&ndash;116.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitConGraph">fitConGraph</a></code>, <code><a href="#topic+icf">icf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Correlations among four strategies to cope with stress for
## 72 students. Cox &amp; Wermuth (1996), p. 73.

data(stress)

## A chordless 4-cycle covariance graph
G &lt;- UG(~ Y*X + X*U + U*V + V*Y)

fitCovGraph(G, S = stress, n=72)
fitCovGraph(G, S = stress, n=72, alg="dual")
</code></pre>

<hr>
<h2 id='fitDag'>Fitting of Gaussian DAG models</h2><span id='topic+fitDag'></span>

<h3>Description</h3>

<p>Fits linear recursive regressions with independent residuals specified
by a DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitDag(amat, S, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitDag_+3A_amat">amat</code></td>
<td>
<p>a square matrix with dimnames representing
the adjacency matrix of the DAG</p>
</td></tr>
<tr><td><code id="fitDag_+3A_s">S</code></td>
<td>
<p>a symmetric positive definite matrix, the
sample covariance matrix</p>
</td></tr>
<tr><td><code id="fitDag_+3A_n">n</code></td>
<td>
<p>an integer &gt; 0, the sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitDag</code> checks if the order of the nodes in adjacency matrix
is the same of <code>S</code> and if not it reorders the adjacency matrix
to match the order of the variables in <code>S</code>. The nodes
of the adjacency matrix may form a subset of the variables in <code>S</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Shat</code></td>
<td>
<p>the fitted covariance matrix.</p>
</td></tr>
<tr><td><code>Ahat</code></td>
<td>
<p>a square matrix of the fitted regression coefficients. The entry
<code>Ahat[i,j]</code> is minus the regression coefficient of variable
<code>i</code> in the regression equation <code>j</code>. Thus there is
a non zero partial regression coefficient <code>Ahat[i,j]</code>
corresponding to each non zero value  <code>amat[j,i]</code> in
the adjacency matrix.</p>
</td></tr>
<tr><td><code>Dhat</code></td>
<td>
<p>a vector containing the partial variances of each
variable given the parents.</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>the &lsquo;deviance&rsquo; of the model.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Cox, D. R. &amp; Wermuth, N. (1996). <em>Multivariate
dependencies</em>. London: Chapman &amp; Hall.</p>


<h3>See Also</h3>

<p><code><a href="#topic+DAG">DAG</a></code>, <code><a href="#topic+swp">swp</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>dag &lt;- DAG(y ~ x+u, x ~ z, z ~ u)
"S" &lt;- structure(c(2.93, -1.7, 0.76, -0.06,
                   -1.7, 1.64, -0.78, 0.1,
                    0.76, -0.78, 1.66, -0.78,
                    -0.06, 0.1, -0.78, 0.81), .Dim = c(4,4),
         .Dimnames = list(c("y", "x", "z", "u"), c("y", "x", "z", "u")))
fitDag(dag, S, 200)
</code></pre>

<hr>
<h2 id='fitDagLatent'>Fitting Gaussian DAG models with one latent variable</h2><span id='topic+fitDagLatent'></span>

<h3>Description</h3>

<p>Fits by maximum likelihood a Gaussian DAG model where one of the nodes
of the graph is latent and it is marginalised over.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitDagLatent(amat, Syy, n, latent, norm = 1, seed,
             maxit = 9000, tol = 1e-06, pri = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitDagLatent_+3A_amat">amat</code></td>
<td>
<p>a square matrix with dimnames representing
the adjacency matrix of the DAG.</p>
</td></tr>
<tr><td><code id="fitDagLatent_+3A_syy">Syy</code></td>
<td>
<p>a symmetric positive definite matrix,
with dimnames, the sample covariance
matrix of the observed variables.
The set of the observed nodes of the graph must be a subset
of the set of the names of the variables in <code>Syy</code>.</p>
</td></tr>
<tr><td><code id="fitDagLatent_+3A_n">n</code></td>
<td>
<p>a positive integer, the sample size.</p>
</td></tr>
<tr><td><code id="fitDagLatent_+3A_latent">latent</code></td>
<td>
<p>the name of the latent variable.</p>
</td></tr>
<tr><td><code id="fitDagLatent_+3A_norm">norm</code></td>
<td>
<p>an integer, the kind of normalization of the latent
variable.
If <code>norm=1</code>, the latent is scaled to have unit variance. If
<code>norm=2</code>, the latent is scaled to have unit partial variance
given its parents.</p>
</td></tr>
<tr><td><code id="fitDagLatent_+3A_seed">seed</code></td>
<td>
<p>an integer, used by <code>set.seed</code> to specify a random
starting point of the EM algorithm.</p>
</td></tr>
<tr><td><code id="fitDagLatent_+3A_maxit">maxit</code></td>
<td>
<p>an integer denoting the maximum number of iterations
allowed for the EM algorithm. If the convergence criterion is not
satisfied within maxit iterations the algorithms stops and a warning
message is returned.</p>
</td></tr>
<tr><td><code id="fitDagLatent_+3A_tol">tol</code></td>
<td>
<p>a small real value, denoting the tolerance used in testing convergence.</p>
</td></tr>
<tr><td><code id="fitDagLatent_+3A_pri">pri</code></td>
<td>
<p>logical, if <code>pri=TRUE</code> then the value of the deviance at
each iteration is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the EM algorithm used see Kiiveri (1987).  
</p>


<h3>Value</h3>

<table>
<tr><td><code>Shat</code></td>
<td>

<p>the fitted covariance matrix of all the variables
including the latent one. The latent variable is the last.
If <code>norm=1</code> then the variance of the latent variable
is constrained to 1.
</p>
</td></tr>
<tr><td><code>Ahat</code></td>
<td>

<p>a square matrix of the fitted regression coefficients. The entry
<code>Ahat[i,j]</code> is minus the regression coefficient of variable
<code>i</code> in the regression equation <code>j</code>. Thus there is
a non zero partial regression coefficient <code>Ahat[i,j]</code>
corresponding to each non zero value  <code>amat[j,i]</code> in
the adjacency matrix.
</p>
</td></tr>
<tr><td><code>Dhat</code></td>
<td>

<p>a vector containing the partial variances of each
variable given the parents. If <code>norm=2</code> then the
partial variance of the latent variable is constrained to 1. 
</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>

<p>the &lsquo;deviance&rsquo; of the model.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>the degrees of freedom of the model.
</p>
</td></tr>
<tr><td><code>it</code></td>
<td>

<p>the number of EM algorithm iterations at convergence.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Kiiveri,H. T. (1987). An incomplete data approach to the
analysis of covariance structures. <em>Psychometrika</em>, 52, 4,
539&ndash;554.
</p>
<p>Joreskog, K.G. and Goldberger, A.S. (1975). Estimation of a model
with multiple indicators and multiple causes of a single latent
variable.
<em>Journal of the American Statistical Association</em>, 10, 631&ndash;639.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitDag">fitDag</a></code>, <code><a href="#topic+checkIdent">checkIdent</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## data from Joreskog and Goldberger (1975)
V &lt;- matrix(c(1,     0.36,   0.21,  0.10,  0.156, 0.158,
              0.36,  1,      0.265, 0.284, 0.192, 0.324,
              0.210, 0.265,  1,     0.176, 0.136, 0.226,
              0.1,   0.284,  0.176, 1,     0.304, 0.305, 
              0.156, 0.192,  0.136, 0.304, 1,     0.344,
              0.158, 0.324,  0.226, 0.305, 0.344, 1),     6,6)
nod &lt;- c("y1", "y2", "y3", "x1", "x2", "x3")
dimnames(V) &lt;- list(nod,nod)
dag &lt;- DAG(y1 ~ z, y2 ~ z, y3 ~ z, z ~ x1 + x2 + x3, x1~x2+x3, x2~x3) 
fitDagLatent(dag, V, n=530, latent="z", seed=4564)
fitDagLatent(dag, V, n=530, latent="z", norm=2, seed=145)
</code></pre>

<hr>
<h2 id='fitmlogit'>
Multivariate logistic models
</h2><span id='topic+fitmlogit'></span>

<h3>Description</h3>

<p>Fits a logistic regression model to multivariate binary responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitmlogit(..., C = c(), D = c(), data, mit = 100, ep = 1e-80, acc = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitmlogit_+3A_...">...</code></td>
<td>

<p>Model formulae of marginal logistic models for each response and for each 
association parameters (log-odds ratios).
</p>
</td></tr>
<tr><td><code id="fitmlogit_+3A_c">C</code></td>
<td>

<p>Matrix of equality constraints. 
</p>
</td></tr>
<tr><td><code id="fitmlogit_+3A_d">D</code></td>
<td>

<p>Matrix of inequality cosntraints.
</p>
</td></tr>
<tr><td><code id="fitmlogit_+3A_data">data</code></td>
<td>

<p>A data frame containing the responses and the explanatory variables.
</p>
</td></tr>
<tr><td><code id="fitmlogit_+3A_mit">mit</code></td>
<td>

<p>A positive integer: maximum number of iterations.  Default: <code>100</code>.
</p>
</td></tr>
<tr><td><code id="fitmlogit_+3A_ep">ep</code></td>
<td>

<p>A tolerance used in the algorithm: default <code>1e-80</code>. 
</p>
</td></tr>
<tr><td><code id="fitmlogit_+3A_acc">acc</code></td>
<td>

<p>A tolerance used in the algorithm: default <code>1e-4</code>.      
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Evans and Forcina (2011). 
</p>


<h3>Value</h3>

<table>
<tr><td><code>LL</code></td>
<td>
<p>The maximized log-likelihood.</p>
</td></tr>
<tr><td><code>be</code></td>
<td>
<p>The vector of the Maximum likelihood estimates of the parameters.</p>
</td></tr>  
<tr><td><code>S</code></td>
<td>
<p>The estimated asymptotic covariance matrix.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>The estimated cell probabilities for each individual.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Antonio Forcina, Giovanni M. Marchetti
</p>


<h3>References</h3>

<p>Evans, R.J. and Forcina, A. (2013). Two algorithms for fitting constrained marginal models. <em>Computational Statistics and Data Analysis</em>, 66, 1-7. 
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
data(surdata)                     
out1 &lt;- fitmlogit(A ~X, B ~ Z, cbind(A, B) ~ X*Z, data = surdata)     
out1$beta
out2 &lt;- fitmlogit(A ~X, B ~ Z, cbind(A, B) ~ 1, data = surdata)        
out2$beta
</code></pre>

<hr>
<h2 id='fundCycles'>Fundamental cycles</h2><span id='topic+fundCycles'></span>

<h3>Description</h3>

<p>Finds the list of fundamental cycles of a connected undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fundCycles(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fundCycles_+3A_amat">amat</code></td>
<td>
<p>a symmetric matrix with dimnames denoting the adjacency matrix
of the undirected graph. The graph must be connected, otherwise
the function returns an error message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the cycles in an UG can be obtained from combination (ring sum)
of the set of fundamental cycles.
</p>


<h3>Value</h3>

<p>a list of matrices with two columns. Every component of the list
is associated to a cycle. The cycle is described by a
<code class="reqn">k \times 2</code> matrix whose rows are the edges of the cycle. If
there is no cycle the function returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>This function is used by <code>cycleMatrix</code> and <code>isGident</code>.</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Thulasiraman, K. &amp; Swamy, M.N.S. (1992). <em>Graphs: theory and
algorithms</em>. New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UG">UG</a></code>,<code><a href="#topic+findPath">findPath</a></code>,
<code><a href="#topic+cycleMatrix">cycleMatrix</a></code>, <code><a href="#topic+isGident">isGident</a></code>,<code><a href="#topic+bfsearch">bfsearch</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Three fundamental cycles
fundCycles(UG(~a*b*d + d*e + e*a*f))
</code></pre>

<hr>
<h2 id='ggm'>
The package <code>ggm</code>: summary information
</h2><span id='topic+ggm'></span>

<h3>Description</h3>

<p>This package provides functions for defining, manipulating and fitting graphical Markov models with mixed graphs. It is intended as a contribution to the gR-project described by Lauritzen (2002).
</p>
<p>For a tutorial illustrating the new functions in the package 'ggm' that deal with ancestral, summary and ribbonless graphs see Sadeghi and Marchetti (2012) in the references.
</p>


<h3>Functions</h3>

<p>The main functions can be classified as follows.
</p>

<ul>
<li><p> Functions for defining graphs (undirected, directed acyclic,
ancestral and summary graphs): <code><a href="#topic+UG">UG</a></code>, <code><a href="#topic+DAG">DAG</a></code>, <code><a href="#topic+makeMG">makeMG</a></code>, <code><a href="#topic+grMAT">grMAT</a></code>;
</p>
</li>
<li><p> Functions for doing graph operations (parents, boundary,
cliques, connected components, fundamental cycles, d-separation, m-separation):
<code><a href="#topic+pa">pa</a></code>, <code><a href="#topic+bd">bd</a></code>, <code><a href="igraph.html#topic+cliques">cliques</a></code>,
<code><a href="#topic+conComp">conComp</a></code>, <code><a href="#topic+fundCycles">fundCycles</a></code>;
</p>
</li>
<li><p> Functions for testing independence statements and generating maximal graphs
from non-maximal graphs:
<code><a href="#topic+dSep">dSep</a></code>, <code><a href="#topic+msep">msep</a></code>, <code><a href="#topic+Max">Max</a></code>;
</p>
</li>
<li><p> Function for finding covariance and concentration graphs
induced by marginalization and conditioning:
<code><a href="#topic+inducedCovGraph">inducedCovGraph</a></code>, <code><a href="#topic+inducedConGraph">inducedConGraph</a></code>;
</p>
</li>
<li><p> Functions for finding multivariate regression graphs and chain
graphs induced by marginalization and conditioning:
<code><a href="#topic+inducedRegGraph">inducedRegGraph</a></code>,  <code><a href="#topic+inducedChainGraph">inducedChainGraph</a></code>,
<code><a href="#topic+inducedDAG">inducedDAG</a></code>;
</p>
</li>
<li><p> Functions for finding stable mixed graphs (ancestral, summary and
ribbonless) after marginalization and conditioning:
<code><a href="#topic+AG">AG</a></code>,  <code><a href="#topic+SG">SG</a></code>, <code><a href="#topic+RG">RG</a></code>;
</p>
</li>
<li><p> Functions for fitting by ML Gaussian DAGs, concentration graphs,
covariance graphs and ancestral graphs:
<code><a href="#topic+fitDag">fitDag</a></code>, <code><a href="#topic+fitConGraph">fitConGraph</a></code>,
<code><a href="#topic+fitCovGraph">fitCovGraph</a></code>, <code><a href="#topic+fitAncestralGraph">fitAncestralGraph</a></code>;
</p>
</li>
<li><p> Functions for testing several conditional independences:<code><a href="#topic+shipley.test">shipley.test</a></code>;
</p>
</li>
<li><p> Functions for checking global identification
of DAG Gaussian  models with one latent variable (Stanghellini-Vicard's condition for concentration graphs, new sufficient conditions for DAGs):
<code><a href="#topic+isGident">isGident</a></code>, <code><a href="#topic+checkIdent">checkIdent</a></code>;
</p>
</li>
<li><p> Functions for fitting Gaussian DAG models with one latent variable:
<code><a href="#topic+fitDagLatent">fitDagLatent</a></code>;
</p>
</li>
<li><p> Functions for testing Markov equivalences and generating Markov
equivalent graphs of specific types:
<code><a href="#topic+MarkEqRcg">MarkEqRcg</a></code>,  <code><a href="#topic+MarkEqMag">MarkEqMag</a></code>,
<code><a href="#topic+RepMarDAG">RepMarDAG</a></code>, <code><a href="#topic+RepMarUG">RepMarUG</a></code>, <code><a href="#topic+RepMarBG">RepMarBG</a></code>.
</p>
</li></ul>



<h3>Authors</h3>

<p>Giovanni M. Marchetti, Dipartimento di Statistica, Informatica, Applicazioni 'G. Parenti'. University of Florence, Italy
</p>
<p>Mathias Drton,  Department of Statistics, University of Washington, USA
</p>
<p>Kayvan Sadeghi, Department of Statistics, Carnegie Mellon University, USA
</p>


<h3>Acknowledgements</h3>

<p>Many thanks to Fulvia Pennoni for testing some of
the functions, to Elena Stanghellini for discussion and
examples and to Claus Dethlefsen and Jens Henrik Badsberg for
suggestions and corrections. The function <code>fitConGraph</code> was corrected by
Ilaria Carobbi. Helpful discussions with Steffen Lauritzen and Nanny Wermuth,
are gratefully acknowledged. Thanks also to Michael Perlman,
Thomas Richardson and David Edwards.
</p>
<p>Giovanni Marchetti has been supported by MIUR, Italy, under grant
scheme PRIN 2002, and Mathias Drton has been supported by NSF grant
DMS-9972008 and University of Washington RRF grant 65-3010.
</p>


<h3>References</h3>

<p>Lauritzen, S. L. (2002). gRaphical Models in R.
<em>R News</em>, 3(2)39.
</p>
<p>Sadeghi, K. and Marchetti, G.M. (2012). Graphical Markov models with mixed graphs in R. <em>The R Journal</em>,  4(2):65-73. <a href="https://journal.r-project.org/archive/2012/RJ-2012-015/RJ-2012-015.pdf">https://journal.r-project.org/archive/2012/RJ-2012-015/RJ-2012-015.pdf</a>
</p>

<hr>
<h2 id='glucose'>Glucose control</h2><span id='topic+glucose'></span>

<h3>Description</h3>

<p>Data on glucose control of diabetes patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(glucose)</code></pre>


<h3>Format</h3>

<p>A data frame with 68 observations on the following 8 variables.
</p>

<dl>
<dt>Y</dt><dd><p>a numeric vector, Glucose control (glycosylated
haemoglobin), values up to about 7 or 8 indicate good glucose control.</p>
</dd>
<dt>X</dt><dd><p>a numeric vector, a score for knowledge about the illness.</p>
</dd>
<dt>Z</dt><dd><p>a numeric vector, a score for fatalistic externality (mere
chance determines what occurs).</p>
</dd>
<dt>U</dt><dd><p>a numeric vector, a score for social externality (powerful
others are responsible).</p>
</dd>
<dt>V</dt><dd><p>a numeric vector, a score for internality (the patient is
him or herself responsible).</p>
</dd>
<dt>W</dt><dd><p>a numeric vector, duration of the illness in years.</p>
</dd>
<dt>A</dt><dd><p>a numeric vector, level of education, with levels <code>-1</code>: at least
13 years of formal schooling, <code>1</code>: less then 13 years.</p>
</dd>
<dt>B</dt><dd><p>a numeric vector, gender with levels <code>-1</code>: females, <code>1</code>: males.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data on 68 patients with fewer than 25 years of diabetes. They were
collected at the University of Mainz to identify psychological
and socio-economic variables possibly important for glucose control,
when patients choose the appropriate dose of treatment depending
on the level of blood glucose measured several times per day.
</p>
<p>The variable   of primary interest is <code>Y</code>, glucose control, measured
by  glycosylated haemoglobin. <code>X</code>, knowledge about the illness,
is a response of secondary interest. Variables <code>Z</code>, <code>U</code> and
<code>V</code> measure patients' type of attribution, called fatalistic
externality, social externality and internality. These are intermediate
variables. Background   variables are <code>W</code>, the duration of the
illness, <code>A</code> the duration of formal schooling and <code>B</code>,
gender. The background variables <code>A</code> and <code>B</code> are binary
variables with coding <code>-1</code>, <code>1</code>.
</p>


<h3>Source</h3>

<p>Cox &amp; Wermuth (1996), p. 229.
</p>


<h3>References</h3>

<p>Cox, D. R. &amp; Wermuth, N. (1996). <em>Multivariate
dependencies</em>. London: Chapman &amp; Hall.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(glucose)
## See Cox &amp; Wermuth (1996), Figure 6.3 p. 140
coplot(Y ~ W | A, data=glucose)
</code></pre>

<hr>
<h2 id='grMAT'>Graph to adjacency matrix
</h2><span id='topic+grMAT'></span>

<h3>Description</h3>

<p><code>grMAT</code> generates the associated adjacency matrix to a given graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grMAT(agr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grMAT_+3A_agr">agr</code></td>
<td>

<p>A graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph,
that is a sequence of triples (type, node1label, node2label). The type
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and
<code>"l"</code> (lines).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that consists 4 different integers as an <code class="reqn">ij</code>-element: 0 for a missing
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 10 for a full line between
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers are
added to be associated with multiple edges of different types. The matrix is
symmetric w.r.t full lines and bi-directed arrows.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generating the adjacency matrix from a vector
exvec &lt;-c ('b',1,2,'b',1,14,'a',9,8,'l',9,11,'a',10,8,
           'a',11,2,'a',11,10,'a',12,1,'b',12,14,'a',13,10,'a',13,12)
grMAT(exvec)
</code></pre>

<hr>
<h2 id='icf'>Iterative conditional fitting</h2><span id='topic+icf'></span><span id='topic+icfmag'></span>

<h3>Description</h3>

<p>Main algorithm for MLE fitting of Gaussian Covariance Graphs and
Gaussian Ancestral models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icf(bi.graph, S, start = NULL, tol = 1e-06)
icfmag(mag, S, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icf_+3A_bi.graph">bi.graph</code></td>
<td>
<p>a symmetric matrix with dimnames representing the adjacency matrix of an undirected graph.</p>
</td></tr>
<tr><td><code id="icf_+3A_mag">mag</code></td>
<td>
<p>a square matrix representing the adjacency matrix of an
ancestral graph (for example returned by <code>makeAG</code>).</p>
</td></tr>
<tr><td><code id="icf_+3A_s">S</code></td>
<td>
<p>a symmetric positive definite matrix, the
sample covariance matrix. The order of the variables
must be the same of the order of vertices in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="icf_+3A_start">start</code></td>
<td>
<p>a symmetric matrix used as starting value
of the algorithm. If <code>start=NULL</code> the starting value
is a diagonal matrix.</p>
</td></tr>
<tr><td><code id="icf_+3A_tol">tol</code></td>
<td>
<p>A small positive number indicating the tolerance
used in convergence tests.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are not intended to be called directly by the user.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Sigmahat</code></td>
<td>
<p>the fitted covariance matrix.</p>
</td></tr>
<tr><td><code>Bhat</code></td>
<td>
<p>matrix of the fitted regression coefficients
associated to the directed edges.</p>
</td></tr>
<tr><td><code>Omegahat</code></td>
<td>
<p>matrix of the partial covariances of the residuals
between regression equations.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mathias Drton</p>


<h3>References</h3>

<p>Drton, M. &amp; Richardson, T. S. (2003). A new algorithm for
maximum likelihood estimation in Gaussian graphical models for
marginal independence. <em>Proceedings
of the Ninetheen Conference on Uncertainty in Artificial
Intelligence</em>, 184&ndash;191.
</p>
<p>Drton, M. &amp; Richardson, T. S. (2004). Iterative Conditional Fitting
for Gaussian Ancestral Graph Models.  Proceedings
of the 20th Conference on Uncertainty in Artificial Intelligence,
Department of Statistics, 130&ndash;137.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitCovGraph">fitCovGraph</a></code>, <code><a href="#topic+fitAncestralGraph">fitAncestralGraph</a></code></p>

<hr>
<h2 id='In'>Indicator matrix</h2><span id='topic+In'></span>

<h3>Description</h3>

<p>Finds the indicator matrix of the zeros of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>In(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="In_+3A_a">A</code></td>
<td>
<p>a matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The indicator matrix is a matrix of zeros and ones which has a zero
element iff the corresponding element of <code>A</code> is (exactly) zero.
</p>


<h3>Value</h3>

<p>a matrix of the same dimensions as <code>A</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Wermuth, N. &amp; Cox, D.R. (2004). Joint response graphs
and separation induced by triangular systems. <em>J.R. Statist. Soc. B</em>,
66, Part 3, 687-717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DAG">DAG</a></code>, <code><a href="#topic+inducedCovGraph">inducedCovGraph</a></code>, <code><a href="#topic+inducedConGraph">inducedConGraph</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A simple way to find the overall induced concentration graph
## The DAG on p. 198 of Cox &amp; Wermuth (1996)
amat &lt;- DAG(y1 ~ y2 + y3, y3 ~ y5, y4 ~ y5)
A &lt;- edgematrix(amat)
In(crossprod(A))
</code></pre>

<hr>
<h2 id='InducedGraphs'>Graphs induced by marginalization or conditioning</h2><span id='topic+inducedCovGraph'></span><span id='topic+inducedConGraph'></span><span id='topic+inducedRegGraph'></span><span id='topic+inducedChainGraph'></span><span id='topic+inducedDAG'></span><span id='topic+InducedGraphs'></span>

<h3>Description</h3>

<p>Functions to find induced graphs after conditioning on a set of variables and marginalizing over another set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inducedCovGraph(amat, sel = rownames(amat), cond = NULL)
inducedConGraph(amat, sel = rownames(amat), cond = NULL)
inducedRegGraph(amat, sel = rownames(amat), cond = NULL)
inducedChainGraph(amat, cc=rownames(amat), cond = NULL, type="LWF")
inducedDAG(amat, order, cond = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InducedGraphs_+3A_amat">amat</code></td>
<td>
<p>a square Boolean matrix, the adjacency matrix of a directed
acyclic graph. The names of rows and of the columns
are the nodes of the DAG.</p>
</td></tr>
<tr><td><code id="InducedGraphs_+3A_sel">sel</code></td>
<td>
<p>a character vector representing a subset
of selected variables.
The elements of the  vector must be a subset of
the names of the nodes i.e. of <code>rownames(A)</code>.
By default <code>sel</code> is the set of the nodes of the DAG.</p>
</td></tr>
<tr><td><code id="InducedGraphs_+3A_cond">cond</code></td>
<td>
<p>a character vector representing the variables on which you
want to condition. <code>cond</code> must be disjoint from <code>sel</code> and
their union must be a subset of the set of nodes. The set difference
between the set of nodes and the union of <code>sel</code> and
<code>cond</code> are  the variables over which we marginalize.
<code>cond</code> may be the null vector (the default), meaning that you want
to condition on the empty set.</p>
</td></tr>
<tr><td><code id="InducedGraphs_+3A_cc">cc</code></td>
<td>
<p>a list of character vectors specifying the chain components
for the chain graph.</p>
</td></tr>
<tr><td><code id="InducedGraphs_+3A_type">type</code></td>
<td>
<p>a string indicating the interpretation of the chain
graph. It can be either &quot;LWF&quot; (Lauritzen, Wermuth, Frydenberg
interpretation), &quot;AMP&quot; (Andersson, Madigan, Perlman interpretation)
or &quot;MRG&quot; (Multivariate regression graph interpretation).</p>
</td></tr>
<tr><td><code id="InducedGraphs_+3A_order">order</code></td>
<td>
<p>a character vector indicating the ordering of the vertices
of a DAG (left to right, past to future).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a directed acyclic graph representing a set of
conditional independencies it is possible to obtain other graphs
of conditional independence implied after marginalizingover and
conditionig on sets of nodes. Such graphs are
the covariance graph, the concentration graph, the multivariate
regression graph and the chain graph with different interpretations  (see Cox &amp; Wermuth, 1996, 2004).
</p>


<h3>Value</h3>

<p><code>inducedCovGraph</code> returns the adjacency matrix of the covariance
graph of the variables in set <code>sel</code> given the variables
in set <code>cond</code>, implied by the original directed acyclic graph
with adjacency matrix <code>amat</code>.
</p>
<p><code>inducedConGraph</code> returns the adjacency matrix of the concentration
graph of the variables in set <code>sel</code> given the variables
in set <code>cond</code>, implied by the original directed acyclic graph
with adjacency matrix <code>amat</code>.
</p>
<p><code>inducedRegGraph</code> returns the adjacency matrix of the
multivariate regression graph of the variables in set <code>sel</code>
given the variables in set  <code>cond</code>, implied by the original
directed acyclic graph with adjacency matrix <code>amat</code>.
</p>
<p><code>inducedChainGraph</code> returns the adjacency matrix of the
chain graph for the variables in chain components
<code>cc</code>, given the variables in set  <code>cond</code>, with
interpretation specified by string <code>type</code>, implied by the original
directed acyclic graph with adjacency matrix <code>amat</code>.
</p>
<p><code>inducedDAG</code> returns the adjacency matrix of the DAG with
the ordering <code>order</code>, implied by the  original directed acyclic
graph with adjacency matrix <code>amat</code>.
</p>


<h3>Note</h3>

<p>If <code>sel</code> is <code>NULL</code> the functions return the null matrix.
If <code>cond</code> is <code>NULL</code>, the conditioning set is empty and the
functions <code>inducedConGraph</code> and <code>inducedCovGraph</code>
return the overall induced covariance or concentration
matrices of the selected variables. If you do not specify <code>sel</code>
you cannot specify a non <code>NULL</code> value of <code>cond</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Cox, D. R. &amp; Wermuth, N. (1996). <em>Multivariate
dependencies</em>. London: Chapman &amp; Hall.
</p>
<p>Wermuth, N. &amp; Cox, D.R. (2004). Joint response graphs
and separation induced by triangular systems. <em>J.R. Statist. Soc. B</em>,
66, Part 3, 687-717.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DAG">DAG</a></code>, <code><a href="#topic+UG">UG</a></code>,<code><a href="#topic+isAcyclic">isAcyclic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define a DAG
dag &lt;- DAG(a ~ x, c ~ b+d, d~ x)
dag
## Induced covariance graph of a, b, d given the empty set.
inducedCovGraph(dag, sel=c("a", "b", "d"), cond=NULL)

## Induced concentration graph of a, b, c given x
inducedConGraph(dag, sel=c("a", "b", "c"), cond="x")

## Overall covariance graph
inducedCovGraph(dag)

## Overall concentration graph
inducedConGraph(dag)

## Induced covariance graph of x, b, d given c, x.
inducedCovGraph(dag, sel=c("a", "b", "d"), cond=c("c", "x"))

## Induced concentration graph of a, x, c given d, b.
inducedConGraph(dag, sel=c("a", "x", "c"), cond=c("d", "b"))

## The DAG on p. 198 of Cox &amp; Wermuth (1996)
dag &lt;- DAG(y1~ y2 + y3, y3 ~ y5, y4 ~ y5)

## Cf. figure 8.7 p. 203 in Cox &amp; Wermuth (1996)
inducedCovGraph(dag, sel=c("y2", "y3", "y4", "y5"), cond="y1")
inducedCovGraph(dag, sel=c("y1", "y2", "y4", "y5"), cond="y3")
inducedCovGraph(dag, sel=c("y1", "y2", "y3", "y4"), cond="y5")

## Cf. figure 8.8 p. 203 in Cox &amp; Wermuth (1996)
inducedConGraph(dag, sel=c("y2", "y3", "y4", "y5"), cond="y1")
inducedConGraph(dag, sel=c("y1", "y2", "y4", "y5"), cond="y3")
inducedConGraph(dag, sel=c("y1", "y2", "y3", "y4"), cond="y5")

## Cf. figure 8.9 p. 204 in Cox &amp; Wermuth (1996)
inducedCovGraph(dag, sel=c("y2", "y3", "y4", "y5"), cond=NULL)
inducedCovGraph(dag, sel=c("y1", "y2", "y4", "y5"), cond=NULL)
inducedCovGraph(dag, sel=c("y1", "y2", "y3", "y4"), cond=NULL)

## Cf. figure 8.10 p. 204 in Cox &amp; Wermuth (1996)
inducedConGraph(dag, sel=c("y2", "y3", "y4", "y5"), cond=NULL)
inducedConGraph(dag, sel=c("y1", "y2", "y4", "y5"), cond=NULL)
inducedConGraph(dag, sel=c("y1", "y2", "y3", "y4"), cond=NULL)

## An induced regression graph
dag2 = DAG(Y ~ X+U, W ~ Z+U)
inducedRegGraph(dag2, sel="W",  cond=c("Y", "X", "Z"))

## An induced DAG
inducedDAG(dag2, order=c("X","Y","Z","W"))

## An induced multivariate regression graph
inducedRegGraph(dag2, sel=c("Y", "W"), cond=c("X", "Z"))

## An induced chain graph with LWF interpretation
dag3 = DAG(X~W, W~Y, U~Y+Z)
cc = list(c("W", "U"), c("X", "Y", "Z"))
inducedChainGraph(dag3, cc=cc, type="LWF")

## ... with AMP interpretation
inducedChainGraph(dag3, cc=cc, type="AMP")

## ... with multivariate regression interpretation
cc= list(c("U"), c("Z", "Y"), c("X", "W"))
inducedChainGraph(dag3, cc=cc, type="MRG")
</code></pre>

<hr>
<h2 id='isAcyclic'>Graph queries</h2><span id='topic+isAcyclic'></span>

<h3>Description</h3>

<p>Checks if a given graph is acyclic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isAcyclic(amat, method = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isAcyclic_+3A_amat">amat</code></td>
<td>
<p>a square Boolean matrix with dimnames, the adjacency matrix of a graph.</p>
</td></tr>
<tr><td><code id="isAcyclic_+3A_method">method</code></td>
<td>
<p>an integer 1 or 2 specifying the method used. If <code>method=1</code> the  function calls the function <code>clusters</code> in package <code>igraph</code> to find the strong components: two nodes v and w are in the same strong component iff there are directed paths from v to w and from w to v. If <code>method=2</code> the function uses the <code>ggm</code> function <code>transClos</code>. Method 1 is faster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value, <code>TRUE</code> if the graph is acyclic and <code>FALSE</code>
otherwise.
</p>


<h3>Author(s)</h3>

<p>David Edwards, Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Aho, A.V., Hopcroft, J.E. &amp; Ullman, J.D. (1983). <em>Data structures
and algorithms.</em> Reading: Addison-Wesley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A cyclic graph
d &lt;- matrix(0,3,3)
rownames(d) &lt;- colnames(d) &lt;- c("x", "y", "z")
d["x","y"] &lt;- d["y", "z"] &lt;- d["z", "x"] &lt;- 1
## Test if the graph is acyclic
isAcyclic(d)
isAcyclic(d, method = 1)
</code></pre>

<hr>
<h2 id='isADMG'>
Acyclic directed mixed graphs
</h2><span id='topic+isADMG'></span>

<h3>Description</h3>

<p>Check if it is an adjacency matrix of an ADMG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isADMG(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isADMG_+3A_amat">amat</code></td>
<td>
<p>An adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks if the following conditions must hold:
(i) no undirected edge meets an arrowhead; (ii) no directed cycles;
</p>


<h3>Value</h3>

<p>A logical value, <code>TRUE</code> if it is an ancestral graph and <code>FALSE</code>
otherwise.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti, Mathias Drton
</p>


<h3>References</h3>

<p>Richardson, T. S. and Spirtes, P. (2002). Ancestral Graph Markov
Models. <em>Annals of Statistics</em>, 30(4), 962&ndash;1030.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeMG">makeMG</a></code>, <code><a href="#topic+isADMG">isADMG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Examples from Richardson and Spirtes (2002)
	a1 &lt;- makeMG(dg=DAG(a~b, b~d, d~c), bg=UG(~a*c))
	isADMG(a1)    # Not an AG. (a2) p.969
	a2 &lt;- makeMG(dg=DAG(b ~ a, d~c), bg=UG(~a*c+c*b+b*d))           # Fig. 3 (b1) p.969
	isADMG(a2)
</code></pre>

<hr>
<h2 id='isAG'>
Ancestral graph
</h2><span id='topic+isAG'></span>

<h3>Description</h3>

<p>Check if it is an adjacency matrix of an ancestral graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isAG(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isAG_+3A_amat">amat</code></td>
<td>
<p>An adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks if the following conditions must hold:
(i) no undirected edge meets an arrowhead; (ii) no directed cycles;
(iii) spouses cannot be ancestors. For details see Richardson and
Spirtes (2002).
</p>


<h3>Value</h3>

<p>A logical value, <code>TRUE</code> if it is an ancestral graph and <code>FALSE</code>
otherwise.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti, Mathias Drton
</p>


<h3>References</h3>

<p>Richardson, T. S. and Spirtes, P. (2002). Ancestral Graph Markov
Models. <em>Annals of Statistics</em>, 30(4), 962&ndash;1030.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeMG">makeMG</a></code>, <code><a href="#topic+isADMG">isADMG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Examples from Richardson and Spirtes (2002)
	a1 &lt;- makeMG(dg=DAG(a~b, b~d, d~c), bg=UG(~a*c))
	isAG(a1)    # Not an AG. (a2) p.969
	a2 &lt;- makeMG(dg=DAG(b ~ a, d~c), bg=UG(~a*c+c*b+b*d))           # Fig. 3 (b1) p.969
	isAG(a2)
</code></pre>

<hr>
<h2 id='isGident'>G-identifiability of an UG</h2><span id='topic+isGident'></span>

<h3>Description</h3>

<p>Tests if an undirected graph is G-identifiable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isGident(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isGident_+3A_amat">amat</code></td>
<td>
<p>a symmetric matrix with dimnames representing the adjacency
matrix of an undirected graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An undirected graph is said G-identifiable if every connected component of
the complementary graph contains an odd cycle (Stanghellini and
Wermuth, 2005). See also Tarantola and Vicard (2002).
</p>


<h3>Value</h3>

<p>a logical value, <code>TRUE</code> if the graph is G-identifiable and
<code>FALSE</code> if it is not.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Stanghellini, E. &amp; Wermuth, N. (2005). On the
identification of path-analysis models with one
hidden variable. <em>Biometrika</em>, 92(2), 337-350.
</p>
<p>Stanghellini, E. (1997). Identification of a single-factor
model using graphical Gaussian rules. <em>Biometrika</em>, 84, 241&ndash;244.
</p>
<p>Tarantola, C. &amp; Vicard, P. (2002). Spanning trees and identifiability
of a single-factor model. <em>Statistical Methods &amp; Applications</em>,
11, 139&ndash;152.
</p>
<p>Vicard, P. (2000). On the identification of a single-factor model
with correlated residuals. <em>Biometrika</em>, 87, 199&ndash;205.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UG">UG</a></code>, <code><a href="#topic+cmpGraph">cmpGraph</a></code>, <code><a href="#topic+cycleMatrix">cycleMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A not G-identifiable UG
G1 &lt;- UG(~ a*b + u*v)
isGident(G1)
## G-identifiable UG
G2 &lt;- UG(~ a + b + u*v)
isGident(G2)
## G-identifiable UG
G3 &lt;- cmpGraph(UG(~a*b*c+x*y*z))
isGident(G3)
</code></pre>

<hr>
<h2 id='MAG'>
Maximal ancestral graph
</h2><span id='topic+MAG'></span>

<h3>Description</h3>

<p><code>MAG</code> generates and plots maximal ancestral graphs after marginalisation
and conditioning.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAG(amat,M=c(),C=c(),showmat=TRUE,plot=FALSE, plotfun = plotGraph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAG_+3A_amat">amat</code></td>
<td>

<p>An adjacency matrix, or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph,
that is a sequence of triples (type, node1label, node2label). The type
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and
<code>"l"</code> (lines).
</p>
</td></tr>
<tr><td><code id="MAG_+3A_m">M</code></td>
<td>

<p>A subset of the node set of <code>a</code> that is going to be marginalized over</p>
</td></tr>
<tr><td><code id="MAG_+3A_c">C</code></td>
<td>

<p>Another disjoint subset of the node set of <code>a</code> that is going to be
conditioned on.
</p>
</td></tr>
<tr><td><code id="MAG_+3A_showmat">showmat</code></td>
<td>

<p>A logical value. <code>TRUE</code> (by default) to print the generated matrix.
</p>
</td></tr>
<tr><td><code id="MAG_+3A_plot">plot</code></td>
<td>

<p>A logical value, <code>FALSE</code> (by default). <code>TRUE</code> to plot
the generated graph.
</p>
</td></tr>
<tr><td><code id="MAG_+3A_plotfun">plotfun</code></td>
<td>

<p>Function to plot the graph when <code>plot == TRUE</code>. Can be <code>plotGraph</code> (the default) or <code>drawGraph</code>.
</p>
</td></tr>
<tr><td><code id="MAG_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plotfun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the functions <code><a href="#topic+AG">AG</a></code> and <code><a href="#topic+Max">Max</a></code>.
</p>


<h3>Value</h3>

<p>A matrix that consists 4 different integers as an <code class="reqn">ij</code>-element: 0 for a missing
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 10 for a full line between
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers are
added to be associated with multiple edges of different types. The matrix is
symmetric w.r.t full lines and bi-directed arrows.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Richardson, T. S. and Spirtes, P. (2002). Ancestral graph Markov models. <em>Annals of Statistics</em>, 30(4), 962-1030.
</p>
<p>Sadeghi, K. (2013). Stable mixed graphs.
<em>Bernoulli</em> 19(5B), 2330â€“2358.
</p>
<p>Sadeghi, K. and Lauritzen, S.L. (2014). Markov properties for loopless mixed graphs. <em>Bernoulli</em> 20(2), 676-696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AG">AG</a></code>, <code><a href="#topic+Max">Max</a></code>, <code><a href="#topic+MRG">MRG</a></code>, <code><a href="#topic+MSG">MSG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex&lt;-matrix(c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ##The adjacency matrix of a DAG
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
             0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
             0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,
             1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
             0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0), 16, 16, byrow = TRUE)
M &lt;- c(3,5,6,15,16)
C &lt;- c(4,7)
MAG(ex, M, C, plot=TRUE)
###################################################
H &lt;- matrix(c(0,100,1,0,100,0,100,0,0,100,0,100,0,1,100,0),4,4)
Max(H)
</code></pre>

<hr>
<h2 id='makeMG'>Mixed Graphs</h2><span id='topic+makeMG'></span>

<h3>Description</h3>

<p>Defines a loopless mixed graph from the directed, undirected and
undirected components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMG(dg = NULL, ug = NULL, bg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMG_+3A_dg">dg</code></td>
<td>
<p>the adjacency matrix of a directed graph specifying
the arrows of the mixed graph.</p>
</td></tr>
<tr><td><code id="makeMG_+3A_ug">ug</code></td>
<td>
<p>the adjacency matrix of an undirected graph specifying the
lines of the mixed graph.</p>
</td></tr>
<tr><td><code id="makeMG_+3A_bg">bg</code></td>
<td>
<p>the adjacency matrix of an undirected graph specifying the
bidirected edges of the mixed graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A loopless mixed graph is a mixed graph with three types of edges: undirected,
directed and bi-directed edges. 
Note that the three adjacency matrices must have labels and
may be defined using the functions <code>DG</code>, <code>DAG</code> or <code>UG</code>.  
The adjacency matrices of the undirected graphs may be just 
symmetric Boolean matrices.   
</p>


<h3>Value</h3>

<p>a square matrix obtained by combining the three graph components
into an adjacency matrix of a mixed graph. The matrix  consists of 
4 different integers as 
an <code class="reqn">ij</code>-element: 0 for a missing 
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 
10 for a full line between 
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. 
These numbers are 
added to be associated with multiple edges of different types. The matrix is 
symmetric w.r.t full lines and bi-directed arrows.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti, Mathias Drton</p>


<h3>References</h3>

<p>Richardson, T. S. and Spirtes, P. (2002). Ancestral Graph Markov
Models. <em>Annals of Statistics</em>, 30(4), 962&ndash;1030.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UG">UG</a></code>, <code><a href="#topic+DAG">DAG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples from Richardson and Spirtes (2002)
a1 &lt;- makeMG(dg=DAG(a~b, b~d, d~c), bg=UG(~a*c))  
isAG(a1)    # Not an AG. (a2) p.969    
a2 &lt;- makeMG(dg=DAG(b ~ a, d~c), bg=UG(~a*c+c*b+b*d))           # Fig. 3 (b1) p.969  
isAG(a1)
a3 &lt;- makeMG(ug = UG(~ a*c), dg=DAG(b ~ a, d~c), bg=UG(~ b*d)) # Fig. 3 (b2) p.969
a5 &lt;- makeMG(bg=UG(~alpha*beta+gamma*delta), dg=DAG(alpha~gamma,
delta~beta))  # Fig. 6 p. 973
## Another Example
a4 &lt;- makeMG(ug=UG(~y0*y1), dg=DAG(y4~y2, y2~y1), bg=UG(~y2*y3+y3*y4))  
## A mixed graphs with double edges. 
mg &lt;- makeMG(dg = DG(Y ~ X, Z~W, W~Z, Q~X), ug = UG(~X*Q), 
bg = UG(~ Y*X+X*Q+Q*W + Y*Z) )
## Chronic pain data: a regression graph
chronic.pain &lt;- makeMG(dg = DAG(Y ~ Za, Za ~ Zb + A, Xa ~ Xb, 
Xb ~ U+V, U ~ A + V, Zb ~ B, A ~ B), bg = UG(~Za*Xa + Zb*Xb))
</code></pre>

<hr>
<h2 id='marg.param'>
Link function of marginal log-linear parameterization
</h2><span id='topic+marg.param'></span>

<h3>Description</h3>

<p>Provides the contrast and marginalization matrices for the marginal parametrization
of a probability vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marg.param(lev, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marg.param_+3A_lev">lev</code></td>
<td>

<p>Integer vector containing the number of levels of each variable.
</p>
</td></tr>
<tr><td><code id="marg.param_+3A_type">type</code></td>
<td>

<p>A character vector   with elements <code>"l"</code>, <code>"g"</code>, <code>"c"</code>, or 
<code>"r"</code> indicating the type of logit. The meaning is as follows:
<code>"g"</code> for global, <code>"c"</code> for continuation,
<code>"r"</code> for reverse continuation and <code>"l"</code> for local.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Bartolucci, Colombi and Forcina (2007).
</p>


<h3>Value</h3>

<table>
<tr><td><code>C</code></td>
<td>
<p>Matrix of constrasts (the first <code>sum(lev)-length(r)</code> elements are
referred to univariate logits)</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Marginalization matrix with elements 0 and 1.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Corresponding design matrix for the corresponding log-linear model.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Assumes that the vector of probabilities is in inv lex order. 
The interactions are returned in order of dimension, like e.g., 
1, 2, 3, 12, 13, 23, 123.
</p>


<h3>Author(s)</h3>

<p>Francesco Bartolucci, Antonio Forcina, Giovanni M. Marchetti
</p>


<h3>References</h3>

<p>Bartolucci, F., Colombi, R. and Forcina, A. (2007). An extended class 
of marginal link functions for modelling contingency tables 
by equality and inequality constraints. Statist. Sinica 17, 691-711.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.mlogit">mat.mlogit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
marg.param(c(3,3), c("l", "g"))
</code></pre>

<hr>
<h2 id='MarkEqMag'>
Markov equivalence of maximal ancestral graphs 
</h2><span id='topic+MarkEqMag'></span>

<h3>Description</h3>

<p><code>MarkEqMag</code> determines whether two MAGs are Markov equivalent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MarkEqMag(amat, bmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MarkEqMag_+3A_amat">amat</code></td>
<td>

<p>An adjacency matrix of a MAG, or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object 
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph, 
that is a sequence of triples (type, node1label, node2label). The type 
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and 
<code>"l"</code> (lines).
</p>
</td></tr>
<tr><td><code id="MarkEqMag_+3A_bmat">bmat</code></td>
<td>

<p>The same as <code>amat</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks whether the two graphs have the same skeleton and
colliders with order.
</p>


<h3>Value</h3>

<p>&quot;Markov Equivalent&quot; or &quot;NOT Markov Equivalent&quot;. 
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Ali, R.A.,  Richardson, T.S. and Spirtes, P. (2009) Markov equivalence 
for ancestral graphs. <em>Annals of Statistics</em>, 37(5B),2808-2837.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MarkEqRcg">MarkEqRcg</a></code>, <code><a href="#topic+msep">msep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H1&lt;-matrix(  c(0,100,  0,  0,
	         100,  0,100,  0,
               0,100,  0,100,
               0,  1,100,  0), 4, 4)
H2&lt;-matrix(c(0,0,0,0,1,0,100,0,0,100,0,100,0,1,100,0),4,4)
H3&lt;-matrix(c(0,0,0,0,1,0,0,0,0,1,0,100,0,1,100,0),4,4)
MarkEqMag(H1,H2)
MarkEqMag(H1,H3)
MarkEqMag(H2,H3)
</code></pre>

<hr>
<h2 id='MarkEqRcg'>
Markov equivalence for regression chain graphs.
</h2><span id='topic+MarkEqRcg'></span>

<h3>Description</h3>

<p><code>MarkEqMag</code> determines whether two RCGs (or subclasses of RCGs) are
Markov equivalent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MarkEqRcg(amat, bmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MarkEqRcg_+3A_amat">amat</code></td>
<td>

<p>An adjacency matrix of an RCG or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph,
that is a sequence of triples (type, node1label, node2label). The type
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and
<code>"l"</code> (lines).
</p>
</td></tr>
<tr><td><code id="MarkEqRcg_+3A_bmat">bmat</code></td>
<td>

<p>The same as <code>amat</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks whether the two graphs have the same skeleton and
unshielded colliders.
</p>


<h3>Value</h3>

<p>&quot;Markov Equivalent&quot; or &quot;NOT Markov Equivalent&quot;.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Wermuth, N. and Sadeghi, K. (2012). Sequences of regressions and their independences. Test 21:215â€“252.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MarkEqMag">MarkEqMag</a></code>, <code><a href="#topic+msep">msep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H1&lt;-matrix(c(0,100,0,0,0,100,0,100,0,0,0,100,0,0,0,1,0,0,0,100,0,0,1,100,0),5,5)
H2&lt;-matrix(c(0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,100,0,0,1,100,0),5,5)
H3&lt;-matrix(c(0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0),5,5)
#MarkEqRcg(H1,H2)
#MarkEqRcg(H1,H3)
#MarkEqRcg(H2,H3)
</code></pre>

<hr>
<h2 id='marks'>Mathematics marks</h2><span id='topic+marks'></span>

<h3>Description</h3>

<p>Examination marks of 88 students in five subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(marks)</code></pre>


<h3>Format</h3>

<p>A data frame with 88 observations on the following 5 variables.
</p>

<dl>
<dt>mechanics</dt><dd><p>a numeric vector, mark in Mechanics</p>
</dd>
<dt>vectors</dt><dd><p>a numeric vector, mark in Vectors</p>
</dd>
<dt>algebra</dt><dd><p>a numeric vector, mark in Algebra</p>
</dd>
<dt>analysis</dt><dd><p>a numeric vector, mark in Analysis</p>
</dd>
<dt>statistics</dt><dd><p>a numeric vector, mark in Statistics </p>
</dd>
</dl>



<h3>Details</h3>

<p>Mechanics and Vectors were closed book examinations. Algebra, Analysis
and Statistics were open book examinations.
</p>


<h3>Source</h3>

<p>Mardia, K.V., Kent, J.T. and Bibby, (1979). <em>Multivariate
analysis</em>. London: Academic Press.
</p>


<h3>References</h3>

<p>Whittaker, J. (1990). <em>Graphical models in applied
multivariate statistics</em>. Chichester: Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(marks)
pairs(marks)
</code></pre>

<hr>
<h2 id='mat.mlogit'>
Multivariate logistic parametrization
</h2><span id='topic+mat.mlogit'></span>

<h3>Description</h3>

<p>Find matrices <code>C</code> and <code>M</code> of e binary multivariate logistic 
parameterization. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.mlogit(d, P = powerset(1:d))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.mlogit_+3A_d">d</code></td>
<td>

<p>A positive integer, the number of binary responses.
</p>
</td></tr>
<tr><td><code id="mat.mlogit_+3A_p">P</code></td>
<td>

<p>A list of vectors of integers specifying margins. For instance
<code>list(1, 2, c(1,2))</code>. Default: the power set of <code>1:d</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power set is in the order of dimensions of the sets.
</p>


<h3>Value</h3>

<table>
<tr><td><code>C</code></td>
<td>
<p>A contrast matrix.</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>A marginalization matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti
</p>


<h3>References</h3>

<p>Glonek, G. J. N. and McCullagh, P. (1995). Multivariate logistic models. Journal of the Royal
Statistical Society, Ser. B 57, 533-546.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+binomial">binomial</a>, <a href="#topic+marg.param">marg.param</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
mat.mlogit(2)
</code></pre>

<hr>
<h2 id='Max'>
Maximisation for graphs
</h2><span id='topic+Max'></span>

<h3>Description</h3>

<p><code>Max</code> generates a maximal graph that induces the same
independence model from a non-maximal graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Max(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Max_+3A_amat">amat</code></td>
<td>

<p>An adjacency matrix, or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph,
that is a sequence of triples (type, node1label, node2label). The type
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and
<code>"l"</code> (lines).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Max</code> looks for non-adjacent pais of nodes that are connected by
primitive inducing paths, and connect such pairs by an appropriate edge.
</p>


<h3>Value</h3>

<p>A matrix that consists 4 different integers as an <code class="reqn">ij</code>-element: 0 for a missing
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 10 for a full line between
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers are
added to be associated with multiple edges of different types. The matrix is
symmetric w.r.t full lines and bi-directed arrows.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Richardson, T.S. and Spirtes, P. (2002). Ancestral graph Markov models. <em>Annals
of Statistics</em>, 30(4), 962-1030.
</p>
<p>Sadeghi, K. and Lauritzen, S.L. (2014). Markov properties for loopless mixed graphs. <em>Bernoulli</em> 20(2), 676-696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MAG">MAG</a></code>, <code><a href="#topic+MRG">MRG</a></code>, <code><a href="#topic+msep">msep</a></code>, <code><a href="#topic+MSG">MSG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H &lt;- matrix(c(  0,100,  1,  0,
	          100,  0,100,  0,
	            0,100,  0,100,
	            0,  1,100,  0), 4, 4)
Max(H)
</code></pre>

<hr>
<h2 id='MRG'>
Maximal ribbonless graph
</h2><span id='topic+MRG'></span>

<h3>Description</h3>

<p><code>MRG</code> generates and plots maximal ribbonless graphs (a modification
of MC graph to use m-separation) after marginalisation and conditioning.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRG(amat,M=c(),C=c(),showmat=TRUE,plot=FALSE, plotfun = plotGraph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRG_+3A_amat">amat</code></td>
<td>

<p>An adjacency matrix, or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph,
that is a sequence of triples (type, node1label, node2label). The type
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and
<code>"l"</code> (lines).
</p>
</td></tr>
<tr><td><code id="MRG_+3A_m">M</code></td>
<td>

<p>A subset of the node set of <code>a</code> that is going to be marginalized over</p>
</td></tr>
<tr><td><code id="MRG_+3A_c">C</code></td>
<td>

<p>Another disjoint subset of the node set of <code>a</code> that is going to be
conditioned on.
</p>
</td></tr>
<tr><td><code id="MRG_+3A_showmat">showmat</code></td>
<td>

<p>A logical value. <code>TRUE</code> (by default) to print the generated matrix.
</p>
</td></tr>
<tr><td><code id="MRG_+3A_plot">plot</code></td>
<td>

<p>A logical value, <code>FALSE</code> (by default). <code>TRUE</code> to plot
the generated graph.
</p>
</td></tr>
<tr><td><code id="MRG_+3A_plotfun">plotfun</code></td>
<td>

<p>Function to plot the graph when <code>plot == TRUE</code>. Can be <code>plotGraph</code> (the default) or <code>drawGraph</code>.
</p>
</td></tr>
<tr><td><code id="MRG_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plotfun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the functions <code><a href="#topic+RG">RG</a></code> and <code><a href="#topic+Max">Max</a></code>.
</p>


<h3>Value</h3>

<p>A matrix that consists 4 different integers as an <code class="reqn">ij</code>-element: 0 for a missing
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 10 for a full line between
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers are
added to be associated with multiple edges of different types. The matrix is
symmetric w.r.t full lines and bi-directed arrows.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Koster, J.T.A. (2002). Marginalizing and conditioning in graphical models. <em>Bernoulli</em>, 8(6), 817-840.
</p>
<p>Richardson, T.S. and Spirtes, P. (2002). Ancestral graph Markov models. <em>Annals of Statistics</em>, 30(4), 962-1030.
</p>
<p>Sadeghi, K. (2013). Stable mixed graphs.
<em>Bernoulli</em> 19(5B), 2330â€“2358.
</p>
<p>Sadeghi, K. and Lauritzen, S.L. (2014). Markov properties for loopless mixed graphs. <em>Bernoulli</em> 20(2), 676-696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MAG">MAG</a></code>, <code><a href="#topic+Max">Max</a></code>, <code><a href="#topic+MSG">MSG</a></code>, <code><a href="#topic+RG">RG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- matrix(c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ##The adjacency matrix of a DAG
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
               1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
               0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
               0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
               0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,
               1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
               0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,
               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
               1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
               0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0),16,16, byrow = TRUE)
M &lt;- c(3,5,6,15,16)
C &lt;- c(4,7)
MRG(ex, M, C, plot = TRUE)
###################################################
H &lt;- matrix(c( 0, 100,   1,   0,
  	         100,   0, 100,   0,
 	             0, 100,   0, 100,
	             0,   1, 100,   0), 4,4)
Max(H)
</code></pre>

<hr>
<h2 id='msep'>The m-separation criterion
</h2><span id='topic+msep'></span>

<h3>Description</h3>

<p><code>msep</code> determines whether two set of nodes are m-separated
by a third set of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msep(a, alpha, beta, C = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msep_+3A_a">a</code></td>
<td>

<p>An adjacency matrix, or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph,
that is a sequence of triples (type, node1label, node2label). The type
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and
<code>"l"</code> (lines).
</p>
</td></tr>
<tr><td><code id="msep_+3A_alpha">alpha</code></td>
<td>

<p>A subset of the node set of <code>a</code></p>
</td></tr>
<tr><td><code id="msep_+3A_beta">beta</code></td>
<td>

<p>Another disjoint subset of the node set of <code>a</code></p>
</td></tr>
<tr><td><code id="msep_+3A_c">C</code></td>
<td>

<p>A third disjoint subset of the node set of <code>a</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value. <code>TRUE</code>  if <code>alpha</code> and <code>beta</code> are m-separated given <code>C</code>.
<code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Richardson, T.S. and Spirtes, P. (2002) Ancestral graph Markov models. <em>Annals
of Statistics</em>, 30(4), 962-1030.
</p>
<p>Sadeghi, K. and Lauritzen, S.L. (2014). Markov properties for loopless mixed graphs. <em>Bernoulli</em> 20(2), 676-696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dSep">dSep</a></code>, <code><a href="#topic+MarkEqMag">MarkEqMag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H &lt;-matrix(c(0,0,0,0,
	         1,0,0,1,
	         0,1,0,0,
	         0,0,0,0),4,4)
msep(H,1,4, 2)
msep(H,1,4, c())
</code></pre>

<hr>
<h2 id='MSG'>
Maximal summary graph
</h2><span id='topic+MSG'></span>

<h3>Description</h3>

<p><code>MAG</code> generates and plots maximal summary graphs after marginalization
and conditioning.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSG(amat,M=c(),C=c(),showmat=TRUE,plot=FALSE, plotfun = plotGraph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSG_+3A_amat">amat</code></td>
<td>

<p>An adjacency matrix of a MAG, or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph,
that is a sequence of triples (type, node1label, node2label). The type
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and
<code>"l"</code> (lines).
</p>
</td></tr>
<tr><td><code id="MSG_+3A_m">M</code></td>
<td>

<p>A subset of the node set of <code>a</code> that is going to be marginalized over</p>
</td></tr>
<tr><td><code id="MSG_+3A_c">C</code></td>
<td>

<p>Another disjoint subset of the node set of <code>a</code> that is going to be
conditioned on.
</p>
</td></tr>
<tr><td><code id="MSG_+3A_showmat">showmat</code></td>
<td>

<p>A logical value. <code>TRUE</code> (by default) to print the generated matrix.
</p>
</td></tr>
<tr><td><code id="MSG_+3A_plot">plot</code></td>
<td>

<p>A logical value, <code>FALSE</code> (by default). <code>TRUE</code> to plot
the generated graph.
</p>
</td></tr>
<tr><td><code id="MSG_+3A_plotfun">plotfun</code></td>
<td>

<p>Function to plot the graph when <code>plot == TRUE</code>. Can be <code>plotGraph</code> (the default) or <code>drawGraph</code>.
</p>
</td></tr>
<tr><td><code id="MSG_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plotfun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the functions <code><a href="#topic+SG">SG</a></code> and <code><a href="#topic+Max">Max</a></code>.
</p>


<h3>Value</h3>

<p>A matrix that consists 4 different integers as an <code class="reqn">ij</code>-element: 0 for a missing
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 10 for a full line between
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers are
added to be associated with multiple edges of different types. The matrix is
symmetric w.r.t full lines and bi-directed arrows.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Richardson, T.S. and Spirtes, P. (2002). Ancestral graph Markov models. <em>Annals
of Statistics</em>, 30(4), 962-1030.
</p>
<p>Sadeghi, K. (2013). Stable mixed graphs.
<em>Bernoulli</em> 19(5B), 2330â€“2358.
</p>
<p>Sadeghi, K. and Lauritzen, S.L. (2014). Markov properties for loopless mixed graphs. <em>Bernoulli</em> 20(2), 676-696.
</p>
<p>Wermuth, N. (2011). Probability distributions with summary graph structure.
<em>Bernoulli</em>, 17(3), 845-879.</p>


<h3>See Also</h3>

<p><code><a href="#topic+MAG">MAG</a></code>, <code><a href="#topic+Max">Max</a></code>, <code><a href="#topic+MRG">MRG</a></code>, <code><a href="#topic+SG">SG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ex&lt;-matrix(c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ##The adjacency matrix of a DAG
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
             0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
             0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,
             1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,
             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
             1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
             0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0), 16, 16, byrow=TRUE)
M &lt;- c(3,5,6,15,16)
C &lt;- c(4,7)
MSG(ex,M,C,plot=TRUE)
###################################################
H&lt;-matrix(c(0,100,1,0,100,0,100,0,0,100,0,100,0,1,100,0),4,4)
Max(H)
</code></pre>

<hr>
<h2 id='null'>
Null space of a matrix
</h2><span id='topic+null'></span>

<h3>Description</h3>

<p>Given a matrix <code>M</code> find a matrix <code>N</code>  such that  
<code class="reqn">N^T M</code> is zero. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_+3A_m">M</code></td>
<td>

<p>A matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix <code>N</code> with the basis for the null space, or an empty vector if 
the matrix <code>M</code> is square and of maximal rank.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+Null">Null</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'> null(c(1,1,1))
</code></pre>

<hr>
<h2 id='parcor'>Partial correlations</h2><span id='topic+parcor'></span>

<h3>Description</h3>

<p>Finds the matrix of the partial correlations between pairs
of variables given the rest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parcor(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parcor_+3A_s">S</code></td>
<td>
<p>a symmetric positive definite matrix, representing a
covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm computes <code class="reqn">- \sigma^{rs}/(\sigma^{rr}
    \sigma^{ss})^{1/2}</code> where the <code class="reqn">\sigma^{rs}</code> are concentrations,
i.e. elements of the inverse covariance matrix.
</p>


<h3>Value</h3>

<p>A symmetric matrix with ones along the diagonal and in position
<code class="reqn">(r,s)</code> the partial correlation between variables <code class="reqn">r</code>
and <code class="reqn">s</code> given all the remaining variables.</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Cox, D. R. &amp; Wermuth, N. (1996). <em>Multivariate
dependencies</em>. London: Chapman &amp; Hall.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+var">var</a></code>, <code><a href="stats.html#topic+cor">cor</a></code>, <code><a href="#topic+correlations">correlations</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### Partial correlations for the mathematics marks data
data(marks)
S &lt;- var(marks)
parcor(S)
</code></pre>

<hr>
<h2 id='pcor'>Partial correlation</h2><span id='topic+pcor'></span>

<h3>Description</h3>

<p>Computes the partial correlation between two variables given
a set of other variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcor(u, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcor_+3A_u">u</code></td>
<td>
<p>a vector of integers of length &gt; 1. The first two integers are
the indices of variables the correlation of which must be
computed. The rest of the vector is the conditioning set.
</p>
</td></tr>
<tr><td><code id="pcor_+3A_s">S</code></td>
<td>
<p>a symmetric positive definite matrix, a sample covariance
matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, the partial correlation matrix between variables <code>u[1]</code>
and <code>u[2]</code> given <code>u[-c(1,2)]</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code>,  <code><a href="#topic+parcor">parcor</a></code>, <code><a href="#topic+correlations">correlations</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(marks)
## The correlation between vectors and algebra given analysis and statistics
 pcor(c("vectors", "algebra", "analysis", "statistics"), var(marks))
## The same
pcor(c(2,3,4,5), var(marks))
## The correlation between vectors and algebra given statistics
 pcor(c("vectors", "algebra", "statistics"), var(marks))
## The marginal correlation between analysis and statistics 
pcor(c("analysis","statistics"), var(marks))
</code></pre>

<hr>
<h2 id='pcor.test'>Test for zero partial association</h2><span id='topic+pcor.test'></span>

<h3>Description</h3>

<p>Test for conditional independence between two variables, given the
other ones, assuming a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcor.test(r, q, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcor.test_+3A_r">r</code></td>
<td>
<p>a partial correlation coefficient, computed by <code><a href="#topic+pcor">pcor</a></code>.</p>
</td></tr>
<tr><td><code id="pcor.test_+3A_q">q</code></td>
<td>
<p>the number of variables in the conditioning set.</p>
</td></tr>
<tr><td><code id="pcor.test_+3A_n">n</code></td>
<td>
<p>integer &gt; 0, the sample size.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>tval</code></td>
<td>
<p>The Student's t-test statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The degrees of freedom</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>The P-value, assuming a two-sided alternative.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcor">pcor</a></code>, <code><a href="#topic+shipley.test">shipley.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Are 2,3 independent given 1?
data(marks)
pcor.test(pcor(c(2,3,1), var(marks)), 1, n=88)
</code></pre>

<hr>
<h2 id='plotGraph'>Plot of a mixed graph</h2><span id='topic+plotGraph'></span>

<h3>Description</h3>

<p>Plots a mixed graph from an adjacency matrix,
a <code>graphNEL</code> object, an <code><a href="igraph.html#topic+igraph">igraph</a></code> object, or
a descriptive vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGraph(a, dashed = FALSE, tcltk = TRUE, layout = layout.auto,
directed = FALSE, noframe = FALSE, nodesize = 15, vld = 0, vc = "gray",
vfc = "black", colbid = "FireBrick3", coloth = "black", cex = 1.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGraph_+3A_a">a</code></td>
<td>

<p>An adjacency matrix: a matrix that consists of 4 different integers as an <code class="reqn">ij</code>-element:
0 for a missing edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>,
10 for a full line between
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers can be added to generate multiple edges of different types. The matrix must be symmetric w.r.t full lines and bi-directed arrows.
Or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object.Or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph, that is a sequence of triples (type,node1label,node2label). The type of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and <code>"l"</code> (lines).
</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_dashed">dashed</code></td>
<td>
<p>A logical value. If <code>TRUE</code> the bi-directed edges are plotted as undirected dashed edges.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_tcltk">tcltk</code></td>
<td>
<p>A logical value. If <code>TRUE</code> the function opens a tcltk device to plot the graphs, allowing the interactive manimulation of the graph. If <code>FALSE</code>the function opens a standard device without interaction.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_layout">layout</code></td>
<td>
<p>The name of a function used to compute the (initial) layout of the graph. The default is <code>layout.auto</code>. This can be further adjusted if <code>tcltk</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_directed">directed</code></td>
<td>
<p>A logical value. If <code>FALSE</code> a symmetric adjacency matrix with entries 1 is interpreted as an undirected graph. If <code>TRUE</code> it is interpreted as a directed graph with double arrows. If <code>a</code> is not an adjacency matrix, it is ignored.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_noframe">noframe</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, then the nodes are not circled.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_nodesize">nodesize</code></td>
<td>
<p>An integer denoting the size of the nodes (default 15). It can be
increased to accommodate larger labels.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_vld">vld</code></td>
<td>
<p>An integer defining the distance between a vertex and its label. Defaults to 0.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_vc">vc</code></td>
<td>
<p>Vertex color. Default is &quot;gray&quot;.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_vfc">vfc</code></td>
<td>
<p>Vertex frame color. Default is &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_colbid">colbid</code></td>
<td>
<p>Color of the bi-directed edges. Default is &quot;FireBrick3&quot;.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_coloth">coloth</code></td>
<td>
<p>Color of all the other edges. Default is &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_cex">cex</code></td>
<td>
<p>An integer (defaults to 1) to adjust the scaling of the font of the labels.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>plot</code> or <code>tkplot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotGraph</code> uses <code><a href="graphics.html#topic+plot">plot</a></code> and <code><a href="igraph.html#topic+tkplot">tkplot</a></code> in <span class="pkg"><a href="igraph.html#topic+igraph">igraph</a></span> package.
</p>


<h3>Value</h3>

<p>Plot of the associated graph and returns invisibly a list with two slots:
<code>tkp.id</code>,
<code>graph</code>, the input graph as an <code>igraph</code> object.
The id can be used to get the layout of the adjusted graph.
The bi-directed edges are plotted in red.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi, Giovanni M. Marchetti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grMAT">grMAT</a></code>, <code><a href="igraph.html#topic+tkplot">tkplot</a></code>, <code><a href="#topic+drawGraph">drawGraph</a></code>,
<code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exvec&lt;-c("b",1,2,"b",1,14,"a",9,8,"l",9,11,
         "a",10,8,"a",11,2,"a",11,9,"a",11,10,
         "a",12,1,"b",12,14,"a",13,10,"a",13,12)
plotGraph(exvec)
############################################
amat&lt;-matrix(c(0,11,0,0,10,0,100,0,0,100,0,1,0,0,1,0),4,4)
plotGraph(amat)
plotGraph(makeMG(bg = UG(~a*b*c+ c*d), dg = DAG(a ~ x + z, b ~ z )))
plotGraph(makeMG(bg = UG(~a*b*c+ c*d), dg = DAG(a ~ x + z, b ~ z )), dashed = TRUE)
# A graph with double and triple edges
G &lt;-
structure(c(0, 101, 0, 0, 100, 0, 100, 100, 0, 100, 0, 100, 0,
111, 100, 0), .Dim = c(4L, 4L), .Dimnames = list(c("X", "Z",
"Y", "W"), c("X", "Z", "Y", "W")))
plotGraph(G)
# A regression chain graph with longer labels
 plotGraph(makeMG(bg = UG(~Love*Constraints+ Constraints*Reversal+ Abuse*Distress),
   dg = DAG(Love ~ Abuse + Distress, Constraints ~ Distress, Reversal ~ Distress,
   Abuse ~ Fstatus, Distress ~ Fstatus),
   ug = UG(~Fstatus*Schooling+ Schooling*Age)),
   dashed = TRUE, noframe = TRUE)
# A graph with 4 edges between two nodes.
G4 = matrix(0, 2, 2); G4[1,2] = 111; G4[2,1] = 111
plotGraph(G4)
</code></pre>

<hr>
<h2 id='powerset'>
Power set
</h2><span id='topic+powerset'></span>

<h3>Description</h3>

<p>Finds the list of all subsets of a set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerset(set, sort = TRUE, nonempty = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerset_+3A_set">set</code></td>
<td>

<p>A numeric or character vector.
</p>
</td></tr>
<tr><td><code id="powerset_+3A_sort">sort</code></td>
<td>

<p>Logical value. If <code>TRUE</code> the subsets are sorted according 
to dimension.   Default is <code>TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="powerset_+3A_nonempty">nonempty</code></td>
<td>

<p>Logical value. If <code>TRUE</code> the empty set is omitted.   Default is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>sort == FALSE</code> the sets are in inverse lexicographical order.  
</p>


<h3>Value</h3>

<p>A list of all subsets of <code>set</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti
</p>


<h3>Examples</h3>

<pre><code class='language-R'>powerset(c("A", "B", "C"), nonempty = FALSE)  
powerset(1:3, sort = FALSE, nonempty = TRUE)
</code></pre>

<hr>
<h2 id='rcorr'>Random correlation matrix</h2><span id='topic+rcorr'></span>

<h3>Description</h3>

<p>Generates a random correlation matrix
with the method of Marsaglia and Olkin (1984).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcorr(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcorr_+3A_d">d</code></td>
<td>
<p>an integer &gt; 0,  the order of the correlation matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm uses <code><a href="#topic+rsphere">rsphere</a></code> to generate <code class="reqn">d</code>
vectors on a sphere in  <code class="reqn">d</code>-space. If <code class="reqn">Z</code>
is a matrix with such vectors as rows, then the random
correlation matrix is <code class="reqn">ZZ'</code>.
</p>


<h3>Value</h3>

<p>a correlation matrix of order <code>d</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Marshall, G.&amp; Olkin, I. (1984).Generating correlation
matrices. <em>SIAM J. Sci. Stat. Comput.</em>, 5, 2, 470&ndash;475.</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsphere">rsphere</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A random correlation matrix of order 3
rcorr(3)
## A random correlation matrix of order 5
rcorr(5)
</code></pre>

<hr>
<h2 id='RepMarBG'>
Representational Markov equivalence to bidirected graphs.
</h2><span id='topic+RepMarBG'></span>

<h3>Description</h3>

<p><code>RepMarBG</code> determines whether a given maximal ancestral graph can 
be Markov equivalent to a bidirected graph, and if that is the case, it finds
a bidirected graph that is Markov equivalent to the given graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RepMarBG(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RepMarBG_+3A_amat">amat</code></td>
<td>

<p>An adjacency matrix, or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object 
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph, 
that is a sequence of triples (type, node1label, node2label). The type 
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and 
<code>"l"</code> (lines).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>RepMarBG</code> looks for presence of an unshielded non-collider 
V-configuration in graph.
</p>


<h3>Value</h3>

<p>A list with two components: <code>verify</code> and
<code>amat</code>. <code>verify</code> is a logical value, <code>TRUE</code> if there is
a representational Markov equivalence and <code>FALSE</code> otherwise.
<code>amat</code> is either <code>NA</code> if <code>verify == FALSE</code> or
the adjacency matrix of the generated graph, if
<code>verify == TRUE</code>. In this case it consists of 4 different
integers as an <code class="reqn">ij</code>-element: 0 for a missing 
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 10 for a full line between 
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers are 
added to be associated with multiple edges of different types. The matrix is 
symmetric w.r.t full lines and bi-directed arrows.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Sadeghi, K. (2011). Markov equivalences for subclasses of loopless mixed graphs.
<em>Submitted</em>, 2011.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MarkEqMag">MarkEqMag</a></code>, <code><a href="#topic+MarkEqRcg">MarkEqRcg</a></code>, <code><a href="#topic+RepMarDAG">RepMarDAG</a></code>,
<code><a href="#topic+RepMarUG">RepMarUG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H&lt;-matrix(c(0,10,0,0,10,0,0,0,0,1,0,100,0,0,100,0),4,4)
RepMarBG(H)
</code></pre>

<hr>
<h2 id='RepMarDAG'>
Representational Markov equivalence to directed acyclic graphs.
</h2><span id='topic+RepMarDAG'></span>

<h3>Description</h3>

<p><code>RepMarDAG</code> determines whether a given maximal ancestral graph can 
be Markov equivalent to a directed acyclic graph, and if that is the case, 
it finds a directed acyclic graph that is Markov equivalent to the given 
graph.</p>


<h3>Usage</h3>

<pre><code class='language-R'>RepMarDAG(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RepMarDAG_+3A_amat">amat</code></td>
<td>

<p>An adjacency matrix, or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object 
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph, 
that is a sequence of triples (type, node1label, node2label). The type 
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and 
<code>"l"</code> (lines).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>RepMarDAG</code> first looks whether the subgraph induced by full lines
is chordal and whether there is a minimal collider path or cycle of
length 4 in graph.</p>


<h3>Value</h3>

<p>A list with two components: <code>verify</code> and
<code>amat</code>. <code>verify</code> is a logical value, <code>TRUE</code> if there is
a representational Markov equivalence and <code>FALSE</code> otherwise.
<code>amat</code> is either <code>NA</code> if <code>verify == FALSE</code> or
the adjacency matrix of the generated graph, if
<code>verify == TRUE</code>. In this case it consists of 4 different
integers as an <code class="reqn">ij</code>-element: 0 for a missing 
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 10 for a full line between 
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers are 
added to be associated with multiple edges of different types. The matrix is 
symmetric w.r.t full lines and bi-directed arrows.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Sadeghi, K. (2011). Markov equivalences for subclasses of loopless mixed graphs.
<em>Submitted</em>, 2011. </p>


<h3>See Also</h3>

<p><code><a href="#topic+MarkEqMag">MarkEqMag</a></code>, <code><a href="#topic+MarkEqRcg">MarkEqRcg</a></code>, <code><a href="#topic+RepMarBG">RepMarBG</a></code>,
<code><a href="#topic+RepMarUG">RepMarUG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>H&lt;-matrix(c(0,10,0,0,10,0,0,0,0,1,0,100,0,0,100,0),4,4)
RepMarBG(H)
</code></pre>

<hr>
<h2 id='RepMarUG'>
Representational Markov equivalence to undirected graphs.
</h2><span id='topic+RepMarUG'></span>

<h3>Description</h3>

<p><code>RepMarUG</code> determines whether a given maximal ancestral graph can 
be Markov equivalent to an undirected graph, and if that is the case, it finds
an undirected graph that is Markov equivalent to the given graph.</p>


<h3>Usage</h3>

<pre><code class='language-R'>RepMarUG(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RepMarUG_+3A_amat">amat</code></td>
<td>

<p>An adjacency matrix, or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object 
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph, 
that is a sequence of triples (type, node1label, node2label). The type 
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and 
<code>"l"</code> (lines).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>RepMarBG</code> looks for presence of an unshielded collider 
V-configuration in graph.</p>


<h3>Value</h3>

<p>A list with two components: <code>verify</code> and
<code>amat</code>. <code>verify</code> is a logical value, <code>TRUE</code> if there is
a representational Markov equivalence and <code>FALSE</code> otherwise.
<code>amat</code> is either <code>NA</code> if <code>verify == FALSE</code> or
the adjacency matrix of the generated graph, if
<code>verify == TRUE</code>. In this case it consists of 4 different
integers as an <code class="reqn">ij</code>-element: 0 for a missing 
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 10 for a full line between 
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers are 
added to be associated with multiple edges of different types. The matrix is 
symmetric w.r.t full lines and bi-directed arrows.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Sadeghi, K. (2011). Markov equivalences for subclasses of loopless mixed graphs.
<em>Submitted</em>, 2011. </p>


<h3>See Also</h3>

<p><code><a href="#topic+MarkEqMag">MarkEqMag</a></code>, <code><a href="#topic+MarkEqRcg">MarkEqRcg</a></code>, <code><a href="#topic+RepMarBG">RepMarBG</a></code>,
<code><a href="#topic+RepMarDAG">RepMarDAG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H&lt;-matrix(c(0,10,0,0,10,0,0,0,0,1,0,100,0,0,100,0),4,4)
RepMarUG(H)
</code></pre>

<hr>
<h2 id='RG'>
Ribbonless graph
</h2><span id='topic+RG'></span>

<h3>Description</h3>

<p><code>RG</code> generates and plots ribbonless graphs (a modification of MC graph
to use m-separation) after marginalization and conditioning.</p>


<h3>Usage</h3>

<pre><code class='language-R'>RG(amat,M=c(),C=c(),showmat=TRUE,plot=FALSE, plotfun = plotGraph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RG_+3A_amat">amat</code></td>
<td>

<p>An adjacency matrix, or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph,
that is a sequence of triples (type, node1label, node2label). The type
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and
<code>"l"</code> (lines).
</p>
</td></tr>
<tr><td><code id="RG_+3A_m">M</code></td>
<td>

<p>A subset of the node set of <code>a</code> that is going to be marginalized over</p>
</td></tr>
<tr><td><code id="RG_+3A_c">C</code></td>
<td>

<p>Another disjoint subset of the node set of <code>a</code> that is going to be
conditioned on.
</p>
</td></tr>
<tr><td><code id="RG_+3A_showmat">showmat</code></td>
<td>

<p>A logical value. <code>TRUE</code> (by default) to print the generated matrix.
</p>
</td></tr>
<tr><td><code id="RG_+3A_plot">plot</code></td>
<td>

<p>A logical value, <code>FALSE</code> (by default). <code>TRUE</code> to plot
the generated graph.
</p>
</td></tr>
<tr><td><code id="RG_+3A_plotfun">plotfun</code></td>
<td>

<p>Function to plot the graph when <code>plot == TRUE</code>. Can be <code>plotGraph</code> (the default) or <code>drawGraph</code>.
</p>
</td></tr>
<tr><td><code id="RG_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plotfun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that consists 4 different integers as an <code class="reqn">ij</code>-element: 0 for a missing
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 10 for a full line between
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers are
added to be associated with multiple edges of different types. The matrix is
symmetric w.r.t full lines and bi-directed arrows.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Koster, J.T.A. (2002). Marginalizing and conditioning in graphical models.
<em>Bernoulli</em>, 8(6), 817-840.
</p>
<p>Sadeghi, K. (2013). Stable mixed graphs.
<em>Bernoulli</em> 19(5B), 2330â€“2358.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AG">AG</a></code>,, <code><a href="#topic+MRG">MRG</a></code>, <code><a href="#topic+SG">SG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	ex &lt;- matrix(c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ##The adjacency matrix of a DAG
	               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
	               0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
	               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
	               0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
	               0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,
	               1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,
	               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
	               0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0),16,16, byrow = TRUE)

M&lt;-c(3,5,6,15,16)
C&lt;-c(4,7)
RG(ex,M,C,plot=TRUE)
</code></pre>

<hr>
<h2 id='rnormDag'>Random sample from a decomposable Gaussian model</h2><span id='topic+rnormDag'></span>

<h3>Description</h3>

<p>Generates a sample from a mean centered  multivariate normal
distribution whose covariance matrix has a given triangular
decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnormDag(n, A, Delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnormDag_+3A_n">n</code></td>
<td>
<p>an integer &gt; 0, the sample size.</p>
</td></tr>
<tr><td><code id="rnormDag_+3A_a">A</code></td>
<td>
<p>a square, upper triangular matrix with ones along the
diagonal. It defines, together with <code>Delta</code>,
the concentration matrix (and also the covariance matrix)
of the multivariate normal. The order of <code>A</code> is the
number of components of the normal.</p>
</td></tr>
<tr><td><code id="rnormDag_+3A_delta">Delta</code></td>
<td>
<p>a numeric vector of length equal to the number of columns
of <code>A</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value in position <code class="reqn">(i,j)</code> of  <code>A</code> (with <code class="reqn">i &lt; j</code>) is
a regression coefficient (with  sign changed) in the regression of
variable <code class="reqn">i</code> on variables <code class="reqn">i+1, \dots, d</code>.
</p>
<p>The value in position <code class="reqn">i</code> of <code>Delta</code> is the residual
variance in the above regression.
</p>


<h3>Value</h3>

<p>a matrix with <code>n</code> rows and <code>nrow(A)</code> columns,
a sample from a multivariate normal distribution with mean zero
and covariance matrix
<code>S = solve(A) %*% diag(Delta) %*% t(solve(A))</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Cox, D. R. &amp; Wermuth, N. (1996). <em>Multivariate
dependencies</em>. London: Chapman &amp; Hall.</p>


<h3>See Also</h3>

<p><code><a href="#topic+triDec">triDec</a></code>, <code><a href="#topic+fitDag">fitDag</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a sample of 100 observation from a multivariate normal
## The matrix of the path coefficients
A &lt;- matrix(
c(1, -2, -3,  0, 0,  0,  0,
  0,  1,  0, -4, 0,  0,  0,
  0,  0,  1,  2, 0,  0,  0,
  0,  0,  0,  1, 1, -5,  0,
  0,  0,  0,  0, 1,  0,  3,
  0,  0,  0,  0, 0,  1, -4,
  0,  0,  0,  0, 0,  0,  1), 7, 7, byrow=TRUE)
D &lt;- rep(1, 7)
X &lt;- rnormDag(100, A, D)

## The true covariance matrix
solve(A) %*% diag(D) %*% t(solve(A))

## Triangular decomposition of the sample covariance matrix
triDec(cov(X))$A
</code></pre>

<hr>
<h2 id='rsphere'>Random vectors on a sphere</h2><span id='topic+rsphere'></span>

<h3>Description</h3>

<p>Generates a sample of points uniformly distributed
on the surface of a sphere in d-space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsphere(n, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsphere_+3A_n">n</code></td>
<td>
<p>an integer, the sample size.</p>
</td></tr>
<tr><td><code id="rsphere_+3A_d">d</code></td>
<td>
<p>an integer, the dimension of the space. For example, a circle
is defined in 2D-space, a sphere in 3D-space.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is based on normalizing to length 1 each d-vector
of a sample from a multivariate normal <code class="reqn">N(0, I)</code>.
</p>


<h3>Value</h3>

<p>a matrix of <code>n</code> rows and <code>d</code> columns.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rnorm">rnorm</a></code>, <code><a href="#topic+rcorr">rcorr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## 100 points on circle
z &lt;- rsphere(100,2)
plot(z)

## 100 points on a sphere
z &lt;- rsphere(100, 3)
pairs(z)
</code></pre>

<hr>
<h2 id='SG'>
summary graph
</h2><span id='topic+SG'></span>

<h3>Description</h3>

<p><code>SG</code> generates and plots summary graphs after marginalization
and conditioning.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SG(amat,M=c(),C=c(),showmat=TRUE,plot=FALSE, plotfun = plotGraph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SG_+3A_amat">amat</code></td>
<td>

<p>An adjacency matrix, or a graph that can be a <code>graphNEL</code> or an <code><a href="igraph.html#topic+igraph">igraph</a></code> object
or a vector of length <code class="reqn">3e</code>, where <code class="reqn">e</code> is the number of edges of the graph,
that is a sequence of triples (type, node1label, node2label). The type
of edge can be <code>"a"</code> (arrows from node1 to node2), <code>"b"</code> (arcs), and
<code>"l"</code> (lines).
</p>
</td></tr>
<tr><td><code id="SG_+3A_m">M</code></td>
<td>

<p>A subset of the node set of <code>a</code> that is going to be marginalised over</p>
</td></tr>
<tr><td><code id="SG_+3A_c">C</code></td>
<td>

<p>Another disjoint subset of the node set of <code>a</code> that is going to be
conditioned on.
</p>
</td></tr>
<tr><td><code id="SG_+3A_showmat">showmat</code></td>
<td>

<p>A logical value. <code>TRUE</code> (by default) to print the generated matrix.
</p>
</td></tr>
<tr><td><code id="SG_+3A_plot">plot</code></td>
<td>

<p>A logical value, <code>FALSE</code> (by default). <code>TRUE</code> to plot
the generated graph.
</p>
</td></tr>
<tr><td><code id="SG_+3A_plotfun">plotfun</code></td>
<td>

<p>Function to plot the graph when <code>plot == TRUE</code>. Can be <code>plotGraph</code> (the default) or <code>drawGraph</code>.
</p>
</td></tr>
<tr><td><code id="SG_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plotfun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that consists 4 different integers as an <code class="reqn">ij</code>-element: 0 for a missing
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 10 for a full line between
<code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers are
added to be associated with multiple edges of different types. The matrix is
symmetric w.r.t full lines and bi-directed arrows.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi
</p>


<h3>References</h3>

<p>Sadeghi, K. (2013). Stable mixed graphs.
<em>Bernoulli</em> 19(5B), 2330â€“2358.
</p>
<p>Wermuth, N. (2011). Probability distributions with summary graph structure.
<em>Bernoulli</em>, 17(3),845-879.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AG">AG</a></code>, <code><a href="#topic+MSG">MSG</a></code>, <code><a href="#topic+RG">RG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	ex &lt;- matrix(c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ##The adjacency matrix of a DAG
	               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
	               0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
	               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
	               0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
	               0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,
	               1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,
	               0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	               1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
	               0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0),16,16, byrow = TRUE)
M &lt;- c(3,5,6,15,16)
C &lt;- c(4,7)
SG(ex, M, C, plot = TRUE)
SG(ex, M, C, plot = TRUE, plotfun = drawGraph, adjust = FALSE)
</code></pre>

<hr>
<h2 id='shipley.test'>Test of all independencies implied by a given DAG</h2><span id='topic+shipley.test'></span>

<h3>Description</h3>

<p>Computes a simultaneous test of all independence relationships
implied by a given Gaussian model  defined according to
a directed acyclic graph, based on the sample covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shipley.test(amat, S, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shipley.test_+3A_amat">amat</code></td>
<td>
<p>a square Boolean matrix, of the same dimension as <code>S</code>,
representing the adjacency matrix of a DAG.</p>
</td></tr>
<tr><td><code id="shipley.test_+3A_s">S</code></td>
<td>
<p>a symmetric positive definite matrix, the sample covariance matrix.</p>
</td></tr>
<tr><td><code id="shipley.test_+3A_n">n</code></td>
<td>
<p>a positive integer, the sample size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test statistic is <code class="reqn">C = -2 \sum \ln p_j</code> where <code class="reqn">p_j</code> are the
p-values of tests of conditional independence in the basis set
computed by <code>basiSet(A)</code>. The p-values are independent
uniform variables on <code class="reqn">(0,1)</code> and the statistic has exactly a
chi square distribution on <code class="reqn">2k</code> degrees of freedom  where
<code class="reqn">k</code> is the number of elements of the basis set.
Shipley (2002) calls this test Fisher's C test.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ctest</code></td>
<td>
<p>Test statistic <code class="reqn">C</code>.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>The P-value of the test, assuming a two-sided alternative.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Shipley, B. (2000). A new inferential test
for path models based on directed acyclic graphs. <em>Structural
Equation Modeling</em>, 7(2), 206&ndash;218.</p>


<h3>See Also</h3>

<p><code><a href="#topic+basiSet">basiSet</a></code>, <code><a href="#topic+pcor.test">pcor.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A decomposable model for the mathematics marks data
data(marks)
dag &lt;- DAG(mechanics ~ vectors+algebra, vectors ~ algebra, 
statistics ~ algebra+analysis, analysis ~ algebra)
shipley.test(dag, cov(marks), n=88)
</code></pre>

<hr>
<h2 id='Simple+20Graph+20Operations'>Simple graph operations</h2><span id='topic+bd'></span><span id='topic+ch'></span><span id='topic+pa'></span>

<h3>Description</h3>

<p>Finds the boundary, children, parents of a subset of nodes of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bd(nn, amat)
ch(nn, amat)
pa(nn, amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simple+2B20Graph+2B20Operations_+3A_nn">nn</code></td>
<td>
<p>a vector of nodes. It may either a numeric vector, or a character vector. If it is character vector must be a subset
of the <code>rownames</code> of the edge matrix.</p>
</td></tr>
<tr><td><code id="Simple+2B20Graph+2B20Operations_+3A_amat">amat</code></td>
<td>
<p>a square matrix with dimnames specifying the adjacency matrix of the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For definitions of the operators see Lauritzen (1996).
</p>


<h3>Value</h3>

<p>The operators return a character vector specifying the boundary or the children or the parents of nodes  <code>nn</code>
in the graph.  This is a numeric or a character vector depending
on the mode of <code>nn</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Lauritzen, S. (1996). <em>Graphical models</em>. Oxford:
Clarendon Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+UG">UG</a></code>, <code><a href="#topic+DAG">DAG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## find boundary of a subset of nodes of a DAG
G &lt;- DAG(y ~ x+b+a, b~a, x~a)
bd("b", G)
bd(c("b", "x"), G)
bd("x", G)
bd(c("x","b"), G)
## find boundary of a subset of nodes of an UG
G &lt;- UG(~ y*x*z + z*h*v)
bd("z", G)
bd(c("y", "x"), G)
bd("v", G)
bd(c("x","v"), G)
## children of a subset of nodes of a DAG
G &lt;- DAG(y ~ x+b+a, b~a, x~a)
ch("b", G)
ch(c("b", "x"), G)
ch("x", G)
ch(c("a","x"), G)
## parents of a subset of nodes of a DAG
pa("b", G)
pa(c("b", "x"), G)
pa("x", G)
pa(c("x","b"), G)
</code></pre>

<hr>
<h2 id='stress'>
Stress
</h2><span id='topic+stress'></span>

<h3>Description</h3>

<p>Stress data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stress)</code></pre>


<h3>Format</h3>

<p>A <code class="reqn">4 \times 4</code> covariance matrix for the following variables.
</p>

<dl>
<dt>Y</dt><dd></dd>
<dt>V</dt><dd></dd>
<dt>X</dt><dd></dd>
<dt>U</dt><dd></dd>
</dl>



<h3>Details</h3>

<p>See Cox and Wermuth (1996).
</p>


<h3>References</h3>

<p>Cox, D. R. &amp; Wermuth, N. (1996). <em>Multivariate
dependencies</em>. London: Chapman &amp; Hall.
</p>
<p>Slangen K., Kleemann P.P and Krohne H.W. (1993). Coping with surgical stress. In: Krohne H. W. (ed.).  <em>Attention and avoidance: Strategies in coping with aversiveness</em>. New York, Heidelberg: Springer, 321-346.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stress)
G = UG(~ Y*X + X*V + V*U + U*Y)
fitConGraph(G, stress, 100)
</code></pre>

<hr>
<h2 id='surdata'>
A simulated data set 
</h2><span id='topic+surdata'></span>

<h3>Description</h3>

<p>Simulated data following a seemingly unrelated regression model.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(surdata)</code></pre>


<h3>Format</h3>

<p>A data frame with 600 observations on the following 4 variables.
</p>

<dl>
<dt><code>A</code></dt><dd><p>a numeric response vector</p>
</dd>
<dt><code>B</code></dt><dd><p>a numeric response vector</p>
</dd>
<dt><code>X</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Z</code></dt><dd><p>a numeric vector with codes <code>1</code> and <code>-1</code> for a binary variables.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(surdata)
pairs(surdata)
</code></pre>

<hr>
<h2 id='swp'>Sweep operator</h2><span id='topic+swp'></span>

<h3>Description</h3>

<p>Sweeps a covariance matrix with respect to a subset of indices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swp(V, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swp_+3A_v">V</code></td>
<td>
<p>a symmetric positive definite matrix, the covariance matrix.</p>
</td></tr>
<tr><td><code id="swp_+3A_b">b</code></td>
<td>
<p>a subset of indices of the columns of <code>V</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sweep operator has been introduced by Beaton (1964) as a tool for
inverting symmetric matrices (see Dempster, 1969).
</p>


<h3>Value</h3>

<p>a square matrix <code>U</code> of the same order as <code>V</code>. If <code>a</code> is
the complement of <code>b</code>, then <code>U[a,b]</code> is the matrix of
regression coefficients of <code>a</code> given <code>b</code> and <code>U[a,a]</code>
is the corresponding covariance matrix of the residuals.
</p>
<p>If <code>b</code> is empty the function returns <code>V</code>.
</p>
<p>If <code>b</code> is the vector <code>1:nrow(V)</code> (or its permutation) then
the function returns the opposite of the inverse of <code>V</code>.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Beaton, A.E. (1964). <em>The use of special matrix operators
in statistical calculus</em>. Ed.D. thesis, Harvard
University. Reprinted as Educational Testing Service Research Bulletin
64-51. Princeton.
</p>
<p>Dempster, A.P. (1969). <em>Elements of continuous multivariate
analysis</em>.  Reading: Addison-Wesley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitDag">fitDag</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A very simple example
V &lt;- matrix(c(10, 1, 1, 2), 2, 2)
swp(V, 2)
</code></pre>

<hr>
<h2 id='topSort'>Topological sort</h2><span id='topic+topSort'></span><span id='topic+topOrder'></span>

<h3>Description</h3>

<p><code>topOrder</code> returns the topological order of a directed
acyclic graph (parents, before children). <code>topSort</code> permutates
the adjacency matrix according to the topological order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topSort(amat)
topOrder(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topSort_+3A_amat">amat</code></td>
<td>
<p>a square Boolean matrix with dimnames, representing the
adjacency matrix of a directed acyclic graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The topological order needs not to be unique.
After the permutation the adjacency matrix of the graph is
upper triangular. The function is a translation of
the Matlab function <code>topological_sort</code> in Toolbox
<span class="pkg">BNT</span> written by Kevin P. Murphy.
</p>


<h3>Value</h3>

<p><code>topOrder(amat)</code> returns a vector of integers representing
the permutation of the nodes. <code>topSort(amat)</code> returns
the adjacency matrix with rows and columns permutated.
</p>


<h3>Note</h3>

<p>The order of the nodes defined by <code>DAG</code> is that of their first
appearance in the model formulae (from left to right).
</p>


<h3>Author(s)</h3>

<p>Kevin P. Murphy, Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Aho, A.V., Hopcrtoft, J.E. &amp; Ullman, J.D. (1983). <em>Data structures
and algorithms.</em> Reading: Addison-Wesley.
</p>
<p>Lauritzen, S. (1996). <em>Graphical models</em>. Oxford:
Clarendon Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DAG">DAG</a></code>, <code><a href="#topic+isAcyclic">isAcyclic</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A simple example
dag &lt;- DAG(a ~ b, c ~ a + b, d ~ c + b)
dag
topOrder(dag)
topSort(dag)
</code></pre>

<hr>
<h2 id='transClos'>Transitive closure of a graph</h2><span id='topic+transClos'></span>

<h3>Description</h3>

<p>Computes the transitive closure of a graph (undirected or directed
acyclic).</p>


<h3>Usage</h3>

<pre><code class='language-R'>transClos(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transClos_+3A_amat">amat</code></td>
<td>
<p>a Boolean matrix with dimnames representing the adjacency
matrix
of a graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transitive closure of a directed graph with adjacency matrix <code class="reqn">A</code> is a
graph with adjacency matrix <code class="reqn">A^*</code> such that <code class="reqn">A^*_{i,j} = 1</code>
if there is a directed path from <code class="reqn">i</code> to <code class="reqn">j</code>. The transitive
closure of an undirected graph is defined similarly (by substituting
path to directed path).
</p>


<h3>Value</h3>

<table>
<tr><td><code>A</code></td>
<td>
<p>The adjacency matrix of the transitive closure.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>See Also</h3>

<p><code><a href="#topic+DAG">DAG</a></code>, <code><a href="#topic+UG">UG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Closure of a DAG
d &lt;- DAG(y ~ x, x ~ z)
transClos(d)

## Closure of an UG
g &lt;- UG(~ x*y*z+z*u+u*v)
transClos(g)
</code></pre>

<hr>
<h2 id='triDec'>Triangular decomposition of a covariance matrix</h2><span id='topic+triDec'></span>

<h3>Description</h3>

<p>Decomposes a symmetric positive definite matrix with a variant of the
Cholesky decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triDec(Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triDec_+3A_sigma">Sigma</code></td>
<td>
<p>a symmetric positive definite matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any symmetric positive definite matrix <code class="reqn">\Sigma</code>
can be decomposed as
<code class="reqn">\Sigma = B \Delta B^T</code>
where <code class="reqn">B</code> is upper triangular with ones
along the main diagonal and <code class="reqn">\Delta</code> is diagonal. If
<code class="reqn">\Sigma</code> is a covariance
matrix, the concentration matrix is <code class="reqn">\Sigma^{-1} = A^T \Delta^{-1}
    A</code> where  <code class="reqn">A = B^{-1}</code> is the matrix of the regression coefficients
(with the sign changed) of a system of linear recursive regression
equations  with independent residuals. In the equations each variable
<code class="reqn">i</code> is regressed on the variables <code class="reqn">i+1, \dots, d</code>.
The elements on the diagonal of <code class="reqn">\Delta</code> are the partial variances.
</p>


<h3>Value</h3>

<table>
<tr><td><code>A</code></td>
<td>
<p>a square upper triangular matrix of the same order as
<code>Sigma</code> with ones on the diagonal.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the inverse of <code>A</code>, another triangular matrix with unit diagonal.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p>a vector containing the diagonal values of <code class="reqn">\Delta</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Cox, D. R. &amp; Wermuth, N. (1996). <em>Multivariate
dependencies</em>. London: Chapman &amp; Hall.</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+chol">chol</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Triangular decomposition of a covariance matrix
B &lt;- matrix(c(1,  -2, 0, 1,
              0,   1, 0, 1,
              0,   0, 1, 0,
              0,   0, 0, 1), 4, 4, byrow=TRUE)
B
D &lt;- diag(c(3, 1, 2, 1))
S &lt;- B %*% D %*% t(B)
triDec(S)
solve(B)
</code></pre>

<hr>
<h2 id='UG'>Defining an undirected graph (UG)</h2><span id='topic+UG'></span>

<h3>Description</h3>

<p>A simple way to define an undirected graph by means of a single
model formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UG(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UG_+3A_f">f</code></td>
<td>
<p>a single model formula without response</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The undirected graph <code class="reqn">G = (V, E)</code> is defined by a set of nodes
<code class="reqn">V</code> and a set of pairs <code class="reqn">E</code>. The set of pairs is defined by
the set of interactions in the formula. Interactions 
define complete subgraphs (not necessarily maximal) of the UG.
The best way is to specify interactions that match the cliques
of the undirected graph. This is the standard way to define
graphical models for contingency tables. Remember that some
hierarchical models are not graphical, but they imply the same graph.
</p>
<p>The function returns the edge matrix of the graph, i.e. 
a square Boolean matrix of order equal to the number of nodes of the
graph and a one in position <code class="reqn">(i,j)</code> if there is an arrow from
<code class="reqn">j</code> to <code class="reqn">i</code> and zero otherwise. By default this matrix
has ones along the main diagonal. For UGs this matrix is symmetric.
The dimnames of the edge matrix are the nodes of the UG.
</p>


<h3>Value</h3>

<p>a Boolean matrix with dimnames, 
the adjacency matrix of the undirected graph.
</p>


<h3>Author(s)</h3>

<p>Giovanni M. Marchetti</p>


<h3>References</h3>

<p>Lauritzen, S. (1996). <em>Graphical models</em>. Oxford:
Clarendon Press.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitConGraph">fitConGraph</a></code>, <code><a href="#topic+fitCovGraph">fitCovGraph</a></code>, <code><a href="#topic+DAG">DAG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## X independent of Y given Z
UG(~ X*Z + Y*Z)

# The saturated model
UG(~ X*Y*Z)

## The model without three-way interactions has the same graph
UG(~ X*Y + Y*Z + Z*X)
UG(~ (X + Y + Z)^2)

## Butterfly model defined from the cliques
UG(~ mec*vec*alg + alg*ana*sta)

## Some isolated nodes
UG(~x*y*z + a + b) 
</code></pre>

<hr>
<h2 id='unmakeMG'>Loopless mixed graphs components</h2><span id='topic+unmakeMG'></span>

<h3>Description</h3>

<p>Splits the adjacency matrix of a loopless mixed graph into  three components:
directed, undirected and bi-directed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmakeMG(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmakeMG_+3A_amat">amat</code></td>
<td>
<p>a square matrix, with dimnames, representing a
loopless mixed graph. The matrix  consists of 4 different integers as
an <code class="reqn">ij</code>-element: 0 for a missing
edge between <code class="reqn">i</code> and <code class="reqn">j</code>, 1 for an arrow from <code class="reqn">i</code> to <code class="reqn">j</code>, 10 for a full line between <code class="reqn">i</code> and <code class="reqn">j</code>, and 100 for a bi-directed arrow between <code class="reqn">i</code> and <code class="reqn">j</code>. These numbers are added to be associated with multiple edges of different types. The matrix is symmetric w.r.t full lines and bi-directed arrows.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrices <code>ug</code>, and <code>bg</code> are just symmetric Boolean
matrices.</p>


<h3>Value</h3>

<p>It is the inverse of <code>makeAG</code>. It returns the following
components.
</p>
<table>
<tr><td><code>dg</code></td>
<td>
<p>the adjacency matrix of the directed edges.</p>
</td></tr>
<tr><td><code>ug</code></td>
<td>
<p>the adjacency matrix of the undirected edges.</p>
</td></tr>
<tr><td><code>bg</code></td>
<td>
<p>the adjacency matrix of the bi-directed edges.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mathias Drton, Giovanni M. Marchetti</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeMG">makeMG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ag &lt;- makeMG(ug=UG(~y0*y1), dg=DAG(y4~y2, y2~y1), bg=UG(~y2*y3+y3*y4))
isAG(ag)
unmakeMG(ag)
</code></pre>

<hr>
<h2 id='Utility+20Functions'>
Utility functions 
</h2><span id='topic+rem'></span><span id='topic+SPl'></span><span id='topic+RR'></span><span id='topic+likGau'></span>

<h3>Description</h3>

<p>Functions used internally.
</p>


<h3>Author(s)</h3>

<p>Kayvan Sadeghi, Giovanni M. Marchetti
</p>


<h3>See Also</h3>

<p><code>unique</code>,<code>setdiff</code>, <code>is.element</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
