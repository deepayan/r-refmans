<!DOCTYPE html><html lang="en"><head><title>Help for package hwep</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hwep}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hwep-package'><p>Hardy-Weinberg Equilibrium in Polyploids</p></a></li>
<li><a href='#all_multinom'><p>Get every possible non-negative tuple with of a given sum.</p></a></li>
<li><a href='#ddirmult'><p>PMF of Dirichlet-multinomial distribution</p></a></li>
<li><a href='#dgamete'><p>Gamete dosage probability</p></a></li>
<li><a href='#drbounds'><p>Upper bounds on rates of double reduction</p></a></li>
<li><a href='#f1dr'><p>Estimate Double Reduction in F1 Populations</p></a></li>
<li><a href='#freqnext'><p>Update genotype frequencies after one generation</p></a></li>
<li><a href='#gibbs_gl'><p>Gibbs sampler under random mating using genotype log-likelihoods.</p></a></li>
<li><a href='#gibbs_gl_alt'><p>Gibbs sampler under the alternative of non-random mating using genotype</p>
log-likelihoods.</a></li>
<li><a href='#gibbs_known'><p>Gibbs sampler under random mating with known genotypes.</p></a></li>
<li><a href='#gsegmat'><p>Segregation probabilities of gametes</p></a></li>
<li><a href='#gsegmat_symb'><p>Symbolic representation of the segregation probability matrix</p></a></li>
<li><a href='#hweboot'><p>Bootstrap procedure to test for equilibrium</p></a></li>
<li><a href='#hwefit'><p>Equilibrium and random mating estimation and testing for many loci.</p></a></li>
<li><a href='#hwefreq'><p>Generate HWE genotype frequencies</p></a></li>
<li><a href='#hwelike'><p>Maximum likelihood approach for equilibrium testing and double reduction</p>
estimation.</a></li>
<li><a href='#hwenodr'><p>Test for HWE in autopolyploids under the assumption of no double reduction</p></a></li>
<li><a href='#hweustat'><p>U-process minimizer approach to equilibrium testing and double reduction</p>
estimation</a></li>
<li><a href='#menbayesgl'><p>Bayes test for F1/S1 genotype frequencies using genotype likelihoods</p></a></li>
<li><a href='#p_from_alpha'><p>Obtain gamete frequencies at equilibrium given rates of double reduction.</p></a></li>
<li><a href='#qqpvalue'><p>QQ-plot for p-values</p></a></li>
<li><a href='#rmbayes'><p>Bayes test for random mating with known genotypes</p></a></li>
<li><a href='#rmbayesgl'><p>Bayes test for random mating using genotype log-likelihoods</p></a></li>
<li><a href='#rmlike'><p>Likelihood inference for random mating</p></a></li>
<li><a href='#simgl'><p>Simulator for genotype likelihoods.</p></a></li>
<li><a href='#ts_bands'><p>Get simultaneous confidence bands for a uniform QQ-plot</p></a></li>
<li><a href='#zsegarray'><p>Zygote segregation distributions.</p></a></li>
<li><a href='#zygdist'><p>Zygote dosage probabilities.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Hardy-Weinberg Equilibrium in Polyploids</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Inference concerning equilibrium and random mating in 
    autopolyploids. Methods are available to test for equilibrium 
    and random mating at any even ploidy level (&gt;2) in the presence
    of double reduction at biallelic loci. For autopolyploid populations
    in equilibrium, methods are available to estimate the degree of 
    double reduction. We also provide functions to calculate genotype 
    frequencies at equilibrium, or after one or several rounds of 
    random mating, given rates of double reduction. The main function is
    hwefit(). This material is based upon work supported by the
    National Science Foundation under Grant No. 2132247. The opinions,
    findings, and conclusions or recommendations expressed are those of
    the author and do not necessarily reflect the views of the National
    Science Foundation. For details of these methods, see 
    Gerard (2022a) &lt;<a href="https://doi.org/10.1111%2Fbiom.13722">doi:10.1111/biom.13722</a>&gt; and
    Gerard (2022b) &lt;<a href="https://doi.org/10.1101%2F2022.08.11.503635">doi:10.1101/2022.08.11.503635</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dcgerard/hwep/issues">https://github.com/dcgerard/hwep/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dcgerard.github.io/hwep/">https://dcgerard.github.io/hwep/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), covr, knitr, rmarkdown, ggplot2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>bridgesampling, doFuture, doRNG, foreach, future, iterators,
methods, pracma, Rcpp (&ge; 0.12.0), RcppParallel (&ge; 5.0.1),
rstan (&ge; 2.18.1), rstantools (&ge; 2.2.0), tensr, updog</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.18.1), StanHeaders (&ge;
2.18.0)</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-16 15:56:30 UTC; dgerard</td>
</tr>
<tr>
<td>Author:</td>
<td>David Gerard <a href="https://orcid.org/0000-0001-9450-5023"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  NSF DBI 2132247 [fnd]
    (https://www.nsf.gov/awardsearch/showAward?AWD_ID=2132247)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Gerard &lt;gerard.1787@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-16 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='hwep-package'>Hardy-Weinberg Equilibrium in Polyploids</h2><span id='topic+hwep-package'></span><span id='topic+hwep'></span>

<h3>Description</h3>

<p>Inference concerning equilibrium and random mating in autopolyploids.
Methods are available to test for equilibrium and random mating at
any even ploidy level (&gt;2) in the presence of double reduction. For
autopolyploid populations in equilibrium, methods are available to
estimate the degree of double reduction. We also provide functions
to calculate genotype frequencies at equilibrium, or after one or
several rounds of random mating, given rates of double reduction.
This material is based upon work supported by the
National Science Foundation under Grant No. 2132247. The opinions,
findings, and conclusions or recommendations expressed are those of
the author and do not necessarily reflect the views of the National
Science Foundation. For details of these methods, see
see Gerard (2022a) <a href="https://doi.org/10.1111/biom.13722">doi:10.1111/biom.13722</a> and
Gerard (2022b) <a href="https://doi.org/10.1101/2022.08.11.503635">doi:10.1101/2022.08.11.503635</a>.
</p>


<h3>Main Functions</h3>


<dl>
<dt><code><a href="#topic+hwefit">hwefit</a>()</code></dt><dd><p>Fit either <code><a href="#topic+hwelike">hwelike</a>()</code>,
<code><a href="#topic+rmlike">rmlike</a>()</code>, <code><a href="#topic+hweustat">hweustat</a>()</code>, or
<code><a href="#topic+hwenodr">hwenodr</a>()</code> across many loci.
Parallelization is supported through the future package.</p>
</dd>
<dt><code><a href="#topic+hwelike">hwelike</a>()</code></dt><dd><p>Likelihood inference for equilibrium.
This function estimates the rate of double reduction given
equilibrium, and tests for at most small deviations from
equilibrium.</p>
</dd>
<dt><code><a href="#topic+rmlike">rmlike</a>()</code></dt><dd><p>Likelihood inference for random
mating in polyploids. This function tests for random mating
and estimates gametic frequencies given random mating.
This function does not assume a model for meiosis.</p>
</dd>
<dt><code><a href="#topic+hweustat">hweustat</a>()</code></dt><dd><p>U-statistic approach for equilibrium
and double reduction. This function tests for equilibrium given
double reduction rates and estimates these rates given equilibrium.</p>
</dd>
<dt><code><a href="#topic+hwenodr">hwenodr</a>()</code></dt><dd><p>Implements a likelihood ratio test
that tests for equilibrium in autopolyploids given no double reduction.</p>
</dd>
<dt><code><a href="#topic+hweboot">hweboot</a>()</code></dt><dd><p>Implements a bootstrap approach to test
for equilibrium which is more appropriate for small samples and
uncertain genotypes.</p>
</dd>
</dl>



<h3>Other Functions</h3>


<dl>
<dt><code><a href="#topic+dgamete">dgamete</a>()</code></dt><dd><p>Gamete dosage probability given
parental dosage.</p>
</dd>
<dt><code><a href="#topic+drbounds">drbounds</a>()</code></dt><dd><p>Upper bounds on the rates of double
reduction given the complete equational segregation model.</p>
</dd>
<dt><code><a href="#topic+freqnext">freqnext</a>()</code></dt><dd><p>Update genotype frequencies after one
generation of random mating.</p>
</dd>
<dt><code><a href="#topic+gsegmat">gsegmat</a>()</code></dt><dd><p>Gamete dosage probabilities for all
possible parental dosages.</p>
</dd>
<dt><code><a href="#topic+hwefreq">hwefreq</a>()</code></dt><dd><p>Generate equilibrium
genotype frequencies.</p>
</dd>
<dt><code><a href="#topic+p_from_alpha">p_from_alpha</a>()</code></dt><dd><p>Obtain gamete frequencies from
the major allele frequency and double reduction rates.</p>
</dd>
<dt><code><a href="#topic+zsegarray">zsegarray</a>()</code></dt><dd><p>All zygote dosage distributions
given all possible parental dosages.</p>
</dd>
<dt><code><a href="#topic+zygdist">zygdist</a>()</code></dt><dd><p>Zygote dosage distribution given
one pair of parental dosages.</p>
</dd>
</dl>



<h3>Citation</h3>

<p>If you find the methods in this package useful, please run the following
in R for citation information: <code>citation("hwep")</code>
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>

<hr>
<h2 id='all_multinom'>Get every possible non-negative tuple with of a given sum.</h2><span id='topic+all_multinom'></span>

<h3>Description</h3>

<p>The total number of rows is <code>choose(n = k + n - 1, k = k - 1)</code>.
This function uses recursion, so is not the most efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_multinom(n, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_multinom_+3A_n">n</code></td>
<td>
<p>Number of indistinguishable balls.</p>
</td></tr>
<tr><td><code id="all_multinom_+3A_k">k</code></td>
<td>
<p>Number of distinguishable bins.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, rows index different possible multinomial counts,
the columns index the bins.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
k &lt;- 3
all_multinom(n = n, k = k)
choose(n = n + k - 1, k = k - 1)

</code></pre>

<hr>
<h2 id='ddirmult'>PMF of Dirichlet-multinomial distribution</h2><span id='topic+ddirmult'></span>

<h3>Description</h3>

<p>PMF of Dirichlet-multinomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirmult(x, alpha, lg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ddirmult_+3A_x">x</code></td>
<td>
<p>The vector of counts.</p>
</td></tr>
<tr><td><code id="ddirmult_+3A_alpha">alpha</code></td>
<td>
<p>The vector of concentration parameters.</p>
</td></tr>
<tr><td><code id="ddirmult_+3A_lg">lg</code></td>
<td>
<p>A logical. Should we log the density (<code>TRUE</code>) or not
(<code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ddirmult(c(1, 2, 3), c(1, 1, 1))
ddirmult(c(2, 2, 2), c(1, 1, 1))

</code></pre>

<hr>
<h2 id='dgamete'>Gamete dosage probability</h2><span id='topic+dgamete'></span>

<h3>Description</h3>

<p>Estimates the probability of a gamete dosage given the parent dosage
(<code>G</code>), the parent ploidy (<code>ploidy</code>), and the double reduction
parameter (<code>alpha</code>). This is for biallelic loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgamete(x, alpha, G, ploidy, log_p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgamete_+3A_x">x</code></td>
<td>
<p>A vector of numerics in <code>seq(0, ploidy/2)</code>. The dosage of the
gametes.</p>
</td></tr>
<tr><td><code id="dgamete_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector containing the double reduction parameter(s).
This should be a
vector of length <code>floor(ploidy/4)</code> where <code>alpha[i]</code>
is the probability of exactly <code>i</code> pairs of IBDR alleles
being in the gamete. Note that <code>sum(alpha)</code> should be less than
1, as <code>1 - sum(alpha)</code> is the probability of no double reduction.</p>
</td></tr>
<tr><td><code id="dgamete_+3A_g">G</code></td>
<td>
<p>The dosage of the parent. Should be an integer between <code>0</code>
and <code>ploidy</code>.</p>
</td></tr>
<tr><td><code id="dgamete_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species. This should be an even positive
integer.</p>
</td></tr>
<tr><td><code id="dgamete_+3A_log_p">log_p</code></td>
<td>
<p>A logical. Should we return the log-probability (<code>TRUE</code>)
or not (<code>FALSE</code>)? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>length(x)</code>, containing the (log)
probabilities of a gamete carrying a dosage of <code>x</code> from a
parent of dosage <code>G</code> who has ploidy <code>ploidy</code> and a
double reduction rate <code>alpha</code>.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dgamete(x = 0:2, alpha = 0, G = 2, ploidy = 4)

</code></pre>

<hr>
<h2 id='drbounds'>Upper bounds on rates of double reduction</h2><span id='topic+drbounds'></span>

<h3>Description</h3>

<p>Calculates the upper bounds of the double reduction parameters
according to the complete equation segregation model. See
Huang et. al. (2019) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drbounds(ploidy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drbounds_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species. Should be even and at least 4.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>floor(ploidy/4)</code>. Element <code>i</code> is
the upper bound on the probability of <code>i</code> pairs of
identical-by-double-reduction alleles being in an individual.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Huang, K., Wang, T., Dunn, D. W., Zhang, P., Cao, X., Liu, R., &amp; Li, B. (2019). Genotypic frequencies at equilibrium for polysomic inheritance under double-reduction. <em>G3: Genes, Genomes, Genetics</em>, 9(5), 1693-1706. <a href="https://doi.org/10.1534/g3.119.400132">doi:10.1534/g3.119.400132</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>drbounds(4)
drbounds(6)
drbounds(8)
drbounds(10)
drbounds(12)
drbounds(14)
drbounds(16)

</code></pre>

<hr>
<h2 id='f1dr'>Estimate Double Reduction in F1 Populations</h2><span id='topic+f1dr'></span>

<h3>Description</h3>

<p>Estimates double reduction in F1 populations by maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f1dr(nvec, G1, G2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f1dr_+3A_nvec">nvec</code></td>
<td>
<p>A vector containing the observed genotype counts,
where <code>nvec[[i]]</code> is the number of individuals with genotype
<code>i-1</code>. This should be of length <code>ploidy+1</code>.</p>
</td></tr>
<tr><td><code id="f1dr_+3A_g1">G1</code></td>
<td>
<p>The dosage of parent 1. Should be an integer between <code>0</code>
and <code>ploidy</code>.</p>
</td></tr>
<tr><td><code id="f1dr_+3A_g2">G2</code></td>
<td>
<p>The dosage of parent 2. Should be an integer between <code>0</code>
and <code>ploidy</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with some or all of the following elements:
</p>

<dl>
<dt><code>alpha</code></dt><dd><p>A vector of numerics of length
<code>floor(ploidy / 4)</code>, the estimated double reduction rate.</p>
</dd>
<dt><code>llike</code></dt><dd><p>The final log-likelihood.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zygdist">zygdist</a>()</code> for calculating the probability of
offpring genotypes given parental genotypes and the double reduction
rate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
size &lt;- 100
qvec &lt;- zygdist(alpha = 0.1, G1 = 2, G2 = 2, ploidy = 4)
nvec &lt;- c(stats::rmultinom(n = 1, size = size, prob = qvec))
f1dr(nvec = nvec, G1 = 2, G2 = 2)

</code></pre>

<hr>
<h2 id='freqnext'>Update genotype frequencies after one generation</h2><span id='topic+freqnext'></span>

<h3>Description</h3>

<p>After one generation of random mating, update the genotype
frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqnext(freq, alpha, segmat = NULL, more = FALSE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="freqnext_+3A_freq">freq</code></td>
<td>
<p>The current genotype frequencies. This should be a
vector of length K+1, where K is the ploidy of the species.
<code>freq[i]</code> could contain the proportion of individuals
that have genotype <code>i-1</code>.</p>
</td></tr>
<tr><td><code id="freqnext_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector containing the double reduction parameter(s).
This should be a
vector of length <code>floor(ploidy/4)</code> where <code>alpha[i]</code>
is the probability of exactly <code>i</code> pairs of IBDR alleles
being in the gamete. Note that <code>sum(alpha)</code> should be less than
1, as <code>1 - sum(alpha)</code> is the probability of no double reduction.</p>
</td></tr>
<tr><td><code id="freqnext_+3A_segmat">segmat</code></td>
<td>
<p>You can provide your own segregation matrix.
<code>segmat[i, j]</code> is the probability that a parent with
dosage <code>i-1</code> produces a gamete with dosage <code>j-1</code>.</p>
</td></tr>
<tr><td><code id="freqnext_+3A_more">more</code></td>
<td>
<p>A logical. Should we return more output (<code>TRUE</code>) or
less (<code>FALSE</code>). See the Value section for details.</p>
</td></tr>
<tr><td><code id="freqnext_+3A_check">check</code></td>
<td>
<p>Should we correct for minor numerical issues? Defaults
to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>more = FALSE</code>, then returns a vector of length
<code>length(freq)</code> that contains the updated genotype frequencies
after one generation of random mating. If <code>more = TRUE</code>, then
returns a list with these genotype frequencies (<code>q</code>) as well as the
parental gamete frequencies (<code>p</code>).
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freq &lt;- c(0.5, 0, 0, 0, 0.5)
freqnext(freq = freq, alpha = 0)

</code></pre>

<hr>
<h2 id='gibbs_gl'>Gibbs sampler under random mating using genotype log-likelihoods.</h2><span id='topic+gibbs_gl'></span>

<h3>Description</h3>

<p>Gibbs sampler under random mating using genotype log-likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gibbs_gl(
  gl,
  alpha,
  B = 10000L,
  T = 1000L,
  more = FALSE,
  lg = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gibbs_gl_+3A_gl">gl</code></td>
<td>
<p>The matrix of genotype log-likelihoods. The columns index the
dosages and the rows index the individuals. <code>gl[i,j]</code> is the
genotype log-likelihood for individual i at dosage j. It is assumed
that natural log is used.</p>
</td></tr>
<tr><td><code id="gibbs_gl_+3A_alpha">alpha</code></td>
<td>
<p>Vector of hyperparameters for the gamete frequencies.
Should be length (x.length() - 1) / 2 + 1.</p>
</td></tr>
<tr><td><code id="gibbs_gl_+3A_b">B</code></td>
<td>
<p>The number of sampling iterations.</p>
</td></tr>
<tr><td><code id="gibbs_gl_+3A_t">T</code></td>
<td>
<p>The number of burn-in iterations.</p>
</td></tr>
<tr><td><code id="gibbs_gl_+3A_more">more</code></td>
<td>
<p>A logical. Should we also return posterior draws (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="gibbs_gl_+3A_lg">lg</code></td>
<td>
<p>Should we return the log marginal likelihood (true) or not
(false).</p>
</td></tr>
<tr><td><code id="gibbs_gl_+3A_verbose">verbose</code></td>
<td>
<p>A logical. Should we print the progress?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with some or all of the following elements
</p>

<ul>
<li><p><code>mx</code>: The estimate of the marginal likelihood
</p>
</li>
<li><p><code>p_tilde</code>: The value of p used to evaluate the posterior density.
</p>
</li>
<li><p><code>p</code>: The samples of the gamete frequencies
</p>
</li>
<li><p><code>z</code>: The samples of the individual genotypes
</p>
</li>
<li><p><code>post</code>: The samples of the full conditionals of p_tilde.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
ploidy &lt;- 8

## Simulate under the null
p &lt;- stats::runif(ploidy / 2 + 1)
p &lt;- p / sum(p)
q &lt;- stats::convolve(p, rev(p), type = "open")
nvec &lt;- c(stats::rmultinom(n = 1, size = 100, prob = q))
gl &lt;- simgl(nvec)

gibbs_gl(gl = gl, alpha = rep(1, ploidy / 2 + 1), lg = TRUE)

</code></pre>

<hr>
<h2 id='gibbs_gl_alt'>Gibbs sampler under the alternative of non-random mating using genotype
log-likelihoods.</h2><span id='topic+gibbs_gl_alt'></span>

<h3>Description</h3>

<p>Gibbs sampler under the alternative of non-random mating using genotype
log-likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gibbs_gl_alt(
  gl,
  beta,
  B = 10000L,
  T = 1000L,
  more = FALSE,
  lg = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gibbs_gl_alt_+3A_gl">gl</code></td>
<td>
<p>The matrix of genotype log-likelihoods. The columns index the
dosages and the rows index the individuals. <code>gl[i,j]</code> is the
genotype log-likelihood for individual i at dosage j. It is assumed
that natural log is used.</p>
</td></tr>
<tr><td><code id="gibbs_gl_alt_+3A_beta">beta</code></td>
<td>
<p>The concentration hyperparameter for the genotype frequencies.</p>
</td></tr>
<tr><td><code id="gibbs_gl_alt_+3A_b">B</code></td>
<td>
<p>The number of sampling iterations.</p>
</td></tr>
<tr><td><code id="gibbs_gl_alt_+3A_t">T</code></td>
<td>
<p>The number of burn-in iterations.</p>
</td></tr>
<tr><td><code id="gibbs_gl_alt_+3A_more">more</code></td>
<td>
<p>A logical. Should we also return posterior draws (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="gibbs_gl_alt_+3A_lg">lg</code></td>
<td>
<p>Should we return the log marginal likelihood (true) or not
(false).</p>
</td></tr>
<tr><td><code id="gibbs_gl_alt_+3A_verbose">verbose</code></td>
<td>
<p>A logical. Should we print the progress?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with some or all of the following elements
</p>

<ul>
<li><p><code>mx</code>: The estimate of the marginal likelihood
</p>
</li></ul>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
ploidy &lt;- 8

## Simulate under the alternative
q &lt;- stats::runif(ploidy + 1)
q &lt;- q / sum(q)
nvec &lt;- c(stats::rmultinom(n = 1, size = 100, prob = q))
gl &lt;- simgl(nvec)

gibbs_gl_alt(gl = gl, beta = rep(1, ploidy + 1), lg = TRUE)

</code></pre>

<hr>
<h2 id='gibbs_known'>Gibbs sampler under random mating with known genotypes.</h2><span id='topic+gibbs_known'></span>

<h3>Description</h3>

<p>Gibbs sampler under random mating with known genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gibbs_known(x, alpha, B = 10000L, T = 1000L, more = FALSE, lg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gibbs_known_+3A_x">x</code></td>
<td>
<p>The vector of genotype counts. x(i) is the number of
individuals that have genotype i.</p>
</td></tr>
<tr><td><code id="gibbs_known_+3A_alpha">alpha</code></td>
<td>
<p>Vector of hyperparameters for the gamete frequencies.
Should be length (x.length() - 1) / 2 + 1.</p>
</td></tr>
<tr><td><code id="gibbs_known_+3A_b">B</code></td>
<td>
<p>The number of sampling iterations.</p>
</td></tr>
<tr><td><code id="gibbs_known_+3A_t">T</code></td>
<td>
<p>The number of burn-in iterations.</p>
</td></tr>
<tr><td><code id="gibbs_known_+3A_more">more</code></td>
<td>
<p>A logical. Should we also return posterior draws (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="gibbs_known_+3A_lg">lg</code></td>
<td>
<p>Should we return the log marginal likelihood (true) or not
(false).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with some or all of the following elements
</p>

<ul>
<li><p><code>mx</code>: The estimate of the marginal likelihood
</p>
</li>
<li><p><code>p_tilde</code>: The value of p used to evaluate the posterior density.
</p>
</li>
<li><p><code>p</code>: The samples of the gamete frequencies
</p>
</li>
<li><p><code>post</code>: The likelihood times prior evaluated at current samples.
</p>
</li>
<li><p><code>ptilde_post</code>: The samples of the full conditionals of p_tilde.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>David Gerard
</p>

<hr>
<h2 id='gsegmat'>Segregation probabilities of gametes</h2><span id='topic+gsegmat'></span>

<h3>Description</h3>

<p>Produces the segregation probabilities for gamete dosages given
parental dosages and the double reduction rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsegmat(alpha, ploidy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsegmat_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector containing the double reduction parameter(s).
This should be a
vector of length <code>floor(ploidy/4)</code> where <code>alpha[i]</code>
is the probability of exactly <code>i</code> pairs of IBDR alleles
being in the gamete. Note that <code>sum(alpha)</code> should be less than
1, as <code>1 - sum(alpha)</code> is the probability of no double reduction.</p>
</td></tr>
<tr><td><code id="gsegmat_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species. This should be an even positive
integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension <code>ploidy + 1</code> by <code>ploidy / 2 + 1</code>.
Element (i, j) is the probability that a parent carrying dosage
j - 1 produces a gamete with dosage i - 1.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gsegmat(alpha = NULL, ploidy = 2)

gsegmat(alpha = 1/6, ploidy = 4)

gsegmat(alpha = 0.3, ploidy = 6)

gsegmat(alpha = c(0.35, 0.02), ploidy = 8)

gsegmat(alpha = c(0.4, 0.05), ploidy = 10)

</code></pre>

<hr>
<h2 id='gsegmat_symb'>Symbolic representation of the segregation probability matrix</h2><span id='topic+gsegmat_symb'></span>

<h3>Description</h3>

<p>Two alleles are identical-by-double-reduction (IBDR) if they originate from
the same (by origin) allele in the parent. We let &quot;a&quot; be the probability of
zero IBDR alleles, &quot;b&quot; be the probability of one IBDR pair,
&quot;c&quot; be the probability of two IBDR pairs, etc...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsegmat_symb(ploidy, out = c("str", "exp"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsegmat_symb_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species</p>
</td></tr>
<tr><td><code id="gsegmat_symb_+3A_out">out</code></td>
<td>
<p>Should we return a character matrix
(<code>"str"</code>) or an expression matrix (<code>"exp"</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character or expression matrix containing the mathematical
form for the segregation matrix. Element (i, j) is the probability
a parent with dosage i-1 produces a gamete with dosage j-1.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsegmat">gsegmat</a>()</code> for numerical expressions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gsegmat_symb(4)
gsegmat_symb(6)
gsegmat_symb(8)
</code></pre>

<hr>
<h2 id='hweboot'>Bootstrap procedure to test for equilibrium</h2><span id='topic+hweboot'></span>

<h3>Description</h3>

<p>Iteratively resample individuals/genotypes, calculating the U-statistic
for each resample, and use these resamples to test against the null
of no equilibrium.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hweboot(n, nboot = 2000, more = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hweboot_+3A_n">n</code></td>
<td>
<p>One of two forms
</p>

<dl>
<dt>A vector of length ploidy + 1</dt><dd><p>Element i is the number of
individuals with genotype i.</p>
</dd>
<dt>A matrix with nsamp rows and ploidy+1 columns</dt><dd><p>Element (i, j)
is the posterior probability that individual i has ploidy j-1.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="hweboot_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap samples to run.</p>
</td></tr>
<tr><td><code id="hweboot_+3A_more">more</code></td>
<td>
<p>A logical. Should we return the bootstrap replicates
(<code>FALSE</code>) or just the p-value, with 95% confidence interval
of the p-value (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with some or all of the following elements
</p>

<dl>
<dt><code>p_hwe</code></dt><dd><p>The bootstrap p-value against the null of equilibrium.</p>
</dd>
<dt><code>p_ci</code></dt><dd><p>The 95% confidence interval of p_hwe.</p>
</dd>
<dt><code>alpha_boot</code></dt><dd><p>The bootstrap samples of the double reduction
parameter.</p>
</dd>
<dt><code>u_boot</code></dt><dd><p>The bootstrap samples of the U-statistic.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
ploidy &lt;- 6
size &lt;- 100
r &lt;- 0.5
alpha &lt;- 0.1
qvec &lt;- hwefreq(r = r, alpha = alpha, ploidy = ploidy)
nvec &lt;- c(rmultinom(n = 1, size = size, prob = qvec))
bout &lt;- hweboot(n = nvec, more = TRUE, nboot = 1000)
bout$p_hwe
bout$p_ci
hist(bout$test_boot)
abline(v = bout$test_stat, lty = 2, col = 2)

</code></pre>

<hr>
<h2 id='hwefit'>Equilibrium and random mating estimation and testing for many loci.</h2><span id='topic+hwefit'></span>

<h3>Description</h3>

<p>Estimates and tests for either equilibrium or random mating  across many loci
using <code><a href="#topic+hwelike">hwelike</a>()</code>, <code><a href="#topic+hweustat">hweustat</a>()</code>,
<code><a href="#topic+rmlike">rmlike</a>()</code>, <code><a href="#topic+hwenodr">hwenodr</a>()</code>, or <code><a href="#topic+hweboot">hweboot</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwefit(
  nmat,
  type = c("ustat", "mle", "rm", "nodr", "boot"),
  effdf = TRUE,
  thresh = 3,
  nboot = 2000,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hwefit_+3A_nmat">nmat</code></td>
<td>
<p>A matrix of counts. The rows index the loci and the columns
index the genotypes. So <code>nmat[i, j]</code> is the number of individuals
that have genotype <code>j-1</code> at locus <code>i</code>. The ploidy is
assumed to be <code>ncol(nmat)-1</code>.</p>
</td></tr>
<tr><td><code id="hwefit_+3A_type">type</code></td>
<td>
<p>The method to use:
</p>

<dl>
<dt><code>"ustat"</code></dt><dd><p>U-statistic approach to test for equilibrium and
estimate double reduction rates given equilibrium. The default.
See <code><a href="#topic+hweustat">hweustat</a>()</code>.</p>
</dd>
<dt><code>"mle"</code></dt><dd><p>Maximum likelihood estimation and testing. Only
supported for ploidies less than or equal to 10.
See <code><a href="#topic+hwelike">hwelike</a>()</code>.</p>
</dd>
<dt><code>"rm"</code></dt><dd><p>Testing random mating, and estimating gamete
frequencies given random mating. See <code><a href="#topic+rmlike">rmlike</a>()</code>.</p>
</dd>
<dt><code>"nodr"</code></dt><dd><p>Testing equilibrium given no double reduction.
See <code><a href="#topic+hwenodr">hwenodr</a>()</code>.</p>
</dd>
<dt><code>"boot"</code></dt><dd><p>Bootstrap approach to test for equilibrium.
See <code><a href="#topic+hweboot">hweboot</a>()</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="hwefit_+3A_effdf">effdf</code></td>
<td>
<p>A logical. Should we use the effective degrees of freedom?
Only applicable if <code>type = "mle"</code> or <code>type = "ustat"</code>.</p>
</td></tr>
<tr><td><code id="hwefit_+3A_thresh">thresh</code></td>
<td>
<p>A non-negative numeric. The threshold for aggregating
genotypes. Only applicable if <code>type = "mle"</code>,
<code>type = "ustat"</code>, or <code>type = "rm"</code>.</p>
</td></tr>
<tr><td><code id="hwefit_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap iterations to use if
<code>type = "boot"</code>.</p>
</td></tr>
<tr><td><code id="hwefit_+3A_verbose">verbose</code></td>
<td>
<p>Should we print more (<code>TRUE</code>) or less (<code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We provide parallelization support through the <a href="future.html#topic+future">future</a>
package.
</p>


<h3>Value</h3>

<p>A data frame. The columns of which can are described in
<code><a href="#topic+hwelike">hwelike</a>()</code>, <code><a href="#topic+hweustat">hweustat</a>()</code>,
<code><a href="#topic+rmlike">rmlike</a>()</code>, or <code><a href="#topic+hwenodr">hwenodr</a>()</code>.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate random data
set.seed(5)
ploidy &lt;- 4
nloc &lt;- 100
size &lt;- 1000
r &lt;- 0.25
alpha &lt;- 1/12
qvec &lt;- hwefreq(r = r, alpha = alpha, ploidy = ploidy)
nmat &lt;- t(rmultinom(n = nloc, size = size, prob = qvec))

## Run the analysis in parallel on the local computer with two workers
future::plan(future::multisession, workers = 2)
hout &lt;- hwefit(nmat = nmat, type = "ustat")

## Shut down parallel workers
future::plan("sequential")

## Show that p-values are uniform

## QQ-plot on -log10 scale
qqpvalue(pvals = hout$p_hwe, method = "base")

## Kolmogorov-Smirnov Test
stats::ks.test(hout$p_hwe, "qunif")

## Can control for Type I error
mean(hout$p_hwe &lt; 0.05)

## Consistent estimate for alpha
alpha
mean(hout$alpha1)

</code></pre>

<hr>
<h2 id='hwefreq'>Generate HWE genotype frequencies</h2><span id='topic+hwefreq'></span>

<h3>Description</h3>

<p>Generate genotype frequencies under Hardy-Weinberg equilibrium
given the allele frequency of the reference allele (<code>r</code>),
the double reduction parameter (<code>alpha</code>), and the ploidy
of the species (<code>ploidy</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwefreq(
  r,
  alpha,
  ploidy,
  niter = 100,
  tol = sqrt(.Machine$double.eps),
  more = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hwefreq_+3A_r">r</code></td>
<td>
<p>The allele frequency of the reference allele.</p>
</td></tr>
<tr><td><code id="hwefreq_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector containing the double reduction parameter(s).
This should be a
vector of length <code>floor(ploidy/4)</code> where <code>alpha[i]</code>
is the probability of exactly <code>i</code> pairs of IBDR alleles
being in the gamete. Note that <code>sum(alpha)</code> should be less than
1, as <code>1 - sum(alpha)</code> is the probability of no double reduction.</p>
</td></tr>
<tr><td><code id="hwefreq_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species. This should be an even positive
integer.</p>
</td></tr>
<tr><td><code id="hwefreq_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations to simulate.</p>
</td></tr>
<tr><td><code id="hwefreq_+3A_tol">tol</code></td>
<td>
<p>The stopping criterion on the Chi-square divergence between
old and new genotype frequencies.</p>
</td></tr>
<tr><td><code id="hwefreq_+3A_more">more</code></td>
<td>
<p>A logical. Should we return more output (<code>TRUE</code>) or
less (<code>FALSE</code>). See the Value section for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>alpha</code> is not all 0, then this function repeatedly
applies <code><a href="#topic+freqnext">freqnext</a>()</code> to simulate genotype frequencies
under HWE. Otherwise, it uses <code><a href="stats.html#topic+dbinom">dbinom</a>()</code>.
</p>


<h3>Value</h3>

<p>If <code>more = FALSE</code>, then returns just the genotype frequencies
after <code>niter</code> generations of random mating. If <code>more = TRUE</code>,
then returns a list with these genotype frequencies, as well as
the parental gamete frequencies.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freq1 &lt;- hwefreq(r = 0.5, alpha = 0, ploidy = 4)
freq2 &lt;- hwefreq(r = 0.5, alpha = 1/6, ploidy = 4)

plot(x = 0:4,
     y = freq1,
     type = "h",
     ylim = c(0, 0.4),
     xlab = "dosage",
     ylab = "Pr(dosage)")
plot(x = 0:4,
     y = freq2,
     type = "h",
     ylim = c(0, 0.4),
     xlab = "dosage",
     ylab = "Pr(dosage)")

</code></pre>

<hr>
<h2 id='hwelike'>Maximum likelihood approach for equilibrium testing and double reduction
estimation.</h2><span id='topic+hwelike'></span>

<h3>Description</h3>

<p>Genotype frequencies from Huang et al (2019) are used to implement a
likelihood procedure to estimate double reduction rates and to test
for equilibrium while accounting for double reduction. This approach
is only implemented for ploidies 4, 6, 8, and 10.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwelike(nvec, thresh = 5, effdf = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hwelike_+3A_nvec">nvec</code></td>
<td>
<p>A vector containing the observed genotype counts,
where <code>nvec[[i]]</code> is the number of individuals with genotype
<code>i-1</code>. This should be of length <code>ploidy+1</code>.</p>
</td></tr>
<tr><td><code id="hwelike_+3A_thresh">thresh</code></td>
<td>
<p>The threshold for ignoring the genotype. We keep
genotypes such that <code>nvec &gt;= thresh</code>.
Setting this to <code>0</code> uses all genotypes.</p>
</td></tr>
<tr><td><code id="hwelike_+3A_effdf">effdf</code></td>
<td>
<p>A logical. Should we use the ad-hoc
&quot;effective degrees of freedom&quot; (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with some or all of the following elements:
</p>

<dl>
<dt><code>alpha</code></dt><dd><p>The estimated double reduction parameter(s).
In diploids, this value is <code>NULL</code>.</p>
</dd>
<dt><code>r</code></dt><dd><p>The estimated allele frequency.</p>
</dd>
<dt><code>chisq_hwe</code></dt><dd><p>The chi-square test statistic for testing
against the null of equilibrium.</p>
</dd>
<dt><code>df_hwe</code></dt><dd><p>The degrees of freedom associated with
<code>chisq_hwe</code>.</p>
</dd>
<dt><code>p_hwe</code></dt><dd><p>The p-value against the null of equilibrium.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Huang, K., Wang, T., Dunn, D. W., Zhang, P., Cao, X., Liu, R., &amp; Li, B. (2019). Genotypic frequencies at equilibrium for polysomic inheritance under double-reduction. G3: Genes, Genomes, Genetics, 9(5), 1693-1706. <a href="https://doi.org/10.1534/g3.119.400132">doi:10.1534/g3.119.400132</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>thout &lt;- hwefreq(alpha = 0.1, r = 0.3, ploidy = 6)
nvec &lt;- c(stats::rmultinom(n = 1, size = 100, prob = thout))
hwelike(nvec = nvec)

</code></pre>

<hr>
<h2 id='hwenodr'>Test for HWE in autopolyploids under the assumption of no double reduction</h2><span id='topic+hwenodr'></span>

<h3>Description</h3>

<p>We run a likelihood ratio test against the null of no HWE, assuming that
there is no double reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwenodr(nvec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hwenodr_+3A_nvec">nvec</code></td>
<td>
<p>A vector containing the observed genotype counts,
where <code>nvec[[i]]</code> is the number of individuals with genotype
<code>i-1</code>. This should be of length <code>ploidy+1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with some or all of the following elements
</p>

<dl>
<dt><code>r</code></dt><dd><p>The estimated allele frequency.</p>
</dd>
<dt><code>chisq_hwe</code></dt><dd><p>The chi-square statistic against the null of
equilibrium given no double reduction.</p>
</dd>
<dt><code>df_hwe</code></dt><dd><p>The degrees of freedom associated with
<code>chisq_hwe</code>.</p>
</dd>
<dt><code>p_hwe</code></dt><dd><p>The p-value against the null of
equilibrium given no double reduction.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
qvec &lt;- c(0.2, 0.3, 0.4, 0.1)
nvec &lt;- c(stats::rmultinom(n = 1, size = 100, prob = qvec))
hwenodr(nvec = nvec)

</code></pre>

<hr>
<h2 id='hweustat'>U-process minimizer approach to equilibrium testing and double reduction
estimation</h2><span id='topic+hweustat'></span>

<h3>Description</h3>

<p>Estimates double reduction and tests for equilibrium while accounting
for double reduction. It does this using an approach called
&quot;U-process minimization&quot;, where we minimize a function of a U-statistic
that should be 0 at equilibrium given the true double reduction rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hweustat(nvec, thresh = NULL, effdf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hweustat_+3A_nvec">nvec</code></td>
<td>
<p>A vector containing the observed genotype counts,
where <code>nvec[[i]]</code> is the number of individuals with genotype
<code>i-1</code>. This should be of length <code>ploidy+1</code>.</p>
</td></tr>
<tr><td><code id="hweustat_+3A_thresh">thresh</code></td>
<td>
<p>The threshold for ignoring the genotype. We keep
genotypes such that <code>nvec &gt;= thresh</code>.
Setting this to <code>0</code> uses all genotypes. Setting this to
<code>NULL</code> uses a heuristic that works well in practice.</p>
</td></tr>
<tr><td><code id="hweustat_+3A_effdf">effdf</code></td>
<td>
<p>A logical. Should we use the ad-hoc
&quot;effective degrees of freedom&quot; (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a two-step estimator, where we first obtain a consistent
estimate of the double reduction parameter, use this to
estimate the covariance of estimators, then use this to obtain
our final estimate of the double reduction parameter.
</p>


<h3>Value</h3>

<p>A list with some or all of the following elements:
</p>

<dl>
<dt><code>alpha</code></dt><dd><p>The estimated double reduction parameter(s).
In diploids, this value is <code>NULL</code>.</p>
</dd>
<dt><code>chisq_hwe</code></dt><dd><p>The chi-square test statistic for testing
against the null of equilibrium.</p>
</dd>
<dt><code>df_hwe</code></dt><dd><p>The degrees of freedom associated with
<code>chisq_hwe</code>.</p>
</dd>
<dt><code>p_hwe</code></dt><dd><p>The p-value against the null of equilibrium.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
ploidy &lt;- 6
size &lt;- 1000
r &lt;- 0.1
alpha &lt;- 0.1
qvec &lt;- hwefreq(r = r, alpha = alpha, ploidy = ploidy)
nvec &lt;- c(rmultinom(n = 1, size = size, prob = qvec))
hweustat(nvec = nvec)

</code></pre>

<hr>
<h2 id='menbayesgl'>Bayes test for F1/S1 genotype frequencies using genotype likelihoods</h2><span id='topic+menbayesgl'></span>

<h3>Description</h3>

<p>Uses <code><a href="updog.html#topic+get_q_array">get_q_array</a>()</code> from the updog R package to
calculate segregation probabilities (assuming no double reduction) and
tests that offspring genotypes follow this distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menbayesgl(
  gl,
  method = c("f1", "s1"),
  p1gl = NULL,
  p2gl = NULL,
  lg = TRUE,
  beta = NULL,
  chains = 2,
  cores = 1,
  iter = 2000,
  warmup = floor(iter/2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="menbayesgl_+3A_gl">gl</code></td>
<td>
<p>A matrix of genotype log-likelihoods. The rows index the
individuals and the columns index the genotypes. So <code>gl[i,k]</code>
is the genotype log-likelihood for individual <code>i</code> at
dosage <code>k-1</code>. We assume the <em>natural</em> log is used (base e).</p>
</td></tr>
<tr><td><code id="menbayesgl_+3A_method">method</code></td>
<td>
<p>Should we test for F1 proportions (<code>"f1"</code>) or
S1 proportions (<code>"s1"</code>)?</p>
</td></tr>
<tr><td><code id="menbayesgl_+3A_p1gl">p1gl</code></td>
<td>
<p>A vector of genotype log-likelihoods for parent 1.
<code>p1gl[k]</code> is the log-likelihood of parent 1's data given
their genotype is <code>k</code>.</p>
</td></tr>
<tr><td><code id="menbayesgl_+3A_p2gl">p2gl</code></td>
<td>
<p>A vector of genotype log-likelihoods for parent 2.
<code>p2gl[k]</code> is the log-likelihood of parent 2's data given
their genotype is <code>k</code>.</p>
</td></tr>
<tr><td><code id="menbayesgl_+3A_lg">lg</code></td>
<td>
<p>A logical. Should we return the log Bayes factor (<code>TRUE</code>)
or the Bayes factor (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="menbayesgl_+3A_beta">beta</code></td>
<td>
<p>The concentration hyperparameters of the genotype frequencies
under the alternative of no random mating. Should be length ploidy + 1.</p>
</td></tr>
<tr><td><code id="menbayesgl_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains. Almost always 1 is enough, but we
use 2 as a default to be conservative.</p>
</td></tr>
<tr><td><code id="menbayesgl_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use.</p>
</td></tr>
<tr><td><code id="menbayesgl_+3A_iter">iter</code></td>
<td>
<p>Total number of iterations.</p>
</td></tr>
<tr><td><code id="menbayesgl_+3A_warmup">warmup</code></td>
<td>
<p>Number of those iterations used in the burnin.</p>
</td></tr>
<tr><td><code id="menbayesgl_+3A_...">...</code></td>
<td>
<p>Control arguments passed to <code><a href="rstan.html#topic+sampling">sampling</a>()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard D (2022). &quot;Bayesian tests for random mating in autopolyploids.&quot; <em>bioRxiv</em>. <a href="https://doi.org/10.1101/2022.08.11.503635">doi:10.1101/2022.08.11.503635</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1)
ploidy &lt;- 4

## Simulate under the null ----
q &lt;- updog::get_q_array(ploidy = 4)[3, 3, ]

## See BF increases
nvec &lt;- c(stats::rmultinom(n = 1, size = 10, prob = q))
gl &lt;- simgl(nvec = nvec)
menbayesgl(gl = gl, method = "f1")

nvec &lt;- c(stats::rmultinom(n = 1, size = 100, prob = q))
gl &lt;- simgl(nvec = nvec)
menbayesgl(gl = gl, method = "f1")

nvec &lt;- c(stats::rmultinom(n = 1, size = 1000, prob = q))
gl &lt;- simgl(nvec = nvec)
menbayesgl(gl = gl, method = "f1")

## Simulate under the alternative ----
q &lt;- stats::runif(ploidy + 1)
q &lt;- q / sum(q)

## See BF decreases
nvec &lt;- c(stats::rmultinom(n = 1, size = 10, prob = q))
gl &lt;- simgl(nvec = nvec)
menbayesgl(gl = gl, method = "f1")

nvec &lt;- c(stats::rmultinom(n = 1, size = 100, prob = q))
gl &lt;- simgl(nvec = nvec)
menbayesgl(gl = gl, method = "f1")

nvec &lt;- c(stats::rmultinom(n = 1, size = 1000, prob = q))
gl &lt;- simgl(nvec = nvec)
menbayesgl(gl = gl, method = "f1")


## End(Not run)

</code></pre>

<hr>
<h2 id='p_from_alpha'>Obtain gamete frequencies at equilibrium given rates of double reduction.</h2><span id='topic+p_from_alpha'></span>

<h3>Description</h3>

<p>Given the rate of double reduction and the major allele frequency, this
function will calculate the gametic frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_from_alpha(alpha, p, ploidy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_from_alpha_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector containing the double reduction parameter(s).
This should be a
vector of length <code>floor(ploidy/4)</code> where <code>alpha[i]</code>
is the probability of exactly <code>i</code> pairs of IBDR alleles
being in the gamete. Note that <code>sum(alpha)</code> should be less than
1, as <code>1 - sum(alpha)</code> is the probability of no double reduction.</p>
</td></tr>
<tr><td><code id="p_from_alpha_+3A_p">p</code></td>
<td>
<p>The allele frequency of the major allele.</p>
</td></tr>
<tr><td><code id="p_from_alpha_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code>ploidy / 2 + 1</code>, where element
<code>i</code> is the probability that a gamete carries <code>i-1</code> copies of
the major allele.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p_from_alpha(0.2, 0.5, 4)

</code></pre>

<hr>
<h2 id='qqpvalue'>QQ-plot for p-values</h2><span id='topic+qqpvalue'></span>

<h3>Description</h3>

<p>This will create a QQ-plot for p-values, comparing them to a uniform
distribution. We make our plot on the -log10 scale. We calculate
simultaneous confidence bands by the Tail Sensitive approach of
Aldor-Noiman et al (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqpvalue(
  pvals,
  method = c("ggplot2", "base"),
  band_type = c("ts", "pointwise"),
  conf_level = 0.95,
  return_plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqpvalue_+3A_pvals">pvals</code></td>
<td>
<p>A vector of p-values.</p>
</td></tr>
<tr><td><code id="qqpvalue_+3A_method">method</code></td>
<td>
<p>Should we use base plotting or ggplot2 (if installed)?</p>
</td></tr>
<tr><td><code id="qqpvalue_+3A_band_type">band_type</code></td>
<td>
<p>Should we use the method of Aldor-Noiman et al (2013) or
pointwise based on beta? Pointwise is not recommended since there is
strong dependence between order statistics, and if one is beyond
the pointwise bands, then likely lots are also beyond them.</p>
</td></tr>
<tr><td><code id="qqpvalue_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level for the bands.</p>
</td></tr>
<tr><td><code id="qqpvalue_+3A_return_plot">return_plot</code></td>
<td>
<p>Should we return the plot? Only applicable if
<code>method == "ggplot2"</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Aldor-Noiman, S., Brown, L. D., Buja, A., Rolke, W., &amp; Stine, R. A. (2013). The power to see: A new graphical test of normality. The American Statistician, 67(4), 249-260.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p>The <code>qqPlot()</code> function from the car package.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
pvals &lt;- runif(100)
qqpvalue(pvals, band_type = "ts", method = "base")

## Not run: 
qqpvalue(pvals, band_type = "ts", method = "ggplot2")

## End(Not run)

</code></pre>

<hr>
<h2 id='rmbayes'>Bayes test for random mating with known genotypes</h2><span id='topic+rmbayes'></span>

<h3>Description</h3>

<p>Bayes test for random mating with known genotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmbayes(
  nvec,
  lg = TRUE,
  alpha = NULL,
  beta = NULL,
  nburn = 10000,
  niter = 10000,
  type = c("auto", "allo")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmbayes_+3A_nvec">nvec</code></td>
<td>
<p>A vector containing the observed genotype counts,
where <code>nvec[[i]]</code> is the number of individuals with genotype
<code>i-1</code>. This should be of length <code>ploidy+1</code>.</p>
</td></tr>
<tr><td><code id="rmbayes_+3A_lg">lg</code></td>
<td>
<p>A logical. Should we return the log Bayes factor (<code>TRUE</code>)
or the Bayes factor (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="rmbayes_+3A_alpha">alpha</code></td>
<td>
<p>The concentration hyperparameters of the gamete frequencies
under the null of random mating. Should be length ploidy/2 + 1.</p>
</td></tr>
<tr><td><code id="rmbayes_+3A_beta">beta</code></td>
<td>
<p>The concentration hyperparameters of the genotype frequencies
under the alternative of no random mating. Should be length ploidy + 1.</p>
</td></tr>
<tr><td><code id="rmbayes_+3A_nburn">nburn</code></td>
<td>
<p>The number of iterations in the Gibbs sampler to burn-in.</p>
</td></tr>
<tr><td><code id="rmbayes_+3A_niter">niter</code></td>
<td>
<p>The number of sampling iterations in the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="rmbayes_+3A_type">type</code></td>
<td>
<p>If <code>alpha</code> is <code>NULL</code>, then the default priors depend
on if you have autopolyploids (<code>"auto"</code>) or allopolyploids
(<code>"allo"</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard D (2022). &quot;Bayesian tests for random mating in autopolyploids.&quot; <em>bioRxiv</em>. <a href="https://doi.org/10.1101/2022.08.11.503635">doi:10.1101/2022.08.11.503635</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
ploidy &lt;- 8

## Simulate under the null
p &lt;- stats::runif(ploidy / 2 + 1)
p &lt;- p / sum(p)
q &lt;- stats::convolve(p, rev(p), type = "open")

## See BF increase
nvec &lt;- c(stats::rmultinom(n = 1, size = 100, prob = q))
rmbayes(nvec = nvec)

nvec &lt;- c(stats::rmultinom(n = 1, size = 1000, prob = q))
rmbayes(nvec = nvec)

nvec &lt;- c(stats::rmultinom(n = 1, size = 10000, prob = q))
rmbayes(nvec = nvec)

## Simulate under the alternative
q &lt;- stats::runif(ploidy + 1)
q &lt;- q / sum(q)

## See BF decrease
nvec &lt;- c(stats::rmultinom(n = 1, size = 100, prob = q))
rmbayes(nvec = nvec)

nvec &lt;- c(stats::rmultinom(n = 1, size = 1000, prob = q))
rmbayes(nvec = nvec)

nvec &lt;- c(stats::rmultinom(n = 1, size = 10000, prob = q))
rmbayes(nvec = nvec)

</code></pre>

<hr>
<h2 id='rmbayesgl'>Bayes test for random mating using genotype log-likelihoods</h2><span id='topic+rmbayesgl'></span>

<h3>Description</h3>

<p>Bayes test for random mating using genotype log-likelihoods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmbayesgl(
  gl,
  method = c("stan", "gibbs"),
  lg = TRUE,
  alpha = NULL,
  beta = NULL,
  type = c("auto", "allo"),
  chains = 2,
  cores = 1,
  iter = 2000,
  warmup = floor(iter/2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmbayesgl_+3A_gl">gl</code></td>
<td>
<p>A matrix of genotype log-likelihoods. The rows index the
individuals and the columns index the genotypes. So <code>gl[i,k]</code>
is the genotype log-likelihood for individual <code>i</code> at
dosage <code>k-1</code>. We assume the <em>natural</em> log is used (base e).</p>
</td></tr>
<tr><td><code id="rmbayesgl_+3A_method">method</code></td>
<td>
<p>Should we use Stan (<code>"stan"</code>) or Gibbs sampling
(<code>"gibbs"</code>)?</p>
</td></tr>
<tr><td><code id="rmbayesgl_+3A_lg">lg</code></td>
<td>
<p>A logical. Should we return the log Bayes factor (<code>TRUE</code>)
or the Bayes factor (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="rmbayesgl_+3A_alpha">alpha</code></td>
<td>
<p>The concentration hyperparameters of the gamete frequencies
under the null of random mating. Should be length ploidy/2 + 1.</p>
</td></tr>
<tr><td><code id="rmbayesgl_+3A_beta">beta</code></td>
<td>
<p>The concentration hyperparameters of the genotype frequencies
under the alternative of no random mating. Should be length ploidy + 1.</p>
</td></tr>
<tr><td><code id="rmbayesgl_+3A_type">type</code></td>
<td>
<p>If <code>alpha</code> is <code>NULL</code>, then the default priors depend
on if you have autopolyploids (<code>"auto"</code>) or allopolyploids
(<code>"allo"</code>).</p>
</td></tr>
<tr><td><code id="rmbayesgl_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains. Almost always 1 is enough, but we
use 2 as a default to be conservative.</p>
</td></tr>
<tr><td><code id="rmbayesgl_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use.</p>
</td></tr>
<tr><td><code id="rmbayesgl_+3A_iter">iter</code></td>
<td>
<p>Total number of iterations.</p>
</td></tr>
<tr><td><code id="rmbayesgl_+3A_warmup">warmup</code></td>
<td>
<p>Number of those iterations used in the burnin.</p>
</td></tr>
<tr><td><code id="rmbayesgl_+3A_...">...</code></td>
<td>
<p>Control arguments passed to <code><a href="rstan.html#topic+sampling">sampling</a>()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard D (2022). &quot;Bayesian tests for random mating in autopolyploids.&quot; <em>bioRxiv</em>. <a href="https://doi.org/10.1101/2022.08.11.503635">doi:10.1101/2022.08.11.503635</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set.seed(1)
ploidy &lt;- 4

## Simulate under the null ----
p &lt;- stats::runif(ploidy / 2 + 1)
p &lt;- p / sum(p)
q &lt;- stats::convolve(p, rev(p), type = "open")

## See BF increases
nvec &lt;- c(stats::rmultinom(n = 1, size = 10, prob = q))
gl &lt;- simgl(nvec = nvec)
rmbayesgl(gl = gl)
rmbayesgl(gl = gl, method = "gibbs")

nvec &lt;- c(stats::rmultinom(n = 1, size = 100, prob = q))
gl &lt;- simgl(nvec = nvec)
rmbayesgl(gl = gl)
rmbayesgl(gl = gl, method = "gibbs")

nvec &lt;- c(stats::rmultinom(n = 1, size = 1000, prob = q))
gl &lt;- simgl(nvec = nvec)
rmbayesgl(gl = gl)
rmbayesgl(gl = gl, method = "gibbs")

## Simulate under the alternative ----
q &lt;- stats::runif(ploidy + 1)
q &lt;- q / sum(q)

## See BF decreases
nvec &lt;- c(stats::rmultinom(n = 1, size = 10, prob = q))
gl &lt;- simgl(nvec = nvec)
rmbayesgl(gl = gl)
rmbayesgl(gl = gl, method = "gibbs")

nvec &lt;- c(stats::rmultinom(n = 1, size = 100, prob = q))
gl &lt;- simgl(nvec = nvec)
rmbayesgl(gl = gl)
rmbayesgl(gl = gl, method = "gibbs")

nvec &lt;- c(stats::rmultinom(n = 1, size = 1000, prob = q))
gl &lt;- simgl(nvec = nvec)
rmbayesgl(gl = gl)
rmbayesgl(gl = gl, method = "gibbs")


## End(Not run)

</code></pre>

<hr>
<h2 id='rmlike'>Likelihood inference for random mating</h2><span id='topic+rmlike'></span>

<h3>Description</h3>

<p>Estimates gamete genotype frequencies using a maximum likelihood approach
and runs a likelihood ratio test for random mating.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmlike(nvec, thresh = 1, nstarts = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmlike_+3A_nvec">nvec</code></td>
<td>
<p>A vector containing the observed genotype counts,
where <code>nvec[[i]]</code> is the number of individuals with genotype
<code>i-1</code>. This should be of length <code>ploidy+1</code>.</p>
</td></tr>
<tr><td><code id="rmlike_+3A_thresh">thresh</code></td>
<td>
<p>All groups with counts less than <code>nvec</code> will
be aggregated together.</p>
</td></tr>
<tr><td><code id="rmlike_+3A_nstarts">nstarts</code></td>
<td>
<p>The number of random restarts to the EM algorithm. Set this
to 0 for only one run.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code>q</code> be the genotype frequencies. Let <code>p</code> be the gamete
frequencies. Then random mating occurs if
<code>q == stats::convolve(p, rev(p), type = "open")</code>. We test for
this hypothesis using likelihood inference, while estimating <code>p</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<dl>
<dt><code>p</code></dt><dd><p>The estimated gamete genotype frequencies. <code>p[[i]]</code>
is the estimated frequency for gamete genotype <code>i-1</code>.</p>
</dd>
<dt><code>chisq_rm</code></dt><dd><p>The likelihood ratio test statistic for testing
against the null of random mating.</p>
</dd>
<dt><code>df_rm</code></dt><dd><p>The degrees of freedom associated with
<code>chisq_rm</code>.</p>
</dd>
<dt><code>p_rm</code></dt><dd><p>The p-value against the null of random mating.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Randomly generate gamete frequencies
set.seed(1)
ploidy &lt;- 10
pvec &lt;- stats::runif(ploidy / 2 + 1)
pvec &lt;- pvec / sum(pvec)

## Genotype frequencies from gamete frequencies under random mating
qvec &lt;- stats::convolve(pvec, rev(pvec), type = "open")

## Generate data
nvec &lt;- c(stats::rmultinom(n = 1, size = 100, prob = qvec))

## Run rmlike()
rmlike(nvec = nvec)

</code></pre>

<hr>
<h2 id='simgl'>Simulator for genotype likelihoods.</h2><span id='topic+simgl'></span>

<h3>Description</h3>

<p>Uses the updog R package for simulating read counts and generating
genotype log-likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simgl(
  nvec,
  rdepth = 10,
  od = 0.01,
  bias = 1,
  seq = 0.01,
  ret = c("gl", "gp", "all"),
  est = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simgl_+3A_nvec">nvec</code></td>
<td>
<p>The genotype counts. <code>nvec[k]</code> contains the number of
individuals with genotype <code>k-1</code>.</p>
</td></tr>
<tr><td><code id="simgl_+3A_rdepth">rdepth</code></td>
<td>
<p>The read depth. Lower means more uncertain.</p>
</td></tr>
<tr><td><code id="simgl_+3A_od">od</code></td>
<td>
<p>The overdispersion parameter. Higher means more uncertain.</p>
</td></tr>
<tr><td><code id="simgl_+3A_bias">bias</code></td>
<td>
<p>The allele bias parameter. Further from 1 means more bias.
Must greater than 0.</p>
</td></tr>
<tr><td><code id="simgl_+3A_seq">seq</code></td>
<td>
<p>The sequencing error rate. Higher means more uncertain.</p>
</td></tr>
<tr><td><code id="simgl_+3A_ret">ret</code></td>
<td>
<p>The return type. Should we just return the genotype
likelihoods (<code>"gl"</code>), just the genotype posteriors
(<code>"gp"</code>), or the entire updog output (<code>"all"</code>)</p>
</td></tr>
<tr><td><code id="simgl_+3A_est">est</code></td>
<td>
<p>A logical. Estimate the updog likelihood parameters while
genotype (<code>TRUE</code>) or fix them at the true values (<code>FALSE</code>)?
More realistic simulations would set this to <code>TRUE</code>, but it makes
the method much slower.</p>
</td></tr>
<tr><td><code id="simgl_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to
<code><a href="updog.html#topic+flexdog_full">flexdog_full</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a matrix. The genotype (natural) log likelihoods.
The rows index the individuals and the columns index the dosage. So
<code>gl[i,j]</code> is the genotype log-likelihood for individual i
at dosage j - 1.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
simgl(c(1, 2, 1, 0, 0), model = "norm", est = TRUE)
simgl(c(1, 2, 1, 0, 0), model = "norm", est = FALSE)

</code></pre>

<hr>
<h2 id='ts_bands'>Get simultaneous confidence bands for a uniform QQ-plot</h2><span id='topic+ts_bands'></span>

<h3>Description</h3>

<p>This will provide 100(1-a)% simultaneous confidence bands for a
sample of size <code>n</code>. It does this by the &quot;tail-sensitive&quot; approach
of Aldor-Noiman et al (2013), which uses simulated uniform vectors. The
number of simulations is controlled by <code>nsamp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_bands(n, nsamp = 1000, a = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ts_bands_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="ts_bands_+3A_nsamp">nsamp</code></td>
<td>
<p>Number of simulation repetitions.</p>
</td></tr>
<tr><td><code id="ts_bands_+3A_a">a</code></td>
<td>
<p>The significance level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure used is described in Aldor-Noiman et al (2013). But note
that they have a mistake in their paper. Step (e) of their algorithm on
page 254 should be the CDF of the Beta distribution, not the quantile
function.
</p>


<h3>Value</h3>

<p>A list of length 3. The <code>$lower</code> and <code>$upper</code> confidence
limits at uniform quantiles <code>$q</code>.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Aldor-Noiman, S., Brown, L. D., Buja, A., Rolke, W., &amp; Stine, R. A. (2013). The power to see: A new graphical test of normality. The American Statistician, 67(4), 249-260.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ts &lt;- ts_bands(100)

graphics::plot(x = ts$q,
               y = ts$upper,
               type = "l",
               xlim = c(0, 1),
               ylim = c(0, 1),
               xlab = "Theoretical Quantiles",
               ylab = "Empirical Quantiles")
graphics::lines(x = ts$q, y = ts$lower)
graphics::lines(x = ts$q, y = ts$q, lty = 2)

</code></pre>

<hr>
<h2 id='zsegarray'>Zygote segregation distributions.</h2><span id='topic+zsegarray'></span>

<h3>Description</h3>

<p>Obtains offspring genotype probabilities given parental probabilities,
the ploidy of the species, and the overdispersion parameter,
for all possible parental genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zsegarray(alpha, ploidy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zsegarray_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector containing the double reduction parameter(s).
This should be a
vector of length <code>floor(ploidy/4)</code> where <code>alpha[i]</code>
is the probability of exactly <code>i</code> pairs of IBDR alleles
being in the gamete. Note that <code>sum(alpha)</code> should be less than
1, as <code>1 - sum(alpha)</code> is the probability of no double reduction.</p>
</td></tr>
<tr><td><code id="zsegarray_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species. This should be an even positive
integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of probabilities. Element (i, j, k) contains the
probability of offspring dosage k-1 given parental dosages
i-1 and j-1.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ploidy &lt;- 10
alpha &lt;- c(0.5, 0.1)
p1 &lt;- 4
p2 &lt;- 3
segarray &lt;- zsegarray(alpha = alpha, ploidy = ploidy)
graphics::plot(x = 0:10,
               y = segarray[p1 + 1, p2 + 1, ],
               type = "h",
               ylab = "Pr(dosage)",
               xlab = "dosage")
graphics::mtext(paste0("P1 dosage = ",
                       p1,
                       ", ",
                       "P2 dosage = ",
                       p2))

</code></pre>

<hr>
<h2 id='zygdist'>Zygote dosage probabilities.</h2><span id='topic+zygdist'></span>

<h3>Description</h3>

<p>Calculates the distribution of an offspring dosages given
parental dosages (<code>G1</code> and <code>G2</code>), the ploidy of the
species (<code>ploidy</code>), and the double reduction parameter
(<code>alpha</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zygdist(alpha, G1, G2, ploidy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zygdist_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector containing the double reduction parameter(s).
This should be a
vector of length <code>floor(ploidy/4)</code> where <code>alpha[i]</code>
is the probability of exactly <code>i</code> pairs of IBDR alleles
being in the gamete. Note that <code>sum(alpha)</code> should be less than
1, as <code>1 - sum(alpha)</code> is the probability of no double reduction.</p>
</td></tr>
<tr><td><code id="zygdist_+3A_g1">G1</code></td>
<td>
<p>The dosage of parent 1. Should be an integer between <code>0</code>
and <code>ploidy</code>.</p>
</td></tr>
<tr><td><code id="zygdist_+3A_g2">G2</code></td>
<td>
<p>The dosage of parent 2. Should be an integer between <code>0</code>
and <code>ploidy</code>.</p>
</td></tr>
<tr><td><code id="zygdist_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the species. This should be an even positive
integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of probabilities. The <code>i</code>th element is the
probability that the offspring will have dosage <code>i-1</code>.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zygdist(alpha = c(0.5, 0.1), G1 = 4, G2 = 5, ploidy = 8)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
