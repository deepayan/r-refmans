<!DOCTYPE html><html><head><title>Help for package pmwg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pmwg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pmwg-package'><p>pmwg: Particle Metropolis Within Gibbs.</p></a></li>
<li><a href='#accept_progress_bar'><p>An altered version of the utils:txtProgressBar that shows acceptance rate</p></a></li>
<li><a href='#accept_rate'><p>Return the acceptance rate for new particles across all subjects</p></a></li>
<li><a href='#as_mcmc'><p>Return a CODA mcmc object with the required samples</p></a></li>
<li><a href='#augment_sampler_epsilon'><p>Augment existing sampler object to have subject specific epsilon storage</p></a></li>
<li><a href='#check_adapted'><p>Check whether the adaptation phase has successfully completed</p></a></li>
<li><a href='#check_efficient'><p>Check for efficient proposals if necessary</p></a></li>
<li><a href='#check_run_stage_args'><p>Test the arguments to the run_stage function for correctness</p></a></li>
<li><a href='#conditional_parms'><p>Obtain the efficent mu and sigma from the adaptation phase draws</p></a></li>
<li><a href='#create_efficient'><p>Create distribution parameters for efficient proposals</p></a></li>
<li><a href='#extend_sampler'><p>Extend the main data store with empty space for new samples</p></a></li>
<li><a href='#extract_samples'><p>Extract relevant samples from the list for conditional dist calc</p></a></li>
<li><a href='#forstmann'><p>Forstmann et al.'s data</p></a></li>
<li><a href='#gen_particles'><p>Generate proposal particles</p></a></li>
<li><a href='#gibbs_step'><p>Gibbs step of the Particle Metropolis within Gibbs sampler</p></a></li>
<li><a href='#gibbs_step_err'><p>Error handler for the gibbs_step call</p></a></li>
<li><a href='#init'><p>Initialise values for the random effects</p></a></li>
<li><a href='#is.pmwgs'><p>Test whether object is a pmwgs</p></a></li>
<li><a href='#last_sample'><p>Create a list with the last samples in the pmwgs object</p></a></li>
<li><a href='#new_sample'><p>Generate particles and select one to be the new sample</p></a></li>
<li><a href='#new_sample_err'><p>Error handler forany error in new_sample function call(s)</p></a></li>
<li><a href='#numbers_from_proportion'><p>Check and normalise the number of each particle type from the mix_proportion</p></a></li>
<li><a href='#particle_draws'><p>Generate a cloud of particles from a multivariate normal distribution</p></a></li>
<li><a href='#particle_select_err'><p>Error handler for the particle selection call</p></a></li>
<li><a href='#pmwgs'><p>Create a PMwG sampler and return the created object</p></a></li>
<li><a href='#relabel_samples'><p>Relabel requested burn-in samples as adaptation</p></a></li>
<li><a href='#riwish'><p>The Inverse Wishart Distribution</p></a></li>
<li><a href='#run_stage'><p>Run a stage of the PMwG sampler</p></a></li>
<li><a href='#rwish'><p>The Wishart Distribution</p></a></li>
<li><a href='#sample_store'><p>Create a new list for storage samples in the pmwgs object</p></a></li>
<li><a href='#sampled_forstmann'><p>A sampled object of a model of the Forstmann dataset</p></a></li>
<li><a href='#set_epsilon'><p>Set default values for epsilon</p></a></li>
<li><a href='#set_mix'><p>Set default values for mix</p></a></li>
<li><a href='#set_proposal'><p>Setup the proposal distribution arguments (if in sample stage)</p></a></li>
<li><a href='#test_sampler_adapted'><p>Test that the sampler has successfully adapted</p></a></li>
<li><a href='#trim_na'><p>Trim the unneeded NA values from the end of the sampler</p></a></li>
<li><a href='#unwind'><p>Unwinds variance matrix to a vector</p></a></li>
<li><a href='#update_epsilon'><p>Update the subject specific scaling parameters (epsilon)</p></a></li>
<li><a href='#update_progress_bar'><p>A function that updates the accept_progress_bar with progress and accept rate</p></a></li>
<li><a href='#wind'><p>Winds a variance vector back to a vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Particle Metropolis Within Gibbs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an R implementation of the Particle Metropolis within
    Gibbs sampler for model parameter, covariance matrix and random effect
    estimation. A more general implementation of the sampler based on the paper
    by Gunawan, D., Hawkins, G. E., Tran, M. N., Kohn, R., &amp; Brown, S. D.
    (2020) &lt;<a href="https://doi.org/10.1016%2Fj.jmp.2020.102368">doi:10.1016/j.jmp.2020.102368</a>&gt;. An HTML tutorial document describing
    the package is available at
    <a href="https://university-of-newcastle-research.github.io/samplerDoc/">https://university-of-newcastle-research.github.io/samplerDoc/</a> and
    includes several detailed examples, some background and troubleshooting
    steps.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/university-of-newcastle-research/pmwg">https://github.com/university-of-newcastle-research/pmwg</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/university-of-newcastle-research/pmwg/issues">https://github.com/university-of-newcastle-research/pmwg/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, coda, condMVNorm, MASS, mvtnorm, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, rtdists, testthat, knitr, rmarkdown, V8</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 04:20:35 UTC; gjc216</td>
</tr>
<tr>
<td>Author:</td>
<td>Gavin Cooper [aut, cre, trl] (Package creator and maintainer),
  Reilly Innes [aut],
  Caroline Kuhne [aut],
  Jon-Paul Cavallaro [aut],
  David Gunawan [aut] (Author of original MATLAB code),
  Guy Hawkins [aut],
  Scott Brown [aut, trl] (Original translation from MATLAB to R),
  Niek Stevenson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gavin Cooper &lt;gavin@gavincooper.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 05:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pmwg-package'>pmwg: Particle Metropolis Within Gibbs.</h2><span id='topic+pmwg'></span><span id='topic+pmwg-package'></span>

<h3>Description</h3>

<p>The pmwg package provides a general purpose implementation of the
sampling techniques outlined in Gunawan et al. (2020)
<a href="https://doi.org/10.1016/j.jmp.2020.102368">doi:10.1016/j.jmp.2020.102368</a>. The user of this package is required to
provide their own log likelihood function, but given this the functions
provided can estimate model parameters, the full covariance matrix and
subject random effects in a hierarchical Bayesian way.
</p>


<h3>Documentation</h3>

<p>The documentation found at
contains background information and motivation for the approach used in
this package and several detailed examples of the package in action. It also
includes a list of common problems and associated troubleshooting steps.
</p>


<h3>User input</h3>

<p>The user is expected to provide a data source in a format that is compatible
with R data.frame methods. This data must have at least one column named
&lsquo;subject' that has a unique identifier for each subject&rsquo;s data.
</p>
<p>Additionally the user should provide a function that when given a set of
parameter estimates and the data for a single subject return the log of the
likelihood of that data given the parameter estimates.
</p>
<p>The final piece of required information is a list of the names of each
parameter that should be estimated. There is also the capability to provide
priors on the model parameters, start points for the model parameters and
covariance matrix as well as options to fine tune the sampling process
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gavin Cooper <a href="mailto:gavin@gavincooper.net">gavin@gavincooper.net</a> (Package creator and maintainer) [translator]
</p>
<p>Authors:
</p>

<ul>
<li><p> Reilly Innes <a href="mailto:Reilly.Innes@uon.edu.au">Reilly.Innes@uon.edu.au</a>
</p>
</li>
<li><p> Caroline Kuhne <a href="mailto:caroline.kuhne@newcastle.edu.au">caroline.kuhne@newcastle.edu.au</a>
</p>
</li>
<li><p> Jon-Paul Cavallaro <a href="mailto:jon-paul.cavallaro@uon.edu.au">jon-paul.cavallaro@uon.edu.au</a>
</p>
</li>
<li><p> David Gunawan <a href="mailto:dgunawan@uow.edu.au">dgunawan@uow.edu.au</a> (Author of original MATLAB code)
</p>
</li>
<li><p> Guy Hawkins <a href="mailto:guy.hawkins@newcastle.edu.au">guy.hawkins@newcastle.edu.au</a>
</p>
</li>
<li><p> Scott Brown <a href="mailto:scott.brown@newcastle.edu.au">scott.brown@newcastle.edu.au</a> (Original translation from MATLAB to R) [translator]
</p>
</li>
<li><p> Niek Stevenson <a href="mailto:niek.stevenson@gmail.com">niek.stevenson@gmail.com</a>
</p>
</li></ul>



<h3>References</h3>

<p>Gunawan, D., Hawkins, G. E., Tran, M. N., Kohn, R., &amp; Brown, S. D. (2020).
New estimation approaches for the hierarchical Linear Ballistic Accumulator
model. <em>Journal of Mathematical Psychology, 96</em>, 102368.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/university-of-newcastle-research/pmwg">https://github.com/university-of-newcastle-research/pmwg</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/university-of-newcastle-research/pmwg/issues">https://github.com/university-of-newcastle-research/pmwg/issues</a>
</p>
</li></ul>


<hr>
<h2 id='accept_progress_bar'>An altered version of the utils:txtProgressBar that shows acceptance rate</h2><span id='topic+accept_progress_bar'></span>

<h3>Description</h3>

<p>The progress bar displays several elements, the progress visually as a bar
being filled and the percentage complete as per the standard
utils::txtProgressBar and additionally the average across subjects of the
rate of accepting newly generated particles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accept_progress_bar(min = 0, max = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accept_progress_bar_+3A_min">min</code></td>
<td>
<p>The minimum of the value being updated for the progress bar</p>
</td></tr>
<tr><td><code id="accept_progress_bar_+3A_max">max</code></td>
<td>
<p>The maximum of the value being updated for the progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structure matching the structure of a txtProgresBar with additional
info
</p>

<hr>
<h2 id='accept_rate'>Return the acceptance rate for new particles across all subjects</h2><span id='topic+accept_rate'></span>

<h3>Description</h3>

<p>Here the acceptance rate is defined as the rate of accepting newly generated
particles for individuals random effects. That is the number of samples where
a newly generated particle was accepted / the number of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accept_rate(pmwgs, window_size = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accept_rate_+3A_pmwgs">pmwgs</code></td>
<td>
<p>The sampler object (containing random effects) with which we are
working</p>
</td></tr>
<tr><td><code id="accept_rate_+3A_window_size">window_size</code></td>
<td>
<p>The size of the window to calculate acceptance rate over</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the acceptance rate for each subject for the last X
samples
</p>

<hr>
<h2 id='as_mcmc'>Return a CODA mcmc object with the required samples</h2><span id='topic+as_mcmc'></span>

<h3>Description</h3>

<p>Given a sampler object and a specification of the samples required, return
either an individual coda mcmc object, or a list of mcmc objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_mcmc(sampler, selection = "theta_mu", filter = stages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_mcmc_+3A_sampler">sampler</code></td>
<td>
<p>The pmwgs object containing samples to extract.</p>
</td></tr>
<tr><td><code id="as_mcmc_+3A_selection">selection</code></td>
<td>
<p>The selection of sample types to return.</p>
</td></tr>
<tr><td><code id="as_mcmc_+3A_filter">filter</code></td>
<td>
<p>A filter that defines which stage to draw samples from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An mcmc object or list containing the selected samples.
</p>


<h3>Selecting sample types</h3>

<p>The values that can be chosen for the <code>selection</code> argument can be one
of the following list:
</p>

<dl>
<dt><code>"theta_mu"</code></dt><dd><p>the model parameter estimate samples</p>
</dd>
<dt><code>"theta_sig"</code></dt><dd><p>the covariance matrix estimates, returns a list
of mcmc objects, one for each model parameter.</p>
</dd>
<dt><code>"alpha"</code></dt><dd><p>the random effect estimates, returns a list of mcmc
objects, one for each subject.</p>
</dd>
</dl>

<p>The default value for <code>selection</code> is <code>"theta_mu"</code>
</p>


<h3>Filtering samples</h3>

<p>The <code>filter</code> argument can take one of two forms:
</p>

<ul>
<li><p> An integer vector, usually a sequence of integers, that must fall
within the range 1:end.
</p>
</li>
<li><p> A character vector, where each element corresponds to a stage of the
sampling process, i.e. one or more of &quot;init&quot;, &quot;burn&quot;, &quot;adapt&quot; or
&quot;sample&quot;.
</p>
</li></ul>

<p>The default value for <code>filter</code> is all stages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par_estimates &lt;- as_mcmc(sampled_forstmann)
par_estimates_sample_stage &lt;- as_mcmc(sampled_forstmann, filter = "sample")
rand_eff &lt;- as_mcmc(
  sampled_forstmann,
  selection = "alpha",
  filter = "sample"
)
</code></pre>

<hr>
<h2 id='augment_sampler_epsilon'>Augment existing sampler object to have subject specific epsilon storage</h2><span id='topic+augment_sampler_epsilon'></span>

<h3>Description</h3>

<p>Older sampler object will be missing subject specific scaling parameter
(epsilon) storage, and running a stage with an updated pmwg will fail. To
fix this you can run the augment_sampler_epsilon function to fill the
appropriate array internals with NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augment_sampler_epsilon(sampler)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment_sampler_epsilon_+3A_sampler">sampler</code></td>
<td>
<p>The sampler object to augment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pmwgs sampler with epsilon array set internally
</p>

<hr>
<h2 id='check_adapted'>Check whether the adaptation phase has successfully completed</h2><span id='topic+check_adapted'></span>

<h3>Description</h3>

<p>Check whether the adaptation phase has successfully completed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_adapted(samples, unq_vals = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_adapted_+3A_samples">samples</code></td>
<td>
<p>The subject mean samples with which we are working</p>
</td></tr>
<tr><td><code id="check_adapted_+3A_unq_vals">unq_vals</code></td>
<td>
<p>The number of unique values for each subject</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean TRUE or FALSE depending on the result of the test
</p>

<hr>
<h2 id='check_efficient'>Check for efficient proposals if necessary</h2><span id='topic+check_efficient'></span>

<h3>Description</h3>

<p>Takes a mix proportion vector (3 x float) and the efficient proposal mu and
sigma. If efficient proposals are to be used (mix_proportion[3] &gt; 0) then
test the efficient proposal values to see whether they are not null and
appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_efficient(mix_proportion, efficient_mu, efficient_sig2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_efficient_+3A_mix_proportion">mix_proportion</code></td>
<td>
<p>A vector of floats between 0 and 1 and summing to 1
which give the proportion of particles to generate from the population
level parameters, the individual random effects and the conditional
parameters respectively</p>
</td></tr>
<tr><td><code id="check_efficient_+3A_efficient_mu">efficient_mu</code></td>
<td>
<p>The mu value for the efficient proposals</p>
</td></tr>
<tr><td><code id="check_efficient_+3A_efficient_sig2">efficient_sig2</code></td>
<td>
<p>The sigma value for the efficient proposals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, stops operation on incorrect combination of parameters.
</p>

<hr>
<h2 id='check_run_stage_args'>Test the arguments to the run_stage function for correctness</h2><span id='topic+check_run_stage_args'></span>

<h3>Description</h3>

<p>Takes the arguments to run_stage and checks them for completeness and
correctness. Returns a list of cleaned/checked arguments to the caller.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_run_stage_args(
  pmwgs,
  stage,
  iter,
  particles,
  display_progress,
  n_cores,
  n_unique,
  epsilon,
  subj_epsilon,
  p_accept,
  mix,
  pdist_update_n
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_run_stage_args_+3A_pmwgs">pmwgs</code></td>
<td>
<p>A Particle Metropolis within Gibbs sampler which has been set
up and initialised</p>
</td></tr>
<tr><td><code id="check_run_stage_args_+3A_stage">stage</code></td>
<td>
<p>The sampling stage to run. Must be one of <code>'burn'</code>,
<code>'adapt'</code> or <code>'sample'</code>.</p>
</td></tr>
<tr><td><code id="check_run_stage_args_+3A_iter">iter</code></td>
<td>
<p>The number of iterations to run for the sampler. For
<code>'burn'</code> and <code>'sample'</code> all iterations will run. However for
<code>'adapt'</code> if all subjects have enough unique samples to create the
conditional distribution then the stage will finish early.</p>
</td></tr>
<tr><td><code id="check_run_stage_args_+3A_particles">particles</code></td>
<td>
<p>The default here is 1000 particles to be generated for each
iteration, however during the sample phase this should be reduced.</p>
</td></tr>
<tr><td><code id="check_run_stage_args_+3A_display_progress">display_progress</code></td>
<td>
<p>Display a progress bar during sampling.</p>
</td></tr>
<tr><td><code id="check_run_stage_args_+3A_n_cores">n_cores</code></td>
<td>
<p>Set to more than 1 to use <code>mclapply</code>. Setting
<code>n_cores</code> greater than 1 is only permitted on Linux and Mac OS X
machines.</p>
</td></tr>
<tr><td><code id="check_run_stage_args_+3A_n_unique">n_unique</code></td>
<td>
<p>A number representing the number of unique samples to check
for on each iteration of the sampler (An initial test for the generation
of the proposal distribution). Only used during the <code>'adapt'</code> stage.</p>
</td></tr>
<tr><td><code id="check_run_stage_args_+3A_epsilon">epsilon</code></td>
<td>
<p>A value between 0 and 1 that controls the extent to which the
covariance matrix is scaled when generating particles from the previous
random effect. The default will be chosen based on the number of random
effects in the model.</p>
</td></tr>
<tr><td><code id="check_run_stage_args_+3A_p_accept">p_accept</code></td>
<td>
<p>A value between 0 and 1 that will flexibly tune epsilon to
achieve an acceptance ratio close to what you set p_accept to. The default
is set at 0.8.</p>
</td></tr>
<tr><td><code id="check_run_stage_args_+3A_mix">mix</code></td>
<td>
<p>A vector of floats that controls the mixture of different sources
for particles. The function <code><a href="#topic+numbers_from_proportion">numbers_from_proportion</a></code> is
passed this value and includes extra details on what is accepted.</p>
</td></tr>
<tr><td><code id="check_run_stage_args_+3A_pdist_update_n">pdist_update_n</code></td>
<td>
<p>The number of iterations in the sample stage after
which the proposal distribution will be recomputed.</p>
</td></tr>
</table>

<hr>
<h2 id='conditional_parms'>Obtain the efficent mu and sigma from the adaptation phase draws</h2><span id='topic+conditional_parms'></span>

<h3>Description</h3>

<p>Obtain the efficent mu and sigma from the adaptation phase draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_parms(s, samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditional_parms_+3A_s">s</code></td>
<td>
<p>current subject number</p>
</td></tr>
<tr><td><code id="conditional_parms_+3A_samples">samples</code></td>
<td>
<p>A list containing previous samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the conditional mean and variances for this subject
</p>

<hr>
<h2 id='create_efficient'>Create distribution parameters for efficient proposals</h2><span id='topic+create_efficient'></span>

<h3>Description</h3>

<p>From the existing samples, create a proposal distribution for drawing
efficient samples from.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_efficient(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_efficient_+3A_x">x</code></td>
<td>
<p>The current pmwgs object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the mu and sigma for the proposal distribution.
</p>

<hr>
<h2 id='extend_sampler'>Extend the main data store with empty space for new samples</h2><span id='topic+extend_sampler'></span>

<h3>Description</h3>

<p>Extend the main data store with empty space for new samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend_sampler(sampler, n_samples, stage)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend_sampler_+3A_sampler">sampler</code></td>
<td>
<p>The pmwgs object that we are adding the new samples to</p>
</td></tr>
<tr><td><code id="extend_sampler_+3A_n_samples">n_samples</code></td>
<td>
<p>The number of new samples to increase by</p>
</td></tr>
<tr><td><code id="extend_sampler_+3A_stage">stage</code></td>
<td>
<p>The name of the stage from which the new samples will be drawn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pmwgs object with the space for new samples added
</p>

<hr>
<h2 id='extract_samples'>Extract relevant samples from the list for conditional dist calc</h2><span id='topic+extract_samples'></span>

<h3>Description</h3>

<p>From the sampler, extract relevant samples for the creation of
the proposal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_samples(sampler, stage = c("adapt", "sample"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_samples_+3A_sampler">sampler</code></td>
<td>
<p>The pmwgs object containing the samples</p>
</td></tr>
<tr><td><code id="extract_samples_+3A_stage">stage</code></td>
<td>
<p>The stage, or list of stages from which you want the samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing only appropriate samples (non init/burnin samples)
</p>

<hr>
<h2 id='forstmann'>Forstmann et al.'s data</h2><span id='topic+forstmann'></span>

<h3>Description</h3>

<p>A dataset containing the speed or accuracy manipulation for a Random Dot
Motion experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forstmann
</code></pre>


<h3>Format</h3>

<p>A data frame with 15818 rows and 5 variables:
</p>

<dl>
<dt>subject</dt><dd><p>integer ID for each subject</p>
</dd>
<dt>rt</dt><dd><p>reaction time for each trial as a double</p>
</dd>
<dt>condition</dt><dd><p>Factor with 3 levels for Speed, Accuracy and
Neutral</p>
</dd>
<dt>stim</dt><dd><p>Factor with 2 levels for Left and Right trials</p>
</dd>
<dt>resp</dt><dd><p>Factor with 2 levels for Left and Right responses</p>
</dd>
</dl>



<h3>Details</h3>

<p>Details on the dataset can be found in the following paper:
</p>
<p><strong>Striatum and pre-SMA facilitate decision-making under time pressure</strong>
</p>
<p>Birte U. Forstmann, Gilles Dutilh, Scott Brown, Jane Neumann,
D. Yves von Cramon, K. Richard Ridderinkhof, Eric-Jan Wagenmakers.
</p>
<p><em>Proceedings of the National Academy of Sciences Nov 2008, 105 (45)
17538-17542; DOI: 10.1073/pnas.0805903105</em>
</p>


<h3>Source</h3>

<p><a href="https://www.pnas.org/content/105/45/17538">https://www.pnas.org/content/105/45/17538</a>
</p>

<hr>
<h2 id='gen_particles'>Generate proposal particles</h2><span id='topic+gen_particles'></span>

<h3>Description</h3>

<p>Generates particles for the <code>new_sample</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_particles(
  num_particles,
  mu,
  sig2,
  particle,
  ...,
  mix_proportion = c(0.5, 0.5, 0),
  prop_mu = NULL,
  prop_sig2 = NULL,
  epsilon = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_particles_+3A_num_particles">num_particles</code></td>
<td>
<p>The total number of particles to generate using a
combination of the three methods.</p>
</td></tr>
<tr><td><code id="gen_particles_+3A_mu">mu</code></td>
<td>
<p>A vector of means for the multivariate normal</p>
</td></tr>
<tr><td><code id="gen_particles_+3A_sig2">sig2</code></td>
<td>
<p>A covariate matrix for the multivariate normal</p>
</td></tr>
<tr><td><code id="gen_particles_+3A_particle">particle</code></td>
<td>
<p>A particle (re proposals for latent variables)</p>
</td></tr>
<tr><td><code id="gen_particles_+3A_mix_proportion">mix_proportion</code></td>
<td>
<p>A vector of floats between 0 and 1 and summing to 1
which give the proportion of particles to generate from the population
level parameters, the individual random effects and the conditional
parameters respectively</p>
</td></tr>
<tr><td><code id="gen_particles_+3A_epsilon">epsilon</code></td>
<td>
<p>Reduce the variance for the individual level samples by this
factor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate particles for a particular subject from a mix of population level
(hierarchical) distribution, from the particles (containing individual level
distribution) and/or from the conditional on accepted individual level
particles, a more efficient proposal method.
</p>
<p>This function is used in burnin, adaptation and sampling using various
combinations of the arguments.
</p>


<h3>Value</h3>

<p>The new proposals
</p>

<hr>
<h2 id='gibbs_step'>Gibbs step of the Particle Metropolis within Gibbs sampler</h2><span id='topic+gibbs_step'></span>

<h3>Description</h3>

<p>Samples new <code>theta_mu</code> and <code>theta_sig</code> using Gibbs sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gibbs_step(sampler)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gibbs_step_+3A_sampler">sampler</code></td>
<td>
<p>The pmwgs object from which to generate the new group
parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new sample for <code>theta_mu</code>, <code>theta_sig</code> and some new
mixing weights in a list for use in the Particle Metropolis step.
</p>

<hr>
<h2 id='gibbs_step_err'>Error handler for the gibbs_step call</h2><span id='topic+gibbs_step_err'></span>

<h3>Description</h3>

<p>If an error was detected when generating new values in Gibbs step this
function is called to generate the error message and save the state of the
samples at that moment to help with debugging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gibbs_step_err(pmwgs, err_cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gibbs_step_err_+3A_pmwgs">pmwgs</code></td>
<td>
<p>The pmwgs object for the current run.</p>
</td></tr>
<tr><td><code id="gibbs_step_err_+3A_err_cond">err_cond</code></td>
<td>
<p>The original error condition that prompted this.</p>
</td></tr>
</table>

<hr>
<h2 id='init'>Initialise values for the random effects</h2><span id='topic+init'></span>

<h3>Description</h3>

<p>Initialise the random effects for each subject using MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init(
  pmwgs,
  start_mu = NULL,
  start_sig = NULL,
  display_progress = TRUE,
  particles = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_+3A_pmwgs">pmwgs</code></td>
<td>
<p>The sampler object that provides the parameters.</p>
</td></tr>
<tr><td><code id="init_+3A_start_mu">start_mu</code></td>
<td>
<p>An array of starting values for the group means</p>
</td></tr>
<tr><td><code id="init_+3A_start_sig">start_sig</code></td>
<td>
<p>An array of starting values for the group covariance matrix</p>
</td></tr>
<tr><td><code id="init_+3A_display_progress">display_progress</code></td>
<td>
<p>Display a progress bar during sampling</p>
</td></tr>
<tr><td><code id="init_+3A_particles">particles</code></td>
<td>
<p>The number of particles to generate in initialisation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before sampling can start the Particle Metropolis within Gibbs sampler needs
initial values for the random effects. The <code>init</code> function generates
these values using a Monte Carlo algorithm. One alternative methods would be
setting the initial values randomly.
</p>
<p>Optionally takes starting values for the model parameters and the variance /
covariance matrix. All arrays must match the appropriate shape.
</p>
<p>For example, with 5 parameters and 10 subjects, the model parameter start
means must be a vector of length 5 and the covariance matrix must be an array
of 5 x 5.
</p>
<p>If the start_mu and start_sig arguments are left at the default (NULL) then
start_mu will be sampled from a normal distribution with mean as the prior
mean for eac variable and sd as the square of the variance from the prior
covariance matrix. start_sig by default is sampled from an inverse wishart
(IW) distribution. For a model with the number of parameters N the degrees of
freedom of the IW distribution is set to N*3 and the scale matrix is the
identity matrix of size NxN.
</p>


<h3>Value</h3>

<p>The sampler object but with initial values set for <code>theta_mu</code>,
<code>theta_sig</code>, <code>alpha</code> and other values for the first sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lba_ll &lt;- function(x, data) {
  x &lt;- exp(x)
  if (any(data$rt &lt; x["t0"])) {
    return(-1e10)
  }
  sum(
    log(
      rtdists::dLBA(
        rt = data$rt,
        response = data$correct,
        A = x["A"],
        b = x["A"] + x[c("b1", "b2", "b3")][data$condition],
        t0 = x["t0"],
        mean_v = x[c("v1", "v2")],
        sd_v = c(1, 1),
        silent = TRUE
      )
    )
  )
}
sampler &lt;- pmwgs(
  forstmann,
  c("b1", "b2", "b3", "A", "v1", "v2", "t0"),
  lba_ll
)
sampler &lt;- init(sampler, particles=10)
</code></pre>

<hr>
<h2 id='is.pmwgs'>Test whether object is a pmwgs</h2><span id='topic+is.pmwgs'></span>

<h3>Description</h3>

<p>Checks whether object is a Particle Metropolis with Gibbs sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.pmwgs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.pmwgs_+3A_x">x</code></td>
<td>
<p>An object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether object inherits from pmwgs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (is.pmwgs(sampled_forstmann)) {
  print("sampled_forstmann object is a pmwgs")
}
</code></pre>

<hr>
<h2 id='last_sample'>Create a list with the last samples in the pmwgs object</h2><span id='topic+last_sample'></span>

<h3>Description</h3>

<p>Create a list with the last samples in the pmwgs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_sample(store)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_sample_+3A_store">store</code></td>
<td>
<p>The list containing samples from which to grab the last.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the last sample of group mean and variance and
subject means.
</p>

<hr>
<h2 id='new_sample'>Generate particles and select one to be the new sample</h2><span id='topic+new_sample'></span>

<h3>Description</h3>

<p>Generate a new sample for a particular subject given their data and the
new model parameter estimates. This should not be called directly, rather it
is used internally to run_stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_sample(
  s,
  data,
  num_particles,
  parameters,
  efficient_mu = NULL,
  efficient_sig2 = NULL,
  mix_proportion = c(0.5, 0.5, 0),
  likelihood_func = NULL,
  epsilon = 1,
  subjects = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_sample_+3A_s">s</code></td>
<td>
<p>A number - the index of the subject. For <code>s == 1</code> The first
subject ID from the <code>data</code> subject column will be selected. For
<code>s == 2</code> the second unique value for subject id will be used.</p>
</td></tr>
<tr><td><code id="new_sample_+3A_data">data</code></td>
<td>
<p>A data.frame (or similar object) which contains the data against
which the particles are assessed. The only strict requirement is that
it contains a subject column named as such to allow for the splitting
of the data by unique subject id. The provided log likelihood function
is the only other contact with the data.</p>
</td></tr>
<tr><td><code id="new_sample_+3A_num_particles">num_particles</code></td>
<td>
<p>The total number of particles to generate using a
combination of the three methods.</p>
</td></tr>
<tr><td><code id="new_sample_+3A_parameters">parameters</code></td>
<td>
<p>A list containing:
</p>

<dl>
<dt><code>tmu</code></dt><dd><p>The vector of means for the multivariate normal</p>
</dd>
<dt><code>tsig</code></dt><dd><p>A covariate matrix for the multivariate normal</p>
</dd>
<dt><code>alpha</code></dt><dd><p>An array of individual subject random effects</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="new_sample_+3A_efficient_mu">efficient_mu</code></td>
<td>
<p>The mu value for the efficient proposals</p>
</td></tr>
<tr><td><code id="new_sample_+3A_efficient_sig2">efficient_sig2</code></td>
<td>
<p>The sigma value for the efficient proposals</p>
</td></tr>
<tr><td><code id="new_sample_+3A_mix_proportion">mix_proportion</code></td>
<td>
<p>A vector of floats between 0 and 1 and summing to 1
which give the proportion of particles to generate from the population
level parameters, the individual random effects and the conditional
parameters respectively</p>
</td></tr>
<tr><td><code id="new_sample_+3A_likelihood_func">likelihood_func</code></td>
<td>
<p>A likelihood function for calculating log likelihood
of samples. Usually provided internally in <code>run_stage</code> from the pmwgs
object.</p>
</td></tr>
<tr><td><code id="new_sample_+3A_epsilon">epsilon</code></td>
<td>
<p>A scaling factor to reduce the variance on the distribution
based on subject random effects when generating particles.</p>
</td></tr>
<tr><td><code id="new_sample_+3A_subjects">subjects</code></td>
<td>
<p>A list of unique subject ids in the order they appear in
the data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function that controls the generation of new samples for the Particle
Metropolis within Gibbs sampler. It generates samples from either the initial
proposal or from the last iteration of the sampler. This function should not
usually need to be called, as the <code>run_stage</code> function uses this
internally.
</p>
<p>The way it selects a new sample is by generating proposal particles from up
to three different distributions (according to a mixing proportion).
</p>
<p>The first distribution is based on the current model parameter sample values.
The second distribution is based on the last random effects for the subject.
The third distribution is only used in the final sampling phase and is based
on the conditional distribution built from accepted particles in the adapt
phase of the sampler.
</p>


<h3>Value</h3>

<p>A single sample from the new proposals
</p>

<hr>
<h2 id='new_sample_err'>Error handler forany error in new_sample function call(s)</h2><span id='topic+new_sample_err'></span>

<h3>Description</h3>

<p>If an error was detected when generating new samples. Save the state
of the samples and particles at that moment to help with debugging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_sample_err(pmwgs, envir, err_cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_sample_err_+3A_pmwgs">pmwgs</code></td>
<td>
<p>The pmwgs object for the current run.</p>
</td></tr>
<tr><td><code id="new_sample_err_+3A_envir">envir</code></td>
<td>
<p>The environment of the function at this point in time.</p>
</td></tr>
<tr><td><code id="new_sample_err_+3A_err_cond">err_cond</code></td>
<td>
<p>The original error condition that prompted this.</p>
</td></tr>
</table>

<hr>
<h2 id='numbers_from_proportion'>Check and normalise the number of each particle type from the mix_proportion</h2><span id='topic+numbers_from_proportion'></span>

<h3>Description</h3>

<p>Takes a mix proportion vector (3 x float) and a number of particles to
generate and returns a vector containing the number of each particle type to
generate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numbers_from_proportion(mix_proportion, num_particles = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numbers_from_proportion_+3A_mix_proportion">mix_proportion</code></td>
<td>
<p>A vector of floats between 0 and 1 and summing to 1
which give the proportion of particles to generate from the population
level parameters, the individual random effects and the conditional
parameters respectively</p>
</td></tr>
<tr><td><code id="numbers_from_proportion_+3A_num_particles">num_particles</code></td>
<td>
<p>The total number of particles to generate using a
combination of the three methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The wound vector as a matrix
</p>

<hr>
<h2 id='particle_draws'>Generate a cloud of particles from a multivariate normal distribution</h2><span id='topic+particle_draws'></span>

<h3>Description</h3>

<p>Takes the mean and variance for a multivariate normal distribution, as well
as the number of particles to generate and return random draws from the
multivariate normal if the numbers of particles is &gt; 0, otherwise return
NULL. At least one of mean or sigma must be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>particle_draws(n, mu, covar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="particle_draws_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="particle_draws_+3A_mu">mu</code></td>
<td>
<p>mean vector</p>
</td></tr>
<tr><td><code id="particle_draws_+3A_covar">covar</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If n &gt; 0 returns n draws from the multivariate normal with mean and
sigma, otherwise returns NULL
</p>

<hr>
<h2 id='particle_select_err'>Error handler for the particle selection call</h2><span id='topic+particle_select_err'></span>

<h3>Description</h3>

<p>If an error was detected when selecting the winning particle, save the state
of the samples and particles at that moment to help with debugging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>particle_select_err(subj, envir, err_cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="particle_select_err_+3A_subj">subj</code></td>
<td>
<p>The index of the subject where the error was detected.</p>
</td></tr>
<tr><td><code id="particle_select_err_+3A_envir">envir</code></td>
<td>
<p>The enclosing environment of the function where the error
occurred.</p>
</td></tr>
<tr><td><code id="particle_select_err_+3A_err_cond">err_cond</code></td>
<td>
<p>The original error condition that prompted this.</p>
</td></tr>
</table>

<hr>
<h2 id='pmwgs'>Create a PMwG sampler and return the created object</h2><span id='topic+pmwgs'></span>

<h3>Description</h3>

<p>This function takes a few necessary elements for creating a PMwG sampler.
Each pmwgs object is required to have a dataset, a list of parameter names,
a log likelihood function and optionally a prior for the model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmwgs(data, pars, ll_func, prior = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmwgs_+3A_data">data</code></td>
<td>
<p>A data frame containing empirical data to be modelled. Assumed
to contain at least one column called subject whose elements are unique
identifiers for each subject. Can be any of <code>data.frame</code>,
<code>data.table</code> or <code>tibble</code>, or any other data frame like object
that can have subsets created in an identical way.</p>
</td></tr>
<tr><td><code id="pmwgs_+3A_pars">pars</code></td>
<td>
<p>The list of parameter names to be used in the model</p>
</td></tr>
<tr><td><code id="pmwgs_+3A_ll_func">ll_func</code></td>
<td>
<p>A log likelihood function that given a list of parameter
values and a data frame (or other data store) containing subject data will
return the log likelihood of <code>data</code> given <code>x</code>.</p>
</td></tr>
<tr><td><code id="pmwgs_+3A_prior">prior</code></td>
<td>
<p>Specification of the prior distribution for the model
parameters. It should be a list with two elements, <code>theta_mu_mean</code> and
<code>theta_mu_var</code> which fully specify the prior distribution. If left as
the default (NULL) then the <code>theta_mu_mean</code> will be all zeroes and
<code>theta_mu_var</code> will be 1 on the diagonal and zero elsewhere.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pmwgs object that is ready to be initialised and sampled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Specify the log likelihood function
lba_loglike &lt;- function(x, data) {
  x &lt;- exp(x)
  if (any(data$rt &lt; x["t0"])) {
    return(-1e10)
  }
  # This is faster than "paste".
  bs &lt;- x["A"] + x[c("b1", "b2", "b3")][data$condition]

  out &lt;- rtdists::dLBA(
    rt = data$rt, # nolint
    response = data$stim,
    A = x["A"],
    b = bs,
    t0 = x["t0"],
    mean_v = x[c("v1", "v2")],
    sd_v = c(1, 1),
    distribution = "norm",
    silent = TRUE
  )
  bad &lt;- (out &lt; 1e-10) | (!is.finite(out))
  out[bad] &lt;- 1e-10
  out &lt;- sum(log(out))
  out
}

# Specify parameter names and priors
pars &lt;- c("b1", "b2", "b3", "A", "v1", "v2", "t0")
priors &lt;- list(
  theta_mu_mean = rep(0, length(pars)),
  theta_mu_var = diag(rep(1, length(pars)))
)

# Create the Particle Metropolis within Gibbs sampler object
sampler &lt;- pmwgs(
  data = forstmann,
  pars = pars,
  ll_func = lba_loglike,
  prior = priors
)

sampler = init(sampler, particles=10)
sampler = run_stage(sampler, stage="burn", iter=10, particles=10)
</code></pre>

<hr>
<h2 id='relabel_samples'>Relabel requested burn-in samples as adaptation</h2><span id='topic+relabel_samples'></span>

<h3>Description</h3>

<p>Given a sampler object and a vector of sample indices, relabel the given
samples to be adaptation samples. This will allow them to be used in the
calculation of the conditional distribution for efficient sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relabel_samples(sampler, indices, from = "burn", to = "adapt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relabel_samples_+3A_sampler">sampler</code></td>
<td>
<p>The pmwgs object that we are relabelling samples from</p>
</td></tr>
<tr><td><code id="relabel_samples_+3A_indices">indices</code></td>
<td>
<p>The sample iterations from burn-in to relabel</p>
</td></tr>
<tr><td><code id="relabel_samples_+3A_from">from</code></td>
<td>
<p>The stage you want to re-label from. Default is &quot;burn&quot;</p>
</td></tr>
<tr><td><code id="relabel_samples_+3A_to">to</code></td>
<td>
<p>The stage you want to relabel to. Default is &quot;adapt&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pmwgs object with re-labelled samples
</p>


<h3>Further information</h3>

<p>This should not usually be needed, however if you have a model that is slow
to fit, and upon visual inspection and/or trace analysis you determine that
during burn-in the samples had already approached the posterior distribution
then you can use this function to re-label samples from that point onwards
to be classed as adaptation samples.
</p>
<p>This will allow them to be used in tests that check for the number of unique
samples, and in the building of the conditional distribution (which is used
for efficient sampling)
</p>
<p>If all old samples do not match 'from' then an error will be raised.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_pmwgs &lt;- relabel_samples(sampled_forstmann, 17:21)
</code></pre>

<hr>
<h2 id='riwish'>The Inverse Wishart Distribution</h2><span id='topic+riwish'></span>

<h3>Description</h3>

<p>Random generation from the Inverse Wishart distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riwish(v, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riwish_+3A_v">v</code></td>
<td>
<p>Degrees of freedom (scalar).</p>
</td></tr>
<tr><td><code id="riwish_+3A_s">S</code></td>
<td>
<p>Scale matrix <code class="reqn">(p \times p)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean of an inverse Wishart random variable with <code>v</code> degrees of
freedom and scale matrix <code>S</code> is <code class="reqn">(v-p-1)^{-1}S</code>.
</p>


<h3>Value</h3>

<p><code>riwish</code> generates one random draw from the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
draw &lt;- riwish(3, matrix(c(1,.3,.3,1),2,2))

## End(Not run)
</code></pre>

<hr>
<h2 id='run_stage'>Run a stage of the PMwG sampler</h2><span id='topic+run_stage'></span>

<h3>Description</h3>

<p>Run one of burnin, adaptation or sampling phase from the PMwG
sampler. Each stage involves slightly different processes, so for the
full PMwG sampling we need to run this three times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_stage(
  pmwgs,
  stage,
  iter = 1000,
  particles = 100,
  display_progress = TRUE,
  n_cores = 1,
  n_unique = ifelse(stage == "adapt", 100, NA),
  epsilon = NULL,
  p_accept = 0.8,
  mix = NULL,
  pdist_update_n = ifelse(stage == "sample", 50, NA)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_stage_+3A_pmwgs">pmwgs</code></td>
<td>
<p>A Particle Metropolis within Gibbs sampler which has been set
up and initialised</p>
</td></tr>
<tr><td><code id="run_stage_+3A_stage">stage</code></td>
<td>
<p>The sampling stage to run. Must be one of <code>'burn'</code>,
<code>'adapt'</code> or <code>'sample'</code>.</p>
</td></tr>
<tr><td><code id="run_stage_+3A_iter">iter</code></td>
<td>
<p>The number of iterations to run for the sampler. For
<code>'burn'</code> and <code>'sample'</code> all iterations will run. However for
<code>'adapt'</code> if all subjects have enough unique samples to create the
conditional distribution then the stage will finish early.</p>
</td></tr>
<tr><td><code id="run_stage_+3A_particles">particles</code></td>
<td>
<p>The default here is 1000 particles to be generated for each
iteration, however during the sample phase this should be reduced.</p>
</td></tr>
<tr><td><code id="run_stage_+3A_display_progress">display_progress</code></td>
<td>
<p>Display a progress bar during sampling.</p>
</td></tr>
<tr><td><code id="run_stage_+3A_n_cores">n_cores</code></td>
<td>
<p>Set to more than 1 to use <code>mclapply</code>. Setting
<code>n_cores</code> greater than 1 is only permitted on Linux and Mac OS X
machines.</p>
</td></tr>
<tr><td><code id="run_stage_+3A_n_unique">n_unique</code></td>
<td>
<p>A number representing the number of unique samples to check
for on each iteration of the sampler (An initial test for the generation
of the proposal distribution). Only used during the <code>'adapt'</code> stage.</p>
</td></tr>
<tr><td><code id="run_stage_+3A_epsilon">epsilon</code></td>
<td>
<p>A value between 0 and 1 that controls the extent to which the
covariance matrix is scaled when generating particles from the previous
random effect. The default will be chosen based on the number of random
effects in the model.</p>
</td></tr>
<tr><td><code id="run_stage_+3A_p_accept">p_accept</code></td>
<td>
<p>A value between 0 and 1 that will flexibly tune epsilon to
achieve an acceptance ratio close to what you set p_accept to. The default
is set at 0.8.</p>
</td></tr>
<tr><td><code id="run_stage_+3A_mix">mix</code></td>
<td>
<p>A vector of floats that controls the mixture of different sources
for particles. The function <code><a href="#topic+numbers_from_proportion">numbers_from_proportion</a></code> is
passed this value and includes extra details on what is accepted.</p>
</td></tr>
<tr><td><code id="run_stage_+3A_pdist_update_n">pdist_update_n</code></td>
<td>
<p>The number of iterations in the sample stage after
which the proposal distribution will be recomputed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>burnin</strong> stage by default selects 50
parameter sample (selected through a Gibbs step) and 50
the previous random effect of each subject. It assesses each particle with
the log-likelihood function and samples from all particles weighted by their
log-likelihood.
</p>
<p>The <strong>adaptation</strong> stage selects and assesses particle in the same was
as burnin, however on each iteration it also checks whether each subject has
enough unique random effect samples to attempt to create a conditional
distribution for efficient sampling in the next stage. If the attempt at
creating a conditional distribution fails, then the number of unique samples
is increased and sampling continues. If the attempt succeeds then the stage
is finished early.
</p>
<p>The <strong>final</strong> stage (sampling) by default samples predominantly from the
conditional distribution created at the end of adaptation. This is more
efficient and allows the number of particles to be reduced whilst still
getting a high enough acceptance rate of new samples.
</p>
<p>Once complete each stage will return a sampler object with the new samples
stored within it.
</p>
<p>The progress bar (which is displayed by default) shows the number of
iterations out of those requested which have been completed. It also contains
additional information at the end about the number of newly generated
particles that have been accepted. This is show as New(XXX
average across subjects of newly sampled random effects accept rate. See
<code><a href="#topic+accept_rate">accept_rate</a></code> for more detail on getting individual accept rate
values per subject.
</p>


<h3>Value</h3>

<p>A pmwgs object with the newly generated samples in place.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rtdists)
sampled_forstmann$data &lt;- forstmann
run_stage(sampled_forstmann, "sample", iter = 1, particles = 10)
</code></pre>

<hr>
<h2 id='rwish'>The Wishart Distribution</h2><span id='topic+rwish'></span><span id='topic+dwish'></span>

<h3>Description</h3>

<p>Random generation from the Wishart distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwish(v, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwish_+3A_v">v</code></td>
<td>
<p>Degrees of freedom (scalar).</p>
</td></tr>
<tr><td><code id="rwish_+3A_s">S</code></td>
<td>
<p>Inverse scale matrix <code class="reqn">(p \times p)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean of a Wishart random variable with <code>v</code> degrees of freedom and
inverse scale matrix <code>S</code> is <code class="reqn">vS</code>.
</p>


<h3>Value</h3>

<p><code>rwish</code> generates one random draw from the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
draw &lt;- rwish(3, matrix(c(1,.3,.3,1),2,2))

## End(Not run)
</code></pre>

<hr>
<h2 id='sample_store'>Create a new list for storage samples in the pmwgs object</h2><span id='topic+sample_store'></span>

<h3>Description</h3>

<p>Create a new list for storage samples in the pmwgs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_store(par_names, subject_ids, iters = 1, stage = "init")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_store_+3A_par_names">par_names</code></td>
<td>
<p>The names of each parameter as a character vector</p>
</td></tr>
<tr><td><code id="sample_store_+3A_subject_ids">subject_ids</code></td>
<td>
<p>The unique ID of each subjects as a character vector</p>
</td></tr>
<tr><td><code id="sample_store_+3A_iters">iters</code></td>
<td>
<p>The number of iterations to be pre-allocated</p>
</td></tr>
<tr><td><code id="sample_store_+3A_stage">stage</code></td>
<td>
<p>The stage for which the samples will be created. Should be one
of <code>c("init", "burn", "adapt", "sample")</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the conditional mean and variances for this subject
</p>

<hr>
<h2 id='sampled_forstmann'>A sampled object of a model of the Forstmann dataset</h2><span id='topic+sampled_forstmann'></span>

<h3>Description</h3>

<p>A pmwgs object with a limited number of samples of the Forstmann dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampled_forstmann
</code></pre>


<h3>Format</h3>

<p>A pmwgs object minus the data. A pmwgs opbject is a list with a
specific structure and elements, as outlined below.
</p>

<dl>
<dt>par_names</dt><dd><p>A character vector containing the model parameter names</p>
</dd>
<dt>n_pars</dt><dd><p>The number of parameters in the model</p>
</dd>
<dt>n_subjects</dt><dd><p>The number of unique subject ID's in the data</p>
</dd>
<dt>subjects</dt><dd><p>A vector containing the unique subject ID's</p>
</dd>
<dt>prior</dt><dd><p>A list that holds the prior for <code>theta_mu</code> (the model
parameters). Contains the mean (<code>theta_mu_mean</code>), covariance matrix
(<code>theta_mu_var</code>) and inverse covariance matrix
(<code>theta_mu_invar</code>)</p>
</dd>
<dt>ll_func</dt><dd><p>The log likielihood function used by pmwg for model
estimation</p>
</dd>
<dt>samples</dt><dd><p>A list with defined structure containing the samples, see
the Samples Element section for more detail</p>
</dd>
</dl>



<h3>Details</h3>

<p>The pmwgs object is missing one aspect, the pmwgs$data element. In order
to fully replicate the full object (ie to run more sampling stages) you will
need to add the data back in, via sampled_forstmann$data &lt;- forstmann
</p>


<h3>Samples Element</h3>

<p>The samples element of a PMwG object contains the different types of samples
estimated by PMwG. These include the three main types of samples
<code>theta_mu</code>, <code>theta_sig</code> and <code>alpha</code> as well as a number of
other items which are detailed here.
</p>

<dl>
<dt>theta_mu</dt><dd><p>samples used for estimating the model parameters (group
level), an array of size (n_pars x n_samples)</p>
</dd>
<dt>theta_sig</dt><dd><p>samples used for estimating the parameter covariance
matrix, an array of size (n_pars x n_pars x n_samples)</p>
</dd>
<dt>alpha</dt><dd><p>samples used for estimating the subject random effects, an
array of size (n_pars x n_subjects x n_samples)</p>
</dd>
<dt>stage</dt><dd><p>A vector containing what PMwG stage each sample was drawn in</p>
</dd>
<dt>subj_ll</dt><dd><p>The winning particles log-likelihood for each subject and
sample</p>
</dd>
<dt>a_half</dt><dd><p>Mixing weights used during the Gibbs step when creating a
new sample for the covariance matrix</p>
</dd>
<dt>last_theta_sig_inv</dt><dd><p>The inverse of the last samples covariance
matrix</p>
</dd>
<dt>idx</dt><dd><p>The index of the last sample drawn</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.pnas.org/content/105/45/17538">https://www.pnas.org/content/105/45/17538</a>
</p>

<hr>
<h2 id='set_epsilon'>Set default values for epsilon</h2><span id='topic+set_epsilon'></span>

<h3>Description</h3>

<p>Takes the number of parameters and the epsilon arg value and sets a default
if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_epsilon(n_pars, epsilon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_epsilon_+3A_n_pars">n_pars</code></td>
<td>
<p>The number of parameters for the model</p>
</td></tr>
<tr><td><code id="set_epsilon_+3A_epsilon">epsilon</code></td>
<td>
<p>The value of epsilon set in the call to 'run_stage' or NULL.</p>
</td></tr>
</table>

<hr>
<h2 id='set_mix'>Set default values for mix</h2><span id='topic+set_mix'></span>

<h3>Description</h3>

<p>Takes the current stage and the mix arg value and sets a default if
necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_mix(stage, mix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_mix_+3A_stage">stage</code></td>
<td>
<p>The stage being run by the sampler.</p>
</td></tr>
<tr><td><code id="set_mix_+3A_mix">mix</code></td>
<td>
<p>The value of mix set in the call to 'run_stage' or NULL.</p>
</td></tr>
</table>

<hr>
<h2 id='set_proposal'>Setup the proposal distribution arguments (if in sample stage)</h2><span id='topic+set_proposal'></span>

<h3>Description</h3>

<p>Takes the current stage and the mix arg value and sets a default if
necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_proposal(i, stage, pmwgs, pdist_update_n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_proposal_+3A_i">i</code></td>
<td>
<p>The current iteration of the stage being run.</p>
</td></tr>
<tr><td><code id="set_proposal_+3A_stage">stage</code></td>
<td>
<p>The stage being run by the sampler.</p>
</td></tr>
<tr><td><code id="set_proposal_+3A_pmwgs">pmwgs</code></td>
<td>
<p>The pmwgs object from which to attempt to create the proposal
distribution</p>
</td></tr>
<tr><td><code id="set_proposal_+3A_pdist_update_n">pdist_update_n</code></td>
<td>
<p>The number of iterations to run before recomputing the
proposal distribution (NA to never update or for burnin/adaptation stages)</p>
</td></tr>
</table>

<hr>
<h2 id='test_sampler_adapted'>Test that the sampler has successfully adapted</h2><span id='topic+test_sampler_adapted'></span>

<h3>Description</h3>

<p>Test that the sampler has successfully adapted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_sampler_adapted(pmwgs, n_unique, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_sampler_adapted_+3A_pmwgs">pmwgs</code></td>
<td>
<p>The full pmwgs object with all samples</p>
</td></tr>
<tr><td><code id="test_sampler_adapted_+3A_n_unique">n_unique</code></td>
<td>
<p>The number of unique samples to look for in random effects
for each subject.</p>
</td></tr>
<tr><td><code id="test_sampler_adapted_+3A_i">i</code></td>
<td>
<p>The number for the current iteration of the sampler</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a string representing successful/unsuccessful
adaptation and an optional message. The string representing the success
or failure can be one of c(&quot;success&quot;, &quot;continue&quot;, &quot;increase&quot;)
</p>

<hr>
<h2 id='trim_na'>Trim the unneeded NA values from the end of the sampler</h2><span id='topic+trim_na'></span>

<h3>Description</h3>

<p>Trim the unneeded NA values from the end of the sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_na(sampler)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_na_+3A_sampler">sampler</code></td>
<td>
<p>The pmwgs object that we are adding the new samples to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pmwgs object without NA values added during extend_sampler
</p>

<hr>
<h2 id='unwind'>Unwinds variance matrix to a vector</h2><span id='topic+unwind'></span>

<h3>Description</h3>

<p>Takes a variance matrix and unwind to a vector via Cholesky decomposition
then take the log of the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unwind(var_matrix, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unwind_+3A_var_matrix">var_matrix</code></td>
<td>
<p>A variance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unwound matrix as a vector
</p>

<hr>
<h2 id='update_epsilon'>Update the subject specific scaling parameters (epsilon)</h2><span id='topic+update_epsilon'></span>

<h3>Description</h3>

<p>Update the subject specific scaling parameter according to procedures
outlined in  P. H. Garthwaite, Y. Fan &amp; S. A. Sisson (2016) Adaptive optimal
scaling of MetropolisHastings algorithms using the RobbinsMonro process,
Communications in Statistics - Theory and Methods, 45:17, 5098-5111,
DOI: 10.1080/03610926.2014.936562
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_epsilon(epsilon, acc, p, i, d, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_epsilon_+3A_epsilon">epsilon</code></td>
<td>
<p>The scaling parameter for all subjects</p>
</td></tr>
<tr><td><code id="update_epsilon_+3A_acc">acc</code></td>
<td>
<p>A boolean vector, TRUE if current sample != last sample</p>
</td></tr>
<tr><td><code id="update_epsilon_+3A_p">p</code></td>
<td>
<p>The target sample acceptance rate (0-1)</p>
</td></tr>
<tr><td><code id="update_epsilon_+3A_i">i</code></td>
<td>
<p>The current iteration for sampling</p>
</td></tr>
<tr><td><code id="update_epsilon_+3A_d">d</code></td>
<td>
<p>The number of parameters for the model</p>
</td></tr>
<tr><td><code id="update_epsilon_+3A_alpha">alpha</code></td>
<td>
<p>A hyperparameter for the epsilon tuning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the new subject specific epsilon values
</p>

<hr>
<h2 id='update_progress_bar'>A function that updates the accept_progress_bar with progress and accept rate</h2><span id='topic+update_progress_bar'></span>

<h3>Description</h3>

<p>A function that updates the accept_progress_bar with progress and accept rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_progress_bar(pb, value, extra = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_progress_bar_+3A_pb">pb</code></td>
<td>
<p>The progress bar object</p>
</td></tr>
<tr><td><code id="update_progress_bar_+3A_value">value</code></td>
<td>
<p>The value to set the bar width to</p>
</td></tr>
<tr><td><code id="update_progress_bar_+3A_extra">extra</code></td>
<td>
<p>A value that represents the number of accepted particles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The old value that was present before updating
</p>

<hr>
<h2 id='wind'>Winds a variance vector back to a vector</h2><span id='topic+wind'></span>

<h3>Description</h3>

<p>The reverse of the unwind function, takes a variance vector and windows back
into matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wind(var_vector, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wind_+3A_var_vector">var_vector</code></td>
<td>
<p>A variance vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The wound vector as a matrix
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
