<!DOCTYPE html><html><head><title>Help for package paleoTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {paleoTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.paleoTS'><p>Make a Paleontological Time-series object</p></a></li>
<li><a href='#as.paleoTSfit'><p>Create a <code>paleoTSfit</code> object</p></a></li>
<li><a href='#bootSimpleComplex'><p>Bootstrap test to see if a complex model is significantly better than a simple</p>
model.</a></li>
<li><a href='#cantius_L'><p>Time-series of the length of lower first molar for the Cantius lineage</p></a></li>
<li><a href='#compareModels'><p>Compare model fits for a paleontological time-series</p></a></li>
<li><a href='#dorsal.spines'><p>Time-series of dorsal spine data from a fossil stickleback lineage</p></a></li>
<li><a href='#ESD'><p>Compute Expected Squared Divergence (ESD) for Evolutionary Models</p></a></li>
<li><a href='#fit.sgs'><p>Fit a model of trait evolution with a protracted punctuation.</p></a></li>
<li><a href='#fit3models'><p>Fit a set of standard evolutionary models</p></a></li>
<li><a href='#fit9models'><p>Fit large set of models to a time-series</p></a></li>
<li><a href='#fitGpunc'><p>Fit trait evolution model with punctuations estimated from the data</p></a></li>
<li><a href='#fitModeShift'><p>Fit model in which the mode of trait evolution shifts once</p></a></li>
<li><a href='#fitMult'><p>Fit the same simple model across multiple time-series</p></a></li>
<li><a href='#fitSimple'><p>Fit simple models of trait evolution</p></a></li>
<li><a href='#IC'><p>Compute Information Criteria</p></a></li>
<li><a href='#ln.paleoTS'><p>Approximate log-transformation of time-series data</p></a></li>
<li><a href='#LRI'><p>Log-rate, Log-interval (LRI) method of Gingerich</p></a></li>
<li><a href='#lynchD'><p>Compute Lynch's Delta rate metric</p></a></li>
<li><a href='#mle.GRW'><p>Analytical ML estimator for random walk and stasis models</p></a></li>
<li><a href='#opt.covTrack'><p>Fit a model in which a trait tracks a covariate</p></a></li>
<li><a href='#opt.GRW'><p>Fit evolutionary model using &quot;AD&quot; parameterization</p></a></li>
<li><a href='#opt.GRW.shift'><p>Fit random walk model with shift(s) in generating parameters</p></a></li>
<li><a href='#opt.joint.GRW'><p>Fit evolutionary models using the &quot;Joint&quot; parameterization</p></a></li>
<li><a href='#opt.joint.OU'><p>Fit Ornstein-Uhlenbeck model using the &quot;Joint&quot; parameterization</p></a></li>
<li><a href='#opt.punc'><p>Fit a model of trait evolution with specified punctuation(s)</p></a></li>
<li><a href='#plot.paleoTS'><p>Plot a paleoTS object</p></a></li>
<li><a href='#pool.var'><p>Compute a pooled variance</p></a></li>
<li><a href='#read.paleoTS'><p>Read a text-file with data from a paleontological time-series</p></a></li>
<li><a href='#sim.covTrack'><p>Simulate trait evolution that tracks a covariate</p></a></li>
<li><a href='#sim.GRW'><p>Simulate random walk or directional time-series for trait evolution</p></a></li>
<li><a href='#sim.GRW.shift'><p>Simulate (general) random walk with shift(s) in generating parameters</p></a></li>
<li><a href='#sim.OU'><p>Simulate an Ornstein-Uhlenbeck time-series</p></a></li>
<li><a href='#sim.punc'><p>Simulate a punctuated time-series</p></a></li>
<li><a href='#sim.sgs'><p>Simulate protracted punctuation</p></a></li>
<li><a href='#sim.Stasis'><p>Simulate Stasis time-series for trait evolution</p></a></li>
<li><a href='#sim.Stasis.RW'><p>Simulate trait evolution with a mode shift</p></a></li>
<li><a href='#std.paleoTS'><p>Convert time-series to standard deviation units</p></a></li>
<li><a href='#sub.paleoTS'><p>Subsample a paleontological time-series</p></a></li>
<li><a href='#test.var.het'><p>Test for heterogeneity of variances among samples in a time-series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analyze Paleontological Time-Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates analysis of paleontological sequences of trait values.  
    Functions are provided to fit, using maximum likelihood, simple 
    evolutionary models (including unbiased random walks, directional 
    evolution,stasis, Ornstein-Uhlenbeck, covariate-tracking) and 
    complex models (punctuation, mode shifts).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>mnormt, foreach, parallel, doParallel</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-08 18:49:24 UTC; hunte</td>
</tr>
<tr>
<td>Author:</td>
<td>Gene Hunt [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gene Hunt &lt;hunte@si.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-08 19:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.paleoTS'>Make a Paleontological Time-series object</h2><span id='topic+as.paleoTS'></span>

<h3>Description</h3>

<p>Combines information into an object of class <code>paleoTS</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.paleoTS(
  mm,
  vv,
  nn,
  tt,
  MM = NULL,
  genpars = NULL,
  label = NULL,
  start.age = NULL,
  oldest = c("first", "last"),
  reset.time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.paleoTS_+3A_mm">mm</code></td>
<td>
<p>vector of sample means</p>
</td></tr>
<tr><td><code id="as.paleoTS_+3A_vv">vv</code></td>
<td>
<p>vector of sample variances</p>
</td></tr>
<tr><td><code id="as.paleoTS_+3A_nn">nn</code></td>
<td>
<p>vector of sample sizes</p>
</td></tr>
<tr><td><code id="as.paleoTS_+3A_tt">tt</code></td>
<td>
<p>vector of sample ages</p>
</td></tr>
<tr><td><code id="as.paleoTS_+3A_mm">MM</code></td>
<td>
<p>vector of true means (simulated data)</p>
</td></tr>
<tr><td><code id="as.paleoTS_+3A_genpars">genpars</code></td>
<td>
<p>generating parameters (simulated data)</p>
</td></tr>
<tr><td><code id="as.paleoTS_+3A_label">label</code></td>
<td>
<p>optional, label for time-series</p>
</td></tr>
<tr><td><code id="as.paleoTS_+3A_start.age">start.age</code></td>
<td>
<p>optional, age of oldest sample</p>
</td></tr>
<tr><td><code id="as.paleoTS_+3A_oldest">oldest</code></td>
<td>
<p>value indicating if the oldest sample is first or last in the
sequence</p>
</td></tr>
<tr><td><code id="as.paleoTS_+3A_reset.time">reset.time</code></td>
<td>
<p>logical; if TRUE, then change time scale to start at t=0
and adjust <code>start.age</code> accordingly</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines data into a <code>paleoTS</code> object. For
empirical data it may be more convenient to use <code>read.paleoTS</code>. <br /><br />
If sample ages decrease through the sequence, as if given in millions of
years ago, <code>tt</code> will automatically be converted to time elapsed from
the beginning of the sequence as long as <code>reset.time</code> = TRUE.
</p>


<h3>Value</h3>

<p>a <code>paleoTS</code> object
</p>


<h3>Note</h3>

<p>All model-fitting functions estimate the contribution of sampling
noise to the observed differences between samples.  They do this assuming
that the trait is represented by sample means, which have sampling
variances equal to variance divided by sample size, <code>vv/nn</code>.  If one
is interested in analyzing statistics other than the sample mean (medians,
quantiles, or other statistics), use the the following procedure: set the
statistic in question as the <code>mm</code> values, replace <code>vv</code> with a
vector of the squared standard errors for each estimate (generated by other
means, for example bootstrapping), and set all values of <code>nn</code> to one.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.paleoTS">read.paleoTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.paleoTS(mm = rnorm(20), vv = rep(1, 20), nn = rep(25, 20), tt=1:20)
plot(x) # easier to use sim.Stasis()
</code></pre>

<hr>
<h2 id='as.paleoTSfit'>Create a <code>paleoTSfit</code> object</h2><span id='topic+as.paleoTSfit'></span>

<h3>Description</h3>

<p>Create a <code>paleoTSfit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.paleoTSfit(logL, parameters, modelName, method, K, n, se)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.paleoTSfit_+3A_logl">logL</code></td>
<td>
<p>model log-likelihood</p>
</td></tr>
<tr><td><code id="as.paleoTSfit_+3A_parameters">parameters</code></td>
<td>
<p>model parameter estimates</p>
</td></tr>
<tr><td><code id="as.paleoTSfit_+3A_modelname">modelName</code></td>
<td>
<p>model name</p>
</td></tr>
<tr><td><code id="as.paleoTSfit_+3A_method">method</code></td>
<td>
<p>parameterization, either &quot;AD&quot; or &quot;Joint&quot;</p>
</td></tr>
<tr><td><code id="as.paleoTSfit_+3A_k">K</code></td>
<td>
<p>number of model parameters</p>
</td></tr>
<tr><td><code id="as.paleoTSfit_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="as.paleoTSfit_+3A_se">se</code></td>
<td>
<p>standard errors of parameter estimates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>paleoTSfit</code> object
</p>


<h3>Note</h3>

<p>All model-fitting functions use this function to package the resulting
data-model fits. Users will not need to call this function.
</p>

<hr>
<h2 id='bootSimpleComplex'>Bootstrap test to see if a complex model is significantly better than a simple
model.</h2><span id='topic+bootSimpleComplex'></span>

<h3>Description</h3>

<p>Bootstrap test to see if a complex model is significantly better than a simple
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootSimpleComplex(
  y,
  simpleFit,
  complexFit,
  nboot = 99,
  minb = 7,
  ret.full.distribution = FALSE,
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootSimpleComplex_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="bootSimpleComplex_+3A_simplefit">simpleFit</code></td>
<td>
<p>a <code>paleoTSfit</code> object, representing the model fit of a
simple model</p>
</td></tr>
<tr><td><code id="bootSimpleComplex_+3A_complexfit">complexFit</code></td>
<td>
<p>a <code>paleoTSfit</code> object, representing the model fit of a
complex model</p>
</td></tr>
<tr><td><code id="bootSimpleComplex_+3A_nboot">nboot</code></td>
<td>
<p>number of replications for parametric bootstrapping</p>
</td></tr>
<tr><td><code id="bootSimpleComplex_+3A_minb">minb</code></td>
<td>
<p>minimum number of populations within each segment</p>
</td></tr>
<tr><td><code id="bootSimpleComplex_+3A_ret.full.distribution">ret.full.distribution</code></td>
<td>
<p>logical, indicating if the null distribution for
the likelihood ratio from the parametric bootstrap should be returned</p>
</td></tr>
<tr><td><code id="bootSimpleComplex_+3A_parallel">parallel</code></td>
<td>
<p>logical, if TRUE, the bootstrapping is done using parallel
computing</p>
</td></tr>
<tr><td><code id="bootSimpleComplex_+3A_...">...</code></td>
<td>
<p>further arguments, passed to optimization functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulations suggest that AICc can be overly liberal with complex
models with mode shifts or punctuations (Hunt et al., 2015). This function
implements an alternative of parametric bootstrapping to compare the fit of a
simple model with a complex model. It proceeds in five steps: </p>

<ol>
<li><p> Compute the observed gain in support from the simple to complex model
as the likelihood ratio, <code class="reqn">LR_obs = -2(logL_simple - logL_complex) </code> </p>
</li>
<li>
<p>Simulate trait evolution under the specified simple model <code>nboot</code> times
</p>
</li>
<li><p> Fit to each simulated sequence the specified simple and complex models
</p>
</li>
<li><p> Measure the gain in support from simple to complex as the bootstrap
likelihood ratio for each simulated sequence </p>
</li>
<li><p> Compute the P-value as the
percentile of the bootstrap distribution corresponding to the observed LR. </p>
</li></ol>

<p>Argument <code>simpleFit</code> should be a <code>paleoTS</code> object returned by the
function <code>fitSimple</code> or similar functions (e.g., <code>opt.joint.GRW,
opt.GRW</code>, etc.). Argument <code>complexFit</code> must be a <code>paleoTS</code> object
returned by <code>fitGpunc</code> or <code>fitModeShift</code>.
</p>
<p>Calculations can be sped up by setting <code>parallel = TRUE</code>, which uses
functions from the <code><a href="doParallel.html#topic+doParallel">doParallel</a></code> package to run the bootstrap
replicates in parallel, using one fewer than the number of detected cores.
</p>


<h3>Value</h3>

<p>A list of the observed likelihood ratio statistic, <code>LRobs</code>, the
P-value of the test, and the number of bootstrap replicates. If
<code>ret.full.distribution = TRUE</code>, the null distribution of likelihood
ratios generated by parametric bootstrapping is also returned.
</p>


<h3>References</h3>

<p>Hunt, G., M. J. Hopkins and S. Lidgard. 2015. Simple versus
complex models of trait evolution and stasis as a response to environmental
change. PNAS 112(16): 4885-4890.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.Stasis.RW">sim.Stasis.RW</a></code>, <code><a href="#topic+fitModeShift">fitModeShift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- sim.Stasis.RW(ns = c(15, 15), omega = 0.5, ms = 1, order = "Stasis-RW")
ws &lt;- fitSimple(x)
wc &lt;- fitModeShift(x, order = "Stasis-RW", rw.model = "GRW")
bootSimpleComplex(x, ws, wc, nboot = 50, minb = 7)  # nboot too low for real analysis!

## End(Not run)
</code></pre>

<hr>
<h2 id='cantius_L'>Time-series of the length of lower first molar for the Cantius lineage</h2><span id='topic+cantius_L'></span>

<h3>Description</h3>

<p>Time-series of the length of lower first molar for the Cantius lineage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cantius_L
</code></pre>


<h3>Format</h3>

<p>a <code>paleoTS</code> object with the data
</p>


<h3>Source</h3>

<p>Clyde, W. C. and P. D. Gingerich (1994). Rates of evolution
in the dentition of early Eocene Cantius: comparison of size and shape.
<em>Paleobiology</em> 20(4): 506-522.
</p>

<hr>
<h2 id='compareModels'>Compare model fits for a paleontological time-series</h2><span id='topic+compareModels'></span>

<h3>Description</h3>

<p>Takes output from model-fitting functions and compiles model-fit
information (log-likelihood, AICc, etc.) into a convenient table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareModels(..., silent = FALSE, sort = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareModels_+3A_...">...</code></td>
<td>
<p>any number of model fit (<code>as.paleoTSfit</code>) objects</p>
</td></tr>
<tr><td><code id="compareModels_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code>, suppresses printing</p>
</td></tr>
<tr><td><code id="compareModels_+3A_sort">sort</code></td>
<td>
<p>if <code>TRUE</code>, the table sorts models from best to worst</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>silent = FALSE</code>, the table is printed and nothing is
returned. If  <code>silent = TRUE</code>, printing is suppressed and a list of
two objects is returned: the table of model fits, <code>modelFits</code>, and a
list of parameter estimates, <code>pl</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.GRW(ns = 40, ms = 0.5, vs = 0.1)
m1 &lt;- fitSimple(x, model = "GRW")  # the true model
m2 &lt;- fitSimple(x, model = "URW")
plot(x, modelFit = m1)
compareModels(m1, m2)
</code></pre>

<hr>
<h2 id='dorsal.spines'>Time-series of dorsal spine data from a fossil stickleback lineage</h2><span id='topic+dorsal.spines'></span>

<h3>Description</h3>

<p>Time-series of dorsal spine data from a fossil stickleback lineage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dorsal.spines
</code></pre>


<h3>Format</h3>

<p>a <code>paleoTS</code> object of the mean number of dorsal spines (log-transformed)
</p>


<h3>Source</h3>

<p>Bell, M.A., M.P. Travis and D.M. Blouw 2006. Inferring natural
selection in a fossil threespine stickleback. <em>Paleobiology</em> <b> 32</b>:562-577. <br /> <br />
Hunt, G., M. A. Bell and M. P. Travis (2008). Evolution toward a new adaptive optimum:
phenotypic evolution in a fossil stickleback lineage. <em>Evolution</em> 62(3): 700-710.
</p>

<hr>
<h2 id='ESD'>Compute Expected Squared Divergence (ESD) for Evolutionary Models</h2><span id='topic+ESD'></span>

<h3>Description</h3>

<p>Computes for a specified model and duration of time the
expected squared divergence (ESD), which is a useful measure of the
magnitude or rate of change across different models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ESD(
  y,
  dt,
  model = c("GRW", "URW", "Stasis", "allThree"),
  method = c("Joint", "AD"),
  pool = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ESD_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="ESD_+3A_dt">dt</code></td>
<td>
<p>the time interval to evaluate ESD</p>
</td></tr>
<tr><td><code id="ESD_+3A_model">model</code></td>
<td>
<p>the model of evolution to assume; see Details</p>
</td></tr>
<tr><td><code id="ESD_+3A_method">method</code></td>
<td>
<p>Joint or AD parameterization</p>
</td></tr>
<tr><td><code id="ESD_+3A_pool">pool</code></td>
<td>
<p>logical, if TRUE, variances are averaged (pooled) across samples</p>
</td></tr>
<tr><td><code id="ESD_+3A_...">...</code></td>
<td>
<p>other arguments to the model-fitting functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hunt (2012) argued that rate metrics make sense only in the context
of specific models of evolution.  It is thus difficult to meaningfully
compare rates across sequences generated by different evolutionary
processes.  ESD values can be used for a specified model and duration as a
comparable measure of the amount of evolutionary change that is expected.
Acceptable values for the model argument can be &quot;GRW&quot; for the general
random walk (directional change), &quot;URW&quot; for the unbiased random walk, and
&quot;Stasis.&quot;  In addition, one can also specify &quot;allThree&quot;, in which case all
these models will be fit and the resulting ESD will be the weighted average
of them, using model support (Akaike weights) for the weighting (see Hunt
[2012], p. 370)
</p>


<h3>Value</h3>

<p>the ESD value
</p>


<h3>References</h3>

<p>Hunt, G. 2012. Measuring rates of phenotypic evolution and the
inseparability of tempo and mode. <em>Paleobiology</em> 38:351–373.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x&lt;- sim.GRW(ns=20)
  esd.urw&lt;- ESD(x, dt=10, model="URW")
  esd.all&lt;- ESD(x, dt=10, model="allThree")
</code></pre>

<hr>
<h2 id='fit.sgs'>Fit a model of trait evolution with a protracted punctuation.</h2><span id='topic+fit.sgs'></span>

<h3>Description</h3>

<p>This function fits a model of punctuated change that is is protracted enough that
it is captured by multiple transitional populations.  Trait evolution starts in stasis,
shifts to a general random walk, and then shifts back into stasis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.sgs(
  y,
  minb = 7,
  oshare = TRUE,
  pool = TRUE,
  silent = FALSE,
  hess = FALSE,
  meth = "L-BFGS-B",
  model = "GRW"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.sgs_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="fit.sgs_+3A_minb">minb</code></td>
<td>
<p>minimum number of populations within each segment</p>
</td></tr>
<tr><td><code id="fit.sgs_+3A_oshare">oshare</code></td>
<td>
<p>logical, if TRUE, variance assumed to be shared (equal) across segments</p>
</td></tr>
<tr><td><code id="fit.sgs_+3A_pool">pool</code></td>
<td>
<p>if TRUE, sample variances are substituted with their pooled estimate</p>
</td></tr>
<tr><td><code id="fit.sgs_+3A_silent">silent</code></td>
<td>
<p>logical, if TRUE, progress updates are suppressed</p>
</td></tr>
<tr><td><code id="fit.sgs_+3A_hess">hess</code></td>
<td>
<p>if TRUE, standard errors computed from the Hessian matrix are returned</p>
</td></tr>
<tr><td><code id="fit.sgs_+3A_meth">meth</code></td>
<td>
<p>optimization method, passes to <code>optim</code></p>
</td></tr>
<tr><td><code id="fit.sgs_+3A_model">model</code></td>
<td>
<p>type of random walk: <code>"URW"</code>, unbiased random walk, or <code>"GRW"</code>,
a general (directional) random walk</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>paleoTSfit</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitGpunc">fitGpunc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- sim.sgs(ns = c(15, 15, 15))  # default values OK
w &lt;- fit.sgs(x, minb = 10)  # increase minb so example takes less time; not recommended!
plot(x)
abline(v = c(16, 31), lwd = 3)  # actual shifts
abline(v = c(w$parameters[6:7]), lwd = 2, lty = 3, col = "red")  # inferred shifts

## End(Not run)
</code></pre>

<hr>
<h2 id='fit3models'>Fit a set of standard evolutionary models</h2><span id='topic+fit3models'></span><span id='topic+fit4models'></span>

<h3>Description</h3>

<p>Fit a set of standard evolutionary models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit3models(y, silent = FALSE, method = c("Joint", "AD"), ...)

fit4models(y, silent = FALSE, method = c("Joint", "AD"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit3models_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="fit3models_+3A_silent">silent</code></td>
<td>
<p>if TRUE, results are returned as a list and not printed</p>
</td></tr>
<tr><td><code id="fit3models_+3A_method">method</code></td>
<td>
<p>&quot;Joint&quot; or &quot;AD&quot;, see <code><a href="#topic+fitSimple">fitSimple</a></code></p>
</td></tr>
<tr><td><code id="fit3models_+3A_...">...</code></td>
<td>
<p>other arguments passed to model fitting functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>fit3models</code> fits the general (biased) random walk (GRW),
unbiased random walk (URW), and Stasis models.  In addition to these three,
<code>fit4models</code> also fits the model of Strict Stasis.
</p>


<h3>Value</h3>

<p>if silent = FALSE, a table of model fit statistics, also printed to the
screen.  if silent = TRUE, a list of the model fit statistics and model parameter values.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fit4models()</code>: add model of &quot;Strict Stasis&quot; to the three models
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+fitSimple">fitSimple</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.GRW(ns = 50, ms = 0.2)
fit4models(x)
</code></pre>

<hr>
<h2 id='fit9models'>Fit large set of models to a time-series</h2><span id='topic+fit9models'></span>

<h3>Description</h3>

<p>This function fits nine models to a time-series following Hunt et al. (2015). These
include the simple models fit by <code>fit4models</code> along with mode shift and
punctuation models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit9models(y, silent = FALSE, method = c("Joint", "AD"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit9models_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="fit9models_+3A_silent">silent</code></td>
<td>
<p>logical, if TRUE, progress updates are suppressed</p>
</td></tr>
<tr><td><code id="fit9models_+3A_method">method</code></td>
<td>
<p>parameterization to use: <code>Joint</code> or <code>AD</code>; see Details</p>
</td></tr>
<tr><td><code id="fit9models_+3A_...">...</code></td>
<td>
<p>other arguments, passed to optimization functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if silent = FALSE, a table of model fit statistics, also printed to the
screen.  if silent = TRUE, a list of the model fit statistics and model parameter values.
</p>


<h3>References</h3>

<p>Hunt, G., M. J. Hopkins and S. Lidgard. 2015. Simple versus complex models of trait evolution
and stasis as a response to environmental change. PNAS 112(16): 4885-4890.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- sim.Stasis.RW(ns = c(15, 15), omega = 0.5, ms = 1, order = "Stasis-RW")
plot(x)
fit9models(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitGpunc'>Fit trait evolution model with punctuations estimated from the data</h2><span id='topic+fitGpunc'></span>

<h3>Description</h3>

<p>Fit trait evolution model with punctuations estimated from the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGpunc(
  y,
  ng = 2,
  minb = 7,
  pool = TRUE,
  oshare = TRUE,
  method = c("Joint", "AD"),
  silent = FALSE,
  hess = FALSE,
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitGpunc_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="fitGpunc_+3A_ng">ng</code></td>
<td>
<p>number of groups (segments) in the sequence</p>
</td></tr>
<tr><td><code id="fitGpunc_+3A_minb">minb</code></td>
<td>
<p>minimum number of populations within each segment</p>
</td></tr>
<tr><td><code id="fitGpunc_+3A_pool">pool</code></td>
<td>
<p>if TRUE, sample variances are substituted with their pooled estimate</p>
</td></tr>
<tr><td><code id="fitGpunc_+3A_oshare">oshare</code></td>
<td>
<p>logical, if TRUE, variance assumed to be shared (equal) across segments</p>
</td></tr>
<tr><td><code id="fitGpunc_+3A_method">method</code></td>
<td>
<p>parameterization to use: <code>Joint</code> or <code>AD</code>; see Details</p>
</td></tr>
<tr><td><code id="fitGpunc_+3A_silent">silent</code></td>
<td>
<p>logical, if TRUE, progress updates are suppressed</p>
</td></tr>
<tr><td><code id="fitGpunc_+3A_hess">hess</code></td>
<td>
<p>if TRUE, standard errors computed from the Hessian matrix are returned</p>
</td></tr>
<tr><td><code id="fitGpunc_+3A_parallel">parallel</code></td>
<td>
<p>logical, if TRUE, the analysis is done in parallel</p>
</td></tr>
<tr><td><code id="fitGpunc_+3A_...">...</code></td>
<td>
<p>other arguments, passed to optimization functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests all possible shift points for punctuations, subject to the
constraint that the number of populations in each segment is always &gt;= <code>minb</code>. The
shiftpoint yielding the highest log-likelihood is returned as the solution, along with
the log-likelihoods (<code>all.logl</code>) of all tested shift points (<code>GG</code>). <br /> <br />
</p>
<p>The function uses <code>opt.punc</code> (if <code>method = "AD"</code>) or <code>opt.joint.punc</code>
(if <code>method = "Joint"</code>) to do the fitting.
</p>


<h3>Value</h3>

<p>a <code>paleoTSfit</code> object with the results of the model-fitting.
</p>


<h3>Note</h3>

<p>Calculations can be sped up by setting <code>parallel = TRUE</code>, which uses functions from
the <code><a href="doParallel.html#topic+doParallel">doParallel</a></code> package to run the bootstrap replicates in parallel, using
one fewer than the number of detected cores.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit9models">fit9models</a></code>, <code><a href="#topic+sim.punc">sim.punc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.punc(ns = c(15, 15), theta = c(0,3), omega = c(0.1, 0.1))
w.punc &lt;- fitGpunc(x, oshare = TRUE)
plot(x, modelFit = w.punc)
</code></pre>

<hr>
<h2 id='fitModeShift'>Fit model in which the mode of trait evolution shifts once</h2><span id='topic+fitModeShift'></span>

<h3>Description</h3>

<p>Trait evolution is modeled as a shift from a random walk (general or unbiased) to stasis, or
vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitModeShift(
  y,
  minb = 7,
  pool = TRUE,
  order = c("Stasis-RW", "RW-Stasis"),
  rw.model = c("URW", "GRW"),
  method = c("Joint", "AD"),
  silent = FALSE,
  hess = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitModeShift_+3A_y">y</code></td>
<td>
<p><code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="fitModeShift_+3A_minb">minb</code></td>
<td>
<p>minimum number of populations within each segment</p>
</td></tr>
<tr><td><code id="fitModeShift_+3A_pool">pool</code></td>
<td>
<p>if TRUE, sample variances are substituted with their pooled estimate</p>
</td></tr>
<tr><td><code id="fitModeShift_+3A_order">order</code></td>
<td>
<p>whether stasis or random walk come first, one of <code>Stasis-RW</code> or
<code>RW-Stasis</code></p>
</td></tr>
<tr><td><code id="fitModeShift_+3A_rw.model">rw.model</code></td>
<td>
<p>whether the random walk segment is an unbiased random walk, <code>URW</code>
or a general random walk, <code>GRW</code></p>
</td></tr>
<tr><td><code id="fitModeShift_+3A_method">method</code></td>
<td>
<p>parameterization to use: <code>Joint</code> or <code>AD</code></p>
</td></tr>
<tr><td><code id="fitModeShift_+3A_silent">silent</code></td>
<td>
<p>logical, if TRUE, progress updates are suppressed</p>
</td></tr>
<tr><td><code id="fitModeShift_+3A_hess">hess</code></td>
<td>
<p>if TRUE, standard errors computed from the Hessian matrix are returned</p>
</td></tr>
<tr><td><code id="fitModeShift_+3A_...">...</code></td>
<td>
<p>other arguments, passed to optimization functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>paleoTSfit</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.Stasis.RW">sim.Stasis.RW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.Stasis.RW(ns = c(15, 15), omega = 0.5, ms = 1, order = "Stasis-RW")
plot(x)
w &lt;- fitModeShift(x, order = "Stasis-RW", rw.model = "GRW")
abline(v = x$tt[15], lwd = 3)  # actual shift point
abline(v = x$tt[w$par["shift1"]], lty = 3, lwd = 2, col = "red") # inferred shift

</code></pre>

<hr>
<h2 id='fitMult'>Fit the same simple model across multiple time-series</h2><span id='topic+fitMult'></span>

<h3>Description</h3>

<p>Fit the same simple model across multiple time-series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitMult(
  yl,
  model = c("GRW", "URW", "Stasis", "covTrack"),
  method = c("Joint", "AD"),
  pool = TRUE,
  zl = NULL,
  hess = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitMult_+3A_yl">yl</code></td>
<td>
<p>a list of <code>paleoTS</code> objects</p>
</td></tr>
<tr><td><code id="fitMult_+3A_model">model</code></td>
<td>
<p>the model to fit; see Details</p>
</td></tr>
<tr><td><code id="fitMult_+3A_method">method</code></td>
<td>
<p>parameterization to use: <code>Joint</code> or <code>AD</code></p>
</td></tr>
<tr><td><code id="fitMult_+3A_pool">pool</code></td>
<td>
<p>if TRUE, sample variances are substituted with their pooled
estimate</p>
</td></tr>
<tr><td><code id="fitMult_+3A_zl">zl</code></td>
<td>
<p>for the <code>covTrack</code> model only, a list of covariate vectors,
one each <code>paleoTS</code> object in <code>yl</code></p>
</td></tr>
<tr><td><code id="fitMult_+3A_hess">hess</code></td>
<td>
<p>if TRUE, standard errors computed from the Hessian matrix are
returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a model with shared parameters across multiple
trait time-series. The most likely application would be to model a common
evolutionary dynamic across different sequences, perhaps representing
time-series of the same trait and lineage from different localities or time
intervals.
</p>
<p>Four simple models are currently implemented: </p>

<ul>
<li> <p><strong>GRW</strong>:
parameters <code>mstep</code> and <code>vstep</code> of the general random walk are
shared across sequences.
</p>
</li>
<li> <p><strong>URW</strong>: parameter <code>vstep</code> of the
unbiased random walk is shared across sequences.
</p>
</li>
<li> <p><strong>Stasis</strong>:
parameter <code>omega</code> of stasis is shared across sequences.
</p>
</li>
<li>
<p><strong>covTrack</strong>: parameters <code>b0</code>, <code>b1</code>,  and <code>evar</code> of the
covariate-tracking model are shared across sequences. </p>
</li></ul>

<p>Under the joint parameterization, <code>method = "Joint"</code>, an additional parameter, <code>anc</code> is
fit, representing the ancestral (starting) trait value. This parameter is estimated separately
in each sequence so it is not assumed that they all start at the same trait value.
</p>


<h3>Value</h3>

<p>a <code>paleoTSfit</code> object with the results of the model-fitting
</p>


<h3>Note</h3>

<p>The models are described in the help for <code>fitSimple</code> and the functions
linked from there.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitSimple">fitSimple</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- sim.GRW(ms = 1, vs = 0.2)
x2 &lt;- sim.GRW(ms = 1, vs = 0.2)
fitMult(list(x1, x2), model = "GRW")
</code></pre>

<hr>
<h2 id='fitSimple'>Fit simple models of trait evolution</h2><span id='topic+fitSimple'></span>

<h3>Description</h3>

<p>Fit simple models of trait evolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitSimple(
  y,
  model = c("GRW", "URW", "Stasis", "StrictStasis", "OU", "covTrack"),
  method = c("Joint", "AD"),
  pool = TRUE,
  z = NULL,
  hess = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitSimple_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="fitSimple_+3A_model">model</code></td>
<td>
<p>the model to be fit, one of <code>"GRW", "URW", "Stasis", "OU",
"covTrack"</code></p>
</td></tr>
<tr><td><code id="fitSimple_+3A_method">method</code></td>
<td>
<p>parameterization to use: <code>Joint</code> or <code>AD</code>; see Details</p>
</td></tr>
<tr><td><code id="fitSimple_+3A_pool">pool</code></td>
<td>
<p>if TRUE, sample variances are substituted with their pooled
estimate</p>
</td></tr>
<tr><td><code id="fitSimple_+3A_z">z</code></td>
<td>
<p>a vector of a covariate, used only for the &quot;covTrack&quot; model</p>
</td></tr>
<tr><td><code id="fitSimple_+3A_hess">hess</code></td>
<td>
<p>if TRUE, standard errors computed from the Hessian matrix are
returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function that calls the specific individual
functions for each model and parameterization, such as <code>opt.GRW</code> and
<code>opt.joint.GRW</code>. The models that this function can fit are:
</p>

<ul>
<li>  <p><strong>GRW</strong>: General Random Walk. Under this model, evolutionary
changes, or &quot;steps&quot; are drawn from a distribution with a mean of <code>mstep</code>
and variance of <code>vstep</code>.  <code>mstep</code> determines directionality and
<code>vstep</code> determines volatility (Hunt, 2006).
</p>
</li>
<li>  <p><strong>URW</strong>:
Unbiased Random Walk. Same as GRW with <code>mstep</code> = 0, and thus evolution
is non-directional. For a URW, <code>vstep</code> is the rate parameter.
</p>
</li>
<li> <p><strong>Stasis</strong>: This parameterization follows Sheets &amp; Mitchell (2001), with
a constant mean <code>theta</code> and variance <code>omega</code> (equivalent to white
noise).
</p>
</li>
<li>  <p><strong>Strict Stasis</strong>: Same as Stasis with <code>omega</code> = 0,
indicating no real evolutionary differences; all observed variation is
sampling error (Hunt et al. 2015).
</p>
</li>
<li>  <p><strong>OU</strong>: Ornstein-Uhlenbeck
model (Hunt et al. 2008). This model is that of a population ascending a
nearby peak in the adaptive landscape. The optimal trait value is <code>theta</code>,
<code>alpha</code> indicates the strength of attraction to that peak (= strength of
stabilizing selection around <code>theta</code>), <code>vstep</code> measures the random walk component (from genetic drift) and <code>anc</code> is the trait value
at the start of the sequence.
</p>
</li>
<li>  <p><strong>covTrack</strong>: Covariate-tracking (Hunt et al. 2010). The trait tracks
a covariate with slope <code>b1</code>, consistent with an adaptive response. <code>evar</code> is the
residual variance, and, under <code>method = "Joint"</code>, <code>b0</code> is the intercept of the
relationship between trait and covariate.
model. </p>
</li></ul>



<h3>Value</h3>

<p>a <code>paleoTSfit</code> object with the model fitting results
</p>


<h3>Note</h3>

<p>For the covariate-tracking model, z should be a vector of length
<em>n</em> when <code>method = "Joint"</code> and <em>n</em> - 1 when <code>method =
"AD"</code>, where <em>n</em> is the number of samples in <code>y</code>. <br /> <br /> Method =
<code>"Joint"</code> is a full likelihood approach, considering each time-series as
a joint sample from a multivariate normal distribution.  Method = <code>"AD"</code>
is a REML approach that uses the differences between successive samples.
They perform similarly, but the Joint approach does better under some
circumstances (Hunt, 2008).
</p>


<h3>References</h3>

<p>Hunt, G. 2006. Fitting and comparing models of phyletic
evolution: random walks and beyond. <em>Paleobiology</em> 32(4): 578-601. <br />
Hunt, G. 2008. Evolutionary patterns within fossil lineages: model-based
assessment of modes, rates, punctuations and process. p. 117-131 <em>In</em>
From Evolution to Geobiology: Research Questions Driving Paleontology at the
Start of a New Century. Bambach, R. and P. Kelley (Eds). <br /> Hunt, G., M. A.
Bell and M. P. Travis. 2008. Evolution toward a new adaptive optimum:
phenotypic evolution in a fossil stickleback lineage. <em>Evolution</em> 62(3):
700-710. <br /> Sheets, H. D., and C. Mitchell. 2010. Why the null matters:
statistical tests, random walks and evolution. <em>Genetica</em> 112–
113:105–125. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opt.GRW">opt.GRW</a></code>, <code><a href="#topic+opt.joint.GRW">opt.joint.GRW</a></code>,
<code><a href="#topic+opt.joint.OU">opt.joint.OU</a></code>, <code><a href="#topic+opt.covTrack">opt.covTrack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- sim.Stasis(ns = 20, omega = 2)
w1 &lt;- fitSimple(y, model = "GRW")
w2 &lt;- fitSimple(y, model = "URW")
w3 &lt;- fitSimple(y, model = "Stasis")
compareModels(w1, w2, w3)
</code></pre>

<hr>
<h2 id='IC'>Compute Information Criteria</h2><span id='topic+IC'></span>

<h3>Description</h3>

<p>Compute Information Criteria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC(logL, K, n = NULL, method = c("AICc", "AIC", "BIC"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC_+3A_logl">logL</code></td>
<td>
<p>log-likelihood</p>
</td></tr>
<tr><td><code id="IC_+3A_k">K</code></td>
<td>
<p>number of parameters</p>
</td></tr>
<tr><td><code id="IC_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="IC_+3A_method">method</code></td>
<td>
<p>either &quot;AIC&quot;, &quot;AICc&quot;, or &quot;BIC&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the specified information criterion
</p>


<h3>Note</h3>

<p>This function is used internally by the model-fitting functions. It
will not generally be called directly by the user.
</p>

<hr>
<h2 id='ln.paleoTS'>Approximate log-transformation of time-series data</h2><span id='topic+ln.paleoTS'></span>

<h3>Description</h3>

<p>Approximate log-transformation of time-series data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ln.paleoTS(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ln.paleoTS_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a random variable x, its approximate mean on a natural log
scale is the log of its untransformed mean.  The approximate variance on a
log scale is equal to the squared coefficient of variation.
</p>


<h3>Value</h3>

<p>the converted <code>paleoTS</code> object
</p>


<h3>Note</h3>

<p>This transformation only makes sense for variables with dimension and a
true zero point, such as lengths and areas.
</p>


<h3>References</h3>

<p>Hunt, G. 2006. Fitting and comparing models of phyletic
evolution: random walks and beyond.  <em>Paleobiology</em> 32:578-601. <br />
Lewontin, R. 1966. On the measurement of relative variability.
<em>Systematic Zoology</em> 15:141-142.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.Stasis(ns = 10, theta = 20, omega = 1)
plot(x)
xl &lt;- ln.paleoTS(x)
plot(xl)
</code></pre>

<hr>
<h2 id='LRI'>Log-rate, Log-interval (LRI) method of Gingerich</h2><span id='topic+LRI'></span>

<h3>Description</h3>

<p>Gingerich (1993) introduced a method that plots on log-log scale,
the rate and interval for each pair of samples in an evolutionary sequence.
On this plot, the slope is interpreted as an indicator of evolutionary mode
(-1 for stasis, 0.5 for random walk, 0 for directional), and the intercept
is interpreted as a measure of the rate of evolution over one generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRI(y, gen.per.t = 1e+06, draw = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LRI_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="LRI_+3A_gen.per.t">gen.per.t</code></td>
<td>
<p>the number of generations per unit time</p>
</td></tr>
<tr><td><code id="LRI_+3A_draw">draw</code></td>
<td>
<p>logical, if TRUE, a plot is produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following Gingerich (1993), a robust line is fit through the
points by minimizing the sum of absolute deviations. If generations are one
year long and time is measured in Myr, <code>gen.per.t</code>= 1e6.
</p>


<h3>Value</h3>

<p>A named vector with three elements: <code>Intercept</code>, <code>slope</code>, and
<code>GenerationalRate</code>
</p>


<h3>Note</h3>

<p>This method was important in early attempts to disentangle
evolutionary tempo and mode. I view likelihood-based methods as more
informative, and in particular the estimation of 'Generational Rates' using
LRI is compromised by sampling error; see Hunt (2012) and the example below.
</p>


<h3>References</h3>

<p>Gingerich, P.D. 1993. Quantification and comparison of
evolutionary rates. <em>American Journal of Science</em> 293-A:453–478. <br /> <br />
Hunt, G. 2012. Measuring rates of phenotypic evolution and the
inseparability of tempo and mode. <em>Paleobiology</em> 38:351–373.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lynchD">lynchD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
xFast &lt;- sim.GRW(ns = 20, ms = 0.5, vs = 0.2)  # fast evolution
xSlow &lt;- sim.Stasis(ns = 20, omega = 0)        # strict stasis (zero rates)
lri.Fast &lt;- LRI(xFast, draw = FALSE)
lri.Slow &lt;- LRI(xSlow, draw = FALSE)
print(lri.Fast[3], 4)
print(lri.Slow[3], 4)  # LRI thinks strict stasis rates are faster!
</code></pre>

<hr>
<h2 id='lynchD'>Compute Lynch's Delta rate metric</h2><span id='topic+lynchD'></span>

<h3>Description</h3>

<p>This function computes D, the rate metric proposed by Lynch
(1990).  This metric derives from the random walk model, with <code>D =
  Vstep/(2Vp)</code>, where <code>Vstep</code> is the step variance of the unbiased
random walk, and <code>Vp</code> is the within sample variance, pooled among
samples.  Under mutation - drift equilibrium, <code>D</code> is expected to range
approximately between 5e-5 and 5e-3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lynchD(y, gen.per.t = 1e+06, pool = TRUE, method = c("Joint", "AD"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lynchD_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="lynchD_+3A_gen.per.t">gen.per.t</code></td>
<td>
<p>the number of generations per unit time</p>
</td></tr>
<tr><td><code id="lynchD_+3A_pool">pool</code></td>
<td>
<p>logical, whether variances should be pooled over samples</p>
</td></tr>
<tr><td><code id="lynchD_+3A_method">method</code></td>
<td>
<p>parameterization to use: based on ancestor-descendant (AD)
differences, or Joint consideration of all samples</p>
</td></tr>
<tr><td><code id="lynchD_+3A_...">...</code></td>
<td>
<p>further arguments, passed to <code>opt.URW</code> or <code>opt.joint.URW</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>D</code></td>
<td>
<p>  value of rate metric </p>
</td></tr>
<tr><td><code>pooled.var</code></td>
<td>
<p> value
of pooled within-sample variance </p>
</td></tr>
<tr><td><code>gen.per.t</code></td>
<td>
<p> number of generations per unit time </p>
</td></tr>
<tr><td><code>vstep</code></td>
<td>
<p> computed <code>Vstep</code>, at the original time
scale of <code>y</code></p>
</td></tr>
<tr><td><code>drift.range</code></td>
<td>
<p> expected minimum and maximum values
of <code>D</code> consistent with neutral evolution </p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p> conclusion reached about the plausibility of neutral evolution </p>
</td></tr>
</table>


<h3>References</h3>

<p>Lynch (1990). The rate of morphological evolution in mammals from the
standpoint of the neutral expectation. <em>The American Naturalist</em>
136:727-741.
Hunt, G. 2012. Fitting and comparing models of phyletic evolution: random
walks and beyond.  <em>Paleobiology</em> 38:351-373.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- sim.GRW(ns = 20, ms = 0, vs = 1e-4, tt=seq(0, 1e6, length.out=20))  # per-year simulation
lynchD(y, gen.per.t = 1)
</code></pre>

<hr>
<h2 id='mle.GRW'>Analytical ML estimator for random walk and stasis models</h2><span id='topic+mle.GRW'></span><span id='topic+mle.URW'></span><span id='topic+mle.Stasis'></span>

<h3>Description</h3>

<p>Analytical ML estimator for random walk and stasis models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle.GRW(y)

mle.URW(y)

mle.Stasis(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle.GRW_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of <code>mstep</code> and <code>vstep</code> for <code>mle.GRW</code>,
<code>vstep</code> for <code>mle.URW</code>, and <code>theta</code> and <code>omega</code> for
<code>mle.Stasis</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>mle.URW()</code>: ML parameter estimates for URW model
</p>
</li>
<li> <p><code>mle.Stasis()</code>: ML parameter estimates for Stasis model
</p>
</li></ul>


<h3>Note</h3>

<p>These analytical solutions assume even spacing of samples and equal
sampling variance in each, which will usually be violated in real data.
They are used here mostly to generate initial parameter estimates for
numerical optimization; they not likely to be called directly by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitSimple">fitSimple</a></code>
</p>

<hr>
<h2 id='opt.covTrack'>Fit a model in which a trait tracks a covariate</h2><span id='topic+opt.covTrack'></span><span id='topic+opt.joint.covTrack'></span>

<h3>Description</h3>

<p>Fit a model in which a trait tracks a covariate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.covTrack(
  y,
  z,
  pool = TRUE,
  cl = list(fnscale = -1),
  meth = "L-BFGS-B",
  hess = FALSE
)

opt.joint.covTrack(
  y,
  z,
  pool = TRUE,
  cl = list(fnscale = -1),
  meth = "L-BFGS-B",
  hess = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt.covTrack_+3A_y">y</code></td>
<td>
<p>a <code>paloeTS</code> object</p>
</td></tr>
<tr><td><code id="opt.covTrack_+3A_z">z</code></td>
<td>
<p>a vector of covariate values</p>
</td></tr>
<tr><td><code id="opt.covTrack_+3A_pool">pool</code></td>
<td>
<p>if TRUE, sample variances are substituted with their pooled
estimate</p>
</td></tr>
<tr><td><code id="opt.covTrack_+3A_cl">cl</code></td>
<td>
<p>optional control list, passed to <code>optim()</code></p>
</td></tr>
<tr><td><code id="opt.covTrack_+3A_meth">meth</code></td>
<td>
<p>optimization algorithm, passed to <code>optim()</code></p>
</td></tr>
<tr><td><code id="opt.covTrack_+3A_hess">hess</code></td>
<td>
<p>if TRUE, return standard errors of parameter estimates from the
hessian matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this model, changes in a trait are linearly related to changes in
a covariate with a slope of <code>b</code> and residual variance <code>evar</code>:
<code>dx = b * dz + eps</code>, where <code>eps ~ N(0, evar)</code>.  This model was
described, and applied to an example in which body size changes tracked
changes in temperature, by Hunt et al. (2010). <br />
</p>
<p>For the AD version (<code>opt.covTrack</code>), a trait sequence of
length <code>ns</code>, the covariate, <code>z</code>, can be of length <code>ns</code> - 1,
interpreted as the vector of <em>changes</em>, <code>dx</code>. If <code>z</code> is
of length <code>ns</code>, differences are taken and these are used as the
<code>dx</code>'s, with a warning issued. <br />
</p>
<p>The Joint version
(<code>opt.joint.covTrack</code>), <code>z</code> should be of length <code>ns</code> and
there is an additional parameter that is the intercept of the linear
relationship between trait and covariate. See warning below about using the
Joint version.
</p>


<h3>Value</h3>

<p>a <code>paleoTSfit</code> object with the results of the model fitting
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>opt.joint.covTrack()</code>: fits the covTrack model using the joint parameterization
</p>
</li></ul>


<h3>Warning</h3>

<p>The Joint parameterization of this model can be fooled by
temporal autocorrelation and, especially, trends in the trait and the
covariate.  The latter is tested for, but the AD parameterization is
generally safer for this model.
</p>


<h3>References</h3>

<p>Hunt, G, S. Wicaksono, J. E. Brown, and K. G. Macleod. 2010. Climate-driven
body size trends in the ostracod fauna of the deep Indian Ocean. <em>Palaeontology</em>
53(6): 1255-1268.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitSimple">fitSimple</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
z &lt;- c(1, 2, 2, 4, 0, 8, 2, 3, 1, 9, 4, 3)
x &lt;- sim.covTrack(ns = 12, z = z, b = 0.5, evar = 0.2)
w.urw &lt;- opt.URW(x)
w.cov &lt;- opt.covTrack(x, z = z)
compareModels(w.urw, w.cov)
</code></pre>

<hr>
<h2 id='opt.GRW'>Fit evolutionary model using &quot;AD&quot; parameterization</h2><span id='topic+opt.GRW'></span><span id='topic+opt.URW'></span><span id='topic+opt.Stasis'></span><span id='topic+opt.StrictStasis'></span>

<h3>Description</h3>

<p>Fit evolutionary model using &quot;AD&quot; parameterization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.GRW(
  y,
  pool = TRUE,
  cl = list(fnscale = -1),
  meth = "L-BFGS-B",
  hess = FALSE
)

opt.URW(
  y,
  pool = TRUE,
  cl = list(fnscale = -1),
  meth = "L-BFGS-B",
  hess = FALSE
)

opt.Stasis(
  y,
  pool = TRUE,
  cl = list(fnscale = -1),
  meth = "L-BFGS-B",
  hess = FALSE
)

opt.StrictStasis(
  y,
  pool = TRUE,
  cl = list(fnscale = -1),
  meth = "L-BFGS-B",
  hess = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt.GRW_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="opt.GRW_+3A_pool">pool</code></td>
<td>
<p>if TRUE, sample variances are substituted with their pooled estimate</p>
</td></tr>
<tr><td><code id="opt.GRW_+3A_cl">cl</code></td>
<td>
<p>optional control list, passed to <code>optim()</code></p>
</td></tr>
<tr><td><code id="opt.GRW_+3A_meth">meth</code></td>
<td>
<p>optimization algorithm, passed to <code>optim()</code></p>
</td></tr>
<tr><td><code id="opt.GRW_+3A_hess">hess</code></td>
<td>
<p>if TRUE, return standard errors of parameter estimates from the
hessian matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use differences between consecutive populations in the
time series in order to remove temporal autocorrelation.  This is referred to as
the &quot;Ancestor-Descendant&quot; or &quot;AD&quot; parameterization by Hunt [2008], and it is a REML
approach (like phylogenetic independent contrasts).  A full ML approach, called
&quot;Joint&quot; was found to have somewhat better performance (Hunt, 2008) and generally
should be used instead.
</p>


<h3>Value</h3>

<p>a <code>paleoTSfit</code> object with the model fitting results
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>opt.URW()</code>: fit the URW model by the AD parameterization
</p>
</li>
<li> <p><code>opt.Stasis()</code>: fit the Stasis model by the AD parameterization
</p>
</li>
<li> <p><code>opt.StrictStasis()</code>: fit the Strict Stasis model by the AD parameterization
</p>
</li></ul>


<h3>Note</h3>

<p>It is easier to use the convenience function <code>fitSimple</code>.
</p>


<h3>References</h3>

<p>Hunt, G. 2006. Fitting and comparing models of phyletic evolution: random walks and beyond.
<em>Paleobiology</em> 32(4): 578-601.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitSimple">fitSimple</a></code>, <code><a href="#topic+opt.joint.GRW">opt.joint.GRW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.GRW(ns = 20, ms = 1)  # strong trend
plot(x)
w.grw &lt;- opt.GRW(x)
w.urw &lt;- opt.URW(x)
compareModels(w.grw, w.urw)
</code></pre>

<hr>
<h2 id='opt.GRW.shift'>Fit random walk model with shift(s) in generating parameters</h2><span id='topic+opt.GRW.shift'></span>

<h3>Description</h3>

<p>Fit random walk model with shift(s) in generating parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.GRW.shift(y, ng = 2, minb = 7, model = 1, pool = TRUE, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt.GRW.shift_+3A_y">y</code></td>
<td>
<p>a <code>paloeTS</code> object</p>
</td></tr>
<tr><td><code id="opt.GRW.shift_+3A_ng">ng</code></td>
<td>
<p>number of segments in the sequence</p>
</td></tr>
<tr><td><code id="opt.GRW.shift_+3A_minb">minb</code></td>
<td>
<p>minimum number of populations in each segment</p>
</td></tr>
<tr><td><code id="opt.GRW.shift_+3A_model">model</code></td>
<td>
<p>numeric, specifies exact evolutionary model; see Details</p>
</td></tr>
<tr><td><code id="opt.GRW.shift_+3A_pool">pool</code></td>
<td>
<p>if TRUE, sample variances are substituted with their pooled estimate</p>
</td></tr>
<tr><td><code id="opt.GRW.shift_+3A_silent">silent</code></td>
<td>
<p>logical, if TRUE, progress updates are suppressed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits a model in which a sequence is divided into two or more segments and
trait evolution proceeds as a general random walk, with each segment (potentially)
getting its own generating parameters (<code>mstep</code>, <code>vstep</code>). <br /> <br />
</p>
<p>This function tests for shifts after each population, subject to the
constraint that the number of populations in each segment is always &gt;= <code>minb</code>. The
shiftpoint yielding the highest log-likelihood is returned as the solution, along with
the log-likelihoods (<code>all.logl</code> of all tested shift points (<code>GG</code>). <br /> <br />
</p>
<p>Different variants of the model can be specified by the <code>model</code> argument:
</p>

<ul>
<li> <p><code>model = 1:  </code> <code>mstep</code> is separate across segments; <code>vstep</code> is shared
</p>
</li>
<li> <p><code>model = 2:  </code> <code>mstep</code> is shared across segments; <code>vstep</code> is separate
</p>
</li>
<li> <p><code>model = 3:  </code> <code>mstep</code> is set to zero (unbiased random walk); <code>vstep</code>
is separate across segments
</p>
</li>
<li> <p><code>model = 4:  </code> <code>mstep</code> and <code>vstep</code> are both separate across segments
</p>
</li></ul>



<h3>Value</h3>

<p>a <code>paleoTSfit</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.GRW.shift">sim.GRW.shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.GRW.shift(ns = c(15,15), ms = c(0, 1), vs = c(0.1,0.1))
w.sep &lt;- opt.GRW.shift(x, ng = 2, model = 4)
w.sameVs &lt;- opt.GRW.shift(x, ng = 2, model = 1)
compareModels(w.sep, w.sameVs)
plot(x)
abline(v = x$tt[16], lwd = 3)  # actual shift point
abline(v = x$tt[w.sameVs$par["shift1"]], lty = 3, col = "red", lwd = 2) # inferred shift point
</code></pre>

<hr>
<h2 id='opt.joint.GRW'>Fit evolutionary models using the &quot;Joint&quot; parameterization</h2><span id='topic+opt.joint.GRW'></span><span id='topic+opt.joint.URW'></span><span id='topic+opt.joint.Stasis'></span><span id='topic+opt.joint.StrictStasis'></span>

<h3>Description</h3>

<p>Fit evolutionary models using the &quot;Joint&quot; parameterization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.joint.GRW(
  y,
  pool = TRUE,
  cl = list(fnscale = -1),
  meth = "L-BFGS-B",
  hess = FALSE
)

opt.joint.URW(
  y,
  pool = TRUE,
  cl = list(fnscale = -1),
  meth = "L-BFGS-B",
  hess = FALSE
)

opt.joint.Stasis(
  y,
  pool = TRUE,
  cl = list(fnscale = -1),
  meth = "L-BFGS-B",
  hess = FALSE
)

opt.joint.StrictStasis(y, pool = TRUE, cl = list(fnscale = -1), hess = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt.joint.GRW_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="opt.joint.GRW_+3A_pool">pool</code></td>
<td>
<p>if TRUE, sample variances are substituted with their pooled estimate</p>
</td></tr>
<tr><td><code id="opt.joint.GRW_+3A_cl">cl</code></td>
<td>
<p>optional control list, passed to <code>optim()</code></p>
</td></tr>
<tr><td><code id="opt.joint.GRW_+3A_meth">meth</code></td>
<td>
<p>optimization algorithm, passed to <code>optim()</code></p>
</td></tr>
<tr><td><code id="opt.joint.GRW_+3A_hess">hess</code></td>
<td>
<p>if TRUE, return standard errors of parameter estimates from the
hessian matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use the joint distribution of population means to fit models
using a full maximum-likelihood approach. This approach was found to have somewhat
better performance than the &quot;AD&quot; approach, especially for noisy trends (Hunt, 2008).
</p>


<h3>Value</h3>

<p>a <code>paleoTSfit</code> object with the model fitting results
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>opt.joint.URW()</code>: fit the URW model by the Joint parameterization
</p>
</li>
<li> <p><code>opt.joint.Stasis()</code>: fit the Stasis model by the Joint parameterization
</p>
</li>
<li> <p><code>opt.joint.StrictStasis()</code>: fit the Strict Stasis model by the Joint parameterization
</p>
</li></ul>


<h3>Note</h3>

<p>It is easier to use the convenience function <code>fitSimple</code>.
</p>


<h3>References</h3>

<p>#' Hunt, G., M. J. Hopkins and S. Lidgard. 2015. Simple versus complex models of trait evolution
and stasis as a response to environmental change. PNAS 112(16): 4885-4890.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitSimple">fitSimple</a></code>, <code><a href="#topic+opt.GRW">opt.GRW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.GRW(ns = 20, ms = 1)  # strong trend
plot(x)
w.grw &lt;- opt.joint.GRW(x)
w.urw &lt;- opt.joint.URW(x)
compareModels(w.grw, w.urw)
</code></pre>

<hr>
<h2 id='opt.joint.OU'>Fit Ornstein-Uhlenbeck model using the &quot;Joint&quot; parameterization</h2><span id='topic+opt.joint.OU'></span>

<h3>Description</h3>

<p>Fit Ornstein-Uhlenbeck model using the &quot;Joint&quot; parameterization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.joint.OU(
  y,
  pool = TRUE,
  cl = list(fnscale = -1),
  meth = "L-BFGS-B",
  hess = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt.joint.OU_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="opt.joint.OU_+3A_pool">pool</code></td>
<td>
<p>if TRUE, sample variances are substituted with their pooled estimate</p>
</td></tr>
<tr><td><code id="opt.joint.OU_+3A_cl">cl</code></td>
<td>
<p>optional control list, passed to <code>optim()</code></p>
</td></tr>
<tr><td><code id="opt.joint.OU_+3A_meth">meth</code></td>
<td>
<p>optimization algorithm, passed to <code>optim()</code></p>
</td></tr>
<tr><td><code id="opt.joint.OU_+3A_hess">hess</code></td>
<td>
<p>if TRUE, return standard errors of parameter estimates from the
hessian matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits an Ornstein-Uhlenbeck (OU) model to time-series data. The OU
model has four generating parameters: an ancestral trait value (<code>anc</code>), an optimum
value (<code>theta</code>), the strength of attraction to the optimum (<code>alpha</code>), and a
parameter that reflects the tendency of traits to diffuse (<code>vstep</code>).  In a
microevolutionary context, these parameters can be related to natural selection and
genetic drift; see Hunt et al. (2008).
</p>


<h3>Value</h3>

<p>a <code>paleoTSfit</code> object with the model fitting results
</p>


<h3>Note</h3>

<p>It is easier to use the convenience function <code>fitSimple</code>.  Note also that
preliminary work found that the &quot;AD&quot; parameterization did not perform as well for the OU
model and thus it is not implemented here.
</p>


<h3>References</h3>

<p>Hunt, G., M. A. Bell and M. P. Travis. 2008. Evolution toward a new adaptive
optimum: phenotypic evolution in a fossil stickleback lineage. <em>Evolution</em> 62(3):
700-710.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitSimple">fitSimple</a></code>, <code><a href="#topic+opt.joint.GRW">opt.joint.GRW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.OU(vs = 0.5)  # most defaults OK
w &lt;- opt.joint.OU(x)
plot(x, modelFit = w)
</code></pre>

<hr>
<h2 id='opt.punc'>Fit a model of trait evolution with specified punctuation(s)</h2><span id='topic+opt.punc'></span><span id='topic+opt.joint.punc'></span>

<h3>Description</h3>

<p>Fit a model of trait evolution with specified punctuation(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.punc(
  y,
  gg,
  pool = TRUE,
  cl = list(fnscale = -1),
  meth = "L-BFGS-B",
  hess = FALSE,
  oshare
)

opt.joint.punc(
  y,
  gg,
  pool = TRUE,
  cl = list(fnscale = -1),
  meth = "L-BFGS-B",
  hess = FALSE,
  oshare
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt.punc_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="opt.punc_+3A_gg">gg</code></td>
<td>
<p>vector of indices indicating different segments</p>
</td></tr>
<tr><td><code id="opt.punc_+3A_pool">pool</code></td>
<td>
<p>if TRUE, sample variances are substituted with their pooled estimate</p>
</td></tr>
<tr><td><code id="opt.punc_+3A_cl">cl</code></td>
<td>
<p>optional control list, passed to <code>optim()</code></p>
</td></tr>
<tr><td><code id="opt.punc_+3A_meth">meth</code></td>
<td>
<p>optimization algorithm, passed to <code>optim()</code></p>
</td></tr>
<tr><td><code id="opt.punc_+3A_hess">hess</code></td>
<td>
<p>if TRUE, return standard errors of parameter estimates from the</p>
</td></tr>
<tr><td><code id="opt.punc_+3A_oshare">oshare</code></td>
<td>
<p>logical, if TRUE, variance assumed to be shared (equal) across segments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence is divided into segments, which are separated by punctuations. Means for
each segment are given by the vector <code>theta</code> with variances given by the vector
<code>omega</code> (or a single value if <code>oshare = TRUE</code>). This function calls <code>optim</code> to numerically fit this model to a time-series, y.
</p>


<h3>Value</h3>

<p>a <code>paleoTSfit</code> object with the results of the model fitting
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>opt.joint.punc()</code>: fits the punctuation model using the joint parameterization
</p>
</li></ul>


<h3>Note</h3>

<p>These functions would be used in the uncommon situation in which there
is a prior hypothesis as to where the punctuation(s) take place.  Normally
users will instead use the function <code>fitGpunc</code>, which uses these
functions to fit a range of possible timings for the punctuations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitGpunc">fitGpunc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.punc(ns = c(15, 15), theta = c(0,3), omega = c(0.1, 0.1))
w.sta  &lt;- fitSimple(x, model = "Stasis", method = "Joint")
w.punc &lt;- opt.joint.punc(x, gg = rep(1:2, each = 15), oshare = TRUE)
compareModels(w.sta, w.punc)
</code></pre>

<hr>
<h2 id='plot.paleoTS'>Plot a paleoTS object</h2><span id='topic+plot.paleoTS'></span>

<h3>Description</h3>

<p>Plot a paleoTS object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'paleoTS'
plot(
  x,
  nse = 1,
  pool = FALSE,
  add = FALSE,
  modelFit = NULL,
  pch = 21,
  lwd = 1.5,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.paleoTS_+3A_x">x</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="plot.paleoTS_+3A_nse">nse</code></td>
<td>
<p>the number of standard errors represented by the error bars on the
plot; defaults to 1</p>
</td></tr>
<tr><td><code id="plot.paleoTS_+3A_pool">pool</code></td>
<td>
<p>logical indicating if variances should be pooled across samples
for the purposes of displaying error bars; defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.paleoTS_+3A_add">add</code></td>
<td>
<p>logical, if <code>TRUE</code>, adds to existing plot</p>
</td></tr>
<tr><td><code id="plot.paleoTS_+3A_modelfit">modelFit</code></td>
<td>
<p>optional model fit from fitting functions</p>
</td></tr>
<tr><td><code id="plot.paleoTS_+3A_pch">pch</code></td>
<td>
<p>plotting symbol, defaults to 19</p>
</td></tr>
<tr><td><code id="plot.paleoTS_+3A_lwd">lwd</code></td>
<td>
<p>line width, defaults to 1.5</p>
</td></tr>
<tr><td><code id="plot.paleoTS_+3A_ylim">ylim</code></td>
<td>
<p>optional, y-limits of the plot</p>
</td></tr>
<tr><td><code id="plot.paleoTS_+3A_...">...</code></td>
<td>
<p>other arguments passed to plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.GRW(ns = 30)
w &lt;- fitSimple(x, model = "GRW", method = "Joint")
plot(x, modelFit = w)
</code></pre>

<hr>
<h2 id='pool.var'>Compute a pooled variance</h2><span id='topic+pool.var'></span>

<h3>Description</h3>

<p>Computes a pooled variance from samples in a paleontological
time-series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool.var(y, nn = NULL, minN = NULL, ret.paleoTS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool.var_+3A_y">y</code></td>
<td>
<p>either a <code>paleoTS</code> object, or a vector of sample variances</p>
</td></tr>
<tr><td><code id="pool.var_+3A_nn">nn</code></td>
<td>
<p>a vector of sample sizes</p>
</td></tr>
<tr><td><code id="pool.var_+3A_minn">minN</code></td>
<td>
<p>sample size below which variances are replaced with pooled
variances. See Details.</p>
</td></tr>
<tr><td><code id="pool.var_+3A_ret.paleots">ret.paleoTS</code></td>
<td>
<p>if TRUE, a <code>paleoTS</code> object is returned. If FALSE,
the value of the pooled variance is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pooled variance of a set of populations is the weighted average
of the individual variances of the populations, with the weight for each
population equal to its sample size minus one. <br /> <br /> For many kinds of
traits, variation levels tend to be similar among closely related
populations. When this is true and sample sizes are low, much of the
observed differences in variance among samples will be due to the high
noise of estimated the variances. Replacing the observed variances of all
populations (or only those with <code>nn &lt; minN</code>) with the estimated pooled
variance can reduce this noise.
</p>


<h3>Value</h3>

<p>if <code>ret.paleoTS = TRUE</code> a <code>paleoTS</code> object with all (or
some) variances replaced with the pooled variance; otherwise the pooled
variance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cantius_L)
cant_all &lt;- pool.var(cantius_L, ret.paleoTS = TRUE)   # replace all variances with pooled variance
cant_n5  &lt;- pool.var(cantius_L, minN = 5, ret.paleoTS = TRUE)  # replace only pops with n &lt; 5

</code></pre>

<hr>
<h2 id='read.paleoTS'>Read a text-file with data from a paleontological time-series</h2><span id='topic+read.paleoTS'></span>

<h3>Description</h3>

<p>Read a text-file with data from a paleontological time-series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.paleoTS(file = NULL, oldest = "first", reset.time = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.paleoTS_+3A_file">file</code></td>
<td>
<p>file name; if not supplied, an interactive window prompts the
user to navigate to the text file</p>
</td></tr>
<tr><td><code id="read.paleoTS_+3A_oldest">oldest</code></td>
<td>
<p>&quot;first&quot; if samples are in order from oldest to youngest, &quot;last&quot;
if the opposite</p>
</td></tr>
<tr><td><code id="read.paleoTS_+3A_reset.time">reset.time</code></td>
<td>
<p>logical; see <code><a href="#topic+as.paleoTS">as.paleoTS</a></code></p>
</td></tr>
<tr><td><code id="read.paleoTS_+3A_...">...</code></td>
<td>
<p>other arguments, passed to <code>read.table</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads a text file with a specified format and converts
it into a <code>paleoTS</code> object. It will often be the easiest way for users
to import their own data. The text file should have four columns without
headers, in this order: sample size, sample means, sample variances, sample
ages.
</p>


<h3>Value</h3>

<p>a <code>paleoTS</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.paleoTS">as.paleoTS</a></code>
</p>

<hr>
<h2 id='sim.covTrack'>Simulate trait evolution that tracks a covariate</h2><span id='topic+sim.covTrack'></span>

<h3>Description</h3>

<p>Simulate trait evolution that tracks a covariate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.covTrack(
  ns = 20,
  b = 1,
  evar = 0.1,
  z,
  nn = rep(20, times = ns),
  tt = 0:(ns - 1),
  vp = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.covTrack_+3A_ns">ns</code></td>
<td>
<p>number of populations in a sequence</p>
</td></tr>
<tr><td><code id="sim.covTrack_+3A_b">b</code></td>
<td>
<p>slope of the relationship between the change in the covariate and
the change in the trait</p>
</td></tr>
<tr><td><code id="sim.covTrack_+3A_evar">evar</code></td>
<td>
<p>residual variance of the same relationship</p>
</td></tr>
<tr><td><code id="sim.covTrack_+3A_z">z</code></td>
<td>
<p>vector of covariate that the trait tracks</p>
</td></tr>
<tr><td><code id="sim.covTrack_+3A_nn">nn</code></td>
<td>
<p>vector of sample sizes for populations</p>
</td></tr>
<tr><td><code id="sim.covTrack_+3A_tt">tt</code></td>
<td>
<p>vector of times (ages) for populations</p>
</td></tr>
<tr><td><code id="sim.covTrack_+3A_vp">vp</code></td>
<td>
<p>phenotypic trait variance within each population</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this model, changes in a trait are linearly related to changes in
a covariate with a slope of <code>b</code> and residual variance <code>evar</code>:
<code>dx = b * dz + eps</code>, where <code>eps ~ N(0, evar)</code>.  This model was
described, and applied to an example in which body size changes tracked
changes in temperature, by Hunt et al. (2010).
</p>


<h3>Value</h3>

<p>a <code>paleoTS</code> object
</p>


<h3>Note</h3>

<p>For a trait sequence of length <code>ns</code>, the covariate, <code>z</code>, can
be of length <code>ns</code> - 1,in which case it is interpreted as the vector of
<em>changes</em>, <code>dz</code>. If <code>z</code> is of length <code>ns</code>,
differences are taken and these are used as the <code>dz</code>'s.
</p>


<h3>References</h3>

<p>Hunt, G, S. Wicaksono, J. E. Brown, and K. G. Macleod. 2010.
Climate-driven body size trends in the ostracod fauna of the deep Indian
Ocean. <em>Palaeontology</em> 53(6): 1255-1268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(13)
z &lt;- c(1, 2, 2, 4, 0, 8, 2, 3, 1, 9, 4, 3)
x &lt;- sim.covTrack(ns = 12, z = z, b = 0.5, evar = 0.2)
plot(x, ylim = c(-1, 10))
lines(x$tt, z, col = "blue")
</code></pre>

<hr>
<h2 id='sim.GRW'>Simulate random walk or directional time-series for trait evolution</h2><span id='topic+sim.GRW'></span>

<h3>Description</h3>

<p>Simulate random walk or directional time-series for trait evolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.GRW(ns = 20, ms = 0, vs = 0.1, vp = 1, nn = rep(20, ns), tt = 0:(ns - 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.GRW_+3A_ns">ns</code></td>
<td>
<p>number of populations in the sequence</p>
</td></tr>
<tr><td><code id="sim.GRW_+3A_ms">ms</code></td>
<td>
<p>mean of evolutionary &quot;steps&quot;</p>
</td></tr>
<tr><td><code id="sim.GRW_+3A_vs">vs</code></td>
<td>
<p>variance of evolutionary &quot;steps&quot;</p>
</td></tr>
<tr><td><code id="sim.GRW_+3A_vp">vp</code></td>
<td>
<p>phenotypic variance within populations</p>
</td></tr>
<tr><td><code id="sim.GRW_+3A_nn">nn</code></td>
<td>
<p>vector of population sample sizes</p>
</td></tr>
<tr><td><code id="sim.GRW_+3A_tt">tt</code></td>
<td>
<p>vector of population times (ages)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general random walk model considers time in discrete steps.
At each time step, an evolutionary change is drawn at random from a distribution of
possible evolutionary &quot;steps.&quot;  It turns out that the long-term dynamics of an evolving
lineage depend only on the mean and variance of this step distribution.  The former,
<code>mstep</code>, determined the directionality in a sequence and the latter, <code>vstep</code>,
determines its volatility.
</p>


<h3>Value</h3>

<p>a <code>paleoTS</code> object
</p>


<h3>Note</h3>

<p>This function simulates an unbiased random walk if <code>ms</code> is  equal to zero and
a general (or biased) random walk otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.Stasis">sim.Stasis</a></code>, <code><a href="#topic+sim.OU">sim.OU</a></code>, <code><a href="#topic+as.paleoTS">as.paleoTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x.grw &lt;- sim.GRW(ms = 0.5)
x.urw &lt;- sim.GRW(ms = 0)
plot(x.grw, ylim = range(c(x.grw$mm, x.urw$mm)))
plot(x.urw, add = TRUE, col = "blue")
legend(x = "topleft", c("GRW", "URW"), col = c("black", "blue"), lty = 1)
</code></pre>

<hr>
<h2 id='sim.GRW.shift'>Simulate (general) random walk with shift(s) in generating parameters</h2><span id='topic+sim.GRW.shift'></span>

<h3>Description</h3>

<p>Simulate (general) random walk with shift(s) in generating parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.GRW.shift(
  ns = c(10, 10),
  ms = c(0, 1),
  vs = c(0.5, 0.5),
  nn = rep(30, sum(ns)),
  tt = 0:(sum(ns) - 1),
  vp = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.GRW.shift_+3A_ns">ns</code></td>
<td>
<p>vector of the number of samples in each segment</p>
</td></tr>
<tr><td><code id="sim.GRW.shift_+3A_ms">ms</code></td>
<td>
<p>vector of mean step parameter in each segment</p>
</td></tr>
<tr><td><code id="sim.GRW.shift_+3A_vs">vs</code></td>
<td>
<p>vector of step variance parameter in each segment</p>
</td></tr>
<tr><td><code id="sim.GRW.shift_+3A_nn">nn</code></td>
<td>
<p>vector of sample sizes, one for each population</p>
</td></tr>
<tr><td><code id="sim.GRW.shift_+3A_tt">tt</code></td>
<td>
<p>vector of samples times (ages)</p>
</td></tr>
<tr><td><code id="sim.GRW.shift_+3A_vp">vp</code></td>
<td>
<p>phenotypic variance in each sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates under a model in which a sequence is divided into two or more segments.
Trait evolution proceeds as a general random walk, with each segment getting its own
generating parameters (<code>mstep</code>, <code>vstep</code>).
</p>


<h3>Value</h3>

<p>a <code>paleoTS</code> object with the simulated time-series
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.GRW">sim.GRW</a></code>, <code><a href="#topic+sim.sgs">sim.sgs</a></code>, <code><a href="#topic+opt.GRW.shift">opt.GRW.shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.GRW.shift(ns = c(10,10,10), ms = c(0, 1, 0), vs = c(0.1,0.1,0.1))
plot(x)
abline(v = c(9.5, 19.5), lty = 3, lwd = 2, col = "blue")  # shows where dynamics shift
text (c(5, 15, 25), c(2,2,2), paste("segement", 1:3, sep =" "), col = "blue")
</code></pre>

<hr>
<h2 id='sim.OU'>Simulate an Ornstein-Uhlenbeck time-series</h2><span id='topic+sim.OU'></span>

<h3>Description</h3>

<p>Simulate an Ornstein-Uhlenbeck time-series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.OU(
  ns = 20,
  anc = 0,
  theta = 10,
  alpha = 0.3,
  vstep = 0.1,
  vp = 1,
  nn = rep(20, ns),
  tt = 0:(ns - 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.OU_+3A_ns">ns</code></td>
<td>
<p>number of populations in the sequence</p>
</td></tr>
<tr><td><code id="sim.OU_+3A_anc">anc</code></td>
<td>
<p>ancestral phenotype</p>
</td></tr>
<tr><td><code id="sim.OU_+3A_theta">theta</code></td>
<td>
<p>OU optimum (long-term mean)</p>
</td></tr>
<tr><td><code id="sim.OU_+3A_alpha">alpha</code></td>
<td>
<p>strength of attraction to the optimum</p>
</td></tr>
<tr><td><code id="sim.OU_+3A_vstep">vstep</code></td>
<td>
<p>step variance</p>
</td></tr>
<tr><td><code id="sim.OU_+3A_vp">vp</code></td>
<td>
<p>phenotypic variance of each sample</p>
</td></tr>
<tr><td><code id="sim.OU_+3A_nn">nn</code></td>
<td>
<p>vector of sample sizes</p>
</td></tr>
<tr><td><code id="sim.OU_+3A_tt">tt</code></td>
<td>
<p>vector of sample times (ages)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates an Ornstein-Uhlenbeck (OU) process. In
microevolutionary terms, this models a population ascending a nearby peak
in the adaptive landscape. The optimal trait value is <code>theta</code>,
<code>alpha</code> indicates the strength of attraction to that peak (= strength
of stabilizing selection around <code>theta</code>), <code>vstep</code> measures the
random walk component (from genetic drift) and <code>anc</code> is the trait
value at the start of the sequence.
</p>


<h3>Value</h3>

<p>a <code>paleoTS</code> object
</p>


<h3>References</h3>

<p>Hunt, G., M. A. Bell and M. P. Travis. 2008. Evolution toward a new adaptive
optimum: phenotypic evolution in a fossil stickleback lineage. <em>Evolution</em> 62(3):
700-710.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opt.joint.OU">opt.joint.OU</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- sim.OU(alpha = 0.8)  # strong alpha
x2 &lt;- sim.OU(alpha = 0.1)  # wearker alpha
plot(x1)
plot(x2, add = TRUE, col = "blue")

</code></pre>

<hr>
<h2 id='sim.punc'>Simulate a punctuated time-series</h2><span id='topic+sim.punc'></span>

<h3>Description</h3>

<p>Simulates punctuated trait evolution with punctuations that are rapid relative
to the spacing of samples. In practice, the time-series is divided into two or more
segments, each of which has its own mean and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.punc(
  ns = c(10, 10),
  theta = c(0, 1),
  omega = rep(0, length(theta)),
  nn = rep(30, sum(ns)),
  tt = 0:(sum(ns) - 1),
  vp = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.punc_+3A_ns">ns</code></td>
<td>
<p>vector of the number of samples in each segment</p>
</td></tr>
<tr><td><code id="sim.punc_+3A_theta">theta</code></td>
<td>
<p>vector of means, one for each segment</p>
</td></tr>
<tr><td><code id="sim.punc_+3A_omega">omega</code></td>
<td>
<p>vector of variances, one for each segment.</p>
</td></tr>
<tr><td><code id="sim.punc_+3A_nn">nn</code></td>
<td>
<p>vector of sample sizes, one for each population</p>
</td></tr>
<tr><td><code id="sim.punc_+3A_tt">tt</code></td>
<td>
<p>vector of times (ages), one for each population</p>
</td></tr>
<tr><td><code id="sim.punc_+3A_vp">vp</code></td>
<td>
<p>phenotypic variance within each population</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Segments are separated by punctuations. Population means in the ith segment are
drawn randomly from a normal distribution with a mean equal to ith element of <code>theta</code>
and variance equal to the ith element of <code>omega</code>. The magnitudes of punctuations are
determined by the differences in adjacent <code>theta</code> values.
</p>


<h3>Value</h3>

<p>a <code>paleoTS</code> object with the simulated time-series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitGpunc">fitGpunc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.punc(ns = c(15, 15), theta = c(0,3), omega = c(0.1, 0.1))
plot(x)
</code></pre>

<hr>
<h2 id='sim.sgs'>Simulate protracted punctuation</h2><span id='topic+sim.sgs'></span>

<h3>Description</h3>

<p>This function simulates a punctuated change that is is protracted enough that
it is captured by multiple transitional populations.  Trait evolution starts in stasis,
shifts to a general random walk, and then shifts back into stasis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.sgs(
  ns = c(20, 20, 20),
  theta = 0,
  omega = 1,
  ms = 1,
  vs = 0.1,
  nn = rep(30, sum(ns)),
  tt = 0:(sum(ns) - 1),
  vp = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.sgs_+3A_ns">ns</code></td>
<td>
<p>vector with the number of samples in each segment</p>
</td></tr>
<tr><td><code id="sim.sgs_+3A_theta">theta</code></td>
<td>
<p>trait mean for initial stasis segment</p>
</td></tr>
<tr><td><code id="sim.sgs_+3A_omega">omega</code></td>
<td>
<p>trait variance for stasis segments</p>
</td></tr>
<tr><td><code id="sim.sgs_+3A_ms">ms</code></td>
<td>
<p>step mean during random walk segment</p>
</td></tr>
<tr><td><code id="sim.sgs_+3A_vs">vs</code></td>
<td>
<p>step variance during random walk segment</p>
</td></tr>
<tr><td><code id="sim.sgs_+3A_nn">nn</code></td>
<td>
<p>vector of sample sizes for each population</p>
</td></tr>
<tr><td><code id="sim.sgs_+3A_tt">tt</code></td>
<td>
<p>vector of times (ages) for each population</p>
</td></tr>
<tr><td><code id="sim.sgs_+3A_vp">vp</code></td>
<td>
<p>phenotypic trait variance for each population</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trait evolution proceeds in three segments: Stasis, General random walk, stasis (sgs).
The initial stasis segment has a mean of <code>theta</code> and variance <code>omega</code> before
shifting in the second segment to a general random walk with parameters <code>ms</code> and
<code>vs</code>. Finally, the third segment is a return to stasis, centered around the trait value
of the last population of the random walk.
</p>


<h3>Value</h3>

<p>a <code>paleoTS</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.sgs()  # default values OK
plot(x)
</code></pre>

<hr>
<h2 id='sim.Stasis'>Simulate Stasis time-series for trait evolution</h2><span id='topic+sim.Stasis'></span>

<h3>Description</h3>

<p>Simulate Stasis time-series for trait evolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.Stasis(
  ns = 20,
  theta = 0,
  omega = 0,
  vp = 1,
  nn = rep(20, ns),
  tt = 0:(ns - 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.Stasis_+3A_ns">ns</code></td>
<td>
<p>number of populations in the sequence</p>
</td></tr>
<tr><td><code id="sim.Stasis_+3A_theta">theta</code></td>
<td>
<p>mean of populations</p>
</td></tr>
<tr><td><code id="sim.Stasis_+3A_omega">omega</code></td>
<td>
<p>variance among populations</p>
</td></tr>
<tr><td><code id="sim.Stasis_+3A_vp">vp</code></td>
<td>
<p>phenotypic variance within populations</p>
</td></tr>
<tr><td><code id="sim.Stasis_+3A_nn">nn</code></td>
<td>
<p>vector of population sample sizes</p>
</td></tr>
<tr><td><code id="sim.Stasis_+3A_tt">tt</code></td>
<td>
<p>vector of population times (ages)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>paleoTS</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.GRW">sim.GRW</a></code>, <code><a href="#topic+sim.OU">sim.OU</a></code>, <code><a href="#topic+as.paleoTS">as.paleoTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.Stasis(omega = 0.5, vp = 0.1)
w.sta &lt;- fitSimple(x, model = "Stasis")
w.ss  &lt;- fitSimple(x, model = "StrictStasis")
compareModels(w.sta, w.ss)

</code></pre>

<hr>
<h2 id='sim.Stasis.RW'>Simulate trait evolution with a mode shift</h2><span id='topic+sim.Stasis.RW'></span>

<h3>Description</h3>

<p>Trait evolution is modeled as a shift from a random walk (general or unbiased)
to stasis, or vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.Stasis.RW(
  ns = c(20, 20),
  order = c("Stasis-RW", "RW-Stasis"),
  anc = 0,
  omega = 1,
  ms = 0,
  vs = 1,
  vp = 1,
  nn = 30,
  tt = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.Stasis.RW_+3A_ns">ns</code></td>
<td>
<p>vector of the number of samples in each segment</p>
</td></tr>
<tr><td><code id="sim.Stasis.RW_+3A_order">order</code></td>
<td>
<p>whether stasis or random walk come first, one of <code>"Stasis-RW"</code> or
<code>"RW-Stasis"</code></p>
</td></tr>
<tr><td><code id="sim.Stasis.RW_+3A_anc">anc</code></td>
<td>
<p>starting trait value</p>
</td></tr>
<tr><td><code id="sim.Stasis.RW_+3A_omega">omega</code></td>
<td>
<p>variance of stasis segment</p>
</td></tr>
<tr><td><code id="sim.Stasis.RW_+3A_ms">ms</code></td>
<td>
<p>step mean during random walk segment</p>
</td></tr>
<tr><td><code id="sim.Stasis.RW_+3A_vs">vs</code></td>
<td>
<p>step variance during random walk segment</p>
</td></tr>
<tr><td><code id="sim.Stasis.RW_+3A_vp">vp</code></td>
<td>
<p>phenotypic trait variance for each population</p>
</td></tr>
<tr><td><code id="sim.Stasis.RW_+3A_nn">nn</code></td>
<td>
<p>vector of sample sizes for each population</p>
</td></tr>
<tr><td><code id="sim.Stasis.RW_+3A_tt">tt</code></td>
<td>
<p>vector of times (ages) for each population</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>anc</code> argument is the starting trait value, and if the
first segment is stasis, this is also the value of the stasis mean. When the first segment
is a random walk, the stasis mean in the second segment is equal to the true trait mean at
the end of the initial random walk.
</p>


<h3>Value</h3>

<p>a <code>paleoTSfit</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitModeShift">fitModeShift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- sim.Stasis.RW(omega = 0.1, ms = 5, order = "Stasis-RW")
x2 &lt;- sim.Stasis.RW(omega = 0.1, ms = 5, order = "RW-Stasis")
plot(x1)
plot(x2, add = TRUE, col = "blue")
abline(v = 19, lty=3)

</code></pre>

<hr>
<h2 id='std.paleoTS'>Convert time-series to standard deviation units</h2><span id='topic+std.paleoTS'></span>

<h3>Description</h3>

<p>Convert time-series to standard deviation units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std.paleoTS(y, center = c("mean", "start"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="std.paleoTS_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="std.paleoTS_+3A_center">center</code></td>
<td>
<p>optional translation of time-series according to &quot;mean&quot; or
&quot;start&quot;; see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standardization expresses each sample mean as the deviation
from the overall mean, divided by the pooled within-sample variance. Sample
variances are also divided by the pooled sample variance. <br /> <br /> Essentially,
this converts paleontological time-series data into standard deviation
units, similar to the computation of evolutionary rates in haldanes.  This
operation <em>does not</em> change the relative fit of models, but it does
facilitate the comparison of parameter estimates across time-series of
traits measured in different units. <br /> <br /> If argument <code>center</code> = &quot;start&quot;
the time-series is translated such that the trait mean of the first sample
is zero.
</p>


<h3>Value</h3>

<p>the converted <code>paleoTS</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.Stasis(ns = 8, theta = 1, omega = 4, vp = 2)
xs &lt;- std.paleoTS(x, center = "start")
plot(x, ylim = range(c(x$mm, xs$mm)))
plot(xs, col = "red", add = TRUE)
legend(x = "topright", c("unstandardized", "standardized"), lty=1, col=c("black", "red"), cex=0.7)
</code></pre>

<hr>
<h2 id='sub.paleoTS'>Subsample a paleontological time-series</h2><span id='topic+sub.paleoTS'></span>

<h3>Description</h3>

<p>Subsampling is done according to the supplied logical vector or,
if none is supplied, as a proportion of samples, randomly chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub.paleoTS(y, ok = NULL, k = 0.1, reset.time = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub.paleoTS_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="sub.paleoTS_+3A_ok">ok</code></td>
<td>
<p>a logical vector, <code>TRUE</code> for populations to retain</p>
</td></tr>
<tr><td><code id="sub.paleoTS_+3A_k">k</code></td>
<td>
<p>proportion of samples to retain, with the samples chosen randomly</p>
</td></tr>
<tr><td><code id="sub.paleoTS_+3A_reset.time">reset.time</code></td>
<td>
<p>if TRUE, resets the time so that the first population time is zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sub-sampled <code>paleoTS</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sim.GRW(ns=20)
plot(x)
xs1 &lt;- sub.paleoTS(x, k = 0.5)
plot(xs1, add = TRUE, col="green")
keep &lt;- rep(c(TRUE, FALSE), 10)
xs2 &lt;- sub.paleoTS(x, ok = keep)
plot(xs2, add = TRUE, col = "red")
</code></pre>

<hr>
<h2 id='test.var.het'>Test for heterogeneity of variances among samples in a time-series</h2><span id='topic+test.var.het'></span>

<h3>Description</h3>

<p>Test for heterogeneity of variances among samples in a time-series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.var.het(y, method = "Bartlett")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.var.het_+3A_y">y</code></td>
<td>
<p>a <code>paleoTS</code> object</p>
</td></tr>
<tr><td><code id="test.var.het_+3A_method">method</code></td>
<td>
<p>test to use; currently only <code>"Bartlett"</code> is implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the test statistic, degrees of freedom, and p-value
</p>


<h3>Note</h3>

<p>Most often, this function will be used to assess if it is reasonable to
pool variances across samples using <code>pool.var</code>. A significant result means
that the null hypothesis of equal variances across samples is rejected.  Even in
this case, however, it may still be preferable to pool variances, at least for
some populations, if sample sizes are quite low.
</p>


<h3>References</h3>

<p>Sokal, R. R and F. J. Rohlf.  1995. <em>Biometry</em> 3rd Ed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool.var">pool.var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cantius_L)
test.var.het(cantius_L)  # significant, but still may want to pool variances
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
