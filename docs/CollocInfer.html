<!DOCTYPE html><html lang="en"><head><title>Help for package CollocInfer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CollocInfer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CollocInfer-package'><p>Collocation Inference in R</p></a></li>
<li><a href='#ChemoData'><p>Chemostat Example Data</p></a></li>
<li><a href='#ChemoRMData'><p>Rosenzweig-MacArthur Model Applied to Chemostat Data</p></a></li>
<li><a href='#CollocInfer-internal'><p>CollocInfer internal functions</p></a></li>
<li><a href='#CollocInferPlots'><p>Diagnostic PLots for CollocInfer</p></a></li>
<li><a href='#FhNdata'><p>FitzHugh-Nagumo data</p></a></li>
<li><a href='#FhNest'><p>Estimated Parameters for FitzHugh-Nagumo data</p></a></li>
<li><a href='#FitMatch'><p>Estimating Hidden States</p></a></li>
<li><a href='#forward.prediction.error'><p>forward.prediction.error</p></a></li>
<li><a href='#inneropt'><p>Inner Optimization Functions</p></a></li>
<li><a href='#IntegrateForward'><p>IntegrateForward</p></a></li>
<li><a href='#make.findif'><p>Finite Difference Functions</p></a></li>
<li><a href='#make.lik'><p>Observation Process Distribution Function</p></a></li>
<li><a href='#make.logtrans'><p>Log Transforms</p></a></li>
<li><a href='#make.proc'><p>Process Distributions</p></a></li>
<li><a href='#make.transfer'><p>Transfer Functions</p></a></li>
<li><a href='#make.variance'><p>Variance Functions</p></a></li>
<li><a href='#NSdata'><p>North Shore data</p></a></li>
<li><a href='#outeropt'><p>Outer Optimization Functions</p></a></li>
<li><a href='#ParsMatch'><p>Estimate of Parameters from Smooth</p></a></li>
<li><a href='#Profile.covariance'><p>Profile.covariance</p></a></li>
<li><a href='#ProfileObjective'><p>Profile Estimation with Collocation Inference</p></a></li>
<li><a href='#Profiling+20Routines'><p>Profile Estimation Functions</p></a></li>
<li><a href='#SEIRdata'><p>SEIR data</p></a></li>
<li><a href='#setup'><p>Setup Functions for proc and lik objects</p></a></li>
<li><a href='#Smooth.LS'><p>Model-Based Smoothing Functions</p></a></li>
<li><a href='#SplineEst'><p>Spline Estimation Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Collocation Inference for Dynamic Systems</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giles Hooker &lt;ghooker@wharton.upenn.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0), fda</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Matrix, spam, deSolve, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pomp, SparseM, subplex, trust, maxLik</td>
</tr>
<tr>
<td>Description:</td>
<td>These functions implement collocation-inference
    for continuous-time and discrete-time stochastic processes.
    They provide model-based smoothing, gradient-matching,
    generalized profiling and forwards prediction error methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.gileshooker.com">http://www.gileshooker.com</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-05 04:08:20 UTC; giles</td>
</tr>
<tr>
<td>Author:</td>
<td>Giles Hooker [aut, cre],
  Luo Xiao [aut],
  James Ramsay [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-05 08:50:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='CollocInfer-package'>Collocation Inference in R</h2><span id='topic+CollocInfer-package'></span><span id='topic+CollocInfer'></span>

<h3>Description</h3>

<p>Functions carry out collocation inference method for nonlinear continuous-time
dynamic systems. These are based on basis-expansion representations for the
state of the system. Gradient-matching, profiling and EM algorithms are
supported.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> CollocInfer</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 2.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2009-08-19</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Giles Hooker,  Luo Xiao
</p>
<p>Maintainer:  Giles Hooker &lt;giles.hooker@cornell.edu&gt;
</p>


<h3>References</h3>

<p>Ramsay, James O., Giles Hooker, Jiguo Cao and David Campbell (2007), &quot;Parameter
Estimation in Ordinary Differential Equations: A Generalized Smoothing
Approach&quot;, <em>Journal of the Royal Statistical Society</em>, 69
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2006), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>

<hr>
<h2 id='ChemoData'>Chemostat Example Data</h2><span id='topic+ChemoData'></span><span id='topic+ChemoTime'></span><span id='topic+ChemoPars'></span><span id='topic+ChemoVarnames'></span><span id='topic+ChemoParnames'></span>

<h3>Description</h3>

<p>Five-species Chemostat Model</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChemoData
</code></pre>


<h3>Format</h3>


<dl>
<dt>ChemoData</dt><dd><p> A 61 by 2 matrix of data observed in a chemostat.</p>
</dd>
<dt>ChemoTime</dt><dd><p> A vector of 61 observation times corresponding to ChemoData.</p>
</dd>
<dt>ChemoPars</dt><dd><p> Named parameter vector as a starting point for estimation <code>ChemoData</code>.</p>
</dd>
<dt>ChemoVarnames</dt><dd> <p><code>c('N','C1','C2','B','S')</code>: the state variable names for the chemostat system.</p>
</dd>
<dt>ChemoParnames</dt><dd><p> parameter names for the chemostat system.</p>
</dd>
</dl>


<h3>Source</h3>

<p>Yoshida, T.,  L. E. Jones, S. P. Ellner, G. F. Fussmann and N. G. Hairston, 2003,
&quot;Rapid evolution drives ecological dynamics in a predator-prey system&quot;, Nature, 424,
pp. 303-306.
</p>

<hr>
<h2 id='ChemoRMData'>Rosenzweig-MacArthur Model Applied to Chemostat Data</h2><span id='topic+ChemoRMData'></span><span id='topic+ChemoRMTime'></span><span id='topic+ChemoRMPars'></span><span id='topic+RMvarnames'></span><span id='topic+RMparnames'></span>

<h3>Description</h3>

<p>Two-Species Rosenzweig-MacArthur Model</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChemoRMData
</code></pre>


<h3>Format</h3>


<dl>
<dt>ChemoRMData</dt><dd><p> A 108 by 2 matrix of data observed in a chemostat.</p>
</dd>
<dt>ChemoRMPars</dt><dd><p> Named parameter vector as a starting point for estimation in <code>ChemoRMData</code>.</p>
</dd>
<dt>ChemoRMTime</dt><dd><p> A vector of 108 observation times corresponding to ChemoData.</p>
</dd>
<dt>RMparnames</dt><dd><p> parameter names for the Rosenzweig-MacArthur system.</p>
</dd>
<dt>RMvarnames</dt><dd><p>  the state variable names for the  Rosenzweig-MacArthur system.</p>
</dd>
</dl>


<h3>Source</h3>

<p>Becks, L., S. P. Ellner, L. E. Jones,  and N. G. Hairston, 2010,
&quot;Reduction of adaptive genetic diversity radically alters eco-evolutionary community dynamics&quot;, Ecology Letters, 13,
pp. 989-997.
</p>

<hr>
<h2 id='CollocInfer-internal'>CollocInfer internal functions</h2><span id='topic+SplineCoefsDC2sparse'></span><span id='topic+ProfileSSE.AllPar'></span><span id='topic+ProfileErr.AllPar'></span><span id='topic+ProfileDP.AllPar'></span><span id='topic+blocks2mat'></span><span id='topic+trimr'></span><span id='topic+Newey.West'></span><span id='topic+NeweyWest.Var'></span><span id='topic+checkweights'></span><span id='topic+check.lik.proc.data.coefs'></span><span id='topic+oderhs'></span><span id='topic+chemo.ode'></span><span id='topic+ProfileErr1'></span><span id='topic+ProfileDP1'></span><span id='topic+mat'></span>

<h3>Description</h3>

<p>Internal undocumentation functions</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocks2mat(H)</code></pre>

<hr>
<h2 id='CollocInferPlots'>Diagnostic PLots for CollocInfer</h2><span id='topic+CollocInferPlots'></span>

<h3>Description</h3>

<p>Diagnostic Plots on the Results of CollocInfer</p>


<h3>Usage</h3>

<pre><code class='language-R'>CollocInferPlots(coefs,pars,lik,proc,times=NULL,data=NULL,
      cols=NULL,datacols=NULL,datanames=NULL,ObsPlot=TRUE,DerivPlot=TRUE,
      cex.axis=1.5,cex.lab=1.5,cex=1.5,lwd=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CollocInferPlots_+3A_coefs">coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients. </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_pars">pars</code></td>
<td>
<p> Vector of estimated parameters. </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_lik">lik</code></td>
<td>
 <p><code>lik</code> object defining the observation process. </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_proc">proc</code></td>
<td>
 <p><code>proc</code> object defining the state process. </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_times">times</code></td>
<td>
<p> Vector observation times for the data.</p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_data">data</code></td>
<td>
<p>  Matrix of observed data values. </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_cols">cols</code></td>
<td>
<p> Optional vector specifying a color for each state variable. </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_datacols">datacols</code></td>
<td>
<p> Optional vector specifying a color for each observation dimension. </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_datanames">datanames</code></td>
<td>
<p> Optional character vector specifying a glyph to plot the data. Taken from the column-names
of <code>data</code> if not given. </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_obsplot">ObsPlot</code></td>
<td>
<p> Should a plot of predictions and observations be given? </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_derivplot">DerivPlot</code></td>
<td>
<p> Should derivative diagnostics be produced? </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_cex.axis">cex.axis</code></td>
<td>
<p> Axis font size. </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_cex.lab">cex.lab</code></td>
<td>
<p> Label font size. </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_cex">cex</code></td>
<td>
<p> Plotting point font size </p>
</td></tr>
<tr><td><code id="CollocInferPlots_+3A_lwd">lwd</code></td>
<td>
<p> Plotting line width </p>
</td></tr>
</table>


<h3>Details</h3>

<p> Timevec is taken to be the quadrature values. Three plots can be produced:
</p>
<p>If <code>ObsPlot=TRUE</code> a plot is given of the predicted values of the observations along with
the observations themselves (if given). 
</p>
<p>If <code>DerivPlot=TRUE</code> two plots are produced. The first gives the value of the derivative of 
the estimated trajectory (dashed) and the value of the right-hand-side of the ordinary differential equation
in <code>proc</code> (hence the predicted derivative) (solid).  The second plot gives their difference in the first panel as well as the estimated trajectory in the second panel. 
</p>


<h3>Value</h3>

<p>A list containing elements used in plotting:
</p>
<table role = "presentation">
<tr><td><code>timevec</code></td>
<td>
<p> Times at which the trajectories etc were evaluated. </p>
</td></tr>
<tr><td><code>traj</code></td>
<td>
<p> Estimated value of the trajectory. </p>
</td></tr>
<tr><td><code>dtraj</code></td>
<td>
<p> Derivative of the estimated trajectory. </p>
</td></tr>
<tr><td><code>ftraj</code></td>
<td>
<p> Value of the derivative of the trajectory predicted by <code>proc</code> </p>
</td></tr>
<tr><td><code>otraj</code></td>
<td>
<p> Predicted values of the observations from <code>lik</code>. </p>
</td></tr>
</table>

<hr>
<h2 id='FhNdata'>FitzHugh-Nagumo data</h2><span id='topic+FhNdata'></span><span id='topic+FhNtimes'></span><span id='topic+FhNpars'></span><span id='topic+FhNvarnames'></span><span id='topic+FhNparnames'></span>

<h3>Description</h3>

<p>Data generated for FitzHugh-Nagumo Examples</p>


<h3>Usage</h3>

<pre><code class='language-R'>FhNdata
</code></pre>


<h3>Format</h3>


<dl>
<dt>FhNdata</dt><dd><p> A 41 by 2 matrix of data generated from the FitzHugh Nagumo equations.</p>
</dd>
<dt>FhNtimes</dt><dd><p> A vector of 41 observation times corresponding to FhNdata.</p>
</dd>
<dt>FhNpars</dt><dd><p> Named parameter vector used to generate <code>FhNdata</code>.</p>
</dd>
<dt>FhNvarnames</dt><dd> <p><code>c('V','R')</code>: the state variable names for the FitzHugh Nagumo system.</p>
</dd>
<dt>FhNparnames</dt><dd> <p><code>c('a','b','c')</code> parameter names for the FitzHugh Nagumo system.</p>
</dd>
</dl>


<h3>Source</h3>

<p>James Ramsay, Giles Hooker David Campbell and Jiguo Cao, 2007.
&quot;Parameter Estimation for Differential Equations: A Generalized Smoothing Approach&quot;.
Journal of the Royal Statistical Society Vol 69 No 5.
</p>

<hr>
<h2 id='FhNest'>Estimated Parameters for FitzHugh-Nagumo data</h2><span id='topic+FhNest'></span><span id='topic+FhNestPars'></span><span id='topic+FhNestCoefs'></span>

<h3>Description</h3>

<p>Parameters Estimated for FhN Data &ndash; used to speed up examples</p>


<h3>Usage</h3>

<pre><code class='language-R'>FhNestPars
</code></pre>


<h3>Format</h3>


<dl>
<dt>FhNestPars</dt><dd><p> Estimated parameters for the FhN Data example.</p>
</dd>
<dt>FhNestCoefs</dt><dd><p> Estimated coefficients for the FhN Data example.</p>
</dd>
</dl>


<h3>Source</h3>

<p>James Ramsay, Giles Hooker David Campbell and Jiguo Cao, 2007.
&quot;Parameter Estimation for Differential Equations: A Generalized Smoothing Approach&quot;.
Journal of the Royal Statistical Society Vol 69 No 5.
</p>

<hr>
<h2 id='FitMatch'>Estimating Hidden States</h2><span id='topic+FitMatchOpt'></span><span id='topic+FitMatchErr'></span><span id='topic+FitMatchDC'></span><span id='topic+FitMatchDC2'></span><span id='topic+FitMatchList'></span>

<h3>Description</h3>

<p>Estimating hidden states to maximize agreement with the process.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>FitMatchOpt(coefs,which,pars,proc,meth='nlminb',control=list())

FitMatchErr(coefs,allcoefs,which,pars,proc,sgn=1)

FitMatchDC(coefs,allcoefs,which,pars,proc,sgn=1)

FitMatchDC2(coefs,allcoefs,which,pars,proc,sgn=1)

FitMatchList(coefs,allcoefs,which,pars,proc,sgn=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FitMatch_+3A_coefs">coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients for the hidden states. </p>
</td></tr>
<tr><td><code id="FitMatch_+3A_allcoefs">allcoefs</code></td>
<td>
<p> Matrix giving the coefficients of all the states including initial values for <code>coefs</code>.</p>
</td></tr> 
<tr><td><code id="FitMatch_+3A_which">which</code></td>
<td>
<p>  Vector of indices of states to be estimated. </p>
</td></tr>
<tr><td><code id="FitMatch_+3A_pars">pars</code></td>
<td>
<p> Parameters to be used for the processes. </p>
</td></tr>
<tr><td><code id="FitMatch_+3A_proc">proc</code></td>
<td>
 <p><code>proc</code> object defining the state process. </p>
</td></tr>
<tr><td><code id="FitMatch_+3A_sgn">sgn</code></td>
<td>
<p> Is the minimizing (1) or maximizing (0)? </p>
</td></tr>
<tr><td><code id="FitMatch_+3A_meth">meth</code></td>
<td>
<p> Optimization function currently one of 'nlminb', 'MaxNR', 'optim' or 'trust'. </p>
</td></tr>
<tr><td><code id="FitMatch_+3A_control">control</code></td>
<td>
<p> Control object for optimization function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These routines allow the values of coefficients for some states to be optimized relative to the others. That is, the
objective defined by <code>proc</code> is minimized over those states specified in <code>which</code> leaving the others constant. This
would be typically done, for example, a smooth is taken to estimate some states non-parametrically, but data is not available on all
of them.
</p>
<p>A number of optimization routines have been implemented in <code>FitMatchOpt</code>, some experimentation is advised.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>FitMatchOpt</code></td>
<td>
<p>A list containing
</p>

<dl>
<dt>coefs</dt><dd><p> The optimized coefficients for all states.</p>
</dd>
<dt>res</dt><dd><p> The output of the optimization routine.</p>
</dd>
</dl>
</td></tr>
<tr><td><code>FitMatchErr</code></td>
<td>
<p>The value of the process likelihood at the current estimated states.</p>
</td></tr>
<tr><td><code>FitMatchDC</code></td>
<td>
<p>The derivative of <code>FitMatchErr</code> with respect to the elements <code>coefs</code> for the states being estimated.</p>
</td></tr>
<tr><td><code>FitMatchDC2</code></td>
<td>
<p>The second derivative of <code>FitMatchErr</code> with respect to the elements <code>coefs</code> for the states being estimated.</p>
</td></tr>
<tr><td><code>FitMatchList</code></td>
<td>
<p>Returns a list with elements <code>value</code>, <code>gradient</code> and <code>hessian</code> given by the output of
<code>FitMatchErr</code>, <code>FitMatchDC</code> and <code>FitMatchDC2</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ParsMatchErr">ParsMatchErr</a></code>, <code><a href="#topic+SplineCoefsErr">SplineCoefsErr</a></code>, <code><a href="#topic+inneropt">inneropt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>###############################
#### Some Data            #####
###############################

data(FhNdata)

# And parameter estimates

data(FhNest)


###############################
####  Basis Object      #######
###############################

knots = seq(0,20,0.2)
norder = 3
nbasis = length(knots) + norder - 2
range = c(0,20)

bbasis = create.bspline.basis(range=range(FhNtimes),nbasis=nbasis,
	norder=norder,breaks=knots)


# Initial values for coefficients will be obtained by smoothing

fd.data = FhNdata[,1]

DEfd = smooth.basis(FhNtimes,fd.data,fdPar(bbasis,1,0.5))   

coefs = cbind(DEfd$fd$coefs,rep(0,nbasis))
colnames(coefs) = FhNvarnames

#############################################################
### If We Only Observe One State, We Can Re-Smooth Others ### 
#############################################################

profile.obj = LS.setup(pars=FhNpars,coefs=coefs,fn=make.fhn(),
                      basisvals=bbasis,lambda=1000,times=FhNtimes)
lik = profile.obj$lik
proc= profile.obj$proc

#  DD = Matrix(diag(1,200),sparse=TRUE)
#  tDD = t(DD)

fres = FitMatchOpt(coefs=coefs,which=2,pars=FhNpars,proc)

plot(fd(fres$coefs,bbasis))
</code></pre>

<hr>
<h2 id='forward.prediction.error'>forward.prediction.error</h2><span id='topic+forward.prediction.error'></span>

<h3>Description</h3>

<p> Forward prediction error objective for choice of lambda in square error criteria.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>forward.prediction.error(times,data,coefs,lik,proc,pars,whichtimes=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forward.prediction.error_+3A_times">times</code></td>
<td>
<p> Vector observation times for the data.</p>
</td></tr>
<tr><td><code id="forward.prediction.error_+3A_data">data</code></td>
<td>
<p>  Matrix of observed data values. </p>
</td></tr>
<tr><td><code id="forward.prediction.error_+3A_coefs">coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients in the spline. </p>
</td></tr>
<tr><td><code id="forward.prediction.error_+3A_lik">lik</code></td>
<td>
 <p><code>lik</code> object defining the observation process. </p>
</td></tr>
<tr><td><code id="forward.prediction.error_+3A_proc">proc</code></td>
<td>
 <p><code>proc</code> object defining the state process. </p>
</td></tr>
<tr><td><code id="forward.prediction.error_+3A_pars">pars</code></td>
<td>
<p> Initial values of parameters to be estimated processes. </p>
</td></tr>
<tr><td><code id="forward.prediction.error_+3A_whichtimes">whichtimes</code></td>
<td>
<p> Specifies the start and end times for forward prediction, given by indeces of <code>times</code>. This can be one of
</p>

<dl>
<dt>list</dt><dd><p> each element of the list is itself a list of length 2; the first element gives the
starting time to use and the second is a vector giving the prediction times.</p>
</dd>
<dt>matrix</dt><dd><p> the first column giving the starting times and the second giving the ending times.</p>
</dd>
</dl>

<p>If left NULL, <code>whichtimes</code> defaults to predicting one observation ahead from each observation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Forward prediction error can be used to choose values of <code>lambda</code> in the profiled
estimation routines. The ordinary differential equation is solved starting from the starting
times specified in <code>whichtimes</code> and measured at the corresponding measurement times. The error is then recorded.
This should then be minimized by a grid search. </p>


<h3>Value</h3>

<p>The forwards prediction error from the estimates.  </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ProfileSSE">ProfileSSE</a></code>, <code><a href="#topic+outeropt">outeropt</a></code></p>

<hr>
<h2 id='inneropt'>Inner Optimization Functions</h2><span id='topic+inneropt'></span>

<h3>Description</h3>

<p>Estmates coefficients given parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>inneropt(data,times,pars,coefs,lik,proc,in.meth='nlminb',control.in=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inneropt_+3A_data">data</code></td>
<td>
<p>  Matrix of observed data values. </p>
</td></tr>
<tr><td><code id="inneropt_+3A_times">times</code></td>
<td>
<p> Vector observation times for the data.</p>
</td></tr>
<tr><td><code id="inneropt_+3A_pars">pars</code></td>
<td>
<p> Initial values of parameters to be estimated processes. </p>
</td></tr>
<tr><td><code id="inneropt_+3A_coefs">coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients in the spline. </p>
</td></tr>
<tr><td><code id="inneropt_+3A_lik">lik</code></td>
<td>
 <p><code>lik</code> object defining the observation process. </p>
</td></tr>
<tr><td><code id="inneropt_+3A_proc">proc</code></td>
<td>
 <p><code>proc</code> object defining the state process. </p>
</td></tr>
<tr><td><code id="inneropt_+3A_in.meth">in.meth</code></td>
<td>
<p> Inner optimization function currently one of 'nlminb', 'maxNR', 'optim', 'trust' or 'SplineEst'.
The last calls <code>SplineEst.NewtRaph</code>. This is fast but has poor convergence.  </p>
</td></tr>
<tr><td><code id="inneropt_+3A_control.in">control.in</code></td>
<td>
<p> Control object for inner optimization function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This minimizes the objective function defined by the addition of the <code>lik</code>
and <code>proc</code> objectives with respect to the coefficients. A number of generic
optimization routines can be used and some experimentation is recommended. </p>


<h3>Value</h3>

<p>A list with elements
</p>
<table role = "presentation">
<tr><td><code>coefs</code></td>
<td>
<p>A matrix giving he optimized coefficients.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>The results of the inner optimization function.</p>
</td></tr> </table>


<h3>See Also</h3>

<p><code><a href="#topic+outeropt">outeropt</a></code>, <code><a href="#topic+Smooth.LS">Smooth.LS</a></code>,<code><a href="#topic+LS.setup">LS.setup</a></code>, <code><a href="#topic+multinorm.setup">multinorm.setup</a></code>, <code><a href="#topic+SplineCoefsErr">SplineCoefsErr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# FitzHugh-Nagumo Equations

data(FhNdata)   # Some data
data(FhNest)    # with some parameter estimates

knots = seq(0,20,0.2)         # Create a basis
norder = 3
nbasis = length(knots) + norder - 2
range = c(0,20)

bbasis = create.bspline.basis(range=range(FhNtimes),nbasis=nbasis,
                                    norder=norder,breaks=knots)

lambda = 10000               # Penalty value

DEfd = smooth.basis(FhNtimes,FhNdata,fdPar(bbasis,1,0.5))   # Smooth to estimate
                                                            # coefficients first
coefs = DEfd$fd$coefs
colnames(coefs) = FhNvarnames

profile.obj = LS.setup(pars=FhNpars,coefs=coefs,fn=make.fhn(),
                        basisvals=bbasis,lambda=lambda,times=FhNtimes)

lik = profile.obj$lik
proc= profile.obj$proc

res = inneropt(FhNdata,times=FhNtimes,FhNpars,coefs,lik,proc,in.meth='nlminb')

plot(fd(res$coefs,bbasis))

## End(Not run)</code></pre>

<hr>
<h2 id='IntegrateForward'>IntegrateForward</h2><span id='topic+IntegrateForward'></span>

<h3>Description</h3>

<p> Solves a differential equation going forward based on a <code>proc</code> object. </p>


<h3>Usage</h3>

<pre><code class='language-R'>IntegrateForward(y0,ts,pars,proc,more)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IntegrateForward_+3A_y0">y0</code></td>
<td>
<p> Initial conditions to start from. </p>
</td></tr>
<tr><td><code id="IntegrateForward_+3A_ts">ts</code></td>
<td>
<p> Vector of time points at which to report values of the differential equation solution. </p>
</td></tr>
<tr><td><code id="IntegrateForward_+3A_pars">pars</code></td>
<td>
<p> Initial values of parameters to be estimated processes. </p>
</td></tr>
<tr><td><code id="IntegrateForward_+3A_proc">proc</code></td>
<td>
<p> Object defining the state process. This can either be a function evaluating
the right hand side of the differential equation or a <code>proc</code> object. If a <code>proc</code> object is given, <code>proc$more$fn</code> is assumed to give the right
hand side of the differential equation. </p>
</td></tr>
<tr><td><code id="IntegrateForward_+3A_more">more</code></td>
<td>
<p> If <code>proc</code> is a function, this contains a list of additional inputs. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the output from solving the differential equation using the <code>lsoda</code> routines. 
Specifically, it returns a list with elements
</p>

<dl>
<dt>times</dt><dd><p> The output times. </p>
</dd>
<dt>states</dt><dd><p> The output states. </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Profile.LS">Profile.LS</a></code>, <code><a href="#topic+Profile.multinorm">Profile.multinorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>proc = make.SSEproc()
proc$more = make.fhn()
proc$more$names = c('V','R')

y0 = c(-1,1)
names(y0) = c('V','R')

pars = c(0.2,0.2,3)
names(pars) = c('a','b','c')

ts = seq(0,20,0.5)

value = IntegrateForward(y0,ts,pars,proc)

matplot(value$times,value$states)
</code></pre>

<hr>
<h2 id='make.findif'>Finite Difference Functions</h2><span id='topic+make.findif'></span><span id='topic+make.findif.ode'></span><span id='topic+make.findif.loglik'></span><span id='topic+make.findif.var'></span>

<h3>Description</h3>

<p>Returns a list of functions that calculate finite difference derivatives.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>make.findif.ode()

make.findif.loglik()

make.findif.var()
</code></pre>


<h3>Details</h3>

<p>All these functions require the sepcification of <code>more$eps</code> to give the size of the
finite differencing step. They also require <code>more</code> to specify the original object (ODE right hand side functions,
definitions of <code>lik</code> and <code>proc</code> objects).</p>


<h3>Value</h3>

<p>A list of functions that calculate the derivatives via finite differencing schemes. 
</p>
<table role = "presentation">
<tr><td><code>make.findif.ode</code></td>
<td>
<p> calculates finite differences of a transform.</p>
</td></tr>
<tr><td><code>make.findif.loglik</code></td>
<td>
<p> returns the finite differences to a calculated log likelihood; used
within <code>lik</code> objects, or as <code>more</code> arguments to <code>Cproc</code> or <code>Dproc</code>.</p>
</td></tr>
<tr><td><code>make.findif.var</code></td>
<td>
<p> finite difference approximations to variances; mostly used in
the <code>Multinorm</code> functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+LS.setup">LS.setup</a></code>, <code><a href="#topic+multinorm.setup">multinorm.setup</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Sum of squared errors with finite differencing to get right-hand-side derivatives

proc = make.SSEproc()
proc$more = make.findif.ode()


# Finite differencing for the log likelihood

lik = make.findif.loglik()
lik$more = make.SSElik()


# Multivariate normal transitions with finite differencing for mean and variance functions

lik = make.multinorm()
lik$more = c(make.findif.ode,make.findif.var)

# Finite differencing for transition density of a discrete time system

proc = make.Dproc()
proc$more = make.findif.loglik()

</code></pre>

<hr>
<h2 id='make.lik'>Observation Process Distribution Function</h2><span id='topic+make.lik'></span><span id='topic+make.SSElik'></span><span id='topic+make.multinorm'></span><span id='topic+pomp.dmeasure'></span>

<h3>Description</h3>

<p>Returns a list of functions that calculate the observation process distribution and its derivatives;
designed to be used with the collocation inference functions. </p>


<h3>Usage</h3>

<pre><code class='language-R'>make.SSElik()

make.multinorm()
</code></pre>


<h3>Details</h3>

<p>These functions require <code>more</code> to be a list with elements:
</p>

<dl>
<dt><code>fn</code></dt><dd><p> The transform function of the states to observations, or to their derivatives.</p>
</dd>
<dt><code>dfdx</code></dt><dd><p> The derivative of <code>fn</code> with respect to states.</p>
</dd>
<dt><code>dfdp</code></dt><dd><p> The derivative of <code>fn</code> with respect to parameters. </p>
</dd>
<dt><code>d2fdx2</code></dt><dd><p> The second derivative of <code>fn</code> with respect to states.</p>
</dd>
<dt><code>d2fdxdp</code></dt><dd><p> The cross derivative of <code>fn</code> with respect to states and parameters.</p>
</dd>
</dl>

<p><code>make.Multinorm</code> further requires:
</p>

<dl>
<dt><code>var.fn</code></dt><dd><p> The variance given in terms of states and parameters. </p>
</dd>
<dt><code>var.dfdx</code></dt><dd><p> The derivative of <code>var.fn</code> with respect to states.</p>
</dd>
<dt><code>var.dfdp</code></dt><dd><p> The derivative of <code>var.fn</code> with respect to parameters. </p>
</dd>
<dt><code>var.d2fdx2</code></dt><dd><p> The second derivative of <code>var.fn</code> with respect to states.</p>
</dd>
<dt><code>var.d2fdxdp</code></dt><dd><p> The cross derivative of <code>var.fn</code> with respect to states and parameters.</p>
</dd>
</dl>

<p><code>make.SSElik</code> further requres <code>weights</code> giving weights to each observation.
</p>


<h3>Value</h3>

<p>A list of functions that calculate the log observation distribution and its derivatives.
</p>
<table role = "presentation">
<tr><td><code>make.SSElik</code></td>
<td>
<p> calculates weighted squared error between predictions
(given by <code>fn</code> in <code>more</code>)  and observations</p>
</td></tr>
<tr><td><code>make.Multinorm</code></td>
<td>
<p> calculates a multivariate normal distribution.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+LS.setup">LS.setup</a></code>, <code><a href="#topic+multinorm.setup">multinorm.setup</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Straightforward sum of squares:

lik = make.SSElik()
lik$more = make.id()

# Multivariate normal about an exponentiated state with constant variance

lik = make.multinorm()
lik$more = c(make.exp(),make.cvar())

</code></pre>

<hr>
<h2 id='make.logtrans'>Log Transforms</h2><span id='topic+make.logtrans'></span><span id='topic+make.exptrans'></span><span id='topic+make.logstate.lik'></span><span id='topic+make.exp.Cproc'></span><span id='topic+make.exp.Dproc'></span>

<h3>Description</h3>

<p>Functions to modify liklihood, transform, <code>lik</code> and <code>proc</code>
objects so that the operate with the state defined on a log scale.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.logtrans()

make.exptrans()

make.logstate.lik()

make.exp.Cproc()

make.exp.Dproc()
</code></pre>


<h3>Details</h3>

<p> All functions require <code>more</code> to specify the original object (ODE right hand side functions,
definitions of <code>lik</code> and <code>proc</code> objects).</p>


<h3>Value</h3>

<p>A list of functions that calculate log transforms and derivatives in various contexts.
</p>
<table role = "presentation">
<tr><td><code>make.logtrans</code></td>
<td>
<p> modifies the right hand side of a differential equation and its
derivatives for a loged state vector. </p>
</td></tr>
<tr><td><code>make.exptrans</code></td>
<td>
<p> modfies a map from states to observations to a map from logged states
to observations along with its derivatives. </p>
</td></tr>
<tr><td><code>make.logstate.lik</code></td>
<td>
<p> modifies a <code>lik</code> object for state vectors given on the log scale. </p>
</td></tr>
<tr><td><code>make.exp.Cproc</code></td>
<td>
 <p><code>Cproc</code> with the state given on the log scale.</p>
</td></tr>
<tr><td><code>make.exp.Dproc</code></td>
<td>
 <p><code>Dproc</code> with the state given on the log scale.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+LS.setup">LS.setup</a></code>, <code><a href="#topic+make.Cproc">make.Cproc</a></code>, <code><a href="#topic+make.Dproc">make.Dproc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Model the log of an SEIR process

proc = make.SSEproc()
proc$more = make.logtrans()
proc$more$more = make.SEIR()

# Observe a linear combination  of

lik = make.logstate.lik()
lik$more = make.SSElik()
lik$more$more = make.genlin()

# SEIR Model with multivariate transition densities

proc = make.exp.Cproc()
proc$more = make.multinorm()
proc$more$more = c(make.SEIR(),make.cvar())

</code></pre>

<hr>
<h2 id='make.proc'>Process Distributions</h2><span id='topic+make.Dproc'></span><span id='topic+make.Cproc'></span><span id='topic+make.SSEproc'></span>

<h3>Description</h3>

<p>Functions to define process distributions in the collocation inference package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.Dproc()

make.Cproc()

make.SSEproc()
</code></pre>


<h3>Details</h3>

<p>All functions require <code>more</code> to specify this distribution. This should be a list containing
</p>

<dl>
<dt><code>fn</code></dt><dd><p> The distribution specified.</p>
</dd>
<dt><code>dfdx</code></dt><dd><p> The derivative of <code>fn</code> with respect to states.</p>
</dd>
<dt><code>dfdp</code></dt><dd><p> The derivative of <code>fn</code> with respect to parameters. </p>
</dd>
<dt><code>d2fdx2</code></dt><dd><p> The second derivative of <code>fn</code> with respect to states.</p>
</dd>
<dt><code>d2fdxdp</code></dt><dd><p> The cross derivative of <code>fn</code> with respect to states and parameters.</p>
</dd>
</dl>

<p>For <code>Cproc</code> and <code>Dproc</code> this should specify the distribution; for <code>SSEproc</code> it
should specify the right hand side of a differential equation. 
</p>


<h3>Value</h3>

<p>A list of functions that the process distribution
</p>
<table role = "presentation">
<tr><td><code>make.Cproc</code></td>
<td>
<p> creates functions to evaluate the distribution of the derivative of
the state vector given the current state for continuous-time systems.  </p>
</td></tr>       
<tr><td><code>make.Dproc</code></td>
<td>
<p> creates functions to evaluate the distribution of the next time point of
the state vector given the current state for discrete-state systems.  </p>
</td></tr>
<tr><td><code>make.SSEproc</code></td>
<td>
<p> treats the distribution of the derivative as an independent gaussian and
cacluates weighted sums of squared errors between derivatives and the prediction from the current state.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+LS.setup">LS.setup</a></code>, <code><a href="#topic+multinorm.setup">multinorm.setup</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# FitzHugh-Nagumo Equations

proc = make.SSEproc()
proc$more = make.fhn()

# Henon Map

proc = make.Dproc()
proc$more = make.Henon


# SEIR with multivariate normal transitions

proc = make.Cproc()
proc$more = make.multinorm()
proc$more$more = c(make.SEIR(),make.var.SEIR())

</code></pre>

<hr>
<h2 id='make.transfer'>Transfer Functions</h2><span id='topic+make.transfer'></span><span id='topic+make.id'></span><span id='topic+make.exp'></span><span id='topic+make.genlin'></span><span id='topic+make.fhn'></span><span id='topic+make.Henon'></span><span id='topic+make.SEIR'></span><span id='topic+make.NS'></span><span id='topic+make.diagnostics'></span><span id='topic+chemo.fun'></span><span id='topic+pomp.skeleton'></span>

<h3>Description</h3>

<p>Returns a list of functions that calculate the transform and its derivatives. </p>


<h3>Usage</h3>

<pre><code class='language-R'>make.id()

make.exp()

make.genlin()

make.fhn()

make.Henon()

make.SEIR()

make.NS()

chemo.fun(times,y,p,more=NULL)
</code></pre>


<h3>Arguments</h3>

<p>All the functions 
created by <code>make...</code> functions, require the arguments needed by  <code>chemo.fun</code>
</p>
<table role = "presentation">
<tr><td><code id="make.transfer_+3A_times">times</code></td>
<td>
<p> Evaluation times</p>
</td></tr>
<tr><td><code id="make.transfer_+3A_y">y</code></td>
<td>
<p> Values of the state at the evaluation times </p>
</td></tr>
<tr><td><code id="make.transfer_+3A_p">p</code></td>
<td>
<p> Parameters to be used </p>
</td></tr>
<tr><td><code id="make.transfer_+3A_more">more</code></td>
<td>
<p> A list of additional arguments, in this case <code>NULL</code>, for
<code>pomp.sekelton</code> and <code>pomp.dmeasure</code>, <code>more</code> should be a list containing a <code>pomp</code> object
in the element <code>pomp.obj</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make.genlin</code> requires the specification of further elements in the list. In particular
the element <code>more</code> should be a list containing
</p>

<dl>
<dt><code>mat</code></dt><dd><p> a matrix defining the linear transform before any parameters are added.
This may be all zero, but it may also specify fixed elements, if desired. </p>
</dd>
<dt><code>sub</code></dt><dd><p> a k-by-3 matrix indicating which parameters should be entered into
which elements of <code>mat</code>. Each row is a triple giving the row and colum of <code>mat</code> to be 
specified and the element of the parameter vector that should be substituted. <code>sub</code> over-rides
any values in <code>mat</code>.</p>
</dd>
<dt><code>force</code></dt><dd><p> if input functions are given, these are given as a list.</p>
</dd>
<dt><code>force.mat</code></dt><dd><p> specifying the influence of the elements of <code>force</code> on the state
variables. Defined as in <code>mat</code>.</p>
</dd>
<dt><code>force.sub</code></dt><dd><p> defined as in <code>sub</code>, over-rides the elements of <code>force.mat</code> with
parameter values.</p>
</dd>
</dl>

<p><code>make.diagnostics</code> estimates forcing-function diagnostics as in Hooker, 2009 for 
goodness-of-fit assessment. It requires
</p>

<dl>
<dt><code>psi</code></dt><dd><p> Values of a basis expansion for forcing functions at the quadrature points. </p>
</dd>
<dt><code>which</code></dt><dd><p> Which states are to be forced? </p>
</dd>
<dt><code>fn</code>, <code>dfdx</code>, <code>d2fdx2</code></dt><dd><p> Functions and derivatives as would be used to estimate 
parameters for the original equations. </p>
</dd>
<dt>pars</dt><dd><p> Parameters to go into <code>more$fn</code>. </p>
</dd>
</dl>

<p><code>make.SEIR</code> estimates parameters and a seasonal variation in the infection rate in an 
SEIR model.  It requires the specification of the seasonal change rate in <code>more</code> by
a list with objects
</p>

<dl>
<dt><code>beta.fun</code></dt><dd><p> A function to calculate beta, it should have arguments <code>t</code>, 
<code>p</code> and <code>betadef</code> and return a matrix giving the value of beta at times <code>t</code> 
with parameters <code>p</code>. </p>
</dd>
<dt><code>beta.dfdp</code></dt><dd><p> Should calculate the derivative of <code>beta.fun</code> with respect to <code>p</code>,
at times <code>t</code> returning a matrix. The matrix should be of size <code>length(t)</code> by
<code>length(p)</code> where <code>p</code> is the entire parameter vector. </p>
</dd>
<dt><code>betadef</code></dt><dd><p> Additional inputs (eg bases) to <code>beta.fun</code> and <code>beta.dfdp</code>.</p>
</dd>
</dl>

<p><code>make.NS</code> provides functions for the North Shore example. This is a possibly time-varying
forced linear system of one dimension. It requires <code>more</code> to specify <code>betabasis</code> to
describe the autoregressive coefficient, and <code>alphabasis</code> to provide a contant in front of
the functional data object <code>rainfd</code>.
</p>
<p><code>chemo.fun</code> Is a five-state predator-prey-resources model used as an example. It stands
alone as a function and should be used with the <code>findif.ode</code> functions. 
</p>


<h3>Value</h3>

<p>A list of functions that calculate the transform and its derivatives,
in a form compatible with the collocation inference functions.
</p>
<table role = "presentation">
<tr><td><code>make.id</code></td>
<td>
<p> returns the identity transform.</p>
</td></tr>
<tr><td><code>make.exp</code></td>
<td>
<p> returns the exponential transform.</p>
</td></tr>
<tr><td><code>make.genlin</code></td>
<td>
<p> returns a linear combination transform &ndash; see details section below.</p>
</td></tr>
<tr><td><code>make.fhn</code></td>
<td>
<p> returns the FitzHugh-Nagumo equations.</p>
</td></tr>
<tr><td><code>make.Henon</code></td>
<td>
<p> reutrns the Henon map.</p>
</td></tr>
<tr><td><code>make.SEIR</code></td>
<td>
<p> returns SEIR equations for estimating the shape of a seasonal forcing component. </p>
</td></tr>
<tr><td><code>make.diagnostics</code></td>
<td>
<p> functions to perform forcing function diagnostics. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+LS.setup">LS.setup</a></code>, <code><a href="#topic+multinorm.setup">multinorm.setup</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Observe the FitzHugh-Nagumo equations

proc = make.SSEproc()
proc$more = make.fhn()

lik = make.SSElik()
lik$more = make.id()

# Observe an unknown scalar transform of each component of a Henon map, given
# in the first two elements of the parameter vector:

proc = make.Dproc()
proc$more = make.multinorm()
proc$more$more = c(make.Henon,make.cvar)

lik = make.multinorm()
lik$more = c(make.genlin,make.cvar)
lik$more$more = list(mat = matrix(0,2,2),sub=matrix(c(1,1,1,2,2,2),2,3,byrow=TRUE))

# Model SEIR equations on the log scale and then exponentiate

lik = make.SSElik()
lik$more = make.exp()

proc = make.SSEproc()
proc$more = make.logtrans()
proc$more$more = make.SEIR()

</code></pre>

<hr>
<h2 id='make.variance'>Variance Functions</h2><span id='topic+make.variance'></span><span id='topic+make.cvar'></span><span id='topic+make.var.SEIR'></span>

<h3>Description</h3>

<p>Returns a list of functions that calculate a (possibly state and parameter dependent) variance. </p>


<h3>Usage</h3>

<pre><code class='language-R'>make.cvar()

make.var.SEIR()
</code></pre>


<h3>Details</h3>

<p><code>make.cvar</code> requires the specification of further elements in the list. In particular
the element <code>more</code> should be a list containing
</p>


<h3>Value</h3>

<p>A list of functions that calculate a variance function and its derivatives,
in a form compatible with the collocation inference functions.
</p>
<table role = "presentation">
<tr><td><code>make.cvar</code></td>
<td>
<p> returns a variance that is constant but may depend on parameters </p>
</td></tr>
<tr><td><code>make.var.SEIR</code></td>
<td>
<p> returns a state-dependent transition covariance matrix calculated for the SEIR equations.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+make.multinorm">make.multinorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Multivariate normal observation of the state vector.

lik = make.multinorm()
lik$more = c(make.id(),make.cvar())

</code></pre>

<hr>
<h2 id='NSdata'>North Shore data</h2><span id='topic+NSgroundwater'></span><span id='topic+NSrainfall'></span><span id='topic+NStimes'></span>

<h3>Description</h3>

<p>Groundwater Data from Vancouver's North Shore</p>


<h3>Usage</h3>

<pre><code class='language-R'>NSgroundwater
</code></pre>


<h3>Format</h3>


<dl>
<dt>NSgroundwater</dt><dd><p> A 315 by 1 matrix of data on groundwater level collected in vancouver.</p>
</dd>
<dt>NStimes</dt><dd><p> A vector of 315 observation times corresponding to NSgroundwater.</p>
</dd>
<dt>NSrainfall</dt><dd><p> Rainfall as a covariate to NSgroundwater; this quantity is lagged by 3 days. </p>
</dd>
</dl>

<hr>
<h2 id='outeropt'>Outer Optimization Functions</h2><span id='topic+outeropt'></span>

<h3>Description</h3>

<p>Outer optimization; performs profiled estimation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>outeropt(data,times,pars,coefs,lik,proc,
      in.meth='nlminb',out.meth='nlminb',
      control.in=list(),control.out=list(),active=1:length(pars))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outeropt_+3A_data">data</code></td>
<td>
<p>  Matrix of observed data values. </p>
</td></tr>
<tr><td><code id="outeropt_+3A_times">times</code></td>
<td>
<p> Vector observation times for the data.</p>
</td></tr>
<tr><td><code id="outeropt_+3A_pars">pars</code></td>
<td>
<p> Initial values of parameters to be estimated processes. </p>
</td></tr>
<tr><td><code id="outeropt_+3A_coefs">coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients in the spline. </p>
</td></tr>
<tr><td><code id="outeropt_+3A_lik">lik</code></td>
<td>
 <p><code>lik</code> object defining the observation process. </p>
</td></tr>
<tr><td><code id="outeropt_+3A_proc">proc</code></td>
<td>
 <p><code>proc</code> object defining the state process. </p>
</td></tr>
<tr><td><code id="outeropt_+3A_in.meth">in.meth</code></td>
<td>
<p> Inner optimization function currently one of 'nlminb', 'maxNR', 'optim' or 'SplineEst'. The last calls <code>SplineEst.NewtRaph</code>.
This is fast but has poor convergence.  </p>
</td></tr>
<tr><td><code id="outeropt_+3A_out.meth">out.meth</code></td>
<td>
<p> Outer optimization function to be used, one of 'optim' (defaults to  BFGS routine in <code>optim</code> unless <code>control.out$meth</code>
specifies otherwise), 'nlminb', 'maxNR' #, 'trust'
or 'subplex'. When squared error is being used, 'ProfileGN' and 'nls' can also be given. The former of these calls <code>Profile.GausNewt</code>,
a fast but naive Gauss-Newton solver. </p>
</td></tr>
<tr><td><code id="outeropt_+3A_control.in">control.in</code></td>
<td>
<p> Control object for inner optimization function. </p>
</td></tr>
<tr><td><code id="outeropt_+3A_control.out">control.out</code></td>
<td>
<p> Control object for outer optimization function. </p>
</td></tr>
<tr><td><code id="outeropt_+3A_active">active</code></td>
<td>
<p> Indices indicating which parameters of <code>pars</code> should be estimated; defaults to all of them.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The outer optimization for parameters looks only at the objective defined by the <code>lik</code>
object. For every parameter value, <code>coefs</code> are optimized by <code>inneropt</code> and then the value of
<code>lik</code> for these coefficients is computed.
</p>
<p>A number of optimization routines can be used here, some experimentation is recommended.  Libraries
for these optimization routines are not pre-loaded.   Where these functions take options as explicit arguments
instead of a list, they should be listed in <code>control.out</code> and will be called by their names.
</p>
<p>The routine creates
temporary files 'curcoefs.tmp' and 'optcoefs.tmp' to update coefficients as <code>pars</code> evolves. These overwrite
existing files of those names and are deleted before the function terminates.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table role = "presentation">
<tr><td><code>pars</code></td>
<td>
<p>Optimized parameters</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>Optimized coefficients at <code>pars</code></p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>The result of the outer optimization.</p>
</td></tr>
<tr><td><code>counter</code></td>
<td>
<p>A set of parameters and objective values for each successful iteration.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+inneropt">inneropt</a></code>, <code><a href="#topic+Profile.LS">Profile.LS</a></code>, <code><a href="#topic+ProfileSSE">ProfileSSE</a></code>, <code><a href="#topic+ProfileErr">ProfileErr</a></code>, <code><a href="#topic+LS.setup">LS.setup</a></code>, <code><a href="#topic+multinorm.setup">multinorm.setup</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(FhNdata)
data(FhNest)

knots = seq(0,20,0.2)         # Create a basis
norder = 3
nbasis = length(knots) + norder - 2
range = c(0,20)

bbasis = create.bspline.basis(range=range,nbasis=nbasis,norder=norder,breaks=knots)

lambda = 10000               # Penalty value

DEfd = smooth.basis(FhNtimes,FhNdata,fdPar(bbasis,1,0.5))   # Smooth to estimate
                                                            # coefficients first
coefs = DEfd$fd$coefs
colnames(coefs) = FhNvarnames

profile.obj = LS.setup(pars=FhNpars,coefs=coefs,fn=make.fhn(),basisvals=bbasis,
      lambda=lambda,times=FhNtimes)

lik = profile.obj$lik
proc= profile.obj$proc

res = outeropt(data=FhNdata,times=FhNtimes,pars=FhNpars,coefs=coefs,lik=lik,proc=proc,
    in.meth="nlminb",out.meth="nlminb",control.in=NULL,control.out=NULL)


plot(res$coefs,main='outeropt')
print(blah)

## End(Not run)</code></pre>

<hr>
<h2 id='ParsMatch'>Estimate of Parameters from Smooth</h2><span id='topic+ParsMatchOpt'></span><span id='topic+ParsMatchErr'></span><span id='topic+ParsMatchDP'></span><span id='topic+ParsMatchList'></span>

<h3>Description</h3>

<p> Objective function and derivatives to estimate parameters with a fixed smooth.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>ParsMatchOpt(pars,coefs,proc,active=1:length(pars),meth='nlminb',control=list())

ParsMatchErr(pars,coefs,proc,active=1:length(pars),allpars,sgn=1)

ParsMatchDP(pars,coefs,proc,active=1:length(pars),allpars,sgn=1)

ParsMatchList(pars,coefs,proc,active=1:length(pars),allpars,sgn=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ParsMatch_+3A_pars">pars</code></td>
<td>
<p> Initial values of parameters to be estimated processes. </p>
</td></tr>
<tr><td><code id="ParsMatch_+3A_coefs">coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients in the spline. </p>
</td></tr>
<tr><td><code id="ParsMatch_+3A_proc">proc</code></td>
<td>
 <p><code>proc</code> object defining the state process. </p>
</td></tr>
<tr><td><code id="ParsMatch_+3A_active">active</code></td>
<td>
<p> Incides indicating which parameters of <code>allpar</code> should be estimated; defaults to all of them.  </p>
</td></tr> 
<tr><td><code id="ParsMatch_+3A_allpars">allpars</code></td>
<td>
<p>  Vector of all parameters, the assignment <code>allpar[active]=pars</code> is made initially.   </p>
</td></tr>
<tr><td><code id="ParsMatch_+3A_sgn">sgn</code></td>
<td>
<p> Is the minimizing (1) or maximizing (0)? </p>
</td></tr>
<tr><td><code id="ParsMatch_+3A_meth">meth</code></td>
<td>
<p> Optimization function currently one of 'nlminb', 'MaxNR', 'optim' or 'trust'. </p>
</td></tr>
<tr><td><code id="ParsMatch_+3A_control">control</code></td>
<td>
<p> Control object for optimization function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These routines fix the estimated states at the value given by <code>coefs</code>
and estimate <code>pars</code> to maximize agreement between the fixed state and the objective
given by the <code>proc</code> object.
</p>
<p>A number of optimization routines have been implemented in <code>FitMatchOpt</code>, some experimentation is advised.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ParsMatchOpt</code></td>
<td>
<p>A list containing:
</p>

<dl>
<dt>pars</dt><dd><p>The entire parameter vector after optimization.</p>
</dd>
<dt>res</dt><dd><p>The output of the optimization routine.</p>
</dd>
</dl>
</td></tr>
<tr><td><code>ParsMatchErr</code></td>
<td>
<p>The value of the process likelihood at the current estimated states.</p>
</td></tr>
<tr><td><code>ParsMatchDP</code></td>
<td>
<p>The derivative fo <code>ParsMatchErr</code> with respect to <code>pars[active]</code>.</p>
</td></tr>
<tr><td><code>ParsMatchList</code></td>
<td>
<p>A list with entries <code>value</code> and <code>gradient</code> given by the output
of <code>ParsMatchErr</code> and <code>ParsMatchDP</code> respectively.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+FitMatchErr">FitMatchErr</a></code>, <code><a href="#topic+SplineCoefsErr">SplineCoefsErr</a></code>, <code><a href="#topic+inneropt">inneropt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FhNdata)

###############################
####  Basis Object      #######
###############################

knots = seq(0,20,0.2)
norder = 3
nbasis = length(knots) + norder - 2
range = c(0,20)

bbasis = create.bspline.basis(range=range(FhNtimes),nbasis=nbasis,
	norder=norder,breaks=knots)


# Initial values for coefficients will be obtained by smoothing

DEfd = smooth.basis(FhNtimes,FhNdata,fdPar(bbasis,1,0.5))   # Smooth to estimate
                                                            # coefficients first
coefs = DEfd$fd$coefs
colnames(coefs) = FhNvarnames



#################################
### Initial Parameter Guesses ###
#################################

profile.obj = LS.setup(pars=FhNpars,coefs=coefs,fn=make.fhn(),basisvals=bbasis,
    lambda=1000,times=FhNtimes)
lik = profile.obj$lik
proc= profile.obj$proc

pres = ParsMatchOpt(FhNpars,coefs,proc)

npars = pres$pars
</code></pre>

<hr>
<h2 id='Profile.covariance'>Profile.covariance</h2><span id='topic+Profile.covariance'></span>

<h3>Description</h3>

<p> Newey-West estimate of covariance of parameter estimates from profiling. </p>


<h3>Usage</h3>

<pre><code class='language-R'>Profile.covariance(pars,active=NULL,times,data,coefs,lik,proc,
          in.meth='nlminb',control.in=NULL,eps=1e-6,GN=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Profile.covariance_+3A_pars">pars</code></td>
<td>
<p> Initial values of parameters to be estimated processes. </p>
</td></tr>
<tr><td><code id="Profile.covariance_+3A_active">active</code></td>
<td>
<p> Incides indicating which parameters of <code>pars</code> should be estimated; defaults to all of them.  </p>
</td></tr> 
<tr><td><code id="Profile.covariance_+3A_times">times</code></td>
<td>
<p> Vector observation times for the data.</p>
</td></tr> 
<tr><td><code id="Profile.covariance_+3A_data">data</code></td>
<td>
<p>  Matrix of observed data values. </p>
</td></tr>
<tr><td><code id="Profile.covariance_+3A_coefs">coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients in the spline. </p>
</td></tr>
<tr><td><code id="Profile.covariance_+3A_lik">lik</code></td>
<td>
 <p><code>lik</code> object defining the observation process. </p>
</td></tr>
<tr><td><code id="Profile.covariance_+3A_proc">proc</code></td>
<td>
 <p><code>proc</code> object defining the state process. </p>
</td></tr>
<tr><td><code id="Profile.covariance_+3A_in.meth">in.meth</code></td>
<td>
<p> Inner optimization function currently one of 'nlminb', 'MaxNR', 'optim' or 'house'. The last calls <code>SplineEst.NewtRaph</code>. This is fast but has poor convergence.  </p>
</td></tr>
<tr><td><code id="Profile.covariance_+3A_control.in">control.in</code></td>
<td>
<p> Control object for inner optimization functions. </p>
</td></tr>
<tr><td><code id="Profile.covariance_+3A_eps">eps</code></td>
<td>
<p> Step-size for finite difference estimate of second derivatives.  </p>
</td></tr>
<tr><td><code id="Profile.covariance_+3A_gn">GN</code></td>
<td>
<p> Indicator of whether a Gauss-Newton approximation for the Hessian should be employed. Only valid for
least-squares methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently assumes a lag-5 auto-correlation among observation vectors. </p>


<h3>Value</h3>

<p>Returns a Newey-West estimate of the covariance matrix of the parameter estimates. </p>


<h3>See Also</h3>

<p><code><a href="#topic+ProfileErr">ProfileErr</a></code>, <code><a href="#topic+ProfileSSE">ProfileSSE</a></code>, <code><a href="#topic+Profile.LS">Profile.LS</a></code>, <code><a href="#topic+Profile.multinorm">Profile.multinorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See example in Profile.LS

</code></pre>

<hr>
<h2 id='ProfileObjective'>Profile Estimation with Collocation Inference</h2><span id='topic+Profile.GausNewt'></span><span id='topic+ProfileSSE'></span><span id='topic+ProfileList'></span><span id='topic+ProfileErr'></span><span id='topic+ProfileDP'></span>

<h3>Description</h3>

<p> Profile estimation and objective functions for collocation estimation of parameters in continuous-time
stochastic processes.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>Profile.GausNewt(pars,times,data,coefs,lik,proc,in.meth="nlminb",
      control.in=NULL,active=1:length(pars),
      control=list(reltol=1e-6,maxit=50,maxtry=15,trace=1))

ProfileSSE(pars,allpars,times,data,coefs,lik,proc,in.meth='nlminb',
      control.in=NULL,active=1:length(pars),dcdp=NULL,oldpars=NULL,
      use.nls=TRUE,sgn=1)
      
ProfileErr(pars,allpars,times,data,coefs,lik,proc,in.meth = "house",
      control.in=NULL,sgn=1,active=1:length(allpars))

ProfileDP(pars,allpars,times,data,coefs,lik,proc,in.meth = "house",
      control.in=NULL,sgn=1,sumlik=1,active=1:length(allpars))

ProfileList(pars,allpars,times,data,coefs,lik,proc,in.meth = "house",
      control.in=NULL,sgn=1,active=1:length(allpars))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ProfileObjective_+3A_pars">pars</code></td>
<td>
<p> Initial values of parameters to be estimated processes. </p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_allpars">allpars</code></td>
<td>
<p> Full parameter vector including <code>pars</code>. Assignment <code>allpars[active] = pars</code> is always made.</p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_times">times</code></td>
<td>
<p> Vector observation times for the data.</p>
</td></tr> 
<tr><td><code id="ProfileObjective_+3A_data">data</code></td>
<td>
<p>  Matrix of observed data values. </p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_coefs">coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients in the spline. </p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_lik">lik</code></td>
<td>
 <p><code>lik</code> object defining the observation process. </p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_proc">proc</code></td>
<td>
 <p><code>proc</code> object defining the state process. </p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_in.meth">in.meth</code></td>
<td>
<p> Inner optimization function currently one of 'nlminb', 'MaxNR', 'optim' or 'house'. The last calls <code>SplineEst.NewtRaph</code>.
This is fast but has poor convergence.  </p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_control.in">control.in</code></td>
<td>
<p> Control object for inner optimization function. </p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_sgn">sgn</code></td>
<td>
<p> Is the minimizing (1) or maximizing (0)? </p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_active">active</code></td>
<td>
<p> Incides indicating which parameters of <code>pars</code> should be estimated; defaults to all of them.  </p>
</td></tr> 
<tr><td><code id="ProfileObjective_+3A_oldpars">oldpars</code></td>
<td>
<p> Starting parameter values for the Q-function in the EM algorithm.</p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_dcdp">dcdp</code></td>
<td>
<p> Estimate for the gradient of the optimized coefficients with respect to parameters; used internally.  </p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_use.nls">use.nls</code></td>
<td>
<p> In ProfileSSE, is 'nls' being used in the outer-optimization?</p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_sumlik">sumlik</code></td>
<td>
<p> In ProfileDP and ProfileDP.AllPar; should the gradient be given for each observation, or summed over them? </p>
</td></tr>
<tr><td><code id="ProfileObjective_+3A_control">control</code></td>
<td>
<p> A list giving control parameters for Newton-Raphson optimization. It should contain
</p>

<dl>
<dt>reltol</dt><dd><p> Relative tollerance criterion for the gradient and improvement before termination. </p>
</dd>
<dt>maxit</dt><dd><p> Maximum number of iterations. </p>
</dd>
<dt>maxtry</dt><dd><p> Maximum number of halving-steps to try before declaring no improvement is possible. </p>
</dd>
<dt>trace</dt><dd><p> How much iteration history to output; 0 surpresses all output, a positive value outputs parameters and improvement at each
iteration. </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

 <p><code>Profile.GausNewt</code> provides a simple implementation of Gauss-Newton optimization and may
not result in optimized values that are as good as other optimizers in <code>R</code>.
</p>
<p>When  <code>Profile.GausNewt</code> is not being used, <code>ProfileSEE</code> and <code>ProfileERR</code> create the
following temporary files:
</p>

<dl>
<dt>counter.tmp</dt><dd><p>The number of halving-steps taken on the current optimization step.</p>
</dd>
<dt>curcoefs.tmp</dt><dd><p>The current estimates of the coefficients.</p>
</dd>
<dt>optcoefs.tmp</dt><dd><p>The optimal estimates of the coefficients in the iteration history.</p>
</dd>  </dl>

<p>These need to be removed manually when the optimization is finished. <code>optcoefs.tmp</code> will contain
the optimal value of <code>coefs</code> for plotting the estimated trajectories.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Profile.GausNewt</code></td>
<td>
<p>Output of a simple Gaus-Newton iteration to optimizing the objective function when the
observation likelihood takes the form of a sum of squared errors. Returns a list with the following elements:
</p>

<dl>
<dt>pars</dt><dd><p> The optimized value of the parameters.</p>
</dd>
<dt>in.res</dt><dd><p> The result of the inner optimization.</p>
</dd>
<dt>value</dt><dd><p> The value of the optimized sum of squared errors.</p>
</dd>
</dl>
</td></tr>
<tr><td><code>ProfileSSE</code></td>
<td>
<p>Output for the outer optimization when the observation likelihood is given by squared error. This is a list
with the following elements
</p>

<dl>
<dt>value</dt><dd><p> The value of the outer optimization criterion.</p>
</dd>
<dt>gradient</dt><dd><p> The derivative of <code>f</code> with respect to <code>pars</code>.</p>
</dd>
<dt>coefs</dt><dd><p> The optimized value of <code>coefs</code> for the current value of <code>pars</code>.</p>
</dd>
<dt>dcdp</dt><dd><p> The derivative of the optimized value of <code>coefs</code> at the current value of <code>pars</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code>ProfileErr</code></td>
<td>
<p>The outer optimization criterion in the general case: the value of the observation likelihood at the profiled
estimates of <code>coefs</code>.</p>
</td></tr>
<tr><td><code>ProfileDP</code></td>
<td>
<p>The derivative of <code>ProfileErr</code> with respect to <code>allpars[active]</code>.</p>
</td></tr>
<tr><td><code>ProfileList</code></td>
<td>
<p>Returns the results of ProfileErr and ProfileDP as a list with elements <code>value</code> and <code>gradient</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+outeropt">outeropt</a></code>, <code><a href="#topic+Profile.LS">Profile.LS</a></code>, <code><a href="#topic+Profile.multinorm">Profile.multinorm</a></code>, <code><a href="#topic+LS.setup">LS.setup</a></code>, <code><a href="#topic+multinorm.setup">multinorm.setup</a></code></p>

<hr>
<h2 id='Profiling+20Routines'>Profile Estimation Functions</h2><span id='topic+Profile.LS'></span><span id='topic+Profile.multinorm'></span>

<h3>Description</h3>

<p>These functions are wrappers that create lik and proc functions
and run generalized profiling.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Profile.LS(fn,data,times,pars,coefs=NULL,basisvals=NULL,lambda,
                        fd.obj=NULL,more=NULL,weights=NULL,quadrature=NULL,
                        likfn = make.id(), likmore = NULL,
                        in.meth='nlminb',out.meth='nls',
                        control.in,control.out,eps=1e-6,active=NULL,posproc=FALSE,
                        poslik=FALSE,discrete=FALSE,names=NULL,sparse=FALSE)

Profile.multinorm(fn,data,times,pars,coefs=NULL,basisvals=NULL,var=c(1,0.01),
                        fd.obj=NULL,more=NULL,quadrature=NULL,
                        in.meth='nlminb',out.meth='optim',
                        control.in,control.out,eps=1e-6,active=NULL,
                        posproc=FALSE,poslik=FALSE,discrete=FALSE,names=NULL,sparse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Profiling+2B20Routines_+3A_fn">fn</code></td>
<td>
<p> A function giving the right hand side of a differential/difference equation.  The function should have arguments
</p>

<dl>
<dt>times</dt><dd><p> The times at which the RHS is being evaluated.</p>
</dd>
<dt>x</dt><dd><p> The state values at those times.</p>
</dd>
<dt>p</dt><dd><p> Parameters to be entered in the system.</p>
</dd>
<dt>more</dt><dd><p> An object containing additional inputs to <code>fn</code>
</p>
</dd></dl>

<p>It should return a matrix of the same dimension of <code>x</code> giving the right hand side values.
</p>
<p>If <code>fn</code> is given as a single function, its derivatives are estimated by finite-differencing with
stepsize <code>eps</code>. Alternatively, a list can be supplied with elements:
</p>

<dl>
<dt>fn</dt><dd><p> Function to calculate the right hand side should accept a matrix of state values at .</p>
</dd>
<dt>dfdx</dt><dd><p> Function to calculate the derivative with respect to <code>x</code></p>
</dd>
<dt>dfdp</dt><dd><p> Function to calculate the derivative with respect to <code>p</code></p>
</dd>
<dt>d2fdx2</dt><dd><p> Function to calculate the second derivative with respect to <code>x</code></p>
</dd>
<dt>d2fdxdp</dt><dd><p> Function to calculate the second derivative with respect to <code>x</code> and <code>p</code></p>
</dd>
</dl>

<p>These functions take the same arguments as <code>fn</code> and should output multidimensional arrays with
the dimensions ordered according to time, state, deriv1, deriv2; here derivatives with respect to <code>x</code>
always precede derivatives with respect to <code>p</code>.</p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_data">data</code></td>
<td>
<p>  Matrix of observed data values. </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_times">times</code></td>
<td>
<p> Vector observation times for the data.</p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_pars">pars</code></td>
<td>
<p> Initial values of parameters to be estimated processes. </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_coefs">coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients in the spline. </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_basisvals">basisvals</code></td>
<td>
<p>Values of the collocation basis to be used. This can either be a basis object from the <code>fda</code> package,
or a list elements:
</p>

<dl>
<dt>bvals.obs</dt><dd><p> A matrix giving the values of the basis at the observation times</p>
</dd>
<dt>bvals</dt><dd><p> A matrix giving the values of the basis at the quadrature times</p>
</dd>
<dt>dbvals</dt><dd><p> A matrix giving the derivative of the basis at the quadrature times</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_lambda">lambda</code></td>
<td>
<p>(<code>Profile.LS</code> only) Penalty value trading off fidelity to data with fidelity to differential equations.</p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_var">var</code></td>
<td>
<p>(<code>profile.Cproc</code> or <code>profile.Dproc</code>) A vector of length 2, giving  </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_fd.obj">fd.obj</code></td>
<td>
<p>(Optional) A functional data object; if this is non-null, <code>coefs</code> and <code>basisvals</code> is extracted from here. </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_more">more</code></td>
<td>
<p>An object specifying additional arguments to <code>fn</code>. </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_weights">weights</code></td>
<td>
<p>(<code>Profile.LS</code> only)  </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_quadrature">quadrature</code></td>
<td>
<p> Quadrature points, should contain two elements (if not NULL)
</p>

<dl>
<dt>qpts</dt><dd><p> Quadrature points; defaults to midpoints between knots</p>
</dd>
<dt>qwts</dt><dd><p> Quadrature weights; defaults to normalizing by the length of <code>qpts</code>.   </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_in.meth">in.meth</code></td>
<td>
<p> Inner optimization function to be used, currently one of 'nlminb', 'MaxNR', 'optim' or 'house'.
The last calls <code>SplineEst.NewtRaph</code>. This is fast but has poor convergence.  </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_out.meth">out.meth</code></td>
<td>
<p> Outer optimization function to be used, depending on the type of method
</p>

<dl>
<dt><code>Profile.LS</code></dt><dd><p> One of 'nls' or 'ProfileGN'; the latter calls <code>Profile.GausNewt</code> which is fast but
may have poor convergence.</p>
</dd>
<dt><code>Profile.multinorm</code></dt><dd><p> One of 'optim' (defaults to  BFGS routine in <code>optim</code> unless <code>control.out$meth</code>
specifies otherwise), 'nlminb', or 'maxNR'.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_control.in">control.in</code></td>
<td>
<p> Control object for inner optimization function. </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_control.out">control.out</code></td>
<td>
<p> Control object for outer optimization function. </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_eps">eps</code></td>
<td>
<p> Finite differencing step size, if needed. </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_active">active</code></td>
<td>
<p> Incides indicating which parameters of <code>pars</code> should be estimated; defaults to all of them.  </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_posproc">posproc</code></td>
<td>
<p> Should the state vector be constrained to be positive? If this is the case, the state is represented by
an exponentiated basis expansion in the <code>proc</code> object. </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_poslik">poslik</code></td>
<td>
<p> Should the state be exponentiated before being compared to the data? When the state is represented
on the log scale (<code>posproc=TRUE</code>), this is an alternative to taking the log of the data. </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_discrete">discrete</code></td>
<td>
<p> Is this a discrete-time or a continuous-time system? If discrete, the derivative is instead
taken to be the value at the next time point. </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_names">names</code></td>
<td>
<p> The names of the state variables if not given by the column names of <code>coefs</code>.</p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_sparse">sparse</code></td>
<td>
<p> Should sparse matrices be used for basis values? This option can save memory when 
<code>ProfileGausNewt</code> and <code>SplineEstNewtRaph</code> are called. Otherwise sparse matrices will be converted to 
full matrices and this can slow the code down.</p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_likfn">likfn</code></td>
<td>
<p> Defines a map from the trajectory to the observations. This should be in the same form as
<code>fn</code>. If a function is given, derivatives are estimated by finite differencing, otherwise a list
is expected to provide the same derivatives as <code>fn</code>. If <code>poslik=TRUE</code>, the states are
exponentiated before the <code>likfn</code> is evaluated and the derivatives are updated to account for this.
Defaults to the identity transform. </p>
</td></tr>
<tr><td><code id="Profiling+2B20Routines_+3A_likmore">likmore</code></td>
<td>
<p> A list containing additional inputs to <code>likfn</code> if needed, otherwise set to <code>NULL</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functional all carry out the profiled optimization method of Ramsay et al 2007.
<code>Profile.LS</code> uses a sum of squared errors criteria for both fit to data and the fit of the derivatives
to a differential equation. <code>Profile.multinorm</code> uses multivariate normal approximations.
<code>discrete</code> changes the system to a discrete-time difference equation with the right hand side function
giving the transition function.
</p>
<p>Note that these all call <code>outeropt</code>, which creates
temporary files 'curcoefs.tmp' and 'optcoefs.tmp' to update coefficients as <code>pars</code> evolves. These overwrite
existing files of those names and are deleted before the function terminates.
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table role = "presentation">
<tr><td><code>pars</code></td>
<td>
<p>Optimized parameters</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>Optimized coefficients at <code>pars</code></p>
</td></tr>
<tr><td><code>lik</code></td>
<td>
<p>The <code>lik</code> object generated</p>
</td></tr>
<tr><td><code>proc</code></td>
<td>
<p>The <code>proc</code> item generated</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data used in doing the fitting.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>The vector of times at which the observations were made</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+outeropt">outeropt</a></code>, <code><a href="#topic+ProfileErr">ProfileErr</a></code>, <code><a href="#topic+ProfileSSE">ProfileSSE</a></code>, <code><a href="#topic+LS.setup">LS.setup</a></code>, <code><a href="#topic+multinorm.setup">multinorm.setup</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
###############################
####   Data             #######
###############################

data(FhNdata)

###############################
####  Basis Object      #######
###############################

knots = seq(0,20,0.2)
norder = 3
nbasis = length(knots) + norder - 2
range = c(0,20)

bbasis = create.bspline.basis(range=range(FhNtimes),nbasis=nbasis,
	norder=norder,breaks=knots)


#### Start from pre-estimated values to speed up optimization

data(FhNest)

spars = FhNestPars
coefs = FhNestCoefs

lambda = 10000

res1 = Profile.LS(make.fhn(),data=FhNdata,times=FhNtimes,pars=spars,coefs=coefs,
  basisvals=bbasis,lambda=lambda,in.meth='nlminb',out.meth='nls')

Covar = Profile.covariance(pars=res1$pars,times=FhNtimes,data=FhNdata,
  coefs=res1$coefs,lik=res1$lik,proc=res1$proc) 


## Not run: 
## Alternative, starting from perturbed coefficients -- takes too long for 
# automatic checks in CRAN

# Initial values for coefficients will be obtained by smoothing

DEfd = smooth.basis(FhNtimes,FhNdata,fdPar(bbasis,1,0.5))   # Smooth to estimate
                                                            # coefficients first
coefs = DEfd$fd$coefs
colnames(coefs) = FhNvarnames


###############################
####     Optimization       ###
###############################

spars = c(0.25,0.15,2.5)          # Perturbed parameters
names(spars)=FhNparnames
lambda = 10000

res1 = Profile.LS(make.fhn(),data=FhNdata,times=FhNtimes,pars=spars,coefs=coefs,
  basisvals=bbasis,lambda=lambda,in.meth='nlminb',out.meth='nls')

par(mfrow=c(2,1))
plotfit.fd(FhNdata,FhNtimes,fd(res1$coefs,bbasis))

## End(Not run)  
  
 
 
  
## Not run: 
####################################################
###  An Explicitly Multivariate Normal Formation ### 
####################################################

var = c(1,0.0001)

res2 = Profile.multinorm(make.fhn(),FhNdata,FhNtimes,pars=res1$pars,
          res1$coefs,bbasis,var=var,out.meth='nlminb', in.meth='nlminb')

## End(Not run)</code></pre>

<hr>
<h2 id='SEIRdata'>SEIR data</h2><span id='topic+SEIRdata'></span><span id='topic+SEIRtimes'></span><span id='topic+SEIRpars'></span><span id='topic+SEIRvarnames'></span><span id='topic+SEIRparnames'></span>

<h3>Description</h3>

<p>Data generated for SEIR Examples</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEIRdata
</code></pre>


<h3>Format</h3>


<dl>
<dt>SEIRdata</dt><dd><p> A 261 by 1 matrix of data generated from the SEIR Gillespie process run over 5 years.</p>
</dd>
<dt>SEIRtimes</dt><dd><p> A vector of 261 observation times corresponding to SEIRdata.</p>
</dd>
<dt>SEIRpars</dt><dd><p> Named parameter vector used to generate <code>SEIRdata</code>.</p>
</dd>
<dt>SEIRvarnames</dt><dd> <p><code>c('V','R')</code>: the state variable names for the SEIR system.</p>
</dd>
<dt>SEIRparnames</dt><dd><p>  parameter names for the SEIR system.</p>
</dd>
</dl>


<h3>Source</h3>

<p>Giles Hooker, Stephen P. Ellner, David Earn and Laura Roditi, 2010.
&quot;Parameterizing State-space Models for Infectious Disease Dynamics by Generalized Profiling: Measles in Ontario&quot;,
Technical Report, Cornell University. 
</p>

<hr>
<h2 id='setup'>Setup Functions for proc and lik objects</h2><span id='topic+setup'></span><span id='topic+LS.setup'></span><span id='topic+multinorm.setup'></span>

<h3>Description</h3>

<p>These functions set up lik and proc objects of squared error
and multinormal processes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>LS.setup(pars,coefs=NULL,fn,basisvals=NULL,lambda,fd.obj=NULL,
        more=NULL,data=NULL,weights=NULL,times=NULL,quadrature=NULL,
        likfn = make.id(), likmore = NULL,eps=1e-6,
        posproc=FALSE,poslik=FALSE,discrete=FALSE,names=NULL,sparse=FALSE)

multinorm.setup(pars,coefs=NULL,fn,basisvals=NULL,var=c(1,0.01),fd.obj=NULL,
        more=NULL,data=NULL,times=NULL,quadrature=NULL,eps=1e-6,posproc=FALSE,
        poslik=FALSE,discrete=FALSE,names=NULL,sparse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_+3A_pars">pars</code></td>
<td>
<p> Initial values of parameters to be estimated processes. </p>
</td></tr>
<tr><td><code id="setup_+3A_coefs">coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients in the spline. </p>
</td></tr>
<tr><td><code id="setup_+3A_fn">fn</code></td>
<td>
<p> A function giving the right hand side of a differential/difference equation.  The function should have arguments
</p>

<dl>
<dt>times</dt><dd><p> The times at which the RHS is being evaluated.</p>
</dd>
<dt>x</dt><dd><p> The state values at those times.</p>
</dd>
<dt>p</dt><dd><p> Parameters to be entered in the system.</p>
</dd>
<dt>more</dt><dd><p> An object containing additional inputs to <code>fn</code> </p>
</dd></dl>

<p>It should return a matrix of the same dimension of <code>x</code> giving the right hand side values.
</p>
<p>If <code>fn</code> is given as a single function, its derivatives are estimated by finite-differencing with
stepsize <code>eps</code>. Alternatively, a list can be supplied with elements:
</p>

<dl>
<dt>fn</dt><dd><p> Function to calculate the right hand side should accept a matrix of state values at .</p>
</dd>
<dt>dfdx</dt><dd><p> Function to calculate the derivative with respect to <code>x</code></p>
</dd>
<dt>dfdp</dt><dd><p> Function to calculate the derivative with respect to <code>p</code></p>
</dd>
<dt>d2fdx2</dt><dd><p> Function to calculate the second derivative with respect to <code>x</code></p>
</dd>
<dt>d2fdxdp</dt><dd><p> Function to calculate the second derivative with respect to <code>x</code> and <code>p</code>
</p>
</dd></dl>

<p>These functions take the same arguments as <code>fn</code> and should output multidimensional arrays with
the dimensions ordered according to time, state, deriv1, deriv2; here derivatives with respect to <code>x</code>
always precede derivatives with respect to <code>p</code>. 
</p>
<p><code>fn</code> can also be given as a <code>pomp</code> object (see the <code>pomp</code> package), in which case it is 
interfaced to <code>CollocInfer</code> through <code>pomp.skeleton</code> using a finite differencing. 
</p>
</td></tr>
<tr><td><code id="setup_+3A_basisvals">basisvals</code></td>
<td>
<p>Values of the collocation basis to be used. This can either be a basis object from the <code>fda</code> package,
or a list elements:
</p>

<dl>
<dt>bvals.obs</dt><dd><p> A matrix giving the values of the basis at the observation times</p>
</dd>
<dt>bvals</dt><dd><p> A matrix giving the values of the basis at the quadrature times</p>
</dd>
<dt>dbvals</dt><dd><p> A matrix giving the derivative of the basis at the quadrature times</p>
</dd>
</dl>

<p>For discrete systems, it may also be specified as a matrix, in which case <code>bvals$bvals</code> is obtained by deleting the last row
and <code>bvals$dbvals</code> is obtained by deleting the first/  
</p>
<p>If left as NULL, it is taken from <code>fd.obj</code> for <code>discrete=FALSE</code> and defaults to an identity matrix
of the same dimension as the number of observations for <code>discrete=TRUE</code> systems. 
</p>
</td></tr>
<tr><td><code id="setup_+3A_lambda">lambda</code></td>
<td>
<p>(<code>LS.setup</code> only) Penalty value trading off fidelity to data with fidelity to differential equations.</p>
</td></tr>
<tr><td><code id="setup_+3A_var">var</code></td>
<td>
<p>(<code>profile.Cproc</code> or <code>profile.Dproc</code>) A vector of length 2, giving  </p>
</td></tr>
<tr><td><code id="setup_+3A_fd.obj">fd.obj</code></td>
<td>
<p>(Optional) A functional data object; if this is non-null, <code>coefs</code> and <code>basisvals</code> is extracted from here. </p>
</td></tr>
<tr><td><code id="setup_+3A_more">more</code></td>
<td>
<p>An object specifying additional arguments to <code>fn</code>. </p>
</td></tr>
<tr><td><code id="setup_+3A_data">data</code></td>
<td>
<p>The data to be used, this can be a matrix, or a three-dimensional array. If the latter, the middle
dimension is taken to be replicates. The data are returned, if replicated they are returned in a concatenated form.</p>
</td></tr>
<tr><td><code id="setup_+3A_weights">weights</code></td>
<td>
<p>(<code>LS.setup</code> only)  </p>
</td></tr>
<tr><td><code id="setup_+3A_times">times</code></td>
<td>
<p> Vector observation times for the data. If the data are replicated, times are returned in a concatenated form.</p>
</td></tr>
<tr><td><code id="setup_+3A_quadrature">quadrature</code></td>
<td>
<p> Quadrature points, should contain two elements (if not NULL)
</p>

<dl>
<dt>qpts</dt><dd><p> Quadrature points; defaults to midpoints between knots</p>
</dd>
<dt>qwts</dt><dd><p> Quadrature weights; defaults to normalizing by the length of <code>qpts</code>.   </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="setup_+3A_eps">eps</code></td>
<td>
<p> Finite differencing step size, if needed. </p>
</td></tr>
<tr><td><code id="setup_+3A_posproc">posproc</code></td>
<td>
<p> Should the state vector be constrained to be positive? If this is the case, the state is represented by
an exponentiated basis expansion in the <code>proc</code> object. </p>
</td></tr>
<tr><td><code id="setup_+3A_poslik">poslik</code></td>
<td>
<p> Should the state be exponentiated before being compared to the data? When the state is represented
on the log scale <code>TRUE</code>, this is an alternative to taking the log of the data. </p>
</td></tr>
<tr><td><code id="setup_+3A_discrete">discrete</code></td>
<td>
<p> Is this a discrete or continuous-time system?</p>
</td></tr>
<tr><td><code id="setup_+3A_names">names</code></td>
<td>
<p> The names of the state variables if not given by the column names of <code>coefs</code>.</p>
</td></tr>
<tr><td><code id="setup_+3A_sparse">sparse</code></td>
<td>
<p> Should sparse matrices be used for basis values? This option can save memory when 
<code>ProfileGausNewt</code> and <code>SplineEstNewtRaph</code> are called. Otherwise sparse matrices will be
converted to  full matrices and this can slow the code down.</p>
</td></tr>
<tr><td><code id="setup_+3A_likfn">likfn</code></td>
<td>
<p> Defines a map from the trajectory to the observations. This should be in the same form as
<code>fn</code>. If a function is given, derivatives are estimated by finite differencing, otherwise a list
is expected to provide the same derivatives as <code>fn</code>. If <code>poslik=TRUE</code>, the states are
exponentiated before the <code>likfn</code> is evaluated and the derivatives are updated to account for this.
Defaults to the identity transform. </p>
</td></tr>
<tr><td><code id="setup_+3A_likmore">likmore</code></td>
<td>
<p> A list containing additional inputs to <code>likfn</code> if needed, otherwise set to <code>NULL</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide basic setup utilities for the collocation inference methods. They define
<code>lik</code> and <code>proc</code> objects for sum of squared errors and multivariate normal log likelihoods with
nonlinear transfer functions describing the evolution of the state vector.
</p>

<dl>
<dt>LS.setup</dt><dd><p> Creates sum of squares functions</p>
</dd>
<dt>multinorm.setup</dt><dd><p> Creates multinormal log likelihoods for a continuous-time system.</p>
</dd>
</dl>


<h3>Value</h3>

<p>A list with elements
</p>
<table role = "presentation">
<tr><td><code>coefs</code></td>
<td>
<p>Starting values for <code>coefs</code></p>
</td></tr>
<tr><td><code>lik</code></td>
<td>
<p>The <code>lik</code> object generated</p>
</td></tr>
<tr><td><code>proc</code></td>
<td>
<p>The <code>proc</code> item generated</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data matrix, concatenated if from a 3d array.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>The vector of observation times, concatenated if data is a 3d array.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+inneropt">inneropt</a></code>, <code><a href="#topic+outeropt">outeropt</a></code>, <code><a href="#topic+Profile.LS">Profile.LS</a></code>, <code><a href="#topic+Profile.multinorm">Profile.multinorm</a></code>, <code><a href="#topic+Smooth.LS">Smooth.LS</a></code>, <code><a href="#topic+Smooth.multinorm">Smooth.multinorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# FitzHugh-Nagumo

t = seq(0,20,0.05)            # Observation times

pars = c(0.2,0.2,3)           # Parameter vector
names(pars) = c('a','b','c')

knots = seq(0,20,0.2)         # Create a basis
norder = 3
nbasis = length(knots) + norder - 2
range = c(0,20)

bbasis = create.bspline.basis(range=range,nbasis=nbasis,norder=norder,breaks=knots)

lambda = 10000               # Penalty value

coefs = matrix(0,nbasis,2)   # Coefficient matrix

profile.obj = LS.setup(pars=pars,coefs=coefs,fn=make.fhn(),basisvals=bbasis,
                       lambda=lambda,times=t)


# Using multinorm

var = c(1,0.01)

profile.obj = multinorm.setup(pars=pars,coefs=coefs,fn=make.fhn(),
                                        basisvals=bbasis,var=var,times=t)


# Henon - discrete

hpars = c(1.4,0.3)
t = 1:200

coefs = matrix(0,200,2)
lambda = 10000

profile.obj = LS.setup(pars=hpars,coefs=coefs,fn=make.Henon(),basisvals=NULL,
                             lambda=lambda,times=t,discrete=TRUE)
</code></pre>

<hr>
<h2 id='Smooth.LS'>Model-Based Smoothing Functions</h2><span id='topic+Smooth.LS'></span><span id='topic+Smooth.multinorm'></span>

<h3>Description</h3>

<p>Perform the inner optimization to estimate coefficients given parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Smooth.LS(fn,data,times,pars,coefs=NULL,basisvals=NULL,lambda,fd.obj=NULL,
        more=NULL,weights=NULL,quadrature=NULL,likfn = make.id(), 
        likmore = NULL,in.meth='nlminb',control.in,eps=1e-6,
        posproc=FALSE,poslik=FALSE,discrete=FALSE,names=NULL,
        sparse=FALSE)
        
Smooth.multinorm(fn,data,times,pars,coefs=NULL,basisvals=NULL,var=c(1,0.01),
        fd.obj=NULL,more=NULL,quadrature=NULL,in.meth='nlminb',
        control.in,eps=1e-6,posproc=FALSE,poslik=FALSE,discrete=FALSE,
        names=NULL,sparse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Smooth.LS_+3A_fn">fn</code></td>
<td>
<p> A function giving the right hand side of a differential/difference equation.  The function should have arguments
</p>

<dl>
<dt>times</dt><dd><p> The times at which the RHS is being evaluated.</p>
</dd>
<dt>x</dt><dd><p> The state values at those times.</p>
</dd>
<dt>p</dt><dd><p> Parameters to be entered in the system.</p>
</dd>
<dt>more</dt><dd><p> An object containing additional inputs to <code>fn</code></p>
</dd>
</dl>

<p>It should return a matrix of the same dimension of <code>x</code> giving the right hand side values.
</p>
<p>If <code>fn</code> is given as a single function, its derivatives are estimated by finite-differencing with
stepsize <code>eps</code>. Alternatively, a list can be supplied with elements:
</p>

<dl>
<dt>fn</dt><dd><p> Function to calculate the right hand side should accept a matrix of state values at .</p>
</dd>
<dt>dfdx</dt><dd><p> Function to calculate the derivative with respect to <code>x</code></p>
</dd>
<dt>dfdp</dt><dd><p> Function to calculate the derivative with respect to <code>p</code></p>
</dd>
<dt>d2fdx2</dt><dd><p> Function to calculate the second derivative with respect to <code>x</code></p>
</dd>
<dt>d2fdxdp</dt><dd><p> Function to calculate the second derivative with respect to <code>x</code> and <code>p</code>
</p>
</dd></dl>

<p>These functions take the same arguments as <code>fn</code> and should output multidimensional arrays with
the dimensions ordered according to time, state, deriv1, deriv2; here derivatives with respect to <code>x</code>
always precede derivatives with respect to <code>p</code>. </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_data">data</code></td>
<td>
<p>  Matrix of observed data values. </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_times">times</code></td>
<td>
<p> Vector observation times for the data.</p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_pars">pars</code></td>
<td>
<p> Initial values of parameters to be estimated processes. </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_coefs">coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients in the spline. </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_basisvals">basisvals</code></td>
<td>
<p>Values of the collocation basis to be used. This can either be a basis object from the <code>fda</code> package,
or a list elements:
</p>

<dl>
<dt>bvals.obs</dt><dd><p> A matrix giving the values of the basis at the observation times</p>
</dd>
<dt>bvals</dt><dd><p> A matrix giving the values of the basis at the quadrature times</p>
</dd>
<dt>dbvals</dt><dd><p> A matrix giving the derivative of the basis at the quadrature times</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_lambda">lambda</code></td>
<td>
<p>(<code>Smooth.LS</code> only) Penalty value trading off fidelity to data with fidelity to differential equations.</p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_var">var</code></td>
<td>
<p>(<code>Smooth.multinorm</code>) A vector of length 2, giving  </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_fd.obj">fd.obj</code></td>
<td>
<p>(Optional) A functional data object; if this is non-null, <code>coefs</code> and <code>basisvals</code> is extracted from here. </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_more">more</code></td>
<td>
<p>An object specifying additional arguments to <code>fn</code>. </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_weights">weights</code></td>
<td>
<p>(<code>Smooth.LS</code> only)  </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_quadrature">quadrature</code></td>
<td>
<p> Quadrature points, should contain two elements (if not NULL)
</p>

<dl>
<dt>qpts</dt><dd><p> Quadrature points; defaults to midpoints between knots</p>
</dd>
<dt>qwts</dt><dd><p> Quadrature weights; defaults to normalizing by the length of <code>qpts</code>.   </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_in.meth">in.meth</code></td>
<td>
<p> Inner optimization function to be used, currently one of 'nlminb', 'MaxNR', 'optim' or 'SplineEst'.
The last calls <code>SplineEst.NewtRaph</code>. This is fast but has poor convergence.  </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_control.in">control.in</code></td>
<td>
<p> Control object for inner optimization function. </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_eps">eps</code></td>
<td>
<p> Finite differencing step size, if needed. </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_posproc">posproc</code></td>
<td>
<p> Should the state vector be constrained to be positive? If this is the case, the state is represented by
an exponentiated basis expansion in the <code>proc</code> object. </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_poslik">poslik</code></td>
<td>
<p> Should the state be exponentiated before being compared to the data? When the state is represented
on the log scale (<code>posproc=TRUE</code>), this is an alternative to taking the log of the data. </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_discrete">discrete</code></td>
<td>
<p> Is this a discrete or continuous-time system?</p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_names">names</code></td>
<td>
<p> The names of the state variables if not given by the column names of <code>coefs</code>.</p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_sparse">sparse</code></td>
<td>
<p> Should sparse matrices be used for basis values? This option can save memory when 
<code>ProfileGausNewt</code> and <code>SplineEstNewtRaph</code> are called. Otherwise sparse matrices will be converted to 
full matrices and this can slow the code down.</p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_likfn">likfn</code></td>
<td>
<p> Defines a map from the trajectory to the observations. This should be in the same form as
<code>fn</code>. If a function is given, derivatives are estimated by finite differencing, otherwise a list
is expected to provide the same derivatives as <code>fn</code>. If <code>poslik=TRUE</code>, the states are
exponentiated before the <code>likfn</code> is evaluated and the derivatives are updated to account for this.
Defaults to the identity transform. </p>
</td></tr>
<tr><td><code id="Smooth.LS_+3A_likmore">likmore</code></td>
<td>
<p> A list containing additional inputs to <code>likfn</code> if needed, otherwise set to <code>NULL</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These routines create <code>lik</code> and <code>proc</code> objects and call <code>inneropt</code>.</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table role = "presentation">
<tr><td><code>coefs</code></td>
<td>
<p>Optimized coefficients at <code>pars</code></p>
</td></tr>
<tr><td><code>lik</code></td>
<td>
<p>The <code>lik</code> object generated</p>
</td></tr>
<tr><td><code>proc</code></td>
<td>
<p>The <code>proc</code> item generated</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>The result of the optimization method</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data used in doing the fitting.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>The vector of times at which the observations were made</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+inneropt">inneropt</a></code>, <code><a href="#topic+LS.setup">LS.setup</a></code>, <code><a href="#topic+multinorm.setup">multinorm.setup</a></code>, <code><a href="#topic+SplineCoefsErr">SplineCoefsErr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
###############################
####   Data             #######
###############################

data(FhNdata)

###############################
####  Basis Object      #######
###############################

knots = seq(0,20,0.2)
norder = 3
nbasis = length(knots) + norder - 2
range = c(0,20)

bbasis = create.bspline.basis(range=range(FhNtimes),nbasis=nbasis,
	norder=norder,breaks=knots)


#### Start from pre-estimated values to speed up optimization

data(FhNest)

spars = FhNestPars
coefs = FhNestCoefs

lambda = 10000

res1 = Smooth.LS(make.fhn(),data=FhNdata,times=FhNtimes,pars=spars,coefs=coefs,
  basisvals=bbasis,lambda=lambda,in.meth='nlminb')


## Not run: 
# Henon system

hpars = c(1.4,0.3)              # Parameters
t = 1:200

x = c(-1,1)                     # Create some dataa
X = matrix(0,200+20,2)
X[1,] = x

for(i in 2:(200+20)){ X[i,] = make.Henon()$ode(i,X[i-1,],hpars,NULL) }

X = X[20+1:200,]

Y = X + 0.05*matrix(rnorm(200*2),200,2)

basisvals = diag(rep(1,200))    # Basis is just identiy
coefs = matrix(0,200,2)


# For sum of squared errors

lambda = 10000

res1	= Smooth.LS(make.Henon(),data=Y,times=t,pars=hpars,coefs,basisvals=basisvals,
  lambda=lambda,in.meth='nlminb',discrete=TRUE)

## End(Not run)


## Not run: 
# For multinormal transitions

var = c(1,0.01)

res2 = Smooth.multinorm(make.Henon(),data=Y,t,pars=hpars,coefs,basisvals=NULL,
  var=var,in.meth='nlminb',discrete=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='SplineEst'>Spline Estimation Functions</h2><span id='topic+SplineEst.NewtRaph'></span><span id='topic+SplineCoefsList'></span><span id='topic+SplineCoefsErr'></span><span id='topic+SplineCoefsDC'></span><span id='topic+SplineCoefsDP'></span><span id='topic+SplineCoefsDC2'></span><span id='topic+SplineCoefsDCDP'></span>

<h3>Description</h3>

<p>Model-based smoothing; estimation,  objective criterion and derivatives. </p>


<h3>Usage</h3>

<pre><code class='language-R'>SplineEst.NewtRaph(coefs,times,data,lik,proc,pars,
      control=list(reltol=1e-12,maxit=1000,maxtry=10,trace=0))
      
SplineCoefsList(coefs,times,data,lik,proc,pars,sgn=1)

SplineCoefsErr(coefs,times,data,lik,proc,pars,sgn=1)

SplineCoefsDC(coefs,times,data,lik,proc,pars,sgn=1)

SplineCoefsDP(coefs,times,data,lik,proc,pars,sgn=1)

SplineCoefsDC2(coefs,times,data,lik,proc,pars,sgn=1)

SplineCoefsDCDP(coefs,times,data,lik,proc,pars,sgn=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SplineEst_+3A_coefs">coefs</code></td>
<td>
<p> Vector giving the current estimate of the coefficients in the spline. </p>
</td></tr>
<tr><td><code id="SplineEst_+3A_times">times</code></td>
<td>
<p> Vector observation times for the data.</p>
</td></tr> 
<tr><td><code id="SplineEst_+3A_data">data</code></td>
<td>
<p>  Matrix of observed data values. </p>
</td></tr>
<tr><td><code id="SplineEst_+3A_lik">lik</code></td>
<td>
 <p><code>lik</code> object defining the observation process. </p>
</td></tr>
<tr><td><code id="SplineEst_+3A_proc">proc</code></td>
<td>
 <p><code>proc</code> object defining the state process. </p>
</td></tr>
<tr><td><code id="SplineEst_+3A_pars">pars</code></td>
<td>
<p> Parameters to be used for the processes. </p>
</td></tr>
<tr><td><code id="SplineEst_+3A_sgn">sgn</code></td>
<td>
<p> Is the minimizing (1) or maximizing (0)? </p>
</td></tr>
<tr><td><code id="SplineEst_+3A_control">control</code></td>
<td>
<p> A list giving control parameters for Newton-Raphson optimization. It should contain
</p>

<dl>
<dt>reltol</dt><dd><p> Relative tollerance criterion for the gradient and improvement before termination. </p>
</dd>
<dt>maxit</dt><dd><p> Maximum number of iterations. </p>
</dd>
<dt>maxtry</dt><dd><p> Maximum number of halving-steps to try before declaring no improvement is possible. </p>
</dd>
<dt>trace</dt><dd><p> How much iteration history to output; 0 surpresses all output, a positive value outputs parameters and improvement at each
iteration. </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SplineEst.NewtRaph</code> performs a simple Newton-Raphson estimate for the optimal value of the coefficients.
This estimate lacks the convergence checks of other estimation packages, but may yeild a fast solution when needed.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>SplineEst.NewtRaph</code></td>
<td>
<p>Returns a list that is the result of the optimization with elements
</p>

<dl>
<dt>value</dt><dd><p> The final objective criterion.</p>
</dd>
<dt>coefs</dt><dd><p> The optimizing value of the coefficients.</p>
</dd>
<dt>g</dt><dd><p> The gradient at the optimizing value.</p>
</dd>
<dt>H</dt><dd><p> The Hessian at the optimizing value.</p>
</dd>
</dl>
</td></tr>
<tr><td><code>SplineCoefsList</code></td>
<td>
<p>Collates the gradient calculations and returns a list with elements
</p>

<dl>
<dt>value</dt><dd><p> Output of <code>SplineCoefsErr</code></p>
</dd>
<dt>gradient</dt><dd><p> Output of <code>SplineCoefsDC</code></p>
</dd>
<dt>Hessian</dt><dd><p> Output of <code>SplineCoefsDC2</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code>SplineCoefsErr</code></td>
<td>
<p>The complete data log likelihood for the smooth; the inner optimization objective. </p>
</td></tr>
<tr><td><code>SplineCoefsDC</code></td>
<td>
<p>The derivative of <code>SplineCoefsErr</code> with respect to <code>coefs</code>.</p>
</td></tr>
<tr><td><code>SplineCoefsDP</code></td>
<td>
<p>The derivative of <code>SplineCoefsErr</code> with respect to <code>pars</code>.</p>
</td></tr>
<tr><td><code>SplineCoefsDC2</code></td>
<td>
<p>The second derivative of <code>SplineCoefsErr</code> with respect to <code>coefs</code>.</p>
</td></tr>
<tr><td><code>SplineCoefsDCDP</code></td>
<td>
<p>The second derivative of <code>SplineCoefsErr</code> with respect to <code>coefs</code> and <code>pars</code>.</p>
</td></tr>
</table>
<p>The output of gradients is in terms of an array with dimensions corresponding to derivatives. Derivatives with with respect to coefficients
are given in dimensions before those that give derivatives with respect to parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inneropt">inneropt</a></code>, <code><a href="#topic+Smooth.LS">Smooth.LS</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
