<!DOCTYPE html><html><head><title>Help for package offsetreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {offsetreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#offsetreg-package'><p>offsetreg: An Extension of 'Tidymodels' Supporting Offset Terms</p></a></li>
<li><a href='#boost_tree_offset'><p>Boosted Poisson Trees with Offsets</p></a></li>
<li><a href='#decision_tree_exposure'><p>Poisson Decision Trees with Exposures</p></a></li>
<li><a href='#glm_offset'><p>Fit Generalized Linear Models with an Offset</p></a></li>
<li><a href='#glmnet_offset'><p>Fit Penalized Generalized Linear Models with an Offset</p></a></li>
<li><a href='#poisson_reg_offset'><p>Poisson regression models with offsets</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rpart_exposure'><p>Poisson Recursive Partitioning and Regression Trees with Exposures</p></a></li>
<li><a href='#us_deaths'><p>United States Deaths 2011-2020</p></a></li>
<li><a href='#xgb_train_offset'><p>Boosted Poisson Trees with Offsets via <code>xgboost</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>An Extension of 'Tidymodels' Supporting Offset Terms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Heaphy &lt;mattrmattrs@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Extend the 'tidymodels' ecosystem <a href="https://www.tidymodels.org/">https://www.tidymodels.org/</a> to
    enable the creation of predictive models with offset terms. Models with 
    offsets are most useful when working with count data or when fitting an
    adjustment model on top of an existing model with a prior expectation. 
    The former situation is common in insurance where data is often weighted by
    exposures. The latter is common in life insurance where industry mortality 
    tables are often used as a starting point for setting assumptions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mattheaphy/offsetreg/">https://github.com/mattheaphy/offsetreg/</a>,
<a href="https://mattheaphy.github.io/offsetreg/">https://mattheaphy.github.io/offsetreg/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mattheaphy/offsetreg/issues">https://github.com/mattheaphy/offsetreg/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>generics, glue, parsnip (&ge; 1.2.0), poissonreg, rlang, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>broom, glmnet, knitr, recipes, rmarkdown, rpart, testthat (&ge;
3.0.0), tune, workflows, rsample, xgboost</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-11 14:27:59 UTC; Matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Heaphy [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-11 14:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='offsetreg-package'>offsetreg: An Extension of 'Tidymodels' Supporting Offset Terms</h2><span id='topic+offsetreg'></span><span id='topic+offsetreg-package'></span>

<h3>Description</h3>

<p>Extend the 'tidymodels' ecosystem <a href="https://www.tidymodels.org/">https://www.tidymodels.org/</a> to enable the creation of predictive models with offset terms. Models with offsets are most useful when working with count data or when fitting an adjustment model on top of an existing model with a prior expectation. The former situation is common in insurance where data is often weighted by exposures. The latter is common in life insurance where industry mortality tables are often used as a starting point for setting assumptions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Matt Heaphy <a href="mailto:mattrmattrs@gmail.com">mattrmattrs@gmail.com</a> [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mattheaphy/offsetreg/">https://github.com/mattheaphy/offsetreg/</a>
</p>
</li>
<li> <p><a href="https://mattheaphy.github.io/offsetreg/">https://mattheaphy.github.io/offsetreg/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mattheaphy/offsetreg/issues">https://github.com/mattheaphy/offsetreg/issues</a>
</p>
</li></ul>


<hr>
<h2 id='boost_tree_offset'>Boosted Poisson Trees with Offsets</h2><span id='topic+boost_tree_offset'></span>

<h3>Description</h3>

<p><code>boost_tree_offset()</code> defines a model that creates a series of Poisson
decision trees with pre-defined offsets forming an ensemble. Each tree
depends on the results of previous trees. All trees in the ensemble are
combined to produce a final prediction. This function can be used for count
regression models only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boost_tree_offset(
  mode = "regression",
  engine = "xgboost_offset",
  mtry = NULL,
  trees = NULL,
  min_n = NULL,
  tree_depth = NULL,
  learn_rate = NULL,
  loss_reduction = NULL,
  sample_size = NULL,
  stop_iter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boost_tree_offset_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model. The only
possible value for this model is &quot;regression&quot;</p>
</td></tr>
<tr><td><code id="boost_tree_offset_+3A_engine">engine</code></td>
<td>
<p>A single character string specifying what computational engine
to use for fitting.</p>
</td></tr>
<tr><td><code id="boost_tree_offset_+3A_mtry">mtry</code></td>
<td>
<p>A number for the number (or proportion) of predictors that will
be randomly sampled at each split when creating the tree models
(specific engines only).</p>
</td></tr>
<tr><td><code id="boost_tree_offset_+3A_trees">trees</code></td>
<td>
<p>An integer for the number of trees contained in
the ensemble.</p>
</td></tr>
<tr><td><code id="boost_tree_offset_+3A_min_n">min_n</code></td>
<td>
<p>An integer for the minimum number of data points
in a node that is required for the node to be split further.</p>
</td></tr>
<tr><td><code id="boost_tree_offset_+3A_tree_depth">tree_depth</code></td>
<td>
<p>An integer for the maximum depth of the tree (i.e. number
of splits) (specific engines only).</p>
</td></tr>
<tr><td><code id="boost_tree_offset_+3A_learn_rate">learn_rate</code></td>
<td>
<p>A number for the rate at which the boosting algorithm adapts
from iteration-to-iteration (specific engines only). This is sometimes referred to
as the shrinkage parameter.</p>
</td></tr>
<tr><td><code id="boost_tree_offset_+3A_loss_reduction">loss_reduction</code></td>
<td>
<p>A number for the reduction in the loss function required
to split further (specific engines only).</p>
</td></tr>
<tr><td><code id="boost_tree_offset_+3A_sample_size">sample_size</code></td>
<td>
<p>A number for the number (or proportion) of data that is
exposed to the fitting routine. For <code>xgboost</code>, the sampling is done at
each iteration while <code>C5.0</code> samples once during training.</p>
</td></tr>
<tr><td><code id="boost_tree_offset_+3A_stop_iter">stop_iter</code></td>
<td>
<p>The number of iterations without improvement before
stopping (specific engines only).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code><a href="parsnip.html#topic+boost_tree">parsnip::boost_tree()</a></code> except that
specification of an offset column is required.
</p>


<h3>Value</h3>

<p>A model specification object with the classes <code>boost_tree_offset</code> and
<code>model_spec</code>.
</p>


<h3>See Also</h3>

<p><code><a href="parsnip.html#topic+boost_tree">parsnip::boost_tree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parsnip::show_model_info("boost_tree_offset")

boost_tree_offset()

</code></pre>

<hr>
<h2 id='decision_tree_exposure'>Poisson Decision Trees with Exposures</h2><span id='topic+decision_tree_exposure'></span>

<h3>Description</h3>

<p><code>decision_tree_exposure()</code> defines a Poisson decision tree model with
weighted exposures (observation times).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decision_tree_exposure(
  mode = "regression",
  engine = "rpart_exposure",
  cost_complexity = NULL,
  tree_depth = NULL,
  min_n = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decision_tree_exposure_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model. The only
possible value for this model is &quot;regression&quot;</p>
</td></tr>
<tr><td><code id="decision_tree_exposure_+3A_engine">engine</code></td>
<td>
<p>A single character string specifying what computational engine
to use for fitting.</p>
</td></tr>
<tr><td><code id="decision_tree_exposure_+3A_cost_complexity">cost_complexity</code></td>
<td>
<p>A positive number for the the cost/complexity
parameter (a.k.a. <code>Cp</code>) used by CART models (specific engines only).</p>
</td></tr>
<tr><td><code id="decision_tree_exposure_+3A_tree_depth">tree_depth</code></td>
<td>
<p>An integer for maximum depth of the tree.</p>
</td></tr>
<tr><td><code id="decision_tree_exposure_+3A_min_n">min_n</code></td>
<td>
<p>An integer for the minimum number of data points
in a node that are required for the node to be split further.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code><a href="parsnip.html#topic+decision_tree">parsnip::decision_tree()</a></code> except that
specification of an exposure column is required.
</p>


<h3>Value</h3>

<p>A model specification object with the classes
<code>decision_tree_exposure</code> and <code>model_spec</code>.
</p>


<h3>See Also</h3>

<p><code><a href="parsnip.html#topic+decision_tree">parsnip::decision_tree()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parsnip::show_model_info("decision_tree_exposure")

decision_tree_exposure()

</code></pre>

<hr>
<h2 id='glm_offset'>Fit Generalized Linear Models with an Offset</h2><span id='topic+glm_offset'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code><a href="stats.html#topic+glm">stats::glm()</a></code> that uses a column from
<code>data</code> as an offset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm_offset(
  formula,
  family = "gaussian",
  data,
  offset_col = "offset",
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm_offset_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="glm_offset_+3A_family">family</code></td>
<td>
<p>A function or character string describing the link function
and error distribution.</p>
</td></tr>
<tr><td><code id="glm_offset_+3A_data">data</code></td>
<td>
<p>Optional. A data frame containing variables used in the model.</p>
</td></tr>
<tr><td><code id="glm_offset_+3A_offset_col">offset_col</code></td>
<td>
<p>Character string. The name of a column in <code>data</code> containing
offsets.</p>
</td></tr>
<tr><td><code id="glm_offset_+3A_weights">weights</code></td>
<td>
<p>Optional weights to use in the fitting process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Outside of the <code>tidymodels</code> ecosystem, <code>glm_offset()</code> has no advantages over
<code><a href="stats.html#topic+glm">stats::glm()</a></code> since that function allows for offsets to be specified
in the formula interface or its <code>offset</code> argument.
</p>
<p>Within <code>tidymodels</code>, <code>glm_offset()</code> provides an advantage because it will
ensure that offsets are included in the data whenever resamples are created.
</p>
<p>The <code>formula</code>, <code>family</code>, <code>data</code>, and <code>weights</code> arguments have the same
meanings as <code><a href="stats.html#topic+glm">stats::glm()</a></code>. See that function's documentation for full
details.
</p>


<h3>Value</h3>

<p>A <code>glm</code> object. See <code><a href="stats.html#topic+glm">stats::glm()</a></code> for full details.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">stats::glm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>us_deaths$off &lt;- log(us_deaths$population)
glm_offset(deaths ~ age_group + gender, family = "poisson",
           us_deaths, offset_col = "off")

</code></pre>

<hr>
<h2 id='glmnet_offset'>Fit Penalized Generalized Linear Models with an Offset</h2><span id='topic+glmnet_offset'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code> that uses a column from
<code>x</code> as an offset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnet_offset(
  x,
  y,
  family,
  offset_col = "offset",
  weights = NULL,
  lambda = NULL,
  alpha = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmnet_offset_+3A_x">x</code></td>
<td>
<p>Input matrix</p>
</td></tr>
<tr><td><code id="glmnet_offset_+3A_y">y</code></td>
<td>
<p>Response variable</p>
</td></tr>
<tr><td><code id="glmnet_offset_+3A_family">family</code></td>
<td>
<p>A function or character string describing the link function
and error distribution.</p>
</td></tr>
<tr><td><code id="glmnet_offset_+3A_offset_col">offset_col</code></td>
<td>
<p>Character string. The name of a column in <code>data</code> containing
offsets.</p>
</td></tr>
<tr><td><code id="glmnet_offset_+3A_weights">weights</code></td>
<td>
<p>Optional weights to use in the fitting process.</p>
</td></tr>
<tr><td><code id="glmnet_offset_+3A_lambda">lambda</code></td>
<td>
<p>A numeric vector of regularization penalty values</p>
</td></tr>
<tr><td><code id="glmnet_offset_+3A_alpha">alpha</code></td>
<td>
<p>A number between zero and one denoting the proportion of L1
(lasso) versus L2 (ridge) regularization.
</p>

<ul>
<li> <p><code>alpha = 1</code>: Pure lasso model
</p>
</li>
<li> <p><code>alpha = 0</code>: Pure ridge model
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Outside of the <code>tidymodels</code> ecosystem, <code>glmnet_offset()</code> has no advantages
over <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code> since that function allows for offsets to be
specified in its <code>offset</code> argument.
</p>
<p>Within <code>tidymodels</code>, <code>glmnet_offset()</code> provides an advantage because it will
ensure that offsets are included in the data whenever resamples are created.
</p>
<p>The <code>x</code>, <code>y</code>, <code>family</code>, <code>lambda</code>, <code>alpha</code> and <code>weights</code> arguments have the
same meanings as <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code>. See that function's documentation for
full details.
</p>


<h3>Value</h3>

<p>A <code>glmnet</code> object. See <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code> for full details.
</p>


<h3>See Also</h3>

<p><code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>us_deaths$off &lt;- log(us_deaths$population)
x &lt;- model.matrix(~ age_group + gender + off, us_deaths)[, -1]
glmnet_offset(x, us_deaths$deaths, family = "poisson", offset_col = "off")

</code></pre>

<hr>
<h2 id='poisson_reg_offset'>Poisson regression models with offsets</h2><span id='topic+poisson_reg_offset'></span>

<h3>Description</h3>

<p><code>poisson_reg_offset()</code> defines a generalized linear model of count data with
an offset that follows a Poisson distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisson_reg_offset(
  mode = "regression",
  penalty = NULL,
  mixture = NULL,
  engine = "glm_offset"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poisson_reg_offset_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model.
The only possible value for this model is &quot;regression&quot;.</p>
</td></tr>
<tr><td><code id="poisson_reg_offset_+3A_penalty">penalty</code></td>
<td>
<p>A non-negative number representing the total
amount of regularization (<code>glmnet</code> only).</p>
</td></tr>
<tr><td><code id="poisson_reg_offset_+3A_mixture">mixture</code></td>
<td>
<p>A number between zero and one (inclusive) giving the
proportion of L1 regularization (i.e. lasso) in the model.
</p>

<ul>
<li> <p><code>mixture = 1</code> specifies a pure lasso model,
</p>
</li>
<li> <p><code>mixture = 0</code>  specifies a ridge regression model, and
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;0 &lt; mixture &lt; 1&#8288;</code> specifies an elastic net model, interpolating lasso and ridge.
</p>
</li></ul>

<p>Available for <code>glmnet</code> and <code>spark</code> only.</p>
</td></tr>
<tr><td><code id="poisson_reg_offset_+3A_engine">engine</code></td>
<td>
<p>A single character string specifying what computational engine
to use for fitting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code><a href="parsnip.html#topic+poisson_reg">parsnip::poisson_reg()</a></code> except that
specification of an offset column is required.
</p>


<h3>Value</h3>

<p>A model specification object with the classes <code>poisson_reg_offset</code>
and <code>model_spec</code>.
</p>


<h3>See Also</h3>

<p><code><a href="parsnip.html#topic+poisson_reg">parsnip::poisson_reg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parsnip::show_model_info("poisson_reg_offset")

poisson_reg_offset()

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+translate'></span><span id='topic+check_args'></span><span id='topic+min_grid'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+min_grid">min_grid</a></code></p>
</dd>
<dt>parsnip</dt><dd><p><code><a href="parsnip.html#topic+add_on_exports">check_args</a></code>, <code><a href="parsnip.html#topic+translate">translate</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rpart_exposure'>Poisson Recursive Partitioning and Regression Trees with Exposures</h2><span id='topic+rpart_exposure'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code><a href="rpart.html#topic+rpart">rpart::rpart()</a></code> for Poisson regression
trees using weighted exposures (observation times).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpart_exposure(
  formula,
  data,
  exposure_col = "exposure",
  weights = NULL,
  control,
  cost,
  shrink = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpart_exposure_+3A_formula">formula</code></td>
<td>
<p>A model formula that contains a single response variable on
the left-hand side.</p>
</td></tr>
<tr><td><code id="rpart_exposure_+3A_data">data</code></td>
<td>
<p>Optional. A data frame containing variables used in the model.</p>
</td></tr>
<tr><td><code id="rpart_exposure_+3A_exposure_col">exposure_col</code></td>
<td>
<p>Character string. The name of a column in <code>data</code>
containing exposures.</p>
</td></tr>
<tr><td><code id="rpart_exposure_+3A_weights">weights</code></td>
<td>
<p>Optional weights to use in the fitting process.</p>
</td></tr>
<tr><td><code id="rpart_exposure_+3A_control">control</code></td>
<td>
<p>A list of hyperparameters. See <code><a href="rpart.html#topic+rpart.control">rpart::rpart.control()</a></code>.</p>
</td></tr>
<tr><td><code id="rpart_exposure_+3A_cost">cost</code></td>
<td>
<p>A vector of non-negative costs for each variable in the model.</p>
</td></tr>
<tr><td><code id="rpart_exposure_+3A_shrink">shrink</code></td>
<td>
<p>Optional parameter for the splitting function. Coefficient of
variation of the prior distribution.</p>
</td></tr>
<tr><td><code id="rpart_exposure_+3A_...">...</code></td>
<td>
<p>Alternative input for arguments passed to
<code><a href="rpart.html#topic+rpart.control">rpart::rpart.control()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Outside of the <code>tidymodels</code> ecosystem, <code>rpart_exposure()</code> has no
advantages over <code><a href="rpart.html#topic+rpart">rpart::rpart()</a></code> since that function allows for exposures to
be specified in the formula interface by passing <code>cbind(exposure, y)</code> as a
response variable.
</p>
<p>Within <code>tidymodels</code>, <code>rpart_exposure()</code> provides an advantage because
it will ensure that exposures are included in the data whenever resamples are
created.
</p>
<p>The <code>formula</code>, <code>data</code>, <code>weights</code>, <code>control</code>, and <code>cost</code> arguments have the
same meanings as <code><a href="rpart.html#topic+rpart">rpart::rpart()</a></code>. <code>shrink</code> is passed to <code><a href="rpart.html#topic+rpart">rpart::rpart()</a></code>'s
<code>parms</code> argument via a named list. See that function's documentation for full
details.
</p>


<h3>Value</h3>

<p>An <code>rpart</code> model
</p>


<h3>See Also</h3>

<p><code><a href="rpart.html#topic+rpart">rpart::rpart()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rpart_exposure(deaths ~ age_group + gender, us_deaths,
               exposure_col = "population")

</code></pre>

<hr>
<h2 id='us_deaths'>United States Deaths 2011-2020</h2><span id='topic+us_deaths'></span>

<h3>Description</h3>

<p>United States deaths, population estimates, and crude mortality rates for
ages 25+ from the CDC Multiple Causes of Death Files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>us_deaths
</code></pre>


<h3>Format</h3>

<p>A data frame with 140 rows and 6 columns.
</p>

<dl>
<dt>gender</dt><dd><p>Gender</p>
</dd>
<dt>age_group</dt><dd><p>Attained age groups</p>
</dd>
<dt>year</dt><dd><p>Calendar year</p>
</dd>
<dt>deaths</dt><dd><p>Number of deaths</p>
</dd>
<dt>population</dt><dd><p>Population estimate</p>
</dd>
<dt>qx</dt><dd><p>Crude mortality rate equal to <code>deaths / population</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Centers for Disease Control and Prevention, National Center for Health
Statistics. National Vital Statistics System, Mortality 1999-2020 on CDC
WONDER Online Database, released in 2021. Data are from the Multiple Cause
of Death Files, 1999-2020, as compiled from data provided by the 57 vital
statistics jurisdictions through the Vital Statistics Cooperative Program.
Accessed at <a href="http://wonder.cdc.gov/mcd-icd10.html">http://wonder.cdc.gov/mcd-icd10.html</a> on Jan 15, 2024.&quot;
</p>

<hr>
<h2 id='xgb_train_offset'>Boosted Poisson Trees with Offsets via <code>xgboost</code></h2><span id='topic+xgb_train_offset'></span><span id='topic+xgb_predict_offset'></span>

<h3>Description</h3>

<p><code>xgb_train_offset()</code> and <code>xgb_predict_offset()</code> are wrappers for <code>xgboost</code>
tree-based models where all of the model arguments are in the main function.
These functions are nearly identical to the parsnip functions
<code>parsnip::xgb_train()</code> and <code>parsnip::xg_predict_offset()</code> except that the
objective &quot;count:poisson&quot; is passed to <code>xgboost::xgb.train()</code> and an offset
term is added to the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xgb_train_offset(
  x,
  y,
  offset_col = "offset",
  weights = NULL,
  max_depth = 6,
  nrounds = 15,
  eta = 0.3,
  colsample_bynode = NULL,
  colsample_bytree = NULL,
  min_child_weight = 1,
  gamma = 0,
  subsample = 1,
  validation = 0,
  early_stop = NULL,
  counts = TRUE,
  ...
)

xgb_predict_offset(object, new_data, offset_col = "offset", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xgb_train_offset_+3A_x">x</code></td>
<td>
<p>A data frame or matrix of predictors</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_y">y</code></td>
<td>
<p>A vector (numeric) or matrix (numeric) of outcome data.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_offset_col">offset_col</code></td>
<td>
<p>Character string. The name of a column in <code>data</code> containing
offsets.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_max_depth">max_depth</code></td>
<td>
<p>An integer for the maximum depth of the tree.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_nrounds">nrounds</code></td>
<td>
<p>An integer for the number of boosting iterations.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_eta">eta</code></td>
<td>
<p>A numeric value between zero and one to control the learning rate.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_colsample_bynode">colsample_bynode</code></td>
<td>
<p>Subsampling proportion of columns for each node
within each tree. See the <code>counts</code> argument below. The default uses all
columns.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_colsample_bytree">colsample_bytree</code></td>
<td>
<p>Subsampling proportion of columns for each tree.
See the <code>counts</code> argument below. The default uses all columns.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_min_child_weight">min_child_weight</code></td>
<td>
<p>A numeric value for the minimum sum of instance
weights needed in a child to continue to split.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_gamma">gamma</code></td>
<td>
<p>A number for the minimum loss reduction required to make a
further partition on a leaf node of the tree</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_subsample">subsample</code></td>
<td>
<p>Subsampling proportion of rows. By default, all of the
training data are used.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_validation">validation</code></td>
<td>
<p>The <em>proportion</em> of the data that are used for performance
assessment and potential early stopping.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_early_stop">early_stop</code></td>
<td>
<p>An integer or <code>NULL</code>. If not <code>NULL</code>, it is the number of
training iterations without improvement before stopping. If <code>validation</code> is
used, performance is base on the validation set; otherwise, the training set
is used.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_counts">counts</code></td>
<td>
<p>A logical. If <code>FALSE</code>, <code>colsample_bynode</code> and
<code>colsample_bytree</code> are both assumed to be <em>proportions</em> of the proportion of
columns affects (instead of counts).</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_...">...</code></td>
<td>
<p>Other options to pass to <code>xgb.train()</code> or xgboost's method for <code>predict()</code>.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_object">object</code></td>
<td>
<p>An <code>xgboost</code> object.</p>
</td></tr>
<tr><td><code id="xgb_train_offset_+3A_new_data">new_data</code></td>
<td>
<p>New data for predictions. Can be a data frame, matrix,
<code>xgb.DMatrix</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted <code>xgboost</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>us_deaths$off &lt;- log(us_deaths$population)
x &lt;- model.matrix(~ age_group + gender + off, us_deaths)[, -1]

mod &lt;- xgb_train_offset(x, us_deaths$deaths, "off",
                        eta = 1, colsample_bynode = 1,
                        max_depth = 2, nrounds = 25,
                        counts = FALSE)

xgb_predict_offset(mod, x, "off")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
