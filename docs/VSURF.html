<!DOCTYPE html><html lang="en"><head><title>Help for package VSURF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VSURF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#plot.VSURF'><p>Plot of VSURF results</p></a></li>
<li><a href='#PM10'><p>Real-world data on PM10 pollution in Rouen area, France</p></a></li>
<li><a href='#predict.VSURF'><p>Predict method for VSURF object</p></a></li>
<li><a href='#print.VSURF'><p>Print of VSURF results</p></a></li>
<li><a href='#summary.VSURF'><p>Summary of VSURF results</p></a></li>
<li><a href='#toys'><p>A simulated dataset called toys data</p></a></li>
<li><a href='#tune'><p>Tuning of the thresholding and interpretation steps of VSURF</p></a></li>
<li><a href='#VSURF'><p>Variable Selection Using Random Forests</p></a></li>
<li><a href='#VSURF_interp'><p>Interpretation step of VSURF</p></a></li>
<li><a href='#VSURF_pred'><p>Prediction step of VSURF</p></a></li>
<li><a href='#VSURF_thres'><p>Thresholding step of VSURF</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Variable Selection Using Random Forests</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-15</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Three steps variable selection procedure based on random forests.
    Initially developed to handle high dimensional data (for which number of
    variables largely exceeds number of observations), the package is very
    versatile and can treat most dimensions of data, for regression and
    supervised classification problems. First step is dedicated to eliminate
    irrelevant variables from the dataset. Second step aims to select all
    variables related to the response for interpretation purpose. Third step
    refines the selection by eliminating redundancy in the set of variables
    selected by the second step, for prediction purpose.
    Genuer, R. Poggi, J.-M. and Tuleau-Malot, C. (2015)
    <a href="https://journal.r-project.org/archive/2015-2/genuer-poggi-tuleaumalot.pdf">https://journal.r-project.org/archive/2015-2/genuer-poggi-tuleaumalot.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/robingenuer/VSURF">https://github.com/robingenuer/VSURF</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/robingenuer/VSURF/issues">https://github.com/robingenuer/VSURF/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, foreach, parallel, randomForest, rpart</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, ranger, Rborist</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-15 12:56:15 UTC; rg</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin Genuer [aut, cre],
  Jean-Michel Poggi [aut],
  Christine Tuleau-Malot [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin Genuer &lt;Robin.Genuer@u-bordeaux.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-15 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='plot.VSURF'>Plot of VSURF results</h2><span id='topic+plot.VSURF'></span><span id='topic+plot.VSURF_thres'></span><span id='topic+plot.VSURF_interp'></span><span id='topic+plot.VSURF_pred'></span>

<h3>Description</h3>

<p>This function plots 4 graphs illustrating VSURF results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VSURF'
plot(
  x,
  step = "all",
  var.names = FALSE,
  imp.mean = TRUE,
  imp.sd = TRUE,
  nvar.imp.mean = length(x$imp.mean.dec),
  nvar.imp.sd = length(x$imp.sd.dec),
  nvar.interp = length(x$varselect.thres),
  nvar.pred = length(x$varselect.pred),
  ...
)

## S3 method for class 'VSURF_thres'
plot(
  x,
  var.names = FALSE,
  imp.mean = TRUE,
  imp.sd = TRUE,
  nvar.imp.mean = length(x$imp.mean.dec),
  nvar.imp.sd = length(x$imp.sd.dec),
  ...
)

## S3 method for class 'VSURF_interp'
plot(x, var.names = FALSE, nvar.interp = length(x$varselect.thres), ...)

## S3 method for class 'VSURF_pred'
plot(x, var.names = FALSE, nvar.pred = length(x$varselect.pred), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.VSURF_+3A_x">x</code></td>
<td>
<p>An object of class <code>VSURF</code>, <code>VSURF_thres</code>,
<code>VSURF_interp</code> or <code>VSURF_pred</code>, which is the result of the
<code><a href="#topic+VSURF">VSURF</a></code> function (or resp. <code><a href="#topic+VSURF_thres">VSURF_thres</a></code>,
<code><a href="#topic+VSURF_interp">VSURF_interp</a></code> or <code><a href="#topic+VSURF_pred">VSURF_pred</a></code>).</p>
</td></tr>
<tr><td><code id="plot.VSURF_+3A_step">step</code></td>
<td>
<p>A character string indicating which step must be plotted (default is &quot;all&quot;).
Available choices are &quot;thres&quot;, &quot;interp&quot;, &quot;pred&quot;.</p>
</td></tr>
<tr><td><code id="plot.VSURF_+3A_var.names">var.names</code></td>
<td>
<p>If FALSE (default) xticks are the numbering given by the
sorting of VI mean, if TRUE they are the variables names.</p>
</td></tr>
<tr><td><code id="plot.VSURF_+3A_imp.mean">imp.mean</code></td>
<td>
<p>If TRUE (default) VI mean is plotted, if FALSE it is not.</p>
</td></tr>
<tr><td><code id="plot.VSURF_+3A_imp.sd">imp.sd</code></td>
<td>
<p>If TRUE (default) VI standard deviation is plotted, if FALSE
it is not.</p>
</td></tr>
<tr><td><code id="plot.VSURF_+3A_nvar.imp.mean">nvar.imp.mean</code></td>
<td>
<p>The number of variables to be kept for the VI mean plot.</p>
</td></tr>
<tr><td><code id="plot.VSURF_+3A_nvar.imp.sd">nvar.imp.sd</code></td>
<td>
<p>The number of variables to be kept for the VI standard
deviation plot.</p>
</td></tr>
<tr><td><code id="plot.VSURF_+3A_nvar.interp">nvar.interp</code></td>
<td>
<p>The number of variables to be kept for the &quot;interp&quot; plot.</p>
</td></tr>
<tr><td><code id="plot.VSURF_+3A_nvar.pred">nvar.pred</code></td>
<td>
<p>The number of variables to be kept for the &quot;pred&quot; plot.</p>
</td></tr>
<tr><td><code id="plot.VSURF_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="graphics.html#topic+par">par</a></code> (they will affect
all plots) or to others methods of plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 2 graphs of the top row correspond to the &quot;thresholding step&quot; (and only
these 2 graphs are plotted by the <code>plot.VSURF_thres</code> function).  The
top left graph plots the mean variable importance in decreasing order (black
curve). The red horizontal line represent the value of the threshold.  The
top right graph plots the standard deviation of variable importance with
variables ordered according to their mean variable importance in decreasing
order (black curve). The green line represents the predictions given by a
CART tree fitted to the black curve (the standard deviations). Finally, the
dotted horizontal red line represents the minimum value of the CART
predictions, which actually is the value of the threshold.
</p>
<p>The bottom left graph corresponds to the &quot;interpretation step&quot; (and only
this graph is plotted by the <code>plot.VSURF_interp</code> function). It plots
the mean OOB error rate of embedded random forests models (from the one with
only one variable as predictor, to the one with all variables kept after the
&quot;thresholding step&quot;). The vertical red line indicates the retained model.
</p>
<p>The bottom right graph corresponds to the &quot;prediction step&quot; (and only this
graph is plotted by the <code>plot.VSURF_pred</code> function). It plots the mean
OOB error rate of embedded random forests models (the difference, here,
being that variables are added to the model in a step-wise manner). The
retained model is the final one.
</p>


<h3>Author(s)</h3>

<p>Robin Genuer, Jean-Michel Poggi and Christine Tuleau-Malot
</p>


<h3>References</h3>

<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2010),
<em>Variable selection using random forests</em>, Pattern Recognition Letters
31(14), 2225-2236
</p>
<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2015),
<em>VSURF: An R Package for Variable Selection Using Random Forests</em>,
The R Journal 7(2):19-33
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VSURF">VSURF</a></code>, <code><a href="#topic+summary.VSURF">summary.VSURF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(iris)
iris.vsurf &lt;- VSURF(iris[,1:4], iris[,5])
plot(iris.vsurf)
plot(iris.vsurf, var.names=TRUE)
plot(iris.vsurf, step="thres")

# A more interesting example with toys data (see \code{\link{toys}})
# (a few minutes to execute) and intermediate functions
data(toys)
toys.vsurf &lt;- VSURF(toys$x, toys$y)
plot(toys.vsurf)
plot(toys.vsurf, nvar.imp.mean = 50, nvar.imp.sd = 50)
toys.thres &lt;- VSURF_thres(toys$x, toys$y)
plot(toys.thres)
plot(toys.thres, nvar.imp.mean = 70, imp.sd = FALSE)
toys.interp &lt;- VSURF_interp(toys$x, toys$y, vars = toys.thres$varselect.thres)
plot(toys.interp, var.names = TRUE)
toys.pred &lt;- VSURF_pred(toys$x, toys$y, err.interp = toys.interp$err.interp,
                        varselect.interp = toys.interp$varselect.interp)
plot(toys.pred, var.names = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='PM10'>Real-world data on PM10 pollution in Rouen area, France</h2><span id='topic+PM10'></span><span id='topic+ail'></span><span id='topic+gcm'></span><span id='topic+gui'></span><span id='topic+hri'></span><span id='topic+jus'></span><span id='topic+rep'></span>

<h3>Description</h3>

<p>These data are TEOM (Tapered Element Oscillating Microbalance) PM10
concentrations from 2004 to 2006 (1096 days) measured by Air Normand, and
the associated weather data provided by Meteo France, the French national
meteorological service, using six different monitoring sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ail

gcm

gui

hri

jus

rep
</code></pre>


<h3>Format</h3>

<p>Each object is a data frame.
</p>
<p>The description of the 18 variables is the following (note that for
<code>gcm</code> station, only the pollutant SO2 is available in addition to
PM10, and for <code>ail</code> station, there is no other pollutant in addition
to PM10):
</p>

<dl>
<dt>PM10</dt><dd><p>Daily mean concentration of PM10, in <code class="reqn">\mu g/m^3</code></p>
</dd>
<dt>NO, NO2, SO2</dt><dd><p>Daily mean concentration of NO, NO2 , SO2, in 
<code class="reqn">\mu g/m^3</code></p>
</dd>
<dt>T.min, T.max, T.moy</dt><dd><p>Daily minimum, maximum and mean temperature, in
degree Celsius</p>
</dd>
<dt>DV.maxvv, DV.dom</dt><dd><p>Daily maximum speed and dominant wind direction,
in degree (for wind direction, 0 degree corresponds to north)</p>
</dd>
<dt>VV.max, VV.moy</dt><dd><p>Daily maximum and mean wind speed, in m/s</p>
</dd>
<dt>PL.som</dt><dd><p>Daily rainfall, in mm</p>
</dd>
<dt>HR.min, HR.max, HR.moy</dt><dd><p>Daily minimum, maximum and mean relative
humidity, in %</p>
</dd>
<dt>PA.moy</dt><dd><p>Daily mean air pressure, in hPa</p>
</dd>
<dt>GTrouen, GTlehavre</dt><dd><p>Daily temperature gradient, in degree Celsius</p>
</dd>
</dl>

<p>An object of class <code>data.frame</code> with 1096 rows and 15 columns.
</p>
<p>An object of class <code>data.frame</code> with 1096 rows and 16 columns.
</p>
<p>An object of class <code>data.frame</code> with 1096 rows and 18 columns.
</p>
<p>An object of class <code>data.frame</code> with 1096 rows and 18 columns.
</p>
<p>An object of class <code>data.frame</code> with 1096 rows and 18 columns.
</p>
<p>An object of class <code>data.frame</code> with 1096 rows and 18 columns.
</p>


<h3>Details</h3>

<p>Six different monitoring stations of the Rouen (Haute Normandie, France)
area are considered. The urban station <code>jus</code>, the traffic station
<code>gui</code>, the second most polluted in the region, and <code>gcm</code> which is
located in an industrial area. In Le Havre, are considered the stations
<code>rep</code> (the most polluted in the region) and <code>hri</code> located at the
seaside. Lastly, the station <code>ail</code> near Dieppe, because it is rural and
coastal, and a priori hardly influenced by social and industrial activity.
Grouping by categories: <code>jus</code> and <code>hri</code> are background urban
monitoring sites, <code>gui</code> and <code>rep</code> are urban sites close to
traffic, <code>gcm</code> is industrial and <code>ail</code> is rural.
</p>


<h3>Source</h3>

<p>F.-X. Jollois, J.-M. Poggi, B. Portier, <em>Three non-linear
statistical methods to analyze PM10 pollution in Rouen area</em>. CSBIGS 3(1):
1-17, 2009
</p>

<hr>
<h2 id='predict.VSURF'>Predict method for VSURF object</h2><span id='topic+predict.VSURF'></span>

<h3>Description</h3>

<p>This function predicts new data with random forests, using variables selected by VSURF only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VSURF'
predict(object, newdata, step = c("interp", "pred"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.VSURF_+3A_object">object</code></td>
<td>
<p>An object of class <code>VSURF</code>, which is the result of the
<code><a href="#topic+VSURF">VSURF</a></code> function.</p>
</td></tr>
<tr><td><code id="predict.VSURF_+3A_newdata">newdata</code></td>
<td>
<p>A data frame or matrix containing new data.
(Note: If not given, the out-of-bag predictions of the randomForest object is returned.)</p>
</td></tr>
<tr><td><code id="predict.VSURF_+3A_step">step</code></td>
<td>
<p>A character string indicating which variable set must be used to train
the <code>randomForest</code> object (default is c(&quot;interp&quot;, &quot;pred&quot;)).
Available choices are &quot;thres&quot;, &quot;interp&quot;, &quot;pred&quot;.</p>
</td></tr>
<tr><td><code id="predict.VSURF_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="randomForest.html#topic+randomForest">randomForest</a></code> or
<code><a href="randomForest.html#topic+predict.randomForest">predict.randomForest</a></code> functions (depending on their names).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method applies for a VSURF object. VSURF selects two sets of variables during its two
last steps. For each set of variables, a random forest object is created, by running
<code><a href="randomForest.html#topic+randomForest">randomForest</a></code> on training data using this set of variables only. Then the
<code><a href="randomForest.html#topic+predict.randomForest">predict.randomForest</a></code> function is used to predict new data.
</p>


<h3>Value</h3>

<p>If only one step is indicated in <code>step</code>, a vector of predicted values.
</p>
<p>If two or more steps are indicated in <code>step</code>, a data frame of predicted values
(each column corresponding to a variable set).
</p>


<h3>Author(s)</h3>

<p>Robin Genuer, Jean-Michel Poggi and Christine Tuleau-Malot
</p>


<h3>References</h3>

<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2010),
<em>Variable selection using random forests</em>, Pattern Recognition Letters
31(14), 2225-2236
</p>
<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2015),
<em>VSURF: An R Package for Variable Selection Using Random Forests</em>,
The R Journal 7(2):19-33
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VSURF">VSURF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(iris)
iris.learn &lt;- sample(1:nrow(iris), nrow(iris)/2)
iris.vsurf &lt;- VSURF(iris[iris.learn, 1:4], iris[iris.learn, 5], ntree = 100, nfor.thres = 20,
                    nfor.interp = 10, nfor.pred = 10)
iris.predictions &lt;- predict(iris.vsurf, newdata = iris[-iris.learn, 1:4])

# A more interesting example with toys data (see \code{\link{toys}})
# (a few minutes to execute)
data(toys)
toys.learn &lt;- 1:(nrow(toys$x) / 2)
toys.vsurf &lt;- VSURF(toys$x[toys.learn, ], toys$y[toys.learn])
toys.predictions &lt;- predict(toys.vsurf, newdata = toys$x[-toys.learn, ])
## End(Not run)

</code></pre>

<hr>
<h2 id='print.VSURF'>Print of VSURF results</h2><span id='topic+print.VSURF'></span>

<h3>Description</h3>

<p>This function display a small description of VSURF results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VSURF'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.VSURF_+3A_x">x</code></td>
<td>
<p>An object of class <code>VSURF</code>, which is the result of the
<code><a href="#topic+VSURF">VSURF</a></code> function.</p>
</td></tr>
<tr><td><code id="print.VSURF_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Genuer, Jean-Michel Poggi and Christine Tuleau-Malot
</p>


<h3>References</h3>

<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2010),
<em>Variable selection using random forests</em>, Pattern Recognition Letters
31(14), 2225-2236
</p>
<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2015),
<em>VSURF: An R Package for Variable Selection Using Random Forests</em>,
The R Journal 7(2):19-33
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VSURF">VSURF</a></code>, <code><a href="#topic+plot.VSURF">plot.VSURF</a></code>, <code><a href="#topic+summary.VSURF">summary.VSURF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(iris)
iris.vsurf &lt;- VSURF(iris[,1:4], iris[,5], ntree = 100, nfor.thres = 20,
                    nfor.interp = 10, nfor.pred = 10)
iris.vsurf

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.VSURF'>Summary of VSURF results</h2><span id='topic+summary.VSURF'></span>

<h3>Description</h3>

<p>This function displays a summary of VSURF results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VSURF'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.VSURF_+3A_object">object</code></td>
<td>
<p>An object of class <code>VSURF</code>, which is the result of the
<code><a href="#topic+VSURF">VSURF</a></code> function.</p>
</td></tr>
<tr><td><code id="summary.VSURF_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints the total computation time of VSURF.  It also gives the
number of selected variables (and the computation time) at each step of
VSURF. In addition, it gives the number of cores and the type of cluster
if the parallel version of VSURF was used.
</p>


<h3>Author(s)</h3>

<p>Robin Genuer, Jean-Michel Poggi and Christine Tuleau-Malot
</p>


<h3>References</h3>

<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2010),
<em>Variable selection using random forests</em>, Pattern Recognition Letters
31(14), 2225-2236
</p>
<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2015),
<em>VSURF: An R Package for Variable Selection Using Random Forests</em>,
The R Journal 7(2):19-33
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VSURF">VSURF</a></code>, <code><a href="#topic+plot.VSURF">plot.VSURF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(iris)
iris.vsurf &lt;- VSURF(iris[,1:4], iris[,5], ntree = 100, nfor.thres = 20,
                    nfor.interp = 10, nfor.pred = 10)
summary(iris.vsurf)

# A more interesting example with toys data (see \code{\link{toys}})
# (a few minutes to execute)
data(toys)
toys.vsurf &lt;- VSURF(toys$x, toys$y)
summary(toys.vsurf)
## End(Not run)

</code></pre>

<hr>
<h2 id='toys'>A simulated dataset called toys data</h2><span id='topic+toys'></span>

<h3>Description</h3>

<p><code>toys</code> is a simple simulated dataset of a binary classification
problem, introduced by Weston et.al..
</p>


<h3>Format</h3>

<p>The format is a list of 2 components:
</p>

<dl>
<dt>x</dt><dd><p>a dataframe containing input variables: with 100 obs. of 200
variables</p>
</dd>
<dt>y</dt><dd><p>output variable: a factor with 2 levels &quot;-1&quot; and &quot;1&quot;</p>
</dd>
</dl>



<h3>Details</h3>

<p>It is an equiprobable two class problem, Y belongs to {-1,1}, with six
true  variables, the others being some noise.
The simulation model is defined through the conditional distribution
of the <code class="reqn">X_i</code> for Y=y:
</p>

<ul>
<li><p> with probability 0.7, X^j ~ N(yj,1) for j=1,2,3 and
X^j ~ N(0,1) for j=4,5,6 ;
</p>
</li>
<li><p> with probability 0.3, X^j ~ N(0,1) for j=1,2,3 and
X^j ~ N(y(j-3),1) for j=4,5,6 ;
</p>
</li>
<li><p> the other variables are noise, X^j ~ N(0,1)
for j=7,...,p.
</p>
</li></ul>

<p>After simulation, the obtained variables are finally standardized.
</p>


<h3>Source</h3>

<p>Weston, J., Elisseff, A., Schoelkopf, B., Tipping, M. (2003),
<em>Use of the zero norm with linear models and Kernel methods</em>,
J. Machine Learn. Res. 3, 1439-1461
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(toys)
toys.rf &lt;- randomForest::randomForest(toys$x, toys$y)
toys.rf

## Not run: 
# VSURF applied for toys data:
# (a few minutes to execute)
data(toys)
toys.vsurf &lt;- VSURF(toys$x, toys$y)
toys.vsurf

## End(Not run)

</code></pre>

<hr>
<h2 id='tune'>Tuning of the thresholding and interpretation steps of VSURF</h2><span id='topic+tune'></span><span id='topic+tune.VSURF_thres'></span><span id='topic+tune.VSURF_interp'></span>

<h3>Description</h3>

<p>This function allows to tune the &quot;thresholding&quot; and &quot;interpretation step&quot; of
VSURF, without rerunning all computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune(x, ...)

## S3 method for class 'VSURF_thres'
tune(x, nmin = 1, ...)

## S3 method for class 'VSURF_interp'
tune(x, nsd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tune_+3A_x">x</code></td>
<td>
<p>An object of class <code>VSURF_thres</code> or <code>VSURF_interp</code>, which
is the result of the <code><a href="#topic+VSURF_thres">VSURF_thres</a></code> or <code><a href="#topic+VSURF_interp">VSURF_interp</a></code>
function.</p>
</td></tr>
<tr><td><code id="tune_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="tune_+3A_nmin">nmin</code></td>
<td>
<p>Number of times the &quot;minimum value&quot; is multiplied to set
threshold value. See details below.</p>
</td></tr>
<tr><td><code id="tune_+3A_nsd">nsd</code></td>
<td>
<p>Number of times the standard deviation of the minimum value of
<code>err.interp</code> is multiplied. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code><a href="#topic+VSURF_thres">VSURF_thres</a></code> function, the actual threshold is performed
like this: only variables with a mean VI larger than <code>nmin</code> *
<code>min.thres</code> are kept.  The function <code>tune.VSURF_thres</code> allows you
to change the value of <code>nmin</code> (which multiply the estimated threshold
value <code>min.thres</code>), without rerunning all computations.  To get a
softer threshold than default, choose a value of <code>nmin</code> less than 1,
and to get a harder one, choose a value larger than 1.
</p>
<p>In <code><a href="#topic+VSURF_interp">VSURF_interp</a></code> function, the smallest model (and hence its
corresponding variables) having a mean OOB error rate less than
<code>err.min</code> + <code>nsd</code> * <code>sd.min</code> is selected.  The function
<code>tune.VSURF_interp</code> allows to change the value of <code>nsd</code> (which
multiply the standard deviation of the minimum OOB error rate
<code>sd.min</code>), without rerunning all computations.  To get a larger model
than default, choose a value of <code>nsd</code> less than 1, and to get a smaller
one, choose a value larger than 1.
</p>


<h3>Value</h3>

<p>An object with the same structure than the original output (from
<code><a href="#topic+VSURF_thres">VSURF_thres</a></code> or <code><a href="#topic+VSURF_interp">VSURF_interp</a></code>).
</p>


<h3>Author(s)</h3>

<p>Robin Genuer, Jean-Michel Poggi and Christine Tuleau-Malot
</p>


<h3>References</h3>

<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2010),
<em>Variable selection using random forests</em>, Pattern Recognition Letters
31(14), 2225-2236
</p>
<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2015),
<em>VSURF: An R Package for Variable Selection Using Random Forests</em>,
The R Journal 7(2):19-33
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VSURF">VSURF</a></code>, <code><a href="#topic+VSURF_thres">VSURF_thres</a></code>,
<code><a href="#topic+VSURF_interp">VSURF_interp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(iris)
iris.thres &lt;- VSURF_thres(iris[,1:4], iris[,5], ntree = 100, nfor.thres = 20)
iris.thres.tuned &lt;- tune(iris.thres, nmin = 10)
iris.thres.tuned
iris.interp &lt;- VSURF_interp(iris[,1:4], iris[,5], vars = iris.thres$varselect.thres,
                            nfor.interp = 10)
iris.interp.tuned &lt;- tune(iris.interp, nsd = 10)
iris.interp.tuned

## End(Not run)

</code></pre>

<hr>
<h2 id='VSURF'>Variable Selection Using Random Forests</h2><span id='topic+VSURF'></span><span id='topic+VSURF.default'></span><span id='topic+VSURF.formula'></span>

<h3>Description</h3>

<p>Three steps variable selection procedure based on random forests for
supervised classification and regression problems.  First step (&quot;thresholding
step&quot;) is dedicated to eliminate irrelevant variables from the dataset.
Second step (&quot;interpretation step&quot;) aims to select all variables related to
the response for interpretation purpose.  Third step (&quot;prediction step&quot;)
refines the selection by eliminating redundancy in the set of variables
selected by the second step, for prediction purpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VSURF(x, ...)

## Default S3 method:
VSURF(
  x,
  y,
  mtry = max(floor(ncol(x)/3), 1),
  ntree.thres = 500,
  nfor.thres = 20,
  nmin = 1,
  ntree.interp = 100,
  nfor.interp = 10,
  nsd = 1,
  ntree.pred = 100,
  nfor.pred = 10,
  nmj = 1,
  RFimplem = "randomForest",
  parallel = FALSE,
  ncores = detectCores() - 1,
  clusterType = "PSOCK",
  verbose = TRUE,
  ntree = 2000,
  ...
)

## S3 method for class 'formula'
VSURF(formula, data, ..., na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VSURF_+3A_x">x</code>, <code id="VSURF_+3A_formula">formula</code></td>
<td>
<p>A data frame or a matrix of predictors, the columns
represent the variables. Or a formula describing the model to be fitted.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_...">...</code></td>
<td>
<p>others parameters to be passed on to the <code>randomForest</code>
function (see ?randomForest for further information).</p>
</td></tr>
<tr><td><code id="VSURF_+3A_y">y</code></td>
<td>
<p>A response vector (must be a factor for classification problems and
numeric for regression ones).</p>
</td></tr>
<tr><td><code id="VSURF_+3A_mtry">mtry</code></td>
<td>
<p>Number of variables randomly sampled as candidates at each split.
Standard parameter of <code>randomForest</code>.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_ntree.thres">ntree.thres</code></td>
<td>
<p>Number of trees of each forest grown for &quot;thresholding
step&quot; (first of the three steps).</p>
</td></tr>
<tr><td><code id="VSURF_+3A_nfor.thres">nfor.thres</code></td>
<td>
<p>Number of forests grown for &quot;thresholding step&quot;.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_nmin">nmin</code></td>
<td>
<p>Number of times the &quot;minimum value&quot; is multiplied to set
threshold value. See details below.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_ntree.interp">ntree.interp</code></td>
<td>
<p>Number of trees of each forest grown for &quot;interpretation
step&quot; (second of the three steps).</p>
</td></tr>
<tr><td><code id="VSURF_+3A_nfor.interp">nfor.interp</code></td>
<td>
<p>Number of forests grown for &quot;interpretation step&quot;.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_nsd">nsd</code></td>
<td>
<p>Number of times the standard deviation of the minimum value of
<code>err.interp</code> is multiplied. See details below.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_ntree.pred">ntree.pred</code></td>
<td>
<p>Number of trees of each forest grown for &quot;prediction
step&quot; (last of the three steps).</p>
</td></tr>
<tr><td><code id="VSURF_+3A_nfor.pred">nfor.pred</code></td>
<td>
<p>Number of forests grown for &quot;prediction step&quot;.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_nmj">nmj</code></td>
<td>
<p>Number of times the mean jump is multiplied. See details below.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_rfimplem">RFimplem</code></td>
<td>
<p>Choice of the random forests implementation to use :
&quot;randomForest&quot; (default), &quot;ranger&quot; or &quot;Rborist&quot; (not that if &quot;Rborist&quot; is
chosen, &quot;randoForest&quot; will still be used for the first step
<code>VSURF_thres</code>). If a vector of length 3 is given, each coordinate is
passed to each intermediate function: <code>VSURF_thres</code>,
<code>VSURF_interp</code>, <code>VSURF_pred</code>, in this order.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_parallel">parallel</code></td>
<td>
<p>A logical indicating if you want VSURF to run in parallel on
multiple cores (default to FALSE). If a vector of length 3 is given,
each coordinate is passed to each intermediate function: <code>VSURF_thres</code>,
<code>VSURF_interp</code>, <code>VSURF_pred</code>, in this order.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use. Default is set to the number of cores
detected by R minus 1.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_clustertype">clusterType</code></td>
<td>
<p>Type of the multiple cores cluster used to run VSURF in
parallel. Must be chosen among &quot;PSOCK&quot; (default: SOCKET cluster available
locally on all OS), &quot;FORK&quot; (local too, only available for Linux and Mac
OS), &quot;MPI&quot; (can be used on a remote cluster, which needs <code>snow</code> and
<code>Rmpi</code> packages installed), &quot;ranger&quot; and &quot;Rborist&quot; for internal
parallelizations of those packages (not that if &quot;Rborist&quot; is
chosen, &quot;SOCKET&quot; will still be used for the first step
<code>VSURF_thres</code>). If a vector of length 2 is given, each
coordinate is passed to each intermediate function: <code>VSURF_thres</code>,
<code>VSURF_interp</code>, in this order.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating if information about method's progress
(included progress bars for each step) must be printed (default to TRUE).
Adds a small extra overload.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_ntree">ntree</code></td>
<td>
<p>(deprecated) Number of trees in each forest grown for
&quot;thresholding step&quot;.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="VSURF_+3A_na.action">na.action</code></td>
<td>
<p>A function to specify the action to be taken if NAs are
found.  (NOTE: If given, this argument must be named, and as
<code>randomForest</code> it is only used with the formula-type call.)</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li><p> First step (&quot;thresholding step&quot;): first, <code>nfor.thres</code>
random forests are computed using the function <code>randomForest</code> with
arguments <code>importance=TRUE</code>, and our choice of default values for
<code>ntree</code> and <code>mtry</code> (which are higher than default in
<code><a href="randomForest.html#topic+randomForest">randomForest</a></code> to get a more stable variable importance measure).
Then variables are sorted according to their mean variable importance (VI),
in decreasing order.  This order is kept all along the procedure. Next, a
threshold is computed: <code>min.thres</code>, the minimum predicted value of a
pruned CART tree fitted to the curve of the standard deviations of VI.
Finally, the actual &quot;thresholding step&quot; is performed: only variables with a
mean VI larger than <code>nmin</code> * <code>min.thres</code> are kept.
</p>
</li>
<li><p> Second step (&quot;interpretation step&quot;): the variables selected by the
first step are considered. <code>nfor.interp</code> embedded random forests models
are grown, starting with the random forest build with only the most important
variable and ending with all variables selected in the first step. Then,
<code>err.min</code> the minimum mean out-of-bag (OOB) error of these models and
its associated standard deviation <code>sd.min</code> are computed.  Finally, the
smallest model (and hence its corresponding variables) having a mean OOB
error less than <code>err.min</code> + <code>nsd</code> * <code>sd.min</code> is selected.
</p>
<p>Note that for this step (and the next one), the <code>mtry</code> parameter of
<code>randomForest</code> is set to its default value (see
<code><a href="randomForest.html#topic+randomForest">randomForest</a></code>) if <code>nvm</code>, the number of variables in the
model, is not greater than the number of observations, while it is set to
<code>nvm/3</code> otherwise. This is to ensure quality of OOB error estimations
along embedded RF models.
</p>
</li>
<li><p> Third step (&quot;prediction step&quot;): the starting point is the same than in
the second step. However, now the variables are added to the model in a
stepwise manner. <code>mean.jump</code>, the mean jump value is calculated using
variables that have been left out by the second step, and is set as the mean
absolute difference between mean OOB errors of one model and its first
following model.  Hence a variable is included in the model if the mean OOB
error decrease is larger than <code>nmj</code> * <code>mean.jump</code>.
</p>
<p>As for interpretation step, the <code>mtry</code> parameter of <code>randomForest</code>
is set to its default value if <code>nvm</code>, the number of variables in the
model, is not greater than the number of observations, while it is set to
<code>nvm/3</code> otherwise.</p>
</li></ul>

<p>VSURF is able to run using multiple cores in parallel (see <code>parallel</code>,
<code>clusterType</code> and <code>ncores</code> arguments).
</p>


<h3>Value</h3>

<p>An object of class <code>VSURF</code>, which is a list with the following
components:
</p>
<table role = "presentation">
<tr><td><code>varselect.thres</code></td>
<td>
<p>A vector of indexes of variables selected after
&quot;thresholding step&quot;, sorted according to their mean VI, in decreasing
order.</p>
</td></tr>
<tr><td><code>varselect.interp</code></td>
<td>
<p>A vector of indexes of variables selected after
&quot;interpretation step&quot;.</p>
</td></tr>
<tr><td><code>varselect.pred</code></td>
<td>
<p>A vector of indexes of variables selected after
&quot;prediction step&quot;.</p>
</td></tr>
<tr><td><code>nums.varselect</code></td>
<td>
<p>A vector of the 3 numbers of variables selected resp.
by &quot;thresholding step&quot;, &quot;interpretation step&quot; and &quot;prediction step&quot;.</p>
</td></tr>
<tr><td><code>imp.varselect.thres</code></td>
<td>
<p>A vector of importance of the
<code>varselect.thres</code> variables.</p>
</td></tr>
<tr><td><code>min.thres</code></td>
<td>
<p>The minimum predicted value of a pruned CART tree fitted to
the curve of the standard deviations of VI.</p>
</td></tr>
<tr><td><code>imp.mean.dec</code></td>
<td>
<p>A vector of the variables importance means (over
<code>nfor.thres</code> runs), in decreasing order.</p>
</td></tr>
<tr><td><code>imp.mean.dec.ind</code></td>
<td>
<p>The ordering index vector associated to the sorting
of variables importance means.</p>
</td></tr>
<tr><td><code>imp.sd.dec</code></td>
<td>
<p>A vector of standard deviations of all variables
importance. The order is given by <code>imp.mean.dec.ind</code>.</p>
</td></tr>
<tr><td><code>mean.perf</code></td>
<td>
<p>Mean OOB error rate, obtained by a random forests build on
all variables.</p>
</td></tr>
<tr><td><code>pred.pruned.tree</code></td>
<td>
<p>Predictions of the CART tree fitted to the curve of
the standard deviations of VI.</p>
</td></tr>
<tr><td><code>err.interp</code></td>
<td>
<p>A vector of the mean OOB error rates of the embedded
random forests models build during the &quot;interpretation step&quot;.</p>
</td></tr>
<tr><td><code>sd.min</code></td>
<td>
<p>The standard deviation of OOB error rates associated to the
random forests model attaining the minimum mean OOB error rate during the
&quot;interpretation step&quot;.</p>
</td></tr>
<tr><td><code>err.pred</code></td>
<td>
<p>A vector of the mean OOB error rates of the random forests
models build during the &quot;prediction step&quot;.</p>
</td></tr>
<tr><td><code>mean.jump</code></td>
<td>
<p>The mean jump value computed during the &quot;prediction step&quot;.</p>
</td></tr>
<tr><td><code>nmin</code>, <code>nsd</code>, <code>nmj</code></td>
<td>
<p>Corresponding parameters values.</p>
</td></tr>
<tr><td><code>overall.time</code></td>
<td>
<p>Overall computation time.</p>
</td></tr>
<tr><td><code>comput.times</code></td>
<td>
<p>A list of the 3 computation times respectively
associated with the 3 steps: &quot;thresholding&quot;, &quot;interpretation&quot; and
&quot;prediction&quot;.</p>
</td></tr>
<tr><td><code>RFimplem</code></td>
<td>
<p>The RF implementation used to run <code>VSURF</code>,
among &quot;randomForest&quot; (default), &quot;ranger&quot; and &quot;Rborist&quot; or a vector of length
3 with those.</p>
</td></tr>
<tr><td><code>ncores</code></td>
<td>
<p>The number of cores used to run <code>VSURF</code> in parallel (NULL
if VSURF did not run in parallel).</p>
</td></tr>
<tr><td><code>clusterType</code></td>
<td>
<p>The type of the cluster used to run <code>VSURF</code> in
parallel (NULL if VSURF did not run in parallel).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The original call to <code>VSURF</code>.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>Terms associated to the formula (only if formula-type call was
used).</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>Method used to deal with missing values (only if
formula-type call was used).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Genuer, Jean-Michel Poggi and Christine Tuleau-Malot
</p>


<h3>References</h3>

<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2010),
<em>Variable selection using random forests</em>, Pattern Recognition Letters
31(14), 2225-2236
</p>
<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2015),
<em>VSURF: An R Package for Variable Selection Using Random Forests</em>, The
R Journal 7(2):19-33
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.VSURF">plot.VSURF</a></code>, <code><a href="#topic+summary.VSURF">summary.VSURF</a></code>,
<code><a href="#topic+VSURF_thres">VSURF_thres</a></code>, <code><a href="#topic+VSURF_interp">VSURF_interp</a></code>,
<code><a href="#topic+VSURF_pred">VSURF_pred</a></code>, <code><a href="#topic+tune">tune</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
iris.vsurf &lt;- VSURF(iris[,1:4], iris[,5])
iris.vsurf

## Not run: 
# A more interesting example with toys data (see \code{\link{toys}})
# (a few minutes to execute)
data(toys)
toys.vsurf &lt;- VSURF(toys$x, toys$y)
toys.vsurf

# VSURF run on 2 cores in parallel (using a SOCKET cluster):
data(toys)
toys.vsurf.parallel &lt;- VSURF(toys$x, toys$y, parallel = TRUE, ncores = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='VSURF_interp'>Interpretation step of VSURF</h2><span id='topic+VSURF_interp'></span><span id='topic+VSURF_interp.default'></span><span id='topic+VSURF_interp.formula'></span>

<h3>Description</h3>

<p>Interpretation step aims to select all variables related to the response for
interpretation purpose. This is the second step of the <code><a href="#topic+VSURF">VSURF</a></code>
function. It is designed to be executed after the thresholding step
<code><a href="#topic+VSURF_thres">VSURF_thres</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VSURF_interp(x, ...)

## Default S3 method:
VSURF_interp(
  x,
  y,
  vars,
  ntree.interp = 100,
  nfor.interp = 25,
  nsd = 1,
  RFimplem = "randomForest",
  parallel = FALSE,
  ncores = detectCores() - 1,
  clusterType = "PSOCK",
  verbose = TRUE,
  ntree = NULL,
  ...
)

## S3 method for class 'formula'
VSURF_interp(formula, data, ..., na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VSURF_interp_+3A_x">x</code>, <code id="VSURF_interp_+3A_formula">formula</code></td>
<td>
<p>A data frame or a matrix of predictors, the columns represent
the variables. Or a formula describing the model to be fitted.</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_...">...</code></td>
<td>
<p>others parameters to be passed on to the <code>randomForest</code>
function (see ?randomForest for further information).</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_y">y</code></td>
<td>
<p>A response vector (must be a factor for classification problems and
numeric for regression ones).</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_vars">vars</code></td>
<td>
<p>A vector of variable indices. Typically, indices of variables
selected by thresholding step (see value <code>varselect.thres</code> of
<code><a href="#topic+VSURF_thres">VSURF_thres</a></code> function).</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_ntree.interp">ntree.interp</code></td>
<td>
<p>Number of trees of each forest grown.</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_nfor.interp">nfor.interp</code></td>
<td>
<p>Number of forests grown.</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_nsd">nsd</code></td>
<td>
<p>Number of times the standard deviation of the minimum value of
<code>err.interp</code> is multiplied. See details below.</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_rfimplem">RFimplem</code></td>
<td>
<p>Choice of the random forests implementation to use :
&quot;randomForest&quot; (default), &quot;ranger&quot; or &quot;Rborist&quot; (not that if &quot;Rborist&quot; is
chosen, &quot;randoForest&quot; will still be used for the first step
<code>VSURF_thres</code>). If a vector of length 3 is given, each coordinate is
passed to each intermediate function: <code>VSURF_thres</code>,
<code>VSURF_interp</code>, <code>VSURF_pred</code>, in this order.</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_parallel">parallel</code></td>
<td>
<p>A logical indicating if you want VSURF to run in parallel on
multiple cores (default to FALSE). If a vector of length 3 is given,
each coordinate is passed to each intermediate function: <code>VSURF_thres</code>,
<code>VSURF_interp</code>, <code>VSURF_pred</code>, in this order.</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use. Default is set to the number of cores
detected by R minus 1.</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_clustertype">clusterType</code></td>
<td>
<p>Type of the multiple cores cluster used to run VSURF in
parallel. Must be chosen among &quot;PSOCK&quot; (default: SOCKET cluster available
locally on all OS), &quot;FORK&quot; (local too, only available for Linux and Mac
OS), &quot;MPI&quot; (can be used on a remote cluster, which needs <code>snow</code> and
<code>Rmpi</code> packages installed), &quot;ranger&quot; and &quot;Rborist&quot; for internal
parallelizations of those packages (not that if &quot;Rborist&quot; is
chosen, &quot;SOCKET&quot; will still be used for the first step
<code>VSURF_thres</code>). If a vector of length 2 is given, each
coordinate is passed to each intermediate function: <code>VSURF_thres</code>,
<code>VSURF_interp</code>, in this order.</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating if information about method's progress
(included progress bars for each step) must be printed (default to TRUE).
Adds a small extra overload.</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_ntree">ntree</code></td>
<td>
<p>(deprecated) Number of trees in each forest grown for
&quot;thresholding step&quot;.</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="VSURF_interp_+3A_na.action">na.action</code></td>
<td>
<p>A function to specify the action to be taken if NAs are
found.  (NOTE: If given, this argument must be named, and as
<code>randomForest</code> it is only used with the formula-type call.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nfor.interp</code> embedded random forests models are grown, starting with the
random forest build with only the most important variable and ending with all
variables.  Then, <code>err.min</code> the minimum mean out-of-bag (OOB) error rate
of these models and its associated standard deviation <code>sd.min</code> are
computed.  Finally, the smallest model (and hence its corresponding variables)
having a mean OOB error less than <code>err.min</code> + <code>nsd</code> * <code>sd.min</code>
is selected.
</p>
<p>Note that, the <code>mtry</code> parameter of <code>randomForest</code> is set to its
default value (see <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>) if <code>nvm</code>, the number of
variables in the model, is not greater than the number of observations, while
it is set to <code>nvm/3</code> otherwise. This is to ensure quality of OOB error
estimations along embedded RF models.
</p>


<h3>Value</h3>

<p>An object of class <code>VSURF_interp</code>, which is a list with the
following components:
</p>
<table role = "presentation">
<tr><td><code>varselect.interp</code></td>
<td>
<p>A vector of indices of selected variables.</p>
</td></tr>
<tr><td><code>err.interp</code></td>
<td>
<p>A vector of the mean OOB error rates of the embedded
random forests models.</p>
</td></tr>
<tr><td><code>sd.min</code></td>
<td>
<p>The standard deviation of OOB error rates associated to the
random forests model attaining the minimum mean OOB error rate.</p>
</td></tr>
<tr><td><code>num.varselect.interp</code></td>
<td>
<p>The number of selected variables.</p>
</td></tr>
<tr><td><code>varselect.thres</code></td>
<td>
<p>A vector of indexes of variables selected after
&quot;thresholding step&quot;, sorted according to their mean VI, in decreasing
order.</p>
</td></tr>
<tr><td><code>nsd</code></td>
<td>
<p>Value of the parameter in the call.</p>
</td></tr>
<tr><td><code>comput.time</code></td>
<td>
<p>Computation time.</p>
</td></tr>
<tr><td><code>RFimplem</code></td>
<td>
<p>The RF implementation used to run
<code>VSURF_interp</code>.</p>
</td></tr>
<tr><td><code>ncores</code></td>
<td>
<p>The number of cores used to run <code>VSURF_interp</code> in
parallel (NULL if VSURF_interp did not run in parallel).</p>
</td></tr>
<tr><td><code>clusterType</code></td>
<td>
<p>The type of the cluster used to run <code>VSURF_interp</code>
in parallel (NULL if VSURF_interp did not run in parallel).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The original call to <code>VSURF</code>.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>Terms associated to the formula (only if formula-type call was
used).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Genuer, Jean-Michel Poggi and Christine Tuleau-Malot
</p>


<h3>References</h3>

<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2010),
<em>Variable selection using random forests</em>, Pattern Recognition Letters
31(14), 2225-2236
</p>
<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2015),
<em>VSURF: An R Package for Variable Selection Using Random Forests</em>, The
R Journal 7(2):19-33
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VSURF">VSURF</a></code>, <code><a href="#topic+tune">tune</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
iris.thres &lt;- VSURF_thres(iris[,1:4], iris[,5])
iris.interp &lt;- VSURF_interp(iris[,1:4], iris[,5],
  vars = iris.thres$varselect.thres)
iris.interp

## Not run: 
# A more interesting example with toys data (see \code{\link{toys}})
# (a few minutes to execute)
data(toys)
toys.thres &lt;- VSURF_thres(toys$x, toys$y)
toys.interp &lt;- VSURF_interp(toys$x, toys$y,
  vars = toys.thres$varselect.thres)
toys.interp
## End(Not run)

</code></pre>

<hr>
<h2 id='VSURF_pred'>Prediction step of VSURF</h2><span id='topic+VSURF_pred'></span><span id='topic+VSURF_pred.default'></span><span id='topic+VSURF_pred.formula'></span>

<h3>Description</h3>

<p>Prediction step refines the selection of interpretation step
<code><a href="#topic+VSURF_interp">VSURF_interp</a></code> by eliminating redundancy in the set of variables
selected, for prediction purpose. This is the third step of the
<code><a href="#topic+VSURF">VSURF</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VSURF_pred(x, ...)

## Default S3 method:
VSURF_pred(
  x,
  y,
  err.interp,
  varselect.interp,
  ntree.pred = 100,
  nfor.pred = 10,
  nmj = 1,
  RFimplem = "randomForest",
  parallel = FALSE,
  ncores = detectCores() - 1,
  verbose = TRUE,
  ntree = NULL,
  ...
)

## S3 method for class 'formula'
VSURF_pred(formula, data, ..., na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VSURF_pred_+3A_x">x</code>, <code id="VSURF_pred_+3A_formula">formula</code></td>
<td>
<p>A data frame or a matrix of predictors, the columns
represent the variables. Or a formula describing the model to be fitted.</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_...">...</code></td>
<td>
<p>others parameters to be passed on to the <code>randomForest</code>
function (see ?randomForest for further information).</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_y">y</code></td>
<td>
<p>A response vector (must be a factor for classification problems and
numeric for regression ones).</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_err.interp">err.interp</code></td>
<td>
<p>A vector of the mean OOB error rates of the embedded random
forests models build during interpretation step (value <code>err.interp</code> of
function <code><a href="#topic+VSURF_interp">VSURF_interp</a></code>).</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_varselect.interp">varselect.interp</code></td>
<td>
<p>A vector of indices of variables selected after
interpretation step.</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_ntree.pred">ntree.pred</code></td>
<td>
<p>Number of trees of each forest grown.</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_nfor.pred">nfor.pred</code></td>
<td>
<p>Number of forests grown.</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_nmj">nmj</code></td>
<td>
<p>Number of times the mean jump is multiplied. See details below.</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_rfimplem">RFimplem</code></td>
<td>
<p>Choice of the random forests implementation to use :
&quot;randomForest&quot; (default), &quot;ranger&quot; or &quot;Rborist&quot; (not that if &quot;Rborist&quot; is
chosen, &quot;randoForest&quot; will still be used for the first step
<code>VSURF_thres</code>). If a vector of length 3 is given, each coordinate is
passed to each intermediate function: <code>VSURF_thres</code>,
<code>VSURF_interp</code>, <code>VSURF_pred</code>, in this order.</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_parallel">parallel</code></td>
<td>
<p>A logical indicating if you want VSURF to run in parallel on
multiple cores (default to FALSE). If a vector of length 3 is given,
each coordinate is passed to each intermediate function: <code>VSURF_thres</code>,
<code>VSURF_interp</code>, <code>VSURF_pred</code>, in this order.</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use. Default is set to the number of cores
detected by R minus 1.</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating if information about method's progress
(included progress bars for each step) must be printed (default to TRUE).
Adds a small extra overload.</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_ntree">ntree</code></td>
<td>
<p>(deprecated) Number of trees in each forest grown for
&quot;thresholding step&quot;.</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="VSURF_pred_+3A_na.action">na.action</code></td>
<td>
<p>A function to specify the action to be taken if NAs are
found.  (NOTE: If given, this argument must be named, and as
<code>randomForest</code> it is only used with the formula-type call.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nfor.pred</code> embedded random forests models are grown, starting with the
random forest build with only the most important variable. Variables are
added to the model in a stepwise manner. The mean jump value <code>mean.jump</code>
is calculated using variables that have been left out by interpretation step,
and is set as the mean absolute difference between mean OOB errors of one
model and its first following model. Hence a variable is included in the
model if the mean OOB error decrease is larger than <code>nmj</code> *
<code>mean.jump</code>.
</p>
<p>Note that, the <code>mtry</code> parameter of <code>randomForest</code> is set to its
default value (see <code><a href="randomForest.html#topic+randomForest">randomForest</a></code>) if <code>nvm</code>, the number of
variables in the model, is not greater than the number of observations, while
it is set to <code>nvm/3</code> otherwise. This is to ensure quality of OOB error
estimations along embedded RF models.
</p>


<h3>Value</h3>

<p>An object of class <code>VSURF_pred</code>, which is a list with the
following components:
</p>
<table role = "presentation">
<tr><td><code>varselect.pred</code></td>
<td>
<p>A vector of indices of variables selected after
&quot;prediction step&quot;.</p>
</td></tr>
<tr><td><code>err.pred</code></td>
<td>
<p>A vector of the mean OOB error rates of the random forests
models build during the &quot;prediction step&quot;.</p>
</td></tr>
<tr><td><code>mean.jump</code></td>
<td>
<p>The mean jump value computed during the &quot;prediction
step&quot;.</p>
</td></tr>
<tr><td><code>num.varselect.pred</code></td>
<td>
<p>The number of selected variables.</p>
</td></tr>
<tr><td><code>nmj</code></td>
<td>
<p>Value of the parameter in the call.</p>
</td></tr>
<tr><td><code>comput.time</code></td>
<td>
<p>Computation time.</p>
</td></tr>
<tr><td><code>RFimplem</code></td>
<td>
<p>The RF implementation used to run
<code>VSURF_pred</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The original call to <code>VSURF</code>.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>Terms associated to the formula (only if formula-type call was
used).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Genuer, Jean-Michel Poggi and Christine Tuleau-Malot
</p>


<h3>References</h3>

<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2010),
<em>Variable selection using random forests</em>, Pattern Recognition Letters
31(14), 2225-2236
</p>
<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2015),
<em>VSURF: An R Package for Variable Selection Using Random Forests</em>, The
R Journal 7(2):19-33
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VSURF">VSURF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
iris.thres &lt;- VSURF_thres(iris[,1:4], iris[,5])
iris.interp &lt;- VSURF_interp(iris[,1:4], iris[,5],
  vars = iris.thres$varselect.thres)
iris.pred &lt;- VSURF_pred(iris[,1:4], iris[,5],
  err.interp = iris.interp$err.interp,
  varselect.interp = iris.interp$varselect.interp)
iris.pred

## Not run: 
# A more interesting example with toys data (see \code{\link{toys}})
# (a few minutes to execute)
data(toys)
toys.thres &lt;- VSURF_thres(toys$x, toys$y)
toys.interp &lt;- VSURF_interp(toys$x, toys$y,
  vars = toys.thres$varselect.thres)
toys.pred &lt;- VSURF_pred(toys$x, toys$y, err.interp = toys.interp$err.interp,
  varselect.interp = toys.interp$varselect.interp)
toys.pred
## End(Not run)

</code></pre>

<hr>
<h2 id='VSURF_thres'>Thresholding step of VSURF</h2><span id='topic+VSURF_thres'></span><span id='topic+VSURF_thres.default'></span><span id='topic+VSURF_thres.formula'></span>

<h3>Description</h3>

<p>Thresholding step is dedicated to roughly eliminate irrelevant variables a the
dataset. This is the first step of the <code><a href="#topic+VSURF">VSURF</a></code> function. For
refined variable selection, see VSURF other steps: <code><a href="#topic+VSURF_interp">VSURF_interp</a></code>
and <code><a href="#topic+VSURF_pred">VSURF_pred</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VSURF_thres(x, ...)

## Default S3 method:
VSURF_thres(
  x,
  y,
  mtry = max(floor(ncol(x)/3), 1),
  ntree.thres = 500,
  nfor.thres = 20,
  nmin = 1,
  RFimplem = "randomForest",
  parallel = FALSE,
  clusterType = "PSOCK",
  ncores = parallel::detectCores() - 1,
  verbose = TRUE,
  ntree = NULL,
  ...
)

## S3 method for class 'formula'
VSURF_thres(formula, data, ..., na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VSURF_thres_+3A_x">x</code>, <code id="VSURF_thres_+3A_formula">formula</code></td>
<td>
<p>A data frame or a matrix of predictors, the columns represent
the variables. Or a formula describing the model to be fitted.</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_...">...</code></td>
<td>
<p>others parameters to be passed on to the <code>randomForest</code>
function (see ?randomForest for further information).</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_y">y</code></td>
<td>
<p>A response vector (must be a factor for classification problems and
numeric for regression ones).</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_mtry">mtry</code></td>
<td>
<p>Number of variables randomly sampled as candidates at each split.
Standard parameter of <code>randomForest</code>.</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_ntree.thres">ntree.thres</code></td>
<td>
<p>Number of trees of each forest grown.</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_nfor.thres">nfor.thres</code></td>
<td>
<p>Number of forests grown.</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_nmin">nmin</code></td>
<td>
<p>Number of times the &quot;minimum value&quot; is multiplied to set
threshold value. See details below.</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_rfimplem">RFimplem</code></td>
<td>
<p>Choice of the random forests implementation to use :
&quot;randomForest&quot; (default), &quot;ranger&quot; or &quot;Rborist&quot; (not that if &quot;Rborist&quot; is
chosen, &quot;randoForest&quot; will still be used for the first step
<code>VSURF_thres</code>). If a vector of length 3 is given, each coordinate is
passed to each intermediate function: <code>VSURF_thres</code>,
<code>VSURF_interp</code>, <code>VSURF_pred</code>, in this order.</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_parallel">parallel</code></td>
<td>
<p>A logical indicating if you want VSURF to run in parallel on
multiple cores (default to FALSE). If a vector of length 3 is given,
each coordinate is passed to each intermediate function: <code>VSURF_thres</code>,
<code>VSURF_interp</code>, <code>VSURF_pred</code>, in this order.</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_clustertype">clusterType</code></td>
<td>
<p>Type of the multiple cores cluster used to run VSURF in
parallel. Must be chosen among &quot;PSOCK&quot; (default: SOCKET cluster available
locally on all OS), &quot;FORK&quot; (local too, only available for Linux and Mac
OS), &quot;MPI&quot; (can be used on a remote cluster, which needs <code>snow</code> and
<code>Rmpi</code> packages installed), &quot;ranger&quot; and &quot;Rborist&quot; for internal
parallelizations of those packages (not that if &quot;Rborist&quot; is
chosen, &quot;SOCKET&quot; will still be used for the first step
<code>VSURF_thres</code>). If a vector of length 2 is given, each
coordinate is passed to each intermediate function: <code>VSURF_thres</code>,
<code>VSURF_interp</code>, in this order.</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use. Default is set to the number of cores
detected by R minus 1.</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating if information about method's progress
(included progress bars for each step) must be printed (default to TRUE).
Adds a small extra overload.</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_ntree">ntree</code></td>
<td>
<p>(deprecated) Number of trees in each forest grown for
&quot;thresholding step&quot;.</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="VSURF_thres_+3A_na.action">na.action</code></td>
<td>
<p>A function to specify the action to be taken if NAs are
found.  (NOTE: If given, this argument must be named, and as
<code>randomForest</code> it is only used with the formula-type call.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, <code>nfor.thres</code> random forests are computed using the function
<code>randomForest</code> with arguments <code>importance=TRUE</code>, and our choice of
default values for <code>ntree</code> and <code>mtry</code> (which are higher than default
in <code><a href="randomForest.html#topic+randomForest">randomForest</a></code> to get a more stable variable importance
measure). Then variables are sorted according to their mean variable
importance (VI), in decreasing order. This order is kept all along the
procedure.  Next, a threshold is computed: <code>min.thres</code>, the minimum
predicted value of a pruned CART tree fitted to the curve of the standard
deviations of VI.  Finally, the actual thresholding is performed: only
variables with a mean VI larger than <code>nmin</code> * <code>min.thres</code> are kept.
</p>


<h3>Value</h3>

<p>An object of class <code>VSURF_thres</code>, which is a list with the
following components:
</p>
<table role = "presentation">
<tr><td><code>varselect.thres</code></td>
<td>
<p>A vector of indices of selected variables, sorted
according to their mean VI, in decreasing order.</p>
</td></tr>
<tr><td><code>imp.varselect.thres</code></td>
<td>
<p>A vector of importance of the
<code>varselect.thres</code> variables.</p>
</td></tr>
<tr><td><code>min.thres</code></td>
<td>
<p>The minimum predicted value of a pruned CART tree fitted to
the curve of the standard deviations of VI.</p>
</td></tr>
<tr><td><code>num.varselect.thres</code></td>
<td>
<p>The number of selected variables.</p>
</td></tr>
<tr><td><code>imp.mean.dec</code></td>
<td>
<p>A vector of the variables importance means (over
<code>nfor.thres</code> runs), in decreasing order.</p>
</td></tr>
<tr><td><code>imp.mean.dec.ind</code></td>
<td>
<p>The ordering index vector associated to the sorting
of variables importance means.</p>
</td></tr>
<tr><td><code>imp.sd.dec</code></td>
<td>
<p>A vector of standard deviations of all variables
importance. The order is given by <code>imp.mean.dec.ind</code>.</p>
</td></tr>
<tr><td><code>mean.perf</code></td>
<td>
<p>The mean OOB error rate, obtained by a random forests build
with all variables.</p>
</td></tr>
<tr><td><code>pred.pruned.tree</code></td>
<td>
<p>The predictions of the CART tree fitted to the curve
of the standard deviations of VI.</p>
</td></tr>
<tr><td><code>nmin</code></td>
<td>
<p>Value of the parameter in the call.</p>
</td></tr>
<tr><td><code>comput.time</code></td>
<td>
<p>Computation time.</p>
</td></tr>
<tr><td><code>RFimplem</code></td>
<td>
<p>The RF implementation used to run
<code>VSURF_thres</code>.</p>
</td></tr>
<tr><td><code>ncores</code></td>
<td>
<p>The number of cores used to run <code>VSURF_thres</code> in parallel
(NULL if VSURF_thres did not run in parallel).</p>
</td></tr>
<tr><td><code>clusterType</code></td>
<td>
<p>The type of the cluster used to run <code>VSURF_thres</code> in
parallel (NULL if VSURF_thres did not run in parallel).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The original call to <code>VSURF</code>.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>Terms associated to the formula (only if formula-type call was
used).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin Genuer, Jean-Michel Poggi and Christine Tuleau-Malot
</p>


<h3>References</h3>

<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2010),
<em>Variable selection using random forests</em>, Pattern Recognition Letters
31(14), 2225-2236
</p>
<p>Genuer, R. and Poggi, J.M. and Tuleau-Malot, C. (2015),
<em>VSURF: An R Package for Variable Selection Using Random Forests</em>, The
R Journal 7(2):19-33
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VSURF">VSURF</a></code>, <code><a href="#topic+tune">tune</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
iris.thres &lt;- VSURF_thres(iris[,1:4], iris[,5])
iris.thres

## Not run: 
# A more interesting example with toys data (see \code{\link{toys}})
# (a few minutes to execute)
data(toys)
toys.thres &lt;- VSURF_thres(toys$x, toys$y)
toys.thres
## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
