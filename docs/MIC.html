<!DOCTYPE html><html lang="en"><head><title>Help for package MIC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MIC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MIC-package'><p>MIC: Analysis of Antimicrobial Minimum Inhibitory Concentration Data</p></a></li>
<li><a href='#bias'><p>Calculate MIC bias</p></a></li>
<li><a href='#clean_raw_mic'><p>Clean up raw MIC for use as a feature</p></a></li>
<li><a href='#combined_file_system'><p>Combine train and test filesystem into single folder</p></a></li>
<li><a href='#compare_mic'><p>Compare and validate MIC values</p></a></li>
<li><a href='#compare_sir'><p>Compare SIR results and generate categorical agreement</p></a></li>
<li><a href='#download_patric_db'><p>Download PATRIC database</p></a></li>
<li><a href='#ecoffs'><p>ECOFF data</p></a></li>
<li><a href='#essential_agreement'><p>Essential agreement for MIC validation</p></a></li>
<li><a href='#example_mics'><p>Example MIC data</p></a></li>
<li><a href='#fill_dilution_levels'><p>Fill MIC dilution levels</p></a></li>
<li><a href='#force_mic'><p>Force MIC-like into MIC-compatible format</p></a></li>
<li><a href='#genome_to_libsvm'><p>Converts a genome to kmers stored in libsvm format on disk</p></a></li>
<li><a href='#genomes_to_kmer_libsvm'><p>Convert genomes to kmers in libsvm format</p></a></li>
<li><a href='#get_mic'><p>Get MIC meta-data from feature database</p></a></li>
<li><a href='#kmers'><p>Generates genome kmers</p></a></li>
<li><a href='#load_patric_db'><p>Load PATRIC database</p></a></li>
<li><a href='#mic_censor'><p>Censor MIC values</p></a></li>
<li><a href='#mic_r_breakpoint'><p>R breakpoint for MIC</p></a></li>
<li><a href='#mic_range'><p>Generate dilution series</p></a></li>
<li><a href='#mic_s_breakpoint'><p>S breakpoint for MIC</p></a></li>
<li><a href='#mic_uncensor'><p>Uncensor MICs</p></a></li>
<li><a href='#move_files'><p>Move or copy files using logical vector</p></a></li>
<li><a href='#plot.mic_validation'><p>Plot MIC validation results</p></a></li>
<li><a href='#print.mic_validation'><p>Print MIC validation object</p></a></li>
<li><a href='#print.mic_validation_summary'><p>Print MIC validation summary</p></a></li>
<li><a href='#pull_PATRIC_genomes'><p>Automated download of genomes from PATRIC database</p></a></li>
<li><a href='#qc_in_range'><p>Check that MIC is within QC range</p></a></li>
<li><a href='#qc_on_target'><p>Check that QC measurement is at the required target</p>
<a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a></a></li>
<li><a href='#replace_multiple_slashes'><p>Removes multiple slashes in a path or url</p></a></li>
<li><a href='#reverse_complement'><p>Reverse complement of DNA string</p></a></li>
<li><a href='#split_and_combine_files'><p>Create test train files from a number of files</p></a></li>
<li><a href='#squeezed_index_to_str'><p>Get str conversion of squeezed kmer using index</p></a></li>
<li><a href='#squeezed_mers'><p>Generates all permutations of squeezed kmers</p></a></li>
<li><a href='#standardise_mic'><p>Standardise MIC to control strain</p>
<a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a></a></li>
<li><a href='#summary.mic_validation'><p>Summary of MIC validation results</p></a></li>
<li><a href='#table'><p>Table</p></a></li>
<li><a href='#tidy_patric_meta_data'><p>Tidy PATRIC data</p></a></li>
<li><a href='#train_test_filesystem'><p>Organise files into a train-test filesystem</p></a></li>
<li><a href='#unsqueezed_index_to_str'><p>Get str conversion of unsqueezed kmer using index</p></a></li>
<li><a href='#unsqueezed_mers'><p>Generates all permutations of unsqueezed kmers</p></a></li>
<li><a href='#xgb.cv.lowmem'><p>Low memory cross-validation wrapper for XGBoost</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Analysis of Antimicrobial Minimum Inhibitory Concentration Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyse, plot, and tabulate antimicrobial minimum inhibitory concentration (MIC) data.
    Validate the results of an MIC experiment by comparing observed MIC values to
    a gold standard assay, in line with standards from the International Organization for
    Standardization (2021) <a href="https://www.iso.org/standard/79377.html">https://www.iso.org/standard/79377.html</a>. Perform MIC prediction from
    whole genome sequence data stored in the Pathosystems Resource Integration Center (2013)
    &lt;<a href="https://doi.org/10.1093%2Fnar%2Fgkt1099">doi:10.1093/nar/gkt1099</a>&gt; database or locally.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>AMR, glue, readr, dplyr, Rcpp, data.table, Biostrings,
stringr, rlang, tidyr, future.apply, progressr, lemon, ggplot2,
forcats, purrr, tibble</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), xgboost, flextable, caret, lifecycle,
future</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/agerada/MIC">https://github.com/agerada/MIC</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/agerada/MIC/issues">https://github.com/agerada/MIC/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-06 16:22:34 UTC; agerada</td>
</tr>
<tr>
<td>Author:</td>
<td>Alessandro Gerada <a href="https://orcid.org/0000-0002-6743-4271"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alessandro Gerada &lt;alessandro.gerada@liverpool.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-07 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='MIC-package'>MIC: Analysis of Antimicrobial Minimum Inhibitory Concentration Data</h2><span id='topic+MIC'></span><span id='topic+MIC-package'></span>

<h3>Description</h3>

<p>Analyse, plot, and tabulate antimicrobial minimum inhibitory concentration (MIC) data. Validate the results of an MIC experiment by comparing observed MIC values to a gold standard assay, in line with standards from the International Organization for Standardization (2021) <a href="https://www.iso.org/standard/79377.html">https://www.iso.org/standard/79377.html</a>. Perform MIC prediction from whole genome sequence data stored in the Pathosystems Resource Integration Center (2013) <a href="https://doi.org/10.1093/nar/gkt1099">doi:10.1093/nar/gkt1099</a> database or locally.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alessandro Gerada <a href="mailto:alessandro.gerada@liverpool.ac.uk">alessandro.gerada@liverpool.ac.uk</a> (<a href="https://orcid.org/0000-0002-6743-4271">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/agerada/MIC">https://github.com/agerada/MIC</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/agerada/MIC/issues">https://github.com/agerada/MIC/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bias'>Calculate MIC bias</h2><span id='topic+bias'></span>

<h3>Description</h3>

<p>Calculate the bias between two AMR::mic vectors. The bias is calculated as
the percentage of test MICs that are above the gold standard MICs minus the
percentage of test MICs that are below the gold standard MICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bias(gold_standard, test)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bias_+3A_gold_standard">gold_standard</code></td>
<td>
<p>AMR::mic vector</p>
</td></tr>
<tr><td><code id="bias_+3A_test">test</code></td>
<td>
<p>AMR::mic vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value
</p>


<h3>References</h3>

<p>International Organization for Standardization. ISO 20776-2:2021
Available from: https://www.iso.org/standard/79377.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_standard &lt;- c("&lt;0.25", "8", "64", "&gt;64")
test &lt;- c("&lt;0.25", "2", "16", "64")
bias(gold_standard, test)
</code></pre>

<hr>
<h2 id='clean_raw_mic'>Clean up raw MIC for use as a feature</h2><span id='topic+clean_raw_mic'></span>

<h3>Description</h3>

<p>Removes leading &quot;=&quot; which can sometimes be present in raw MIC results. Also converts co-trimoxazole to trimethprim component only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_raw_mic(mic)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_raw_mic_+3A_mic">mic</code></td>
<td>
<p>character containing MIC/s</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character of clean MIC/s
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clean_raw_mic(c("==&gt;64","0.25/8.0"))
</code></pre>

<hr>
<h2 id='combined_file_system'>Combine train and test filesystem into single folder</h2><span id='topic+combined_file_system'></span>

<h3>Description</h3>

<p>This function reorganises files that have been split into train and test
directories using train_test_filesystem() back into a single directory.
This is a convenience function to reverse the effects of
train_test_filesystem().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combined_file_system(
  path_to_folders,
  file_ext,
  train_folder = "train",
  test_folder = "test",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combined_file_system_+3A_path_to_folders">path_to_folders</code></td>
<td>
<p>path containing test and train folders; files will be
moved here</p>
</td></tr>
<tr><td><code id="combined_file_system_+3A_file_ext">file_ext</code></td>
<td>
<p>file extension to filter</p>
</td></tr>
<tr><td><code id="combined_file_system_+3A_train_folder">train_folder</code></td>
<td>
<p>train folder subdirectory name</p>
</td></tr>
<tr><td><code id="combined_file_system_+3A_test_folder">test_folder</code></td>
<td>
<p>test folder subdirectory name</p>
</td></tr>
<tr><td><code id="combined_file_system_+3A_overwrite">overwrite</code></td>
<td>
<p>force overwrite of files that already exist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector, indicated success or failure for each file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# create 10 random DNA files
tmp_dir &lt;- tempdir()
# remove any existing .fna files
file.remove(
 list.files(tmp_dir, pattern = "*.fna", full.names = TRUE)
)
for (i in 1:10) {
writeLines(paste0("&gt;", i, "\n", paste0(sample(c("A", "T", "C", "G"),
  100, replace = TRUE), collapse = "")), file.path(tmp_dir, paste0(i, ".fna")))
}

# split files into train and test directories
paths &lt;- train_test_filesystem(tmp_dir,
                               file_ext = "fna",
                               split = 0.8,
                               shuffle = TRUE,
                               overwrite = TRUE)
# combine files back into a single directory
combined_file_system(tmp_dir, "fna")
list.files(tmp_dir)
</code></pre>

<hr>
<h2 id='compare_mic'>Compare and validate MIC values</h2><span id='topic+compare_mic'></span>

<h3>Description</h3>

<p>This function compares an vector of MIC values to another. Generally, this is
in the context of a validation experiment &ndash; an investigational assay or
method (the &quot;test&quot;) is compared to a gold standard. The rules used by this
function are in line with &quot;ISO 20776-2:2021 Part 2: Evaluation of performance
of antimicrobial susceptibility test devices against reference broth
micro-dilution.&quot;
</p>
<p>There are two levels of detail that are provided. If only the MIC values are
provided, the function will look for essential agreement between the two sets
of MIC. If the organism and antibiotic arguments are provided, the function
will also calculate the categorical agreement using EUCAST breakpoints (or,
if breakpoint not available and accept_ecoff = TRUE, ECOFFs).
</p>
<p>The function returns a special dataframe of results, which is also an
mic_validation object. This object can be summarised using summary() for
summary metrics, plotted using plot() for an essential agreement confusion
matrix, and tabulated using table().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_mic(
  gold_standard,
  test,
  ab = NULL,
  mo = NULL,
  accept_ecoff = FALSE,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_mic_+3A_gold_standard">gold_standard</code></td>
<td>
<p>vector of MICs to compare against.</p>
</td></tr>
<tr><td><code id="compare_mic_+3A_test">test</code></td>
<td>
<p>vector of MICs that are under investigation</p>
</td></tr>
<tr><td><code id="compare_mic_+3A_ab">ab</code></td>
<td>
<p>character vector (same length as MIC) of antibiotic names (optional)</p>
</td></tr>
<tr><td><code id="compare_mic_+3A_mo">mo</code></td>
<td>
<p>character vector (same length as MIC) of microorganism names (optional)</p>
</td></tr>
<tr><td><code id="compare_mic_+3A_accept_ecoff">accept_ecoff</code></td>
<td>
<p>if TRUE, ECOFFs will be used when no clinical breakpoints are available</p>
</td></tr>
<tr><td><code id="compare_mic_+3A_simplify">simplify</code></td>
<td>
<p>if TRUE, MIC values will be coerced into the closest halving
dilution (e.g., 0.55 will be converted to 0.5)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 mic_validation object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Just using MIC values only
gold_standard &lt;- c("&lt;0.25", "8", "64", "&gt;64")
test &lt;- c("&lt;0.25", "2", "16", "64")
val &lt;- compare_mic(gold_standard, test)
summary(val)

# Using MIC values and antibiotic and organism names
gold_standard &lt;- c("&lt;0.25", "8", "64", "&gt;64")
test &lt;- c("&lt;0.25", "2", "16", "64")
ab &lt;- c("AMK", "AMK", "AMK", "AMK")
mo &lt;- c("B_ESCHR_COLI", "B_ESCHR_COLI", "B_ESCHR_COLI", "B_ESCHR_COLI")
val &lt;- compare_mic(gold_standard, test, ab, mo)
"error" %in% names(val)  # val now has categorical agreement
</code></pre>

<hr>
<h2 id='compare_sir'>Compare SIR results and generate categorical agreement</h2><span id='topic+compare_sir'></span>

<h3>Description</h3>

<p>Compare two AMR::sir vectors and generate a categorical agreement vector with
the following levels: M (major error), vM (very major error), m (minor error).
The error definitions are:
</p>

<ol>
<li><p> Major error (M): The test result is resistant (R) when the gold standard
is susceptible (S).
</p>
</li>
<li><p> vM (very major error): The test result is susceptible (S) when the gold
standard is resistant (R).
</p>
</li>
<li><p> Minor error (m): The test result is intermediate (I) when the gold standard
is susceptible (S) or resistant (R), or vice versa.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>compare_sir(gold_standard, test)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_sir_+3A_gold_standard">gold_standard</code></td>
<td>
<p>Susceptibility results in AMR::sir format</p>
</td></tr>
<tr><td><code id="compare_sir_+3A_test">test</code></td>
<td>
<p>Susceptibility results in AMR::sir format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>factor vector with the following levels: M, vM, m.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_standard &lt;- c("S", "R", "I", "I")
gold_standard &lt;- AMR::as.sir(gold_standard)
test &lt;- c("S", "I", "R", "R")
test &lt;- AMR::as.sir(test)
compare_sir(gold_standard, test)
</code></pre>

<hr>
<h2 id='download_patric_db'>Download PATRIC database</h2><span id='topic+download_patric_db'></span>

<h3>Description</h3>

<p>Download PATRIC database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_patric_db(save_path, ftp_path = patric_ftp_path, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="download_patric_db_+3A_save_path">save_path</code></td>
<td>
<p>Save path (should be .txt)</p>
</td></tr>
<tr><td><code id="download_patric_db_+3A_ftp_path">ftp_path</code></td>
<td>
<p>PATRIC database FTP path to download</p>
</td></tr>
<tr><td><code id="download_patric_db_+3A_overwrite">overwrite</code></td>
<td>
<p>Force overwrite</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if successful, FALSE if failure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
download_patric_db(tempfile())

</code></pre>

<hr>
<h2 id='ecoffs'>ECOFF data</h2><span id='topic+ecoffs'></span>

<h3>Description</h3>

<p>A dataset containing the epidemiological cut-off values (ECOFFs) for
different antibiotics and microorganisms. Currently, only the ECOFF values
for <em>Escherichia coli</em> are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecoffs
</code></pre>


<h3>Format</h3>



<h4><code>ecoffs</code></h4>

<p>A data frame with 85 rows and 25 columns:
</p>

<dl>
<dt>organism</dt><dd><p>Microorganism code in AMR::mo format</p>
</dd>
<dt>antibiotic</dt><dd><p>Antibiotic code in AMR::ab format</p>
</dd>
<dt><code>0.002</code>:<code>512</code></dt><dd><p>Counts of isolates in each concentration &quot;bin&quot;</p>
</dd>
<dt>Distributions</dt><dd><p>see EUCAST documentation below</p>
</dd>
<dt>Observations</dt><dd><p>Number of observations</p>
</dd>
<dt><code style="white-space: pre;">&#8288;(T)ECOFF&#8288;</code></dt><dd><p>see EUCAST documentation below</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Confidence interval&#8288;</code></dt><dd><p>see EUCAST documentation below</p>
</dd>
</dl>




<h3>Source</h3>

<p>EUCAST <a href="https://www.eucast.org/mic_and_zone_distributions_and_ecoffs">https://www.eucast.org/mic_and_zone_distributions_and_ecoffs</a>
</p>
<p>These data have (or this document, presentation or video has) been produced
in part under ECDC service contracts and made available by EUCAST at no cost
to the user and can be accessed on the EUCAST website www.eucast.org.
The views and opinions expressed are those of EUCAST at a given point in time.
EUCAST recommendations are frequently updated and the latest versions are available at www.eucast.org.
</p>

<hr>
<h2 id='essential_agreement'>Essential agreement for MIC validation</h2><span id='topic+essential_agreement'></span>

<h3>Description</h3>

<p>Essential agreement calculation for comparing two MIC vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>essential_agreement(x, y, coerce_mic = TRUE, mode = "categorical")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="essential_agreement_+3A_x">x</code></td>
<td>
<p>AMR::mic or coercible</p>
</td></tr>
<tr><td><code id="essential_agreement_+3A_y">y</code></td>
<td>
<p>AMR::mic or coercible</p>
</td></tr>
<tr><td><code id="essential_agreement_+3A_coerce_mic">coerce_mic</code></td>
<td>
<p>convert to AMR::mic</p>
</td></tr>
<tr><td><code id="essential_agreement_+3A_mode">mode</code></td>
<td>
<p>Categorical or numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essential agreement is a central concept in the comparison of two sets of MIC
values. It is most often used when validating a new method against a gold
standard. This function reliably performs essential agreement in line with
ISO 20776-2:2021. The function can be used in two modes: categorical and
numeric. In categorical mode, the function will use traditional MIC
concentrations to determine the MIC (therefore it will use force_mic() to
convert both x and y to a clean MIC &ndash; see ?force_mic()). In numeric mode,
the function will compare the ratio of the two MICs. In most cases,
categorical mode provides more reliable results. Values within +/- 2
dilutions are considered to be in essential agreement.
</p>


<h3>Value</h3>

<p>logical vector
</p>


<h3>References</h3>

<p>International Organization for Standardization. ISO 20776-2:2021
Available from: https://www.iso.org/standard/79377.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- AMR::as.mic(c("&lt;0.25", "8", "64", "&gt;64"))
y &lt;- AMR::as.mic(c("&lt;0.25", "2", "16", "64"))
essential_agreement(x, y)
# TRUE FALSE FALSE TRUE
</code></pre>

<hr>
<h2 id='example_mics'>Example MIC data</h2><span id='topic+example_mics'></span>

<h3>Description</h3>

<p>Example minimum inhibitory concentration validation data for three
antimicrobials on Escherichia coli strains. This data is synthetic and
generated to give an example of different MIC distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_mics
</code></pre>


<h3>Format</h3>



<h4><code>example_mics</code></h4>

<p>A data frame with 300 rows and 4 columns:
</p>

<dl>
<dt>gs</dt><dd><p>Gold standard MICs</p>
</dd>
<dt>test</dt><dd><p>Test MICs</p>
</dd>
<dt>mo</dt><dd><p>Microorganism code in AMR::mo format</p>
</dd>
<dt>ab</dt><dd><p>Antibiotic code in AMR::ab format</p>
</dd>
</dl>




<h3>Source</h3>

<p>Synthetic data
</p>

<hr>
<h2 id='fill_dilution_levels'>Fill MIC dilution levels</h2><span id='topic+fill_dilution_levels'></span>

<h3>Description</h3>

<p>Fill MIC dilution levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_dilution_levels(x, cap_upper = TRUE, cap_lower = TRUE, as.mic = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_dilution_levels_+3A_x">x</code></td>
<td>
<p>MIC vector</p>
</td></tr>
<tr><td><code id="fill_dilution_levels_+3A_cap_upper">cap_upper</code></td>
<td>
<p>If True, will the top level will be the highest MIC dilution in x</p>
</td></tr>
<tr><td><code id="fill_dilution_levels_+3A_cap_lower">cap_lower</code></td>
<td>
<p>If True, will the bottom level will be the lowest MIC dilution in x</p>
</td></tr>
<tr><td><code id="fill_dilution_levels_+3A_as.mic">as.mic</code></td>
<td>
<p>By default, returns an ordered factor. Set as.mic = TRUE to return as AMR::mic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ordered factor (or AMR::mic if as.mic = TRUE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use in combination with droplevels to clean up levels:
x &lt;- AMR::as.mic(c("&lt;0.25", "8", "64", "&gt;64"))
x &lt;- droplevels(x)
fill_dilution_levels(x)
</code></pre>

<hr>
<h2 id='force_mic'>Force MIC-like into MIC-compatible format</h2><span id='topic+force_mic'></span>

<h3>Description</h3>

<p>Convert a value that is &quot;almost&quot; an MIC into a valid MIC value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force_mic(
  value,
  levels_from_AMR = FALSE,
  max_conc = 512,
  min_conc = 0.002,
  method = "closest",
  prefer = "max"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="force_mic_+3A_value">value</code></td>
<td>
<p>vector of MIC-like values (numeric or character)</p>
</td></tr>
<tr><td><code id="force_mic_+3A_levels_from_amr">levels_from_AMR</code></td>
<td>
<p>conform to AMR::as.mic levels</p>
</td></tr>
<tr><td><code id="force_mic_+3A_max_conc">max_conc</code></td>
<td>
<p>maximum concentration to force to</p>
</td></tr>
<tr><td><code id="force_mic_+3A_min_conc">min_conc</code></td>
<td>
<p>minimum concentration to force to</p>
</td></tr>
<tr><td><code id="force_mic_+3A_method">method</code></td>
<td>
<p>method to use when forcing MICs (closest or round_up)</p>
</td></tr>
<tr><td><code id="force_mic_+3A_prefer">prefer</code></td>
<td>
<p>where value is in between MIC (e.g., 24mg/L) chose the higher
MIC (&quot;max&quot;) or lower MIC (&quot;min&quot;); only applies to method = &quot;closest&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some experimental or analytical conditions measure MIC (or surrogate) in a
way that does not fully conform to traditional MIC levels
(i.e., concentrations). This function allows these values to be coerced into
an MIC value that is compatible with the AMR::mic class. When using method =
&quot;closest&quot;, the function will choose the closest MIC value to the input value
(e.g., 2.45 will be coerced to 2). When using method = &quot;round up&quot;, the
function will round up to the next highest MIC value (e.g., 2.45 will be
coerced to 4). &quot;Round up&quot; is technically the correct approach if the input
value was generated from an experiment that censored between concentrations
(e.g., broth or agar dilution). However, &quot;closest&quot; may be more appropriate in
some cases.
</p>


<h3>Value</h3>

<p>AMR::as.mic compatible character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>force_mic(c("2.32", "&lt;4.12", "&gt;1.01"))
</code></pre>

<hr>
<h2 id='genome_to_libsvm'>Converts a genome to kmers stored in libsvm format on disk</h2><span id='topic+genome_to_libsvm'></span>

<h3>Description</h3>

<p>This function converts a single genome to a libsvm file containing kmer
counts. The libsvm format will be as follows:
</p>
<pre>
  label 1:count 2:count 3:count ...
</pre>
<p>Label is optional and defaults to 0. The kmer counts are indexed by the
kmer index, which is the lexicographically sorted index of the kmer.
Libsvm is a sparse format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genome_to_libsvm(
  x,
  target_path,
  label = as.character(c("0")),
  k = 3L,
  canonical = TRUE,
  squeeze = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genome_to_libsvm_+3A_x">x</code></td>
<td>
<p>genome in string format</p>
</td></tr>
<tr><td><code id="genome_to_libsvm_+3A_target_path">target_path</code></td>
<td>
<p>path to store libsvm file (.txt)</p>
</td></tr>
<tr><td><code id="genome_to_libsvm_+3A_label">label</code></td>
<td>
<p>libsvm label</p>
</td></tr>
<tr><td><code id="genome_to_libsvm_+3A_k">k</code></td>
<td>
<p>kmer length</p>
</td></tr>
<tr><td><code id="genome_to_libsvm_+3A_canonical">canonical</code></td>
<td>
<p>only record canonical kmers
(i.e., the lexicographically smaller of a kmer and its reverse complement)</p>
</td></tr>
<tr><td><code id="genome_to_libsvm_+3A_squeeze">squeeze</code></td>
<td>
<p>remove non-canonical kmers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean indicating success
</p>


<h3>See Also</h3>

<p>For multiple genomes in a directory, processed in parallel, see <code><a href="#topic+genomes_to_kmer_libsvm">genomes_to_kmer_libsvm()</a></code>
</p>
<p>For more details on libsvm format, see
<a href="https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html">https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>temp_libsvm_path &lt;- tempfile(fileext = ".txt")
genome_to_libsvm("ATCGCAGT", temp_libsvm_path)
readLines(temp_libsvm_path)
</code></pre>

<hr>
<h2 id='genomes_to_kmer_libsvm'>Convert genomes to kmers in libsvm format</h2><span id='topic+genomes_to_kmer_libsvm'></span>

<h3>Description</h3>

<p>Raw genome data (pre- or post-assembly) is usually transformed by k-mer
counting prior to machine learning (ML). XGBoost is a popular ML algorithm
for this problem, due to its scalability to high dimensional data. This
function converts genomes to k-mer counts stored in XGBoost's preferred
format, libsvm. Further information on the libsvm format is available at
<a href="https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html">https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html</a>.
Briefly, libsvm is effectively a text file that stores data points as
x:y pairs, where x is the feature index, and y is the feature value. Each
observation is stored on its own line, with the first column reserved for
labels. Labels can be provided later, during data import.
</p>
<p>This function converts each individual genome to an individual libsvm
text file of k-mer counts (therefore, each .txt file will be 1 line long).
This function supports parallel processing using the by setting an appropriate
<code>future::plan()</code> (usually <code>future::multisession</code>) &mdash;
each genome is processed in parallel. To monitor progress, use the
<code>progressr</code> package by wrapping the function in
<code><a href="progressr.html#topic+with_progress">with_progress</a></code>.
</p>
<p>Although XGBoost can load a multiple .txt (libsvm) files by providing the
directory as an input, this is generally not recommended as order of
import cannot be guaranteed and probably depends on filesystem. Instead,
it is recommended that this function is combined with
<code><a href="#topic+split_and_combine_files">split_and_combine_files()</a></code> which generates a single .txt file (with the
order of observations guaranteed and stored in a .csv file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genomes_to_kmer_libsvm(
  source_dir,
  target_dir,
  k = 3,
  canonical = TRUE,
  squeeze = FALSE,
  ext = ".fna"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genomes_to_kmer_libsvm_+3A_source_dir">source_dir</code></td>
<td>
<p>directory containing genomes</p>
</td></tr>
<tr><td><code id="genomes_to_kmer_libsvm_+3A_target_dir">target_dir</code></td>
<td>
<p>target directory to store kmers in libsvm format</p>
</td></tr>
<tr><td><code id="genomes_to_kmer_libsvm_+3A_k">k</code></td>
<td>
<p>k-mer length</p>
</td></tr>
<tr><td><code id="genomes_to_kmer_libsvm_+3A_canonical">canonical</code></td>
<td>
<p>only count canonical kmers</p>
</td></tr>
<tr><td><code id="genomes_to_kmer_libsvm_+3A_squeeze">squeeze</code></td>
<td>
<p>remove non-canonical kmers</p>
</td></tr>
<tr><td><code id="genomes_to_kmer_libsvm_+3A_ext">ext</code></td>
<td>
<p>file extension to filter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if successful
</p>


<h3>See Also</h3>

<p>to convert a single genome, use <code><a href="#topic+genome_to_libsvm">genome_to_libsvm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# create 10 random DNA files
tmp_dir &lt;- tempdir()
# remove any existing .fna files
file.remove(
 list.files(tmp_dir, pattern = "*.fna", full.names = TRUE)
)
for (i in 1:10) {
writeLines(paste0("&gt;", i, "\n", paste0(sample(c("A", "T", "C", "G"),
 100, replace = TRUE), collapse = "")), file.path(tmp_dir, paste0(i, ".fna")))
}

tmp_target_dir &lt;- file.path(tmp_dir, "kmers")
unlink(tmp_target_dir, recursive = TRUE)

# convert genomes to k-mers
future::plan(future::sequential)  # use multisession for parallel processing
progressr::with_progress(
  genomes_to_kmer_libsvm(tmp_dir, tmp_target_dir, k = 3)
)

# check the output
list.files(tmp_target_dir)
readLines(list.files(tmp_target_dir, full.names = TRUE)[1])

</code></pre>

<hr>
<h2 id='get_mic'>Get MIC meta-data from feature database</h2><span id='topic+get_mic'></span>

<h3>Description</h3>

<p>This function helps extract MICs from a database of results. It is compatible
with the PATRIC meta data format when used on a tidy_patric_db object,
created using tidy_patric_db().
</p>
<p>If more than one MIC is present for a particular observation, the function
can return the higher MIC by setting prefer_high_mic = TRUE. If
prefer_high_mic = FALSE, the lower MIC will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mic(
  x,
  ids,
  ab_col,
  id_col = NULL,
  as_mic = TRUE,
  prefer_high_mic = TRUE,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_mic_+3A_x">x</code></td>
<td>
<p>dataframe containing meta-data</p>
</td></tr>
<tr><td><code id="get_mic_+3A_ids">ids</code></td>
<td>
<p>vector of IDs to get meta-data for</p>
</td></tr>
<tr><td><code id="get_mic_+3A_ab_col">ab_col</code></td>
<td>
<p>column name containing MIC results</p>
</td></tr>
<tr><td><code id="get_mic_+3A_id_col">id_col</code></td>
<td>
<p>column name containing IDs</p>
</td></tr>
<tr><td><code id="get_mic_+3A_as_mic">as_mic</code></td>
<td>
<p>return as AMR::as.mic</p>
</td></tr>
<tr><td><code id="get_mic_+3A_prefer_high_mic">prefer_high_mic</code></td>
<td>
<p>where multiple MIC results per ID, prefer the higher MIC</p>
</td></tr>
<tr><td><code id="get_mic_+3A_simplify">simplify</code></td>
<td>
<p>return as vector of MICs (vs dataframe)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector containing MICs, or dataframe of IDs and MICs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(genome_id = c("a_12", "b_42", "x_21", "x_21", "r_75"),
                 gentamicin = c(0.25, 0.125, 32.0, 16.0, "&lt;0.0125"))
get_mic(df,
        ids = c("b_42", "x_21"),
        ab_col = "gentamicin",
        id_col = "genome_id",
        as_mic = FALSE,
        prefer_high_mic = TRUE,
        simplify = TRUE)
</code></pre>

<hr>
<h2 id='kmers'>Generates genome kmers</h2><span id='topic+kmers'></span>

<h3>Description</h3>

<p>Generates genome kmers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmers(
  x,
  k = 3L,
  simplify = FALSE,
  canonical = TRUE,
  squeeze = FALSE,
  anchor = TRUE,
  clean_up = TRUE,
  key_as_int = FALSE,
  starting_index = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmers_+3A_x">x</code></td>
<td>
<p>genome in string format</p>
</td></tr>
<tr><td><code id="kmers_+3A_k">k</code></td>
<td>
<p>kmer length</p>
</td></tr>
<tr><td><code id="kmers_+3A_simplify">simplify</code></td>
<td>
<p>returns a numeric vector of kmer counts,
without associated string. This is useful to save memory,
but should always be used with anchor = true.</p>
</td></tr>
<tr><td><code id="kmers_+3A_canonical">canonical</code></td>
<td>
<p>only record canonical kmers
(i.e., the lexicographically smaller of a kmer and its reverse complement)</p>
</td></tr>
<tr><td><code id="kmers_+3A_squeeze">squeeze</code></td>
<td>
<p>remove non-canonical kmers</p>
</td></tr>
<tr><td><code id="kmers_+3A_anchor">anchor</code></td>
<td>
<p>includes unobserved kmers (with counts of 0).
This is useful when generating a dense matrix where kmers of different
genomes align.</p>
</td></tr>
<tr><td><code id="kmers_+3A_clean_up">clean_up</code></td>
<td>
<p>only include valid bases (ACTG) in kmer counts
(excludes non-coding results such as N)</p>
</td></tr>
<tr><td><code id="kmers_+3A_key_as_int">key_as_int</code></td>
<td>
<p>return kmer index (as &quot;kmer_index&quot;)
rather than the full kmer string. Useful for index-coded data structures
such as libsvm.</p>
</td></tr>
<tr><td><code id="kmers_+3A_starting_index">starting_index</code></td>
<td>
<p>the starting index, only used if key_as_int = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of kmer values, either as a list of a single vector
(if simplify = TRUE), or as a named list containing &quot;kmer_string&quot; and
&quot;kmer_value&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmers("ATCGCAGT")
</code></pre>

<hr>
<h2 id='load_patric_db'>Load PATRIC database</h2><span id='topic+load_patric_db'></span>

<h3>Description</h3>

<p>Load PATRIC database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_patric_db(x = patric_ftp_path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_patric_db_+3A_x">x</code></td>
<td>
<p>Character path to local or ftp path (.txt or .rds), or
data.frame object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PATRIC database (S3 class 'patric_db')
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
patric_db &lt;- load_patric_db()  # will get from PATRIC ftp


# make data.frame with single row
p &lt;- data.frame(genome_id = 1,
                genome_name = "E. coli",
                antibiotic = "amoxicillin",
                measurement = 2.0,
                measurement_unit = "mg/L",
                laboratory_typing_method = "Agar dilution",
                resistant_phenotype = "R")
load_patric_db(p)
</code></pre>

<hr>
<h2 id='mic_censor'>Censor MIC values</h2><span id='topic+mic_censor'></span>

<h3>Description</h3>

<p>MIC datasets often arise from different laboratories or experimental
conditions. In practice, this means that there can be different levels of
censoring (&lt;= and &gt;) within the data. This function can be used to harmonise
the dataset to a single level of censoring. The function requires a set of
rules that specify the censoring levels (see example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mic_censor(mic, ab, mo, rules)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mic_censor_+3A_mic">mic</code></td>
<td>
<p>MIC (coercible to AMR::as.mic)</p>
</td></tr>
<tr><td><code id="mic_censor_+3A_ab">ab</code></td>
<td>
<p>antibiotic name (coercible to AMR::as.ab)</p>
</td></tr>
<tr><td><code id="mic_censor_+3A_mo">mo</code></td>
<td>
<p>microorganism name (coercible to AMR::as.mo)</p>
</td></tr>
<tr><td><code id="mic_censor_+3A_rules">rules</code></td>
<td>
<p>censor rules - named list of pathogen (in AMR::as.mo code) to
antibiotic (in AMR::as.ab code) to censoring rules. The censoring rules
should provide a min or max value to censor MICs to. See example for more.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>censored MIC values (S3 mic class)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_rules &lt;- list("B_ESCHR_COLI" = list(
  "AMK" = list(min = 2, max = 32),
  "CHL" = list(min = 4, max = 64),
  "GEN" = list(min = 1, max = 16),
  "CIP" = list(min = 0.015, max = 4),
  "MEM" = list(min = 0.016, max = 16),
  "AMX" = list(min = 2, max = 64),
  "AMC" = list(min = 2, max = 64),
  "FEP" = list(min = 0.5, max = 64),
  "CAZ" = list(min = 1, max = 128),
  "TGC" = list(min = 0.25, max = 1)
  ))

mic_censor(AMR::as.mic(512),
           "AMK",
           "B_ESCHR_COLI",
           example_rules) == AMR::as.mic("&gt;32")
</code></pre>

<hr>
<h2 id='mic_r_breakpoint'>R breakpoint for MIC</h2><span id='topic+mic_r_breakpoint'></span>

<h3>Description</h3>

<p>R breakpoint for MIC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mic_r_breakpoint(mo, ab, accept_ecoff = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mic_r_breakpoint_+3A_mo">mo</code></td>
<td>
<p>mo name (coerced using AMR::as.mo)</p>
</td></tr>
<tr><td><code id="mic_r_breakpoint_+3A_ab">ab</code></td>
<td>
<p>ab name (coerced using AMR::as.ab)</p>
</td></tr>
<tr><td><code id="mic_r_breakpoint_+3A_accept_ecoff">accept_ecoff</code></td>
<td>
<p>if TRUE, ECOFFs will be used when no clinical breakpoints are available</p>
</td></tr>
<tr><td><code id="mic_r_breakpoint_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to AMR::as.sir, which is used to
calculate the R breakpoint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MIC value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mic_r_breakpoint("B_ESCHR_COLI", "AMK")
mic_r_breakpoint("B_ESCHR_COLI", "CHL", accept_ecoff = TRUE)
</code></pre>

<hr>
<h2 id='mic_range'>Generate dilution series</h2><span id='topic+mic_range'></span>

<h3>Description</h3>

<p>Generate dilution series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mic_range(start = 512, dilutions = Inf, min = 0.002, precise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mic_range_+3A_start">start</code></td>
<td>
<p>starting (highest) concentration</p>
</td></tr>
<tr><td><code id="mic_range_+3A_dilutions">dilutions</code></td>
<td>
<p>number of dilutions</p>
</td></tr>
<tr><td><code id="mic_range_+3A_min">min</code></td>
<td>
<p>minimum (lowest) concentration</p>
</td></tr>
<tr><td><code id="mic_range_+3A_precise">precise</code></td>
<td>
<p>force range to be high precision (not usually desired
behaviour)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of numeric concentrations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mic_range(128)
mic_range(128, dilutions = 21) # same results
</code></pre>

<hr>
<h2 id='mic_s_breakpoint'>S breakpoint for MIC</h2><span id='topic+mic_s_breakpoint'></span>

<h3>Description</h3>

<p>S breakpoint for MIC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mic_s_breakpoint(mo, ab, accept_ecoff = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mic_s_breakpoint_+3A_mo">mo</code></td>
<td>
<p>mo name (coerced using AMR::as.mo)</p>
</td></tr>
<tr><td><code id="mic_s_breakpoint_+3A_ab">ab</code></td>
<td>
<p>ab name (coerced using AMR::as.ab)</p>
</td></tr>
<tr><td><code id="mic_s_breakpoint_+3A_accept_ecoff">accept_ecoff</code></td>
<td>
<p>if TRUE, ECOFFs will be used when no clinical breakpoints are available</p>
</td></tr>
<tr><td><code id="mic_s_breakpoint_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to AMR::as.sir, which is used to
calculate the S breakpoint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MIC value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mic_s_breakpoint("B_ESCHR_COLI", "AMK")
mic_s_breakpoint("B_ESCHR_COLI", "CHL", accept_ecoff = TRUE)
</code></pre>

<hr>
<h2 id='mic_uncensor'>Uncensor MICs</h2><span id='topic+mic_uncensor'></span>

<h3>Description</h3>

<p>Uncensor MICs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mic_uncensor(
  mic,
  method = "scale",
  scale = 2,
  ab = NULL,
  mo = NULL,
  distros = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mic_uncensor_+3A_mic">mic</code></td>
<td>
<p>vector of MICs to uncensor; will be coerced to MIC using AMR::as.mic</p>
</td></tr>
<tr><td><code id="mic_uncensor_+3A_method">method</code></td>
<td>
<p>method to uncensor MICs (scale, simple, or bootstrap)</p>
</td></tr>
<tr><td><code id="mic_uncensor_+3A_scale">scale</code></td>
<td>
<p>scalar to multiply or divide MIC by (for method = scale)</p>
</td></tr>
<tr><td><code id="mic_uncensor_+3A_ab">ab</code></td>
<td>
<p>antibiotic name (for method = bootstrap)</p>
</td></tr>
<tr><td><code id="mic_uncensor_+3A_mo">mo</code></td>
<td>
<p>microorganism name (for method = bootstrap)</p>
</td></tr>
<tr><td><code id="mic_uncensor_+3A_distros">distros</code></td>
<td>
<p>dataframe of epidemiological distributions (only used,
optionally, for method = bootstrap)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Censored MIC data is generally unsuitable for modelling without some
conversion of censored data. The default behaviour (method = scale) is to
halve MICs under the limit of detection (&lt;=) and double MICs above the limit
of detection (&gt;). When used with method = simple, this function effectively
just removes the censoring symbols, e.g., &lt;=2 becomes 2, and &gt;64 becomes 64.
</p>
<p>The bootstrap method is the more complex of the three available methods. It
attempts to use a second (uncensored) MIC distribution to sample values in
the censored range. These values are then used to populate and uncensor
the MIC data provided as input (mic). The second (uncensored) MIC
distribution is ideally provided from similar experimental conditions.
Alternatively, epidemiological distributions can be used. These distributions
should be provided as a dataframe to the distros argument. The format for
this dataframe is inspired by the EUCAST epidemiological distributions, see:
https://www.eucast.org/mic_and_zone_distributions_and_ecoffs. The dataframe
should contain columns for antimicrobial (converted using AMR::as.ab),
organism (converted using AMR::as.mo), and MIC concentrations. An example
is provided in the 'ecoffs' dataset available with this pacakge. Currently,
only Escherichia coli is available in this dataset. Each observation (row)
consists of the frequency a particular MIC concentration is observed in the
distribution. If such a dataframe is not provided to distros, the function
will attempt to use 'ecoffs', but remains limited to E. coli.
</p>


<h3>Value</h3>

<p>vector of MICs in AMR::mic format
</p>


<h3>References</h3>

<p>https://www.eucast.org/mic_and_zone_distributions_and_ecoffs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mic_uncensor(c("&gt;64.0", "&lt;0.25", "8.0"), method = "scale", scale = 2)
</code></pre>

<hr>
<h2 id='move_files'>Move or copy files using logical vector</h2><span id='topic+move_files'></span>

<h3>Description</h3>

<p>This is simply a wrapper around file.copy/file.rename that allows for
filtering by a logical vector (move_which). This can replicate the behaviour
of a predicate function (see example), and may be easier to read.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move_files(source_dir, target_dir, move_which, ext = ".txt", copy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="move_files_+3A_source_dir">source_dir</code></td>
<td>
<p>move from directory</p>
</td></tr>
<tr><td><code id="move_files_+3A_target_dir">target_dir</code></td>
<td>
<p>move to directory</p>
</td></tr>
<tr><td><code id="move_files_+3A_move_which">move_which</code></td>
<td>
<p>logical vector to filter (or use TRUE to move all)</p>
</td></tr>
<tr><td><code id="move_files_+3A_ext">ext</code></td>
<td>
<p>file extension to filter</p>
</td></tr>
<tr><td><code id="move_files_+3A_copy">copy</code></td>
<td>
<p>copy files (rather than move)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector, indicating success or failure for each file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# create 10 random DNA files
tmp_dir &lt;- tempdir()
# remove any existing .fna files
file.remove(
 list.files(tmp_dir, pattern = "*.fna", full.names = TRUE)
)
for (i in 1:10) {
writeLines(paste0("&gt;", i, "\n", paste0(sample(c("A", "T", "C", "G"),
 100, replace = TRUE), collapse = "")), file.path(tmp_dir, paste0(i, ".fna")))
}

# move files with even numbers to a new directory
new_dir &lt;- file.path(tempdir(), "even_files")
unlink(new_dir, recursive = TRUE)
move_files(tmp_dir,
           new_dir,
           move_which = as.integer(
              tools::file_path_sans_ext(
                  list.files(tmp_dir, pattern = "*.fna"))) %% 2 == 0,
           ext = "fna")
list.files(new_dir)
</code></pre>

<hr>
<h2 id='plot.mic_validation'>Plot MIC validation results</h2><span id='topic+plot.mic_validation'></span>

<h3>Description</h3>

<p>Plot MIC validation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mic_validation'
plot(
  x,
  match_axes = TRUE,
  add_missing_dilutions = TRUE,
  facet_wrap_ncol = NULL,
  facet_wrap_nrow = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mic_validation_+3A_x">x</code></td>
<td>
<p>object generated using compare_mic</p>
</td></tr>
<tr><td><code id="plot.mic_validation_+3A_match_axes">match_axes</code></td>
<td>
<p>Same x and y axis</p>
</td></tr>
<tr><td><code id="plot.mic_validation_+3A_add_missing_dilutions">add_missing_dilutions</code></td>
<td>
<p>Axes will include dilutions that are not</p>
</td></tr>
<tr><td><code id="plot.mic_validation_+3A_facet_wrap_ncol">facet_wrap_ncol</code></td>
<td>
<p>Facet wrap into n columns by antimicrobial (optional,
only available when more than one antimicrobial in validation)</p>
</td></tr>
<tr><td><code id="plot.mic_validation_+3A_facet_wrap_nrow">facet_wrap_nrow</code></td>
<td>
<p>Facet wrap into n rows by antimicrobial (optional,
only available when more than one antimicrobial in validation)
represented in the data, based on a series of dilutions generated using mic_range().</p>
</td></tr>
<tr><td><code id="plot.mic_validation_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_standard &lt;- c("&lt;0.25", "8", "64", "&gt;64")
test &lt;- c("&lt;0.25", "2", "16", "64")
val &lt;- compare_mic(gold_standard, test)
plot(val)

# works with validation that includes categorical agreement
# categorical agreement is ignored
ab &lt;- c("AMK", "AMK", "AMK", "AMK")
mo &lt;- c("B_ESCHR_COLI", "B_ESCHR_COLI", "B_ESCHR_COLI", "B_ESCHR_COLI")
val &lt;- compare_mic(gold_standard, test, ab, mo)
plot(val)

# if the validation contains multiple antibiotics, i.e.,
ab &lt;- c("CIP", "CIP", "AMK", "AMK")
val &lt;- compare_mic(gold_standard, test, ab, mo)
# the following will plot all antibiotics in a single plot (pooled results)
plot(val)
# use the faceting arguments to split the plot by antibiotic
plot(val, facet_wrap_ncol = 2)
</code></pre>

<hr>
<h2 id='print.mic_validation'>Print MIC validation object</h2><span id='topic+print.mic_validation'></span>

<h3>Description</h3>

<p>Print MIC validation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mic_validation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mic_validation_+3A_x">x</code></td>
<td>
<p>mic_validation object</p>
</td></tr>
<tr><td><code id="print.mic_validation_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_standard &lt;- c("&lt;0.25", "8", "64", "&gt;64")
test &lt;- c("&lt;0.25", "2", "16", "64")
val &lt;- compare_mic(gold_standard, test)
print(val)
</code></pre>

<hr>
<h2 id='print.mic_validation_summary'>Print MIC validation summary</h2><span id='topic+print.mic_validation_summary'></span>

<h3>Description</h3>

<p>Print MIC validation summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mic_validation_summary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mic_validation_summary_+3A_x">x</code></td>
<td>
<p>mic_validation_summary object</p>
</td></tr>
<tr><td><code id="print.mic_validation_summary_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_standard &lt;- c("&lt;0.25", "8", "64", "&gt;64")
test &lt;- c("&lt;0.25", "2", "16", "64")
val &lt;- compare_mic(gold_standard, test)
print(summary(val))
</code></pre>

<hr>
<h2 id='pull_PATRIC_genomes'>Automated download of genomes from PATRIC database</h2><span id='topic+pull_PATRIC_genomes'></span>

<h3>Description</h3>

<p>Automated download of genomes from PATRIC database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_PATRIC_genomes(
  output_directory,
  taxonomic_name = NULL,
  database = patric_ftp_path,
  filter = "MIC",
  n_genomes = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull_PATRIC_genomes_+3A_output_directory">output_directory</code></td>
<td>
<p>local directory to save to</p>
</td></tr>
<tr><td><code id="pull_PATRIC_genomes_+3A_taxonomic_name">taxonomic_name</code></td>
<td>
<p>character of taxonomic bacterial name to download</p>
</td></tr>
<tr><td><code id="pull_PATRIC_genomes_+3A_database">database</code></td>
<td>
<p>local or ftp path to PATRIC database, or loaded database using load_patric_db()</p>
</td></tr>
<tr><td><code id="pull_PATRIC_genomes_+3A_filter">filter</code></td>
<td>
<p>&quot;MIC&quot; or &quot;disk&quot; or &quot;all&quot; phenotypes</p>
</td></tr>
<tr><td><code id="pull_PATRIC_genomes_+3A_n_genomes">n_genomes</code></td>
<td>
<p>number of genomes (0 = all)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of failed downloads (i.e., 0 if all attempted downloads
were successful).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pull_PATRIC_genomes(tempdir(),
                    taxonomic_name = "Escherichia coli",
                    filter = "MIC",
                    n_genomes = 10)

</code></pre>

<hr>
<h2 id='qc_in_range'>Check that MIC is within QC range</h2><span id='topic+qc_in_range'></span>

<h3>Description</h3>

<p>Check whether MIC values are within acceptable range for
quality control (QC). Every MIC experiment should include a control strain
with a known MIC. The results of the experiment are only valid if the control
strain MIC falls within the acceptable range. This function checks whether
an MIC result is within the acceptable range given: 1) a control strain
(usually identified as an ATCC or NCTC number), 2) an antibiotic name, and 3)
a guideline (EUCAST or CLSI). The acceptable range is defined by 'QC_table',
which is a dataset which is loaded with this package.
</p>
<p>The source of the QC values is the WHONET QC Ranges and Targets available from
the 'Antimicrobial Resistance Test Interpretation Engine' (AMRIE) repository:
https://github.com/AClark-WHONET/AMRIE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_in_range(
  measurement,
  strain,
  ab,
  ignore_na = TRUE,
  guideline = "EUCAST",
  year = "2023"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_in_range_+3A_measurement">measurement</code></td>
<td>
<p>measured QC MIC</p>
</td></tr>
<tr><td><code id="qc_in_range_+3A_strain">strain</code></td>
<td>
<p>control strain identifier (usually ATCC)</p>
</td></tr>
<tr><td><code id="qc_in_range_+3A_ab">ab</code></td>
<td>
<p>antibiotic name (will be coerced to AMR::as.ab)</p>
</td></tr>
<tr><td><code id="qc_in_range_+3A_ignore_na">ignore_na</code></td>
<td>
<p>ignores NA (returns TRUE)</p>
</td></tr>
<tr><td><code id="qc_in_range_+3A_guideline">guideline</code></td>
<td>
<p>Guideline to use (EUCAST or CLSI)</p>
</td></tr>
<tr><td><code id="qc_in_range_+3A_year">year</code></td>
<td>
<p>Guideline year (version)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector
</p>


<h3>References</h3>

<p>O’Brien TF, Stelling JM. WHONET: An Information System for Monitoring
Antimicrobial Resistance. Emerg Infect Dis. 1995 Jun;1(2):66–66.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qc_in_range(AMR::as.mic(0.5), 25922, "GEN") == TRUE
qc_in_range(AMR::as.mic(8.0), 25922, "GEN") == FALSE
</code></pre>

<hr>
<h2 id='qc_on_target'>Check that QC measurement is at the required target
<a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a></h2><span id='topic+qc_on_target'></span>

<h3>Description</h3>

<p>MIC experiments should include a control strain with a known MIC.
The MIC result for the control strain should be a particular target MIC. This
function checks whether the target MIC was achieved given: 1) a control
strain (usually identified as an ATCC or NCTC number), 2) an antibiotic name,
and 3) a guideline (EUCAST or CLSI).
</p>
<p>Since QC target values are currently not publicly available in an easy to
use format, this function takes a pragmatic approach &ndash; for most antibiotics
and QC strains, the target is assumed to be the midpoint of the acceptable
range. This approximation is not necessarily equal to the QC target reported
by guideline setting bodies such as EUCAST. Therefore, this function is
considered experimental and should be used with caution.
</p>
<p>This function can be used alongnside qc_in_range(), which checks whether the
MIC is within the acceptable range.
</p>
<p>The source of the QC values is the WHONET QC Ranges and Targets available from
the 'Antimicrobial Resistance Test Interpretation Engine' (AMRIE) repository:
https://github.com/AClark-WHONET/AMRIE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_on_target(
  measurement,
  strain,
  ab,
  ignore_na = TRUE,
  guideline = "EUCAST",
  year = "2023"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc_on_target_+3A_measurement">measurement</code></td>
<td>
<p>measured QC MIC</p>
</td></tr>
<tr><td><code id="qc_on_target_+3A_strain">strain</code></td>
<td>
<p>control strain identifier (usually ATCC)</p>
</td></tr>
<tr><td><code id="qc_on_target_+3A_ab">ab</code></td>
<td>
<p>antibiotic name (will be coerced to AMR::as.ab)</p>
</td></tr>
<tr><td><code id="qc_on_target_+3A_ignore_na">ignore_na</code></td>
<td>
<p>ignores NA (returns TRUE)</p>
</td></tr>
<tr><td><code id="qc_on_target_+3A_guideline">guideline</code></td>
<td>
<p>Guideline to use (EUCAST or CLSI)</p>
</td></tr>
<tr><td><code id="qc_on_target_+3A_year">year</code></td>
<td>
<p>Guideline year (version)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector
</p>


<h3>References</h3>

<p>O’Brien TF, Stelling JM. WHONET: An Information System for Monitoring
Antimicrobial Resistance. Emerg Infect Dis. 1995 Jun;1(2):66–66.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qc_on_target(AMR::as.mic(0.5), 25922, "GEN") == TRUE
</code></pre>

<hr>
<h2 id='replace_multiple_slashes'>Removes multiple slashes in a path or url</h2><span id='topic+replace_multiple_slashes'></span>

<h3>Description</h3>

<p>Removes multiple slashes in a path or url
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_multiple_slashes(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_multiple_slashes_+3A_path">path</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of paths without duplicate slashes
</p>

<hr>
<h2 id='reverse_complement'>Reverse complement of DNA string</h2><span id='topic+reverse_complement'></span>

<h3>Description</h3>

<p>Reverse complement of DNA string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_complement(dna)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverse_complement_+3A_dna">dna</code></td>
<td>
<p>DNA string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>reverse complement of DNA string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reverse_complement("ATCG")
</code></pre>

<hr>
<h2 id='split_and_combine_files'>Create test train files from a number of files</h2><span id='topic+split_and_combine_files'></span>

<h3>Description</h3>

<p>This function combines files into a train and test set, stored on disk.
It can be used in combination with genomes_to_kmer_libsvm() to create a
dataset that can be loaded into XGBoost (either by first creating an
xgboost::DMatrix, or by using the data argument in xgboost::xgb.train()
or xgboost::xgb.cv()). The following three files will be created:
</p>

<ol>
<li><p> train.txt - the training data
</p>
</li>
<li><p> test.txt - the testing data (if split &lt; 1)
</p>
</li>
<li><p> names.csv - a csv file containing the original filenames and their
corresponding type (train or test)
</p>
</li></ol>

<p>The function will check if the data is already in the appropriate format
and will not overwrite unless forced using the overwrite argument.
</p>
<p>By providing 1.0 to the split argument, the function can be used to combine
files without a train-test split. In this case, all the files will be
classed as 'train', and there will be no 'test' data. This is useful if
one wants to perform cross-validation using xgboost::xgb.cv() or
MIC::xgb.cv.lowmem(). It is also possible to combine all data into train
and then perform splitting after loading into an xgboost::DMatrix, using
xgboost::slice().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_and_combine_files(
  path_to_files,
  file_ext = ".txt",
  split = 0.8,
  train_target_path = NULL,
  test_target_path = NULL,
  names_backup = NULL,
  shuffle = TRUE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_and_combine_files_+3A_path_to_files">path_to_files</code></td>
<td>
<p>path containing files or vector of filepaths</p>
</td></tr>
<tr><td><code id="split_and_combine_files_+3A_file_ext">file_ext</code></td>
<td>
<p>file extension to filter</p>
</td></tr>
<tr><td><code id="split_and_combine_files_+3A_split">split</code></td>
<td>
<p>train-test split</p>
</td></tr>
<tr><td><code id="split_and_combine_files_+3A_train_target_path">train_target_path</code></td>
<td>
<p>name of train file to save as (by default, will be
train.txt in the path_to_files directory)</p>
</td></tr>
<tr><td><code id="split_and_combine_files_+3A_test_target_path">test_target_path</code></td>
<td>
<p>name of test file to save as (by default, will be
test.txt in the path_to_files directory)</p>
</td></tr>
<tr><td><code id="split_and_combine_files_+3A_names_backup">names_backup</code></td>
<td>
<p>name of file to save backup of filename metadata (by
default, will be names.csv in the path_to_files directory)</p>
</td></tr>
<tr><td><code id="split_and_combine_files_+3A_shuffle">shuffle</code></td>
<td>
<p>randomise prior to splitting</p>
</td></tr>
<tr><td><code id="split_and_combine_files_+3A_overwrite">overwrite</code></td>
<td>
<p>overwrite target files</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of paths to created train/test files, original filenames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# create 10 random libsvm files
tmp_dir &lt;- tempdir()
# remove any existing .txt files
file.remove(
list.files(tmp_dir, pattern = "*.txt", full.names = TRUE)
)
for (i in 1:10) {
 # each line is K: V
 writeLines(paste0(i, ": ", paste0(sample(1:100, 10, replace = TRUE),
 collapse = " ")), file.path(tmp_dir, paste0(i, ".txt")))
 }

 # split files into train and test directories
 paths &lt;- split_and_combine_files(
  tmp_dir,
  file_ext = "txt",
  split = 0.8,
  train_target_path = file.path(tmp_dir, "train.txt"),
  test_target_path = file.path(tmp_dir, "test.txt"),
  names_backup = file.path(tmp_dir, "names.csv"),
  overwrite = TRUE)

 readLines(paths[["train"]])
</code></pre>

<hr>
<h2 id='squeezed_index_to_str'>Get str conversion of squeezed kmer using index</h2><span id='topic+squeezed_index_to_str'></span>

<h3>Description</h3>

<p>Get str conversion of squeezed kmer using index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>squeezed_index_to_str(x, k, starting_index = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="squeezed_index_to_str_+3A_x">x</code></td>
<td>
<p>integer vector of kmer indices</p>
</td></tr>
<tr><td><code id="squeezed_index_to_str_+3A_k">k</code></td>
<td>
<p>kmer length</p>
</td></tr>
<tr><td><code id="squeezed_index_to_str_+3A_starting_index">starting_index</code></td>
<td>
<p>starting index (libsvm is usually indexed starting at 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of squeezed kmer strings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>squeezed_index_to_str(2, k = 3)
</code></pre>

<hr>
<h2 id='squeezed_mers'>Generates all permutations of squeezed kmers</h2><span id='topic+squeezed_mers'></span>

<h3>Description</h3>

<p>Generates all permutations of squeezed kmers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>squeezed_mers(k = 3L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="squeezed_mers_+3A_k">k</code></td>
<td>
<p>kmer length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of squeezed kmers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>squeezed_mers(3)
</code></pre>

<hr>
<h2 id='standardise_mic'>Standardise MIC to control strain
<a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a></h2><span id='topic+standardise_mic'></span>

<h3>Description</h3>

<p>MIC experiments are generally quality-controlled by including a control strain
with a known MIC. The MIC result for the control strain should be a particular
target MIC, or at least within an acceptable range. This function standardises
a measured MIC to the target MIC given: 1) a control strain (usually identified
as an ATCC or NCTC number), 2) an antibiotic name, and 3) a guideline (EUCAST
or CLSI). The definition of standardisation in this context is to adjust the
measured MIC based on the QC MIC. This is based on the following principles
and assumption:
</p>

<ol>
<li><p> A measured MIC is composed of two components: the true MIC and a
measurement error. The measurement error is considered to be inevitable when
measuring MICs, and is likely to be further composed of variability in
laboratory conditions and operator interpretation.
</p>
</li>
<li><p> It is assumed that the MIC of the control strain in the experiment has
also been affected by this error.
</p>
</li></ol>

<p>The standardisation applied by this function uses the measured QC strain
MIC as a reference point, and scales the rest of the MICs to this reference.
In general, this means that the MICs are doubled or halved, depending on the
result of the QC MIC. A worked example is provided below and illustrates
the transformation that this function applies.
</p>
<p>There is no current evidence base for this approach, therefore, this
function is considered experimental and should be used with caution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardise_mic(
  test_measurement,
  qc_measurement,
  strain,
  ab,
  prefer_upper = FALSE,
  ignore_na = TRUE,
  guideline = "EUCAST",
  year = "2023",
  force = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardise_mic_+3A_test_measurement">test_measurement</code></td>
<td>
<p>Measured MIC to standardise</p>
</td></tr>
<tr><td><code id="standardise_mic_+3A_qc_measurement">qc_measurement</code></td>
<td>
<p>Measured QC MIC to standardise to</p>
</td></tr>
<tr><td><code id="standardise_mic_+3A_strain">strain</code></td>
<td>
<p>control strain identifier (usually ATCC)</p>
</td></tr>
<tr><td><code id="standardise_mic_+3A_ab">ab</code></td>
<td>
<p>antibiotic name (will be coerced to AMR::as.ab)</p>
</td></tr>
<tr><td><code id="standardise_mic_+3A_prefer_upper">prefer_upper</code></td>
<td>
<p>Where the target MIC is a range, prefer the upper value
in the range</p>
</td></tr>
<tr><td><code id="standardise_mic_+3A_ignore_na">ignore_na</code></td>
<td>
<p>Ignore NA (returns AMR::NA_mic_)</p>
</td></tr>
<tr><td><code id="standardise_mic_+3A_guideline">guideline</code></td>
<td>
<p>Guideline to use (EUCAST or CLSI)</p>
</td></tr>
<tr><td><code id="standardise_mic_+3A_year">year</code></td>
<td>
<p>Guideline year (version)</p>
</td></tr>
<tr><td><code id="standardise_mic_+3A_force">force</code></td>
<td>
<p>Force into MIC-compatible format after standardisation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AMR::mic vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ref strain QC MIC for GEN is 0.5
standardise_mic(
  test_measurement = c(AMR::as.mic("&gt;8.0"),  # QC = 1, censored MIC remains censored
                       AMR::as.mic(4.0),  # QC = 0.5 which is on target, so stays same
                       AMR::as.mic(2),  # QC = 1, so scaled down to 1
                       AMR::as.mic(2)),  # QC = 0.25, so scaled up to 8
  qc_measurement = c(AMR::as.mic(1),
                     AMR::as.mic(0.5),
                     AMR::as.mic(1),
                     AMR::as.mic(0.25)),
  strain = 25922,
  ab = AMR::as.ab("GEN"))
</code></pre>

<hr>
<h2 id='summary.mic_validation'>Summary of MIC validation results</h2><span id='topic+summary.mic_validation'></span>

<h3>Description</h3>

<p>Summarise the results of an MIC validation generated using compare_mic().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mic_validation'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mic_validation_+3A_object">object</code></td>
<td>
<p>S3 mic_validation object</p>
</td></tr>
<tr><td><code id="summary.mic_validation_+3A_...">...</code></td>
<td>
<p>further optional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 mic_validation_summary object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_standard &lt;- c("&lt;0.25", "8", "64", "&gt;64")
test &lt;- c("&lt;0.25", "2", "16", "64")
val &lt;- compare_mic(gold_standard, test)
summary(val)
# or, for more detailed results
as.data.frame(summary(val))
</code></pre>

<hr>
<h2 id='table'>Table</h2><span id='topic+table'></span><span id='topic+table.default'></span><span id='topic+table.mic_validation'></span>

<h3>Description</h3>

<p>Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table(x, ...)

## Default S3 method:
table(x, ...)

## S3 method for class 'mic_validation'
table(
  x,
  format = "flextable",
  fill_dilutions = TRUE,
  bold = TRUE,
  ea_color = NULL,
  gold_standard_name = "Gold Standard",
  test_name = "Test",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table_+3A_x">x</code></td>
<td>
<p>mic_validation S3 object</p>
</td></tr>
<tr><td><code id="table_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="table_+3A_format">format</code></td>
<td>
<p>simple or flextable</p>
</td></tr>
<tr><td><code id="table_+3A_fill_dilutions">fill_dilutions</code></td>
<td>
<p>Fill dilutions that are not present in the data in
order to match the y- and x- axes</p>
</td></tr>
<tr><td><code id="table_+3A_bold">bold</code></td>
<td>
<p>Bold cells where essential agreement is TRUE</p>
</td></tr>
<tr><td><code id="table_+3A_ea_color">ea_color</code></td>
<td>
<p>Background color for essential agreement cells</p>
</td></tr>
<tr><td><code id="table_+3A_gold_standard_name">gold_standard_name</code></td>
<td>
<p>Name of the gold standard to display in output</p>
</td></tr>
<tr><td><code id="table_+3A_test_name">test_name</code></td>
<td>
<p>Name of the test to display in output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>table or flextable object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gold_standard &lt;- c("&lt;0.25", "8", "64", "&gt;64")
test &lt;- c("&lt;0.25", "2", "16", "64")
val &lt;- compare_mic(gold_standard, test)
table(val)
</code></pre>

<hr>
<h2 id='tidy_patric_meta_data'>Tidy PATRIC data</h2><span id='topic+tidy_patric_meta_data'></span>

<h3>Description</h3>

<p>Tidy PATRIC data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_patric_meta_data(
  x,
  prefer_more_resistant = TRUE,
  as_ab = TRUE,
  filter_abx = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy_patric_meta_data_+3A_x">x</code></td>
<td>
<p>PATRIC database loaded using MIC::load_patric_db</p>
</td></tr>
<tr><td><code id="tidy_patric_meta_data_+3A_prefer_more_resistant">prefer_more_resistant</code></td>
<td>
<p>High MICs, narrow zones, or resistant phenotypes
will be preferred where multiple reported for the same isolate</p>
</td></tr>
<tr><td><code id="tidy_patric_meta_data_+3A_as_ab">as_ab</code></td>
<td>
<p>convert antibiotics to AMR::ab class (column names are antibiotic
codes)</p>
</td></tr>
<tr><td><code id="tidy_patric_meta_data_+3A_filter_abx">filter_abx</code></td>
<td>
<p>filter antibiotics of interest, provided as a vector of
antibiotics character names/codes, or ideally, as AMR::ab classes, created
using AMR::as.ab</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tidy data, with antimicrobials in wide format, column names describing
methodology (&quot;mic_&quot;, &quot;disk_&quot;, &quot;pheno_&quot;). S3 class &quot;tidy_patric_db&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- data.frame(genome_id = 1,
                genome_name = "E. coli",
                antibiotic = "amoxicillin",
                measurement = 2.0,
                measurement_unit = "mg/L",
                laboratory_typing_method = "Agar dilution",
                resistant_phenotype = "R")
db &lt;- load_patric_db(db)
tidy_patric_meta_data(db)
</code></pre>

<hr>
<h2 id='train_test_filesystem'>Organise files into a train-test filesystem</h2><span id='topic+train_test_filesystem'></span>

<h3>Description</h3>

<p>Organise files into a train-test filesystem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_test_filesystem(
  path_to_files,
  file_ext,
  split = 0.8,
  train_folder = "train",
  test_folder = "test",
  shuffle = TRUE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="train_test_filesystem_+3A_path_to_files">path_to_files</code></td>
<td>
<p>directory containing files</p>
</td></tr>
<tr><td><code id="train_test_filesystem_+3A_file_ext">file_ext</code></td>
<td>
<p>file extension to filter</p>
</td></tr>
<tr><td><code id="train_test_filesystem_+3A_split">split</code></td>
<td>
<p>training data split</p>
</td></tr>
<tr><td><code id="train_test_filesystem_+3A_train_folder">train_folder</code></td>
<td>
<p>name of training folder (subdirectory), will be created
if does not exist</p>
</td></tr>
<tr><td><code id="train_test_filesystem_+3A_test_folder">test_folder</code></td>
<td>
<p>name of testing folder (subdirectory), will be created
if does not exist</p>
</td></tr>
<tr><td><code id="train_test_filesystem_+3A_shuffle">shuffle</code></td>
<td>
<p>randomise files when splitting (if FALSE, files will be
sorted by filename prior to splitting)</p>
</td></tr>
<tr><td><code id="train_test_filesystem_+3A_overwrite">overwrite</code></td>
<td>
<p>force overwrite of files that already exist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named vector of train and test directories
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# create 10 random DNA files
tmp_dir &lt;- tempdir()
# remove any existing .fna files
file.remove(
  list.files(tmp_dir, pattern = "*.fna", full.names = TRUE)
)

for (i in 1:10) {
 writeLines(paste0("&gt;", i, "\n", paste0(sample(c("A", "T", "C", "G"),
 100, replace = TRUE), collapse = "")), file.path(tmp_dir, paste0(i, ".fna")))
}

# split files into train and test directories
paths &lt;- train_test_filesystem(tmp_dir,
                               file_ext = "fna",
                               split = 0.8,
                               shuffle = TRUE,
                               overwrite = TRUE)

list.files(paths[["train"]])
list.files(paths[["test"]])
</code></pre>

<hr>
<h2 id='unsqueezed_index_to_str'>Get str conversion of unsqueezed kmer using index</h2><span id='topic+unsqueezed_index_to_str'></span>

<h3>Description</h3>

<p>Get str conversion of unsqueezed kmer using index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unsqueezed_index_to_str(x, k, starting_index = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unsqueezed_index_to_str_+3A_x">x</code></td>
<td>
<p>integer vector of kmer indices</p>
</td></tr>
<tr><td><code id="unsqueezed_index_to_str_+3A_k">k</code></td>
<td>
<p>kmer length</p>
</td></tr>
<tr><td><code id="unsqueezed_index_to_str_+3A_starting_index">starting_index</code></td>
<td>
<p>starting index (libsvm is usually indexed starting at 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of unsqueezed kmer strings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unsqueezed_index_to_str(2, k = 3)
</code></pre>

<hr>
<h2 id='unsqueezed_mers'>Generates all permutations of unsqueezed kmers</h2><span id='topic+unsqueezed_mers'></span>

<h3>Description</h3>

<p>Generates all permutations of unsqueezed kmers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unsqueezed_mers(k = 3L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unsqueezed_mers_+3A_k">k</code></td>
<td>
<p>kmer length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of unsqueezed kmers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unsqueezed_mers(3)
</code></pre>

<hr>
<h2 id='xgb.cv.lowmem'>Low memory cross-validation wrapper for XGBoost</h2><span id='topic+xgb.cv.lowmem'></span>

<h3>Description</h3>

<p>This function performs similar operations to xgboost::xgb.cv, but with the
operations performed in a memory efficient manner. Unlike xgboost::xgb.cv,
this version does not load all folds into memory from the start. Rather it
loads each fold into memory sequentially, and trains trains each fold using
xgboost::xgb.train. This allows larger datasets to be cross-validated.
</p>
<p>The main disadvantage of this function is that it is not possible to perform
early stopping based the results of all folds. The function does accept an
early stopping argument, but this is applied to each fold separately. This
means that different folds can (and should be expected to) train for a
different number of rounds.
</p>
<p>This function also allows for a train-test split (as opposed to multiple)
folds. This is done by providing a value of less than 1 to nfold, or a list
of 1 fold to folds. This is not possible with xgboost::xgb.cv, but can be
desirable if there is downstream processing that depends on an
xgb.cv.synchromous object (which is the return object of both this function
and xgboost::xgb.cv).
</p>
<p>Otherwise, where possible this function tries to return the same data
structure as xgboost::xgb.cv, with the exception of callbacks (not supported
as a field within the return object). To save models, use the save_models
argument, rather than the cb.cv.predict(save_models = TRUE) callback.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xgb.cv.lowmem(
  params = list(),
  data,
  nrounds,
  nfold,
  label = NULL,
  missing = NA,
  prediction = FALSE,
  metrics = list(),
  obj = NULL,
  feval = NULL,
  stratified = TRUE,
  folds = NULL,
  train_folds = NULL,
  verbose = 1,
  print_every_n = 1L,
  early_stopping_rounds = NULL,
  maximize = NULL,
  save_models = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xgb.cv.lowmem_+3A_params">params</code></td>
<td>
<p>parameters for xgboost</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_data">data</code></td>
<td>
<p>DMatrix or matrix</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_nrounds">nrounds</code></td>
<td>
<p>number of training rounds</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_nfold">nfold</code></td>
<td>
<p>number of folds, or if &lt; 1 then the proportion will be used
as the training split in a train-test split</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_label">label</code></td>
<td>
<p>data labels (alternatively provide with DMatrix)</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_missing">missing</code></td>
<td>
<p>handling of missing data (see xgb.cv)</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_prediction">prediction</code></td>
<td>
<p>return predictions</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_metrics">metrics</code></td>
<td>
<p>evaluation metrics</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_obj">obj</code></td>
<td>
<p>custom objective function</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_feval">feval</code></td>
<td>
<p>custom evaluation function</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_stratified">stratified</code></td>
<td>
<p>whether to use stratified folds</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_folds">folds</code></td>
<td>
<p>custom folds</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_train_folds">train_folds</code></td>
<td>
<p>custom train folds</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_verbose">verbose</code></td>
<td>
<p>verbosity level</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_print_every_n">print_every_n</code></td>
<td>
<p>print every n iterations</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_early_stopping_rounds">early_stopping_rounds</code></td>
<td>
<p>early stopping rounds (applied to each fold)</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_maximize">maximize</code></td>
<td>
<p>whether to maximize the evaluation metric</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_save_models">save_models</code></td>
<td>
<p>whether to save the models</p>
</td></tr>
<tr><td><code id="xgb.cv.lowmem_+3A_...">...</code></td>
<td>
<p>additional arguments passed to xgb.train</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xgb.cv.synchronous object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>train &lt;- list(data = matrix(rnorm(20), ncol = 2),
             label = rbinom(10, 1, 0.5))
dtrain &lt;- xgboost::xgb.DMatrix(train$data, label = train$label, nthread = 1)
cv &lt;- xgb.cv.lowmem(data = dtrain,
                   params = list(objective = "binary:logistic"),
                   nrounds = 2,
                   nfold = 3,
                   prediction = TRUE,
                   nthread = 1)
cv
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
