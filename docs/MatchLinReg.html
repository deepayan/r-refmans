<!DOCTYPE html><html lang="en"><head><title>Help for package MatchLinReg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MatchLinReg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lalonde'>
<p>Lalonde's National Supported Work Demonstration data</p></a></li>
<li><a href='#lindner'>
<p>Lindner Center data on 996 PCI patients analyzed by Kereiakes et al. (2000)</p></a></li>
<li><a href='#mlr'>
<p>Creating a series of matched data sets with different calibration parameters</p></a></li>
<li><a href='#mlr.bias'>
<p>Treatment effect bias</p></a></li>
<li><a href='#mlr.bias.constructor'>
<p>Generating the treatment effect bias constructor vector</p></a></li>
<li><a href='#mlr.combine.bias.variance'>
<p>Combining bias and variance to produce total MSE for treatment effect</p></a></li>
<li><a href='#mlr.generate.Z.o'>
<p>Generating omitted covariates from included covariates</p></a></li>
<li><a href='#mlr.match'>
<p>Thin wrapper around <code>Match</code> function from <code>Matching</code> package</p></a></li>
<li><a href='#mlr.orthogonalize'>
<p>Orthogonalization of vectors with repsect to a matrix</p></a></li>
<li><a href='#mlr.power'>
<p>Power analysis for causal inference using linear regression</p></a></li>
<li><a href='#mlr.smd'>
<p>Standardized mean difference</p></a></li>
<li><a href='#mlr.variance'>
<p>Treatment effect variance</p></a></li>
<li><a href='#plot.summary.mlr'>
<p>Plotting diagnostic and calibration objects resulting from call to <code>summary.mlr</code></p></a></li>
<li><a href='#summary.mlr'>
<p>Applying diagnostic and calibration functions to mlr objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Combining Matching and Linear Regression for Causal Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Alireza S. Mahani, Mansour T.A. Sharabiani</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alireza S. Mahani &lt;alireza.s.mahani@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Core functions as well as diagnostic and calibration tools for combining matching and linear regression for causal inference in observational studies.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Hmisc, Matching, graphics, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-30 12:12:28 UTC; ubuntu</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-30 13:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='lalonde'>
Lalonde's National Supported Work Demonstration data
</h2><span id='topic+lalonde'></span>

<h3>Description</h3>

<p>One of the datasets used by Dehejia and Wahba in their paper &quot;Causal Effects in Non-Experimental Studies: Reevaluating the Evaluation of Training Programs.&quot; Also used as an example dataset in the MatchIt package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("lalonde")</code></pre>


<h3>Format</h3>

<p>A data frame with 614 observations on the following 10 variables.
</p>

<dl>
<dt><code>treat</code></dt><dd><p>treatment indicator; 1 if treated in the National Supported Work Demonstration, 0 if from the Current Population Survey</p>
</dd>
<dt><code>age</code></dt><dd><p>age, a numeric vector.</p>
</dd>
<dt><code>educ</code></dt><dd><p>years of education, a numeric vector between 0 and 18.</p>
</dd>
<dt><code>black</code></dt><dd><p>a binary vector, 1 if <code>black</code>, 0 otherwise.</p>
</dd>
<dt><code>hispan</code></dt><dd><p>a binary vector, 1 if <code>hispanic</code>, 0 otherwise.</p>
</dd>
<dt><code>married</code></dt><dd><p>a binary vector, 1 if <code>married</code>, 0 otherwise.</p>
</dd>
<dt><code>nodegree</code></dt><dd><p>a binary vector, 1 if no degree, 0 otherwise.</p>
</dd>
<dt><code>re74</code></dt><dd><p>earnings in 1974, a numeric vector.</p>
</dd>
<dt><code>re75</code></dt><dd><p>earnings in 1975, a numeric vector.</p>
</dd>
<dt><code>re78</code></dt><dd><p>earnings in 1978, a numeric vector (outcome variable).</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set has been taken from <code>twang</code> package, with small changes to field descriptions.
</p>


<h3>Source</h3>

<p>http://www.columbia.edu/~rd247/nswdata.html http://cran.r-project.org/src/contrib/Descriptions/MatchIt.html
</p>


<h3>References</h3>

<p>Lalonde, R. (1986). Evaluating the econometric evaluations of training programs with experimental data. American Economic Review 76: 604-620.
</p>
<p>Dehejia, R.H. and Wahba, S. (1999). Causal Effects in Nonexperimental Studies: Re-Evaluating the Evaluation of Training Programs. Journal of the American Statistical Association 94: 1053-1062.
</p>

<hr>
<h2 id='lindner'>
Lindner Center data on 996 PCI patients analyzed by Kereiakes et al. (2000)
</h2><span id='topic+lindner'></span>

<h3>Description</h3>

<p>These data are adapted from the lindner dataset in the USPS package. The description comes from that package, except for the variable sixMonthSurvive, which is a recode of lifepres
</p>
<p>Data from an observational study of 996 patients receiving an initial Percutaneous Coronary Intervention (PCI) at Ohio Heart Health, Christ Hospital, Cincinnati in 1997 and followed for at least 6 months by the staff of the Lindner Center. The patients thought to be more severely diseased were assigned to treatment with abciximab (an expensive, high-molecular-weight IIb/IIIa cascade blocker); in fact, only 298 (29.9 percent) of patients received usual-care-alone with their initial PCI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("lindner")</code></pre>


<h3>Format</h3>

<p>A data frame of 10 variables collected on 996 patients; no NAs.
</p>

<dl>
<dt><code>lifepres</code></dt><dd><p>Mean life years preserved due to survival for at least 6 months following PCI; numeric value of either 11.4 or 0.</p>
</dd>
<dt><code>cardbill</code></dt><dd><p>Cardiac related costs incurred within 6 months of patient's initial PCI; numeric value in 1998 dollars; costs were truncated by death for the 26 patients with lifepres == 0.</p>
</dd>
<dt><code>abcix</code></dt><dd><p>Numeric treatment selection indicator; 0 implies usual PCI care alone; 1 implies usual PCI care deliberately augmented by either planned or rescue treatment with abciximab.</p>
</dd>
<dt><code>stent</code></dt><dd><p>Coronary stent deployment; numeric, with 1 meaning YES and 0 meaning NO.</p>
</dd>
<dt><code>height</code></dt><dd><p>Height in centimeters; numeric integer from 108 to 196.</p>
</dd>
<dt><code>female</code></dt><dd><p>Female gender; numeric, with 1 meaning YES and 0 meaning NO.</p>
</dd>
<dt><code>diabetic</code></dt><dd><p>Diabetes mellitus diagnosis; numeric, with 1 meaning YES and 0 meaning NO.</p>
</dd>
<dt><code>acutemi</code></dt><dd><p>Acute myocardial infarction within the previous 7 days; numeric, with 1 meaning YES and 0 meaning NO.</p>
</dd>
<dt><code>ejecfrac</code></dt><dd><p>Left ejection fraction; numeric value from 0 percent to 90 percent.</p>
</dd>
<dt><code>ves1proc</code></dt><dd><p>Number of vessels involved in the patient's initial PCI procedure; numeric integer from 0 to 5.</p>
</dd>
<dt><code>sixMonthSurvive</code></dt><dd><p>Survival at six months - a recoded version of lifepres.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set and documentation is taken from <code>twang</code> package.
</p>


<h3>References</h3>

<p>Kereiakes DJ, Obenchain RL, Barber BL, et al. Abciximab provides cost effective survival advantage in high volume interventional practice. Am Heart J 2000; 140: 603-610.
</p>

<hr>
<h2 id='mlr'>
Creating a series of matched data sets with different calibration parameters
</h2><span id='topic+mlr'></span>

<h3>Description</h3>

<p>Creating a series of matched data sets with different calibration parameters. The output of this function can be supplied to <code>summary.mlr</code> and then <code>plot.summary.mlr</code> methods to generate diagnostic and calibration plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlr(tr, Z.i = NULL, Z.o = mlr.generate.Z.o(Z.i), psm = TRUE
  , caliper.vec = c(0.1, 0.25, 0.5, 0.75, 1, 1.5, 2, 5, Inf)
  , ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr_+3A_tr">tr</code></td>
<td>
<p>Binary treatment indicator vector (1=treatment, 0=control), whose coefficient in the linear regression model is TE.</p>
</td></tr>
<tr><td><code id="mlr_+3A_z.i">Z.i</code></td>
<td>
<p>Matrix of adjustment covariates included in linear regression. We must have <code>nrow(Z.i) == length(tr)</code>.</p>
</td></tr>
<tr><td><code id="mlr_+3A_z.o">Z.o</code></td>
<td>
<p>Matrix of adjustment covariates (present in generative model but) omitted from regression estimation. We must have <code>nrow(Z.o) == length(tr)</code>.</p>
</td></tr>
<tr><td><code id="mlr_+3A_psm">psm</code></td>
<td>
<p>Boolean flag, indicating whether propensity score matching should be used (<code>TRUE</code>) or Mahalanobis matching (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="mlr_+3A_caliper.vec">caliper.vec</code></td>
<td>
<p>Vector of matching calipers used.</p>
</td></tr>
<tr><td><code id="mlr_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>mlr.match</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>
<table role = "presentation">
<tr><td><code>tr</code></td>
<td>
<p>Same as input.</p>
</td></tr>
<tr><td><code>Z.i</code></td>
<td>
<p>Same as input.</p>
</td></tr>
<tr><td><code>Z.o</code></td>
<td>
<p>Same as input.</p>
</td></tr>
<tr><td><code>idx.list</code></td>
<td>
<p>List of observation indexes for each matched data set.</p>
</td></tr>
<tr><td><code>caliper.vec</code></td>
<td>
<p>Same as input.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Link to a draft paper, documenting the supporting mathematical framework, will be provided in the next release.
</p>

<hr>
<h2 id='mlr.bias'>
Treatment effect bias
</h2><span id='topic+mlr.bias'></span>

<h3>Description</h3>

<p>Calculating treatment effect bias due to misspecified regression, using coefficients of omitted covariates (if supplied) or a constrained bias estimation approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlr.bias(tr, Z.i = NULL, Z.o, gamma.o = NULL
  , idx = 1:length(tr))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr.bias_+3A_tr">tr</code></td>
<td>
<p>Binary treatment indicator vector (1=treatment, 0=control), whose coefficient in the linear regression model is TE.</p>
</td></tr>
<tr><td><code id="mlr.bias_+3A_z.i">Z.i</code></td>
<td>
<p>Matrix of adjustment covariates included in linear regression. We must have <code>nrow(Z.i) == length(tr)</code>.</p>
</td></tr>
<tr><td><code id="mlr.bias_+3A_z.o">Z.o</code></td>
<td>
<p>Matrix of adjustment covariates (present in generative model but) omitted from regression estimation. We must have <code>nrow(Z.o) == length(tr)</code>.</p>
</td></tr>
<tr><td><code id="mlr.bias_+3A_gamma.o">gamma.o</code></td>
<td>
<p>Vector of coefficients for omitted adjustment covariates.</p>
</td></tr>
<tr><td><code id="mlr.bias_+3A_idx">idx</code></td>
<td>
<p>Index of observations to be used, with possible duplication, e.g. as indexes of matched subset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>single</code>, <code>subspace</code> and <code>absolute</code>, biases are calculated using the constrained bias estimation framework, i.e. L2 norm of <code>Z.o%*%gamma.o</code> is taken to be <code>length(tr)</code> (mean squared of 1).
</p>


<h3>Value</h3>

<p>A list with the following elements is returned:
</p>
<table role = "presentation">
<tr><td><code>gamma.o</code></td>
<td>
<p>If function argument <code>gamma.o</code> is <code>NULL</code>, this field will be <code>NA</code>. Otherwise, this will be the covariate omission bias for the given coefficient values.</p>
</td></tr>
<tr><td><code>single</code></td>
<td>
<p>A list with elements: 1) <code>bias</code>: bias for the omitted covariate with maximum absolute bias, 2) <code>bias.vec</code>: vector of biases for all omitted covariates, 3) <code>dir</code>: vector of length <code>length(tr)</code>, being the particular column of <code>Z.o</code> with maximum absolute bias (after orthogonalization and normalization), 4) <code>idx</code>: column number for <code>Z.o</code> corresponding to <code>dir</code>.</p>
</td></tr>
<tr><td><code>subspace</code></td>
<td>
<p>A list with elements: 1) <code>bias</code>: bias in direction within omitted covariate subspace with maximum absolute bias, 2) <code>dir</code>: direction in omitted-covariate subspace (and orthogonal to subspace spanned by <code>{1,Z.i}</code>) corresponding to the bias in previous element.</p>
</td></tr>
<tr><td><code>absolute</code></td>
<td>
<p>A list with elements: 1) <code>bias</code>: bias in direction within subspace orthogonal to <code>{1,Z.i}</code> with maximum absolute bias, 2) <code>dir</code>: direction in aforementioned subspace corresponding to maximum absolute bias.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Link to a draft paper, documenting the supporting mathematical framework, will be provided in the next release.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# number of included adjustment covariates
K &lt;- 10
# number of observations in treatment group
Nt &lt;- 100
# number of observations in control group
Nc &lt;- 100
N &lt;- Nt + Nc
# number of omitted covariates
Ko &lt;- 3

# treatment indicator variable
tr &lt;- c(rep(1, Nt), rep(0, Nc))
# matrix of included (adjustment) covariates
Z.i &lt;- matrix(runif(K*N), ncol = K)
# matrix of omitted covariates
Z.o &lt;- matrix(runif(Ko*N), ncol = Ko)
# coefficients of omitted covariates
gamma.o &lt;- runif(Ko)

retobj &lt;- mlr.bias(tr = tr, Z.i = Z.i, Z.o = Z.o, gamma.o = gamma.o)

# 1) using actual coefficients for computing bias
ret &lt;- retobj$gamma.o

# comparing with brute-force approach
X.i &lt;- cbind(tr, 1, Z.i)
ret2 &lt;- (solve(t(X.i) %*% X.i, t(X.i) %*% Z.o %*% gamma.o))[1]

cat("check 1:", all.equal(ret2, ret), "\n")

# comparing with single method
Z.o.proj &lt;- mlr.orthogonalize(X = cbind(1, Z.i), Z = Z.o, normalize = TRUE)
ret3 &lt;- (solve(t(X.i) %*% X.i, t(X.i) %*% Z.o.proj))[1, ]

cat("check 2:", all.equal(ret3, retobj$single$bias.vec), "\n")

ret4 &lt;- (solve(t(X.i) %*% X.i, t(X.i) %*% retobj$subspace$dir))[1, ]

cat("check 3:", all.equal(as.numeric(ret4), as.numeric(retobj$subspace$bias)), "\n")

ret4 &lt;- (solve(t(X.i) %*% X.i, t(X.i) %*% retobj$absolute$dir))[1, ]

cat("check 4:", all.equal(as.numeric(ret4), as.numeric(retobj$absolute$bias)), "\n")

</code></pre>

<hr>
<h2 id='mlr.bias.constructor'>
Generating the treatment effect bias constructor vector
</h2><span id='topic+mlr.bias.constructor'></span>

<h3>Description</h3>

<p>Generaring the vector that, multiplied by <code>Z.o%*%gamma.o</code> (contribution of omitted covariates to outcome), produces the treatment effect bias - due to model misspecification in the form of covariate omission - when using linear regression for causal inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlr.bias.constructor(tr, Z.i = NULL, details = FALSE, idx = 1:length(tr))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr.bias.constructor_+3A_tr">tr</code></td>
<td>
<p>Binary treatment indicator vector (1=treatment, 0=control), whose coefficient in the linear regression model is TE.</p>
</td></tr>
<tr><td><code id="mlr.bias.constructor_+3A_z.i">Z.i</code></td>
<td>
<p>Matrix of adjustment covariates included in linear regression. We must have <code>nrow(Z.i) == length(tr)</code>.</p>
</td></tr>
<tr><td><code id="mlr.bias.constructor_+3A_details">details</code></td>
<td>
<p>Boolean flag, indicating whether intermediate objects used in generating the constrcutor vector must be returned or not. This only works if at least one adjustment covariate is included in the regression (<code>Z.i</code> is not <code>NULL</code>), and there are no repeated observations, i.e. <code>max(table(idx))==1</code>.</p>
</td></tr>
<tr><td><code id="mlr.bias.constructor_+3A_idx">idx</code></td>
<td>
<p>Index of observations to be used, with possible duplication, e.g. as indexes of matched subset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of same length as <code>tr</code> is returned. If <code>details = TRUE</code> and <code>Z.i</code> is not <code>NULL</code>, then the following objects are attached as attributes:
</p>
<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p>Vector of length <code>ncol(Z.i)</code>, reflecting the sum of each included covariate in treatment group.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>Vector of length <code>ncol(Z.i)</code>, reflecting the sum of each included covariate across both treatment and control groups.</p>
</td></tr>
<tr><td><code>u.i</code></td>
<td>
<p>Vector of length <code>ncol(Z.i)</code>, reflecting the mean difference between groups (control - treatment) for each included covariate.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Weighted, within-group covariance matrix of included covariates. It is a square matrix of dimension <code>ncol(Z.i)</code>.</p>
</td></tr>
<tr><td><code>iA</code></td>
<td>
<p>Inverse of <code>A</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Link to a draft paper, documenting the supporting mathematical framework, will be provided in the next release.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# number of included adjustment covariates
K &lt;- 10
# number of observations in treatment group
Nt &lt;- 100
# number of observations in control group
Nc &lt;- 100
N &lt;- Nt + Nc

# treatment indicator variable
tr &lt;- c(rep(1, Nt), rep(0, Nc))
# matrix of included (adjustment) covariates
Z.i &lt;- matrix(runif(K*N), ncol = K)

ret &lt;- mlr.bias.constructor(tr = tr, Z.i = Z.i)

# comparing with brute-force approach
X.i &lt;- cbind(tr, 1, Z.i)
ret2 &lt;- (solve(t(X.i) %*% X.i, t(X.i)))[1, ]

cat("check 1:", all.equal(ret2, ret), "\n")

# sampling with replacement
idx &lt;- sample(1:N, size = round(0.75*N), replace = TRUE)
ret3 &lt;- mlr.bias.constructor(tr = tr, Z.i = Z.i, idx = idx)
ret4 &lt;- (solve(t(X.i[idx, ]) %*% X.i[idx, ], t(X.i[idx, ])))[1, ]

cat("check 2:", all.equal(ret3, ret4), "\n")

</code></pre>

<hr>
<h2 id='mlr.combine.bias.variance'>
Combining bias and variance to produce total MSE for treatment effect
</h2><span id='topic+mlr.combine.bias.variance'></span>

<h3>Description</h3>

<p>Combining normalized bias and variance over a range of values for omitted R-squared to produce normalized MSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlr.combine.bias.variance(tr, bvmat, orsq.min = 0.001, orsq.max = 1, n.orsq = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr.combine.bias.variance_+3A_tr">tr</code></td>
<td>
<p>Binary treatment indicator vector (1=treatment, 0=control), whose coefficient in the linear regression model is TE.</p>
</td></tr>
<tr><td><code id="mlr.combine.bias.variance_+3A_bvmat">bvmat</code></td>
<td>
<p>Matrix of bias and variances. First column must be bias, and second column must be variance. Each row corresponds to a different &lsquo;calibration index&rsquo; or scenario, which we want to compare and find the best among them.</p>
</td></tr>
<tr><td><code id="mlr.combine.bias.variance_+3A_orsq.min">orsq.min</code></td>
<td>
<p>Minimum omitted R-squared used for combining bias and variance.</p>
</td></tr>
<tr><td><code id="mlr.combine.bias.variance_+3A_orsq.max">orsq.max</code></td>
<td>
<p>Maximum omitted R-squared.</p>
</td></tr>
<tr><td><code id="mlr.combine.bias.variance_+3A_n.orsq">n.orsq</code></td>
<td>
<p>Number of values for omitted R-squared generated in the vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>orsq.vec</code></td>
<td>
<p>Vector of omitted R-squared values used for combining bias and variance.</p>
</td></tr>
<tr><td><code>errmat</code></td>
<td>
<p>Matrix of MSE, with each row corresponding to an omitted R-squared value, and each column for a value of calibration index, i.e. one row if <code>bvmat</code>.</p>
</td></tr>
<tr><td><code>biassq.mat</code></td>
<td>
<p>Matrix of squared biases, with a structure similar to <code>errmat</code>.</p>
</td></tr>
<tr><td><code>which.min.vec</code></td>
<td>
<p>Value of calibration index (row number for <code>errmat</code>) with minimum MSE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Link to a draft paper, documenting the supporting mathematical framework, will be provided in the next release.
</p>

<hr>
<h2 id='mlr.generate.Z.o'>
Generating omitted covariates from included covariates
</h2><span id='topic+mlr.generate.Z.o'></span>

<h3>Description</h3>

<p>Utility function for generating interaction terms and step functions from a set of base covariates, to be used as candidate omitted covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlr.generate.Z.o(X, interaction.order = 3, step.funcs = TRUE
  , step.thresh = 20, step.ncuts = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr.generate.Z.o_+3A_x">X</code></td>
<td>
<p>Matrix of base covariates.</p>
</td></tr>
<tr><td><code id="mlr.generate.Z.o_+3A_interaction.order">interaction.order</code></td>
<td>
<p>Order of interactions to generate. It must be at least 2.</p>
</td></tr>
<tr><td><code id="mlr.generate.Z.o_+3A_step.funcs">step.funcs</code></td>
<td>
<p>Boolean flag, indicating whether (binary) step functions must be generated from continuous variables.</p>
</td></tr>
<tr><td><code id="mlr.generate.Z.o_+3A_step.thresh">step.thresh</code></td>
<td>
<p>Minimum number of distinct values in a numeric vector to generate step functions from.</p>
</td></tr>
<tr><td><code id="mlr.generate.Z.o_+3A_step.ncuts">step.ncuts</code></td>
<td>
<p>How many cuts to apply for generating step functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TBD
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Link to a draft paper, documenting the supporting mathematical framework, will be provided in the next release.
</p>

<hr>
<h2 id='mlr.match'>
Thin wrapper around <code>Match</code> function from <code>Matching</code> package
</h2><span id='topic+mlr.match'></span>

<h3>Description</h3>

<p>Performs propensity score or Mahalanobis matching and return indexes of treatment and control groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlr.match(tr, X, psm = TRUE, replace = F, caliper = Inf
  , verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr.match_+3A_tr">tr</code></td>
<td>
<p>Binary treatment indicator vector (1=treatment, 0=control), whose coefficient in the linear regression model is TE.</p>
</td></tr>
<tr><td><code id="mlr.match_+3A_x">X</code></td>
<td>
<p>Covariates used in matching, either directly (Mahalanobis matching) or indirectly (propensity score).</p>
</td></tr>
<tr><td><code id="mlr.match_+3A_psm">psm</code></td>
<td>
<p>Boolean flag, indicating whether propensity score matching should be used (<code>TRUE</code>) or Mahalanobis matching (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="mlr.match_+3A_replace">replace</code></td>
<td>
<p>Boolean flag, indicating whether matching must be done with or without replacement.</p>
</td></tr>
<tr><td><code id="mlr.match_+3A_caliper">caliper</code></td>
<td>
<p>Size of caliper (standardized distance of two observations) used in matching. Treatment and control observations with standardized distance larger than <code>caliper</code> will not be considered as eligible pairs duing matching.</p>
</td></tr>
<tr><td><code id="mlr.match_+3A_verbose">verbose</code></td>
<td>
<p>Boolean flag, indicating whether size of treatment and control groups before and after matching will be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For propensity score matching, linear predictors from logistic regression are used (rather than predicted probabilities).
</p>


<h3>Value</h3>

<p>A vector of matched indexes, containing both treatment and control groups. Also, the following attributes are attached: 1) <code>nt</code>: size of treatment group, 2) <code>nc</code>: size of control group, 3) <code>psm.reg</code>: logistic regression object used in generating propensity scores (<code>NA</code> if <code>psm</code> is <code>FALSE</code>), 4) <code>match.obj</code>: matching object returned by <code>Match</code> function.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lalonde)

tr &lt;- lalonde$treat
Z.i &lt;- as.matrix(lalonde[, c("age", "educ", "black"
  , "hispan", "married", "nodegree", "re74", "re75")])
Z.o &lt;- model.matrix(~ I(age^2) + I(educ^2) + I(re74^2) + I(re75^2) - 1, lalonde)

# propensity score matching on all covariates
idx &lt;- mlr.match(tr = tr, X = cbind(Z.i, Z.o), caliper = 1.0, replace = FALSE)

# improvement in maximum single-covariate bias due to matching
bias.obj.before &lt;- mlr.bias(tr = tr, Z.i = Z.i, Z.o = Z.o)
bias.before &lt;- bias.obj.before$subspace$bias
dir &lt;- bias.obj.before$subspace$dir
bias.after &lt;- as.numeric(mlr.bias(tr = tr[idx]
  , Z.i = Z.i[idx, ], Z.o = dir[idx], gamma.o = 1.0)$single$bias)

# percentage bias-squared rediction
cat("normalized bias - before:", bias.before, "\n")
cat("normalized bias - after:", bias.after, "\n")
cat("percentage squared-bias reduction:"
  , (bias.before^2 - bias.after^2)/bias.before^2, "\n")

# matching with replacement
idx.wr &lt;- mlr.match(tr = tr, X = cbind(Z.i, Z.o), caliper = 1.0
  , replace = TRUE)
bias.after.wr &lt;- as.numeric(mlr.bias(tr = tr
  , Z.i = Z.i, Z.o = dir, gamma.o = 1.0, idx = idx.wr)$single$bias)
cat("normalized bias - after (with replacement):", bias.after.wr, "\n")

</code></pre>

<hr>
<h2 id='mlr.orthogonalize'>
Orthogonalization of vectors with repsect to a matrix
</h2><span id='topic+mlr.orthogonalize'></span>

<h3>Description</h3>

<p>Decomposing a collection of vectors into parallel and orthogonal components with respect to the subspace spanned by columns of a reference matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlr.orthogonalize(X, Z, normalize = FALSE, tolerance = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr.orthogonalize_+3A_x">X</code></td>
<td>
<p>Matrix whose columns form the subspace, with respect to which we want to orthogonalize columns of <code>Z</code>.</p>
</td></tr>
<tr><td><code id="mlr.orthogonalize_+3A_z">Z</code></td>
<td>
<p>Matrix whose columns we want to orthogonalize with respect to the subpsace spanned by columns of <code>X</code>. We must have <code>nrow(Z) == nrow(X)</code>.</p>
</td></tr>
<tr><td><code id="mlr.orthogonalize_+3A_normalize">normalize</code></td>
<td>
<p>Boolean flag, indicating whether the orthogonal component of <code>Z</code> columns must be normalized so that their L2 norms equal <code>nrow(Z)</code> (mean squared is 1).</p>
</td></tr>
<tr><td><code id="mlr.orthogonalize_+3A_tolerance">tolerance</code></td>
<td>
<p>If unnormalized projection of a column of <code>Z</code> has an L2 norm below <code>tolerance</code>, it will not be normalized (even if requested via <code>normalize</code>) and instead a zero vector will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current implementation uses Singular Value Decomposition (<code>svd</code>) of <code>X</code> to form an orthonormal basis from columns of <code>X</code> to facilitate the projection process.
</p>


<h3>Value</h3>

<p>A matrix of same dimensions as <code>Z</code> is returned, with each column containing the orthogonal component of the corresponding column of <code>Z</code>. Parallel components are attached as <code>parallel</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Link to a draft paper, documenting the supporting mathematical framework, will be provided in the next release.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
K &lt;- 10
N &lt;- 100
Ko &lt;- 5

X &lt;- matrix(runif(N*K), ncol = K)
Z &lt;- matrix(runif(N*Ko), ncol = Ko)

ret &lt;- mlr.orthogonalize(X = X, Z = Z, normalize = FALSE)

orthogonal &lt;- ret
parallel &lt;- attr(ret, "parallel")
Z.rec &lt;- parallel + orthogonal

# check that parallel and orthogonal components add up to Z
cat("check 1:", all.equal(as.numeric(Z.rec), as.numeric(Z)), "\n")
# check that inner product of orthogonal columns and X columns are zero
cat("check 2:", all.equal(t(orthogonal) %*% X, matrix(0, nrow = Ko, ncol = K)), "\n")

</code></pre>

<hr>
<h2 id='mlr.power'>
Power analysis for causal inference using linear regression
</h2><span id='topic+mlr.power'></span>

<h3>Description</h3>

<p>Monte Carlo based calculation of study power for treatment effect estimation using linear regression on treatment indicator and adjustment covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlr.power(tr, Z.i = NULL, d, sig.level = 0.05, niter = 1000
  , verbose = FALSE, idx = 1:length(tr), rnd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr.power_+3A_tr">tr</code></td>
<td>
<p>Binary treatment indicator vector (1=treatment, 0=control), whose coefficient in the linear regression model is TE.</p>
</td></tr>
<tr><td><code id="mlr.power_+3A_z.i">Z.i</code></td>
<td>
<p>Matrix of adjustment covariates included in linear regression. We must have <code>nrow(Z.i) == length(tr)</code>.</p>
</td></tr>
<tr><td><code id="mlr.power_+3A_d">d</code></td>
<td>
<p>Standardized effect size, equal to treatment effect divided by standard deviation of generative noise.</p>
</td></tr>
<tr><td><code id="mlr.power_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level for rejecting null hypothesis.</p>
</td></tr>
<tr><td><code id="mlr.power_+3A_niter">niter</code></td>
<td>
<p>Number of Monte Carlo simulations used for calculating power.</p>
</td></tr>
<tr><td><code id="mlr.power_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, calculated power is printed.</p>
</td></tr>
<tr><td><code id="mlr.power_+3A_idx">idx</code></td>
<td>
<p>Subset of observations to use for power calculation.</p>
</td></tr>
<tr><td><code id="mlr.power_+3A_rnd">rnd</code></td>
<td>
<p>Boolean flag. If <code>TRUE</code>, power is also calculated for random subsampling of observations, using same treatment and control group sizes as indicated by <code>idx</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In each Monte Carlo iteration, response variable is generated from a normal distribution whose mean is equal to <code>d * tr</code> (other coefficients are assumed to be zero since their value does not affect power calculation), and whose standard deviation is <code>1.0</code>. Then OLS-based regression is performed on data, and p-value for treatment effect is compared to <code>sig.level</code>, based on which null hypothesis (no effect) is rejected or accepted. The fraction of iterations where null hypothesis is rejected is taken to be power. Standard error is calculated using a binomial-distribution assumption.
</p>


<h3>Value</h3>

<p>A numeric vector is returned. If <code>rnd</code> is <code>FALSE</code>, meand and standard error of calculated power is returned. If <code>rnd</code> is <code>TRUE</code>, mean and standard error of power calculated for random subsampling of observations is returned as well.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>

<hr>
<h2 id='mlr.smd'>
Standardized mean difference
</h2><span id='topic+mlr.smd'></span>

<h3>Description</h3>

<p>Calculate standardized mean difference for each column of a matrix, given a binary treatment indicator vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlr.smd(tr, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr.smd_+3A_tr">tr</code></td>
<td>
<p>Binary treatment indicator vector; 1 means treatment, 0 means control.</p>
</td></tr>
<tr><td><code id="mlr.smd_+3A_x">X</code></td>
<td>
<p>Matrix of covariates; each column is a covariate whose standardized mean difference we want to calculate. <code>nrow(X)</code> must be equal to <code>length(tr)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>ncol(X)</code>, containing standardized mean differences for each column of <code>X</code>, given treatment variable <code>tr</code>.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>

<hr>
<h2 id='mlr.variance'>
Treatment effect variance
</h2><span id='topic+mlr.variance'></span>

<h3>Description</h3>

<p>Calculating treatment effect variance, resulting from linear regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlr.variance(tr, Z.i = NULL, sigsq = 1, details = FALSE
  , idx =1:length(tr))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlr.variance_+3A_tr">tr</code></td>
<td>
<p>Binary treatment indicator vector (1=treatment, 0=control), whose coefficient in the linear regression model is TE.</p>
</td></tr>
<tr><td><code id="mlr.variance_+3A_z.i">Z.i</code></td>
<td>
<p>Matrix of adjustment covariates included in linear regression. We must have <code>nrow(Z.i) == length(tr)</code>.</p>
</td></tr>
<tr><td><code id="mlr.variance_+3A_sigsq">sigsq</code></td>
<td>
<p>Variance of data generation noise.</p>
</td></tr>
<tr><td><code id="mlr.variance_+3A_details">details</code></td>
<td>
<p>Boolean flag, indicating whether intermediate objects used in generating the constrcutor vector must be returned or not (only when no repeated observations).</p>
</td></tr>
<tr><td><code id="mlr.variance_+3A_idx">idx</code></td>
<td>
<p>Index of observations to be used, with possible duplication, e.g. as indexes of matched subset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar value is returned for TE variance. If <code>details = TRUE</code> and <code>Z.i</code> is not <code>NULL</code>, then the following objects are attached as attributes:
</p>
<table role = "presentation">
<tr><td><code>u.i</code></td>
<td>
<p>Vector of length <code>ncol(Z.i)</code>, reflecting the mean difference between groups (control - treatment) for each included covariate.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Weighted, within-group covariance matrix of included covariates. It is a square matrix of dimension <code>ncol(Z.i)</code>.</p>
</td></tr>
<tr><td><code>iA</code></td>
<td>
<p>Inverse of <code>A</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Link to a draft paper, documenting the supporting mathematical framework, will be provided in the next release.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lalonde)

tr &lt;- lalonde$treat
Z.i &lt;- as.matrix(lalonde[, c("age", "educ", "black"
  , "hispan", "married", "nodegree", "re74", "re75")])

ret &lt;- mlr.variance(tr = tr, Z.i = Z.i)

# comparing with brute-force approach
X.i &lt;- cbind(tr, 1, Z.i)
ret2 &lt;- (solve(t(X.i) %*% X.i))[1, 1]

cat("check 1:", all.equal(ret2, ret), "\n")

# matching with/without replacement
idx &lt;- mlr.match(tr = tr, X = Z.i, caliper = 1.0
  , replace = FALSE)
idx.wr &lt;- mlr.match(tr = tr, X = Z.i, caliper = 1.0
  , replace = TRUE)

ret3 &lt;- mlr.variance(tr = tr, Z.i = Z.i, idx = idx)
cat("variance - matching without replacement:"
  , ret3, "\n")

ret4 &lt;- mlr.variance(tr = tr, Z.i = Z.i, idx = idx.wr)
cat("variance - matching with replacement:"
  , ret4, "\n")

</code></pre>

<hr>
<h2 id='plot.summary.mlr'>
Plotting diagnostic and calibration objects resulting from call to <code>summary.mlr</code>
</h2><span id='topic+plot.summary.mlr'></span>

<h3>Description</h3>

<p>Diagnostic and calibration plots, inlcuding relative squared bias reduction, constrained bias estimation, bias-variance trade-off, and power analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.mlr'
plot(x, which = 1
  , smd.index = 1:min(10, ncol(x$smd))
  , bias.index = 1:min(10, ncol(x$bias.terms))
  , orsq.plot = c(0.01, 0.05, 0.25)
  , caption.vec = c("relative squared bias reduction", "normalized bias"
    , "standardized mean difference", "maximum bias"
    , "error components", "optimum choice", "power analysis")
  , ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.summary.mlr_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.mlr</code>, typically the result of a call to <code>summary.mlr</code>.</p>
</td></tr>
<tr><td><code id="plot.summary.mlr_+3A_which">which</code></td>
<td>
<p>Selection of which plots to generate: <code>1</code> = relative squared bias reduction (by term) for a single idx, <code>2</code> = bias terms vs. idx, <code>3</code> = standardized mean difference by term vs. idx, <code>4</code> = maximum bias (single-covariate, subspace, absolute) vs. idx, <code>5</code> = bias/variance/MSE plots, <code>6</code> = optimum index vs. omitted r-squared, <code>7</code> = power analysis (matched and random subsamples) vs. idx.</p>
</td></tr>
<tr><td><code id="plot.summary.mlr_+3A_smd.index">smd.index</code></td>
<td>
<p>Index of columns in <code>smd.mat</code> field of <code>x</code> to plot.</p>
</td></tr>
<tr><td><code id="plot.summary.mlr_+3A_bias.index">bias.index</code></td>
<td>
<p>Index of columns in <code>bias.terms</code> field of <code>x</code> to plot.</p>
</td></tr>
<tr><td><code id="plot.summary.mlr_+3A_orsq.plot">orsq.plot</code></td>
<td>
<p>Which values for omitted R-squared to generate plots for.</p>
</td></tr>
<tr><td><code id="plot.summary.mlr_+3A_caption.vec">caption.vec</code></td>
<td>
<p>Character vector to be used as caption for plots. Values will be repeated if necessary if length is shorter than number of plots requested.</p>
</td></tr>
<tr><td><code id="plot.summary.mlr_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to/from other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, 7 types of plots can be generated, as specified by the <code>which</code> flag: 1) relative squared bias reduction, by candidate omitted term, comparing before and after matching, 2) normalized squared bias, by candidate omitted term, vs. calibration index, 3) standardized mean difference, for all included and (candidate) omitted terms, vs. calibration index, 4) aggregate bias (single-covariate maximum, covariate-subspace maximum, and absolute maximum) vs. calibration index, 5) bias/variance/MSE vs. calibration index, at user-supplied values for omitted R-squared, 6) optimal index vs. omitted R-squared, and 7) study power vs. calibration index.
</p>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Link to a draft paper, documenting the supporting mathematical framework, will be provided in the next release.
</p>

<hr>
<h2 id='summary.mlr'>
Applying diagnostic and calibration functions to mlr objects
</h2><span id='topic+summary.mlr'></span>

<h3>Description</h3>

<p>Applying a series of diagnostic and calibration functions to a series of matched data sets to determine impact of matching on TE bias, variance and total error, and to select the best matching parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlr'
summary(object, power = FALSE
  , power.control = list(rnd = TRUE, d = 0.5, sig.level = 0.05
    , niter = 1000, rnd = TRUE)
  , max.method = c("single-covariate", "covariate-subspace"
    , "absolute")
  , verbose = FALSE, ...
  , orsq.min = 1e-03, orsq.max = 1e0, n.orsq = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mlr_+3A_object">object</code></td>
<td>
<p>An object of class <code>mlr</code>, typically the result of a call to <code>mlr</code>.</p>
</td></tr>
<tr><td><code id="summary.mlr_+3A_power">power</code></td>
<td>
<p>Boolean flag indicating whether Monte-Carlo based power analysis must be performed or not.</p>
</td></tr>
<tr><td><code id="summary.mlr_+3A_power.control">power.control</code></td>
<td>
<p>A list containing parameters to be passed to <code>mlr.power</code> for power calculation.</p>
</td></tr>
<tr><td><code id="summary.mlr_+3A_max.method">max.method</code></td>
<td>
<p>Which constrained bias estimation method must be used in bias-variance trade-off and other analyses?</p>
</td></tr>
<tr><td><code id="summary.mlr_+3A_verbose">verbose</code></td>
<td>
<p>Whether progress message must be printed.</p>
</td></tr>
<tr><td><code id="summary.mlr_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to/from other functions.</p>
</td></tr>
<tr><td><code id="summary.mlr_+3A_orsq.min">orsq.min</code></td>
<td>
<p>Minimum value of omitted R-squared used for combining normalized bias and variance.</p>
</td></tr>
<tr><td><code id="summary.mlr_+3A_orsq.max">orsq.max</code></td>
<td>
<p>Maximum value of omitted R-squared used for combining normalized bias and variance.</p>
</td></tr>
<tr><td><code id="summary.mlr_+3A_n.orsq">n.orsq</code></td>
<td>
<p>Number of values for omitted R-squared to generate in the specified range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.mlr</code>, with the following elements:
</p>
<table role = "presentation">
<tr><td><code>mlr.obj</code></td>
<td>
<p>Same as input.</p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p>Matrix of aggregate bias values, one row per calibration index, and three columns: 1) single-covariate maximum, 2) covariate-subspace maximum, and 3) absolute maximum, in that order.</p>
</td></tr>
<tr><td><code>bias.terms</code></td>
<td>
<p>Matrix of biases, one row per calibration index, and one column per candidate omitted term.</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>Vector of normalized variances, one per each value of calibration index.</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>Matrix of power calculations, one row per calibration index. Each row is identical to output of <code>mlr.power</code> for that calibration index value.</p>
</td></tr>
<tr><td><code>smd</code></td>
<td>
<p>Matrix of standardized mean differences, one row per calibration index, and one column for each included or omitted covariates.</p>
</td></tr>
<tr><td><code>combine.obj</code></td>
<td>
<p>Output of <code>mlr.combine.bias.variance</code> applied to bias and variances at each calibration index value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alireza S. Mahani, Mansour T.A. Sharabiani
</p>


<h3>References</h3>

<p>Link to a draft paper, documenting the supporting mathematical framework, will be provided in the next release.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
