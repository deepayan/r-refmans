<!DOCTYPE html><html><head><title>Help for package s2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {s2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_s2_geography'><p>Create an S2 Geography Vector</p></a></li>
<li><a href='#s2_boundary'><p>S2 Geography Transformations</p></a></li>
<li><a href='#s2_bounds_cap'><p>Compute feature-wise and aggregate bounds</p></a></li>
<li><a href='#s2_cell'><p>Create S2 Cell vectors</p></a></li>
<li><a href='#s2_cell_is_valid'><p>S2 cell operators</p></a></li>
<li><a href='#s2_cell_union'><p>Create S2 Cell Union vectors</p></a></li>
<li><a href='#s2_cell_union_normalize'><p>S2 cell union operators</p></a></li>
<li><a href='#s2_closest_feature'><p>Matrix Functions</p></a></li>
<li><a href='#s2_contains'><p>S2 Geography Predicates</p></a></li>
<li><a href='#s2_data_example_wkt'><p>Example Geometries</p></a></li>
<li><a href='#s2_data_tbl_countries'><p>Low-resolution world boundaries, timezones, and cities</p></a></li>
<li><a href='#s2_earth_radius_meters'><p>Earth Constants</p></a></li>
<li><a href='#s2_geog_point'><p>Create and Format Geography Vectors</p></a></li>
<li><a href='#s2_is_collection'><p>S2 Geography Accessors</p></a></li>
<li><a href='#s2_lnglat'><p>Create an S2 LngLat Vector</p></a></li>
<li><a href='#s2_options'><p>Geography Operation Options</p></a></li>
<li><a href='#s2_plot'><p>Plot S2 Geographies</p></a></li>
<li><a href='#s2_point'><p>Create an S2 Point Vector</p></a></li>
<li><a href='#s2_project'><p>Linear referencing</p></a></li>
<li><a href='#s2-package'><p>s2: Spherical Geometry Operators Using the S2 Geometry Library</p></a></li>
<li><a href='#wk_handle.s2_geography'><p>Low-level wk filters and handlers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spherical Geometry Operators Using the S2 Geometry Library</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides R bindings for Google's s2 library for geometric calculations on
    the sphere. High-performance constructors and exporters provide high compatibility
    with existing spatial packages, transformers construct new geometries from existing
    geometries, predicates provide a means to select geometries based on spatial 
    relationships, and accessors extract information about geometries.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>OpenSSL &gt;= 1.0.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, wk</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, wk (&ge; 0.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bit64, testthat (&ge; 3.0.0), vctrs</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-spatial.github.io/s2/">https://r-spatial.github.io/s2/</a>, <a href="https://github.com/r-spatial/s2">https://github.com/r-spatial/s2</a>,
<a href="http://s2geometry.io/">http://s2geometry.io/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-spatial/s2/issues">https://github.com/r-spatial/s2/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-19 14:38:19 UTC; edzer</td>
</tr>
<tr>
<td>Author:</td>
<td>Dewey Dunnington <a href="https://orcid.org/0000-0002-9415-4582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Edzer Pebesma <a href="https://orcid.org/0000-0001-8049-7069"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ege Rubak [aut],
  Jeroen Ooms [ctb] (configure script),
  Google, Inc. [cph] (Original s2geometry.io source code)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edzer Pebesma &lt;edzer.pebesma@uni-muenster.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-19 17:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_s2_geography'>Create an S2 Geography Vector</h2><span id='topic+as_s2_geography'></span><span id='topic+s2_geography'></span><span id='topic+as_s2_geography.s2_geography'></span><span id='topic+as_s2_geography.wk_xy'></span><span id='topic+as_s2_geography.wk_wkb'></span><span id='topic+as_s2_geography.WKB'></span><span id='topic+as_s2_geography.blob'></span><span id='topic+as_s2_geography.wk_wkt'></span><span id='topic+as_s2_geography.character'></span><span id='topic+as_s2_geography.logical'></span><span id='topic+as_wkb.s2_geography'></span><span id='topic+as_wkt.s2_geography'></span>

<h3>Description</h3>

<p>Geography vectors are arrays of points, lines, polygons, and/or collections
of these. Geography vectors assume coordinates are longitude and latitude
on a perfect sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_s2_geography(x, ...)

s2_geography()

## S3 method for class 's2_geography'
as_s2_geography(x, ...)

## S3 method for class 'wk_xy'
as_s2_geography(x, ...)

## S3 method for class 'wk_wkb'
as_s2_geography(x, ..., oriented = FALSE, check = TRUE)

## S3 method for class 'WKB'
as_s2_geography(x, ..., oriented = FALSE, check = TRUE)

## S3 method for class 'blob'
as_s2_geography(x, ..., oriented = FALSE, check = TRUE)

## S3 method for class 'wk_wkt'
as_s2_geography(x, ..., oriented = FALSE, check = TRUE)

## S3 method for class 'character'
as_s2_geography(x, ..., oriented = FALSE, check = TRUE)

## S3 method for class 'logical'
as_s2_geography(x, ...)

## S3 method for class 's2_geography'
as_wkb(x, ...)

## S3 method for class 's2_geography'
as_wkt(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_s2_geography_+3A_x">x</code></td>
<td>
<p>An object that can be converted to an s2_geography vector</p>
</td></tr>
<tr><td><code id="as_s2_geography_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="as_s2_geography_+3A_oriented">oriented</code></td>
<td>
<p>TRUE if polygon ring directions are known to be correct
(i.e., exterior rings are defined counter clockwise and interior
rings are defined clockwise).</p>
</td></tr>
<tr><td><code id="as_s2_geography_+3A_check">check</code></td>
<td>
<p>Use <code>check = FALSE</code> to skip error on invalid geometries</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coercion function <code><a href="#topic+as_s2_geography">as_s2_geography()</a></code> is used to wrap the input
of most functions in the s2 package so that you can use other objects with
an unambiguious interpretation as a geography vector. Geography vectors
have a minimal <a href="vctrs.html#topic+vctrs-package">vctrs</a> implementation, so you can
use these objects in tibble, dplyr, and other packages that use the vctrs
framework.
</p>


<h3>Value</h3>

<p>An object with class s2_geography
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s2_geog_from_wkb">s2_geog_from_wkb()</a></code>, <code><a href="#topic+s2_geog_from_text">s2_geog_from_text()</a></code>, <code><a href="#topic+s2_geog_point">s2_geog_point()</a></code>,
<code><a href="#topic+s2_make_line">s2_make_line()</a></code>, <code><a href="#topic+s2_make_polygon">s2_make_polygon()</a></code> for other ways to
create geography vectors, and <code><a href="#topic+s2_as_binary">s2_as_binary()</a></code> and <code><a href="#topic+s2_as_text">s2_as_text()</a></code>
for other ways to export them.
</p>

<hr>
<h2 id='s2_boundary'>S2 Geography Transformations</h2><span id='topic+s2_boundary'></span><span id='topic+s2_centroid'></span><span id='topic+s2_closest_point'></span><span id='topic+s2_minimum_clearance_line_between'></span><span id='topic+s2_difference'></span><span id='topic+s2_sym_difference'></span><span id='topic+s2_intersection'></span><span id='topic+s2_union'></span><span id='topic+s2_snap_to_grid'></span><span id='topic+s2_simplify'></span><span id='topic+s2_rebuild'></span><span id='topic+s2_buffer_cells'></span><span id='topic+s2_convex_hull'></span><span id='topic+s2_centroid_agg'></span><span id='topic+s2_coverage_union_agg'></span><span id='topic+s2_rebuild_agg'></span><span id='topic+s2_union_agg'></span><span id='topic+s2_convex_hull_agg'></span><span id='topic+s2_point_on_surface'></span>

<h3>Description</h3>

<p>These functions operate on one or more geography vectors and
return a geography vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_boundary(x)

s2_centroid(x)

s2_closest_point(x, y)

s2_minimum_clearance_line_between(x, y)

s2_difference(x, y, options = s2_options())

s2_sym_difference(x, y, options = s2_options())

s2_intersection(x, y, options = s2_options())

s2_union(x, y = NULL, options = s2_options())

s2_snap_to_grid(x, grid_size)

s2_simplify(x, tolerance, radius = s2_earth_radius_meters())

s2_rebuild(x, options = s2_options())

s2_buffer_cells(
  x,
  distance,
  max_cells = 1000,
  min_level = -1,
  radius = s2_earth_radius_meters()
)

s2_convex_hull(x)

s2_centroid_agg(x, na.rm = FALSE)

s2_coverage_union_agg(x, options = s2_options(), na.rm = FALSE)

s2_rebuild_agg(x, options = s2_options(), na.rm = FALSE)

s2_union_agg(x, options = s2_options(), na.rm = FALSE)

s2_convex_hull_agg(x, na.rm = FALSE)

s2_point_on_surface(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_boundary_+3A_x">x</code>, <code id="s2_boundary_+3A_y">y</code></td>
<td>
<p><a href="#topic+as_s2_geography">geography vectors</a>. These inputs
are passed to <code><a href="#topic+as_s2_geography">as_s2_geography()</a></code>, so you can pass other objects
(e.g., character vectors of well-known text) directly.</p>
</td></tr>
<tr><td><code id="s2_boundary_+3A_options">options</code></td>
<td>
<p>An <code><a href="#topic+s2_options">s2_options()</a></code> object describing the polygon/polyline
model to use and the snap level.</p>
</td></tr>
<tr><td><code id="s2_boundary_+3A_grid_size">grid_size</code></td>
<td>
<p>The grid size to which coordinates should be snapped;
will be rounded to the nearest power of 10.</p>
</td></tr>
<tr><td><code id="s2_boundary_+3A_tolerance">tolerance</code></td>
<td>
<p>The minimum distance between vertexes to use when
simplifying a geography.</p>
</td></tr>
<tr><td><code id="s2_boundary_+3A_radius">radius</code></td>
<td>
<p>Radius of the earth. Defaults to the average radius of
the earth in meters as defined by <code><a href="#topic+s2_earth_radius_meters">s2_earth_radius_meters()</a></code>.</p>
</td></tr>
<tr><td><code id="s2_boundary_+3A_distance">distance</code></td>
<td>
<p>The distance to buffer, in units of <code>radius</code>.</p>
</td></tr>
<tr><td><code id="s2_boundary_+3A_max_cells">max_cells</code></td>
<td>
<p>The maximum number of cells to approximate a buffer.</p>
</td></tr>
<tr><td><code id="s2_boundary_+3A_min_level">min_level</code></td>
<td>
<p>The minimum cell level used to approximate a buffer
(1 - 30). Setting this value too high will result in unnecessarily
large geographies, but may help improve buffers along long, narrow
regions.</p>
</td></tr>
<tr><td><code id="s2_boundary_+3A_na.rm">na.rm</code></td>
<td>
<p>For aggregate calculations use <code>na.rm = TRUE</code>
to drop missing values.</p>
</td></tr>
</table>


<h3>Model</h3>

<p>The geometry model indicates whether or not a geometry includes its boundaries.
Boundaries of line geometries are its end points.
OPEN geometries do not contain their boundary (<code>model = "open"</code>); CLOSED
geometries (<code>model = "closed"</code>) contain their boundary; SEMI-OPEN geometries
(<code>model = "semi-open"</code>) contain half of their boundaries, such that when two polygons
do not overlap or two lines do not cross, no point exist that belong to
more than one of the geometries. (This latter form, half-closed, is
not present in the OpenGIS &quot;simple feature access&quot; (SFA) standard nor DE9-IM on
which that is based). The default values for <code><a href="#topic+s2_contains">s2_contains()</a></code> (open)
and covers/covered_by (closed) correspond to the SFA standard specification
of these operators.
</p>


<h3>See Also</h3>

<p>BigQuery's geography function reference:
</p>

<ul>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_boundary">ST_BOUNDARY</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_centroid">ST_CENTROID</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_closestpoint">ST_CLOSESTPOINT</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_difference">ST_DIFFERENCE</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_intersection">ST_INTERSECTION</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_union">ST_UNION</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_snaptogrid">ST_SNAPTOGRID</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_simplify">ST_SIMPLIFY</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_union_agg">ST_UNION_AGG</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#s2_centroid_agg">ST_CENTROID_AGG</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># returns the boundary:
# empty for point, endpoints of a linestring,
# perimeter of a polygon
s2_boundary("POINT (-64 45)")
s2_boundary("LINESTRING (0 0, 10 0)")
s2_boundary("POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))")

# returns the area-weighted centroid, element-wise
s2_centroid("POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))")
s2_centroid("LINESTRING (0 0, 10 0)")

# s2_point_on_surface guarantees a point on surface
# Note: this is not the same as st_point_on_surface
s2_centroid("POLYGON ((0 0, 10 0, 1 1, 0 10, 0 0))")
s2_point_on_surface("POLYGON ((0 0, 10 0, 1 1, 0 10, 0 0))")

# returns the unweighted centroid of the entire input
s2_centroid_agg(c("POINT (0 0)", "POINT (10 0)"))

# returns the closest point on x to y
s2_closest_point(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  "POINT (0 90)" # north pole!
)

# returns the shortest possible line between x and y
s2_minimum_clearance_line_between(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  "POINT (0 90)" # north pole!
)

# binary operations: difference, symmetric difference, intersection and union
s2_difference(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  "POLYGON ((5 5, 15 5, 15 15, 5 15, 5 5))",
  # 32 bit platforms may need to set snap rounding
  s2_options(snap = s2_snap_level(30))
)

s2_sym_difference(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  "POLYGON ((5 5, 15 5, 15 15, 5 15, 5 5))",
  # 32 bit platforms may need to set snap rounding
  s2_options(snap = s2_snap_level(30))
)

s2_intersection(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  "POLYGON ((5 5, 15 5, 15 15, 5 15, 5 5))",
  # 32 bit platforms may need to set snap rounding
  s2_options(snap = s2_snap_level(30))
)

s2_union(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  "POLYGON ((5 5, 15 5, 15 15, 5 15, 5 5))",
  # 32 bit platforms may need to set snap rounding
  s2_options(snap = s2_snap_level(30))
)

# s2_convex_hull_agg builds the convex hull of a list of geometries
s2_convex_hull_agg(
  c(
    "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
    "POLYGON ((5 5, 15 5, 15 15, 5 15, 5 5))"
  )
)

# use s2_union_agg() to aggregate geographies in a vector
s2_coverage_union_agg(
  c(
    "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
    "POLYGON ((5 5, 15 5, 15 15, 5 15, 5 5))"
  ),
  # 32 bit platforms may need to set snap rounding
  s2_options(snap = s2_snap_level(30))
)

# snap to grid rounds coordinates to a specified grid size
s2_snap_to_grid("POINT (0.333333333333 0.666666666666)", 1e-2)


</code></pre>

<hr>
<h2 id='s2_bounds_cap'>Compute feature-wise and aggregate bounds</h2><span id='topic+s2_bounds_cap'></span><span id='topic+s2_bounds_rect'></span>

<h3>Description</h3>

<p><code><a href="#topic+s2_bounds_rect">s2_bounds_rect()</a></code> returns a bounding latitude-longitude
rectangle that contains the region; <code><a href="#topic+s2_bounds_cap">s2_bounds_cap()</a></code> returns a bounding circle
represented by a centre point (lat, lng) and an angle. The bound may not be tight
for points, polylines and geometry collections. The rectangle returned may depend on
the order of points or polylines. <code>lng_lo</code> values larger than <code>lng_hi</code> indicate
regions that span the antimeridian, see the Fiji example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_bounds_cap(x)

s2_bounds_rect(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_bounds_cap_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+s2_geography">s2_geography()</a></code> vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return a <code>data.frame</code>:
</p>

<ul>
<li> <p><code><a href="#topic+s2_bounds_rect">s2_bounds_rect()</a></code>: Columns <code>minlng</code>, <code>minlat</code>, <code>maxlng</code>, <code>maxlat</code> (degrees)
</p>
</li>
<li> <p><code><a href="#topic+s2_bounds_cap">s2_bounds_cap()</a></code>: Columns <code>lng</code>, <code>lat</code>, <code>angle</code> (degrees)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>s2_bounds_cap(s2_data_countries("Antarctica"))
s2_bounds_cap(s2_data_countries("Netherlands"))
s2_bounds_cap(s2_data_countries("Fiji"))

s2_bounds_rect(s2_data_countries("Antarctica"))
s2_bounds_rect(s2_data_countries("Netherlands"))
s2_bounds_rect(s2_data_countries("Fiji"))

</code></pre>

<hr>
<h2 id='s2_cell'>Create S2 Cell vectors</h2><span id='topic+s2_cell'></span><span id='topic+s2_cell_sentinel'></span><span id='topic+s2_cell_invalid'></span><span id='topic+as_s2_cell'></span><span id='topic+as_s2_cell.s2_cell'></span><span id='topic+as_s2_cell.character'></span><span id='topic+as_s2_cell.s2_geography'></span><span id='topic+as_s2_cell.wk_xy'></span><span id='topic+as_s2_cell.integer64'></span><span id='topic+new_s2_cell'></span>

<h3>Description</h3>

<p>The S2 cell indexing system forms the basis for spatial indexing
in the S2 library. On their own, S2 cells can represent points
or areas. As a union, a vector of S2 cells can approximate a
line or polygon. These functions allow direct access to the
S2 cell indexing system and are designed to have minimal overhead
such that looping and recursion have acceptable performance
when used within R code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_cell(x = character())

s2_cell_sentinel()

s2_cell_invalid()

as_s2_cell(x, ...)

## S3 method for class 's2_cell'
as_s2_cell(x, ...)

## S3 method for class 'character'
as_s2_cell(x, ...)

## S3 method for class 's2_geography'
as_s2_cell(x, ...)

## S3 method for class 'wk_xy'
as_s2_cell(x, ...)

## S3 method for class 'integer64'
as_s2_cell(x, ...)

new_s2_cell(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_cell_+3A_x">x</code></td>
<td>
<p>The canonical S2 cell identifier as a character vector.</p>
</td></tr>
<tr><td><code id="s2_cell_+3A_...">...</code></td>
<td>
<p>Passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the hood, S2 cell vectors are represented in R as vectors
of type <code><a href="base.html#topic+double">double()</a></code>. This works because S2 cell identifiers are
64 bits wide, as are <code>double</code>s on all systems where R runs (The
same trick is used by the bit64 package to represent signed
64-bit integers). As a happy accident, <code>NA_real_</code> is not a valid
or meaningful cell identifier, so missing value support in the
way R users might expect is preserved. It is worth noting that
the underlying value of <code>s2_cell_sentinel()</code> would normally be
considered <code>NA</code>; however, as it is meaningful and useful when
programming with S2 cells, custom <code>is.na()</code> and comparison methods
are implemented such that <code>s2_cell_sentinel()</code> is greater than
all valid S2 cells and not considered missing. Users can and should
implement compiled code that uses the underlying bytes of the
vector, ensuring that the class of any returned object that should
be interpreted in this way is constructed with <code>new_s2_cell()</code>.
</p>


<h3>Value</h3>

<p>An object of class s2_cell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s2_cell("4b59a0cd83b5de49")
as_s2_cell(s2_lnglat(-64, 45))
as_s2_cell(s2_data_cities("Ottawa"))

</code></pre>

<hr>
<h2 id='s2_cell_is_valid'>S2 cell operators</h2><span id='topic+s2_cell_is_valid'></span><span id='topic+s2_cell_debug_string'></span><span id='topic+s2_cell_to_lnglat'></span><span id='topic+s2_cell_center'></span><span id='topic+s2_cell_boundary'></span><span id='topic+s2_cell_polygon'></span><span id='topic+s2_cell_vertex'></span><span id='topic+s2_cell_level'></span><span id='topic+s2_cell_is_leaf'></span><span id='topic+s2_cell_is_face'></span><span id='topic+s2_cell_area'></span><span id='topic+s2_cell_area_approx'></span><span id='topic+s2_cell_parent'></span><span id='topic+s2_cell_child'></span><span id='topic+s2_cell_edge_neighbour'></span><span id='topic+s2_cell_contains'></span><span id='topic+s2_cell_distance'></span><span id='topic+s2_cell_max_distance'></span><span id='topic+s2_cell_may_intersect'></span><span id='topic+s2_cell_common_ancestor_level'></span><span id='topic+s2_cell_common_ancestor_level_agg'></span>

<h3>Description</h3>

<p>S2 cell operators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_cell_is_valid(x)

s2_cell_debug_string(x)

s2_cell_to_lnglat(x)

s2_cell_center(x)

s2_cell_boundary(x)

s2_cell_polygon(x)

s2_cell_vertex(x, k)

s2_cell_level(x)

s2_cell_is_leaf(x)

s2_cell_is_face(x)

s2_cell_area(x, radius = s2_earth_radius_meters())

s2_cell_area_approx(x, radius = s2_earth_radius_meters())

s2_cell_parent(x, level = -1L)

s2_cell_child(x, k)

s2_cell_edge_neighbour(x, k)

s2_cell_contains(x, y)

s2_cell_distance(x, y, radius = s2_earth_radius_meters())

s2_cell_max_distance(x, y, radius = s2_earth_radius_meters())

s2_cell_may_intersect(x, y)

s2_cell_common_ancestor_level(x, y)

s2_cell_common_ancestor_level_agg(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_cell_is_valid_+3A_x">x</code>, <code id="s2_cell_is_valid_+3A_y">y</code></td>
<td>
<p>An <code><a href="#topic+s2_cell">s2_cell()</a></code> vector</p>
</td></tr>
<tr><td><code id="s2_cell_is_valid_+3A_k">k</code></td>
<td>
<p>An integer between 0 and 3</p>
</td></tr>
<tr><td><code id="s2_cell_is_valid_+3A_radius">radius</code></td>
<td>
<p>The radius to use (e.g., <code><a href="#topic+s2_earth_radius_meters">s2_earth_radius_meters()</a></code>)</p>
</td></tr>
<tr><td><code id="s2_cell_is_valid_+3A_level">level</code></td>
<td>
<p>An integer between 0 and 30, inclusive.</p>
</td></tr>
<tr><td><code id="s2_cell_is_valid_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NAs prior to computing aggregate?</p>
</td></tr>
</table>

<hr>
<h2 id='s2_cell_union'>Create S2 Cell Union vectors</h2><span id='topic+s2_cell_union'></span><span id='topic+as_s2_geography.s2_cell_union'></span><span id='topic+as_s2_cell_union'></span><span id='topic+as_s2_cell_union.s2_cell_union'></span><span id='topic+as_s2_cell_union.s2_cell'></span><span id='topic+as_s2_cell_union.character'></span>

<h3>Description</h3>

<p>Create S2 Cell Union vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_cell_union(x = list())

## S3 method for class 's2_cell_union'
as_s2_geography(x, ...)

as_s2_cell_union(x, ...)

## S3 method for class 's2_cell_union'
as_s2_cell_union(x, ...)

## S3 method for class 's2_cell'
as_s2_cell_union(x, ...)

## S3 method for class 'character'
as_s2_cell_union(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_cell_union_+3A_x">x</code></td>
<td>
<p>A <code>list()</code> of <code><a href="#topic+s2_cell">s2_cell()</a></code> vectors.</p>
</td></tr>
<tr><td><code id="s2_cell_union_+3A_...">...</code></td>
<td>
<p>Passed to S3 methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;s2_cell_union&quot;.
</p>

<hr>
<h2 id='s2_cell_union_normalize'>S2 cell union operators</h2><span id='topic+s2_cell_union_normalize'></span><span id='topic+s2_cell_union_contains'></span><span id='topic+s2_cell_union_intersects'></span><span id='topic+s2_cell_union_intersection'></span><span id='topic+s2_cell_union_union'></span><span id='topic+s2_cell_union_difference'></span><span id='topic+s2_covering_cell_ids'></span><span id='topic+s2_covering_cell_ids_agg'></span>

<h3>Description</h3>

<p>S2 cell union operators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_cell_union_normalize(x)

s2_cell_union_contains(x, y)

s2_cell_union_intersects(x, y)

s2_cell_union_intersection(x, y)

s2_cell_union_union(x, y)

s2_cell_union_difference(x, y)

s2_covering_cell_ids(
  x,
  min_level = 0,
  max_level = 30,
  max_cells = 8,
  buffer = 0,
  interior = FALSE,
  radius = s2_earth_radius_meters()
)

s2_covering_cell_ids_agg(
  x,
  min_level = 0,
  max_level = 30,
  max_cells = 8,
  buffer = 0,
  interior = FALSE,
  radius = s2_earth_radius_meters(),
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_cell_union_normalize_+3A_x">x</code>, <code id="s2_cell_union_normalize_+3A_y">y</code></td>
<td>
<p>An <a href="#topic+as_s2_geography">s2_geography</a> or <code><a href="#topic+s2_cell_union">s2_cell_union()</a></code>.</p>
</td></tr>
<tr><td><code id="s2_cell_union_normalize_+3A_min_level">min_level</code>, <code id="s2_cell_union_normalize_+3A_max_level">max_level</code></td>
<td>
<p>The minimum and maximum levels to constrain the
covering.</p>
</td></tr>
<tr><td><code id="s2_cell_union_normalize_+3A_max_cells">max_cells</code></td>
<td>
<p>The maximum number of cells in the covering. Defaults to
8.</p>
</td></tr>
<tr><td><code id="s2_cell_union_normalize_+3A_buffer">buffer</code></td>
<td>
<p>A distance to buffer outside the geography</p>
</td></tr>
<tr><td><code id="s2_cell_union_normalize_+3A_interior">interior</code></td>
<td>
<p>Use <code>TRUE</code> to force the covering inside the geography.</p>
</td></tr>
<tr><td><code id="s2_cell_union_normalize_+3A_radius">radius</code></td>
<td>
<p>The radius to use (e.g., <code><a href="#topic+s2_earth_radius_meters">s2_earth_radius_meters()</a></code>)</p>
</td></tr>
<tr><td><code id="s2_cell_union_normalize_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NAs prior to computing aggregate?</p>
</td></tr>
</table>

<hr>
<h2 id='s2_closest_feature'>Matrix Functions</h2><span id='topic+s2_closest_feature'></span><span id='topic+s2_closest_edges'></span><span id='topic+s2_farthest_feature'></span><span id='topic+s2_distance_matrix'></span><span id='topic+s2_max_distance_matrix'></span><span id='topic+s2_contains_matrix'></span><span id='topic+s2_within_matrix'></span><span id='topic+s2_covers_matrix'></span><span id='topic+s2_covered_by_matrix'></span><span id='topic+s2_intersects_matrix'></span><span id='topic+s2_disjoint_matrix'></span><span id='topic+s2_equals_matrix'></span><span id='topic+s2_touches_matrix'></span><span id='topic+s2_dwithin_matrix'></span><span id='topic+s2_may_intersect_matrix'></span>

<h3>Description</h3>

<p>These functions are similar to accessors and predicates, but instead of
recycling <code>x</code> and <code>y</code> to a common length and returning a vector of that
length, these functions return a vector of length <code>x</code> with each element
<code>i</code> containing information about how the entire vector <code>y</code> relates to
the feature at <code>x[i]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_closest_feature(x, y)

s2_closest_edges(
  x,
  y,
  k,
  min_distance = -1,
  max_distance = Inf,
  radius = s2_earth_radius_meters()
)

s2_farthest_feature(x, y)

s2_distance_matrix(x, y, radius = s2_earth_radius_meters())

s2_max_distance_matrix(x, y, radius = s2_earth_radius_meters())

s2_contains_matrix(x, y, options = s2_options(model = "open"))

s2_within_matrix(x, y, options = s2_options(model = "open"))

s2_covers_matrix(x, y, options = s2_options(model = "closed"))

s2_covered_by_matrix(x, y, options = s2_options(model = "closed"))

s2_intersects_matrix(x, y, options = s2_options())

s2_disjoint_matrix(x, y, options = s2_options())

s2_equals_matrix(x, y, options = s2_options())

s2_touches_matrix(x, y, options = s2_options())

s2_dwithin_matrix(x, y, distance, radius = s2_earth_radius_meters())

s2_may_intersect_matrix(x, y, max_edges_per_cell = 50, max_feature_cells = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_closest_feature_+3A_x">x</code>, <code id="s2_closest_feature_+3A_y">y</code></td>
<td>
<p>Geography vectors, coerced using <code><a href="#topic+as_s2_geography">as_s2_geography()</a></code>.
<code>x</code> is considered the source, where as <code>y</code> is considered the target.</p>
</td></tr>
<tr><td><code id="s2_closest_feature_+3A_k">k</code></td>
<td>
<p>The number of closest edges to consider when searching. Note
that in S2 a point is also considered an edge.</p>
</td></tr>
<tr><td><code id="s2_closest_feature_+3A_min_distance">min_distance</code></td>
<td>
<p>The minimum distance to consider when searching for
edges. This filter is applied after the search is complete (i.e.,
may cause fewer than <code>k</code> values to be returned).</p>
</td></tr>
<tr><td><code id="s2_closest_feature_+3A_max_distance">max_distance</code></td>
<td>
<p>The maximum distance to consider when searching for
edges. This filter is applied before the search.</p>
</td></tr>
<tr><td><code id="s2_closest_feature_+3A_radius">radius</code></td>
<td>
<p>Radius of the earth. Defaults to the average radius of
the earth in meters as defined by <code><a href="#topic+s2_earth_radius_meters">s2_earth_radius_meters()</a></code>.</p>
</td></tr>
<tr><td><code id="s2_closest_feature_+3A_options">options</code></td>
<td>
<p>An <code><a href="#topic+s2_options">s2_options()</a></code> object describing the polygon/polyline
model to use and the snap level.</p>
</td></tr>
<tr><td><code id="s2_closest_feature_+3A_distance">distance</code></td>
<td>
<p>A distance on the surface of the earth in the same units
as <code>radius</code>.</p>
</td></tr>
<tr><td><code id="s2_closest_feature_+3A_max_edges_per_cell">max_edges_per_cell</code></td>
<td>
<p>For <code><a href="#topic+s2_may_intersect_matrix">s2_may_intersect_matrix()</a></code>,
this values controls the nature of the index on <code>y</code>, with higher values
leading to coarser index. Values should be between 10 and 50; the default
of 50 is adequate for most use cases, but for specialized operations users
may wish to use a lower value to increase performance.</p>
</td></tr>
<tr><td><code id="s2_closest_feature_+3A_max_feature_cells">max_feature_cells</code></td>
<td>
<p>For <code><a href="#topic+s2_may_intersect_matrix">s2_may_intersect_matrix()</a></code>, this value
controls the approximation of <code>x</code> used to identify potential intersections
on <code>y</code>. The default value of 4 gives the best performance for most operations,
but for specialized operations users may wish to use a higher value to increase
performance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>x</code>.
</p>


<h3>See Also</h3>

<p>See pairwise predicate functions (e.g., <code><a href="#topic+s2_intersects">s2_intersects()</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>city_names &lt;- c("Vatican City", "San Marino", "Luxembourg")
cities &lt;- s2_data_cities(city_names)
country_names &lt;- s2_data_tbl_countries$name
countries &lt;- s2_data_countries()

# closest feature returns y indices of the closest feature
# for each feature in x
country_names[s2_closest_feature(cities, countries)]

# farthest feature returns y indices of the farthest feature
# for each feature in x
country_names[s2_farthest_feature(cities, countries)]

# use s2_closest_edges() to find the k-nearest neighbours
nearest &lt;- s2_closest_edges(cities, cities, k = 2, min_distance = 0)
city_names
city_names[unlist(nearest)]

# predicate matrices
country_names[s2_intersects_matrix(cities, countries)[[1]]]

# distance matrices
s2_distance_matrix(cities, cities)
s2_max_distance_matrix(cities, countries[1:4])

</code></pre>

<hr>
<h2 id='s2_contains'>S2 Geography Predicates</h2><span id='topic+s2_contains'></span><span id='topic+s2_within'></span><span id='topic+s2_covered_by'></span><span id='topic+s2_covers'></span><span id='topic+s2_disjoint'></span><span id='topic+s2_intersects'></span><span id='topic+s2_equals'></span><span id='topic+s2_intersects_box'></span><span id='topic+s2_touches'></span><span id='topic+s2_dwithin'></span><span id='topic+s2_prepared_dwithin'></span>

<h3>Description</h3>

<p>These functions operate two geography vectors (pairwise), and return
a logical vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_contains(x, y, options = s2_options(model = "open"))

s2_within(x, y, options = s2_options(model = "open"))

s2_covered_by(x, y, options = s2_options(model = "closed"))

s2_covers(x, y, options = s2_options(model = "closed"))

s2_disjoint(x, y, options = s2_options())

s2_intersects(x, y, options = s2_options())

s2_equals(x, y, options = s2_options())

s2_intersects_box(
  x,
  lng1,
  lat1,
  lng2,
  lat2,
  detail = 1000,
  options = s2_options()
)

s2_touches(x, y, options = s2_options())

s2_dwithin(x, y, distance, radius = s2_earth_radius_meters())

s2_prepared_dwithin(x, y, distance, radius = s2_earth_radius_meters())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_contains_+3A_x">x</code>, <code id="s2_contains_+3A_y">y</code></td>
<td>
<p><a href="#topic+as_s2_geography">geography vectors</a>. These inputs
are passed to <code><a href="#topic+as_s2_geography">as_s2_geography()</a></code>, so you can pass other objects
(e.g., character vectors of well-known text) directly.</p>
</td></tr>
<tr><td><code id="s2_contains_+3A_options">options</code></td>
<td>
<p>An <code><a href="#topic+s2_options">s2_options()</a></code> object describing the polygon/polyline
model to use and the snap level.</p>
</td></tr>
<tr><td><code id="s2_contains_+3A_lng1">lng1</code>, <code id="s2_contains_+3A_lat1">lat1</code>, <code id="s2_contains_+3A_lng2">lng2</code>, <code id="s2_contains_+3A_lat2">lat2</code></td>
<td>
<p>A latitude/longitude range</p>
</td></tr>
<tr><td><code id="s2_contains_+3A_detail">detail</code></td>
<td>
<p>The number of points with which to approximate
non-geodesic edges.</p>
</td></tr>
<tr><td><code id="s2_contains_+3A_distance">distance</code></td>
<td>
<p>A distance on the surface of the earth in the same units
as <code>radius</code>.</p>
</td></tr>
<tr><td><code id="s2_contains_+3A_radius">radius</code></td>
<td>
<p>Radius of the earth. Defaults to the average radius of
the earth in meters as defined by <code><a href="#topic+s2_earth_radius_meters">s2_earth_radius_meters()</a></code>.</p>
</td></tr>
</table>


<h3>Model</h3>

<p>The geometry model indicates whether or not a geometry includes its boundaries.
Boundaries of line geometries are its end points.
OPEN geometries do not contain their boundary (<code>model = "open"</code>); CLOSED
geometries (<code>model = "closed"</code>) contain their boundary; SEMI-OPEN geometries
(<code>model = "semi-open"</code>) contain half of their boundaries, such that when two polygons
do not overlap or two lines do not cross, no point exist that belong to
more than one of the geometries. (This latter form, half-closed, is
not present in the OpenGIS &quot;simple feature access&quot; (SFA) standard nor DE9-IM on
which that is based). The default values for <code><a href="#topic+s2_contains">s2_contains()</a></code> (open)
and covers/covered_by (closed) correspond to the SFA standard specification
of these operators.
</p>


<h3>See Also</h3>

<p>Matrix versions of these predicates (e.g., <code><a href="#topic+s2_intersects_matrix">s2_intersects_matrix()</a></code>).
</p>
<p>BigQuery's geography function reference:
</p>

<ul>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_contains">ST_CONTAINS</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_coveredby">ST_COVEREDBY</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_covers">ST_COVERS</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_disjoint">ST_DISJOINT</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_equals">ST_EQUALS</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_intersects">ST_INTERSECTS</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_intersectsbox">ST_INTERSECTSBOX</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_touches">ST_TOUCHES</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_within">ST_WITHIN</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_dwithin">ST_DWITHIN</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>s2_contains(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  c("POINT (5 5)", "POINT (-1 1)")
)

s2_within(
  c("POINT (5 5)", "POINT (-1 1)"),
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))"
)

s2_covered_by(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  c("POINT (5 5)", "POINT (-1 1)")
)

s2_covers(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  c("POINT (5 5)", "POINT (-1 1)")
)

s2_disjoint(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  c("POINT (5 5)", "POINT (-1 1)")
)

s2_intersects(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  c("POINT (5 5)", "POINT (-1 1)")
)

s2_equals(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  c(
    "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
    "POLYGON ((10 0, 10 10, 0 10, 0 0, 10 0))",
    "POLYGON ((-1 -1, 10 0, 10 10, 0 10, -1 -1))"
  )
)

s2_intersects(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  c("POINT (5 5)", "POINT (-1 1)")
)

s2_intersects_box(
  c("POINT (5 5)", "POINT (-1 1)"),
  0, 0, 10, 10
)

s2_touches(
  "POLYGON ((0 0, 0 1, 1 1, 0 0))",
  c("POINT (0 0)", "POINT (0.5 0.75)", "POINT (0 0.5)")
)

s2_dwithin(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  c("POINT (5 5)", "POINT (-1 1)"),
  0 # distance in meters
)

s2_dwithin(
  "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))",
  c("POINT (5 5)", "POINT (-1 1)"),
  1e6 # distance in meters
)

</code></pre>

<hr>
<h2 id='s2_data_example_wkt'>Example Geometries</h2><span id='topic+s2_data_example_wkt'></span>

<h3>Description</h3>

<p>These geometries are toy examples useful for testing various coordinate
shuffling operations in the s2 package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_data_example_wkt
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 29.
</p>

<hr>
<h2 id='s2_data_tbl_countries'>Low-resolution world boundaries, timezones, and cities</h2><span id='topic+s2_data_tbl_countries'></span><span id='topic+s2_data_tbl_timezones'></span><span id='topic+s2_data_tbl_cities'></span><span id='topic+s2_data_countries'></span><span id='topic+s2_data_timezones'></span><span id='topic+s2_data_cities'></span>

<h3>Description</h3>

<p>Well-known binary versions of the <a href="https://www.naturalearthdata.com/">Natural Earth</a>
low-resolution world boundaries and timezone boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_data_tbl_countries

s2_data_tbl_timezones

s2_data_tbl_cities

s2_data_countries(name = NULL)

s2_data_timezones(utc_offset_min = NULL, utc_offset_max = utc_offset_min)

s2_data_cities(name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_data_tbl_countries_+3A_name">name</code></td>
<td>
<p>The name of a country, continent, city, or <code>NULL</code>
for all features.</p>
</td></tr>
<tr><td><code id="s2_data_tbl_countries_+3A_utc_offset_min">utc_offset_min</code>, <code id="s2_data_tbl_countries_+3A_utc_offset_max">utc_offset_max</code></td>
<td>
<p>Minimum and/or maximum timezone
offsets.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>A data.frame with columns <code>name</code> (character), and
<code>geometry</code> (wk_wkb)
</p>
<p>An object of class <code>data.frame</code> with 120 rows and 2 columns.
</p>
<p>An object of class <code>data.frame</code> with 243 rows and 3 columns.
</p>


<h3>Source</h3>

<p><a href="https://www.naturalearthdata.com/">Natural Earth Data</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(s2_data_countries())
s2_data_countries("Germany")
s2_data_countries("Europe")

head(s2_data_timezones())
s2_data_timezones(-4)

head(s2_data_cities())
s2_data_cities("Cairo")

</code></pre>

<hr>
<h2 id='s2_earth_radius_meters'>Earth Constants</h2><span id='topic+s2_earth_radius_meters'></span>

<h3>Description</h3>

<p>According to Yoder (1995), the radius of the earth is
6371.01 km. These functions are used to set the
default radis for functions that return a distance
or accept a distance as input
(e.g., <code><a href="#topic+s2_distance">s2_distance()</a></code> and <code><a href="#topic+s2_dwithin">s2_dwithin()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_earth_radius_meters()
</code></pre>


<h3>References</h3>

<p>Yoder, C.F. 1995. &quot;Astrometric and Geodetic Properties of Earth and the
Solar System&quot; in Global Earth Physics, A Handbook of Physical Constants,
AGU Reference Shelf 1, American Geophysical Union, Table 2.
<a href="https://doi.org/10.1029/RF001p0001">doi:10.1029/RF001p0001</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s2_earth_radius_meters()

</code></pre>

<hr>
<h2 id='s2_geog_point'>Create and Format Geography Vectors</h2><span id='topic+s2_geog_point'></span><span id='topic+s2_make_line'></span><span id='topic+s2_make_polygon'></span><span id='topic+s2_geog_from_text'></span><span id='topic+s2_geog_from_wkb'></span><span id='topic+s2_as_text'></span><span id='topic+s2_as_binary'></span><span id='topic+s2_tessellate_tol_default'></span>

<h3>Description</h3>

<p>These functions create and export <a href="#topic+as_s2_geography">geography vectors</a>.
Unlike the BigQuery geography constructors, these functions do not sanitize
invalid or redundant input using <code><a href="#topic+s2_union">s2_union()</a></code>. Note that when creating polygons
using <code><a href="#topic+s2_make_polygon">s2_make_polygon()</a></code>, rings can be open or closed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_geog_point(longitude, latitude)

s2_make_line(longitude, latitude, feature_id = 1L)

s2_make_polygon(
  longitude,
  latitude,
  feature_id = 1L,
  ring_id = 1L,
  oriented = FALSE,
  check = TRUE
)

s2_geog_from_text(
  wkt_string,
  oriented = FALSE,
  check = TRUE,
  planar = FALSE,
  tessellate_tol_m = s2_tessellate_tol_default()
)

s2_geog_from_wkb(
  wkb_bytes,
  oriented = FALSE,
  check = TRUE,
  planar = FALSE,
  tessellate_tol_m = s2_tessellate_tol_default()
)

s2_as_text(
  x,
  precision = 16,
  trim = TRUE,
  planar = FALSE,
  tessellate_tol_m = s2_tessellate_tol_default()
)

s2_as_binary(
  x,
  endian = wk::wk_platform_endian(),
  planar = FALSE,
  tessellate_tol_m = s2_tessellate_tol_default()
)

s2_tessellate_tol_default()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_geog_point_+3A_longitude">longitude</code>, <code id="s2_geog_point_+3A_latitude">latitude</code></td>
<td>
<p>Vectors of latitude and longitude</p>
</td></tr>
<tr><td><code id="s2_geog_point_+3A_feature_id">feature_id</code>, <code id="s2_geog_point_+3A_ring_id">ring_id</code></td>
<td>
<p>Vectors for which a change in
sequential values indicates a new feature or ring. Use <code><a href="base.html#topic+factor">factor()</a></code>
to convert from a character vector.</p>
</td></tr>
<tr><td><code id="s2_geog_point_+3A_oriented">oriented</code></td>
<td>
<p>TRUE if polygon ring directions are known to be correct
(i.e., exterior rings are defined counter clockwise and interior
rings are defined clockwise).</p>
</td></tr>
<tr><td><code id="s2_geog_point_+3A_check">check</code></td>
<td>
<p>Use <code>check = FALSE</code> to skip error on invalid geometries</p>
</td></tr>
<tr><td><code id="s2_geog_point_+3A_wkt_string">wkt_string</code></td>
<td>
<p>Well-known text</p>
</td></tr>
<tr><td><code id="s2_geog_point_+3A_planar">planar</code></td>
<td>
<p>Use <code>TRUE</code> to force planar edges in import or export.</p>
</td></tr>
<tr><td><code id="s2_geog_point_+3A_tessellate_tol_m">tessellate_tol_m</code></td>
<td>
<p>The maximum number of meters to that a point must
be moved to satisfy the planar edge constraint.</p>
</td></tr>
<tr><td><code id="s2_geog_point_+3A_wkb_bytes">wkb_bytes</code></td>
<td>
<p>A <code>list()</code> of <code>raw()</code></p>
</td></tr>
<tr><td><code id="s2_geog_point_+3A_x">x</code></td>
<td>
<p>An object that can be converted to an s2_geography vector</p>
</td></tr>
<tr><td><code id="s2_geog_point_+3A_precision">precision</code></td>
<td>
<p>The number of significant digits to export when
writing well-known text. If <code>trim = FALSE</code>, the number of
digits after the decimal place.</p>
</td></tr>
<tr><td><code id="s2_geog_point_+3A_trim">trim</code></td>
<td>
<p>Should trailing zeroes be included after the decimal place?</p>
</td></tr>
<tr><td><code id="s2_geog_point_+3A_endian">endian</code></td>
<td>
<p>The endian-ness of the well-known binary. See <code><a href="wk.html#topic+deprecated">wk::wkb_translate_wkb()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+as_s2_geography">as_s2_geography()</a></code> for other ways to construct geography vectors.
</p>
<p>BigQuery's geography function reference:
</p>

<ul>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_geogpoint">ST_GEOGPOINT</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_makeline">ST_MAKELINE</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_makepolygon">ST_MAKEPOLYGON</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_geogfromtext">ST_GEOGFROMTEXT</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_geogfromwkb">ST_GEOGFROMWKB</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_astext">ST_ASTEXT</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_asbinary">ST_ASBINARY</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># create point geographies using coordinate values:
s2_geog_point(-64, 45)

# create line geographies using coordinate values:
s2_make_line(c(-64, 8), c(45, 71))

# optionally, separate features using feature_id:
s2_make_line(
  c(-64, 8, -27, -27), c(45, 71, 0, 45),
  feature_id = c(1, 1, 2, 2)
)

# create polygon geographies using coordinate values:
# (rings can be open or closed)
s2_make_polygon(c(-45, 8, 0), c(64, 71, 90))

# optionally, separate rings and/or features using
# ring_id and/or feature_id
s2_make_polygon(
  c(20, 10, 10, 30, 45, 30, 20, 20, 40, 20, 45),
  c(35, 30, 10, 5, 20, 20, 15, 25, 40, 45, 30),
  feature_id = c(rep(1, 8), rep(2, 3)),
  ring_id = c(1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1)
)

# import and export well-known text
(geog &lt;- s2_geog_from_text("POINT (-64 45)"))
s2_as_text(geog)

# import and export well-known binary
(geog &lt;- s2_geog_from_wkb(wk::as_wkb("POINT (-64 45)")))
s2_as_binary(geog)

# import geometry from planar space
s2_geog_from_text(
   "POLYGON ((0 0, 1 0, 0 1, 0 0))",
   planar = TRUE,
   tessellate_tol_m = 1
)

# export geographies into planar space
geog &lt;- s2_make_polygon(c(179, -179, 179), c(10, 10, 11))
s2_as_text(geog, planar = TRUE)

# polygons containing a pole need an extra step
geog &lt;- s2_data_countries("Antarctica")
geom &lt;- s2_as_text(
  s2_intersection(geog, s2_world_plate_carree()),
  planar = TRUE
)

</code></pre>

<hr>
<h2 id='s2_is_collection'>S2 Geography Accessors</h2><span id='topic+s2_is_collection'></span><span id='topic+s2_is_valid'></span><span id='topic+s2_is_valid_detail'></span><span id='topic+s2_dimension'></span><span id='topic+s2_num_points'></span><span id='topic+s2_is_empty'></span><span id='topic+s2_area'></span><span id='topic+s2_length'></span><span id='topic+s2_perimeter'></span><span id='topic+s2_x'></span><span id='topic+s2_y'></span><span id='topic+s2_distance'></span><span id='topic+s2_max_distance'></span>

<h3>Description</h3>

<p>Accessors extract information about <a href="#topic+as_s2_geography">geography vectors</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_is_collection(x)

s2_is_valid(x)

s2_is_valid_detail(x)

s2_dimension(x)

s2_num_points(x)

s2_is_empty(x)

s2_area(x, radius = s2_earth_radius_meters())

s2_length(x, radius = s2_earth_radius_meters())

s2_perimeter(x, radius = s2_earth_radius_meters())

s2_x(x)

s2_y(x)

s2_distance(x, y, radius = s2_earth_radius_meters())

s2_max_distance(x, y, radius = s2_earth_radius_meters())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_is_collection_+3A_x">x</code>, <code id="s2_is_collection_+3A_y">y</code></td>
<td>
<p><a href="#topic+as_s2_geography">geography vectors</a>. These inputs
are passed to <code><a href="#topic+as_s2_geography">as_s2_geography()</a></code>, so you can pass other objects
(e.g., character vectors of well-known text) directly.</p>
</td></tr>
<tr><td><code id="s2_is_collection_+3A_radius">radius</code></td>
<td>
<p>Radius of the earth. Defaults to the average radius of
the earth in meters as defined by <code><a href="#topic+s2_earth_radius_meters">s2_earth_radius_meters()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>BigQuery's geography function reference:
</p>

<ul>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_iscollection">ST_ISCOLLECTION</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_dimension">ST_DIMENSION</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_numpoints">ST_NUMPOINTS</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_isempty">ST_ISEMPTY</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_area">ST_AREA</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_length">ST_LENGTH</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_perimeter">ST_PERIMETER</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_x">ST_X</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_y">ST_Y</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_distance">ST_DISTANCE</a>
</p>
</li>
<li> <p><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_maxdistance">ST_MAXDISTANCE</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># s2_is_collection() tests for multiple geometries in one feature
s2_is_collection(c("POINT (-64 45)", "MULTIPOINT ((-64 45), (8 72))"))

# s2_dimension() returns 0 for point, 1  for line, 2 for polygon
s2_dimension(
  c(
    "GEOMETRYCOLLECTION EMPTY",
    "POINT (-64 45)",
    "LINESTRING (-64 45, 8 72)",
    "POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))",
    "GEOMETRYCOLLECTION (POINT (-64 45), LINESTRING (-64 45, 8 72))"
   )
)

# s2_num_points() counts points
s2_num_points(c("POINT (-64 45)", "LINESTRING (-64 45, 8 72)"))

# s2_is_empty tests for emptiness
s2_is_empty(c("POINT (-64 45)", "POINT EMPTY"))

# calculate area, length, and perimeter
s2_area("POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))")
s2_perimeter("POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))")
s2_length(s2_boundary("POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))"))

# extract x and y coordinates from points
s2_x(c("POINT (-64 45)", "POINT EMPTY"))
s2_y(c("POINT (-64 45)", "POINT EMPTY"))

# calculate minimum and maximum distance between two geometries
s2_distance(
  "POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))",
  "POINT (-64 45)"
)
s2_max_distance(
  "POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))",
  "POINT (-64 45)"
)

</code></pre>

<hr>
<h2 id='s2_lnglat'>Create an S2 LngLat Vector</h2><span id='topic+s2_lnglat'></span><span id='topic+as_s2_lnglat'></span><span id='topic+as_s2_lnglat.default'></span><span id='topic+as_s2_lnglat.wk_xy'></span><span id='topic+as_s2_lnglat.wk_xyz'></span>

<h3>Description</h3>

<p>This class represents a latitude and longitude on the Earth's surface.
Most calculations in S2 convert this to a <code><a href="#topic+as_s2_point">as_s2_point()</a></code>, which is a
unit vector representation of this value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_lnglat(lng, lat)

as_s2_lnglat(x, ...)

## Default S3 method:
as_s2_lnglat(x, ...)

## S3 method for class 'wk_xy'
as_s2_lnglat(x, ...)

## S3 method for class 'wk_xyz'
as_s2_lnglat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_lnglat_+3A_lat">lat</code>, <code id="s2_lnglat_+3A_lng">lng</code></td>
<td>
<p>Vectors of latitude and longitude values in degrees.</p>
</td></tr>
<tr><td><code id="s2_lnglat_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+s2_lnglat">s2_lnglat()</a></code> vector or an object that can be coerced to one.</p>
</td></tr>
<tr><td><code id="s2_lnglat_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class s2_lnglat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s2_lnglat(45, -64) # Halifax, Nova Scotia!
as.data.frame(s2_lnglat(45, -64))

</code></pre>

<hr>
<h2 id='s2_options'>Geography Operation Options</h2><span id='topic+s2_options'></span><span id='topic+s2_snap_identity'></span><span id='topic+s2_snap_level'></span><span id='topic+s2_snap_precision'></span><span id='topic+s2_snap_distance'></span>

<h3>Description</h3>

<p>These functions specify defaults for options used to perform operations
and construct geometries. These are used in predicates (e.g., <code><a href="#topic+s2_intersects">s2_intersects()</a></code>),
and boolean operations (e.g., <code><a href="#topic+s2_intersection">s2_intersection()</a></code>) to specify the model for
containment and how new geometries should be constructed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_options(
  model = NULL,
  snap = s2_snap_identity(),
  snap_radius = -1,
  duplicate_edges = FALSE,
  edge_type = "directed",
  validate = FALSE,
  polyline_type = "path",
  polyline_sibling_pairs = "keep",
  simplify_edge_chains = FALSE,
  split_crossing_edges = FALSE,
  idempotent = FALSE,
  dimensions = c("point", "polyline", "polygon")
)

s2_snap_identity()

s2_snap_level(level)

s2_snap_precision(precision)

s2_snap_distance(distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_options_+3A_model">model</code></td>
<td>
<p>One of 'open', 'semi-open' (default for polygons),
or 'closed' (default for polylines). See section 'Model'</p>
</td></tr>
<tr><td><code id="s2_options_+3A_snap">snap</code></td>
<td>
<p>Use <code>s2_snap_identity()</code>, <code>s2_snap_distance()</code>, <code>s2_snap_level()</code>,
or <code>s2_snap_precision()</code> to specify how or if coordinate rounding should
occur.</p>
</td></tr>
<tr><td><code id="s2_options_+3A_snap_radius">snap_radius</code></td>
<td>
<p>As opposed to the snap function, which specifies
the maximum distance a vertex should move, the snap radius (in radians) sets
the minimum distance between vertices of the output that don't cause vertices
to move more than the distance specified by the snap function. This can be used
to simplify the result of a boolean operation. Use -1 to specify that any
minimum distance is acceptable.</p>
</td></tr>
<tr><td><code id="s2_options_+3A_duplicate_edges">duplicate_edges</code></td>
<td>
<p>Use <code>TRUE</code> to keep duplicate edges (e.g., duplicate
points).</p>
</td></tr>
<tr><td><code id="s2_options_+3A_edge_type">edge_type</code></td>
<td>
<p>One of 'directed' (default) or 'undirected'.</p>
</td></tr>
<tr><td><code id="s2_options_+3A_validate">validate</code></td>
<td>
<p>Use <code>TRUE</code> to validate the result from the builder.</p>
</td></tr>
<tr><td><code id="s2_options_+3A_polyline_type">polyline_type</code></td>
<td>
<p>One of 'path' (default) or 'walk'. If 'walk',
polylines that backtrack are preserved.</p>
</td></tr>
<tr><td><code id="s2_options_+3A_polyline_sibling_pairs">polyline_sibling_pairs</code></td>
<td>
<p>One of 'discard' (default) or 'keep'.</p>
</td></tr>
<tr><td><code id="s2_options_+3A_simplify_edge_chains">simplify_edge_chains</code></td>
<td>
<p>Use <code>TRUE</code> to remove vertices that are within
<code>snap_radius</code> of the original vertex.</p>
</td></tr>
<tr><td><code id="s2_options_+3A_split_crossing_edges">split_crossing_edges</code></td>
<td>
<p>Use <code>TRUE</code> to split crossing polyline edges
when creating geometries.</p>
</td></tr>
<tr><td><code id="s2_options_+3A_idempotent">idempotent</code></td>
<td>
<p>Use <code>FALSE</code> to apply snap even if snapping is not necessary
to satisfy vertex constraints.</p>
</td></tr>
<tr><td><code id="s2_options_+3A_dimensions">dimensions</code></td>
<td>
<p>A combination of 'point', 'polyline', and/or 'polygon'
that can used to constrain the output of <code><a href="#topic+s2_rebuild">s2_rebuild()</a></code> or a
boolean operation.</p>
</td></tr>
<tr><td><code id="s2_options_+3A_level">level</code></td>
<td>
<p>A value from 0 to 30 corresponding to the cell level
at which snapping should occur.</p>
</td></tr>
<tr><td><code id="s2_options_+3A_precision">precision</code></td>
<td>
<p>A number by which coordinates should be multiplied
before being rounded. Rounded to the nearest exponent of 10.</p>
</td></tr>
<tr><td><code id="s2_options_+3A_distance">distance</code></td>
<td>
<p>A distance (in radians) denoting the maximum
distance a vertex should move in the snapping process.</p>
</td></tr>
</table>


<h3>Model</h3>

<p>The geometry model indicates whether or not a geometry includes its boundaries.
Boundaries of line geometries are its end points.
OPEN geometries do not contain their boundary (<code>model = "open"</code>); CLOSED
geometries (<code>model = "closed"</code>) contain their boundary; SEMI-OPEN geometries
(<code>model = "semi-open"</code>) contain half of their boundaries, such that when two polygons
do not overlap or two lines do not cross, no point exist that belong to
more than one of the geometries. (This latter form, half-closed, is
not present in the OpenGIS &quot;simple feature access&quot; (SFA) standard nor DE9-IM on
which that is based). The default values for <code><a href="#topic+s2_contains">s2_contains()</a></code> (open)
and covers/covered_by (closed) correspond to the SFA standard specification
of these operators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use s2_options() to specify containment models, snap level
# layer creation options, and builder options
s2_options(model = "closed", snap = s2_snap_level(30))

</code></pre>

<hr>
<h2 id='s2_plot'>Plot S2 Geographies</h2><span id='topic+s2_plot'></span>

<h3>Description</h3>

<p>Plot S2 Geographies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_plot(
  x,
  ...,
  asp = 1,
  xlab = "",
  ylab = "",
  rule = "evenodd",
  add = FALSE,
  plot_hemisphere = FALSE,
  simplify = TRUE,
  centre = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_plot_+3A_x">x</code></td>
<td>
<p>A <code><a href="wk.html#topic+wkb">wkb()</a></code> or <code><a href="wk.html#topic+wkt">wkt()</a></code></p>
</td></tr>
<tr><td><code id="s2_plot_+3A_...">...</code></td>
<td>
<p>Passed to plotting functions for features: <code><a href="graphics.html#topic+points">graphics::points()</a></code>
for point and multipoint geometries, <code><a href="graphics.html#topic+lines">graphics::lines()</a></code> for linestring
and multilinestring geometries, and <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code> for polygon
and multipolygon geometries.</p>
</td></tr>
<tr><td><code id="s2_plot_+3A_asp">asp</code>, <code id="s2_plot_+3A_xlab">xlab</code>, <code id="s2_plot_+3A_ylab">ylab</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code></p>
</td></tr>
<tr><td><code id="s2_plot_+3A_rule">rule</code></td>
<td>
<p>The rule to use for filling polygons (see <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code>)</p>
</td></tr>
<tr><td><code id="s2_plot_+3A_add">add</code></td>
<td>
<p>Should a new plot be created, or should <code>handleable</code> be added to the
existing plot?</p>
</td></tr>
<tr><td><code id="s2_plot_+3A_plot_hemisphere">plot_hemisphere</code></td>
<td>
<p>Plot the outline of the earth</p>
</td></tr>
<tr><td><code id="s2_plot_+3A_simplify">simplify</code></td>
<td>
<p>Use <code>FALSE</code> to skip the simplification step</p>
</td></tr>
<tr><td><code id="s2_plot_+3A_centre">centre</code></td>
<td>
<p>The longitude/latitude point of the centre of the
orthographic projection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s2_plot(s2_data_countries())
s2_plot(s2_data_cities(), add = TRUE)

</code></pre>

<hr>
<h2 id='s2_point'>Create an S2 Point Vector</h2><span id='topic+s2_point'></span><span id='topic+s2_point_crs'></span><span id='topic+as_s2_point'></span><span id='topic+as_s2_point.default'></span><span id='topic+as_s2_point.wk_xy'></span><span id='topic+as_s2_point.wk_xyz'></span>

<h3>Description</h3>

<p>In S2 terminology, a &quot;point&quot; is a 3-dimensional unit vector representation
of an <code><a href="#topic+s2_point">s2_point()</a></code>. Internally, all s2 objects are stored as
3-dimensional unit vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_point(x, y, z)

s2_point_crs()

as_s2_point(x, ...)

## Default S3 method:
as_s2_point(x, ...)

## S3 method for class 'wk_xy'
as_s2_point(x, ...)

## S3 method for class 'wk_xyz'
as_s2_point(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_point_+3A_x">x</code>, <code id="s2_point_+3A_y">y</code>, <code id="s2_point_+3A_z">z</code></td>
<td>
<p>Vectors of latitude and longitude values in degrees.</p>
</td></tr>
<tr><td><code id="s2_point_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class s2_point
</p>


<h3>Examples</h3>

<pre><code class='language-R'>point &lt;- s2_lnglat(-64, 45) # Halifax, Nova Scotia!
as_s2_point(point)
as.data.frame(as_s2_point(point))

</code></pre>

<hr>
<h2 id='s2_project'>Linear referencing</h2><span id='topic+s2_project'></span><span id='topic+s2_project_normalized'></span><span id='topic+s2_interpolate'></span><span id='topic+s2_interpolate_normalized'></span>

<h3>Description</h3>

<p>Linear referencing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2_project(x, y, radius = s2_earth_radius_meters())

s2_project_normalized(x, y)

s2_interpolate(x, distance, radius = s2_earth_radius_meters())

s2_interpolate_normalized(x, distance_normalized)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_project_+3A_x">x</code></td>
<td>
<p>A simple polyline geography vector</p>
</td></tr>
<tr><td><code id="s2_project_+3A_y">y</code></td>
<td>
<p>A simple point geography vector. The point will be
snapped to the nearest point on <code>x</code> for the purposes of
interpolation.</p>
</td></tr>
<tr><td><code id="s2_project_+3A_radius">radius</code></td>
<td>
<p>Radius of the earth. Defaults to the average radius of
the earth in meters as defined by <code><a href="#topic+s2_earth_radius_meters">s2_earth_radius_meters()</a></code>.</p>
</td></tr>
<tr><td><code id="s2_project_+3A_distance">distance</code></td>
<td>
<p>A distance along <code>x</code> in <code>radius</code> units.</p>
</td></tr>
<tr><td><code id="s2_project_+3A_distance_normalized">distance_normalized</code></td>
<td>
<p>A <code>distance</code> normalized to <code><a href="#topic+s2_length">s2_length()</a></code> of
<code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>s2_interpolate()</code> returns the point on <code>x</code>, <code>distance</code> meters
along the line.
</p>
</li>
<li> <p><code>s2_interpolate_normalized()</code> returns the point on <code>x</code> interpolated
to a fraction along the line.
</p>
</li>
<li> <p><code>s2_project()</code> returns the <code>distance</code> that <code>point</code> occurs along <code>x</code>.
</p>
</li>
<li> <p><code>s2_project_normalized()</code> returns the <code>distance_normalized</code> along <code>x</code>
where <code>point</code> occurs.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>s2_project_normalized("LINESTRING (0 0, 0 90)", "POINT (0 22.5)")
s2_project("LINESTRING (0 0, 0 90)", "POINT (0 22.5)")
s2_interpolate_normalized("LINESTRING (0 0, 0 90)", 0.25)
s2_interpolate("LINESTRING (0 0, 0 90)", 2501890)

</code></pre>

<hr>
<h2 id='s2-package'>s2: Spherical Geometry Operators Using the S2 Geometry Library</h2><span id='topic+s2'></span><span id='topic+s2-package'></span>

<h3>Description</h3>

<p>Provides R bindings for Google's s2 library for geometric calculations on the sphere. High-performance constructors and exporters provide high compatibility with existing spatial packages, transformers construct new geometries from existing geometries, predicates provide a means to select geometries based on spatial relationships, and accessors extract information about geometries.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Edzer Pebesma <a href="mailto:edzer.pebesma@uni-muenster.de">edzer.pebesma@uni-muenster.de</a> (<a href="https://orcid.org/0000-0001-8049-7069">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Dewey Dunnington <a href="mailto:dewey@fishandwhistle.net">dewey@fishandwhistle.net</a> (<a href="https://orcid.org/0000-0002-9415-4582">ORCID</a>)
</p>
</li>
<li><p> Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Jeroen Ooms <a href="mailto:jeroen.ooms@stat.ucla.edu">jeroen.ooms@stat.ucla.edu</a> (configure script) [contributor]
</p>
</li>
<li><p>  Google, Inc. (Original s2geometry.io source code) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://r-spatial.github.io/s2/">https://r-spatial.github.io/s2/</a>
</p>
</li>
<li> <p><a href="https://github.com/r-spatial/s2">https://github.com/r-spatial/s2</a>
</p>
</li>
<li> <p><a href="http://s2geometry.io/">http://s2geometry.io/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-spatial/s2/issues">https://github.com/r-spatial/s2/issues</a>
</p>
</li></ul>


<hr>
<h2 id='wk_handle.s2_geography'>Low-level wk filters and handlers</h2><span id='topic+wk_handle.s2_geography'></span><span id='topic+s2_geography_writer'></span><span id='topic+wk_writer.s2_geography'></span><span id='topic+s2_trans_point'></span><span id='topic+s2_trans_lnglat'></span><span id='topic+s2_projection_plate_carree'></span><span id='topic+s2_projection_mercator'></span><span id='topic+s2_hemisphere'></span><span id='topic+s2_world_plate_carree'></span><span id='topic+s2_projection_orthographic'></span>

<h3>Description</h3>

<p>Low-level wk filters and handlers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 's2_geography'
wk_handle(
  handleable,
  handler,
  ...,
  s2_projection = s2_projection_plate_carree(),
  s2_tessellate_tol = Inf
)

s2_geography_writer(
  oriented = FALSE,
  check = TRUE,
  projection = s2_projection_plate_carree(),
  tessellate_tol = Inf
)

## S3 method for class 's2_geography'
wk_writer(handleable, ...)

s2_trans_point()

s2_trans_lnglat()

s2_projection_plate_carree(x_scale = 180)

s2_projection_mercator(x_scale = 20037508.3427892)

s2_hemisphere(centre)

s2_world_plate_carree(epsilon_east_west = 0, epsilon_north_south = 0)

s2_projection_orthographic(centre = s2_lnglat(0, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wk_handle.s2_geography_+3A_handleable">handleable</code></td>
<td>
<p>A geometry vector (e.g., <code><a href="wk.html#topic+wkb">wkb()</a></code>, <code><a href="wk.html#topic+wkt">wkt()</a></code>, <code><a href="wk.html#topic+xy">xy()</a></code>,
<code><a href="wk.html#topic+rct">rct()</a></code>, or <code><a href="sf.html#topic+sfc">sf::st_sfc()</a></code>) for which <code><a href="wk.html#topic+wk_handle">wk_handle()</a></code> is defined.</p>
</td></tr>
<tr><td><code id="wk_handle.s2_geography_+3A_handler">handler</code></td>
<td>
<p>A <a href="wk.html#topic+wk_handle">wk_handler</a> object.</p>
</td></tr>
<tr><td><code id="wk_handle.s2_geography_+3A_...">...</code></td>
<td>
<p>Passed to the <code><a href="wk.html#topic+wk_handle">wk_handle()</a></code> method.</p>
</td></tr>
<tr><td><code id="wk_handle.s2_geography_+3A_oriented">oriented</code></td>
<td>
<p>TRUE if polygon ring directions are known to be correct
(i.e., exterior rings are defined counter clockwise and interior
rings are defined clockwise).</p>
</td></tr>
<tr><td><code id="wk_handle.s2_geography_+3A_check">check</code></td>
<td>
<p>Use <code>check = FALSE</code> to skip error on invalid geometries</p>
</td></tr>
<tr><td><code id="wk_handle.s2_geography_+3A_projection">projection</code>, <code id="wk_handle.s2_geography_+3A_s2_projection">s2_projection</code></td>
<td>
<p>One of <code><a href="#topic+s2_projection_plate_carree">s2_projection_plate_carree()</a></code> or
<code><a href="#topic+s2_projection_mercator">s2_projection_mercator()</a></code></p>
</td></tr>
<tr><td><code id="wk_handle.s2_geography_+3A_tessellate_tol">tessellate_tol</code>, <code id="wk_handle.s2_geography_+3A_s2_tessellate_tol">s2_tessellate_tol</code></td>
<td>
<p>An angle in radians.
Points will not be added if a line segment is within this
distance of a point.</p>
</td></tr>
<tr><td><code id="wk_handle.s2_geography_+3A_x_scale">x_scale</code></td>
<td>
<p>The maximum x value of the projection</p>
</td></tr>
<tr><td><code id="wk_handle.s2_geography_+3A_centre">centre</code></td>
<td>
<p>The center point of the orthographic projection</p>
</td></tr>
<tr><td><code id="wk_handle.s2_geography_+3A_epsilon_east_west">epsilon_east_west</code>, <code id="wk_handle.s2_geography_+3A_epsilon_north_south">epsilon_north_south</code></td>
<td>
<p>Use a positive number to
define the edges of a Cartesian world slightly inward from -180, -90,
180, 90. This may be used to define a world outline for a projection where
projecting at the extreme edges of the earth results in a non-finite value.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>s2_projection_plate_carree()</code>, <code>s2_projection_mercator()</code>: An external pointer
to an S2 projection.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
