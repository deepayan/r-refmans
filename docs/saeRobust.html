<!DOCTYPE html><html><head><title>Help for package saeRobust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {saeRobust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootstrap'><p>Fit model on Bootstrap sample</p></a></li>
<li><a href='#corSAR1-class'><p>Correlation Structure</p></a></li>
<li><a href='#fitrfh'><p>Fitting Precedures</p></a></li>
<li><a href='#fixedPoint'><p>Fixed Point Algorithm Infrastructure</p></a></li>
<li><a href='#makeXY'><p>makeXY</p></a></li>
<li><a href='#matU'><p>Matrix constructor functions</p></a></li>
<li><a href='#mse'><p>Compute the Mean Squared Error of an Estimator</p></a></li>
<li><a href='#plot.rfh'><p>Plots</p></a></li>
<li><a href='#psiOne'><p>psiOne</p></a></li>
<li><a href='#rfh'><p>Robust Fay Herriot Model</p></a></li>
<li><a href='#score'><p>Compute values of robust score functions</p></a></li>
<li><a href='#testMatX'><p>Construction of test data</p></a></li>
<li><a href='#update,rfh-method'><p>Update a fitted object</p></a></li>
<li><a href='#variance'><p>Construct variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Robust Small Area Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Warnholz [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Warnholz &lt;wahani@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods to fit robust alternatives to commonly used models used in
    Small Area Estimation. The methods here used are based on best linear
    unbiased predictions and linear mixed models. At this time available models
    include area level models incorporating spatial and temporal correlation in
    the random effects.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wahani/saeRobust/issues">https://github.com/wahani/saeRobust/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), methods, aoos</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, ggplot2, Matrix, magrittr, MASS, modules, memoise,
pbapply, Rcpp, spdep</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, sae, saeSim, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Collate:</td>
<td>'NAMESPACE.R' 'RcppExports.R' 'bootstrap.R' 'check.R'
'correlation.R' 'fit.R' 'fixedPoint.R' 'helper.R' 'makeXY.R'
'mat.R' 'matModels.R' 'mse.R' 'plot.R' 'print.R'
'psiFunctions.R' 'rfh.R' 'robustEstimationEquations.R'
'robustObjectiveFunctions.R' 'testData.R' 'update.R'
'variance.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-15 14:08:45 UTC; root</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-15 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootstrap'>Fit model on Bootstrap sample</h2><span id='topic+bootstrap'></span><span id='topic+boot'></span><span id='topic+boot+2CANY+2CANY+2CintegerORnumeric-method'></span><span id='topic+boot+2Crfh+2CrfhVariance+2CNULL-method'></span>

<h3>Description</h3>

<p>These functions help to repeatedly fit a <a href="#topic+rfh">rfh</a> model on bootstrap
samples. Use <code>bootstrap</code> as a user interface. <code>boot</code> can be used to
extend the framework but is not meant to be used interactively. If you are
interested in the parameteric bootstrap for a 'rfh' model you can use the
implementation in <a href="#topic+mse">mse</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(object, matV = variance(object), B = NULL, ...)

boot(object, matV, B, ...)

## S4 method for signature 'ANY,ANY,integerORnumeric'
boot(object, matV, B, filter = NULL, postProcessing = identity, ...)

## S4 method for signature 'rfh,rfhVariance,'NULL''
boot(object, matV, B, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_object">object</code></td>
<td>
<p>a fitted object</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_matv">matV</code></td>
<td>
<p>the variance of a fitted object used to draw samples. In most
cases this is <code>object</code>. Alternatively it may be useful to use a
non-robust model.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_b">B</code></td>
<td>
<p>the number of repetitions</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_...">...</code></td>
<td>
<p>arguments passed down to methods</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_filter">filter</code></td>
<td>
<p>a vector indicating which elements in the fittedd object to
keep in each repetition.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_postprocessing">postProcessing</code></td>
<td>
<p>a function to process the results. Is applied before
the filter.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk, package = "sae")
milk$samplingVar &lt;- milk$SD^2
modelFit &lt;- rfh(yi ~ as.factor(MajorArea), milk, "samplingVar")
bootstrapCoefs &lt;- bootstrap(modelFit, B = 2, filter = "coefficients")
do.call(rbind, unlist(bootstrapCoefs, FALSE))
</code></pre>

<hr>
<h2 id='corSAR1-class'>Correlation Structure</h2><span id='topic+corSAR1-class'></span><span id='topic+corSAR1'></span><span id='topic+corAR1-class'></span><span id='topic+corAR1'></span><span id='topic+corSAR1AR1-class'></span><span id='topic+corSAR1AR1'></span>

<h3>Description</h3>

<p>Various correlation structures. They can be used inside the <a href="#topic+rfh">rfh</a>
function to supply an alterantive variance structure to be fitted. For
examples see the documentation of <a href="#topic+rfh">rfh</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corSAR1(W)

corAR1(nTime)

corSAR1AR1(nTime, W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corSAR1-class_+3A_w">W</code></td>
<td>
<p>the row-standardised proximity matrix</p>
</td></tr>
<tr><td><code id="corSAR1-class_+3A_ntime">nTime</code></td>
<td>
<p>(numeric) number of time periods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>corSAR1</code> can be used to model a simultanous autoregressive
process of order one: spatial correlation.
</p>
<p><code>corAR1</code> can be used to model a autoregressive
process of order one: temporal correlation.
</p>
<p><code>corSAR1AR1</code> can be used to model to model spatial and temporal
correlation
</p>


<h3>Slots</h3>


<dl>
<dt><code>W</code></dt><dd><p>the row-standardised proximity matrix</p>
</dd>
<dt><code>nTime</code></dt><dd><p>(numeric) number of time periods</p>
</dd>
</dl>

<hr>
<h2 id='fitrfh'>Fitting Precedures</h2><span id='topic+fitrfh'></span><span id='topic+fitrsfh'></span><span id='topic+fitrtfh'></span><span id='topic+fitrstfh'></span><span id='topic+fitGenericModel'></span><span id='topic+rfh+2Cnumeric+2CmatrixORMatrix+2Cnumeric+2CNULL-method'></span><span id='topic+rfh+2Cnumeric+2CmatrixORMatrix+2Cnumeric+2CcorSAR1-method'></span><span id='topic+rfh+2Cnumeric+2CmatrixORMatrix+2Cnumeric+2CcorAR1-method'></span><span id='topic+rfh+2Cnumeric+2CmatrixORMatrix+2Cnumeric+2CcorSAR1AR1-method'></span>

<h3>Description</h3>

<p>Several fitting procedures. The arguments can be passed to these functions
using the interface in <a href="#topic+rfh">rfh</a>. The functions here listed are the low
level implementations and are not intended for interactive use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitrfh(y, x, samplingVar, ...)

fitrsfh(y, x, samplingVar, W, x0Var = c(0.01, 1), ...)

fitrtfh(y, x, samplingVar, nTime, x0Var = c(0.01, 1, 1), ...)

fitrstfh(y, x, samplingVar, W, nTime, x0Var = c(0.01, 0.01, 1, 1), ...)

fitGenericModel(
  y,
  x,
  matVFun,
  fixedPointParam,
  k = 1.345,
  K = getK(k),
  x0Coef = NULL,
  x0Var = 1,
  x0Re = NULL,
  tol = 1e-06,
  maxIter = 100,
  maxIterParam = 10,
  maxIterRe = 100,
  convCrit = convCritRelative(tol),
  ...
)

## S4 method for signature 'numeric,matrixORMatrix,numeric,'NULL''
rfh(formula, data, samplingVar, correlation = NULL, ...)

## S4 method for signature 'numeric,matrixORMatrix,numeric,corSAR1'
rfh(formula, data, samplingVar, correlation = NULL, ...)

## S4 method for signature 'numeric,matrixORMatrix,numeric,corAR1'
rfh(formula, data, samplingVar, correlation = NULL, ...)

## S4 method for signature 'numeric,matrixORMatrix,numeric,corSAR1AR1'
rfh(formula, data, samplingVar, correlation = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitrfh_+3A_y">y</code></td>
<td>
<p>(numeric) response vector</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_x">x</code></td>
<td>
<p>([m|M]atrix) the design matrix</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_samplingvar">samplingVar</code></td>
<td>
<p>(numeric) vector with sampling variances</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>fitGenericModel</code></p>
</td></tr>
<tr><td><code id="fitrfh_+3A_w">W</code></td>
<td>
<p>(matrix) proximity matrix</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_x0var">x0Var</code></td>
<td>
<p>(numeric) starting values for variance parameters</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_ntime">nTime</code></td>
<td>
<p>(integer) number of time periods</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_matvfun">matVFun</code></td>
<td>
<p>(function) a function with one argument - the variance
parameters - constructing something like <a href="#topic+variance">variance</a></p>
</td></tr>
<tr><td><code id="fitrfh_+3A_fixedpointparam">fixedPointParam</code></td>
<td>
<p>(function) a function with one argument. The vector of
model parameters. Returns a list of results of the next iteration in the
overall algorithm.</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_k">k</code></td>
<td>
<p>(numeric) tuning constant</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_k">K</code></td>
<td>
<p>(numeric) scaling constant</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_x0coef">x0Coef</code></td>
<td>
<p>(numeric) starting values for regression coefficients</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_x0re">x0Re</code></td>
<td>
<p>(numeric) starting values for random effects</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_tol">tol</code></td>
<td>
<p>(numeric) numerical toloerance to be used during optimisation</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_maxiter">maxIter</code></td>
<td>
<p>(integer) the maximum number of iterations for model parameters.</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_maxiterparam">maxIterParam</code></td>
<td>
<p>(integer) the maximum number of iterations for each
parameter in each overall iteration</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_maxiterre">maxIterRe</code></td>
<td>
<p>(integer) the maximum number of iterations for fitting the
random effects</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_convcrit">convCrit</code></td>
<td>
<p>(function) a function defining the stopping rule</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_formula">formula</code></td>
<td>
<p>(formula) a formula specifying the fixed effects part of the
model.</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_data">data</code></td>
<td>
<p>(data.frame) a data set.</p>
</td></tr>
<tr><td><code id="fitrfh_+3A_correlation">correlation</code></td>
<td>
<p>an optional correlation structure, e.g. <a href="#topic+corSAR1">corSAR1</a>,
for the random effects part of the model. Default is no correlation, i.e. a
random intercept.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitrfh</code> implements the robust Fay-Herriot model; <code>fitrsfh</code> the
spatial, <code>fitrtfh</code> the temporal, and <code>fitrstfh</code> the spatio-temporal
extension to this model type. See <a href="#topic+rfh">rfh</a> how to fit such models.
<code>fitGenericModel</code> is used by all these implementations and can be used
for possible extensions of the framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(milk, package = "sae")
x &lt;- matrix(1, nrow = NROW(milk))
y &lt;- milk$yi
samplingVar &lt;- milk$SD^2
fitrfh(y, x, samplingVar)
</code></pre>

<hr>
<h2 id='fixedPoint'>Fixed Point Algorithm Infrastructure</h2><span id='topic+fixedPoint'></span><span id='topic+addAverageDamp'></span><span id='topic+addConstraintMin'></span><span id='topic+addConstraintMax'></span><span id='topic+convCritAbsolute'></span><span id='topic+convCritRelative'></span><span id='topic+addMaxIter'></span><span id='topic+addCounter'></span><span id='topic+addHistory'></span><span id='topic+addStorage'></span><span id='topic+newtonRaphson'></span><span id='topic+newtonRaphsonFunction'></span>

<h3>Description</h3>

<p>A fixed-point function supplied by the user is iteratively
evaluated. <code>addAverageDamp</code> can be used to add average damping to the
function - this may have a positive effect on the speed of convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixedPoint(fun, x0, convCrit)

addAverageDamp(fun)

addConstraintMin(fun, value)

addConstraintMax(fun, value)

convCritAbsolute(tolerance = 1e-06)

convCritRelative(tolerance = 1e-06)

addMaxIter(fun, maxIter)

addCounter(fun)

addHistory(fun)

addStorage(fun)

newtonRaphson(funList, ...)

newtonRaphsonFunction(funList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixedPoint_+3A_fun">fun</code></td>
<td>
<p>the function to be evaluated in the algorithm</p>
</td></tr>
<tr><td><code id="fixedPoint_+3A_x0">x0</code></td>
<td>
<p>starting value</p>
</td></tr>
<tr><td><code id="fixedPoint_+3A_convcrit">convCrit</code></td>
<td>
<p>a function returning a logical scalar. Is called with two
arguments; the first is the value from iteration n; the second is the value
from iteration n-1</p>
</td></tr>
<tr><td><code id="fixedPoint_+3A_value">value</code></td>
<td>
<p>(numeric)</p>
</td></tr>
<tr><td><code id="fixedPoint_+3A_tolerance">tolerance</code></td>
<td>
<p>a numeric value &gt; 0</p>
</td></tr>
<tr><td><code id="fixedPoint_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="fixedPoint_+3A_funlist">funList</code></td>
<td>
<p>(list) the functions to be evaluated in the algorithm. First
element is typically the score function, second is the derivative of the
score.</p>
</td></tr>
<tr><td><code id="fixedPoint_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+fixedPoint">fixedPoint</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>addAverageDamp</code> adds average damping to an arbitrary fixed point
function.
</p>
<p><code>addConstraintMin</code> takes care that values are not below a
minimum value.
</p>
<p><code>addConstraintMax</code> takes care that values are not larger than
maximum value.
</p>
<p><code>convCritAbsolute</code> absolute difference as convergence criterion.
</p>
<p><code>convCritRelative</code> relative (to previous iteration) absolute
difference as convergence criterion. If value is smaller than 1, absolute
difference is used.
</p>
<p><code>addMaxIter</code> can be used to modify convergence criterion functions.
</p>
<p><code>addCounter</code> can be used to count the number of calls of a function.
</p>
<p><code>addHistory</code> can be used to save a history of results of a
function. The history is stored as a matrix, so this works best if the
return value of <code>fun</code> is numeric.
</p>
<p><code>addStorage</code> will add a storage to a function. The storage is a
list in which each result is stored. The function will coerce the return
value into a numeric.
</p>
<p><code>newtonRaphson</code> finds zeroes of a function. The user can supply
the function and its first derivative. Note that the Newton Raphson
Algorithm is a special case of a fixed point algorithm thus it is
implemented using <code><a href="#topic+fixedPoint">fixedPoint</a></code> and is only a convenience.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
vignette("fixedPoint", "saeRobust")

## End(Not run)
</code></pre>

<hr>
<h2 id='makeXY'>makeXY</h2><span id='topic+makeXY'></span>

<h3>Description</h3>

<p>Extract respone vector and design matrix from data with given
formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeXY(.formula, .data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeXY_+3A_.formula">.formula</code></td>
<td>
<p>(formula)</p>
</td></tr>
<tr><td><code id="makeXY_+3A_.data">.data</code></td>
<td>
<p>(data.frame) data from which design matrix and response to
extract from</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
makeXY(y ~ I(x^2), data.frame(x = rnorm(10), y = rnorm(10)))
</code></pre>

<hr>
<h2 id='matU'>Matrix constructor functions</h2><span id='topic+matU'></span><span id='topic+matTrace'></span><span id='topic+matB'></span><span id='topic+matBConst'></span><span id='topic+matA'></span><span id='topic+matAConst'></span><span id='topic+matW'></span><span id='topic+matWbc'></span><span id='topic+matTZ'></span><span id='topic+matTZ1'></span>

<h3>Description</h3>

<p>These functions construct different parts of matrix components. They are used
internally. If you are interested in the weights of a model fitted using
<a href="#topic+rfh">rfh</a> please try to use <a href="#topic+weights.fitrfh">weights.fitrfh</a> on that object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matU(.V)

matTrace(x)

matB(y, X, beta, re, matV, psi)

matBConst(y, X, beta, matV, psi)

matA(y, X, beta, matV, psi)

matAConst(y, X, matV, psi)

matW(y, X, beta, re, matV, psi)

matWbc(y, reblup, W, samplingVar, c = 1)

matTZ(.nDomains, .nTime)

matTZ1(.nDomains = 10, .nTime = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matU_+3A_.v">.V</code></td>
<td>
<p>(Matrix) variance matrix</p>
</td></tr>
<tr><td><code id="matU_+3A_x">x</code></td>
<td>
<p>([m|M]atrix) a matrix</p>
</td></tr>
<tr><td><code id="matU_+3A_y">y</code></td>
<td>
<p>(numeric) response</p>
</td></tr>
<tr><td><code id="matU_+3A_x">X</code></td>
<td>
<p>(Matrix) design matrix</p>
</td></tr>
<tr><td><code id="matU_+3A_beta">beta</code></td>
<td>
<p>(numeric) vector of regression coefficients</p>
</td></tr>
<tr><td><code id="matU_+3A_re">re</code></td>
<td>
<p>(numeric) vector of random effects</p>
</td></tr>
<tr><td><code id="matU_+3A_matv">matV</code></td>
<td>
<p>(list of functions) see <code>matVFH</code> for an example</p>
</td></tr>
<tr><td><code id="matU_+3A_psi">psi</code></td>
<td>
<p>(function) the influence function</p>
</td></tr>
<tr><td><code id="matU_+3A_reblup">reblup</code></td>
<td>
<p>(numeric) vector with robust best linear unbiased predictions</p>
</td></tr>
<tr><td><code id="matU_+3A_w">W</code></td>
<td>
<p>(Matrix) the weighting matrix</p>
</td></tr>
<tr><td><code id="matU_+3A_samplingvar">samplingVar</code></td>
<td>
<p>(numeric) the vector of sampling variances</p>
</td></tr>
<tr><td><code id="matU_+3A_c">c</code></td>
<td>
<p>(numeric) scalar</p>
</td></tr>
<tr><td><code id="matU_+3A_.ndomains">.nDomains</code></td>
<td>
<p>(integer) number of domains</p>
</td></tr>
<tr><td><code id="matU_+3A_.ntime">.nTime</code></td>
<td>
<p>(integer) number of time periods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>matU</code> computes U. U is the matrix containing only the diagonal
elements of V. This function returns a list of functions which can be
called to compute specific transformations of U.
</p>
<p><code>matTrace</code> computes the trace of a matrix.
</p>
<p><code>matB</code> computes the matrix B which is used to compute the
weights in the pseudo linearised representation of the REBLUP.
</p>
<p><code>matBConst</code> returns a function with one argument, u, to compute
the matrix B. This function is used internally to compute B in the fixed
point algorithm.
</p>
<p><code>matA</code> computes the matrix A which is used to compute the
weights in the pseudo linearized representation of the REBLUP.
</p>
<p><code>matAConst</code> returns a function with one argument, beta, to
compute the matrix A. This function is used internally to compute A in the
fixed point algorithm for beta.
</p>
<p><code>matW</code> returns a matrix containing the weights as they are
defined for the pseudo linear form, such that <code>matW %*% y</code> is the
REBLUP.
</p>
<p><code>matWbc</code> returns a matrix containing the weights as they are
defined for the pseudo linear form, such that <code>matWbc %*% y</code> is the
bias-corrected REBLUP. <code>c</code> is a multiplyer for the standard deviation.
</p>
<p><code>matTZ</code> constructs the Z matrix in a linear mixed model with
autocorrelated random effects.
</p>
<p><code>matTZ1</code> constructs the Z1 matrix in a linear mixed model with
autocorrelated random effects.
</p>


<h3>References</h3>

<p>Warnholz, S. (2016): &quot;Small Area Estimaiton Using Robust Extension to Area
Level Models&quot;. Not published (yet).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("grapes", package = "sae")
data("grapesprox", package = "sae")

fitRFH &lt;- rfh(
  grapehect ~ area + workdays - 1,
  data = grapes,
  samplingVar = "var"
)

matV &lt;- variance(fitRFH)

# matU:
matU(matV$V())$U()
matU(matV$V())$sqrt()
matU(matV$V())$sqrtInv()

# matB (and matA + matW accordingly):
matB(
  fitRFH$y,
  fitRFH$x,
  fitRFH$coefficients,
  fitRFH$re,
  matV,
  function(x) psiOne(x, k = fitRFH$k)
)

matBConst(
  fitRFH$y,
  fitRFH$x,
  fitRFH$coefficients,
  matV,
  function(x) psiOne(x, k = fitRFH$k)
)(fitRFH$re)

# construcors for 'Z' in linear mixed models
matTZ(2, 3)
matTZ1(2, 3)
</code></pre>

<hr>
<h2 id='mse'>Compute the Mean Squared Error of an Estimator</h2><span id='topic+mse'></span><span id='topic+mse.fitrfh'></span>

<h3>Description</h3>

<p>A generic function to compute the mean squared error of the predicted values
under the estimated model. See also <a href="#topic+rfh">rfh</a> for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(object, ...)

## S3 method for class 'fitrfh'
mse(object, type = "pseudo", predType = "reblupbc", B = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mse_+3A_object">object</code></td>
<td>
<p>(see methods) an object containing the estimation result, e.g.
<a href="#topic+rfh">rfh</a></p>
</td></tr>
<tr><td><code id="mse_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
<tr><td><code id="mse_+3A_type">type</code></td>
<td>
<p>(character) the type of the MSE. Available are 'pseudo' and
'boot'</p>
</td></tr>
<tr><td><code id="mse_+3A_predtype">predType</code></td>
<td>
<p>(character) the type of prediction: <code>c("reblup",
"reblupbc")</code></p>
</td></tr>
<tr><td><code id="mse_+3A_b">B</code></td>
<td>
<p>(numeric) number of bootstrap repetitions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Type pseudo is an approximation of the MSE based on a pseudo
linearisation approach by Chambers, et. al. (2011). The specifics can be
found in Warnholz (2016). Type boot implements a parameteric bootstrap for
these methods.
</p>


<h3>References</h3>

<p>Chambers, R., H. Chandra and N. Tzavidis (2011). &quot;On bias-robust mean squared
error estimation for pseudo-linear small area estimators&quot;. In: Survey
Methodology 37 (2), pp. 153–170.
</p>
<p>Warnholz, S. (2016): &quot;Small Area Estimaiton Using Robust Extension to Area
Level Models&quot;. Not published (yet).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("grapes", package = "sae")
data("grapesprox", package = "sae")

fitRFH &lt;- rfh(
  grapehect ~ area + workdays - 1,
  data = grapes,
  samplingVar = "var"
)

mseRFH &lt;- mse(fitRFH)
plot(mseRFH)
</code></pre>

<hr>
<h2 id='plot.rfh'>Plots</h2><span id='topic+plot.rfh'></span><span id='topic+plot.prediction.fitrfh'></span><span id='topic+plot.mse.fitrfh'></span><span id='topic+qqPlot'></span><span id='topic+blandAltmanPlot'></span>

<h3>Description</h3>

<p>Various implementations of diagnostic plots. They are linked together using
the <a href="graphics.html#topic+plot">plot</a> generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rfh'
plot(x, y, ...)

## S3 method for class 'prediction.fitrfh'
plot(x, y, alpha = 0.05, ...)

## S3 method for class 'mse.fitrfh'
plot(x, y = "pseudo", xlim = NULL, ylim = NULL, ...)

qqPlot(sample)

blandAltmanPlot(x, y, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rfh_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="plot.rfh_+3A_y">y</code></td>
<td>
<p>for mse estimates a filter for the predictors; otherwise ignored</p>
</td></tr>
<tr><td><code id="plot.rfh_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="plot.rfh_+3A_alpha">alpha</code></td>
<td>
<p>(numeric) between 0 and 1 - used in computation of confidence
interval</p>
</td></tr>
<tr><td><code id="plot.rfh_+3A_xlim">xlim</code>, <code id="plot.rfh_+3A_ylim">ylim</code></td>
<td>
<p>arguments are passed to <a href="ggplot2.html#topic+coord_cartesian">coord_cartesian</a> and
<a href="ggplot2.html#topic+coord_flip">coord_flip</a>.</p>
</td></tr>
<tr><td><code id="plot.rfh_+3A_sample">sample</code></td>
<td>
<p>(numeric) a vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qqPlot</code> a QQ-Plot using ggplot2
</p>
<p><code>blandAltmanPlot</code> a Bland-Altman plot. Solid line is the mean. Dashed
lines are the upper and lower bound of the limits-of-aggreements: z-quantile
* sd(x - y) &ndash; not the standard error. The alpha level can be set using
<code>alpha</code>. This plot is otherwise known as Tukey's mean-difference plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qqPlot(rnorm(10))
blandAltmanPlot(rnorm(10), rnorm(10))
</code></pre>

<hr>
<h2 id='psiOne'>psiOne</h2><span id='topic+psiOne'></span><span id='topic+getK'></span>

<h3>Description</h3>

<p><code>psiOne</code> is a Huber influence function. <code>getK</code>
function to compute capital K &ndash; used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psiOne(u, k = 1.345, deriv = FALSE)

getK(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psiOne_+3A_u">u</code></td>
<td>
<p>standardized residuals</p>
</td></tr>
<tr><td><code id="psiOne_+3A_k">k</code></td>
<td>
<p>tuning constant</p>
</td></tr>
<tr><td><code id="psiOne_+3A_deriv">deriv</code></td>
<td>
<p>if <code>TRUE</code> returns the derivative</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
u &lt;- rnorm(10)
psiOne(u, k = 1.345, deriv = FALSE)
</code></pre>

<hr>
<h2 id='rfh'>Robust Fay Herriot Model</h2><span id='topic+rfh'></span><span id='topic+rfh+2Cformula+2Cdata.frame+2Ccharacter+2CANY-method'></span><span id='topic+predict.fitrfh'></span>

<h3>Description</h3>

<p>User interface to fit robust Fay-Herriot type models. These models are here
framed as linear mixed models. The parameter estimation is robust against
outliers. Available models are the standard FH model, a spatial extension, a
temporal extension and a spatio-temporal extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfh(formula, data, samplingVar, correlation = NULL, ...)

## S4 method for signature 'formula,data.frame,character,ANY'
rfh(formula, data,
  samplingVar, correlation, ...)

## S3 method for class 'fitrfh'
predict(object, type = "reblup", c = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfh_+3A_formula">formula</code></td>
<td>
<p>(formula) a formula specifying the fixed effects part of the
model.</p>
</td></tr>
<tr><td><code id="rfh_+3A_data">data</code></td>
<td>
<p>(data.frame) a data set.</p>
</td></tr>
<tr><td><code id="rfh_+3A_samplingvar">samplingVar</code></td>
<td>
<p>(character) the name of the variable in <code>data</code>
containing the sampling variances.</p>
</td></tr>
<tr><td><code id="rfh_+3A_correlation">correlation</code></td>
<td>
<p>an optional correlation structure, e.g. <a href="#topic+corSAR1">corSAR1</a>,
for the random effects part of the model. Default is no correlation, i.e. a
random intercept.</p>
</td></tr>
<tr><td><code id="rfh_+3A_...">...</code></td>
<td>
<p>arguments passed <a href="#topic+fitGenericModel">fitGenericModel</a></p>
</td></tr>
<tr><td><code id="rfh_+3A_object">object</code></td>
<td>
<p>(rfh) an object of class rfh</p>
</td></tr>
<tr><td><code id="rfh_+3A_type">type</code></td>
<td>
<p>(character) one or more in <code>c("linear", "reblup", "reblupbc")</code></p>
</td></tr>
<tr><td><code id="rfh_+3A_c">c</code></td>
<td>
<p>(numeric) scalar; a multiplyer constant used in the bias correction.
Default is to make no correction for realisations of direct estimator
within <code>c = 1</code> times the standard deviation of direct estimator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To trigger the spatial and temporal extensions you can supply an argument
<code>correlation</code>. When <code>corSAR1</code> is used the model of Petrucci and
Salvati (2006); for <code>corAR1</code> the model of Rao and Yu (1994) is used; and
for <code>corSAR1AR1</code> the model of Marhuenda et al. (2013).
</p>
<p>The methods introducing the robust framework underpinning this implementation
can be found in Warnholz (2016). They are based on the results by Sinha and
Rao (2009) and Richardson and Welsh (1995).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>call</code> (language) the call generating the value
</p>
</li>
<li> <p><code>formula</code> (formula) the formula passed as argument
</p>
</li>
<li> <p><code>samplingVar</code> (numeric) the vector of sampling variances
</p>
</li>
<li> <p><code>coefficients</code> (numeric) the vector of regression coefficients
</p>
</li>
<li> <p><code>variance</code> (numeric) the vector of fitted variance parameter(s)
</p>
</li>
<li> <p><code>iterations</code> (list) reporting each step in the optimisation
</p>
</li>
<li> <p><code>tol</code> (numeric) the tolerance level used
</p>
</li>
<li> <p><code>maxIter</code> (numeric) maximum overall allowed iterations
</p>
</li>
<li> <p><code>maxIterParam</code> (numeric) maximum allowed iterations for model
parameters in each overall iteration
</p>
</li>
<li> <p><code>maxIterRe</code> (numeric) maximum allowed iterations for fitting the
random effects
</p>
</li>
<li> <p><code>k</code> (numeric) tuning constant in influence function
</p>
</li>
<li> <p><code>K</code> (numeric) additional tuning constant; often derived from
<code>k</code> to scale down the residual variance
</p>
</li>
<li> <p><code>y</code> (numeric) the response vector
</p>
</li>
<li> <p><code>x</code> (Matrix) the design matrix
</p>
</li>
<li> <p><code>re</code> (numeric) the fitted random effects. Can be c(re1, re2)
</p>
</li>
<li> <p><code>reblup</code> (numeric) the robust best linear unbiased prediction
under the fitted model
</p>
</li>
<li> <p><code>residuals</code> (numeric) the realised sampling errors
</p>
</li>
<li> <p><code>fitted</code> (numeric) the fitted values using only the fixed effects
part
</p>
</li></ul>



<h3>References</h3>

<p>Marhuenda, Y., I. Molina and D. Morales (2013). &quot;Small area estimation with
spatio-temporal Fay-Herriot models&quot;. In: Computational Statistics and Data
Analysis 58, pp. 308–325.
</p>
<p>Pratesi, M. and N. Salvati (2008). &quot;Small area estimation: the EBLUP
estimator based on spatially correlated random area effects&quot;. In: Statistical
Methods &amp; Applications 17, pp. 113–141.
</p>
<p>Rao, J. N. K. and M. Yu (1994). &quot;Small-Area Estimation by Combining
Time-Series and Cross-Sectional Data&quot;. In: Canadian Journal of Statistics
22.4, pp. 511–528.
</p>
<p>Richardson, A. M. and A. H. Welsh (1995). &quot;Robust Restricted Maximum
Likelihood in Mixed Linear Models&quot;. In: Biometrics 51 (4), pp. 1429–1439.
</p>
<p>Sinha, S. K. and J. N. K. Rao (2009). &quot;Robust Small Area Estimation&quot;. In: The
Canadian Journal of Statistics 37 (3), pp. 381–399.
</p>
<p>Warnholz, S. (2016): &quot;Small Area Estimaiton Using Robust Extension to Area
Level Models&quot;. Dissertation. https://refubium.fu-berlin.de/handle/fub188/9706.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Non-temporal models:
data("grapes", package = "sae")
data("grapesprox", package = "sae")

fitRFH &lt;- rfh(
  grapehect ~ area + workdays - 1,
  data = grapes,
  samplingVar = "var"
)

fitRFH
summary(fitRFH)

plot(fitRFH)
plot(predict(fitRFH))
plot(mse(fitRFH))

## Not run: 
# And the same including a spatial structure:
fitRSFH &lt;- rfh(
  grapehect ~ area + workdays - 1,
  data = grapes,
  samplingVar = "var",
  corSAR1(as.matrix(grapesprox))
)

# Use the same methods, e.g. plot, for all these implementations:
data("spacetime", package = "sae")
data("spacetimeprox", package = "sae")
nTime &lt;- length(unique(spacetime$Time))

fitRTFH &lt;- rfh(
  Y ~ X1 + X2,
  spacetime,
  "Var",
  corAR1(nTime = nTime)
)

fitRSTFH &lt;- rfh(
  Y ~ X1 + X2,
  spacetime,
  "Var",
  corSAR1AR1(W = as.matrix(spacetimeprox), nTime = nTime)
)

## End(Not run)
</code></pre>

<hr>
<h2 id='score'>Compute values of robust score functions</h2><span id='topic+score'></span>

<h3>Description</h3>

<p>Can be used to compute the values of the robust estimation equations at their
'solution'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score(object, filter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_+3A_object">object</code></td>
<td>
<p>a fitted object</p>
</td></tr>
<tr><td><code id="score_+3A_filter">filter</code></td>
<td>
<p>(character) a selection of values to be computed</p>
</td></tr>
<tr><td><code id="score_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("grapes", package = "sae")

fitRFH &lt;- rfh(
  grapehect ~ area + workdays - 1,
  data = grapes,
  samplingVar = "var"
)

score(fitRFH)
</code></pre>

<hr>
<h2 id='testMatX'>Construction of test data</h2><span id='topic+testMatX'></span><span id='topic+testResponse0'></span><span id='topic+testResponse'></span><span id='topic+testRook'></span>

<h3>Description</h3>

<p>Construction of test data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testMatX(...)

testResponse0(x, beta = rep(1, ncol(x)))

testResponse(y0, k = 1:4, .sd = sd(y0))

testRook(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testMatX_+3A_...">...</code></td>
<td>
<p>matrices</p>
</td></tr>
<tr><td><code id="testMatX_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="testMatX_+3A_beta">beta</code></td>
<td>
<p>a vector with parameters</p>
</td></tr>
<tr><td><code id="testMatX_+3A_y0">y0</code></td>
<td>
<p>a response vector (numeric)</p>
</td></tr>
<tr><td><code id="testMatX_+3A_k">k</code></td>
<td>
<p>values in 1 to 4 (integer)</p>
</td></tr>
<tr><td><code id="testMatX_+3A_.sd">.sd</code></td>
<td>
<p>the standard deviation used for random numbers</p>
</td></tr>
<tr><td><code id="testMatX_+3A_n">n</code></td>
<td>
<p>dimension</p>
</td></tr>
</table>


<h3>References</h3>

<p>Weihs / Mersmann / Ligges (2014): Foundations of Statistical
Algorithms: With References to R Packages
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples from Weihs et. al. (2014) p. 108
library("Matrix")
testMatX(Matrix(998), Matrix(998))
Z &lt;- Matrix(c(998, 0, 0, 0), 2, 2)
testMatX(Z, Z)
testResponse0(testMatX(Matrix(1)))
library("magrittr")
Matrix(1) %&gt;% testMatX %&gt;% testResponse0 %&gt;% testResponse
</code></pre>

<hr>
<h2 id='update+2Crfh-method'>Update a fitted object</h2><span id='topic+update+2Crfh-method'></span><span id='topic+update+2Cfitrfh-method'></span>

<h3>Description</h3>

<p>This is a method which can be used to update a <a href="#topic+rfh">rfh</a> result object and
refit it. The fitted parameter values from the current object are used as
starting values, then <a href="stats.html#topic+update.default">update.default</a> is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'rfh'
update(object, formula, ..., where = parent.frame(2))

## S4 method for signature 'fitrfh'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update+2B2Crfh-method_+3A_object">object</code></td>
<td>
<p>(rfh) an object fitted by <a href="#topic+rfh">rfh</a></p>
</td></tr>
<tr><td><code id="update+2B2Crfh-method_+3A_formula">formula</code></td>
<td>
<p>see <a href="stats.html#topic+update.formula">update.formula</a></p>
</td></tr>
<tr><td><code id="update+2B2Crfh-method_+3A_...">...</code></td>
<td>
<p>arguments passed to <a href="stats.html#topic+update.default">update.default</a></p>
</td></tr>
<tr><td><code id="update+2B2Crfh-method_+3A_where">where</code></td>
<td>
<p>(environment) should not be specified by the user</p>
</td></tr>
</table>

<hr>
<h2 id='variance'>Construct variance</h2><span id='topic+variance'></span><span id='topic+variance.fitrfh'></span><span id='topic+variance.fitrsfh'></span><span id='topic+variance.fitrtfh'></span><span id='topic+variance.fitrstfh'></span><span id='topic+weights.fitrfh'></span>

<h3>Description</h3>

<p>A generic function to construct the different variance components of an
object. You may want to use this in conjunction with <a href="#topic+bootstrap">bootstrap</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance(.object, ...)

## S3 method for class 'fitrfh'
variance(.object, ...)

## S3 method for class 'fitrsfh'
variance(.object, ...)

## S3 method for class 'fitrtfh'
variance(.object, ...)

## S3 method for class 'fitrstfh'
variance(.object, ...)

## S3 method for class 'fitrfh'
weights(object, c = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variance_+3A_.object">.object</code>, <code id="variance_+3A_object">object</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="variance_+3A_...">...</code></td>
<td>
<p>arguments passed to method</p>
</td></tr>
<tr><td><code id="variance_+3A_c">c</code></td>
<td>
<p>(numeric) scalar</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("grapes", package = "sae")
data("grapesprox", package = "sae")

fitRFH &lt;- rfh(
  grapehect ~ area + workdays - 1,
  data = grapes,
  samplingVar = "var"
)

# The variance component of a mixed linear model:
matV &lt;- variance(fitRFH)
# The full variance matrix:
matV$V()

# The sampling error component
matV$Ve()

# the random effects component
matV$Vu()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
