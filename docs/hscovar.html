<!DOCTYPE html><html><head><title>Help for package hscovar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hscovar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AR1'><p>Correlation matrix of an autoregressive model of order 1</p></a></li>
<li><a href='#calcvar'><p>Variance of estimator</p></a></li>
<li><a href='#coeff.beta.k'><p>Ratio of expected value to variance of estimator</p></a></li>
<li><a href='#CovarMatrix'><p>Calculation of covariance matrices from maternal and paternal LD</p></a></li>
<li><a href='#CovMat'><p>Calculation of covariance or correlation matrix</p></a></li>
<li><a href='#ExpectMat'><p>Expected value of paternally inherited allele</p></a></li>
<li><a href='#H.sire'><p>testdata: sire haplotypes</p></a></li>
<li><a href='#Haplo2Geno'><p>Conversion of haplotypes into genotypes</p></a></li>
<li><a href='#LDdam'><p>Calculation of maternal LD matrix</p></a></li>
<li><a href='#LDsire'><p>Calculation of paternal LD matrix</p></a></li>
<li><a href='#matLD'><p>testdata: maternal linkage disequilibrium</p></a></li>
<li><a href='#pos.chr'><p>testdata: genetic map positions</p></a></li>
<li><a href='#pwr.normtest'><p>Probability under alternative hypothesis (power)</p></a></li>
<li><a href='#pwr.snpblup'><p>Wrapper function for sample size calculation</p></a></li>
<li><a href='#search.best.n.bisection'><p>Method of bisection for estimating optimal sample size</p></a></li>
<li><a href='#simpleM'><p>Calculation of effective number of independent tests</p></a></li>
<li><a href='#startvalue'><p>Start value for estimating optimal sample size</p></a></li>
<li><a href='#tagSNP'><p>tagSNP</p></a></li>
<li><a href='#testdata'><p>Description of the testdata</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculation of Covariance Between Markers for Half-Sib Families</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-13</td>
</tr>
<tr>
<td>Description:</td>
<td>The theoretical covariance between pairs of markers is calculated
    from either paternal haplotypes and maternal linkage disequilibrium (LD) or 
    vise versa. A genetic map is required. Grouping of markers is based on the 
    correlation matrix and a representative marker is suggested for each group.
    Employing the correlation matrix, optimal sample size can be derived for 
    association studies based on a SNP-BLUP approach.
    The implementation relies on paternal half-sib families and biallelic 
    markers. If maternal half-sib families are used, the roles of sire/dam are 
    swapped. Multiple families can be considered.
    Wittenburg, Bonk, Doschoris, Reyer (2020) "Design of Experiments for 
    Fine-Mapping Quantitative Trait Loci in Livestock Populations" 
    &lt;<a href="https://doi.org/10.1186%2Fs12863-020-00871-1">doi:10.1186/s12863-020-00871-1</a>&gt;.
    Carlson, Eberle, Rieder, Yi, Kruglyak, Nickerson (2004) "Selecting a 
    maximally informative set of single-nucleotide polymorphisms for association
    analyses using linkage disequilibrium" &lt;<a href="https://doi.org/10.1086%2F381000">doi:10.1086/381000</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, Matrix, foreach, rlist, pwr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-13 06:30:46 UTC; wittenburg</td>
</tr>
<tr>
<td>Author:</td>
<td>Dörte Wittenburg [aut, cre],
  Michael Doschoris [aut],
  Jan Klosa [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dörte Wittenburg &lt;wittenburg@fbn-dummerstorf.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-13 07:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='AR1'>Correlation matrix of an autoregressive model of order 1</h2><span id='topic+AR1'></span>

<h3>Description</h3>

<p>An order-1 autoregressive correlation matrix is set up which is
used for the examples on power and sample size calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AR1(p, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AR1_+3A_p">p</code></td>
<td>
<p>dimension</p>
</td></tr>
<tr><td><code id="AR1_+3A_rho">rho</code></td>
<td>
<p>correlation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(p x p) matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  AR1(10, 0.2)
</code></pre>

<hr>
<h2 id='calcvar'>Variance of estimator</h2><span id='topic+calcvar'></span>

<h3>Description</h3>

<p>Calculation of variance of estimator and residual degrees of
freedom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcvar(lambda, eigendec, n, weights = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcvar_+3A_lambda">lambda</code></td>
<td>
<p>shrinkage parameter</p>
</td></tr>
<tr><td><code id="calcvar_+3A_eigendec">eigendec</code></td>
<td>
<p>eigenvalue decomposition of (p x p) correlation matrix
<code>R</code></p>
</td></tr>
<tr><td><code id="calcvar_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="calcvar_+3A_weights">weights</code></td>
<td>
<p>vector (LEN p) of SNP-specific weights or scalar if weights
are equal for all SNPs; default value 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance of estimator beta (regression coefficient of SNP-BLUP
approach) and the residual degrees of freedom are calculated based on the
eigenvalue decomposition of correlation matrix <code>R</code>
</p>


<h3>Value</h3>


<dl>
<dt><code>df</code></dt><dd><p>residual degrees of freedom</p>
</dd>
<dt><code>var.beta</code></dt><dd><p>vector (LEN p) of variance of estimator beta up to a
constant (i.e. residual variance / n)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  ### correlation matrix (should depend on sire haplotypes)
  R &lt;- AR1(100, rho = 0.1)
  eigendec &lt;- eigen(R)
  out &lt;- calcvar(1200, eigendec, 100)
</code></pre>

<hr>
<h2 id='coeff.beta.k'>Ratio of expected value to variance of estimator</h2><span id='topic+coeff.beta.k'></span>

<h3>Description</h3>

<p>The ratio of expected value to standard deviation is calculated
for the estimator of a selected regression coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeff.beta.k(k, beta.true, lambda, eigendec, n, weights = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coeff.beta.k_+3A_k">k</code></td>
<td>
<p>index of selected regression coefficient</p>
</td></tr>
<tr><td><code id="coeff.beta.k_+3A_beta.true">beta.true</code></td>
<td>
<p>(LEN p) vector of regression coefficients</p>
</td></tr>
<tr><td><code id="coeff.beta.k_+3A_lambda">lambda</code></td>
<td>
<p>shrinkage parameter</p>
</td></tr>
<tr><td><code id="coeff.beta.k_+3A_eigendec">eigendec</code></td>
<td>
<p>eigenvalue decomposition of (p x p) correlation matrix
<code>R</code></p>
</td></tr>
<tr><td><code id="coeff.beta.k_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="coeff.beta.k_+3A_weights">weights</code></td>
<td>
<p>vector (LEN p) of SNP-specific weights or scalar if weights
are equal for all SNPs; default value 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ratio
</p>

<hr>
<h2 id='CovarMatrix'>Calculation of covariance matrices from maternal and paternal LD</h2><span id='topic+CovarMatrix'></span>

<h3>Description</h3>

<p>The covariance matrix is set as maternal plus paternal LD
matrix where the paternal part is a weighted average of sire-specific LD
matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovarMatrix(exp_freq_mat, LDDam, LDSire, Ns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovarMatrix_+3A_exp_freq_mat">exp_freq_mat</code></td>
<td>
<p>[MATRIX] paternal EXPECTATION matrix</p>
</td></tr>
<tr><td><code id="CovarMatrix_+3A_lddam">LDDam</code></td>
<td>
<p>[MATRIX] maternal Linkage Disequilibrium matrix</p>
</td></tr>
<tr><td><code id="CovarMatrix_+3A_ldsire">LDSire</code></td>
<td>
<p>[LIST] Linkage disequilibrium matrices for the sires; each
element of the list corresponds to a family</p>
</td></tr>
<tr><td><code id="CovarMatrix_+3A_ns">Ns</code></td>
<td>
<p>[VECTOR] family size for each sire s</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internal suMM function works on lists!
</p>


<h3>Value</h3>


<dl>
<dt><code>covK</code></dt><dd><p>(p x p) matrix of covariance between markers</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'> data(testdata)
 G &lt;- Haplo2Geno(H.sire)
 E &lt;- ExpectMat(G)
 LDfam2 &lt;- LDsire(H.sire, pos.chr, family = 3:4)
 LDfam3 &lt;- LDsire(H.sire, pos.chr, family = 5:6)
 ## covariance matrix based on sires 2 and 3 only, each with 100 progeny
 K &lt;- CovarMatrix(E[2:3, ], LDDam = matLD, LDSire = list(LDfam2, LDfam3), Ns = c(100, 100))
</code></pre>

<hr>
<h2 id='CovMat'>Calculation of covariance or correlation matrix</h2><span id='topic+CovMat'></span>

<h3>Description</h3>

<p>The theoretical covariance between pairs of markers is
calculated from either paternal haplotypes and maternal linkage
disequilibrium (LD) or vise versa. A genetic map is required. The
implementation relies on paternal half-sib families and biallelic markers
such as single nucleotide polymorphisms (SNP). If parental haplotypes are
incomplete (i.e., SNP alleles are missing), those parents will be discarded
at the corresponding pairs of SNPs. If maternal half-sib families are used,
the roles of sire/dam are swapped. Multiple families can be considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovMat(linkMat, haploMat, nfam, pos_chr, map_fun = "haldane", corr = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovMat_+3A_linkmat">linkMat</code></td>
<td>
<p>(p x p) matrix of maternal LD between pairs of p markers;
matrix is block diagonal in case of multiple chromosomes and must not
contain missing values; use zeros if LD is uncertain</p>
</td></tr>
<tr><td><code id="CovMat_+3A_haplomat">haploMat</code></td>
<td>
<p>(2N x p) matrix of sires haplotypes for all chromosomes
(2 lines per sire); coding with 0's and 1's reflecting reference and
alternate alleles, respectively; missing values can be coded as NA or any
integer but not 0 and 1</p>
</td></tr>
<tr><td><code id="CovMat_+3A_nfam">nfam</code></td>
<td>
<p>vector (LEN N) containing number of progeny per family or
scalar value in case of equal family size</p>
</td></tr>
<tr><td><code id="CovMat_+3A_pos_chr">pos_chr</code></td>
<td>
<p>list (LEN number of chromosomes) of vectors (LEN number of
markers) of genetic positions in Morgan per chromosome</p>
</td></tr>
<tr><td><code id="CovMat_+3A_map_fun">map_fun</code></td>
<td>
<p>character string of mapping function used; so far &quot;haldane&quot;
(default) and &quot;kosambi&quot; are enabled</p>
</td></tr>
<tr><td><code id="CovMat_+3A_corr">corr</code></td>
<td>
<p>logical; <code>FALSE</code> (default) if output is covariance matrix or
<code>TRUE</code> if output is correlation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list (LEN 2) of matrix (DIM <code class="reqn">p1</code> x <code class="reqn">p1</code>) and vector
(LEN <code class="reqn">p1</code>) with <code class="reqn">p1 \le p</code>
</p>

<dl>
<dt><code>K</code></dt><dd><p>covariance matrix OR</p>
</dd>
<dt><code>R</code></dt><dd><p>correlation matrix</p>
</dd>
<dt><code>valid.snps</code></dt><dd><p>vector of SNP indices considered for covariance/
correlation matrix</p>
</dd>
</dl>



<h3>Note</h3>

<p>Family size is used for weighting covariance terms in case of multiple
half-sib families. It only matters if number of progeny differs.
</p>
<p>If maternal haplotypes (H.mothers) are used instead of maternal LD (matLD),
LD can be estimated from counting haplotype frequencies as:
</p>
<p><code>matLD &lt;- LDdam(inMat = H.mother, pos.chr)</code>
</p>
<p>If multiple chromosomes are considered, SNP positions are provided as, e.g.
</p>
<p><code>pos.chr &lt;- list(pos.snp.chr1, pos.snp.chr2, pos.snp.chr3)</code>
</p>


<h3>References</h3>

<p>Wittenburg, Bonk, Doschoris, Reyer (2020) Design of Experiments
for Fine-Mapping Quantitative Trait Loci in Livestock Populations. BMC
Genetics 21:66. doi: <a href="https://doi.org/10.1186/s12863-020-00871-1">10.1186/s12863-020-00871-1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### 1: INPUT DATA
  data(testdata)
  ### 2: COVARIANCE/CORRELATION MATRIX
  corrmat &lt;- CovMat(matLD, H.sire, 100, pos.chr, corr = TRUE)
  ### 3: TAGSNPS FROM CORRELATION MATRIX
  bin &lt;- tagSNP(corrmat$R)
  bin &lt;- tagSNP(corrmat$R, 0.5)
</code></pre>

<hr>
<h2 id='ExpectMat'>Expected value of paternally inherited allele</h2><span id='topic+ExpectMat'></span>

<h3>Description</h3>

<p>Expected value is +/-0.5 if sire is homozygous reference/
alternate allele or 0 if sire is heterozygous at the investigated marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpectMat(inMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpectMat_+3A_inmat">inMat</code></td>
<td>
<p>[MATRIX] The paternal genotype matrix</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>ExP.Fa</code></dt><dd><p>(N x p) matrix of expected values</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'> data(testdata)
 G &lt;- Haplo2Geno(H.sire)
 E &lt;- ExpectMat(G)
</code></pre>

<hr>
<h2 id='H.sire'>testdata: sire haplotypes</h2><span id='topic+H.sire'></span>

<h3>Description</h3>

<p>(2N x p) matrix of sire haplotypes for all chromosomes (2 lines
per sire); unknown alleles are marked as 9
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H.sire
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 10 rows and 300 columns.
</p>

<hr>
<h2 id='Haplo2Geno'>Conversion of haplotypes into genotypes</h2><span id='topic+Haplo2Geno'></span>

<h3>Description</h3>

<p>Haplotypes are converted into into genotypes without checking
for missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Haplo2Geno(inpMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Haplo2Geno_+3A_inpmat">inpMat</code></td>
<td>
<p>[MATRIX] haplotype matrix (2 lines per individual)</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>outMa</code></dt><dd><p>(N x p) genotype matrix</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'> data(testdata)
 G &lt;- Haplo2Geno(H.sire)
</code></pre>

<hr>
<h2 id='LDdam'>Calculation of maternal LD matrix</h2><span id='topic+LDdam'></span>

<h3>Description</h3>

<p>Matrix containing linkage disequilibrium between marker pairs
on maternal gametes is set up by counting haplotypes frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDdam(inMat, pos_chr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDdam_+3A_inmat">inMat</code></td>
<td>
<p>[MATRIX] The maternal HAPLOTYPE matrix.</p>
</td></tr>
<tr><td><code id="LDdam_+3A_pos_chr">pos_chr</code></td>
<td>
<p>[LIST] The marker positions in Morgan on chromosomes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a block diagonal sparse matrix based on
Matrix::bdiag. Use as.matrix() to obtain a regular one.
</p>


<h3>Value</h3>


<dl>
<dt><code>Dd</code></dt><dd><p>(p x p) matrix of maternal LD</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'> ## haplotype matrix of n individuals at p SNPs
 p &lt;- 10; n &lt;- 4
 mat &lt;- matrix(ncol = p, nrow = 2 * n, sample(c(0, 1), size = 2 * n * p, replace = TRUE))
 LDdam(mat, list(1:p))
</code></pre>

<hr>
<h2 id='LDsire'>Calculation of paternal LD matrix</h2><span id='topic+LDsire'></span>

<h3>Description</h3>

<p>Matrix containing linkage disequilibrium between marker pairs
on paternal gametes is set up from sire haplotypes and genetic-map
information for each half-sib family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDsire(inMat, pos_chr, family, map_fun = "haldane")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDsire_+3A_inmat">inMat</code></td>
<td>
<p>[MATRIX] Haplotype matrix for sires for all chromosomes.</p>
</td></tr>
<tr><td><code id="LDsire_+3A_pos_chr">pos_chr</code></td>
<td>
<p>[LIST] The marker positions in Morgan on chromosomes.</p>
</td></tr>
<tr><td><code id="LDsire_+3A_family">family</code></td>
<td>
<p>[VECTOR] Which family (sire) should be processed?
Vector with consecutive entries of the form 1:2, 3:4, 5:6 and so on,
linking to haplotypes (rows in inMat) of the corresponding sire</p>
</td></tr>
<tr><td><code id="LDsire_+3A_map_fun">map_fun</code></td>
<td>
<p>[&quot;haldane&quot; or &quot;kosambi&quot;] The mapping function applied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a block diagonal sparse matrix based on
Matrix::bdiag. Use as.matrix() to obtain a regular one.
</p>


<h3>Value</h3>

<p>Ds
</p>

<dl>
<dt><code>Ds</code></dt><dd><p>(p x p) matrix of paternal LD</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'> data(testdata)
 LDfam2 &lt;- LDsire(H.sire, pos.chr, family = 3:4)
</code></pre>

<hr>
<h2 id='matLD'>testdata: maternal linkage disequilibrium</h2><span id='topic+matLD'></span>

<h3>Description</h3>

<p>(p x p) matrix of maternal LD between pairs of p markers;
matrix is block diagonal in case of multiple chromosomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matLD
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 300 rows and 300 columns.
</p>

<hr>
<h2 id='pos.chr'>testdata: genetic map positions</h2><span id='topic+pos.chr'></span>

<h3>Description</h3>

<p>list of vectors of genetic map positions per chromosome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pos.chr
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>

<hr>
<h2 id='pwr.normtest'>Probability under alternative hypothesis (power)</h2><span id='topic+pwr.normtest'></span>

<h3>Description</h3>

<p>Calculation of power is based on normal distribution.
At each selected QTL position, the probability of the corresponding
regression coefficient being different from zero is calculated using a
t-like test statistic which has normal distribution with mean
<code>E(beta_k)/sqrt{Var(beta_k)}</code>
and variance 1. Under the null hypothesis <code>beta_k = 0</code>,
<code>E(beta_k) = 0</code>.
Then, the mean value is returned as power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwr.normtest(R, n, betaSE, lambda, pos, weights = 1, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwr.normtest_+3A_r">R</code></td>
<td>
<p>(p x p) matrix containing theoretical correlation between SNP pairs</p>
</td></tr>
<tr><td><code id="pwr.normtest_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="pwr.normtest_+3A_betase">betaSE</code></td>
<td>
<p>effect size relative to residual standard deviation</p>
</td></tr>
<tr><td><code id="pwr.normtest_+3A_lambda">lambda</code></td>
<td>
<p>shrinkage parameter</p>
</td></tr>
<tr><td><code id="pwr.normtest_+3A_pos">pos</code></td>
<td>
<p>vector (LEN nqtl) of SNP indices for assumed QTL positions</p>
</td></tr>
<tr><td><code id="pwr.normtest_+3A_weights">weights</code></td>
<td>
<p>weights vector (LEN p) of SNP-specific weights or scalar if weights
are equal for all SNPs; default value 1</p>
</td></tr>
<tr><td><code id="pwr.normtest_+3A_alpha">alpha</code></td>
<td>
<p>type-I error level; default value 0.01</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>result</code></dt><dd><p>mean power at selected QTL positions</p>
</dd>
<dt><code>h2.le</code></dt><dd><p>QTL heritability under linkage-equilibrium assumption</p>
</dd>
<dt><code>h2.ld</code></dt><dd><p>QTL heritability under linkage-disequilibrium
assumption</p>
</dd>
</dl>



<h3>References</h3>

<p>Wittenburg, Bonk, Doschoris, Reyer (2020) Design of Experiments
for Fine-Mapping Quantitative Trait Loci in Livestock Populations.
BMC Genetics 21:66. doi: <a href="https://doi.org/10.1186/s12863-020-00871-1">10.1186/s12863-020-00871-1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### correlation matrix (should depend on sire haplotypes)
  R &lt;- AR1(100, rho = 0.1)
  ### positions of putative QTL signals
  pos &lt;- c(14, 75)
  ### power at given sample size and other parameters
  pwr.normtest(R, 100, 0.35, 1200, pos)
</code></pre>

<hr>
<h2 id='pwr.snpblup'>Wrapper function for sample size calculation</h2><span id='topic+pwr.snpblup'></span>

<h3>Description</h3>

<p>Given parameters specified by the experimenter, optimal sample
size is estimated by repeatedly applying <code>search.best.n.bisection</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwr.snpblup(
  nfathers,
  nqtl,
  h2,
  R,
  rep = 10,
  nmax = 5000,
  weights = 1,
  typeII = 0.2,
  alpha = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwr.snpblup_+3A_nfathers">nfathers</code></td>
<td>
<p>number of half-sib families</p>
</td></tr>
<tr><td><code id="pwr.snpblup_+3A_nqtl">nqtl</code></td>
<td>
<p>number of QTL assumed</p>
</td></tr>
<tr><td><code id="pwr.snpblup_+3A_h2">h2</code></td>
<td>
<p>heritability captured by QTL</p>
</td></tr>
<tr><td><code id="pwr.snpblup_+3A_r">R</code></td>
<td>
<p>(p x p) matrix containing theoretical correlation between SNP pairs</p>
</td></tr>
<tr><td><code id="pwr.snpblup_+3A_rep">rep</code></td>
<td>
<p>number of repetitions; default value 10</p>
</td></tr>
<tr><td><code id="pwr.snpblup_+3A_nmax">nmax</code></td>
<td>
<p>maximum value for grid search; default value 5000</p>
</td></tr>
<tr><td><code id="pwr.snpblup_+3A_weights">weights</code></td>
<td>
<p>vector (LEN p) of SNP-specific weights or scalar if weights
are equal for all SNPs; default value 1</p>
</td></tr>
<tr><td><code id="pwr.snpblup_+3A_typeii">typeII</code></td>
<td>
<p>type-II error level; default value 0.2</p>
</td></tr>
<tr><td><code id="pwr.snpblup_+3A_alpha">alpha</code></td>
<td>
<p>type-I error level; default value 0.01</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sample size depends on parameters specified by the experimenter
(number of half-sib families, number of QTL, heritability, correlation
matrix). These values are converted into parameters required for the
probability density function under the alternative hypothesis (beta_k !=0,
for k selected QTL positions). As power depends on the selected QTL
positions, these are sampled at random and power calculations are repeated.
Afterwards the mean value is a plausible estimate of optimal sample size.
</p>
<p>Linear model for SNP-BLUP approach:
<code>y = X beta + e</code>
with <code>t(beta) = (beta_1, ldots, beta_p)</code>
Ridge approach:
<code>hat{beta} = (Xt X + I lambda)^{-1} Xt y</code>
</p>
<p>The identity matrix <code>I</code> can be replaced by a diagonal matrix
containing SNP-specific weights yielding a generalised ridge approach.
</p>


<h3>Value</h3>

<p>vector of optimal sample size over all repetitions
</p>


<h3>References</h3>

<p>Wittenburg, Bonk, Doschoris, Reyer (2020) Design of Experiments
for Fine-Mapping Quantitative Trait Loci in Livestock Populations. BMC
Genetics 21:66. doi: <a href="https://doi.org/10.1186/s12863-020-00871-1">10.1186/s12863-020-00871-1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### input parameters specified by experimenter
  # number of half-sib families
  nfathers &lt;- 10
  # number of assumed QTL
  nqtl &lt;- 2
  # QTL heritability
  h2 &lt;- 0.2
  ### correlation matrix (should depend on sire haplotypes)
  R &lt;- AR1(100, rho = 0.1)
  ### optimal sample size in a multi-marker approach
  set.seed(11)
  pwr.snpblup(nfathers, nqtl, h2, R, rep = 1)
</code></pre>

<hr>
<h2 id='search.best.n.bisection'>Method of bisection for estimating optimal sample size</h2><span id='topic+search.best.n.bisection'></span>

<h3>Description</h3>

<p>A grid <code>[nstart, nmax]</code> for possible sample size is
considered. Instead of executing a time-consuming grid search, the method
of bisection is applied to this interval. For each step, the function
<code>pwr.normtest</code> is called for the given set of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.best.n.bisection(
  R,
  betaSE,
  lambda,
  pos,
  nstart,
  nmax,
  weights = 1,
  typeII = 0.2,
  alpha = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search.best.n.bisection_+3A_r">R</code></td>
<td>
<p>(p x p) matrix containing theoretical correlation between SNP pairs</p>
</td></tr>
<tr><td><code id="search.best.n.bisection_+3A_betase">betaSE</code></td>
<td>
<p>effect size relative to residual standard deviation</p>
</td></tr>
<tr><td><code id="search.best.n.bisection_+3A_lambda">lambda</code></td>
<td>
<p>shrinkage parameter</p>
</td></tr>
<tr><td><code id="search.best.n.bisection_+3A_pos">pos</code></td>
<td>
<p>vector (LEN nqtl) of SNP indices for assumed QTL positions</p>
</td></tr>
<tr><td><code id="search.best.n.bisection_+3A_nstart">nstart</code></td>
<td>
<p>minimum value for grid search</p>
</td></tr>
<tr><td><code id="search.best.n.bisection_+3A_nmax">nmax</code></td>
<td>
<p>maximum value for grid search</p>
</td></tr>
<tr><td><code id="search.best.n.bisection_+3A_weights">weights</code></td>
<td>
<p>vector (LEN p) of SNP-specific weights or scalar if weights
are equal for all SNPs; default value 1</p>
</td></tr>
<tr><td><code id="search.best.n.bisection_+3A_typeii">typeII</code></td>
<td>
<p>type-II error level; default value 0.2</p>
</td></tr>
<tr><td><code id="search.best.n.bisection_+3A_alpha">alpha</code></td>
<td>
<p>type-I error level; default value 0.01</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer of optimal sample size
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### correlation matrix (should depend on sire haplotypes)
  R &lt;- AR1(100, rho = 0.1)
  ### positions of putative QTL signals
  pos &lt;- c(14, 75)
  ### optimal sample size
  search.best.n.bisection(R, 0.35, 1200, pos, 10, 5000)
</code></pre>

<hr>
<h2 id='simpleM'>Calculation of effective number of independent tests</h2><span id='topic+simpleM'></span>

<h3>Description</h3>

<p>Adapted simpleM method which considers theoretical correlation
between SNP pairs instead of composite LD values. Principal component
decomposition yields the effective number of independent tests. This value
is needed for the Bonferroni correction of type-I error when testing SNP
effects based on a single-marker model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleM(mat, quant = 0.995)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpleM_+3A_mat">mat</code></td>
<td>
<p>correlation matrix</p>
</td></tr>
<tr><td><code id="simpleM_+3A_quant">quant</code></td>
<td>
<p>percentage cutoff, variation of SNP data explained by
eigenvalues; default value 0.995</p>
</td></tr>
</table>


<h3>Value</h3>

<p>effective number of independent tests
</p>


<h3>References</h3>

<p>Gao, Starmer &amp; Martin (2008) A multiple testing correction method for
genetic association studies using correlated single nucleotide
polymorphisms. Genetic Epidemiology 32:361-369.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### correlation matrix (should depend on sire haplotypes)
  R &lt;- AR1(100, rho = 0.1)
  ### effective number of tests
  Meff &lt;- simpleM(R)
  ### relative effect size given heritability and number of QTL signals
  h2 &lt;- 0.2
  nqtl &lt;- 2
  betaSE &lt;- sqrt(h2 / (nqtl - nqtl * h2))
  ### optimal sample size in a single-marker approach
  pwr::pwr.t.test(d = betaSE, sig.level = 0.01 / Meff, power = 0.8,
   alternative = "two.sided", type = "one.sample")
</code></pre>

<hr>
<h2 id='startvalue'>Start value for estimating optimal sample size</h2><span id='topic+startvalue'></span>

<h3>Description</h3>

<p>Calculation of start value for estimating optimal sample size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startvalue(lambda, R, nfam, weights = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="startvalue_+3A_lambda">lambda</code></td>
<td>
<p>shrinkage parameter</p>
</td></tr>
<tr><td><code id="startvalue_+3A_r">R</code></td>
<td>
<p>(p x p) matrix containing theoretical correlation between SNP pairs</p>
</td></tr>
<tr><td><code id="startvalue_+3A_nfam">nfam</code></td>
<td>
<p>number of half-sib families</p>
</td></tr>
<tr><td><code id="startvalue_+3A_weights">weights</code></td>
<td>
<p>vector (LEN p) of SNP-specific weights or scalar if weights
are equal for all SNPs; default value 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minimum sample size that exceeds residual degrees of freedom; this
value can be used as start value in grid search for optimal sample size
</p>


<h3>Value</h3>

<p>start value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### correlation matrix (should depend on sire haplotypes)
  R &lt;- AR1(100, rho = 0.1)
  startvalue(1200, R, 10)
</code></pre>

<hr>
<h2 id='tagSNP'>tagSNP</h2><span id='topic+tagSNP'></span>

<h3>Description</h3>

<p>Grouping of markers depending on correlation structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tagSNP(mat, threshold = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tagSNP_+3A_mat">mat</code></td>
<td>
<p>(p x p) correlation matrix</p>
</td></tr>
<tr><td><code id="tagSNP_+3A_threshold">threshold</code></td>
<td>
<p>lower value of correlation considered for grouping</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Grouping of markers is based on the  correlation matrix. Apart from
this, the strategy for grouping is similar to Carlson et al. (2004). A
representative marker is suggested for each group.
</p>


<h3>Value</h3>

<p>list (LEN number of groups) of lists (LEN 2); marker names correspond
to column names of mat
</p>

<dl>
<dt><code>snps</code></dt><dd><p>vector of marker IDs in group</p>
</dd>
<dt><code>tagsnp</code></dt><dd><p>representative marker suggested for this group</p>
</dd>
</dl>



<h3>References</h3>

<p>Carlson, Eberle, Rieder, Yi, Kruglyak &amp; Nickerson (2004)
Selecting a maximally informative set of single-nucleotide polymorphisms
for association analyses using linkage disequilibrium. American Journal of
Human Genetics 74:106-120.
</p>
<p>Wittenburg, Doschoris, Klosa (2021) Grouping of genomic markers in
populations with family structure BMC Bioinformatics 22:79.
doi: <a href="https://doi.org/10.1186/s12859-021-04010-0">10.1186/s12859-021-04010-0</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### 1: INPUT DATA
  data(testdata)
  ### 2: COVARIANCE/CORRELATION MATRIX
  corrmat &lt;- CovMat(matLD, H.sire, 100, pos.chr, corr = TRUE)
  ### 3: TAGSNPS FROM CORRELATION MATRIX
  bin &lt;- tagSNP(corrmat$R)
  bin &lt;- tagSNP(corrmat$R, 0.5)
  as.numeric(unlist(rlist::list.select(bin, tagsnp)))
</code></pre>

<hr>
<h2 id='testdata'>Description of the testdata</h2><span id='topic+testdata'></span>

<h3>Description</h3>

<p>The data set contains paternal haplotypes, maternal LD and
genetic map positions that are required to calculate the covariance between
pairs of markers.
</p>

<p>The raw data can be downloaded at the source given below. Then,
executing the following R code leads to the data that have been provided as
<code>testdata.RData</code>.
</p>
<dl>
<dt>H.sire</dt><dd><p>(2N x p) haplotype matrix for sires for all chromosomes
(2 lines per sire)</p>
</dd>
<dt>matLD</dt><dd><p>(p x p) matrix of maternal LD between pairs of p markers;
matrix is block diagonal in case of multiple chromosomes</p>
</dd>
<dt>pos.chr</dt><dd><p>list of vectors of genetic map positions per chromosome</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data are available from RADAR doi: <a href="https://doi.org/10.22000/280">10.22000/280</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## data.frame of estimates of paternal recombination rate and maternal LD
load('Result.RData')
## list of haplotypes of sires for each chromosome
load('sire_haplotypes.RData')
## physical map
map &lt;- read.table('map50K_ARS_reordered.txt', header = T)
## select target region
chr &lt;- 1
window &lt;- 301:600
## map information of target region
map.target &lt;- map[map$Chr == chr, ][window, ]
Result.target &lt;- Result[(Result$Chr == chr) &amp; (Result$SNP1 %in% window) &amp;
  (Result$SNP2 %in% window), ]
## SNP position in Morgan approximated from recombination rate
part &lt;- Result.target[Result.target$SNP1 == window[1], ]
sp &lt;- smooth.spline(x = map.target$locus_Mb[part$SNP2 - window[1] + 1], y = part$Theta, df = 4)
pos.snp &lt;- predict(sp, x =  map.target$locus_Mb[window - window[1] + 1])$y
## list of SNPs positions
pos.chr &lt;- list(pos.snp)
## haplotypes of sires (mating candidates) in target region
H.sire &lt;- rlist::list.rbind(haps[[chr]])[, window]
## matrix of maternal LD (block diagonal if multiple chromosome)
matLD &lt;- matrix(0, ncol = length(window), nrow = length(window))
## off-diagonal elements
for(l in 1:nrow(Result.target)){
  id1 &lt;- Result.target$SNP1[l] - window[1] + 1
  id2 &lt;- Result.target$SNP2[l] - window[1] + 1
  matLD[id1, id2] &lt;- matLD[id2, id1] &lt;- Result.target$D[l]
}
## diagonal elements
for(k in unique(Result.target$SNP1)){
  id &lt;- k - window[1] + 1
  p &lt;- Result.target$fAA[Result.target$SNP1 == k] + Result.target$fAB[Result.target$SNP1 == k]
  matLD[id, id] &lt;- max(p * (1 - p))
}

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
