<!DOCTYPE html><html lang="en-GB"><head><title>Help for package stevedore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stevedore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#docker_available'><p>Test if docker available</p></a></li>
<li><a href='#docker_client'><p>Create docker client</p></a></li>
<li><a href='#docker_config_collection'><p>Management commands for working with swarm configs</p></a></li>
<li><a href='#docker_container'><p>Management commands for working with a particular docker container</p></a></li>
<li><a href='#docker_container_collection'><p>Management commands for working with docker containers</p></a></li>
<li><a href='#docker_exec'><p>Commands for working with a docker exec instance</p></a></li>
<li><a href='#docker_image'><p>Management commands for working with a particular docker image</p></a></li>
<li><a href='#docker_image_collection'><p>Management commands for working with docker images</p></a></li>
<li><a href='#docker_network'><p>Management commands for working with a particular docker network</p></a></li>
<li><a href='#docker_network_collection'><p>Management commands for working with docker networks</p></a></li>
<li><a href='#docker_node'><p>Management commands for working with a particular docker node</p></a></li>
<li><a href='#docker_node_collection'><p>Management commands for working with swarm nodes</p></a></li>
<li><a href='#docker_plugin'><p>Management commands for working with a particular docker plugin</p></a></li>
<li><a href='#docker_plugin_collection'><p>Management commands for working with docker plugins</p></a></li>
<li><a href='#docker_secret_collection'><p>Management commands for working with swarm secrets</p></a></li>
<li><a href='#docker_service'><p>Management commands for working with a particular docker service</p></a></li>
<li><a href='#docker_service_collection'><p>Management commands for working with docker services</p></a></li>
<li><a href='#docker_swarm_collection'><p>Management commands for working with docker swarm</p></a></li>
<li><a href='#docker_task'><p>Management commands for working with a particular docker task</p></a></li>
<li><a href='#docker_task_collection'><p>Management commands for working with docker tasks</p></a></li>
<li><a href='#docker_types'><p>Constructors for complex types</p></a></li>
<li><a href='#docker_volume'><p>Management commands for working with a particular docker volume</p></a></li>
<li><a href='#docker_volume_collection'><p>Management commands for working with docker volumes</p></a></li>
<li><a href='#stevedore'><p>Docker Client For R</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Docker Client</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Work with containers over the Docker API.  Rather than
    using system calls to interact with a docker client, using the
    API directly means that we can receive richer information from
    docker.  The interface in the package is automatically generated
    using the 'OpenAPI' (a.k.a., 'swagger') specification, and all
    return values are checked in order to make them type stable.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/richfitz/stevedore">https://github.com/richfitz/stevedore</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>crayon, curl (&ge; 2.3.0), jsonlite, yaml (&ge; 2.1.18)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, openssl, redux, reticulate, rmarkdown, testthat, withr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>docker</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-10 09:47:03 UTC; rfitzjoh</td>
</tr>
<tr>
<td>Author:</td>
<td>Rich FitzJohn [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rich FitzJohn &lt;rich.fitzjohn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-10 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='docker_available'>Test if docker available</h2><span id='topic+docker_available'></span>

<h3>Description</h3>

<p>Test if we can construct a docker client and confirm that we can
communicate with it.  This is intended to help in debug connection
issues, and also for use in tests.  For example, you might
implement a testthat skip test that skips if
<code>stevedore::docker_available()</code> returns <code>FALSE</code> to
conditionally use stevedore/docker within tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docker_available(..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="docker_available_+3A_...">...</code></td>
<td>
<p>Passed through to <code>docker_client</code> (e.g.,
<code>api_version</code>, <code>host</code>).</p>
</td></tr>
<tr><td><code id="docker_available_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating if information should be
printed about failures to connect.  If <code>FALSE</code> (the
default) the function runs silently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reasons for failure to connect might include:
</p>

<ul>
<li><p> You do not have a docker daemon running
</p>
</li>
<li><p> You have docker installed but the socket in a non-standard
place and have not adjusted environment variables accordingly
</p>
</li>
<li><p> You do not have permission to write to the docker socket
</p>
</li>
<li><p> You are on windows and the required python packages to get
everything working there are not present or configured correctly
</p>
</li>
<li><p> There are problems arranging verification over https/tls.
</p>
</li></ul>

<p>If <code>versose</code> is <code>TRUE</code> then some diagnostic information
will be printed.
</p>


<h3>Value</h3>

<p>Logical scalar, <code>TRUE</code> if
<code><a href="#topic+docker_client">docker_client</a>(...)</code> would succeed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Is docker available on your system?
stevedore::docker_available()
</code></pre>

<hr>
<h2 id='docker_client'>Create docker client</h2><span id='topic+docker_client'></span>

<h3>Description</h3>

<p>Create a docker client object, which allows you to interact with
docker from R.  The object has several <em>methods</em> that allow
interaction with the docker daemon (for this object they are all
&quot;system&quot; commands) and <em>collections</em>, which contains further
methods.  The client is structured similarly to the docker command
line client, such that <code>docker container create &lt;args&gt;</code> in
the command line becomes <code>docker$container$create(...)</code> in R
(if the client is called R).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docker_client(
  ...,
  api_version = NULL,
  host = NULL,
  cert_path = NULL,
  tls_verify = NULL,
  machine = NULL,
  http_client_type = NULL,
  data_frame = NULL,
  quiet = FALSE,
  debug = NULL,
  ignore_environment = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="docker_client_+3A_...">...</code></td>
<td>
<p>Reserved for future use.  Passing in any unrecognised
argument will throw an error.  Part of the role of this argument
is to force use of named arguments until the API is stabilised.</p>
</td></tr>
<tr><td><code id="docker_client_+3A_api_version">api_version</code></td>
<td>
<p>Version of the API to use when communicating
with the docker daemon.  The default value, <code>NULL</code>, detects
the docker server API version and attempts to match it (this
mirrors the default behaviour of the docker command line
client).  Alternatively, provide an API version number as a
string or <code><a href="base.html#topic+numeric_version">numeric_version</a></code> object (supported
between 1.25 and
1.39).  The version
1.29 is the version
used in most automated tests, and if problems are encountered,
consider forcing this version).</p>
</td></tr>
<tr><td><code id="docker_client_+3A_host">host</code></td>
<td>
<p>The URL for the docker daemon.  This can be a unix
socket (e.g., unix:///var/run/docker.sock) on macOS/Linux, a
named pipe (e.g., <code>npipe:////./pipe/docker_engine</code>) on
Windows, or an http or https url (e.g.,
<code>https://localhost:2376</code>).  If not given, we use the
environment variable <code>DOCKER_HOST</code>, falling back on the
default socket or named pipe (for macOS/unix and windows
respectively).</p>
</td></tr>
<tr><td><code id="docker_client_+3A_cert_path">cert_path</code></td>
<td>
<p>The path to a directory containing certificate
files.  If using an <code>https</code> url this is required.  If not
given, we use the environment variable <code>DOCKER_CERT_PATH</code>.
This is ignored without warning if used with a socket or named
pipe connection.</p>
</td></tr>
<tr><td><code id="docker_client_+3A_tls_verify">tls_verify</code></td>
<td>
<p>Logical, indicating if TLS should be verified.
This is only used if using an https connection (i.e., host is a
tcp/http/https url and<code>cert_path</code> is given).  If not given,
we use the environment variable <code>DOCKER_TLS_VERIFY</code>.</p>
</td></tr>
<tr><td><code id="docker_client_+3A_machine">machine</code></td>
<td>
<p>Scalar character (if provided) indicating the name
of a &quot;docker machine&quot; instance to use.  If this is provided then
<code>docker-machine</code> must be installed and the machine must
exist and be running.  <code>stevedore</code> will run
<code>docker-machine env machine</code> to determine the environment
variables to contact this machine and use these values for
<code>host</code>, <code>cert_path</code> and <code>tls_verify</code> (silently
ignoring any provided values).  Carl Boettiger is working on a
<a href="https://github.com/cboettig/dockermachine">docker machine</a>
package for R that would make managing docker machines from R
easier.  As an alternative to this option, one can set
docker-machine environment variables as described in
<code>docker-machine env</code> before running R and they would be picked
up as described above.</p>
</td></tr>
<tr><td><code id="docker_client_+3A_http_client_type">http_client_type</code></td>
<td>
<p>HTTP client type to use.  The options are
(currently) &quot;curl&quot;, which uses the <code>curl</code> package (works
over unix sockets and over TCP) and <code>httppipe</code> which works
over unix sockets and windows named pipes, using the Docker
SDK's pipe code via the <code>httppipe</code> package.  Not all
functionality is supported with the <code>httppipe</code> client.
This option may eventually be moved into the <code>...</code> argument
as is not intended for end-user use; it is primarily intended
for debugging in development (forcing the <code>httppipe</code> client
where the <code>curl</code> client would ordinarily be preferred).</p>
</td></tr>
<tr><td><code id="docker_client_+3A_data_frame">data_frame</code></td>
<td>
<p>Function, used to wrap data.frames returned.
This may make output easier to consume.  You might use
<code>tibble::as_tibble</code> to return a <code>tbl_df</code> or
<code>datatable::as.data.table</code> to return <code>data.table</code>
objects.  This will be applied to all data.frames <em>after</em>
they are constructed, and so must take a single argument (the
newly constructed data.frame) and return a new object that is
largely compatible with data.frame.  Another use for this would
be to define a function <code>data_frame = function(x)
structure(x, class = c("foo", "data.frame"))</code> to set the class
of all returned data.frame objects to be &quot;foo&quot; as well and then
defining a custom S3 print method for &quot;foo&quot; that limited the
output.</p>
</td></tr>
<tr><td><code id="docker_client_+3A_quiet">quiet</code></td>
<td>
<p>Suppress informational messages.</p>
</td></tr>
<tr><td><code id="docker_client_+3A_debug">debug</code></td>
<td>
<p>Enable http debugging (supported by the curl http
driver only).  Provide a connection object and http headers and
content will be sent to it.  Using <code>debug = TRUE</code> is
equivalent to <code>code = stdout()</code>, while <code>debug = FALSE</code>
is equivalent to <code>debug = NULL</code> (the default) which
prevents debugging information being printed.  This option can
be used to write to a file by opening a writeable connection but
care must be made not to close this connection because otherwise
the curl requests may fail.</p>
</td></tr>
<tr><td><code id="docker_client_+3A_ignore_environment">ignore_environment</code></td>
<td>
<p>Logical, indicating if environment
variables (<code>DOCKER_HOST</code>, <code>DOCKER_CERT_PATH</code>,
<code>DOCKER_TLS_VERIFY</code> and <code>DOCKER_API_VERSION</code>) should
be ignored (this has no effect if <code>machine</code> is specified).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Management commands</h4>

<dl>
<dt><code>config</code></dt><dd><p>Manage config - see <code><a href="#topic+docker_config_collection">docker_config_collection</a></code></p>
</dd><dt><code>container</code></dt><dd><p>Manage container - see <code><a href="#topic+docker_container_collection">docker_container_collection</a></code></p>
</dd><dt><code>image</code></dt><dd><p>Manage image - see <code><a href="#topic+docker_image_collection">docker_image_collection</a></code></p>
</dd><dt><code>network</code></dt><dd><p>Manage network - see <code><a href="#topic+docker_network_collection">docker_network_collection</a></code></p>
</dd><dt><code>node</code></dt><dd><p>Manage node - see <code><a href="#topic+docker_node_collection">docker_node_collection</a></code></p>
</dd><dt><code>plugin</code></dt><dd><p>Manage plugin - see <code><a href="#topic+docker_plugin_collection">docker_plugin_collection</a></code></p>
</dd><dt><code>secret</code></dt><dd><p>Manage secret - see <code><a href="#topic+docker_secret_collection">docker_secret_collection</a></code></p>
</dd><dt><code>service</code></dt><dd><p>Manage service - see <code><a href="#topic+docker_service_collection">docker_service_collection</a></code></p>
</dd><dt><code>swarm</code></dt><dd><p>Manage swarm - see <code><a href="#topic+docker_swarm_collection">docker_swarm_collection</a></code></p>
</dd><dt><code>task</code></dt><dd><p>Manage task - see <code><a href="#topic+docker_task_collection">docker_task_collection</a></code></p>
</dd><dt><code>types</code></dt><dd><p>Manage types - see <code><a href="#topic+docker_types">docker_types</a></code></p>
</dd><dt><code>volume</code></dt><dd><p>Manage volume - see <code><a href="#topic+docker_volume_collection">docker_volume_collection</a></code></p>
</dd></dl>


<h4>Methods</h4>

<dl>
<dt><code>api_version</code></dt><dd><p>Return the version of the API that the docker client is using to communicate with the server, as a string (e.g., &quot;1.29&quot;)
</p>
<p><em>Usage:</em></p>
<pre>  api_version()</pre></dd><dt><code>connection_info</code></dt><dd><p>Return information about the connection to the server.
</p>
<p><em>Usage:</em></p>
<pre>  connection_info()</pre></dd><dt><code>cp</code></dt><dd><p>Copy a file or directory between the host filesystem and a running container.  Like the command line, exactly one of <code>from</code>and <code>to</code>must be in the form <code>&lt;container&gt;:&lt;path&gt;</code>while the other must be in the form <code>&lt;path&gt;</code>.  This wrapper is included for compatiblity with the docker command line and is available in a slightly more flexible form as <code>cp_out</code>and <code>cp_in</code>methods of a <code>docker_container</code>object. Similar to the cli command <code>docker cp</code>.
</p>
<p><em>Usage:</em></p>
<pre>  cp(src, dest)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>src</code>: The source file or directory.  If on the host it may be a relative or an absolute path.  If on the container then it must be of the form <code>&lt;container_id&gt;:&lt;path&gt;</code>; the container id can be an id (hex) or name.
</p>
</li>
<li><p><code>dest</code>: The destination file or directory, with the same pattern as <code>from</code>.
</p>
</li></ul>
</dd><dt><code>system_df</code></dt><dd><p>Get data usage information. Similar to the cli command <code>docker system df</code>.
</p>
<p><em>Usage:</em></p>
<pre>  system_df()</pre></dd><dt><code>system_events</code></dt><dd><p>Monitor events. Stream real-time events from the server.
</p>
<p>Various objects within Docker report events when something happens to them.
</p>
<p>Containers report these events: <code>attach, commit, copy, create, destroy, detach, die, exec_create, exec_detach, exec_start, export, health_status, kill, oom, pause, rename, resize, restart, start, stop, top, unpause, update</code></p>
<p>Images report these events: <code>delete, import, load, pull, push, save, tag, untag</code></p>
<p>Volumes report these events: <code>create, mount, unmount, destroy</code></p>
<p>Networks report these events: <code>create, connect, disconnect, destroy</code></p>
<p>The Docker daemon reports these events: <code>reload</code>. Similar to the cli command <code>docker events</code>.
</p>
<p><em>Usage:</em></p>
<pre>  system_events(since = NULL, until = NULL, filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>since</code>: Show events created since this timestamp then stream new events.
</p>
</li>
<li><p><code>until</code>: Show events created until this timestamp then stop streaming.
</p>
</li>
<li><p><code>filters</code>: A named character vector of filters to process on the event list. Available filters:
</p>
<ul>
<li><p><code>container=&lt;string&gt;</code>container name or ID
</p>
</li>
<li><p><code>daemon=&lt;string&gt;</code>daemon name or ID
</p>
</li>
<li><p><code>event=&lt;string&gt;</code>event type
</p>
</li>
<li><p><code>image=&lt;string&gt;</code>image name or ID
</p>
</li>
<li><p><code>label=&lt;string&gt;</code>image or container label
</p>
</li>
<li><p><code>network=&lt;string&gt;</code>network name or ID
</p>
</li>
<li><p><code>plugin</code>=&lt;string&gt; plugin name or ID
</p>
</li>
<li><p><code>type=&lt;string&gt;</code>object to filter by, one of <code>container</code>, <code>image</code>, <code>volume</code>, <code>network</code>, or <code>daemon</code></p>
</li>
<li><p><code>volume=&lt;string&gt;</code>volume name or ID
</p>
</li></ul>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>system_info</code></dt><dd><p>Get system information. Similar to the cli command <code>docker info</code>.
</p>
<p><em>Usage:</em></p>
<pre>  system_info()</pre></dd><dt><code>system_auth</code></dt><dd><p>Check auth configuration. Validate credentials for a registry and, if available, get an identity token for accessing the registry without password. Similar to the cli command <code>docker login</code>.
</p>
<p><em>Usage:</em></p>
<pre>  system_auth(username = NULL, password = NULL, email = NULL,
      serveraddress = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>username</code>: For authentication to check
</p>
</li>
<li><p><code>password</code>: For authentication to check
</p>
</li>
<li><p><code>email</code>: For authentication to check
</p>
</li>
<li><p><code>serveraddress</code>: For authentication to check
</p>
</li></ul>
</dd><dt><code>system_ping</code></dt><dd><p>Ping. This is a dummy endpoint you can use to test if the server is accessible.
</p>
<p><em>Usage:</em></p>
<pre>  system_ping()</pre></dd><dt><code>request</code></dt><dd><p>Interact directly with the Docker HTTP API.  This might be useful for debugging or for trying out new/experimental docker features that have not yet made it into stevedore.  This is most likely to be useful in conjunction with the Docker API docs; https://docs.docker.com/engine/api Each call will return a list with elements <code>url</code>(the used url), <code>status_code</code>(the HTTP status code), <code>headers</code>(a raw vector containing the returned headers) and <code>content</code>(a raw vector containing the content). The <code>curl</code>driver provides some other entries too.
</p>
<p><em>Usage:</em></p>
<pre>  request(verb, path, query = NULL, body = NULL,
      headers = NULL, stream = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>verb</code>: A HTTP verb (e.g., <code>GET</code>, <code>POST</code>) as a string.  Will be converted to uppercase.
</p>
</li>
<li><p><code>path</code>: A path as a string, e.g., <code>/version</code>or <code>/containers/json</code>. Do not provide any hostname, and use an absoluate path.
</p>
</li>
<li><p><code>query</code>: Optionally, a named list of query parameters (e.g., <code>list(limit = 10)</code>as a query parameter for <code>/containers/json</code>).
</p>
</li>
<li><p><code>body</code>: Either a raw vector (e.g., a tar-ed image for <code>POST /build</code>) or a string representing json (e.g. for <code>POST /containers/create</code>).
</p>
</li>
<li><p><code>headers</code>: Headers to send with the request.  The API does not use this extensively except for <code>X-Registry-Auth</code>for some endpoints.
</p>
</li>
<li><p><code>stream</code>: An R function to handle streaming output.  If given then the function must take a single argument which will be a raw vector with the docker daemon's output.  The function's return output is ignored so needs to do all actions via side effects.
</p>
</li></ul>
</dd><dt><code>system_version</code></dt><dd><p>Get version. Returns the version of Docker that is running and various information about the system that Docker is running on. Similar to the cli command <code>docker version</code>.
</p>
<p><em>Usage:</em></p>
<pre>  system_version()</pre></dd></dl>



<h3>Connection options</h3>

<p><code>stevedore</code> can connect to the docker daemon via a unix
socket (this is the default set-up on Linux and macOS), over a
named pipe (Windows 10 - see below) and https over a normal tcp
connection (this is especially useful with
<a href="https://docs.docker.com/machine/"><code>docker-machine</code></a>.
</p>

<ol>
<li><p> If the <code>machine</code> argument is given then
<code>stevedore</code> queries <code>docker-machine</code> for settings.  If
that command fails (e.g., there is no machine,
<code>docker-machine</code> not installed) then that will cause an
error.  (Note that the <code>docker-machine</code> output does not
include API version information so the <code>api_version</code>
argument is relevant, but <code>host</code>, <code>cert_path</code> and
<code>tls_verify</code> will be silently ignored if provided).
</p>
</li>
<li><p> The arguments <code>host</code> overrides the environment variable
<code>DOCKER_HOST</code>, <code>cert_path</code> overrides
<code>DOCKER_CERT_PATH</code> and <code>tls_verify</code> overrides
<code>DOCKER_TLS_VERIFY</code>.  If <code>ignore_environment</code> is
<code>TRUE</code> then the environment variables are not used at all.
</p>
</li>
<li><p> if <code>code</code> is not provided by any of the above methods
(machine, argument or environment variable) it will fall back
on the default unix socket (<code>var/run/docker.sock</code>) on
Linux/macOS or the default windows named pipe
(<code>npipe:////./pipe/docker_engine</code>) on windows.
</p>
</li></ol>

<p>The API version is set by the <code>api_version</code> argument, which
falls back on the environment variable <code>DOCKER_API_VERSION</code>
(this is the same as the docker command line client and the python
SDK).  If neither are provided then <code>stevedore</code> will detect
the API version being used by the daemon and match that (provided
it falls within the range of versions supported by the package).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (stevedore::docker_available()) {
  # Create a new client object:
  client &lt;- stevedore::docker_client()

  # Version information for your docker daemon:
  client$version()

  # General information about your daemon:
  client$info()

  # Most of the interesting methods are within the collections.
  # For example, to see a summary of running containers:
  client$container$list()

  # (see ?docker_container) for more information.
}
</code></pre>

<hr>
<h2 id='docker_config_collection'>Management commands for working with swarm configs</h2><span id='topic+docker_config_collection'></span>

<h3>Description</h3>

<p>Methods for managing docker swarm configurations.  This object is
<code>$config</code> within a <code><a href="#topic+docker_client">docker_client</a></code> object.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>config_create</code></dt><dd><p>Create a config. Unimplemented, as 'config_create' (POST /configs/create) requires docker API version at least 1.30 (version 1.29 used)
</p>
<p><em>Usage:</em></p>
<pre>  config_create(...)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>...</code>: Ignored in this version
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>config_inspect</code></dt><dd><p>Inspect a config. Unimplemented, as 'config_inspect' (GET /configs/id) requires docker API version at least 1.30 (version 1.29 used)
</p>
<p><em>Usage:</em></p>
<pre>  config_inspect(...)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>...</code>: Ignored in this version
</p>
</li></ul>
</dd><dt><code>config_list</code></dt><dd><p>List configs. Unimplemented, as 'config_list' (GET /configs) requires docker API version at least 1.30 (version 1.29 used)
</p>
<p><em>Usage:</em></p>
<pre>  config_list(...)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>...</code>: Ignored in this version
</p>
</li></ul>
</dd><dt><code>config_delete</code></dt><dd><p>Delete a config. Unimplemented, as 'config_delete' (DELETE /configs/id) requires docker API version at least 1.30 (version 1.29 used)
</p>
<p><em>Usage:</em></p>
<pre>  config_delete(...)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>...</code>: Ignored in this version
</p>
</li></ul>
</dd><dt><code>config_update</code></dt><dd><p>Update a Config. Unimplemented, as 'config_update' (POST /configs/id/update) requires docker API version at least 1.30 (version 1.29 used)
</p>
<p><em>Usage:</em></p>
<pre>  config_update(...)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>...</code>: Ignored in this version
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_swarm_collection">docker_swarm_collection</a></code> for management
commands for the swarm itself, and
<code><a href="#topic+docker_secret_collection">docker_secret_collection</a></code> for a similar interface
for configuring sensitive configurations.
</p>

<hr>
<h2 id='docker_container'>Management commands for working with a particular docker container</h2><span id='topic+docker_container'></span>

<h3>Description</h3>

<p>Methods for working with a particular docker container.  Container
objects are returned by creating or running a docker container, or
by using <code>$container$get</code> to fetch an existing container by
name or id.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>image_commit</code></dt><dd><p>Create a new image from a container. Similar to the cli command <code>docker commit</code>or <code>docker container commit</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_commit(repo = NULL, tag = NULL, author = NULL,
      changes = NULL, comment = NULL, pause = NULL,
      hostname = NULL, domainname = NULL, user = NULL,
      attach_stdin = NULL, attach_stdout = NULL,
      attach_stderr = NULL, exposed_ports = NULL, tty = NULL,
      open_stdin = NULL, stdin_once = NULL, env = NULL,
      cmd = NULL, healthcheck = NULL, args_escaped = NULL,
      image = NULL, volumes = NULL, working_dir = NULL,
      entrypoint = NULL, network_disabled = NULL,
      mac_address = NULL, on_build = NULL, labels = NULL,
      stop_signal = NULL, stop_timeout = NULL, shell = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>repo</code>: Repository name for the created image
</p>
</li>
<li><p><code>tag</code>: Tag name for the create image
</p>
</li>
<li><p><code>author</code>: Author of the image (e.g., <code>John Hannibal Smith &lt;hannibal@a-team.com&gt;</code>)
</p>
</li>
<li><p><code>changes</code>: <code>Dockerfile</code>instructions to apply while committing
</p>
</li>
<li><p><code>comment</code>: Commit message
</p>
</li>
<li><p><code>pause</code>: Whether to pause the container before committing
</p>
</li>
<li><p><code>hostname</code>: The hostname to use for the container, as a valid RFC 1123 hostname.
</p>
</li>
<li><p><code>domainname</code>: The domain name to use for the container.
</p>
</li>
<li><p><code>user</code>: The user that commands are run as inside the container.
</p>
</li>
<li><p><code>attach_stdin</code>: Whether to attach to <code>stdin</code>.
</p>
</li>
<li><p><code>attach_stdout</code>: Whether to attach to <code>stdout</code>.
</p>
</li>
<li><p><code>attach_stderr</code>: Whether to attach to <code>stderr</code>.
</p>
</li>
<li><p><code>exposed_ports</code>: A character vector of port mappings between the container and host, in (1) the form <code>&lt;host&gt;:&lt;container&gt;</code>(e.g., <code>10080:80</code>to map the container's port 80 to the host's port 10080), <code>&lt;ip&gt;:&lt;host&gt;:&lt;container&gt;</code>to bind a specific host interface as well as a port (e.g., you can use <code>localhost</code>or <code>127.0.0.1</code>for the first element), (3) form <code>&lt;port&gt;</code>to map the containers port to a random available port on the host s shorthand for <code>&lt;port&gt;:&lt;port&gt;</code>, or (3) a single logical value <code>TRUE</code>indicating to map all container ports to random available ports on the host. You can use the <code>$ports()</code>method in the <code><a href="#topic+docker_container">docker_container</a></code>object to query the port mapping of a running container.  Multiple values can be provided to map multiple ports to the host (e.g., <code>c("80", "443:443")</code>.
</p>
</li>
<li><p><code>tty</code>: Attach standard streams to a TTY, including <code>stdin</code>if it is not closed.
</p>
</li>
<li><p><code>open_stdin</code>: Open <code>stdin</code></p>
</li>
<li><p><code>stdin_once</code>: Close <code>stdin</code>after one attached client disconnects
</p>
</li>
<li><p><code>env</code>: A list of environment variables to set inside the container in the form <code>["VAR=value", ...]</code>. A variable without <code>=</code>is removed from the environment, rather than to have an empty value.
</p>
</li>
<li><p><code>cmd</code>: Command to run specified as a string or an array of strings.
</p>
</li>
<li><p><code>healthcheck</code>: A test to perform to check that the container is healthy.
</p>
</li>
<li><p><code>args_escaped</code>: Command is already escaped (Windows only)
</p>
</li>
<li><p><code>image</code>: The name of the image to use when creating the container
</p>
</li>
<li><p><code>volumes</code>: A character vector of mappings of mount points on the host (or in volumes) to paths on the container.  Each element must be of the form <code>&lt;path_host&gt;:&lt;path_container&gt;</code>, possibly followed by <code>:ro</code>for read-only mappings (i.e., the same syntax as the docker command line client).
<code><a href="#topic+docker_volume">docker_volume</a></code>objects have a <code>$map</code>method to help with generating these paths for volume mappings.
</p>
</li>
<li><p><code>working_dir</code>: The working directory for commands to run in.
</p>
</li>
<li><p><code>entrypoint</code>: The entry point for the container as a string or an array of strings.
</p>
<p>If the array consists of exactly one empty string (<code>[""]</code>) then the entry point is reset to system default (i.e., the entry point used by docker when there is no <code>ENTRYPOINT</code>instruction in the <code>Dockerfile</code>).
</p>
</li>
<li><p><code>network_disabled</code>: Disable networking for the container.
</p>
</li>
<li><p><code>mac_address</code>: MAC address of the container.
</p>
</li>
<li><p><code>on_build</code>: <code>ONBUILD</code>metadata that were defined in the image's <code>Dockerfile</code>.
</p>
</li>
<li><p><code>labels</code>: User-defined key/value metadata.
</p>
</li>
<li><p><code>stop_signal</code>: Signal to stop a container as a string or unsigned integer.
</p>
</li>
<li><p><code>stop_timeout</code>: Timeout to stop a container in seconds.
</p>
</li>
<li><p><code>shell</code>: Shell for when <code>RUN</code>, <code>CMD</code>, and <code>ENTRYPOINT</code>uses a shell.
</p>
</li></ul>
</dd><dt><code>cp_in</code></dt><dd><p>Copy files or directory into the container.  This function tries to follow the same semantics as the command line <code>docker cp</code>command.
</p>
<p><em>Usage:</em></p>
<pre>  cp_in(src, dest)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>src</code>: File or directory to copy into the container.
</p>
</li>
<li><p><code>dest</code>: Destination within the container.  This must be a single path.
</p>
</li></ul>
</dd><dt><code>cp_out</code></dt><dd><p>Copy files or directories from the container.  This function tries to follow the same semantics as the command line <code>docker cp</code>command.
</p>
<p><em>Usage:</em></p>
<pre>  cp_out(src, dest)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>src</code>: File or directory within the container to copy to the host.
</p>
</li>
<li><p><code>dest</code>: Destination on the host.  This must be a single path.
</p>
</li></ul>
</dd><dt><code>container_changes</code></dt><dd><p>Get changes on a container's filesystem. Returns which files in a container's filesystem have been added, deleted,
or modified. The <code>Kind</code>of modification can be one of:
</p>
<ul>
<li><p><code>0</code>: Modified
</p>
</li>
<li><p><code>1</code>: Added
</p>
</li>
<li><p><code>2</code>: Deleted. Similar to the cli command <code>docker diff</code>or <code>docker container diff</code>.
</p>
</li></ul>
<p><em>Usage:</em></p>
<pre>  container_changes()</pre></dd><dt><code>exec</code></dt><dd><p>Create and run an exec instance. Run a command inside a running container. Similar to the cli command <code>docker exec</code>.
</p>
<p><em>Usage:</em></p>
<pre>  exec(cmd, stdin = NULL, stdout = TRUE, stderr = TRUE,
      detach_keys = NULL, tty = NULL, env = NULL,
      privileged = NULL, user = NULL, detach = FALSE,
      stream = stdout())</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>cmd</code>: Command to run, as a string or array of strings.
</p>
</li>
<li><p><code>stdin</code>: Attach to <code>stdin</code>of the exec command.
</p>
</li>
<li><p><code>stdout</code>: Attach to <code>stdout</code>of the exec command.
</p>
</li>
<li><p><code>stderr</code>: Attach to <code>stderr</code>of the exec command.
</p>
</li>
<li><p><code>detach_keys</code>: Override the key sequence for detaching a container. Format is a single character <code>[a-Z]</code>or <code>ctrl-&lt;value&gt;</code>where <code>&lt;value&gt;</code>is one of: <code>a-z</code>, <code>@</code>, <code>^</code>, <code>[</code>, <code>,</code>or <code>_</code>.
</p>
</li>
<li><p><code>tty</code>: Allocate a pseudo-TTY.
</p>
</li>
<li><p><code>env</code>: A list of environment variables in the form <code>["VAR=value", ...]</code>.
</p>
</li>
<li><p><code>privileged</code>: Runs the exec process with extended privileges.
</p>
</li>
<li><p><code>user</code>: The user, and optionally, group to run the exec process inside the container. Format is one of: <code>user</code>, <code>user:group</code>, <code>uid</code>, or <code>uid:gid</code>.
</p>
</li>
<li><p><code>detach</code>: Detach from the command.
</p>
</li>
<li><p><code>stream</code>: The stream to send output to.  Options here are (1) a connection object (e.g. <code>stdout()</code>, <code>stderr()</code>or a writable open file connection object, (2) a scalar character indicating a filename to write to, or (3) <code>FALSE</code>or <code>NULL</code>to disable any output.
</p>
</li></ul>
</dd><dt><code>exec_create</code></dt><dd><p>Create an exec instance. Run a command inside a running container. Similar to the cli command <code>docker exec</code>.
</p>
<p><em>Usage:</em></p>
<pre>  exec_create(cmd, stdin = NULL, stdout = TRUE, stderr = TRUE,
      detach_keys = NULL, tty = NULL, env = NULL,
      privileged = NULL, user = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>cmd</code>: Command to run, as a string or array of strings.
</p>
</li>
<li><p><code>stdin</code>: Attach to <code>stdin</code>of the exec command.
</p>
</li>
<li><p><code>stdout</code>: Attach to <code>stdout</code>of the exec command.
</p>
</li>
<li><p><code>stderr</code>: Attach to <code>stderr</code>of the exec command.
</p>
</li>
<li><p><code>detach_keys</code>: Override the key sequence for detaching a container. Format is a single character <code>[a-Z]</code>or <code>ctrl-&lt;value&gt;</code>where <code>&lt;value&gt;</code>is one of: <code>a-z</code>, <code>@</code>, <code>^</code>, <code>[</code>, <code>,</code>or <code>_</code>.
</p>
</li>
<li><p><code>tty</code>: Allocate a pseudo-TTY.
</p>
</li>
<li><p><code>env</code>: A list of environment variables in the form <code>["VAR=value", ...]</code>.
</p>
</li>
<li><p><code>privileged</code>: Runs the exec process with extended privileges.
</p>
</li>
<li><p><code>user</code>: The user, and optionally, group to run the exec process inside the container. Format is one of: <code>user</code>, <code>user:group</code>, <code>uid</code>, or <code>uid:gid</code>.
</p>
</li></ul>
</dd><dt><code>container_export</code></dt><dd><p>Export a container. Export the contents of a container as a tarball. Similar to the cli command <code>docker export</code>or <code>docker container export</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_export()</pre></dd><dt><code>container_archive</code></dt><dd><p>Get an archive of a filesystem resource in a container. Get a tar archive of a resource in the filesystem of container id.
</p>
<p><em>Usage:</em></p>
<pre>  container_archive(path, dest)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>path</code>: Resource in the container's filesystem to archive.
</p>
</li>
<li><p><code>dest</code>: Destination for the archive.  Must be either a scalar character (representing a filename) or <code>NULL</code>, in which case a raw vector is returned.
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>id</code></dt><dd><p>Return the container's id
</p>
<p><em>Usage:</em></p>
<pre>  id()</pre></dd><dt><code>image</code></dt><dd><p>Return the image for this container, as a <code><a href="#topic+docker_image">docker_image</a></code>object.
</p>
<p><em>Usage:</em></p>
<pre>  image()</pre></dd><dt><code>inspect</code></dt><dd><p>Return detailed information about this container. Similar to the cli command <code>docker container inspect</code>.
</p>
<p><em>Usage:</em></p>
<pre>  inspect(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a container has been removed.
</p>
</li></ul>
</dd><dt><code>container_kill</code></dt><dd><p>Kill a container. Send a POSIX signal to a container, defaulting to killing to the container. Similar to the cli command <code>docker kill</code>or <code>docker container kill</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_kill(signal = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>signal</code>: Signal to send to the container as an integer or string (e.g. <code>SIGINT</code>)
</p>
</li></ul>
</dd><dt><code>labels</code></dt><dd><p>Return labels for this container
</p>
<p><em>Usage:</em></p>
<pre>  labels(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a container has been removed.
</p>
</li></ul>
</dd><dt><code>container_logs</code></dt><dd><p>Get container logs. Get <code>stdout</code>and <code>stderr</code>logs from a container.
</p>
<p>Note: This endpoint works only for containers with the <code>json-file</code>or <code>journald</code>logging driver. Similar to the cli command <code>docker logs</code>or <code>docker container logs</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_logs(follow = NULL, stdout = TRUE, stderr = TRUE,
      since = NULL, timestamps = NULL, tail = NULL,
      stream = stdout())</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>follow</code>: Return the logs as a stream.
</p>
<p>This will return a <code>101</code>HTTP response with a <code>Connection: upgrade</code>header, then hijack the HTTP connection to send raw output. For more information about hijacking and the stream format, hrefhttps://docs.docker.com/engine/api/1.29/#operation/ContainerAttachsee the documentation for the attach endpoint.
</p>
</li>
<li><p><code>stdout</code>: Return logs from <code>stdout</code></p>
</li>
<li><p><code>stderr</code>: Return logs from <code>stderr</code></p>
</li>
<li><p><code>since</code>: Only return logs since this time, as a UNIX timestamp
</p>
</li>
<li><p><code>timestamps</code>: Add timestamps to every log line
</p>
</li>
<li><p><code>tail</code>: Only return this number of log lines from the end of the logs. Specify as an integer or <code>all</code>to output all log lines.
</p>
</li>
<li><p><code>stream</code>: The stream to send output to.  Options here are (1) a connection object (e.g. <code>stdout()</code>, <code>stderr()</code>or a writable open file connection object, (2) a scalar character indicating a filename to write to, or (3) <code>FALSE</code>or <code>NULL</code>to disable any output.
</p>
</li></ul>
</dd><dt><code>name</code></dt><dd><p>Return name for this container
</p>
<p><em>Usage:</em></p>
<pre>  name()</pre></dd><dt><code>container_path_stat</code></dt><dd><p>Get information about files in a container. A response header <code>X-Docker-Container-Path-Stat</code>is return containing a base64 - encoded JSON object with some filesystem header information about the path.
</p>
<p><em>Usage:</em></p>
<pre>  container_path_stat(path)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>path</code>: Resource in the container's filesystem to archive.
</p>
</li></ul>
</dd><dt><code>container_pause</code></dt><dd><p>Pause a container. Use the cgroups freezer to suspend all processes in a container.
</p>
<p>Traditionally, when suspending a process the <code>SIGSTOP</code>signal is used, which is observable by the process being suspended. With the cgroups freezer the process is unaware, and unable to capture, that it is being suspended, and subsequently resumed. Similar to the cli command <code>docker pause</code>or <code>docker container pause</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_pause()</pre></dd><dt><code>ports</code></dt><dd><p>Return a <code>data.frame</code>of information about ports opened by this container.  This is particularly useful in a container started with <code>ports = TRUE</code>, where container ports are mapped to random ports on the host. Similar to the cli command <code>docker container port</code>.
</p>
<p><em>Usage:</em></p>
<pre>  ports(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a container has been removed.
</p>
</li></ul>
</dd><dt><code>container_import</code></dt><dd><p>Extract an archive of files or folders to a directory in a container. Upload a tar archive to be extracted to a path in the filesystem of container id.
</p>
<p><em>Usage:</em></p>
<pre>  container_import(src, path, no_overwrite_dir_non_dir = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>src</code>: The input stream must be a tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.
</p>
</li>
<li><p><code>path</code>: Path to a directory in the container to extract the archive's contents into. 
</p>
</li>
<li><p><code>no_overwrite_dir_non_dir</code>: If '1', 'true', or 'True' then it will be an error if unpacking the given content would cause an existing directory to be replaced with a non-directory and vice versa.
</p>
</li></ul>
</dd><dt><code>reload</code></dt><dd><p>Refresh infomation on the container from the server, returning <code>$inspect()</code>invisibly.
</p>
<p><em>Usage:</em></p>
<pre>  reload()</pre></dd><dt><code>container_delete</code></dt><dd><p>Remove a container. Similar to the cli command <code>docker rm</code>or <code>docker container rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_delete(delete_volumes = NULL, force = NULL,
      link = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>delete_volumes</code>: Remove the volumes associated with the container.
</p>
</li>
<li><p><code>force</code>: If the container is running, kill it before removing it.
</p>
</li>
<li><p><code>link</code>: Remove the specified link associated with the container.
</p>
</li></ul>
</dd><dt><code>container_rename</code></dt><dd><p>Rename a container. Similar to the cli command <code>docker rename</code>or <code>docker container rename</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_rename(name)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>name</code>: New name for the container
</p>
</li></ul>
</dd><dt><code>container_resize</code></dt><dd><p>Resize a container TTY. Resize the TTY for a container. You must restart the container for the resize to take effect.
</p>
<p><em>Usage:</em></p>
<pre>  container_resize(h = NULL, w = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>h</code>: Height of the tty session in characters
</p>
</li>
<li><p><code>w</code>: Width of the tty session in characters
</p>
</li></ul>
</dd><dt><code>container_restart</code></dt><dd><p>Restart a container. Similar to the cli command <code>docker restart</code>or <code>docker container restart</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_restart(t = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>t</code>: Number of seconds to wait before killing the container
</p>
</li></ul>
</dd><dt><code>container_start</code></dt><dd><p>Start a container. Similar to the cli command <code>docker start</code>or <code>docker container start</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_start(detach_keys = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>detach_keys</code>: Override the key sequence for detaching a container. Format is a single character <code>[a-Z]</code>or <code>ctrl-&lt;value&gt;</code>where <code>&lt;value&gt;</code>is one of: <code>a-z</code>, <code>@</code>, <code>^</code>, <code>[</code>, <code>,</code>or <code>_</code>.
</p>
</li></ul>
</dd><dt><code>container_stats</code></dt><dd><p>Get container stats based on resource usage. This endpoint returns a live stream of a container's resource usage
statistics.
</p>
<p>The <code>precpu_stats</code>is the CPU statistic of last read, which is used
for calculating the CPU usage percentage. It is not the same as the
<code>cpu_stats</code>field.
</p>
<p>If either <code>precpu_stats.online_cpus</code>or <code>cpu_stats.online_cpus</code>is
nil then for compatibility with older daemons the length of the
corresponding <code>cpu_usage.percpu_usage</code>array should be used. Similar to the cli command <code>docker stats</code>or <code>docker container stats</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_stats()</pre></dd><dt><code>status</code></dt><dd><p>Short status of the container (&quot;running&quot;, &quot;exited&quot;, etc).
</p>
<p><em>Usage:</em></p>
<pre>  status(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Refresh container data?
</p>
</li></ul>
</dd><dt><code>container_stop</code></dt><dd><p>Stop a container. Similar to the cli command <code>docker stop</code>or <code>docker container stop</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_stop(t = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>t</code>: Number of seconds to wait before killing the container
</p>
</li></ul>
</dd><dt><code>container_top</code></dt><dd><p>List processes running inside a container. On Unix systems, this is done by running the <code>ps</code>command. This endpoint is not supported on Windows. Similar to the cli command <code>docker top</code>or <code>docker container top</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_top(ps_args = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>ps_args</code>: The arguments to pass to <code>ps</code>. For example, <code>aux</code></p>
</li></ul>
</dd><dt><code>container_unpause</code></dt><dd><p>Unpause a container. Resume a container which has been paused. Similar to the cli command <code>docker unpause</code>or <code>docker container unpause</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_unpause()</pre></dd><dt><code>container_update</code></dt><dd><p>Update a container. Change various configuration options of a container without having to recreate it. Similar to the cli command <code>docker update</code>or <code>docker container update</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_update(cpu_shares = NULL, memory = NULL,
      cgroup_parent = NULL, blkio_weight = NULL,
      blkio_weight_device = NULL, blkio_device_read_bps = NULL,
      blkio_device_write_bps = NULL,
      blkio_device_read_iops = NULL,
      blkio_device_write_iops = NULL, cpu_period = NULL,
      cpu_quota = NULL, cpu_realtime_period = NULL,
      cpu_realtime_runtime = NULL, cpuset_cpus = NULL,
      cpuset_mems = NULL, devices = NULL,
      device_cgroup_rules = NULL, disk_quota = NULL,
      kernel_memory = NULL, memory_reservation = NULL,
      memory_swap = NULL, memory_swappiness = NULL,
      nano_cpus = NULL, oom_kill_disable = NULL,
      pids_limit = NULL, ulimits = NULL, cpu_count = NULL,
      cpu_percent = NULL, io_maximum_iops = NULL,
      io_maximum_bandwidth = NULL, restart_policy = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>cpu_shares</code>: An integer value representing this container's relative CPU weight versus other containers.
</p>
</li>
<li><p><code>memory</code>: Memory limit in bytes.
</p>
</li>
<li><p><code>cgroup_parent</code>: Path to <code>cgroups</code>under which the container's <code>cgroup</code>is created. If the path is not absolute, the path is considered to be relative to the <code>cgroups</code>path of the init process. Cgroups are created if they do not already exist.
</p>
</li>
<li><p><code>blkio_weight</code>: Block IO weight (relative weight).
</p>
</li>
<li><p><code>blkio_weight_device</code>: Block IO weight (relative device weight) in the form <code>[{"Path": "device_path", "Weight": weight}]</code>.
</p>
</li>
<li><p><code>blkio_device_read_bps</code>: Limit read rate (bytes per second) from a device, in the form <code>[{"Path": "device_path", "Rate": rate}]</code>.
</p>
</li>
<li><p><code>blkio_device_write_bps</code>: Limit write rate (bytes per second) to a device, in the form <code>[{"Path": "device_path", "Rate": rate}]</code>.
</p>
</li>
<li><p><code>blkio_device_read_iops</code>: Limit read rate (IO per second) from a device, in the form <code>[{"Path": "device_path", "Rate": rate}]</code>.
</p>
</li>
<li><p><code>blkio_device_write_iops</code>: Limit write rate (IO per second) to a device, in the form <code>[{"Path": "device_path", "Rate": rate}]</code>.
</p>
</li>
<li><p><code>cpu_period</code>: The length of a CPU period in microseconds.
</p>
</li>
<li><p><code>cpu_quota</code>: Microseconds of CPU time that the container can get in a CPU period.
</p>
</li>
<li><p><code>cpu_realtime_period</code>: The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
</p>
</li>
<li><p><code>cpu_realtime_runtime</code>: The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
</p>
</li>
<li><p><code>cpuset_cpus</code>: CPUs in which to allow execution (e.g., <code>0-3</code>, <code>0,1</code>)
</p>
</li>
<li><p><code>cpuset_mems</code>: Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.
</p>
</li>
<li><p><code>devices</code>: A list of devices to add to the container.
</p>
</li>
<li><p><code>device_cgroup_rules</code>: a list of cgroup rules to apply to the container
</p>
</li>
<li><p><code>disk_quota</code>: Disk limit (in bytes).
</p>
</li>
<li><p><code>kernel_memory</code>: Kernel memory limit in bytes.
</p>
</li>
<li><p><code>memory_reservation</code>: Memory soft limit in bytes.
</p>
</li>
<li><p><code>memory_swap</code>: Total memory limit (memory + swap). Set as <code>-1</code>to enable unlimited swap.
</p>
</li>
<li><p><code>memory_swappiness</code>: Tune a container's memory swappiness behavior. Accepts an integer between 0 and 100.
</p>
</li>
<li><p><code>nano_cpus</code>: CPU quota in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPUs.
</p>
</li>
<li><p><code>oom_kill_disable</code>: Disable OOM Killer for the container.
</p>
</li>
<li><p><code>pids_limit</code>: Tune a container's pids limit. Set -1 for unlimited.
</p>
</li>
<li><p><code>ulimits</code>: A list of resource limits to set in the container. For example: <code>{"Name": "nofile", "Soft": 1024, "Hard": 2048}</code>&quot;
</p>
</li>
<li><p><code>cpu_count</code>: The number of usable CPUs (Windows only).
</p>
<p>On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is <code>CPUCount</code>first, then <code>CPUShares</code>, and <code>CPUPercent</code>last.
</p>
</li>
<li><p><code>cpu_percent</code>: The usable percentage of the available CPUs (Windows only).
</p>
<p>On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is <code>CPUCount</code>first, then <code>CPUShares</code>, and <code>CPUPercent</code>last.
</p>
</li>
<li><p><code>io_maximum_iops</code>: Maximum IOps for the container system drive (Windows only)
</p>
</li>
<li><p><code>io_maximum_bandwidth</code>: Maximum IO in bytes per second for the container system drive (Windows only)
</p>
</li>
<li><p><code>restart_policy</code>: The behavior to apply when the container exits. The default is not to restart.
</p>
<p>An ever increasing delay (double the previous delay, starting at 100ms) is added before each restart to prevent flooding the server.
</p>
</li></ul>
</dd><dt><code>container_wait</code></dt><dd><p>Wait for a container. Block until a container stops, then returns the exit code. Similar to the cli command <code>docker wait</code>or <code>docker container wait</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_wait()</pre></dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_container_collection">docker_container_collection</a></code> for other
container management methods.
</p>

<hr>
<h2 id='docker_container_collection'>Management commands for working with docker containers</h2><span id='topic+docker_container_collection'></span>

<h3>Description</h3>

<p>Methods for working with docker containers.  This object is
<code>$container</code> within a <code><a href="#topic+docker_client">docker_client</a></code> object.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>container_create</code></dt><dd><p>Create a container. Similar to the cli command <code>docker create</code>or <code>docker container create</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_create(image, cmd = NULL, hostname = NULL,
      domainname = NULL, user = NULL, attach_stdin = NULL,
      attach_stdout = NULL, attach_stderr = NULL, ports = NULL,
      tty = NULL, open_stdin = NULL, stdin_once = NULL,
      env = NULL, health_check = NULL, args_escaped = NULL,
      volumes = NULL, working_dir = NULL, entrypoint = NULL,
      network_disabled = NULL, mac_address = NULL,
      on_build = NULL, labels = NULL, stop_signal = NULL,
      stop_timeout = NULL, shell = NULL, host_config = NULL,
      network = NULL, name = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>image</code>: The name of the image to use when creating the container
</p>
</li>
<li><p><code>cmd</code>: Command to run specified as a string or an array of strings.
</p>
</li>
<li><p><code>hostname</code>: The hostname to use for the container, as a valid RFC 1123 hostname.
</p>
</li>
<li><p><code>domainname</code>: The domain name to use for the container.
</p>
</li>
<li><p><code>user</code>: The user that commands are run as inside the container.
</p>
</li>
<li><p><code>attach_stdin</code>: Whether to attach to <code>stdin</code>.
</p>
</li>
<li><p><code>attach_stdout</code>: Whether to attach to <code>stdout</code>.
</p>
</li>
<li><p><code>attach_stderr</code>: Whether to attach to <code>stderr</code>.
</p>
</li>
<li><p><code>ports</code>: A character vector of port mappings between the container and host, in (1) the form <code>&lt;host&gt;:&lt;container&gt;</code>(e.g., <code>10080:80</code>to map the container's port 80 to the host's port 10080), <code>&lt;ip&gt;:&lt;host&gt;:&lt;container&gt;</code>to bind a specific host interface as well as a port (e.g., you can use <code>localhost</code>or <code>127.0.0.1</code>for the first element), (3) form <code>&lt;port&gt;</code>to map the containers port to a random available port on the host s shorthand for <code>&lt;port&gt;:&lt;port&gt;</code>, or (3) a single logical value <code>TRUE</code>indicating to map all container ports to random available ports on the host. You can use the <code>$ports()</code>method in the <code><a href="#topic+docker_container">docker_container</a></code>object to query the port mapping of a running container.  Multiple values can be provided to map multiple ports to the host (e.g., <code>c("80", "443:443")</code>.
</p>
</li>
<li><p><code>tty</code>: Attach standard streams to a TTY, including <code>stdin</code>if it is not closed.
</p>
</li>
<li><p><code>open_stdin</code>: Open <code>stdin</code></p>
</li>
<li><p><code>stdin_once</code>: Close <code>stdin</code>after one attached client disconnects
</p>
</li>
<li><p><code>env</code>: A list of environment variables to set inside the container in the form <code>["VAR=value", ...]</code>. A variable without <code>=</code>is removed from the environment, rather than to have an empty value.
</p>
</li>
<li><p><code>health_check</code>: A test to perform to check that the container is healthy. Construct with <code>$types$health_config()</code></p>
</li>
<li><p><code>args_escaped</code>: Command is already escaped (Windows only)
</p>
</li>
<li><p><code>volumes</code>: A character vector of mappings of mount points on the host (or in volumes) to paths on the container.  Each element must be of the form <code>&lt;path_host&gt;:&lt;path_container&gt;</code>, possibly followed by <code>:ro</code>for read-only mappings (i.e., the same syntax as the docker command line client).
<code><a href="#topic+docker_volume">docker_volume</a></code>objects have a <code>$map</code>method to help with generating these paths for volume mappings.
</p>
</li>
<li><p><code>working_dir</code>: The working directory for commands to run in.
</p>
</li>
<li><p><code>entrypoint</code>: The entry point for the container as a string or an array of strings.
</p>
<p>If the array consists of exactly one empty string (<code>[""]</code>) then the entry point is reset to system default (i.e., the entry point used by docker when there is no <code>ENTRYPOINT</code>instruction in the <code>Dockerfile</code>).
</p>
</li>
<li><p><code>network_disabled</code>: Disable networking for the container.
</p>
</li>
<li><p><code>mac_address</code>: MAC address of the container.
</p>
</li>
<li><p><code>on_build</code>: <code>ONBUILD</code>metadata that were defined in the image's <code>Dockerfile</code>.
</p>
</li>
<li><p><code>labels</code>: User-defined key/value metadata.
</p>
</li>
<li><p><code>stop_signal</code>: Signal to stop a container as a string or unsigned integer.
</p>
</li>
<li><p><code>stop_timeout</code>: Timeout to stop a container in seconds.
</p>
</li>
<li><p><code>shell</code>: Shell for when <code>RUN</code>, <code>CMD</code>, and <code>ENTRYPOINT</code>uses a shell.
</p>
</li>
<li><p><code>host_config</code>: Container configuration that depends on the host we are running on
</p>
</li>
<li><p><code>network</code>: This container's networking configuration.
</p>
</li>
<li><p><code>name</code>: Assign the specified name to the container. Must match <code>/?[a-zA-Z0-9_-]+</code>.
</p>
</li></ul>
</dd><dt><code>get</code></dt><dd><p>Get a container by name or id
</p>
<p><em>Usage:</em></p>
<pre>  get(id)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: A scalar character with the container's name or id (abbreviations of the id are allowed and will be resolved by the docker daemon).
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>container_list</code></dt><dd><p>List containers. Similar to the cli command <code>docker ps</code>or <code>docker container ls</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_list(all = NULL, limit = NULL, size = NULL,
      filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>all</code>: Return all containers. By default, only running containers are shown
</p>
</li>
<li><p><code>limit</code>: Return this number of most recently created containers, including non-running ones.
</p>
</li>
<li><p><code>size</code>: Return the size of container as fields <code>SizeRw</code>and <code>SizeRootFs</code>.
</p>
</li>
<li><p><code>filters</code>: Filters to process on the container list, as a named character vector.  For example <code>c(status = "paused")</code>will only return paused containers. Available filters:
</p>
<ul>
<li><p><code>ancestor</code>=(<code>&lt;image-name&gt;[:&lt;tag&gt;]</code>, <code>&lt;image id&gt;</code>, or <code>&lt;image@digest&gt;</code>)
</p>
</li>
<li><p><code>before</code>=(<code>&lt;container id&gt;</code>or <code>&lt;container name&gt;</code>)
</p>
</li>
<li><p><code>expose</code>=(<code>&lt;port&gt;[/&lt;proto&gt;]</code>|<code>&lt;startport-endport&gt;/[&lt;proto&gt;]</code>)
</p>
</li>
<li><p><code>exited=&lt;int&gt;</code>containers with exit code of <code>&lt;int&gt;</code></p>
</li>
<li><p><code>health</code>=(<code>starting</code>|<code>healthy</code>|<code>unhealthy</code>|<code>none</code>)
</p>
</li>
<li><p><code>id=&lt;ID&gt;</code>a container's ID
</p>
</li>
<li><p><code>isolation=</code>(<code>default</code>|<code>process</code>|<code>hyperv</code>) (Windows daemon only)
</p>
</li>
<li><p><code>is-task=</code>(<code>true</code>|<code>false</code>)
</p>
</li>
<li><p><code>label=key</code>or <code>label="key=value"</code>of a container label
</p>
</li>
<li><p><code>name=&lt;name&gt;</code>a container's name
</p>
</li>
<li><p><code>network</code>=(<code>&lt;network id&gt;</code>or <code>&lt;network name&gt;</code>)
</p>
</li>
<li><p><code>publish</code>=(<code>&lt;port&gt;[/&lt;proto&gt;]</code>|<code>&lt;startport-endport&gt;/[&lt;proto&gt;]</code>)
</p>
</li>
<li><p><code>since</code>=(<code>&lt;container id&gt;</code>or <code>&lt;container name&gt;</code>)
</p>
</li>
<li><p><code>status=</code>(<code>created</code>|<code>restarting</code>|<code>running</code>|<code>removing</code>|<code>paused</code>|<code>exited</code>|<code>dead</code>)
</p>
</li>
<li><p><code>volume</code>=(<code>&lt;volume name&gt;</code>or <code>&lt;mount point destination&gt;</code>)
</p>
</li></ul>
</li></ul>
</dd><dt><code>container_prune</code></dt><dd><p>Delete stopped containers. Similar to the cli command <code>docker container prune</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_prune(filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>filters</code>: Filters to process on the prune list, as a named character vector.
</p>
<p>Available filters:
</p>
<ul>
<li><p><code>until=&lt;timestamp&gt;</code>Prune containers created before this timestamp. The <code>&lt;timestamp&gt;</code>can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. <code>10m</code>, <code>1h30m</code>) computed relative to the daemon machine's time.
</p>
</li></ul>
</li></ul>
</dd><dt><code>container_delete</code></dt><dd><p>Remove a container. Similar to the cli command <code>docker rm</code>or <code>docker container rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  container_delete(id, delete_volumes = NULL, force = NULL,
      link = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: ID or name of the container
</p>
</li>
<li><p><code>delete_volumes</code>: Remove the volumes associated with the container.
</p>
</li>
<li><p><code>force</code>: If the container is running, kill it before removing it.
</p>
</li>
<li><p><code>link</code>: Remove the specified link associated with the container.
</p>
</li></ul>
</dd><dt><code>run</code></dt><dd><p>Run a command in a new container. This method does rather a lot, and wraps several other methods.
It aims to mimic the behaviour of <code>docker run</code>in the command
line tool.  It will:
</p>
<ul>
<li><p>Try to pull a container if it does not yet exist (see
<code>$pull</code>in <code><a href="#topic+docker_image_collection">docker_image_collection</a></code>)
</p>
</li>
<li><p>Create the container (see <code>$create</code>in
<code><a href="#topic+docker_container_collection">docker_container_collection</a></code>)
</p>
</li>
<li><p>Start the container (see <code>$start</code>in <code><a href="#topic+docker_container">docker_container</a></code>)
</p>
</li>
<li><p>Optionally stream the logs, if not detached (see
<code>$logs</code>in <code><a href="#topic+docker_container">docker_container</a></code></p>
</li>
<li><p>Wait for the container to finish (see <code>$wait</code>in
<code><a href="#topic+docker_container">docker_container</a></code>)
</p>
</li></ul>
<p>It returns a list with a container object as
<code>"container"</code>and a <code>"docker_stream"</code>object
containing logs as <code>"logs"</code>).  If <code>rm = TRUE</code>and
<code>detach = TRUE</code>the container object will be of limited
utility and you will need to use <code>reload = FALSE</code>on many
methods (and some will not work) as the container will have
been removed on exit.
</p>
<p>Unlike the command line version, interrupting the streaming
logs will not necessarily kill the container but may leave it
running in the background.
</p>
<p>Unlike the command line version, the <code>attach = TRUE</code></p>
<p>simply attaches the output of the container and blocks
the R session until it is complete.  There is currently no way
of sending input into the docker container. Similar to the cli command <code>docker run</code>.
</p>
<p><em>Usage:</em></p>
<pre>  run(image, cmd = NULL, ..., detach = FALSE, rm = FALSE,
      stream = stdout(), host_config = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>image</code>: Image to run.  Can be a name, id, or a <code><a href="#topic+docker_image">docker_image</a></code>object.
</p>
</li>
<li><p><code>cmd</code>: Command to run in the container.  Must be a character vector.  If not specified then the default <code>ENTRYPOINT</code>and <code>CMD</code>will be used (see the docker documentation for details)
</p>
</li>
<li><p><code>...</code>: Additional arguments passed through to <code>$create</code>(see <code><a href="#topic+docker_container_collection">docker_container_collection</a></code>.  There are many possible arguments here.
</p>
</li>
<li><p><code>detach</code>: Detach the container as soon as it has started and return control to R.  The container will run in the background. The returned object can be used to interrogate the container afterwards (see <code><a href="#topic+docker_container">docker_container</a></code>).
</p>
</li>
<li><p><code>rm</code>: Remove the container on exit.
</p>
</li>
<li><p><code>stream</code>: The stream to use to send output to, if <code>detach = FALSE</code>.  The default uses the standard output stream (i.e., where <code>cat</code>would send output).  Other valid values are an R connection object, a string (interpreted as a filename) or <code>FALSE</code>to prevent any output.
</p>
</li>
<li><p><code>host_config</code>: Passed through to <code>$create</code>, as with <code>...</code>.
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_container">docker_container</a></code> for information on
container objects.
</p>

<hr>
<h2 id='docker_exec'>Commands for working with a docker exec instance</h2><span id='topic+docker_exec'></span>

<h3>Description</h3>

<p>Methods for working with docker &quot;exec&quot; instances, which are
returned by running <code>exec</code> on a running container
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>id</code></dt><dd><p>Return the exec instance's id
</p>
<p><em>Usage:</em></p>
<pre>  id()</pre></dd><dt><code>inspect</code></dt><dd><p>Return detailed information about this exec instance
</p>
<p><em>Usage:</em></p>
<pre>  inspect(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.
</p>
</li></ul>
</dd><dt><code>reload</code></dt><dd><p>Refresh infomation on the exec instance from the server, returning <code>$inspect()</code>invisibly.
</p>
<p><em>Usage:</em></p>
<pre>  reload()</pre></dd><dt><code>exec_resize</code></dt><dd><p>Resize an exec instance. Resize the TTY session used by an exec instance. This endpoint only works if <code>tty</code>was specified as part of creating and starting the exec instance.
</p>
<p><em>Usage:</em></p>
<pre>  exec_resize(h = NULL, w = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>h</code>: Height of the TTY session in characters
</p>
</li>
<li><p><code>w</code>: Width of the TTY session in characters
</p>
</li></ul>
</dd><dt><code>exec_start</code></dt><dd><p>Start an exec instance. Starts a previously set up exec instance. If detach is true, this endpoint returns immediately after starting the command. Otherwise, it sets up an interactive session with the command.
</p>
<p><em>Usage:</em></p>
<pre>  exec_start(detach = FALSE, tty = NULL, stream = stdout())</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>detach</code>: Detach from the command.
</p>
</li>
<li><p><code>tty</code>: Allocate a pseudo-TTY.
</p>
</li>
<li><p><code>stream</code>: The stream to send output to.  Options here are (1) a connection object (e.g. <code>stdout()</code>, <code>stderr()</code>or a writable open file connection object, (2) a scalar character indicating a filename to write to, or (3) <code>FALSE</code>or <code>NULL</code>to disable any output.
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_container">docker_container</a></code>
</p>

<hr>
<h2 id='docker_image'>Management commands for working with a particular docker image</h2><span id='topic+docker_image'></span>

<h3>Description</h3>

<p>Methods for working with a particular docker image.  Image objects
are returned by building or pulling a docker image, or by using
<code>$image$get</code> to fetch an existing image by name or id.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>image_tarball</code></dt><dd><p>Export an image. Get a tarball containing all images and metadata for a repository.
</p>
<p>If <code>name</code>is a specific name and tag (e.g. <code>ubuntu:latest</code>), then only that image (and its parents) are returned. If <code>name</code>is an image ID, similarly only that image (and its parents) are returned, but with the exclusion of the <code>repositories</code>file in the tarball, as there were no image names referenced.
</p>
<p>### Image tarball format
</p>
<p>An image tarball contains one directory per image layer (named using its long ID), each containing these files:
</p>
<ul>
<li><p><code>VERSION</code>: currently <code>1.0</code>- the file format version
</p>
</li>
<li><p><code>json</code>: detailed layer information, similar to <code>docker inspect layer_id</code></p>
</li>
<li><p><code>layer.tar</code>: A tarfile containing the filesystem changes in this layer
</p>
</li></ul>
<p>The <code>layer.tar</code>file contains <code>aufs</code>style <code>.wh..wh.aufs</code>files and directories for storing attribute changes and deletions.
</p>
<p>If the tarball defines a repository, the tarball should also include a <code>repositories</code>file at the root that contains a list of repository and tag names mapped to layer IDs.
</p>
<pre>json
{
  "hello-world": {
    "latest": "565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1"
  }
}
</pre><p>. Similar to the cli command <code>docker image save</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_tarball()</pre></dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>image_history</code></dt><dd><p>Get the history of an image. Return parent layers of an image. Similar to the cli command <code>docker image history</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_history()</pre></dd><dt><code>id</code></dt><dd><p>Return the image's id
</p>
<p><em>Usage:</em></p>
<pre>  id()</pre></dd><dt><code>inspect</code></dt><dd><p>Return detailed information about this image. Similar to the cli command <code>docker image inspect</code>.
</p>
<p><em>Usage:</em></p>
<pre>  inspect(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after an image has been removed.
</p>
</li></ul>
</dd><dt><code>labels</code></dt><dd><p>Return labels for this image
</p>
<p><em>Usage:</em></p>
<pre>  labels(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after an image has been removed.
</p>
</li></ul>
</dd><dt><code>name</code></dt><dd><p>Return name for this image
</p>
<p><em>Usage:</em></p>
<pre>  name()</pre></dd><dt><code>reload</code></dt><dd><p>Refresh infomation on the image from the server, returning <code>$inspect()</code>invisibly.
</p>
<p><em>Usage:</em></p>
<pre>  reload()</pre></dd><dt><code>image_delete</code></dt><dd><p>Remove an image. Remove an image, along with any untagged parent images that were
referenced by that image.
</p>
<p>Images can't be removed if they have descendant images, are being
used by a running container or are being used by a build. Similar to the cli command <code>docker rmi</code>or <code>docker image rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_delete(force = NULL, noprune = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>force</code>: Remove the image even if it is being used by stopped containers or has other tags
</p>
</li>
<li><p><code>noprune</code>: Do not delete untagged parent images
</p>
</li></ul>
</dd><dt><code>short_id</code></dt><dd><p>Abbreviated identifier, truncated to 10 characters (perhaps plus the leading <code>sha256:</code></p>
<p><em>Usage:</em></p>
<pre>  short_id()</pre></dd><dt><code>image_tag</code></dt><dd><p>Tag an image. Tag an image so that it becomes part of a repository. Similar to the cli command <code>docker tag</code>or <code>docker image tag</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_tag(repo, tag = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>repo</code>: The repository to tag in. For example, <code>someuser/someimage</code>.
</p>
</li>
<li><p><code>tag</code>: The name of the new tag.
</p>
</li></ul>
</dd><dt><code>tags</code></dt><dd><p>Return tags for this image
</p>
<p><em>Usage:</em></p>
<pre>  tags(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after an image has been removed.
</p>
</li></ul>
</dd><dt><code>untag</code></dt><dd><p>Remove tags from the image.  This is a lot like <code>image$remove</code>(see <code><a href="#topic+docker_image_collection">docker_image_collection</a></code>) but with <code>noprune = TRUE</code>.
</p>
<p><em>Usage:</em></p>
<pre>  untag(repo_tag)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>repo_tag</code>: Tags to remove
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_image_collection">docker_image_collection</a></code> for other
image management methods.
</p>

<hr>
<h2 id='docker_image_collection'>Management commands for working with docker images</h2><span id='topic+docker_image_collection'></span>

<h3>Description</h3>

<p>Methods for working with docker images.  This object is
<code>$image</code> within a <code><a href="#topic+docker_client">docker_client</a></code> object.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>image_build</code></dt><dd><p>Build an image. Build an image from a tar archive with a <code>Dockerfile</code>in it.
</p>
<p>The <code>Dockerfile</code>specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the <code>dockerfile</code>parameter. <a href="https://docs.docker.com/engine/reference/builder/">See the <code>Dockerfile</code>reference for more information</a>.
</p>
<p>The Docker daemon performs a preliminary validation of the <code>Dockerfile</code>before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.
</p>
<p>The build is canceled if the client drops the connection by quitting or being killed. Similar to the cli command <code>docker build</code>or <code>docker image build</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_build(context, dockerfile = NULL, tag = NULL,
      extrahosts = NULL, remote = NULL, q = NULL,
      nocache = NULL, cachefrom = NULL, pull = NULL, rm = NULL,
      forcerm = NULL, memory = NULL, memswap = NULL,
      cpushares = NULL, cpusetcpus = NULL, cpuperiod = NULL,
      cpuquota = NULL, buildargs = NULL, shmsize = NULL,
      squash = NULL, labels = NULL, networkmode = NULL,
      registry_config = NULL, stream = stdout())</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>context</code>: A tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.
</p>
</li>
<li><p><code>dockerfile</code>: Path within the build context to the <code>Dockerfile</code>. This is ignored if <code>remote</code>is specified and points to an external <code>Dockerfile</code>.
</p>
</li>
<li><p><code>tag</code>: A name and optional tag to apply to the image in the <code>name:tag</code>format. If you omit the tag the default <code>latest</code>value is assumed. You can provide a vector of mutiple tags here.
</p>
</li>
<li><p><code>extrahosts</code>: Extra hosts to add to /etc/hosts
</p>
</li>
<li><p><code>remote</code>: A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file's contents are placed into a file called <code>Dockerfile</code>and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the <code>dockerfile</code>parameter is also specified, there must be a file with the corresponding path inside the tarball.
</p>
</li>
<li><p><code>q</code>: Suppress verbose build output.
</p>
</li>
<li><p><code>nocache</code>: Do not use the cache when building the image.
</p>
</li>
<li><p><code>cachefrom</code>: JSON array of images used for build cache resolution.
</p>
</li>
<li><p><code>pull</code>: Attempt to pull the image even if an older image exists locally.
</p>
</li>
<li><p><code>rm</code>: Remove intermediate containers after a successful build.
</p>
</li>
<li><p><code>forcerm</code>: Always remove intermediate containers, even upon failure.
</p>
</li>
<li><p><code>memory</code>: Set memory limit for build.
</p>
</li>
<li><p><code>memswap</code>: Total memory (memory + swap). Set as <code>-1</code>to disable swap.
</p>
</li>
<li><p><code>cpushares</code>: CPU shares (relative weight).
</p>
</li>
<li><p><code>cpusetcpus</code>: CPUs in which to allow execution (e.g., <code>0-3</code>, <code>0,1</code>).
</p>
</li>
<li><p><code>cpuperiod</code>: The length of a CPU period in microseconds.
</p>
</li>
<li><p><code>cpuquota</code>: Microseconds of CPU time that the container can get in a CPU period.
</p>
</li>
<li><p><code>buildargs</code>: JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the <code>Dockerfile</code>RUN instruction, or for variable expansion in other <code>Dockerfile</code>instructions. This is not meant for passing secret values. <a href="https://docs.docker.com/engine/reference/builder/#arg">Read more about the buildargs instruction.</a></p>
</li>
<li><p><code>shmsize</code>: Size of <code>/dev/shm</code>in bytes. The size must be greater than 0. If omitted the system uses 64MB.
</p>
</li>
<li><p><code>squash</code>: Squash the resulting images layers into a single layer. <em>(Experimental release only.)</em></p>
</li>
<li><p><code>labels</code>: Arbitrary key/value labels to set on the image, as a JSON map of string pairs.
</p>
</li>
<li><p><code>networkmode</code>: Sets the networking mode for the run commands during build. Supported standard values are: <code>bridge</code>, <code>host</code>, <code>none</code>, and <code>container:&lt;name|id&gt;</code>. Any other value is taken as a custom network's name to which this container should connect to.
</p>
</li>
<li><p><code>registry_config</code>: This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.
</p>
<p>The key is a registry URL, and the value is an auth configuration object, hrefhttps://docs.docker.com/engine/api/1.29/#section/Authenticationas described in the authentication section. For example:
</p>
<pre>
{
  "docker.example.com": {
    "username": "janedoe",
    "password": "hunter2"
  },
  "https://index.docker.io/v1/": {
    "username": "mobydock",
    "password": "conta1n3rize14"
  }
}
</pre><p>Only the registry domain name (and port if not the default 443) are required. However, for legacy reasons, the Docker Hub registry must be specified with both a <code>https://</code>prefix and a <code>/v1/</code>suffix even though Docker will prefer to use the v2 registry API.
</p>
</li>
<li><p><code>stream</code>: The stream to send output to.  Options here are (1) a connection object (e.g. <code>stdout()</code>, <code>stderr()</code>or a writable open file connection object, (2) a scalar character indicating a filename to write to, or (3) <code>FALSE</code>or <code>NULL</code>to disable any output.
</p>
</li></ul>
</dd><dt><code>image_build_clean</code></dt><dd><p>Delete builder cache. Unimplemented, as 'image_build_clean' (POST /build/prune) requires docker API version at least 1.31 (version 1.29 used)
</p>
<p><em>Usage:</em></p>
<pre>  image_build_clean(...)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>...</code>: Ignored in this version
</p>
</li></ul>
</dd><dt><code>image_export</code></dt><dd><p>Export several images. Get a tarball containing all images and metadata for several image repositories.
</p>
<p>For each value of the <code>names</code>parameter: if it is a specific name and tag (e.g. <code>ubuntu:latest</code>), then only that image (and its parents) are returned; if it is an image ID, similarly only that image (and its parents) are returned and there would be no names referenced in the 'repositories' file for this image ID.
</p>
<p>For details on the format, see hrefhttps://docs.docker.com/engine/api/1.29/#operation/ImageGetthe export image endpoint. Similar to the cli command <code>docker image save</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_export(names = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>names</code>: Image names to filter by
</p>
</li></ul>
</dd><dt><code>get</code></dt><dd><p>Get an image by name or id
</p>
<p><em>Usage:</em></p>
<pre>  get(id)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: A scalar character with the image's name or id (abbreviations of the id are allowed and will be resolved by the docker daemon).
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>image_import</code></dt><dd><p>Import images. Load a set of images and tags into a repository.
</p>
<p>For details on the format, see hrefhttps://docs.docker.com/engine/api/1.29/#operation/ImageGetthe export image endpoint. Similar to the cli command <code>docker image import</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_import(images_tarball = NULL, quiet = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>images_tarball</code>: Tar archive containing images
</p>
</li>
<li><p><code>quiet</code>: Suppress progress details during load.
</p>
</li></ul>
</dd><dt><code>image_list</code></dt><dd><p>List Images. Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image. Similar to the cli command <code>docker images</code>or <code>docker image list</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_list(all = NULL, filters = NULL, digests = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>all</code>: Show all images. Only images from a final layer (no children) are shown by default.
</p>
</li>
<li><p><code>filters</code>: A named character vector of filters to process on the images list. Available filters:
</p>
<ul>
<li><p><code>before</code>=(<code>&lt;image-name&gt;[:&lt;tag&gt;]</code>,  <code>&lt;image id&gt;</code>or <code>&lt;image@digest&gt;</code>)
</p>
</li>
<li><p><code>dangling=true</code></p>
</li>
<li><p><code>label=key</code>or <code>label="key=value"</code>of an image label
</p>
</li>
<li><p><code>reference</code>=(<code>&lt;image-name&gt;[:&lt;tag&gt;]</code>)
</p>
</li>
<li><p><code>since</code>=(<code>&lt;image-name&gt;[:&lt;tag&gt;]</code>,  <code>&lt;image id&gt;</code>or <code>&lt;image@digest&gt;</code>)
</p>
</li></ul>
</li>
<li><p><code>digests</code>: Show digest information as a <code>RepoDigests</code>field on each image.
</p>
</li></ul>
</dd><dt><code>image_prune</code></dt><dd><p>Delete unused images. Similar to the cli command <code>docker image prune</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_prune(filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>filters</code>: Filters to process on the prune list, as a named character vector. Available filters:
</p>
<ul>
<li><p><code>dangling=&lt;boolean&gt;</code>When set to <code>true</code>(or <code>1</code>), prune only
unused <em>and</em>untagged images. When set to <code>false</code></p>
<p>(or <code>0</code>), all unused images are pruned.
</p>
</li>
<li><p><code>until=&lt;string&gt;</code>Prune images created before this timestamp. The <code>&lt;timestamp&gt;</code>can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. <code>10m</code>, <code>1h30m</code>) computed relative to the daemon machine's time.
</p>
</li></ul>
</li></ul>
</dd><dt><code>image_create</code></dt><dd><p>Create an image. Create an image by either pulling it from a registry or importing it. Similar to the cli command <code>docker pull</code>or <code>docker image pull</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_create(name, tag = NULL, stream = stdout())</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>name</code>: Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed.
</p>
</li>
<li><p><code>tag</code>: Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled.
</p>
</li>
<li><p><code>stream</code>: The stream to send output to.  Options here are (1) a connection object (e.g. <code>stdout()</code>, <code>stderr()</code>or a writable open file connection object, (2) a scalar character indicating a filename to write to, or (3) <code>FALSE</code>or <code>NULL</code>to disable any output.
</p>
</li></ul>
</dd><dt><code>image_push</code></dt><dd><p>Push an image. Push an image to a registry.
</p>
<p>If you wish to push an image on to a private registry, that image must already have a tag which references the registry. For example, <code>registry.example.com/myimage:latest</code>.
</p>
<p>The push is cancelled if the HTTP connection is closed. Similar to the cli command <code>docker push</code>or <code>docker image push</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_push(name, stream = stdout())</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>name</code>: Image name or ID.
</p>
</li>
<li><p><code>stream</code>: The stream to send output to.  Options here are (1) a connection object (e.g. <code>stdout()</code>, <code>stderr()</code>or a writable open file connection object, (2) a scalar character indicating a filename to write to, or (3) <code>FALSE</code>or <code>NULL</code>to disable any output.
</p>
</li></ul>
</dd><dt><code>image_delete</code></dt><dd><p>Remove an image. Remove an image, along with any untagged parent images that were
referenced by that image.
</p>
<p>Images can't be removed if they have descendant images, are being
used by a running container or are being used by a build. Similar to the cli command <code>docker rmi</code>or <code>docker image rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_delete(name, force = NULL, noprune = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>name</code>: Image name or ID
</p>
</li>
<li><p><code>force</code>: Remove the image even if it is being used by stopped containers or has other tags
</p>
</li>
<li><p><code>noprune</code>: Do not delete untagged parent images
</p>
</li></ul>
</dd><dt><code>image_search</code></dt><dd><p>Search images. Search for an image on Docker Hub. Similar to the cli command <code>docker search</code>.
</p>
<p><em>Usage:</em></p>
<pre>  image_search(term, limit = NULL, filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>term</code>: Term to search
</p>
</li>
<li><p><code>limit</code>: Maximum number of results to return
</p>
</li>
<li><p><code>filters</code>: A named character vector of filters to process on the images list. Available filters:
</p>
<ul>
<li><p><code>is-automated=(true|false)</code></p>
</li>
<li><p><code>is-official=(true|false)</code></p>
</li>
<li><p><code>stars=&lt;number&gt;</code>Matches images that has at least 'number' stars.
</p>
</li></ul>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_image">docker_image</a></code> for information on
image objects.
</p>

<hr>
<h2 id='docker_network'>Management commands for working with a particular docker network</h2><span id='topic+docker_network'></span>

<h3>Description</h3>

<p>Methods for working with a particular docker network.  Network
objects are returned by creating a docker network, or by using
<code>$network$get</code> to fetch an existing network by name or id.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>network_connect</code></dt><dd><p>Connect a container to a network. Similar to the cli command <code>docker network connect</code>.
</p>
<p><em>Usage:</em></p>
<pre>  network_connect(container = NULL, endpoint_config = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>container</code>: The ID or name of the container to connect to the network.
</p>
</li>
<li><p><code>endpoint_config</code>: Configuration for a network endpoint.
</p>
</li></ul>
</dd><dt><code>containers</code></dt><dd><p>Return containers connected to this network
</p>
<p><em>Usage:</em></p>
<pre>  containers(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon (usually what you want).
</p>
</li></ul>
</dd><dt><code>network_disconnect</code></dt><dd><p>Disconnect a container from a network. Similar to the cli command <code>docker network disconnect</code>.
</p>
<p><em>Usage:</em></p>
<pre>  network_disconnect(container = NULL, force = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>container</code>: The ID or name of the container to disconnect from the network.
</p>
</li>
<li><p><code>force</code>: Force the container to disconnect from the network.
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>id</code></dt><dd><p>Return the network's id
</p>
<p><em>Usage:</em></p>
<pre>  id()</pre></dd><dt><code>inspect</code></dt><dd><p>Return detailed information about this network. Similar to the cli command <code>docker network inspect</code>.
</p>
<p><em>Usage:</em></p>
<pre>  inspect(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after an network has been removed.
</p>
</li></ul>
</dd><dt><code>name</code></dt><dd><p>Return name for this network
</p>
<p><em>Usage:</em></p>
<pre>  name(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a network has been removed.
</p>
</li></ul>
</dd><dt><code>reload</code></dt><dd><p>Refresh infomation on the network from the server, returning <code>$inspect()</code>invisibly.
</p>
<p><em>Usage:</em></p>
<pre>  reload()</pre></dd><dt><code>network_delete</code></dt><dd><p>Remove a network. Similar to the cli command <code>docker network rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  network_delete()</pre></dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_network_collection">docker_network_collection</a></code> for other
network management methods.
</p>

<hr>
<h2 id='docker_network_collection'>Management commands for working with docker networks</h2><span id='topic+docker_network_collection'></span>

<h3>Description</h3>

<p>Methods for working with docker networks.  This object is
<code>$network</code> within a <code><a href="#topic+docker_client">docker_client</a></code> object.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>network_create</code></dt><dd><p>Create a network. Similar to the cli command <code>docker network create</code>.
</p>
<p><em>Usage:</em></p>
<pre>  network_create(name = NULL, check_duplicate = TRUE,
      driver = NULL, internal = NULL, attachable = NULL,
      ingress = NULL, ipam = NULL, enable_ipv6 = NULL,
      options = NULL, labels = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>name</code>: The network's name.
</p>
</li>
<li><p><code>check_duplicate</code>: Check for networks with duplicate names. Since Network is primarily keyed based on a random ID and not on the name, and network name is strictly a user-friendly alias to the network which is uniquely identified using ID, there is no guaranteed way to check for duplicates. CheckDuplicate is there to provide a best effort checking of any networks which has the same name but it is not guaranteed to catch all name collisions.
</p>
</li>
<li><p><code>driver</code>: Name of the network driver plugin to use.
</p>
</li>
<li><p><code>internal</code>: Restrict external access to the network.
</p>
</li>
<li><p><code>attachable</code>: Globally scoped network is manually attachable by regular containers from workers in swarm mode.
</p>
</li>
<li><p><code>ingress</code>: Ingress network is the network which provides the routing-mesh in swarm mode.
</p>
</li>
<li><p><code>ipam</code>: Optional custom IP scheme for the network.
</p>
</li>
<li><p><code>enable_ipv6</code>: Enable IPv6 on the network.
</p>
</li>
<li><p><code>options</code>: Network specific options to be used by the drivers.
</p>
</li>
<li><p><code>labels</code>: User-defined key/value metadata.
</p>
</li></ul>
</dd><dt><code>get</code></dt><dd><p>Get a network by name or id
</p>
<p><em>Usage:</em></p>
<pre>  get(id)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: A scalar character with the network's name or id (abbreviations of the id are allowed and will be resolved by the docker daemon).
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>network_list</code></dt><dd><p>List networks. Similar to the cli command <code>docker network ls</code>.
</p>
<p><em>Usage:</em></p>
<pre>  network_list(filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>filters</code>: A named character vector of filters to process on the networks list. Available filters:
</p>
<ul>
<li><p><code>driver=&lt;driver-name&gt;</code>Matches a network's driver.
</p>
</li>
<li><p><code>id=&lt;network-id&gt;</code>Matches all or part of a network ID.
</p>
</li>
<li><p><code>label=&lt;key&gt;</code>or <code>label=&lt;key&gt;=&lt;value&gt;</code>of a network label.
</p>
</li>
<li><p><code>name=&lt;network-name&gt;</code>Matches all or part of a network name.
</p>
</li>
<li><p><code>scope=["swarm"|"global"|"local"]</code>Filters networks by scope (<code>swarm</code>, <code>global</code>, or <code>local</code>).
</p>
</li>
<li><p><code>type=["custom"|"builtin"]</code>Filters networks by type. The <code>custom</code>keyword returns all user-defined networks.
</p>
</li></ul>
</li></ul>
</dd><dt><code>network_prune</code></dt><dd><p>Delete unused networks. Similar to the cli command <code>docker network prune</code>.
</p>
<p><em>Usage:</em></p>
<pre>  network_prune(filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>filters</code>: Filters to process on the prune list, as a named character vector.
</p>
<p>Available filters:
</p>
<ul>
<li><p><code>until=&lt;timestamp&gt;</code>Prune networks created before this timestamp. The <code>&lt;timestamp&gt;</code>can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. <code>10m</code>, <code>1h30m</code>) computed relative to the daemon machine's time.
</p>
</li></ul>
</li></ul>
</dd><dt><code>network_delete</code></dt><dd><p>Remove a network. Similar to the cli command <code>docker network rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  network_delete(id)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: Network ID or name
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_network">docker_network</a></code> for information on
network objects.
</p>

<hr>
<h2 id='docker_node'>Management commands for working with a particular docker node</h2><span id='topic+docker_node'></span>

<h3>Description</h3>

<p>Methods for working with a particular docker node.  Node objects
are by using <code>$node$get</code> to fetch an existing node by name or
id.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>availability</code></dt><dd><p>Return the node's availability (active, pause, drain)
</p>
<p><em>Usage:</em></p>
<pre>  availability(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a node has been removed.
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>hostname</code></dt><dd><p>Return the node's hostname
</p>
<p><em>Usage:</em></p>
<pre>  hostname(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a node has been removed.
</p>
</li></ul>
</dd><dt><code>id</code></dt><dd><p>Return the node's id
</p>
<p><em>Usage:</em></p>
<pre>  id()</pre></dd><dt><code>inspect</code></dt><dd><p>Return detailed information about this node. Similar to the cli command <code>docker node inspect</code>.
</p>
<p><em>Usage:</em></p>
<pre>  inspect(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a node has been removed.
</p>
</li></ul>
</dd><dt><code>reload</code></dt><dd><p>Refresh infomation on the node from the server, returning <code>$inspect()</code>invisibly.
</p>
<p><em>Usage:</em></p>
<pre>  reload()</pre></dd><dt><code>role</code></dt><dd><p>Return the node's role (worker, manager))
</p>
<p><em>Usage:</em></p>
<pre>  role(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a node has been removed.
</p>
</li></ul>
</dd><dt><code>status</code></dt><dd><p>Return the node's status (
</p>
<p><em>Usage:</em></p>
<pre>  status(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a node has been removed.
</p>
</li></ul>
</dd><dt><code>node_update</code></dt><dd><p>Update a node. Similar to the cli command <code>docker node update</code>.
</p>
<p><em>Usage:</em></p>
<pre>  node_update(version, name = NULL, labels = NULL, role = NULL,
      availability = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>version</code>: The version number of the node object being updated. This is required to avoid conflicting writes.
</p>
</li>
<li><p><code>name</code>: Name for the node.
</p>
</li>
<li><p><code>labels</code>: User-defined key/value metadata.
</p>
</li>
<li><p><code>role</code>: Role of the node.
</p>
</li>
<li><p><code>availability</code>: Availability of the node.
</p>
</li></ul>
</dd><dt><code>version</code></dt><dd><p>Return the node's version.  This is used by some other methods to avoid conflicting writes.
</p>
<p><em>Usage:</em></p>
<pre>  version(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a node has been removed.
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_node_collection">docker_node_collection</a></code> for other
node management methods.
</p>

<hr>
<h2 id='docker_node_collection'>Management commands for working with swarm nodes</h2><span id='topic+docker_node_collection'></span>

<h3>Description</h3>

<p>Methods for managing docker swarm nodes.  This object is
<code>$node</code> within a <code><a href="#topic+docker_client">docker_client</a></code> object.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>node_delete</code></dt><dd><p>Delete a node. Similar to the cli command <code>docker node rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  node_delete(id, force = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: The ID or name of the node
</p>
</li>
<li><p><code>force</code>: Force remove a node from the swarm
</p>
</li></ul>
</dd><dt><code>get</code></dt><dd><p>Get a service by name or id
</p>
<p><em>Usage:</em></p>
<pre>  get(id)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: A scalar character with the network's name or id (abbreviations of the id are allowed and will be resolved by the docker daemon).
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>node_list</code></dt><dd><p>List nodes. Similar to the cli command <code>docker node list</code>.
</p>
<p><em>Usage:</em></p>
<pre>  node_list(filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>filters</code>: Filters to process on the nodes list, as a named character vector.
</p>
<p>Available filters:
</p>
<ul>
<li><p><code>id=&lt;node id&gt;</code></p>
</li>
<li><p><code>label=&lt;engine label&gt;</code></p>
</li>
<li><p><code>membership</code>=(<code>accepted</code>|<code>pending</code>)
</p>
</li>
<li><p><code>name=&lt;node name&gt;</code></p>
</li>
<li><p><code>role</code>=(<code>manager</code>|<code>worker</code>)
</p>
</li></ul>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_swarm_collection">docker_swarm_collection</a></code> for management
commands for the swarm itself.
</p>

<hr>
<h2 id='docker_plugin'>Management commands for working with a particular docker plugin</h2><span id='topic+docker_plugin'></span>

<h3>Description</h3>

<p>Methods for working with a particular docker plugin.  Plugin
objects are returned by installing or building a docker plugin, or
by using <code>$plugin$get</code> to fetch an existing plugin by name
or id.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>plugin_configure</code></dt><dd><p>Configure a plugin. Similar to the cli command <code>docker plugin set</code>.
</p>
<p><em>Usage:</em></p>
<pre>  plugin_configure(body = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>body</code>: NA
</p>
</li></ul>
</dd><dt><code>plugin_disable</code></dt><dd><p>Disable a plugin. Similar to the cli command <code>docker plugin disable</code>.
</p>
<p><em>Usage:</em></p>
<pre>  plugin_disable()</pre></dd><dt><code>plugin_enable</code></dt><dd><p>Enable a plugin. Similar to the cli command <code>docker plugin enable</code>.
</p>
<p><em>Usage:</em></p>
<pre>  plugin_enable(timeout = 0L)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>timeout</code>: Set the HTTP client timeout (in seconds)
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>id</code></dt><dd><p>Return the plugins' id
</p>
<p><em>Usage:</em></p>
<pre>  id()</pre></dd><dt><code>inspect</code></dt><dd><p>Return detailed information about this plugin
</p>
<p><em>Usage:</em></p>
<pre>  inspect(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a plugin has been removed.
</p>
</li></ul>
</dd><dt><code>is_enabled</code></dt><dd><p>Test if plugin is enabled
</p>
<p><em>Usage:</em></p>
<pre>  is_enabled(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a plugin has been removed.
</p>
</li></ul>
</dd><dt><code>name</code></dt><dd><p>Return the plugin's name
</p>
<p><em>Usage:</em></p>
<pre>  name()</pre></dd><dt><code>reload</code></dt><dd><p>Refresh infomation on the plugin from the server, returning <code>$inspect()</code>invisibly.
</p>
<p><em>Usage:</em></p>
<pre>  reload()</pre></dd><dt><code>plugin_remove</code></dt><dd><p>Remove a plugin. Similar to the cli command <code>docker plugin rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  plugin_remove(force = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>force</code>: Disable the plugin before removing. This may result in issues if the plugin is in use by a container.
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_plugin_collection">docker_plugin_collection</a></code> for other
plugin management methods.
</p>

<hr>
<h2 id='docker_plugin_collection'>Management commands for working with docker plugins</h2><span id='topic+docker_plugin_collection'></span>

<h3>Description</h3>

<p>Methods for working with docker plugins.  This object is
<code>$plugin</code> within a <code><a href="#topic+docker_client">docker_client</a></code> object.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>plugin_create</code></dt><dd><p>Create a plugin. Similar to the cli command <code>docker plugin create</code>.
</p>
<p><em>Usage:</em></p>
<pre>  plugin_create(name, plugin_data_dir)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>name</code>: The name of the plugin. The <code>:latest</code>tag is optional, and is the default if omitted.
</p>
</li>
<li><p><code>plugin_data_dir</code>: Path to tar containing plugin rootfs and manifest
</p>
</li></ul>
</dd><dt><code>get</code></dt><dd><p>Get a plugin by name or id
</p>
<p><em>Usage:</em></p>
<pre>  get(name)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>name</code>: A scalar character with the plugins' name.
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>plugin_install</code></dt><dd><p>Install a plugin. Pulls and installs a plugin. After the plugin is installed, it can be enabled using the hrefhttps://docs.docker.com/engine/api/1.29/#operation/PostPluginsEnable<code>POST /plugins/{name}/enable</code>endpoint. Similar to the cli command <code>docker plugin install</code>.
</p>
<p><em>Usage:</em></p>
<pre>  plugin_install(remote, alias = NULL, registry_auth = NULL,
      disable = FALSE, grant_all = NULL, stream = stdout())</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>remote</code>: Remote reference for plugin to install.
</p>
<p>The <code>:latest</code>tag is optional, and is used as the default if omitted.
</p>
</li>
<li><p><code>alias</code>: Local name for the pulled plugin.
</p>
<p>The <code>:latest</code>tag is optional, and is used as the default if omitted.
</p>
</li>
<li><p><code>registry_auth</code>: A base64-encoded auth configuration to use when pulling a plugin from a registry. hrefhttps://docs.docker.com/engine/api/1.29/#section/AuthenticationSee the authentication section for details.</p>
</li>
<li><p><code>disable</code>: Do not enable the plugin on install
</p>
</li>
<li><p><code>grant_all</code>: Logical, indicating if all requested permissions should be granted.  If <code>NULL</code>, this will prompt interactively for permission.  Setting this to <code>FALSE</code>will cause the installation to fail.
</p>
</li>
<li><p><code>stream</code>: The stream to send output to.  Options here are (1) a connection object (e.g. <code>stdout()</code>, <code>stderr()</code>or a writable open file connection object, (2) a scalar character indicating a filename to write to, or (3) <code>FALSE</code>or <code>NULL</code>to disable any output.
</p>
</li></ul>
</dd><dt><code>plugin_list</code></dt><dd><p>List plugins. Returns information about installed plugins. Similar to the cli command <code>docker plugin ls</code>.
</p>
<p><em>Usage:</em></p>
<pre>  plugin_list(filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>filters</code>: A JSON encoded value of the filters (a <code>map[string][]string</code>) to process on the plugin list. Available filters:
</p>
<ul>
<li><p><code>capability=&lt;capability name&gt;</code></p>
</li>
<li><p><code>enable=&lt;true&gt;|&lt;false&gt;</code></p>
</li></ul>
</li></ul>
</dd><dt><code>plugin_privileges</code></dt><dd><p>Get plugin privileges
</p>
<p><em>Usage:</em></p>
<pre>  plugin_privileges(remote)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>remote</code>: The name of the plugin. The <code>:latest</code>tag is optional, and is the default if omitted.
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_plugin">docker_plugin</a></code> for information on
plugin objects.
</p>

<hr>
<h2 id='docker_secret_collection'>Management commands for working with swarm secrets</h2><span id='topic+docker_secret_collection'></span>

<h3>Description</h3>

<p>Methods for managing docker swarm secrets.  This object is
<code>$secret</code> within a <code><a href="#topic+docker_client">docker_client</a></code> object.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>secret_create</code></dt><dd><p>Create a secret. Similar to the cli command <code>docker secret create</code>.
</p>
<p><em>Usage:</em></p>
<pre>  secret_create(name, data, labels = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>name</code>: User-defined name of the secret.
</p>
</li>
<li><p><code>data</code>: Secret data, as a raw vector or character string
</p>
</li>
<li><p><code>labels</code>: User-defined key/value metadata.
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>secret_inspect</code></dt><dd><p>Inspect a secret. Similar to the cli command <code>docker secret inspect</code>.
</p>
<p><em>Usage:</em></p>
<pre>  secret_inspect(id)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: ID of the secret
</p>
</li></ul>
</dd><dt><code>secret_list</code></dt><dd><p>List secrets. Similar to the cli command <code>docker secret ls</code>.
</p>
<p><em>Usage:</em></p>
<pre>  secret_list(filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>filters</code>: A named character vector of filters to process on the secrets list. Available filters:
</p>
<ul>
<li><p><code>id=&lt;secret id&gt;</code></p>
</li>
<li><p><code>label=&lt;key&gt; or label=&lt;key&gt;=value</code></p>
</li>
<li><p><code>name=&lt;secret name&gt;</code></p>
</li>
<li><p><code>names=&lt;secret name&gt;</code></p>
</li></ul>
</li></ul>
</dd><dt><code>secret_delete</code></dt><dd><p>Delete a secret. Similar to the cli command <code>docker secret rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  secret_delete(id)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: ID of the secret
</p>
</li></ul>
</dd><dt><code>secret_update</code></dt><dd><p>Update a Secret
</p>
<p><em>Usage:</em></p>
<pre>  secret_update(id, version, name = NULL, labels = NULL,
      data = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: The ID or name of the secret
</p>
</li>
<li><p><code>version</code>: The version number of the secret object being updated. This is required to avoid conflicting writes.
</p>
</li>
<li><p><code>name</code>: User-defined name of the secret.
</p>
</li>
<li><p><code>labels</code>: User-defined key/value metadata.
</p>
</li>
<li><p><code>data</code>: Secret data, as a raw vector or character string
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_swarm_collection">docker_swarm_collection</a></code> for management
commands for the swarm itself, and
<code><a href="#topic+docker_config_collection">docker_config_collection</a></code> for a similar interface
for configuring non-sensitive configurations.
</p>

<hr>
<h2 id='docker_service'>Management commands for working with a particular docker service</h2><span id='topic+docker_service'></span>

<h3>Description</h3>

<p>Methods for working with a particular docker service.  Service
objects are returned by creating a docker service, or by using
<code>$service$get</code> to fetch an existing service by name or id.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>id</code></dt><dd><p>Return the services's id
</p>
<p><em>Usage:</em></p>
<pre>  id()</pre></dd><dt><code>inspect</code></dt><dd><p>Return detailed information about this service. Similar to the cli command <code>docker service inspect</code>.
</p>
<p><em>Usage:</em></p>
<pre>  inspect(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a service has been removed.
</p>
</li></ul>
</dd><dt><code>name</code></dt><dd><p>Return the service's name
</p>
<p><em>Usage:</em></p>
<pre>  name(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a service has been removed.
</p>
</li></ul>
</dd><dt><code>ps</code></dt><dd><p>Get summary information about a service. Similar to the cli command <code>docker service ps</code>.
</p>
<p><em>Usage:</em></p>
<pre>  ps(resolve_names = TRUE, filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>resolve_names</code>: Resolve task and node names, from their ids?  If <code>FALSE</code>, rather than do this instead only print ids.  Task &quot;names&quot; are constructed from a combination of service name (or id) and the replicate number.
</p>
</li>
<li><p><code>filters</code>: A named character vector of filters to process on the tasks list.  Available filters are the same as <code>$task$list()</code>, except that <code>service</code>is not accepted (it is used internally by this method).  Useful filters include <code>desired-state</code>, <code>label</code>, <code>node</code>, <code>name</code>and <code>id</code>.
</p>
</li></ul>
</dd><dt><code>reload</code></dt><dd><p>Refresh infomation on the service from the server, returning <code>$inspect()</code>invisibly.
</p>
<p><em>Usage:</em></p>
<pre>  reload()</pre></dd><dt><code>service_delete</code></dt><dd><p>Delete a service. Similar to the cli command <code>docker service rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  service_delete()</pre></dd><dt><code>tasks</code></dt><dd><p>Fetch tasks associated with this service.  Returns a list of <code><a href="#topic+docker_task">docker_task</a></code>objects
</p>
<p><em>Usage:</em></p>
<pre>  tasks(filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>filters</code>: A named character vector of filters to process on the tasks list.  Available filters are the same as <code>$task$list()</code>, except that <code>service</code>is not accepted (it is used internally by this method).  Useful filters include <code>desired-state</code>, <code>label</code>, <code>node</code>, <code>name</code>and <code>id</code>.
</p>
</li></ul>
</dd><dt><code>version</code></dt><dd><p>Return the service's version.  This is used by some other methods to avoid conflicting writes.
</p>
<p><em>Usage:</em></p>
<pre>  version(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a service has been removed.
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_service_collection">docker_service_collection</a></code> for other
service management methods.
</p>

<hr>
<h2 id='docker_service_collection'>Management commands for working with docker services</h2><span id='topic+docker_service_collection'></span>

<h3>Description</h3>

<p>Methods for working with docker services.  This object is
<code>$service</code> within a <code><a href="#topic+docker_client">docker_client</a></code> object.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>service_create</code></dt><dd><p>Create a service. Similar to the cli command <code>docker service create</code>.
</p>
<p><em>Usage:</em></p>
<pre>  service_create(name = NULL, labels = NULL, image = NULL,
      container_spec_labels = NULL, command = NULL,
      args = NULL, hostname = NULL, env = NULL, dir = NULL,
      user = NULL, groups = NULL, tty = NULL,
      open_stdin = NULL, read_only = NULL, mounts = NULL,
      stop_signal = NULL, stop_grace_period = NULL,
      health_check = NULL, hosts = NULL, dns_config = NULL,
      secrets = NULL, resources = NULL, restart_policy = NULL,
      placement = NULL, force_update = NULL,
      task_spec_networks = NULL, log_driver = NULL,
      update_config = NULL, rollback_config = NULL,
      networks = NULL, endpoint_spec = NULL,
      registry_auth = NULL, stream = stdout(), replicas = NULL,
      global = FALSE, detach = FALSE, timeout = 60,
      time_wait_stable = 5, task_template = NULL,
      container_spec = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>name</code>: Name of the service.
</p>
</li>
<li><p><code>labels</code>: User-defined key/value metadata.
</p>
</li>
<li><p><code>image</code>: The image name to use for the container.
</p>
</li>
<li><p><code>container_spec_labels</code>: User-defined key/value data.
</p>
</li>
<li><p><code>command</code>: The command to be run in the image.
</p>
</li>
<li><p><code>args</code>: Arguments to the command.
</p>
</li>
<li><p><code>hostname</code>: The hostname to use for the container, as a valid RFC 1123 hostname.
</p>
</li>
<li><p><code>env</code>: A list of environment variables in the form <code>VAR=value</code>.
</p>
</li>
<li><p><code>dir</code>: The working directory for commands to run in.
</p>
</li>
<li><p><code>user</code>: The user inside the container.
</p>
</li>
<li><p><code>groups</code>: A list of additional groups that the container process will run as.
</p>
</li>
<li><p><code>tty</code>: Whether a pseudo-TTY should be allocated.
</p>
</li>
<li><p><code>open_stdin</code>: Open <code>stdin</code></p>
</li>
<li><p><code>read_only</code>: Mount the container's root filesystem as read only.
</p>
</li>
<li><p><code>mounts</code>: Specification for mounts to be added to containers created as part of the service.
</p>
</li>
<li><p><code>stop_signal</code>: Signal to stop the container.
</p>
</li>
<li><p><code>stop_grace_period</code>: Amount of time to wait for the container to terminate before forcefully killing it.
</p>
</li>
<li><p><code>health_check</code>: A test to perform to check that the container is healthy. Construct with <code>$types$health_config()</code></p>
</li>
<li><p><code>hosts</code>: A list of hostnames/IP mappings to add to the container's <code>/etc/hosts</code>file.
The format of extra hosts on swarmkit is specified in:
http://man7.org/linux/man-pages/man5/hosts.5.html
IP_address canonical_hostname [aliases...]
</p>
</li>
<li><p><code>dns_config</code>: Specification for DNS related configurations in resolver configuration file (<code>resolv.conf</code>). Construct with <code>$types$dns_config()</code></p>
</li>
<li><p><code>secrets</code>: Secrets contains references to zero or more secrets that will be exposed to the service.
</p>
</li>
<li><p><code>resources</code>: Resource requirements which apply to each individual container created as part of the service. Construct with <code>$types$task_resources()</code></p>
</li>
<li><p><code>restart_policy</code>: Specification for the restart policy which applies to containers created as part of this service. Construct with <code>$types$task_restart_policy()</code></p>
</li>
<li><p><code>placement</code>: Construct with <code>$types$task_placement()</code></p>
</li>
<li><p><code>force_update</code>: A counter that triggers an update even if no relevant parameters have been changed.
</p>
</li>
<li><p><code>task_spec_networks</code>: NA
</p>
</li>
<li><p><code>log_driver</code>: Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified.
</p>
</li>
<li><p><code>update_config</code>: Specification for the update strategy of the service.
</p>
</li>
<li><p><code>rollback_config</code>: Specification for the rollback strategy of the service.
</p>
</li>
<li><p><code>networks</code>: Array of network names or IDs to attach the service to.
</p>
</li>
<li><p><code>endpoint_spec</code>: Properties that can be configured to access and load balance a service.
</p>
</li>
<li><p><code>registry_auth</code>: A base64-encoded auth configuration for pulling from private registries. hrefhttps://docs.docker.com/engine/api/1.29/#section/AuthenticationSee the authentication section for details.</p>
</li>
<li><p><code>stream</code>: The stream to send output to.  Options here are (1) a connection object (e.g. <code>stdout()</code>, <code>stderr()</code>or a writable open file connection object, (2) a scalar character indicating a filename to write to, or (3) <code>FALSE</code>or <code>NULL</code>to disable any output.
</p>
</li>
<li><p><code>replicas</code>: Number of replicas to use.  If <code>NULL</code>(the default) then a single replica is used (the same behaviour as the command line client).
</p>
</li>
<li><p><code>global</code>: Logical, indicating if this should be a &quot;global&quot; service (running one instance on each node) rather than a &quot;replicated&quot; service (running across nodes - the default).
</p>
</li>
<li><p><code>detach</code>: Logical, indicating if we should exit immediately, rather than waiting for the service to converge.  This option is named for consistency with <code>docker service create</code>- this command never &quot;attaches&quot; in the sense of a single container.
</p>
</li>
<li><p><code>timeout</code>: Time, in seconds, to wait for the service to converge when <code>detach = FALSE</code>.  If the service has not converged by this time an error will be thrown, but the docker daemon will continue trying to start the service.
</p>
</li>
<li><p><code>time_wait_stable</code>: Time, in seconds, to wait for the service to stay up after it has started.  This is needed to detect services that fail shortly after starting.  The default is 5 seconds, which matches the command line client.
</p>
</li>
<li><p><code>task_template</code>: User modifiable task configuration. Construct with <code>$types$task_spec()</code>.  If this is given then 'container_spec', 'resources', 'restart_policy', 'placement', 'force_update', 'task_spec_networks' and 'log_driver' must all be NULL.
</p>
</li>
<li><p><code>container_spec</code>: Construct with <code>$types$container_spec()</code>.  If this is given then 'image', 'container_spec_labels', 'command', 'args', 'hostname', 'env', 'dir', 'user', 'groups', 'tty', 'open_stdin', 'read_only', 'mounts', 'stop_signal', 'stop_grace_period', 'health_check', 'hosts', 'dns_config' and 'secrets' must all be NULL.
</p>
</li></ul>
</dd><dt><code>get</code></dt><dd><p>Get a service by name or id
</p>
<p><em>Usage:</em></p>
<pre>  get(id)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: A scalar character with the network's name or id (abbreviations of the id are allowed and will be resolved by the docker daemon).
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>service_list</code></dt><dd><p>List services. Similar to the cli command <code>docker service list</code>.
</p>
<p><em>Usage:</em></p>
<pre>  service_list(filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>filters</code>: A named character vector of filters to process on the services list. Available filters:
</p>
<ul>
<li><p><code>id=&lt;service id&gt;</code></p>
</li>
<li><p><code>label=&lt;service label&gt;</code></p>
</li>
<li><p><code>mode=["replicated"|"global"]</code></p>
</li>
<li><p><code>name=&lt;service name&gt;</code></p>
</li></ul>
</li></ul>
</dd><dt><code>service_delete</code></dt><dd><p>Delete a service. Similar to the cli command <code>docker service rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  service_delete(id)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: ID or name of service.
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_service">docker_service</a></code> for information on
service objects.
</p>

<hr>
<h2 id='docker_swarm_collection'>Management commands for working with docker swarm</h2><span id='topic+docker_swarm_collection'></span>

<h3>Description</h3>

<p>Methods for managing the docker swarm.  This object is
<code>$swarm</code> within a <code><a href="#topic+docker_client">docker_client</a></code> object.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>swarm_init</code></dt><dd><p>Initialize a new swarm. Similar to the cli command <code>docker swarm init</code>.
</p>
<p><em>Usage:</em></p>
<pre>  swarm_init(listen_addr = "0.0.0.0:2377",
      advertise_addr = NULL, force_new_cluster = NULL,
      spec = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>listen_addr</code>: Listen address used for inter-manager communication, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP). This can either be an address/port combination in the form <code>192.168.1.1:4567</code>, or an interface followed by a port number, like <code>eth0:4567</code>. If the port number is omitted, the default swarm listening port is used.
</p>
</li>
<li><p><code>advertise_addr</code>: Externally reachable address advertised to other nodes. This can either be an address/port combination in the form <code>192.168.1.1:4567</code>, or an interface followed by a port number, like <code>eth0:4567</code>. If the port number is omitted, the port number from the listen address is used. If <code>AdvertiseAddr</code>is not specified, it will be automatically detected when possible.
</p>
</li>
<li><p><code>force_new_cluster</code>: Force creation of a new swarm.
</p>
</li>
<li><p><code>spec</code>: User modifiable swarm configuration.
</p>
</li></ul>
</dd><dt><code>swarm_inspect</code></dt><dd><p>Inspect swarm
</p>
<p><em>Usage:</em></p>
<pre>  swarm_inspect()</pre></dd><dt><code>swarm_join</code></dt><dd><p>Join an existing swarm. Similar to the cli command <code>docker swarm join</code>.
</p>
<p><em>Usage:</em></p>
<pre>  swarm_join(listen_addr = NULL, advertise_addr = NULL,
      remote_addrs = NULL, join_token = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>listen_addr</code>: Listen address used for inter-manager communication if the node gets promoted to manager, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP).
</p>
</li>
<li><p><code>advertise_addr</code>: Externally reachable address advertised to other nodes. This can either be an address/port combination in the form <code>192.168.1.1:4567</code>, or an interface followed by a port number, like <code>eth0:4567</code>. If the port number is omitted, the port number from the listen address is used. If <code>AdvertiseAddr</code>is not specified, it will be automatically detected when possible.
</p>
</li>
<li><p><code>remote_addrs</code>: Addresses of manager nodes already participating in the swarm.
</p>
</li>
<li><p><code>join_token</code>: Secret token for joining this swarm.
</p>
</li></ul>
</dd><dt><code>swarm_leave</code></dt><dd><p>Leave a swarm. Similar to the cli command <code>docker swarm leave</code>.
</p>
<p><em>Usage:</em></p>
<pre>  swarm_leave(force = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>force</code>: Force leave swarm, even if this is the last manager or that it will break the cluster.
</p>
</li></ul>
</dd><dt><code>swarm_unlock</code></dt><dd><p>Unlock a locked manager. Similar to the cli command <code>docker swarm unlock</code>.
</p>
<p><em>Usage:</em></p>
<pre>  swarm_unlock(unlock_key = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>unlock_key</code>: The swarm's unlock key.
</p>
</li></ul>
</dd><dt><code>swarm_unlock_key</code></dt><dd><p>Get the unlock key. Similar to the cli command <code>docker swarm unlock-key</code>.
</p>
<p><em>Usage:</em></p>
<pre>  swarm_unlock_key()</pre></dd><dt><code>swarm_update</code></dt><dd><p>Update a swarm. Similar to the cli command <code>docker swarm update</code>.
</p>
<p><em>Usage:</em></p>
<pre>  swarm_update(version, name = NULL, labels = NULL,
      orchestration = NULL, raft = NULL, dispatcher = NULL,
      ca_config = NULL, encryption_config = NULL,
      task_defaults = NULL, rotate_worker_token = NULL,
      rotate_manager_token = NULL,
      rotate_manager_unlock_key = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>version</code>: The version number of the swarm object being updated. This is required to avoid conflicting writes.
</p>
</li>
<li><p><code>name</code>: Name of the swarm.
</p>
</li>
<li><p><code>labels</code>: User-defined key/value metadata.
</p>
</li>
<li><p><code>orchestration</code>: Orchestration configuration.
</p>
</li>
<li><p><code>raft</code>: Raft configuration.
</p>
</li>
<li><p><code>dispatcher</code>: Dispatcher configuration.
</p>
</li>
<li><p><code>ca_config</code>: CA configuration.
</p>
</li>
<li><p><code>encryption_config</code>: Parameters related to encryption-at-rest.
</p>
</li>
<li><p><code>task_defaults</code>: Defaults for creating tasks in this cluster.
</p>
</li>
<li><p><code>rotate_worker_token</code>: Rotate the worker join token.
</p>
</li>
<li><p><code>rotate_manager_token</code>: Rotate the manager join token.
</p>
</li>
<li><p><code>rotate_manager_unlock_key</code>: Rotate the manager unlock key.
</p>
</li></ul>
</dd></dl>


<hr>
<h2 id='docker_task'>Management commands for working with a particular docker task</h2><span id='topic+docker_task'></span>

<h3>Description</h3>

<p>Methods for working with a particular docker task.  Task objects
are returned by using <code>$task$get</code> to fetch an existing task
by name or id, or <code>$tasks</code> from a
<code><a href="#topic+docker_service">docker_service</a></code> object representing a docker service.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>id</code></dt><dd><p>Return the tasks's id
</p>
<p><em>Usage:</em></p>
<pre>  id()</pre></dd><dt><code>inspect</code></dt><dd><p>Return detailed information about this task
</p>
<p><em>Usage:</em></p>
<pre>  inspect(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a task has been removed.
</p>
</li></ul>
</dd><dt><code>task_logs</code></dt><dd><p>Get task logs. Get <code>stdout</code>and <code>stderr</code>logs from a task.
</p>
<p><b>Note</b>: This endpoint works only for services with the <code>json-file</code>or <code>journald</code>logging drivers.
</p>
<p><em>Usage:</em></p>
<pre>  task_logs(details = NULL, follow = NULL, stdout = TRUE,
      stderr = TRUE, since = NULL, timestamps = NULL,
      tail = NULL, stream = stdout())</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>details</code>: Show task context and extra details provided to logs.
</p>
</li>
<li><p><code>follow</code>: Return the logs as a stream.
</p>
<p>This will return a <code>101</code>HTTP response with a <code>Connection: upgrade</code>header, then hijack the HTTP connection to send raw output. For more information about hijacking and the stream format, hrefhttps://docs.docker.com/engine/api/1.29/#operation/ContainerAttachsee the documentation for the attach endpoint.
</p>
</li>
<li><p><code>stdout</code>: Return logs from <code>stdout</code></p>
</li>
<li><p><code>stderr</code>: Return logs from <code>stderr</code></p>
</li>
<li><p><code>since</code>: Only return logs since this time, as a UNIX timestamp
</p>
</li>
<li><p><code>timestamps</code>: Add timestamps to every log line
</p>
</li>
<li><p><code>tail</code>: Only return this number of log lines from the end of the logs. Specify as an integer or <code>all</code>to output all log lines.
</p>
</li>
<li><p><code>stream</code>: The stream to send output to.  Options here are (1) a connection object (e.g. <code>stdout()</code>, <code>stderr()</code>or a writable open file connection object, (2) a scalar character indicating a filename to write to, or (3) <code>FALSE</code>or <code>NULL</code>to disable any output.
</p>
</li></ul>
</dd><dt><code>reload</code></dt><dd><p>Refresh infomation on the task from the server, returning <code>$inspect()</code>invisibly.
</p>
<p><em>Usage:</em></p>
<pre>  reload()</pre></dd><dt><code>service</code></dt><dd><p>Return parent service
</p>
<p><em>Usage:</em></p>
<pre>  service()</pre></dd><dt><code>state</code></dt><dd><p>Retrieve task state (running, shutdown, etc).  Richer information about task status is available as <code>$inspect()$status</code></p>
<p><em>Usage:</em></p>
<pre>  state(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after a task has been removed.
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_task_collection">docker_task_collection</a></code> for other
task management methods.
</p>

<hr>
<h2 id='docker_task_collection'>Management commands for working with docker tasks</h2><span id='topic+docker_task_collection'></span>

<h3>Description</h3>

<p>Methods for working with docker tasks.  This object is
<code>$task</code> within a <code><a href="#topic+docker_client">docker_client</a></code> object.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>get</code></dt><dd><p>Get a task by name or id
</p>
<p><em>Usage:</em></p>
<pre>  get(id)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>id</code>: A scalar character with the network's name or id (abbreviations of the id are allowed and will be resolved by the docker daemon).
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>task_list</code></dt><dd><p>List tasks
</p>
<p><em>Usage:</em></p>
<pre>  task_list(filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>filters</code>: A named character vector of filters to process on the tasks list. Available filters:
</p>
<ul>
<li><p><code>desired-state=(running | shutdown | accepted)</code></p>
</li>
<li><p><code>id=&lt;task id&gt;</code></p>
</li>
<li><p><code>label=key</code>or <code>label="key=value"</code></p>
</li>
<li><p><code>name=&lt;task name&gt;</code></p>
</li>
<li><p><code>node=&lt;node id or name&gt;</code></p>
</li>
<li><p><code>service=&lt;service name&gt;</code></p>
</li></ul>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_task">docker_task</a></code> for information on
task objects.
</p>

<hr>
<h2 id='docker_types'>Constructors for complex types</h2><span id='topic+docker_types'></span>

<h3>Description</h3>

<p>Methods for building complex docker types.  This is most objects
more complicated than R's atomic types.  Most functions will
indicate if they require one of these objects in their help.  None
of these functions do anything interesting in their own regard -
they just validate inputs.
</p>


<h3>Details</h3>

<p>The functions here will all depend on the API versions - some of
the most fluid parts of the docker API are the different options
that are supported via things like <code>host_config</code>.
</p>
<p>These functions are needed because <code>stevedore</code> aims to be a
fairly direct wrapping around the docker API.  For most of the
single host methods the types here are not really used (with the
notable exception of <code>host_config</code> which is used by
<code>$container$create</code> and <code>$container$update</code>).  But for
the swarm endpoints the function definitions would be impossibly
complex if we did not reflect the types.  So rather than one
function call with a hundred arguments, we can build up the
required types.
</p>
<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>container_spec</code></dt><dd><p>container_spec
</p>
<p><em>Usage:</em></p>
<pre>  container_spec(image = NULL, labels = NULL, command = NULL,
      args = NULL, hostname = NULL, env = NULL, dir = NULL,
      user = NULL, groups = NULL, tty = NULL,
      open_stdin = NULL, read_only = NULL, mounts = NULL,
      stop_signal = NULL, stop_grace_period = NULL,
      health_check = NULL, hosts = NULL, dns_config = NULL,
      secrets = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>image</code>: The image name to use for the container.
</p>
</li>
<li><p><code>labels</code>: User-defined key/value data.
</p>
</li>
<li><p><code>command</code>: The command to be run in the image.
</p>
</li>
<li><p><code>args</code>: Arguments to the command.
</p>
</li>
<li><p><code>hostname</code>: The hostname to use for the container, as a valid RFC 1123 hostname.
</p>
</li>
<li><p><code>env</code>: A list of environment variables in the form <code>VAR=value</code>.
</p>
</li>
<li><p><code>dir</code>: The working directory for commands to run in.
</p>
</li>
<li><p><code>user</code>: The user inside the container.
</p>
</li>
<li><p><code>groups</code>: A list of additional groups that the container process will run as.
</p>
</li>
<li><p><code>tty</code>: Whether a pseudo-TTY should be allocated.
</p>
</li>
<li><p><code>open_stdin</code>: Open <code>stdin</code></p>
</li>
<li><p><code>read_only</code>: Mount the container's root filesystem as read only.
</p>
</li>
<li><p><code>mounts</code>: Specification for mounts to be added to containers created as part of the service.
</p>
</li>
<li><p><code>stop_signal</code>: Signal to stop the container.
</p>
</li>
<li><p><code>stop_grace_period</code>: Amount of time to wait for the container to terminate before forcefully killing it.
</p>
</li>
<li><p><code>health_check</code>: A test to perform to check that the container is healthy. Construct with <code>$types$health_config()</code></p>
</li>
<li><p><code>hosts</code>: A list of hostnames/IP mappings to add to the container's <code>/etc/hosts</code>file.
The format of extra hosts on swarmkit is specified in:
http://man7.org/linux/man-pages/man5/hosts.5.html
IP_address canonical_hostname [aliases...]
</p>
</li>
<li><p><code>dns_config</code>: Specification for DNS related configurations in resolver configuration file (<code>resolv.conf</code>). Construct with <code>$types$dns_config()</code></p>
</li>
<li><p><code>secrets</code>: Secrets contains references to zero or more secrets that will be exposed to the service.
</p>
</li></ul>
</dd><dt><code>dns_config</code></dt><dd><p>Specification for DNS related configurations in resolver configuration file (<code>resolv.conf</code>).
</p>
<p><em>Usage:</em></p>
<pre>  dns_config(nameservers = NULL, search = NULL,
      options = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>nameservers</code>: The IP addresses of the name servers.
</p>
</li>
<li><p><code>search</code>: A search list for host-name lookup.
</p>
</li>
<li><p><code>options</code>: A list of internal resolver variables to be modified (e.g., <code>debug</code>, <code>ndots:3</code>, etc.).
</p>
</li></ul>
</dd><dt><code>health_config</code></dt><dd><p>A test to perform to check that the container is healthy.
</p>
<p><em>Usage:</em></p>
<pre>  health_config(test = NULL, interval = NULL, timeout = NULL,
      retries = NULL, start_period = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>test</code>: The test to perform. Possible values are:
</p>
<ul>
<li><p><code>[]</code>inherit healthcheck from image or parent image
</p>
</li>
<li><p><code>["NONE"]</code>disable healthcheck
</p>
</li>
<li><p><code>["CMD", args...]</code>exec arguments directly
</p>
</li>
<li><p><code>["CMD-SHELL", command]</code>run command with system's default shell
</p>
</li></ul>
</li>
<li><p><code>interval</code>: The time to wait between checks in nanoseconds. It should be 0 or not less than 1000000000(1s). 0 means inherit.
</p>
</li>
<li><p><code>timeout</code>: The time to wait before considering the check to have hung. It should be 0 or not less than 1000000000(1s). 0 means inherit.
</p>
</li>
<li><p><code>retries</code>: The number of consecutive failures needed to consider a container as unhealthy. 0 means inherit.
</p>
</li>
<li><p><code>start_period</code>: Start period for the container to initialize before starting health-retries countdown in nanoseconds. 0 means inherit.
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>mount</code></dt><dd><p>mount
</p>
<p><em>Usage:</em></p>
<pre>  mount(target = NULL, source = NULL, type = NULL,
      read_only = NULL, consistency = NULL,
      bind_options = NULL, volume_options = NULL,
      tmpfs_options = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>target</code>: Container path.
</p>
</li>
<li><p><code>source</code>: Mount source (e.g. a volume name, a host path).
</p>
</li>
<li><p><code>type</code>: The mount type. Available types:
</p>
<ul>
<li><p><code>bind</code>Mounts a file or directory from the host into the container. Must exist prior to creating the container.
</p>
</li>
<li><p><code>volume</code>Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are <b>not</b>removed when the container is removed.
</p>
</li>
<li><p><code>tmpfs</code>Create a tmpfs with the given options. The mount source cannot be specified for tmpfs.
</p>
</li></ul>
</li>
<li><p><code>read_only</code>: Whether the mount should be read-only.
</p>
</li>
<li><p><code>consistency</code>: The consistency requirement for the mount: <code>default</code>, <code>consistent</code>, <code>cached</code>, or <code>delegated</code>.
</p>
</li>
<li><p><code>bind_options</code>: Optional configuration for the <code>bind</code>type.
</p>
</li>
<li><p><code>volume_options</code>: Optional configuration for the <code>volume</code>type.
</p>
</li>
<li><p><code>tmpfs_options</code>: Optional configuration for the <code>tmpfs</code>type.
</p>
</li></ul>
</dd><dt><code>task_placement</code></dt><dd><p>task_placement
</p>
<p><em>Usage:</em></p>
<pre>  task_placement(constraints = NULL, preferences = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>constraints</code>: An array of constraints.
</p>
</li>
<li><p><code>preferences</code>: Preferences provide a way to make the scheduler aware of factors such as topology. They are provided in order from highest to lowest precedence.
</p>
</li></ul>
</dd><dt><code>task_resources</code></dt><dd><p>Resource requirements which apply to each individual container created as part of the service.
</p>
<p><em>Usage:</em></p>
<pre>  task_resources(limits = NULL, reservation = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>limits</code>: Define resources limits.
</p>
</li>
<li><p><code>reservation</code>: Define resources reservation.
</p>
</li></ul>
</dd><dt><code>task_restart_policy</code></dt><dd><p>Specification for the restart policy which applies to containers created as part of this service.
</p>
<p><em>Usage:</em></p>
<pre>  task_restart_policy(condition = NULL, delay = NULL,
      max_attempts = NULL, window = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>condition</code>: Condition for restart.
</p>
</li>
<li><p><code>delay</code>: Delay between restart attempts.
</p>
</li>
<li><p><code>max_attempts</code>: Maximum attempts to restart a given container before giving up (default value is 0, which is ignored).
</p>
</li>
<li><p><code>window</code>: Windows is the time window used to evaluate the restart policy (default value is 0, which is unbounded).
</p>
</li></ul>
</dd><dt><code>task_spec</code></dt><dd><p>User modifiable task configuration.
</p>
<p><em>Usage:</em></p>
<pre>  task_spec(container_spec = NULL, resources = NULL,
      restart_policy = NULL, placement = NULL,
      force_update = NULL, networks = NULL, log_driver = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>container_spec</code>: Construct with <code>$types$container_spec()</code></p>
</li>
<li><p><code>resources</code>: Resource requirements which apply to each individual container created as part of the service. Construct with <code>$types$task_resources()</code></p>
</li>
<li><p><code>restart_policy</code>: Specification for the restart policy which applies to containers created as part of this service. Construct with <code>$types$task_restart_policy()</code></p>
</li>
<li><p><code>placement</code>: Construct with <code>$types$task_placement()</code></p>
</li>
<li><p><code>force_update</code>: A counter that triggers an update even if no relevant parameters have been changed.
</p>
</li>
<li><p><code>networks</code>: NA
</p>
</li>
<li><p><code>log_driver</code>: Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified.
</p>
</li></ul>
</dd></dl>


<hr>
<h2 id='docker_volume'>Management commands for working with a particular docker volume</h2><span id='topic+docker_volume'></span>

<h3>Description</h3>

<p>Methods for working with a particular docker volume.  Volume
objects are returned by creating a docker volume, or by using
<code>$volume$get</code> to fetch an existing volume by name or id.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>inspect</code></dt><dd><p>Return detailed information about this volume. Similar to the cli command <code>docker volume inspect</code>.
</p>
<p><em>Usage:</em></p>
<pre>  inspect(reload = TRUE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>reload</code>: Logical scalar, indicating if the information should be refreshed from the daemon.  This is useful to set to <code>FALSE</code>after an volume has been removed.
</p>
</li></ul>
</dd><dt><code>map</code></dt><dd><p>Generate a path suitable to be passed in to <code>docker$container$run</code>or <code>docker$container$create</code></p>
<p><em>Usage:</em></p>
<pre>  map(path, readonly = FALSE)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>path</code>: Path in the container to map the volume to
</p>
</li>
<li><p><code>readonly</code>: Logical, indicating if this should be a readonly mount
</p>
</li></ul>
</dd><dt><code>name</code></dt><dd><p>Return name for this volume
</p>
<p><em>Usage:</em></p>
<pre>  name()</pre></dd><dt><code>reload</code></dt><dd><p>Refresh infomation on the volume from the server, returning <code>$inspect()</code>invisibly.
</p>
<p><em>Usage:</em></p>
<pre>  reload()</pre></dd><dt><code>volume_delete</code></dt><dd><p>Remove a volume. Instruct the driver to remove the volume. Similar to the cli command <code>docker volume rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  volume_delete(force = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>force</code>: Force the removal of the volume
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_volume_collection">docker_volume_collection</a></code> for other
volume management methods.
</p>

<hr>
<h2 id='docker_volume_collection'>Management commands for working with docker volumes</h2><span id='topic+docker_volume_collection'></span>

<h3>Description</h3>

<p>Methods for working with docker volumes.  This object is
<code>$volume</code> within a <code><a href="#topic+docker_client">docker_client</a></code> object.
</p>


<h3>Details</h3>

<p>Below is reference documentation for all methods for version
'1.29'
of the docker API - other versions are available. This documentation
is automatically generated from docker's API schema, and so
inaccuracies may exist between it and stevedore's interface
(especially references to JSON objects). Please report any
documentation that might be improved at
<a href="https://github.com/richfitz/stevedore/issues">https://github.com/richfitz/stevedore/issues</a></p>


<h4>Methods</h4>

<dl>
<dt><code>volume_create</code></dt><dd><p>Create a volume. Similar to the cli command <code>docker volume create</code>.
</p>
<p><em>Usage:</em></p>
<pre>  volume_create(name = NULL, driver = NULL, driver_opts = NULL,
      labels = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>name</code>: The new volume's name. If not specified, Docker generates a name.
</p>
</li>
<li><p><code>driver</code>: Name of the volume driver to use.
</p>
</li>
<li><p><code>driver_opts</code>: A mapping of driver options and values. These options are passed directly to the driver and are driver specific.
</p>
</li>
<li><p><code>labels</code>: User-defined key/value metadata.
</p>
</li></ul>
</dd><dt><code>get</code></dt><dd><p>Get a volume by name or id
</p>
<p><em>Usage:</em></p>
<pre>  get(name)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>name</code>: A scalar character with the volume's name.
</p>
</li></ul>
</dd><dt><code>help</code></dt><dd><p>Display help for this object
</p>
<p><em>Usage:</em></p>
<pre>  help(help_type = getOption("help_type"))</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>help_type</code>: Passed to <code>utils::help</code>, can be one of &quot;text&quot;, &quot;html&quot; or &quot;pdf&quot; (or an abbreviation).  By default it uses the value <code>getOption("help_type")</code>and should follow the same behaviour as other R help (e.g., using &quot;?&quot;)
</p>
</li></ul>
</dd><dt><code>volume_list</code></dt><dd><p>List volumes. Similar to the cli command <code>docker volume ls</code>.
</p>
<p><em>Usage:</em></p>
<pre>  volume_list(filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>filters</code>: A named character vector of filters to
process on the volumes list. Available filters:
</p>
<ul>
<li><p><code>dangling=&lt;boolean&gt;</code>When set to <code>true</code>(or <code>1</code>), returns all
volumes that are not in use by a container. When set to <code>false</code></p>
<p>(or <code>0</code>), only volumes that are in use by one or more
containers are returned.
</p>
</li>
<li><p><code>driver=&lt;volume-driver-name&gt;</code>Matches volumes based on their driver.
</p>
</li>
<li><p><code>label=&lt;key&gt;</code>or <code>label=&lt;key&gt;:&lt;value&gt;</code>Matches volumes based on
the presence of a <code>label</code>alone or a <code>label</code>and a value.
</p>
</li>
<li><p><code>name=&lt;volume-name&gt;</code>Matches all or part of a volume name.
</p>
</li></ul>
</li></ul>
</dd><dt><code>volume_prune</code></dt><dd><p>Delete unused volumes. Similar to the cli command <code>docker volume prune</code>.
</p>
<p><em>Usage:</em></p>
<pre>  volume_prune(filters = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>filters</code>: Filters to process on the prune list, as a named character vector.
</p>
<p>Available filters:
</p>
</li></ul>
</dd><dt><code>volume_delete</code></dt><dd><p>Remove a volume. Instruct the driver to remove the volume. Similar to the cli command <code>docker volume rm</code>.
</p>
<p><em>Usage:</em></p>
<pre>  volume_delete(name, force = NULL)</pre><p><em>Arguments:</em></p>
<ul>
<li><p><code>name</code>: Volume name or ID
</p>
</li>
<li><p><code>force</code>: Force the removal of the volume
</p>
</li></ul>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="#topic+docker_volume">docker_volume</a></code> for information on
volume objects.
</p>

<hr>
<h2 id='stevedore'>Docker Client For R</h2><span id='topic+stevedore'></span>

<h3>Description</h3>

<p><code>stevedore</code> implements a docker client for R.  Docker is a
framework for &quot;containerisation&quot; - abstracting the details of how
software is installed and run.  It is conceptually similar to
virtualisation but much lighter weight.
</p>


<h3>Details</h3>

<p>Within the R space containers have been discussed for:
</p>
<p><em>Reproducible research</em>: collecting all dependencies for an
analysis into an image that can be run by other people without
installation headaches.
</p>
<p><em>Testing packages</em>: Collect all the requirements of a package
together and run your tests in an isolated environment.
</p>
<p>Containers can also be used to construct larger applications with
multiple processes that need to talk to each other - for example a
database, API server and proxy server.  One might also implement
something like a set of shiny servers that are load balanced
through a proxy!
</p>
<p>This package provides a complete interface to docker allowing you
to basically everything that can be done from the command line
from within R.  All communication happens over docker's HTTP API
and does not use system commands.  As a result, the information
returned back to R is richer and the interface is likely to be
reliable than parsing the command line output. <code>stevedore</code>'s
interface is largely automatically generated so will track new
features available in the docker daemon closely.
</p>
<p>The interface is designed to be similar to docker's command link
API - the command for creating a network on the command line is
</p>
<pre>
docker network create mynetwork
</pre>
<p>and in <code>stevedore</code> can be done as
</p>
<pre>
docker &lt;- stevedore::docker_client()
docker$network$create("mynetwork")
</pre>
<p>Familiarity with the command line interface will be helpful but
probably as much because of the concepts as the details.
</p>
<p>To get started, please see the package vignette - running
<code>vignette("stevedore")</code> will work if the package was
installed with the vignettes, or see
<a href="https://richfitz.github.io/stevedore/">https://richfitz.github.io/stevedore/</a>. A good place to get
started with the reference documentation is the
<code><a href="#topic+docker_client">docker_client</a></code> function.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
