<!DOCTYPE html><html lang="en"><head><title>Help for package potts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {potts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Cache+20T'><p>Cache calculated Canonical Statistics for Potts Models.</p></a></li>
<li><a href='#calc_t'><p>Calculate Canonical Statistic for Potts Model</p></a></li>
<li><a href='#composite.ll'><p>Composite Log Likelihood for Potts Models</p></a></li>
<li><a href='#image.raw'><p>Plot Potts Model Data</p></a></li>
<li><a href='#packPotts'><p>Transform Potts Model Data</p></a></li>
<li><a href='#potts'><p>Potts Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.5-11</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Markov Chain Monte Carlo for Potts Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles J. Geyer &lt;charlie@stat.umn.edu&gt; and Leif Johnson
    &lt;ltjohnson@google.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charles J. Geyer &lt;charlie@stat.umn.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pooh (&ge; 0.2)</td>
</tr>
<tr>
<td>Description:</td>
<td>Do Markov chain Monte Carlo (MCMC) simulation of Potts models
   (Potts, 1952, &lt;<a href="https://doi.org/10.1017%2FS0305004100027419">doi:10.1017/S0305004100027419</a>&gt;),
   which are the multi-color generalization of Ising models
   (so, as as special case, also simulates Ising models).
   Use the Swendsen-Wang algorithm (Swendsen and Wang, 1987,
   &lt;<a href="https://doi.org/10.1103%2FPhysRevLett.58.86">doi:10.1103/PhysRevLett.58.86</a>&gt;) so MCMC is fast.
   Do maximum composite likelihood estimation of parameters
   (Besag, 1975, &lt;<a href="https://doi.org/10.2307%2F2987782">doi:10.2307/2987782</a>&gt;,
   Lindsay, 1988, &lt;<a href="https://doi.org/10.1090%2Fconm%2F080">doi:10.1090/conm/080</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.stat.umn.edu/geyer/mcmc/">http://www.stat.umn.edu/geyer/mcmc/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-12 15:24:13 UTC; geyer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-12 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Cache+20T'>Cache calculated Canonical Statistics for Potts Models.</h2><span id='topic+generate_t_cache'></span><span id='topic+gengridcache'></span><span id='topic+gensingleton'></span><span id='topic+singleton'></span><span id='topic+gentwopixel'></span><span id='topic+twopixel'></span><span id='topic+twopixel.nonoverlap'></span><span id='topic+genfourpixel'></span><span id='topic+fourpixel'></span><span id='topic+fourpixel.nonoverlap'></span><span id='topic+genthreebythree'></span><span id='topic+ninepixel.nonoverlap'></span><span id='topic+genfourbyfour'></span><span id='topic+sixteenpixel.nonoverlap'></span>

<h3>Description</h3>

<p>Variety of functions to support caching of calculated canonical
statistics for Potts Models.  There is some attempt at being 'smart'
with when to regenerate the statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_t_cache(x, ncolor, t_stat, sizeA, npixel, f,
                 fapply=lapply, gridcache=NULL)

gengridcache(ncolor, sizeCA, ncol)

gensingleton(ncolor)

singleton(x, ncolor, a, idx, gridcache=NULL)

gentwopixel(ncolor)

twopixel(x, ncolor, a, idx, gridcache=NULL)

twopixel.nonoverlap(x, ncolor, a, idx, gridcache=NULL)

genfourpixel(ncolor)

fourpixel(x, ncolor, a, idx, gridcache=NULL)

fourpixel.nonoverlap(x, ncolor, a, idx, gridcache=NULL)

genthreebythree(ncolor)

ninepixel.nonoverlap(x, ncolor, a, idx, gridcache=NULL)

genfourbyfour(ncolor)

sixteenpixel.nonoverlap(x, ncolor, a, idx, gridcache=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cache+2B20T_+3A_t_stat">t_stat</code></td>
<td>
<p>numerical vector of length <code>ncolor</code>.  Contains the
canonical statistic for the whole image.</p>
</td></tr>
<tr><td><code id="Cache+2B20T_+3A_sizea">sizeA</code></td>
<td>
<p>numerical.  The number of elements in <code class="reqn">\mathcal{A}</code>.</p>
</td></tr>
<tr><td><code id="Cache+2B20T_+3A_sizeca">sizeCA</code></td>
<td>
<p>numerical.  The number of elements in <code class="reqn">C^A</code>.</p>
</td></tr>
<tr><td><code id="Cache+2B20T_+3A_npixel">npixel</code></td>
<td>
<p>numerical.  The number of pixels in one element of
<code class="reqn">\mathcal{A}</code>.</p>
</td></tr>
<tr><td><code id="Cache+2B20T_+3A_f">f</code></td>
<td>
<p>function.  Takes arguments <code>x</code>, <code>ncolor</code>, <code>a</code>,
<code>idx</code> and <code>ncolor</code>.  Returns value of
<code>t_calc_innergrid</code> with window <code class="reqn">A_a</code> replaced
by the <code class="reqn">\texttt{idx}^{th}</code>
element of <code class="reqn">C^A</code>.</p>
</td></tr>
<tr><td><code id="Cache+2B20T_+3A_fapply">fapply</code></td>
<td>
<p>function.  It should behave exactly as lapply does.
You can use this argument to enable parallel computing.</p>
</td></tr>
<tr><td><code id="Cache+2B20T_+3A_gridcache">gridcache</code></td>
<td>
<p>list.  Optional.  If non-null, it is a list of the
elements of <code class="reqn">C^A</code>.</p>
</td></tr>
<tr><td><code id="Cache+2B20T_+3A_x">x</code></td>
<td>
<p>numeric, 2 dimensional matrix, elements in 1, ..., <code>ncolor</code>,
representing a Potts model.</p>
</td></tr>
<tr><td><code id="Cache+2B20T_+3A_ncolor">ncolor</code></td>
<td>
<p>numeric.  Number of colors in this Potts Model.</p>
</td></tr>
<tr><td><code id="Cache+2B20T_+3A_ncol">ncol</code></td>
<td>
<p>numeric.  Gives the number of columns in a rectangular
window.</p>
</td></tr>
<tr><td><code id="Cache+2B20T_+3A_a">a</code></td>
<td>
<p>numeric.  Indicates which member of <code class="reqn">\mathcal{A}</code> is being
referenced.</p>
</td></tr>
<tr><td><code id="Cache+2B20T_+3A_idx">idx</code></td>
<td>
<p>numeric.  Indicates which element of <code class="reqn">C^A</code> is
being referenced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a description of notation and terminology, see
<code><a href="#topic+composite.ll">composite.ll</a></code>.
</p>
<p>This set of functions is used to generate cached calculations of the
canonical statistic of a Potts model suitable for passing into
<code>composite.ll</code> or <code>gr.composite.ll</code>.
</p>
<p>All of the calculations using <code><a href="#topic+composite.ll">composite.ll</a></code> and these
caching functions need one of the color components to be dropped for
the model to be identifiable.  For simplicity, the first color is
dropped by <code>generate_t_cache</code>.  In computing the composite log
likelihood for a Potts model with <code>ncolor</code> colors, we are
interested in many calculations across <code class="reqn">C^A</code>, the set of all
permutations of colors across a window.  These functions facilitate
those calculations.  <code>gridcache</code> is a list of <code class="reqn">C^A</code>.
</p>
<p><code>generate_t_cache</code> is the main function, and the others are
intended to be used in conjunction with it.  <code>generate_t_cache</code>
creates a list of arrays.  Each array represents one window in the
image, and each row of the array contains the value of
<code class="reqn">t(x)</code> (with one component dropped) found by replacing the
pixels in that window with one of the elements of <code class="reqn">C^A</code>.
</p>
<p><code>gengridcache</code> can generate the <code>gridcache</code> for any rectangular
window, give the number of colors, size of <code class="reqn">C^A</code>, and number
of columns in the window.  <code>gensingleton</code>, <code>gentwopixel</code>,
<code>genfourpixel</code>, <code>genthreebythree</code> and <code>genfourbyfour</code>
are all just simple wrappers for <code>gengridcache</code>.
</p>
<p><code>singleton</code>, <code>twopixel</code>, <code>twopixel.nonoverlap</code>,
<code>fourpixel</code>, <code>fourpixel.nonoverlap</code>,
<code>ninepixel.nonoverlap</code> and <code>sixteenpixel.nonoverlap</code> are
intended to be passed to <code>generate_t_cache</code> in the argument
<code>f</code>.  They are used to calculate <code class="reqn">t(ca_{idx} \cup X \setminus
  A_a)</code> for the
<code class="reqn">\texttt{idx}^{th}</code> element of <code class="reqn">C^{A_a}</code>.
</p>
<p>Functions that have <code>overlap</code> and <code>nonoverlap</code> versions
generate a overlapping and nonoverlapping set of windows respectively.
</p>
<p><code>singleton</code> is for a single pixel window (Besag or MPLE).
</p>
<p><code>twopixel</code> does a two horizontal pixel window.
</p>
<p><code>fourpixel</code> does a two by two pixel window.
</p>
<p><code>ninepixel</code> does a three by three pixel window.
</p>
<p><code>sixteenpixel</code> does a four by four pixel window.
</p>


<h3>Value</h3>

<p>Functions that start with <code>gen</code> return a <code>list</code> of the
elements of <code class="reqn">C^A</code>.  
</p>
<p>The other functions (e.g. <code>twopixel</code>, <code>fourpixel</code>, ...)
return the result of replacing the <code>a</code>-th window of <code>x</code> with
the <code>idx</code>-th element of <code class="reqn">C^A</code> and calculating
<code>calc_t_innergrid</code> for that window.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+composite.ll">composite.ll</a></code>, <code><a href="#topic+calc_t">calc_t</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ncolor &lt;- 4
beta   &lt;- log(1+sqrt(ncolor))
theta  &lt;- c(rep(0,ncolor), beta)

nrow &lt;- 32
ncol &lt;- 32

x &lt;- matrix(sample(ncolor, nrow*ncol, replace=TRUE), nrow=nrow, ncol=ncol)
foo &lt;- packPotts(x, ncolor)
out &lt;- potts(foo, theta, nbatch=10)
x &lt;- unpackPotts(out$final)

t_stat &lt;- calc_t(x, ncolor)
t_cache_mple &lt;- generate_t_cache(x, ncolor, t_stat, nrow*ncol, 1,
                                 singleton)

## Not run: 
# use multicore to speed things up.
library(multicore)
t_cache_mple &lt;- generate_t_cache(x, ncolor, t_stat, nrow*ncol, 1,
                                 singleton, fapply=mclapply)

## End(Not run)

</code></pre>

<hr>
<h2 id='calc_t'>Calculate Canonical Statistic for Potts Model</h2><span id='topic+calc_t'></span><span id='topic+calc_t_innergrid'></span><span id='topic+calc_t_full'></span>

<h3>Description</h3>

<p>Calculate the canonical statistic 't' for a realization of a Potts
Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_t_full(x,ncolor)
calc_t_innergrid(x, ncolor, grid, i, j)
calc_t(x, ncolor, grid=NULL, i=NULL, j=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_t_+3A_x">x</code></td>
<td>
<p>2 dimensional matrix, elements in 1, ..., <code>ncolor</code>,
representing a Potts model</p>
</td></tr>
<tr><td><code id="calc_t_+3A_ncolor">ncolor</code></td>
<td>
<p>numeric. Number of colors in this Potts Model.</p>
</td></tr>
<tr><td><code id="calc_t_+3A_grid">grid</code></td>
<td>
<p>numeric. 2 dimensional matrix, elements in 1, ...,
<code>ncolor</code>.  If non-NULL it is placed into <code>x</code> at the location
<code>x[i,j]</code>.</p>
</td></tr>
<tr><td><code id="calc_t_+3A_i">i</code></td>
<td>
<p>numeric.  Row to place the grid.</p>
</td></tr>
<tr><td><code id="calc_t_+3A_j">j</code></td>
<td>
<p>numeric.  Column to place the grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a description of notation and terminology, see
<code><a href="#topic+composite.ll">composite.ll</a></code>.
</p>
<p>Calculates the canonical statistics for a realized Potts Model.
<code>calc_t</code> calls <code>calc_t_full</code> if <code>grid</code> is <code>NULL</code>
and <code>calc_t_innergrid</code> otherwise.
</p>
<p><code>calc_t_full</code> calculates the canonical statistics for the full image.
</p>
<p><code>calc_t_innergrid</code> calculates the canonical statistics for the a
window of the image, but with that window replaced by <code>grid</code>,
with the upper left corner of <code>grid</code> located at <code>x[i,j]</code>.
</p>


<h3>Value</h3>

<p>For a description of notation and terminology, see
<code><a href="#topic+composite.ll">composite.ll</a></code>.
</p>
<p>All functions return a vector of length <code>ncolor+1</code>.  Elements
1,...,<code>ncolor</code> contain the number of pixels of each color.
Element <code>ncolor+1</code> contains the number of matching neighbor pairs
for the image.
</p>
<p><code>calc_t_full</code> returns the values for the whole image.
</p>
<p><code>calc_t_innergrid</code> returns the value for just the selected
window, but this includes the number of matching pairs from the
replaced window to it's neighbors.  E.g. if <code>X</code> is the full
image, and <code class="reqn">A_a</code> is the value of some window in the image
and we want to know the value of <code class="reqn">t(y \cup X \setminus
  A_a)</code> this would be <code>calc_t_full(X,
  ncolor) + calc_t_innergrid(X, ncolor, y, i, j) - calc_t_innergrid(X,
  ncolor, A(a), i, j)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_t_cache">generate_t_cache</a></code>, <code><a href="#topic+composite.ll">composite.ll</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ncolor &lt;- 4
beta   &lt;- log(1+sqrt(ncolor))
theta  &lt;- c(rep(0,ncolor), beta)

nrow &lt;- 32
ncol &lt;- 32

x &lt;- matrix(sample(ncolor, nrow*ncol, replace=TRUE), nrow=nrow, ncol=ncol)
foo &lt;- packPotts(x, ncolor)
out &lt;- potts(foo, theta, nbatch=10)
x &lt;- unpackPotts(out$final)

t_stat &lt;- calc_t(x, ncolor)
t_stat_inner &lt;- calc_t(x, ncolor, matrix(1, nrow=2, ncol=2), 1, 1)

</code></pre>

<hr>
<h2 id='composite.ll'>Composite Log Likelihood for Potts Models</h2><span id='topic+composite.ll'></span><span id='topic+gr.composite.ll'></span>

<h3>Description</h3>

<p>Calculate Composite Log Likelihood (CLL) and the gradient of the CLL
for Potts models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>composite.ll(theta, t_stat, t_cache=NULL, fapply=lapply)
gr.composite.ll(theta, t_stat, t_cache=NULL, fapply=lapply) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="composite.ll_+3A_theta">theta</code></td>
<td>
<p>numeric canonical parameter vector.  The CLL will be
evaluated at this point.  It is assumed that the
component corresponding to the first color has been
dropped.</p>
</td></tr>
<tr><td><code id="composite.ll_+3A_t_stat">t_stat</code></td>
<td>
<p>numeric, canonical statistic vector.  The value of the
canonical statistic for the full image.</p>
</td></tr>
<tr><td><code id="composite.ll_+3A_t_cache">t_cache</code></td>
<td>
<p>list of arrays.  <code>t_cache[[i]][j,]</code> = the value of
<code class="reqn">t</code> with window <code class="reqn">A_i</code> replaced by the
<code class="reqn">j^{th}</code> element of <code class="reqn">C^A</code>.</p>
</td></tr>
<tr><td><code id="composite.ll_+3A_fapply">fapply</code></td>
<td>
<p>function.  Expected to function as <code>lapply</code> does.  Useful
for enabling parallel processing.  E.g. use the <code>mclapply</code> function
from the <span class="pkg">multicore</span> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the given value of <code>theta</code> <code>composite.ll</code> and
<code>gr.composite.ll</code> calculate the CLL and the gradient of the CLL
respectively for a realized Potts model represented by <code>t_stat</code>
and <code>t_cache</code>.
</p>
<p><code class="reqn">\mathcal{A}</code> is the set of all <em>windows</em> to be used in
calculating the Composite Log Likelihood (CLL) for a Potts model.  A
<dfn>window</dfn> is a collection of adjacent pixels on the lattice of the
Potts model.  <code class="reqn">A</code> is used to represent a generic window in
<code class="reqn">\mathcal{A}</code>, the code in this package
expects that all the windows in <code class="reqn">\mathcal{A}</code> have the same
size and shape.  <code class="reqn">|A|</code> is used to denote the size, or number
of pixels in a window.  Each pixel in a Potts takes on a value in
<code class="reqn">C</code>, the set of possible colors.  For simplicity, this
implementation takes <code class="reqn">C = \{1,\dots,\texttt{ncolor}\}</code>.  Elements of <code class="reqn">C</code> will be referenced
using <code class="reqn">c_j</code> with <code class="reqn">j \in \{1,\dots,\texttt{ncolor}\}</code>.  <code class="reqn">C^A</code> is used to denote all
the permutations of <code class="reqn">C</code> across the window <code class="reqn">A</code>, and
<code class="reqn">|C|^{|A|}</code> is used to denote the size of <code class="reqn">C^A</code>.
In an abuse of notation, we use <code class="reqn">A_a</code> to refer to the
<code class="reqn">a^{th}</code> element of <code class="reqn">\mathcal{A}</code>.  No ordinal or
numerical properties of <code class="reqn">\mathcal{A}</code>, <code class="reqn">C</code> or
<code class="reqn">C^A</code> are used, only that each element in the sets are
referenced by one and only one indexing value.
</p>


<h3>Value</h3>

<p><code>composite.ll</code> returns CLL evaluated at <code>theta</code>.
</p>
<p><code>gr.composite.ll</code> returns a numeric vector of length
<code>length(theta)</code> containing the gradient of the CLL at <code>theta</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_t_cache">generate_t_cache</a></code>, <code><a href="#topic+calc_t">calc_t</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ncolor &lt;- 4
beta   &lt;- log(1+sqrt(ncolor))
theta  &lt;- c(rep(0,ncolor), beta)

nrow &lt;- 32
ncol &lt;- 32

x &lt;- matrix(sample(ncolor, nrow*ncol, replace=TRUE), nrow=nrow, ncol=ncol)
foo &lt;- packPotts(x, ncolor)
out &lt;- potts(foo, theta, nbatch=10)
x &lt;- unpackPotts(out$final)

t_stat &lt;- calc_t(x, ncolor)
t_cache_mple &lt;- generate_t_cache(x, ncolor, t_stat, nrow*ncol, 1,
                                 singleton)
t_cache_two &lt;- generate_t_cache(x, ncolor, t_stat, nrow*ncol/2, 2,
                                twopixel.nonoverlap)

composite.ll(theta[-1], t_stat, t_cache_mple)
gr.composite.ll(theta[-1], t_stat, t_cache_mple)

## Not run: 
optim.mple &lt;- optim(theta.initial, composite.ll, gr=gr.composite.ll,
                    t_stat, t_cache_mple, method="BFGS",
                    control=list(fnscale=-1))
optim.mple$par

optim.two &lt;- optim(theta.initial, composite.ll, gr=gr.composite.ll,
                   t_stat, t_cache_two, method="BFGS",
                   control=list(fnscale=-1))
optim.two$par

## End(Not run)

## Not run: 
# or use mclapply to speed things up.
library(multicore)
optim.two &lt;- optim(theta.initial, composite.ll, gr=gr.composite.ll,
                   t_stat, t_cache_two, mclapply, method="BFGS",
                   control=list(fnscale=-1))
optim.two$par


## End(Not run)

</code></pre>

<hr>
<h2 id='image.raw'>Plot Potts Model Data</h2><span id='topic+image.raw'></span>

<h3>Description</h3>

<p>plot Potts model data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'raw'
image(x, col = c("white", "red", "blue", "green",
    "black", "cyan", "yellow", "magenta"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image.raw_+3A_x">x</code></td>
<td>
<p>an R vector of class <code>"raw"</code> that encodes a realization
of a Potts model, typically the output of <code><a href="#topic+packPotts">packPotts</a></code>
or of <code><a href="#topic+potts">potts</a></code>.</p>
</td></tr>
<tr><td><code id="image.raw_+3A_col">col</code></td>
<td>
<p>a vector of colors.  Must be as many as number of colors of
Potts model.</p>
</td></tr>
<tr><td><code id="image.raw_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>image.default</code>.</p>
</td></tr>
</table>


<h3>Bugs</h3>

<p>Too slow for large images.  Needs to be rewritten for
efficient plotting.</p>


<h3>See Also</h3>

<p><code><a href="#topic+potts">potts</a></code></p>

<hr>
<h2 id='packPotts'>Transform Potts Model Data</h2><span id='topic+packPotts'></span><span id='topic+inspectPotts'></span><span id='topic+unpackPotts'></span>

<h3>Description</h3>

<p>transform Potts model data from integer matrix to raw vector and
vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>packPotts(x, ncolor)
inspectPotts(raw)
unpackPotts(raw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="packPotts_+3A_x">x</code></td>
<td>
<p>integer matrix containing Potts model data.  Colors are coded
from one to <code>ncolor</code>.</p>
</td></tr>
<tr><td><code id="packPotts_+3A_ncolor">ncolor</code></td>
<td>
<p>integer scalar, number of colors.</p>
</td></tr>
<tr><td><code id="packPotts_+3A_raw">raw</code></td>
<td>
<p>vector of type <code>"raw"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>packPotts</code> a vector of type <code>"raw"</code>.
for <code>inspectPotts</code> a list containing components
<code>ncolor</code>, <code>nrow</code>, and <code>ncol</code>.
for <code>unpackPotts</code> an integer matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(sample(4, 2 * 3, replace = TRUE), nrow = 2)
x
foo &lt;- packPotts(x, ncolor = 4)
foo
inspectPotts(foo)
unpackPotts(foo)
</code></pre>

<hr>
<h2 id='potts'>Potts Models</h2><span id='topic+potts'></span><span id='topic+potts.raw'></span><span id='topic+potts.potts'></span>

<h3>Description</h3>

<p>Simulate Potts model using Swendsen-Wang algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>potts(obj, param, nbatch, blen = 1, nspac = 1,
    boundary = c("torus", "free", "condition"), debug = FALSE,
    outfun = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="potts_+3A_obj">obj</code></td>
<td>
<p>an R vector of class <code>"raw"</code> that encodes a realization
of a Potts model, typically the output of <code><a href="#topic+packPotts">packPotts</a></code>.
Alternatively, an object of class <code>"potts"</code> from a
previous invocation of this function can be supplied,
in which case any missing arguments
are taken from this object.</p>
</td></tr>
<tr><td><code id="potts_+3A_param">param</code></td>
<td>
<p>numeric, canonical parameter vector.  Last component must
nonnegative (see Details below).</p>
</td></tr>
<tr><td><code id="potts_+3A_nbatch">nbatch</code></td>
<td>
<p>the number of batches.</p>
</td></tr>
<tr><td><code id="potts_+3A_blen">blen</code></td>
<td>
<p>the length of batches.</p>
</td></tr>
<tr><td><code id="potts_+3A_nspac">nspac</code></td>
<td>
<p>the spacing of iterations that contribute to batches.</p>
</td></tr>
<tr><td><code id="potts_+3A_boundary">boundary</code></td>
<td>
<p>type of boundary conditions.
The value of this argument can be abbreviated.</p>
</td></tr>
<tr><td><code id="potts_+3A_debug">debug</code></td>
<td>
<p>return additional debugging information.</p>
</td></tr>
<tr><td><code id="potts_+3A_outfun">outfun</code></td>
<td>
<p>controls the output.  If a function, then the batch means
of <code>outfun(tt, ...)</code> are returned.  The argument <code>tt</code>
is the canonical statistic of the Potts model having the same length
as the argument <code>param</code> of this function.  If <code>NULL</code>, the
batch means of the canonical statistic are returned.</p>
</td></tr>
<tr><td><code id="potts_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>outfun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs a Swendsen-Wang algorithm producing a Markov chain with equilibrium
distribution having the specified Potts model.  The state of a Potts model
is a collection of random variables taking values in a finite set.  Here
the finite set is 1, ..., <code>ncolor</code> and the elements are called
&ldquo;colors&rdquo;.  The random variables are associated with the nodes of
a rectangular lattice, represented by <code><a href="#topic+unpackPotts">unpackPotts</a></code> as a matrix.
In keeping with calling the values &ldquo;colors&rdquo;, the random variables
themselves are often called &ldquo;pixels&rdquo;.  The probability model is an
exponential family with canonical statistic vector of length <code>ncolor + 1</code>.
The first <code>ncolor</code> components are the counts of the number of pixels
of each color.  The last component is the number of pairs of neighboring
pixels colored the same.  The corresponding canonical parameter, last
component of the canonical parameter vector (argument <code>param</code>)
must be nonnegative for the Swendsen-Wang algorithm to work (Potts models
are defined for negative dependence parameter, but can't be simulated
using this algorithm).
</p>
<p>In the default boundary specification (<code>"torus"</code>), also called toroidal
or periodic boundary conditions, the vertical edges of the pixel matrix 
are considered glued together, as are the horizontal edges.
Thus corresponding pixels in the first and last rows are considered neighbors,
as are corresponding pixels in the first and last columns.  In the other
boundary specifications there is no such gluing: pixels in the the relative
interiors of the first and last rows and first and last columns have only
three neighbors, and the four corner pixels have only two neighbors.
</p>
<p>In the <code>"torus"</code> and <code>"free"</code> boundary specifications, all pixels
are counted in determining the color count canonical statistics, which thus
range from zero to <code>nrow * ncol</code>, where <code>nrow</code> and <code>ncol</code> are
the number of rows and columns of the pixel matrix.
In the <code>"condition"</code> boundary specification, all pixels in the first
and last rows and first and last columns are fixed (conditioned on), and only
the random pixels are counted in determining the color count canonical
statistics, which thus range from zero to <code>(nrow - 2) * (ncol - 2)</code>.
</p>
<p>In the <code>"torus"</code> boundary specification, all pixels have four neighbors,
so the neighbor pair canonical statistic ranges from zero
to <code>2 * nrow * ncol</code>.
In the <code>"free"</code> boundary specification, pixels in the interior have four
neighbors,  those in the relative interior of edges have three, and those
in the corners have two, so the neighbor pair canonical statistic ranges from
zero to <code>nrow * (ncol - 1) + (nrow - 1) * ncol</code>.
In the <code>"condition"</code> boundary specification, only neighbor pairs in which
at least one pixel is random are counted, so the neighbor pair canonical
statistic ranges from zero
to <code>(nrow - 2) * (ncol - 1) + (nrow - 1) * (ncol - 2)</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"potts"</code>,
which is a list containing at least the following components:
</p>
<table role = "presentation">
<tr><td><code>initial</code></td>
<td>
<p>initial state of Markov chain in the format output
by <code><a href="#topic+packPotts">packPotts</a></code>.</p>
</td></tr>
<tr><td><code>final</code></td>
<td>
<p>final state of Markov chain in the same format.</p>
</td></tr>
<tr><td><code>initial.seed</code></td>
<td>
<p>value of <code>.Random.seed</code> before the run.</p>
</td></tr>
<tr><td><code>final.seed</code></td>
<td>
<p>value of <code>.Random.seed</code> after the run.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>running time of Markov chain from <code><a href="base.html#topic+system.time">system.time</a></code>.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>canonical parameter vector.</p>
</td></tr>
<tr><td><code>nbatch</code></td>
<td>
<p>the number of batches.</p>
</td></tr>
<tr><td><code>blen</code></td>
<td>
<p>the length of batches.</p>
</td></tr>
<tr><td><code>nspac</code></td>
<td>
<p>the spacing of iterations that contribute to batches.</p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>the argument <code>boundary</code>.</p>
</td></tr>
<tr><td><code>batch</code></td>
<td>
<p>an <code>nbatch</code> by <code>nout</code> matrix, where <code>nout</code> is
the length of the result returned by <code>outfun</code> or <code>length(param)</code>
if <code>outfun == NULL</code>; each row is the batch means for the result
of <code>outfun</code> or the canonical statistic vector for one batch
of Markov chain iterations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ncolor &lt;- as.integer(4)
beta &lt;- log(1 + sqrt(ncolor))
theta &lt;- c(rep(0, ncolor), beta)

nrow &lt;- 100
ncol &lt;- 100
x &lt;- matrix(1, nrow = nrow, ncol = ncol)
foo &lt;- packPotts(x, ncolor)

out &lt;- potts(foo, theta, nbatch = 10)
out$batch
## Not run: image(out$final)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
