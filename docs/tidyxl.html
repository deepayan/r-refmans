<!DOCTYPE html><html><head><title>Help for package tidyxl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyxl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidyxl-package'><p>tidyxl: Import xlsx (Excel) spreadsheet data and formatting into tidy structures.</p></a></li>
<li><a href='#excel_functions'><p>Names of all Excel functions</p></a></li>
<li><a href='#is_date_format'><p>Test that Excel number formats are date formats</p></a></li>
<li><a href='#is_range'><p>Test that Excel formulas are ranges</p></a></li>
<li><a href='#maybe_xlsx'><p>Determine file format</p></a></li>
<li><a href='#tidy_xlsx'><p>Import xlsx (Excel) cell contents into a tidy structure.</p></a></li>
<li><a href='#xlex'><p>Parse xlsx (Excel) formulas into tokens</p></a></li>
<li><a href='#xlsx_cells'><p>Import xlsx (Excel) cell contents into a tidy structure.</p></a></li>
<li><a href='#xlsx_color_standard'><p>Names and RGB values of Excel standard colours</p></a></li>
<li><a href='#xlsx_color_theme'><p>Import theme color definitions from xlsx (Excel) files</p></a></li>
<li><a href='#xlsx_formats'><p>Import xlsx (Excel) formatting definitions.</p></a></li>
<li><a href='#xlsx_names'><p>Import named formulas from xlsx (Excel) files</p></a></li>
<li><a href='#xlsx_sheet_names'><p>List sheets in an xlsx (Excel) file</p></a></li>
<li><a href='#xlsx_validation'><p>Import data validation rules of cells in xlsx (Excel) files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Read Untidy Excel Files</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.10</td>
</tr>
<tr>
<td>Description:</td>
<td>Imports non-tabular from Excel files into R.  Exposes cell content,
    position and formatting in a tidy structure for further manipulation.
    Tokenizes Excel formulas.  Supports '.xlsx' and '.xlsm' via the embedded
    'RapidXML' C++ library <a href="https://rapidxml.sourceforge.net">https://rapidxml.sourceforge.net</a>.  Does not support
    '.xlsb' or '.xls'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, piton (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nacnudus/tidyxl">https://github.com/nacnudus/tidyxl</a>,
<a href="https://nacnudus.github.io/tidyxl/">https://nacnudus.github.io/tidyxl/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nacnudus/tidyxl/issues">https://github.com/nacnudus/tidyxl/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, here, knitr, rmarkdown, readxl, dplyr, tidyr,
purrr, tibble, ggplot2, cellranger, openxlsx, rlang</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-21 12:58:45 UTC; nacnudus</td>
</tr>
<tr>
<td>Author:</td>
<td>Duncan Garmonsway [aut, cre],
  Hadley Wickham [ctb] (Author of included readxl fragments),
  Jenny Bryan [ctb] (Author of included readxl fragments),
  RStudio [cph] (Copyright holder of included readxl fragments),
  Marcin Kalicinski [ctb, cph] (Author of included RapidXML code)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Duncan Garmonsway &lt;nacnudus@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-21 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidyxl-package'>tidyxl: Import xlsx (Excel) spreadsheet data and formatting into tidy structures.</h2><span id='topic+tidyxl'></span><span id='topic+tidyxl-package'></span>

<h3>Description</h3>

<p>Tidyxl imports data from spreadsheets without coercing it into a rectangle,
and retains information encoded in cell formatting (e.g. font/fill/border).
This data structure is compatible with the 'unpivotr' package for
recognising information expressed by relative cell positions and cell
formatting, and re-expressing it in a tidy way.
</p>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+xlsx_cells">xlsx_cells()</a></code> Import cells from an xlsx file.
</p>
</li>
<li> <p><code><a href="#topic+xlsx_formats">xlsx_formats()</a></code> Import formatting from an xlsx file.
</p>
</li>
<li> <p><code><a href="#topic+xlsx_sheet_names">xlsx_sheet_names()</a></code> List the names of sheets in an xlsx file.
</p>
</li>
<li> <p><code><a href="#topic+xlsx_names">xlsx_names()</a></code> Import names and definitions of named ranges (aka
'named formulas', 'defined names') from an xlsx file.
</p>
</li>
<li> <p><code><a href="#topic+is_range">is_range()</a></code> Test whether a 'name' from <code><a href="#topic+xlsx_names">xlsx_names()</a></code>
refers to a range or not.
</p>
</li>
<li> <p><code><a href="#topic+xlsx_validation">xlsx_validation()</a></code> Import cell input validation rules (e.g.
'must be from this drop-down list') from an xlsx file.
</p>
</li>
<li> <p><code><a href="#topic+xlsx_colour_standard">xlsx_colour_standard()</a></code> A data frame of standard colour names and
their RGB values.
</p>
</li>
<li> <p><code><a href="#topic+xlsx_colour_theme">xlsx_colour_theme()</a></code> Imports a data frame of theme colour names
and their RGB values from an xlsx file.
</p>
</li>
<li> <p><code><a href="#topic+xlex">xlex()</a></code> Tokenise (lex) an Excel formula.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Duncan Garmonsway <a href="mailto:nacnudus@gmail.com">nacnudus@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Hadley Wickham (Author of included readxl fragments) [contributor]
</p>
</li>
<li><p> Jenny Bryan (Author of included readxl fragments) [contributor]
</p>
</li>
<li><p> RStudio (Copyright holder of included readxl fragments) [copyright holder]
</p>
</li>
<li><p> Marcin Kalicinski (Author of included RapidXML code) [contributor, copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/nacnudus/tidyxl">https://github.com/nacnudus/tidyxl</a>
</p>
</li>
<li> <p><a href="https://nacnudus.github.io/tidyxl/">https://nacnudus.github.io/tidyxl/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/nacnudus/tidyxl/issues">https://github.com/nacnudus/tidyxl/issues</a>
</p>
</li></ul>


<hr>
<h2 id='excel_functions'>Names of all Excel functions</h2><span id='topic+excel_functions'></span>

<h3>Description</h3>

<p>A dataset containing the names of all functions available in Excel.  This is
useful for identifying user-defined functions in formulas tokenized by
<code><a href="#topic+xlex">xlex()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excel_functions
</code></pre>


<h3>Format</h3>

<p>A character vector of length 600.
</p>


<h3>Details</h3>

<p>Note that this includes future function names that are already reserved.
</p>


<h3>Source</h3>

<p>Pages 26&ndash;27 of Microsoft's document &quot;Excel (.xlsx) extensions to the
office openxml spreadsheetml file format p.24&quot;
<a href="https://learn.microsoft.com/en-us/openspecs/office_standards/ms-xlsx/2c5dee00-eff2-4b22-92b6-0738acd4475e">https://learn.microsoft.com/en-us/openspecs/office_standards/ms-xlsx/2c5dee00-eff2-4b22-92b6-0738acd4475e</a>,
revision 8.0 2017-06-20.
</p>

<hr>
<h2 id='is_date_format'>Test that Excel number formats are date formats</h2><span id='topic+is_date_format'></span>

<h3>Description</h3>

<p><code>is_date_format()</code> tests whether an Excel number format string
would a resolve to a date in Excel.  For example, the number format string
<code>"yyyy-mm-dd"</code> would resolve to a date, whereas the string <code>"0.0\\%"</code> would
not.
</p>
<p>This is useful if a cell formula contains a number formatting string (e.g.
<code>TEXT(45678,"yyyy")</code>), and you need to know that the constant 45678 is a date
in order to recover it at full resolution (rather than parsing the character
output &quot;2025&quot; as a year).
</p>
<p>It is used internally to convert the value of a cell to the correct data
type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_date_format(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_date_format_+3A_x">x</code></td>
<td>
<p>character vector of number format strings</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is_date_format(c("yyyy-mm-dd", "0.0%", "h:m:s", "£#,##0;[Red]-£#,##0"))
</code></pre>

<hr>
<h2 id='is_range'>Test that Excel formulas are ranges</h2><span id='topic+is_range'></span>

<h3>Description</h3>

<p><code>is_range()</code> tests whether or not an Excel formula is a range.
A formula like <code>A1</code> is a range, whereas a formula like <code>MAX(A1,2)</code> is not.
Formulas are not evaluated, so it returns <code>FALSE</code> for formulas that would
eventually resolve to arrange (e.g.  <code>INDEX(A1:A10,2)</code>) but that are not
immediately a range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_range(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_range_+3A_x">x</code></td>
<td>
<p>character vector of formulas</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("A1", "Sheet1!A1", "[0]Sheet1!A1", "A1,A2", "A:A 3:3", "MAX(A1,2)")
is_range(x)
</code></pre>

<hr>
<h2 id='maybe_xlsx'>Determine file format</h2><span id='topic+maybe_xlsx'></span>

<h3>Description</h3>

<p>Whether a file may be be xlsx, xlsm, xltx or xltm (rather than xls or xlt),
based on the <a href="https://en.wikipedia.org/wiki/List_of_file_signatures">file signature</a> or &quot;magic
number&quot;, rather than the filename extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maybe_xlsx(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maybe_xlsx_+3A_path">path</code></td>
<td>
<p>File path</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only 'maybe', not 'is', because the xlsx magic number is common to all zip
files, not specific to xlsx files.  The inverse, 'is_xls' isn't possible
either, because the xls magic number is common to other Microsoft Office
files such as .doc and .ppt.
</p>
<p>This uses some logic from Jenny Bryan's commit to the
<a href="https://github.com/tidyverse/readxl/commit/ff071a4758da3677568362daff52e419c4e0cdfe">readxl</a>
package.
</p>


<h3>Value</h3>

<p>Logicial
</p>


<h3>Examples</h3>

<pre><code class='language-R'>examples_xlsx &lt;- system.file("extdata/examples.xlsx", package = "tidyxl")
examples_xlsm &lt;- system.file("extdata/examples.xlsm", package = "tidyxl")
examples_xltx &lt;- system.file("extdata/examples.xltx", package = "tidyxl")
examples_xltm &lt;- system.file("extdata/examples.xltm", package = "tidyxl")
examples_xlsb &lt;- system.file("extdata/examples.xlsb", package = "tidyxl")
examples_xls &lt;- system.file("extdata/examples.xls", package = "tidyxl")

maybe_xlsx(examples_xlsx)
maybe_xlsx(examples_xlsm)
maybe_xlsx(examples_xltx)
maybe_xlsx(examples_xltm)
maybe_xlsx(examples_xlsb)
maybe_xlsx(examples_xls)
</code></pre>

<hr>
<h2 id='tidy_xlsx'>Import xlsx (Excel) cell contents into a tidy structure.</h2><span id='topic+tidy_xlsx'></span>

<h3>Description</h3>

<p><code>tidy_xlsx()</code> is deprecated.  Please use <code><a href="#topic+xlsx_cells">xlsx_cells()</a></code> or <code><a href="#topic+xlsx_formats">xlsx_formats()</a></code>
instead.
</p>
<p><code>tidy_xlsx()</code> imports data from spreadsheets without coercing it into a
rectangle.  Each cell is represented by a row in a data frame, giving the
cell's address, contents, formula, height, width, and keys to look up the
cell's formatting in an adjacent data structure within the list returned by
this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_xlsx(path, sheets = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_xlsx_+3A_path">path</code></td>
<td>
<p>Path to the xlsx file.</p>
</td></tr>
<tr><td><code id="tidy_xlsx_+3A_sheets">sheets</code></td>
<td>
<p>Sheets to read. Either a character vector (the names of the
sheets), an integer vector (the positions of the sheets), or NA (default, all
sheets).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A cell has two 'values': its content, and sometimes also a formula.  It also
has formatting applied at the 'style' level, which can be locally overridden.
</p>


<h4>Content</h4>

<p>Depending on the cell, the content may be a numeric value such as 365 or
365.25, it may represent a date/datetime in one of Excel's date/datetime
systems, or it may be an index into an internal table of strings.
<code>tidy_xlsx()</code> attempts to infer the correct data type of each cell,
returning its value in the appropriate column (error, logical, numeric,
date, character). In case this cleverness is unhelpful, the unparsed value
and type information is available in the 'content' and 'type' columns.
</p>



<h4>Formula</h4>

<p>When a cell has a formula, the value in the 'content' column is the result
of the formula the last time it was evaluated.
</p>
<p>Certain groups of cells may share a formula that differs only by addresses
referred to in the formula; such groups are identified by an index, the
'formula_group'.  The xlsx (Excel) file format only records the formula
against one cell in any group, but <code>tidy_xlsx()</code> propagates the formula to
all the cells in the group, making the necessary changes to relative
addresses in the formula.
</p>
<p>Array formulas may also apply to a group of cells, identified by an address
'formula_ref', but xlsx (Excel) file format only records the formula
against one cell in the group.  Unlike ordinary formulas, <code>tidy_xlsx()</code>
does not propagate these to the other cells in the group.
</p>
<p>Formulas that refer to other workbooks currently do not name the workbooks
directly, instead via indices such as <code style="white-space: pre;">&#8288;[1]&#8288;</code>.  It is planned to
dereference these.
</p>



<h4>Formatting</h4>

<p>Cell formatting is returned in <code>x$formats</code>.  There are two types of
formatting: 'style' formatting, such as Excel's built-in styles 'normal',
'bad', etc., and 'local' formatting, which overrides the style.  These are
returned in <code>x$formats$style</code> and <code>x$formats$local</code>, with
identical structures.  To look up the local formatting of a given cell,
take the cell's 'local_format_id' value (<code>x$data$Sheet1[1, "local_format_id"]</code>), and use it as an index into the format structure.
E.g. to look up the font size,
<code>x$formats$local$font$size[local_format_id]</code>.  To see all available
formats, type <code>str(x$formats$local)</code>.
</p>



<h3>Value</h3>

<p>A list of the data within each sheet (<code style="white-space: pre;">&#8288;$data&#8288;</code>), and the formatting applied to
each cell (<code style="white-space: pre;">&#8288;$formats&#8288;</code>).
</p>
<p>Each sheet's data is returned as a data frames, one per sheet, by the sheet
name.  For example, the data in a sheet named 'My Worksheet' is in
x$data$<code style="white-space: pre;">&#8288;My Worksheet&#8288;</code>.  Each data frame has the following
columns:
</p>

<ul>
<li> <p><code>address</code> The cell address in A1 notation.
</p>
</li>
<li> <p><code>row</code> The row number of a cell address (integer).
</p>
</li>
<li> <p><code>col</code> The column number of a cell address (integer).
</p>
</li>
<li> <p><code>is_blank</code> Whether or not the cell has a value
</p>
</li>
<li> <p><code>data_type</code> The type of a cell, referring to the following columns:
error, logical, numeric, date, character, blank.
</p>
</li>
<li> <p><code>error</code> The error value of a cell.
</p>
</li>
<li> <p><code>logical</code> The boolean value of a cell.
</p>
</li>
<li> <p><code>numeric</code> The numeric value of a cell.
</p>
</li>
<li> <p><code>date</code> The date value of a cell.
</p>
</li>
<li> <p><code>character</code> The string value of a cell.
</p>
</li>
<li> <p><code>character_formatted</code> A data frame of substrings and their individual
formatting.
</p>
</li>
<li> <p><code>formula</code> The formula in a cell (see 'Details').
</p>
</li>
<li> <p><code>is_array</code> Whether or not the formula is an array formula.
</p>
</li>
<li> <p><code>formula_ref</code> The address of a range of cells group to which an array
formula or shared formula applies (see 'Details').
</p>
</li>
<li> <p><code>formula_group</code> The formula group to which the cell belongs (see
'Details').
</p>
</li>
<li> <p><code>comment</code> The text of a comment attached to a cell.
</p>
</li>
<li> <p><code>height</code> The height of a cell's row, in Excel's units.
</p>
</li>
<li> <p><code>width</code> The width of a cell's column, in Excel's units.
</p>
</li>
<li> <p><code>style_format</code> An index into a table of style formats
<code>x$formats$style</code> (see 'Details').
</p>
</li>
<li> <p><code>local_format_id</code> An index into a table of local cell formats
<code>x$formats$local</code> (see 'Details').
</p>
</li></ul>



<h4>Formula</h4>

<p>When a cell has a formula, the value in the 'content' column is the result
of the formula the last time it was evaluated.
</p>
<p>Certain groups of cells may share a formula that differs only by addresses
referred to in the formula; such groups are identified by an index, the
'formula_group'.  The xlsx (Excel) file format only records the formula
against one cell in any group.  <code>xlsx_cells()</code> propagates such formulas to
the other cells in a group, making the necessary changes to relative
addresses in the formula.
</p>
<p>Array formulas may also apply to a group of cells, identified by an address
'formula_ref', but xlsx (Excel) file format only records the formula
against one cell in the group.  <code>xlsx_cells()</code> propagates such formulas to
the other cells in a group.  Unlike shared formulas, no changes to
addresses in array formulas are necessary.
</p>
<p>Formulas that refer to other workbooks currently do not name the workbooks
directly, instead via indices such as <code style="white-space: pre;">&#8288;[1]&#8288;</code>.  It is planned to
dereference these.
</p>



<h4>Formatting</h4>

<p>Cell formatting is returned in <code>x$formats</code>.  There are two types or scopes
of formatting: 'style' formatting, such as Excel's built-in styles
'normal', 'bad', etc., and 'local' formatting, which overrides particular
elements of the style, e.g. by making it bold.  Both types of  are returned
in <code>x$formats$style</code> and <code>x$formats$local</code>, with identical structures.  To
look up the local formatting of a given cell, take the cell's
'local_format_id' value (<code>x$data$Sheet1[1, "local_format_id"]</code>), and use it
as an index into the format structure.  E.g. to look up the font size,
<code>x$formats$local$font$size[local_format_id]</code>.  To see all available
formats, type <code>str(x$formats$local)</code>.
</p>
<p>Colours may be recorded in any of three ways: a hexadecimal RGB string with
or without alpha, an 'indexed' colour, and an index into a 'theme'.
<code>tidy_xlsx</code> dereferences 'indexed' and 'theme' colours to their hexadecimal
RGB string representation, and standardises all RGB strings to have an
alpha channel in the first two characters.  The 'index' and the 'theme'
name are still provided.  To filter by an RGB string, you could  look up
the RGB values in a spreadsheet program (e.g. Excel, LibreOffice,
Gnumeric), and use the <code><a href="grDevices.html#topic+rgb">grDevices::rgb()</a></code> function to convert these to a
hexadecimal string.  Put the alpha value in first, e.g.
</p>
<div class="sourceCode"><pre>A &lt;- 1; R &lt;- 0.5; G &lt;- 0; B &lt;- 0
rgb(A, R, G, B)
# [1] "#FF800000"
</pre></div>
<p>Strings can be formatted within a cell, so that a single cell can contain
substrings with different formatting.  This in-cell formatting is available
in the column <code>character_formatted</code>, which is a list-column of data frames.
Each row of each data frame describes a substring and its formatting.  For
cells without a character value, <code>character_formatted</code> is <code>NULL</code>, so for
further processing you might need to filter out the <code>NULL</code>s first.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
examples &lt;- system.file("extdata/examples.xlsx", package = "tidyxl")

# All sheets
str(tidy_xlsx(examples)$data)

# Specific sheet either by position or by name
str(tidy_xlsx(examples, 2)$data)
str(tidy_xlsx(examples, "Sheet1")$data)

# Data (cell values)
x &lt;- tidy_xlsx(examples)
str(x$data$Sheet1)

# Formatting
str(x$formats$local)

# The formats of particular cells can be retrieved like this:

Sheet1 &lt;- x$data$Sheet1
x$formats$style$font$bold[Sheet1$style_format]
x$formats$local$font$bold[Sheet1$local_format_id]

# To filter for cells of a particular format, first filter the formats to get
# the relevant indices, and then filter the cells by those indices.
bold_indices &lt;- which(x$formats$local$font$bold)
Sheet1[Sheet1$local_format_id %in% bold_indices, ]

# In-cell formatting is available in the `character_formatted` column as a
# data frame, one row per substring.
tidy_xlsx(examples)$data$Sheet1$character_formatted[77]

## End(Not run)
</code></pre>

<hr>
<h2 id='xlex'>Parse xlsx (Excel) formulas into tokens</h2><span id='topic+xlex'></span>

<h3>Description</h3>

<p><code>xlex</code> takes an Excel formula and separates it into tokens.  The name is
a bad pun on 'Excel' and 'lexer'.  It returns a dataframe, one row per token,
giving the token itself, its type (e.g.  <code>number</code>, or <code>error</code>), and its
level.
</p>
<p>The level is a number to show the depth of a token within nested function
calls.  The token <code>A2</code> in the formula <code>IF(A1=1,A2,MAX(A3,A4))</code> is at level 1.
Tokens <code>A3</code> and <code>A4</code> are at level 2.  The token <code>IF</code> is at level 0, which is
the outermost level.
</p>
<p>The output isn't enough to enable computation or validation of formulas, but
it is enough to investigate the structure of formulas and spreadsheets.  It
has been tested on millions of formulas in the Enron corpus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlex(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlex_+3A_x">x</code></td>
<td>
<p>Character vector of length 1, giving the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The different types of tokens are:
</p>

<ul>
<li> <p><code>ref</code> A cell reference/address e.g. <code>A1</code> or <code style="white-space: pre;">&#8288;$B2:C$14&#8288;</code>.
</p>
</li>
<li> <p><code>sheet</code>A sheet name, e.g. <code style="white-space: pre;">&#8288;Sheet1!&#8288;</code> or <code style="white-space: pre;">&#8288;'My Sheet'!&#8288;</code>.  If the sheet is
from a different file, then the file is included in this token &ndash; usually
it has been normalized to the form <code style="white-space: pre;">&#8288;[0]&#8288;</code>.
</p>
</li>
<li> <p><code>name</code> A named range, or more properly a named formula.
</p>
</li>
<li> <p><code>function</code> An Excel or user-defined function, e.g. <code>MAX</code> or
<code style="white-space: pre;">&#8288;_xll.MY_CUSTOM_FUNCTION&#8288;</code>.  A complete list of official Excel functions is
available in the vector <code><a href="#topic+excel_functions">excel_functions</a></code>.
</p>
</li>
<li> <p><code>error</code> An error, e.g. <code style="white-space: pre;">&#8288;#N/A&#8288;</code> or <code style="white-space: pre;">&#8288;#REF!&#8288;</code>.
</p>
</li>
<li> <p><code>bool</code> <code>TRUE</code> or <code>FALSE</code> &ndash; note that there are also functions <code>TRUE()</code> and
<code>FALSE()</code>.
</p>
</li>
<li> <p><code>number</code> All forms of numbers, e.g. <code>1</code>, <code>1.1</code>, <code>-1</code>, <code>1.2E3</code>.
</p>
</li>
<li> <p><code>text</code> Strings inside double quotes, e.g. <code>"Hello, World!"</code>.
</p>
</li>
<li> <p><code>operator</code> The usual infix operators, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code style="white-space: pre;">&#8288;&lt;&gt;&#8288;</code>, etc.  and also the range operator <code>:</code> when it is used with ranges
that aren't cell addresses, e.g. <code>INDEX(something):A1</code>. The union operator
<code style="white-space: pre;">&#8288;,&#8288;</code> is the same symbol that is used to separate function arguments and
array columns, so it is only tagged <code>operator</code> when it is inside
parentheses that are not function parentheses or array curly braces (see
the examples).
</p>
</li>
<li> <p><code>paren_open</code> An open parenthesis <code>(</code> indicating an increase in the level
of nesting, but not directly enclosing function arguments.
</p>
</li>
<li> <p><code>paren_close</code> As <code>open</code>, but reducing the level of nesting.
</p>
</li>
<li> <p><code>open_array</code> An open curly brace '{' indicating the start of an array
of constants, and an increase in the level of nesting.
</p>
</li>
<li> <p><code>close_array</code> As <code>open_array</code>, but ending the array of constants
</p>
</li>
<li> <p><code>fun_open</code> An open parenthesis <code>(</code> immediately after a function name,
directly enclosing the function arguments.
</p>
</li>
<li> <p><code>fun_close</code> As <code>fun_open</code> but immediately after the function
arguments.
</p>
</li>
<li> <p><code>separator</code> A comma <code style="white-space: pre;">&#8288;,&#8288;</code> separating function arguments or array
columns, or a semicolon <code style="white-space: pre;">&#8288;;&#8288;</code> separating array rows.
</p>
</li>
<li> <p><code>DDE</code> A call to a Dynamic Data Exchange server, usually normalized to
the form <code style="white-space: pre;">&#8288;[1]!'DDE_parameter=1'&#8288;</code>, but the full form is
<code style="white-space: pre;">&#8288;'ABCD'|'EFGH'!'IJKL'&#8288;</code>.
</p>
</li>
<li> <p><code>space</code> Some old files haven't stripped formulas of meaningless
spaces. They are returned as <code>space</code> tokens so that the original formula
can always be reconstructed by concatenating all tokens.
</p>
</li>
<li> <p><code>other</code> If you see this, then something has gone wrong &ndash; please
report it at https://github.com/nacnudus/tidyxl/issues with a
reproducible example (e.g. using the reprex package).
</p>
</li></ul>

<p>Every part of the original formula is returned as a token, so the original
formula can be reconstructed by concatenating the tokens.  If that doesn't
work, please report it at https://github.com/nacnudus/tidyxl/issues with a
reproducible example (e.g. using the reprex package).
</p>
<p>The XLParser project was a great help in creating the grammar.
https://github.com/spreadsheetlab/XLParser.
</p>


<h3>Value</h3>

<p>A data frame (a tibble, if you use the tidyverse) one row per token,
giving the token itself, its type (e.g.  <code>number</code>, or <code>error</code>), and its
level.
</p>
<p>A class attribute <code>xlex</code> is added, so that the <code><a href="base.html#topic+print">base::print()</a></code> generic can be
specialised to print the tree prettily.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># All explicit cell references/addresses are returned as a single 'ref' token.
xlex("A1")
xlex("A$1")
xlex("$A1")
xlex("$A$1")
xlex("A1:B2")
xlex("1:1") # Whole row
xlex("A:B") # Whole column

# If one part of an address is a name or a function, then the colon ':' is
# regarded as a 'range operator', so is tagged 'operator'.
xlex("A1:SOME.NAME")
xlex("SOME_FUNCTION():B2")
xlex("SOME_FUNCTION():SOME.NAME")

# Sheet names are recognised by the terminal exclamation mark '!'.
xlex("Sheet1!A1")
xlex("'Sheet 1'!A1")       # Quoted names may contain some punctuation
xlex("'It''s a sheet'!A1") # Quotes are escaped by doubling

# Sheets can be ranged together in so-called 'three-dimensional formulas'.
# Both sheets are returned in a single 'sheet' token.
xlex("Sheet1:Sheet2!A1")
xlex("'Sheet 1:Sheet 2'!A1") # Quotes surround both (rather than each) sheet

# Sheets from other files are prefixed by the filename, which Excel
# normalizes the filenames into indexes.  Either way, xlex() includes the
# file/index in the 'sheet' token.
xlex("[1]Sheet1!A1")
xlex("'[1]Sheet 1'!A1") # Quotes surround both the file index and the sheet
xlex("'C:\\My Documents\\[file.xlsx]Sheet1'!A1")

# Function names are recognised by the terminal open-parenthesis '('.  There
# is no distinction between custom functions and built-in Excel functions.
# The open-parenthesis is tagged 'fun_open', and the corresponding
# close-parenthesis at the end of the arguments is tagged 'fun_close'.
xlex("MAX(1,2)")
xlex("_xll.MY_CUSTOM_FUNCTION()")

# Named ranges (properly called 'named formulas') are a last resort after
# attempting to match a function (ending in an open parenthesis '(') or a
# sheet (ending in an exclamation mark '!')
xlex("MY_NAMED_RANGE")

# Some cell addresses/references, functions and names can look alike, but
# xlex() should always make the right choice.
xlex("XFD1")     # A cell in the maximum column in Excel
xlex("XFE1")     # Beyond the maximum column, must be a named range/formula
xlex("A1048576") # A cell in the maximum row in Excel
xlex("A1048577") # Beyond the maximum row, must be a named range/formula
xlex("LOG10")    # A cell address
xlex("LOG10()")  # A log function
xlex("LOG:LOG")  # The whole column 'LOG'
xlex("LOG")      # Not a cell address, must be a named range/formula
xlex("LOG()")    # Another log function
xlex("A1.2!A1")  # A sheet called 'A1.2'

# Text is surrounded by double-quotes.
xlex("\"Some text\"")
xlex("\"Some \"\"text\"\"\"") # Double-quotes within text are escaped by

# Numbers are signed where it makes sense, and can be scientific
xlex("1")
xlex("1.2")
xlex("-1")
xlex("-1-1")
xlex("-1+-1")
xlex("MAX(-1-1)")
xlex("-1.2E-3")

# Booleans can be constants or functions, and names can look like booleans,
# but xlex() should always make the right choice.
xlex("TRUE")
xlex("TRUEISH")
xlex("TRUE!A1")
xlex("TRUE()")

# Errors are tagged 'error'
xlex("#DIV/0!")
xlex("#N/A")
xlex("#NAME?")
xlex("#NULL!")
xlex("#NUM!")
xlex("#REF!")
xlex("#VALUE!")

# Operators with more than one character are treated as single tokens
xlex("1&lt;&gt;2")
xlex("1&lt;=2")
xlex("1&lt;2")
xlex("1=2")
xlex("1&amp;2")
xlex("1 2")
xlex("(1,2)")
xlex("1%")   # postfix operator

# The union operator is a comma ',', which is the same symbol that is used
# to separate function arguments or array columns.  It is tagged 'operator'
# only when it is inside parentheses that are not function parentheses or
# array curly braces.  The curly braces are tagged 'array_open' and
# 'array_close'.
tidyxl::xlex("A1,B2") # invalid formula, defaults to 'union' to avoid a crash
tidyxl::xlex("(A1,B2)")
tidyxl::xlex("MAX(A1,B2)")
tidyxl::xlex("SMALL((A1,B2),1)")

# Function arguments are separated by commas ',', which are tagged
# 'separator'.
xlex("MAX(1,2)")

# Nested functions are marked by an increase in the 'level'.  The level
# increases inside parentheses, rather than at the parentheses.  Curly
# braces, for arrays, have the same behaviour, as do subexpressions inside
# ordinary parenthesis, tagged 'paren_open' and 'paren_close'.  To see the
# levels explicitly (rather than by the pretty printing), print as a normal
# data frame or tibble by specifying `pretty = FALSE`.
# class with as.data.frame.
xlex("MAX(MIN(1,2),3)")
xlex("{1,2;3,4}")
xlex("1*(2+3)")
print(xlex("1*(2+3)"), pretty = FALSE)

# Arrays are marked by opening and closing curly braces, with comma ','
# between columns, and semicolons ';' between rows  Commas and semicolons are
# both tagged 'separator'.  Arrays contain only constants, which are
# booleans, numbers, text, and errors.
xlex("MAX({1,2;3,4})")
xlex("=MAX({-1E-2,TRUE;#N/A,\"Hello, World!\"})")

# Structured references are surrounded by square brackets.  Subexpressions
# may also be surrounded by square brackets, but xlex() returns the whole
# expression in a single 'structured_ref' token.
xlex("[@col2]")
xlex("SUM([col22])")
xlex("Table1[col1]")
xlex("Table1[[col1]:[col2]]")
xlex("Table1[#Headers]")
xlex("Table1[[#Headers],[col1]]")
xlex("Table1[[#Headers],[col1]:[col2]]")

# DDE calls (Dynamic Data Exchange) are normalized by Excel into indexes.
# Either way, xlex() includes everything in one token.
xlex("[1]!'DDE_parameter=1'")
xlex("'Quote'|'NYSE'!ZAXX")
# Meaningless spaces that appear in some old files are returned as 'space'
# tokens, so that the original formula can still be recovered by
# concatenating all the tokens.  Spaces between function names and their open
# parenthesis have not been observed, so are not permitted.
xlex(" MAX( A1 ) ")

# print.xlex() invisibly returns the original argument, so that it can be
# used in magrittr pipelines.
str(print(xlex("ROUND(A1*2")))
</code></pre>

<hr>
<h2 id='xlsx_cells'>Import xlsx (Excel) cell contents into a tidy structure.</h2><span id='topic+xlsx_cells'></span>

<h3>Description</h3>

<p><code>xlsx_cells()</code> imports data from spreadsheets without coercing it into a
rectangle.  Each cell is represented by a row in a data frame, giving the
cell's address, contents, formula, height, width, and keys to look up the
cell's formatting in the return value of <code><a href="#topic+xlsx_formats">xlsx_formats()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlsx_cells(
  path,
  sheets = NA,
  check_filetype = TRUE,
  include_blank_cells = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlsx_cells_+3A_path">path</code></td>
<td>
<p>Path to the xlsx file.</p>
</td></tr>
<tr><td><code id="xlsx_cells_+3A_sheets">sheets</code></td>
<td>
<p>Sheets to read. Either a character vector (the names of the
sheets), an integer vector (the positions of the sheets), or NA (default, all
sheets).</p>
</td></tr>
<tr><td><code id="xlsx_cells_+3A_check_filetype">check_filetype</code></td>
<td>
<p>Logical. Whether to check that the filetype is xlsx (or
xlsm) by looking at the file itself, rather than using the filename
extension.</p>
</td></tr>
<tr><td><code id="xlsx_cells_+3A_include_blank_cells">include_blank_cells</code></td>
<td>
<p>Logical. Whether to include cells that have no
value or formula (but might have formatting or comments).  Useful when a
whole column of cells has been formatted, but most are empty.  Try setting
this to <code>FALSE</code> if a spreadsheet seems too large to load.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A cell has two 'values': its content, and sometimes also a formula.  It also
has formatting applied at the 'style' level, which can be locally overridden.
</p>


<h4>Content</h4>

<p>Depending on the cell, the content may be a numeric value such as 365 or
365.25, it may represent a date/datetime in one of Excel's date/datetime
systems, or it may be an index into an internal table of strings.
<code>xlsx_cells()</code> attempts to infer the correct data type of each cell,
returning its value in the appropriate column (error, logical, numeric,
date, character). In case this cleverness is unhelpful, the unparsed value
and type information is available in the 'content' and 'data_type' columns.
</p>



<h4>Formula</h4>

<p>When a cell has a formula, the value in the 'content' column is the result
of the formula the last time it was evaluated.
</p>
<p>Certain groups of cells may share a formula that differs only by addresses
referred to in the formula; such groups are identified by an index, the
'formula_group'.  The xlsx (Excel) file format only records the formula
against one cell in any group.  <code>xlsx_cells()</code> propagates such formulas to
the other cells in a group, making the necessary changes to relative
addresses in the formula.
</p>
<p>Array formulas may also apply to a group of cells, identified by an address
'formula_ref', but xlsx (Excel) file format only records the formula
against one cell in the group.  <code>xlsx_cells()</code> propagates such formulas to
the other cells in a group.  Unlike shared formulas, no changes to
addresses in array formulas are necessary.
</p>
<p>Formulas that refer to other workbooks currently do not name the workbooks
directly, instead via indices such as <code style="white-space: pre;">&#8288;[1]&#8288;</code>.  It is planned to
dereference these.
</p>



<h4>Formatting</h4>

<p>Cell formatting is returned by <code><a href="#topic+xlsx_formats">xlsx_formats()</a></code>.  There are two
types of formatting: 'style' formatting, such as Excel's built-in styles
'normal', 'bad', etc., and 'local' formatting, which overrides the style.
These are returned in the <code style="white-space: pre;">&#8288;$style&#8288;</code> and <code style="white-space: pre;">&#8288;$local&#8288;</code> sublists of
<code><a href="#topic+xlsx_formats">xlsx_formats()</a></code>, with identical structures.
</p>
<p>To look up the local formatting of a given cell, take the cell's
<code>local_format_id</code> value (<code>my_cells$Sheet1[1, "local_format_id"]</code>), and use
it as an index into the format structure.  E.g. to look up the font size,
<code>my_formats$local$font$size[local_format_id]</code>.  To see all available
formats, type <code>str(my_formats$local)</code>.
</p>
<p>Strings can be formatted within a cell, so that a single cell can contain
substrings with different formatting.  This in-cell formatting is available
in the column <code>character_formatted</code>, which is a list-column of data frames.
Each row of each data frame describes a substring and its formatting.  For
cells without a character value, <code>character_formatted</code> is <code>NULL</code>, so for
further processing you might need to filter out the <code>NULL</code>s first.
</p>



<h3>Value</h3>

<p>A data frame with the following columns.
</p>

<ul>
<li> <p><code>sheet</code> The worksheet that the cell is from.
</p>
</li>
<li> <p><code>address</code> The cell address in A1 notation.
</p>
</li>
<li> <p><code>row</code> The row number of a cell address (integer).
</p>
</li>
<li> <p><code>col</code> The column number of a cell address (integer).
</p>
</li>
<li> <p><code>is_blank</code> Whether or not the cell has a value
</p>
</li>
<li> <p><code>content</code> Raw cell value before type conversion, useful for debugging.
</p>
</li>
<li> <p><code>data_type</code> The type of a cell, referring to the following columns:
error, logical, numeric, date, character, blank.
</p>
</li>
<li> <p><code>error</code> The error value of a cell.
</p>
</li>
<li> <p><code>logical</code> The boolean value of a cell.
</p>
</li>
<li> <p><code>numeric</code> The numeric value of a cell.
</p>
</li>
<li> <p><code>date</code> The date value of a cell.
</p>
</li>
<li> <p><code>character</code> The string value of a cell.
</p>
</li>
<li> <p><code>formula</code> The formula in a cell (see 'Details').
</p>
</li>
<li> <p><code>is_array</code> Whether or not the formula is an array formula.
</p>
</li>
<li> <p><code>formula_ref</code> The address of a range of cells group to which an array
formula or shared formula applies (see 'Details').
</p>
</li>
<li> <p><code>formula_group</code> The formula group to which the cell belongs (see
'Details').
</p>
</li>
<li> <p><code>comment</code> The text of a comment attached to a cell.
</p>
</li>
<li> <p><code>height</code> The height of a cell's row, in Excel's units.
</p>
</li>
<li> <p><code>width</code> The width of a cell's column, in Excel's units.
</p>
</li>
<li> <p><code>row_outline_level</code> The outline level of a cells's row.
</p>
</li>
<li> <p><code>col_outline_level</code> The outline level of a cells's column.
</p>
</li>
<li> <p><code>style_format</code> An index into a table of style formats
<code>x$formats$style</code> (see 'Details').
</p>
</li>
<li> <p><code>local_format_id</code> An index into a table of local cell formats
<code>x$formats$local</code> (see 'Details').
</p>
</li></ul>

<p>Cell formatting is returned in <code><a href="#topic+xlsx_formats">xlsx_formats()</a></code>.  There are two types
or scopes of formatting: 'style' formatting, such as Excel's built-in styles
'normal', 'bad', etc., and 'local' formatting, which overrides particular
elements of the style, e.g. by making it bold.  Both types are returned, in
the <code style="white-space: pre;">&#8288;$style&#8288;</code> and <code style="white-space: pre;">&#8288;$local&#8288;</code> sublists of <code><a href="#topic+xlsx_formats">xlsx_formats()</a></code>, with
identical structures.  To look up the local formatting of a given cell, take
the cell's 'local_format_id' value (<code>my_cells$data$Sheet1[1, "local_format_id"]</code>), and use it as an index into the format structure.  E.g.
to look up the font size, <code>my_formats$local$font$size[local_format_id]</code>.  To
see all available formats, type <code>str(my_formats$local)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>examples &lt;- system.file("extdata/examples.xlsx", package = "tidyxl")

# All sheets
str(xlsx_cells(examples))

# Specific sheet either by position or by name
str(xlsx_cells(examples, 2))
str(xlsx_cells(examples, "Sheet1"))

# The formats of particular cells can be retrieved like this:

Sheet1 &lt;- xlsx_cells(examples, "Sheet1")
formats &lt;- xlsx_formats(examples)

formats$local$font$bold[Sheet1$local_format_id]
formats$style$font$bold[Sheet1$style_format]

# To filter for cells of a particular format, first filter the formats to get
# the relevant indices, and then filter the cells by those indices.
bold_indices &lt;- which(formats$local$font$bold)
Sheet1[Sheet1$local_format_id %in% bold_indices, ]

# In-cell formatting is available in the `character_formatted` column as a
# data frame, one row per substring.
xlsx_cells(examples)$character_formatted[77]
</code></pre>

<hr>
<h2 id='xlsx_color_standard'>Names and RGB values of Excel standard colours</h2><span id='topic+xlsx_color_standard'></span><span id='topic+xlsx_colour_standard'></span>

<h3>Description</h3>

<p>A dataset containing the names and RGB colour values of Excel's standard
palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlsx_color_standard

xlsx_colour_standard
</code></pre>


<h3>Format</h3>

<p>A data frame with 10 rows and 2 variables:
</p>

<ul>
<li> <p><code>name</code> Name of the colour
</p>
</li>
<li> <p><code>rgb</code>  RGB value of the colour
</p>
</li></ul>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 10 rows and 2 columns.
</p>

<hr>
<h2 id='xlsx_color_theme'>Import theme color definitions from xlsx (Excel) files</h2><span id='topic+xlsx_color_theme'></span><span id='topic+xlsx_colour_theme'></span>

<h3>Description</h3>

<p><code>xlsx_color_theme()</code> (alias <code>xlsx_colour_theme()</code> returns the names and RGB
values of theme colours defined in xlsx (Excel) files.  For example,
<code>"accent6"</code> is the name of a theme colour in Excel, which could resolve to
any RGB colour defined by the author of the file.  Themes are often defined
to comply with corporate standards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlsx_color_theme(path, check_filetype = TRUE)

xlsx_colour_theme(path, check_filetype = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlsx_color_theme_+3A_path">path</code></td>
<td>
<p>Path to the xlsx file.</p>
</td></tr>
<tr><td><code id="xlsx_color_theme_+3A_check_filetype">check_filetype</code></td>
<td>
<p>Logical. Whether to check that the filetype is xlsx (or
xlsm) by looking at the file itself, rather than using the filename
extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, one row per colour, with the following columns.
</p>

<ul>
<li> <p><code>name</code> The name of the theme.
</p>
</li>
<li> <p><code>rgb</code> The RGB colour that has been set for the theme in this file.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>examples &lt;- system.file("extdata/examples.xlsx", package = "tidyxl")
xlsx_color_theme(examples)
xlsx_colour_theme(examples)
</code></pre>

<hr>
<h2 id='xlsx_formats'>Import xlsx (Excel) formatting definitions.</h2><span id='topic+xlsx_formats'></span>

<h3>Description</h3>

<p><code>xlsx_formats()</code> imports formatting definitions from spreadsheets.  The
structure is a nested list, e.g. <code>bold</code> is a vector within the list <code>font</code>,
which is within the list <code>local</code>, which is within the list
returned by <code>xlsx_formats()</code>.  You can look up a cell's formatting by
indexing the bottom-level vectors.  See 'Details' for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlsx_formats(path, check_filetype = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlsx_formats_+3A_path">path</code></td>
<td>
<p>Path to the xlsx file.</p>
</td></tr>
<tr><td><code id="xlsx_formats_+3A_check_filetype">check_filetype</code></td>
<td>
<p>Logical. Whether to check that the filetype is xlsx (or
xlsm) by looking at the file itself, rather than using the filename
extension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two types of formatting: 'style' formatting, such as Excel's
built-in styles 'normal', 'bad', etc., and 'local' formatting, which
overrides the style.  These are returned in the <code style="white-space: pre;">&#8288;$style&#8288;</code> and <code style="white-space: pre;">&#8288;$local&#8288;</code>
sublists of <code>xlsx_formats()</code>, with identical structures.
</p>
<p>To look up the local formatting of a given cell, take the cell's
<code>local_format_id</code> value (<code>my_cells$Sheet1[1, "local_format_id"]</code>), and use it
as an index into the format structure.  E.g.  to look up the font size,
<code>my_formats$local$font$size[local_format_id]</code>.  To see all available formats,
type <code>str(my_formats$local)</code>.
</p>
<p>Colours may be recorded in any of three ways: a hexadecimal RGB string with
or without alpha, an 'indexed' colour, and an index into a 'theme'.
<code>xlsx_formats()</code> dereferences 'indexed' and 'theme' colours to their
hexadecimal RGB string representation, and standardises all RGB strings to
have an alpha channel in the first two characters.  The 'index' and the
'theme' name are still provided.  To filter by an RGB string, you could  look
up the RGB values in a spreadsheet program (e.g. Excel, LibreOffice,
Gnumeric), and use the <code><a href="grDevices.html#topic+rgb">grDevices::rgb()</a></code> function to convert these to a
hexadecimal string.
</p>
<div class="sourceCode"><pre>A &lt;- 1; R &lt;- 0.5; G &lt;- 0; B &lt;- 0
rgb(A, R, G, B)
# [1] "#FF800000"
</pre></div>


<h3>Value</h3>

<p>A nested list of vectors, beginning at the top level with <code style="white-space: pre;">&#8288;$style&#8288;</code> and
<code style="white-space: pre;">&#8288;$local&#8288;</code>, then drilling down to the vectors that hold the definitions.  E.g.
<code>my_formats$local$font$size</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>examples &lt;- system.file("extdata/examples.xlsx", package = "tidyxl")
str(xlsx_formats(examples))

# The formats of particular cells can be retrieved like this:

cells &lt;- xlsx_cells(examples)
formats &lt;- xlsx_formats(examples)

formats$local$font$bold[cells$local_format_id]
formats$style$font$bold[cells$style_format]

# To filter for cells of a particular format, first filter the formats to get
# the relevant indices, and then filter the cells by those indices.
bold_indices &lt;- which(formats$local$font$bold)
cells[cells$local_format_id %in% bold_indices, ]
</code></pre>

<hr>
<h2 id='xlsx_names'>Import named formulas from xlsx (Excel) files</h2><span id='topic+xlsx_names'></span>

<h3>Description</h3>

<p><code>xlsx_names()</code> returns the names and definitions of named formulas (aka named
ranges) in xlsx (Excel) files.
</p>
<p>Most names refer to ranges of cells, but they can also be defined as
formulas.  <code>xlsx_names()</code> tells you whether or not they are a range, using
<code><a href="#topic+is_range">is_range()</a></code> to work this out.
</p>
<p>Names are scoped either globally (used only once in the file), or locally to
each sheet (can be reused with different definitions in different sheets).
For sheet-scoped names, <code>xlsx_names()</code> provides the name of the sheet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlsx_names(path, check_filetype = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlsx_names_+3A_path">path</code></td>
<td>
<p>Path to the xlsx file.</p>
</td></tr>
<tr><td><code id="xlsx_names_+3A_check_filetype">check_filetype</code></td>
<td>
<p>Logical. Whether to check that the filetype is xlsx (or
xlsm) by looking at the file itself, rather than using the filename
extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, one row per name, with the following columns.
</p>

<ul>
<li> <p><code>sheet</code> If the name is defined only for a specific sheet, the name of
the sheet.  Otherwise <code>NA</code> for names defined globally.
</p>
</li>
<li> <p><code>name</code>
</p>
</li>
<li> <p><code>formula</code> Usually a range of cells, but sometimes a whole formula, e.g.
<code>MAX(A2,1)</code>.
</p>
</li>
<li> <p><code>comment</code> A description given by the spreadsheet author.
</p>
</li>
<li> <p><code>hidden</code> Whether or not the name is visible to the user in spreadsheet
applications.  Hidden names are usually ones that were created
automatically by the spreadsheet application.
</p>
</li>
<li> <p><code>is_range</code> Whether or not the <code>formula</code> is a range of cells.  This is handy
for joining to the set of cells referred to by a name.  In this context,
commas between cell addresses are always regarded as union operators &ndash;
this differs from <code><a href="#topic+xlex">xlex()</a></code>, see that help file for details.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>examples &lt;- system.file("extdata/examples.xlsx", package = "tidyxl")
xlsx_names(examples)
</code></pre>

<hr>
<h2 id='xlsx_sheet_names'>List sheets in an xlsx (Excel) file</h2><span id='topic+xlsx_sheet_names'></span>

<h3>Description</h3>

<p><code>xlsx_sheets()</code> returns the names of the sheets in a workbook, as a character
vector.  They are in the same order as they appear in the spreadsheet when it
is opened with a spreadsheet application like Excel or LibreOffice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlsx_sheet_names(path, check_filetype = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlsx_sheet_names_+3A_path">path</code></td>
<td>
<p>Path to the xlsx file.</p>
</td></tr>
<tr><td><code id="xlsx_sheet_names_+3A_check_filetype">check_filetype</code></td>
<td>
<p>Logical. Whether to check that the filetype is xlsx (or
xlsm) by looking at the file itself, rather than using the filename
extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the names of the worksheets in the file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>examples &lt;- system.file("extdata/examples.xlsx", package = "tidyxl")
xlsx_sheet_names(examples)
</code></pre>

<hr>
<h2 id='xlsx_validation'>Import data validation rules of cells in xlsx (Excel) files</h2><span id='topic+xlsx_validation'></span>

<h3>Description</h3>

<p><code>xlsx_validation()</code> returns the data validation rules applied to cells in
xlsx (Excel) files.  Data validation rules control what constants can be
entered into a cell, e.g. any whole number between 0 and 9, or one of several
values from another part of the spreadsheet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlsx_validation(path, sheets = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlsx_validation_+3A_path">path</code></td>
<td>
<p>Path to the xlsx file.</p>
</td></tr>
<tr><td><code id="xlsx_validation_+3A_sheets">sheets</code></td>
<td>
<p>Sheets to read. Either a character vector (the names of the
sheets), an integer vector (the positions of the sheets), or NA (default, all
sheets).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns.
</p>

<ul>
<li> <p><code>sheet</code> The worksheet that a validation rule cell is from.
</p>
</li>
<li> <p><code>ref</code> Comma-delimited cell addresses to which the rules apply,
e.g. <code>A106</code> or A115,A121:A122'.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;type Data type of input, one of &#8288;</code>whole<code style="white-space: pre;">&#8288;, &#8288;</code>decimal<code style="white-space: pre;">&#8288;, &#8288;</code>list<code style="white-space: pre;">&#8288;, &#8288;</code>date<code style="white-space: pre;">&#8288;, &#8288;</code>time<code style="white-space: pre;">&#8288;, &#8288;</code>textLength<code style="white-space: pre;">&#8288;, &#8288;</code>custom<code style="white-space: pre;">&#8288;, and &#8288;</code>whole'.
</p>
</li>
<li> <p><code>operator</code> Unless <code>type</code> is <code>list</code> or <code>custom</code>, then <code>operator</code> is one of
<code>between</code>, <code>notBetween</code>, <code>equal</code>, <code>notEqual</code>, <code>greaterThan</code>, <code>lessThan</code>,
<code>greaterThanOrEqual</code>, <code>lessthanOrEqual</code>.
</p>
</li>
<li> <p><code>formula1</code> If <code>type</code> is <code>list</code>, then a range of cells whose values are
allowed by the rule.  If <code>type</code> is <code>custom</code>, then a formula to determine
allowable values.  Otherwise, a cell address or constant, coerced to
character.  Dates and times are formatted like &quot;2017-01-27 13:30:45&quot;.
Times without dates are formatted like &quot;13:30:45&quot;.
</p>
</li>
<li> <p><code>formula2</code> If <code>operator</code> is <code>between</code> or <code>notBetween</code>, then a cell address
or constant as with formula1, otherwise NA.
</p>
</li>
<li> <p><code>allow_blank</code> Boolean, whether or not the rule allows blanks.
</p>
</li>
<li> <p><code>show_input_message</code> Boolean, whether or not the rule shows a message when
the user begins entering a value.
</p>
</li>
<li> <p><code>prompt_title</code> Text to appear in the title bar of a popup message box
when the user begins entering a value.
</p>
</li>
<li> <p><code>prompt_body</code> Text to appear in a popup message box when the user begins
entering a value.  When <code>NA</code>, then some default text is shown.
</p>
</li>
<li> <p><code>show_error_message</code> Boolean, whether or not the rule shows a message when
the user has entered a forbidden value.  When <code>NA</code>, then some default
text is shown.
</p>
</li>
<li> <p><code>error_title</code> Text to appear in the title bar of a popup message box
when the user enters a forbidden value.  When <code>NA</code>, then some default
text is shown.
</p>
</li>
<li> <p><code>error_body</code> Text to appear in a popup message box when the user enters a
forbidden value.  When <code>NA</code>, then some default text is shown.
</p>
</li>
<li> <p><code>error_symbol</code> Name of a symbol to appear in the popup error message when
the user enters a forbidden value.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>examples &lt;- system.file("extdata/examples.xlsx", package = "tidyxl")
xlsx_validation(examples)
xlsx_validation(examples, 1)
xlsx_validation(examples, "Sheet1")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
