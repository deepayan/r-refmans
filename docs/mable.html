<!DOCTYPE html><html><head><title>Help for package mable</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mable}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chicken.embryo'><p>Chicken Embryo Data</p></a></li>
<li><a href='#cosmesis'><p>Breast cosmesis data</p></a></li>
<li><a href='#dmixbeta'><p>Mixture Beta Distribution</p></a></li>
<li><a href='#dmixmvbeta'><p>Multivariate Mixture Beta Distribution</p></a></li>
<li><a href='#dtmixbeta'><p>Exponentially Tilted Mixture Beta Distribution</p></a></li>
<li><a href='#mable'><p>Mable fit of one-sample raw data with an optimal or given degree.</p></a></li>
<li><a href='#mable.aft'><p>Mable fit of Accelerated Failure Time Model</p></a></li>
<li><a href='#mable.ctrl'><p>Control parameters for mable fit</p></a></li>
<li><a href='#mable.decon'><p>Mable deconvolution with a known error density</p></a></li>
<li><a href='#mable.dr'><p>MABLE in Desnity Ratio Model</p></a></li>
<li><a href='#mable.dr.group'><p>Mable fit of the density ratio model based on grouped data</p></a></li>
<li><a href='#mable.group'><p>Mable fit of one-sample grouped data by an optimal or a preselected model degree</p></a></li>
<li><a href='#mable.ic'><p>Mable fit based on one-sample interval censored data</p></a></li>
<li><a href='#mable.mvar'><p>Maximum Approximate Bernstein Likelihood Estimate</p>
of Multivariate Density Function</a></li>
<li><a href='#mable.ph'><p>Mable fit of Cox's proportional hazards regression model</p></a></li>
<li><a href='#mable.reg'><p>Mable fit of semiparametric regression model based on interval censored data</p></a></li>
<li><a href='#maple.aft'><p>Mable fit of AFT model with given regression coefficients</p></a></li>
<li><a href='#maple.dr'><p>Maximum approximate profile likelihood estimate of the density ratio model</p></a></li>
<li><a href='#maple.dr.group'><p>Maximum approximate profile likelihood estimate of the density ratio model</p>
for grouped data with given regression coefficients</a></li>
<li><a href='#maple.ph'><p>Mable fit of the PH model with given regression coefficients</p></a></li>
<li><a href='#marginal.p'><p>The mixing proportions of marginal distribution from the mixture of</p>
multivariate beta distribution</a></li>
<li><a href='#momodem'><p>Method of mode estimate of a Bernstein polynomial model degree</p></a></li>
<li><a href='#optim.gcp'><p>Choosing optimal model degree by gamma change-point method</p></a></li>
<li><a href='#optimable'><p>mable with degree selected by the method of moment and method of mode</p></a></li>
<li><a href='#pancreas'><p>Pancreatic Cancer Biomarker Data</p></a></li>
<li><a href='#plot.mable'><p>Plot mathod for class 'mable'</p></a></li>
<li><a href='#plot.mable_reg'><p>Plot mathod for class 'mable_reg'</p></a></li>
<li><a href='#se.coef.dr'><p>Standard errors of coefficients in density ratio model</p></a></li>
<li><a href='#summary.mable'><p>Summary mathods for classes 'mable' and 'mable_reg'</p></a></li>
<li><a href='#Vaal.Flow'><p>Vaal River Annual Flow Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Maximum Approximate Bernstein/Beta Likelihood Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhong Guan [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhong Guan &lt;zguan@iusb.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit data from a continuous population with a smooth density on finite interval by an approximate Bernstein polynomial model which is a mixture of certain beta distributions and find maximum approximate Bernstein likelihood estimator of the unknown coefficients. Consequently, maximum likelihood estimates of the unknown density, distribution functions, and more can be obtained. If the support of the density is not the unit interval then transformation can be applied. This is an implementation of the methods proposed by the author of this package published in the Journal of Nonparametric Statistics: Guan (2016) &lt;<a href="https://doi.org/10.1080%2F10485252.2016.1163349">doi:10.1080/10485252.2016.1163349</a>&gt; and Guan (2017) &lt;<a href="https://doi.org/10.1080%2F10485252.2017.1374384">doi:10.1080/10485252.2017.1374384</a>&gt;. For data with covariates, under some semiparametric regression models such as Cox proportional hazards model and the accelerated failure time model, the baseline survival function can be estimated smoothly based on general interval censored data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> [expanded from: LGPL (&ge; 2.0, &lt; 3)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>survival, graphics, stats, icenReg, parallel, doParallel,
foreach, iterators, tcltk</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mixtools, ICsurv, knitr, rmarkdown, pbapply, markdown, ks,
multimode</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-24 15:51:46 UTC; zguan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-24 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='chicken.embryo'>Chicken Embryo Data</h2><span id='topic+chicken.embryo'></span>

<h3>Description</h3>

<p>The chicken embryo dataset which contains <code>day</code>, number of days,  and <code>nT</code>, the corresponding frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chicken.embryo)
</code></pre>


<h3>Format</h3>

<p>The format is:
List of 2: 
day: int [1:21] 1 2 3 4 5 6 7 8 9 10 ...; 
nT : int [1:21] 6 5 11 2 2 3 0 0 0 0 ...
</p>


<h3>Source</h3>

<p>Jassim, E. W., Grossman, M., Koops, W. J. And Luykx, R. A. J. (1996). Multi-phasic analysis of embryonic
mortality in chickens. <em>Poultry Sci.</em> 75, 464-71.
</p>


<h3>References</h3>

<p>Kuurman, W. W., Bailey, B. A., Koops, W. J. And Grossman, M. (2003). A model for failure of a chicken embryo to survive incubation. <em>Poultry Sci.</em> 82, 214-22.
</p>
<p>Guan, Z. (2017) Bernstein polynomial model for grouped continuous data.  <em>Journal of Nonparametric Statistics</em>, 29(4):831-848.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chicken.embryo)
</code></pre>

<hr>
<h2 id='cosmesis'>Breast cosmesis data</h2><span id='topic+cosmesis'></span>

<h3>Description</h3>

<p>Data contain the interval-censored times to cosmetic deterioration  
for breast cancer patients undergoing radiation or radiation plus chemotherapy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cosmesis)
</code></pre>


<h3>Format</h3>

<p>A data frame with 94 observations on the following 3 variables. 
</p>

<ul>
<li><p> left left endpoint of the censoring interval in months
</p>
</li>
<li><p> right right endpoint of the censoring interval in months
</p>
</li>
<li><p> treat a factor with levels <code>RT</code> and <code>RCT</code> representing radiotherapy-only 
and radiation plus chemotherapy treatments, respectively
</p>
</li></ul>



<h3>Source</h3>

<p>Finkelstein, D. M. and Wolfe, R. A. (1985) 
A semiparametric model for regression analysis of interval-censored failure time data. 
Biometrics 41, 933–945.
</p>


<h3>References</h3>

<p>Finkelstein, D. M. (1986) A proportional hazards model for interval-censored 
failure time data. Biometrics 42, 845–854.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cosmesis)
</code></pre>

<hr>
<h2 id='dmixbeta'>Mixture Beta Distribution</h2><span id='topic+dmixbeta'></span><span id='topic+pmixbeta'></span><span id='topic+qmixbeta'></span><span id='topic+rmixbeta'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and
pseudorandom number generation for the Bernstein polynomial model,
mixture of beta distributions, with shapes <code class="reqn">(i+1, m-i+1)</code>, <code class="reqn">i = 0, \ldots, m</code>,
given mixture proportions <code class="reqn">p = (p_0, \ldots, p_m)</code> and support <code>interval</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixbeta(x, p, interval = c(0, 1))

pmixbeta(x, p, interval = c(0, 1))

qmixbeta(u, p, interval = c(0, 1))

rmixbeta(n, p, interval = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmixbeta_+3A_x">x</code></td>
<td>
<p>a vector of quantiles</p>
</td></tr>
<tr><td><code id="dmixbeta_+3A_p">p</code></td>
<td>
<p>a vector of <code>m+1</code> values. The <code>m+1</code> components of <code>p</code>
must be nonnegative and sum to one for mixture beta distribution. See 'Details'.</p>
</td></tr>
<tr><td><code id="dmixbeta_+3A_interval">interval</code></td>
<td>
<p>support/truncation interval <code>[a, b]</code>.</p>
</td></tr>
<tr><td><code id="dmixbeta_+3A_u">u</code></td>
<td>
<p>a vector of probabilities</p>
</td></tr>
<tr><td><code id="dmixbeta_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of the mixture beta distribution on an interval <code class="reqn">[a, b]</code> can be written as a
Bernstein polynomial <code class="reqn">f_m(x; p) = (b-a)^{-1}\sum_{i=0}^m p_i\beta_{mi}[(x-a)/(b-a)]/(b-a)</code>,
where <code class="reqn">p = (p_0, \ldots, p_m)</code>, <code class="reqn">p_i\ge 0</code>, <code class="reqn">\sum_{i=0}^m p_i=1</code> and
<code class="reqn">\beta_{mi}(u) = (m+1){m\choose i}u^i(1-x)^{m-i}</code>, <code class="reqn">i = 0, 1, \ldots, m</code>,
is the beta density with shapes <code class="reqn">(i+1, m-i+1)</code>. The cumulative distribution
function is <code class="reqn">F_m(x; p) = \sum_{i=0}^m p_i B_{mi}[(x-a)/(b-a)]</code>, where
<code class="reqn">B_{mi}(u)</code>, <code class="reqn">i = 0, 1, \ldots, m</code>, is the beta cumulative distribution function
with shapes <code class="reqn">(i+1, m-i+1)</code>. If <code class="reqn">\pi = \sum_{i=0}^m p_i&lt;1</code>, then <code class="reqn">f_m/\pi</code>
is a truncated desity on <code class="reqn">[a, b]</code> with cumulative distribution function
<code class="reqn">F_m/\pi</code>. The argument <code>p</code> may be any numeric vector of <code>m+1</code>
values when <code>pmixbeta()</code> and and <code>qmixbeta()</code> return the integral
function <code class="reqn">F_m(x; p)</code> and its inverse, respectively, and <code>dmixbeta()</code>
returns a Bernstein polynomial <code class="reqn">f_m(x; p)</code>. If components of <code>p</code> are not
all nonnegative or do not sum to one, warning message will be returned.
</p>


<h3>Value</h3>

<p>A vector of <code class="reqn">f_m(x; p)</code> or <code class="reqn">F_m(x; p)</code> values at <code class="reqn">x</code>.
<code>dmixbeta</code> returns the density, <code>pmixbeta</code> returns the cumulative
distribution function, <code>qmixbeta</code> returns the quantile function, and
<code>rmixbeta</code>  generates pseudo random numbers.
</p>


<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Bernstein, S.N. (1912), Demonstration du theoreme de Weierstrass fondee sur le calcul des probabilities,
Communications of the Kharkov Mathematical Society, 13, 1–2.
</p>
<p>Guan, Z. (2016) Efficient and robust density estimation using Bernstein type polynomials. <em>Journal of Nonparametric Statistics</em>, 28(2):250-271.
</p>
<p>Guan, Z. (2017) Bernstein polynomial model for grouped continuous data. <em>Journal of Nonparametric Statistics</em>, 29(4):831-848.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mable">mable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# classical Bernstein polynomial approximation
a&lt;--4; b&lt;-4; m&lt;-200
x&lt;-seq(a,b,len=512)
u&lt;-(0:m)/m
p&lt;-dnorm(a+(b-a)*u)
plot(x, dnorm(x), type="l")
lines(x, (b-a)*dmixbeta(x, p, c(a, b))/(m+1), lty=2, col=2)
legend(a, dnorm(0), lty=1:2, col=1:2, c(expression(f(x)==phi(x)),
               expression(B^{f}*(x))))

</code></pre>

<hr>
<h2 id='dmixmvbeta'>Multivariate Mixture Beta Distribution</h2><span id='topic+dmixmvbeta'></span><span id='topic+pmixmvbeta'></span><span id='topic+rmixmvbeta'></span>

<h3>Description</h3>

<p>Density, distribution function,  and 
pseudorandom number generation for the multivariate Bernstein polynomial model, 
mixture of multivariate beta distributions, with given mixture proportions 
<code class="reqn">p = (p_0, \ldots, p_{K-1})</code>, given degrees <code class="reqn">m = (m_1, \ldots, m_d)</code>,
and support <code>interval</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixmvbeta(x, p, m, interval = NULL)

pmixmvbeta(x, p, m, interval = NULL)

rmixmvbeta(n, p, m, interval = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmixmvbeta_+3A_x">x</code></td>
<td>
<p>a matrix with <code>d</code> columns or a vector of length <code>d</code> within 
support hyperrectangle <code class="reqn">[a, b] = [a_1, b_1] \times \cdots \times [a_d, b_d]</code></p>
</td></tr>
<tr><td><code id="dmixmvbeta_+3A_p">p</code></td>
<td>
<p>a vector of <code>K</code> values. All components of <code>p</code> must be 
nonnegative and sum to one for the mixture multivariate beta distribution. See 'Details'.</p>
</td></tr>
<tr><td><code id="dmixmvbeta_+3A_m">m</code></td>
<td>
<p>a vector of degrees, <code class="reqn">(m_1, \ldots, m_d)</code></p>
</td></tr>
<tr><td><code id="dmixmvbeta_+3A_interval">interval</code></td>
<td>
<p>a vector of two endpoints or a <code>2 x d</code> matrix, each column containing 
the endpoints of support/truncation interval for each marginal density.
If missing, the i-th column is assigned as <code>c(0,1))</code>.</p>
</td></tr>
<tr><td><code id="dmixmvbeta_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dmixmvbeta()</code> returns a linear combination <code class="reqn">f_m</code> of <code class="reqn">d</code>-variate beta densities 
on <code class="reqn">[a, b]</code>, <code class="reqn">\beta_{mj}(x) = \prod_{i=1}^d\beta_{m_i,j_i}[(x_i-a_i)/(b_i-a_i)]/(b_i-a_i)</code>,   
with coefficients <code class="reqn">p(j_1, \ldots, j_d)</code>, <code class="reqn">0 \le j_i \le m_i, i = 1, \ldots, d</code>, where
<code class="reqn">[a, b] = [a_1, b_1] \times \cdots \times [a_d, b_d]</code> is a hyperrectangle, and the  
coefficients are arranged in the column-major order of <code class="reqn">j = (j_1, \ldots, j_d)</code>, 
<code class="reqn">p_0, \ldots, p_{K-1}</code>,  where <code class="reqn">K = \prod_{i=1}^d (m_i+1)</code>. 
<code>pmixmvbeta()</code> returns a linear combination <code class="reqn">F_m</code> of the distribution
functions of <code class="reqn">d</code>-variate beta distribution.
</p>
<p>If all <code class="reqn">p_i</code>'s are nonnegative and sum to one, then <code>p</code>
are the mixture proportions of the mixture multivariate beta distribution.
</p>

<hr>
<h2 id='dtmixbeta'>Exponentially Tilted Mixture Beta Distribution</h2><span id='topic+dtmixbeta'></span><span id='topic+ptmixbeta'></span><span id='topic+qtmixbeta'></span><span id='topic+rtmixbeta'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and
pseudorandom number generation for the exponentially tilted  mixture of 
beta distributions, with shapes <code class="reqn">(i+1, m-i+1)</code>, <code class="reqn">i = 0, \ldots, m</code>,  
given mixture proportions <code class="reqn">p=(p_0,\ldots,p_m)</code> and support <code>interval</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtmixbeta(x, p, alpha, interval = c(0, 1), regr, ...)

ptmixbeta(x, p, alpha, interval = c(0, 1), regr, ...)

qtmixbeta(u, p, alpha, interval = c(0, 1), regr, ...)

rtmixbeta(n, p, alpha, interval = c(0, 1), regr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtmixbeta_+3A_x">x</code></td>
<td>
<p>a vector of quantiles</p>
</td></tr>
<tr><td><code id="dtmixbeta_+3A_p">p</code></td>
<td>
<p>a vector of <code>m+1</code> components of <code>p</code> must be nonnegative 
and sum to one for mixture beta distribution. See 'Details'.</p>
</td></tr>
<tr><td><code id="dtmixbeta_+3A_alpha">alpha</code></td>
<td>
<p>regression coefficients</p>
</td></tr>
<tr><td><code id="dtmixbeta_+3A_interval">interval</code></td>
<td>
<p>support/truncation interval <code>[a, b]</code>.</p>
</td></tr>
<tr><td><code id="dtmixbeta_+3A_regr">regr</code></td>
<td>
<p>regressor vector function <code class="reqn">r(x)=(1,r_1(x),...,r_d(x))</code> 
which returns n x (d+1) matrix, n=length(x)</p>
</td></tr>
<tr><td><code id="dtmixbeta_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to regr</p>
</td></tr>
<tr><td><code id="dtmixbeta_+3A_u">u</code></td>
<td>
<p>a vector of probabilities</p>
</td></tr>
<tr><td><code id="dtmixbeta_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of the mixture exponentially tilted beta distribution on an 
interval <code class="reqn">[a, b]</code> can be written <code class="reqn">f_m(x; p)=(b-a)^{-1}\exp(\alpha'r(x))
 \sum_{i=0}^m p_i\beta_{mi}[(x-a)/(b-a)]/(b-a)</code>,
where <code class="reqn">p = (p_0, \ldots, p_m)</code>, <code class="reqn">p_i\ge 0</code>, <code class="reqn">\sum_{i=0}^m p_i=1</code> and
<code class="reqn">\beta_{mi}(u) = (m+1){m\choose i}u^i(1-x)^{m-i}</code>, <code class="reqn">i = 0, 1, \ldots, m</code>,
is the beta density with shapes <code class="reqn">(i+1, m-i+1)</code>. The cumulative distribution
function is <code class="reqn">F_m(x; p) = \sum_{i=0}^m p_i B_{mi}[(x-a)/(b-a);alpha]</code>, where
<code class="reqn">B_{mi}(u ;alpha)</code>, <code class="reqn">i = 0, 1, \ldots, m</code>, is the exponentially tilted 
beta cumulative distribution function with shapes <code class="reqn">(i+1, m-i+1)</code>.
</p>


<h3>Value</h3>

<p>A vector of <code class="reqn">f_m(x; p)</code> or <code class="reqn">F_m(x; p)</code> values at <code class="reqn">x</code>.
<code>dmixbeta</code> returns the density, <code>pmixbeta</code> returns the cumulative
distribution function, <code>qmixbeta</code> returns the quantile function, and
<code>rmixbeta</code>  generates pseudo random numbers.
</p>


<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Guan, Z., Application of Bernstein Polynomial Model to Density 
and ROC Estimation in a Semiparametric Density Ratio Model
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mable">mable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># classical Bernstein polynomial approximation
a&lt;--4; b&lt;-4; m&lt;-200
x&lt;-seq(a,b,len=512)
u&lt;-(0:m)/m
p&lt;-dnorm(a+(b-a)*u)
plot(x, dnorm(x), type="l")
lines(x, (b-a)*dmixbeta(x, p, c(a, b))/(m+1), lty=2, col=2)
legend(a, dnorm(0), lty=1:2, col=1:2, c(expression(f(x)==phi(x)),
               expression(B^{f}*(x))))

</code></pre>

<hr>
<h2 id='mable'>Mable fit of one-sample raw data with an optimal or given degree.</h2><span id='topic+mable'></span>

<h3>Description</h3>

<p>Maximum approximate Bernstein/Beta likelihood estimation based on
one-sample raw data with an optimal selected by the change-point method among <code>m0:m1</code>
or a preselected model degree <code>m</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable(
  x,
  M,
  interval = c(0, 1),
  IC = c("none", "aic", "hqic", "all"),
  vb = 0,
  controls = mable.ctrl(),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="mable_+3A_m">M</code></td>
<td>
<p>a positive integer or a vector <code>(m0, m1)</code>. If <code>M = m</code> or <code>m0 = m1 = m</code>,
then <code>m</code> is a preselected degree. If <code>m0&lt;m1</code> it specifies the set of
consective candidate model degrees <code>m0:m1</code> for searching an optimal degree,
where <code>m1-m0&gt;3</code>.</p>
</td></tr>
<tr><td><code id="mable_+3A_interval">interval</code></td>
<td>
<p>a vector containing the endpoints of supporting/truncation interval <code>c(a,b)</code></p>
</td></tr>
<tr><td><code id="mable_+3A_ic">IC</code></td>
<td>
<p>information criterion(s) in addition to Bayesian information criterion (BIC). Current choices are
&quot;aic&quot; (Akaike information criterion) and/or
&quot;qhic&quot; (Hannan–Quinn information criterion).</p>
</td></tr>
<tr><td><code id="mable_+3A_vb">vb</code></td>
<td>
<p>code for vanishing boundary constraints, -1: f0(a)=0 only, 
1: f0(b)=0 only, 2: both, 0: none (default).</p>
</td></tr>
<tr><td><code id="mable_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit
and the convergence criterion <code>eps</code>. Default is <code><a href="#topic+mable.ctrl">mable.ctrl</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="mable_+3A_progress">progress</code></td>
<td>
<p>if TRUE a text progressbar is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any continuous density function <code class="reqn">f</code> on a known closed supporting interval <code class="reqn">[a,b]</code> can be
estimated by Bernstein polynomial <code class="reqn">f_m(x; p) = \sum_{i=0}^m p_i\beta_{mi}[(x-a)/(b-a)]/(b-a)</code>,
where <code class="reqn">p = (p_0, \ldots, p_m)</code>, <code class="reqn">p_i \ge 0</code>, <code class="reqn">\sum_{i=0}^m p_i = 1</code> and
<code class="reqn">\beta_{mi}(u) = (m+1){m\choose i}u^i(1-x)^{m-i}</code>, <code class="reqn">i = 0, 1, \ldots, m</code>,
is the beta density with shapes <code class="reqn">(i+1, m-i+1)</code>.
For each <code>m</code>, the MABLE of the coefficients <code>p</code>, the mixture proportions, are
obtained using EM algorithm. The EM iteration for each candidate <code>m</code> stops if either
the total absolute change of the log likelihood and the coefficients of Bernstein polynomial
is smaller than <code>eps</code> or the maximum number of iterations <code>maxit</code> is reached.
</p>
<p>If <code>m0&lt;m1</code>, an optimal model degree is selected as the change-point of the increments of
log-likelihood, log likelihood ratios, for <code class="reqn">m \in \{m_0, m_0+1, \ldots, m_1\}</code>. Alternatively,
one can choose an optimal degree based on the BIC (Schwarz, 1978) which are evaluated at
<code class="reqn">m \in \{m_0, m_0+1, \ldots, m_1\}</code>. The search for optimal degree <code>m</code> is stoped if either
<code>m1</code> is reached with a warning or the test for change-point results in a p-value <code>pval</code>
smaller than <code>sig.level</code>.  The BIC for a given degree <code>m</code> is calculated as in
Schwarz (1978) where the dimension of the model is <code class="reqn">d = \#\{i: \hat p_i\ge\epsilon,
  i = 0, \ldots, m\} - 1</code> and a default <code class="reqn">\epsilon</code> is chosen as <code>.Machine$double.eps</code>.
</p>
<p>If data show a clearly multimodal distribution by plotting the histogram for example, 
the model degree is usually large. The range <code>M</code> should be large enough to cover the 
optimal degree and the computation is time-consuming. In this case the iterative method 
of moment with an initial selected by a method of mode which is implemented
by <code><a href="#topic+optimable">optimable</a></code> can be used to reduce the computation time.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>m</code> the given or a selected degree by method of change-point
</p>
</li>
<li> <p><code>p</code> the estimated vector of mixture proportions <code class="reqn">p = (p_0, \ldots, p_m)</code>
with the selected/given optimal degree <code>m</code>
</p>
</li>
<li> <p><code>mloglik</code>  the maximum log-likelihood at degree <code>m</code>
</p>
</li>
<li> <p><code>interval</code> support/truncation interval <code>(a,b)</code>
</p>
</li>
<li> <p><code>convergence</code> An integer code. 0 indicates successful completion (all the EM iterations are convergent and an optimal degree
is successfully selected in <code>M</code>). Possible error codes are
</p>

<ul>
<li><p> 1, indicates that the iteration limit <code>maxit</code> had been reached in at least one EM iteration;
</p>
</li>
<li><p> 2, the search did not finish before <code>m1</code>.
</p>
</li></ul>

</li>
<li> <p><code>delta</code> the convergence criterion <code>delta</code> value
</p>
</li></ul>

<p>and, if <code>m0&lt;m1</code>,
</p>

<ul>
<li> <p><code>M</code> the vector <code>(m0, m1)</code>, where <code>m1</code>, if greater than <code>m0</code>, is the
largest candidate when the search stoped
</p>
</li>
<li> <p><code>lk</code> log-likelihoods evaluated at <code class="reqn">m \in \{m_0, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>lr</code> likelihood ratios for change-points evaluated at <code class="reqn">m \in \{m_0+1, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>ic</code> a list containing the selected information criterion(s)
</p>
</li>
<li> <p><code>pval</code> the p-values of the change-point tests for choosing optimal model degree
</p>
</li>
<li> <p><code>chpts</code> the change-points chosen with the given candidate model degrees
</p>
</li></ul>



<h3>Note</h3>

<p>Since the Bernstein polynomial model of degree <code class="reqn">m</code> is nested in the model of
degree <code class="reqn">m+1</code>, the maximum likelihood is increasing in <code class="reqn">m</code>. The change-point method
is used to choose an optimal degree <code class="reqn">m</code>. The degree can also be chosen by a method of
moment and a method of mode which are implemented by function <code>optimal()</code>.
</p>


<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Guan, Z. (2016) Efficient and robust density estimation using Bernstein type polynomials. <em>Journal of Nonparametric Statistics</em>, 28(2):250-271.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimable">optimable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Vaal Rive Flow Data
 data(Vaal.Flow)
 x&lt;-Vaal.Flow$Flow
 res&lt;-mable(x, M = c(2,100), interval = c(0, 3000), controls =
        mable.ctrl(sig.level = 1e-8, maxit = 2000, eps = 1.0e-9))
 op&lt;-par(mfrow = c(1,2),lwd = 2)
 layout(rbind(c(1, 2), c(3, 3)))
 plot(res, which = "likelihood", cex = .5)
 plot(res, which = c("change-point"), lgd.x = "topright")
 hist(x, prob = TRUE, xlim = c(0,3000), ylim = c(0,.0022), breaks = 100*(0:30),
  main = "Histogram and Densities of the Annual Flow of Vaal River",
  border = "dark grey",lwd = 1,xlab = "x", ylab = "f(x)", col  = "light grey")
 lines(density(x, bw = "nrd0", adjust = 1), lty = 4, col = 4)
 lines(y&lt;-seq(0, 3000, length = 100), dlnorm(y, mean(log(x)),
                   sqrt(var(log(x)))), lty = 2, col = 2)
 plot(res, which = "density", add = TRUE)
 legend("top", lty = c(1, 2, 4), col = c(1, 2, 4), bty = "n",
 c(expression(paste("MABLE: ",hat(f)[B])),
        expression(paste("Log-Normal: ",hat(f)[P])),
               expression(paste("KDE: ",hat(f)[K]))))
 par(op)


# Old Faithful Data
 library(mixtools)
 x&lt;-faithful$eruptions
 a&lt;-0; b&lt;-7
 v&lt;-seq(a, b,len = 512)
 mu&lt;-c(2,4.5); sig&lt;-c(1,1)
 pmix&lt;-normalmixEM(x,.5, mu, sig)
 lam&lt;-pmix$lambda; mu&lt;-pmix$mu; sig&lt;-pmix$sigma
 y1&lt;-lam[1]*dnorm(v,mu[1], sig[1])+lam[2]*dnorm(v, mu[2], sig[2])
 res&lt;-mable(x, M = c(2,300), interval = c(a,b), controls  =
        mable.ctrl(sig.level = 1e-8, maxit = 2000L, eps = 1.0e-7))
 op&lt;-par(mfrow = c(1,2),lwd = 2)
 layout(rbind(c(1, 2), c(3, 3)))
 plot(res, which = "likelihood")
 plot(res, which = "change-point")
 hist(x, breaks = seq(0,7.5,len = 20), xlim = c(0,7), ylim = c(0,.7),
     prob  = TRUE,xlab = "t", ylab = "f(t)", col  = "light grey",
     main = "Histogram and Density of
               Duration of Eruptions of Old Faithful")
 lines(density(x, bw = "nrd0", adjust = 1), lty = 4, col = 4, lwd = 2)
 plot(res, which = "density", add = TRUE)
 lines(v, y1, lty = 2, col = 2, lwd = 2)
 legend("topright", lty = c(1,2,4), col = c(1,2,4), lwd = 2, bty = "n",
      c(expression(paste("MABLE: ",hat(f)[B](x))),
         expression(paste("Mixture: ",hat(f)[P](t))),
         expression(paste("KDE: ",hat(f)[K](t)))))
 par(op)


</code></pre>

<hr>
<h2 id='mable.aft'>Mable fit of Accelerated Failure Time Model</h2><span id='topic+mable.aft'></span>

<h3>Description</h3>

<p>Maximum approximate Bernstein/Beta likelihood estimation for
accelerated failure time model based on interval censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable.aft(
  formula,
  data,
  M,
  g = NULL,
  p = NULL,
  tau = NULL,
  x0 = NULL,
  controls = mable.ctrl(),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable.aft_+3A_formula">formula</code></td>
<td>
<p>regression formula. Response must be <code>cbind</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="mable.aft_+3A_data">data</code></td>
<td>
<p>a dataset</p>
</td></tr>
<tr><td><code id="mable.aft_+3A_m">M</code></td>
<td>
<p>a positive integer or a vector <code>(m0, m1)</code>. If <code>M = m0</code> or <code>m0 = m1 = m</code>,
then <code>m0</code> is a preselected degree. If <code>m0 &lt; m1</code> it specifies the set of 
consective candidate model degrees <code>m0:m1</code> for searching an optimal degree,
where <code>m1-m0&gt;3</code>.</p>
</td></tr>
<tr><td><code id="mable.aft_+3A_g">g</code></td>
<td>
<p>a <code class="reqn">d</code>-vector of regression coefficients, default is the zero vector.</p>
</td></tr>
<tr><td><code id="mable.aft_+3A_p">p</code></td>
<td>
<p>an initial coefficients of Bernstein polynomial of degree <code>m0</code>, 
default is the uniform initial.</p>
</td></tr>
<tr><td><code id="mable.aft_+3A_tau">tau</code></td>
<td>
<p>the right endpoint of the support or truncation interval <code class="reqn">[0,\tau)</code> of the
baseline density. Default is <code>NULL</code> (unknown), otherwise if <code>tau</code> is given 
then it is taken as a known value of <code class="reqn">\tau</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="mable.aft_+3A_x0">x0</code></td>
<td>
<p>a working baseline covariate <code class="reqn">x_0</code>, default is zero vector. See 'Details'.</p>
</td></tr>
<tr><td><code id="mable.aft_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit 
and other control options. Default is <code><a href="#topic+mable.ctrl">mable.ctrl</a></code>.</p>
</td></tr>
<tr><td><code id="mable.aft_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> a text progressbar is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the accelerated failure time model with covariate for interval-censored failure time data: 
<code class="reqn">S(t|x) = S(t \exp(\gamma^T(x-x_0))|x_0)</code>, where <code class="reqn">x_0</code> is a baseline covariate.   
Let <code class="reqn">f(t|x)</code> and <code class="reqn">F(t|x) = 1-S(t|x)</code> be the density and cumulative distribution
functions of the event time given <code class="reqn">X = x</code>, respectively.
Then <code class="reqn">f(t|x_0)</code> on a truncation interval <code class="reqn">[0, \tau]</code> can be approximated by  
<code class="reqn">f_m(t|x_0; p) = \tau^{-1}\sum_{i=0}^m p_i\beta_{mi}(t/\tau)</code>,
where <code class="reqn">p_i\ge 0</code>, <code class="reqn">i = 0, \ldots, m</code>, <code class="reqn">\sum_{i=0}^mp_i=1</code>,  
<code class="reqn">\beta_{mi}(u)</code> is the beta denity with shapes <code class="reqn">i+1</code> and <code class="reqn">m-i+1</code>, and
<code class="reqn">\tau</code> is larger than the largest observed time, either uncensored time, or right endpoint of interval/left censored,
or left endpoint of right censored time. So we can approximate  <code class="reqn">S(t|x_0)</code> on <code class="reqn">[0, \tau]</code> by
<code class="reqn">S_m(t|x_0; p) = \sum_{i=0}^{m} p_i \bar B_{mi}(t/\tau)</code>, where <code class="reqn">\bar B_{mi}(u)</code> is
the beta survival function with shapes <code class="reqn">i+1</code> and <code class="reqn">m-i+1</code>.
</p>
<p>Response variable should be of the form <code>cbind(l, u)</code>, where <code>(l,u)</code> is the interval 
containing the event time. Data is uncensored if <code>l = u</code>, right censored 
if <code>u = Inf</code> or <code>u = NA</code>, and  left censored data if <code>l = 0</code>.
The truncation time <code>tau</code> and the baseline <code>x0</code> should be chosen so that 
<code class="reqn">S(t|x)=S(t \exp(\gamma^T(x-x_0))|x_0)</code> on <code class="reqn">[\tau, \infty)</code> is negligible for
all the observed <code class="reqn">x</code>.
</p>
<p>The search for optimal degree <code>m</code> stops if either <code>m1</code> is reached or the test 
for change-point results in a p-value <code>pval</code> smaller than <code>sig.level</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>
 
<ul>
<li> <p><code>m</code> the given or selected optimal degree <code>m</code>
</p>
</li>
<li> <p><code>p</code> the estimate of <code>p = (p_0, ..., p_m)</code>, the coefficients of Bernstein polynomial of degree <code>m</code>
</p>
</li>
<li> <p><code>coefficients</code> the estimated regression coefficients of the AFT model
</p>
</li>
<li> <p><code>SE</code> the standard errors of the estimated regression coefficients 
</p>
</li>
<li> <p><code>z</code> the z-scores of the estimated regression coefficients 
</p>
</li>
<li> <p><code>mloglik</code> the maximum log-likelihood at an optimal degree <code>m</code>
</p>
</li>
<li> <p><code>tau.n</code> maximum observed time <code class="reqn">\tau_n</code>
</p>
</li>
<li> <p><code>tau</code> right endpoint of trucation interval <code class="reqn">[0, \tau)</code>
</p>
</li>
<li> <p><code>x0</code> the working baseline covariates 
</p>
</li>
<li> <p><code>egx0</code> the value of <code class="reqn">e^{\gamma^T x_0}</code> 
</p>
</li>
<li> <p><code>convergence</code> an integer code: 0 indicates a successful completion; 
1 indicates that the search of an optimal degree using change-point method reached  
the maximum candidate degree; 2 indicates that the matimum iterations was reached for
calculating <code class="reqn">\hat p</code> and <code class="reqn">\hat\gamma</code> with the selected degree <code class="reqn">m</code>,  
or the divergence of the last EM-like iteration for <code class="reqn">p</code> or the divergence of
the last (quasi) Newton iteration for <code class="reqn">\gamma</code>; 3 indicates 1 and 2.   
</p>
</li>
<li> <p><code>delta</code> the final <code>delta</code> if <code>m0 = m1</code> or the final <code>pval</code> of the change-point 
for searching the optimal degree <code>m</code>;
</p>
</li></ul>

<p>and, if <code>m0&lt;m1</code>,
</p>

<ul>
<li> <p><code>M</code> the vector <code>(m0, m1)</code>, where <code>m1</code> is the last candidate when the search stoped
</p>
</li>
<li> <p><code>lk</code> log-likelihoods evaluated at <code class="reqn">m \in \{m_0, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>lr</code> likelihood ratios for change-points evaluated at <code class="reqn">m \in \{m_0+1, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>pval</code> the p-values of the change-point tests for choosing optimal model degree
</p>
</li>
<li> <p><code>chpts</code> the change-points chosen with the given candidate model degrees
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Guan, Z. (2019) Maximum Approximate Likelihood Estimation in Accelerated Failure Time Model for Interval-Censored Data, 
arXiv:1911.07087.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maple.aft">maple.aft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Breast Cosmesis Data
  bcos=cosmesis
  bcos2&lt;-data.frame(bcos[,1:2], x=1*(bcos$treat=="RCT"))
  g &lt;- 0.41 #Hanson and  Johnson 2004, JCGS
  aft.res&lt;-mable.aft(cbind(left, right)~x, data=bcos2, M=c(1, 30), g=g, tau=100, x0=1)
  op&lt;-par(mfrow=c(1,2), lwd=1.5)
  plot(x=aft.res, which="likelihood")
  plot(x=aft.res, y=data.frame(x=0), which="survival", model='aft', type="l", col=1, 
      add=FALSE, main="Survival Function")
  plot(x=aft.res, y=data.frame(x=1), which="survival", model='aft', lty=2, col=1)
  legend("bottomleft", bty="n", lty=1:2, col=1, c("Radiation Only", "Radiation and Chemotherapy"))
  par(op)

</code></pre>

<hr>
<h2 id='mable.ctrl'>Control parameters for mable fit</h2><span id='topic+mable.ctrl'></span>

<h3>Description</h3>

<p>Control parameters for mable fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable.ctrl(
  sig.level = 0.01,
  eps = 1e-07,
  maxit = 5000L,
  eps.em = 1e-07,
  maxit.em = 5000L,
  eps.nt = 1e-07,
  maxit.nt = 100L,
  tini = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable.ctrl_+3A_sig.level">sig.level</code></td>
<td>
<p>the sigificance level for change-point method of choosing
optimal model degree</p>
</td></tr>
<tr><td><code id="mable.ctrl_+3A_eps">eps</code></td>
<td>
<p>convergence criterion for iteration involves EM like and Newton-Raphson iterations</p>
</td></tr>
<tr><td><code id="mable.ctrl_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations involve EM like and Newton-Raphson iterations</p>
</td></tr>
<tr><td><code id="mable.ctrl_+3A_eps.em">eps.em</code></td>
<td>
<p>convergence criterion for EM like iteration</p>
</td></tr>
<tr><td><code id="mable.ctrl_+3A_maxit.em">maxit.em</code></td>
<td>
<p>maximum number of EM like iterations</p>
</td></tr>
<tr><td><code id="mable.ctrl_+3A_eps.nt">eps.nt</code></td>
<td>
<p>convergence criterion for Newton-Raphson iteration</p>
</td></tr>
<tr><td><code id="mable.ctrl_+3A_maxit.nt">maxit.nt</code></td>
<td>
<p>maximum number of Newton-Raphson iterations</p>
</td></tr>
<tr><td><code id="mable.ctrl_+3A_tini">tini</code></td>
<td>
<p>a small positive number used to make sure initial <code>p</code> 
is in the interior of the simplex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the arguments' values
</p>


<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>

<hr>
<h2 id='mable.decon'>Mable deconvolution with a known error density</h2><span id='topic+mable.decon'></span>

<h3>Description</h3>

<p>Maximum approximate Bernstein/Beta likelihood estimation in additive density deconvolution model
with a known error density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable.decon(
  y,
  gn = NULL,
  ...,
  M,
  interval = c(0, 1),
  IC = c("none", "aic", "hqic", "all"),
  vanished = TRUE,
  controls = mable.ctrl(maxit.em = 1e+05, eps.em = 1e-05, maxit.nt = 100, eps.nt = 1e-10),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable.decon_+3A_y">y</code></td>
<td>
<p>vector of observed data values</p>
</td></tr>
<tr><td><code id="mable.decon_+3A_gn">gn</code></td>
<td>
<p>error density function if known, default is NULL if unknown</p>
</td></tr>
<tr><td><code id="mable.decon_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to gn</p>
</td></tr>
<tr><td><code id="mable.decon_+3A_m">M</code></td>
<td>
<p>a vector <code>(m0, m1)</code> specifies the set of consective candidate model degrees, <code>M = m0:m1</code>.
If <code>gn</code> is unknown then <code>M</code> a 2 x 2 matrix whose rows <code>(m0,m1)</code> and <code>(k0,k1)</code>
specify lower and upper bounds for degrees <code>m</code> and <code>k</code>, respectively.</p>
</td></tr>
<tr><td><code id="mable.decon_+3A_interval">interval</code></td>
<td>
<p>a finite vector <code>(a,b)</code>, the endpoints of supporting/truncation interval
if <code>gn</code> is known. Otherwise, it is a 2 x 2 matrix whose rows <code>(a,b)</code> and <code>(a1,b1)</code>
specify supporting/truncation intervals of <code>X</code> and <code class="reqn">\epsilon</code>, respectively. See Details.</p>
</td></tr>
<tr><td><code id="mable.decon_+3A_ic">IC</code></td>
<td>
<p>information criterion(s) in addition to Bayesian information criterion (BIC). Current choices are
&quot;aic&quot; (Akaike information criterion) and/or
&quot;qhic&quot; (Hannan–Quinn information criterion).</p>
</td></tr>
<tr><td><code id="mable.decon_+3A_vanished">vanished</code></td>
<td>
<p>logical whether the unknown error density vanishes at both end-points of <code>[a1,b1]</code></p>
</td></tr>
<tr><td><code id="mable.decon_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit
and other control options. Default is <code><a href="#topic+mable.ctrl">mable.ctrl</a></code>.</p>
</td></tr>
<tr><td><code id="mable.decon_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> a text progressbar is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the additive measurement error model <code class="reqn">Y = X + \epsilon</code>, where
<code class="reqn">X</code> has an unknown distribution <code class="reqn">F</code> on a known support <code>[a,b]</code>, <code class="reqn">\epsilon</code> has a known or unknown distribution <code class="reqn">G</code>,
and <code class="reqn">X</code> and <code class="reqn">\epsilon</code> are independent. We want to estimate density <code class="reqn">f = F'</code>
based on independent observations, <code class="reqn">y_i = x_i + \epsilon_i</code>, <code class="reqn">i = 1, \ldots, n</code>, of <code class="reqn">Y</code>.
We approximate <code class="reqn">f</code> by a Bernstein polynomial model on <code>[a,b]</code>. If <code class="reqn">g=G'</code> is unknown on
a known support <code>[a1,b1]</code>, then we approximate <code class="reqn">g</code> by a Bernstein polynomial model on
<code>[a1,b1]</code>, <code class="reqn">a1&lt;0&lt;b1</code>. We assume <code class="reqn">E(\epsilon)=0</code>. AIC and BIC methods are used to
select model degrees <code>(m,k)</code>.
</p>


<h3>Value</h3>

<p>A <code>mable</code> class object with components, if <code class="reqn">g</code> is known,
</p>

<ul>
<li> <p><code>M</code> the vector <code>(m0, m1)</code>, where <code>m1</code> is the last candidate degree when the search stoped
</p>
</li>
<li> <p><code>m</code> the selected optimal degree <code>m</code>
</p>
</li>
<li> <p><code>p</code> the estimate of <code>p = (p_0, ..., p_m)</code>, the coefficients of Bernstein polynomial of degree <code>m</code>
</p>
</li>
<li> <p><code>lk</code> log-likelihoods evaluated at <code class="reqn">m \in \{m_0, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>lr</code> likelihood ratios for change-points evaluated at <code class="reqn">m \in \{m_0+1, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>convergence</code> An integer code. 0 indicates an optimal degree
is successfully selected in <code>M</code>. 1 indicates that the search stoped at <code>m1</code>.
</p>
</li>
<li> <p><code>ic</code> a list containing the selected information criterion(s)
</p>
</li>
<li> <p><code>pval</code> the p-values of the change-point tests for choosing optimal model degree
</p>
</li>
<li> <p><code>chpts</code> the change-points chosen with the given candidate model degrees
</p>
</li></ul>

<p>if <code class="reqn">g</code> is unknown,
</p>

<ul>
<li> <p><code>M</code> the 2 x 2 matrix with rows <code>(m0, m1)</code> and <code>(k0,k1)</code>
</p>
</li>
<li> <p><code>nu_aic</code> the selected optimal degrees <code>(m,k)</code> using AIC method
</p>
</li>
<li> <p><code>p_aic</code> the estimate of <code>p = (p_0, ..., p_m)</code>, the coefficients
of Bernstein polynomial model for <code class="reqn">f</code> of degree <code>m</code> as in <code>nu_aic</code>
</p>
</li>
<li> <p><code>q_aic</code> the estimate of <code>q = (q_0, ..., q_k)</code>, the coefficients
of Bernstein polynomial model for <code class="reqn">g</code> of degree <code>k</code> as in <code>nu_aic</code>
</p>
</li>
<li> <p><code>nu_bic</code> the selected optimal degrees <code>(m,k)</code> using BIC method
</p>
</li>
<li> <p><code>p_bic</code> the estimate of <code>p = (p_0, ..., p_m)</code>, the coefficients
of Bernstein polynomial model for <code class="reqn">f</code> of degree <code>m</code> as in <code>nu_bic</code>
</p>
</li>
<li> <p><code>q_bic</code> the estimate of <code>q = (q_0, ..., q_k)</code>, the coefficients
of Bernstein polynomial model for <code class="reqn">g</code> of degree <code>k</code> as in <code>nu_bic</code>
</p>
</li>
<li> <p><code>lk</code> matrix of log-likelihoods evaluated at <code class="reqn">m \in \{m_0, \ldots, m_1\}</code>
and <code class="reqn">k \in \{k_0, \ldots, k_1\}</code>
</p>
</li>
<li> <p><code>aic</code> a matrix containing the Akaike information criterion(s) at
<code class="reqn">m \in \{m_0, \ldots, m_1\}</code> and <code class="reqn">k \in \{k_0, \ldots, k_1\}</code>
</p>
</li>
<li> <p><code>bic</code> a matrix containing the Bayesian information criterion(s) at
<code class="reqn">m \in \{m_0, \ldots, m_1\}</code> and <code class="reqn">k \in \{k_0, \ldots, k_1\}</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Guan, Z., (2019) Fast Nonparametric Maximum Likelihood Density Deconvolution Using Bernstein Polynomials, Statistica Sinica,
doi:10.5705/ss.202018.0173
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # A simulated normal dataset
 set.seed(123)
 mu&lt;-1; sig&lt;-2; a&lt;-mu-sig*5; b&lt;-mu+sig*5;
 gn&lt;-function(x) dnorm(x, 0, 1)
 n&lt;-50;
 x&lt;-rnorm(n, mu, sig); e&lt;-rnorm(n); y&lt;-x+e;
 res&lt;-mable.decon(y, gn, interval = c(a, b), M = c(5, 50))
 op&lt;-par(mfrow = c(2, 2),lwd = 2)
 plot(res, which="likelihood")
 plot(res, which="change-point", lgd.x="topright")
 plot(xx&lt;-seq(a, b, length=100), yy&lt;-dnorm(xx, mu, sig), type="l", xlab="x",
     ylab="Density", ylim=c(0, max(yy)*1.1))
 plot(res, which="density", types=c(2,3), colors=c(2,3))
 # kernel density based on pure data
 lines(density(x), lty=4, col=4)
 legend("topright", bty="n", lty=1:4, col=1:4,
 c(expression(f), expression(hat(f)[cp]), expression(hat(f)[bic]), expression(tilde(f)[K])))
 plot(xx, yy&lt;-pnorm(xx, mu, sig), type="l", xlab="x", ylab="Distribution Function")
 plot(res, which="cumulative",  types=c(2,3), colors=c(2,3))
 legend("bottomright", bty="n", lty=1:3, col=1:3,
     c(expression(F), expression(hat(F)[cp]), expression(hat(F)[bic])))
 par(op)

</code></pre>

<hr>
<h2 id='mable.dr'>MABLE in Desnity Ratio Model</h2><span id='topic+mable.dr'></span>

<h3>Description</h3>

<p>Maximum approximate Bernstein/Beta likelihood estimation in a
density ratio model based on two-sample raw data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable.dr(
  x,
  y,
  M,
  regr,
  ...,
  interval = c(0, 1),
  alpha = NULL,
  vb = 0,
  baseline = NULL,
  controls = mable.ctrl(),
  progress = TRUE,
  message = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable.dr_+3A_x">x</code>, <code id="mable.dr_+3A_y">y</code></td>
<td>
<p>original two sample raw data, codex:&quot;Control&quot;, <code>y</code>: &quot;Case&quot;.</p>
</td></tr>
<tr><td><code id="mable.dr_+3A_m">M</code></td>
<td>
<p>a positive integer or a vector <code>(m0, m1)</code>.</p>
</td></tr>
<tr><td><code id="mable.dr_+3A_regr">regr</code></td>
<td>
<p>regressor vector function <code class="reqn">r(x)=(1,r_1(x),...,r_d(x))</code> 
which returns n x (d+1) matrix, n=length(x)</p>
</td></tr>
<tr><td><code id="mable.dr_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to regr</p>
</td></tr>
<tr><td><code id="mable.dr_+3A_interval">interval</code></td>
<td>
<p>a vector <code>(a,b)</code> containing the endpoints of 
supporting/truncation interval of x and y.</p>
</td></tr>
<tr><td><code id="mable.dr_+3A_alpha">alpha</code></td>
<td>
<p>initial regression coefficient, missing value is imputed by 
logistic regression</p>
</td></tr>
<tr><td><code id="mable.dr_+3A_vb">vb</code></td>
<td>
<p>code for vanishing boundary constraints, -1: f0(a)=0 only, 
1: f0(b)=0 only, 2: both, 0: none (default).</p>
</td></tr>
<tr><td><code id="mable.dr_+3A_baseline">baseline</code></td>
<td>
<p>the working baseline, &quot;Control&quot; or &quot;Case&quot;, if <code>NULL</code>
it is chosen to the one with smaller estimated lower bound for model degree.</p>
</td></tr>
<tr><td><code id="mable.dr_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit
and the convergence criterion for EM and Newton iterations. Default is 
<code><a href="#topic+mable.ctrl">mable.ctrl</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="mable.dr_+3A_progress">progress</code></td>
<td>
<p>logical: should a text progressbar be displayed</p>
</td></tr>
<tr><td><code id="mable.dr_+3A_message">message</code></td>
<td>
<p>logical: should warning messages be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that <code>x</code> (&quot;control&quot;) and <code>y</code> (&quot;case&quot;) are independent  
samples from f0 and f1 which  samples
satisfy f1(x)=f0(x)exp[alpha0+alpha'r(x)] with r(x)=(r1(x),...,r_d(x)). Maximum 
approximate Bernstein/Beta likelihood estimates of (alpha0,alpha), f0 and f1 
are calculated. If support is (a,b) then replace r(x) by r[a+(b-a)x].
For a fixed <code>m</code>, using the Bernstein polynomial model for baseline <code class="reqn">f_0</code>,
MABLEs of <code class="reqn">f_0</code> and parameters alpha can be estimated by EM algorithm and Newton  
iteration. If estimated lower bound <code class="reqn">m_b</code> for <code>m</code> based on <code>y</code>
is smaller that that based on <code>x</code>, then switch <code>x</code> and <code>y</code> and
<code class="reqn">f_1</code> is used as baseline. If <code>M=m</code> or <code>m0=m1=m</code>, then <code>m</code> is a 
preselected degree. If <code>m0&lt;m1</code> it specifies the set of consective  
candidate model degrees <code>m0:m1</code> for searching an optimal degree by 
the change-point method, where <code>m1-m0&gt;3</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>m</code> the given or a selected degree by method of change-point
</p>
</li>
<li> <p><code>p</code> the estimated vector of mixture proportions <code class="reqn">p = (p_0, \ldots, p_m)</code>
with the given or selected degree <code>m</code>
</p>
</li>
<li> <p><code>alpha</code> the estimated regression coefficients
</p>
</li>
<li> <p><code>mloglik</code>  the maximum log-likelihood at degree <code>m</code>
</p>
</li>
<li> <p><code>interval</code> support/truncation interval <code>(a,b)</code>
</p>
</li>
<li> <p><code>baseline</code> =&quot;control&quot; if <code class="reqn">f_0</code> is used as baseline, 
or =&quot;case&quot; if <code class="reqn">f_1</code> is used as baseline.
</p>
</li>
<li> <p><code>M</code> the vector <code>(m0, m1)</code>, where <code>m1</code>, if greater than <code>m0</code>, is the
largest candidate when the search stoped
</p>
</li>
<li> <p><code>lk</code> log-likelihoods evaluated at <code class="reqn">m \in \{m_0, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>lr</code> likelihood ratios for change-points evaluated at <code class="reqn">m \in \{m_0+1, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>pval</code> the p-values of the change-point tests for choosing optimal model degree
</p>
</li>
<li> <p><code>chpts</code> the change-points chosen with the given candidate model degrees
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Guan, Z., Maximum Approximate Bernstein Likelihood Estimation of 
Densities in a Two-sample Semiparametric Model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Hosmer and Lemeshow (1989): 
# ages and the status of coronary disease (CHD) of 100 subjects 
x&lt;-c(20, 23, 24, 25, 26, 26, 28, 28, 29, 30, 30, 30, 30, 30, 32,
32, 33, 33, 34, 34, 34, 34, 35, 35, 36, 36, 37, 37, 38, 38, 39,
40, 41, 41, 42, 42, 42, 43, 43, 44, 44, 45, 46, 47, 47, 48, 49,
49, 50, 51, 52, 55, 57, 57, 58, 60, 64)
y&lt;-c(25, 30, 34, 36, 37, 39, 40, 42, 43, 44, 44, 45, 46, 47, 48,
48, 49, 50, 52, 53, 53, 54, 55, 55, 56, 56, 56, 57, 57, 57, 57,
58, 58, 59, 59, 60, 61, 62, 62, 63, 64, 65, 69)
regr&lt;-function(x) cbind(1,x)
chd.mable&lt;-mable.dr(x, y, M=c(1, 15), regr, interval = c(20, 70))
chd.mable

</code></pre>

<hr>
<h2 id='mable.dr.group'>Mable fit of the density ratio model based on grouped data</h2><span id='topic+mable.dr.group'></span>

<h3>Description</h3>

<p>Maximum approximate Bernstein/Beta likelihood estimation in a
density ratio model based on two-sample grouped data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable.dr.group(
  t,
  n0,
  n1,
  M,
  regr,
  ...,
  interval = c(0, 1),
  alpha = NULL,
  vb = 0,
  controls = mable.ctrl(),
  progress = TRUE,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable.dr.group_+3A_t">t</code></td>
<td>
<p>cutpoints of class intervals</p>
</td></tr>
<tr><td><code id="mable.dr.group_+3A_n0">n0</code>, <code id="mable.dr.group_+3A_n1">n1</code></td>
<td>
<p>frequencies of two sample data grouped by the classes 
specified by <code>t</code>. coden0:&quot;Control&quot;, <code>n1</code>: &quot;Case&quot;.</p>
</td></tr>
<tr><td><code id="mable.dr.group_+3A_m">M</code></td>
<td>
<p>a positive integer or a vector <code>(m0, m1)</code>.</p>
</td></tr>
<tr><td><code id="mable.dr.group_+3A_regr">regr</code></td>
<td>
<p>regressor vector function <code class="reqn">r(x)=(1,r_1(x),...,r_d(x))</code> 
which returns n x (d+1) matrix, n=length(x)</p>
</td></tr>
<tr><td><code id="mable.dr.group_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to regr</p>
</td></tr>
<tr><td><code id="mable.dr.group_+3A_interval">interval</code></td>
<td>
<p>a vector <code>(a,b)</code> containing the endpoints of 
supporting/truncation interval of x and y.</p>
</td></tr>
<tr><td><code id="mable.dr.group_+3A_alpha">alpha</code></td>
<td>
<p>a given regression coefficient, missing value is imputed by 
logistic regression</p>
</td></tr>
<tr><td><code id="mable.dr.group_+3A_vb">vb</code></td>
<td>
<p>code for vanishing boundary constraints, -1: f0(a)=0 only, 
1: f0(b)=0 only, 2: both, 0: none (default).</p>
</td></tr>
<tr><td><code id="mable.dr.group_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit
and the convergence criterion for EM and Newton iterations. Default is 
<code><a href="#topic+mable.ctrl">mable.ctrl</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="mable.dr.group_+3A_progress">progress</code></td>
<td>
<p>logical: should a text progressbar be displayed</p>
</td></tr>
<tr><td><code id="mable.dr.group_+3A_message">message</code></td>
<td>
<p>logical: should warning messages be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that <code>n0</code> (&quot;control&quot;) and <code>n1</code> (&quot;case&quot;) are frequencies of  
independent samples grouped by the classes <code>t</code> from f0 and f1 which   
satisfy f1(x)=f0(x)exp[alpha0+alpha'r(x)] with r(x)=(r1(x),...,r_d(x)). Maximum 
approximate Bernstein/Beta likelihood estimates of (alpha0,alpha), f0 and f1 
are calculated. If support is (a,b) then replace r(x) by r[a+(b-a)x].
For a fixed <code>m</code>, using the Bernstein polynomial model for baseline <code class="reqn">f_0</code>,
MABLEs of <code class="reqn">f_0</code> and parameters alpha can be estimated by EM algorithm and Newton  
iteration. If estimated lower bound <code class="reqn">m_b</code> for <code>m</code> based on <code>n1</code>
is smaller that that based on <code>n0</code>, then switch <code>n0</code> and <code>n1</code> and
use <code class="reqn">f_1</code> as baseline. If <code>M=m</code> or <code>m0=m1=m</code>, then <code>m</code> is a 
preselected degree. If <code>m0&lt;m1</code> it specifies the set of consective  
candidate model degrees <code>m0:m1</code> for searching an optimal degree by 
the change-point method, where <code>m1-m0&gt;3</code>.
</p>

<hr>
<h2 id='mable.group'>Mable fit of one-sample grouped data by an optimal or a preselected model degree</h2><span id='topic+mable.group'></span>

<h3>Description</h3>

<p>Maximum approximate Bernstein/Beta likelihood estimation based on
one-sample grouped data with an optimal selected by the change-point method among <code>m0:m1</code>
or a preselected model degree <code>m</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable.group(
  x,
  breaks,
  M,
  interval = c(0, 1),
  IC = c("none", "aic", "hqic", "all"),
  vb = 0,
  controls = mable.ctrl(),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable.group_+3A_x">x</code></td>
<td>
<p>vector of frequencies</p>
</td></tr>
<tr><td><code id="mable.group_+3A_breaks">breaks</code></td>
<td>
<p>class interval end points</p>
</td></tr>
<tr><td><code id="mable.group_+3A_m">M</code></td>
<td>
<p>a positive integer or a vector <code>(m0, m1)</code>. If <code>M = m</code> or <code>m0 = m1 = m</code>,
then <code>m</code> is a preselected degree. If <code>m0&lt;m1</code> it specifies the set of
consective candidate model degrees <code>m0:m1</code> for searching an optimal degree,
where <code>m1-m0&gt;3</code>.</p>
</td></tr>
<tr><td><code id="mable.group_+3A_interval">interval</code></td>
<td>
<p>a vector containing the endpoints of support/truncation interval</p>
</td></tr>
<tr><td><code id="mable.group_+3A_ic">IC</code></td>
<td>
<p>information criterion(s) in addition to Bayesian information criterion (BIC). Current choices are
&quot;aic&quot; (Akaike information criterion) and/or
&quot;qhic&quot; (Hannan–Quinn information criterion).</p>
</td></tr>
<tr><td><code id="mable.group_+3A_vb">vb</code></td>
<td>
<p>code for vanishing boundary constraints, -1: f0(a)=0 only, 
1: f0(b)=0 only, 2: both, 0: none (default).</p>
</td></tr>
<tr><td><code id="mable.group_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit
and the convergence criterion <code>eps</code>. Default is <code><a href="#topic+mable.ctrl">mable.ctrl</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="mable.group_+3A_progress">progress</code></td>
<td>
<p>if TRUE a text progressbar is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any continuous density function <code class="reqn">f</code> on a known closed supporting interval <code class="reqn">[a, b]</code> can be
estimated by Bernstein polynomial <code class="reqn">f_m(x; p) = \sum_{i=0}^m p_i\beta_{mi}[(x-a)/(b-a)]/(b-a)</code>,
where <code class="reqn">p = (p_0, \ldots, p_m)</code>, <code class="reqn">p_i\ge 0</code>, <code class="reqn">\sum_{i=0}^m p_i=1</code> and
<code class="reqn">\beta_{mi}(u) = (m+1){m\choose i}u^i(1-x)^{m-i}</code>, <code class="reqn">i = 0, 1, \ldots, m</code>,
is the beta density with shapes <code class="reqn">(i+1, m-i+1)</code>.
For each <code>m</code>, the MABLE of the coefficients <code>p</code>, the mixture proportions, are
obtained using EM algorithm. The EM iteration for each candidate <code>m</code> stops if either
the total absolute change of the log likelihood and the coefficients of Bernstein polynomial
is smaller than <code>eps</code> or the maximum number of iterations <code>maxit</code> is reached.
</p>
<p>If <code>m0&lt;m1</code>, an optimal model degree is selected as the change-point of the increments of
log-likelihood, log likelihood ratios, for <code class="reqn">m \in \{m_0, m_0+1, \ldots, m_1\}</code>. Alternatively,
one can choose an optimal degree based on the BIC (Schwarz, 1978) which are evaluated at
<code class="reqn">m \in \{m_0, m_0+1, \ldots, m_1\}</code>. The search for optimal degree <code>m</code> is stoped if either
<code>m1</code> is reached with a warning or the test for change-point results in a p-value <code>pval</code>
smaller than <code>sig.level</code>.  The BIC for a given degree <code>m</code> is calculated as in
Schwarz (1978) where the dimension of the model is <code class="reqn">d=\#\{i: \hat p_i \ge \epsilon,
 i = 0, \ldots, m\} - 1</code> and a default <code class="reqn">\epsilon</code> is chosen as <code>.Machine$double.eps</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>m</code> the given or a selected degree by method of change-point
</p>
</li>
<li> <p><code>p</code> the estimated <code>p</code> with degree <code>m</code>
</p>
</li>
<li> <p><code>mloglik</code>  the maximum log-likelihood at degree <code>m</code>
</p>
</li>
<li> <p><code>interval</code> supporting interval <code>(a, b)</code>
</p>
</li>
<li> <p><code>convergence</code> An integer code. 0 indicates successful completion
(all the EM iterations are convergent and an optimal degree
is successfully selected in <code>M</code>). Possible error codes are
</p>

<ul>
<li><p> 1, indicates that the iteration limit <code>maxit</code> had been
reached in at least one EM iteration;
</p>
</li>
<li><p> 2, the search did not finish before <code>m1</code>.
</p>
</li></ul>

</li>
<li> <p><code>delta</code> the convergence criterion <code>delta</code> value
</p>
</li></ul>

<p>and, if <code>m0&lt;m1</code>,
</p>

<ul>
<li> <p><code>M</code> the vector <code>(m0, m1)</code>, where <code>m1</code>, if greater than <code>m0</code>, is the
largest candidate when the search stoped
</p>
</li>
<li> <p><code>lk</code> log-likelihoods evaluated at <code class="reqn">m \in \{m_0, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>lr</code> likelihood ratios for change-points evaluated at <code class="reqn">m \in \{m_0+1, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>ic</code> a list containing the selected information criterion(s)
</p>
</li>
<li> <p><code>pval</code> the p-values of the change-point tests for choosing optimal model degree
</p>
</li>
<li> <p><code>chpts</code> the change-points chosen with the given candidate model degrees
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Guan, Z. (2017) Bernstein polynomial model for grouped continuous data.
<em>Journal of Nonparametric Statistics</em>, 29(4):831-848.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mable.ic">mable.ic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Chicken Embryo Data
 data(chicken.embryo)
 a&lt;-0; b&lt;-21
 day&lt;-chicken.embryo$day
 nT&lt;-chicken.embryo$nT
 Day&lt;-rep(day,nT)
 res&lt;-mable.group(x=nT, breaks=a:b, M=c(2,100), interval=c(a, b), IC="aic",
    controls=mable.ctrl(sig.level=1e-6,  maxit=2000, eps=1.0e-7))
 op&lt;-par(mfrow=c(1,2), lwd=2)
 layout(rbind(c(1, 2), c(3, 3)))
 plot(res, which="likelihood")
 plot(res, which="change-point")
 fk&lt;-density(x=rep((0:20)+.5, nT), bw="sj", n=101, from=a, to=b)
 hist(Day, breaks=seq(a,b,  length=12), freq=FALSE, col="grey",
          border="white", main="Histogram and Density Estimates")
 plot(res, which="density",types=1:2, colors=1:2)
 lines(fk, lty=2, col=2)
 legend("topright", lty=c(1:2), c("MABLE", "Kernel"), bty="n", col=c(1:2))
 par(op)

</code></pre>

<hr>
<h2 id='mable.ic'>Mable fit based on one-sample interval censored data</h2><span id='topic+mable.ic'></span>

<h3>Description</h3>

<p>Maximum approximate Bernstein/Beta likelihood estimation of density and 
cumulative/survival distributions functions  based on interal censored event time data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable.ic(
  data,
  M,
  pi0 = NULL,
  tau = Inf,
  IC = c("none", "aic", "hqic", "all"),
  controls = mable.ctrl(),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable.ic_+3A_data">data</code></td>
<td>
<p>a dataset either <code>data.frame</code> or an <code>n x 2</code> matrix.</p>
</td></tr>
<tr><td><code id="mable.ic_+3A_m">M</code></td>
<td>
<p>an positive integer or a vector <code>(m0, m1)</code>. If <code>M = m</code> or <code>m0 = m1 = m</code>,
then <code>m</code> is a preselected degree. If <code>m0 &lt; m1</code> it specifies the set of 
consective candidate model degrees <code>m0:m1</code> for searching an optimal degree,
where <code>m1-m0&gt;3</code>.</p>
</td></tr>
<tr><td><code id="mable.ic_+3A_pi0">pi0</code></td>
<td>
<p>Initial guess of <code class="reqn">\pi = F(\tau_n)</code>. Without right censored data, <code>pi0 = 1</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="mable.ic_+3A_tau">tau</code></td>
<td>
<p>right endpoint of support <code class="reqn">[0, \tau)</code> must be greater than or equal to the maximum observed time</p>
</td></tr>
<tr><td><code id="mable.ic_+3A_ic">IC</code></td>
<td>
<p>information criterion(s) in addition to Bayesian information criterion (BIC). Current choices are
&quot;aic&quot; (Akaike information criterion) and/or 
&quot;qhic&quot; (Hannan–Quinn information criterion).</p>
</td></tr>
<tr><td><code id="mable.ic_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit 
and other control options. Default is <code><a href="#topic+mable.ctrl">mable.ctrl</a></code>.</p>
</td></tr>
<tr><td><code id="mable.ic_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> a text progressbar is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">f(t)</code> and <code class="reqn">F(t) = 1 - S(t)</code> be the density and cumulative distribution
functions of the event time, respectively. Then <code class="reqn">f(t)</code> on <code class="reqn">[0, \tau_n]</code> can be
approximated by <code class="reqn">f_m(t; p) = \tau_n^{-1}\sum_{i=0}^m p_i\beta_{mi}(t/\tau_n)</code>,
where <code class="reqn">p_i \ge 0</code>, <code class="reqn">i = 0, \ldots, m</code>, <code class="reqn">\sum_{i=0}^mp_i = 1-p_{m+1}</code>,
<code class="reqn">\beta_{mi}(u)</code> is the beta denity with shapes <code class="reqn">i+1</code> and <code class="reqn">m-i+1</code>, and
<code class="reqn">\tau_n</code> is the largest observed time, either uncensored time, or right endpoint of 
interval/left censored, or left endpoint of right censored time. We can approximate  
<code class="reqn">S(t)</code> on <code class="reqn">[0, \tau]</code> by <code class="reqn">S_m(t; p) = \sum_{i=0}^{m+1} p_i \bar B_{mi}(t/\tau)</code>,  
where  <code class="reqn">\bar B_{mi}(u)</code>, <code class="reqn">i = 0, \ldots, m</code>, is the beta survival function with shapes 
<code class="reqn">i+1</code> and <code class="reqn">m-i+1</code>, <code class="reqn">\bar B_{m,m+1}(t) = 1</code>, <code class="reqn">p_{m+1} = 1 - \pi</code>, and
<code class="reqn">\pi = F(\tau_n)</code>. For data without right-censored time, <code class="reqn">p_{m+1} = 1-\pi=0</code>.  
The search for optimal degree <code>m</code> is stoped if either <code>m1</code> is reached or the test 
for change-point results in a p-value <code>pval</code> smaller than <code>sig.level</code>. 
</p>
<p>Each row of <code>data</code>, <code>(l, u)</code>, is the interval containing the event time. 
Data is uncensored if <code>l = u</code>, right censored if <code>u = Inf</code> or <code>u = NA</code>,  
and left censored data if <code>l = 0</code>.
</p>


<h3>Value</h3>

<p>a class '<code>mable</code>' object with components
</p>
 
<ul>
<li> <p><code>p</code> the estimated <code>p</code> with degree <code>m</code>
selected by the change-point method 
</p>
</li>
<li> <p><code>mloglik</code> the maximum log-likelihood at an optimal degree <code>m</code>
</p>
</li>
<li> <p><code>interval</code> support/truncation interval <code>(0, b)</code>
</p>
</li>
<li> <p><code>M</code> the vector <code>(m0,m1)</code>, where <code>m1</code> is the last candidate when the search stoped
</p>
</li>
<li> <p><code>m</code> the selected optimal degree by the method  of change-point 
</p>
</li>
<li> <p><code>lk</code> log-likelihoods evaluated at <code class="reqn">m  \in  \{m_0, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>lr</code> likelihood ratios for change-points evaluated at <code class="reqn">m \in \{m_0+1, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>tau.n</code> maximum observed time <code class="reqn">\tau_n</code>
</p>
</li>
<li> <p><code>tau</code> right endpoint of support <code class="reqn">[0, \tau)</code>
</p>
</li>
<li> <p><code>ic</code> a list containing the selected information criterion(s)
</p>
</li>
<li> <p><code>pval</code> the p-values of the change-point tests for choosing optimal model degree
</p>
</li>
<li> <p><code>chpts</code> the change-points chosen with the given candidate model degrees
</p>
</li>
<li> <p><code>convergence</code> an integer code. 0 indicates successful completion(the iteration is   
convergent). 1 indicates that the maximum candidate degree had been reached in the calculation;
</p>
</li>
<li> <p><code>delta</code> the final <code>pval</code> of the change-point for selecting the optimal degree <code>m</code>;
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Guan, Z. (2019) Maximum Approximate Bernstein Likelihood Estimation in Proportional Hazard Model for Interval-Censored Data, 
arXiv:1906.08882 .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mable.group">mable.group</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mable) 
 bcos=cosmesis
 bc.res0&lt;-mable.ic(bcos[bcos$treat=="RT",1:2], M=c(1,50), IC="none")
 bc.res1&lt;-mable.ic(bcos[bcos$treat=="RCT",1:2], M=c(1,50), IC="none")
 op&lt;-par(mfrow=c(2,2),lwd=2)
 plot(bc.res0, which="change-point", lgd.x="right")
 plot(bc.res1, which="change-point", lgd.x="right")
 plot(bc.res0, which="survival", add=FALSE, xlab="Months", ylim=c(0,1), main="Radiation Only")
 legend("topright", bty="n", lty=1:2, col=1:2, c(expression(hat(S)[CP]),
               expression(hat(S)[BIC])))
 plot(bc.res1, which="survival", add=FALSE, xlab="Months", main="Radiation and Chemotherapy")
 legend("topright", bty="n", lty=1:2, col=1:2, c(expression(hat(S)[CP]),
               expression(hat(S)[BIC])))
 par(op)

</code></pre>

<hr>
<h2 id='mable.mvar'>Maximum Approximate Bernstein Likelihood Estimate
of Multivariate Density Function</h2><span id='topic+mable.mvar'></span>

<h3>Description</h3>

<p>Maximum Approximate Bernstein Likelihood Estimate
of Multivariate Density Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable.mvar(
  x,
  M0 = 1,
  M,
  search = TRUE,
  interval = NULL,
  mar.deg = TRUE,
  high.dim = FALSE,
  criterion = c("cdf", "pdf"),
  controls = mable.ctrl(),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable.mvar_+3A_x">x</code></td>
<td>
<p>an <code>n x d</code> matrix or <code>data.frame</code> of multivariate sample of size <code>n</code></p>
</td></tr>
<tr><td><code id="mable.mvar_+3A_m0">M0</code></td>
<td>
<p>a positive integer or a vector of <code>d</code> positive integers specify
starting candidate degrees for searching optimal degrees.</p>
</td></tr>
<tr><td><code id="mable.mvar_+3A_m">M</code></td>
<td>
<p>a positive integer or a vector of <code>d</code> positive integers specify
the maximum candidate or the given model degrees for the joint density.</p>
</td></tr>
<tr><td><code id="mable.mvar_+3A_search">search</code></td>
<td>
<p>logical, whether to search optimal degrees between <code>M0</code> and <code>M</code> 
or not but use <code>M</code> as the given model degrees for the joint density.</p>
</td></tr>
<tr><td><code id="mable.mvar_+3A_interval">interval</code></td>
<td>
<p>a vector of two endpoints or a <code>2 x d</code> matrix, each column containing 
the endpoints of support/truncation interval for each marginal density.
If missing, the i-th column is assigned as <code>c(min(x[,i]), max(x[,i]))</code>.</p>
</td></tr>
<tr><td><code id="mable.mvar_+3A_mar.deg">mar.deg</code></td>
<td>
<p>logical, if TRUE, the optimal degrees are selected based
on marginal data, otherwise, the optimal degrees are those minimize the maximum
L2 distance between marginal cdf or pdf estimated based on marginal data and the
joint data. See details.</p>
</td></tr>
<tr><td><code id="mable.mvar_+3A_high.dim">high.dim</code></td>
<td>
<p>logical, data are high dimensional/large sample or not
if TRUE, run a slower version procedure which requires less memory</p>
</td></tr>
<tr><td><code id="mable.mvar_+3A_criterion">criterion</code></td>
<td>
<p>either cdf or pdf should be used for selecting optimal degrees.
Default is &quot;cdf&quot;</p>
</td></tr>
<tr><td><code id="mable.mvar_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit
and the convergence criterion <code>eps</code>. Default is <code><a href="#topic+mable.ctrl">mable.ctrl</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="mable.mvar_+3A_progress">progress</code></td>
<td>
<p>if TRUE a text progressbar is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code class="reqn">d</code>-variate density <code class="reqn">f</code> on a hyperrectangle <code class="reqn">[a, b]
  =[a_1, b_1] \times \cdots \times [a_d, b_d]</code> can be approximated 
by a mixture of <code class="reqn">d</code>-variate beta densities on <code class="reqn">[a, b]</code>, 
<code class="reqn">\beta_{mj}(x) = \prod_{i=1}^d\beta_{m_i,j_i}[(x_i-a_i)/(b_i-a_i)]/(b_i-a_i)</code>,
with proportion <code class="reqn">p(j_1, \ldots, j_d)</code>, <code class="reqn">0 \le j_i \le m_i, i = 1, \ldots, d</code>. 
Let <code class="reqn">\tilde F_i</code> (<code class="reqn">\tilde f_i</code>) be an estimate with degree <code class="reqn">\tilde m_i</code> of  
the i-th marginal cdf (pdf) based on marginal data <code>x[,i]</code>, <code class="reqn">i=1, \ldots, d</code>. 
If <code>search=TRUE</code> and <code>use.marginal=TRUE</code>, then the optimal degrees
are <code class="reqn">(\tilde m_1,\ldots,\tilde m_d)</code>. If <code>search=TRUE</code> and 
<code>use.marginal=FALSE</code>, then the optimal degrees <code class="reqn">(\hat m_1,\ldots,\hat m_d)</code>
are those that minimize the maximum of <code class="reqn">L_2</code>-distance between 
<code class="reqn">\tilde F_i</code> (<code class="reqn">\tilde f_i</code>) and the estimate of <code class="reqn">F_i</code> (<code class="reqn">f_i</code>) 
based on the joint data with degrees <code class="reqn">m=(m_1,\ldots,m_d)</code> for all <code class="reqn">m</code>
between <code class="reqn">M_0</code> and <code class="reqn">M</code> if <code>criterion</code>=&quot;cdf&quot; (<code>criterion</code>=&quot;pdf&quot;). 
</p>
<p>For large data and multimodal density, the search for the model degrees is 
very time-consuming. In this case, it is suggested that the degrees are selected  
based on marginal data using <code><a href="#topic+mable">mable</a></code> or <code><a href="#topic+optimable">optimable</a></code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>m</code> a vector of the selected optimal degrees by the method of change-point
</p>
</li>
<li> <p><code>p</code> a vector of the mixture proportions <code class="reqn">p(j_1, \ldots, j_d)</code>, arranged in the 
column-major order of <code class="reqn">j = (j_1, \ldots, j_d)</code>, <code class="reqn">0 \le j_i \le m_i, i = 1, \ldots, d</code>.
</p>
</li>
<li> <p><code>mloglik</code>  the maximum log-likelihood at an optimal degree <code>m</code>
</p>
</li>
<li> <p><code>pval</code>  the p-values of change-points for choosing the optimal degrees for the 
marginal densities
</p>
</li>
<li> <p><code>M</code> the vector <code>(m1, m2, ... , md)</code>, where <code>mi</code> is the largest candidate 
degree when the search stoped for the <code>i</code>-th marginal density
</p>
</li>
<li> <p><code>interval</code> support hyperrectangle <code class="reqn">[a, b]=[a_1, b_1] \times \cdots \times [a_d, b_d]</code>
</p>
</li>
<li> <p><code>convergence</code> An integer code. 0 indicates successful completion(the EM iteration is   
convergent). 1 indicates that the iteration limit <code>maxit</code> had been reached in the EM iteration;
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Wang, T. and Guan, Z.,(2019) Bernstein Polynomial Model for Nonparametric Multivariate Density,    
<em>Statistics</em>, Vol. 53, no. 2, 321-338
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mable">mable</a></code>, <code><a href="#topic+optimable">optimable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Old Faithful Data

 a&lt;-c(0, 40); b&lt;-c(7, 110)
 ans&lt;- mable.mvar(faithful, M = c(46,19), search =FALSE, 
         interval = rbind(a,b), progress=FALSE)
 plot(ans, which="density") 
 plot(ans, which="cumulative")

</code></pre>

<hr>
<h2 id='mable.ph'>Mable fit of Cox's proportional hazards regression model</h2><span id='topic+mable.ph'></span>

<h3>Description</h3>

<p>Maximum approximate Bernstein/Beta likelihood estimation in Cox's proportional hazards regression model 
based on interal censored event time data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable.ph(
  formula,
  data,
  M,
  g = NULL,
  p = NULL,
  pi0 = NULL,
  tau = Inf,
  x0 = NULL,
  controls = mable.ctrl(),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable.ph_+3A_formula">formula</code></td>
<td>
<p>regression formula. Response must be <code>cbind</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="mable.ph_+3A_data">data</code></td>
<td>
<p>a dataset</p>
</td></tr>
<tr><td><code id="mable.ph_+3A_m">M</code></td>
<td>
<p>a positive integer or a vector <code>(m0, m1)</code>. If <code>M = m</code> or <code>m0 = m1</code>,
then <code>m0</code> is a preselected degree. If <code>m0&lt;m1</code> it specifies the set of 
consective candidate model degrees <code>m0:m1</code> for searching an optimal degree,
where <code>m1-m0&gt;3</code>.</p>
</td></tr>
<tr><td><code id="mable.ph_+3A_g">g</code></td>
<td>
<p>initial guess of <code class="reqn">d</code>-vector of regression coefficients.  See 'Details'.</p>
</td></tr>
<tr><td><code id="mable.ph_+3A_p">p</code></td>
<td>
<p>an initial coefficients of Bernstein polynomial model of degree <code>m0</code>, 
default is the uniform initial.</p>
</td></tr>
<tr><td><code id="mable.ph_+3A_pi0">pi0</code></td>
<td>
<p>Initial guess of <code class="reqn">\pi(x_0) = F(\tau_n|x_0)</code>. Without right censored data, <code>pi0 = 1</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="mable.ph_+3A_tau">tau</code></td>
<td>
<p>right endpoint of support <code class="reqn">[0, \tau)</code> must be greater than or equal to the maximum observed time</p>
</td></tr>
<tr><td><code id="mable.ph_+3A_x0">x0</code></td>
<td>
<p>a working baseline covariate. See 'Details'.</p>
</td></tr>
<tr><td><code id="mable.ph_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit 
and other control options. Default is <code><a href="#topic+mable.ctrl">mable.ctrl</a></code>.</p>
</td></tr>
<tr><td><code id="mable.ph_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> a text progressbar is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider Cox's PH model with covariate for interval-censored failure time data: 
<code class="reqn">S(t|x) = S(t|x_0)^{\exp(\gamma^T(x-x_0))}</code>, where <code class="reqn">x_0</code> satisfies <code class="reqn">\gamma^T(x-x_0)\ge 0</code>.   
Let <code class="reqn">f(t|x)</code> and <code class="reqn">F(t|x) = 1-S(t|x)</code> be the density and cumulative distribution
functions of the event time given <code class="reqn">X = x</code>, respectively.
Then <code class="reqn">f(t|x_0)</code> on <code class="reqn">[0, \tau_n]</code> can be approximated by  
<code class="reqn">f_m(t|x_0, p) = \tau_n^{-1}\sum_{i=0}^m p_i\beta_{mi}(t/\tau_n)</code>,
where <code class="reqn">p_i \ge 0</code>, <code class="reqn">i = 0, \ldots, m</code>, <code class="reqn">\sum_{i=0}^mp_i = 1-p_{m+1}</code>,  
<code class="reqn">\beta_{mi}(u)</code> is the beta denity with shapes <code class="reqn">i+1</code> and <code class="reqn">m-i+1</code>, and 
<code class="reqn">\tau_n</code> is the largest observed time, either uncensored time, or right endpoint of interval/left censored,
or left endpoint of right censored time. So we can approximate  <code class="reqn">S(t|x_0)</code> on <code class="reqn">[0, \tau_n]</code> by
<code class="reqn">S_m(t|x_0; p) = \sum_{i=0}^{m+1} p_i \bar B_{mi}(t/\tau_n)</code>, where 
<code class="reqn">\bar B_{mi}(u)</code>, <code class="reqn">i = 0, \ldots, m</code>, is the beta survival function with shapes 
<code class="reqn">i+1</code> and <code class="reqn">m-i+1</code>, <code class="reqn">\bar B_{m,m+1}(t) = 1</code>, <code class="reqn">p_{m+1} = 1-\pi(x_0)</code>, and
<code class="reqn">\pi(x_0) = F(\tau_n|x_0)</code>. For data without right-censored time, <code class="reqn">p_{m+1} = 1-\pi(x_0) = 0</code>.
</p>
<p>Response variable should be of the form <code>cbind(l, u)</code>, where <code>(l, u)</code> is the interval 
containing the event time. Data is uncensored if <code>l = u</code>, right censored 
if <code>u = Inf</code> or <code>u = NA</code>, and  left censored data if <code>l = 0</code>.
The associated covariate contains <code class="reqn">d</code> columns. The baseline <code>x0</code> should chosen so that 
<code class="reqn">\gamma'(x-x_0)</code> is nonnegative for all the observed <code class="reqn">x</code> and 
all <code class="reqn">\gamma</code> in a neighborhood of its true value.
</p>
<p>A missing initial value of <code>g</code> is imputed by <code>ic_sp()</code> of package <code>icenReg</code>. 
</p>
<p>The search for optimal degree <code>m</code> stops if either <code>m1</code> is reached or the test 
for change-point results in a p-value <code>pval</code> smaller than <code>sig.level</code>.
This process takes longer than <code><a href="#topic+maple.ph">maple.ph</a></code> to select an optimal degree.
</p>


<h3>Value</h3>

<p>A list with components
</p>
 
<ul>
<li> <p><code>m</code> the selected/preselected optimal degree <code>m</code>
</p>
</li>
<li> <p><code>p</code> the estimate of <code class="reqn">p = (p_0, \dots, p_m, p_{m+1})</code>, the coefficients of Bernstein polynomial of degree <code>m</code>
</p>
</li>
<li> <p><code>coefficients</code> the estimated regression coefficients of the PH model
</p>
</li>
<li> <p><code>SE</code> the standard errors of the estimated regression coefficients 
</p>
</li>
<li> <p><code>z</code> the z-scores of the estimated regression coefficients 
</p>
</li>
<li> <p><code>mloglik</code> the maximum log-likelihood at an optimal degree <code>m</code>
</p>
</li>
<li> <p><code>tau.n</code> maximum observed time <code class="reqn">\tau_n</code>
</p>
</li>
<li> <p><code>tau</code> right endpoint of support <code class="reqn">[0, \tau)</code>
</p>
</li>
<li> <p><code>x0</code> the working baseline covariates 
</p>
</li>
<li> <p><code>egx0</code> the value of <code class="reqn">e^{\gamma'x_0}</code> 
</p>
</li>
<li> <p><code>convergence</code> an integer code, 1 indicates either the EM-like 
iteration for finding maximum likelihood reached the maximum iteration for at least one <code>m</code> 
or the search of an optimal degree using change-point method reached the maximum candidate degree,
2 indicates both occured, and 0 indicates a successful completion.  
</p>
</li>
<li> <p><code>delta</code> the final <code>delta</code> if <code>m0 = m1</code> or the final <code>pval</code> of the change-point 
for searching the optimal degree <code>m</code>;
</p>
</li></ul>

<p>and, if <code>m0&lt;m1</code>,
</p>

<ul>
<li> <p><code>M</code> the vector <code>(m0, m1)</code>, where <code>m1</code> is the last candidate degree when the search stoped
</p>
</li>
<li> <p><code>lk</code> log-likelihoods evaluated at <code class="reqn">m \in \{m_0,\ldots, m_1\}</code>
</p>
</li>
<li> <p><code>lr</code> likelihood ratios for change-points evaluated at <code class="reqn">m \in \{m_0+1, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>pval</code> the p-values of the change-point tests for choosing optimal model degree
</p>
</li>
<li> <p><code>chpts</code> the change-points chosen with the given candidate model degrees
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Guan, Z. Maximum Approximate Bernstein Likelihood Estimation in Proportional Hazard Model for Interval-Censored Data, 
Statistics in Medicine. 2020; 1–21. https://doi.org/10.1002/sim.8801.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maple.ph">maple.ph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   # Ovarian Cancer Survival Data
   require(survival)
   futime2&lt;-ovarian$futime
   futime2[ovarian$fustat==0]&lt;-Inf
   ovarian2&lt;-data.frame(age=ovarian$age, futime1=ovarian$futime, 
        futime2=futime2)
   ova&lt;-mable.ph(cbind(futime1, futime2) ~ age, data = ovarian2, 
        M=c(2,35), g=.16, x0=35)
   op&lt;-par(mfrow=c(2,2))
   plot(ova, which = "likelihood")
   plot(ova, which = "change-point")
   plot(ova, y=data.frame(age=60), which="survival", add=FALSE, type="l", 
         xlab="Days", main="Age = 60")
   plot(ova, y=data.frame(age=65), which="survival", add=FALSE, type="l", 
         xlab="Days", main="Age = 65")
   par(op)

</code></pre>

<hr>
<h2 id='mable.reg'>Mable fit of semiparametric regression model based on interval censored data</h2><span id='topic+mable.reg'></span>

<h3>Description</h3>

<p>Wrapping all codemable fit of regression models in one function.
Using maximum approximate Bernstein/Beta likelihood
estimation to fit semiparametric regression models: Cox ph model,
proportional odds(po) model, accelerated failure time model, and so on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mable.reg(
  formula,
  data,
  model = c("ph", "aft"),
  M,
  g = NULL,
  pi0 = NULL,
  tau = Inf,
  x0 = NULL,
  eta = 1,
  controls = mable.ctrl(),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mable.reg_+3A_formula">formula</code></td>
<td>
<p>regression formula. Response must be of the form <code>cbind(l, u)</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="mable.reg_+3A_data">data</code></td>
<td>
<p>a dataset</p>
</td></tr>
<tr><td><code id="mable.reg_+3A_model">model</code></td>
<td>
<p>the model to fit. Current options are &quot;<code>ph</code>&quot;
(Cox PH) or &quot;<code>aft</code>&quot; (accelerated failure time model)</p>
</td></tr>
<tr><td><code id="mable.reg_+3A_m">M</code></td>
<td>
<p>a vector <code>(m0, m1)</code> specifies the set of consective integers as candidate degrees</p>
</td></tr>
<tr><td><code id="mable.reg_+3A_g">g</code></td>
<td>
<p>an initial guess of the regression coefficients</p>
</td></tr>
<tr><td><code id="mable.reg_+3A_pi0">pi0</code></td>
<td>
<p>Initial guess of <code class="reqn">\pi(x_0) = F(\tau_n|x_0)</code>. Without right censored data, <code>pi0 = 1</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="mable.reg_+3A_tau">tau</code></td>
<td>
<p>right endpoint of support <code class="reqn">[0, \tau)</code> must be greater than or equal to the maximum observed time</p>
</td></tr>
<tr><td><code id="mable.reg_+3A_x0">x0</code></td>
<td>
<p>a working baseline covariate. See 'Details'.</p>
</td></tr>
<tr><td><code id="mable.reg_+3A_eta">eta</code></td>
<td>
<p>the given positive value of <code class="reqn">\eta</code>. Used when <code>model="po"</code>.</p>
</td></tr>
<tr><td><code id="mable.reg_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit 
and other control options. Default is <code><a href="#topic+mable.ctrl">mable.ctrl</a></code>.</p>
</td></tr>
<tr><td><code id="mable.reg_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> a text progressbar is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For &quot;<code>ph</code>&quot;  model a missing initial guess of the regression coefficients 
<code>g</code> is obtained by <code>ic_sp()</code> of package <code>icenReg</code>. For &quot;<code>aft</code>&quot; model a
missing <code>g</code> is imputed by the rank estimate <code>aftsrr()</code> of package <code>aftgee</code> 
for right-censored data. For general interval censored observations, we keep the 
right-censored but replace the finite interval with its midpoint and fit the data by 
<code>aftsrr()</code> as a right-censored data.
</p>


<h3>Value</h3>

<p>A 'mable_reg' class object
</p>


<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mable.aft">mable.aft</a></code>, <code><a href="#topic+mable.ph">mable.ph</a></code>
</p>

<hr>
<h2 id='maple.aft'>Mable fit of AFT model with given regression coefficients</h2><span id='topic+maple.aft'></span>

<h3>Description</h3>

<p>Maximum approximate profile likelihood estimation of Bernstein
polynomial model in accelerated failure time based on interal 
censored event time data with given regression coefficients which are efficient
estimates provided by other semiparametric methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maple.aft(
  formula,
  data,
  M,
  g,
  tau = NULL,
  p = NULL,
  x0 = NULL,
  controls = mable.ctrl(),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maple.aft_+3A_formula">formula</code></td>
<td>
<p>regression formula. Response must be <code>cbind</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="maple.aft_+3A_data">data</code></td>
<td>
<p>a dataset</p>
</td></tr>
<tr><td><code id="maple.aft_+3A_m">M</code></td>
<td>
<p>a positive integer or a vector <code>(m0, m1)</code>. If <code>M = m0</code> or <code>m0 = m1</code>,
then <code>m0</code> is a preselected degree. If <code>m0 &lt; m1</code> it specifies the set of 
consective candidate model degrees <code>m0:m1</code> for searching an optimal degree,
where <code>m1-m0 &gt; 3</code>.</p>
</td></tr>
<tr><td><code id="maple.aft_+3A_g">g</code></td>
<td>
<p>the given <code class="reqn">d</code>-vector of regression coefficients.</p>
</td></tr>
<tr><td><code id="maple.aft_+3A_tau">tau</code></td>
<td>
<p>the right endpoint of the support or truncation interval <code class="reqn">[0,\tau)</code> of the
baseline density. Default is <code>NULL</code> (unknown), otherwise if <code>tau</code> is given 
then it is taken as a known value of <code class="reqn">\tau</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="maple.aft_+3A_p">p</code></td>
<td>
<p>an initial coefficients of Bernstein polynomial of degree <code>m0</code>, 
default is the uniform initial.</p>
</td></tr>
<tr><td><code id="maple.aft_+3A_x0">x0</code></td>
<td>
<p>a working baseline covariate <code class="reqn">x_0</code>, default is zero vector. See 'Details'.</p>
</td></tr>
<tr><td><code id="maple.aft_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit 
and other control options. Default is <code><a href="#topic+mable.ctrl">mable.ctrl</a></code>.</p>
</td></tr>
<tr><td><code id="maple.aft_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> a text progressbar is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the accelerated failure time model with covariate for interval-censored failure time data: 
<code class="reqn">S(t|x) = S(t \exp(\gamma^T(x-x_0))|x_0)</code>, where <code class="reqn">x_0</code> is a baseline covariate.   
Let <code class="reqn">f(t|x)</code> and <code class="reqn">F(t|x) = 1-S(t|x)</code> be the density and cumulative distribution
functions of the event time given <code class="reqn">X = x</code>, respectively.
Then <code class="reqn">f(t|x_0)</code> on a support or truncation interval <code class="reqn">[0, \tau]</code> can be approximated by  
<code class="reqn">f_m(t|x_0; p) = \tau^{-1}\sum_{i=0}^m p_i\beta_{mi}(t/\tau)</code>,
where <code class="reqn">p_i \ge 0</code>, <code class="reqn">i = 0, \ldots, m</code>, <code class="reqn">\sum_{i=0}^mp_i=1</code>,  
<code class="reqn">\beta_{mi}(u)</code> is the beta denity with shapes <code class="reqn">i+1</code> and <code class="reqn">m-i+1</code>, and
<code class="reqn">\tau</code> is larger than the largest observed time, either uncensored time, or right endpoint of interval/left censored,
or left endpoint of right censored time. We can approximate  <code class="reqn">S(t|x_0)</code> on <code class="reqn">[0, \tau]</code> by
<code class="reqn">S_m(t|x_0; p) = \sum_{i=0}^{m} p_i \bar B_{mi}(t/\tau)</code>, where <code class="reqn">\bar B_{mi}(u)</code> is
the beta survival function with shapes <code class="reqn">i+1</code> and <code class="reqn">m-i+1</code>.
</p>
<p>Response variable should be of the form <code>cbind(l, u)</code>, where <code>(l,u)</code> is the interval 
containing the event time. Data is uncensored if <code>l = u</code>, right censored 
if <code>u = Inf</code> or <code>u = NA</code>, and  left censored data if <code>l = 0</code>.
The truncation time <code>tau</code> and the baseline <code>x0</code> should be chosen so that 
<code class="reqn">S(t|x) = S(t \exp(\gamma^T(x-x_0))|x_0)</code> on <code class="reqn">[\tau, \infty)</code> is negligible for
all the observed <code class="reqn">x</code>.
</p>
<p>The search for optimal degree <code>m</code> stops if either <code>m1</code> is reached or the test 
for change-point results in a p-value <code>pval</code> smaller than <code>sig.level</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>
 
<ul>
<li> <p><code>m</code> the selected optimal degree <code>m</code>
</p>
</li>
<li> <p><code>p</code> the estimate of <code class="reqn">p=(p_0, \dots, p_m)</code>, the coefficients of Bernstein polynomial of degree <code>m</code>
</p>
</li>
<li> <p><code>coefficients</code> the given regression coefficients of the AFT model
</p>
</li>
<li> <p><code>SE</code> the standard errors of the estimated regression coefficients 
</p>
</li>
<li> <p><code>z</code> the z-scores of the estimated regression coefficients 
</p>
</li>
<li> <p><code>mloglik</code> the maximum log-likelihood at an optimal degree <code>m</code>
</p>
</li>
<li> <p><code>tau.n</code> maximum observed time <code class="reqn">\tau_n</code>
</p>
</li>
<li> <p><code>tau</code> right endpoint of trucation interval <code class="reqn">[0, \tau)</code>
</p>
</li>
<li> <p><code>x0</code> the working baseline covariates 
</p>
</li>
<li> <p><code>egx0</code> the value of <code class="reqn">e^{\gamma^T x_0}</code> 
</p>
</li>
<li> <p><code>convergence</code> an integer code, 1 indicates either the EM-like 
iteration for finding maximum likelihood reached the maximum iteration for at least one <code>m</code> 
or the search of an optimal degree using change-point method reached the maximum candidate degree,
2 indicates both occured, and 0 indicates a successful completion.  
</p>
</li>
<li> <p><code>delta</code> the final <code>delta</code> if <code>m0 = m1</code> or the final <code>pval</code> of the change-point 
for searching the optimal degree <code>m</code>;
</p>
</li></ul>

<p>and, if <code>m0&lt;m1</code>,
</p>

<ul>
<li> <p><code>M</code> the vector <code>(m0, m1)</code>, where <code>m1</code> is the last candidate when the search stoped
</p>
</li>
<li> <p><code>lk</code> log-likelihoods evaluated at <code class="reqn">m \in \{m_0, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>lr</code> likelihood ratios for change-points evaluated at <code class="reqn">m \in \{m_0+1, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>pval</code> the p-values of the change-point tests for choosing optimal model degree
</p>
</li>
<li> <p><code>chpts</code> the change-points chosen with the given candidate model degrees
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Guan, Z. (2019) Maximum Approximate Likelihood Estimation in Accelerated Failure Time Model for Interval-Censored Data, 
arXiv:1911.07087.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mable.aft">mable.aft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Breast Cosmesis Data
  bcos=cosmesis
  bcos2&lt;-data.frame(bcos[,1:2], x=1*(bcos$treat=="RCT"))
  g&lt;-0.41 #Hanson and  Johnson 2004, JCGS, 
  res1&lt;-maple.aft(cbind(left, right)~x, data=bcos2, M=c(1,30),  g=g, tau=100, x0=1)
  op&lt;-par(mfrow=c(1,2), lwd=1.5)
  plot(x=res1, which="likelihood")
  plot(x=res1, y=data.frame(x=0), which="survival", model='aft', type="l", col=1, 
      add=FALSE, main="Survival Function")
  plot(x=res1, y=data.frame(x=1), which="survival", model='aft', lty=2, col=1)
  legend("bottomleft", bty="n", lty=1:2, col=1, c("Radiation Only", "Radiation and Chemotherapy"))
  par(op)

</code></pre>

<hr>
<h2 id='maple.dr'>Maximum approximate profile likelihood estimate of the density ratio model</h2><span id='topic+maple.dr'></span>

<h3>Description</h3>

<p>Select optimal degree with a given regression coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maple.dr(
  x,
  y,
  M,
  regr,
  ...,
  interval = c(0, 1),
  alpha = NULL,
  vb = 0,
  baseline = NULL,
  controls = mable.ctrl(),
  progress = TRUE,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maple.dr_+3A_x">x</code>, <code id="maple.dr_+3A_y">y</code></td>
<td>
<p>original two sample raw data, codex:&quot;Control&quot;, <code>y</code>: &quot;Case&quot;.</p>
</td></tr>
<tr><td><code id="maple.dr_+3A_m">M</code></td>
<td>
<p>a positive integer or a vector <code>(m0, m1)</code>.</p>
</td></tr>
<tr><td><code id="maple.dr_+3A_regr">regr</code></td>
<td>
<p>regressor vector function <code class="reqn">r(x)=(1,r_1(x),...,r_d(x))</code> 
which returns n x (d+1) matrix, n=length(x)</p>
</td></tr>
<tr><td><code id="maple.dr_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to regr</p>
</td></tr>
<tr><td><code id="maple.dr_+3A_interval">interval</code></td>
<td>
<p>a vector <code>(a,b)</code> containing the endpoints of 
supporting/truncation interval of x and y.</p>
</td></tr>
<tr><td><code id="maple.dr_+3A_alpha">alpha</code></td>
<td>
<p>a given regression coefficient, missing value is imputed by 
logistic regression</p>
</td></tr>
<tr><td><code id="maple.dr_+3A_vb">vb</code></td>
<td>
<p>code for vanishing boundary constraints, -1: f0(a)=0 only, 
1: f0(b)=0 only, 2: both, 0: none (default).</p>
</td></tr>
<tr><td><code id="maple.dr_+3A_baseline">baseline</code></td>
<td>
<p>the working baseline, &quot;Control&quot; or &quot;Case&quot;, if <code>NULL</code>
it is chosen to the one with smaller estimated lower bound for model degree.</p>
</td></tr>
<tr><td><code id="maple.dr_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit
and the convergence criterion for EM and Newton iterations. Default is 
<code><a href="#topic+mable.ctrl">mable.ctrl</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="maple.dr_+3A_progress">progress</code></td>
<td>
<p>logical: should a text progressbar be displayed</p>
</td></tr>
<tr><td><code id="maple.dr_+3A_message">message</code></td>
<td>
<p>logical: should warning messages be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that (&quot;control&quot;) and <code>y</code> (&quot;case&quot;) are independent samples from   
f0 and f1 which satisfy f1(x)=f0(x)exp[alpha0+alpha'r(x)] 
with r(x)=(r1(x),...,r_d(x)). Maximum 
approximate Bernstein/Beta likelihood estimates of  f0 and f1 are calculated 
with a given regression coefficients which are efficient estimates  provided 
by other semiparametric methods such as logistic regression.
If support is (a,b) then replace r(x) by r[a+(b-a)x].
For a fixed <code>m</code>, using the Bernstein polynomial model for baseline <code class="reqn">f_0</code>,
MABLEs of <code class="reqn">f_0</code> and parameters alpha can be estimated by EM algorithm and Newton  
iteration. If estimated lower bound <code class="reqn">m_b</code> for <code>m</code> based on <code>y</code>
is smaller that that based on <code>x</code>, then switch <code>x</code> and <code>y</code> and
<code class="reqn">f_1</code> is used as baseline. If <code>M=m</code> or <code>m0=m1=m</code>, then <code>m</code> is a 
preselected degree. If <code>m0&lt;m1</code> it specifies the set of consective  
candidate model degrees <code>m0:m1</code> for searching an optimal degree by 
the change-point method, where <code>m1-m0&gt;3</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>m</code> the given or a selected degree by method of change-point
</p>
</li>
<li> <p><code>p</code> the estimated vector of mixture proportions <code class="reqn">p = (p_0, \ldots, p_m)</code>
with the given or selected degree <code>m</code>
</p>
</li>
<li> <p><code>alpha</code> the given regression coefficients
</p>
</li>
<li> <p><code>mloglik</code>  the maximum log-likelihood at degree <code>m</code>
</p>
</li>
<li> <p><code>interval</code> support/truncation interval <code>(a,b)</code>
</p>
</li>
<li> <p><code>baseline</code> =&quot;control&quot; if <code class="reqn">f_0</code> is used as baseline, 
or =&quot;case&quot; if <code class="reqn">f_1</code> is used as baseline.
</p>
</li>
<li> <p><code>M</code> the vector <code>(m0, m1)</code>, where <code>m1</code>, if greater than <code>m0</code>, is the
largest candidate when the search stoped
</p>
</li>
<li> <p><code>lk</code> log-likelihoods evaluated at <code class="reqn">m \in \{m_0, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>lr</code> likelihood ratios for change-points evaluated at <code class="reqn">m \in \{m_0+1, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>pval</code> the p-values of the change-point tests for choosing optimal model degree
</p>
</li>
<li> <p><code>chpts</code> the change-points chosen with the given candidate model degrees
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Guan, Z., Maximum Approximate Bernstein Likelihood Estimation of 
Densities in a Two-sample Semiparametric Model
</p>

<hr>
<h2 id='maple.dr.group'>Maximum approximate profile likelihood estimate of the density ratio model 
for grouped data with given regression coefficients</h2><span id='topic+maple.dr.group'></span>

<h3>Description</h3>

<p>Select optimal degree of Bernstein polynomial model for grouped data
with a given regression coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maple.dr.group(
  t,
  n0,
  n1,
  M,
  regr,
  ...,
  interval = c(0, 1),
  alpha = NULL,
  vb = 0,
  controls = mable.ctrl(),
  progress = TRUE,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maple.dr.group_+3A_t">t</code></td>
<td>
<p>cutpoints of class intervals</p>
</td></tr>
<tr><td><code id="maple.dr.group_+3A_n0">n0</code>, <code id="maple.dr.group_+3A_n1">n1</code></td>
<td>
<p>frequencies of two sample data grouped by the classes 
specified by <code>t</code>. coden0:&quot;Control&quot;, <code>n1</code>: &quot;Case&quot;.</p>
</td></tr>
<tr><td><code id="maple.dr.group_+3A_m">M</code></td>
<td>
<p>a positive integer or a vector <code>(m0, m1)</code>.</p>
</td></tr>
<tr><td><code id="maple.dr.group_+3A_regr">regr</code></td>
<td>
<p>regressor vector function <code class="reqn">r(x)=(1,r_1(x),...,r_d(x))</code> 
which returns n x (d+1) matrix, n=length(x)</p>
</td></tr>
<tr><td><code id="maple.dr.group_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to regr</p>
</td></tr>
<tr><td><code id="maple.dr.group_+3A_interval">interval</code></td>
<td>
<p>a vector <code>(a,b)</code> containing the endpoints of 
supporting/truncation interval of x and y.</p>
</td></tr>
<tr><td><code id="maple.dr.group_+3A_alpha">alpha</code></td>
<td>
<p>a given regression coefficient, missing value is imputed by 
logistic regression</p>
</td></tr>
<tr><td><code id="maple.dr.group_+3A_vb">vb</code></td>
<td>
<p>code for vanishing boundary constraints, -1: f0(a)=0 only, 
1: f0(b)=0 only, 2: both, 0: none (default).</p>
</td></tr>
<tr><td><code id="maple.dr.group_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit
and the convergence criterion for EM and Newton iterations. Default is 
<code><a href="#topic+mable.ctrl">mable.ctrl</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="maple.dr.group_+3A_progress">progress</code></td>
<td>
<p>logical: should a text progressbar be displayed</p>
</td></tr>
<tr><td><code id="maple.dr.group_+3A_message">message</code></td>
<td>
<p>logical: should warning messages be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that <code>n0</code>(&quot;control&quot;) and <code>n1</code>(&quot;case&quot;) are frequencies of  
independent samples grouped by the classes <code>t</code> from f0 and f1 which   
satisfy f1(x)=f0(x)exp[alpha0+alpha'r(x)] with r(x)=(r1(x),...,r_d(x)). Maximum 
approximate Bernstein/Beta likelihood estimates of f0 and f1 are calculated 
with a given regression coefficients which are efficient estimates provided 
by other semiparametric methods such as logistic regression.
If support is (a,b) then replace r(x) by r[a+(b-a)x].
For a fixed <code>m</code>, using the Bernstein polynomial model for baseline <code class="reqn">f_0</code>,
MABLEs of <code class="reqn">f_0</code> and parameters alpha can be estimated by EM algorithm and Newton  
iteration. If estimated lower bound <code class="reqn">m_b</code> for <code>m</code> based on <code>n1</code>
is smaller that that based on <code>n0</code>, then switch <code>n0</code> and <code>n1</code> and
use <code class="reqn">f_1</code> as baseline. If <code>M=m</code> or <code>m0=m1=m</code>, then <code>m</code> is a 
preselected degree. If <code>m0&lt;m1</code> it specifies the set of consective  
candidate model degrees <code>m0:m1</code> for searching an optimal degree by 
the change-point method, where <code>m1-m0&gt;3</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>m</code> the given or a selected degree by method of change-point
</p>
</li>
<li> <p><code>p</code> the estimated vector of mixture proportions <code class="reqn">p = (p_0, \ldots, p_m)</code>
with the given or selected degree <code>m</code>
</p>
</li>
<li> <p><code>alpha</code> the given regression coefficients
</p>
</li>
<li> <p><code>mloglik</code>  the maximum log-likelihood at degree <code>m</code>
</p>
</li>
<li> <p><code>interval</code> support/truncation interval <code>(a,b)</code>
</p>
</li>
<li> <p><code>baseline</code> =&quot;control&quot; if <code class="reqn">f_0</code> is used as baseline, 
or =&quot;case&quot; if <code class="reqn">f_1</code> is used as baseline.
</p>
</li>
<li> <p><code>M</code> the vector <code>(m0, m1)</code>, where <code>m1</code>, if greater than <code>m0</code>, is the
largest candidate when the search stoped
</p>
</li>
<li> <p><code>lk</code> log-likelihoods evaluated at <code class="reqn">m \in \{m_0, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>lr</code> likelihood ratios for change-points evaluated at <code class="reqn">m \in \{m_0+1, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>pval</code> the p-values of the change-point tests for choosing optimal model degree
</p>
</li>
<li> <p><code>chpts</code> the change-points chosen with the given candidate model degrees
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Guan, Z., Application of Bernstein Polynomial Model to Density 
and ROC Estimation in a Semiparametric Density Ratio Model
</p>

<hr>
<h2 id='maple.ph'>Mable fit of the PH model with given regression coefficients</h2><span id='topic+maple.ph'></span>

<h3>Description</h3>

<p>Maximum approximate profile likelihood estimation of Bernstein
polynomial model in Cox's proportional hazards regression  based on interal 
censored event time data with given regression coefficients which are efficient
estimates provided by other semiparametric methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maple.ph(
  formula,
  data,
  M,
  g,
  pi0 = NULL,
  p = NULL,
  tau = Inf,
  x0 = NULL,
  controls = mable.ctrl(),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maple.ph_+3A_formula">formula</code></td>
<td>
<p>regression formula. Response must be <code>cbind</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="maple.ph_+3A_data">data</code></td>
<td>
<p>a dataset</p>
</td></tr>
<tr><td><code id="maple.ph_+3A_m">M</code></td>
<td>
<p>a positive integer or a vector <code>(m0, m1)</code>. If <code>M = m0</code> or <code>m0 = m1</code>,
then <code>m0</code> is a preselected degree. If <code>m0 &lt; m1</code> it specifies the set of 
consective candidate model degrees <code>m0:m1</code> for searching an optimal degree,
where <code>m1-m0&gt;3</code>.</p>
</td></tr>
<tr><td><code id="maple.ph_+3A_g">g</code></td>
<td>
<p>the given <code class="reqn">d</code>-vector of regression coefficients</p>
</td></tr>
<tr><td><code id="maple.ph_+3A_pi0">pi0</code></td>
<td>
<p>Initial guess of <code class="reqn">\pi(x_0) = F(\tau_n|x_0)</code>. Without right censored data, <code>pi0 = 1</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="maple.ph_+3A_p">p</code></td>
<td>
<p>an initial coefficients of Bernstein polynomial model of degree <code>m0</code>, 
default is the uniform initial.</p>
</td></tr>
<tr><td><code id="maple.ph_+3A_tau">tau</code></td>
<td>
<p>right endpoint of support <code class="reqn">[0, \tau)</code> must be greater than or equal to the maximum observed time</p>
</td></tr>
<tr><td><code id="maple.ph_+3A_x0">x0</code></td>
<td>
<p>a working baseline covariate. See 'Details'.</p>
</td></tr>
<tr><td><code id="maple.ph_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit 
and other control options. Default is <code><a href="#topic+mable.ctrl">mable.ctrl</a></code>.</p>
</td></tr>
<tr><td><code id="maple.ph_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> a text progressbar is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider Cox's PH model with covariate for interval-censored failure time data: 
<code class="reqn">S(t|x) = S(t|x_0)^{\exp(\gamma^T(x-x_0))}</code>, where <code class="reqn">x_0</code> satisfies <code class="reqn">\gamma^T(x-x_0)\ge 0</code>.   
Let <code class="reqn">f(t|x)</code> and <code class="reqn">F(t|x) = 1-S(t|x)</code> be the density and cumulative distribution
functions of the event time given <code class="reqn">X = x</code>, respectively.
Then <code class="reqn">f(t|x_0)</code> on <code class="reqn">[0,\tau_n]</code> can be approximated by  
<code class="reqn">f_m(t|x_0; p) = \tau_n^{-1}\sum_{i=0}^m p_i\beta_{mi}(t/\tau_n)</code>,
where <code class="reqn">p_i \ge 0</code>, <code class="reqn">i = 0, \ldots, m</code>, <code class="reqn">\sum_{i=0}^mp_i = 1-p_{m+1}</code>,
<code class="reqn">\beta_{mi}(u)</code> is the beta denity with shapes <code class="reqn">i+1</code> and <code class="reqn">m-i+1</code>, and
<code class="reqn">\tau_n</code> is the largest observed time, either uncensored time, or right endpoint of interval/left censored,
or left endpoint of right censored time. So we can approximate  <code class="reqn">S(t|x_0)</code> on <code class="reqn">[0, \tau_n]</code> by
<code class="reqn">S_m(t|x_0; p) = \sum_{i=0}^{m+1} p_i \bar B_{mi}(t/\tau_n)</code>, where 
<code class="reqn">\bar B_{mi}(u)</code>, <code class="reqn">i = 0, \ldots, m</code>, is the beta survival function with shapes 
<code class="reqn">i+1</code> and <code class="reqn">m-i+1</code>, <code class="reqn">\bar B_{m,m+1}(t) =  1</code>, <code class="reqn">p_{m+1} = 1-\pi(x_0)</code>, and
<code class="reqn">\pi(x_0) = F(\tau_n|x_0)</code>. For data without right-censored time, <code class="reqn">p_{m+1} = 1-\pi(x_0) = 0.</code>  
</p>
<p>Response variable should be of the form <code>cbind(l, u)</code>, where <code>(l, u)</code> is the interval 
containing the event time. Data is uncensored if <code>l = u</code>, right censored 
if <code>u = Inf</code> or <code>u = NA</code>, and  left censored data if <code>l = 0</code>.
The associated covariate contains <code class="reqn">d</code> columns. The baseline <code>x0</code> should chosen so that 
<code class="reqn">\gamma^T(x-x_0)</code> is nonnegative for all the observed <code class="reqn">x</code>.
</p>
<p>The search for optimal degree <code>m</code> stops if either <code>m1</code> is reached or the test 
for change-point results in a p-value <code>pval</code> smaller than <code>sig.level</code>.
</p>


<h3>Value</h3>

<p>a class '<code>mable_reg</code>' object, a list with components
</p>
 
<ul>
<li> <p><code>M</code> the vector <code>(m0, m1)</code>, where <code>m1</code> is the last candidate degree when the search stoped
</p>
</li>
<li> <p><code>m</code> the selected optimal degree <code>m</code>
</p>
</li>
<li> <p><code>p</code> the estimate of <code class="reqn">p = (p_0, \dots, p_m,p_{m+1})</code>, the coefficients of Bernstein polynomial of degree <code>m</code>
</p>
</li>
<li> <p><code>coefficients</code> the given regression coefficients of the PH model
</p>
</li>
<li> <p><code>mloglik</code> the maximum log-likelihood at an optimal degree <code>m</code>
</p>
</li>
<li> <p><code>lk</code> log-likelihoods evaluated at <code class="reqn">m \in \{m_0, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>lr</code> likelihood ratios for change-points evaluated at <code class="reqn">m \in \{m_0+1, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>tau.n</code> maximum observed time <code class="reqn">\tau_n</code>
</p>
</li>
<li> <p><code>tau</code> right endpoint of support <code class="reqn">[0, \tau)</code>
</p>
</li>
<li> <p><code>x0</code> the working baseline covariates 
</p>
</li>
<li> <p><code>egx0</code> the value of <code class="reqn">e^{\gamma'x_0}</code> 
</p>
</li>
<li> <p><code>convergence</code> an integer code. 0 indicates successful completion(the iteration is 
convergent). 1 indicates that the maximum candidate degree had been reached in the calculation;
</p>
</li>
<li> <p><code>delta</code> the final convergence criterion for EM iteration;
</p>
</li>
<li> <p><code>chpts</code> the change-points among the candidate degrees;
</p>
</li>
<li> <p><code>pom</code> the p-value of the selected optimal degree <code>m</code> as a change-point;
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>References</h3>

<p>Guan, Z. (2019) Maximum Approximate Bernstein Likelihood Estimation in Proportional Hazard Model for Interval-Censored Data, 
arXiv:1906.08882 .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mable.ph">mable.ph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Simulated Weibull data
   require(icenReg) 
   set.seed(123)
   simdata&lt;-simIC_weib(70, inspections = 5, inspectLength = 1)
   sp&lt;-ic_sp(cbind(l, u) ~ x1 + x2, data = simdata)
   res0&lt;-maple.ph(cbind(l, u) ~ x1 + x2, data = simdata, M=c(2,20), 
        g=sp$coefficients, tau=7)
   op&lt;-par(mfrow=c(1,2))
   plot(res0,  which=c("likelihood","change-point"))
   par(op)
   res1&lt;-mable.ph(cbind(l, u) ~ x1 + x2, data = simdata, M=res0$m, 
      g=c(.5,-.5), tau=7)
   op&lt;-par(mfrow=c(1,2))
   plot(res1, y=data.frame(x=0, x2=0), which="density", add=FALSE, type="l", 
       xlab="Time", main="Desnity Function")
   lines(xx&lt;-seq(0, 7, len=512), dweibull(xx, 2,2), lty=2, col=2)
   legend("topright", bty="n", lty=1:2, col=1:2, c("Estimated","True"))
   plot(res1, y=data.frame(x=0, x2=0), which="survival", add=FALSE, type="l", 
       xlab="Time", main="Survival Function")
   lines(xx, 1-pweibull(xx, 2, 2), lty=2, col=2)
   legend("topright", bty="n", lty=1:2, col=1:2, c("Estimated","True"))
   par(op)

</code></pre>

<hr>
<h2 id='marginal.p'>The mixing proportions of marginal distribution from the mixture of 
multivariate beta distribution</h2><span id='topic+marginal.p'></span>

<h3>Description</h3>

<p>The mixing proportions of marginal distribution from the mixture of 
multivariate beta distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal.p(p, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal.p_+3A_p">p</code></td>
<td>
<p>the mixing proportions of the mixture of multivariate beta distribution</p>
</td></tr>
<tr><td><code id="marginal.p_+3A_m">m</code></td>
<td>
<p>the model  degrees <code>m=(m1,...,md)</code> of the mixture of 
multivariate beta distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of mixing proportions of all the marginal distributions
</p>

<hr>
<h2 id='momodem'>Method of mode estimate of a Bernstein polynomial model degree</h2><span id='topic+momodem'></span>

<h3>Description</h3>

<p>Select a Bernstein polynomial model degree for density  
on [0,1] based on mode(s) used as an initial guess for the iterative method
of moment of choosing the model degree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momodem(modes, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="momodem_+3A_modes">modes</code></td>
<td>
<p>a list containing <code>z</code>, a vector of the known or estimated 
locations of modes,  <code>ufz</code>, a vector of upper confidence limits
of density values at modes, and <code>fz</code>, a vector of estimated density 
values at modes by <code>ks::kde</code> or <code>multimode::locmodes()</code></p>
</td></tr>
<tr><td><code id="momodem_+3A_x">x</code></td>
<td>
<p>a vector sample values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>mode</code> a vector of modes
</p>
</li>
<li> <p><code>nmod</code> the number of modes in <code>mode</code>
</p>
</li>
<li> <p><code>m</code>  the method of mode estimate of degree 
</p>
</li>
<li> <p><code>lam</code> a vector of rough estimates of the mixing proportions 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>

<hr>
<h2 id='optim.gcp'>Choosing optimal model degree by gamma change-point method</h2><span id='topic+optim.gcp'></span>

<h3>Description</h3>

<p>Choose an optimal degree using gamma change-point model with two
changing shape and scale parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.gcp(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.gcp_+3A_obj">obj</code></td>
<td>
<p>a class &quot;mable&quot; or 'mable_reg' object containig a vector <code>M = (m0, m1)</code>, <code>lk</code>,
loglikelihoods evaluated evaluated at <code class="reqn">m \in \{m_0, \ldots, m_1\}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>

<ul>
<li> <p><code>m</code> the selected optimal degree <code>m</code>
</p>
</li>
<li> <p><code>M</code> the vector <code>(m0, m1)</code>, where <code>m1</code> is the last candidate when the search stoped
</p>
</li>
<li> <p><code>mloglik</code>  the maximum log-likelihood at degree <code>m</code>
</p>
</li>
<li> <p><code>interval</code> support/truncation interval <code>(a, b)</code>
</p>
</li>
<li> <p><code>lk</code> log-likelihoods evaluated at <code class="reqn">m \in \{m_0, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>lr</code> likelihood ratios for change-points evaluated at <code class="reqn">m \in \{m_0+1, \ldots, m_1\}</code>
</p>
</li>
<li> <p><code>pval</code> the p-values of the change-point tests for choosing optimal model degree
</p>
</li>
<li> <p><code>chpts</code> the change-points chosen with the given candidate model degrees
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
 # simulated data
 p&lt;-c(1:5,5:1)
 p&lt;-p/sum(p)
 x&lt;-rmixbeta(100, p)
 res1&lt;-mable(x, M=c(2, 50), IC="none")
 m1&lt;-res1$m[1]
 res2&lt;-optim.gcp(res1)
 m2&lt;-res2$m
 op&lt;-par(mfrow=c(1,2))
 plot(res1, which="likelihood", add=FALSE)
 plot(res2, which="likelihood")
 #segments(m2, min(res1$lk), m2, res2$mloglik, col=4)
 plot(res1, which="change-point", add=FALSE)
 plot(res2, which="change-point")
 par(op)

</code></pre>

<hr>
<h2 id='optimable'>mable with degree selected by the method of moment and method of mode</h2><span id='topic+optimable'></span>

<h3>Description</h3>

<p>Maximum Approximate Bernstein/Beta Likelihood Estimation
with an optimal model degree estimated by the Method of Moment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimable(
  x,
  interval,
  m = NULL,
  mu = NULL,
  lam = NULL,
  modes = NULL,
  nmod = 1,
  ushaped = FALSE,
  maxit = 50L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimable_+3A_x">x</code></td>
<td>
<p>a univariate sample data in <code>interval</code></p>
</td></tr>
<tr><td><code id="optimable_+3A_interval">interval</code></td>
<td>
<p>a closed interval <code>c(a,b)</code>, default is [0,1]</p>
</td></tr>
<tr><td><code id="optimable_+3A_m">m</code></td>
<td>
<p>initial degree, default is 2 times the number of modes <code>nmod</code>.</p>
</td></tr>
<tr><td><code id="optimable_+3A_mu">mu</code></td>
<td>
<p>a vector of component means of multimodal mixture density, 
default is NULL for unimodal or unknown</p>
</td></tr>
<tr><td><code id="optimable_+3A_lam">lam</code></td>
<td>
<p>a vector of mixture proportions of same length of <code>mu</code></p>
</td></tr>
<tr><td><code id="optimable_+3A_modes">modes</code></td>
<td>
<p>a vector of the locations of modes, if it is NULL (default) and 
<code>multimode::locmodes()</code></p>
</td></tr>
<tr><td><code id="optimable_+3A_nmod">nmod</code></td>
<td>
<p>the number of modes, if <code>nmod</code>=0, the lower bound for
m is estimated based on mean and variance only.</p>
</td></tr>
<tr><td><code id="optimable_+3A_ushaped">ushaped</code></td>
<td>
<p>logical, whether or not the density is clearly U-shaped 
including J- and L-shaped with mode occurs at the endpoint of the support.</p>
</td></tr>
<tr><td><code id="optimable_+3A_maxit">maxit</code></td>
<td>
<p>maximum iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the data show a clear uni- or multi-modal distribution, then give 
the value of <code>nmod</code> as the number of modes. Otherwise <code>nmod</code>=0.
The degree is estimated by the iterative method of moment with an initial
degree estimated by the method of mode. For multimodal density, 
if useful estimates of the component means <code>mu</code> and proportions 
<code>lam</code> are available then they can be used to give an initial degree.  
If the distribution is clearly U-, J-, or L-shaped, i.e., the mode occurs
at the endpoint of <code>interval</code>, then set <code>ushaped</code>=TRUE. 
In this case the degree is estimated by the method of mode.
</p>


<h3>Value</h3>

<p>A class &quot;mable&quot; object with components
</p>

<ul>
<li> <p><code>m</code> the given or a selected degree by method of change-point
</p>
</li>
<li> <p><code>p</code> the estimated vector of mixture proportions <code class="reqn">p = (p_0, \ldots, p_m)</code>
with the selected/given optimal degree <code>m</code>
</p>
</li>
<li> <p><code>mloglik</code>  the maximum log-likelihood at degree <code>m</code>
</p>
</li>
<li> <p><code>interval</code> support/truncation interval <code>(a,b)</code>
</p>
</li>
<li> <p><code>convergence</code> An integer code. 0 indicates successful completion 
(all the EM iterations are convergent and an optimal degree
is successfully selected in <code>M</code>). Possible error codes are
</p>

<ul>
<li><p> 1, indicates that the iteration limit <code>maxit</code> had been 
reached in at least one EM iteration;
</p>
</li>
<li><p> 2, the search did not finish before <code>m1</code>.
</p>
</li></ul>

</li>
<li> <p><code>delta</code> the convergence criterion <code>delta</code> value
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Old Faithful Data
x&lt;-faithful
x1&lt;-faithful[,1]
x2&lt;-faithful[,2]
a&lt;-c(0, 40); b&lt;-c(7, 110)
mu&lt;-(apply(x,2,mean)-a)/(b-a)
s2&lt;-apply(x,2,var)/(b-a)^2
# mixing proportions
lambda&lt;-c(mean(x1&lt;3),mean(x2&lt;65))
# guess component mean
mu1&lt;-(c(mean(x1[x1&lt;3]), mean(x2[x2&lt;65]))-a)/(b-a)  
mu2&lt;-(c(mean(x1[x1&gt;=3]), mean(x2[x2&gt;=65]))-a)/(b-a)  
# estimate lower bound for m
mb&lt;-ceiling((mu*(1-mu)-s2)/(s2-lambda*(1-lambda)*(mu1-mu2)^2)-2)
mb
m1&lt;-optimable(x1, interval=c(a[1],b[1]), nmod=2, modes=c(2,4.5))$m 
m2&lt;-optimable(x2, interval=c(a[2],b[2]), nmod=2, modes=c(52.5,80))$m 
m1;m2
erupt1&lt;-mable(x1, M=mb[1], interval=c(a[1],b[1]))
erupt2&lt;-mable(x1, M=m1, interval=c(a[1],b[1])) 
wait1&lt;-mable(x2, M=mb[2],interval=c(a[2],b[2])) 
wait2&lt;-mable(x2, M=m2,interval=c(a[2],b[2])) 
ans1&lt;- mable.mvar(faithful, M = mb, search =FALSE, interval = cbind(a,b))
ans2&lt;- mable.mvar(faithful, M = c(m1,m2), search =FALSE, interval = cbind(a,b))
op&lt;-par(mfrow=c(1,2), cex=0.8)
hist(x1, probability = TRUE, col="grey", border="white", main="", 
      xlab="Eruptions", ylim=c(0,.65), las=1)
plot(erupt1, add=TRUE,"density")
plot(erupt2, add=TRUE,"density",lty=2,col=2)
legend("topleft", lty=c(1,2),col=1:2, bty="n", cex=.7,  
      c(expression(paste("m = ", m[b])),expression(paste("m = ", hat(m)))))
hist(x2, probability = TRUE, col="grey", border="white", main="", 
      xlab="Waiting", las=1)
plot(wait1, add=TRUE,"density")
plot(wait2, add=TRUE,"density",lty=2,col=2)
legend("topleft", lty=c(1,2),col=1:2, bty="n", cex=.7,  
      c(expression(paste("m = ", m[b])),expression(paste("m = ", hat(m)))))
par(op)
op&lt;-par(mfrow=c(1,2), cex=0.7)
plot(ans1, which="density", contour=TRUE) 
plot(ans2, which="density", contour=TRUE, add=TRUE, lty=2, col=2) 
plot(ans1, which="cumulative", contour=TRUE)       
plot(ans2, which="cumulative", contour=TRUE, add=TRUE, lty=2, col=2)
par(op)

</code></pre>

<hr>
<h2 id='pancreas'>Pancreatic Cancer Biomarker Data</h2><span id='topic+pancreas'></span>

<h3>Description</h3>

<p>Contain sera measurements from 51 control patients with pancreatitis and 90
case patients with pancreatic cancer at the Mayo Clinic with a cancer antigen, CA125,
and with a carbohydrate antigen, CA19-9 (Wieand, et al, 1989)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pancreas)
</code></pre>


<h3>Format</h3>

<p>A data frame with 141 rows and 3 variables. 
</p>

<ul>
<li><p> ca199. CA19-9 levels
</p>
</li>
<li><p> ca125. CA125 levels
</p>
</li>
<li><p> status. 0 = controls (non-cancer) and 1 = cases (cancer).
</p>
</li></ul>



<h3>Source</h3>

<p>Wieand, S., Gail, M. H., James, B. R., and James, K.L. (1989). 
A family of nonparametric statistics for comparing diagnostic markers with 
paired or unpaired data. Biometrika, 76, 585&ndash;592.
</p>


<h3>References</h3>

<p>Wieand, S., Gail, M. H., James, B. R., and James, K.L. (1989). 
A family of nonparametric statistics for comparing diagnostic markers with 
paired or unpaired data. Biometrika, 76, 585&ndash;592.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pancreas)
</code></pre>

<hr>
<h2 id='plot.mable'>Plot mathod for class 'mable'</h2><span id='topic+plot.mable'></span>

<h3>Description</h3>

<p>Plot mathod for class 'mable'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mable'
plot(
  x,
  which = c("density", "cumulative", "survival", "likelihood", "change-point", "all"),
  add = FALSE,
  contour = FALSE,
  lgd.x = NULL,
  lgd.y = NULL,
  nx = 512,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mable_+3A_x">x</code></td>
<td>
<p>Class &quot;mable&quot; object return by <code>mablem</code>, <code>mable</code>, <code>mablem.group</code> or <code>mable.group</code> functions
which contains <code>p</code>, <code>mloglik</code>, and <code>M = m0:m1</code>, <code>lk</code>, <code>lr</code>,</p>
</td></tr>
<tr><td><code id="plot.mable_+3A_which">which</code></td>
<td>
<p>indicates which graphs to plot, options are
&quot;density&quot;, &quot;cumulative&quot;, &quot;likelihood&quot;, &quot;change-point&quot;, &quot;all&quot;. If not &quot;all&quot;,
<code>which</code> can contain more than one options.</p>
</td></tr>
<tr><td><code id="plot.mable_+3A_add">add</code></td>
<td>
<p>logical add to an existing plot or not</p>
</td></tr>
<tr><td><code id="plot.mable_+3A_contour">contour</code></td>
<td>
<p>logical plot contour or not for two-dimensional data</p>
</td></tr>
<tr><td><code id="plot.mable_+3A_lgd.x">lgd.x</code>, <code id="plot.mable_+3A_lgd.y">lgd.y</code></td>
<td>
<p>coordinates of position where the legend is displayed</p>
</td></tr>
<tr><td><code id="plot.mable_+3A_nx">nx</code></td>
<td>
<p>number of evaluations of density, or cumulative distribution curve to be plotted.</p>
</td></tr>
<tr><td><code id="plot.mable_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the base plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data used for 'plot()', 'lines()', or 'persp()' are returned invisibly.
</p>

<hr>
<h2 id='plot.mable_reg'>Plot mathod for class 'mable_reg'</h2><span id='topic+plot.mable_reg'></span>

<h3>Description</h3>

<p>Plot mathod for class 'mable_reg'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mable_reg'
plot(
  x,
  y,
  newdata = NULL,
  ntime = 512,
  xlab = "Time",
  which = c("survival", "likelihood", "change-point", "density", "all"),
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mable_reg_+3A_x">x</code></td>
<td>
<p>a class 'mable_reg' object return by functions such as <code>mable.ph</code> which contains 
<code>M</code>, <code>coefficients</code>, <code>p</code>, <code>m</code>, <code>x0</code>, <code>tau.n</code>, <code>tau</code> 
<code>lk</code>, <code>lr</code>.</p>
</td></tr>
<tr><td><code id="plot.mable_reg_+3A_y">y</code></td>
<td>
<p>a new data.frame of covariate value(s) as row(s), whose columns are
arranged in the same order as in the <code>formula</code> called by the function
that returned the object <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.mable_reg_+3A_newdata">newdata</code></td>
<td>
<p>a new data.frame (ignored if <code>y</code> is included), imputed
by the working baseline <code>x0</code> if both missing.</p>
</td></tr>
<tr><td><code id="plot.mable_reg_+3A_ntime">ntime</code></td>
<td>
<p>number of evaluations of density, survival or cumulative distribution
curve to be plotted.</p>
</td></tr>
<tr><td><code id="plot.mable_reg_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="plot.mable_reg_+3A_which">which</code></td>
<td>
<p>indicates which graphs to plot, options are 
&quot;survival&quot;, &quot;likelihood&quot;, &quot;change-point&quot;, &quot;density&quot;, or &quot;all&quot;. If not &quot;all&quot;, 
<code>which</code> can contain more than one options.</p>
</td></tr>
<tr><td><code id="plot.mable_reg_+3A_add">add</code></td>
<td>
<p>logical add to an existing plot or not</p>
</td></tr>
<tr><td><code id="plot.mable_reg_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the base plot function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhong Guan &lt;zguan@iusb.edu&gt;
</p>

<hr>
<h2 id='se.coef.dr'>Standard errors of coefficients in density ratio model</h2><span id='topic+se.coef.dr'></span>

<h3>Description</h3>

<p>Bootstrap estimates of standard errors for the regression
coefficients which are estimated by maximum approximate Bernstein/Beta 
likelihood estimation method in a density ratio model based on two-sample 
raw data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se.coef.dr(
  obj,
  grouped = FALSE,
  B = 500L,
  parallel = FALSE,
  ncore = NULL,
  controls = mable.ctrl()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se.coef.dr_+3A_obj">obj</code></td>
<td>
<p>Class 'mable_dr' object return by <code>mable.dr</code> or <code>mable.dr.group</code>  functions</p>
</td></tr>
<tr><td><code id="se.coef.dr_+3A_grouped">grouped</code></td>
<td>
<p>logical: are data grouped or not.</p>
</td></tr>
<tr><td><code id="se.coef.dr_+3A_b">B</code></td>
<td>
<p>number of bootstrap runs.</p>
</td></tr>
<tr><td><code id="se.coef.dr_+3A_parallel">parallel</code></td>
<td>
<p>logical: do parallel or not.</p>
</td></tr>
<tr><td><code id="se.coef.dr_+3A_ncore">ncore</code></td>
<td>
<p>number of cores used for parallel computing. Default is half of availables.</p>
</td></tr>
<tr><td><code id="se.coef.dr_+3A_controls">controls</code></td>
<td>
<p>Object of class <code>mable.ctrl()</code> specifying iteration limit
and the convergence criterion for EM and Newton iterations. Default is 
<code><a href="#topic+mable.ctrl">mable.ctrl</a></code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bootstrap method is used based on bootstrap samples generated from
the MABLE's of the densities f0 and f1. The bootstrap samples are fitted by
the Bernstein polynomial model and the <code>glm()</code> to obtain bootstrap 
versions of coefficient estimates.
</p>


<h3>Value</h3>

<p>the estimated standard errors
</p>

<hr>
<h2 id='summary.mable'>Summary mathods for classes 'mable' and 'mable_reg'</h2><span id='topic+summary.mable'></span><span id='topic+summary.mable_reg'></span>

<h3>Description</h3>

<p>Produces a summary of a mable fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mable'
summary(object, ...)

## S3 method for class 'mable_reg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mable_+3A_object">object</code></td>
<td>
<p>Class &quot;mable&quot; or 'mable_reg' object return by <code>mable</code> or 
<code>mable.xxxx</code>  functions</p>
</td></tr>
<tr><td><code id="summary.mable_+3A_...">...</code></td>
<td>
<p>for future methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns its argument, <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Breast Cosmesis Data
  bcos=cosmesis
  bcos2&lt;-data.frame(bcos[,1:2], x=1*(bcos$treat=="RCT"))
  aft.res&lt;-mable.aft(cbind(left, right)~x, data=bcos2, M=c(1, 30), g=.41, 
       tau=100, x0=1)
  summary(aft.res)

</code></pre>

<hr>
<h2 id='Vaal.Flow'>Vaal River Annual Flow Data</h2><span id='topic+Vaal.Flow'></span>

<h3>Description</h3>

<p>The annual flow data of Vaal River at Standerton as given by Table 1.1 of Linhart and Zucchini
(1986) give the flow in millions of cubic metres.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Vaal.Flow)
</code></pre>


<h3>Format</h3>

<p>The format is: int [1:65] 222 1094 452 1298 882 988 276 216 103 490 ...
</p>


<h3>References</h3>

<p>Linhart, H., and Zucchini, W., <em>Model Selection</em>, 
Wiley Series in Probability and Mathematical Statistics: Applied
Probability and Statistics, New York: John Wiley and Sons Inc, 1986.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Vaal.Flow)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
