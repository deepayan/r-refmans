<!DOCTYPE html><html><head><title>Help for package rgl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rgl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rgl-package'><p>3D visualization device system</p></a></li>
<li><a href='#.check3d'>
<p>Check for an open RGL window.</p></a></li>
<li><a href='#abclines3d'>
<p>Lines intersecting the bounding box</p></a></li>
<li><a href='#addNormals'>
<p>Add normal vectors to objects so they render more smoothly</p></a></li>
<li><a href='#ageControl'>
<p>Set attributes of vertices based on their age</p></a></li>
<li><a href='#all.equal.mesh3d'>
<p>Compare mesh3d objects in a meaningful way.</p></a></li>
<li><a href='#arc3d'>
<p>Draw arcs</p></a></li>
<li><a href='#arrow3d'>
<p>Draw an arrow</p></a></li>
<li><a href='#as.mesh3d'>
<p>Convert object to mesh object</p></a></li>
<li><a href='#as.mesh3d.ashape3d'>
<p>Convert alpha-shape surface of a cloud of points to</p>
RGL mesh object</a></li>
<li><a href='#as.mesh3d.rglId'>
<p>Convert object in plot to RGL mesh object</p></a></li>
<li><a href='#as.rglscene'>
<p>Convert an object to an <code>rglscene</code> object.</p></a></li>
<li><a href='#as.tmesh3d'>
<p>Convert object to a triangular mesh</p></a></li>
<li><a href='#as.triangles3d'>
<p>Convert an object to triangles</p></a></li>
<li><a href='#aspect3d'><p>Set the aspect ratios of the current plot</p></a></li>
<li><a href='#asRow'>
<p>Convenience functions for RGL HTML layouts</p></a></li>
<li><a href='#axes3d'><p> Draw boxes, axes and other text outside the data</p></a></li>
<li><a href='#bbox3d'><p>Set up bounding box decoration</p></a></li>
<li><a href='#bg3d'><p>Set up background</p></a></li>
<li><a href='#bgplot3d'><p>Use base graphics for RGL background</p></a></li>
<li><a href='#Buffer'><p>R6 Class for binary buffers in glTF files.</p></a></li>
<li><a href='#callbacks'><p> User callbacks on mouse events</p></a></li>
<li><a href='#checkDeldir'>
<p>Check for a compatible version of <span class="pkg">deldir</span></p></a></li>
<li><a href='#clipMesh3d'>
<p>Clip mesh or RGL object to general region</p></a></li>
<li><a href='#clipplaneControl'>
<p>Sets attributes of a clipping plane</p></a></li>
<li><a href='#contourLines3d'>
<p>Draw contours on a surface</p></a></li>
<li><a href='#cube3d'><p>Sample 3D mesh objects</p></a></li>
<li><a href='#cylinder3d'>
<p>Create cylindrical or &quot;tube&quot; plots</p></a></li>
<li><a href='#decorate3d'>
<p>Add decorations to a 3D plot</p></a></li>
<li><a href='#drape3d'>
<p>Drape lines over a scene.</p></a></li>
<li><a href='#elementId2Prefix'>
<p>Use widget with old-style controls</p></a></li>
<li><a href='#ellipse3d'>
<p>Make an ellipsoid</p></a></li>
<li><a href='#expect_known_scene'>
<p>Helper for <span class="pkg">testthat</span> testing.</p></a></li>
<li><a href='#extrude3d'>
<p>Generate extrusion mesh</p></a></li>
<li><a href='#facing3d'>
<p>Subset an object to parts facing in a particular direction</p></a></li>
<li><a href='#figWidth'>
<p>Get R Markdown figure dimensions in pixels</p></a></li>
<li><a href='#getBoundary3d'>
<p>Extract the boundary of a mesh</p></a></li>
<li><a href='#gltfTypes'>
<p>Names of glTF types.</p></a></li>
<li><a href='#GramSchmidt'>
<p>The Gram-Schmidt algorithm</p></a></li>
<li><a href='#grid3d'><p>Add a grid to a 3D plot</p></a></li>
<li><a href='#hover3d'>
<p>Display hover info in plot.</p></a></li>
<li><a href='#identify3d'>
<p>Identify points in plot</p></a></li>
<li><a href='#import'><p>Imported from magrittr</p></a></li>
<li><a href='#in_pkgdown_example'>
<p>Are we running in a <span class="pkg">pkgdown</span> example?</p></a></li>
<li><a href='#light'><p>Add light source</p></a></li>
<li><a href='#makeDependency'>
<p>Process Javascript for HTML dependency</p></a></li>
<li><a href='#material3d'><p>Get or set material properties</p></a></li>
<li><a href='#matrices'><p>Work with homogeneous coordinates</p></a></li>
<li><a href='#merge.mesh3d'>
<p>Merge RGL mesh objects</p></a></li>
<li><a href='#mergeVertices'>
<p>Merge duplicate vertices in mesh object</p></a></li>
<li><a href='#mesh3d'><p>Construct 3D mesh objects</p></a></li>
<li><a href='#mfrow3d'>
<p>Set up multiple figure layouts</p></a></li>
<li><a href='#observer3d'>
<p>Set the observer location</p></a></li>
<li><a href='#open3d'><p>Work with RGL windows</p></a></li>
<li><a href='#par3d'><p>Set or query RGL parameters</p></a></li>
<li><a href='#par3dinterp'><p>Interpolator for par3d parameters</p></a></li>
<li><a href='#par3dinterpControl'>
<p>Control RGL widget like par3dinterp()</p></a></li>
<li><a href='#pch3d'>
<p>Plot symbols similar to base graphics</p></a></li>
<li><a href='#persp3d'><p> Surface plots</p></a></li>
<li><a href='#persp3d.deldir'>
<p>Plot a Delaunay triangulation</p></a></li>
<li><a href='#persp3d.function'>
<p>Plot a function of two variables</p></a></li>
<li><a href='#persp3d.triSht'>
<p>Plot an interp or tripack Delaunay triangulation</p></a></li>
<li><a href='#planes3d'><p>Add planes</p></a></li>
<li><a href='#play3d'><p> Play animation of RGL scene</p></a></li>
<li><a href='#playwidget'>
<p>Add a widget to play animations</p></a></li>
<li><a href='#plot3d'><p>3D scatterplot</p></a></li>
<li><a href='#plot3d.formula'>
<p>Methods for formulas</p></a></li>
<li><a href='#plot3d.lm'>
<p>Method for plotting simple linear fit</p></a></li>
<li><a href='#plotmath3d'>
<p>Draw text using base graphics math plotting</p></a></li>
<li><a href='#polygon3d'>
<p>Draw a polygon in three dimensions</p></a></li>
<li><a href='#primitives'><p>Add primitive shape</p></a></li>
<li><a href='#propertyControl'>
<p>Controls to use with playwidget()</p></a></li>
<li><a href='#r3d'><p>Generic 3D interface</p></a></li>
<li><a href='#readSTL'>
<p>Read and write STL (stereolithography) format files</p></a></li>
<li><a href='#rgl-defunct'>
<p>Defunct functions in <span class="pkg">rgl</span></p></a></li>
<li><a href='#rgl-deprecated'>
<p>Deprecated functions in <span class="pkg">rgl</span></p></a></li>
<li><a href='#rgl-duplicated'>
<p>Duplicated functions in <span class="pkg">rgl</span></p></a></li>
<li><a href='#rgl-internal'><p>Internal RGL functions and data</p></a></li>
<li><a href='#rgl.attrib'>
<p>Get information about shapes</p></a></li>
<li><a href='#rgl.attrib.info'>
<p>Get information about attributes of objects</p></a></li>
<li><a href='#rgl.bringtotop'><p>Assign focus to an RGL window</p></a></li>
<li><a href='#rgl.fns'>
<p>Low level functions that should not be called by users.</p></a></li>
<li><a href='#rgl.getAxisCallback'>
<p>Get user-defined axis labelling callbacks.</p></a></li>
<li><a href='#rgl.init'><p>Initializing RGL</p></a></li>
<li><a href='#rgl.pixels'><p> Extract pixel information from window</p></a></li>
<li><a href='#rgl.postscript'><p>Export vector graphics</p></a></li>
<li><a href='#rgl.select'>
<p>Switch to select mode, and return the mouse position selected</p></a></li>
<li><a href='#rgl.Sweave'>
<p>Integrating RGL with Sweave</p></a></li>
<li><a href='#rgl.useNULL'>
<p>Report default use of null device</p></a></li>
<li><a href='#rgl.user2window'><p> Convert between RGL user and window coordinates</p></a></li>
<li><a href='#rglExtrafonts'>
<p>Register extra fonts</p></a></li>
<li><a href='#rglFonts'>
<p>Specify FreeType fonts</p></a></li>
<li><a href='#rglIds'>
<p>RGL id values</p></a></li>
<li><a href='#rglMouse'>
<p>Generate HTML code to select mouse mode</p></a></li>
<li><a href='#rglShared'>
<p>Create shared data from an RGL object</p></a></li>
<li><a href='#rglToLattice'>
<p>Convert RGL userMatrix to lattice or base angles</p></a></li>
<li><a href='#rglwidget'>
<p>An htmlwidget to hold an RGL scene</p></a></li>
<li><a href='#safe.dev.off'>
<p>Close graphics device in a safe way.</p></a></li>
<li><a href='#scene'><p>Scene management</p></a></li>
<li><a href='#scene3d'>
<p>Saves the current scene to a variable, and displays such variables</p></a></li>
<li><a href='#sceneChange'>
<p>Make large change to a scene from Shiny</p></a></li>
<li><a href='#select3d'><p> Select a rectangle in an RGL scene</p></a></li>
<li><a href='#selectpoints3d'>
<p>Select points from a scene</p></a></li>
<li><a href='#setAxisCallbacks'>
<p>User-defined axis labelling callbacks.</p></a></li>
<li><a href='#setGraphicsDelay'>
<p>Set a one-time slowdown on opening standard graphics</p></a></li>
<li><a href='#setupKnitr'>
<p>Displaying RGL scenes in <span class="pkg">knitr</span> documents</p></a></li>
<li><a href='#setUserCallbacks'>
<p>Set mouse callbacks in R or Javascript code</p></a></li>
<li><a href='#setUserShaders'>
<p>Set user-defined shaders for RGL objects, or get</p>
shaders.</a></li>
<li><a href='#shade3d'><p>Draw 3D mesh objects</p></a></li>
<li><a href='#shadow3d'>
<p>Project shadows of mesh onto object.</p></a></li>
<li><a href='#shapelist3d'><p> Create and plot a list of shapes</p></a></li>
<li><a href='#shiny'>
<p>Functions for integration of RGL widgets into</p>
Shiny app</a></li>
<li><a href='#shinyGetPar3d'>
<p>Communicate RGL parameters between R and Javascript in Shiny</p></a></li>
<li><a href='#show2d'>
<p>Draw a 2D plot on a rectangle in a 3D scene</p></a></li>
<li><a href='#snapshot3d'><p>Export screenshot</p></a></li>
<li><a href='#spheres3d'><p>Add spheres</p></a></li>
<li><a href='#spin3d'><p> Create a function to spin a scene at a fixed rate</p></a></li>
<li><a href='#sprites'><p>Add sprites</p></a></li>
<li><a href='#subdivision3d'><p>Subdivide a mesh</p></a></li>
<li><a href='#subscene3d'>
<p>Create, select or modify a subscene</p></a></li>
<li><a href='#subsceneInfo'>
<p>Get information on subscenes</p></a></li>
<li><a href='#surface3d'><p>Add surface</p></a></li>
<li><a href='#tagged3d'>
<p>Find tags on rgl objects.</p></a></li>
<li><a href='#text3d'><p>Add text to plot</p></a></li>
<li><a href='#textureSource'>
<p>Retrieve source code used to produce texture file.</p></a></li>
<li><a href='#thigmophobe3d'>
<p>Find the direction away from the closest point in a 3d projection</p></a></li>
<li><a href='#tkpar3dsave'><p> Modal dialog for saving par3d settings</p></a></li>
<li><a href='#tkrgl'>
<p>The former tkrgl package</p></a></li>
<li><a href='#tkspin3d'><p>Create TCL/TK controller for RGL window</p></a></li>
<li><a href='#tkspinControl'><p>Create a spin control in a TCL/TK window</p></a></li>
<li><a href='#toggleWidget'>
<p>An HTML widget to toggle display of elements of a scene</p></a></li>
<li><a href='#triangulate'>
<p>Triangulate a two-dimensional polygon</p></a></li>
<li><a href='#turn3d'>
<p>Create a solid of rotation from a two-dimensional curve</p></a></li>
<li><a href='#vertexControl'>
<p>Set attributes of vertices</p></a></li>
<li><a href='#viewpoint'><p>Set up viewpoint</p></a></li>
<li><a href='#writeASY'>
<p>Write Asymptote code for an RGL scene</p></a></li>
<li><a href='#writeOBJ'>
<p>Read and write Wavefront OBJ format files</p></a></li>
<li><a href='#writePLY'>
<p>Write Stanford PLY format files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Title:</td>
<td>3D Visualization Using OpenGL</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, markdown (&ge; 1.12), rmarkdown (&ge; 2.16), deldir (&ge;
1.0-4), orientlib, lattice, misc3d, magick, plotrix (&ge; 3.7-3),
tripack, interp, alphashape3d, tcltk, js (&ge; 1.2), webshot2 (&ge;
0.1.0), downlit (&ge; 0.4.0), pkgdown (&ge; 2.0.0), extrafont,
shiny, manipulateWidget (&ge; 0.9.0), testthat, crosstalk, V8,
chromote, jpeg, png</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, utils, htmlwidgets (&ge; 1.6.0),
htmltools, knitr (&ge; 1.33), jsonlite (&ge; 0.9.20), magrittr, R6,
base64enc, mime</td>
</tr>
<tr>
<td>Enhances:</td>
<td>waldo</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides medium to high level functions for 3D interactive graphics, including
    functions modelled on base graphics (plot3d(), etc.) as well as functions for
    constructing representations of geometric objects (cube3d(), etc.).  Output
    may be on screen using OpenGL, or to various standard 3D file formats including
    WebGL, PLY, OBJ, STL as well as 2D image formats, including PNG, Postscript, SVG, PGF.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dmurdoch/rgl">https://github.com/dmurdoch/rgl</a>, <a href="https://dmurdoch.github.io/rgl/">https://dmurdoch.github.io/rgl/</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>OpenGL and GLU Library (Required for display in R.
See "Installing OpenGL support" in README.md. Not needed if
only browser displays using rglwidget() are wanted.), zlib
(optional), libpng (&gt;=1.2.9, optional), FreeType (optional)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dmurdoch/rgl/issues">https://github.com/dmurdoch/rgl/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 10:42:47 UTC; murdoch</td>
</tr>
<tr>
<td>Author:</td>
<td>Duncan Murdoch [aut, cre],
  Daniel Adler [aut],
  Oleg Nenadic [ctb],
  Simon Urbanek [ctb],
  Ming Chen [ctb],
  Albrecht Gebhardt [ctb],
  Ben Bolker [ctb],
  Gabor Csardi [ctb],
  Adam Strzelecki [ctb],
  Alexander Senger [ctb],
  The R Core Team [ctb, cph],
  Dirk Eddelbuettel [ctb],
  The authors of Shiny [cph],
  The authors of knitr [cph],
  Jeroen Ooms [ctb],
  Yohann Demont [ctb],
  Joshua Ulrich [ctb],
  Xavier Fernandez i Marin [ctb],
  George Helffrich [ctb],
  Ivan Krylov [ctb],
  Michael Sumner [ctb],
  Mike Stein [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Duncan Murdoch &lt;murdoch.duncan@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rgl-package'>3D visualization device system</h2><span id='topic+rgl-package'></span><span id='topic+rgl'></span><span id='topic+RGL'></span>

<h3>Description</h3>

<p>3D real-time rendering system.
</p>


<h3>Details</h3>

<p>RGL is a 3D real-time rendering system for R.
Multiple windows are managed at a time. Windows
may be divided into &ldquo;subscenes&rdquo;, where one has the current focus
that receives instructions from the R command-line. 
The device design is oriented towards the R device metaphor. If you send
scene management instructions, and there's no device open, it will be opened
automatically.
Opened devices automatically get the current device focus. The focus may be
changed by using <code><a href="#topic+set3d">set3d</a>()</code> or <code><a href="#topic+useSubscene3d">useSubscene3d</a>()</code>.
</p>
<p>RGL provides medium to high level functions for 3D interactive graphics, including
functions modelled on base graphics (<code><a href="#topic+plot3d">plot3d</a>()</code>, etc.) as well as functions for 
constructing geometric objects (<code><a href="#topic+cube3d">cube3d</a>()</code>, etc.).  Output
may be on screen using OpenGL, or to various standard 3D file formats including 
WebGL, PLY, OBJ, STL as well as 2D image formats, including PNG, Postscript, SVG, PGF.
</p>
<p>The <code><a href="#topic+open3d">open3d</a>()</code> function attempts to open a new RGL window,
using default settings specified by the user.
</p>
<p>See the first example below to display the ChangeLog.
</p>


<h3>See Also</h3>

<p><a href="#topic+r3d">r3d</a> for a description of the <code>*3d</code> interface;
<code><a href="#topic+par3d">par3d</a></code> for a description of scene properties and the rendering
pipeline; <code><a href="#topic+rgl.useNULL">rgl.useNULL</a></code> for a description of how to 
use RGL on a system with no graphics support.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!in_pkgdown_example())
  file.show(system.file("NEWS", package = "rgl"))
example(surface3d)
example(plot3d)
</code></pre>

<hr>
<h2 id='.check3d'>
Check for an open RGL window.
</h2><span id='topic+.check3d'></span><span id='topic+check3d'></span>

<h3>Description</h3>

<p>Mostly for internal use, this function returns the current device
number if one exists, or opens a new device and returns that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check3d()
</code></pre>


<h3>Value</h3>

<p>The device number of an RGL device.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+open3d">open3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rgl.dev.list()
.check3d()
rgl.dev.list()
.check3d()
rgl.dev.list()
close3d()
</code></pre>

<hr>
<h2 id='abclines3d'>
Lines intersecting the bounding box
</h2><span id='topic+abclines3d'></span>

<h3>Description</h3>

<p>This adds mathematical lines to a scene.  Their intersection with the current
bounding box will be drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abclines3d(x, y = NULL, z = NULL, a, b = NULL, c = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abclines3d_+3A_x">x</code>, <code id="abclines3d_+3A_y">y</code>, <code id="abclines3d_+3A_z">z</code></td>
<td>

<p>Coordinates of points through which each line passes.  
</p>
</td></tr> 
<tr><td><code id="abclines3d_+3A_a">a</code>, <code id="abclines3d_+3A_b">b</code>, <code id="abclines3d_+3A_c">c</code></td>
<td>

<p>Coordinates of the direction vectors for the lines.
</p>
</td></tr>
<tr><td><code id="abclines3d_+3A_...">...</code></td>
<td>

<p>Material properties.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws the segment of a line that intersects the current
bounding box of the scene using the parametrization
<code class="reqn"> (x, y, z) + (a, b, c) * s </code> where <code class="reqn">s</code> is a real number.
</p>
<p>Any reasonable way of defining the
coordinates <code>x, y, z</code> and <code>a, b, c</code> is acceptable.  
See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>
for details.
</p>


<h3>Value</h3>

<p>A shape ID of the object is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+planes3d">planes3d</a></code> for mathematical planes.
</p>
<p><code><a href="#topic+segments3d">segments3d</a></code> draws sections of lines that
do not adapt to the bounding box.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot3d(rnorm(100), rnorm(100), rnorm(100))
abclines3d(0, 0, 0, a = diag(3), col = "gray")
</code></pre>

<hr>
<h2 id='addNormals'>
Add normal vectors to objects so they render more smoothly
</h2><span id='topic+addNormals'></span><span id='topic+addNormals.mesh3d'></span><span id='topic+addNormals.shapelist3d'></span>

<h3>Description</h3>

<p>This generic function adds normals at each of the vertices
of a polyhedron by averaging the normals of each incident face.  This has the
effect of making the surface of the object appear smooth rather than faceted
when rendered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNormals(x, ...)
## S3 method for class 'mesh3d'
addNormals(x, angleWeighted = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addNormals_+3A_x">x</code></td>
<td>
<p>An object to which to add normals.</p>
</td></tr>
<tr><td><code id="addNormals_+3A_...">...</code></td>
<td>
<p>Additional parameters which will be passed to the methods.</p>
</td></tr>
<tr><td><code id="addNormals_+3A_angleweighted">angleWeighted</code></td>
<td>
<p>See Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently methods are supplied for <code><a href="#topic+mesh3d">&quot;mesh3d&quot;</a></code> and 
<code><a href="#topic+shapelist3d">&quot;shapelist3d&quot;</a></code> classes.
</p>
<p>These methods work by averaging the normals on the faces incident at 
each vertex.  By default these are weighted according to the angle 
in the polygon at that vertex.
If <code>angleWeighted = FALSE</code>, a slightly faster
but less accurate weighting by the triangle area is used.  
</p>
<p>Prior to <span class="pkg">rgl</span> version 0.104.12 an incorrect weighting was used; 
it can be partially reproduced by using <code>angleWeighted = NA</code>, 
but not all the bugs in that scheme will be kept.
</p>


<h3>Value</h3>

<p>A new object of the same class as <code>x</code>, with normals added.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
y &lt;- subdivision3d(tetrahedron3d(col = "red"), depth = 3)
shade3d(y) # No normals
y &lt;- addNormals(y)
shade3d(translate3d(y, x = 1, y = 0, z = 0)) # With normals
</code></pre>

<hr>
<h2 id='ageControl'>
Set attributes of vertices based on their age
</h2><span id='topic+ageControl'></span>

<h3>Description</h3>

<p>This is a function to produce actions in response to
a <code><a href="#topic+playwidget">playwidget</a></code> or Shiny input control.  The
mental model is that each of the vertices of some object has
a certain birth time; a control sets the current time, so that
vertices have ages depending on the control setting.
Attributes of those vertices can then be changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ageControl(births, ages, objids = tagged3d(tags), tags, value = 0,
           colors = NULL, alpha = NULL, radii = NULL, vertices = NULL,
           normals = NULL, origins = NULL, texcoords = NULL,
           x = NULL, y = NULL, z = NULL,
           red = NULL, green = NULL, blue = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ageControl_+3A_births">births</code></td>
<td>
<p>Numeric birth times of vertices.</p>
</td></tr>
<tr><td><code id="ageControl_+3A_ages">ages</code></td>
<td>
<p>Chosen ages at which the following attributes
will apply.</p>
</td></tr>
<tr><td><code id="ageControl_+3A_objids">objids</code></td>
<td>
<p>Object ids to which the changes apply.</p>
</td></tr>
<tr><td><code id="ageControl_+3A_tags">tags</code></td>
<td>

<p>Alternate way to specify <code>objids</code>.  Ignored if <code>objids</code> is
given.
</p>
</td></tr>
<tr><td><code id="ageControl_+3A_value">value</code></td>
<td>
<p>Initial value; typically overridden by input.</p>
</td></tr>
<tr><td><code id="ageControl_+3A_colors">colors</code>, <code id="ageControl_+3A_alpha">alpha</code>, <code id="ageControl_+3A_radii">radii</code>, <code id="ageControl_+3A_vertices">vertices</code>, <code id="ageControl_+3A_normals">normals</code>, <code id="ageControl_+3A_origins">origins</code>, <code id="ageControl_+3A_texcoords">texcoords</code></td>
<td>

<p>Attributes of the vertices that can be changed.  There should be
one entry or row for each entry in <code>ages</code>.</p>
</td></tr>
<tr><td><code id="ageControl_+3A_x">x</code>, <code id="ageControl_+3A_y">y</code>, <code id="ageControl_+3A_z">z</code>, <code id="ageControl_+3A_red">red</code>, <code id="ageControl_+3A_green">green</code>, <code id="ageControl_+3A_blue">blue</code></td>
<td>
<p>These one-dimensional
components of vertices and colors are provided for convenience.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All attributes must have the same number of entries (rows for the matrices)
as the ages vector. The births vector must have the same number of entries as
the number of vertices in the object.
</p>
<p>Not all objects contain all attributes; if one is chosen that is
not a property of the corresponding object, a Javascript <code>alert()</code> will be
generated.  (This restriction may be removed in the future by attempting
to add the attribute when it makes sense.)
</p>
<p>If a <code>births</code> entry is <code>NA</code>, no change will be made to that
vertex.
</p>


<h3>Value</h3>

<p>A list of class <code>"rglControl"</code> of cleaned up parameter
values, to be used in an RGL widget.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  saveopts &lt;- options(rgl.useNULL = TRUE)

  theta &lt;- seq(0, 4*pi, length.out = 100)
  xyz &lt;- cbind(sin(theta), cos(theta), sin(theta/2))
  lineid &lt;- plot3d(xyz, type="l", alpha = 0, lwd = 5, col = "blue")["data"]

  widget &lt;- rglwidget() %&gt;%
  playwidget(ageControl(births = theta,
                        ages = c(-4*pi, -4*pi, 1-4*pi, 0, 0, 1),
                        objids = lineid,
                        alpha = c(0, 1, 0, 0, 1, 0)),
             start = 0, stop = 4*pi,
             step = 0.1, rate = 4)
  if (interactive() || in_pkgdown_example())
    widget
  options(saveopts)
</code></pre>

<hr>
<h2 id='all.equal.mesh3d'>
Compare mesh3d objects in a meaningful way.
</h2><span id='topic+all.equal.mesh3d'></span><span id='topic+compare_proxy.mesh3d'></span>

<h3>Description</h3>

<p>These functions allow comparison of mesh3d objects, ignoring
irrelevant differences.  
</p>
<p><code>compare_proxy.mesh3d</code> can function as a <code>compare_proxy</code> method for the
<span class="pkg">waldo</span> package, by stripping out <code>NULL</code> components
and ordering other components alphabetically by name.
</p>
<p><code>all.equal.mesh3d</code> compares mesh3d objects by using
<code>compare_proxy.mesh3d</code> to standardize them, then
using the regular <code><a href="base.html#topic+all.equal">all.equal</a></code> function to
compare them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mesh3d'
all.equal(target, current, ...)
compare_proxy.mesh3d(x, path = "x")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.mesh3d_+3A_target">target</code>, <code id="all.equal.mesh3d_+3A_current">current</code></td>
<td>

<p>Two mesh3d objects to compare.  
</p>
</td></tr>
<tr><td><code id="all.equal.mesh3d_+3A_x">x</code></td>
<td>

<p>A single mesh3d object to standardize.
</p>
</td></tr>
<tr><td><code id="all.equal.mesh3d_+3A_path">path</code></td>
<td>

<p>The string to use in a <span class="pkg">waldo</span> display of this object.
</p>
</td></tr>
<tr><td><code id="all.equal.mesh3d_+3A_...">...</code></td>
<td>

<p>Additional parameters to pass to <code><a href="base.html#topic+all.equal">all.equal</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>all.equal.mesh3d</code> returns <code>TRUE</code>, or a character
vector describing (some of) the differences.
</p>
<p><code>compare_proxy.mesh3d</code> returns a list containing two
components:
</p>

<dl>
<dt>object</dt><dd><p>a copy of <code>x</code> with
relevant components in alphabetical order.</p>
</dd>
<dt>path</dt><dd><p>a modification of the path label for <code>x</code></p>
</dd>
</dl>



<h3>Note</h3>

<p><span class="pkg">waldo</span> is not an installation requirement for <span class="pkg">rgl</span>
and <span class="pkg">rgl</span> will never cause it to be loaded.
The <code>compare_proxy.mesh3d</code> function will only be 
registered as a method for <code>waldo::compare_proxy</code>
if you load <span class="pkg">waldo</span> before <span class="pkg">rgl</span>, as would normally 
happen during testing using <span class="pkg">testthat</span>, or if you load
it before calling <code><a href="#topic+mesh3d">mesh3d</a></code>,
as might happen if you are doing manual tests.
</p>

<hr>
<h2 id='arc3d'>
Draw arcs
</h2><span id='topic+arc3d'></span>

<h3>Description</h3>

<p>Given starting and ending points on a sphere and the center of the
sphere, draw the
great circle arc between the starting and ending points.  If
the starting and ending points have different radii, a segment of a
logarithmic spiral will join them, unless they are in the same
direction, in which case a straight line will join them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arc3d(from, to, center, radius, n, circle = 50, base = 0,
plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arc3d_+3A_from">from</code></td>
<td>

<p>One or more points from which to start arcs.
</p>
</td></tr>
<tr><td><code id="arc3d_+3A_to">to</code></td>
<td>

<p>One or more destination points.
</p>
</td></tr>
<tr><td><code id="arc3d_+3A_center">center</code></td>
<td>

<p>One or more center points.
</p>
</td></tr>
<tr><td><code id="arc3d_+3A_radius">radius</code></td>
<td>

<p>If not missing, a vector of length <code>n</code> giving the
radii at each point between <code>from</code> and <code>to</code>.
If missing, the starting and ending points will be joined by
a logarithmic spiral.
</p>
</td></tr>
<tr><td><code id="arc3d_+3A_n">n</code></td>
<td>

<p>If not missing, how many segments to use between the first and last point.  If missing, a value will be calculated based on the
angle between starting and ending points as seen from the center.
</p>
</td></tr>
<tr><td><code id="arc3d_+3A_circle">circle</code></td>
<td>

<p>How many segments would be used if the arc went completely around
a circle.
</p>
</td></tr>
<tr><td><code id="arc3d_+3A_base">base</code></td>
<td>

<p>See Details below.
</p>
</td></tr>
<tr><td><code id="arc3d_+3A_plot">plot</code></td>
<td>

<p>Should the arcs be plotted, or returned as a matrix?
</p>
</td></tr>
<tr><td><code id="arc3d_+3A_...">...</code></td>
<td>

<p>Additional parameters to pass to <code><a href="#topic+points3d">points3d</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If any of <code>from</code>, <code>to</code> or <code>center</code> is an n by 3
matrix with n &gt; 1, multiple arcs will be drawn by recycling
each of these parameters to the number of rows of the longest
one.
</p>
<p>If the vector lengths of <code>from - center</code> and
<code>to - center</code> differ, then instead of a spherical
arc, the function will draw a segment of a logarithmic spiral joining
the two points.
</p>
<p>By default, the arc is drawn along the shortest great 
circle path from <code>from</code> to <code>to</code>, but the
<code>base</code> parameter can be used to modify this.  
If <code>base = 1</code> is used, the longer arc will be followed.
Larger positive integer values will result in <code>base - 1</code>
loops in that direction completely around the sphere.  
Negative values will draw the curve in the same direction
as the shortest arc, but with <code>abs(base)</code> full loops.
It doesn't make much sense to ask for such loops unless
the radii of <code>from</code> and <code>to</code> differ, because
spherical arcs would overlap.
Normally the <code>base</code> parameter is left at its default
value of <code>0</code>.  
</p>
<p>When <code>base</code> is non-zero, the curve will be constructed in multiple
pieces, between <code>from</code>, <code>to</code>, <code>-from</code> and <code>-to</code>,
for as many steps as necessary.  If <code>n</code> is specified, it
will apply to each of these pieces.
</p>


<h3>Value</h3>

<p>If <code>plot = TRUE</code>, called mainly for the side effect of drawing arcs.  Invisibly
returns the object ID of the collection of arcs. 
</p>
<p>If <code>plot = FALSE</code>, returns a 3 column matrix containing
the points that would be drawn as the arcs.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalize &lt;- function(v) v/sqrt(sum(v^2))

# These vectors all have the same length

from &lt;- t(apply(matrix(rnorm(9), ncol = 3), 1, normalize))
to &lt;- normalize(rnorm(3))
center &lt;- c(0, 0, 0)

open3d()
spheres3d(center, radius = 1, col = "white", alpha = 0.2)

arc3d(from, to, center, col = "red")
arc3d(from, 2*to, center, col = "blue")

text3d(rbind(from, to, center, 2*to), 
       texts = c(paste0("from", 1:3), "to", "center", "2*to"),
       depth_mask = FALSE, depth_test = "always")
</code></pre>

<hr>
<h2 id='arrow3d'>
Draw an arrow
</h2><span id='topic+arrow3d'></span>

<h3>Description</h3>

<p>Draws various types of arrows in a scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrow3d(p0 = c(1, 1, 1), p1 = c(0, 0, 0), 
        barblen, s = 1/3, theta = pi/12, 
        type = c("extrusion", "lines", "flat", "rotation"), 
        n = 3, width = 1/3, thickness = 0.618 * width, 
        spriteOrigin = NULL, 
        plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrow3d_+3A_p0">p0</code></td>
<td>

<p>The base of the arrow.
</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_p1">p1</code></td>
<td>

<p>The head of the arrow.
</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_barblen">barblen</code></td>
<td>

<p>The length of the barbs (in display coordinates).
Default given by <code>s</code>.
</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_s">s</code></td>
<td>

<p>The length of the barbs as a fraction of line length.  Ignored if <code>barblen</code> is present.
</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_theta">theta</code></td>
<td>

<p>Opening angle of barbs
</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_type">type</code></td>
<td>

<p>Type of arrow to draw.  Choose one from the list
of defaults.  Can be abbreviated.  See below.
</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_n">n</code></td>
<td>

<p>Number of barbs.
</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_width">width</code></td>
<td>

<p>Width of shaft as fraction of barb width.
</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_thickness">thickness</code></td>
<td>

<p>Thickness of shaft as fraction of barb width.
</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_spriteorigin">spriteOrigin</code></td>
<td>

<p>If arrow is to be replicated as sprites, the origins relative
to which the sprites are drawn.
</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_plot">plot</code></td>
<td>

<p>If <code>TRUE</code> (the default), plot the object;
otherwise return the computed data that
would be used to plot it.
</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_...">...</code></td>
<td>

<p>Material properties passed to <code><a href="#topic+polygon3d">polygon3d</a></code>, <code><a href="#topic+shade3d">shade3d</a></code> or <code><a href="#topic+segments3d">segments3d</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four types of arrows can be drawn.  The shapes
of all of them are affected by <code>p0</code>, <code>p1</code>, <code>barblen</code>,
<code>s</code>, <code>theta</code>, material properties
in <code>...</code>, and <code>spriteOrigin</code>.  Other parameters 
only affect some of the types, as shown.
</p>

<dl>
<dt><code>"extrusion"</code></dt><dd><p>(default) A 3-dimensional
flat arrow, drawn with <code><a href="#topic+shade3d">shade3d</a></code>.  Affected by <code>width</code>, <code>thickness</code> and
<code>smooth</code>.</p>
</dd>
<dt><code>"lines"</code></dt><dd><p>Drawn with lines, similar to <code><a href="graphics.html#topic+arrows">arrows</a></code>, drawn with <code><a href="#topic+segments3d">segments3d</a></code>.  Affected by <code>n</code>.</p>
</dd>
<dt><code>"flat"</code></dt><dd><p>A flat arrow, drawn with <code><a href="#topic+polygon3d">polygon3d</a></code>.  Affected by <code>width</code> and <code>smooth</code>.</p>
</dd>
<dt><code>"rotation"</code></dt><dd><p>A solid of rotation, 
drawn with <code><a href="#topic+shade3d">shade3d</a></code>.  Affected by 
<code>n</code> and <code>width</code>.</p>
</dd>
</dl>

<p>Normally this function draws just one arrow from
<code>p0</code> to <code>p1</code>, but
if <code>spriteOrigin</code> is given (in any form
that <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a>(spriteOrigin)</code> can
handle), arrows will be drawn for each point
specified, with <code>p0</code> and <code>p1</code> 
interpreted relative to those origins.  The
arrows will be drawn as 3D sprites which will
maintain their orientation as the scene is rotated, so this is a good way to indicate
particular locations of interest in the scene.
</p>


<h3>Value</h3>

<p>If <code>plot = TRUE</code> (the default), this is
called mainly for the side effect of drawing
the arrow; invisibly returns the id(s) of 
the objects drawn.
</p>
<p>If <code>plot = FALSE</code>, the data that would be
used in the plot (not including material
properties) is returned.
</p>


<h3>Author(s)</h3>

<p>Design based on <code>heplots::arrow3d</code>, which contains modifications by Michael Friendly
to a function posted by Barry Rowlingson to R-help on 1/10/2010.  Additions by Duncan Murdoch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyz &lt;- matrix(rnorm(300), ncol = 3)
plot3d(xyz)
arrow3d(xyz[1,], xyz[2,], type = "extrusion", col = "red")
arrow3d(xyz[3,], xyz[4,], type = "flat",      col = "blue")
arrow3d(xyz[5,], xyz[6,], type = "rotation",  col = "green")
arrow3d(xyz[7,], xyz[8,], type = "lines",     col = "black")
arrow3d(spriteOrigin = xyz[9:12,],            col = "purple")
</code></pre>

<hr>
<h2 id='as.mesh3d'>
Convert object to mesh object
</h2><span id='topic+as.mesh3d'></span><span id='topic+as.mesh3d.default'></span>

<h3>Description</h3>

<p>The <code>as.mesh3d</code> generic function converts various objects
to <code><a href="#topic+mesh3d">mesh3d</a></code> objects.  
</p>
<p>The default method takes takes a matrix of vertices 
as input and (optionally) merges repeated vertices, producing a <code><a href="#topic+mesh3d">mesh3d</a></code>
object as output.  It will contain either triangles or quads or segments or points
according to the <code>type</code> argument.
</p>
<p>If the generic is called without any argument, it will pass
all RGL ids from the current scene to the 
<code><a href="#topic+as.mesh3d.rglId">as.mesh3d.rglId</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.mesh3d(x, ...)
## Default S3 method:
as.mesh3d(x, y = NULL, z = NULL, 
             type = c("triangles", "quads", "segments", "points"),
             smooth = FALSE, 
             tolerance = sqrt(.Machine$double.eps), 
             notEqual = NULL, 
             merge = TRUE,
             ...,
             triangles)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mesh3d_+3A_x">x</code>, <code id="as.mesh3d_+3A_y">y</code>, <code id="as.mesh3d_+3A_z">z</code></td>
<td>

<p>For the generic, <code>x</code> is the object to convert.
For the default method, <code>x</code>, <code>y</code> and <code>z</code> are
coordinates. Any reasonable way of defining the coordinates is
acceptable. See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code> for details.
</p>
</td></tr>
<tr><td><code id="as.mesh3d_+3A_type">type</code></td>
<td>

<p>What type of things should be in the mesh?  Tries
this list in order until it finds one that works.
</p>
</td></tr>
<tr><td><code id="as.mesh3d_+3A_smooth">smooth</code></td>
<td>

<p>If <code>TRUE</code>, <code><a href="#topic+addNormals">addNormals</a></code> will be called on the mesh
object to make it render smoothly.
</p>
</td></tr>  
<tr><td><code id="as.mesh3d_+3A_tolerance">tolerance</code></td>
<td>

<p>The numerical tolerance to be used in <code><a href="base.html#topic+all.equal">all.equal</a></code> to
determine whether two vertices should be merged.
</p>
</td></tr>
<tr><td><code id="as.mesh3d_+3A_notequal">notEqual</code></td>
<td>

<p>If not <code>NULL</code>, an n by n matrix of logical values, where n is the
number of vertices as input.  <code>TRUE</code> entries indicate that the
corresponding pair of vertices should not be merged even if they appear equal.
</p>
</td></tr>
<tr><td><code id="as.mesh3d_+3A_merge">merge</code></td>
<td>

<p>Should apparently equal vertices be merged?
</p>
</td></tr>
<tr><td><code id="as.mesh3d_+3A_...">...</code></td>
<td>

<p>Material properties to pass to <code><a href="#topic+tmesh3d">tmesh3d</a></code> or <code><a href="#topic+qmesh3d">qmesh3d</a></code>.
</p>
</td></tr>
<tr><td><code id="as.mesh3d_+3A_triangles">triangles</code></td>
<td>

<p>Deprecated.  If present, <code>TRUE</code> indicates <code>type = "triangles"</code> and <code>FALSE</code> indicates <code>type = "quads"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The motivation for this function is the following problem:  I was
asked whether RGL could render a surface made up of triangles or 
quadrilaterals to look smooth.  It can do that, but needs normals at 
each vertex; they should be the average of the normals for each polygon 
sharing that vertex.  Then OpenGL will interpolate the normals across 
the polygons and give the illusion of smoothness.
</p>
<p>To do this, it needs to know which polygons share each vertex.  If the 
surface is described as a list of triangles or quadrilaterals, that 
means identifying vertices that are in multiple polygons, and converting 
the representation to a <code>"<a href="#topic+mesh3d">mesh3d</a>"</code> object (which is a matrix of vertices 
and a matrix of vertex numbers making up triangles or quads).  Then the 
<code><a href="#topic+addNormals">addNormals</a></code> function will add the normals.
</p>
<p>Sometimes two polygons will share vertices (within numerical 
tolerance) without the user wanting them to be considered internal to 
the surface, or might want one sharp edge in an otherwise smooth 
surface.  This means I needed a way to declare that two vertices from 
the original list of vertices in the triangles or quads are &quot;not equal&quot;, 
even when they test numerically equal.  That's what the <code>notEqual</code> matrix specifies.
</p>


<h3>Value</h3>

<p>A <code>"<a href="#topic+mesh3d">mesh3d</a>"</code> object with the same faces as in the 
input, but (if <code>merge=TRUE</code>) with vertices that test equal to
within <code>tolerance</code> merged.  
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyz &lt;- matrix(c(-1, -1, -1,
                -1,  1, -1,
                 1,  1, -1,
                 1, -1, -1,
                -1,  1, -1,
                -1,  1,  1,
                 1,  1,  1,
                 1,  1, -1,
                 1, -1, -1,
                 1,  1, -1,
                 1,  1,  1,
                 1, -1,  1), byrow = TRUE, ncol = 3)
mesh &lt;- as.mesh3d(xyz, type = "quads", col = "red")
mesh$vb
mesh$ib
open3d()
shade3d(mesh)

# Stop vertices 2 and 5 from being merged
notEQ &lt;- matrix(FALSE, 12, 12)
notEQ[2, 5] &lt;- TRUE
mesh &lt;- as.mesh3d(xyz, type = "quads", notEqual = notEQ)
mesh$vb
mesh$ib
</code></pre>

<hr>
<h2 id='as.mesh3d.ashape3d'>
Convert alpha-shape surface of a cloud of points to
RGL mesh object
</h2><span id='topic+as.mesh3d.ashape3d'></span>

<h3>Description</h3>

<p>The <code><a href="alphashape3d.html#topic+ashape3d">alphashape3d::ashape3d</a></code>
function computes the
3D <code class="reqn">\alpha</code>-shape of a cloud of points. This is an approximation
to the visual outline of the cloud.  It may include isolated
points, line segments, and triangular faces:  this function
converts the triangular faces to an RGL <code><a href="#topic+tmesh3d">tmesh3d</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ashape3d'
as.mesh3d(x, 
                   alpha = x$alpha[1], 
                   tri_to_keep = 2L,
                   col = "gray", 
                   smooth = FALSE, normals = NULL,
                   texcoords = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mesh3d.ashape3d_+3A_x">x</code></td>
<td>

<p>An object of class <code>"ashape3d"</code>.
</p>
</td></tr>
<tr><td><code id="as.mesh3d.ashape3d_+3A_alpha">alpha</code></td>
<td>

<p>Which <code>alpha</code> value stored in <code>x</code> should be converted?
</p>
</td></tr>
<tr><td><code id="as.mesh3d.ashape3d_+3A_tri_to_keep">tri_to_keep</code></td>
<td>

<p>Which triangles to keep.  Expert use only:  see <code>triang</code>
entry in <b>Value</b> section of <a href="alphashape3d.html#topic+ashape3d">ashape3d</a>
for details.
</p>
</td></tr>
<tr><td><code id="as.mesh3d.ashape3d_+3A_col">col</code></td>
<td>

<p>The surface colour.
</p>
</td></tr>
<tr><td><code id="as.mesh3d.ashape3d_+3A_smooth">smooth</code></td>
<td>

<p>Whether to attempt to add normals to make the surface
look smooth.  See the Details below.
</p>
</td></tr>
<tr><td><code id="as.mesh3d.ashape3d_+3A_normals">normals</code>, <code id="as.mesh3d.ashape3d_+3A_texcoords">texcoords</code></td>
<td>

<p>Normals and texture coordinates at each vertex can be specified.
</p>
</td></tr>
<tr><td><code id="as.mesh3d.ashape3d_+3A_...">...</code></td>
<td>

<p>Additional arguments to pass to use as <code><a href="#topic+material3d">material3d</a></code> properties on the resulting mesh.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Edelsbrunner and Mucke's (1994) <code class="reqn">\alpha</code>-shape algorithm is 
intended to compute a surface of a general cloud of points.
Unlike the convex hull, the cloud may have voids, isolated points, and other oddities.  This function is designed to 
work in the case where the surface is made up of 
simple polygons.
</p>
<p>If <code>smooth = TRUE</code>, this method attempts to orient all
of the triangles in the surface consistently and add normals
at each vertex by averaging the triangle normals.  
However, for some point clouds, the <code class="reqn">\alpha</code>-shape will contain 
sheets of polygons with a few solid polyhedra embedded.
This does not allow a consistent definition of &quot;inside&quot;
and outside.  If this is detected, a warning is issued
and the resulting mesh will likely contain boundaries
where the assumed orientation of triangles changes, resulting
in ugly dark lines through the shape.  Larger values
of <code>alpha</code> in the call to <code><a href="alphashape3d.html#topic+ashape3d">alphashape3d::ashape3d</a></code> may help.
</p>
<p>Methods for <code><a href="#topic+plot3d">plot3d</a></code> and <code><a href="#topic+persp3d">persp3d</a></code>
are also defined:  they call the <code><a href="#topic+as.mesh3d">as.mesh3d</a></code> method and then plot the result.  
</p>


<h3>Value</h3>

<p>A <code>"mesh3d"</code> object, suitable for plotting.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>Edelsbrunner, H., Mucke, E. P. (1994). Three-Dimensional Alpha Shapes. ACM Transactions on Graphics, 13(1), pp.43-72.
</p>
<p>Lafarge, T. and Pateiro-Lopez, B. (2017).
alphashape3d: Implementation of the 3D Alpha-Shape
for the Reconstruction of 3D Sets from a Point Cloud.
R package version 1.3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("alphashape3d", quietly = TRUE)) {
  set.seed(123)
  n &lt;- 400    # 1000 gives a nicer result, but takes longer
  xyz &lt;- rbind(cbind(runif(n), runif(n), runif(n)),
               cbind(runif(n/8, 1, 1.5), 
                     runif(n/8, 0.25, 0.75), 
                     runif(n/8, 0.25, 0.75)))
  ash &lt;- suppressMessages(alphashape3d::ashape3d(xyz, alpha = 0.2))
  m &lt;- as.mesh3d(ash, smooth = TRUE)
  open3d()
  mfrow3d(1, 2, sharedMouse = TRUE)
  plot3d(xyz, size = 1)
  plot3d(m, col = "red", alpha = 0.5)
  points3d(xyz, size = 1)
}
</code></pre>

<hr>
<h2 id='as.mesh3d.rglId'>
Convert object in plot to RGL mesh object
</h2><span id='topic+as.mesh3d.rglId'></span>

<h3>Description</h3>

<p>This method attempts to read the attributes of objects in the
rgl display and construct a mesh3d object to approximate them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rglId'
as.mesh3d(x, type = NA, subscene = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mesh3d.rglId_+3A_x">x</code></td>
<td>

<p>A vector of RGL identifiers of objects in the specified subscene.
</p>
</td></tr>
<tr><td><code id="as.mesh3d.rglId_+3A_type">type</code></td>
<td>

<p>A vector of names of types of shapes to convert.  Other shapes 
will be ignored.
</p>
</td></tr>
<tr><td><code id="as.mesh3d.rglId_+3A_subscene">subscene</code></td>
<td>

<p>Which subscene to look in; the default <code>NA</code> specifies the 
current subscene.
</p>
</td></tr>
<tr><td><code id="as.mesh3d.rglId_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts to construct a triangle mesh to approximate 
one or more objects from the current display.  It can handle objects of types from <code>c("points", "lines", "linestrip", "triangles", "quads", "planes", "surface")</code>.
</p>
<p>Since this method only produces meshes containing points,
segments and triangles, they won't necessarily
be an exact match to the original object.
</p>
<p>If the generic <code><a href="#topic+as.mesh3d">as.mesh3d</a></code> is called with no <code>x</code>
argument, this method will be called with <code>x</code> set to the 
ids in the current scene.  
</p>


<h3>Value</h3>

<p>A mesh object.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.triangles3d.rglId">as.triangles3d.rglId</a></code> for extracting the triangles,
<code><a href="#topic+clipMesh3d">clipMesh3d</a></code> to apply complex clipping to a mesh object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># volcano example taken from "persp"
#
data(volcano)

z &lt;- 2 * volcano        # Exaggerate the relief

x &lt;- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
y &lt;- 10 * (1:ncol(z))   # 10 meter spacing (E to W)

zlim &lt;- range(y)
zlen &lt;- zlim[2] - zlim[1] + 1

colorlut &lt;- terrain.colors(zlen) # height color lookup table

col &lt;- colorlut[ z - zlim[1] + 1 ] # assign colors to heights for each point

open3d(useNULL = TRUE)
surface3d(x, y, z, color = col)
m &lt;- as.mesh3d()
close3d()

open3d()
shade3d(m)
</code></pre>

<hr>
<h2 id='as.rglscene'>
Convert an object to an <code>rglscene</code> object.
</h2><span id='topic+as.rglscene'></span>

<h3>Description</h3>

<p>This is a placeholder generic function, to allow other
packages to create <code>"rglscene"</code> objects compatible with
the objects produced by <code><a href="#topic+scene3d">scene3d</a></code>.
</p>
<p>No methods are currently defined in <span class="pkg">rgl</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.rglscene(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.rglscene_+3A_x">x</code></td>
<td>

<p>Object to convert.
</p>
</td></tr>
<tr><td><code id="as.rglscene_+3A_...">...</code></td>
<td>

<p>Other parameters to pass to methods.
</p>
</td></tr>
</table>

<hr>
<h2 id='as.tmesh3d'>
Convert object to a triangular mesh
</h2><span id='topic+as.tmesh3d'></span><span id='topic+as.tmesh3d.default'></span><span id='topic+as.tmesh3d.mesh3d'></span>

<h3>Description</h3>

<p>Converts the quads in a mesh version of an object to
triangles by splitting them up.  Optionally drops any
point or segment components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.tmesh3d(x, ...)
## Default S3 method:
as.tmesh3d(x, drop = FALSE, ...)
## S3 method for class 'mesh3d'
as.tmesh3d(x, drop = FALSE, keepTags = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.tmesh3d_+3A_x">x</code></td>
<td>

<p>An object from which to create a triangular mesh object.
</p>
</td></tr>
<tr><td><code id="as.tmesh3d_+3A_drop">drop</code></td>
<td>

<p>If <code>TRUE</code>, drop any point or segment components.
</p>
</td></tr>
<tr><td><code id="as.tmesh3d_+3A_keeptags">keepTags</code></td>
<td>

<p>Whether to include the <code>"tags"</code> component in the output.
</p>
</td></tr>
<tr><td><code id="as.tmesh3d_+3A_...">...</code></td>
<td>

<p>Ignored in the <code>mesh3d</code> method, passed to 
<code>as.mesh3d</code> in the default method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method simply calls <code><a href="#topic+as.mesh3d">as.mesh3d</a>(x, ...)</code>
and passes the result to the <code>"mesh3d"</code> method.
</p>


<h3>Value</h3>

<p>A <code>"mesh3d"</code> object containing no quads.  If <code>drop = TRUE</code>, it will only contain triangles.  
</p>
<p>If <code>keepTags = TRUE</code>, a <code>"tags"</code> element will be 
added to the result.  For details, see the <code><a href="#topic+clipMesh3d">clipMesh3d</a></code>
help page.
</p>


<h3>Note</h3>

<p>Older versions of <span class="pkg">rgl</span> had a <code>"tmesh3d"</code> class
for meshes of triangles.  That class is no longer used:
<code>as.tmesh3d</code> and <code><a href="#topic+tmesh3d">tmesh3d</a></code> both produce
<code>"mesh3d"</code> objects.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code>as.triangles3d</code> to get just the coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cuboctahedron3d()
x             # has quads and triangles
as.tmesh3d(x) # has only triangles
</code></pre>

<hr>
<h2 id='as.triangles3d'>
Convert an object to triangles
</h2><span id='topic+as.triangles3d'></span><span id='topic+as.triangles3d.rglId'></span>

<h3>Description</h3>

<p>This generic and its methods extract or creates a matrix of coordinates
of triangles from an object, suitable for passing to <code><a href="#topic+triangles3d">triangles3d</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.triangles3d(obj, ...)
## S3 method for class 'rglId'
as.triangles3d(obj,
               attribute = c("vertices", "normals", "texcoords", "colors"),
               subscene = NA,
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.triangles3d_+3A_obj">obj</code></td>
<td>

<p>The object to convert.
</p>
</td></tr>
<tr><td><code id="as.triangles3d_+3A_attribute">attribute</code></td>
<td>
<p>Which attribute of an RGL object to extract?</p>
</td></tr>
<tr><td><code id="as.triangles3d_+3A_subscene">subscene</code></td>
<td>
<p>Which subscene is this object in?</p>
</td></tr>
<tr><td><code id="as.triangles3d_+3A_...">...</code></td>
<td>

<p>Additional arguments used by the methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for <code>"rglId"</code> objects can extract several different
attributes, organizing them as it would organize the vertices for
the triangles.
</p>


<h3>Value</h3>

<p>An <code>n x 3</code> matrix containing the vertices of triangles making
up the object.  Each successive 3 rows of the matrix corresponds to
a triangle.
</p>
<p>If the attribute doesn't exist, <code>NULL</code> will be returned.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.mesh3d">as.mesh3d</a></code> to also capture material properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
x &lt;- surface3d(x = 1:10, y = 1:10, z = rnorm(100), col = "red")
tri &lt;- as.triangles3d(x)
open3d()
triangles3d(tri, col = "blue")
</code></pre>

<hr>
<h2 id='aspect3d'>Set the aspect ratios of the current plot</h2><span id='topic+aspect3d'></span>

<h3>Description</h3>

<p>This function sets the apparent ratios of the x, y, and z axes
of the current bounding box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aspect3d(x, y = NULL, z = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aspect3d_+3A_x">x</code></td>
<td>
<p>The ratio for the x axis, or all three ratios, or <code>"iso"</code> </p>
</td></tr>
<tr><td><code id="aspect3d_+3A_y">y</code></td>
<td>
<p>The ratio for the y axis </p>
</td></tr>
<tr><td><code id="aspect3d_+3A_z">z</code></td>
<td>
<p>The ratio for the z axis </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the ratios are all 1, the bounding box will be displayed as a cube approximately filling the display.
Values may be set larger or smaller as desired.  Aspect <code>"iso"</code> signifies that the
coordinates should all be displayed at the same scale, i.e. the bounding box should not be
rescaled.  (This corresponds to the default display before <code>aspect3d</code> has been called.)
Partial matches to <code>"iso"</code> are allowed.
</p>
<p><code>aspect3d</code> works by modifying <code>par3d("scale")</code>.
</p>


<h3>Value</h3>

<p>The previous value of the scale is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3d">plot3d</a></code>, <code><a href="#topic+par3d">par3d</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(100)
  y &lt;- rnorm(100)*2
  z &lt;- rnorm(100)*3
  
  open3d()
  plot3d(x, y, z)
  aspect3d(1, 1, 0.5)
  highlevel()  # To trigger display
  open3d()
  plot3d(x, y, z)
  aspect3d("iso")
  highlevel()
</code></pre>

<hr>
<h2 id='asRow'>
Convenience functions for RGL HTML layouts
</h2><span id='topic+asRow'></span><span id='topic+getWidgetId'></span>

<h3>Description</h3>

<p>The <code>asRow</code> function arranges objects in a row in the display;
the <code>getWidgetId</code> function extracts the HTML element ID
from an HTML widget.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asRow(..., last = NA, height = NULL, colsize = 1)
getWidgetId(widget)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asRow_+3A_...">...</code></td>
<td>

<p>Either a single <code>"combineWidgets"</code> object produced by
<code>asRow</code> or a <code>%&gt;%</code> pipe of RGL objects, 
or several objects intended for rearrangement.
</p>
</td></tr>
<tr><td><code id="asRow_+3A_last">last</code></td>
<td>

<p>If not <code>NA</code>, the number of objects from <code>...</code> that
are to be arranged in a row.  Earlier ones will remain in a column.
</p>
</td></tr>
<tr><td><code id="asRow_+3A_height">height</code></td>
<td>

<p>An optional height for the resulting row.  This is normally specified
in pixels, but will be rescaled as necessary to fit the display.
</p>
</td></tr>
<tr><td><code id="asRow_+3A_colsize">colsize</code></td>
<td>

<p>A vector of relative widths for the columns in the row.
</p>
</td></tr>
<tr><td><code id="asRow_+3A_widget">widget</code></td>
<td>

<p>A single HTML widget from which to extract the HTML element ID.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>asRow</code> requires that the <span class="pkg">manipulateWidget</span>
package is installed.
</p>
<p><code>asRow</code> produces a <code>"combineWidgets"</code> object which
is a single column whose last element is another <code>"combineWidgets"</code> object which is a single row.
</p>
<p>If <code>n</code> objects are given as input and <code>last</code> is given a value
less than <code>n</code>, the first <code>n - last</code> objects will be displayed
in a column above the row containing the <code>last</code> objects.
</p>


<h3>Value</h3>

<p><code>asRow</code> returns a single <code>"combineWidgets"</code> object suitable for display or nesting
within a more complicated display.
</p>
<p><code>getWidgetId</code> returns a character string containing the 
HTML element ID of the widget.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><a href="#topic+pipe">pipe</a> for the <code>%&gt;%</code> operator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("manipulateWidget", quietly = TRUE) &amp;&amp;
    require("crosstalk", quietly = TRUE)) {
  sd &lt;- SharedData$new(mtcars)
  ids &lt;- plot3d(sd$origData(), col = mtcars$cyl, type = "s")
  # Copy the key and group from existing shared data
  rglsd &lt;- rglShared(ids["data"], key = sd$key(), group = sd$groupName())
  w &lt;- rglwidget(shared = rglsd) %&gt;%
       asRow("Mouse mode: ", rglMouse(getWidgetId(.)), 
             "Subset: ", filter_checkbox("cylinderselector", 
		               "Cylinders", sd, ~ cyl, inline = TRUE),
             last = 4, colsize = c(1,2,1,2), height = 60)
  if (interactive() || in_pkgdown_example())
    w
}
</code></pre>

<hr>
<h2 id='axes3d'> Draw boxes, axes and other text outside the data </h2><span id='topic+axes3d'></span><span id='topic+axis3d'></span><span id='topic+mtext3d'></span><span id='topic+title3d'></span><span id='topic+box3d'></span>

<h3>Description</h3>

<p>These functions draw axes, boxes and text outside the range of the data.
<code>axes3d</code>, <code>box3d</code> and <code>title3d</code> are the higher level functions; 
normally the others need not be called directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axes3d(edges = "bbox", labels = TRUE, tick = TRUE, nticks = 5, 
	box = FALSE, expand = 1.03, ...)
box3d(...) 
title3d(main = NULL, sub = NULL, xlab = NULL, ylab = NULL, 
	zlab = NULL, line = NA, level = NA, floating = NULL, ...) 
axis3d(edge, at = NULL, labels = TRUE, tick = TRUE, line = 0, 
	pos = NULL, nticks = 5, ...) 
mtext3d(text, edge, at = NULL, line = 0, level = 0, 
        floating = FALSE, pos = NA, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axes3d_+3A_edges">edges</code></td>
<td>
<p> a code to describe which edge(s) of the box to use; see Details below </p>
</td></tr>
<tr><td><code id="axes3d_+3A_labels">labels</code></td>
<td>
<p> whether to label the axes, or (for <code>axis3d</code>) the
labels to use</p>
</td></tr>
<tr><td><code id="axes3d_+3A_tick">tick</code></td>
<td>
<p> whether to use tick marks </p>
</td></tr>
<tr><td><code id="axes3d_+3A_nticks">nticks</code></td>
<td>
<p> suggested number of ticks </p>
</td></tr>
<tr><td><code id="axes3d_+3A_box">box</code></td>
<td>
<p> draw the full box if <code>"bbox"</code> axes are used </p>
</td></tr>
<tr><td><code id="axes3d_+3A_expand">expand</code></td>
<td>
<p> how much to expand the box around the data </p>
</td></tr>
<tr><td><code id="axes3d_+3A_main">main</code></td>
<td>
<p> the main title for the plot </p>
</td></tr>
<tr><td><code id="axes3d_+3A_sub">sub</code></td>
<td>
<p> the subtitle for the plot </p>
</td></tr>
<tr><td><code id="axes3d_+3A_xlab">xlab</code>, <code id="axes3d_+3A_ylab">ylab</code>, <code id="axes3d_+3A_zlab">zlab</code></td>
<td>
<p> the axis labels for the plot </p>
</td></tr>
<tr><td><code id="axes3d_+3A_line">line</code>, <code id="axes3d_+3A_level">level</code></td>
<td>
<p> the &quot;line&quot; of the plot margin to draw the label on, and &quot;level&quot; above or below it  </p>
</td></tr>
<tr><td><code id="axes3d_+3A_floating">floating</code></td>
<td>
<p> which mode of axis labels? One of 
<code>TRUE</code>, <code>FALSE</code> or <code>NA</code>. (<code>NULL</code>
may also be used in <code>title3d</code> calls).
See Details for how these are handled.</p>
</td></tr>
<tr><td><code id="axes3d_+3A_edge">edge</code>, <code id="axes3d_+3A_pos">pos</code></td>
<td>
<p> the position at which to draw the axis or text </p>
</td></tr>
<tr><td><code id="axes3d_+3A_text">text</code></td>
<td>
<p> the text to draw </p>
</td></tr>
<tr><td><code id="axes3d_+3A_at">at</code></td>
<td>
<p> the value of a coordinate at which to draw the axis or labels. </p>
</td></tr>
<tr><td><code id="axes3d_+3A_...">...</code></td>
<td>
<p> additional parameters which are passed to <code><a href="#topic+bbox3d">bbox3d</a></code> or <code><a href="#topic+material3d">material3d</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rectangular prism holding the 3D plot has 12 edges.  They are identified
using 3 character strings.  The first character (&lsquo;x&rsquo;, &lsquo;y&rsquo;, or &lsquo;z&rsquo;) selects 
the direction of the axis.  The next two characters are each &lsquo;-&rsquo; or &lsquo;+&rsquo;,
selecting the lower or upper end of one of the other coordinates.  If only
one or two characters are given, the remaining characters normally default to &lsquo;-&rsquo; (but with <code>mtext3d(..., floating = TRUE)</code> the default is &lsquo;+&rsquo;; see below).  
For example <code>edge = 'x+'</code> draws an x-axis at the high level of y and the
low level of z.
</p>
<p>By default, <code>axes3d</code> uses the <code><a href="#topic+bbox3d">bbox3d</a></code> function to draw the axes.  
The labels will move so that they do not obscure the data.  Alternatively,
a vector of arguments as described above may be used, in which case
fixed axes are drawn using <code>axis3d</code>.
</p>
<p>As of <span class="pkg">rgl</span> version 0.106.21, axis drawing has changed
significantly.  Text drawn in the margins 
will
adapt to the margins (see <code><a href="#topic+bbox3d">bbox3d</a></code>).  The
<code>edge</code> and <code>floating</code> parameters will be recorded
in the <code>margin</code> and <code>floating</code> material
properties for the object.
</p>
<p>If <code>floating = FALSE</code>, they will be drawn on the
specified edge.  
</p>
<p>If <code>floating = TRUE</code>, they will
move as the axis labels move when the scene is rotated.
The signs on the edge specification are interpreted as
agreeing with the axis ticks &lsquo;+&rsquo; or disagreeing &lsquo;-&rsquo;.
For example, <code>"x++"</code> will draw text on the x axis
in the same edge as the ticks, while <code>"x--"</code> will draw
on the opposite edge.
</p>
<p>The final possible value for <code>floating</code> in <code>mtext3d</code> is
<code>NA</code>, which reproduces legacy <span class="pkg">rgl</span>
behaviour.  In
this case the labels are not tied to the bounding box,
so they should be drawn last, or they could appear inside
the box, overlapping the data.
</p>
<p>In <code>title3d</code> <code>floating = NULL</code> (the default) 
indicates the main title 
and subtitle will be fixed while the axis labels will be
floating.  The default locations for title and subtitle
are <code>line = 2</code> and 
<code>level = 2</code> on edges <code>"x++"</code> and <code>"x--"</code>
respectively.  The axis labels float at <code>line = 4</code> and <code>level = 1</code> on the same edge as the ticks.
</p>
<p>The <code>at</code> parameter in <code>axis3d</code> is the location
of the ticks, defaulting to <code><a href="base.html#topic+pretty">pretty</a></code> locations.
In <code>mtext3d</code> the <code>at</code> parameter is the location
on the specified axis
at which to draw the text, defaulting to the middle of the
bounding box.
</p>
<p>The <code>line</code> parameter is the line counting out
from the box in the same direction as the axis ticks,
and <code>level</code> is the line out in the orthogonal
direction.  The ticks run from <code>line = 0</code> to <code>line = 1</code>, and the
tick labels are drawn at <code>line = 2</code>.  Both are drawn at level 0.  
</p>
<p>The <code>pos</code> parameter is only supported in legacy mode.  If it is a numeric vector of length 3, <code>edge</code> determines
the direction of the axis and the tick marks, and the values of the
other two coordinates in <code>pos</code> determine the position.  
The <code>level</code> parameter is ignored in legacy mode.
</p>
<p>For <code>mtext3d</code> in <code>floating = TRUE</code> or <code>floating = FALSE</code> mode,
there are 3 special values for the <code>at</code> parameter: it may
be <code>-Inf</code>, <code>NA</code> or <code>+Inf</code>, referring 
to the bottom, middle or top of the given axis respectively.
</p>


<h3>Value</h3>

<p>These functions are called for their side effects.  They return the object IDs of
objects added to the scene.
</p>


<h3>Note</h3>

<p><code>mtext3d</code> is a wrapper for <code><a href="#topic+text3d">text3d</a></code>
that sets the <code>margin</code> and <code>floating</code> material
properties.  In fact, these properties can be set for many
kinds of objects (most kinds where it would make sense), 
with the effect that the object will be drawn
in the margin, with <code>x</code> coordinate corresponding to
<code>at</code>, <code>y</code> corresponding to <code>line</code>, and <code>z</code>
corresponding to <code>level</code>.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

<p>Classic graphics functions <code><a href="graphics.html#topic+axis">axis</a></code>, <code><a href="graphics.html#topic+box">box</a></code>,
<code><a href="graphics.html#topic+title">title</a></code>, <code><a href="graphics.html#topic+mtext">mtext</a></code>, and RGL function <code><a href="#topic+bbox3d">bbox3d</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  open3d()
  points3d(rnorm(10), rnorm(10), rnorm(10))

  # First add standard axes
  axes3d()  

  # and one in the middle (the NA will be ignored, a number would 
  # do as well)
  axis3d('x', pos = c(NA, 0, 0))

  # add titles
  title3d('main', 'sub', 'xlab', 'ylab', 'zlab')

  rgl.bringtotop()
  
  open3d()
  points3d(rnorm(10), rnorm(10), rnorm(10))
  
  # Use fixed axes
  
  axes3d(c('x', 'y', 'z'))
         
  # Put 4 x-axes on the plot
  axes3d(c('x--', 'x-+', 'x+-', 'x++'))         
  
  axis3d('x', pos = c(NA, 0, 0))     
  title3d('main', 'sub', 'xlab', 'ylab', 'zlab')
</code></pre>

<hr>
<h2 id='bbox3d'>Set up bounding box decoration</h2><span id='topic+bbox3d'></span>

<h3>Description</h3>

<p>Set up the bounding box decoration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbox3d(xat = NULL, yat = NULL, zat = NULL, 
	xunit = "pretty", yunit = "pretty", zunit = "pretty", 
	expand = 1.03,
	draw_front = FALSE, 
	xlab=NULL, ylab=NULL, zlab=NULL,
  xlen=5, ylen=5, zlen=5,
  marklen=15.0, marklen.rel=TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox3d_+3A_xat">xat</code>, <code id="bbox3d_+3A_yat">yat</code>, <code id="bbox3d_+3A_zat">zat</code></td>
<td>
<p>vector specifying the tickmark positions</p>
</td></tr>
<tr><td><code id="bbox3d_+3A_xlab">xlab</code>, <code id="bbox3d_+3A_ylab">ylab</code>, <code id="bbox3d_+3A_zlab">zlab</code></td>
<td>
<p>character vector specifying the tickmark labeling</p>
</td></tr>
<tr><td><code id="bbox3d_+3A_xunit">xunit</code>, <code id="bbox3d_+3A_yunit">yunit</code>, <code id="bbox3d_+3A_zunit">zunit</code></td>
<td>
<p>value specifying the tick mark base for uniform tick mark layout</p>
</td></tr>
<tr><td><code id="bbox3d_+3A_xlen">xlen</code>, <code id="bbox3d_+3A_ylen">ylen</code>, <code id="bbox3d_+3A_zlen">zlen</code></td>
<td>
<p>value specifying the number of tickmarks</p>
</td></tr>
<tr><td><code id="bbox3d_+3A_marklen">marklen</code></td>
<td>
<p>value specifying the length of the tickmarks</p>
</td></tr>
<tr><td><code id="bbox3d_+3A_marklen.rel">marklen.rel</code></td>
<td>
<p>logical, if TRUE tick mark length is calculated using 1/<code>marklen</code> * axis length, otherwise tick mark length is <code>marklen</code> in coordinate space</p>
</td></tr>
<tr><td><code id="bbox3d_+3A_expand">expand</code></td>
<td>
<p>value specifying how much to expand the bounding box around the data</p>
</td></tr>
<tr><td><code id="bbox3d_+3A_draw_front">draw_front</code></td>
<td>
<p>draw the front faces of the bounding box</p>
</td></tr>
<tr><td><code id="bbox3d_+3A_...">...</code></td>
<td>
<p>Material properties (or other <code>rgl.bbox</code> parameters
in the case of <code>bbox3d</code>). See <code><a href="#topic+material3d">material3d</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four different types of tick mark layouts are possible.
This description applies to the X axis; other axes are similar:
If <code>xat</code> is not <code>NULL</code>, the ticks are set up at custom positions.
If <code>xunit</code> is numeric but not zero, it defines the tick mark base.  If
it is <code>"pretty"</code> (the default in <code>bbox3d</code>), ticks are set at <code><a href="base.html#topic+pretty">pretty</a></code>
locations.
If <code>xlen</code> is not zero, it specifies the number of ticks
(a suggestion if <code>xunit</code> is <code>"pretty"</code>).
</p>
<p>The first color specifies the bounding box, while the second one specifies the tick mark and font color.
</p>
<p><code>bbox3d</code> defaults to <code><a href="base.html#topic+pretty">pretty</a></code> locations for the axis labels and a slightly larger
box, whereas <code>rgl.bbox</code> covers the exact range.
</p>
<p><code><a href="#topic+axes3d">axes3d</a></code> offers more flexibility in the specification of the axes, but 
they are static, unlike those drawn by <code><a href="#topic+bbox3d">bbox3d</a></code>.
</p>


<h3>Value</h3>

<p>This function is called for the side effect of setting the bounding box decoration.
A shape ID is returned to allow <code><a href="#topic+pop3d">pop3d</a></code> to delete it.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+material3d">material3d</a></code>, <code><a href="#topic+axes3d">axes3d</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  open3d()
  points3d(rnorm(100), rnorm(100), rnorm(100))
  bbox3d(color = c("#333377", "black"), emission = "#333377", 
         specular = "#3333FF", shininess = 5, alpha = 0.8)
</code></pre>

<hr>
<h2 id='bg3d'>Set up background</h2><span id='topic+bg3d'></span>

<h3>Description</h3>

<p>Set up the background of the scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bg3d(color,
    sphere=FALSE, 
    back="lines",
    fogtype="none",
    fogScale = 1, 
    col, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bg3d_+3A_color">color</code>, <code id="bg3d_+3A_col">col</code></td>
<td>

<p>See Details below.
</p>
</td></tr>
<tr><td><code id="bg3d_+3A_sphere">sphere</code></td>
<td>

<p>logical:  if <code>TRUE</code>, an environmental sphere geometry is used for the background decoration.
</p>
</td></tr>
<tr><td><code id="bg3d_+3A_back">back</code></td>
<td>

<p>Specifies the fill style of the sphere geometry. See <code><a href="#topic+material3d">material3d</a></code> for details.
</p>
</td></tr>
<tr><td><code id="bg3d_+3A_fogtype">fogtype</code></td>
<td>
<p>fog type:
</p>

<dl>
<dt>&quot;none&quot;</dt><dd><p>no fog</p>
</dd>
<dt>&quot;linear&quot;</dt><dd><p>linear fog function</p>
</dd>
<dt>&quot;exp&quot;</dt><dd><p>exponential fog function</p>
</dd>
<dt>&quot;exp2&quot;</dt><dd><p>squared exponential fog function</p>
</dd>
</dl>

<p>Fog only applies to objects with <code><a href="#topic+material3d">material3d</a></code> 
property <code>fog</code> set to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="bg3d_+3A_fogscale">fogScale</code></td>
<td>

<p>Scaling for fog.  See Details.
</p>
</td></tr>
<tr><td><code id="bg3d_+3A_...">...</code></td>
<td>
<p>Additional material properties. See <code><a href="#topic+material3d">material3d</a></code> for details.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The background color is taken from <code>color</code> or <code>col</code>
if <code>color</code> is missing.
The first entry
is used for background clearing and as the fog color.
The second (if present) is used for background sphere geometry.
</p>
<p>If <code>color</code> and <code>col</code> are both missing, the default is found in 
the <code><a href="#topic+r3dDefaults">r3dDefaults</a>$bg</code> list, or <code>"white"</code> is used
if nothing is specified there.
</p>
<p>If <code>sphere</code> is set to <code>TRUE</code>, an environmental
sphere enclosing the whole scene is drawn.
</p>
<p>If not, but the material properties include a bitmap as a texture, the bitmap is drawn in the 
background of the scene.  (The bitmap colors modify the general color setting.)
</p>
<p>If neither a sphere nor a bitmap background is drawn, the background is filled with a 
solid color.
</p>
<p>The <code>fogScale</code> parameter should be a positive value
to change the density of the fog in the plot.  For 
<code>fogtype = "linear"</code> it multiplies the density of the
fog; for the exponential fog types it multiplies the density
parameter used in the display.  
</p>
<p>See 
<a href="https://registry.khronos.org/OpenGL-Refpages/gl2.1/xhtml/glFog.xml">the OpenGL 2.1 reference</a> 
for the formulas used in the fog calculations within <span class="rlang"><b>R</b></span> (though the
<code>"exp2"</code> formula appears to be wrong, at least on my
system).  In WebGL displays,
the following rules are used.  They appear to match the
rules used in <span class="rlang"><b>R</b></span> on my system.
</p>

<ul>
<li><p>For <code>"linear"</code> fog, the near clipping plane is
taken as <code class="reqn">c=0</code>, and the 
far clipping plane is taken as <code class="reqn">c=1</code>.  The
amount of fog is <code class="reqn">s * c</code> clamped to a 0 to 1
range, where <code class="reqn">s = fogScale</code>.
</p>
</li>
<li><p>For <code>"exp"</code> and <code>"exp2"</code> fog, the observer location
is negative at a distance depending on the field of view.
The formula for the distance is 
</p>
<p style="text-align: center;"><code class="reqn">c = [1-sin(theta)]/[1 + sin(theta)]</code>
</p>

<p>where <code class="reqn">theta = FOV/2</code>.
We calculate </p>
<p style="text-align: center;"><code class="reqn">c' = d(1-c) + c</code>
</p>

<p>so <code class="reqn">c'</code> runs from 0 at the observer to
1 at the far clipping plane.
</p>
</li>
<li><p>For <code>"exp"</code> fog, the amount of fog is 
<code class="reqn">1 - exp(-s * c')</code>.
</p>
</li>
<li><p>For <code>"exp2"</code> fog, the amount of fog is
<code class="reqn">1 - exp[-(s * c')^2]</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+material3d">material3d</a></code>, <code><a href="#topic+bgplot3d">bgplot3d</a></code> to add a 2D plot as background.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  open3d()
  
  # a simple white background
  
  bg3d("white")

  # the holo-globe (inspired by star trek):

  bg3d(sphere = TRUE, color = c("black", "green"), lit = FALSE, back = "lines" )

  # an environmental sphere with a nice texture.

  bg3d(sphere = TRUE, texture = system.file("textures/sunsleep.png", package = "rgl"), 
         back = "filled" )
         
  # The same texture as a fixed background
  
  open3d()
  bg3d(texture = system.file("textures/sunsleep.png", package = "rgl"), col = "white")
</code></pre>

<hr>
<h2 id='bgplot3d'>Use base graphics for RGL background</h2><span id='topic+bgplot3d'></span><span id='topic+legend3d'></span>

<h3>Description</h3>

<p>Add a 2D plot or a legend in the background of an RGL window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgplot3d(expression, bg.color = getr3dDefaults("bg", "color"), 
         magnify = 1, ...)
legend3d(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgplot3d_+3A_expression">expression</code></td>
<td>

<p>Any plotting commands to produce a plot.
</p>
</td></tr>
<tr><td><code id="bgplot3d_+3A_bg.color">bg.color</code></td>
<td>

<p>The color to use for the background.
</p>
</td></tr>
<tr><td><code id="bgplot3d_+3A_magnify">magnify</code></td>
<td>

<p>Multiplicative factor to apply to size of window when producing background 
plot.
</p>
</td></tr>
<tr><td><code id="bgplot3d_+3A_...">...</code></td>
<td>

<p>For <code>legend3d</code>, arguments to pass to <code>bgplot3d</code>
or <code><a href="graphics.html#topic+legend">legend</a></code>; for <code>bgplot3d</code>, 
arguments to pass to <code><a href="#topic+bg3d">bg3d</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>bgplot3d</code> function opens a <code><a href="grDevices.html#topic+png">png</a></code> device and executes <code>expression</code>,
producing a plot there.  This plot is then used as a bitmap background for the current
RGL subscene.
</p>
<p>The <code>legend3d</code> function draws a standard 2D legend to the background of the current
subscene by calling <code>bgplot3d</code> to open a device, and setting up a plot region there 
to fill the whole display.
</p>


<h3>Value</h3>

<p>The <code>bgplot3d</code> function invisibly returns the ID of the background object that was created,
with attribute <code>"value"</code> holding the value returned when the <code>expression</code> was
evaluated.
</p>
<p>The <code>legend3d</code> function does similarly.  The <code>"value"</code> attribute is the result
of the call to <code><a href="graphics.html#topic+legend">legend</a></code>.   The scaling of the coordinates runs from 0 to 1 
in X and Y.
</p>


<h3>Note</h3>

<p>Because the background plots are drawn as bitmaps, they do not resize very gracefully.
It's best to size your window first, then draw the background at that size.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bg3d">bg3d</a></code> for other background options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- rnorm(100)
z &lt;- rnorm(100)
open3d()
# Needs to be a bigger window than the default
par3d(windowRect = c(100, 100, 612, 612))
parent &lt;- currentSubscene3d()
mfrow3d(2, 2)
plot3d(x, y, z)
next3d(reuse = FALSE)
bgplot3d(plot(y, z))
next3d(reuse = FALSE)
bgplot3d(plot(x, z))
next3d(reuse = FALSE)
legend3d("center", c("2D Points", "3D Points"), pch = c(1, 16))
useSubscene3d(parent)
</code></pre>

<hr>
<h2 id='Buffer'>R6 Class for binary buffers in glTF files.</h2><span id='topic+Buffer'></span>

<h3>Description</h3>

<p>These files typically have one buffer holding all the
binary data for a scene.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Buffer-new"><code>Buffer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-load"><code>Buffer$load()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-saveOpenBuffer"><code>Buffer$saveOpenBuffer()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-getBuffer"><code>Buffer$getBuffer()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-setBuffer"><code>Buffer$setBuffer()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-openBuffer"><code>Buffer$openBuffer()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-writeBuffer"><code>Buffer$writeBuffer()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-closeBuffer"><code>Buffer$closeBuffer()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-closeBuffers"><code>Buffer$closeBuffers()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-getBufferview"><code>Buffer$getBufferview()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-addBufferView"><code>Buffer$addBufferView()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-openBufferview"><code>Buffer$openBufferview()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-setBufferview"><code>Buffer$setBufferview()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-getAccessor"><code>Buffer$getAccessor()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-setAccessor"><code>Buffer$setAccessor()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-readAccessor"><code>Buffer$readAccessor()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-readAccessor0"><code>Buffer$readAccessor0()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-addAccessor"><code>Buffer$addAccessor()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-dataURI"><code>Buffer$dataURI()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-as.list"><code>Buffer$as.list()</code></a>
</p>
</li>
<li> <p><a href="#method-Buffer-clone"><code>Buffer$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Buffer-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Buffer$new(json = NULL, binfile = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>json</code></dt><dd><p>list read from glTF file.</p>
</dd>
<dt><code>binfile</code></dt><dd><p>optional External binary filename, or raw vector</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Buffer-load"></a>



<h4>Method <code>load()</code></h4>

<p>Load from file.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$load(uri, buf = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>uri</code></dt><dd><p>Which file to load.</p>
</dd>
<dt><code>buf</code></dt><dd><p>Which buffer number to load.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Buffer-saveOpenBuffer"></a>



<h4>Method <code>saveOpenBuffer()</code></h4>

<p>Write open buffer to connection.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$saveOpenBuffer(con, buf = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>con</code></dt><dd><p>Output connection.</p>
</dd>
<dt><code>buf</code></dt><dd><p>Buffer number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Buffer-getBuffer"></a>



<h4>Method <code>getBuffer()</code></h4>

<p>Get buffer object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$getBuffer(buf, default = list(byteLength = 0))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>buf</code></dt><dd><p>Buffer number.</p>
</dd>
<dt><code>default</code></dt><dd><p>Default buffer object if <code>buf</code> not found.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list containing components described here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-buffer">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-buffer</a>.
</p>


<hr>
<a id="method-Buffer-setBuffer"></a>



<h4>Method <code>setBuffer()</code></h4>

<p>Set buffer object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$setBuffer(buf, buffer)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>buf</code></dt><dd><p>Buffer number.</p>
</dd>
<dt><code>buffer</code></dt><dd><p>New value to insert.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Buffer-openBuffer"></a>



<h4>Method <code>openBuffer()</code></h4>

<p>Open a connection for the data in a buffer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$openBuffer(buf)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>buf</code></dt><dd><p>Buffer number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An open binary connection.
</p>


<hr>
<a id="method-Buffer-writeBuffer"></a>



<h4>Method <code>writeBuffer()</code></h4>

<p>Write data to buffer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$writeBuffer(values, type, size, buf = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>values</code></dt><dd><p>Values to write.</p>
</dd>
<dt><code>type</code></dt><dd><p>Type to write.</p>
</dd>
<dt><code>size</code></dt><dd><p>Byte size of each value.</p>
</dd>
<dt><code>buf</code></dt><dd><p>Which buffer to write to.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Byte offset of start of bytes written.
</p>


<hr>
<a id="method-Buffer-closeBuffer"></a>



<h4>Method <code>closeBuffer()</code></h4>

<p>Close the connection in a buffer.
</p>
<p>If there was a connection open, this will save the
contents in the raw vector <code>bytes</code> within the buffer object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$closeBuffer(buf)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>buf</code></dt><dd><p>The buffer number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Buffer-closeBuffers"></a>



<h4>Method <code>closeBuffers()</code></h4>

<p>Close any open buffers.
</p>
<p>Call this after working with a GLTF file to avoid warnings
from R about closing unused connections.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$closeBuffers()</pre></div>


<hr>
<a id="method-Buffer-getBufferview"></a>



<h4>Method <code>getBufferview()</code></h4>

<p>Get <code>bufferView</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$getBufferview(bufv)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bufv</code></dt><dd><p><code>bufferView</code> number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list containing components described here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-bufferview">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-bufferview</a>.
</p>


<hr>
<a id="method-Buffer-addBufferView"></a>



<h4>Method <code>addBufferView()</code></h4>

<p>Add a new buffer view.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$addBufferView(values, type, size, target = NULL, buf = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>values</code></dt><dd><p>Values to put in the view.</p>
</dd>
<dt><code>type</code></dt><dd><p>Type of values.</p>
</dd>
<dt><code>size</code></dt><dd><p>Size of values in bytes.</p>
</dd>
<dt><code>target</code></dt><dd><p>Optional target use for values.</p>
</dd>
<dt><code>buf</code></dt><dd><p>Which buffer to write to.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New <code>bufferView</code> number.
</p>


<hr>
<a id="method-Buffer-openBufferview"></a>



<h4>Method <code>openBufferview()</code></h4>

<p>Open a connection to a buffer view.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$openBufferview(bufv)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bufv</code></dt><dd><p>Which <code>bufferView</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A connection.
</p>


<hr>
<a id="method-Buffer-setBufferview"></a>



<h4>Method <code>setBufferview()</code></h4>

<p>Set <code>bufferView</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$setBufferview(bufv, bufferView)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bufv</code></dt><dd><p><code>bufferView</code> number.</p>
</dd>
<dt><code>bufferView</code></dt><dd><p>New value to insert.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Buffer-getAccessor"></a>



<h4>Method <code>getAccessor()</code></h4>

<p>Get accessor object
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$getAccessor(acc)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>acc</code></dt><dd><p>Accessor number</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list containing components described here:
<a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-accessor">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-accessor</a>
</p>


<hr>
<a id="method-Buffer-setAccessor"></a>



<h4>Method <code>setAccessor()</code></h4>

<p>Set accessor object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$setAccessor(acc, accessor)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>acc</code></dt><dd><p>Accessor number.</p>
</dd>
<dt><code>accessor</code></dt><dd><p>New value to insert.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Buffer-readAccessor"></a>



<h4>Method <code>readAccessor()</code></h4>

<p>Read data given by accessor number.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$readAccessor(acc)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>acc</code></dt><dd><p>Accessor number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector or array as specified in the accessor.  For the <code>MATn</code> types, the 3rd index
indexes the element.
</p>


<hr>
<a id="method-Buffer-readAccessor0"></a>



<h4>Method <code>readAccessor0()</code></h4>

<p>Read data given by accessor object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$readAccessor0(accessor)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>accessor</code></dt><dd><p>Accessor object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector or array as specified in the accessor.  For the <code>MATn</code> types, the 3rd index
indexes the element.
</p>


<hr>
<a id="method-Buffer-addAccessor"></a>



<h4>Method <code>addAccessor()</code></h4>

<p>Write values to accessor, not including <code>min</code> and <code>max</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$addAccessor(
  values,
  target = NULL,
  types = "anyGLTF",
  normalized = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>values</code></dt><dd><p>Values to write.</p>
</dd>
<dt><code>target</code></dt><dd><p>Optional target use for values.</p>
</dd>
<dt><code>types</code></dt><dd><p>Which types can be used?</p>
</dd>
<dt><code>normalized</code></dt><dd><p>Are normalized integers allowed?</p>
</dd>
<dt><code>useDouble</code></dt><dd><p>Whether to write doubles or singles.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>New accessor number
</p>


<hr>
<a id="method-Buffer-dataURI"></a>



<h4>Method <code>dataURI()</code></h4>

<p>Convert buffer to data URI.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$dataURI(buf = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>buf</code></dt><dd><p>Buffer to convert.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>String containing data URI.
</p>


<hr>
<a id="method-Buffer-as.list"></a>



<h4>Method <code>as.list()</code></h4>

<p>Convert to list.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$as.list()</pre></div>



<h5>Returns</h5>

<p>List suitable for writing using JSON.
</p>


<hr>
<a id="method-Buffer-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Buffer$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='callbacks'> User callbacks on mouse events </h2><span id='topic+rgl.setMouseCallbacks'></span><span id='topic+rgl.getMouseCallbacks'></span><span id='topic+rgl.setWheelCallback'></span><span id='topic+rgl.getWheelCallback'></span>

<h3>Description</h3>

<p>Set and get user callbacks on mouse events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.setMouseCallbacks(button, begin = NULL, update = NULL, end = NULL, 
                      dev = cur3d(), subscene = currentSubscene3d(dev))
rgl.getMouseCallbacks(button, 
                      dev = cur3d(), subscene = currentSubscene3d(dev))

rgl.setWheelCallback(rotate, 
                      dev = cur3d(), subscene = currentSubscene3d(dev))

rgl.getWheelCallback(dev = cur3d(), subscene = currentSubscene3d(dev))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callbacks_+3A_button">button</code></td>
<td>
<p> Which button? Use 1 for left, 2 for
right, 3 for middle, 4 for wheel.  Use 0 to set
an action when no button is pressed. </p>
</td></tr>
<tr><td><code id="callbacks_+3A_begin">begin</code></td>
<td>
<p> Called when mouse down event occurs </p>
</td></tr>
<tr><td><code id="callbacks_+3A_update">update</code></td>
<td>
<p> Called when mouse moves </p>
</td></tr>
<tr><td><code id="callbacks_+3A_end">end</code></td>
<td>
<p> Called when mouse is released </p>
</td></tr>
<tr><td><code id="callbacks_+3A_rotate">rotate</code></td>
<td>
<p> Called when mouse wheel is rotated </p>
</td></tr>
<tr><td><code id="callbacks_+3A_dev">dev</code>, <code id="callbacks_+3A_subscene">subscene</code></td>
<td>
<p>The RGL device and subscene to work with </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The set functions set event handlers on mouse events that occur within the current RGL window.
The <code>begin</code> and <code>update</code> events should be functions taking two arguments; these
will be the mouse coordinates when the event occurs.  The <code>end</code> event handler
takes no arguments.  The <code>rotate</code> event takes a single argument, which will be 
equal to <code>1</code> if the user pushes the wheel away by one click, and <code>2</code> if 
the user pulls the wheel by one click.
</p>
<p>Alternatively, the handlers may be set to <code>NULL</code>, the default value, in which case
no action will occur.
</p>
<p>If a subscene has multiple listeners, the user action will still only be called for the
subscene that received the mouse event.  It should consult <code><a href="#topic+par3d">par3d</a>("listeners")</code>
if it makes sense to take action on the whole group of subscenes.
</p>
<p>The get function retrieves the callbacks that are currently set.
</p>
<p>The &ldquo;no button&rdquo; mouse handler may be set by
specifying <code>button = 0</code>.  The <code>begin</code>
function will be called the first time the mouse
moves within the subscene, and the <code>update</code>
function will be called repeatedly as it moves.  The
<code>end</code> function will never be called.
</p>


<h3>Value</h3>

<p>The set functions are called for the side effect of setting the mouse event handlers.
</p>
<p>The <code>rgl.getMouseCallbacks</code> function returns a list containing the callback functions or <code>NULL</code> if no user callback is set.
The <code>rgl.getWheelCallback</code> returns the callback function or <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

 <p><code><a href="#topic+par3d">par3d</a></code> to set built-in handlers,
<code><a href="#topic+setUserCallbacks">setUserCallbacks</a></code> to work with <code><a href="#topic+rglwidget">rglwidget</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 pan3d &lt;- function(button, dev = cur3d(), subscene = currentSubscene3d(dev)) {
   start &lt;- list()
   
   begin &lt;- function(x, y) {
     activeSubscene &lt;- par3d("activeSubscene", dev = dev)
     start$listeners &lt;&lt;- par3d("listeners", dev = dev, subscene = activeSubscene)
     for (sub in start$listeners) {
       init &lt;- par3d(c("userProjection","viewport"), dev = dev, subscene = sub)
       init$pos &lt;- c(x/init$viewport[3], 1 - y/init$viewport[4], 0.5)
       start[[as.character(sub)]] &lt;&lt;- init
     }
   }
   
   update &lt;- function(x, y) {
     for (sub in start$listeners) {
       init &lt;- start[[as.character(sub)]]
       xlat &lt;- 2*(c(x/init$viewport[3], 1 - y/init$viewport[4], 0.5) - init$pos)
       mouseMatrix &lt;- translationMatrix(xlat[1], xlat[2], xlat[3])
       par3d(userProjection = mouseMatrix %*% init$userProjection, dev = dev, subscene = sub )
      }
   }
   rgl.setMouseCallbacks(button, begin, update, dev = dev, subscene = subscene)
   cat("Callbacks set on button", button, "of RGL device", dev, "in subscene", subscene, "\n")
 }
 open3d()
 shade3d(icosahedron3d(), col = "yellow")
 # This only works in the internal display...
 pan3d(1)
</code></pre>

<hr>
<h2 id='checkDeldir'>
Check for a compatible version of <span class="pkg">deldir</span>
</h2><span id='topic+checkDeldir'></span>

<h3>Description</h3>

<p>Version 1.0-2 of <span class="pkg">deldir</span> is not compatible with <span class="pkg">rgl</span>.
This allows code to avoid trying to call it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDeldir(error = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkDeldir_+3A_error">error</code></td>
<td>

<p>If <code>TRUE</code>, stop with an error.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <span class="pkg">deldir</span> is available in a compatible
version.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>checkDeldir()
</code></pre>

<hr>
<h2 id='clipMesh3d'>
Clip mesh or RGL object to general region
</h2><span id='topic+clipMesh3d'></span><span id='topic+clipObj3d'></span>

<h3>Description</h3>

<p>Modifies a mesh3d object so that values of 
a function are bounded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clipMesh3d(mesh, fn, bound = 0, greater = TRUE, 
           minVertices = 0, plot = FALSE, keepValues = FALSE,
           keepTags = FALSE)
clipObj3d(ids = tagged3d(tags), fn, bound = 0, greater = TRUE,
           minVertices = 0,
           replace = TRUE, tags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clipMesh3d_+3A_mesh">mesh</code></td>
<td>

<p>A <code><a href="#topic+mesh3d">mesh3d</a></code> object.
</p>
</td></tr>
<tr><td><code id="clipMesh3d_+3A_fn">fn</code></td>
<td>

<p>A function used to determine clipping, or a vector of values from such
a function, with one value per vertex.
</p>
</td></tr>
<tr><td><code id="clipMesh3d_+3A_bound">bound</code></td>
<td>

<p>The value(s) of <code>fn</code> on the clipping boundary.
</p>
</td></tr>
<tr><td><code id="clipMesh3d_+3A_greater">greater</code></td>
<td>

<p>Logical; whether to keep <code>fn &gt;= bound</code> or not.
</p>
</td></tr>
<tr><td><code id="clipMesh3d_+3A_minvertices">minVertices</code></td>
<td>

<p>See Details below.
</p>
</td></tr>
<tr><td><code id="clipMesh3d_+3A_plot">plot</code></td>
<td>
<p>Logical; whether or not to plot the mesh.</p>
</td></tr>
<tr><td><code id="clipMesh3d_+3A_keepvalues">keepValues</code></td>
<td>
<p>Logical; whether to save the function values at 
each vertex when <code>plot = FALSE</code>.</p>
</td></tr>
<tr><td><code id="clipMesh3d_+3A_keeptags">keepTags</code></td>
<td>
<p>Whether to keep the <code>"tags"</code> component
of the result; see details below.</p>
</td></tr>
<tr><td><code id="clipMesh3d_+3A_ids">ids</code></td>
<td>

<p>The RGL id value(s) of objects to clip.
</p>
</td></tr>
<tr><td><code id="clipMesh3d_+3A_tags">tags</code></td>
<td>

<p>Object tags; an alternate way to specify <code>ids</code>.  Ignored if <code>ids</code> is
given.
</p>
</td></tr>
<tr><td><code id="clipMesh3d_+3A_replace">replace</code></td>
<td>

<p>Should the <code>ids</code> objects be deleted after the clipped
ones are drawn?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions transform a mesh3d object or other
RGL objects by removing parts where <code>fn</code> violates
the bound.
</p>
<p>For <code>clipMesh3d</code> the <code>fn</code> argument can be any
of the following:
</p>

<ul>
<li><p>a character vector naming a function (with special
names <code>"x"</code>, <code>"y"</code>, and <code>"z"</code> corresponding
to functions returning those coordinates)
</p>
</li>
<li><p>a function
</p>
</li>
<li><p>a numeric vector with one value per vertex
</p>
</li>
<li><p><code>NULL</code>, indicating that the numeric values
are saved in <code>mesh$values</code>
</p>
</li></ul>

<p>For <code>clipObj3d</code> any of the above except <code>NULL</code>
may be used.
</p>
<p>If <code>fn</code>
is a numeric vector, with one value per vertex, those values will be
used in the test.
If it is a function with formal arguments <code>x</code>,
<code>y</code> and <code>z</code>, it will receive the coordinates of 
vertices in those arguments, otherwise it will receive 
the coordinates in a single n x 3 matrix.   The function
should be vectorized and return one value per vertex, 
to check against the bound.
</p>
<p>These operations are performed on the mesh:
</p>
<p>First, all quads are converted to triangles.
</p>
<p>Next, each vertex is checked against the condition.
</p>
<p>Modifications to triangles depend
on how many of the vertices satisfy the condition 
(<code>fn &gt;= bound</code> or <code>fn &lt;= bound</code>, depending on <code>greater</code>)
for inclusion.
</p>

<ul>
<li><p> If no vertices in a triangle satisfy the condition, the triangle is omitted.
</p>
</li>
<li><p> If one vertex satisfies the condition, the other two vertices
in that triangle are shrunk towards it by assuming <code>fn</code>
is locally linear.
</p>
</li>
<li><p> If two vertices satisfy the condition, the third vertex
is shrunk along each edge towards each other vertex, forming a
quadrilateral made of two new triangles.
</p>
</li>
<li><p> If all vertices satisfy the condition, they are included
with no modifications.
</p>
</li></ul>

<p>Modifications to line segments are similar:  the segment
will be shortened if it crosses the boundary, or omitted
if it is entirely out of bounds.  Points, spheres, text
and sprites will just be kept or rejected.
</p>
<p>The <code>minVertices</code> argument is used to improve the 
approximation to the boundary when <code>fn</code> is a non-linear
function.  In that case, the interpolation described above
can be inaccurate.  If <code>minVertices</code> is set to a
positive
number (e.g. <code>10000</code>), then each object is modified
by subdivision to have at least that number of vertices, 
so that pieces are smaller and the linear interpolation
is more accurate.  In the <code>clipObj3d</code> function, 
<code>minVertices</code> can be a vector, with entries corresponding
to each of the entries in <code>ids</code>.
</p>


<h3>Value</h3>

<p>If <code>plot = FALSE</code>,
<code>clipMesh3d</code> returns new mesh3d object in which all vertices (approximately) satisfy the
clipping condition.  Note that the order of vertices will likely
differ from the original order, and new vertices will be added near
the boundary (and if <code>minVertices &gt; 0</code>, in the 
interior).  If in addition <code>keepValues = TRUE</code>,
a component named <code>"values"</code> will be added to the 
mesh containing the values for each vertex.
If <code>keepTags = TRUE</code>, the <code>tags</code> component
described below will be added to the output mesh.
</p>
<p>If <code>plot = TRUE</code>, the result will be 
plotted with <code><a href="#topic+shade3d">shade3d</a></code> and its result returned.
</p>
<p><code>clipObj3d</code> is called for the side effect of modifying
the scene.  It returns a list of new RGL id values
corresponding to the <code>ids</code> passed as arguments.
</p>


<h3>The <code>keepTags</code> argument</h3>

<p>If <code>keepTags = TRUE</code>, a <code>"tags"</code> element will be 
added to the result.  It will be a vector with one entry per
point, segment, triangle and quad in the output mesh.  (These tags are not related
to the tags used to identify <span class="pkg">rgl</span> objects.)
The mesh tags may be used to show the correspondence between
the parts of 
the input mesh and output mesh.
By default, the tags are constructed as a numerical sequence
over points,
segments, triangles and
quads in the input mesh, in that order, starting from one.  This is the same order 
used for colours when 
shading with 
<code>meshColor == "faces"</code>.  
</p>
<p>For example, start with a mesh with one point, two segments, three
triangles and four
quads, but no <code>tags</code> member.  
It would implicitly tag the parts from one to ten as
</p>
<p><code style="white-space: pre;">&#8288;
  c(1,    # the point
    2:3,  # the two segments
    4:6,  # the three triangles
    7:10) # the four quads
&#8288;</code>
</p>
<p>If clipping deleted the segments
and the first triangle, the output would contain the seven
element result
</p>
<p><code style="white-space: pre;">&#8288;
  mesh$tags &lt;- c(1,    # the point remains
                       # no segments now
                 5:6,  # the two remaining triangles
                       # were previously items 5 and 6
                 7:10) # the four quads
&#8288;</code>
</p>
<p>The <code>tags</code> output may contain repetitions. For example,
when a triangle is partially clipped and replaced by several
smaller triangles, entries for all of them will contain the value
corresponding to the original triangle.
</p>
<p>The <code>mesh$tags</code> component may be supplied as part of the input
mesh as any type of vector; 
the output will propagate values to the new mesh.  The input length
must match the total number of points, segments, triangles and 
quads in the input mesh or an error will be raised.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>See <a href="https://stackoverflow.com/q/56242470/2554330">https://stackoverflow.com/q/56242470/2554330</a> and
<a href="https://laustep.github.io/stlahblog/posts/MeshClipping.html">https://laustep.github.io/stlahblog/posts/MeshClipping.html</a> for a
motivating example.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+contourLines3d">contourLines3d</a></code> and
<code><a href="#topic+filledContour3d">filledContour3d</a></code> for ways to display function 
values without clipping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Show the problem that minVertices solves:

cube &lt;- cube3d(col = rainbow(6), meshColor = "faces")

# This function only has one argument, so it will 
# be passed x, y and z in columns of a matrix
vecnorm &lt;- function(vals) apply(vals, 1, function(row) sqrt(sum(row^2)))

open3d()
mfrow3d(2, 2, sharedMouse = TRUE)
id1 &lt;- shade3d(cube)
# All vertices have norm sqrt(3), so this clips nothing:
clipObj3d(id1, fn = vecnorm, bound = sqrt(2))
next3d()
id2 &lt;- wire3d(cube, lit = FALSE)
clipObj3d(id2, fn = vecnorm, bound = sqrt(2))

# This subdivides the cube, and does proper clipping:
next3d()
id3 &lt;- shade3d(cube)
clipObj3d(id3, fn = vecnorm, bound = sqrt(2), minVertices = 200)
next3d()
id4 &lt;- wire3d(cube, lit = FALSE)
clipObj3d(id4, fn = vecnorm, bound = sqrt(2), minVertices = 200)

</code></pre>

<hr>
<h2 id='clipplaneControl'>
Sets attributes of a clipping plane
</h2><span id='topic+clipplaneControl'></span>

<h3>Description</h3>

<p>This is a function to produce actions in a web display.  A
<code><a href="#topic+playwidget">playwidget</a></code> or Shiny
input control (e.g. a <code><a href="shiny.html#topic+sliderInput">sliderInput</a></code> control)
sets a value which controls attributes of one or more clipping
planes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clipplaneControl(a = NULL, b = NULL, c = NULL, d = NULL, 
                 plane = 1, clipplaneids = tagged3d(tag), tag, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clipplaneControl_+3A_a">a</code>, <code id="clipplaneControl_+3A_b">b</code>, <code id="clipplaneControl_+3A_c">c</code>, <code id="clipplaneControl_+3A_d">d</code></td>
<td>

<p>Parameter values for the clipping planes.
</p>
</td></tr>
<tr><td><code id="clipplaneControl_+3A_plane">plane</code></td>
<td>

<p>Which plane in the clipplane object?
</p>
</td></tr>
<tr><td><code id="clipplaneControl_+3A_clipplaneids">clipplaneids</code></td>
<td>

<p>The id of the clipplane object.
</p>
</td></tr>
<tr><td><code id="clipplaneControl_+3A_tag">tag</code></td>
<td>

<p>Select clipplane with matching tag.  Ignored
if <code>clipplaneid</code> is specified.
</p>
</td></tr>  
<tr><td><code id="clipplaneControl_+3A_...">...</code></td>
<td>

<p>Other parameters passed to <code><a href="#topic+propertyControl">propertyControl</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"rglControl"</code> of cleaned up parameter
values, to be used in an RGL widget.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  open3d()
  saveopts &lt;- options(rgl.useNULL = TRUE)
  xyz &lt;- matrix(rnorm(300), ncol = 3)
  id &lt;- plot3d(xyz, type="s", col = "blue", zlim = c(-3,3))["clipplanes"]
  dvals &lt;- c(3, -3)
  widget &lt;- rglwidget() %&gt;%
    playwidget(clipplaneControl(d = dvals, clipplaneids = id),
               start = 0, stop = 1, step = 0.01,
               rate = 0.5)
  if (interactive() || in_pkgdown_example())
    widget
  options(saveopts)
</code></pre>

<hr>
<h2 id='contourLines3d'>
Draw contours on a surface
</h2><span id='topic+contourLines3d'></span><span id='topic+contourLines3d.rglId'></span><span id='topic+contourLines3d.mesh3d'></span><span id='topic+filledContour3d'></span><span id='topic+filledContour3d.rglId'></span><span id='topic+filledContour3d.mesh3d'></span>

<h3>Description</h3>

<p><code>contourLines3d</code> draws contour lines on a surface;
<code>filledContour3d</code> draws filled contours on it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contourLines3d(obj, ...)
## S3 method for class 'rglId'
contourLines3d(obj, ...)
## S3 method for class 'mesh3d'
contourLines3d(obj, fn = "z", 
    nlevels = 10, 
    levels = NULL, 
    minVertices = 0,
    plot = TRUE, ... )
filledContour3d(obj, ...)
## S3 method for class 'rglId'
filledContour3d(obj, plot = TRUE, replace = plot, ...)
## S3 method for class 'mesh3d'
filledContour3d(obj, fn = "z", 
    nlevels = 20, 
    levels = pretty(range(values), nlevels), 
    color.palette = function(n) hcl.colors(n, "YlOrRd", rev = TRUE),
    col = color.palette(length(levels) - 1),
    minVertices = 0,
    plot = TRUE, 
    keepValues = FALSE, ... )    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contourLines3d_+3A_obj">obj</code></td>
<td>

<p>The object(s) on which to draw contour lines.
</p>
</td></tr>
<tr><td><code id="contourLines3d_+3A_fn">fn</code></td>
<td>

<p>The function(s) to be contoured.  See Details.
</p>
</td></tr>
<tr><td><code id="contourLines3d_+3A_nlevels">nlevels</code></td>
<td>

<p>Suggested number of contour levels if <code>levels</code> is not given.
</p>
</td></tr>
<tr><td><code id="contourLines3d_+3A_levels">levels</code></td>
<td>

<p>Specified contour values.
</p>
</td></tr>
<tr><td><code id="contourLines3d_+3A_minvertices">minVertices</code></td>
<td>

<p>See Details below.  
</p>
</td></tr>
<tr><td><code id="contourLines3d_+3A_plot">plot</code></td>
<td>

<p>Whether to draw the lines or return them in a dataframe.
</p>
</td></tr>
<tr><td><code id="contourLines3d_+3A_...">...</code></td>
<td>

<p>For the <code>"mesh3d"</code> methods, additional parameters to pass to <code><a href="#topic+segments3d">segments3d</a></code>
when drawing the contour lines or to <code><a href="#topic+shade3d">shade3d</a></code>
when drawing the filled contours.  For the <code>"rglId"</code>
methods, additional parameters to pass to the <code>"mesh3d"</code>
methods.
</p>
</td></tr>
<tr><td><code id="contourLines3d_+3A_replace">replace</code></td>
<td>

<p>Whether to delete the objects that are being contoured.
</p>
</td></tr>
<tr><td><code id="contourLines3d_+3A_color.palette">color.palette</code></td>
<td>
<p>a color palette function to 
assign colors in the plot</p>
</td></tr>
<tr><td><code id="contourLines3d_+3A_col">col</code></td>
<td>
<p>the actual colors to use in the plot.</p>
</td></tr>
<tr><td><code id="contourLines3d_+3A_keepvalues">keepValues</code></td>
<td>
<p>whether to save the function values at 
each vertex when <code>plot = FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>contourLines3d</code>, the <code>fn</code> argument can be any
of the following:
</p>

<ul>
<li><p> a character vector naming
one or more functions 
</p>
</li>
<li><p>a function
</p>
</li>
<li><p>a numeric vector with one value per vertex
</p>
</li>
<li><p><code>NULL</code>, indicating that the numeric values
are saved in <code>obj$values</code>
</p>
</li>
<li><p>a list containing any of the above.
</p>
</li></ul>

<p>For <code>filledContour3d</code>, only one function can be specified.
</p>
<p>The special names <code>"x", "y", "z"</code> may be used in
<code>fn</code> to specify functions returning one of those
coordinates.  (If you have existing functions <code>x()</code>, <code>y()</code>
or <code>z()</code> they will be masked by this choice; specify
such functions by value rather than name, e.g. <code>fn = x</code>
instead of <code>fn = "x"</code>.)
</p>
<p>Functions in <code>fn</code> with formal arguments <code>x</code>,
<code>y</code> and <code>z</code> will receive the coordinates of 
vertices in those arguments, otherwise they will receive 
the coordinates in a single n x 3 matrix.   They should
be vectorized and return one value per vertex.
</p>
<p>Each of the functions will be evaluated at each vertex
of the surface specified by <code>obj</code>, and contours will
be drawn assuming the function is linear between vertices.
If contours of a nonlinear function are needed, you may
want to increase <code>minVertices</code> as described below.
</p>
<p>If <code>levels</code> is not specified, values will be set
separately for each entry in <code>fn</code>, using 
<code>pretty(range(values, na.rm = TRUE), nlevels)</code> where
<code>values</code> are the values on the vertices.
</p>
<p>The <code>minVertices</code> argument is used to improve the 
approximation to the contour when the function is non-linear.
In that case, the interpolation between vertices 
can be inaccurate.  If <code>minVertices</code> is set to a
positive
number (e.g. <code>10000</code>), then the mesh is modified
by subdivision to have at least that number of vertices, 
so that pieces are smaller and the linear interpolation
is more accurate. 
</p>


<h3>Value</h3>

<p>For both <code>contourLines3d</code> and <code>filledContour3d</code>
the <code>"rglId"</code> method converts the given id values to
a mesh, and calls the <code>"mesh3d"</code> method.  
</p>
<p>The <code>"mesh3d"</code> method returns an object of class
<code>"rglId"</code> corresponding to what was
drawn if <code>plot</code> is <code>TRUE</code>,
</p>
<p>If <code>plot</code> is <code>FALSE</code>, <code>contourLines3d</code> returns a dataframe containing 
columns <code>c("x", "y", "z", "fn", "level")</code> giving
the coordinates of the endpoints of each line segment, 
the name (or index) of the function for this contour, and the 
level of the contour.  
</p>
<p>If <code>plot</code> is <code>FALSE</code>, <code>filledContour3d</code>
returns a <code>"<a href="#topic+mesh3d">mesh3d</a>"</code> object holding the result.
If <code>keepValues</code> is <code>TRUE</code>, the mesh
will contain the values corresponding to each vertex
(with linear approximations at the boundaries).
</p>


<h3>Note</h3>

<p>To draw contours on a surface, the surface should be drawn
with material property <code>polygon_offset = 1</code> (or perhaps
some larger positive value) so that the lines of the contour are not
obscured by the surface.
</p>
<p>In R versions prior to 3.6.0, the default <code>color.palette</code>
is <code>grDevices::cm.colors</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p>The <span class="pkg">misc3d</span> package contains the function <code><a href="misc3d.html#topic+contour3d">contour3d</a></code>
to draw contour surfaces in space instead of contour lines
on surfaces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Add contourlines in "z" to a persp plot

z &lt;- 2 * volcano        # Exaggerate the relief
x &lt;- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
y &lt;- 10 * (1:ncol(z))   # 10 meter spacing (E to W)

open3d()
id &lt;- persp3d(x, y, z, aspect = "iso",
      axes = FALSE, box = FALSE, polygon_offset = 1)
contourLines3d(id)     # "z" is the default function
filledContour3d(id, polygon_offset = 1, nlevels = 10, replace = TRUE)

# Draw longitude and latitude lines on a globe

lat &lt;- matrix(seq(90, -90, length.out = 50)*pi/180, 50, 50, byrow = TRUE)
long &lt;- matrix(seq(-180, 180, length.out = 50)*pi/180, 50, 50)

r &lt;- 6378.1 # radius of Earth in km
x &lt;- r*cos(lat)*cos(long)
y &lt;- r*cos(lat)*sin(long)
z &lt;- r*sin(lat)

open3d()
ids &lt;- persp3d(x, y, z, col = "white", 
        texture = system.file("textures/worldsmall.png", package = "rgl"), 
        specular = "black", axes = FALSE, box = FALSE, xlab = "", ylab = "", zlab = "",
        normal_x = x, normal_y = y, normal_z = z, polygon_offset = 1)
        
contourLines3d(ids, list(latitude = function(x, y, z) asin(z/sqrt(x^2+y^2+z^2))*180/pi,
                         longitude = function(x, y, z) atan2(y, x)*180/pi))
</code></pre>

<hr>
<h2 id='cube3d'>Sample 3D mesh objects</h2><span id='topic+cube3d'></span><span id='topic+oh3d'></span><span id='topic+tetrahedron3d'></span><span id='topic+octahedron3d'></span><span id='topic+icosahedron3d'></span><span id='topic+dodecahedron3d'></span><span id='topic+cuboctahedron3d'></span>

<h3>Description</h3>

<p>A collection of sample mesh objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cube3d(trans = identityMatrix(), ...)  
  tetrahedron3d(trans = identityMatrix(), ...)  
  octahedron3d(trans = identityMatrix(), ...)  
  icosahedron3d(trans = identityMatrix(), ...)
  dodecahedron3d(trans = identityMatrix(), ...)
  cuboctahedron3d(trans = identityMatrix(), ...)
  
  oh3d(trans = identityMatrix(), ...)    # an 'o' object

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cube3d_+3A_trans">trans</code></td>
<td>
<p>transformation to apply to objects</p>
</td></tr>
<tr><td><code id="cube3d_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code><a href="#topic+mesh3d">mesh3d</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These sample objects optionally take a 4x4 matrix transformation <code>trans</code> as 
an argument.  This transformation is applied to all vertices of the default shape.
The default is an identity transformation. 
</p>


<h3>Value</h3>

<p>Objects of class <code>c("mesh3d",
  "shape3d")</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mesh3d">mesh3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # render all of the Platonic solids
  open3d()
  shade3d( translate3d( tetrahedron3d(col = "red"), 0, 0, 0) )
  shade3d( translate3d( cube3d(col = "green"), 3, 0, 0) )
  shade3d( translate3d( octahedron3d(col = "blue"), 6, 0, 0) )
  shade3d( translate3d( dodecahedron3d(col = "cyan"), 9, 0, 0) )
  shade3d( translate3d( icosahedron3d(col = "magenta"), 12, 0, 0) )
</code></pre>

<hr>
<h2 id='cylinder3d'>
Create cylindrical or &quot;tube&quot; plots
</h2><span id='topic+cylinder3d'></span>

<h3>Description</h3>

<p>This function converts a description of a space curve into a <code><a href="#topic+mesh3d">&quot;mesh3d&quot;</a></code>
object forming a cylindrical tube around the curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cylinder3d(center, radius = 1, twist = 0, e1 = NULL, e2 = NULL, e3 = NULL, 
	sides = 8, section = NULL, closed = 0, 
	rotationMinimizing = is.null(e2) &amp;&amp; is.null(e3),
	debug = FALSE, keepVars = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cylinder3d_+3A_center">center</code></td>
<td>
<p>An n by 3 matrix whose columns are the x, y and z coordinates of the space curve.</p>
</td></tr>
<tr><td><code id="cylinder3d_+3A_radius">radius</code></td>
<td>
<p>The radius of the cross-section of the tube at each point in the center.</p>
</td></tr>
<tr><td><code id="cylinder3d_+3A_twist">twist</code></td>
<td>
<p>The amount by which the polygon forming the tube is twisted at each point.</p>
</td></tr>
<tr><td><code id="cylinder3d_+3A_e1">e1</code>, <code id="cylinder3d_+3A_e2">e2</code>, <code id="cylinder3d_+3A_e3">e3</code></td>
<td>
<p>The local coordinates to use at each point on the space curve.  These default to a rotation
minimizing frame or Frenet coordinates.</p>
</td></tr>
<tr><td><code id="cylinder3d_+3A_sides">sides</code></td>
<td>
<p>The number of sides in the polygon cross section.</p>
</td></tr>
<tr><td><code id="cylinder3d_+3A_section">section</code></td>
<td>
<p>The polygon cross section as a two-column matrix, or <code>NULL</code>.</p>
</td></tr>  
<tr><td><code id="cylinder3d_+3A_closed">closed</code></td>
<td>
<p>Whether to treat the first and last points of the space curve as identical,
and close the curve, or put caps on the ends.  See the Details.</p>
</td></tr>
<tr><td><code id="cylinder3d_+3A_rotationminimizing">rotationMinimizing</code></td>
<td>
<p>Use a rotation minimizing local
frame if <code>TRUE</code>, or a Frenet or user-specified frame if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cylinder3d_+3A_debug">debug</code></td>
<td>
<p>If <code>TRUE</code>, plot the local Frenet coordinates at each point.</p>
</td></tr>
<tr><td><code id="cylinder3d_+3A_keepvars">keepVars</code></td>
<td>
<p>If <code>TRUE</code>, return the local variables in attribute <code>"vars"</code>.</p>
</td></tr>
<tr><td><code id="cylinder3d_+3A_...">...</code></td>
<td>
<p>Additional arguments to set as material properties.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of points in the space curve is determined by the vector lengths in <code>center</code>,
after using <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code> to convert it to a list.  The other arguments
<code>radius</code>, <code>twist</code>, <code>e1</code>, <code>e2</code>, and <code>e3</code> are extended to the same
length.
</p>
<p>The <code>closed</code> argument controls how the ends of the cylinder are
handled. If <code>closed &gt; 0</code>, it represents the number of points of
overlap in the coordinates.  <code>closed == TRUE</code> is the same as 
<code>closed = 1</code>. If <code>closed &gt; 0</code> but the ends don't actually 
match, a warning will be given and results will be somewhat 
unpredictable.
</p>
<p>Negative values of <code>closed</code> indicate that caps should be put on the
ends of the cylinder.  If <code>closed == -1</code>, a cap will be put on the
end corresponding to <code>center[1, ]</code>.  If <code>closed == -2</code>, caps
will be put on both ends.
</p>
<p>If <code>section</code> is <code>NULL</code> (the default), a regular
<code>sides</code>-sided polygon is used, and <code>radius</code> measures the
distance from the center of the cylinder to each vertex.  If not
<code>NULL</code>, <code>sides</code> is ignored (and set internally to
<code>nrow(section)</code>), and <code>radius</code> is used as a multiplier to
the vertex coordinates.  <code>twist</code> specifies the rotation of the
polygon.  Both <code>radius</code> and <code>twist</code> may be vectors, with
values recycled to the number of rows in <code>center</code>, while
<code>sides</code> and <code>section</code> are the same at every point along the
curve.
</p>
<p>The three optional arguments <code>e1</code>, <code>e2</code>, and <code>e3</code>
determine the local coordinate system used to create the vertices at
each point in <code>center</code>.  If missing, they are computed by simple
numerical approximations.  <code>e1</code> should be the tangent coordinate,
giving the direction of the curve at the point.  The cross-section of
the polygon will be orthogonal to <code>e1</code>. When <code>rotationMinimizing</code> is <code>TRUE</code>, <code>e2</code> and <code>e3</code> are chosen to give
a rotation minimizing frame (see Wang et al., 2008).  When it is
<code>FALSE</code>,  <code>e2</code> defaults to an
approximation to the normal or curvature vector; it is used as the
image of the <code>y</code> axis of the polygon cross-section.  <code>e3</code>
defaults to an approximation to the binormal vector, to which the
<code>x</code> axis of the polygon maps.  The vectors are orthogonalized and
normalized at each point.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+mesh3d">&quot;mesh3d&quot;</a></code> object holding the cylinder, possibly with
attribute <code>"vars"</code> containing the local environment of the function.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>Wang, W., Jüttler, B., Zheng, D. and Liu, Y. (2008).  
Computation of rotation minimizing frames.  
ACM Transactions on Graphics, Vol. 27, No. 1, Article 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A trefoil knot
open3d()
theta &lt;- seq(0, 2*pi, length.out = 25)
knot &lt;- cylinder3d(
      center = cbind(
        sin(theta) + 2*sin(2*theta), 
        2*sin(3*theta), 
        cos(theta) - 2*cos(2*theta)),
      e1 = cbind(
        cos(theta) + 4*cos(2*theta), 
        6*cos(3*theta), 
        sin(theta) + 4*sin(2*theta)),
      radius = 0.8, 
      closed = TRUE,
      color = "green")
                     
shade3d(addNormals(subdivision3d(knot, depth = 2)))  
</code></pre>

<hr>
<h2 id='decorate3d'>
Add decorations to a 3D plot
</h2><span id='topic+decorate3d'></span>

<h3>Description</h3>

<p><code>decorate3d</code> adds the usual decorations to a plot:  labels, axes, etc.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decorate3d(xlim = NULL, ylim = NULL, zlim = NULL, 
           xlab = "x", ylab = "y", zlab = "z", 
           box = TRUE, axes = TRUE, 
           main = NULL, sub = NULL, 
           top = TRUE, aspect = FALSE, expand = 1.03, 
           tag = material3d("tag"), ...)
</code></pre>


<h3>Arguments</h3>

  
<table>
<tr><td><code id="decorate3d_+3A_xlim">xlim</code>, <code id="decorate3d_+3A_ylim">ylim</code>, <code id="decorate3d_+3A_zlim">zlim</code></td>
<td>
<p>These are used
for the labels.</p>
</td></tr>
<tr><td><code id="decorate3d_+3A_xlab">xlab</code>, <code id="decorate3d_+3A_ylab">ylab</code>, <code id="decorate3d_+3A_zlab">zlab</code></td>
<td>
<p>labels for the coordinates.</p>
</td></tr>
<tr><td><code id="decorate3d_+3A_box">box</code>, <code id="decorate3d_+3A_axes">axes</code></td>
<td>
<p>whether to draw a box and axes.</p>
</td></tr>
<tr><td><code id="decorate3d_+3A_main">main</code>, <code id="decorate3d_+3A_sub">sub</code></td>
<td>
<p>main title and subtitle.</p>
</td></tr>
<tr><td><code id="decorate3d_+3A_top">top</code></td>
<td>
<p>whether to bring the window to the top when done.</p>
</td></tr>
<tr><td><code id="decorate3d_+3A_aspect">aspect</code></td>
<td>
<p>either a logical indicating whether to adjust the aspect ratio, or a new ratio.</p>
</td></tr>
<tr><td><code id="decorate3d_+3A_expand">expand</code></td>
<td>
<p>how much to expand the box around the data, if it is drawn.</p>
</td></tr>
<tr><td><code id="decorate3d_+3A_tag">tag</code></td>
<td>
<p>optional label for objects
being produced.</p>
</td></tr>
<tr><td><code id="decorate3d_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The RGL id values for those items.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
shade3d(tetrahedron3d(), col = "red")
decorate3d(main = "A Tetrahedron")
</code></pre>

<hr>
<h2 id='drape3d'>
Drape lines over a scene.
</h2><span id='topic+drape3d'></span><span id='topic+drape3d.default'></span><span id='topic+drape3d.mesh3d'></span>

<h3>Description</h3>

<p>Project a line onto the surface in a scene so that it appears to drape itself
onto the surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drape3d(obj, ...)
## S3 method for class 'mesh3d'
drape3d(obj, x, y = NULL, z = NULL, plot = TRUE,
                         up = c(0, 0, 1),
                         P = projectDown(up), ...)
## Default S3 method:
drape3d(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drape3d_+3A_obj">obj</code></td>
<td>

<p>The object(s) upon which to drape lines.
</p>
</td></tr>
<tr><td><code id="drape3d_+3A_x">x</code>, <code id="drape3d_+3A_y">y</code>, <code id="drape3d_+3A_z">z</code></td>
<td>
<p>Coordinates of the line segments
to be draped.  Any reasonable way of defining the
coordinates is acceptable.  See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code> for details.
</p>
</td></tr>
<tr><td><code id="drape3d_+3A_plot">plot</code></td>
<td>

<p>Should the result be plotted, or returned as a data frame?
</p>
</td></tr>
<tr><td><code id="drape3d_+3A_up">up</code></td>
<td>

<p>The direction to consider as &ldquo;up&rdquo;.
</p>
</td></tr>
<tr><td><code id="drape3d_+3A_p">P</code></td>
<td>

<p>The projection to use for draping, a 4x4 matrix.
</p>
</td></tr>
<tr><td><code id="drape3d_+3A_...">...</code></td>
<td>

<p>For the <code>"mesh3d"</code> method, additional parameters to pass to <code><a href="#topic+segments3d">segments3d</a></code>
when drawing the draped lines.
For the <code>"default"</code> method, additional parameters to pass to the
<code>"mesh3d"</code> method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method converts <code>obj</code> to a mesh
using <code><a href="#topic+as.mesh3d">as.mesh3d</a></code>, then uses the <code>"mesh3d"</code>
method.
</p>
<p>The current implementation constructs the segments to drape
across the surface using the same method as
<code><a href="#topic+lines3d">lines3d</a></code> uses:  each successive point is
joined to the previous one.  Use <code>NA</code> coordinates to
indicate breaks in the line.
</p>
<p>The <code>P</code> matrix is used to project points to a plane as
follows:  They are transformed by <code>P</code> in 
homogeneous coordinates, then only first two (Euclidean)
coordinates are kept.
</p>


<h3>Value</h3>

<p>If <code>plot = TRUE</code>, 
plots the result and invisibly returns the object ID of the collection of segments. 
</p>
<p>If <code>plot = FALSE</code>, returns a matrix containing &quot;x&quot;, &quot;y&quot; and &quot;z&quot;
values for the line(s) 
(for use with <code><a href="#topic+segments3d">segments3d</a></code>),
</p>


<h3>Author(s)</h3>

<p>George Helffrich and Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shadow3d">shadow3d</a></code>, <code><a href="#topic+facing3d">facing3d</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# volcano example taken from "persp"
#

z &lt;- 2 * volcano        # Exaggerate the relief

x &lt;- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
y &lt;- 10 * (1:ncol(z))   # 10 meter spacing (E to W)

zlim &lt;- range(z)
zlen &lt;- zlim[2] - zlim[1] + 1

colorlut &lt;- terrain.colors(zlen) # height color lookup table

col &lt;- colorlut[ z - zlim[1] + 1 ] # assign colors to heights for each point

open3d()
id &lt;- surface3d(x, y, z, color = col, polygon_offset = 1)

segs &lt;- data.frame(x = range(x) + c(100, -100),
                   y = range(y) + c(150, -100), z = 325)
drape3d(id, segs, col = 'yellow', lwd = 3)
lines3d(segs, col='red', lwd=3)

p &lt;- c(350, 205)         # (x,y) of strike &amp; dip reading
off &lt;- 20*c(-1, +1)      # X-marks-the-spot offset
segs &lt;- data.frame(
    x = c(p[1] + off, NA, p[1] + off),
    y = c(p[2] + off, NA, p[2] - off),
    z = rep(350, 5)
    )
drape3d(id, segs, col = "yellow", lwd = 3)
</code></pre>

<hr>
<h2 id='elementId2Prefix'>
Use widget with old-style controls
</h2><span id='topic+elementId2Prefix'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+rglwidget">rglwidget</a></code> control is designed to work in the
<span class="pkg">htmlwidgets</span> framework.  Older RGL web pages that
used the deprecated <code><a href="#topic+writeWebGL">writeWebGL</a></code> or <span class="pkg">knitr</span> used a different
method of linking the controls to the scene.  This is a partial
bridge between the two systems.  You should adopt the new system, not use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elementId2Prefix(elementId, prefix = elementId)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elementId2Prefix_+3A_elementid">elementId</code></td>
<td>

<p>An element identifier from a <code><a href="#topic+rglwidget">rglwidget</a></code> call.
</p>
</td></tr>
<tr><td><code id="elementId2Prefix_+3A_prefix">prefix</code></td>
<td>

<p>The prefix to use in the old-style control.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function generates Javascript code, so it should be
used in an <code>results = "asis"</code> block in a <span class="pkg">knitr</span> document.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>

<hr>
<h2 id='ellipse3d'>
Make an ellipsoid
</h2><span id='topic+ellipse3d'></span><span id='topic+ellipse3d.default'></span><span id='topic+ellipse3d.lm'></span><span id='topic+ellipse3d.glm'></span><span id='topic+ellipse3d.nls'></span>

<h3>Description</h3>

<p>A generic function and several methods
returning an ellipsoid or other outline of a confidence region
for three parameters.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse3d(x, ...)
## Default S3 method:
ellipse3d(x, scale = c(1, 1, 1), centre = c(0, 0, 0), level = 0.95, 
	t = sqrt(qchisq(level, 3)), which = 1:3, subdivide = 3, smooth = TRUE, ...)
## S3 method for class 'lm'
ellipse3d(x, which = 1:3, level = 0.95, t = sqrt(3 * qf(level, 
                                                3, x$df.residual)), ...)     
## S3 method for class 'glm'
ellipse3d(x, which = 1:3, level = 0.95, t, dispersion, ...) 
## S3 method for class 'nls'
ellipse3d(x, which = 1:3, level = 0.95, t = sqrt(3 * qf(level, 
                                                3, s$df[2])), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipse3d_+3A_x">x</code></td>
<td>

<p>An object. In the default method the parameter <code>x</code> should be a 
square positive definite matrix at least 3x3
in size. It will be treated as the correlation or covariance 
of a multivariate normal distribution.
</p>
</td></tr>
<tr><td><code id="ellipse3d_+3A_...">...</code></td>
<td>

<p>Additional parameters to pass to the default method or to <code><a href="#topic+qmesh3d">qmesh3d</a></code>.
</p>
</td></tr>
<tr><td><code id="ellipse3d_+3A_scale">scale</code></td>
<td>

<p>If <code>x</code> is a correlation matrix, then the standard deviations of each
parameter can be given in the scale parameter.  This defaults to <code>c(1, 1, 1)</code>,
so no rescaling will be done.
</p>
</td></tr>
<tr><td><code id="ellipse3d_+3A_centre">centre</code></td>
<td>

<p>The centre of the ellipse will be at this position.
</p>
</td></tr>
<tr><td><code id="ellipse3d_+3A_level">level</code></td>
<td>

<p>The confidence level of a simultaneous confidence region.  The default is
0.95, for a 95% region.  This is used to control the size of the ellipsoid.
</p>
</td></tr>
<tr><td><code id="ellipse3d_+3A_t">t</code></td>
<td>

<p>The size of the ellipse may also be controlled by specifying the value
of a t-statistic on its boundary.  This defaults to the appropriate
value for the confidence region.
</p>
</td></tr>
<tr><td><code id="ellipse3d_+3A_which">which</code></td>
<td>

<p>This parameter selects which variables from the object will be
plotted.  The default is the first 3.
</p>
</td></tr>
<tr><td><code id="ellipse3d_+3A_subdivide">subdivide</code></td>
<td>

<p>This controls the number of subdivisions (see <code><a href="#topic+subdivision3d">subdivision3d</a></code>)
used in constructing the ellipsoid.  Higher numbers give a smoother shape.
</p>
</td></tr>
<tr><td><code id="ellipse3d_+3A_smooth">smooth</code></td>
<td>

<p>If <code>TRUE</code>, smooth interpolation of normals is used; if <code>FALSE</code>, 
a faceted ellipsoid will be displayed.
</p>
</td></tr>
<tr><td><code id="ellipse3d_+3A_dispersion">dispersion</code></td>
<td>

<p>The value of dispersion to use.  If specified, it is treated as fixed,
and chi-square limits for <code>t</code> are used. If missing, it is 
taken from <code>summary(x)</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+mesh3d">mesh3d</a></code> object representing the ellipsoid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot a random sample and an ellipsoid of concentration corresponding to a 95% 
# probability region for a
# trivariate normal distribution with mean 0, unit variances and 
# correlation 0.8.
if (requireNamespace("MASS", quietly = TRUE)) {
  Sigma &lt;- matrix(c(10, 3, 0, 3, 2, 0, 0, 0, 1), 3, 3)
  Mean &lt;- 1:3
  x &lt;- MASS::mvrnorm(1000, Mean, Sigma)
  
  open3d()
  
  plot3d(x, box = FALSE)
  
  plot3d( ellipse3d(Sigma, centre = Mean), col = "green", alpha = 0.5, add = TRUE)
}  

# Plot the estimate and joint 90% confidence region for the displacement and cylinder
# count linear coefficients in the mtcars dataset

data(mtcars)
fit &lt;- lm(mpg ~ disp + cyl , mtcars)

open3d()
plot3d(ellipse3d(fit, level = 0.90), col = "blue", alpha = 0.5, aspect = TRUE)
</code></pre>

<hr>
<h2 id='expect_known_scene'>
Helper for <span class="pkg">testthat</span> testing.
</h2><span id='topic+expect_known_scene'></span>

<h3>Description</h3>

<p>Gets the current scene using <code><a href="#topic+scene3d">scene3d</a></code>, and
compares the result to a saved value, optionally closing
the window afterwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_known_scene(name, 
                   close = TRUE, 
                   file = paste0("testdata/", name, ".rds"),
                   ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_known_scene_+3A_name">name</code></td>
<td>

<p>By default, the base name of the file to save results in.
Not used if <code>file</code> is specified.
</p>
</td></tr>
<tr><td><code id="expect_known_scene_+3A_close">close</code></td>
<td>

<p>Whether to close the <span class="pkg">rgl</span> window after the comparison.
</p>
</td></tr>
<tr><td><code id="expect_known_scene_+3A_file">file</code></td>
<td>

<p>The file in which to save the result.
</p>
</td></tr>
<tr><td><code id="expect_known_scene_+3A_...">...</code></td>
<td>

<p>Other arguments which will be passed to <code><a href="testthat.html#topic+expect_known_value">expect_known_value</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code><a href="testthat.html#topic+expect_known_value">expect_known_value</a></code> 
to save a representation of the scene.  During the comparison, the scene
is modified so that non-reproducible aspects are standardized
or omitted:  
</p>

<ul>
<li><p>object ids are changed to start at 1.
</p>
</li>
<li><p>system-specific font names and texture names are deleted.
</p>
</li>
<li><p>the window is shifted to the top left of the screen.
</p>
</li></ul>

<p>Calls to <code>expect_known_scene()</code> enable <code>testthat::<a href="testthat.html#topic+local_edition">local_edition</a>(2)</code> 
for the duration of the call, so it will work in <span class="pkg">testthat</span> &ldquo;3rd edition&rdquo;.
</p>


<h3>Value</h3>

<p>A value describing the changes to the saved object,
suitable for use in <code><a href="testthat.html#topic+test_that">test_that</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# These lines can be included in testthat::test_that() code.
plot3d(1:10, 1:10, 1:10)
expect_known_scene("plot")

## End(Not run)
</code></pre>

<hr>
<h2 id='extrude3d'>
Generate extrusion mesh
</h2><span id='topic+extrude3d'></span>

<h3>Description</h3>

<p>Given a two-dimensional polygon, this generates a three-dimensional extrusion
of the shape by triangulating the polygon and creating a cylinder with
that shape as the end faces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrude3d(x, y = NULL, thickness = 1, smooth = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrude3d_+3A_x">x</code>, <code id="extrude3d_+3A_y">y</code></td>
<td>

<p>A polygon description in one of the forms supported by <code><a href="#topic+triangulate">triangulate</a></code>.
</p>
</td></tr>
<tr><td><code id="extrude3d_+3A_thickness">thickness</code></td>
<td>

<p>The extrusion will have this thickness.
</p>
</td></tr>
<tr><td><code id="extrude3d_+3A_smooth">smooth</code></td>
<td>

<p>logical; should normals be added so that the edges of the extrusion appear
smooth?
</p>
</td></tr>
<tr><td><code id="extrude3d_+3A_...">...</code></td>
<td>

<p>Other parameters to pass to <code><a href="#topic+tmesh3d">tmesh3d</a></code> when constructing the
mesh.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extrusion is always constructed with the polygon in the xy plane at
<code>z = 0</code> and another copy at <code>z = thickness</code>.  Use
the transformation functions (e.g. <code><a href="#topic+rotate3d">rotate3d</a></code>) to 
obtain other orientations and placements.
</p>


<h3>Value</h3>

<p>A mesh object containing a triangulation of the polygon
for each face, and quadrilaterals for the sides.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polygon3d">polygon3d</a></code> for a simple polygon, <code><a href="#topic+triangulate">triangulate</a></code> for
the triangulation, <code><a href="#topic+turn3d">turn3d</a></code> for a solid of rotation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:10, 10:1)
y &lt;- rev(c(rep(c(0, 2), 5), rep(c(1.5, -0.5), 5)))
plot(x, y, type = "n")
polygon(x, y)
open3d()
shade3d( extrude3d(x, y), col = "red" )
</code></pre>

<hr>
<h2 id='facing3d'>
Subset an object to parts facing in a particular direction
</h2><span id='topic+facing3d'></span><span id='topic+projectDown'></span>

<h3>Description</h3>

<p><code>facing3d</code> subsets an object by converting it to a triangle mesh,
then subsetting to those triangles that are counterclockwise
(for <code>front = TRUE</code>) when projected into a plane.
</p>
<p><code>projectDown</code> computes a projection that &ldquo;looks down&rdquo; the specified direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facing3d(obj, up = c(0, 0, 1), 
         P = projectDown(up), 
         front = TRUE, strict = TRUE)
projectDown(up)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facing3d_+3A_obj">obj</code></td>
<td>

<p>An object that can be converted to a triangular mesh object.
</p>
</td></tr>
<tr><td><code id="facing3d_+3A_up">up</code></td>
<td>

<p>The direction that is to be considered &ldquo;up&rdquo;.  It may
be either a 3 vector in Euclidean coordinates or a 4 vector in
homogeneous coordinates.
</p>
</td></tr>
<tr><td><code id="facing3d_+3A_p">P</code></td>
<td>

<p>The projection to use for draping, a 4x4 matrix.  See <code><a href="#topic+drape3d">drape3d</a></code> for details on how <code>P</code> is used.
</p>
</td></tr>
<tr><td><code id="facing3d_+3A_front">front</code></td>
<td>

<p>If <code>front = TRUE</code>, retains triangles that are counterclockwise after projection by <code>P</code>, otherwise
retains those that are clockwise.
</p>
</td></tr>
<tr><td><code id="facing3d_+3A_strict">strict</code></td>
<td>
<p>If <code>TRUE</code>, drops indeterminate triangles
(those that are annihilated by <code>P</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default 
the returned subset will be those triangles whose upper side
matches <code>front</code>.  Change <code>up</code> or use an
arbitrary projection for different subsets.
</p>
<p><code><a href="#topic+drape3d">drape3d</a></code> and <code><a href="#topic+shadow3d">shadow3d</a></code> project objects onto meshes; these functions can be used to
project only onto the top or front.
</p>


<h3>Value</h3>

<p><code>facing3d</code> returns a mesh object made of those triangles which face in the 
desired direction.
</p>
<p><code>projectDown</code> computes a 4x4 matrix.   The first two
coordinates of <code>asEuclidean(x %*% projectDown(up))</code> 
give a projection of <code>x</code> from above into a plane, where 
<code>up</code> determines which direction is taken to be &ldquo;up&rdquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drape3d">drape3d</a></code>, <code><a href="#topic+shadow3d">shadow3d</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
d &lt;- rnorm(3)
d &lt;- d/sqrt(sum(d^2))
shade3d( facing3d( icosahedron3d(), up = d, strict = FALSE), 
         col = "yellow")
wire3d( facing3d( icosahedron3d(), up = d, front = FALSE), 
         col = "black")
# Show the direction:
arrow3d(-2*d , -d)
</code></pre>

<hr>
<h2 id='figWidth'>
Get R Markdown figure dimensions in pixels
</h2><span id='topic+figWidth'></span><span id='topic+figHeight'></span>

<h3>Description</h3>

<p>In an R Markdown document, figure dimensions are normally
specified in inches; these are translated into pixel
dimensions when HTML output is requested and <code><a href="#topic+rglwidget">rglwidget</a></code> is used.  These functions reproduce that
translation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>figWidth()
figHeight()
</code></pre>


<h3>Value</h3>

<p>When used in an R Markdown document, these functions
return the requested current dimensions of figures in pixels.  Outside such a document, <code>NULL</code>
is returned.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'># No useful return value outside of R Markdown:
figWidth()
figHeight()
</code></pre>

<hr>
<h2 id='getBoundary3d'>
Extract the boundary of a mesh
</h2><span id='topic+getBoundary3d'></span>

<h3>Description</h3>

<p>Constructs a mesh of line segments corresponding to
non-shared (i.e. boundary) edges of triangles or quads
in the original mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBoundary3d(mesh, sorted = FALSE, simplify = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBoundary3d_+3A_mesh">mesh</code></td>
<td>

<p>A mesh object.
</p>
</td></tr>
<tr><td><code id="getBoundary3d_+3A_sorted">sorted</code></td>
<td>

<p>Whether the result should have the segments sorted in
sequential order.
</p>
</td></tr>
<tr><td><code id="getBoundary3d_+3A_simplify">simplify</code></td>
<td>

<p>Whether to simplify the resulting mesh, dropping all unused
vertices.  If <code>FALSE</code>, the vertices of the result will 
be identical to the vertices of <code>mesh</code>; if <code>TRUE</code>,
they will likely be different, even if no vertices were dropped.
</p>
</td></tr>
<tr><td><code id="getBoundary3d_+3A_...">...</code></td>
<td>

<p>Material properties to apply to the mesh.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"mesh3d"</code> object containing 0 or more segments.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mesh3d">mesh3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cube3d(col = "blue")
x$ib &lt;- x$ib[,-(1:2)]
b &lt;- getBoundary3d(x, sorted = TRUE, col = "black")

open3d()
shade3d(x, alpha=0.2)

shade3d(b) 

# Show edge vertices in sequence:
text3d(t(b$vb), texts = 1:ncol(b$vb), adj = 0)
c(b$is[1,1], b$is[2,]) 
</code></pre>

<hr>
<h2 id='gltfTypes'>
Names of glTF types.
</h2><span id='topic+gltfTypes'></span>

<h3>Description</h3>

<p>The glTF specification packs data into buffers, labelling
the type of each part with an integer.  The first six values
in <code>gltfTypes</code> are the
integers used there, with <code>"int"</code> and <code>"double"</code>
added for completeness; those values are taken from
OpenGL header files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gltfTypes</code></pre>


<h3>Format</h3>

<p><code>gltfTypes</code> is simply a named vector containing integer values.
</p>


<h3>Details</h3>

<p>These are used in the <code><a href="#topic+Buffer">Buffer</a></code> object.
</p>


<h3>References</h3>

<p><a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#_accessor_componenttype">https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#_accessor_componenttype</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gltfTypes
</code></pre>

<hr>
<h2 id='GramSchmidt'>
The Gram-Schmidt algorithm
</h2><span id='topic+GramSchmidt'></span>

<h3>Description</h3>

<p>Generate a 3x3 orthogonal matrix using the Gram-Schmidt algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GramSchmidt(v1, v2, v3, order = 1:3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GramSchmidt_+3A_v1">v1</code>, <code id="GramSchmidt_+3A_v2">v2</code>, <code id="GramSchmidt_+3A_v3">v3</code></td>
<td>

<p>Three length 3 vectors (taken as row vectors).
</p>
</td></tr>
<tr><td><code id="GramSchmidt_+3A_order">order</code></td>
<td>

<p>The precedence order for the vectors; see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function orthogonalizes the matrix <code>rbind(v1, v2, v3)</code>
using the Gram-Schmidt algorithm.  It can handle rank 2 matrices
(returning a rank 3 matrix).  If the original is rank 1, it is likely
to fail.
</p>
<p>The <code>order</code> vector determines the precedence of the original
vectors. For example, if it is <code>c(i, j, k)</code>, then row <code>i</code> 
will be unchanged (other than normalization); row <code>j</code> will
normally be transformed within the span of rows <code>i</code> and <code>j</code>.  
Row <code>k</code> will be transformed orthogonally to the span of
the others.
</p>


<h3>Value</h3>

<p>A 3x3 matrix whose rows are the orthogonalization of the original
row vectors.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Proceed through the rows in order
print(A &lt;- matrix(rnorm(9), 3, 3))
GramSchmidt(A[1, ], A[2, ], A[3, ])

# Keep the middle row unchanged
print(A &lt;- matrix(c(rnorm(2), 0, 1, 0, 0, rnorm(3)), 3, 3, byrow = TRUE))
GramSchmidt(A[1, ], A[2, ], A[3, ], order = c(2, 1, 3))
</code></pre>

<hr>
<h2 id='grid3d'>Add a grid to a 3D plot </h2><span id='topic+grid3d'></span>

<h3>Description</h3>

<p>This function adds a reference grid to an RGL plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid3d(side, at = NULL, col = "gray", lwd = 1, lty = 1, n = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid3d_+3A_side">side</code></td>
<td>
<p> Where to put the grid; see the Details section. </p>
</td></tr>
<tr><td><code id="grid3d_+3A_at">at</code></td>
<td>
<p> How to draw the grid; see the Details section. </p>
</td></tr>
<tr><td><code id="grid3d_+3A_col">col</code></td>
<td>
<p> The color of the grid lines. </p>
</td></tr>
<tr><td><code id="grid3d_+3A_lwd">lwd</code></td>
<td>
<p> The line width of the grid lines. (Currently only
<code>lty = 1</code> is supported.)</p>
</td></tr>
<tr><td><code id="grid3d_+3A_lty">lty</code></td>
<td>
<p> The line type of the grid lines. </p>
</td></tr>
<tr><td><code id="grid3d_+3A_n">n</code></td>
<td>
<p> Suggested number of grid lines; see the Details section. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code><a href="graphics.html#topic+grid">grid</a></code> in classic graphics,
except that it draws a 3D grid in the plot.
</p>
<p>The grid is drawn in a plane perpendicular to the coordinate axes. The
first letter of the <code>side</code> argument specifies the direction of
the plane: <code>"x"</code>, <code>"y"</code> or <code>"z"</code> (or uppercase
versions) to specify the coordinate which is constant on the plane.
</p>
<p>If <code>at = NULL</code> (the default), the grid is drawn at the limit of 
the box around the data.  If the second letter of the <code>side</code> argument
is <code>"-"</code> or is not present, it is the lower limit; if <code>"+"</code>
then at the upper limit.  The grid lines are drawn at values
chosen by <code><a href="base.html#topic+pretty">pretty</a></code> with <code>n</code> suggested locations.
The default locations should match those chosen by <code><a href="#topic+axis3d">axis3d</a></code>
with <code>nticks = n</code>.
</p>
<p>If <code>at</code> is a numeric vector, the grid lines are drawn at those values.
</p>
<p>If <code>at</code> is a list, then the <code>"x"</code> component is used to
specify the x location, the <code>"y"</code> component specifies the y location, and
the <code>"z"</code> component specifies the z location.  Missing components
are handled using the default as for <code>at = NULL</code>.
</p>
<p>Multiple grids may be drawn by specifying multiple values for <code>side</code>
or for the component of <code>at</code> that specifies the grid location.
</p>


<h3>Value</h3>

<p> A vector or matrix of object ids is returned invisibly. </p>


<h3>Note</h3>

<p>If the scene is resized, the grid will not be resized; use <code><a href="#topic+abclines3d">abclines3d</a></code>
to draw grid lines that will automatically resize.
</p>


<h3>Author(s)</h3>

<p> Ben Bolker and Duncan Murdoch </p>


<h3>See Also</h3>

 <p><code><a href="#topic+axis3d">axis3d</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
y &lt;- 1:10
z &lt;- matrix(outer(x - 5, y - 5) + rnorm(100), 10, 10)
open3d()
persp3d(x, y, z, col = "red", alpha = 0.7, aspect = c(1, 1, 0.5))
grid3d(c("x", "y+", "z"))
</code></pre>

<hr>
<h2 id='hover3d'>
Display hover info in plot.
</h2><span id='topic+hover3d'></span>

<h3>Description</h3>

<p>This adds text to identify points within a plot when the mouse is near 
them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hover3d(x, y = NULL, z = NULL, 
        labeller = NULL, 
        tolerance = 20, 
        persist = c("no", "one", "yes"), 
        labels = seq_along(x),
        adj = c(-0.2, 0.5),
        scene = scene3d(minimal = FALSE),
        applyToScene = TRUE,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hover3d_+3A_x">x</code>, <code id="hover3d_+3A_y">y</code>, <code id="hover3d_+3A_z">z</code></td>
<td>

<p>Coordinates of point to identify. Any reasonable way of defining the
coordinates is acceptable.  See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code> for details. 
Alternatively, <code>x</code> may be the id of a single existing 
object, and its vertices will be used.
</p>
</td></tr>
<tr><td><code id="hover3d_+3A_labeller">labeller</code></td>
<td>

<p>A function to display information about identified points. <code>NULL</code>
indicates the default function, described in Details.
</p>
</td></tr>
<tr><td><code id="hover3d_+3A_tolerance">tolerance</code></td>
<td>

<p>How close (in pixels) the mouse should be to a point to display the
information.
</p>
</td></tr>
<tr><td><code id="hover3d_+3A_persist">persist</code></td>
<td>

<p>Should the label persist?  If <code>"no"</code> (the default), it will be removed
when the mouse moves away.  If <code>"one"</code>, it will be removed when 
another point is closer to the mouse.  If <code>"yes"</code>, it will 
not be removed.
</p>
</td></tr>
<tr><td><code id="hover3d_+3A_labels">labels</code></td>
<td>

<p>If the default <code>labeller</code> is used, these labels will be displayed.
</p>
</td></tr>
<tr><td><code id="hover3d_+3A_adj">adj</code></td>
<td>

<p>If the default <code>labeller</code> is used, this adjustment will be passed
to <code><a href="#topic+text3d">text3d</a></code> to display the labels.
</p>
</td></tr>
<tr><td><code id="hover3d_+3A_scene">scene</code>, <code id="hover3d_+3A_applytoscene">applyToScene</code></td>
<td>

<p>Arguments to pass to <code><a href="#topic+setUserCallbacks">setUserCallbacks</a></code>.
The <code>applyToDev</code> argument to that function is always
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="hover3d_+3A_...">...</code></td>
<td>

<p>Additional arguments that will be passed to the labeller.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If specified, the <code>labeller</code> argument should specify a
function with arguments
compatible with <code>function(index, ...)</code>.  It will be called with
<code>index</code> being the index of the point that was selected.  It should
plot the label, and return the <span class="pkg">rgl</span> ids of the objects that were 
plotted.
</p>
<p>When <code>applyToScene</code> is <code>TRUE</code>, all labels
or labelling objects will be created and attached to the scene.  You may want to
delete them (using the ids returned in <code>idverts</code> and
<code>idtexts</code>) once <code><a href="#topic+rglwidget">rglwidget</a></code> has been called,
as they serve no purpose in the current device.
</p>
<p>Only one hover handler is supported per scene or device.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+lowlevel">lowlevel</a></code> vector of ids is returned invisibly.
If <code>applyToScene</code> is <code>TRUE</code>, it will contain the
ids of the temporary objects created for Javascript.
It will also have these attributes:
</p>
<table>
<tr><td><code>oldPar</code></td>
<td>
<p>Values of <code><a href="#topic+par3d">par3d</a></code> parameters that were changed.
Currently only <code>"mouseMode"</code>.</p>
</td></tr>
<tr><td><code>oldDev</code></td>
<td>
<p>The value of <code>cur3d()</code> at the time of calling, so that
<code>oldPar</code> can be restored to the right device.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+identify3d">identify3d</a></code> and <code><a href="#topic+selectpoints3d">selectpoints3d</a></code>
work in the <span class="pkg">rgl</span> device and return information
about the selections. <code><a href="#topic+setUserCallbacks">setUserCallbacks</a></code>
is the underlying function used by <code>hover3d</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a labeller to show the coordinates of the selected point.
labelLocation &lt;- function(x, y = NULL, z = NULL) {
  xyz &lt;- xyz.coords(x, y, z)
  function(sel, ...) {
    p &lt;- with(xyz, matrix(c(x[sel], y[sel], z[sel]), ncol = 3))
    c(text3d(p, texts = sprintf("x:%.2f", p[1]), 
                  adj = c(-0.2, -0.6), ...),
      text3d(p, texts = sprintf("y:%.2f", p[2]),
                  adj = c(-0.2, 0.5), ...),
      text3d(p, texts = sprintf("z:%.2f", p[3]),
                  adj = c(-0.2, 1.6), ...))
  }
}

xyz &lt;- matrix(rnorm(30), ncol = 3)
open3d()
ids &lt;- plot3d(xyz)
hover3d(xyz, labeller = labelLocation(xyz), col = "red", cex = 0.8)
# The same thing using the data id:
# hover3d(ids["data"], 
#         labeller = labelLocation(rgl.attrib(ids["data"], "vertices")), 
#         col = "red", cex = 0.8)
</code></pre>

<hr>
<h2 id='identify3d'>
Identify points in plot
</h2><span id='topic+identify3d'></span>

<h3>Description</h3>

<p>Identify points in a plot, similarly to the <code><a href="graphics.html#topic+identify">identify</a></code> function
in base graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify3d(x, y = NULL, z = NULL, labels = seq_along(x), n = length(x), 
	plot = TRUE, adj = c(-0.1, 0.5), tolerance = 20, 
	buttons = c("right", "middle"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify3d_+3A_x">x</code>, <code id="identify3d_+3A_y">y</code>, <code id="identify3d_+3A_z">z</code></td>
<td>
<p>coordinates of points in a scatter plot.  Alternatively, any
object which defines coordinates (see <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>) 
can be given as <code>x</code>, and <code>y</code> and <code>z</code> left missing.</p>
</td></tr>
<tr><td><code id="identify3d_+3A_labels">labels</code></td>
<td>
<p>an optional character vector giving labels for the
points.  Will be coerced using <code><a href="base.html#topic+as.character">as.character</a></code>, and
recycled if necessary to the length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="identify3d_+3A_n">n</code></td>
<td>
<p>the maximum number of points to be identified.</p>
</td></tr>
<tr><td><code id="identify3d_+3A_plot">plot</code></td>
<td>
<p>logical: if <code>plot</code> is <code>TRUE</code>, the labels are
printed near the points and if <code>FALSE</code> they are omitted.</p>
</td></tr>
<tr><td><code id="identify3d_+3A_adj">adj</code></td>
<td>
<p>numeric vector to use as <code>adj</code> parameter to 
<code><a href="#topic+text3d">text3d</a></code> when plotting the labels.</p>
</td></tr>
<tr><td><code id="identify3d_+3A_tolerance">tolerance</code></td>
<td>
<p>the maximal distance (in pixels) 
for the pointer to be &lsquo;close enough&rsquo; to a point.</p>
</td></tr>
<tr><td><code id="identify3d_+3A_buttons">buttons</code></td>
<td>
<p>a length 1 or 2 character vector giving the buttons
to use for selection and quitting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>buttons</code> is length 1, the user can quit by reaching <code>n</code>
selections, or by hitting the 
escape key, but the result will be lost if escape is used.
</p>


<h3>Value</h3>

<p>A vector of selected indices.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+identify">identify</a></code> for base graphics, <code><a href="#topic+select3d">select3d</a></code> for selecting regions.
</p>

<hr>
<h2 id='import'>Imported from magrittr</h2><span id='topic++25+3E+25'></span><span id='topic+pipe'></span>

<h3>Description</h3>

<p>This object is imported from <span class="pkg">magrittr</span>. Follow the link to its documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<p>Pipes can be used to string together
<code><a href="#topic+rglwidget">rglwidget</a></code> calls and <code><a href="#topic+playwidget">playwidget</a></code>
calls.  See <code><a href="#topic+ageControl">ageControl</a></code> for an example.
</p>

<hr>
<h2 id='in_pkgdown_example'>
Are we running in a <span class="pkg">pkgdown</span> example?
</h2><span id='topic+in_pkgdown_example'></span>

<h3>Description</h3>

<p>This is mainly for internal use to decide whether results
should be automatically included in a <span class="pkg">pkgdown</span> web
page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_pkgdown_example()
</code></pre>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>in_pkgdown_example()
</code></pre>

<hr>
<h2 id='light'>Add light source</h2><span id='topic+light3d'></span>

<h3>Description</h3>

<p>add a light source to the scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light3d(theta=0, phi=15,
        x=NULL, y = NULL, z = NULL,
        viewpoint.rel = TRUE, 
        ambient = "#FFFFFF", 
        diffuse = "#FFFFFF", 
        specular = "#FFFFFF")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_+3A_theta">theta</code>, <code id="light_+3A_phi">phi</code></td>
<td>
<p>direction to infinitely distant light</p>
</td></tr>
<tr><td><code id="light_+3A_x">x</code>, <code id="light_+3A_y">y</code>, <code id="light_+3A_z">z</code></td>
<td>
<p>position of finitely distant light</p>
</td></tr>
<tr><td><code id="light_+3A_viewpoint.rel">viewpoint.rel</code></td>
<td>
<p>logical, if TRUE light is a viewpoint light that is positioned relative to the current viewpoint</p>
</td></tr>
<tr><td><code id="light_+3A_ambient">ambient</code>, <code id="light_+3A_diffuse">diffuse</code>, <code id="light_+3A_specular">specular</code></td>
<td>
<p> light color values used for lighting calculation </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Up to 8 light sources are supported. They are positioned either in
world space or relative to the camera. By providing polar
coordinates to <code>theta</code> and <code>phi</code> a directional light source is used. If
numerical values are given to x, y and z, a point-like light source with
finite distance to the objects in the scene is set up.
</p>
<p>If <code>x</code> is non-null, <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code> will
be used to form the location values, so all three coordinates
can be specified in <code>x</code>.
</p>
<p>If no lights have been added to a subscene, lights from the parent
subscene will be used.
</p>
<p>See <code><a href="#topic+material3d">material3d</a></code> for a discussion of how
the components of the light affect the display of objects.
</p>


<h3>Value</h3>

<p>This function is called for the side effect of adding a light.  A light ID is
returned to allow <code><a href="#topic+pop3d">pop3d</a></code> to remove it.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clear3d">clear3d</a></code>
<code><a href="#topic+pop3d">pop3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# a lightsource moving through the scene
#
data(volcano)
z &lt;- 2 * volcano # Exaggerate the relief
x &lt;- 10 * (1:nrow(z)) # 10 meter spacing (S to N)
y &lt;- 10 * (1:ncol(z)) # 10 meter spacing (E to W)
zlim &lt;- range(z)
zlen &lt;- zlim[2] - zlim[1] + 1
colorlut &lt;- terrain.colors(zlen) # height color lookup table
col &lt;- colorlut[ z - zlim[1] + 1 ] # assign colors to heights for each point

open3d()
bg3d("gray50")
surface3d(x, y, z, color = col, back = "lines")
r &lt;- max(y) - mean(y)
lightid &lt;- spheres3d(1, 1, 1, alpha = 0)
frame &lt;- function(time) {
    a &lt;- pi*(time - 1)
    save &lt;- par3d(skipRedraw = TRUE)
    clear3d(type = "lights")
    pop3d(id = lightid)
    xyz &lt;- matrix(c(r*sin(a) + mean(x), r*cos(a) + mean(y), max(z)), ncol = 3)
    light3d(x = xyz, diffuse = "gray75", 
            specular = "gray75", viewpoint.rel = FALSE) 
    light3d(diffuse = "gray10", specular = "gray25")
    lightid &lt;&lt;- spheres3d(xyz, emission = "white", radius = 4)
    par3d(save)
    Sys.sleep(0.02)
    NULL
}
play3d(frame, duration = 2)
</code></pre>

<hr>
<h2 id='makeDependency'>
Process Javascript for HTML dependency
</h2><span id='topic+makeDependency'></span><span id='topic+RGL_DEBUGGING'></span>

<h3>Description</h3>

<p>A utility function to help in development of internal 
Javascript code, this function processes the Javascript
to minify it and report on errors and bad style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDependency(name, src, script = NULL, package, 
               version = packageVersion(package),
               minifile = paste0(basename(src), ".min.js"),
               debugging = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDependency_+3A_name">name</code>, <code id="makeDependency_+3A_src">src</code>, <code id="makeDependency_+3A_script">script</code>, <code id="makeDependency_+3A_package">package</code>, <code id="makeDependency_+3A_version">version</code>, <code id="makeDependency_+3A_...">...</code></td>
<td>

<p>Arguments to pass to <code>htmltools::<a href="htmltools.html#topic+htmlDependency">htmlDependency</a>.</code>
</p>
</td></tr>
<tr><td><code id="makeDependency_+3A_minifile">minifile</code></td>
<td>
<p>Basename of minified file.</p>
</td></tr>
<tr><td><code id="makeDependency_+3A_debugging">debugging</code></td>
<td>

<p>See details below.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a utility function used by RGL 
to process its Javascript code used when displaying <code><a href="#topic+rglwidget">rglwidget</a></code> values.  It may be helpful in other packages to use
in their own installation.
</p>
<p>If the <span class="pkg">js</span> package version 1.2 or greater is installed,
the Javascript code will be minified and stored in the file named
by <code>minifile</code> in the <code>src</code> directory.  Syntax errors
in the code will stop the process; unused variables will be
reported.
</p>
<p>If <code>debugging</code> is <code>TRUE</code>, the locations of Javascript syntax
errors will be reported, along with hints about improvements,
and the original files will be used in the dependency object
that is created.
</p>
<p>If <code>debugging</code> is <code>FALSE</code> (the default), 
the minified file will be used in the dependency object,
hints won't be given, and syntax errors will lead to an
uninformative failure to minify.
</p>


<h3>Value</h3>

<p>An object that can be included in a list of dependencies passed to <code>htmltools::<a href="htmltools.html#topic+htmlDependencies">attachDependencies</a></code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This is a slightly simplified version of the code used to 
# produce one of the dependencies for rglwidget().  
# It writes to the system library copy of rgl so 
# has been marked not to run in the example code.

makeDependency("rglwidgetClass", 
               src = "htmlwidgets/lib/rglClass",
               script = c("rglClass.src.js",
                          "utils.src.js",
                          "buffer.src.js",
                          "subscenes.src.js",
                          "shaders.src.js",
                          "textures.src.js",
                          "projection.src.js",
                          "mouse.src.js",
                          "init.src.js",
                          "pieces.src.js",
                          "draw.src.js",
                          "controls.src.js",
                          "selection.src.js",
                          "rglTimer.src.js",
                          "pretty.src.js",
                          "axes.src.js",
                          "animation.src.js"),
               stylesheet = "rgl.css",
               package = "rgl",
               debugging = isTRUE(as.logical(Sys.getenv("RGL_DEBUGGING", "FALSE"))))

## End(Not run)
</code></pre>

<hr>
<h2 id='material3d'>Get or set material properties</h2><span id='topic+material3d'></span><span id='topic+rgl.material.names'></span><span id='topic+rgl.material.readonly'></span>

<h3>Description</h3>

<p>Get or set material properties for geometry appearance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>material3d(..., id = NULL)

rgl.material.names
rgl.material.readonly
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="material3d_+3A_...">...</code></td>
<td>
<p>Material properties to set or query.</p>
</td></tr>
<tr><td><code id="material3d_+3A_id">id</code></td>
<td>

<p>the <span class="pkg">rgl</span> id of an object to query, or <code>NULL</code>
to query or set the defaults.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <span class="pkg">rgl</span> scene, each object has &ldquo;material properties&rdquo; that control how it is rendered and (in the case of <code>tag</code>) 
that can be used to store a 
label or other information.  <code>material3d</code> sets defaults
for these properties and queries the defaults or specific
values for an individual object.
</p>
<p>To set values, use <code>name = value</code> settings, e.g.
<code>material3d(color = "red")</code>.  To query values, 
specify the property or properties in a character vector,
e.g. <code>material3d("color")</code>.  
</p>
<p>Only one side at a time can be culled.
</p>
<p>The <code>material</code> member of the <code><a href="#topic+r3dDefaults">r3dDefaults</a></code> list may be used to 
set default values for material properties.
</p>


<h3>Value</h3>

<p><code>material3d()</code> returns values similarly
to <code><a href="#topic+par3d">par3d</a></code>:
When setting properties, it returns the previous values
invisibly in a named list.  When querying multiple values, a
named list is returned. When a single value is queried it is
returned directly.
</p>


<h3>Material Properties</h3>

<p>The <code>rgl.material.names</code> variable contains the
full list of material names.
The following read-write material properties control
the appearance
of objects in an <span class="pkg">rgl</span> scene.
</p>

<dl>
<dt>color</dt><dd>
<p>vector of R color characters. Represents the diffuse component in case of lighting calculation (lit = TRUE),
otherwise it describes the solid color characteristics.
</p>
</dd>
<dt>lit</dt><dd>
<p>logical, specifying if lighting calculation should take place on geometry
</p>
</dd>
<dt>ambient, specular, emission, shininess</dt><dd>
<p>properties for lighting calculation. ambient, specular, emission are R color character string values; shininess represents a
numerical.
</p>
</dd>
<dt>alpha</dt><dd> 
<p>vector of alpha values between 0.0 (fully transparent) .. 1.0 (opaque).
</p>
</dd>
<dt>smooth</dt><dd>
<p>logical, specifying whether smooth shading or flat shading
should be used.  For smooth shading, Gouraud shading is
used in <span class="pkg">rgl</span> windows, while Phong shading is used 
in WebGL.
</p>
</dd>
<dt>texture</dt><dd> 
<p>path to a texture image file. See the Textures section
below for details.
</p>
</dd>
<dt>textype</dt><dd>
<p>specifies what is defined with the pixmap
</p>

<dl>
<dt>&quot;alpha&quot;</dt><dd><p>alpha values</p>
</dd>
<dt>&quot;luminance&quot;</dt><dd><p>luminance</p>
</dd>
<dt>&quot;luminance.alpha&quot;</dt><dd><p>luminance and alpha</p>
</dd>
<dt>&quot;rgb&quot;</dt><dd><p>color</p>
</dd>
<dt>&quot;rgba&quot;</dt><dd><p>color and alpha texture</p>
</dd>
</dl>

<p>Note that support for these modes is slightly different
in the display within R versus the WebGL display using
<code>rglwidget()</code>.  In particular, in WebGL 
<code>textype = "alpha"</code> will always take the alpha value from
the luminance (i.e. the average of the R, G and B channels) 
of the texture, whereas the R display bases
the choice on the internal format of the texture file.
</p>
</dd>
<dt>texmode</dt><dd>
<p>specifies how the texture interacts with the existing
color
</p>

<dl>
<dt>&quot;replace&quot;</dt><dd><p>texture value replaces existing value</p>
</dd>
<dt>&quot;modulate&quot;</dt><dd><p>default; texture value multiplies existing value</p>
</dd>
<dt>&quot;decal&quot;</dt><dd><p>for <code>textype = "rgba"</code>, texture
is mixed with existing value</p>
</dd>
<dt>&quot;blend&quot;</dt><dd><p>uses the texture to blend the existing
value with black</p>
</dd>
<dt>&quot;add&quot;</dt><dd><p>adds the texture value to the existing.
May not be available in the R display with very old
OpenGL drivers.</p>
</dd>
</dl>

</dd>
<dt>texmipmap</dt><dd>
<p>Logical, specifies if the texture should be mipmapped.
</p>
</dd>
<dt>texmagfilter</dt><dd>
<p>specifies the magnification filtering type (sorted by ascending quality):
</p>

<dl>
<dt>&quot;nearest&quot;</dt><dd><p>texel nearest to the center of the pixel</p>
</dd>
<dt>&quot;linear&quot;</dt><dd><p>weighted linear average of a 2x2 array of texels</p>
</dd>
</dl>

</dd>
<dt>texminfilter</dt><dd>
<p>specifies the minification filtering type (sorted by ascending quality):
</p>

<dl>
<dt>&quot;nearest&quot;</dt><dd><p>texel nearest to the center of the pixel</p>
</dd>
<dt>&quot;linear&quot;</dt><dd><p>weighted linear average of a 2x2 array of texels</p>
</dd>
<dt>&quot;nearest.mipmap.nearest&quot;</dt><dd><p>low quality mipmapping</p>
</dd>
<dt>&quot;nearest.mipmap.linear&quot;</dt><dd><p>medium quality mipmapping</p>
</dd>
<dt>&quot;linear.mipmap.nearest&quot;</dt><dd><p>medium quality mipmapping</p>
</dd>
<dt>&quot;linear.mipmap.linear&quot;</dt><dd><p>high quality mipmapping</p>
</dd>
</dl>

</dd>
<dt>texenvmap</dt><dd>
<p>logical, specifies if auto-generated texture coordinates for environment-mapping 
should be performed on geometry.
</p>
</dd>
<dt>front, back</dt><dd>
<p>Determines the polygon mode for the specified side:
</p>

<dl>
<dt>&quot;filled&quot;</dt><dd><p>filled polygon</p>
</dd>
<dt>&quot;lines&quot;</dt><dd><p>wireframed polygon</p>
</dd>
<dt>&quot;points&quot;</dt><dd><p>point polygon</p>
</dd>
<dt>&quot;culled&quot;</dt><dd><p>culled (hidden) polygon</p>
</dd>
</dl>

</dd>
<dt>size</dt><dd> 
<p>numeric, specifying the size of points in pixels
</p>
</dd>
<dt>lwd</dt><dd>
<p>numeric, specifying the line width in pixels
</p>
</dd>
<dt>fog</dt><dd><p>logical, specifying if fog effect should be applied on the corresponding shape.  Fog type is set in <code><a href="#topic+bg3d">bg3d</a></code>.</p>
</dd>
<dt>point_antialias, line_antialias</dt><dd><p>logical, specifying if points should be round and lines 
should be antialiased, but see Note below.</p>
</dd>
<dt>depth_mask</dt><dd><p>logical, specifying whether the object's depth
should be stored.</p>
</dd>
<dt>depth_test</dt><dd><p>Determines which depth test is used to see if this
object is visible, depending on its apparent depth in the scene
compared to the stored depth. Possible values are <code>"never"</code>,
<code>"less"</code> (the default), <code>"equal"</code>, <code>"lequal"</code>
(less than or equal), <code>"greater"</code>, <code>"notequal"</code>,
<code>"gequal"</code> (greater than or equal), <code>"always"</code>.</p>
</dd>
<dt>polygon_offset</dt><dd><p>A one or two element
vector giving the &lsquo;<span class="samp">&#8288;factor&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;units&#8288;</span>&rsquo; values
to use in a <code>glPolygonOffset()</code> call in OpenGL.  If
only one value is given, it is used for both elements.
The &lsquo;<span class="samp">&#8288;units&#8288;</span>&rsquo; value is added to the depth of all pixels in
a filled polygon,
and the &lsquo;<span class="samp">&#8288;factor&#8288;</span>&rsquo; value is multiplied by an estimate of
the slope of the polygon and then added to the depth.  Positive values &ldquo;push&rdquo; polygons back slightly for the purpose
of depth testing, to allow points, lines or other polygons
to be drawn on the surface without being obscured due 
to rounding error.  Negative values pull the object forward.
A typical value to use is <code>1</code> (which
is automatically expanded to <code>c(1,1)</code>).
If values are too large, objects which should be behind
the polygon will show through, and if values are too small,
the objects on the surface will be partially obscured. 
Experimentation may be needed to get it right.  The first
example in <code>?<a href="#topic+persp3d">persp3d</a></code> uses this property to add 
grid lines to a surface.</p>
</dd>
<dt>margin, floating</dt><dd><p>Used mainly for text to
draw annotations in the margins, but supported by
most kinds of objects:  see <code><a href="#topic+mtext3d">mtext3d</a></code>.</p>
</dd>
<dt>tag</dt><dd><p>A length 1 string value.  These
may be used to identify objects, or encode other meta
data about the object.</p>
</dd>
<dt>blend</dt><dd><p>Two string values from the list below
describing how transparent objects are blended with
colors behind them.
The first determines the coefficient applied to the 
color of the current object (the source); the second determines
the coefficient applied to the existing color 
(the destination). The resulting
color will be the sum of the two resulting colors.
The allowed strings
correspond to OpenGL constants:
</p>

<dl>
<dt>&quot;zero&quot;</dt><dd><p>Zero; color has no effect.</p>
</dd>
<dt>&quot;one&quot;</dt><dd><p>One; color is added to the other term.</p>
</dd>
<dt>&quot;src_color&quot;, &quot;one_minus_src_color&quot;</dt><dd><p>Multiply by source color or its opposite.</p>
</dd>
<dt>&quot;dst_color&quot;, &quot;one_minus_dst_color&quot;</dt><dd><p>Multiply by destination color or its opposite.</p>
</dd>
<dt>&quot;src_alpha&quot;, &quot;one_minus_src_alpha&quot;</dt><dd><p>Multiply by
source alpha or its opposite.  Default values.</p>
</dd>
<dt>&quot;dst_alpha&quot;, &quot;one_minus_dst_alpha&quot;</dt><dd><p>Multiply by
destination alpha or its opposite.</p>
</dd>
<dt>&quot;constant_color&quot;, &quot;one_minus_constant_color&quot;,
&quot;constant_alpha&quot;, &quot;one_minus_constant_alpha&quot;,
&quot;src_alpha_saturate&quot;</dt><dd><p>These are allowed, but to be useful
they require other settings which <span class="pkg">rgl</span> doesn't
support.</p>
</dd>
</dl>

</dd>
<dt>col</dt><dd><p>An allowed abbreviation of <code>color</code>.</p>
</dd>
</dl>

<p>The <code>rgl.material.readonly</code> variable contains
the subset of material properties that are read-only
so they can be queried
but not set.
Currently there is only one:
</p>

<dl>
<dt>isTransparent</dt><dd><p>Is the current color transparent?</p>
</dd>
</dl>



<h3>Textures</h3>

<p>The <code>texture</code> material property may be <code>NULL</code> or the name of
a bitmap file to be displayed on the surface being rendered.
Currently only PNG format files are supported.
</p>
<p>By default, the colors in the bitmap will modify the color of the
object being plotted.  If the color is black (a common default), you
won't see anything, so a warning may be issued.  You can
suppress the warning by specifying 
the color explicitly, or calling
<code>options{rgl.warnBlackTexture = FALSE}</code>.
</p>
<p>Other aspects of texture display are controlled by the material
properties <code>textype, texmode, texmipmap, texmagfilter,
texminfilter</code> and <code>texenvmap</code> described above.
</p>
<p>For an extensive discussion of textures, see the <a href="../articles/rgl.html#textures">Textures</a> section of the 
<a href="../articles/rgl.html">rgl Overview</a>
vignette.
</p>


<h3>Display of objects</h3>

<p>Object display colors are determined as follows:
</p>

<ul>
<li><p>If <code>lit = FALSE</code>, an element of the <code>color</code> vector property is displayed without modification.  See documentation for individual objects for information on which element is chosen.
</p>
</li>
<li><p>If <code>lit = TRUE</code>, the color is determined as follows.
</p>

<ol>
<li><p>The color is set to the <code>emission</code> property
of the object. 
</p>
</li>
<li><p>For each defined light, the following are added:
</p>

<ul>
<li><p>the product of the <code>ambient</code> color
of the light and the <code>ambient</code> color of the object is added.
</p>
</li>
<li><p>the <code>color</code> of the
object is multiplied by the <code>diffuse</code> color
of the light and by a constant depending on
the angle between the surface and the direction to 
the light, and added.
</p>
</li>
<li><p>the <code>specular</code> color of the object
is multiplied by the <code>specular</code> color of the 
light and a constant depending on the <code>shininess</code>
of the object and the direction to the light, and
added.  The <code>shininess</code> property mainly
determines the size of the shiny highlight; adjust
one or both of the <code>specular</code> colors to change
its brightness.
</p>
</li></ul>


</li></ol>

</li></ul>

<p>If <code>point_antialias</code> is <code>TRUE</code>, points will be drawn as circles in WebGL; otherwise, they
will be drawn as squares.  Within R, the behaviour depends
on your graphics hardware:  for example, I see circles for 
both settings on my laptop.
</p>
<p>Within R, lines tend to appear heavier with <code>line_antialias == TRUE</code>.  There's no difference at all
in WebGL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bbox3d">bbox3d</a></code>,
<code><a href="#topic+bg3d">bg3d</a></code>,
<code><a href="#topic+light3d">light3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>save &lt;- material3d("color")
material3d(color = "red")
material3d("color")
material3d(color = save)

# this illustrates the effect of depth_test
x &lt;- c(1:3); xmid &lt;- mean(x)
y &lt;- c(2, 1, 3); ymid &lt;- mean(y)
z &lt;- 1
open3d()
tests &lt;- c("never", "less", "equal", "lequal", "greater", 
                  "notequal", "gequal", "always")
for (i in 1:8) {
  triangles3d(x, y, z + i, col = heat.colors(8)[i])
  texts3d(xmid, ymid, z + i, paste(i, tests[i], sep = ". "), depth_test = tests[i]) 
}
highlevel()  # To trigger display

# this illustrates additive blending
open3d()
bg3d("darkgray")
quad &lt;- cbind(c(-1, 1, 1, -1), 1, c(-1, -1, 1, 1))
quads3d(rbind(translate3d(quad, -0.5, 0, -0.5),
              translate3d(quad, 0.5,  0.5, -0.5),
              translate3d(quad, 0, 1, 0.5)), 
        col = rep(c("red", "green", "blue"), each = 4),
        alpha = 0.5, 
        blend = c("src_alpha", "one"))
</code></pre>

<hr>
<h2 id='matrices'>Work with homogeneous coordinates </h2><span id='topic+matrices'></span><span id='topic+identityMatrix'></span><span id='topic+scaleMatrix'></span><span id='topic+translationMatrix'></span><span id='topic+rotationMatrix'></span><span id='topic+scale3d'></span><span id='topic+translate3d'></span><span id='topic+rotate3d'></span><span id='topic+transform3d'></span><span id='topic+asHomogeneous'></span><span id='topic+asEuclidean'></span><span id='topic+asHomogeneous2'></span><span id='topic+asEuclidean2'></span>

<h3>Description</h3>

<p>These functions construct 4x4 matrices for transformations
in the homogeneous coordinate system used by OpenGL, and translate
vectors between homogeneous and Euclidean coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identityMatrix()
scaleMatrix(x, y, z)
translationMatrix(x, y, z)
rotationMatrix(angle, x, y, z, matrix)
asHomogeneous(x)
asEuclidean(x)
asHomogeneous2(x)
asEuclidean2(x)

scale3d(obj, x, y, z, ...)
translate3d(obj, x, y, z, ...)
rotate3d(obj, angle, x, y, z, matrix, ...)

transform3d(obj, matrix, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrices_+3A_x">x</code>, <code id="matrices_+3A_y">y</code>, <code id="matrices_+3A_z">z</code>, <code id="matrices_+3A_angle">angle</code>, <code id="matrices_+3A_matrix">matrix</code></td>
<td>
<p>See details</p>
</td></tr> 
<tr><td><code id="matrices_+3A_obj">obj</code></td>
<td>
<p>An object to be transformed</p>
</td></tr>
<tr><td><code id="matrices_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>OpenGL uses homogeneous coordinates to handle perspective and affine
transformations.  The homogeneous point <code>(x, y, z, w)</code> corresponds
to the Euclidean point <code>(x/w, y/w, z/w)</code>.  The matrices produced by
the functions <code>scaleMatrix</code>, <code>translationMatrix</code>, and <code>rotationMatrix</code>
are to be left-multiplied by a row vector 
of homogeneous coordinates; alternatively, the transpose of the result
can be right-multiplied by a column vector.  The generic functions
<code>scale3d</code>, <code>translate3d</code> and <code>rotate3d</code> apply these transformations
to the <code>obj</code> argument.  The <code>transform3d</code> function is a synonym 
for <code>rotate3d(obj, matrix = matrix)</code>.
</p>
<p>By default, it is assumed that <code>obj</code> is a row vector
(or a matrix of row vectors) which will be multiplied on the right by
the corresponding matrix, but users may write methods for these generics
which operate differently.  Methods are supplied for <code><a href="#topic+mesh3d">mesh3d</a></code>
objects.
</p>
<p>To compose transformations, use matrix multiplication.  The effect is
to apply the matrix on the left first, followed by the one on the right.
</p>
<p><code>identityMatrix</code> returns an identity matrix.
</p>
<p><code>scaleMatrix</code> scales each coordinate by the given factor.  In Euclidean
coordinates, <code>(u, v, w)</code> is transformed to <code>(x*u, y*v, z*w)</code>.
</p>
<p><code>translationMatrix</code> translates each coordinate by the given translation, i.e.
<code>(u, v, w)</code> is transformed to <code>(u + x, v + y, w + z)</code>.
</p>
<p><code>rotationMatrix</code> can be called in three ways.  With 
arguments <code>angle, x, y, z</code> it represents a rotation 
of <code>angle</code> radians about the axis 
<code>x, y, z</code>.  If <code>matrix</code> is a 3x3 rotation matrix,
it will be converted into the corresponding matrix in 4x4 homogeneous
coordinates.  Finally, if a 4x4 matrix is given, it will be returned unchanged.
(The latter behaviour is used to allow <code>transform3d</code> to act like a 
generic function, even though it is not.)
</p>
<p>Use <code>asHomogeneous(x)</code> to convert the Euclidean vector <code>x</code> to
homogeneous coordinates, and <code>asEuclidean(x)</code> for the reverse transformation.  These functions accept the following
inputs:
</p>

<ul>
<li><p> n x 3 matrices:  rows are assumed to be Euclidean
</p>
</li>
<li><p> n x 4 matrices:  rows are assumed to be homogeneous
</p>
</li>
<li><p> vectors of length 3n or 4n:  assumed to be vectors
concatenated. For the ambiguous case
of vectors that are length 12n (so both 3n and 4n are possible),
the assumption is that the conversion is necessary:  <code>asEuclidean</code> assumes the vectors are homogeneous,
and <code>asHomogeneous</code> assumes the vectors are Euclidean.
</p>
</li></ul>

<p>Outputs are n x 4 or n x 3 matrices for <code>asHomogeneous</code>
and <code>asEuclidean</code> respectively.  
</p>
<p>The functions <code>asHomogeneous2</code> and <code>asEuclidean2</code>
act similarly, but they assume inputs are 3 x n or 4 x n
and outputs are in similar shapes.
</p>


<h3>Value</h3>

<p><code>identityMatrix</code>,
<code>scaleMatrix</code>, <code>translationMatrix</code>, and <code>rotationMatrix</code> produce
a 4x4 matrix representing the requested transformation
in homogeneous coordinates.  
</p>
<p><code>scale3d</code>, <code>translate3d</code> and <code>rotate3d</code> transform the object
and produce a new object of the same class.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

<p><code><a href="#topic+par3d">par3d</a></code> for a description of how RGL uses matrices in
rendering.</p>


<h3>Examples</h3>

<pre><code class='language-R'># A 90 degree rotation about the x axis:

rotationMatrix(pi/2, 1, 0, 0)

# Find what happens when you rotate (2, 0, 0) by 45 degrees about the y axis:

x &lt;- asHomogeneous(c(2, 0, 0))
y &lt;- x %*% rotationMatrix(pi/4, 0, 1, 0)
asEuclidean(y)

# or more simply...

rotate3d(c(2, 0, 0), pi/4, 0, 1, 0)

</code></pre>

<hr>
<h2 id='merge.mesh3d'>
Merge RGL mesh objects
</h2><span id='topic+merge.mesh3d'></span>

<h3>Description</h3>

<p>Attempts to merge <code>"mesh3d"</code> objects.  Objects need
to be similar enough; see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mesh3d'
merge(x, y, ..., attributesMustMatch = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.mesh3d_+3A_x">x</code>, <code id="merge.mesh3d_+3A_y">y</code></td>
<td>

<p><code>"mesh3d"</code> objects to merge.
</p>
</td></tr>
<tr><td><code id="merge.mesh3d_+3A_...">...</code></td>
<td>

<p>Optional additional objects.
</p>
</td></tr>
<tr><td><code id="merge.mesh3d_+3A_attributesmustmatch">attributesMustMatch</code></td>
<td>
<p> See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To allow objects to be merged, they need to be similar enough
in terms of having the same list of material properties,
normals, texture coordinates, etc.  
</p>
<p>If <code>attributesMustMatch</code> is <code>TRUE</code>, it is an error
to have attributes in one mesh but not in another, and 
those attributes that only specify a single value must have equal
values in all meshes.
</p>
<p>If <code>attributesMustMatch</code> is <code>FALSE</code>, any non-matching
attributes will be dropped from the final result.
</p>


<h3>Value</h3>

<p>A single <code>"mesh3d"</code> object merging the contents
of the arguments.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
# Notice that the alpha setting for the cube is dropped, because
# the other shapes don't specify alpha.
shade3d(merge(cube3d(col="red", alpha = 0.5),
              translate3d(tetrahedron3d(col="green"), 2, 0, 0),
              translate3d(octahedron3d(col="blue"), 4, 0, 0)))
</code></pre>

<hr>
<h2 id='mergeVertices'>
Merge duplicate vertices in mesh object
</h2><span id='topic+mergeVertices'></span>

<h3>Description</h3>

<p>A mesh object can have the same vertex listed twice.  Each copy is
allowed to have separate normals, texture coordinates, and color.
However, it is more efficient to have just a single copy if those
differences aren't needed.  For automatic smoothing using 
<code><a href="#topic+addNormals">addNormals</a></code>, triangles and quads need to share vertices.
This function merges identical (or similar) vertices to achieve this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeVertices(mesh, 
              notEqual = NULL, 
              attribute = "vertices", 
              tolerance = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeVertices_+3A_mesh">mesh</code></td>
<td>

<p>A <code><a href="#topic+mesh3d">mesh3d</a></code> object.
</p>
</td></tr>
<tr><td><code id="mergeVertices_+3A_notequal">notEqual</code></td>
<td>

<p>A logical matrix indicating that certain pairs should not be merged
even if they appear identical.
</p>
</td></tr>
<tr><td><code id="mergeVertices_+3A_attribute">attribute</code></td>
<td>

<p>Which attribute(s) should be considered in comparing vertices? 
A vector chosen from <code>c("vertices", "colors", "normals", "texcoords"))</code>
</p>
</td></tr>
<tr><td><code id="mergeVertices_+3A_tolerance">tolerance</code></td>
<td>

<p>When comparing vertices using <code><a href="base.html#topic+all.equal">all.equal</a></code>, this tolerance
will be used to ignore rounding error.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new mesh object.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.mesh3d.rglId">as.mesh3d.rglId</a></code>, which often constructs mesh
objects containing a lot of duplication.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
(mesh1 &lt;- cuboctahedron3d(col = rainbow(14), meshColor = "face"))
id &lt;- shade3d(mesh1)
(mesh2 &lt;- as.mesh3d(id))
shade3d(translate3d(mesh2, 3, 0, 0))
(mesh3 &lt;- mergeVertices(mesh2))
shade3d(translate3d(mesh3, 6, 0, 0))
</code></pre>

<hr>
<h2 id='mesh3d'>Construct 3D mesh objects</h2><span id='topic+shape3d'></span><span id='topic+mesh3d'></span><span id='topic+qmesh3d'></span><span id='topic+tmesh3d'></span>

<h3>Description</h3>

<p>Creates meshes containing points, segments, triangles and quads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mesh3d( x, y = NULL, z = NULL, vertices,
                    material = NULL,
                    normals = NULL, texcoords = NULL,
                    points = NULL, segments = NULL,
                    triangles = NULL, quads = NULL,
                    meshColor = c("vertices", "edges", "faces", "legacy"))
  qmesh3d(vertices, indices, homogeneous = TRUE, material = NULL, 
         normals = NULL, texcoords = NULL,
         meshColor = c("vertices", "edges", "faces", "legacy"))
  tmesh3d(vertices, indices, homogeneous = TRUE, material = NULL, 
         normals = NULL, texcoords = NULL,
         meshColor = c("vertices", "edges", "faces", "legacy"))
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh3d_+3A_x">x</code>, <code id="mesh3d_+3A_y">y</code>, <code id="mesh3d_+3A_z">z</code></td>
<td>
<p>coordinates.  Any reasonable way of defining the
coordinates is acceptable.  See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>
for details.</p>
</td></tr>
<tr><td><code id="mesh3d_+3A_vertices">vertices</code></td>
<td>
<p>A 4 row matrix of homogeneous coordinates; takes
precedence over <code>x, y, z</code>.</p>
</td></tr>
<tr><td><code id="mesh3d_+3A_material">material</code></td>
<td>
<p>material properties for later rendering</p>
</td></tr>
<tr><td><code id="mesh3d_+3A_normals">normals</code></td>
<td>
<p>normals at each vertex</p>
</td></tr>
<tr><td><code id="mesh3d_+3A_texcoords">texcoords</code></td>
<td>
<p>texture coordinates at each vertex</p>
</td></tr>
<tr><td><code id="mesh3d_+3A_points">points</code></td>
<td>
<p>vector of indices of vertices to draw as points</p>
</td></tr>
<tr><td><code id="mesh3d_+3A_segments">segments</code></td>
<td>
<p>2 x n matrix of indices of vertices to draw as
segments</p>
</td></tr>
<tr><td><code id="mesh3d_+3A_triangles">triangles</code></td>
<td>
<p>3 x n matrix of indices of vertices to draw
as triangles</p>
</td></tr>
<tr><td><code id="mesh3d_+3A_quads">quads</code></td>
<td>
<p>4 x n matrix of indices of vertices to draw as quads</p>
</td></tr>
<tr><td><code id="mesh3d_+3A_indices">indices</code></td>
<td>
<p>(obsolete) 3 or 4 x n matrix of vertex indices</p>
</td></tr>
<tr><td><code id="mesh3d_+3A_homogeneous">homogeneous</code></td>
<td>
<p>(obsolete) should <code>tmesh3d</code> and <code>qmesh3d</code> vertices be assumed to be homogeneous?</p>
</td></tr>
<tr><td><code id="mesh3d_+3A_meshcolor">meshColor</code></td>
<td>
<p>how should colours be interpreted?  See details in <code><a href="#topic+shade3d">shade3d</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions create <code>mesh3d</code> objects, which consist of a matrix
of vertex coordinates together with a matrices of indices indicating how the vertices should be displayed, and 
material properties.
</p>
<p>The <code>"shape3d"</code> class is a general class for shapes that can be plotted
by <code>dot3d</code>, <code>wire3d</code> or <code>shade3d</code>.
</p>
<p>The <code>"mesh3d"</code> class is a class of objects that form meshes: the vertices
are in member <code>vb</code>, as a 4 by <code>n</code> matrix using
homogeneous coordinates.  Indices of these vertices are
contained in optional components <code>ip</code> for points,
<code>is</code> for line segments, <code>it</code> for triangles, and
<code>ib</code> for quads.
Individual meshes may have any combination of these.
</p>
<p>The functions <code>tmesh3d</code> and <code>qmesh3d</code> are included
for back-compatibility; they produce meshes of triangles and
quads respectively.
</p>


<h3>Value</h3>

<p>Objects of class <code>c("mesh3d",
  "shape3d")</code>. 
</p>
<p>See <code><a href="#topic+points3d">points3d</a></code> for a discussion of texture coordinates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shade3d">shade3d</a></code>, <code><a href="#topic+shapelist3d">shapelist3d</a></code> for multiple shapes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # generate a quad mesh object

  vertices &lt;- c( 
     -1.0, -1.0, 0,
      1.0, -1.0, 0,
      1.0,  1.0, 0,
     -1.0,  1.0, 0
  )
  indices &lt;- c( 1, 2, 3, 4 )
  
  open3d()  
  wire3d( mesh3d(vertices = vertices, quads = indices) )
  
</code></pre>

<hr>
<h2 id='mfrow3d'>
Set up multiple figure layouts
</h2><span id='topic+mfrow3d'></span><span id='topic+layout3d'></span><span id='topic+next3d'></span><span id='topic+subsceneList'></span><span id='topic+clearSubsceneList'></span>

<h3>Description</h3>

<p>The <code>mfrow3d</code> and <code>layout3d</code> functions provide functionality in RGL
similar to <code><a href="graphics.html#topic+par">par</a>("mfrow")</code> and <code><a href="graphics.html#topic+layout">layout</a></code> in classic R graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsceneList(value, window = cur3d())

mfrow3d(nr, nc, byrow = TRUE, parent = NA, sharedMouse = FALSE, ...)
layout3d(mat, widths = rep.int(1, ncol(mat)), 
              heights = rep.int(1, nrow(mat)),
              parent = NA, sharedMouse = FALSE,
              ...)
next3d(current = NA, clear = TRUE, reuse = TRUE)
clearSubsceneList(delete = currentSubscene3d() %in% subsceneList(), 
                  window = cur3d())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfrow3d_+3A_value">value</code></td>
<td>

<p>A new subscene list to set.  If missing, return the current one (or <code>NULL</code>).
</p>
</td></tr>
<tr><td><code id="mfrow3d_+3A_window">window</code></td>
<td>

<p>Which window to operate on.
</p>
</td></tr>
<tr><td><code id="mfrow3d_+3A_nr">nr</code>, <code id="mfrow3d_+3A_nc">nc</code></td>
<td>

<p>Number of rows and columns of figures.
</p>
</td></tr>
<tr><td><code id="mfrow3d_+3A_byrow">byrow</code></td>
<td>

<p>Whether figures progress by row (as with <code><a href="graphics.html#topic+par">par</a>("mfrow")</code>) or by column 
(as with <code><a href="graphics.html#topic+par">par</a>("mfcol")</code>).
</p>
</td></tr>
<tr><td><code id="mfrow3d_+3A_mat">mat</code>, <code id="mfrow3d_+3A_widths">widths</code>, <code id="mfrow3d_+3A_heights">heights</code></td>
<td>

<p>Layout parameters; see <code><a href="graphics.html#topic+layout">layout</a></code> for their interpretation.
</p>
</td></tr>
<tr><td><code id="mfrow3d_+3A_parent">parent</code></td>
<td>

<p>The parent subscene.  <code>NA</code> indicates the current subscene.  See Details below.
</p>
</td></tr>
<tr><td><code id="mfrow3d_+3A_sharedmouse">sharedMouse</code></td>
<td>

<p>Whether to make all subscenes <code><a href="#topic+par3d">par3d</a>("listeners")</code> to each other.
</p>
</td></tr>
<tr><td><code id="mfrow3d_+3A_...">...</code></td>
<td>

<p>Additional parameters to pass to <code><a href="#topic+newSubscene3d">newSubscene3d</a></code> as each
subscene is created.
</p>
</td></tr>
<tr><td><code id="mfrow3d_+3A_current">current</code></td>
<td>

<p>The subscene to move away from.  <code>NA</code> indicates the current subscene.
</p>
</td></tr>
<tr><td><code id="mfrow3d_+3A_clear">clear</code></td>
<td>

<p>Whether the newly entered subscene should be cleared upon entry.
</p>
</td></tr>
<tr><td><code id="mfrow3d_+3A_reuse">reuse</code></td>
<td>

<p>Whether to skip advancing if the current subscene has no objects in it.
</p>
</td></tr>
<tr><td><code id="mfrow3d_+3A_delete">delete</code></td>
<td>

<p>If <code>TRUE</code>, delete the subscenes in the current window.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>rgl can maintain a list of subscenes; the <code>mfrow3d</code> and <code>layout3d</code> functions create that list.
When the list is in place, <code>next3d</code> causes RGL to move to the next scene in the list, or cycle
back to the first one.
</p>
<p>Unlike the classic R graphics versions of these functions, these functions are completely compatible with
each other.  You can mix them within a single RGL window.
</p>
<p>In the default case where <code>parent</code> is missing, <code>mfrow3d</code> and <code>layout3d</code> will
call <code>clearSubsceneList()</code> at the start.  
</p>
<p>By default <code>clearSubsceneList()</code> checks
whether the current subscene is in the current subscene list; if so, it will delete
all subscenes in the list, and call <code><a href="#topic+gc3d">gc3d</a></code> to delete any objects that are no
longer shown.  The subscene list will be set to a previous value if one was recorded,
or <code>NULL</code> if not.
</p>
<p>If <code>parent</code> is specified in <code>mfrow3d</code> or <code>layout3d</code> 
(even as <code>NA</code>), the new subscenes will be created within 
the parent.
</p>
<p>The <code>next3d()</code> function first finds out if the current
subscene is in the current list.  If not, it moves to the
previous list, and looks there.  Once it finds a list 
containing the current subscene, it moves to the next entry
in that list.  If it can't find one, it creates a length
one list containing just the current subscene.
</p>


<h3>Value</h3>

<p><code>mfrow3d</code> and <code>layout3d</code> return a vector of subscene id values that have just been
created.  If a previous subscene list was in effect and was not automatically cleared,
it is attached as an attribute <code>"prev"</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+newSubscene3d">newSubscene3d</a></code>, <code><a href="graphics.html#topic+par">par</a></code>, <code><a href="graphics.html#topic+layout">layout</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shapes &lt;- list(Tetrahedron = tetrahedron3d(), Cube = cube3d(), Octahedron = octahedron3d(),
               Icosahedron = icosahedron3d(), Dodecahedron = dodecahedron3d(),
               Cuboctahedron = cuboctahedron3d())
col &lt;- rainbow(6)
open3d()
mfrow3d(3, 2)
for (i in 1:6) {
  next3d()   # won't advance the first time, since it is empty
  shade3d(shapes[[i]], col = col[i])
}
highlevel(integer()) # To trigger display as rglwidget

open3d()
mat &lt;- matrix(1:4, 2, 2)
mat &lt;- rbind(mat, mat + 4, mat + 8)
layout3d(mat, height = rep(c(3, 1), 3), sharedMouse = TRUE)
for (i in 1:6) {
  next3d()
  shade3d(shapes[[i]], col = col[i])
  next3d()
  text3d(0, 0, 0, names(shapes)[i])
}
highlevel(integer())
</code></pre>

<hr>
<h2 id='observer3d'>
Set the observer location
</h2><span id='topic+observer3d'></span>

<h3>Description</h3>

<p>This function sets the location of the viewer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observer3d(x, y = NULL, z = NULL, auto = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="observer3d_+3A_x">x</code>, <code id="observer3d_+3A_y">y</code>, <code id="observer3d_+3A_z">z</code></td>
<td>

<p>The location as a 3 vector, using the usual <code>xyz.coords</code>
conventions for specification.  If <code>x</code> is missing
or any coordinate is <code>NA</code>, no change will be made to the
location.  
</p>
</td></tr>
<tr><td><code id="observer3d_+3A_auto">auto</code></td>
<td>
 
<p>If <code>TRUE</code>, the location will be set 
automatically by RGL to make the whole bounding box visible.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function
sets the location of the viewer relative to the scene, after the model transformations
(scaling, rotation) have been done, but before lighting or projection have been 
applied.  (See <code><a href="#topic+par3d">par3d</a></code> for details on the rendering pipeline.)
</p>
<p>The coordinate system is a slightly strange one:  the X coordinate
moves the observer location from left to right, and the Y coordinate moves up
and down.  The Z coordinate changes the depth from the viewer.  All are measured
relative to the center of the bounding box (<code>par("bbox")</code>) of the subscene.
The observer always looks in the positive Z direction
after the model rotation have been done.  The coordinates are in post-scaling
units.
</p>


<h3>Value</h3>

<p>Invisibly returns the previous value.
</p>


<h3>Note</h3>

<p>This function is likely to change in future versions of RGL, to allow more 
flexibility in the specification of the observer's location and orientation.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(surface3d)  # The volcano data
observer3d(0, 0, 440) # Viewed from very close up
</code></pre>

<hr>
<h2 id='open3d'>Work with RGL windows</h2><span id='topic+open3d'></span><span id='topic+close3d'></span><span id='topic+cur3d'></span><span id='topic+set3d'></span><span id='topic+getr3dDefaults'></span><span id='topic+r3dDefaults'></span><span id='topic+rgl.dev.list'></span><span id='topic+rgl.quit'></span>

<h3>Description</h3>

<p><code>open3d</code> opens a new RGL window; <code>cur3d</code> returns the device number of the current
window; <code>close3d</code> closes one or more windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>open3d(..., params = getr3dDefaults(), 
	    useNULL = rgl.useNULL(), silent = FALSE)
	    
close3d(dev = cur3d(), silent = TRUE)
	    
cur3d()

rgl.dev.list()

set3d(dev, silent = FALSE)

getr3dDefaults(class = NULL, value = NULL)

r3dDefaults

rgl.quit()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="open3d_+3A_...">...</code></td>
<td>
<p>arguments in <code>name = value</code> form, or a list of named
values.  The names must come from the graphical
parameters described in <code><a href="#topic+par3d">par3d</a></code>.</p>
</td></tr>
<tr><td><code id="open3d_+3A_params">params</code></td>
<td>
<p>a list of graphical parameters</p>
</td></tr>
<tr><td><code id="open3d_+3A_usenull">useNULL</code></td>
<td>
<p>whether to use the null graphics device</p>
</td></tr>
<tr><td><code id="open3d_+3A_dev">dev</code></td>
<td>
<p>which device to close or use</p>
</td></tr>
<tr><td><code id="open3d_+3A_silent">silent</code></td>
<td>
<p>whether report on what was done</p>
</td></tr>
<tr><td><code id="open3d_+3A_class">class</code>, <code id="open3d_+3A_value">value</code></td>
<td>
<p>names of components to retrieve</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>open3d</code> opens a new RGL device, and sets the parameters as
requested.  The <code>r3dDefaults</code> list returned by the 
<code>getr3dDefaults</code> function will be used as default
values for parameters.  As installed this sets the point of view to
'world coordinates' (i.e. x running from left to right, y from front
to back, z from bottom to top), the <code>mouseMode</code> to
<code>(zAxis, zoom, fov)</code>, and the field of view to 30 degrees.  <code>useFreeType</code> defaults to <code>FALSE</code> on 
Windows; on other systems it indicates the availability
of FreeType.
Users may create their own variable named <code>r3dDefaults</code> in the global
environment and it will override the installed one.  If there
is a <code>bg</code> element in the list or the arguments, it should be
a list of arguments to pass to the <code><a href="#topic+bg3d">bg3d</a></code> function to 
set the background.  
</p>
<p>The arguments to <code>open3d</code> may include <code>material</code>, a list
of material properties as in <code><a href="#topic+r3dDefaults">r3dDefaults</a></code>, but note
that high level functions such as <code><a href="#topic+plot3d">plot3d</a></code> normally use
the <code>r3dDefaults</code> values in preference to this setting. 
</p>
<p>If <code>useNULL</code> is <code>TRUE</code>, RGL will use a &ldquo;null&rdquo;
device.  This device records objects as they are plotted, but 
displays nothing. It is intended for use with <code><a href="#topic+rglwidget">rglwidget</a></code>.
</p>


<h3>Value</h3>

<p>The <code>open3d</code> function returns the device that 
was opened.  If 
<code>silent = TRUE</code>, it is returned invisibly.
</p>
<p>The <code>cur3d</code> function returns the current device,
or the value 0 if there isn't one.  <code>rgl.dev.list</code>
returns a vector of all open devices.  Items are named
according to the type of device:  <code>null</code> for a hidden
null device, 
<code>wgl</code> for a Windows device, and <code>glX</code> for an X windows device.
</p>
<p><code>set3d</code> returns the device number of the
previously active device.
</p>
<p>The <code>close3d</code> function returns the new current
device, invisibly.
</p>
<p>The <code>r3dDefaults</code> variable is a list containing default
settings.  The <code>getr3dDefaults</code> function searches the user's
global environment for <code>r3dDefaults</code> and returns the 
one in the RGL namespace if it was not found there.
The components of the list may include any settable <code>par3d</code>
parameter, or <code>"material"</code>, which should include a list
of default <code><a href="#topic+material3d">material3d</a></code> properties, or <code>"bg"</code>, 
which is a
list of defaults to pass to the <code><a href="#topic+bg3d">bg3d</a></code> function.
</p>
<p><code>rgl.quit</code> attempts to unload <span class="pkg">rgl</span> and then returns
<code>NULL</code> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rgl.useNULL">rgl.useNULL</a></code> for default usage of null device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    r3dDefaults
    open3d()
    shade3d(cube3d(color = rainbow(6), meshColor = "faces"))
    cur3d()
</code></pre>

<hr>
<h2 id='par3d'>Set or query RGL parameters</h2><span id='topic+par3d'></span><span id='topic+rgl.par3d.names'></span><span id='topic+rgl.par3d.readonly'></span>

<h3>Description</h3>

<p><code>par3d</code> can be used to set or query graphical parameters in RGL.
Parameters can be set by specifying them as arguments to <code>par3d</code> in
<code>name = value</code> form, or by passing them as a list of named
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par3d(..., no.readonly = FALSE, dev = cur3d(), 
      subscene = currentSubscene3d(dev))
rgl.par3d.names
rgl.par3d.readonly
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par3d_+3A_...">...</code></td>
<td>
<p>arguments in <code>name = value</code> form, or a list of tagged
values.  The names must come from the graphical parameters described
below.</p>
</td></tr>
<tr><td><code id="par3d_+3A_no.readonly">no.readonly</code></td>
<td>
<p>logical; if <code>TRUE</code> and there are no other
arguments, only those parameters which can be set by a
subsequent <code>par3d()</code> call are returned.</p>
</td></tr>
<tr><td><code id="par3d_+3A_dev">dev</code></td>
<td>
<p>integer; the RGL device.</p>
</td></tr>
<tr><td><code id="par3d_+3A_subscene">subscene</code></td>
<td>
<p>integer; the subscene.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters are queried by giving one or more character vectors to
<code>par3d</code>.
</p>
<p><code>par3d()</code> (no arguments) or <code>par3d(no.readonly = TRUE)</code> is used to
get <em>all</em> the graphical parameters (as a named list).  
</p>
<p>By default, queries and modifications apply to the current subscene
on the current device; specify <code>dev</code> and/or <code>subscene</code> to 
change this.  Some parameters apply to the device as a whole;
these are marked in the list below.
</p>


<h3>Value</h3>

<p>When parameters are set, their former values are returned in an
invisible named list.  Such a list can be passed as an argument to
<code>par3d</code> to restore the parameter values.
Use <code>par3d(no.readonly = TRUE)</code> for the full list of parameters
that can be restored.
</p>
<p>When just one parameter is queried, its value is returned directly.
When two or more parameters are queried, the result is a list of
values, with the list names giving the parameters.
</p>
<p>Note the inconsistency: setting one parameter returns a list, but
querying one parameter returns an object.
</p>


<h3>Parameters</h3>

<p>The <code>rgl.par3d.names</code> variable contains the
full list of names of <code>par3d</code> properties.
<code>rgl.par3d.readonly</code> contains the list of
read-only properties.
</p>
<p>In the list below, <em><b>R.O.</b></em> indicates the
read-only arguments: These may only be used in
queries, they do not set anything.
</p>

<dl>
<dt><code>activeSubscene</code></dt><dd><p><em><b>R.O.</b></em> integer.  Used
with <code><a href="#topic+rgl.setMouseCallbacks">rgl.setMouseCallbacks</a></code>:  during a 
callback, indicates the id of the subscene that was clicked.</p>
</dd>
<dt><code>antialias</code></dt><dd><p><em><b>R.O.</b></em> in <code>par3d</code>, may be
set in <code>open3d</code>. The (requested) number of hardware
antialiasing planes to use (with multisample antialiasing).  The
OpenGL driver may not support the requested number, in which case
<code>par3d("antialias")</code> will report what was actually set. Applies to the whole device.</p>
</dd>    
<dt><code>cex</code></dt><dd><p>real.  The default size for text.</p>
</dd>
<dt><code>family</code></dt><dd><p>character.  The default device independent family name; see <code><a href="#topic+text3d">text3d</a></code>.
Applies to the whole device.</p>
</dd>
<dt><code>font</code></dt><dd><p>integer.  The default font number (from 1 to 4; see <code><a href="#topic+text3d">text3d</a></code>).
Applies to the whole device.</p>
</dd>
<dt><code>useFreeType</code></dt><dd><p>logical.  Should FreeType fonts be used?
Applies to the whole device.</p>
</dd>
<dt><code>fontname</code></dt><dd><p><em><b>R.O.</b></em>; the system-dependent name of the current font.
Applies to the whole device.</p>
</dd>
<dt><code>FOV</code></dt><dd><p>real.  The field of view, from 0 to 179 degrees.  This controls
the degree of parallax in the perspective view.
Isometric perspective corresponds to <code>FOV = 0</code>.</p>
</dd>
<dt><code>ignoreExtent</code></dt><dd><p>logical.  Set to <code>TRUE</code> so that subsequently plotted objects
will be ignored in calculating the bounding box of the scene.  Applies to the
whole device.</p>
</dd>
<dt><code>maxClipPlanes</code></dt><dd><p><em><b>R.O.</b></em>; an integer giving the maximum
number of clip planes that can be defined in the current system. Applies to the whole device.</p>
</dd>
<dt><code>modelMatrix</code></dt><dd><p><em><b>R.O.</b></em>; a 4 by 4 matrix describing the position
of the user data.  See the Note below.</p>
</dd>
<dt><code>listeners</code></dt><dd><p>integer.  A vector of subscene id values.  If a subscene receives
a mouse event (see <code>mouseMode</code> just below), the same action will be carried out
on all subscenes in this list.  (The subscene itself is normally listed as a listener.
If it is not listed, it will not respond to its own mouse events.)</p>
</dd>
<dt><code>mouseMode</code></dt><dd><p>character.  A vector of 5 strings describing
mouse actions. The 5 entries are named
<code>c("none", "left", "right", "middle", "wheel")</code>, corresponding to actions for no button, 
the left, right or middle button, and the 
mouse wheel.
Partial matching to action names is used.  Possible values for the actions are:
</p>

<dl>
<dt><code>"none"</code></dt><dd><p>No action for this button.</p>
</dd>
<dt><code>"trackball"</code></dt><dd><p>Mouse acts as a virtual trackball, rotating the scene.</p>
</dd>
<dt><code>"xAxis"</code></dt><dd><p>Similar to <code>"trackball"</code>, but restricted to X axis rotation.</p>
</dd>
<dt><code>"yAxis"</code></dt><dd><p>Y axis rotation.</p>
</dd>
<dt><code>"zAxis"</code></dt><dd><p>Z axis rotation.</p>
</dd>
<dt><code>"polar"</code></dt><dd><p>Mouse rotates the scene by moving in polar coordinates.</p>
</dd>
<dt><code>"selecting"</code></dt><dd><p>Mouse is used for selection.  This is not normally set by the
user, but is used internally by the <code><a href="#topic+select3d">select3d</a></code> function.</p>
</dd>
<dt><code>"zoom"</code></dt><dd><p>Mouse is used to zoom the display.</p>
</dd>
<dt><code>"fov"</code></dt><dd><p>Mouse changes the field of view of the display.</p>
</dd>
<dt><code>"user"</code></dt><dd><p>Used  when a user handler is set by 
<code><a href="#topic+rgl.setMouseCallbacks">rgl.setMouseCallbacks</a></code>.</p>
</dd>
</dl>

<p>Possible values for the last entry corresponding to the mouse wheel also include
</p>

<dl>
<dt><code>"pull"</code></dt><dd><p>Pulling on the mouse wheel increases magnification, i.e. &ldquo;pulls the scene closer&rdquo;.</p>
</dd>
<dt><code>"push"</code></dt><dd><p>Pulling on the mouse wheel decreases magnification, i.e. &ldquo;pushes the scene away&rdquo;.</p>
</dd>
<dt><code>"user2"</code></dt><dd><p>Used when a user handler is set by 
<code><a href="#topic+rgl.setWheelCallback">rgl.setWheelCallback</a></code>.</p>
</dd>
</dl>

<p>A common default on Mac OSX is to convert a two finger drag on a trackpad to a mouse wheel rotation.
</p>
<p>The first entry is for actions to take when
no mouse button is pressed.  Legal values are the same
as for the mouse buttons.
</p>
<p>The first entry was added after <span class="pkg">rgl</span> version 0.106.8.  For back compatibility, if the vector
of actions is less than 5 entries, <code>"none"</code>
will be added at the start of it.
</p>
</dd>
<dt><code>observer</code></dt><dd><p><em><b>R.O.</b></em>; the position of the observer relative to
the model.  Set by <code><a href="#topic+observer3d">observer3d</a></code>.  See the Note below.</p>
</dd>
<dt><code>projMatrix</code></dt><dd><p><em><b>R.O.</b></em>; a 4 by 4 matrix describing the current
projection of the scene.</p>
</dd>
<dt><code>scale</code></dt><dd><p>real.  A vector of 3 values indicating the amount by which to
rescale each axis before display.  Set by <code><a href="#topic+aspect3d">aspect3d</a></code>.</p>
</dd>
<dt><code>skipRedraw</code></dt><dd><p>whether to update the display.  Set to <code>TRUE</code> to suspend
updating while making multiple changes to the scene.  See <code>demo(hist3d)</code> for an example.
Applies to the whole device.</p>
</dd>
<dt><code>userMatrix</code></dt><dd><p>a 4 by 4 matrix describing user actions to
display the scene.</p>
</dd>
<dt><code>userProjection</code></dt><dd><p>a 4 by 4 matrix describing
changes to the projection.</p>
</dd>
<dt><code>viewport</code></dt><dd><p>real.  A vector giving the dimensions of the
window in pixels.  The entries are taken to be <code>c(x, y, width, height)</code> where
<code>c(x, y)</code> are the coordinates in pixels of the lower left corner within the window.</p>
</dd>
<dt><code>zoom</code></dt><dd><p>real. A positive value indicating the current
magnification of the scene.</p>
</dd>
<dt><code>bbox</code></dt><dd><p><em><b>R.O.</b></em>; real. A vector of six values indicating the current values of the
bounding box of the scene (xmin, xmax, ymin, ymax, zmin, zmax)</p>
</dd>
<dt><code>windowRect</code></dt><dd><p>integer.  A vector of four values indicating the left, top, right and 
bottom of the displayed window (in pixels).  Applies to the whole device.</p>
</dd>
</dl>



<h3>Rendering</h3>

<p>The parameters returned by <code>par3d</code> are sufficient to determine where RGL would render
a point on the screen.  Given a column vector <code>(x, y, z)</code> in a subscene <code>s</code>, 
it performs the equivalent of 
the following operations:
</p>

<ol>
<li><p> It converts the point to homogeneous coordinates by appending <code>w = 1</code>, giving
the vector <code>v = (x, y, z, 1)</code>.
</p>
</li>
<li><p> It calculates the <code>M = par3d("modelMatrix")</code> as a product from right to left
of several matrices:
</p>
  
<ul>
<li><p> A matrix to translate the centre of the bounding box to the origin.
</p>
</li>
<li><p> A matrix to rescale according to <code>par3d("scale")</code>.
</p>
</li>
<li><p> The <code>par3d("userMatrix")</code> as set by the user.
</p>
</li>
<li><p> A matrix which may be set by mouse movements.
</p>
</li>
<li><p> The description above applies to the usual case where there 
is just one subscene, or where the subscene's <code>"model"</code> is set to
<code>"replace"</code>.  If it is set to <code>"modify"</code>, the first step is
skipped, and at the end the procedure is followed for the parent subscene.  If it is set to <code>"inherit"</code> only the parent settings
are used.
</p>
</li></ul>

</li>
<li><p> It multiplies the point by <code>M</code> giving <code>u = M %*% v</code>. 
</p>
</li>
<li><p> It multiplies that point by a matrix based on the observer position
to translate the origin to the centre of the viewing region.
</p>
</li>
<li><p> Using this location and information on the
normals (which have been similarly transformed), it performs lighting calculations. 
</p>
</li>
<li><p> It obtains the projection matrix <code>P = par3d("projMatrix")</code> based on the bounding box and field of view
or observer location, multiplies that by the <code>userProjection</code> matrix to give <code>P</code>.  It multiplies the point
by it giving <code>P %*% u = (x2, y2, z2, w2)</code>.
</p>
</li>
<li><p> It converts back to Euclidean coordinates by dividing the first 3 coordinates by <code>w2</code>.
</p>
</li>
<li><p> The new value <code>z2/w2</code> represents the depth into the scene of the point.  Depending
on what has already been plotted, this depth might be obscured, in which case nothing more is plotted.
</p>
</li>
<li><p> If the point is not culled due to depth, the <code>x2</code> and <code>y2</code> values are used
to determine the point in the image.  The <code>par3d("viewport")</code> values are used to translate
from the range <code>(-1, 1)</code> to pixel locations, and the point is plotted.
</p>
</li>
<li><p> If hardware antialiasing is enabled, then the whole process is
repeated multiple times (at least conceptually) with different
locations in each pixel sampled to determine what is plotted there,
and then the images are combined into what is displayed.
</p>
</li></ol>

<p>See ?<a href="#topic+matrices">matrices</a> for more information on homogeneous and Euclidean coordinates.
</p>
<p>Note that many of these calculations are done on the graphics card using single precision;
you will likely see signs of rounding error if your scene requires more than 4 or 5 
digit precision to distinguish values in any coordinate.  
</p>


<h3>Note</h3>

<p>The <code>"xAxis"</code>, <code>"yAxis"</code> and <code>"zAxis"</code> mouse modes rotate 
relative to the coordinate system of the data, regardless of the current 
orientation of the scene.
</p>
<p>When multiple parameters are set, they are set in the order given.  In some 
cases this may lead to warnings and ignored values; for example, some font 
families only support <code>cex = 1</code>, so changing both <code>cex</code> and 
<code>family</code> needs to be done in the right order.  For example, when using the
<code>"bitmap"</code> family on Windows, <code>par3d(family = "sans", cex = 2)</code>
will work, but <code>par3d(cex = 2, family = "sans")</code> will leave <code>cex</code>
at 1 (with a warning that the <code>"bitmap"</code> family only supports that size).
</p>
<p>Although <code>par3d("viewport")</code> names the entries of the reported vector,
names are ignored when setting the viewport and entries must be specified
in the standard order.
</p>
<p>In <span class="pkg">rgl</span> versions 0.94.x the <code>modelMatrix</code> entry had a changed meaning; 
before and after that it contains a copy of the OpenGL MODELVIEW matrix. 
</p>
<p>As of version 0.100.32, when changing the <code>"windowRect"</code> parameter, the 
<code>"viewport"</code> for the root (or specified) subscene
is changed immediately.  This fixes a bug where in earlier
versions it would only be changed when the window was redrawn, potentially after another command making use of the value.
</p>
<p>Default values are not described here, as several of them
are changed by the <code><a href="#topic+r3dDefaults">r3dDefaults</a></code> variable when
the window is opened by <code><a href="#topic+open3d">open3d</a></code>.
</p>


<h3>References</h3>

<p>OpenGL Architecture Review Board (1997).  OpenGL Programming Guide.  Addison-Wesley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+view3d">view3d</a></code> to set <code>FOV</code> and <code>zoom</code>.
</p>
<p><code><a href="#topic+open3d">open3d</a></code> for how to open a new window
with default settings for these parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    open3d()
    shade3d(cube3d(color = rainbow(6), meshColor = "faces"))
    save &lt;- par3d(userMatrix = rotationMatrix(90*pi/180, 1, 0, 0))
    highlevel()  # To trigger display
    save
    par3d("userMatrix")    
    par3d(save)
    highlevel()
    par3d("userMatrix")
</code></pre>

<hr>
<h2 id='par3dinterp'>Interpolator for par3d parameters</h2><span id='topic+par3dinterp'></span>

<h3>Description</h3>

<p>Returns a function which interpolates <code>par3d</code> parameter values,
suitable for use in animations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par3dinterp(times = NULL, userMatrix, scale, zoom, FOV, 
            method = c("spline", "linear"), 
            extrapolate = c("oscillate", "cycle", "constant", "natural"),
            dev = cur3d(), subscene = par3d("listeners", dev = dev))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par3dinterp_+3A_times">times</code></td>
<td>
<p> Times at which values are recorded or a list; see below </p>
</td></tr>
<tr><td><code id="par3dinterp_+3A_usermatrix">userMatrix</code></td>
<td>
<p> Values of <code>par3d("userMatrix")</code> </p>
</td></tr>
<tr><td><code id="par3dinterp_+3A_scale">scale</code></td>
<td>
<p> Values of <code>par3d("scale")</code> </p>
</td></tr>
<tr><td><code id="par3dinterp_+3A_zoom">zoom</code></td>
<td>
<p> Values of <code>par3d("zoom")</code> </p>
</td></tr>
<tr><td><code id="par3dinterp_+3A_fov">FOV</code></td>
<td>
<p> Values of <code>par3d("FOV")</code> </p>
</td></tr>
<tr><td><code id="par3dinterp_+3A_method">method</code></td>
<td>
<p> Method of interpolation </p>
</td></tr>
<tr><td><code id="par3dinterp_+3A_extrapolate">extrapolate</code></td>
<td>
<p> How to extrapolate outside the time range </p>
</td></tr>
<tr><td><code id="par3dinterp_+3A_dev">dev</code></td>
<td>
<p> Which RGL device to use </p>
</td></tr>
<tr><td><code id="par3dinterp_+3A_subscene">subscene</code></td>
<td>
<p> Which subscene to use </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be used in constructing animations.  It produces
a function that returns a list suitable to pass to <code><a href="#topic+par3d">par3d</a></code>, to set 
the viewpoint at a given point in time.
</p>
<p>All of the parameters are optional.  Only those <code>par3d</code> parameters that are 
specified will be returned.
</p>
<p>The input values other than <code>times</code> may each be specified as
lists, giving the parameter value settings at a fixed time, or as
matrices or arrays.  If not lists, the following formats should be
used: <code>userMatrix</code> can be a <code>4 x 4 x n</code> array, or a <code>4
x 4n</code> matrix; <code>scale</code> should be an <code>n x 3</code> matrix;
<code>zoom</code> and <code>FOV</code> should be length <code>n</code> vectors.
</p>
<p>An alternative form of input is to put all of the above arguments into
a list (i.e. a list of lists, or a list of arrays/matrices/vectors),
and pass it as the first argument.  This is the most convenient way to
use this function with the  function
<code><a href="#topic+tkpar3dsave">tkpar3dsave</a></code>.
</p>
<p>Interpolation is by cubic spline or linear interpolation in an appropriate
coordinate-wise fashion.  Extrapolation may oscillate
(repeat the sequence forward, backward, forward, etc.), cycle (repeat
it forward), be constant (no repetition outside the specified time
range), or be natural (linear on an appropriate scale).   
In the case of cycling, the first and last specified values
should be equal, or the last one will be dropped.  Natural extrapolation
is only supported with spline interpolation.
</p>


<h3>Value</h3>

<p>A function is returned.  The function takes one argument, and returns a list of 
<code>par3d</code> settings interpolated to that time.
</p>


<h3>Note</h3>

<p>Prior to <span class="pkg">rgl</span> version 0.95.1476, the
<code>subscene</code> argument defaulted to the
current subscene, and any additional entries would
be ignored by <code><a href="#topic+play3d">play3d</a></code>.  The current
default value of <code>par3d("listeners", dev = dev)</code> means that all subscenes that share 
mouse responses will also share modifications
by this function.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch </p>


<h3>See Also</h3>

 <p><code><a href="#topic+play3d">play3d</a></code> to play the animation. </p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- par3dinterp( zoom = c(1, 2, 3, 1) )
f(0)
f(1)
f(0.5)
## Not run: 
play3d(f)

## End(Not run)
</code></pre>

<hr>
<h2 id='par3dinterpControl'>
Control RGL widget like par3dinterp()
</h2><span id='topic+par3dinterpControl'></span>

<h3>Description</h3>

<p>This control works with <code><a href="#topic+playwidget">playwidget</a></code> to 
change settings in a WebGL display in the same way
as <code><a href="#topic+par3dinterp">par3dinterp</a></code> does within R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par3dinterpControl(fn, from, to, steps, subscene = NULL, omitConstant = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par3dinterpControl_+3A_fn">fn</code></td>
<td>
<p>A function returned from <code><a href="#topic+par3dinterp">par3dinterp</a></code>.</p>
</td></tr>
<tr><td><code id="par3dinterpControl_+3A_from">from</code>, <code id="par3dinterpControl_+3A_to">to</code>, <code id="par3dinterpControl_+3A_steps">steps</code></td>
<td>
<p>Values where <code>fn</code> should be evaluated.</p>
</td></tr>
<tr><td><code id="par3dinterpControl_+3A_subscene">subscene</code></td>
<td>
<p>Which subscene's properties should be modified?</p>
</td></tr>
<tr><td><code id="par3dinterpControl_+3A_omitconstant">omitConstant</code></td>
<td>
<p>If <code>TRUE</code>, do not set values that are
constant across the range.</p>
</td></tr>
<tr><td><code id="par3dinterpControl_+3A_...">...</code></td>
<td>
<p>Additional parameters which will be passed
to <code><a href="#topic+propertyControl">propertyControl</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>par3dinterpSetter</code> sets parameters corresponding to values produced by the result of
<code>par3dinterp</code>.  
</p>


<h3>Value</h3>

<p>Returns controller data in a list of class &quot;rglControl&quot;.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(plot3d)
M &lt;- r3dDefaults$userMatrix
fn &lt;- par3dinterp(times = (0:2)*0.75, userMatrix = list(M,
                                      rotate3d(M, pi/2, 1, 0, 0),
                                      rotate3d(M, pi/2, 0, 1, 0)),
                                      scale = c(0.5, 1, 2))
control &lt;- par3dinterpControl(fn, 0, 3, steps = 15)
control      
if (interactive() || in_pkgdown_example()) 
  rglwidget(width = 500, height = 250) %&gt;%
  playwidget(control,
       step = 0.01, loop = TRUE, rate = 0.5)
</code></pre>

<hr>
<h2 id='pch3d'>
Plot symbols similar to base graphics
</h2><span id='topic+pch3d'></span>

<h3>Description</h3>

<p>This function plots symbols similarly to 
what the base graphics function <code><a href="graphics.html#topic+points">points</a></code> does when <code>pch</code> is specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pch3d(x, y = NULL, z = NULL, pch = 1, 
      bg = material3d("color")[1], cex = 1, radius, 
      color = "black", lit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pch3d_+3A_x">x</code>, <code id="pch3d_+3A_y">y</code>, <code id="pch3d_+3A_z">z</code></td>
<td>

<p>The locations at which to plot in a form
suitable for use in <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>.
</p>
</td></tr>
<tr><td><code id="pch3d_+3A_pch">pch</code></td>
<td>

<p>A vector of integers or single characters
describing the symbols to plot.
</p>
</td></tr>
<tr><td><code id="pch3d_+3A_bg">bg</code></td>
<td>

<p>The fill color(s) to use for <code>pch</code> from 21 
to 25.
</p>
</td></tr>
<tr><td><code id="pch3d_+3A_cex">cex</code></td>
<td>

<p>A relative size of the symbol to plot.
</p>
</td></tr>
<tr><td><code id="pch3d_+3A_radius">radius</code></td>
<td>

<p>An absolute size of the symbol to plot 
in user coordinates.
</p>
</td></tr>
<tr><td><code id="pch3d_+3A_color">color</code></td>
<td>
 
<p>The color(s) to use for symbols.
</p>
</td></tr>
<tr><td><code id="pch3d_+3A_lit">lit</code></td>
<td>

<p>Whether the object responds to lighting or just shows the
displayed color directly.
</p>
</td></tr>
<tr><td><code id="pch3d_+3A_...">...</code></td>
<td>

<p>Other material properties.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of symbols encoded by numerical
<code>pch</code> values is given in the <code><a href="graphics.html#topic+points">points</a></code> help page.  
</p>


<h3>Value</h3>

<p>A vector of object id values is returned invisibly.  Separate objects will be drawn
for each different combination of <code>pch</code> value from 
0 to 25, <code>color</code> and  <code>bg</code>, and another holding all the character
symbols.
</p>


<h3>Note</h3>

<p>This function is not a perfect match to how the <code><a href="graphics.html#topic+points">points</a></code> function works due
to limitations in RGL and OpenGL.  In
particular:
</p>
<p>Symbols with numbers from 1 to 25 are drawn
as 3D sprites (see <code><a href="#topic+sprites3d">sprites3d</a></code>),
so they will resize as the window is zoomed.
Letters and numbers from 32 to 255 (which are
mapped to letters) are drawn using <code><a href="#topic+text3d">text3d</a></code>, 
so they maintain a fixed size.
</p>
<p>A calculation somewhat like the one in <code><a href="#topic+plot3d">plot3d</a></code> that sets the size
of spheres is used to choose the size of
sprites based on <code>cex</code> and the 
current scaling.  This will likely need manual
tweaking.  Use the <code>radius</code> argument
for a fixed size.
</p>
<p>No special handling is done for the case of 
<code>pch = "."</code>.  Use <code>points3d</code> for 
small dots.
</p>
<p>As of <span class="pkg">rgl</span> version 0.100.10, background and foreground 
colors can vary from symbol to symbol.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+points3d">points3d</a></code>, <code><a href="#topic+text3d">text3d</a></code> and
<code><a href="#topic+sprites3d">sprites3d</a></code> for other ways to label points,
<code><a href="graphics.html#topic+points">points</a></code> for the base graphics symbol
definitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
i &lt;- 0:25; x &lt;- i %% 5; y &lt;- rep(0, 26); z &lt;- i %/% 5
pch3d(x, y, z, pch = i, bg = "gray", color = rainbow(26))
text3d(x, y, z + 0.3, i)
pch3d(x + 5, y, z, pch = i+65)
text3d(x + 5, y, z + 0.3, i+65)
</code></pre>

<hr>
<h2 id='persp3d'> Surface plots </h2><span id='topic+persp3d'></span><span id='topic+persp3d.default'></span>

<h3>Description</h3>

<p>This function draws plots of surfaces in 3-space. <code>persp3d</code> is a generic function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>persp3d(x, ...)

## Default S3 method:
persp3d(x = seq(0, 1, length.out = nrow(z)),
    y = seq(0, 1, length.out = ncol(z)), z,
    xlim = NULL, ylim = NULL, zlim = NULL,
    xlab = NULL, ylab = NULL, zlab = NULL, add = FALSE, aspect = !add, 
    forceClipregion = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persp3d_+3A_x">x</code>, <code id="persp3d_+3A_y">y</code>, <code id="persp3d_+3A_z">z</code></td>
<td>
<p>points to plot on surface.  See Details below.</p>
</td></tr>
<tr><td><code id="persp3d_+3A_xlim">xlim</code>, <code id="persp3d_+3A_ylim">ylim</code>, <code id="persp3d_+3A_zlim">zlim</code></td>
<td>
<p>x-, y-  and z-limits.  If present,
the plot is clipped to this region.</p>
</td></tr>
<tr><td><code id="persp3d_+3A_xlab">xlab</code>, <code id="persp3d_+3A_ylab">ylab</code>, <code id="persp3d_+3A_zlab">zlab</code></td>
<td>
<p>titles for the axes.  N.B. These must be
character strings; expressions are not accepted.  Numbers will be
coerced to character strings.</p>
</td></tr>
<tr><td><code id="persp3d_+3A_add">add</code></td>
<td>
<p>whether to add the points to an existing plot.</p>
</td></tr>    
<tr><td><code id="persp3d_+3A_aspect">aspect</code></td>
<td>
<p>either a logical indicating whether to adjust the aspect ratio, or a new ratio.</p>
</td></tr>
<tr><td><code id="persp3d_+3A_forceclipregion">forceClipregion</code></td>
<td>
<p>force a clipping region to be used,
whether or not limits are given.</p>
</td></tr>
<tr><td><code id="persp3d_+3A_...">...</code></td>
<td>
<p>additional material parameters to be passed to <code><a href="#topic+surface3d">surface3d</a></code>
and <code><a href="#topic+decorate3d">decorate3d</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method plots a surface defined as a grid of <code>(x,y,z)</code> locations in space.  The grid may be specified in several ways:
</p>

<ul>
<li><p>As with <code><a href="graphics.html#topic+persp">persp</a></code>, <code>x</code> and <code>y</code> may be given as vectors in ascending order, with <code>z</code> given as a matrix. There
should be one <code>x</code> value for each row of <code>z</code> and
one <code>y</code> value for each column.  The surface drawn will
have <code>x</code> constant across rows and <code>y</code> constant
across columns.  This is the most convenient format when
<code>z</code> is a function of <code>x</code> and <code>y</code> which are
measured on a regular grid.
</p>
</li>
<li><p><code>x</code> and <code>y</code> may also be given as matrices, in which
case they should have the same dimensions as <code>z</code>.  The
surface will combine corresponding points in each matrix
into locations <code>(x,y,z)</code> and draw the surface through those.  This
allows general surfaces to be drawn, as in the example of a spherical Earth shown below.
</p>
</li>
<li><p>If <code>x</code> is a <code>list</code>, its components <code>x$x</code>, <code>x$y</code> and <code>x$z</code> are used for <code>x</code>, <code>y</code> and
<code>z</code> respectively, though an explicitly specified
<code>z</code> value will have priority.</p>
</li></ul>

<p>One difference from <code><a href="graphics.html#topic+persp">persp</a></code> is that colors are specified on each
vertex, rather than on each facet of the surface.  To emulate the <code><a href="graphics.html#topic+persp">persp</a></code>
color handling, you need to do the following.  First, convert the color vector to 
an <code>(nx - 1)</code> by <code>(ny - 1)</code> matrix; then add an extra row before row 1, 
and an extra column after the last column, to convert it to <code>nx</code> by <code>ny</code>.
(These extra colors will not be used).  For example, 
<code>col &lt;- rbind(1, cbind(matrix(col, nx - 1, ny - 1), 1))</code>.
Finally, call <code>persp3d</code> with material property <code>smooth = FALSE</code>.
</p>
<p>See the &ldquo;Clipping&rdquo; section in <code><a href="#topic+plot3d">plot3d</a></code>
for more details on <code>xlim, ylim, zlim</code> and <code>forceClipregion</code>.
</p>


<h3>Value</h3>

<p>This function is called for the side effect of drawing the plot.  A vector 
of shape IDs is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot3d">plot3d</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>. There is
a <code><a href="#topic+persp3d.function">persp3d.function</a></code> method for drawing functions, and <code><a href="#topic+persp3d.deldir">persp3d.deldir</a></code> can be used
to draw surfaces defined by an irregular collection of points.  A formula method <code><a href="#topic+persp3d.formula">persp3d.formula</a></code> draws 
surfaces using this method.
</p>
<p>The <code><a href="#topic+surface3d">surface3d</a></code> function is used to draw the surface without the axes etc. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) The Obligatory Mathematical surface.
#     Rotated sinc function.

x &lt;- seq(-10, 10, length.out = 20)
y &lt;- x
f &lt;- function(x, y) { r &lt;- sqrt(x^2 + y^2); 10 * sin(r)/r }
z &lt;- outer(x, y, f)
z[is.na(z)] &lt;- 1
open3d()

# Draw the surface twice:  the first draws the solid part, 
# the second draws the grid.  Offset the first so it doesn't
# obscure the lines.

persp3d(x, y, z, aspect = c(1, 1, 0.5), col = "lightblue",
        xlab = "X", ylab = "Y", zlab = "Sinc( r )", 
        polygon_offset = 1)
persp3d(x, y, z, front = "lines", back = "lines", 
        lit = FALSE, add = TRUE)
highlevel()   # trigger the plot

# (2) Add to existing persp plot:

xE &lt;- c(-10, 10); xy &lt;- expand.grid(xE, xE)
points3d(xy[, 1], xy[, 2], 6, col = "red")
lines3d(x, y = 10, z = 6 + sin(x), col = "green")

phi &lt;- seq(0, 2*pi, length.out = 201)
r1 &lt;- 7.725 # radius of 2nd maximum
xr &lt;- r1 * cos(phi)
yr &lt;- r1 * sin(phi)
lines3d(xr, yr, f(xr, yr), col = "pink", lwd = 2)

# (3) Visualizing a simple DEM model

z &lt;- 2 * volcano        # Exaggerate the relief
x &lt;- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
y &lt;- 10 * (1:ncol(z))   # 10 meter spacing (E to W)

open3d()
invisible(bg3d("slategray")) # suppress display
material3d(col = "black")
persp3d(x, y, z, col = "green3", aspect = "iso",
      axes = FALSE, box = FALSE)

# (4) A globe

lat &lt;- matrix(seq(90, -90, length.out = 50)*pi/180, 50, 50, byrow = TRUE)
long &lt;- matrix(seq(-180, 180, length.out = 50)*pi/180, 50, 50)

r &lt;- 6378.1 # radius of Earth in km
x &lt;- r*cos(lat)*cos(long)
y &lt;- r*cos(lat)*sin(long)
z &lt;- r*sin(lat)

open3d()
persp3d(x, y, z, col = "white", 
       texture = system.file("textures/worldsmall.png", package = "rgl"), 
       specular = "black", axes = FALSE, box = FALSE, xlab = "", ylab = "", zlab = "",
       normal_x = x, normal_y = y, normal_z = z)

## Not run: 
# This looks much better, but is slow because the texture is very big
persp3d(x, y, z, col = "white", 
       texture = system.file("textures/world.png", package = "rgl"), 
       specular = "black", axes = FALSE, box = FALSE, xlab = "", ylab = "", zlab = "",
       normal_x = x, normal_y = y, normal_z = z)

## End(Not run)


</code></pre>

<hr>
<h2 id='persp3d.deldir'>
Plot a Delaunay triangulation
</h2><span id='topic+persp3d.deldir'></span><span id='topic+plot3d.deldir'></span><span id='topic+as.mesh3d.deldir'></span>

<h3>Description</h3>

<p>The <code><a href="deldir.html#topic+deldir">deldir</a>()</code> function in the <span class="pkg">deldir</span> package computes a Delaunay triangulation of a set
of points.  These functions display it as a surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'deldir'
plot3d(x, ...)
## S3 method for class 'deldir'
persp3d(x, ..., add = FALSE)
## S3 method for class 'deldir'
as.mesh3d(x, col = "gray", coords = c("x", "y", "z"), 
    smooth = TRUE, normals = NULL, texcoords = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persp3d.deldir_+3A_x">x</code></td>
<td>

<p>A <code>"deldir"</code> object, produced by the <code><a href="deldir.html#topic+deldir">deldir</a>()</code> function.  It must contain <code>z</code> values.
</p>
</td></tr>
<tr><td><code id="persp3d.deldir_+3A_add">add</code></td>
<td>

<p>Whether to add surface to existing plot (<code>add = TRUE</code>)
or create a new plot (<code>add = FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="persp3d.deldir_+3A_col">col</code></td>
<td>

<p>Colors to apply to each vertex in the triangulation.
Will be recycled as needed.
</p>
</td></tr>
<tr><td><code id="persp3d.deldir_+3A_coords">coords</code></td>
<td>

<p>See Details below.
</p>
</td></tr>
<tr><td><code id="persp3d.deldir_+3A_smooth">smooth</code></td>
<td>

<p>Whether to average normals at vertices for
a smooth appearance.
</p>
</td></tr>
<tr><td><code id="persp3d.deldir_+3A_normals">normals</code></td>
<td>

<p>User-specified normals at each vertex.  Requires <code>smooth = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="persp3d.deldir_+3A_texcoords">texcoords</code></td>
<td>

<p>Texture coordinates at each vertex.
</p>
</td></tr>
<tr><td><code id="persp3d.deldir_+3A_...">...</code></td>
<td>

<p>See Details below.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions construct a <code><a href="#topic+mesh3d">mesh3d</a></code> object
corresponding to the triangulation in <code>x</code>.  The
<code>plot3d</code> and <code>persp3d</code> methods plot it.
</p>
<p>The <code>coords</code> parameter allows surfaces to be 
plotted over any coordinate plane.  It should be
a permutation of the column names <code>c("x", "y", "z")</code>
from the <code>"deldir"</code> object.  The first will be used
as the x coordinate, the second as the y coordinate, 
and the third as the z coordinate.
</p>
<p>The <code>...</code> parameters in <code>plot3d.deldir</code> 
are passed to <code>persp3d.deldir</code>; in <code>persp3d.deldir</code> they are
passed to both <code>as.mesh3d.deldir</code> and <code>persp3d.mesh3d</code>; 
in <code>as.mesh3d.deldir</code> they are used as material parameters
in a <code><a href="#topic+tmesh3d">tmesh3d</a></code> call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(200, sd = 5)
y &lt;- rnorm(200, sd = 5)
r &lt;- sqrt(x^2 + y^2)
z &lt;- 10 * sin(r)/r
col &lt;- cm.colors(20)[1 + round(19*(z - min(z))/diff(range(z)))]

save &lt;- options(rgl.meshColorWarning = FALSE)

# This code is awkward:  to work with demo(rglExamples),
# we need auto-printing of the plots.  This means we
# have to repeat the test for deldir.

haveDeldir &lt;- checkDeldir()
              
if (haveDeldir) {
  dxyz &lt;- deldir::deldir(x, y, z = z, suppressMsge = TRUE)
  persp3d(dxyz, col = col)
}

if (haveDeldir) {
  open3d()
  # Do it without smoothing and with a different orientation.
  persp3d(dxyz, col = col, coords = c("z", "x", "y"), smooth = FALSE)
}

options(save)
</code></pre>

<hr>
<h2 id='persp3d.function'>
Plot a function of two variables
</h2><span id='topic+plot3d.function'></span><span id='topic+persp3d.function'></span>

<h3>Description</h3>

<p>Plot a function <code>z(x, y)</code> or a parametric function
<code>(x(s, t), y(s, t), z(s, t))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'function'
persp3d(x, 
  xlim = c(0, 1), ylim = c(0, 1), 
  slim = NULL, tlim = NULL, 
  n = 101, 
  xvals = seq.int(min(xlim), max(xlim), length.out = n[1]), 
  yvals = seq.int(min(ylim), max(ylim), length.out = n[2]), 
  svals = seq.int(min(slim), max(slim), length.out = n[1]), 
  tvals = seq.int(min(tlim), max(tlim), length.out = n[2]), 
  xlab, ylab, zlab, 
  col = "gray", otherargs = list(), 
  normal = NULL, texcoords = NULL, ...)
## S3 method for class 'function'
plot3d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persp3d.function_+3A_x">x</code></td>
<td>

<p>A function of two arguments.  See the details below.
</p>
</td></tr>
<tr><td><code id="persp3d.function_+3A_xlim">xlim</code>, <code id="persp3d.function_+3A_ylim">ylim</code></td>
<td>

<p>By default, the range of x and y values.  For a parametric
surface, if these are not missing, they are used as limits
on the displayed x and y values.
</p>
</td></tr>
<tr><td><code id="persp3d.function_+3A_slim">slim</code>, <code id="persp3d.function_+3A_tlim">tlim</code></td>
<td>

<p>If not <code>NULL</code>, these give the range of s and t in the
parametric specification of the surface.  If
only one is given, the other defaults to <code>c(0, 1)</code>.
</p>
</td></tr>
<tr><td><code id="persp3d.function_+3A_n">n</code></td>
<td>

<p>A one or two element vector giving the number of 
steps in the x and y (or s and t) grid.
</p>
</td></tr>
<tr><td><code id="persp3d.function_+3A_xvals">xvals</code>, <code id="persp3d.function_+3A_yvals">yvals</code></td>
<td>

<p>The values at which to evaluate x and y.  Ignored for
a parametric surface.  If used, <code>xlim</code> and/or <code>ylim</code>
are ignored.
</p>
</td></tr>
<tr><td><code id="persp3d.function_+3A_svals">svals</code>, <code id="persp3d.function_+3A_tvals">tvals</code></td>
<td>

<p>The values at which to evaluate s and t for a parametric
surface.  Only used if
<code>slim</code> or <code>tlim</code> is not <code>NULL</code>.  As with 
<code>xvals</code> and <code>yvals</code>, these override the corresponding
<code>slim</code> or <code>tlim</code> specification.
</p>
</td></tr>
<tr><td><code id="persp3d.function_+3A_xlab">xlab</code>, <code id="persp3d.function_+3A_ylab">ylab</code>, <code id="persp3d.function_+3A_zlab">zlab</code></td>
<td>

<p>The axis labels.  See the details below for the defaults.
</p>
</td></tr>
<tr><td><code id="persp3d.function_+3A_col">col</code></td>
<td>

<p>The color to use for the plot.  See the details below.
</p>
</td></tr>
<tr><td><code id="persp3d.function_+3A_otherargs">otherargs</code></td>
<td>

<p>Additional arguments to pass to the function.
</p>
</td></tr>
<tr><td><code id="persp3d.function_+3A_normal">normal</code>, <code id="persp3d.function_+3A_texcoords">texcoords</code></td>
<td>

<p>Functions to set surface normals or texture coordinates.  See
the details below.
</p>
</td></tr>
<tr><td><code id="persp3d.function_+3A_...">...</code></td>
<td>

<p>Additional arguments to pass to <code><a href="#topic+persp3d">persp3d</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"function"</code> method for <code>plot3d</code> simply passes
all arguments to <code>persp3d</code>.  Thus this description applies
to both.
</p>
<p>The first argument <code>x</code> is required to be a function.  It
is named <code>x</code> only because of the requirements of the S3
system; in the remainder of this help page, we will assume
that the assignment <code>f &lt;- x</code> has been made, and will 
refer to the function <code>f()</code>.
</p>
<p><code>persp3d.function</code> evaluates <code>f()</code> on a two-dimensional
grid of values, and displays the resulting surface.  The values
on the grid will be passed in as vectors in the 
first two arguments to the function, so <code>f()</code> needs
to be vectorized.  Other optional arguments to <code>f()</code>
can be specified in the <code>otherargs</code> list.
</p>
<p>In the default form where <code>slim</code> and <code>tlim</code> are both
<code>NULL</code>, it is assumed that <code>f(x, y)</code> returns heights,
which will be plotted in the z coordinate.  The default axis labels
will be taken from the argument names to <code>f()</code> and the
expression passed as argument <code>x</code> to this function.
</p>
<p>If <code>slim</code> or <code>tlim</code> is specified, a parametric
surface is plotted.  The function
<code>f(s, t)</code> must return a 3-column matrix, giving x, y and z 
coordinates of points on the surface.  The default axis
labels will be the column names if those are present.
In this case <code>xlim</code>, <code>ylim</code> and <code>zlim</code>
are used to define a clipping region only if specified;
the defaults are ignored.
</p>
<p>The color of the surface may be specified as the name of a
color, or a vector or matrix of color names. In this case
the colors will be recycled across the points on the grid
of values.
</p>
<p>Alternatively, a function may be given:  it should be a function
like <code><a href="grDevices.html#topic+rainbow">rainbow</a></code> that takes an integer argument and
returns a vector of colors.  In this case the colors are mapped
to z values.
</p>
<p>The <code>normal</code> argument allows specification of a function
to compute normal vectors to the surface.  This function is
passed the same arguments as <code>f()</code> (including <code>otherargs</code>
if present), and should produce a 3-column matrix containing the
x, y and z coordinates of the normals.
</p>
<p>The <code>texcoords</code> argument is a function similar to <code>normal</code>, but
it produces a 2-column matrix containing texture coordinates.
</p>
<p>Both <code>normal</code> and <code>texcoords</code> may also contain matrices,
with 3 and 2 columns respectively, and rows corresponding to the
points that were passed to <code>f()</code>.
</p>


<h3>Value</h3>

<p>This function constructs a call to <code><a href="#topic+persp3d">persp3d</a></code>
and returns the value from that function.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p>The <code><a href="graphics.html#topic+curve">curve</a></code> function in base graphics does
something similar for functions of one variable.  See the
example below for space curves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) The Obligatory Mathematical surface.
#     Rotated sinc function, with colors

f &lt;- function(x, y) { 
  r &lt;- sqrt(x^2 + y^2)
  ifelse(r == 0, 10, 10 * sin(r)/r)
}
open3d()
plot3d(f, col = colorRampPalette(c("blue", "white", "red")), 
       xlab = "X", ylab = "Y", zlab = "Sinc( r )", 
       xlim = c(-10, 10), ylim = c(-10, 10),
       aspect = c(1, 1, 0.5))
       
# (2) A cylindrical plot

f &lt;- function(s, t) {
  r &lt;- 1 + exp( -pmin( (s - t)^2, 
                       (s - t - 1)^2, 
                       (s - t + 1)^2 )/0.01 )
  cbind(r*cos(t*2*pi), r*sin(t*2*pi), s)
}

open3d()
plot3d(f, slim = c(0, 1), tlim = c(0, 1), col = "red", alpha = 0.8)

# Add a curve to the plot, fixing s at 0.5.

plot3d(f(0.5, seq.int(0, 1, length.out = 100)), type = "l", add = TRUE, 
       lwd = 3, depth_test = "lequal")
</code></pre>

<hr>
<h2 id='persp3d.triSht'>
Plot an interp or tripack Delaunay triangulation
</h2><span id='topic+persp3d.triSht'></span><span id='topic+plot3d.triSht'></span><span id='topic+as.mesh3d.triSht'></span><span id='topic+persp3d.tri'></span><span id='topic+plot3d.tri'></span><span id='topic+as.mesh3d.tri'></span>

<h3>Description</h3>

<p>The <code><a href="interp.html#topic+tri.mesh">tri.mesh</a>()</code> functions in the
<span class="pkg">interp</span> and <span class="pkg">tripack</span> packages compute a Delaunay triangulation of a set
of points.  These functions display it as a surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'triSht'
plot3d(x, z, ...)
## S3 method for class 'triSht'
persp3d(x, z, ..., add = FALSE)
## S3 method for class 'triSht'
as.mesh3d(x, z, col = "gray", coords = c("x", "y", "z"), 
    smooth = TRUE, normals = NULL, texcoords = NULL, ...)
## S3 method for class 'tri'
plot3d(x, z, ...)
## S3 method for class 'tri'
persp3d(x, z, ..., add = FALSE)
## S3 method for class 'tri'
as.mesh3d(x, z, col = "gray", coords = c("x", "y", "z"), 
    smooth = TRUE, normals = NULL, texcoords = NULL, ...)    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persp3d.triSht_+3A_x">x</code></td>
<td>

<p>A <code>"triSht"</code> or <code>"tri"</code> object, produced by the <code><a href="interp.html#topic+tri.mesh">tri.mesh</a>()</code> function in the <span class="pkg">interp</span> or <span class="pkg">tripack</span> packages respectively.  
</p>
</td></tr>
<tr><td><code id="persp3d.triSht_+3A_z">z</code></td>
<td>

<p>z coordinate values corresponding to each of the nodes in <code>x</code>.  
</p>
</td></tr>
<tr><td><code id="persp3d.triSht_+3A_add">add</code></td>
<td>

<p>Whether to add surface to existing plot (<code>add = TRUE</code>)
or create a new plot (<code>add = FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="persp3d.triSht_+3A_col">col</code></td>
<td>

<p>Colors to apply to each vertex in the triangulation.
Will be recycled as needed.
</p>
</td></tr>
<tr><td><code id="persp3d.triSht_+3A_coords">coords</code></td>
<td>

<p>See Details below.
</p>
</td></tr>
<tr><td><code id="persp3d.triSht_+3A_smooth">smooth</code></td>
<td>

<p>Whether to average normals at vertices for
a smooth appearance.
</p>
</td></tr>
<tr><td><code id="persp3d.triSht_+3A_normals">normals</code></td>
<td>

<p>User-specified normals at each vertex.  Requires <code>smooth = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="persp3d.triSht_+3A_texcoords">texcoords</code></td>
<td>

<p>Texture coordinates at each vertex.
</p>
</td></tr>
<tr><td><code id="persp3d.triSht_+3A_...">...</code></td>
<td>

<p>See Details below.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions construct a <code><a href="#topic+mesh3d">mesh3d</a></code> object
corresponding to the triangulation in <code>x</code>.  The
<code>plot3d</code> and <code>persp3d</code> methods plot it.
</p>
<p>The <code>coords</code> parameter allows surfaces to be 
plotted over any coordinate plane.  It should be
a permutation of the column names <code>c("x", "y", "z")</code>.
The first will be used
as the x coordinate, the second as the y coordinate, 
and the third as the z coordinate.
</p>
<p>The <code>...</code> parameters in <code>plot3d.triSht</code> and <code>plot3d.tri</code> 
are passed to <code>persp3d</code>; in <code>persp3d.triSht</code>
and <code>persp3d.tri</code> they are
passed to both <code>as.mesh3d</code> and <code>persp3d.mesh3d</code>; 
in <code>as.mesh3d.triSht</code> and <code>as.mesh3d.tri</code> they are used as material parameters
in a <code><a href="#topic+tmesh3d">tmesh3d</a></code> call.
</p>
<p><code>"tri"</code> objects may contain constraints.  These appear
internally as extra nodes, representing either the inside
or outside of boundaries on the region being triangulated.
Each of these nodes should also have a <code>z</code> value, but 
triangles corresponding entirely to constraint nodes will not
be drawn.  In this way complex, non-convex regions can
be triangulated.  See the second example below.
</p>


<h3>Note</h3>

<p>If there are duplicate points, the <code>tri.mesh()</code> functions
will optionally delete some of them.  If you choose this option,
the <code>z</code> values must correspond to the nodes <em>after</em>
deletion, not before.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(200, sd = 5)
y &lt;- rnorm(200, sd = 5)
r &lt;- sqrt(x^2 + y^2)
z &lt;- 10 * sin(r)/r
col &lt;- cm.colors(20)[1 + round(19*(z - min(z))/diff(range(z)))]
save &lt;- NULL
if ((haveinterp &lt;- requireNamespace("interp", quietly = TRUE))) {
  save &lt;- options(rgl.meshColorWarning = FALSE)
  dxy &lt;- interp::tri.mesh(x, y)
  open3d()
  persp3d(dxy, z, col = col, meshColor = "vertices")
}
if (haveinterp) {
  open3d()
  # Do it without smoothing and with a different orientation.
  persp3d(dxy, z, col = col, coords = c("z", "x", "y"), smooth = FALSE)
}
if (requireNamespace("tripack", quietly = TRUE)) {
  if (is.null(save))
    save &lt;- options(rgl.meshColorWarning = FALSE)

  # Leave a circular hole around (3, 0)
  theta &lt;- seq(0, 2*pi, length.out = 30)[-1]
  cx &lt;- 2*cos(theta) + 3
  cy &lt;- 2*sin(theta)
  keep &lt;- (x - 3)^2 + y^2 &gt; 4
  dxy2 &lt;- tripack::tri.mesh(x[keep], y[keep])
  dxy2 &lt;- tripack::add.constraint(dxy2, cx, cy)
  z &lt;- dxy2$x^2 - dxy2$y^2
  col &lt;- terrain.colors(20)[1 + round(19*(z - min(z))/diff(range(z)))]
  open3d()
  persp3d(dxy2, z, col = col)
}
options(save)
</code></pre>

<hr>
<h2 id='planes3d'>Add planes</h2><span id='topic+planes3d'></span><span id='topic+clipplanes3d'></span>

<h3>Description</h3>

<p><code>planes3d</code> adds mathematical planes 
to a scene.  Their intersection with the current
bounding box will be drawn.  <code>clipplanes3d</code> 
adds clipping planes to a scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planes3d(a, b = NULL, c = NULL, d = 0, ...)
clipplanes3d(a, b = NULL, c = NULL, d = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="planes3d_+3A_a">a</code>, <code id="planes3d_+3A_b">b</code>, <code id="planes3d_+3A_c">c</code></td>
<td>

<p>Coordinates of the normal to the plane.  Any reasonable way of defining the
coordinates is acceptable.  See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>
for details.
</p>
</td></tr>
<tr><td><code id="planes3d_+3A_d">d</code></td>
<td>

<p>Coordinates of the &quot;offset&quot;.  See the details.
</p>
</td></tr>
<tr><td><code id="planes3d_+3A_...">...</code></td>
<td>

<p>Material properties. See <code><a href="#topic+material3d">material3d</a></code> for details.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>planes3d</code> draws planes using the parametrization
<code class="reqn">a x + b y + c z + d = 0</code>.  Multiple planes may be specified
by giving multiple values for any of <code>a, b, c, d</code>; the other 
values will be recycled as necessary.
</p>
<p><code>clipplanes3d</code> defines clipping planes
using the same equations.  Clipping planes suppress the display of
other objects (or parts of them) in the subscene, based on their coordinates.
Points (or parts of lines or surfaces) where the coordinates <code>x, y, z</code>
satisfy <code class="reqn">a x + b y + c z + d &lt; 0</code> will be suppressed.
</p>
<p>The number of clipping planes
supported by the OpenGL driver is implementation dependent; use
<code>par3d("maxClipPlanes")</code> to find the limit.
</p>


<h3>Value</h3>

<p>A shape ID of the planes or clipplanes object is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abclines3d">abclines3d</a></code> for mathematical lines.
</p>
<p><code><a href="#topic+triangles3d">triangles3d</a></code> or the corresponding
functions for quadrilaterals may be used to draw sections of planes that
do not adapt to the bounding box.
</p>
<p>The example in <a href="#topic+subscene3d">subscene3d</a> shows how to combine clipping planes
to suppress complex shapes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Show regression plane with z as dependent variable

open3d()
x &lt;- rnorm(100)
y &lt;- rnorm(100)
z &lt;- 0.2*x - 0.3*y + rnorm(100, sd = 0.3)
fit &lt;- lm(z ~ x + y)
plot3d(x, y, z, type = "s", col = "red", size = 1)

coefs &lt;- coef(fit)
a &lt;- coefs["x"]
b &lt;- coefs["y"]
c &lt;- -1
d &lt;- coefs["(Intercept)"]
planes3d(a, b, c, d, alpha = 0.5)

open3d()
ids &lt;- plot3d(x, y, z, type = "s", col = "red", size = 1, forceClipregion = TRUE) 
oldid &lt;- useSubscene3d(ids["clipregion"])
clipplanes3d(a, b, c, d)
useSubscene3d(oldid)
</code></pre>

<hr>
<h2 id='play3d'> Play animation of RGL scene </h2><span id='topic+play3d'></span><span id='topic+movie3d'></span>

<h3>Description</h3>

<p><code>play3d</code> calls a function repeatedly, passing it the elapsed
time in seconds, and using the result of the function to
reset the viewpoint.  <code>movie3d</code> does the same, but
records each frame to a file to make a movie.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>play3d(f, duration = Inf, dev = cur3d(), ..., startTime = 0)
movie3d(f, duration, dev = cur3d(), ..., fps = 10, 
                    movie = "movie", frames = movie, dir = tempdir(), 
                    convert = NULL, clean = TRUE, verbose = TRUE,
                    top = !rgl.useNULL(), type = "gif", startTime = 0,
                    webshot = TRUE) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="play3d_+3A_f">f</code></td>
<td>
<p> A function returning a list that may be passed to <code><a href="#topic+par3d">par3d</a></code> </p>
</td></tr>
<tr><td><code id="play3d_+3A_duration">duration</code></td>
<td>
<p> The duration of the animation </p>
</td></tr>    
<tr><td><code id="play3d_+3A_dev">dev</code></td>
<td>
<p> Which RGL device to select </p>
</td></tr>
<tr><td><code id="play3d_+3A_...">...</code></td>
<td>
<p> Additional parameters to pass to <code>f</code>. </p>
</td></tr>
<tr><td><code id="play3d_+3A_starttime">startTime</code></td>
<td>
<p> Initial time at which to start the animation </p>
</td></tr>
<tr><td><code id="play3d_+3A_fps">fps</code></td>
<td>
<p> Number of frames per second </p>
</td></tr>
<tr><td><code id="play3d_+3A_movie">movie</code></td>
<td>
<p> The base of the output filename, not including .gif </p>
</td></tr>
<tr><td><code id="play3d_+3A_frames">frames</code></td>
<td>
<p> The base of the name for each frame </p>
</td></tr>
<tr><td><code id="play3d_+3A_dir">dir</code></td>
<td>
<p> A directory in which to create temporary files for each frame of the movie </p>
</td></tr>  
<tr><td><code id="play3d_+3A_convert">convert</code></td>
<td>
<p> How to convert to a GIF movie; see Details </p>
</td></tr>
<tr><td><code id="play3d_+3A_clean">clean</code></td>
<td>
<p> If <code>convert</code> is <code>NULL</code> or <code>TRUE</code>, whether to delete the individual frames </p>
</td></tr>
<tr><td><code id="play3d_+3A_verbose">verbose</code></td>
<td>
<p> Whether to report the <code>convert</code> command and the output filename </p>
</td></tr>
<tr><td><code id="play3d_+3A_top">top</code></td>
<td>
<p> Whether to call <code><a href="#topic+rgl.bringtotop">rgl.bringtotop</a></code> before each frame </p>
</td></tr>
<tr><td><code id="play3d_+3A_type">type</code></td>
<td>
<p> What type of movie to create.  See Details. </p>
</td></tr>
<tr><td><code id="play3d_+3A_webshot">webshot</code></td>
<td>
<p> Whether to use the <span class="pkg">webshot2</span> package
for snapshots of frames. See <code><a href="#topic+snapshot3d">snapshot3d</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>f</code> will be called in a loop with the first argument
being the <code>startTime</code> plus the time in seconds since the start 
(where the start is measured after all arguments have been evaluated).
</p>
<p><code>play3d</code> is likely to place a high load
on the CPU; if this is a problem, calls to <code><a href="base.html#topic+Sys.sleep">Sys.sleep</a></code>
should be made within the function to release time to other processes.
</p>
<p><code>play3d</code> will run for the specified <code>duration</code> (in seconds), but
can be interrupted by pressing <code>ESC</code> while the RGL window has the focus.
</p>
<p><code>movie3d</code> saves each frame to disk in a filename of the form &lsquo;<span class="file">framesXXX.png</span>&rsquo;, where
XXX is the frame number, starting from 0.  
If <code>convert</code> is <code>NULL</code> (the default) and the
<span class="pkg"><a href="magick.html#topic+magick">magick</a></span> package is installed, it will be used
to convert the frames to a GIF movie (or other format if supported).  If 
<span class="pkg"><a href="magick.html#topic+magick">magick</a></span> is not installed or 
<code>convert</code> is <code>TRUE</code>, <code>movie3d</code> will attempt
to use the external <code>ImageMagick</code> program to convert the
frames to a movie.  
The newer <code>magick</code> executable is tried
first, then <code>convert</code> if that fails.
The <code>type</code> argument will be passed to <code>ImageMagick</code> to use as a file extension
to choose the file type.
</p>
<p>Finally, <code>convert</code> can be a template for a command to
execute in the standard shell (wildcards are allowed). The template is
converted to a command using <br />
<code><a href="base.html#topic+sprintf">sprintf</a>(convert, fps, frames, movie, type, duration, dir)</code> <br />
For example, <code>convert = TRUE</code>
uses the template <code>"magick -delay 1x%d %s*.png %s.%s"</code>. All work
is done in the directory <code>dir</code>, so paths should not be needed in
the command.  (Note that <code><a href="base.html#topic+sprintf">sprintf</a></code> does not require all
arguments to be used, and supports formats that use them in an
arbitrary order.)
</p>
<p>The <code>top = TRUE</code> default is designed to work around an OpenGL limitation:
in some implementations, <code><a href="#topic+rgl.snapshot">rgl.snapshot</a></code> will fail if the window
is not topmost.
</p>
<p>As of <span class="pkg">rgl</span> version 0.94, the <code>dev</code> argument is not needed:  the
function <code>f</code> can specify its device, as <code><a href="#topic+spin3d">spin3d</a></code> does, 
for example.  However, if <code>dev</code> is specified, it will be selected
as the current device as each update is played.
</p>
<p>As of <span class="pkg">rgl</span> version 0.95.1476, <code>f</code> can 
include multiple values in a <code>"subscene"</code>
component, and <code>par3d()</code> will be called
for each of them.
</p>


<h3>Value</h3>

<p><code>play3d</code> is called for the side effect of its repeated calls to <code>f</code>.
It returns <code>NULL</code> invisibly.
</p>
<p><code>movie3d</code> is also normally called for the side effect
of producing the output movie.  It invisibly returns
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch, based on code by Michael Friendly </p>


<h3>See Also</h3>

 <p><code><a href="#topic+spin3d">spin3d</a></code> and <code><a href="#topic+par3dinterp">par3dinterp</a></code> return functions suitable 
to use as <code>f</code>. See <code>demo(flag)</code> for an example that modifies the
scene in <code>f</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
plot3d( cube3d(col = "green") )
M &lt;- par3d("userMatrix")
if (!rgl.useNULL() &amp;&amp; interactive())
  play3d( par3dinterp(times = (0:2)*0.5, userMatrix = list(M,
                                     rotate3d(M, pi/2, 1, 0, 0),
                                     rotate3d(M, pi/2, 0, 1, 0) ) ), 
        duration = 2 )
## Not run: 
movie3d( spin3d(), duration = 5 )

## End(Not run)

</code></pre>

<hr>
<h2 id='playwidget'>
Add a widget to play animations
</h2><span id='topic+playwidget'></span>

<h3>Description</h3>

<p>This is a widget that can be put in a web page to allow
animations with or without Shiny.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>playwidget(sceneId, controls,
            start = 0, stop = Inf, interval = 0.05, rate = 1,
            components = c("Reverse", "Play", "Slower", "Faster",
                           "Reset", "Slider", "Label"),
            loop = TRUE,
            step = 1, labels = NULL,
            precision = 3,
            elementId = NULL, respondTo = NULL,
            reinit = NULL,
            buttonLabels = components, pause = "Pause",
            height = 40,
            ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="playwidget_+3A_sceneid">sceneId</code></td>
<td>

<p>The HTML id of the RGL scene being controlled,
or an object.  See the Details below.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_controls">controls</code></td>
<td>

<p>A single <code>"rglControl"</code> object, e.g. <code><a href="#topic+propertyControl">propertyControl</a></code>, or a list of several.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_start">start</code>, <code id="playwidget_+3A_stop">stop</code></td>
<td>

<p>The starting and stopping values of the animation.  If
<code>labels</code> is supplied <code>stop</code> will default to step
through the labels.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_interval">interval</code></td>
<td>

<p>The requested interval (in seconds) between updates.  Updates
may occur at longer intervals.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_rate">rate</code></td>
<td>

<p>The number of units of &ldquo;nominal&rdquo; time per real world
second.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_components">components</code></td>
<td>

<p>Which components should be displayed?  See Details below.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_loop">loop</code></td>
<td>

<p>When the player reaches the end of the interval,
should it loop back to the beginning?
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_step">step</code></td>
<td>

<p>Step size in the slider.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_labels">labels</code></td>
<td>

<p>Optional labels to use, corresponding to slider steps.  Set to
<code>NULL</code> for auto-generated labels.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_precision">precision</code></td>
<td>

<p>If <code>labels=NULL</code>, the precision to use when displaying
timer values.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_elementid">elementId</code></td>
<td>

<p>The HTML id of the generated widget, containing buttons,
slider, etc.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_respondto">respondTo</code></td>
<td>

<p>The HTML ID of a Shiny input control (e.g. a <code><a href="shiny.html#topic+sliderInput">sliderInput</a></code>
control) to respond to.</p>
</td></tr>
<tr><td><code id="playwidget_+3A_reinit">reinit</code></td>
<td>

<p>A vector of ids that will need re-initialization before
being drawn again.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_buttonlabels">buttonLabels</code>, <code id="playwidget_+3A_pause">pause</code></td>
<td>

<p>These are the labels that will be shown on the buttons if they are displayed.  <code>pause</code> will
be shown on the <code>"Play"</code> button while playing.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_height">height</code></td>
<td>

<p>The height of the widget in pixels.  In a pipe, this is a relative height.
</p>
</td></tr>
<tr><td><code id="playwidget_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to
to <code>htmlwidgets::<a href="htmlwidgets.html#topic+createWidget">createWidget</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>components</code> are buttons to control the animation,
a slider for manual control, and a label to show the current
value.  They will be displayed in the order given in <code>components</code>.  Not all need be included.
</p>
<p>The buttons have the following behaviour:
</p>

<dl>
<dt>Reverse</dt><dd><p>Reverse the direction.</p>
</dd>
<dt>Play</dt><dd><p>Play the animation.</p>
</dd>
<dt>Slower</dt><dd><p>Decrease the playing speed.</p>
</dd>
<dt>Faster</dt><dd><p>Increase the playing speed.</p>
</dd>
<dt>Reset</dt><dd><p>Stop the animation and reset to the start value.</p>
</dd>
</dl>

<p>If <code>respondTo</code> is used, no <code>components</code> are shown, as it is assumed Shiny (or whatever control is being referenced) will provide the UI components.
</p>
<p>The <code>sceneId</code> component can be another <code>playwidget</code>, a <code><a href="#topic+rglwidget">rglwidget</a></code> result, or a result of
<code>htmltools::<a href="htmltools.html#topic+builder">tags</a></code> or <code>htmltools::<a href="htmltools.html#topic+tag">tagList</a></code>.  This allows you
to use a <span class="pkg">magrittr</span>-style
&ldquo;pipe&rdquo; command to join an <code>rglwidget</code> with one or more <code><a href="#topic+playwidget">playwidget</a></code>s.  If a <code>playwidget</code> comes
first, <code>sceneId</code> should be set to <code>NA</code>.  If
the <code><a href="#topic+rglwidget">rglwidget</a></code> does not come first,
previous values should be piped into its <code>controllers</code>
argument.  Other HTML code (including other widgets)
can be used in the chain if wrapped in <code>htmltools::<a href="htmltools.html#topic+tag">tagList</a></code>.
</p>
<p>Each control should inherit from <code>"rglControl"</code>.  They
can have the following components in addition to any 
private ones:
</p>

<dl>
<dt><code>labels</code></dt><dd><p>default labels for the slider.</p>
</dd>
<dt><code>param</code></dt><dd><p>values to include on the slider.</p>
</dd>
<dt><code>dependencies</code></dt><dd><p>additional HTML dependencies to
include, after the default <code>rglwidgetClass</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A widget suitable for use in an <span class="pkg">Rmarkdown</span>-generated web
page, or elsewhere.
</p>


<h3>Appearance</h3>

<p>The appearance of the controls is set by the stylesheet
in <code>system.file("htmlwidgets/lib/rglClass/rgl.css")</code>.
</p>
<p>The overall widget is of class <code>rglPlayer</code>, with id
set according to <code>elementId</code>.
</p>
<p>The buttons are of HTML class <code>rgl-button</code>, the
slider is of class <code>rgl-slider</code>, and the label is of
class <code>rgl-label</code>.  Each element has an id prefixed
by the widget id, e.g. <code>elementId-button-Reverse</code>,
<code>elementId-slider</code>, etc. (where <code>elementId</code>
should be replaced by the actual id).
</p>
<p>The <code>reinit</code> parameter handles the case where
an object needs re-initialization after each change.  For
example, plane objects may need this if their intersection
with the bounding box changes shape.  Note that
re-initialization is generally incompatible with
the <code><a href="#topic+vertexControl">vertexControl</a></code> as it modifies values
which are set during initialization.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subsetControl">subsetControl</a></code>,
<code><a href="#topic+propertyControl">propertyControl</a></code>, <code><a href="#topic+ageControl">ageControl</a></code> and
<code><a href="#topic+vertexControl">vertexControl</a></code> are possible controls to use.
</p>
<p><code><a href="#topic+toggleWidget">toggleWidget</a></code> is a wrapper for 
<code>playwidget</code> and <code><a href="#topic+subsetControl">subsetControl</a></code>
to insert a single button to toggle some elements in a display.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>saveopts &lt;- options(rgl.useNULL = TRUE)

objid &lt;- plot3d(1:10, 1:10, rnorm(10), col=c("red", "red"), type = "s")["data"]

control &lt;- ageControl(value=0,
             births=1:10,
             ages = c(-5,0,5),
             colors = c("green", "yellow", "red"),
             objids = objid)


# This example uses explicit names
rglwidget(elementId = "theplot", controllers = "theplayer",
          height = 300, width = 300)
playwidget("theplot", control, start = -5, stop = 5,
           rate = 3, elementId = "theplayer",
           components = c("Play", "Slider"))


# This example uses pipes, and can skip the names

widget &lt;- rglwidget(height = 300, width = 300) %&gt;%
playwidget(control, start = -5, stop = 5,
           rate = 3, components = c("Play", "Slider"))
if (interactive() || in_pkgdown_example())
  widget

options(saveopts)
</code></pre>

<hr>
<h2 id='plot3d'>3D scatterplot</h2><span id='topic+plot3d'></span><span id='topic+plot3d.default'></span><span id='topic+plot3d.mesh3d'></span>

<h3>Description</h3>

<p>Draws a 3D scatterplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3d(x, ...)
## Default S3 method:
plot3d(x, y, z,  
	xlab, ylab, zlab, type = "p", 
	col, size, lwd, radius,
	add = FALSE, aspect = !add, 
	xlim = NULL, ylim = NULL, zlim = NULL, 
	forceClipregion = FALSE, 
	decorate = !add, ...)
## S3 method for class 'mesh3d'
plot3d(x, xlab = "x", ylab = "y", zlab = "z", type = c("shade", "wire", "dots"),
	add = FALSE, aspect = !add, ...)	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d_+3A_x">x</code>, <code id="plot3d_+3A_y">y</code>, <code id="plot3d_+3A_z">z</code></td>
<td>
<p>vectors of points to be plotted. Any reasonable way of defining the
coordinates is acceptable.  See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>
for details.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_xlab">xlab</code>, <code id="plot3d_+3A_ylab">ylab</code>, <code id="plot3d_+3A_zlab">zlab</code></td>
<td>
<p>labels for the coordinates.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_type">type</code></td>
<td>
<p>For the default method, a single character indicating the type of item to plot.  
Supported types are: 'p' for points, 's' for spheres, 
'l' for lines, 'h' for line segments 
from <code>z = 0</code>, and 'n' for nothing.  For the <code>mesh3d</code> method, one of 
'shade', 'wire', or 'dots'.  Partial matching is used.
</p>
</td></tr>
<tr><td><code id="plot3d_+3A_col">col</code></td>
<td>
<p>the color to be used for plotted items.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_size">size</code></td>
<td>
<p>the size for plotted points.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_lwd">lwd</code></td>
<td>
<p>the line width for plotted items.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_radius">radius</code></td>
<td>
<p>the radius of spheres:  see Details below.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_add">add</code></td>
<td>
<p>whether to add the points to an existing plot.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_aspect">aspect</code></td>
<td>
<p>either a logical indicating whether to adjust the aspect ratio, or a new ratio.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_xlim">xlim</code>, <code id="plot3d_+3A_ylim">ylim</code>, <code id="plot3d_+3A_zlim">zlim</code></td>
<td>
<p>If not <code>NULL</code>, set clipping
limits for the plot.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_forceclipregion">forceClipregion</code></td>
<td>
<p>Force a clipping region to be used,
whether or not limits are given.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_decorate">decorate</code></td>
<td>
<p>Whether to add bounding axes and other
decorations.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_...">...</code></td>
<td>
<p>additional parameters which will be passed to <code><a href="#topic+par3d">par3d</a></code>, <code><a href="#topic+material3d">material3d</a></code>
or <code><a href="#topic+decorate3d">decorate3d</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot3d</code> is a partial 3D analogue of plot.default.
</p>
<p>Missing values in the data are skipped, as in standard graphics.
</p>
<p>If <code>aspect</code> is <code>TRUE</code>, aspect ratios of <code>c(1, 1, 1)</code> are passed to
<code><a href="#topic+aspect3d">aspect3d</a></code>.  If <code>FALSE</code>, no aspect adjustment is done.  In other
cases, the value is passed to <code><a href="#topic+aspect3d">aspect3d</a></code>.
</p>
<p>With <code>type = "s"</code>, spheres are drawn centered at the specified locations.
The radius may be controlled by <code>size</code> (specifying the size relative
to the plot display, with the default <code>size = 3</code> giving a radius 
about 1/20 of the plot region) or <code>radius</code> (specifying it on the data scale
if an isometric aspect ratio is chosen, or on an average scale
if not). 
</p>


<h3>Value</h3>

<p><code>plot3d</code> is called for the side effect of drawing the plot; a vector
of object IDs is returned.
</p>


<h3>Clipping</h3>

<p>If any of <code>xlim</code>, <code>ylim</code> or <code>zlim</code> are specified,
they should be length two vectors giving lower and upper 
clipping limits for the corresponding coordinate.  <code>NA</code>
limits will be ignored.
</p>
<p>If any clipping limits are given, then the data will be
plotted in a newly created subscene within the current one;
otherwise plotting will take place directly in the current
subscene.  This subscene is named <code>"clipregion"</code>
in the results.  This may affect the appearance of transparent
objects if some are drawn in the <code>plot3d</code> call and others after, 
as RGL will not attempt to depth-sort objects if they are
in different subscenes.  It is best to draw all overlapping 
transparent objects in the same subscene.  See the example 
in <code><a href="#topic+planes3d">planes3d</a></code>.  It will also affect the use
of <code><a href="#topic+clipplanes3d">clipplanes3d</a></code>; clipping planes need to be in the 
same subscene as the objects being clipped.
</p>
<p>Use <code>forceClipregion = TRUE</code> to force creation of this 
subscene even without specifying limits. 
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot.default">plot.default</a></code>,  
<code><a href="#topic+open3d">open3d</a></code>, <code><a href="#topic+par3d">par3d</a></code>.
There are  <code><a href="#topic+plot3d.function">plot3d.function</a></code> and <code><a href="#topic+plot3d.deldir">plot3d.deldir</a></code> methods for plotting surfaces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  open3d()
  x &lt;- sort(rnorm(1000))
  y &lt;- rnorm(1000)
  z &lt;- rnorm(1000) + atan2(x, y)
  plot3d(x, y, z, col = rainbow(1000))
</code></pre>

<hr>
<h2 id='plot3d.formula'>
Methods for formulas
</h2><span id='topic+plot3d.formula'></span><span id='topic+persp3d.formula'></span>

<h3>Description</h3>

<p>These functions provide a simple formula-based interface
to <code><a href="#topic+plot3d">plot3d</a></code> and <code><a href="#topic+persp3d">persp3d</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
plot3d(x, data = NULL, xlab, ylab, zlab, ...)
## S3 method for class 'formula'
persp3d(x, data = NULL, xlab, ylab, zlab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.formula_+3A_x">x</code></td>
<td>

<p>A formula like <code>z ~ x + y</code>.
</p>
</td></tr>
<tr><td><code id="plot3d.formula_+3A_data">data</code></td>
<td>

<p>An optional dataframe or list in which to find the components
of the formula.
</p>
</td></tr>
<tr><td><code id="plot3d.formula_+3A_xlab">xlab</code>, <code id="plot3d.formula_+3A_ylab">ylab</code>, <code id="plot3d.formula_+3A_zlab">zlab</code></td>
<td>

<p>Optional axis labels to override the ones automatically
obtained from the formula.
</p>
</td></tr>
<tr><td><code id="plot3d.formula_+3A_...">...</code></td>
<td>

<p>Additional arguments to pass to the default <code>plot3d</code>
method, or the <code>persp3d</code> method for <code>"deldir"</code>
objects.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only simple formulas (the ones handled by the <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code> function) are supported:  a single variable on the left hand side (which will be plotted on the Z axis),
and a sum of two variables on the right hand side (which
will be the X and Y axis variables in the plot.)
</p>


<h3>Value</h3>

<p>These functions are called for the side effect of drawing
the plots. The <code>plot3d</code> method draws a scatterplot.  The <code>persp3d</code> method draws a surface plot.
</p>
<p>Return values are as given by the <code><a href="#topic+plot3d.default">plot3d.default</a></code> method or the <code><a href="#topic+persp3d.deldir">persp3d.deldir</a></code> 
methods.
</p>


<h3>Note</h3>

<p>The <code>persp3d</code> method requires that the suggested package <span class="pkg">deldir</span> is installed.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
mfrow3d(1, 2, sharedMouse = TRUE)
plot3d(mpg ~ wt + qsec, data = mtcars)
if (checkDeldir())
  persp3d(mpg ~ wt + qsec, data = mtcars)
</code></pre>

<hr>
<h2 id='plot3d.lm'>
Method for plotting simple linear fit
</h2><span id='topic+plot3d.lm'></span>

<h3>Description</h3>

<p>This function provides several plots of the result of
fitting a two-predictor model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
plot3d(x, 
       which = 1, 
       plane.col = "gray", plane.alpha = 0.5,
       sharedMouse = TRUE, 
       use_surface3d, 
       do_grid = TRUE,
       grid.col = "black", 
       grid.alpha = 1,
       grid.steps = 5,
       sub.steps = 4,
       vars = get_all_vars(terms(x), x$model),
       clip_to_density = 0,
       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.lm_+3A_x">x</code></td>
<td>

<p>An object inheriting from class <code>"lm"</code> obtained by fitting
a two-predictor model.
</p>
</td></tr>
<tr><td><code id="plot3d.lm_+3A_which">which</code></td>
<td>

<p>Which plot to show?  See Details below.
</p>
</td></tr>
<tr><td><code id="plot3d.lm_+3A_plane.col">plane.col</code>, <code id="plot3d.lm_+3A_plane.alpha">plane.alpha</code></td>
<td>

<p>These parameters control
the colour and transparency of a plane or surface.
</p>
</td></tr>
<tr><td><code id="plot3d.lm_+3A_sharedmouse">sharedMouse</code></td>
<td>

<p>If multiple plots are requested, should they share
mouse controls, so that they move in sync?
</p>
</td></tr>
<tr><td><code id="plot3d.lm_+3A_use_surface3d">use_surface3d</code></td>
<td>

<p>Use the <code><a href="#topic+surface3d">surface3d</a></code> function to plot the surface
rather than <code><a href="#topic+planes3d">planes3d</a></code>.  This allows curved
surfaces to be shown.  The default is <code>FALSE</code> if the model
looks like a simple 2 parameter linear fit, otherwise <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot3d.lm_+3A_do_grid">do_grid</code></td>
<td>
<p>Plot a grid.</p>
</td></tr>
<tr><td><code id="plot3d.lm_+3A_grid.col">grid.col</code>, <code id="plot3d.lm_+3A_grid.alpha">grid.alpha</code>, <code id="plot3d.lm_+3A_grid.steps">grid.steps</code></td>
<td>

<p>Characteristics of the grid.
</p>
</td></tr>
<tr><td><code id="plot3d.lm_+3A_sub.steps">sub.steps</code></td>
<td>
<p>If <code>use_surface3d</code> is <code>TRUE</code>, 
use an internal grid of <code>grid.steps*sub.steps</code> to draw
the surface.  <code>sub.steps &gt; 1</code> allows curvature within facets.
Similarly, if <code>do_grid</code> is <code>TRUE</code>, it allows 
curvature within grid lines.</p>
</td></tr>
<tr><td><code id="plot3d.lm_+3A_vars">vars</code></td>
<td>
<p>A dataframe containing the variables to plot
in the first three columns, with the response assumed to be in
column 1.  See the Note below.</p>
</td></tr>
<tr><td><code id="plot3d.lm_+3A_clip_to_density">clip_to_density</code></td>
<td>

<p>If positive, the surface, plane or grid will be clipped to a region with sufficient data.
</p>
</td></tr>
<tr><td><code id="plot3d.lm_+3A_...">...</code></td>
<td>

<p>Other parameters to pass to the default <code><a href="#topic+plot3d">plot3d</a></code> method, to control the appearance of aspects of the plot
other than the plane.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three plots are possible, depending on the value(s) in <code>which</code>:
</p>

<ol>
<li><p>(default) Show the points and the fitted plane or surface.
</p>
</li>
<li><p>Show the residuals and the plane at <code>z = 0</code>.
</p>
</li>
<li><p>Show the predicted values on the fitted plane or surface.
</p>
</li></ol>

<p>If <code>clip_to_density</code> is positive, then the
surface, plane or grid will be clipped to 
the region where a non-parametric density estimate
(using <code>MASS::<a href="MASS.html#topic+kde2d">kde2d</a></code>), normalized to have a
maximum value of 1, is greater than the given value.
This will suppress parts of the plot that aren't 
supported by the observed data.  
</p>


<h3>Value</h3>

<p>Called for the side effect of drawing one or more plots.
</p>
<p>Invisibly returns a high-level vector of object ids.  Names of
object ids have the plot number (in drawing order) appended.
</p>


<h3>Note</h3>

<p>The default value for the <code>vars</code> argument will handle
simple linear models with a response and two predictors, and
some models with functions of those two predictors.  For 
models that fail (e.g. models using <code><a href="stats.html#topic+poly">poly</a></code>), you
can include the observed values as in the third example below.
</p>
<p>If <code>clip_to_density &gt; 0</code>,
</p>

<ol>
<li><p>The clipping is
approximate, so it may not agree perfectly between
surfaces, planes and grids.
</p>
</li>
<li><p>This option requires the suggested packages
<span class="pkg">MASS</span> and <span class="pkg">interp</span>, and will be ignored with
a warning if either is not installed.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
ids &lt;- plot3d(lm(mpg ~ wt + qsec, data = mtcars), which = 1:3)
names(ids)

open3d()
plot3d(lm(mpg ~ wt + I(wt^2) + qsec, data = mtcars))

open3d()
# Specify vars in the order:  response, pred1, pred2.
plot3d(lm(mpg ~ poly(wt, 3) + qsec, data = mtcars), 
       vars = mtcars[,c("mpg", "wt", "qsec")])
       
open3d()
# Clip parts of the plot with few (wt, qsec) points
plot3d(lm(mpg ~ poly(wt, 3) + qsec, data = mtcars), 
       vars = mtcars[,c("mpg", "wt", "qsec")],
       clip_to_density = 0.1)       
</code></pre>

<hr>
<h2 id='plotmath3d'>
Draw text using base graphics math plotting
</h2><span id='topic+plotmath3d'></span>

<h3>Description</h3>

<p>To plot mathematical text, this function uses base graphics
functions to plot it to a &lsquo;<span class="file">.png</span>&rsquo; file, then uses that
file as a texture in a sprite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmath3d(x, y = NULL, z = NULL, text, cex = par("cex"),
           adj = 0.5, pos = NULL, offset = 0.5,
           fixedSize = TRUE, startsize = 480, initCex = 5, 
           margin = "", floating = FALSE, tag = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotmath3d_+3A_x">x</code>, <code id="plotmath3d_+3A_y">y</code>, <code id="plotmath3d_+3A_z">z</code></td>
<td>
<p>coordinates.  Any reasonable way of defining the
coordinates is acceptable.  See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>
for details.</p>
</td></tr>  
<tr><td><code id="plotmath3d_+3A_text">text</code></td>
<td>

<p>A character vector or expression.  See
<code><a href="grDevices.html#topic+plotmath">plotmath</a></code> for how expressions are
interpreted.
</p>
</td></tr>
<tr><td><code id="plotmath3d_+3A_cex">cex</code></td>
<td>

<p>Character size expansion.
</p>
</td></tr>
<tr><td><code id="plotmath3d_+3A_adj">adj</code></td>
<td>
<p> one value specifying the horizontal adjustment, or two, 
specifying horizontal and vertical adjustment respectively, or three, for depth as well. </p>
</td></tr>
<tr><td><code id="plotmath3d_+3A_pos">pos</code>, <code id="plotmath3d_+3A_offset">offset</code></td>
<td>
<p> alternate way to specify <code>adj</code>; see <code><a href="#topic+text3d">text3d</a></code></p>
</td></tr>
<tr><td><code id="plotmath3d_+3A_fixedsize">fixedSize</code></td>
<td>

<p>Should the resulting sprite behave like the default
ones, and resize with the scene, or like text, and
stay at a fixed size?
</p>
</td></tr>
<tr><td><code id="plotmath3d_+3A_startsize">startsize</code>, <code id="plotmath3d_+3A_initcex">initCex</code></td>
<td>

<p>These parameters are unlikely to be needed by users.
<code>startsize</code> is an over-estimate of the size (in pixels) of the 
largest expression.  Increase this if large expressions
are cut off.  <code>initCex</code> is the size of text used
to form the bitmap.  Increase this if letters look too blurry
at the desired size.
</p>
</td></tr>
<tr><td><code id="plotmath3d_+3A_margin">margin</code>, <code id="plotmath3d_+3A_floating">floating</code>, <code id="plotmath3d_+3A_tag">tag</code></td>
<td>

<p><code><a href="#topic+material3d">material3d</a></code> properties.
</p>
</td></tr>
<tr><td><code id="plotmath3d_+3A_...">...</code></td>
<td>

<p>Additional arguments to pass to  
<code><a href="graphics.html#topic+text">text</a></code> when drawing the text.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for the side effect of displaying the sprites.
The shape ID of the displayed object is returned.
</p>


<h3>Note</h3>

<p>The <code><a href="#topic+text3d">text3d</a></code> function passes calls to this
function if its <code>usePlotmath</code> argument is <code>TRUE</code>.
This is the default value if its
<code>texts</code> argument looks like an expression.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+text3d">text3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
plotmath3d(1:3, 1:3, 1:3, expression(x[1] == 1, x[2] == 2, x[3] == 3))
# This lets the text resize with the plot
text3d(4, 4, 4, "resizeable text", usePlotmath = TRUE, fixedSize = FALSE)
</code></pre>

<hr>
<h2 id='polygon3d'>
Draw a polygon in three dimensions
</h2><span id='topic+polygon3d'></span>

<h3>Description</h3>

<p>This function takes a description of a flat polygon in x, y and z coordinates,
and draws it in three dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygon3d(x, y = NULL, z = NULL, fill = TRUE, plot = TRUE, 
          coords, random = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygon3d_+3A_x">x</code>, <code id="polygon3d_+3A_y">y</code>, <code id="polygon3d_+3A_z">z</code></td>
<td>

<p>Vertices of the polygon in a form accepted by <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>.
</p>
</td></tr>
<tr><td><code id="polygon3d_+3A_fill">fill</code></td>
<td>

<p>logical; should the polygon be filled?
</p>
</td></tr>
<tr><td><code id="polygon3d_+3A_plot">plot</code></td>
<td>

<p>logical; should the polygon be displayed?
</p>
</td></tr>
<tr><td><code id="polygon3d_+3A_coords">coords</code></td>
<td>

<p>Which two coordinates (<code>x = 1</code>, <code>y = 2</code>, <code>z = 3</code>) describe the
polygon.  If missing, <code><a href="#topic+triangulate">triangulate</a></code> makes
an automatic choice.
</p>
</td></tr>
<tr><td><code id="polygon3d_+3A_random">random</code></td>
<td>

<p>Should a random triangulation be used?
</p>
</td></tr>
<tr><td><code id="polygon3d_+3A_...">...</code></td>
<td>

<p>Other parameters to pass to <code><a href="#topic+lines3d">lines3d</a></code> or <code><a href="#topic+shade3d">shade3d</a></code> if <code>plot = TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function triangulates the two dimensional polygon described by <code>coords</code>, then
applies the triangulation to all three coordinates.  No check is made that the polygon
is actually all in one plane, but the results may be somewhat unpredictable
(especially if <code>random = TRUE</code>) if it is not.
</p>
<p>Polygons need not be simple; use <code>NA</code> to indicate separate closed pieces.  For
<code>fill = FALSE</code> there are no other restrictions on the pieces, but for 
<code>fill = TRUE</code> the resulting two-dimensional polygon needs to be one that
<code><a href="#topic+triangulate">triangulate</a></code> can handle.
</p>


<h3>Value</h3>

<p>If <code>plot = TRUE</code>, the id number of the lines (for <code>fill = FALSE</code>) or triangles
(for <code>fill = TRUE</code>) that have been plotted.
</p>
<p>If <code>plot = FALSE</code>, then for <code>fill = FALSE</code>, a vector of indices into
the XYZ matrix that could be used to draw the polygon.  For <code>fill = TRUE</code>, 
a triangular mesh object representing the triangulation.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extrude3d">extrude3d</a></code> for a solid extrusion of a polygon, <code><a href="#topic+triangulate">triangulate</a></code> for
the triangulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- seq(0, 4*pi, length.out = 50)
r &lt;- theta + 1
r &lt;- c(r[-50], rev(theta*0.8) + 1)
theta &lt;- c(theta[-50], rev(theta))
x &lt;- r*cos(theta)
y &lt;- r*sin(theta)
open3d()
plot(x, y, type = "n")
polygon(x, y)
polygon3d(x, y, x + y, col = "blue")
</code></pre>

<hr>
<h2 id='primitives'>Add primitive shape</h2><span id='topic+primitives'></span><span id='topic+points3d'></span><span id='topic+lines3d'></span><span id='topic+segments3d'></span><span id='topic+triangles3d'></span><span id='topic+quads3d'></span><span id='topic+3dobjects'></span>

<h3>Description</h3>

<p>Adds a shape node to the current scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points3d(x, y = NULL, z = NULL,  ...)
lines3d(x, y = NULL, z = NULL,  ...)
segments3d(x, y = NULL, z = NULL, ...)
triangles3d(x, y = NULL, z = NULL, ...)
quads3d(x, y = NULL, z = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="primitives_+3A_x">x</code>, <code id="primitives_+3A_y">y</code>, <code id="primitives_+3A_z">z</code></td>
<td>
<p>coordinates. Any reasonable way of defining the
coordinates is acceptable.  See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>
for details.</p>
</td></tr>
<tr><td><code id="primitives_+3A_...">...</code></td>
<td>
<p>Material properties (see <code><a href="#topic+material3d">material3d</a></code>), <code>normals</code>,
<code>texcoords</code> or <code>indices</code>; see details below.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The functions <code>points3d</code>, <code>lines3d</code>, <code>segments3d</code>,
<code>triangles3d</code> and <code>quads3d</code> add points, joined lines, line segments,
filled triangles or quadrilaterals to the plots.  They correspond to the OpenGL types
<code>GL_POINTS, GL_LINE_STRIP, GL_LINES, GL_TRIANGLES</code> and <code>GL_QUADS</code> respectively.  
</p>
<p>Points are taken in pairs by <code>segments3d</code>, triplets as the vertices
of the triangles, and quadruplets for the quadrilaterals.  Colors are applied vertex by vertex; 
if different at each end of a line segment, or each vertex of a polygon, the colors
are blended over the extent of the object.  Polygons
must be non-degenerate and quadrilaterals must be entirely 
in one plane and convex, or the results are undefined.
</p>
<p>The appearance of the new objects are defined by the material properties.
See <code><a href="#topic+material3d">material3d</a></code> for details.
</p>
<p>For triangles and quads, the normals at each vertex may be specified
using <code>normals</code>.  These may be given in any way that would be
acceptable as a single argument to <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>.  
These need not match the actual normals to the polygon:
curved surfaces can be simulated by using other choices of normals.
</p>
<p>Texture coordinates may also be specified.  These may be given in
any way that would be acceptable as a single argument to 
<code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>, and are interpreted in terms
of the bitmap specified as the material texture, with <code>(0, 0)</code> 
at the lower left, <code>(1, 1)</code> at the upper right.  The texture
is used to modulate the color of the polygon.
</p>
<p>All of these functions support an argument called
<code>indices</code>, which allows vertices (and other attributes)
to be re-used, as they are in objects created by <code><a href="#topic+mesh3d">mesh3d</a></code> and related functions.  This is
intended to be used on smooth surfaces, where each shared
vertex has just one value for normals, colors and texture
coordinates.  
</p>
<p>For shapes with flat-looking faces (e.g. polyhedra like <code><a href="#topic+cube3d">cube3d</a></code>),
the vertices <b>must</b> be duplicated
to be rendered properly.
</p>


<h3>Value</h3>

<p>Each function returns the integer object ID of the shape that
was added to the scene.  These can be passed to <code><a href="#topic+pop3d">pop3d</a></code>
to remove the object from the scene.
</p>


<h3>Author(s)</h3>

<p>Ming Chen and Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Show 12 random vertices in various ways. 

M &lt;- matrix(rnorm(36), 3, 12, dimnames = list(c('x', 'y', 'z'), 
                                       rep(LETTERS[1:4], 3)))

# Force 4-tuples to be convex in planes so that quads3d works.

for (i in c(1, 5, 9)) {
    quad &lt;- as.data.frame(M[, i + 0:3])
    coeffs &lt;- runif(2, 0, 3)
    if (mean(coeffs) &lt; 1) coeffs &lt;- coeffs + 1 - mean(coeffs)
    quad$C &lt;- with(quad, coeffs[1]*(B - A) + coeffs[2]*(D - A) + A)
    M[, i + 0:3] &lt;- as.matrix(quad)
}

open3d()

# Rows of M are x, y, z coords; transpose to plot

M &lt;- t(M)
shift &lt;- matrix(c(-3, 3, 0), 12, 3, byrow = TRUE)

points3d(M)
lines3d(M + shift)
segments3d(M + 2*shift)
triangles3d(M + 3*shift, col = 'red')
quads3d(M + 4*shift, col = 'green')  
text3d(M + 5*shift, texts = 1:12)

# Add labels

shift &lt;- outer(0:5, shift[1, ])
shift[, 1] &lt;- shift[, 1] + 3
text3d(shift, 
       texts = c('points3d', 'lines3d', 'segments3d',
         'triangles3d', 'quads3d', 'text3d'),
       adj = 0)
 rgl.bringtotop()
</code></pre>

<hr>
<h2 id='propertyControl'>
Controls to use with playwidget()
</h2><span id='topic+subsetControl'></span><span id='topic+propertyControl'></span>

<h3>Description</h3>

<p>These are setter functions to produce actions in a Shiny app,
or in an animation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetControl(value = 1, subsets, subscenes = NULL,
                         fullset = Reduce(union, subsets),
                         accumulate = FALSE)
propertyControl(value = 0, entries, properties, 
                objids = tagged3d(tags), tags, values = NULL,
                param = seq_len(NROW(values)) - 1, interp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propertyControl_+3A_value">value</code></td>
<td>
<p>The value to use for input (typically <code>input$value</code>
in a Shiny app.)</p>
</td></tr>
<tr><td><code id="propertyControl_+3A_subsets">subsets</code></td>
<td>
<p>A list of vectors of object identifiers; the value will
choose among them.</p>
</td></tr>
<tr><td><code id="propertyControl_+3A_fullset">fullset</code></td>
<td>
<p>Objects in the subscene which are not in <code>fullset</code>
will not be touched.</p>
</td></tr>
<tr><td><code id="propertyControl_+3A_subscenes">subscenes</code></td>
<td>
<p>The subscenes to be controlled.  If <code>NULL</code>, the
root subscene.</p>
</td></tr>
<tr><td><code id="propertyControl_+3A_accumulate">accumulate</code></td>
<td>
<p>If <code>TRUE</code>, the subsets will accumulate (by union)
as the value increases.</p>
</td></tr>
<tr><td><code id="propertyControl_+3A_entries">entries</code>, <code id="propertyControl_+3A_properties">properties</code>, <code id="propertyControl_+3A_objids">objids</code></td>
<td>
<p>Which properties to set.</p>
</td></tr>
<tr><td><code id="propertyControl_+3A_tags">tags</code></td>
<td>

<p>Select objects with matching tags.  Ignored
if <code>objids</code> is specified.
</p>
</td></tr>
<tr><td><code id="propertyControl_+3A_values">values</code></td>
<td>
<p>Values to set.</p>
</td></tr>
<tr><td><code id="propertyControl_+3A_param">param</code></td>
<td>
<p>Parameter values corresponding to the rows of <code>value</code></p>
</td></tr>
<tr><td><code id="propertyControl_+3A_interp">interp</code></td>
<td>
<p>Whether to use linear interpolation between <code>param</code>
values</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>subsetControl</code> produces data for <code><a href="#topic+playwidget">playwidget</a></code> to
display subsets of the object in one or more subscenes.  This code will not
touch objects in the
subscenes if they
are not in <code>fullset</code>.  <code>fullset</code> defaults to the union of
all the object ids mentioned in <code>subsets</code>, so by default if an id is
not mentioned in one of the subsets, it will not be controlled by the slider.  If <code>value</code> is specified in R code, it will be a 1-based
index into the <code>subsets</code> list; when specified internally
in Javascript, 0-based indexing into the corresponding array
will be used.
</p>
<p><code>propertyControl</code> sets individual properties.  Here the row
of <code>values</code> is determined by the position of <code>value</code>
in <code>param</code>.
</p>


<h3>Value</h3>

<p>These functions return controller data in a list of class
<code>"rglControl"</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subsetSetter">subsetSetter</a></code> for a way to embed a pure Javascript
control, and <code><a href="#topic+playwidget">playwidget</a></code> for a way to use these
in animations (including Shiny), <code><a href="#topic+rglShared">rglShared</a></code>
for linking using the <span class="pkg">crosstalk</span> package.
</p>

<hr>
<h2 id='r3d'>Generic 3D interface</h2><span id='topic+r3d'></span>

<h3>Description</h3>

<p>Generic 3D interface for 3D rendering and computational geometry.</p>


<h3>Details</h3>

  
<p>R3d is a design for an interface for 3d rendering and computation without dependency
on a specific rendering implementation. R3d includes a collection
of 3D objects and geometry algorithms.
All r3d interface functions are named <code>*3d</code>.  They represent generic functions that delegate 
to implementation functions.
</p>
<p>The interface can be grouped into 8 categories: Scene Management, Primitive Shapes,
High-level Shapes, Geometry Objects, Visualization, Interaction, Transformation,
Subdivision.  
</p>
<p>The rendering interface gives an abstraction to the underlying rendering model. It can
be grouped into four categories:    
</p>

<dl>
<dt>Scene Management:</dt><dd><p>A 3D scene consists of shapes, lights and background environment.</p>
</dd> 
<dt>Primitive Shapes:</dt><dd><p>Generic primitive 3D graphics shapes such as points, lines, triangles, quadrangles and texts.</p>
</dd> 
<dt>High-level Shapes:</dt><dd><p>Generic high-level 3D graphics shapes such as spheres, sprites and terrain.</p>
</dd>
<dt>Interaction:</dt><dd><p>Generic interface to select points in 3D space using the pointer device.</p>
</dd>
</dl>

<p>In this package we include an implementation of r3d using the underlying <code>rgl.*</code> functions.
</p>
<p>3D computation is supported through the use of object structures that live entirely in R.
</p>

<dl>
<dt>Geometry Objects:</dt><dd><p>Geometry and mesh objects allow to define high-level geometry for computational purpose such as triangle or 
quadrangle meshes (see <code><a href="#topic+mesh3d">mesh3d</a></code>).</p>
</dd>
<dt>Transformation:</dt><dd><p>Generic interface to transform 3d objects.</p>
</dd>
<dt>Visualization:</dt><dd><p>Generic rendering of 3d objects such as dotted, wired or shaded.</p>
</dd>
<dt>Computation:</dt><dd><p>Generic subdivision of 3d objects.</p>
</dd>
</dl>

<p>At present, the main practical differences between the r3d functions
and the <code>rgl.*</code> functions are as follows. 
</p>
<p>The r3d functions call
<code><a href="#topic+open3d">open3d</a></code> if there is no device open, and the
<code>rgl.*</code> functions call <code><a href="#topic+rgl.open">rgl.open</a></code>. By default
<code><a href="#topic+open3d">open3d</a></code> sets the initial orientation of the coordinate
system in 'world coordinates', i.e. a right-handed coordinate system
in which the x-axis increases from left to right, the y-axis
increases with depth into the scene, and the z-axis increases from
bottom to top of the screen.  <code>rgl.*</code> functions, on the other
hand, use a right-handed coordinate system similar to that used in
OpenGL.  The x-axis matches that of r3d, but the y-axis increases
from bottom to top, and the z-axis decreases with depth into the
scene.  Since the user can manipulate the scene, either system can
be rotated into the other one.  
</p>
<p>The r3d functions also preserve the <code>rgl.material</code> setting across
calls (except for texture elements, in the current implementation), whereas
the deprecated <code>rgl.*</code> functions leave it as set by the last call.
</p>
<p>The example code below illustrates the two coordinate systems.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+points3d">points3d</a></code>,
<code><a href="#topic+lines3d">lines3d</a></code>,
<code><a href="#topic+segments3d">segments3d</a></code>,
<code><a href="#topic+triangles3d">triangles3d</a></code>,
<code><a href="#topic+quads3d">quads3d</a></code>,
<code><a href="#topic+text3d">text3d</a></code>,
<code><a href="#topic+spheres3d">spheres3d</a></code>,
<code><a href="#topic+sprites3d">sprites3d</a></code>,
<code><a href="#topic+terrain3d">terrain3d</a></code>,
<code><a href="#topic+select3d">select3d</a></code>,
<code><a href="#topic+dot3d">dot3d</a></code>,
<code><a href="#topic+wire3d">wire3d</a></code>,
<code><a href="#topic+shade3d">shade3d</a></code>,
<code><a href="#topic+transform3d">transform3d</a></code>,
<code><a href="#topic+rotate3d">rotate3d</a></code>,
<code><a href="#topic+subdivision3d">subdivision3d</a></code>,
<code><a href="#topic+mesh3d">mesh3d</a></code>,
<code><a href="#topic+cube3d">cube3d</a></code>,
<code><a href="#topic+rgl">rgl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
     x &lt;- c(0, 1, 0, 0)
     y &lt;- c(0, 0, 1, 0)
     z &lt;- c(0, 0, 0, 1)
     labels &lt;- c("Origin", "X", "Y", "Z")
     i &lt;- c(1, 2, 1, 3, 1, 4)

     # *3d interface
     
     open3d()
     text3d(x, y, z, labels)
     text3d(1, 1, 1, "*3d coordinates")
     segments3d(x[i], y[i], z[i])
</code></pre>

<hr>
<h2 id='readSTL'>
Read and write STL (stereolithography) format files
</h2><span id='topic+readSTL'></span><span id='topic+writeSTL'></span>

<h3>Description</h3>

<p>These functions read and write STL files.  This is a simple file format that
is commonly used in 3D printing.  It does not represent text,
only triangles.  The <code>writeSTL</code> function converts some RGL object
types to triangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSTL(con, ascii = FALSE, plot = TRUE, ...)
writeSTL(con, ascii = FALSE, 
         pointRadius = 0.005, 
         pointShape = icosahedron3d(),
         lineRadius = pointRadius,
         lineSides = 20,
         ids = tagged3d(tags),
         tags = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSTL_+3A_con">con</code></td>
<td>

<p>A connection or filename.
</p>
</td></tr>
<tr><td><code id="readSTL_+3A_ascii">ascii</code></td>
<td>

<p>Whether to use the ASCII format or the binary format.
</p>
</td></tr>
<tr><td><code id="readSTL_+3A_plot">plot</code></td>
<td>

<p>On reading, should the object be plotted?
</p>
</td></tr>
<tr><td><code id="readSTL_+3A_...">...</code></td>
<td>

<p>If plotting, other parameters to pass to <code><a href="#topic+triangles3d">triangles3d</a></code>
</p>
</td></tr>
<tr><td><code id="readSTL_+3A_pointradius">pointRadius</code>, <code id="readSTL_+3A_lineradius">lineRadius</code></td>
<td>

<p>The radius of points and lines relative to the overall scale of the figure.
</p>
</td></tr>
<tr><td><code id="readSTL_+3A_pointshape">pointShape</code></td>
<td>

<p>A mesh shape to use for points.  It is scaled by the <code>pointRadius</code>.
</p>
</td></tr>
<tr><td><code id="readSTL_+3A_linesides">lineSides</code></td>
<td>

<p>Lines are rendered as cylinders with this many sides.
</p>
</td></tr>
<tr><td><code id="readSTL_+3A_ids">ids</code></td>
<td>

<p>The identifiers (from <code><a href="#topic+ids3d">ids3d</a></code>) of the
objects to write.  If <code>NULL</code>, try to write everything.
</p>
</td></tr>
<tr><td><code id="readSTL_+3A_tags">tags</code></td>
<td>

<p>Alternate way to specify <code>ids</code>.  Ignored if <code>ids</code> is
given. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current implementation is limited.  For reading, it ignores normals
and color information.  For writing, it only outputs triangles, quads, planes, spheres,
points, line segments, line strips and surfaces, and does not write color information.
Lines and points are rendered in an isometric scale:  if your data scales vary, they
will look strange.
</p>
<p>Since the STL format only allows one object per file, all RGL objects
are combined into a single object when output.
</p>
<p>The output file is readable by Blender and Meshlab; the latter can write in
a number of other formats, including U3D, suitable for import into a PDF document.
</p>


<h3>Value</h3>

<p><code>readSTL</code> invisibly returns the object id if <code>plot = TRUE</code>, or (visibly) 
a matrix of vertices of the triangles if not.
</p>
<p><code>writeSTL</code> invisibly returns the name of the connection to which the 
data was written.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>The file format was found on Wikipedia on October 25, 2012.  I learned
about the STL file format from David Smith's blog reporting on 
Ian Walker's <code>r2stl</code> function.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scene3d">scene3d</a></code> saves a copy of a scene to an R variable;
<code><a href="#topic+rglwidget">rglwidget</a></code>, <code><a href="#topic+writeASY">writeASY</a></code>, <code><a href="#topic+writePLY">writePLY</a></code>, <code><a href="#topic+writeOBJ">writeOBJ</a></code> and <code><a href="#topic+writeSTL">writeSTL</a></code>
write the scene to a file in various other formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename &lt;- tempfile(fileext = ".stl")
open3d()
shade3d( icosahedron3d(col = "magenta") )
writeSTL(filename)
open3d()
readSTL(filename, col = "red")
</code></pre>

<hr>
<h2 id='rgl-defunct'>
Defunct functions in <span class="pkg">rgl</span>
</h2><span id='topic+rgl-defunct'></span><span id='topic+subsetSlider'></span><span id='topic+subsetSetter'></span><span id='topic+clipplaneSlider'></span><span id='topic+toggleButton'></span><span id='topic+propertySlider'></span><span id='topic+propertySetter'></span><span id='topic+par3dinterpSetter'></span><span id='topic+matrixSetter'></span><span id='topic+vertexSetter'></span>

<h3>Description</h3>

<p>These functions have been removed from <span class="pkg">rgl</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Removed in version 1.0.0:

subsetSlider(subsets, labels = names(subsets), 
             fullset = Reduce(union, subsets),
             subscenes = currentSubscene3d(), prefixes = "",
             accumulate = FALSE, ...)
             
subsetSetter(subsets, subscenes = currentSubscene3d(), prefixes = "", 
			 fullset = Reduce(union, subsets),
                         accumulate = FALSE)
             
clipplaneSlider(a=NULL, b=NULL, c=NULL, d=NULL, 
                plane = 1, clipplaneids, prefixes = "", 
                labels = signif(values[,1],3), ...)
             
toggleButton(subset, subscenes = currentSubscene3d(), prefixes = "", 
             label = deparse(substitute(subset)), 
             id = paste0(basename(tempfile("input"))), name = id) 
propertySlider(setter = propertySetter,
             minS = NULL, maxS = NULL, step = 1, init = NULL, 
	     labels, 
	     id = basename(tempfile("input")), name = id,
	     outputid = paste0(id, "text"),
	     index = NULL,
	     ...) 
	     
propertySetter(values = NULL, entries, properties, objids, prefixes = "",
               param = seq_len(NROW(values)), interp = TRUE, digits = 7) 
               
par3dinterpSetter(fn, from, to, steps, subscene, omitConstant = TRUE, 
                  rename = character(), ...)

matrixSetter(fns, from, to, steps, subscene = currentSubscene3d(), 
             matrix = "userMatrix", omitConstant = TRUE, prefix = "", ...) 
             
vertexSetter(values, vertices = 1, attributes, objid, prefix = "",
	     param = seq_len(NROW(values)), interp = TRUE,
	     digits = 7)             
</code></pre>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Defunct">Defunct</a></code>
</p>

<hr>
<h2 id='rgl-deprecated'>
Deprecated functions in <span class="pkg">rgl</span>
</h2><span id='topic+rgl-deprecated'></span><span id='topic+rgl.antialias'></span><span id='topic+rgl.bbox'></span><span id='topic+rgl.primitive'></span><span id='topic+rgl.points'></span><span id='topic+rgl.light'></span><span id='topic+rgl.lines'></span><span id='topic+rgl.linestrips'></span><span id='topic+rgl.material'></span><span id='topic+rgl.primitive'></span><span id='topic+rgl.select3d'></span><span id='topic+rgl.triangles'></span><span id='topic+rgl.quads'></span><span id='topic+rgl.viewpoint'></span><span id='topic+rgl.open'></span><span id='topic+rgl.close'></span><span id='topic+rgl.set'></span><span id='topic+rgl.setAxisCallback'></span><span id='topic+writeWebGL'></span><span id='topic+rgl.bg'></span><span id='topic+rgl.surface'></span><span id='topic+rgl.clear'></span><span id='topic+rgl.texts'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of
<span class="pkg">rgl</span> only, and may be defunct as soon as the next release.  See the comments for the replacements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.bbox(xat = NULL, xlab = NULL, xunit = 0, xlen = 5, 
         yat = NULL, ylab = NULL, yunit = 0, ylen = 5, 
         zat = NULL, zlab = NULL, zunit = 0, zlen = 5, 
         marklen = 15, marklen.rel = TRUE, 
         expand = 1, draw_front = FALSE, ...)  # bbox3d
rgl.bg( sphere = FALSE, fogtype = "none", color = c("black", "white"), 
	back = "lines", fogScale = 1, ...)           # bg3d
rgl.clear( type = "shapes", subscene = 0 )     # clear3d

rgl.close()                                    # close3d
rgl.light( theta = 0, phi = 0, viewpoint.rel = TRUE, 
           ambient = "#FFFFFF", diffuse = "#FFFFFF", specular = "#FFFFFF", 
           x = NULL, y = NULL, z = NULL)       # light3d
rgl.lines(x, y = NULL, z = NULL, ... )         # segments3d
rgl.linestrips(x, y = NULL, z = NULL, ...)     # lines3d
rgl.open(useNULL = rgl.useNULL())              # open3d

rgl.points(x, y = NULL, z = NULL, ... )        # points3d
rgl.primitive(...)                             
rgl.quads(x, y = NULL, z = NULL, 
          normals = NULL, 
          texcoords = NULL, ... )              # quads3d
rgl.select3d(button = c("left", "middle", "right"),
            dev = cur3d(), 
            subscene = currentSubscene3d(dev)) # select3d
rgl.set(which, silent = FALSE)                 # set3d
rgl.setAxisCallback(axis, draw = NULL, 
            dev = cur3d(), 
            subscene = currentSubscene3d(dev)) # setAxisCallback
rgl.surface(x, z, y, coords = 1:3, ..., 
            normal_x = NULL, normal_y = NULL, normal_z = NULL,
            texture_s = NULL, texture_t = NULL) # surface3d
rgl.texts(x, y = NULL, z = NULL, text, 
          adj = 0.5, pos = NULL, offset = 0.5, 
          family = par3d("family"), 
          font = par3d("font"), 
          cex = par3d("cex"), 
          useFreeType = par3d("useFreeType"), 
          ...)                                  # text3d
rgl.triangles(x, y = NULL, z = NULL, 
              normals = NULL, texcoords = NULL, 
              ... )                             # triangles3d
rgl.viewpoint( theta = 0, phi = 15, 
               fov = 60, zoom = 1, 
               scale = par3d("scale"), 
               interactive = TRUE, 
               userMatrix, 
               type = c("userviewpoint",
                        "modelviewpoint") )     # view3d
writeWebGL(dir = "webGL", 
           filename = file.path(dir, "index.html"), 
           template = system.file(file.path("WebGL", "template.html"), package = "rgl"),
           prefix = "",
           snapshot = TRUE, 
           commonParts = TRUE, 
           reuse = NULL, 
           font = "Arial", 
           width, height)                       # rglwidget
</code></pre>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Deprecated">Deprecated</a>, <a href="#topic+bbox3d">bbox3d</a>, <a href="#topic+bg3d">bg3d</a>,
  <a href="#topic+clear3d">clear3d</a>, <a href="#topic+close3d">close3d</a>, <a href="#topic+light3d">light3d</a>, 
  <a href="#topic+lines3d">lines3d</a>, <a href="#topic+open3d">open3d</a>, <a href="#topic+points3d">points3d</a>, 
  <a href="#topic+quads3d">quads3d</a>, <a href="#topic+rglwidget">rglwidget</a>, <a href="#topic+segments3d">segments3d</a>,
  <a href="#topic+select3d">select3d</a>, <a href="#topic+set3d">set3d</a>, <a href="#topic+surface3d">surface3d</a>,
  <a href="#topic+text3d">text3d</a>, <a href="#topic+triangles3d">triangles3d</a>, <a href="#topic+view3d">view3d</a></code>
</p>

<hr>
<h2 id='rgl-duplicated'>
Duplicated functions in <span class="pkg">rgl</span>
</h2><span id='topic+rgl.pop'></span><span id='topic+rgl.cur'></span><span id='topic+rgl.ids'></span><span id='topic+terrain3d'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of
<span class="pkg">rgl</span>.  See the functions in the comments for the 
full documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.cur()                             # cur3d      
rgl.ids(type = "shapes", 
        subscene = NA, tags = FALSE)  # ids3d 
rgl.pop(type = "shapes", 
        id = 0, tag = NULL)           # pop3d
terrain3d(x, y = NULL, z = NULL, ...,
          normal_x = NULL, normal_y = NULL, normal_z = NULL,
          texture_s = NULL, texture_t=NULL,
          flip = FALSE)               # surface3d
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+cur3d">cur3d</a></code>, <code><a href="#topic+ids3d">ids3d</a></code>, <code><a href="#topic+pop3d">pop3d</a></code>, <code><a href="#topic+surface3d">surface3d</a></code></p>

<hr>
<h2 id='rgl-internal'>Internal RGL functions and data</h2><span id='topic+rgl.bool'></span><span id='topic+rgl.numeric'></span><span id='topic+rgl.vertex'></span><span id='topic+rgl.nvertex'></span><span id='topic+rgl.color'></span><span id='topic+rgl.mcolor'></span><span id='topic+rgl.clamp'></span><span id='topic+rgl.attr'></span><span id='topic+rgl.enum'></span><span id='topic+rgl.enum.gl2ps'></span><span id='topic+rgl.enum.nodetype'></span><span id='topic+rgl.enum.pixfmt'></span><span id='topic+rgl.enum.polymode'></span><span id='topic+rgl.enum.textype'></span><span id='topic+rgl.enum.fogtype'></span><span id='topic+rgl.enum.primtype'></span><span id='topic+rgl.enum.texmagfilter'></span><span id='topic+rgl.enum.texminfilter'></span><span id='topic+rgl.selectstate'></span><span id='topic+rgl.setselectstate'></span><span id='topic+edgemap'></span><span id='topic+edgeindex'></span><span id='topic+cube3d.ib'></span><span id='topic+cube3d.vb'></span><span id='topic+oh3d.ib'></span><span id='topic+oh3d.vb'></span><span id='topic+dev3d'></span>

<h3>Description</h3>

<p>Internal RGL functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.bool(x)
rgl.numeric(x)
rgl.vertex(x, y = NULL, z = NULL)
rgl.nvertex(vertex)
rgl.color(color)
rgl.mcolor(colors)
rgl.clamp(value, low, high)
rgl.attr(vattr, nvertex) 
rgl.enum(name, ..., multi = FALSE)
rgl.enum.gl2ps(postscripttype) 
rgl.enum.nodetype(type)
rgl.enum.pixfmt(fmt)
rgl.enum.polymode(mode)
rgl.enum.textype(textype)
rgl.enum.fogtype(fogtype)
rgl.enum.primtype(primtype)
rgl.enum.texmagfilter(magfiltertype)
rgl.enum.texminfilter(minfiltertype)
rgl.selectstate(dev, subscene)
rgl.setselectstate(state, dev, subscene)
edgemap(size)
edgeindex(from, to, size, row, col)
</code></pre>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='rgl.attrib'>
Get information about shapes
</h2><span id='topic+rgl.attrib'></span>

<h3>Description</h3>

<p>Retrieves information about the shapes in a scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.attrib(id, attrib, first = 1, 
	last = rgl.attrib.count(id, attrib))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.attrib_+3A_id">id</code></td>
<td>

<p>A shape identifier, as returned by <code><a href="#topic+ids3d">ids3d</a></code>.
</p>
</td></tr>
<tr><td><code id="rgl.attrib_+3A_attrib">attrib</code></td>
<td>

<p>An attribute of a shape.  Currently supported: one of <br />
<code>"vertices"</code>, <code>"normals"</code>, <code>"colors"</code>, <code>"texcoords"</code>, 
<code>"dim"</code>, <code>"texts"</code>, <code>"cex"</code>, <code>"adj"</code>, <code>"radii"</code>, 
<code>"centers"</code>, <code>"ids"</code>, <code>"usermatrix"</code>, <code>"types"</code>,
<code>"flags"</code>, <code>"offsets"</code>, <code>"family"</code>, <code>"font"</code>,
<code>"pos"</code><br />
or unique prefixes
to one of those. 
</p>
</td></tr>
<tr><td><code id="rgl.attrib_+3A_first">first</code>, <code id="rgl.attrib_+3A_last">last</code></td>
<td>

<p>Specify these to retrieve only those rows of the result.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the identifier is not found or is not a shape that has the given attribute, 
zero will be returned by <code>rgl.attrib.count</code>, and an empty matrix
will be returned by <code>rgl.attrib</code>.
</p>
<p>The first four <code>attrib</code> names correspond to the usual OpenGL
properties; <code>"dim"</code> is used just for surfaces, defining the rows
and columns in the rectangular grid; <code>"cex"</code>, <code>"adj"</code>,
<code>"family"</code>, <code>"font"</code> and <code>"pos"</code> apply only to text objects.
</p>


<h3>Value</h3>

<p><code>rgl.attrib</code>
returns the values of the attribute.  Attributes
are mostly real-valued, with the following sizes:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"vertices"</code>	</td><td style="text-align: left;"> 3 values 	</td><td style="text-align: left;"> x, y, z </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"normals"</code>	</td><td style="text-align: left;"> 3 values 	</td><td style="text-align: left;"> x, y, z </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"centers"</code>	</td><td style="text-align: left;"> 3 values 	</td><td style="text-align: left;"> x, y, z </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"colors"</code>	</td><td style="text-align: left;"> 4 values 	</td><td style="text-align: left;"> r, g, b, a </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"texcoords"</code>	</td><td style="text-align: left;"> 2 values 	</td><td style="text-align: left;"> s, t </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"dim"</code>	</td><td style="text-align: left;"> 2 values 	</td><td style="text-align: left;"> r, c </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"cex"</code>	</td><td style="text-align: left;"> 1 value 	</td><td style="text-align: left;"> cex </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"adj"</code>	</td><td style="text-align: left;"> 2 values 	</td><td style="text-align: left;"> x, y </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"radii"</code>	</td><td style="text-align: left;"> 1 value 	</td><td style="text-align: left;"> r </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"ids"</code>	</td><td style="text-align: left;"> 1 value	</td><td style="text-align: left;"> id </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"usermatrix"</code>	</td><td style="text-align: left;"> 4 values 	</td><td style="text-align: left;"> x, y, z, w </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"texts"</code>	</td><td style="text-align: left;"> 1 value	</td><td style="text-align: left;"> text </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"types"</code>	</td><td style="text-align: left;"> 1 value	</td><td style="text-align: left;"> type </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"flags"</code>	</td><td style="text-align: left;"> 1 value	</td><td style="text-align: left;"> flag </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"family"</code> </td><td style="text-align: left;"> 1 value    </td><td style="text-align: left;"> family </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"font"</code>   </td><td style="text-align: left;"> 1 value    </td><td style="text-align: left;"> font </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"pos"</code>    </td><td style="text-align: left;"> 1 value </td><td style="text-align: left;"> pos </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <code>"texts"</code>, <code>"types"</code> and <code>"family"</code>
attributes are character-valued; the <code>"flags"</code>
attribute is logical valued, with named rows.
</p>
<p>These are returned as matrices with the row count equal to the count for the attribute,
and the columns as listed above.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ids3d">ids3d</a></code>, <code><a href="#topic+rgl.attrib.info">rgl.attrib.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- plot3d(rnorm(100), rnorm(100), rnorm(100), type = "s", col = "red")
rgl.attrib(p["data"], "vertices", last = 10)
</code></pre>

<hr>
<h2 id='rgl.attrib.info'>
Get information about attributes of objects
</h2><span id='topic+rgl.attrib.info'></span><span id='topic+rgl.attrib.count'></span>

<h3>Description</h3>

<p>These functions give information about the attributes of
RGL objects.  <code>rgl.attrib.info</code> is the more 
&ldquo;user-friendly&rdquo; function; <code>rgl.attrib.count</code> is a 
lower-level function more likely to be used in programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.attrib.info(id = ids3d("all", 0)$id, attribs = NULL, showAll = FALSE)
rgl.attrib.count(id, attrib)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.attrib.info_+3A_id">id</code></td>
<td>

<p>One or more RGL object ids.
</p>
</td></tr>
<tr><td><code id="rgl.attrib.info_+3A_attribs">attribs</code></td>
<td>

<p>A character vector of one or more attribute names.
</p>
</td></tr>
<tr><td><code id="rgl.attrib.info_+3A_showall">showAll</code></td>
<td>

<p>Should attributes with zero entries be shown?
</p>
</td></tr>
<tr><td><code id="rgl.attrib.info_+3A_attrib">attrib</code></td>
<td>

<p>A single attribute name.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the first example below to get the full list of attribute
names.
</p>


<h3>Value</h3>

<p>A dataframe containing the following columns:
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>The id of the object.</p>
</td></tr>
<tr><td><code>attrib</code></td>
<td>
<p>The full name of the attribute.</p>
</td></tr>
<tr><td><code>nrow</code>, <code>ncol</code></td>
<td>
<p>The size of matrix that would be returned
by <code><a href="#topic+rgl.attrib">rgl.attrib</a></code> for this attribute.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rgl.attrib">rgl.attrib</a></code> to obtain the attribute values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
id &lt;- points3d(rnorm(100), rnorm(100), rnorm(100), col = "green")
rgl.attrib.info(id, showAll = TRUE)
rgl.attrib.count(id, "vertices")

merge(rgl.attrib.info(), ids3d("all"))
</code></pre>

<hr>
<h2 id='rgl.bringtotop'>Assign focus to an RGL window </h2><span id='topic+rgl.bringtotop'></span>

<h3>Description</h3>

<p>'rgl.bringtotop' brings the current RGL window to the
front of the window stack (and gives it focus).</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.bringtotop(stay = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.bringtotop_+3A_stay">stay</code></td>
<td>
<p>whether to make the window stay on top.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>stay</code> is <code>TRUE</code>, then the window will stay on top
of normal windows.
</p>


<h3>Note</h3>

<p>not completely implemented for X11 graphics (stay not implemented;
window managers such as KDE may block this action
(set &quot;Focus stealing prevention level&quot; to None in Control Center/Window Behavior/Advanced)).
Not currently implemented under OS/X.</p>


<h3>Author(s)</h3>

<p> Ming Chen/Duncan Murdoch </p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
points3d(rnorm(1000), rnorm(1000), rnorm(1000), color = heat.colors(1000))
rgl.bringtotop(stay = TRUE)    
</code></pre>

<hr>
<h2 id='rgl.fns'>
Low level functions that should not be called by users.
</h2><span id='topic+rgl.abclines'></span><span id='topic+rgl.planes'></span><span id='topic+rgl.clipplanes'></span><span id='topic+rgl.sprites'></span><span id='topic+rgl.spheres'></span>

<h3>Description</h3>

<p>These functions provide the implementation for various
<code>*3d</code> functions designed for users to call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.abclines(x, y = NULL, z = NULL, a, b = NULL, c = NULL, ...)
rgl.planes(a, b = NULL, c = NULL, d = 0, ...)
rgl.clipplanes(a, b = NULL, c = NULL, d = 0)
rgl.sprites(x, y = NULL, z = NULL, radius = 1, 
            shapes = NULL, userMatrix, fixedSize = FALSE,
            adj = 0.5, pos = NULL, offset = 0.25, 
            rotating = FALSE, ...)
rgl.spheres(x, y = NULL, z = NULL, radius, fastTransparency = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.fns_+3A_x">x</code>, <code id="rgl.fns_+3A_y">y</code>, <code id="rgl.fns_+3A_z">z</code></td>
<td>

<p>Coordinates of points
</p>
</td></tr> 
<tr><td><code id="rgl.fns_+3A_a">a</code>, <code id="rgl.fns_+3A_b">b</code>, <code id="rgl.fns_+3A_c">c</code></td>
<td>

<p>Coordinates of the direction vectors for the lines,
or normals for the planes.
</p>
</td></tr>
<tr><td><code id="rgl.fns_+3A_d">d</code></td>
<td>
<p>Plane offset.</p>
</td></tr>
<tr><td><code id="rgl.fns_+3A_radius">radius</code></td>
<td>
<p>Size of sprites or spheres.</p>
</td></tr>
<tr><td><code id="rgl.fns_+3A_fixedsize">fixedSize</code>, <code id="rgl.fns_+3A_rotating">rotating</code></td>
<td>
<p>Fixed size, changing orientation.</p>
</td></tr>
<tr><td><code id="rgl.fns_+3A_fasttransparency">fastTransparency</code></td>
<td>
<p>Sphere drawing strategy.</p>
</td></tr>
<tr><td><code id="rgl.fns_+3A_adj">adj</code>, <code id="rgl.fns_+3A_pos">pos</code>, <code id="rgl.fns_+3A_offset">offset</code></td>
<td>
<p>Positioning.</p>
</td></tr>
<tr><td><code id="rgl.fns_+3A_...">...</code></td>
<td>

<p>Material properties.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the corresponding <code>*3d</code> function: <code><a href="#topic+abclines3d">abclines3d</a></code>, <code><a href="#topic+planes3d">planes3d</a></code>, <code><a href="#topic+clipplanes3d">clipplanes3d</a></code>, <code><a href="#topic+sprites3d">sprites3d</a></code>, <code><a href="#topic+spheres3d">spheres3d</a></code>.
</p>

<hr>
<h2 id='rgl.getAxisCallback'>
Get user-defined axis labelling callbacks.
</h2><span id='topic+rgl.getAxisCallback'></span>

<h3>Description</h3>

<p>This function gets a user-defined axis labelling callback in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.getAxisCallback(axis, dev = cur3d(), subscene = currentSubscene3d(dev))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.getAxisCallback_+3A_axis">axis</code></td>
<td>

<p>Which axis? Can be value from <code>1:3</code>.
</p>
</td></tr>
<tr><td><code id="rgl.getAxisCallback_+3A_dev">dev</code>, <code id="rgl.getAxisCallback_+3A_subscene">subscene</code></td>
<td>

<p>The RGL device and subscene to work with.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The callback function.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setAxisCallbacks">setAxisCallbacks</a></code> to
work with <code><a href="#topic+rglwidget">rglwidget</a></code>.
</p>

<hr>
<h2 id='rgl.init'>Initializing RGL</h2><span id='topic+rgl.init'></span>

<h3>Description</h3>

<p>Initializing the RGL system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.init(initValue = 0, onlyNULL = FALSE, 
         debug = getOption("rgl.debug", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.init_+3A_initvalue">initValue</code></td>
<td>
<p>value for internal use only</p>
</td></tr>
<tr><td><code id="rgl.init_+3A_onlynull">onlyNULL</code></td>
<td>
<p>only initialize the null (no display) device</p>
</td></tr>
<tr><td><code id="rgl.init_+3A_debug">debug</code></td>
<td>
<p>enable some debugging messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>useNULL</code> is <code>TRUE</code>, RGL will use a &ldquo;null&rdquo;
device.  This device records objects as they are plotted, but 
displays nothing. It is intended for use with <code><a href="#topic+rglwidget">rglwidget</a></code>
and similar functions.
</p>
<p>Currently <code>debug</code> only controls messages printed by the OpenGL
library during initialization.  In future <code>debug = TRUE</code> may
become more verbose.
</p>
<p>For display within an OpenGL window in R, RGL requires the OpenGL
system to be installed and available.  If there is a problem 
initializing it, you may see the message
<code style="white-space: pre;">&#8288;'rgl.init' failed, running with 'rgl.useNULL = TRUE'.&#8288;</code>  There
are several causes and remedies:
</p>

<ul>
<li><p>On any system, the OpenGL libraries need to be present for RGL to be able to start an OpenGL device.
</p>

<ul>
<li><p>On macOS, you need to install XQuartz.  It is available from
<a href="https://www.xquartz.org">https://www.xquartz.org</a>.
</p>
</li>
<li><p>On Linux, you need to install Mesa 3D.  One of these commands
may work, depending on your system:
<code style="white-space: pre;">&#8288;
  zypper source-install --build-deps-only Mesa # openSUSE/SLED/SLES
  yum-builddep mesa      # yum Fedora, OpenSuse(?)
  dnf builddep mesa      # dnf Fedora
  apt-get build-dep mesa # Debian, Ubuntu and related
  &#8288;</code>

</p>
</li>
<li><p>Windows should have OpenGL installed by default.
</p>
</li></ul>

</li>
<li><p>On Unix-alike systems (macOS and Linux, for example), RGL
normally
uses the GLX system for creating displays.  If the graphic is created
on a remote machine, it may need to use &ldquo;Indirect GLX&rdquo; (IGLX).  Due
to security concerns, this is often disabled by default.  See
<a href="https://www.x.org/wiki/Development/Security/Advisory-2014-12-09/">https://www.x.org/wiki/Development/Security/Advisory-2014-12-09/</a>
for a discussion of the security issues, and 
<a href="https://unix.stackexchange.com/q/317954">https://unix.stackexchange.com/q/317954</a>
for ways to re-enable IGLX.
</p>
</li>
<li><p>The <a href="https://www.virtualgl.org">https://www.virtualgl.org</a> project is intended to 
be a way to avoid IGLX, by rendering remotely and sending bitmaps
to the local machine.  It's not a simple install...
</p>
</li>
<li><p>If you don't need to see RGL displays on screen, you
can use the &ldquo;NULL device&rdquo;.  See <code><a href="#topic+rgl.useNULL">rgl.useNULL</a></code>.
</p>
</li>
<li><p>If you can't build the <span class="pkg">rgl</span> package with OpenGL
support, you can
disable it and use the NULL device.  (This may happen automatically
during configuration, but you'll get a tested result if you
specify it explicitly.)  See the instructions in the
&lsquo;<span class="file">README</span>&rsquo; file in the source tarball.
</p>
</li></ul>



<h3>Value</h3>

<p>Normally the user doesn't call <code>rgl.init</code> at all:  it
is called when the package is loaded.  It returns no
useful value.
</p>

<hr>
<h2 id='rgl.pixels'> Extract pixel information from window </h2><span id='topic+rgl.pixels'></span>

<h3>Description</h3>

<p>This function extracts single components of the pixel information from the 
topmost window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.pixels(component = c("red", "green", "blue"), 
        viewport = par3d("viewport"), top = TRUE)
</code></pre>


<h3>Arguments</h3>

  
<table>
<tr><td><code id="rgl.pixels_+3A_component">component</code></td>
<td>
<p> Which component(s)? </p>
</td></tr>
<tr><td><code id="rgl.pixels_+3A_viewport">viewport</code></td>
<td>
<p> Lower left corner and size of desired region. </p>
</td></tr>
<tr><td><code id="rgl.pixels_+3A_top">top</code></td>
<td>
<p> Whether to bring window to top before reading. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The possible components are <code>"red"</code>, <code>"green"</code>, <code>"blue"</code>, 
<code>"alpha"</code>, <code>"depth"</code>, and <code>"luminance"</code> (the sum of the three
colors).  All are scaled from 0 to 1.
</p>
<p>Note that the luminance is kept below 1 by truncating the sum; this is the 
definition used for the <code>GL_LUMINANCE</code> component in OpenGL.
</p>


<h3>Value</h3>

<p>A vector, matrix or array containing the desired components.  If one component
is requested, a vector or matrix will be returned depending on the size of
block requested (length 1 dimensions are dropped); if more, an array, whose last dimension
is the list of components.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

 <p><code><a href="#topic+rgl.snapshot">rgl.snapshot</a></code> to write a copy to a file,
<code>demo("stereo")</code> for functions that make use of this to draw
a random dot stereogram and an anaglyph. </p>


<h3>Examples</h3>

<pre><code class='language-R'>example(surface3d)
depth &lt;- rgl.pixels(component = "depth")
if (length(depth) &amp;&amp; is.matrix(depth)) # Protect against empty or single pixel windows
    contour(depth)
</code></pre>

<hr>
<h2 id='rgl.postscript'>Export vector graphics</h2><span id='topic+rgl.postscript'></span>

<h3>Description</h3>

<p>Saves the screenshot to a file in PostScript or other vector graphics format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.postscript( filename, fmt = "eps", drawText = TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.postscript_+3A_filename">filename</code></td>
<td>
<p>full path to filename.</p>
</td></tr>
<tr><td><code id="rgl.postscript_+3A_fmt">fmt</code></td>
<td>
<p>export format, currently supported: ps, eps, tex, pdf, svg, pgf </p>
</td></tr>
<tr><td><code id="rgl.postscript_+3A_drawtext">drawText</code></td>
<td>
<p>logical, whether to draw text</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Animations can be created in a loop modifying the scene and saving 
a screenshot to a file. (See example below)
</p>
<p>This function is a wrapper for the GL2PS library by Christophe Geuzaine,
and has the same limitations as that library:  not all OpenGL features
are supported, and some are only supported in some formats.
See the reference for full details.
</p>


<h3>Author(s)</h3>

<p> Christophe Geuzaine / Albrecht Gebhardt </p>


<h3>References</h3>

<p>GL2PS: an OpenGL to PostScript printing library by Christophe Geuzaine,
<a href="https://www.geuz.org/gl2ps/">https://www.geuz.org/gl2ps/</a>, version 1.4.2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+view3d">view3d</a></code>, <code><a href="#topic+snapshot3d">snapshot3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create new files in tempdir
savedir &lt;- setwd(tempdir())

x &lt;- y &lt;- seq(-10, 10, length.out = 20)
z &lt;- outer(x, y, function(x, y) x^2 + y^2)
persp3d(x, y, z, col = 'lightblue')

title3d("Using LaTeX text", col = 'red', line = 3)
rgl.postscript("persp3da.ps", "ps", drawText = FALSE)
rgl.postscript("persp3da.pdf", "pdf", drawText = FALSE)
rgl.postscript("persp3da.tex", "tex")
pop3d()
title3d("Using ps/pdf text", col = 'red', line = 3)
rgl.postscript("persp3db.ps", "ps")
rgl.postscript("persp3db.pdf", "pdf")
rgl.postscript("persp3db.tex", "tex", drawText = FALSE)

setwd(savedir)

## Not run: 

#
# create a series of frames for an animation
#

open3d()
shade3d(oh3d(), color = "red")
view3d(0, 20)

for (i in 1:45) {
  view3d(i, 20)
  filename &lt;- paste("pic", formatC(i, digits = 1, flag = "0"), ".eps", sep = "") 
  rgl.postscript(filename, fmt = "eps")
}


## End(Not run)

</code></pre>

<hr>
<h2 id='rgl.select'>
Switch to select mode, and return the mouse position selected
</h2><span id='topic+rgl.select'></span>

<h3>Description</h3>

<p>Mostly for internal use, this function temporarily
installs a handler on a button of the mouse that will 
return the mouse coordinates of one click and drag rectangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.select(button = c("left", "middle", "right"),
           dev = cur3d(), subscene = currentSubscene3d(dev))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.select_+3A_button">button</code></td>
<td>

<p>Which button to use?
</p>
</td></tr>
<tr><td><code id="rgl.select_+3A_dev">dev</code>, <code id="rgl.select_+3A_subscene">subscene</code></td>
<td>

<p>The RGL device and subscene to work with  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of four coordinates:  the X and Y coordinates of the start and end of the
dragged rectangle.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select3d">select3d</a></code>, a version that allows the selection region to be used to
select points in the scene.
</p>

<hr>
<h2 id='rgl.Sweave'>
Integrating RGL with Sweave
</h2><span id='topic+rgl.Sweave'></span><span id='topic+rgl.Sweave.off'></span><span id='topic+Sweave.snapshot'></span>

<h3>Description</h3>

<p>As of <span class="rlang"><b>R</b></span> 2.13.0, it is possible to include RGL graphics into
a <a href="utils.html#topic+Sweave">Sweave</a> document.  These functions support that
integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sweave.snapshot()
rgl.Sweave(name, width, height, options, ...)
rgl.Sweave.off()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.Sweave_+3A_name">name</code>, <code id="rgl.Sweave_+3A_width">width</code>, <code id="rgl.Sweave_+3A_height">height</code>, <code id="rgl.Sweave_+3A_options">options</code>, <code id="rgl.Sweave_+3A_...">...</code></td>
<td>

<p>These arguments are passed by <code><a href="utils.html#topic+Sweave">Sweave</a></code> to <code>rgl.Sweave</code>
when it opens the device.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rgl.Sweave</code> function is not normally called by the user.  The user
specifies it as the graphics driver when opening the code chunk, e.g. by
using
</p>
<pre>&lt;&lt;fig = TRUE, pdf = FALSE, grdevice = rgl.Sweave, resolution = 100&gt;&gt;=</pre>
<p>When the RGL device is closed at the end of the code chunk,
<code>rgl.Sweave.off()</code> will be called automatically.  It
will save a snapshot
of the last image (by default in &lsquo;<span class="file">.png</span>&rsquo; format) for inclusion in the 
Sweave document and (by default) close the device.  
Alternatively, the <code>Sweave.snapshot()</code> function
can be called to save the image before the end of the chunk.  Only one
snapshot will be taken per chunk.
</p>
<p>Several chunk options are used by the <code>rgl.Sweave</code> device:
</p>

<dl>
<dt>stayopen</dt><dd><p>(default <code>FALSE</code>).  If <code>TRUE</code> then the RGL
device will <em>not</em> be closed at the end of the chunk,
instead a call to <code>Sweave.snapshot()</code>
will be used if it has not been called explicitly.  Subsequent chunks can add
to the scene.</p>
</dd>
<dt>outputtype</dt><dd><p>(default <code>png</code>).  The output may be specified 
as <code>outputtype = pdf</code> or <code>outputtype = eps</code> instead, in which case
the <code><a href="#topic+rgl.postscript">rgl.postscript</a></code> function will be used to write output in the
specified format.  Note that  <code><a href="#topic+rgl.postscript">rgl.postscript</a></code> has limitations
and does not always render scenes correctly.</p>
</dd>
<dt>delay</dt><dd><p>(default 0.1).  After creating the display window, <code><a href="base.html#topic+Sys.sleep">Sys.sleep</a></code>
will be called to delay this many seconds, to allow the display system to 
initialize.  This is needed in X11 systems which open the display
asynchronously.  If the default time is too short, <code>rgl.Sweave</code> may
falsely report that the window is too large to open.</p>
</dd>
</dl>



<h3>Value</h3>

<p>These functions are called for their side effects.
</p>


<h3>Note</h3>

<p>We recommend turning off all other graphics drivers in a chunk that uses
<code>grdevice = rgl.Sweave</code>.  The RGL functions do not write to
a standard graphics device.
</p>


<h3>Note</h3>

<p>The <span class="pkg">rgl</span> package relies on your graphics hardware to render OpenGL scenes,
and the default &lsquo;<span class="file">.png</span>&rsquo; output copies a bitmap from the hardware device.  All 
such devices have limitations on the size of the bitmap, but they do not 
always signal these limitations in a way that RGL will detect.  If you find
that images are not being produced properly, try reducing the size using 
the <code>resolution</code>, <code>width</code> or <code>height</code> chunk options.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+RweaveLatex">RweaveLatex</a></code> for a description of alternate graphics drivers
in Sweave, and standard options that can be used in code chunks.  
</p>
<p><code><a href="#topic+hook_rgl">hook_rgl</a></code>
and <code><a href="#topic+hook_webgl">hook_webgl</a></code> allow fixed or interactive RGL
scenes to be embedded in <span class="pkg">knitr</span> 
documents.
</p>

<hr>
<h2 id='rgl.useNULL'>
Report default use of null device
</h2><span id='topic+rgl.useNULL'></span><span id='topic+RGL_USE_NULL'></span>

<h3>Description</h3>

<p>This function checks the <code>"rgl.useNULL"</code> option if present, or the
<span class="env">RGL_USE_NULL</span> environment variable if it is not.  If the value is
<code>TRUE</code> or a string which matches &ldquo;yes&rdquo; or &ldquo;true&rdquo;
in a case-insensitive test, <code>TRUE</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.useNULL()
</code></pre>


<h3>Value</h3>

<p>A logical value indicating the current default for use of the null
device.
</p>


<h3>Note</h3>

<p>This function is checked by the initialization code when the <span class="pkg">rgl</span> package
is loaded.  Thus if you want to run RGL on a system where there is no
graphics support, you should run <code>options(rgl.useNULL = TRUE)</code>
or set the environment variable <code>RGL_USE_NULL=TRUE</code> *before*
calling <code>library(rgl)</code> (or other code that 
loads <span class="pkg">rgl</span>), and it will not fail in its attempt at initialization.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+open3d">open3d</a></code> and <code><a href="#topic+rgl.open">rgl.open</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rgl.useNULL()
</code></pre>

<hr>
<h2 id='rgl.user2window'> Convert between RGL user and window coordinates </h2><span id='topic+rgl.user2window'></span><span id='topic+rgl.window2user'></span><span id='topic+rgl.projection'></span>

<h3>Description</h3>

<p>This function converts from 3-dimensional user coordinates
to 3-dimensional window coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.user2window(x, y = NULL, z = NULL, projection = rgl.projection())
rgl.window2user(x, y = NULL, z = 0, projection = rgl.projection())
rgl.projection(dev = cur3d(), subscene = currentSubscene3d(dev))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl.user2window_+3A_x">x</code>, <code id="rgl.user2window_+3A_y">y</code>, <code id="rgl.user2window_+3A_z">z</code></td>
<td>
<p>Input coordinates.  Any reasonable way of defining the
coordinates is acceptable.  See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>
for details.</p>
</td></tr>
<tr><td><code id="rgl.user2window_+3A_projection">projection</code></td>
<td>
<p>The RGL projection to use </p>
</td></tr>
<tr><td><code id="rgl.user2window_+3A_dev">dev</code>, <code id="rgl.user2window_+3A_subscene">subscene</code></td>
<td>
<p>The RGL device and subscene to work with </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions convert between user coordinates and window coordinates.
</p>
<p>Window coordinates run from 0 to 1 in X, Y, and Z.  X runs from 0 on the
left to 1 on the right; Y runs from 0 at the bottom to 1 at the top;
Z runs from 0 foremost to 1 in the background.  RGL does not currently
display vertices plotted outside of this range, but in normal circumstances will automatically resize the
display to show them.  In the example below this has been suppressed.
</p>


<h3>Value</h3>

<p>The coordinate conversion functions produce a matrix with columns corresponding 
to the X, Y, and Z coordinates.
</p>
<p><code>rgl.projection()</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>the modelview matrix</p>
</td></tr>
<tr><td><code>projection</code></td>
<td>
<p>the projection matrix</p>
</td></tr>
<tr><td><code>viewport</code></td>
<td>
<p>the viewport vector</p>
</td></tr>
</table>
<p>See <code><a href="#topic+par3d">par3d</a></code> for more details.
</p>


<h3>Author(s)</h3>

<p> Ming Chen / Duncan Murdoch</p>


<h3>See Also</h3>

<p><code><a href="#topic+select3d">select3d</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
points3d(rnorm(100), rnorm(100), rnorm(100))
if (interactive() || !.Platform$OS == "unix") {
# Calculate a square in the middle of the display and plot it
square &lt;- rgl.window2user(c(0.25, 0.25, 0.75, 0.75, 0.25), 
                          c(0.25, 0.75, 0.75, 0.25, 0.25), 0.5)
par3d(ignoreExtent = TRUE)
lines3d(square)
par3d(ignoreExtent = FALSE)
}
</code></pre>

<hr>
<h2 id='rglExtrafonts'>
Register extra fonts
</h2><span id='topic+rglExtrafonts'></span>

<h3>Description</h3>

<p>This function uses the <a href="https://github.com/wch/extrafont"><span class="pkg">extrafont</span></a> 
package to help register system fonts for use with
FreeType in <span class="pkg">rgl</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglExtrafonts(..., quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rglExtrafonts_+3A_...">...</code></td>
<td>

<p>Vectors of fonts to try.  See the Details.
</p>
</td></tr>
<tr><td><code id="rglExtrafonts_+3A_quiet">quiet</code></td>
<td>

<p>Whether to print information on progress.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <span class="pkg">extrafont</span>
package collects information on
installed fonts from the system.  When you first
install <span class="pkg">extrafont</span>, or after new fonts have been installed on your
system, run <code>extrafont::font_import()</code> to build
its database of system fonts.  
</p>
<p>Fonts can be installed in <span class="pkg">rgl</span> using
<code>rglExtrafonts(rglname = familyname)</code> or <code>rglExtrafonts(familyname)</code>.  In this call
<code>familyname</code> is a vector of family names to look
for in the <span class="pkg">extrafont</span> database using <code>extrafont::choose_font(familyname)</code>; the first one found
will be registered with <span class="pkg">rgl</span>.  The optional name <code>rglname</code> will also be usable to refer to the font family.
</p>
<p>If none of the given family names is found, no change
will be made to the registered fonts in <span class="pkg">rgl</span>.
</p>
<p>During startup, <span class="pkg">rgl</span> detects whether <span class="pkg">extrafont</span>
is installed, and if so runs 
<code style="white-space: pre;">&#8288;

rglExtrafonts(sans = c("Helvetica", "Arial"), 
              serif = c("Times", "Times New Roman"), 
              mono = c("Courier", "Courier New"))
              
&#8288;</code> 
to attempt to set up the default fonts.
</p>
<p>Fonts found by <span class="pkg">extrafont</span> can also be used in
some other graphics devices besides <span class="pkg">rgl</span>; see 
<a href="https://github.com/wch/extrafont">the <span class="pkg">extrafont</span> documentation</a>
for details.
</p>


<h3>Value</h3>

<p>Invisibly returns a vector giving the <span class="pkg">rgl</span> name
and the family name for the newly installed font.
</p>


<h3>Note</h3>

<p>Each font in a display needs a unique <span class="pkg">rgl</span> name;
if the associated font for a given name is changed,
all previously plotted text will also change.
</p>
<p>Currently <code><a href="#topic+rglwidget">rglwidget</a></code> displays will not 
respect the new definitions.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+text3d">text3d</a></code>, <code><a href="#topic+rglFonts">rglFonts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("extrafont") &amp;&amp; !in_pkgdown_example()) {
  
  open3d()
  text3d(1,1,1, "Default", family = "sans", cex = 2)  
  
  # Attempt to register new sans-serif font:
  newfamily &lt;- rglExtrafonts(newsans = c("Comic Sans MS", "Impact", 
                                         "Verdana", "Tahoma"))
  
  text3d(2,2,2, newfamily, family = "newsans", cex = 2)
  
}
</code></pre>

<hr>
<h2 id='rglFonts'>
Specify FreeType fonts
</h2><span id='topic+rglFonts'></span>

<h3>Description</h3>

<p>Specify FreeType fonts for use in <span class="pkg">rgl</span> graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglFonts(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rglFonts_+3A_...">...</code></td>
<td>
<p>Device dependent font definitions for use with FreeType.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>FreeType fonts are specified using the <code>rglFonts</code> function.  This function
takes a vector of four filenames of TrueType font files which
will be used for the four styles regular, bold, italic and bold italic.  The
vector is passed with a name to be used as the family name, e.g.
<code>rglFonts(sans = c("/path/to/FreeSans.ttf", ...))</code>.  In order to 
limit the file size, the <span class="pkg">rgl</span> package ships with just 3 font files, for 
regular versions of the <code>serif</code>, <code>sans</code> and <code>mono</code> families.  
Additional free font files were available in the past from the
Amaya project, though currently the
<code><a href="#topic+rglExtrafonts">rglExtrafonts</a></code> function provides an easier way
to register new fonts.
</p>
<p>On Windows the system fonts are acceptable and are used
when <code>useFreeType = FALSE</code> (the current default in
<code><a href="#topic+r3dDefaults">r3dDefaults</a></code>).  Mappings to <code>family</code> names
are controlled by the <code>grDevices::windowsFonts()</code>
function.
</p>
<p>Full pathnames should normally be used to specify font files.  If relative
paths are used, they are interpreted differently by platform.  Currently
Windows fonts are looked for in the Windows fonts folder, while other
platforms use the current working directory.
</p>
<p>If FreeType fonts are not used, then bitmapped fonts will be used instead.
On Windows these will be based on the fonts specified using the 
</p>
<p><code>windowsFonts</code>
function, and are resizable.
Other platforms will use the default bitmapped font which is not
resizable.  
</p>
<p>Bitmapped fonts have a limited number of characters supported; if any
unsupported characters are used, an error will be thrown.
</p>


<h3>Value</h3>

<p>the current set of font definitions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+text3d">text3d</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# These FreeType fonts are available from the Amaya project, and are not shipped
# with rgl.  You would normally install them to the rgl/fonts directory
# and use fully qualified pathnames, e.g. 
# system.file("fonts/FreeSerif.ttf", package = "rgl")

rglFonts(serif = c("FreeSerif.ttf", "FreeSerifBold.ttf", "FreeSerifItalic.ttf",
                 "FreeSerifBoldItalic.ttf"),
         sans  = c("FreeSans.ttf", "FreeSansBold.ttf", "FreeSansOblique.ttf",
                 "FreeSansBoldOblique.ttf"),
         mono  = c("FreeMono.ttf", "FreeMonoBold.ttf", "FreeMonoOblique.ttf",
                 "FreeMonoBoldOblique.ttf"),
         symbol= c("ESSTIX10.TTF", "ESSTIX12.TTF", "ESSTIX9_.TTF", 
                 "ESSTIX11.TTF"))

## End(Not run) 
</code></pre>

<hr>
<h2 id='rglIds'>
RGL id values
</h2><span id='topic+lowlevel'></span><span id='topic+highlevel'></span><span id='topic+rglId'></span><span id='topic+rglLowlevel'></span><span id='topic+rglHighlevel'></span><span id='topic+print.rglId'></span>

<h3>Description</h3>

<p>All objects in an RGL scene have a
numerical id.  These ids are normally stored
in vectors of class <code>c("rglIds", "numeric")</code>, which
will also have class <code>"rglHighlevel"</code>
or <code>"rglLowlevel"</code> depending on 
whether a high level function like 
<code><a href="#topic+plot3d">plot3d</a></code> or <code><a href="#topic+persp3d">persp3d</a></code>, or a low level function created the objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglId(ids = integer())
lowlevel(ids = integer())
highlevel(ids = integer())
## S3 method for class 'rglId'
print(x, 
      rglwidget = getOption("rgl.printRglwidget", FALSE),
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rglIds_+3A_ids">ids</code></td>
<td>

<p>A vector of object ids.
</p>
</td></tr>
<tr><td><code id="rglIds_+3A_x">x</code></td>
<td>

<p>An <code>"rglId"</code> object to print.
</p>
</td></tr>
<tr><td><code id="rglIds_+3A_rglwidget">rglwidget</code></td>
<td>

<p>Whether to create and print an RGL widget.
If false, nothing is printed.
</p>
</td></tr>
<tr><td><code id="rglIds_+3A_...">...</code></td>
<td>

<p>Other arguments which will be passed to
<code><a href="#topic+rglwidget">rglwidget</a></code> if it is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions and classes are intended to allow
RGL scenes to be automatically 
displayed in R Markdown documents.  See <code><a href="#topic+setupKnitr">setupKnitr</a></code> for details on enabling auto-printing.
</p>
<p>Note that <em>all</em> objects in the current
scene will be printed by default, not just
the ids in <code>x</code>.  (One reason for this
is that lights are also objects; printing
objects without lights would rarely make
sense.)
</p>


<h3>Value</h3>

<p>Objects of class <code>"rglId"</code>, <code>c("rglHighlevel", "rglId",
"numeric")</code> or <code>c("rglLowlevel", "rglId",
"numeric")</code> for <code>rglId</code>, <code>lowlevel</code> or <code>highlevel</code> 
respectively.  
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(30), ncol = 3, dimnames = list(NULL, c("x", "y", "z")))
p &lt;- plot3d(x, type = "s")
str(p)
if (interactive() || in_pkgdown_example())
  print(p, rglwidget = TRUE)
</code></pre>

<hr>
<h2 id='rglMouse'>
Generate HTML code to select mouse mode
</h2><span id='topic+rglMouse'></span>

<h3>Description</h3>

<p>This generates an HTML <code>select</code> element to 
choose among the mouse modes supported by <code><a href="#topic+rglwidget">rglwidget</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglMouse(sceneId, 
         choices = c("trackball", "selecting", 
                     "xAxis", "yAxis", "zAxis", 
                     "polar", "zoom", "fov", 
                     "none"), 
         labels = choices, 
         button = 1, 
         dev = cur3d(), 
         subscene = currentSubscene3d(dev), 
         default = par3d("mouseMode", dev = dev, subscene = subscene)[button + 1],
         stayActive = FALSE,
         height = 40,
         ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rglMouse_+3A_sceneid">sceneId</code></td>
<td>

<p>Either an <code><a href="#topic+rglwidget">rglwidget</a></code> or the <code>elementId</code>
from one of them.
</p>
</td></tr>
<tr><td><code id="rglMouse_+3A_choices">choices</code></td>
<td>

<p>Which mouse modes to support?
</p>
</td></tr>
<tr><td><code id="rglMouse_+3A_labels">labels</code></td>
<td>

<p>How to label each mouse mode.
</p>
</td></tr>
<tr><td><code id="rglMouse_+3A_button">button</code></td>
<td>

<p>Which mouse button is being controlled.
</p>
</td></tr>
<tr><td><code id="rglMouse_+3A_dev">dev</code></td>
<td>

<p>The RGL device used for defaults.
</p>
</td></tr>
<tr><td><code id="rglMouse_+3A_subscene">subscene</code></td>
<td>

<p>Which subscene is being modified.
</p>
</td></tr>
<tr><td><code id="rglMouse_+3A_default">default</code></td>
<td>

<p>What is the default entry to show in the control.
</p>
</td></tr>
<tr><td><code id="rglMouse_+3A_stayactive">stayActive</code></td>
<td>

<p>Whether a selection brush should stay active if the
mouse mode is changed.
</p>
</td></tr>
<tr><td><code id="rglMouse_+3A_height">height</code></td>
<td>

<p>The (relative) height of the item in the output display.
</p>
</td></tr>
<tr><td><code id="rglMouse_+3A_...">...</code></td>
<td>

<p>Additional arguments to pass to <code>htmltools::tags$select()</code>, e.g. <code>id</code> or <code>class</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A result of an <code><a href="#topic+rglwidget">rglwidget</a></code> call can be passed
as the <code>sceneId</code> argument.  This allows the widget
to be &ldquo;piped&rdquo; into the <code>rglMouse</code> call.
The widget will appear first, the selector next in
a <code><a href="htmltools.html#topic+tag">tagList</a></code>.
</p>
<p>If the <code>sceneId</code> is a character string, it should be
the <code>elementId</code> of a separately constructed
<code><a href="#topic+rglwidget">rglwidget</a></code> result.
</p>
<p>Finally, the <code>sceneId</code> can be omitted.  In this case
the <code>rglMouse</code> result needs to be passed into an
<code><a href="#topic+rglwidget">rglwidget</a></code> call as part of the
<code>controllers</code> argument.  This will place the selector before the
widget on the resulting display.
</p>
<p>If the mouse mode is changed while brushing the scene, 
by default the brush will be removed (and so the selection
will be cleared too).  If this is not desired, set
<code>stayActive = TRUE</code>.
</p>


<h3>Value</h3>

<p>A browsable value to put in a web page.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive() || in_pkgdown_example()) {
  open3d()
  xyz &lt;- matrix(rnorm(300), ncol = 3)
  id &lt;- plot3d(xyz, col = "red", type = "s")["data"]
  par3d(mouseMode = "selecting")
  share &lt;- rglShared(id)

# This puts the selector below the widget.
  rglwidget(shared = share, width = 300, height = 300) %&gt;% rglMouse()
  
# This puts the selector above the widget.
  rglMouse() %&gt;% rglwidget(shared = share, width = 300, height = 300, controllers = .) 
}
</code></pre>

<hr>
<h2 id='rglShared'>
Create shared data from an RGL object
</h2><span id='topic+rglShared'></span>

<h3>Description</h3>

<p>The <span class="pkg">crosstalk</span> package provides a way for
different parts of an interactive display to 
communicate about datasets, using &ldquo;shared data&rdquo; objects.  When selection or filtering
is performed in one view, the result is mirrored 
in all other views.
</p>
<p>This function allows vertices of RGL objects
to be treated as shared data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglShared(id, key = NULL, group = NULL,
          deselectedFade = 0.1, 
          deselectedColor = NULL,
	  selectedColor = NULL,
          selectedIgnoreNone = TRUE,
	  filteredFade = 0,
          filteredColor = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rglShared_+3A_id">id</code></td>
<td>

<p>An existing RGL id.
</p>
</td></tr>
<tr><td><code id="rglShared_+3A_key">key</code></td>
<td>

<p>Optional unique labels to apply to each vertex.
If missing, numerical keys will be used.
</p>
</td></tr>
<tr><td><code id="rglShared_+3A_group">group</code></td>
<td>

<p>Optional name of the shared group to which
this data belongs.  If missing, a random name
will be generated.
</p>
</td></tr>
<tr><td><code id="rglShared_+3A_deselectedfade">deselectedFade</code>, <code id="rglShared_+3A_deselectedcolor">deselectedColor</code></td>
<td>

<p>Appearance of points that are not selected. See Details.
</p>
</td></tr>
<tr><td><code id="rglShared_+3A_selectedcolor">selectedColor</code></td>
<td>

<p>Appearance of points that are selected.
</p>
</td></tr>
<tr><td><code id="rglShared_+3A_selectedignorenone">selectedIgnoreNone</code></td>
<td>

<p>If no points are selected, should the points be shown
in their original colors (<code>TRUE</code>), or in the 
deselected colors (<code>FALSE</code>)?
</p>
</td></tr>
<tr><td><code id="rglShared_+3A_filteredfade">filteredFade</code>, <code id="rglShared_+3A_filteredcolor">filteredColor</code></td>
<td>

<p>Appearance of points that have been filtered out.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some functions which normally work on 
dataframe-like datasets will accept shared data
objects in their place. 
</p>
<p>If a selection is in progress, the alpha value for
unselected points is multiplied by <code>deselectedFade</code>.
If <code>deselectedColor</code> is <code>NULL</code>, the color is left
as originally specified; if not, the point is changed to
the color given by <code>deselectedColor</code>.
</p>
<p>If no points have been selected, then by default points
are shown in their original colors.  However, if 
<code>selectedIgnoreNone = FALSE</code>, all points are displayed
as if unselected.
</p>
<p>The <code>selectedColor</code> argument is similarly used to 
change the color (or not) of selected points, and <code>filteredFade</code> 
and <code>filteredColor</code> are used for points that
have been filtered out of the display.
</p>


<h3>Value</h3>

<p>An object of class <code>"SharedData"</code> (from the 
optional <span class="pkg">crosstalk</span> package) which 
contains the x, y and z coordinates of the RGL object 
with the given <code>id</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p><a href="https://rstudio.github.io/crosstalk/index.html">https://rstudio.github.io/crosstalk/index.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  save &lt;- options(rgl.useNULL = TRUE)
  
  #  rglShared requires the crosstalk package,
  #  and the slider and rglMouse require manipulateWidget
  
  if (requireNamespace("crosstalk", quietly = TRUE) &amp;&amp;
      requireNamespace("manipulateWidget", quietly = TRUE)) {
    open3d()
    x &lt;- sort(rnorm(100))
    y &lt;- rnorm(100)
    z &lt;- rnorm(100) + atan2(x, y)
    ids &lt;- plot3d(x, y, z, col = rainbow(100))

    # The data will be selected and filtered, not the axes.
    sharedData &lt;- rglShared(ids["data"])
  
    # Also add some labels that are only displayed
    # when points are selected
  
    sharedLabel &lt;- rglShared(text3d(x, y, z, text = 1:100,
                                    adj = -0.5),
                             group = sharedData$groupName(),
                             deselectedFade = 0,
                             selectedIgnoreNone = FALSE) 
    if (interactive() || in_pkgdown_example()) 
      crosstalk::filter_slider("x", "x", sharedData, ~x) %&gt;%
      rglwidget(shared = list(sharedData, sharedLabel), controller = .) %&gt;% 
      rglMouse()
  }    
  options(save)
</code></pre>

<hr>
<h2 id='rglToLattice'>
Convert RGL userMatrix to lattice or base angles
</h2><span id='topic+rglToLattice'></span><span id='topic+rglToBase'></span>

<h3>Description</h3>

<p>These functions take a user orientation matrix
from an RGL scene and approximate the
parameters to either <span class="pkg">lattice</span> or base
graphics functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglToLattice(rotm = par3d("userMatrix"))
rglToBase(rotm = par3d("userMatrix"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rglToLattice_+3A_rotm">rotm</code></td>
<td>

<p>A matrix in homogeneous coordinates to convert.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <span class="pkg">lattice</span> package can use Euler angles in
the ZYX scheme to describe the rotation of a scene
in its <code><a href="lattice.html#topic+cloud">wireframe</a></code> or
<code><a href="lattice.html#topic+cloud">cloud</a></code> functions.  The
<code>rglToLattice</code> function computes these angles
based on <code>rotm</code>, which defaults to the current
user matrix.  This allows RGL to be used
to interactively find a decent viewpoint and
then reproduce it in <span class="pkg">lattice</span>.
</p>
<p>The base graphics <code><a href="graphics.html#topic+persp">persp</a></code> function does
not use full Euler angles; it
uses a viewpoint angle, and assume the z axis
remains vertical.  The <code>rglToBase</code> function
computes the viewpoint angle accurately if the
RGL scene is displayed with a vertical
z axis, and does an approximation otherwise.
</p>


<h3>Value</h3>

<p><code>rglToLattice</code> returns a list suitable to
be used as the <code>screen</code> argument to 
<code><a href="lattice.html#topic+cloud">wireframe</a></code>.
</p>
<p><code>rglToBase</code> returns a list containing
<code>theta</code> and <code>phi</code> components which
can be used as corresponding arguments in <code><a href="graphics.html#topic+persp">persp</a></code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>persp3d(volcano, col = "green")
if ((hasorientlib &lt;- requireNamespace("orientlib", quietly = TRUE)) &amp;&amp; 
    requireNamespace("lattice", quietly = TRUE)) 
    lattice::wireframe(volcano, screen = rglToLattice())
if (hasorientlib) {
  angles &lt;- rglToBase()
  persp(volcano, col = "green", border = NA, shade = 0.5,
        theta = angles$theta, phi = angles$phi)
}
</code></pre>

<hr>
<h2 id='rglwidget'>
An htmlwidget to hold an RGL scene
</h2><span id='topic+rglwidget'></span><span id='topic+rgl.printRglwidget'></span>

<h3>Description</h3>

<p>The <span class="pkg">htmlwidgets</span> package provides a framework for embedding
graphical displays in HTML documents of various types.  This function
provides the necessities to embed an RGL scene in one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglwidget(x = scene3d(minimal), width = figWidth(), height = figHeight(),
          controllers = NULL,
          elementId = NULL, 
          reuse = FALSE,
          webGLoptions = list(preserveDrawingBuffer = TRUE), 
          shared = NULL, minimal = TRUE, 
          webgl, snapshot, 
          shinyBrush = NULL, 
          altText = "3D plot",
          ...,
          oldConvertBBox = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rglwidget_+3A_x">x</code></td>
<td>

<p>An RGL scene produced by the <code><a href="#topic+scene3d">scene3d</a></code> function.
</p>
</td></tr>
<tr><td><code id="rglwidget_+3A_width">width</code>, <code id="rglwidget_+3A_height">height</code></td>
<td>

<p>The width and height of the display in pixels.
</p>
</td></tr>
<tr><td><code id="rglwidget_+3A_controllers">controllers</code></td>
<td>
<p>Names of <code><a href="#topic+playwidget">playwidget</a></code> objects
associated with this scene, or objects (typically piped in).  See Details below.
</p>
</td></tr>
<tr><td><code id="rglwidget_+3A_snapshot">snapshot</code>, <code id="rglwidget_+3A_webgl">webgl</code></td>
<td>
<p>Control of mode of display of scene.
See Details below.
</p>
</td></tr>
<tr><td><code id="rglwidget_+3A_elementid">elementId</code></td>
<td>
<p>The id to use on the HTML <code>div</code>
component that will hold the scene.
</p>
</td></tr>
<tr><td><code id="rglwidget_+3A_reuse">reuse</code></td>
<td>
<p>Ignored.  See Details below.
</p>
</td></tr>
<tr><td><code id="rglwidget_+3A_webgloptions">webGLoptions</code></td>
<td>
<p>A list of options to pass
to WebGL when the drawing context is created.  See the Details below.</p>
</td></tr>
<tr><td><code id="rglwidget_+3A_shared">shared</code></td>
<td>
<p>An object produced by <code><a href="#topic+rglShared">rglShared</a></code>, or a list of such objects.</p>
</td></tr>
<tr><td><code id="rglwidget_+3A_minimal">minimal</code></td>
<td>
<p>Should attributes be skipped if they currently have
no effect?  See <code><a href="#topic+scene3d">scene3d</a></code>.</p>
</td></tr>
<tr><td><code id="rglwidget_+3A_shinybrush">shinyBrush</code></td>
<td>
<p>The name of a Shiny <code>input</code> element
to receive information about mouse selections.</p>
</td></tr>
<tr><td><code id="rglwidget_+3A_alttext">altText</code></td>
<td>
<p>Text to include for screen-readers or browsers
that don't handle WebGL.  See Details below.</p>
</td></tr>
<tr><td><code id="rglwidget_+3A_oldconvertbbox">oldConvertBBox</code></td>
<td>
<p>See Details below.</p>
</td></tr>
<tr><td><code id="rglwidget_+3A_...">...</code></td>
<td>
<p>Additional arguments
to pass to <code>htmlwidgets::<a href="htmlwidgets.html#topic+createWidget">createWidget</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This produces a WebGL version of an RGL scene using the <span class="pkg">htmlwidgets</span>
framework.  This allows display of the scene in the RStudio IDE, a browser, an <span class="pkg">rmarkdown</span> document
or in a <span class="pkg">shiny</span> app.
</p>
<p><code>options(rgl.printRglwidget = TRUE)</code> will cause
<code>rglwidget()</code> to be called and displayed
when the result of an RGL call that changes the
scene is printed.
</p>
<p>In RMarkdown or in standalone code, you can use a <span class="pkg">magrittr</span>-style
&ldquo;pipe&rdquo; command to join an <code>rglwidget</code> with a
<code><a href="#topic+playwidget">playwidget</a></code> or <code><a href="#topic+toggleWidget">toggleWidget</a></code>.  If the control widget comes
first, it should be piped into the <code>controllers</code>
argument.  If the <code>rglwidget</code> comes first, it
can be piped into the first argument of <code>playwidget</code> or <code>toggleWidget</code>.
</p>
<p>In earlier versions, the <code>reuse</code> argument let one output scene share data from earlier ones.  This is no longer supported.
</p>
<p>If <code>elementId</code> is <code>NULL</code> and we are not in a Shiny app,
<code>elementId</code> is set to a random value to facilitate re-use
of information.
</p>
<p>To save the display to a file, use <code>htmlwidgets::<a href="htmlwidgets.html#topic+saveWidget">saveWidget</a></code>.
This requires <code>pandoc</code> to be installed.  
For a snapshot, you can use
<code>htmltools::save_html(img(src=rglwidget(snapshot=TRUE)), file = ...)</code>.
</p>
<p>The <code>webGLoptions</code> argument is a list which will
be passed when the WebGL context is created.  See
the WebGL 1.0 specification on <a href="https://registry.khronos.org/webgl/specs/">https://registry.khronos.org/webgl/specs/</a> for possible
settings.  The default in <code>rglwidget</code> differs
from the WebGL default by setting <code>preserveDrawingBuffer = TRUE</code> in order to allow other tools to read
the image, but please note that some implementations
of WebGL contain bugs with this setting.  We have
attempted to work around them, but may change our
default in the future if this proves unsatisfactory.
</p>
<p>The <code>webgl</code> argument controls
whether a dynamic plot is displayed in HTML.  In LaTeX
and some other formats
dynamic plots can't be
displayed, so if the <code>snapshot</code> argument is <code>TRUE</code>,
<code>webgl</code> must be <code>FALSE</code>.  (In previous versions
of the <span class="pkg">rgl</span> package, both <code>webgl</code> and <code>snapshot</code> could be
<code>TRUE</code>; that hasn't worked for a while and is no longer
allowed as of version 0.105.6.)
</p>
<p>The <code>snapshot</code> argument controls whether a snapshot is
displayed:  it must be <code>!webgl</code> if both are specified.
</p>
<p>Prior to <span class="pkg">rgl</span> 0.106.21, <code>rglwidget</code> converted 
bounding box decorations into separate objects: a box, text
for the labels, segments for the ticks.  By default it now
generates these in Javascript, allowing axis labels to move as
they do in the display in <span class="rlang"><b>R</b></span>.  If you prefer the old conversion,
set <code>oldConvertBBox = TRUE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"htmlwidget"</code> (or <code>"shiny.tag.list"</code>
if pipes are used) that will intelligently print itself into
HTML in a variety of contexts including the R console, within R Markdown
documents, and within Shiny output bindings.
</p>
<p>If objects are passed in the <code>shared</code> argument,
then the widget will respond to selection and filtering 
applied to those as shared datasets.  See <code><a href="#topic+rglShared">rglShared</a></code> for more details and an example.
</p>


<h3>R Markdown specifics</h3>

<p>In an R Markdown document, you would normally call
<code><a href="#topic+setupKnitr">setupKnitr</a>(autoprint = TRUE)</code> and would not 
make explicit calls to <code>rglwidget()</code>.  If you do
make such calls, the graphics will be inserted into the
document. 
</p>
<p>In <span class="pkg">knitr</span> versions greater than 1.42.5,
the <code>altText</code> argument will be ignored and the alternate
text will be set from chunk option <code>fig.alt</code> or 
<code>fig.cap</code> as with other graphics.
</p>


<h3>Shiny specifics</h3>

<p>This widget is designed to work with Shiny for interactive
displays linked to a server running R.
</p>
<p>In a Shiny app, there will often be one or more
<code><a href="#topic+playwidget">playwidget</a></code> objects in the app, taking input from
the user.  In order to be sure that the initial value of the user control
is reflected in the scene, you should list all players in the
<code>controllers</code> argument.  See the sample application in
<code>system.file("shinyDemo", package = "rglwidget")</code> for an example.
</p>
<p>In Shiny, it is possible to find out information about mouse selections
by specifying the name of an <code>input</code> item in the
<code>shinyBrush</code> argument.  For example, with
<code>shinyBrush = "brush3d"</code>, each change
to the mouse selection will send data to <code>input$brush3d</code> in an
object of class <code>"rglMouseSelection"</code> with the
following components:
</p>

<dl>
<dt>subscene</dt><dd><p>The ID of the subscene where the mouse is selecting.</p>
</dd>
<dt>state</dt><dd><p>Either <code>"changing"</code> or <code>"inactive"</code>.</p>
</dd>
<dt>region</dt><dd><p>The coordinates of the corners of the selected region in the window,
in order <code>c(x1, y1, x2, y2)</code>.</p>
</dd>
<dt>model, proj, view</dt><dd><p>The model matrix, projection matrix and viewport in effect at that location.</p>
</dd>
</dl>

<p>This object can be used as the first argument to
<code><a href="#topic+selectionFunction3d">selectionFunction3d</a></code> to produce a test function for
whether a particular location is in the selected region.  If the 
brush becomes inactive, an object containing only the <code>state</code>
field will be sent, with value <code>"inactive"</code>.
</p>


<h3>Appearance</h3>

<p>The appearance of the display is set by the stylesheet
in <code>system.file("htmlwidgets/lib/rglClass/rgl.css")</code>.
</p>
<p>The widget is of class <code>rglWebGL</code>, with id
set according to <code>elementId</code>.  (As of this writing,
no special settings are given for class <code>rglWebGL</code>,
but you can add your own.)
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hook_webgl">hook_webgl</a></code> for an earlier approach to this problem. <code><a href="#topic+rglwidgetOutput">rglwidgetOutput</a></code> for Shiny details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>save &lt;- options(rgl.useNULL=TRUE)
example("plot3d", "rgl")
widget &lt;- rglwidget()
if (interactive() || in_pkgdown_example())
  widget
  

if (interactive() &amp;&amp; !in_pkgdown_example()) {
  # Save it to a file.  This requires pandoc
  filename &lt;- tempfile(fileext = ".html")
  htmlwidgets::saveWidget(rglwidget(), filename)
  browseURL(filename)
}


options(save)
</code></pre>

<hr>
<h2 id='safe.dev.off'>
Close graphics device in a safe way.
</h2><span id='topic+safe.dev.off'></span>

<h3>Description</h3>

<p>The <code><a href="grDevices.html#topic+dev.off">dev.off</a></code> function in <span class="pkg">grDevices</span> doesn't restore
the previous graphics device when called.  This function does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>safe.dev.off(which = dev.cur(), prev = dev.prev())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="safe.dev.off_+3A_which">which</code></td>
<td>

<p>Which device to close.
</p>
</td></tr>
<tr><td><code id="safe.dev.off_+3A_prev">prev</code></td>
<td>

<p>Which device to set as current after closing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function closes device <code>which</code> if it is not device 1,
then calls <code><a href="grDevices.html#topic+dev.set">dev.set</a>(prev)</code> if there are any devices still
open.
</p>


<h3>Value</h3>

<p>The number and name of the new active device.  It will not 
necessarily be <code>prev</code> if that device isn't already open.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p><a href="https://bugs.r-project.org/show_bug.cgi?id=18604">https://bugs.r-project.org/show_bug.cgi?id=18604</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a graphics device
dev.new()
first &lt;- dev.cur()

# Open a second graphics device
dev.new()
second &lt;- dev.cur()
second

# Open another one, and close it using dev.off()
dev.new()
dev.off()
dev.cur() == second # Not the same as second!

# Try again with safe.dev.off()
dev.set(second)
dev.new()
safe.dev.off()
dev.cur() == second

# Close the other two devs
safe.dev.off()
safe.dev.off()
</code></pre>

<hr>
<h2 id='scene'>Scene management</h2><span id='topic+clear3d'></span><span id='topic+pop3d'></span><span id='topic+ids3d'></span>

<h3>Description</h3>

<p>Clear shapes, lights, bbox
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear3d( type = c("shapes", "bboxdeco", "material"), defaults, subscene = 0 ) 
pop3d( type = "shapes", id = 0, tag = NULL)
ids3d( type = "shapes", subscene = NA, tags = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scene_+3A_type">type</code></td>
<td>
<p>Select subtype(s):
</p>

<dl>
<dt>&quot;shapes&quot;</dt><dd><p>shape stack</p>
</dd>
<dt>&quot;lights&quot;</dt><dd><p>light stack</p>
</dd>
<dt>&quot;bboxdeco&quot;</dt><dd><p>bounding box</p>
</dd>
<dt>&quot;userviewpoint&quot;</dt><dd><p>user viewpoint</p>
</dd>
<dt>&quot;modelviewpoint&quot;</dt><dd><p>model viewpoint</p>
</dd>
<dt>&quot;material&quot;</dt><dd><p>material properties</p>
</dd>
<dt>&quot;background&quot;</dt><dd><p>scene background</p>
</dd>
<dt>&quot;subscene&quot;</dt><dd><p>subscene list</p>
</dd>
<dt>&quot;all&quot;</dt><dd><p>all of the above</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="scene_+3A_defaults">defaults</code></td>
<td>
<p>default values to use after clearing</p>
</td></tr>
<tr><td><code id="scene_+3A_subscene">subscene</code></td>
<td>
<p>which subscene to work with.  <code>NA</code> means the current one, 
<code>0</code> means the whole scene</p>
</td></tr>  
<tr><td><code id="scene_+3A_id">id</code></td>
<td>
<p>vector of ID numbers of items to remove</p>
</td></tr>
<tr><td><code id="scene_+3A_tag">tag</code></td>
<td>
<p>override <code>id</code> with objects matching
these <code>tag</code> material properties</p>
</td></tr>
<tr><td><code id="scene_+3A_tags">tags</code></td>
<td>
<p>logical; whether to return <code>tag</code> column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RGL holds several lists of objects in each scene. 
There are lists for shapes, lights, bounding box decorations, subscenes, etc.
<code>clear3d</code> clears the specified stack, or restores
the defaults for the bounding box (not visible) or viewpoint. 
With <code>id = 0</code> <code>pop3d</code> removes 
the last added node on the list (except for subscenes:  there it
removes the active subscene).  The <code>id</code> argument
may be used to specify arbitrary item(s) to remove; if <code>id != 0</code>, 
the <code>type</code> argument is ignored.
</p>
<p><code>clear3d</code> may also be used to clear material properties
back to their defaults.  
</p>
<p><code>clear3d</code> has an optional <code>defaults</code> argument, which defaults to 
<code><a href="#topic+r3dDefaults">r3dDefaults</a></code>.  Only the <code>materials</code> component of this argument
is currently used by <code>clear3d</code>.
</p>
<p><code>ids3d</code> returns a dataframe containing the IDs in the currently active subscene
by default, or a specified subscene, or if <code>subscene = 0</code>, in the whole
rgl window along with an indicator of their type and if <code>tags = TRUE</code>, the
<code>tag</code> value for each.
</p>
<p>Note that clearing the light stack leaves the scene in darkness; it should normally
be followed by a call to <code><a href="#topic+light3d">light3d</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rgl">rgl</a></code>,
<code><a href="#topic+bbox3d">bbox3d</a></code>,
<code><a href="#topic+light3d">light3d</a></code>,
<code><a href="#topic+open3d">open3d</a></code> to open a new window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(100)
  y &lt;- rnorm(100)
  z &lt;- rnorm(100)
  p &lt;- plot3d(x, y, z, type = 's', tag = "plot")
  ids3d()
  lines3d(x, y, z)
  ids3d(tags = TRUE)
  if (interactive() &amp;&amp; !rgl.useNULL() &amp;&amp; !in_pkgdown_example()) {
    readline("Hit enter to change spheres")
    pop3d(id = p["data"])
    spheres3d(x, y, z, col = "red", radius = 1/5)
    box3d()
  }
</code></pre>

<hr>
<h2 id='scene3d'>
Saves the current scene to a variable, and displays such variables
</h2><span id='topic+scene3d'></span><span id='topic+rglscene-class'></span><span id='topic+rglobject-class'></span><span id='topic+plot3d.rglscene'></span><span id='topic+plot3d.rglobject'></span><span id='topic+print.rglscene'></span><span id='topic+print.rglobject'></span>

<h3>Description</h3>

<p>This function saves a large part of the RGL state associated with the current
window to a variable.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scene3d(minimal = TRUE)
## S3 method for class 'rglscene'
plot3d(x, add = FALSE, open3dParams = getr3dDefaults(), ...)
## S3 method for class 'rglobject'
plot3d(x, ...)
## S3 method for class 'rglscene'
print(x, ...)
## S3 method for class 'rglobject'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scene3d_+3A_minimal">minimal</code></td>
<td>
<p>Should attributes be skipped if they currently have
no effect?  See Details.</p>
</td></tr>
<tr><td><code id="scene3d_+3A_x">x</code></td>
<td>
<p>An object of class <code>"rglscene"</code></p>
</td></tr>
<tr><td><code id="scene3d_+3A_add">add</code></td>
<td>
<p>Whether to open a new window, or add to the existing one.</p>
</td></tr>
<tr><td><code id="scene3d_+3A_open3dparams">open3dParams</code></td>
<td>
<p>Default parameters for <code>open3d</code></p>
</td></tr>
<tr><td><code id="scene3d_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>open3d</code>
by <code>plot3d(..., add = FALSE)</code>.  These override
<code>open3dParams</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The components saved are:  the <code><a href="#topic+par3d">par3d</a></code> settings, the <code><a href="#topic+material3d">material3d</a></code>
settings, the <code><a href="#topic+bg3d">bg3d</a></code> settings, the lights and the objects in the scene.
</p>
<p>In most cases, calling <code><a href="#topic+plot3d">plot3d</a></code> on that variable will
duplicate the scene.  (There are likely to be small differences, mostly internal, but
some aspects of the scene are not currently available.) If textures are used,
the name of the texture will be saved, rather than the contents of the 
texture file.
</p>
<p>Other than saving the code
to recreate a scene, saving the result of <code>scene3d</code> to 
a file will allow it to be reproduced later most accurately.  In roughly decreasing order of fidelity,
<code><a href="#topic+writeWebGL">writeWebGL</a></code> (now deprecated), <code><a href="#topic+writePLY">writePLY</a></code>, <code><a href="#topic+writeOBJ">writeOBJ</a></code> and <code><a href="#topic+writeSTL">writeSTL</a></code>
write the scene to a file in formats readable by other software.
</p>
<p>If <code>minimal = TRUE</code> (the default), then attributes of objects
will not be saved if they currently have no effect on
the display, thereby reducing the file size.  
Set <code>minimal = FALSE</code> if the scene is intended
to be used in a context where the appearance could be changed.  
Currently this only affects the inclusion of normals; with 
<code>minimal = TRUE</code> they are
omitted for objects when the material is not lit.
</p>


<h3>Value</h3>

<p>The <code>scene3d</code> function returns an object of class
<code>"rglscene"</code>.  This is a list with some or all of the components:
</p>
<table>
<tr><td><code>material</code></td>
<td>
<p>The results returned from a <code><a href="#topic+material3d">material3d</a></code> call.</p>
</td></tr>
<tr><td><code>rootSubscene</code></td>
<td>
<p>A list containing information about
the main (&quot;root&quot;) subscene.  This may include:
</p>

<dl>
<dt>id</dt><dd><p>The scene id.</p>
</dd>
<dt>type</dt><dd><p>&quot;subscene&quot;</p>
</dd>
<dt>par3d</dt><dd><p>The <code><a href="#topic+par3d">par3d</a></code> settings for the
subscene.</p>
</dd>
<dt>embeddings</dt><dd><p>The <code><a href="#topic+subsceneInfo">subsceneInfo</a>()$embeddings</code> for the main subscene.</p>
</dd>
<dt>objects</dt><dd><p>The ids for objects in the subscene.</p>
</dd>
<dt>subscenes</dt><dd><p>A recursive list of child subscenes.</p>
</dd></dl>
</td></tr>
<tr><td><code>objects</code></td>
<td>
<p>A list containing the RGL lights, background and objects in the scene.</p>
</td></tr>  
</table>
<p>The objects in the <code>objects</code> component are of class
<code>"rglobject"</code>.  They are lists containing some or all of the
components
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>The RGL identifier of the object in the original scene.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>A character variable identifying the type of object.</p>
</td></tr>
<tr><td><code>material</code></td>
<td>
<p>Components of the material that differ from the scene material.</p>
</td></tr>
<tr><td><code>vertices</code>, <code>normals</code>, <code>etc.</code></td>
<td>
<p>Any of the attributes of the object retrievable by <code><a href="#topic+rgl.attrib">rgl.attrib</a></code>.</p>
</td></tr>
<tr><td><code>ignoreExtent</code></td>
<td>
<p>A logical value indicating whether this object contributes to the bounding box.
Currently this may differ from the object in the original scene.</p>
</td></tr>
<tr><td><code>objects</code></td>
<td>
<p>Sprites may contain other objects; they will be stored here as a list of  <code>"rglobject"</code>s.</p>
</td></tr>
</table>
<p>Lights in the scene are stored similarly, mixed into the <code>objects</code> list.
</p>
<p>The <code>plot3d</code> methods invisibly return a vector of RGL object ids
that were plotted.  The <code>print</code> methods invisibly return the
object that was printed.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rglwidget">rglwidget</a></code>, <code><a href="#topic+writePLY">writePLY</a></code>, <code><a href="#topic+writeOBJ">writeOBJ</a></code> and <code><a href="#topic+writeSTL">writeSTL</a></code>
write the scene to a file in various formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
z &lt;- 2 * volcano        # Exaggerate the relief
x &lt;- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
y &lt;- 10 * (1:ncol(z))   # 10 meter spacing (E to W)
persp3d(x, y, z, col = "green3", aspect = "iso")

s &lt;- scene3d()
# Make it bigger
s$par3d$windowRect &lt;- 1.5*s$par3d$windowRect
# and draw it again
plot3d(s)
</code></pre>

<hr>
<h2 id='sceneChange'>
Make large change to a scene from Shiny
</h2><span id='topic+sceneChange'></span><span id='topic+registerSceneChange'></span>

<h3>Description</h3>

<p>These functions allow Shiny apps to make relatively large changes
to a scene, adding and removing objects from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sceneChange(elementId, x = scene3d(minimal),
            delete = NULL, add = NULL, replace = NULL,
            material = FALSE, rootSubscene = FALSE,
            delfromSubscenes = NULL, skipRedraw = FALSE,
            minimal = TRUE)
registerSceneChange()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sceneChange_+3A_elementid">elementId</code></td>
<td>

<p>The id of the element holding the <code>rglClass</code> instance.
</p>
</td></tr>
<tr><td><code id="sceneChange_+3A_x">x</code></td>
<td>

<p>The new scene to use as a source for objects to add.
</p>
</td></tr>
<tr><td><code id="sceneChange_+3A_delete">delete</code>, <code id="sceneChange_+3A_add">add</code>, <code id="sceneChange_+3A_replace">replace</code></td>
<td>

<p>Object ids to modify in the scene.  The <code>delete</code> and
<code>replace</code> ids must be present in the old scene in the browser;
the <code>add</code> and <code>replace</code> ids must be present in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="sceneChange_+3A_material">material</code></td>
<td>

<p>Logical to indicate whether default material should be updated.
</p>
</td></tr>
<tr><td><code id="sceneChange_+3A_rootsubscene">rootSubscene</code></td>
<td>

<p>Logical to indicate whether root subscene should be updated.
</p>
</td></tr>
<tr><td><code id="sceneChange_+3A_delfromsubscenes">delfromSubscenes</code></td>
<td>

<p>A vector of subscene ids that may have been changed by
deletions.  By default, all subscenes in <code>x</code> are used,
but the objects may be included in subscenes in the browser
that are different.
</p>
</td></tr>
<tr><td><code id="sceneChange_+3A_skipredraw">skipRedraw</code></td>
<td>

<p>If <code>TRUE</code>, stop the scene from redrawing until <code>skipRedraw=FALSE</code> is sent.  If <code>NA</code>, don't redraw this time, but don't
change the state of the <code>skipRedraw</code> flag.
</p>
</td></tr>
<tr><td><code id="sceneChange_+3A_minimal">minimal</code></td>
<td>

<p>See <code><a href="#topic+scene3d">scene3d</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>registerSceneChange</code> must be called in the UI component
of a Shiny app to register the <code>"sceneChange"</code> custom
message.
</p>


<h3>Value</h3>

<p><code>registerSceneChange</code> returns the HTML code to register the
message.
</p>
<p><code>sceneChange</code> returns a list to be used as the <code>"sceneChange"</code>
message to change the scene.  Use
<code><a href="shiny.html#topic+session">shiny::session$sendCustomMessage</a></code> to send it.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+playwidget">playwidget</a></code> for a different approach to modifying
scenes that can be much faster, but may be less flexible.  The
Shiny demo in this package makes use of all of these approaches.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
shinyUI(fluidPage(
  registerSceneChange(),
  actionButton("thebutton", "Change")
))

shinyServer(function(input, output, session) {
  observeEvent(input$thebutton, {
    session$sendCustomMessage("sceneChange",
      sceneChange("thewidget", delete = deletes, add = adds))
  })
})

## End(Not run)
</code></pre>

<hr>
<h2 id='select3d'> Select a rectangle in an RGL scene </h2><span id='topic+select3d'></span><span id='topic+selectionFunction3d'></span>

<h3>Description</h3>

<p>This function allows the user to use the mouse to
select a region in an RGL scene.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select3d(button = c("left", "middle", "right"),
             dev = cur3d(), subscene = currentSubscene3d(dev))
selectionFunction3d(proj, region = proj$region)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select3d_+3A_button">button</code></td>
<td>
<p> Which button to use for selection.</p>
</td></tr>
<tr><td><code id="select3d_+3A_dev">dev</code>, <code id="select3d_+3A_subscene">subscene</code></td>
<td>
<p> The RGL device and subscene to work with </p>
</td></tr>
<tr><td><code id="select3d_+3A_proj">proj</code></td>
<td>
<p>An object returned from <code><a href="#topic+rgl.projection">rgl.projection</a></code>
containing details of the current projection.</p>
</td></tr>
<tr><td><code id="select3d_+3A_region">region</code></td>
<td>
<p>Corners of a rectangular region in the display.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>select3d</code> selects 3-dimensional regions by allowing the
user to use a mouse to draw a rectangle showing
the projection of the region onto the screen.  It returns
a function which tests points for inclusion in the selected region.
</p>
<p><code>selectionFunction3d</code> constructs such a test function given 
coordinates and current transformation matrices.
</p>
<p>If the scene is later moved or rotated, the selected region will 
remain the same, though no longer corresponding to a rectangle on the screen.
</p>


<h3>Value</h3>

<p>These return a function <code>f(x, y, z)</code> which tests whether each
of the points <code>(x, y, z)</code> is in the selected region, returning
a logical vector.  This function accepts input in a wide
variety of formats as it uses <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code> 
to interpret its parameters.
</p>


<h3>Author(s)</h3>

<p> Ming Chen / Duncan Murdoch </p>


<h3>See Also</h3>

 <p><code><a href="#topic+selectpoints3d">selectpoints3d</a></code>, <code><a href="graphics.html#topic+locator">locator</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Allow the user to select some points, and then redraw them
# in a different color

if (interactive() &amp;&amp; !in_pkgdown_example()) {
 x &lt;- rnorm(1000)
 y &lt;- rnorm(1000)
 z &lt;- rnorm(1000)
 open3d()
 points3d(x, y, z)
 f &lt;- select3d()
 if (!is.null(f)) {
   keep &lt;- f(x, y, z)
   pop3d()
   points3d(x[keep], y[keep], z[keep], color = 'red')
   points3d(x[!keep], y[!keep], z[!keep])
 }
}
</code></pre>

<hr>
<h2 id='selectpoints3d'>
Select points from a scene
</h2><span id='topic+selectpoints3d'></span>

<h3>Description</h3>

<p>This function uses the <code><a href="#topic+select3d">select3d</a></code> function to allow the user to choose a
point or region in the scene, then reports on all the vertices in or near that selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectpoints3d(objects = ids3d()$id, value = TRUE, closest = TRUE, 
               multiple = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectpoints3d_+3A_objects">objects</code></td>
<td>

<p>A vector of object id values to use for the search.
</p>
</td></tr>
<tr><td><code id="selectpoints3d_+3A_value">value</code></td>
<td>

<p>If <code>TRUE</code>, return the coordinates of the points; otherwise, return
their indices.
</p>
</td></tr>
<tr><td><code id="selectpoints3d_+3A_closest">closest</code></td>
<td>

<p>If <code>TRUE</code>, return the points closest to the selection of no points are
exactly within it.
</p>
</td></tr>
<tr><td><code id="selectpoints3d_+3A_multiple">multiple</code></td>
<td>

<p>If <code>TRUE</code> or a function, do multiple selections.  See the Details below.
</p>
</td></tr>
<tr><td><code id="selectpoints3d_+3A_...">...</code></td>
<td>

<p>Other parameters to pass to <code><a href="#topic+select3d">select3d</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>multiple</code> argument may be a logical value or a function.  If logical, 
it controls whether multiple selections will be performed.  If 
<code>multiple</code> is <code>FALSE</code>, a single selection will be performed;
it might contain multiple points.  If <code>TRUE</code>, multiple selections 
will occur and the results will be combined into a single matrix.  
</p>
<p>If <code>multiple</code> is a function, it should take a single argument.
This function will be called with the argument set to a matrix
containing newly added rows to the value, i.e. 
it will contain coordinates of the newly selected points (if 
<code>value = TRUE</code>), or the indices of the points (if <code>value =
FALSE</code>).  It should return a logical value, <code>TRUE</code> to indicate
that selection should continue, <code>FALSE</code> to indicate that it
should stop.
</p>
<p>In either case, if multiple selections are being performed, the <code>ESC</code> key will 
stop the process.
</p>


<h3>Value</h3>

<p>If <code>value</code> is <code>TRUE</code>, a 3-column matrix giving the coordinates of the 
selected points.  All rows in the matrix will be unique even if multiple vertices
have the same coordinates.
</p>
<p>If <code>value</code> is <code>FALSE</code>, a 2-column matrix containing columns:
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>The object id containing the point.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>The index of the point within <code><a href="#topic+rgl.attrib">rgl.attrib</a>(id, "vertices")</code>.
If multiple points have the same coordinates, all indices will be returned.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function selects points, not areas.  For example,
if the selection region is in the interior of the triangle, that
will count as a miss for all of the triangle's vertices.</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select3d">select3d</a></code> to return a selection function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyz &lt;- cbind(rnorm(20), rnorm(20), rnorm(20))
ids &lt;- plot3d( xyz )

if (interactive() &amp;&amp; !in_pkgdown_example()) {
  # Click near a point to select it and put a sphere there.
  # Press ESC to quit...

  # This version returns coordinates
  selectpoints3d(ids["data"], 
     multiple = function(x) {
        spheres3d(x, color = "red", alpha = 0.3, radius = 0.2)
        TRUE
     })

  # This one returns indices
  selectpoints3d(ids["data"], value = FALSE,
     multiple = function(ids) {
        spheres3d(xyz[ids[, "index"], , drop = FALSE], color = "blue", 
                  alpha = 0.3, radius = 0.2)
        TRUE
     })
}
</code></pre>

<hr>
<h2 id='setAxisCallbacks'>
User-defined axis labelling callbacks.
</h2><span id='topic+setAxisCallbacks'></span>

<h3>Description</h3>

<p>This function sets user callbacks to construct axes in R or
<code><a href="#topic+rglwidget">rglwidget</a></code> displays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setAxisCallbacks(axes, fns, 
                 javascript = NULL, 
                 subscene = scene$rootSubscene$id, 
                 scene = scene3d(minimal = FALSE), 
                 applyToScene = TRUE, 
                 applyToDev = missing(scene))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setAxisCallbacks_+3A_axes">axes</code></td>
<td>

<p>Which axes?  Specify as number in <code>1:3</code> or letter in
<code>c("x", "y", "z")</code>.
</p>
</td></tr>
<tr><td><code id="setAxisCallbacks_+3A_fns">fns</code></td>
<td>

<p>Function or list of functions or character vector giving
names of functions.
</p>
</td></tr>
<tr><td><code id="setAxisCallbacks_+3A_javascript">javascript</code></td>
<td>

<p>Optional block of Javascript code to be
included (at the global level).
</p>
</td></tr>
<tr><td><code id="setAxisCallbacks_+3A_subscene">subscene</code></td>
<td>

<p>Which subscene do these callbacks apply to?
</p>
</td></tr>
<tr><td><code id="setAxisCallbacks_+3A_scene">scene</code></td>
<td>

<p>Which scene?
</p>
</td></tr>
<tr><td><code id="setAxisCallbacks_+3A_applytoscene">applyToScene</code></td>
<td>

<p>Should these changes apply to the scene object?
</p>
</td></tr>
<tr><td><code id="setAxisCallbacks_+3A_applytodev">applyToDev</code></td>
<td>

<p>Should these changes apply to the current device?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>applyToScene</code> is <code>TRUE</code>, this function adds Javascript 
callbacks to the <code>scene</code> object.  
If <code>applyToDev</code> is <code>TRUE</code>, it adds R
callbacks to the current RGL device.
</p>
<p>For Javascript, 
the callbacks are specified as strings; these will be
evaluated within the browser in the global context to define the functions, 
which will then be called with the Javascript
<code>this</code> object set to the current
<code>rglwidgetClass</code> object.
</p>
<p>For R, they may be strings or R functions.
</p>
<p>Both options may be <code>TRUE</code>, in which case the
callbacks must be specified as strings which are 
both valid Javascript and valid R.  The usual way to
do this is to give just a function name, with the
function defined elsewhere, as in the Example below.
</p>
<p>The functions should have a header of the form 
<code>function(margin)</code>.  The <code>margin</code> argument
will be a string like <code>"x++"</code> indicating which margin
would be chosen by R.  If RGL would not choose to draw any
axis annotations (which happens with <code><a href="#topic+rglwidget">rglwidget</a></code>, though
not currently in R itself), only the letter will be passed,
e.g. <code>"x"</code>.
</p>


<h3>Value</h3>

<p>Invisibly returns an <code>rglScene</code> object.  This
object will record the changes if <code>applyToScene</code>
is <code>TRUE</code>.
</p>
<p>If <code>applyToDev</code> is <code>TRUE</code>, it will also 
have the side effect of attempting to install the
callbacks.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setUserCallbacks">setUserCallbacks</a></code> for mouse callbacks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Draw arrows instead of tick marks on axes

arrowAxis &lt;- local({
  ids &lt;- c(NA, NA, NA)
  bbox &lt;- c(NA, NA, NA, NA, NA, NA)
  function(margin) {
    dim &lt;- if (grepl("x", margin)) 1 else
           if (grepl("y", margin)) 2 else
           3
    inds &lt;- 2*dim + (-1):0
    range &lt;- par3d("bbox")[inds]
    if (!identical(bbox[inds], range)) {
      if (!is.na(ids[dim]))
        pop3d(id = ids[dim])
       
      bbox[inds] &lt;&lt;- range 
      center &lt;- mean(range)
      from &lt;- mean(c(range[1], center))
      to &lt;- mean(c(center, range[2]))
      # margin should agree with suggestion, so use "x++" etc.
      margin &lt;- gsub("-", "+", margin)
      ids[dim] &lt;- arrow3d(p0 = c(from, 1, 1), 
                         p1 = c(to, 1, 1),
                         n = 4,
                         type = "lines",
                         margin = margin,
                         floating = TRUE)
    }
  }
})

# Define the Javascript function with the same name to use in WebGL
# Since Javascript won't change the bounding box, this function
# doesn't need to do anything.
  
js &lt;- "
window.arrowAxis = function(margin) {} ;
"

xyz &lt;- matrix(rnorm(60), ncol = 3)
plot3d(xyz, xlab = "x", ylab = "y", zlab = "z")
setAxisCallbacks(1:3, "arrowAxis", javascript = js)
rglwidget()
</code></pre>

<hr>
<h2 id='setGraphicsDelay'>
Set a one-time slowdown on opening standard graphics
</h2><span id='topic+setGraphicsDelay'></span><span id='topic+RGL_SLOW_DEV'></span>

<h3>Description</h3>

<p>This function is mainly for internal use, to work around  
a bug in macOS Catalina:  if base plotting happens
too quickly after opening RGL and the first call to quartz, R crashes.
</p>
<p>This inserts a delay after the first call to open the 
graphics device.  The default is
no delay, unless on Catalina with no graphics device
currently open but the <code><a href="grDevices.html#topic+quartz">quartz</a></code> device set
as the default, when a 1 second delay will be added.
Use environment variable &quot;RGL_SLOW_DEV = value&quot; to set
a different default delay. 
</p>
<p>It works by changing the value of <code><a href="base.html#topic+options">options</a>("device")</code>,
so explicit calls to the device will not be affected.
</p>
<p>It is called automatically when the <span class="pkg">rgl</span> package is loaded.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGraphicsDelay(delay = Sys.getenv("RGL_SLOW_DEV", 0), 
                 unixos = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setGraphicsDelay_+3A_delay">delay</code></td>
<td>

<p>Number of seconds for the delay.
</p>
</td></tr>
<tr><td><code id="setGraphicsDelay_+3A_unixos">unixos</code></td>
<td>

<p>The name of the Unix OS.  If set to <code>"Darwin"</code>, 
and the version is 19.0.0 or greater, the default delay is
changed to 1 second.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for the side effect of adding the delay to the first
opening of the graphics device.
</p>

<hr>
<h2 id='setupKnitr'>
Displaying RGL scenes in <span class="pkg">knitr</span> documents
</h2><span id='topic+hook_rgl'></span><span id='topic+hook_webgl'></span><span id='topic+hook_rglchunk'></span><span id='topic+setupKnitr'></span>

<h3>Description</h3>

<p>These functions allow RGL graphics to be embedded in <span class="pkg">knitr</span>
documents.
</p>
<p>The simplest method is to run <code>setupKnitr(autoprint = TRUE)</code>
early in the document.  That way RGL commands act a lot
like base graphics commands:  plots will be automatically inserted
where appropriate, according to the <code>fig.keep</code> chunk option.
By default (<code>fig.keep = "high"</code>), only high-level plots
are kept, after low-level changes have been merged into them.
See the <span class="pkg">knitr</span> documentation 
<a href="https://yihui.org/knitr/options/#plots">https://yihui.org/knitr/options/#plots</a> for more details.
To suppress auto-printing, the RGL calls
can be wrapped in <code><a href="base.html#topic+invisible">invisible</a>()</code>.  
Similarly to <span class="pkg">grid</span> graphics (used by <span class="pkg">lattice</span>
and <span class="pkg">ggplot2</span>), automatic inclusion requires the object
to be printed:  only the last statement in a code block
in braces is automatically printed.  Unlike those 
packages, auto-printing is the only way to get this to
work:  calling <code><a href="base.html#topic+print">print</a></code> explicitly doesn't
work.
</p>
<p>Other functions allow embedding either as bitmaps (<code>hook_rgl</code> with format <code>"png"</code>),
fixed vector graphics (<code>hook_rgl</code> with format <code>"eps"</code>, <code>"pdf"</code> or
<code>"postscript"</code>), or interactive WebGL graphics (<code>hook_webgl</code>).  <code>hook_rglchunk</code> is not normally invoked by the 
user; it is the hook that supports automatic creation and 
deletion of RGL scenes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupKnitr(autoprint = FALSE,
           rgl.newwindow = autoprint,
           rgl.closewindows = autoprint)
hook_rgl(before, options, envir)
hook_webgl(before, options, envir)
hook_rglchunk(before, options, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setupKnitr_+3A_autoprint">autoprint</code></td>
<td>
<p>If true, RGL commands
automatically plot (with low level plots suppressed by
the default value of the <code>fig.keep</code> chunk option.)</p>
</td></tr>
<tr><td><code id="setupKnitr_+3A_rgl.newwindow">rgl.newwindow</code>, <code id="setupKnitr_+3A_rgl.closewindows">rgl.closewindows</code></td>
<td>
<p>Default values
for the <span class="pkg">knitr</span> chunk options.</p>
</td></tr>
<tr><td><code id="setupKnitr_+3A_before">before</code>, <code id="setupKnitr_+3A_options">options</code>, <code id="setupKnitr_+3A_envir">envir</code></td>
<td>

<p>Standard <span class="pkg">knitr</span> hook function arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>setupKnitr()</code> function needs to be called once
at the start of the document to install the <span class="pkg">knitr</span> hooks.
If it is called twice in the same session the second call 
will override the first.
</p>
<p>The following chunk options are supported:
</p>

<ul>
<li> <p><code>rgl.newwindow</code>:  Whether to open a new window for the chunk.  Default is set by <code>setupKnitr</code> argument.
</p>
</li>
<li> <p><code>rgl.closewindows</code>: Whether
to close windows at the end of the chunk.  Default is set by <code>setupKnitr</code> argument.
</p>
</li>
<li> <p><code>rgl.margin</code> (default 100):  number of pixels by which to indent the
WebGL window.
</p>
</li>
<li> <p><code>snapshot</code>: Logical value:  when autoprinting
in HTML, should a snapshot be used instead of the dynamic 
WebGL display?  Corresponds to <code>rglwidget(snapshot = TRUE, webgl = FALSE)</code>.  Ignored in LaTeX, where a snapshot
will always be produced (unless <code>fig.keep</code> specifies
no figure at all).
</p>
</li>
<li> <p><code>dpi</code>, <code>fig.retina</code>, <code>fig.width</code>, <code>fig.height</code>:  standard <span class="pkg">knitr</span> chunk
options used to set the size of the output.
</p>
</li>
<li> <p><code>fig.keep</code>, <code>fig.hold</code>, <code>fig.beforecode</code>:  standard <span class="pkg">knitr</span> chunk options used to control the
display of plots.
</p>
</li>
<li> <p><code>dev</code>:  used by <code>hook_rgl</code> to set 
the output format.  May be <code>"eps"</code>, <code>"postscript"</code>,
<code>"pdf"</code> or <code>"png"</code> (default:  <code>"png"</code>).
</p>
</li>
<li> <p><code>rgl.keepopen</code>:  no longer used.  Ignored
with a warning.
</p>
</li>
<li> <p><code>fig.alt</code> is partially supported:  <span class="pkg">rgl</span>
will always use the first entry if <code>fig.alt</code> is a vector.
Other graphics types match the entries in <code>fig.alt</code>
to successive plots within the chunk.
(This is due to a limitation in <span class="pkg">knitr</span>, and may
change in the future.)
</p>
</li></ul>



<h3>Value</h3>

<p>A string to be embedded into the output, or <code>NULL</code> if called
when no output is available.
</p>


<h3>Note</h3>

<p>The <code>setupKnitr(autoprint = TRUE)</code> method assumes
<em>all</em> printing of RGL objects happens through 
auto-printing of objects produced by the <code><a href="#topic+lowlevel">lowlevel</a></code>
or <code><a href="#topic+highlevel">highlevel</a></code> functions.  All RGL functions that
produce graphics do this, but functions in other packages that
call them may not return values appropriately.
</p>
<p>Mixing explicit calls
to <code><a href="#topic+rglwidget">rglwidget</a></code> with auto-printing is likely to lead to failure of some
scenes to display.  To avoid this, set <code>options(rgl.printRglwidget = FALSE)</code> before using such explicit calls.  Similarly,
use that option before calling the <code><a href="utils.html#topic+example">example</a></code> function
in a code chunk if the example prints RGL objects.
</p>


<h3>Author(s)</h3>

<p>The <code>hook*</code> functions are originally by Yihui Xie in the <span class="pkg">knitr</span> package; and have been modified by
Duncan Murdoch.  Some parts of the <code>setupKnitr</code> function
duplicate source code from <span class="pkg">knitr</span>.
</p>

<hr>
<h2 id='setUserCallbacks'>
Set mouse callbacks in R or Javascript code
</h2><span id='topic+setUserCallbacks'></span>

<h3>Description</h3>

<p>This function sets user mouse callbacks in R or
<code><a href="#topic+rglwidget">rglwidget</a></code> displays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setUserCallbacks(button, 
                 begin = NULL, 
                 update = NULL, 
                 end = NULL, 
                 rotate = NULL,
                 javascript = NULL, 
                 subscene = scene$rootSubscene$id,
                 scene = scene3d(minimal = FALSE),
                 applyToScene = TRUE,
			           applyToDev = missing(scene))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setUserCallbacks_+3A_button">button</code></td>
<td>

<p>Which button should this callback apply to? Can
be numeric from <code>0:4</code>, or character from <code>"none", "left", "right", "center", "wheel"</code>.
</p>
</td></tr>
<tr><td><code id="setUserCallbacks_+3A_begin">begin</code>, <code id="setUserCallbacks_+3A_update">update</code>, <code id="setUserCallbacks_+3A_end">end</code>, <code id="setUserCallbacks_+3A_rotate">rotate</code></td>
<td>

<p>Functions to call when events occur.  See Details.
</p>
</td></tr>
<tr><td><code id="setUserCallbacks_+3A_javascript">javascript</code></td>
<td>

<p>Optional block of Javascript code to be
included (at the global level).
</p>
</td></tr>
<tr><td><code id="setUserCallbacks_+3A_subscene">subscene</code></td>
<td>

<p>Which subscene do these callbacks apply to?
</p>
</td></tr>
<tr><td><code id="setUserCallbacks_+3A_scene">scene</code></td>
<td>

<p>Which scene?
</p>
</td></tr>
<tr><td><code id="setUserCallbacks_+3A_applytoscene">applyToScene</code></td>
<td>

<p>Should these changes apply to the scene object?
</p>
</td></tr>
<tr><td><code id="setUserCallbacks_+3A_applytodev">applyToDev</code></td>
<td>

<p>Should these changes apply to the current device?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>applyToScene</code> is <code>TRUE</code>, this function adds Javascript 
callbacks to the <code>scene</code> object.  
If <code>applyToDev</code> is <code>TRUE</code>, it adds R
callbacks to the current RGL device.
</p>
<p>For Javascript, 
the callbacks are specified as strings; these will be
evaluated within the browser in the global context to define the functions, 
which will then be called with the Javascript
<code>this</code> object set to the current
<code>rglwidgetClass</code> object.
</p>
<p>For R, they may be strings or R functions.
</p>
<p>Both options may be <code>TRUE</code>, in which case the
callbacks must be specified as strings which are 
both valid Javascript and valid R.  The usual way to
do this is to give just a function name, with the
function defined elsewhere, as in the Example below.
</p>
<p>The <code>begin</code> and <code>update</code> functions should be 
of the form
<code>function(x, y) { ... }</code>.  The <code>end</code> function
will be called with no arguments.  
</p>
<p>The <code>rotate</code> callback can only be set on the 
mouse wheel.  It is called when the mouse 
wheel is rotated.  It should be of the form
<code>function(away)</code>, where <code>away</code> will be 1
while rotating the wheel &ldquo;away&rdquo; from you,
and 2 while rotating it towards you.  If <code>rotate</code>
is not set but other callbacks are set on the wheel
&ldquo;button&rdquo;, then each click of the mouse wheel
will trigger all <code>start</code>, <code>update</code>, 
then <code>end</code> calls in sequence.
</p>
<p>The <code>javascript</code> argument is an optional block 
of code which will be evaluated once during the 
initialization of the widget.  It can define functions
and assign them as members of the <code>window</code> object,
and then the names of those functions can be given 
in the callback arguments; this allows the callbacks
to share information.
</p>


<h3>Value</h3>

<p>Invisibly returns an <code>rglScene</code> object.  This
object will record the changes if <code>applyToScene</code>
is <code>TRUE</code>.
</p>
<p>If <code>applyToDev</code> is <code>TRUE</code>, it will also 
have the side effect of attempting to install the
callbacks using <code><a href="#topic+rgl.setMouseCallbacks">rgl.setMouseCallbacks</a></code>
and <code><a href="#topic+rgl.setWheelCallback">rgl.setWheelCallback</a></code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setAxisCallbacks">setAxisCallbacks</a></code> for user defined axes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # This example identifies points in both the rgl window and
  # in WebGL
  
  verts &lt;- cbind(rnorm(11), rnorm(11), rnorm(11))
  idverts &lt;- plot3d(verts, type = "s", col = "blue")["data"]
  
  # Plot some invisible text; the Javascript will move it
  idtext &lt;- text3d(verts[1,,drop = FALSE], texts = 1, adj = c(0.5, -1.5), alpha = 0)
  
  # Define the R functions to use within R
  fns &lt;- local({
    idverts &lt;- idverts
    idtext &lt;- idtext
    closest &lt;- -1
    update &lt;- function(x, y) {
      save &lt;- par3d(skipRedraw = TRUE)
      on.exit(par3d(save))
      rect &lt;- par3d("windowRect")
      size &lt;- rect[3:4] - rect[1:2]
      x &lt;- x / size[1];
      y &lt;- 1 - y / size[2];
      verts &lt;- rgl.attrib(idverts, "vertices")
      # Put in window coordinates
      vw &lt;- rgl.user2window(verts)
      dists &lt;- sqrt((x - vw[,1])^2 + (y - vw[,2])^2)
      newclosest &lt;- which.min(dists)
      if (newclosest != closest) {
        if (idtext &gt; 0)
          pop3d(id = idtext)
        closest &lt;&lt;- newclosest
        idtext &lt;&lt;- text3d(verts[closest,,drop = FALSE], texts = closest, adj = c(0.5, -1.5))
      }
    }
    end &lt;- function() {
      if (idtext &gt; 0)
        pop3d(id = idtext)
      closest &lt;&lt;- -1
      idtext &lt;&lt;- -1
    }
    list(rglupdate = update, rglend = end)
  })
  rglupdate &lt;- fns$rglupdate
  rglend &lt;- fns$rglend
  
  # Define the Javascript functions with the same names to use in WebGL
  js &lt;-
   ' var idverts = %id%, idtext = %idtext%, closest = -1,
         subid = %subid%;
   
     window.rglupdate = function(x, y) { 
       var   obj = this.getObj(idverts), i, newdist, dist = Infinity, pt, newclosest;
       x = x/this.canvas.width;
       y = y/this.canvas.height;
       
       for (i = 0; i &lt; obj.vertices.length; i++) {
         pt = obj.vertices[i].concat(1);
         pt = this.user2window(pt, subid);
         pt[0] = x - pt[0];
         pt[1] = y - pt[1];
         pt[2] = 0;
         newdist = rglwidgetClass.vlen(pt);
         if (newdist &lt; dist) {
           dist = newdist;
           newclosest = i;
         }
       }

       if (newclosest !== closest) {
         closest = newclosest
         var text = this.getObj(idtext);
         text.vertices[0] = obj.vertices[closest];
         text.colors[0][3] = 1; // alpha is here!
         text.texts[0] = (closest + 1).toString();
         text.initialized = false;
         this.drawScene();
       }
     };
     window.rglend = function() {
       var text = this.getObj(idtext);
       closest = -1;
       text.colors[0][3] = 0;
       text.initialized = false;
       this.drawScene();
     }'
  js &lt;- sub("%id%", idverts, js)  
  js &lt;- sub("%subid%", subsceneInfo()$id, js)
  js &lt;- sub("%idtext%", idtext, js)
    
  # Install both
  setUserCallbacks("left",
                    begin = "rglupdate",
                    update = "rglupdate",
                    end = "rglend",
                    javascript = js)
  rglwidget()
  
  # This example doesn't affect the rgl window, it only modifies
  # the scene object to implement panning
  
  # Define the Javascript functions to use in WebGL
  js &lt;-
  '  window.subid = %subid%;
   
     window.panbegin = function(x, y) {
       var activeSub = this.getObj(subid),
           viewport = activeSub.par3d.viewport,
           activeModel = this.getObj(this.useid(activeSub.id, "model")),
           l = activeModel.par3d.listeners, i;

        this.userSave = {x:x, y:y, viewport:viewport,
                            cursor:this.canvas.style.cursor};
        for (i = 0; i &lt; l.length; i++) {
          activeSub = this.getObj(l[i]);
          activeSub.userSaveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
        }
        this.canvas.style.cursor = "grabbing";
     };
     
     window.panupdate = function(x, y) { 
        var objects = this.scene.objects,
            activeSub = this.getObj(subid),
            activeModel = this.getObj(this.useid(activeSub.id, "model")),
            l = activeModel.par3d.listeners,
            viewport = this.userSave.viewport,
            par3d, i, zoom;
        if (x === this.userSave.x &amp;&amp; y === this.userSave.y)
          return;
        x = (x - this.userSave.x)/this.canvas.width;
        y = (y - this.userSave.y)/this.canvas.height;
        for (i = 0; i &lt; l.length; i++) {
          activeSub = this.getObj(l[i]);
          par3d = activeSub.par3d;
          /* NB:  The right amount of zoom depends on the scaling of the data
                  and the position of the observer.  This might
                  need tweaking.
          */
          zoom = rglwidgetClass.vlen(par3d.observer)*par3d.zoom;
          activeSub.par3d.userMatrix.load(objects[l[i]].userSaveMat);
          activeSub.par3d.userMatrix.translate(zoom*x, zoom*y, 0);
        }
        this.drawScene();
     };
     
     window.panend = function() {
       this.canvas.style.cursor = this.userSave.cursor;
     };
'

js &lt;- sub("%subid%", subsceneInfo()$id, js)

scene &lt;- setUserCallbacks("left", 
                 begin = "panbegin", 
                 update = "panupdate", 
                 end = "panend", 
                 applyToDev = FALSE, javascript = js)
rglwidget(scene)
</code></pre>

<hr>
<h2 id='setUserShaders'>
Set user-defined shaders for RGL objects, or get
shaders.
</h2><span id='topic+setUserShaders'></span><span id='topic+getShaders'></span>

<h3>Description</h3>

<p><code>setUserShaders</code> sets user-defined shaders (programs written in GLSL)
for customized display of RGL objects.  Currently
only supported in WebGL displays, as the regular
displays do not support GLSL.  <code>getShaders</code> gets
the user defined shader, or if it is not present, the
automatically generated one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setUserShaders(ids, vertexShader = NULL, fragmentShader = NULL, 
               attributes = NULL, uniforms = NULL, textures = NULL,
               scene = scene3d(minimal), minimal = TRUE)

getShaders(id, scene = scene3d(minimal), minimal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setUserShaders_+3A_ids">ids</code>, <code id="setUserShaders_+3A_id">id</code></td>
<td>

<p>Which objects should receive the shaders, or which object
should be queried?
</p>
</td></tr>
<tr><td><code id="setUserShaders_+3A_vertexshader">vertexShader</code>, <code id="setUserShaders_+3A_fragmentshader">fragmentShader</code></td>
<td>

<p>The vertex and fragment shader source code.  If <code>NULL</code>, the
automatically generated shader will be used instead.
</p>
</td></tr>
<tr><td><code id="setUserShaders_+3A_attributes">attributes</code></td>
<td>

<p>A named list of &ldquo;attributes&rdquo; to attach to each vertex.
</p>
</td></tr>
<tr><td><code id="setUserShaders_+3A_uniforms">uniforms</code></td>
<td>

<p>A named list of &ldquo;uniforms&rdquo;.
</p>
</td></tr>
<tr><td><code id="setUserShaders_+3A_textures">textures</code></td>
<td>

<p>A named list of textures.
</p>
</td></tr>
<tr><td><code id="setUserShaders_+3A_scene">scene</code></td>
<td>

<p>A <code><a href="#topic+scene3d">scene3d</a></code> object to work with.
</p>
</td></tr>
<tr><td><code id="setUserShaders_+3A_minimal">minimal</code></td>
<td>

<p>See <code><a href="#topic+scene3d">scene3d</a></code>.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modern versions of OpenGL work with &ldquo;shaders&rdquo;, 
programs written to run on the graphics processor.  The
vertex shader does the calculations to move vertices and
set their intrinsic colours.  The fragment shader
computes how each pixel in the display will be shown,
taking into account lighting, material properties, etc.
(More precisely, it does the computation for each &ldquo;fragment&rdquo;; a fragment is a pixel within an object to display.
There may be many objects at a particular location, and
each will result in a fragment calculation unless culled
by z-buffering or being discarded in some other way.)
</p>
<p>Normally the WebGL Javascript code uses the default
shaders stored in 
<code>system.file("htmlwidgets/lib/rglClass/shaders", 
package = "rgl")</code>.  This function allows them to be written
by hand, for testing new features, hand optimization, etc.
The defines used by the default shaders will also be prepended
to user shaders, which can use them for customization on
an object-by-object basis.
</p>
<p>The names used for the <code>attributes</code>, <code>uniforms</code>
and <code>textures</code> should match names in the shaders
for corresponding variables.  (The texture names should be
names of <code>uniform sampler2D</code> variables.)
</p>


<h3>Value</h3>

<p>A modified version of the <code>scene</code>.
</p>


<h3>Note</h3>

<p>The <code>getShaders</code> function requires the <span class="pkg">V8</span> package
to extract auto-generated shaders, since the defines
are generated by Javascript code.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rglwidget">rglwidget</a></code> for display of the scene in WebGL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
id &lt;- shade3d(octahedron3d(), col = "red")

# For each triangle, set weights on the 3 vertices.
# This will be replicated to the appropriate size in Javascript.
wts &lt;- diag(3)

# This leaves out the centres of each face
vs &lt;- "
  attribute vec3 aPos;
  attribute vec4 aCol;
  uniform mat4 mvMatrix;
  uniform mat4 prMatrix;
  varying vec4 vCol;
  varying vec4 vPosition;
  attribute vec3 aNorm;
  uniform mat4 normMatrix;
  varying vec3 vNormal;
  attribute vec3 wts;
  varying vec3 vwts;
  void main(void) {
    vPosition = mvMatrix * vec4(aPos, 1.);
    gl_Position = prMatrix * vPosition;
    vCol = aCol;
    vNormal = normalize((normMatrix * vec4(aNorm, 1.)).xyz);
    vwts = wts;
  }
"  
fs &lt;- "
  #ifdef GL_ES
  precision highp float;
  #endif
  varying vec4 vCol; // carries alpha
  varying vec4 vPosition;
  varying vec3 vNormal;
  uniform mat4 mvMatrix;
  uniform vec3 emission;
  uniform float shininess;
  uniform vec3 ambient[NLIGHTS];
  uniform vec3 specular[NLIGHTS]; // light*material
  uniform vec3 diffuse[NLIGHTS];
  uniform vec3 lightDir[NLIGHTS];
  uniform bool viewpoint[NLIGHTS];
  uniform bool finite[NLIGHTS];
  varying vec3 vwts;
  uniform vec2 wtrange;
  void main(void) {
    float minwt = min(vwts.x, min(vwts.y, vwts.z));
    if (minwt &lt; wtrange.x || minwt &gt; wtrange.y) discard;
    vec3 eye = normalize(-vPosition.xyz);
    vec3 lightdir;
    vec4 colDiff;
    vec3 halfVec;
    vec4 lighteffect = vec4(emission, 0.);
    vec3 col;
    float nDotL;
    vec3 n = normalize(vNormal);
    n = -faceforward(n, n, eye);
    colDiff = vec4(vCol.rgb * diffuse[0], vCol.a);
    lightdir = lightDir[0];
    if (!viewpoint[0])
      lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;
    if (!finite[0]) {
      halfVec = normalize(lightdir + eye);
    } else {
      lightdir = normalize(lightdir - vPosition.xyz);
      halfVec = normalize(lightdir + eye);
    }
    col = ambient[0];
    nDotL = dot(n, lightdir);
    col = col + max(nDotL, 0.) * colDiff.rgb;
    col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[0];
    lighteffect = lighteffect + vec4(col, colDiff.a);
    gl_FragColor = lighteffect;
  }
"
x &lt;- setUserShaders(id, vs, fs, attributes = list(wts=wts),
                    uniforms = list(wtrange = c(-0.01, 0.15)))
if (interactive() || in_pkgdown_example())
  rglwidget(x)
</code></pre>

<hr>
<h2 id='shade3d'>Draw 3D mesh objects</h2><span id='topic+dot3d'></span><span id='topic+dot3d.mesh3d'></span><span id='topic+wire3d'></span><span id='topic+wire3d.mesh3d'></span><span id='topic+shade3d'></span><span id='topic+shade3d.mesh3d'></span>

<h3>Description</h3>

<p>Draws 3D mesh objects in full, or just the edges, or just 
the vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dot3d(x, ...)   # draw dots at the vertices of an object
  ## S3 method for class 'mesh3d'
dot3d(x, ...,
                         front = "points", back = "points")
  wire3d(x, ...)  # draw a wireframe object
  ## S3 method for class 'mesh3d'
wire3d(x, ...,
                          front = "lines", back = "lines")
  shade3d(x, ...) # draw a shaded object
  ## S3 method for class 'mesh3d'
shade3d(x, override = TRUE, 
                           meshColor = c("vertices", "edges", "faces", "legacy"), 
                           texcoords = NULL, ...,
                           front = "filled", back = "filled")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shade3d_+3A_x">x</code></td>
<td>
<p>a <code>mesh3d</code> object.</p>
</td></tr>
<tr><td><code id="shade3d_+3A_...">...</code></td>
<td>
<p>additional rendering parameters, or for
<code>dots3d</code> and <code>wire3d</code>, parameters to pass
to <code>shade3d</code></p>
</td></tr>
<tr><td><code id="shade3d_+3A_override">override</code></td>
<td>
<p>should the parameters specified here override those stored in the object?</p>
</td></tr>
<tr><td><code id="shade3d_+3A_meshcolor">meshColor</code></td>
<td>
<p>how should colours be interpreted?  See details 
below</p>
</td></tr>
<tr><td><code id="shade3d_+3A_texcoords">texcoords</code></td>
<td>
<p>texture coordinates at each vertex.</p>
</td></tr>
<tr><td><code id="shade3d_+3A_front">front</code>, <code id="shade3d_+3A_back">back</code></td>
<td>
<p>Material properties for rendering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>meshColor</code> argument controls how material colours and textures are interpreted.  This parameter
was added in <span class="pkg">rgl</span> version 0.100.1 (0.100.27 for <code>dot3d</code>).  Possible values are:
</p>

<dl>
<dt><code>"vertices"</code></dt><dd><p>Colours and texture coordinates are applied by vertex, in the order
they appear in the <code>x$vb</code> matrix.</p>
</dd>
<dt><code>"edges"</code></dt><dd><p>Colours are applied to each edge:  first to the segments in the <code>x$is</code> matrix, then
the 
3 edges of each triangle in the <code>x$it</code> matrix, then the 4
edges of each quad in the <code>x$ib</code> matrix.  This mode
is only supported if both front and back materials are
<code>"lines"</code>, and the mesh contains no points.</p>
</dd>
<dt><code>"faces"</code></dt><dd><p>Colours are applied to each object
in the mesh:  first to the points, then the segments, 
triangles and finally quads.  The entire whole face (or point or
segment) receives one colour from the specified colours.</p>
</dd>
<dt><code>"legacy"</code></dt><dd><p>Colours and textures are applied in the same way
as in <span class="pkg">rgl</span> versions earlier than 0.100.1.</p>
</dd>
</dl>

<p>Unique partial matches of these values will be recognized.
</p>
<p>If colours are specified but <code>meshColor</code> is not
and <code>options(rgl.meshColorWarning = TRUE)</code>,
a warning will be given that their
interpretation may have changed.  In versions 0.100.1 to 0.100.26
of <span class="pkg">rgl</span>, the default
was to give the warning; now the default is for no warning.
</p>
<p>Note that since version 0.102.10, <code>meshColor = 
"edges"</code> is only allowed when drawing lines (the
<code>wire3d</code> default), and it may draw
edges more than once.  In general, if any rendering
draws twice at the same location, which copy is visible 
depends on the order of drawing and the
<code><a href="#topic+material3d">material3d</a>("depth_test")</code>
setting.  
</p>
<p>Whether points, lines or solid faces are drawn is
determined in 3 steps:
</p>

<ol>
<li><p>If arguments <code>"front"</code> or <code>"back"</code> are
specified in the call, those are used.
</p>
</li>
<li><p>If one or both of those arguments are not
specified, but the material properties are present in
the object, those are used.
</p>
</li>
<li><p>If values are not specified in either of those
places, <code>shade3d</code> draws filled surfaces,
<code>wire3d</code> draws lines, and <code>dot3d</code> draws points.

</p>
</li></ol>

<p>Note:  For some versions of rgl up to version 0.107.15, 
rule 2 above was not respected.
</p>


<h3>Value</h3>

<p><code>dot3d</code>, <code>wire3d</code>, and <code>shade3d</code> are called for their side effect
of drawing an object into the scene; they return an object ID (or vector of IDs) invisibly.
</p>
<p>See <a href="#topic+primitives">primitives</a> for a discussion of texture coordinates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mesh3d">mesh3d</a></code>, <code><a href="#topic+par3d">par3d</a></code>, <code><a href="#topic+shapelist3d">shapelist3d</a></code> for multiple shapes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # generate a quad mesh object

  vertices &lt;- c( 
     -1.0, -1.0, 0,
      1.0, -1.0, 0,
      1.0,  1.0, 0,
     -1.0,  1.0, 0
  )
  indices &lt;- c( 1, 2, 3, 4 )
  
  open3d()  
  wire3d( mesh3d(vertices = vertices, quads = indices) )
  
  # render 4 meshes vertically in the current view

  open3d()  
  bg3d("gray")
  l0 &lt;- oh3d(tran = par3d("userMatrix"), color = "green" )
  shade3d( translate3d( l0, -6, 0, 0 ))
  l1 &lt;- subdivision3d( l0 )
  shade3d( translate3d( l1 , -2, 0, 0 ), color = "red", override = FALSE )
  l2 &lt;- subdivision3d( l1 )
  shade3d( translate3d( l2 , 2, 0, 0 ), color = "red", override = TRUE )
  l3 &lt;- subdivision3d( l2 )
  shade3d( translate3d( l3 , 6, 0, 0 ), color = "red" )
  
  # render all of the Platonic solids
  open3d()
  shade3d( translate3d( tetrahedron3d(col = "red"), 0, 0, 0) )
  shade3d( translate3d( cube3d(col = "green"), 3, 0, 0) )
  shade3d( translate3d( octahedron3d(col = "blue"), 6, 0, 0) )
  shade3d( translate3d( dodecahedron3d(col = "cyan"), 9, 0, 0) )
  shade3d( translate3d( icosahedron3d(col = "magenta"), 12, 0, 0) )
</code></pre>

<hr>
<h2 id='shadow3d'>
Project shadows of mesh onto object.
</h2><span id='topic+shadow3d'></span>

<h3>Description</h3>

<p>Project a mesh onto a surface in a scene so that it appears to cast a shadow onto the surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shadow3d(obj, mesh, plot = TRUE, up = c(0, 0, 1),
         P = projectDown(up), outside = FALSE,
         ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shadow3d_+3A_obj">obj</code></td>
<td>

<p>The target object which will show the shadow.
</p>
</td></tr>
<tr><td><code id="shadow3d_+3A_mesh">mesh</code></td>
<td>

<p>The mesh which will cast the shadow.
</p>
</td></tr>
<tr><td><code id="shadow3d_+3A_plot">plot</code></td>
<td>

<p>Whether to plot the result.
</p>
</td></tr>
<tr><td><code id="shadow3d_+3A_up">up</code></td>
<td>

<p>Which direction is &ldquo;up&rdquo;?
</p>
</td></tr>
<tr><td><code id="shadow3d_+3A_p">P</code></td>
<td>

<p>The projection to use for draping, a 4x4 matrix.  See <code><a href="#topic+drape3d">drape3d</a></code> for details on how <code>P</code> is used.
</p>
</td></tr>
<tr><td><code id="shadow3d_+3A_outside">outside</code></td>
<td>

<p>Should the function compute and (possibly) plot the region
outside of the shadow?
</p>
</td></tr>
<tr><td><code id="shadow3d_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to <code><a href="#topic+filledContour3d">filledContour3d</a></code>,
which will do the boundary calculations and plotting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>shadow3d</code> internally constructs a function that 
is zero on the boundary of the shadow and positive inside, 
then draws filled contours of that function.  Because the
function is nonlinear, the boundaries will be approximate,
with the best approximation resulting from a large
value of <code><a href="#topic+filledContour3d">filledContour3d</a></code> parameter <code>minVertices</code>.
</p>
<p>If <code>outside = TRUE</code>, the first color used by
<code><a href="#topic+filledContour3d">filledContour3d</a></code> will indicate the inside
of the shadow, and the second color will indicate the exterior.
</p>


<h3>Value</h3>

<p>The returned value from <code><a href="#topic+filledContour3d">filledContour3d</a></code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drape3d">drape3d</a></code>, <code><a href="#topic+facing3d">facing3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
obj &lt;- translate3d(scale3d(oh3d(), 0.3, 0.3, 0.3), 0,0,2)
shade3d(obj, col = "red")
target &lt;- icosahedron3d()

# We offset the target using polygon_offset = 1 so that the
# shadow on its surface will appear clearly.

shade3d(target, col = "white", polygon_offset = 1)

# minVertices = 1000 leaves noticeable artifacts on the edges
# of the shadow.  A larger value gives a better result, but is
# slower.

# We use facing3d(target) so the shadow and outside part only 
# appear on the upper side of the target

shadow3d(facing3d(target), obj, minVertices = 1000, plot=TRUE,
         col = c("yellow", "blue"), outside = TRUE)
</code></pre>

<hr>
<h2 id='shapelist3d'> Create and plot a list of shapes </h2><span id='topic+shapelist3d'></span>

<h3>Description</h3>

<p>These functions create and plot a list of shapes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapelist3d(shapes, x = 0, y = NULL, z = NULL, size = 1, matrix = NULL, override = TRUE, 
            ..., plot = TRUE)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shapelist3d_+3A_shapes">shapes</code></td>
<td>
<p> A single <code>shape3d</code> object, or a list of them. </p>
</td></tr>
<tr><td><code id="shapelist3d_+3A_x">x</code>, <code id="shapelist3d_+3A_y">y</code>, <code id="shapelist3d_+3A_z">z</code></td>
<td>
<p> Translation(s) to apply </p>
</td></tr>
<tr><td><code id="shapelist3d_+3A_size">size</code></td>
<td>
<p> Scaling(s) to apply </p>
</td></tr>
<tr><td><code id="shapelist3d_+3A_matrix">matrix</code></td>
<td>
<p> A single matrix transformation, or a list of them. </p>
</td></tr>
<tr><td><code id="shapelist3d_+3A_override">override</code></td>
<td>
<p> Whether the material properties should override the ones in the shapes. </p>
</td></tr>
<tr><td><code id="shapelist3d_+3A_...">...</code></td>
<td>
<p> Material properties to apply. </p>
</td></tr>
<tr><td><code id="shapelist3d_+3A_plot">plot</code></td>
<td>
<p> Whether to plot the result. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>shapelist3d</code> is a quick way to create a complex object made up of simpler ones.
Each of the arguments <code>shapes</code> through <code>override</code> may be a vector of 
values (a list in the case of <code>shapes</code> or <code>matrix</code>).  All values
will be recycled to produce a list of shapes as long as the longest of them.
</p>
<p>The <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code> function will be used to process the <code>x</code>,
<code>y</code> and <code>z</code> arguments, so a matrix may be used as <code>x</code> to 
specify all three.   If a vector is used for <code>x</code> but <code>y</code> or <code>z</code>
is missing, default values of <code>0</code> will be used.
</p>
<p>The <code>"shapelist3d"</code> class is simply a list of <code>"shape3d"</code> objects.
</p>
<p>Methods for <code><a href="#topic+dot3d">dot3d</a></code>, <code><a href="#topic+wire3d">wire3d</a></code>, <code><a href="#topic+shade3d">shade3d</a></code>,
<code><a href="#topic+translate3d">translate3d</a></code>, <code><a href="#topic+scale3d">scale3d</a></code>, and <code><a href="#topic+rotate3d">rotate3d</a></code>
are defined for these objects.
</p>


<h3>Value</h3>

<p>An object of class <code>c("shapelist3d", "shape3d")</code>.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

 <p><code><a href="#topic+mesh3d">mesh3d</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
open3d() 
shapelist3d(icosahedron3d(), x = rnorm(10), y = rnorm(10), z = rnorm(10), col = 1:5, size = 0.3)

</code></pre>

<hr>
<h2 id='shiny'>
Functions for integration of RGL widgets into
Shiny app
</h2><span id='topic+rglwidgetOutput'></span><span id='topic+renderRglwidget'></span><span id='topic+playwidgetOutput'></span><span id='topic+renderPlaywidget'></span>

<h3>Description</h3>

<p>These functions allow an RGL scene to be embedded
in a Shiny app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglwidgetOutput(outputId, width = "512px", height = "512px")
renderRglwidget(expr, env = parent.frame(), quoted = FALSE, outputArgs = list())

playwidgetOutput(outputId, width = "0px", height = "0px")
renderPlaywidget(expr, env = parent.frame(), quoted = FALSE, outputArgs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shiny_+3A_outputid">outputId</code></td>
<td>

<p>The name for the control.
</p>
</td></tr>
<tr><td><code id="shiny_+3A_width">width</code>, <code id="shiny_+3A_height">height</code></td>
<td>

<p>Width and height to display the control.
</p>
</td></tr>
<tr><td><code id="shiny_+3A_expr">expr</code></td>
<td>
<p>An R expression returning
a <code><a href="#topic+rglwidget">rglwidget</a></code> (for <code>renderRglwidget</code>) or a <code><a href="#topic+playwidget">playwidget</a></code> (for <code>renderPlaywidget</code>) as output.</p>
</td></tr>
<tr><td><code id="shiny_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate <code>expr</code>.</p>
</td></tr>
<tr><td><code id="shiny_+3A_quoted">quoted</code></td>
<td>
<p>Is the expression already quoted?</p>
</td></tr>
<tr><td><code id="shiny_+3A_outputargs">outputArgs</code></td>
<td>
<p>A list containing arguments; see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>rglwidgetOutput</code> or <code>playwidgetOutput</code> as an output
object in a Shiny user
interface section; use <code>renderRglwidget</code> or <code>renderPlaywidget</code>
as the render
function in the server section.
</p>
<p>In a dynamic R Markdown document with <code>runtime: shiny</code>, you 
only call the render function, and may optionally pass <code>width</code>
and <code>height</code> to the output function by putting them in
a list in <code>outputArgs</code>.  See the example below.
</p>


<h3>Value</h3>

<p>Used internally by Shiny.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This could be used in a dynamic R Markdown document.  See
# demo("shinyDemo") and demo("simpleShinyRgl") for Shiny apps.

inputPanel(
  sliderInput("n", label = "n", min = 10, max = 100, value = 10, step = 10)
)

renderRglwidget({
    n &lt;- input$n
    try(close3d())
    plot3d(rnorm(n), rnorm(n), rnorm(n))
    rglwidget()
  }, outputArgs = list(width = "auto", height = "300px"))


## End(Not run)
</code></pre>

<hr>
<h2 id='shinyGetPar3d'>
Communicate RGL parameters between R and Javascript in Shiny
</h2><span id='topic+shinyGetPar3d'></span><span id='topic+shinySetPar3d'></span><span id='topic+shinyResetBrush'></span>

<h3>Description</h3>

<p>These functions allow Shiny apps to read and write the <code>par3d</code>
settings that may have been modified by user interaction in the browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shinyGetPar3d(parameters, session, subscene = currentSubscene3d(cur3d()), tag = "")
shinySetPar3d(..., session, subscene = currentSubscene3d(cur3d()))
shinyResetBrush(session, brush)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shinyGetPar3d_+3A_parameters">parameters</code></td>
<td>

<p>A character vector naming the parameters to get.
</p>
</td></tr>
<tr><td><code id="shinyGetPar3d_+3A_session">session</code></td>
<td>

<p>The Shiny session object.
</p>
</td></tr>
<tr><td><code id="shinyGetPar3d_+3A_subscene">subscene</code></td>
<td>

<p>The subscene to which the parameters apply.  Defaults to 
the currently active subscene in the R session.
</p>
</td></tr>
<tr><td><code id="shinyGetPar3d_+3A_tag">tag</code></td>
<td>

<p>An arbitrary string or value which will be sent as part of the
response.
</p>
</td></tr>
<tr><td><code id="shinyGetPar3d_+3A_...">...</code></td>
<td>

<p>A number of <code>name = value</code> pairs to be modified, or a
single named list of parameters.  Entries named <code>tag</code>
or <code>subscene</code> will be ignored.
</p>
</td></tr>
<tr><td><code id="shinyGetPar3d_+3A_brush">brush</code></td>
<td>
<p>The name of a Shiny input element corresponding to
the <code>shinyBrush</code> argument to <code><a href="#topic+rglwidget">rglwidget</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requesting information from the browser is a complicated process.
The <code>shinyGetPar3d</code> function doesn't return the requested value,
it just submits a request for the value to be returned later in
<code>input$par3d</code>, a reactive input.  No action will result
except when a reactive observer depends on <code>input$par3d</code>.
See the example code below.
</p>
<p>The <code>shinySetPar3d</code> function sends a message to the browser
asking it to change a particular parameter.  The change will be
made immediately, without sending the full scene to the browser,
so should be reasonably fast.
</p>


<h3>Value</h3>

<p>These functions are called for their side effects, and don't return
useful values.
</p>
<p>The side effect of <code>shinyGetPar3d</code> is to cause <code>input$par3d</code>
to be updated sometime later.  
Besides the requested parameter values, <code>input$par3d</code> will
contain a copy of the <code>subscene</code> and <code>tag</code> arguments.
</p>
<p>The side effect of <code>shinySetPar3d</code> is to send a message to the
browser to update its copy of the <code>par3d</code> parameters 
immediately.
</p>


<h3>Note</h3>

<p>R and the browser don't maintain a perfect match between the way
parameters are stored internally.  The browser version of parameters
will be returned by <code>shinyGetPar3d</code> and should be supplied to
<code>shinySetPar3d</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p><a href="https://shiny.rstudio.com/articles/communicating-with-js.html">https://shiny.rstudio.com/articles/communicating-with-js.html</a>
describes the underlying mechanisms used by these two functions.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+rglwidget">rglwidget</a></code> argument <code>shinySelectionInput</code> allows information about mouse selections
to be returned to R.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive() &amp;&amp; !in_pkgdown_example() &amp;&amp; requireNamespace("shiny")) {
  save &lt;- options(rgl.useNULL = TRUE)

  xyz &lt;- matrix(rnorm(300), ncol = 3)

  app = shiny::shinyApp(
    ui = shiny::bootstrapPage(
      shiny::actionButton("redraw", "Redraw"),
      rglwidgetOutput("rglPlot")
    ),
    server = function(input, output, session) {
      # This waits until the user to click on the "redraw" 
      # button, then sends a request for the current userMatrix
      shiny::observeEvent(input$redraw, {
        shinyGetPar3d("userMatrix", session)
      })
    
      # This draws the plot whenever input$par3d changes,
      # i.e. whenever a response to the request above is
      # received.
      output$rglPlot &lt;- renderRglwidget({
        if (length(rgl.dev.list())) close3d()
        col &lt;- sample(colors(), 1)
        plot3d(xyz, col = col, type = "s", main = col)
        par3d(userMatrix = input$par3d$userMatrix)
        rglwidget()
      })
    })
  shiny::runApp(app)
  options(save)
}
</code></pre>

<hr>
<h2 id='show2d'>
Draw a 2D plot on a rectangle in a 3D scene
</h2><span id='topic+show2d'></span>

<h3>Description</h3>

<p>This function uses a bitmap of a standard 2D graphics plot
as a texture on a quadrilateral.  Default arguments are
set up so that it will appear on the face of the bounding
box of the current 3D plot, but optional arguments allow
it to be placed anywhere in the scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show2d(expression, 
  face = "z-", line = 0, 
  reverse = FALSE, rotate = 0, 
  x = NULL, y = NULL, z = NULL, 
  width = 480, height = 480, 
  filename = NULL, 
  ignoreExtent = TRUE, 
  color = "white", specular = "black", lit = FALSE, 
  texmipmap = TRUE, texminfilter = "linear.mipmap.linear",
  expand = 1.03,
  texcoords = matrix(c(0, 1, 1, 0, 0, 0, 1, 1), ncol = 2),  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show2d_+3A_expression">expression</code></td>
<td>

<p>Any plotting commands to produce a plot in standard graphics.
Ignored if <code>filename</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="show2d_+3A_face">face</code></td>
<td>

<p>A character string defining which face of the bounding
box to use.  See Details below.
</p>
</td></tr>
<tr><td><code id="show2d_+3A_line">line</code></td>
<td>

<p>How far out from the bounding box should the quadrilateral
be placed?  Uses same convention as <code><a href="#topic+mtext3d">mtext3d</a></code>:
not lines of text, but fraction of the bounding box size.
</p>
</td></tr>
<tr><td><code id="show2d_+3A_reverse">reverse</code>, <code id="show2d_+3A_rotate">rotate</code></td>
<td>
 
<p>Should the image be reversed or rotated?  See Details below.
</p>
</td></tr>
<tr><td><code id="show2d_+3A_x">x</code>, <code id="show2d_+3A_y">y</code>, <code id="show2d_+3A_z">z</code></td>
<td>

<p>Specific values to use to override <code>face</code>.
</p>
</td></tr>
<tr><td><code id="show2d_+3A_width">width</code>, <code id="show2d_+3A_height">height</code></td>
<td>

<p>Parameters to pass to <code><a href="grDevices.html#topic+png">png</a></code> when creating the
bitmap.  See Details below.
</p>
</td></tr>
<tr><td><code id="show2d_+3A_filename">filename</code></td>
<td>

<p>A &lsquo;<span class="file">.png</span>&rsquo; file image to use as the texture.
</p>
</td></tr>
<tr><td><code id="show2d_+3A_ignoreextent">ignoreExtent</code></td>
<td>

<p>Whether the quadrilateral should be ignored when computing
the bounding box of the scene.
</p>
</td></tr>
<tr><td><code id="show2d_+3A_color">color</code>, <code id="show2d_+3A_specular">specular</code>, <code id="show2d_+3A_lit">lit</code>, <code id="show2d_+3A_texmipmap">texmipmap</code>, <code id="show2d_+3A_texminfilter">texminfilter</code>, <code id="show2d_+3A_...">...</code></td>
<td>

<p>Material properties to use for the quadrilateral.
</p>
</td></tr>
<tr><td><code id="show2d_+3A_expand">expand</code></td>
<td>
<p>Amount by which the quadrilateral is 
expanded outside the bounding box of the data.
</p>
</td></tr>
<tr><td><code id="show2d_+3A_texcoords">texcoords</code></td>
<td>
<p>Coordinates on the image.  Lower left
of the bitmap is <code>c(0,0)</code>, upper right is <code>c(1,1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default arguments are chosen to make it easy to place
a 2D image on the face of the bounding box.  If <code>x</code>, 
<code>y</code> and <code>z</code> are <code>NULL</code> (the defaults),
<code>face</code> will be used as a code for one of the
six faces of the bounding box.  The first letter should
be <code>"x"</code>, <code>"y"</code> or <code>"z"</code>; this defines 
the axis perpendicular to the desired face.  If the
second letter is <code>"-"</code> or is missing, the face
will be chosen to be the face with the lower value 
on that axis.  Any other letter will use the opposite 
face.
</p>
<p>If any of  <code>x</code>, <code>y</code> or <code>z</code> is given, the
specified value will be used to replace the value calculated 
above.  Usually four values should be given, corresponding to
the coordinates of the lower left, lower right, upper right
and upper left of the destination for the image before
<code>reverse</code> and <code>rotate</code> are used.  Fewer values
can be used for one or two coordinates; <code><a href="base.html#topic+cbind">cbind</a></code>
will be used to put together all 3 coordinates into
a 4 by 3 matrix (which will be returned as an attribute
of the result).
</p>
<p>The bitmap plot will by default be oriented so that it is
properly oriented when viewed from the
direction of the higher values of the perpendicular coordinate,
and its lower left corner is at the lower value of the two
remaining coordinates.  The argument <code>reverse</code> causes
the orientation to be mirrored, and <code>rotate</code> causes it
to be rotated by multiples of 90 degrees.  <code>rotate</code> should be an integer,
with <code>0</code> for no rotation, <code>1</code> for a 90 degree
counter-clockwise rotation, etc.
</p>
<p>The <code>width</code> and <code>height</code> arguments control the shape
and resolution of the bitmap.  The defaults give a square
bitmap, which is appropriate with the usual <code>c(1,1,1)</code>
aspect ratios (see <code>aspect3d</code>).  Some tuning may be 
needed to choose the resolution.  The plot will look best when
displayed at its original size; shrinking it smaller tends to make
it look faded, while expanding it bigger will make it look 
blurry.  If <code>filename</code> is given, the width and height
will be taken from the file, and <code>width</code> and <code>height</code>
arguments will be ignored.
</p>


<h3>Value</h3>

<p>Invisibly returns the id value of the quadrilateral,
with the following attributes:
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The value returned by <code>expression</code>.</p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p>A 4 by 3 matrix giving the coordinates of the corners
as used in plotting.</p>
</td></tr>
<tr><td><code>texcoords</code></td>
<td>
<p>A 4 by 2 matrix giving the texture coordinates
of the image.</p>
</td></tr>
<tr><td><code>filename</code></td>
<td>
<p>The filename for the temporary file holding
the bitmap image.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgplot3d">bgplot3d</a></code> uses a plot as the background for the window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(plot3d, ask = FALSE)
show2d({
  par(mar=c(0,0,0,0))
  plot(x, y, col = rainbow(1000), axes=FALSE)
  })
</code></pre>

<hr>
<h2 id='snapshot3d'>Export screenshot</h2><span id='topic+rgl.snapshot'></span><span id='topic+snapshot3d'></span><span id='topic+RGL_USE_WEBSHOT'></span>

<h3>Description</h3>

<p>Saves the screenshot to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl.snapshot( filename, fmt = "png", top = TRUE )
snapshot3d( filename = tempfile(fileext = ".png"), 
            fmt = "png", top = TRUE,
            ..., scene, width = NULL, height = NULL,
            webshot = as.logical(Sys.getenv("RGL_USE_WEBSHOT", "TRUE")) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snapshot3d_+3A_filename">filename</code></td>
<td>
<p>path to file to save.</p>
</td></tr>
<tr><td><code id="snapshot3d_+3A_fmt">fmt</code></td>
<td>
<p>image export format, currently supported: png.  Ignored if <code>webshot = TRUE</code>. </p>
</td></tr>
<tr><td><code id="snapshot3d_+3A_top">top</code></td>
<td>
<p>whether to call <code><a href="#topic+rgl.bringtotop">rgl.bringtotop</a></code>.
Ignored if <code>webshot = TRUE</code>.</p>
</td></tr>
<tr><td><code id="snapshot3d_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code>webshot2::webshot</code> </p>
</td></tr>
<tr><td><code id="snapshot3d_+3A_scene">scene</code></td>
<td>
<p>an optional result of <code><a href="#topic+scene3d">scene3d</a></code> 
or <code><a href="#topic+rglwidget">rglwidget</a></code> to plot</p>
</td></tr>
<tr><td><code id="snapshot3d_+3A_width">width</code>, <code id="snapshot3d_+3A_height">height</code></td>
<td>
<p>optional specifications of output
size in pixels</p>
</td></tr>
<tr><td><code id="snapshot3d_+3A_webshot">webshot</code></td>
<td>
<p>Use the <span class="pkg">webshot2</span> package to take the 
snapshot</p>
</td></tr>  
</table>


<h3>Details</h3>

<p><code>rgl.snapshot()</code> is a low-level function
that copies the current RGL window from the screen.  Users
should use <code>snapshot3d()</code> instead; it is more flexible,
and (if <span class="pkg">webshot2</span> is installed) can take images even if
no window is showing, and they can be larger than the physical
screen.
</p>
<p>Animations can be created in a loop modifying the scene and saving 
each screenshot to a file. Various graphics programs (e.g. ImageMagick)
can put these together into a single animation. (See <code><a href="#topic+movie3d">movie3d</a></code> or
the example below.)
</p>


<h3>Value</h3>

<p>These functions are mainly called for the side effects.  The
filename of the saved file is returned invisibly.
</p>


<h3>Note</h3>

<p>When <code>rgl.useNULL()</code> is <code>TRUE</code>, only <code>webshot = TRUE</code>
will produce a snapshot.  It requires the <span class="pkg">webshot2</span>
package and a Chrome browser.  If no suitable browser is
found, <code>snapshot3d()</code> will revert to <code>rgl.snapshot()</code>.
To override the automatic search, set
environment variable <span class="env">CHROMOTE_CHROME</span>
to the path to a suitable browser.
</p>
<p><code>rgl.snapshot</code> works by taking an image from the displayed
window on-screen.
On some systems, the snapshot
will include content from other windows if they cover the active RGL
window.  Setting <code>top = TRUE</code> (the default) will use 
<code><a href="#topic+rgl.bringtotop">rgl.bringtotop</a></code> before the snapshot
to avoid this.  
</p>
<p>There are likely limits to how large <code>width</code> and
<code>height</code> can be set based on the display hardware; if these
are exceeded the results are undefined.  A typical result
is that the snapshot will still be made but at a smaller
size.
</p>
<p>There are slight differences between the displays with
<code>webshot = TRUE</code> and <code>webshot = FALSE</code>, as the 
former are rendered using WebGL while the latter are rendered
using OpenGL.  Often the <code>webshot = TRUE</code> displays
have better quality, but they are usually slower to
produce, sometimes drastically so.  
</p>
<p>Set the environment
variable <span class="env">RGL_USE_WEBSHOT</span> to <code>"FALSE"</code> if
you want <code>rgl.snapshot</code> to be used by default.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+movie3d">movie3d</a></code>, <code><a href="#topic+view3d">view3d</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive() &amp;&amp; !in_pkgdown_example()) {
  saveopts &lt;- options(rgl.useNULL = TRUE)
  plot3d(matrix(rnorm(300), ncol = 3, dimnames = list(NULL, c("x", "y", "z"))), 
         col = "red")
  options(saveopts)
  browseURL(snapshot3d())
}

## Not run: 

#
# create animation
#

shade3d(oh3d(), color = "red")
rgl.bringtotop()
view3d(0, 20)

olddir &lt;- setwd(tempdir())
for (i in 1:45) {
  view3d(i, 20)
  filename &lt;- paste("pic", formatC(i, digits = 1, flag = "0"), ".png", sep = "")
  snapshot3d(filename)
}
## Now run ImageMagick in tempdir().  Use 'convert' instead of 'magick'
## if you have an older version of ImageMagick:
##    magick -delay 10 *.png -loop 0 pic.gif
setwd(olddir)

## End(Not run)

</code></pre>

<hr>
<h2 id='spheres3d'>Add spheres</h2><span id='topic+spheres3d'></span>

<h3>Description</h3>

<p>Adds a sphere set shape node to the scene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spheres3d(x, y = NULL, z = NULL, radius = 1, fastTransparency = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spheres3d_+3A_x">x</code>, <code id="spheres3d_+3A_y">y</code>, <code id="spheres3d_+3A_z">z</code></td>
<td>
<p>Numeric vector of point coordinates corresponding to
the center of each sphere.  Any reasonable way of defining the
coordinates is acceptable.  See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>
for details.</p>
</td></tr>
<tr><td><code id="spheres3d_+3A_radius">radius</code></td>
<td>
<p>Vector or single value defining the sphere radius/radii</p>
</td></tr>
<tr><td><code id="spheres3d_+3A_fasttransparency">fastTransparency</code></td>
<td>
<p>logical value indicating whether
fast sorting should be used for transparency.  See the Details.</p>
</td></tr>
<tr><td><code id="spheres3d_+3A_...">...</code></td>
<td>
<p>Material properties. See <code><a href="#topic+material3d">material3d</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a non-isometric aspect ratio is chosen, these functions will still draw
objects that appear to the viewer to be spheres.  Use <code><a href="#topic+ellipse3d">ellipse3d</a></code> 
to draw shapes that are spherical in the data scale.
</p>
<p>When the scale is not isometric, the radius is measured in an average scale.
In this case the bounding box calculation is iterative, since rescaling the
plot changes the shape of the spheres in user-coordinates, which changes
the bounding box.  Versions of <span class="pkg">rgl</span> prior to 0.92.802 did not do 
this iterative adjustment.
</p>
<p>If any coordinate or radius is <code>NA</code>, the sphere is not plotted.
</p>
<p>If a texture is used, its bitmap is wrapped around the 
sphere, with the top edge at the maximum y coordinate, 
and the left-right edges joined at the maximum in the
z coordinate, centred in x.
</p>
<p>If the <code>alpha</code> material value of the spheres is less than 
the default <code>1</code>, they need to be drawn in order from
back to front.  When <code>fastTransparency</code> is <code>TRUE</code>, this is approximated by sorting the centers and drawing
complete spheres in that order.  This produces acceptable
results in most cases, but artifacts may be visible, 
especially if the <code>radius</code> values vary, or they 
intersect other transparent objects.  Setting 
<code>fastTransparency = FALSE</code> will cause the sorting 
to apply to each of the 480 facets of individual spheres.
This is much slower, but may produce better
output.
</p>


<h3>Value</h3>

<p>A shape ID of the spheres object is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+material3d">material3d</a></code>, <code><a href="#topic+aspect3d">aspect3d</a></code> for setting non-isometric scales
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
spheres3d(rnorm(10), rnorm(10), rnorm(10), 
          radius = runif(10), color = rainbow(10))
</code></pre>

<hr>
<h2 id='spin3d'> Create a function to spin a scene at a fixed rate </h2><span id='topic+spin3d'></span>

<h3>Description</h3>

<p>This creates a function to use with <code><a href="#topic+play3d">play3d</a></code> to
spin an RGL scene at a fixed rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spin3d(axis = c(0, 0, 1), rpm = 5,
       dev = cur3d(), subscene = par3d("listeners", dev = dev))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spin3d_+3A_axis">axis</code></td>
<td>
<p> The desired axis of rotation </p>
</td></tr>
<tr><td><code id="spin3d_+3A_rpm">rpm</code></td>
<td>
<p> The rotation speed in rotations per minute </p>
</td></tr>
<tr><td><code id="spin3d_+3A_dev">dev</code></td>
<td>
<p> Which RGL device to use </p>
</td></tr>
<tr><td><code id="spin3d_+3A_subscene">subscene</code></td>
<td>
<p> Which subscene to use </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function with header <code>function(time, base = M)</code>, where <code>M</code>
is the result of <code>par3d("userMatrix")</code> at the time the function
is created.  This function
calculates and returns a list containing <code>userMatrix</code> updated by
spinning the base matrix for <code>time</code> seconds at <code>rpm</code> revolutions per
minute about the specified <code>axis</code>.
</p>


<h3>Note</h3>

<p>Prior to <span class="pkg">rgl</span> version 0.95.1476, the
<code>subscene</code> argument defaulted to the
current subscene, and any additional entries would
be ignored by <code><a href="#topic+play3d">play3d</a></code>.  The current
default value of <code>par3d("listeners", dev = dev)</code> means that all subscenes that share 
mouse responses will also share modifications
by this function.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

 <p><code><a href="#topic+play3d">play3d</a></code> to play the animation </p>


<h3>Examples</h3>

<pre><code class='language-R'># Spin one object
open3d()
plot3d(oh3d(col = "lightblue", alpha = 0.5))
if (!rgl.useNULL()  &amp;&amp; interactive())
  play3d(spin3d(axis = c(1, 0, 0), rpm = 30), duration = 2)

# Show spinning sprites, and rotate the whole view
open3d()
spriteid &lt;- NULL

spin1 &lt;- spin3d(rpm = 4.5 ) # the scene spinner
spin2 &lt;- spin3d(rpm = 9 ) # the sprite spinner

f &lt;- function(time) {
    par3d(skipRedraw = TRUE) # stops intermediate redraws
    on.exit(par3d(skipRedraw = FALSE)) # redraw at the end

    pop3d(id = spriteid) # delete the old sprite
    cubeid &lt;- shade3d(cube3d(), col = "red")
    spriteid &lt;&lt;- sprites3d(0:1, 0:1, 0:1, shape = cubeid,
                   userMatrix = spin2(time, 
                     base = spin1(time)$userMatrix)$userMatrix)
    spin1(time)
}
if (!rgl.useNULL() &amp;&amp; interactive())
  play3d(f, duration = 2)
</code></pre>

<hr>
<h2 id='sprites'>Add sprites</h2><span id='topic+sprites3d'></span><span id='topic+particles3d'></span>

<h3>Description</h3>

<p>Adds a sprite set shape node to the scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprites3d(x, y = NULL, z = NULL, radius = 1, 
          shapes = NULL, userMatrix, 
          fixedSize = FALSE, 
          adj = 0.5, pos = NULL, offset = 0.25, 
          rotating = FALSE, ...)
          
particles3d(x, y = NULL, z = NULL, radius = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sprites_+3A_x">x</code>, <code id="sprites_+3A_y">y</code>, <code id="sprites_+3A_z">z</code></td>
<td>
<p>point coordinates.  Any reasonable way of defining the
coordinates is acceptable.  See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>
for details.</p>
</td></tr>
<tr><td><code id="sprites_+3A_radius">radius</code></td>
<td>
<p>vector or single value defining the sprite radius</p>
</td></tr>
<tr><td><code id="sprites_+3A_shapes">shapes</code></td>
<td>
<p><code>NULL</code> for a simple square, a vector of
identifiers of shapes in the scene, or a list of 
such vectors.  See Details.</p>
</td></tr>
<tr><td><code id="sprites_+3A_usermatrix">userMatrix</code></td>
<td>
<p>if <code>shape</code> is not <code>NULL</code>, the transformation matrix 
for the shapes</p>
</td></tr>
<tr><td><code id="sprites_+3A_fixedsize">fixedSize</code></td>
<td>
<p>should sprites remain at a fixed size,
or resize with the scene?</p>
</td></tr>
<tr><td><code id="sprites_+3A_adj">adj</code>, <code id="sprites_+3A_pos">pos</code>, <code id="sprites_+3A_offset">offset</code></td>
<td>
<p>positioning arguments; see Details</p>
</td></tr>
<tr><td><code id="sprites_+3A_rotating">rotating</code></td>
<td>
<p>should sprites remain at a fixed orientation, or rotate with the scene?</p>
</td></tr>
<tr><td><code id="sprites_+3A_...">...</code></td>
<td>
<p>material properties when <code>shapes = NULL</code>, texture mapping is supported</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple sprites (used when <code>shapes</code> is <code>NULL</code>) are 1 by 1 squares
that are directed towards the viewpoint. Their primary use is for
fast (and faked) atmospherical effects, e.g. particles and clouds
using alpha blended textures. Particles are sprites using an alpha-blended 
particle texture giving the illusion of clouds and gases.  
The centre of each square will by default be at the
coordinates given by <code>x, y, z</code>.  This may be adjusted
using the <code>adj</code> or <code>pos</code> parameters.
</p>
<p><code>adj</code> and <code>pos</code> are treated similarly to the same
parameters for <code><a href="#topic+text3d">text3d</a></code>.  <code>adj</code> has 3
entries, for adjustment to the <code>x</code>, <code>y</code> and
<code>z</code> coordinates respectively.  For <code>x</code>, a value
of 0 puts the sprite to the right of the specified point,
0.5 centers it there, and 1 puts it to the left.  The other
coordinates are similar.  By default, each value is 0.5 and
the sprites are centered at the points given by <code>(x, y, z)</code>.
</p>
<p>The <code>pos</code> parameter overrides <code>adj</code>.  It should
be an integer or vector of integers (one per point),
interpreted as in <code><a href="#topic+text3d">text3d</a></code> to position the
sprite relative to the <code>(x, y, z)</code> point:  0 is centered on it, 1 is below,
2 is to the left, 3 is above, 4 is to the right, 5 is in
front, and 6 is behind.  <code>offset</code> is the
fraction of the sprite size to separate it from the point.
</p>
<p>When <code>shapes</code> is not <code>NULL</code>, it should be a vector of
identifiers of objects to plot in the scene (e.g. as returned by
plotting functions or by <code><a href="#topic+ids3d">ids3d</a></code>), or a list of such vectors.  The referenced objects will
be removed from the scene and duplicated as sprite images in a
constant orientation, as specified by <code>userMatrix</code>.  By default the 
origin <code>(0, 0, 0)</code> will be plotted at the coordinates given by <code>(x, y, z)</code>, perhaps modified by <code>adj</code>
or <code>pos</code>.
</p>
<p>If <code>shapes</code> is a vector all entries in it will be plotted at every
location.  If <code>shapes</code> is a list, different shapes
will be plotted at each location. All entries in list 
entry 1 will be plotted
at location 1, all entries in entry 2 at location 2, etc.
Entries will be recycled as needed.
</p>
<p>The <code>userMatrix</code> argument is ignored for <code>shapes = NULL</code>.  For
shapes, <code>sprites3d</code> defaults the matrix to <code>r3dDefaults$userMatrix</code>.
</p>
<p>If any coordinate is <code>NA</code>, the sprite is not plotted.
</p>
<p>The id values of the shapes may be retrieved after plotting
using <code>rgl.attrib(id, "ids")</code>, the associated entry
in <code>shapes</code>
is retrievable in <code>rgl.attrib(id, "shapenum")</code>, and
the user matrix is retrieved using <code>rgl.attrib(id, "usermatrix")</code>.
</p>


<h3>Value</h3>

<p>These functions are called for the side effect of displaying the sprites.
The shape ID of the displayed object is returned.
</p>


<h3>Note</h3>

<p>While any rgl objects can be used as 3D sprites, spheres
produced by <code><a href="#topic+spheres3d">spheres3d</a></code> and other objects that
adapt to the coordinate system
may not render properly.  To plot spheres, construct them
as mesh objects as shown in the example.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+material3d">material3d</a></code>, <code><a href="#topic+text3d">text3d</a></code>, <code><a href="#topic+pch3d">pch3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
particles3d( rnorm(100), rnorm(100), rnorm(100), color = rainbow(100) )
# is the same as
sprites3d( rnorm(100), rnorm(100), rnorm(100), color = rainbow(100),
  lit = FALSE, alpha = .2,
  textype = "alpha", texture = system.file("textures/particle.png", package = "rgl") )
sprites3d( rnorm(10) + 6, rnorm(10), rnorm(10), shape = shade3d(tetrahedron3d(), col = "red") )


open3d()

# Since the symbols are objects in the scene, they need
# to be added to the scene after calling plot3d()

plot3d(iris, type = "n")

# Use list(...) to apply different symbols to different points.

symbols &lt;- list(shade3d(cube3d(), col = "red"),
                shade3d(tetrahedron3d(), col = "blue"),
                # Construct spheres
                shade3d(addNormals(subdivision3d(icosahedron3d(), 2)),
                        col = "yellow"))
                
sprites3d(iris, shape = symbols[iris$Species], radius = 0.1)
</code></pre>

<hr>
<h2 id='subdivision3d'>Subdivide a mesh</h2><span id='topic+subdivision3d'></span><span id='topic+subdivision3d.mesh3d'></span><span id='topic+divide.mesh3d'></span><span id='topic+normalize.mesh3d'></span><span id='topic+deform.mesh3d'></span>

<h3>Description</h3>

<p>The subdivision surface algorithm divides and refines (deforms) a
given mesh recursively to certain degree (depth).
The mesh3d algorithm consists of two stages: divide and deform.
The divide step generates for each triangle or quad four new triangles or quads, the deform
step drags the points (refinement step).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  subdivision3d( x,  ...)
  ## S3 method for class 'mesh3d'
subdivision3d( x, depth = 1, normalize = FALSE,
                deform = TRUE, keepTags = FALSE, ... )
  divide.mesh3d(mesh,  vb = mesh$vb, 
                ib = mesh$ib, it = mesh$it, is = mesh$is,
                keepTags = FALSE)
  normalize.mesh3d(mesh)
  deform.mesh3d(mesh, vb = mesh$vb, ib = mesh$ib, it = mesh$it,
                is = mesh$is)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subdivision3d_+3A_x">x</code></td>
<td>
<p>3d geometry mesh</p>
</td></tr>
<tr><td><code id="subdivision3d_+3A_mesh">mesh</code></td>
<td>
<p>3d geometry mesh</p>
</td></tr>
<tr><td><code id="subdivision3d_+3A_depth">depth</code></td>
<td>
<p>recursion depth</p>
</td></tr>
<tr><td><code id="subdivision3d_+3A_normalize">normalize</code></td>
<td>
<p>normalize mesh3d coordinates after division if <code>deform</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="subdivision3d_+3A_deform">deform</code></td>
<td>
<p>deform mesh</p>
</td></tr>
<tr><td><code id="subdivision3d_+3A_keeptags">keepTags</code></td>
<td>
<p>if <code>TRUE</code>, add a <code>"tags"</code>
component to the output.</p>
</td></tr>
<tr><td><code id="subdivision3d_+3A_is">is</code></td>
<td>
<p>indices for segments</p>
</td></tr>
<tr><td><code id="subdivision3d_+3A_it">it</code></td>
<td>
<p>indices for triangular faces</p>
</td></tr>
<tr><td><code id="subdivision3d_+3A_ib">ib</code></td>
<td>
<p>indices for quad faces</p>
</td></tr>
<tr><td><code id="subdivision3d_+3A_vb">vb</code></td>
<td>
<p>matrix of vertices: 4 x n matrix (rows x, y, z, h) or equivalent
vector, where h indicates scaling of each plotted quad</p>
</td></tr>
<tr><td><code id="subdivision3d_+3A_...">...</code></td>
<td>
<p>other arguments (unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>subdivision3d</code> takes
a mesh object and replaces each segment with two new ones, and 
each triangle or quad with 4 new ones
by adding vertices half-way along the edges (and one in the
centre of a quad).  The positions of the vertices are 
deformed so that the resulting surface is smoother than the original.  These operations are repeated <code>depth</code> times.
</p>
<p>The other functions do the individual steps of the subdivision.
<code>divide.mesh3d</code> adds the extra vertices.  <code>deform.mesh3d</code>
does the smoothing by replacing each vertex with the average of each of its neighbours. <code>normalize.mesh3d</code> 
normalizes the homogeneous coordinates, by setting the 
4th coordinate to 1.  (The 4th coordinate is used as a
weight in the deform step.)
</p>


<h3>Value</h3>

<p>A modified <code><a href="#topic+mesh3d">mesh3d</a></code> object.  If <code>keepTags</code> is
<code>TRUE</code>, it will contain a <code>tags</code> component.  For
details, see the <code><a href="#topic+clipMesh3d">clipMesh3d</a></code> help topic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+r3d">r3d</a></code>
<code><a href="#topic+mesh3d">mesh3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  open3d()
  shade3d( subdivision3d( cube3d(), depth = 3 ), color = "red", alpha = 0.5 )
</code></pre>

<hr>
<h2 id='subscene3d'>
Create, select or modify a subscene
</h2><span id='topic+subscene3d'></span><span id='topic+newSubscene3d'></span><span id='topic+currentSubscene3d'></span><span id='topic+useSubscene3d'></span><span id='topic+addToSubscene3d'></span><span id='topic+delFromSubscene3d'></span><span id='topic+gc3d'></span>

<h3>Description</h3>

<p>This creates a new subscene, or selects one by <code>id</code> value, or adds objects to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newSubscene3d(viewport = "replace", 
              projection = "replace", 
              model = "replace",
              mouseMode = "inherit", 
              parent = currentSubscene3d(), 
              copyLights = TRUE, 
              copyShapes = FALSE, 
              copyBBoxDeco = copyShapes, 
              copyBackground = FALSE, newviewport,
              ignoreExtent)
currentSubscene3d(dev = cur3d())
useSubscene3d(subscene)
addToSubscene3d(ids = tagged3d(tags), tags, subscene = currentSubscene3d())
delFromSubscene3d(ids = tagged3d(tags), tags, subscene = currentSubscene3d())
gc3d(protect = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subscene3d_+3A_viewport">viewport</code>, <code id="subscene3d_+3A_projection">projection</code>, <code id="subscene3d_+3A_model">model</code>, <code id="subscene3d_+3A_mousemode">mouseMode</code></td>
<td>

<p>How should the new subscene be embedded?  Possible values are
<code>c("inherit", "modify", "replace")</code>.  See Details below.
</p>
</td></tr>
<tr><td><code id="subscene3d_+3A_parent">parent</code></td>
<td>

<p>The parent subscene (defaults to the current subscene).
</p>
</td></tr>
<tr><td><code id="subscene3d_+3A_copylights">copyLights</code>, <code id="subscene3d_+3A_copyshapes">copyShapes</code>, <code id="subscene3d_+3A_copybboxdeco">copyBBoxDeco</code>, <code id="subscene3d_+3A_copybackground">copyBackground</code></td>
<td>

<p>Whether lights, shapes, bounding box decorations and background should be copied to the new subscene.
</p>
</td></tr>
<tr><td><code id="subscene3d_+3A_newviewport">newviewport</code></td>
<td>

<p>Optionally specify the new subscene's viewport (in pixels).
</p>
</td></tr>
<tr><td><code id="subscene3d_+3A_ignoreextent">ignoreExtent</code></td>
<td>

<p>Whether to ignore the subscene's bounding box when calculating the parent bounding
box.  Defaults to <code>TRUE</code> if <code>model</code> is not <code>"inherit"</code>.
</p>
</td></tr>
<tr><td><code id="subscene3d_+3A_dev">dev</code></td>
<td>

<p>Which RGL device to query for the current subscene.
</p>
</td></tr>
<tr><td><code id="subscene3d_+3A_subscene">subscene</code></td>
<td>

<p>Which subscene to use or modify.
</p>
</td></tr>
<tr><td><code id="subscene3d_+3A_ids">ids</code></td>
<td>

<p>A vector of integer object ids to add to the subscene.
</p>
</td></tr>
<tr><td><code id="subscene3d_+3A_tags">tags</code></td>
<td>

<p>Alternate way to specify <code>ids</code>.  Ignored if <code>ids</code> is
given.
</p>
</td></tr>
<tr><td><code id="subscene3d_+3A_protect">protect</code></td>
<td>

<p>Object ids to protect from this garbage collection.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <span class="pkg">rgl</span> package allows multiple windows to be open; each one corresponds to a &ldquo;scene&rdquo;.
Within each scene there are one or more &ldquo;subscenes&rdquo;.  Each subscene corresponds
to a rectangular region in the window, and may have its own projection, transformation and behaviour in response to 
the mouse.
</p>
<p>There is always a current subscene:  most graphic operations make changes there, e.g. by adding
an object to it.
</p>
<p>The scene &ldquo;owns&rdquo; objects; <code>addToSubscene3d</code> and <code>delFromSubscene3d</code> 
put their ids into or remove them from the list being displayed within a particular subscene.
The <code>gc3d</code> function deletes objects from the scene if they are not visible in any
subscene, unless they are protected by having their id included in <code>protect</code>.
</p>
<p>The <code>viewport</code>, <code>projection</code> and <code>model</code> parameters each have three possible settings:
<code>c("inherit", "modify", "replace")</code>.  <code>"inherit"</code> means that the corresponding value
from the parent subscene will be used.  <code>"replace"</code> means that the new subscene will
have its own value of the value, independent of its parent.  <code>"modify"</code> means that the 
child value will be applied first, and then the parent value will be applied.  For viewport, this
means that if the parent viewport is changed, the child will maintain its relative position.  For
the two matrices, <code>"modify"</code> is unlikely to give satisfactory results, but it is available
for possible use.  
</p>
<p>The <code>mouseMode</code> parameter 
can only be one of <code>c("inherit", "replace")</code>.  If
it is <code>"inherit"</code>, the subscene will use the mouse
controls of the parent, and any change to them will
affect the parent and all children that inherit from it.
This is the behaviour that was present before <span class="pkg">rgl</span>
version 0.100.13.  If it is <code>"replace"</code>, then
it will receive a copy of the parent mouse controls,
but modifications to them will affect only this 
subscene, not the parent.  Note that this is orthogonal
to the <code><a href="#topic+par3d">par3d</a>("listeners")</code> setting:
if another subscene is listed as a listener, it will respond
to mouse actions using the same mode as the one receiving
them.
</p>
<p>The <code>viewport</code> parameter controls the rectangular region in which the subscene is displayed.
It is specified using <code>newviewport</code> (in pixels relative to the whole window), or set to 
match the parent viewport.
</p>
<p>The <code>projection</code> parameter controls settings corresponding to the observer.  These
include the field of view and the zoom; they also include the position of the observer relative to
the model.  The <code>par3d("projMatrix")</code> matrix is determined by the projection.
</p>
<p>The <code>model</code> parameter controls settings corresponding to the model.  Mouse rotations affect
the model, as does scaling.  The <code>par3d("modelMatrix")</code> matrix is determined by these as
well as by the position of the observer (since OpenGL assumes that the observer is at
(0, 0, 0) after the MODELVIEW transformation).  Only those parts concerning the model are
inherited when <code>model</code> specifies inheritance, the observer setting is controlled by
<code>projection</code>.
</p>
<p>If <code>copyBackground</code> is <code>TRUE</code>, the background of the newly created child will
overwrite anything displayed in the parent subscene, regardless of depth.
</p>


<h3>Value</h3>

<p>If successful, each function returns the object id of the subscene, with the exception of
<code>gc3d</code>, which returns the count of objects which have been deleted, 
and <code>useSubscene3d</code>, which returns the previously active subscene id.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch and Fang He.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subsceneInfo">subsceneInfo</a></code> for information about a subscene, 
<code><a href="#topic+mfrow3d">mfrow3d</a></code> and <code><a href="#topic+layout3d">layout3d</a></code> to set up 
multiple panes of subscenes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Show the Earth with a cutout by using clipplanes in subscenes

lat &lt;- matrix(seq(90, -90, length.out = 50)*pi/180, 50, 50, byrow = TRUE)
long &lt;- matrix(seq(-180, 180, length.out = 50)*pi/180, 50, 50)

r &lt;- 6378.1 # radius of Earth in km
x &lt;- r*cos(lat)*cos(long)
y &lt;- r*cos(lat)*sin(long)
z &lt;- r*sin(lat)

open3d()
obj &lt;- surface3d(x, y, z, col = "white", 
       texture = system.file("textures/worldsmall.png", package = "rgl"), 
       specular = "black", axes = FALSE, box = FALSE, xlab = "", ylab = "", zlab = "",
       normal_x = x, normal_y = y, normal_z = z)
       
cols &lt;- c(rep("chocolate4", 4), rep("burlywood1", 4), "darkgoldenrod1")
rs &lt;- c(6350, 5639, 4928.5, 4207, 3486, 
                         (3486 + 2351)/2, 2351, (2351 + 1216)/2, 1216)
for (i in seq_along(rs)) 
  obj &lt;- c(obj, spheres3d(0, 0, col = cols[i], radius = rs[i]))
  
root &lt;- currentSubscene3d()

newSubscene3d("inherit", "inherit", "inherit", copyShapes = TRUE, parent = root)
clipplanes3d(1, 0, 0, 0)

newSubscene3d("inherit", "inherit", "inherit", copyShapes = TRUE, parent = root)
clipplanes3d(0, 1, 0, 0)

newSubscene3d("inherit", "inherit", "inherit", copyShapes = TRUE, parent = root)
clipplanes3d(0, 0, 1, 0)

# Now delete the objects from the root subscene, to reveal the clipping planes
useSubscene3d(root)
delFromSubscene3d(obj)
</code></pre>

<hr>
<h2 id='subsceneInfo'>
Get information on subscenes
</h2><span id='topic+subsceneInfo'></span>

<h3>Description</h3>

<p>This function retrieves information about the tree of subscenes shown in the active
window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsceneInfo(id = NA, embeddings, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsceneInfo_+3A_id">id</code></td>
<td>

<p>Which subscene to report on; <code>NA</code> is the current subscene.  Set to <code>"root"</code> for the root.
</p>
</td></tr>
<tr><td><code id="subsceneInfo_+3A_embeddings">embeddings</code></td>
<td>

<p>Optional new setting for the embeddings for this subscene.
</p>
</td></tr>
<tr><td><code id="subsceneInfo_+3A_recursive">recursive</code></td>
<td>

<p>Whether to report on children recursively.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In RGL, each window contains a tree of &ldquo;subscenes&rdquo;, each containing views of 
a subset of the objects defined in the window.
</p>
<p>Rendering in each subscene depends on the viewport, the projection, and the model
transformation.  Each of these characteristics may be inherited from the parent 
(<code>embedding[i] = "inherit"</code>), may modify the parent (<code>embedding[i] = "modify"</code>),
or may replace the parent (<code>embedding[i] == "replace"</code>).  All three must be
specified if <code>embeddings</code> is used.
</p>


<h3>Value</h3>

<table>
<tr><td><code>id</code></td>
<td>
<p>The object id of the subscene</p>
</td></tr>
<tr><td><code>parent</code></td>
<td>
<p>The object id of the parent subscene, if any</p>
</td></tr>
<tr><td><code>children</code></td>
<td>
<p>If <code>recursive</code>, a list of the information for the children,
otherwise just their object ids.</p>
</td></tr>
<tr><td><code>embedding</code></td>
<td>
<p>A vector of 3 components describing how this subscene is
embedded in its parent.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+newSubscene3d">newSubscene3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(plot3d)
subsceneInfo()
</code></pre>

<hr>
<h2 id='surface3d'>Add surface</h2><span id='topic+surface3d'></span>

<h3>Description</h3>

<p>Adds a surface to the current scene. The surface is defined by 
a matrix defining the height of each grid point and two vectors or matrices
defining the grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surface3d(x, y, z, ..., 
         normal_x = NULL, normal_y = NULL, normal_z = NULL,
         texture_s=NULL, texture_t=NULL, flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surface3d_+3A_x">x</code>, <code id="surface3d_+3A_y">y</code>, <code id="surface3d_+3A_z">z</code></td>
<td>

<p>vectors or matrices of values.  See Details.
</p>
</td></tr>
<tr><td><code id="surface3d_+3A_...">...</code></td>
<td>
<p>Material properties. See <code><a href="#topic+material3d">material3d</a></code> for details.</p>
</td></tr>    
<tr><td><code id="surface3d_+3A_normal_x">normal_x</code>, <code id="surface3d_+3A_normal_y">normal_y</code>, <code id="surface3d_+3A_normal_z">normal_z</code></td>
<td>

<p>matrices giving the coordinates of normals at 
each grid point
</p>
</td></tr>
<tr><td><code id="surface3d_+3A_texture_s">texture_s</code>, <code id="surface3d_+3A_texture_t">texture_t</code></td>
<td>

<p>matrices giving the texture coordinates at each
grid point
</p>
</td></tr>
<tr><td><code id="surface3d_+3A_flip">flip</code></td>
<td>

<p>flip definition of &ldquo;up&rdquo;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds a surface mesh to the current scene. The surface is 
typically defined by a matrix of height values in <code>z</code>
(as in <code><a href="graphics.html#topic+persp">persp</a></code>), 
but any of <code>x</code>, <code>y</code>, or <code>z</code> may be matrices or
vectors, as long as at least one is a matrix.  (One 
historical exception is allowed:  if all are vectors but
the length of <code>z</code> is the product of the lengths of
<code>x</code> and <code>y</code>, <code>z</code> is converted to a matrix.)
</p>
<p>Dimensions of all matrices must match.
</p>
<p>If any of the coordinates are vectors, they are interpreted as follows:
</p>

<ul>
<li><p> If <code>x</code> is a vector, it corresponds to rows of the matrix.
</p>
</li>
<li><p> If <code>y</code> is a vector, it corresponds to columns
of the matrix.
</p>
</li>
<li><p> If <code>z</code> is a vector, it corresponds to columns
unless <code>y</code> is also a vector, in which case it corresponds
to rows.
</p>
</li></ul>

<p>If the normals are not supplied, they will be calculated automatically based
on neighbouring points.
</p>
<p>Texture coordinates run from 0 to 1 over each dimension of the texture bitmap.
If texture coordinates are not supplied, they will be calculated to 
render the texture exactly once over the grid.  Values greater than 1 can be
used to repeat the texture over the surface.
</p>
<p><code>surface3d</code> always tries to draw the surface with the &lsquo;front&rsquo; upwards
(typically towards higher <code>z</code> values).  This can be used to render
the top and bottom differently; see <code><a href="#topic+material3d">material3d</a></code> and
the example below.  If you don't like its choice, set
<code>flip = TRUE</code> to use the opposition definition.
</p>
<p><code>NA</code> values in the height matrix are not drawn.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+persp3d">persp3d</a></code> for a higher level interface.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# volcano example taken from "persp"
#

z &lt;- 2 * volcano        # Exaggerate the relief

x &lt;- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
y &lt;- 10 * (1:ncol(z))   # 10 meter spacing (E to W)

zlim &lt;- range(z)
zlen &lt;- zlim[2] - zlim[1] + 1

colorlut &lt;- terrain.colors(zlen) # height color lookup table

col &lt;- colorlut[ z - zlim[1] + 1 ] # assign colors to heights for each point

open3d()
surface3d(x, y, z, color = col, back = "lines")

</code></pre>

<hr>
<h2 id='tagged3d'>
Find tags on rgl objects.
</h2><span id='topic+tagged3d'></span>

<h3>Description</h3>

<p>Objects with material properties may have an arbitrary
string set as a tag.  This function retrieves the id
values associated with a given tag, or the tags set on 
given ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tagged3d(tags = NULL, ids = NULL, full = FALSE, subscene = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tagged3d_+3A_tags">tags</code></td>
<td>

<p>A vector of tags to use for selection.
</p>
</td></tr>
<tr><td><code id="tagged3d_+3A_ids">ids</code></td>
<td>

<p>A vector of ids to report the tags on.
</p>
</td></tr>
<tr><td><code id="tagged3d_+3A_full">full</code></td>
<td>
<p>logical; whether to return 
a dataframe containing <code>id</code>, <code>type</code>, <code>tag</code>,
or a vector of ids or tags.</p>
</td></tr>
<tr><td><code id="tagged3d_+3A_subscene">subscene</code></td>
<td>

<p>Where to look:  by default, the whole scene is searched.
<code>NA</code> restricts the search to the current subscene,
or a subscene id can be given.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of <code>tags</code> and <code>ids</code> must be specified.
</p>


<h3>Value</h3>

<p>A dataframe is constructed with columns
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>item id</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>item type</p>
</td></tr>
<tr><td><code>tag</code></td>
<td>
<p>item tag</p>
</td></tr>
</table>
<p>matching the specified <code>tags</code> or <code>ids</code> value.
If <code>full = TRUE</code>, the full dataframe is returned, otherwise
just the requested ids or tags.
</p>
<p>If <code>ids</code> is specified, the return value will be
in the same order
as <code>ids</code>).
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
ids &lt;- plot3d(rnorm(10), rnorm(10), rnorm(10), tag = "plot")
unclass(ids)
tagged3d("plot")
tagged3d(ids = ids, full = TRUE)
</code></pre>

<hr>
<h2 id='text3d'>Add text to plot</h2><span id='topic+text3d'></span><span id='topic+texts3d'></span>

<h3>Description</h3>

<p>Adds text to the scene. The text is positioned in 3D space. 
Text is always oriented towards the camera.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text3d(x, y = NULL, z = NULL, texts, adj = 0.5, pos = NULL, offset = 0.5,
       usePlotmath = is.language(texts), 
       family = par3d("family"), font = par3d("font"), 
			 cex = par3d("cex"), useFreeType = par3d("useFreeType"),
			...) 
texts3d(x, y = NULL, z = NULL, texts, adj = 0.5, pos = NULL, offset = 0.5,
       usePlotmath = is.language(texts),
       family = par3d("family"), font = par3d("font"), 
			 cex = par3d("cex"), useFreeType = par3d("useFreeType"),
			...)       
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text3d_+3A_x">x</code>, <code id="text3d_+3A_y">y</code>, <code id="text3d_+3A_z">z</code></td>
<td>
<p>point coordinates.  Any reasonable way of defining the
coordinates is acceptable.  See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>
for details.</p>
</td></tr>
<tr><td><code id="text3d_+3A_texts">texts</code></td>
<td>
<p>text character vector to draw</p>
</td></tr>
<tr><td><code id="text3d_+3A_adj">adj</code></td>
<td>
<p> one value specifying the horizontal adjustment, or two, 
specifying horizontal and vertical adjustment respectively, or three, specifying adjustment in all
three directions.</p>
</td></tr>
<tr><td><code id="text3d_+3A_pos">pos</code></td>
<td>
<p> a position specifier for the text.  If specified, this
overrides any <code>adj</code> value given. Values of 0, 1, 2, 3, 4, 5, 6 respectively indicate positions at, below, to the left of, above, to the right of, in front of, and behind the specified coordinates.</p>
</td></tr>
<tr><td><code id="text3d_+3A_offset">offset</code></td>
<td>
<p> when <code>pos</code> is specified, this value gives the offset of the label from the specified coordinate in fractions of a character width.</p>
</td></tr>
<tr><td><code id="text3d_+3A_useplotmath">usePlotmath</code></td>
<td>
<p>logical.  Should <code><a href="#topic+plotmath3d">plotmath3d</a></code> be used for the text?</p>
</td></tr>
<tr><td><code id="text3d_+3A_family">family</code></td>
<td>
<p>A device-independent font family name, or &quot;&quot; </p>
</td></tr>
<tr><td><code id="text3d_+3A_font">font</code></td>
<td>
<p>A numeric font number from 1 to 4 </p>
</td></tr>
<tr><td><code id="text3d_+3A_cex">cex</code></td>
<td>
<p>A numeric character expansion value </p>
</td></tr>
<tr><td><code id="text3d_+3A_usefreetype">useFreeType</code></td>
<td>
<p>logical.  Should FreeType be used to draw text? (See details below.)</p>
</td></tr>
<tr><td><code id="text3d_+3A_...">...</code></td>
<td>
<p>Material properties; see <code><a href="#topic+material3d">material3d</a></code> for details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The <code>adj</code> parameter determines the position of the text relative to the 
specified coordinate.  Use <code>adj = c(0, 0)</code> to place the left bottom corner at
<code>(x, y, z)</code>, <code>adj = c(0.5, 0.5)</code> to center the text there, and <code>adj = c(1, 1)</code>
to put the right top corner there. The optional second coordinate for vertical 
adjustment defaults to <code>0.5</code>.  Placement is done using the &quot;advance&quot; of
the string and the &quot;ascent&quot; of the font relative to the baseline, when these metrics
are known.
</p>
<p><code>text3d</code> and <code>texts3d</code> draw text using the <a href="#topic+r3d">r3d</a>
conventions. These are synonyms; the former is singular to be
consistent with the classic 2-D graphics functions, and the latter is
plural to be consistent with all the other graphics primitives.  Take
your choice!
</p>
<p>If any coordinate or text is <code>NA</code>, that text is not plotted.
</p>
<p>If <code>usePlotmath</code> is <code>TRUE</code>, the work will be done
by the <code><a href="#topic+plotmath3d">plotmath3d</a></code> function.  This is the default
if the <code>texts</code>
parameter is &ldquo;language&rdquo;, e.g. the result of
a call to <code><a href="base.html#topic+expression">expression</a></code> or <code><a href="base.html#topic+quote">quote</a></code>.
</p>


<h3>Value</h3>

<p>The text drawing functions return the object ID of the text object (or sprites, in case of <code>usePlotmath = TRUE</code>)
invisibly.
</p>


<h3>Fonts</h3>

<p>Fonts are specified using the <code>family</code>, <code>font</code>, <code>cex</code>, 
and <code>useFreeType</code> arguments.  Defaults for the currently active
device may be set using <code><a href="#topic+par3d">par3d</a></code>, or for future devices
using <code><a href="#topic+r3dDefaults">r3dDefaults</a></code>.
</p>
<p>The <code>family</code> specification is the same as for standard graphics, i.e.
families <br />
<code>c("serif", "sans", "mono", "symbol")</code> <br />
are normally
available, but users may add additional families.  <code>font</code> numbers
are restricted to the range 1 to 4 for standard, bold, italic and bold italic
respectively.  Font 5 is recoded as family <code>"symbol"</code>
font 1, but that is not supported unless specifically
installed, so should be avoided.
</p>
<p>Using an unrecognized value for <code>"family"</code> will result in
the system standard font as used in RGL up to version 0.76.  That font
is not resizable and <code>font</code> values are ignored.
</p>
<p>If <code>useFreeType</code> is <code>TRUE</code>, then RGL will use the FreeType
anti-aliased fonts for drawing.  This is generally desirable, and it is the
default on non-Windows systems if RGL was built to support FreeType.
</p>
<p>FreeType fonts are specified using the <code><a href="#topic+rglFonts">rglFonts</a></code> function. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+r3d">r3d</a></code>, <code><a href="#topic+plotmath3d">plotmath3d</a></code>, <code><a href="#topic+rglExtrafonts">rglExtrafonts</a></code> for adding fonts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>open3d()
famnum &lt;- rep(1:3, 8)
family &lt;- c("serif", "sans", "mono")[famnum]
font &lt;- rep(rep(1:4, each = 3), 2)
cex &lt;- rep(1:2, each = 12)
text3d(font, cex, famnum, texts = paste(family, font), adj = 0.5, 
       color = "blue", family = family, font = font, cex = cex)
</code></pre>

<hr>
<h2 id='textureSource'>
Retrieve source code used to produce texture file.
</h2><span id='topic+textureSource'></span>

<h3>Description</h3>

<p>Internally, <span class="pkg">rgl</span> works with PNG files for textures.
If a texture is requested using a different format, a temporary
PNG file of the image will be saved.  This function allows
you to retrieve the original expression used to produce
the texture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textureSource(texture)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textureSource_+3A_texture">texture</code></td>
<td>

<p>The filename of a texture file.  If missing, the directory
where texture files are stored will be returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">rgl</span> creates a new file in the temporary directory
whenever a non-PNG texture is used.  It will delete them
when it knows there are no references and 
at the end of the session, but conceivably there will be 
situations where you need to delete them earlier.  Calling
<code>textureSource()</code> with no arguments will give
you the directory holding the textures so that they can
be deleted sooner.
</p>


<h3>Value</h3>

<p>If <code>texture</code> is specified and it is the name of a 
temporary PNG texture file produced by <span class="pkg">rgl</span>, the 
expression used to specify the texture will be returned.  
If it is the name of some other file, <code>texture</code> will
be returned.
</p>
<p>If no argument is given, the session-specific directory
holding the temporary texture files will be returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+material3d">material3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyz &lt;- cbind(c(0,1,1,0), c(0,0,1,1), c(0,0,0,0))
st &lt;- xyz[,1:2]

open3d()
id &lt;- quads3d(xyz, texcoords = st, 
               texture = as.raster(matrix(colors()[1:120], ncol = 10)), 
               col="white")
material3d(id = id, "texture")
textureSource(material3d(id = id, "texture"))
</code></pre>

<hr>
<h2 id='thigmophobe3d'>
Find the direction away from the closest point in a 3d projection
</h2><span id='topic+thigmophobe3d'></span>

<h3>Description</h3>

<p>Jim Lemon's <code><a href="plotrix.html#topic+thigmophobe">thigmophobe</a></code> function in the 
<code><a href="plotrix.html#topic+plotrix-package">plotrix</a></code> package
computes good directions for labels in a 2D plot.  This function
does the same for a particular projection in a 3D plot by
projecting down to 2D and calling his function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thigmophobe3d(x, y = NULL, z = NULL, 
              P = par3d("projMatrix"), 
              M = par3d("modelMatrix"),
              windowRect = par3d("windowRect"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thigmophobe3d_+3A_x">x</code>, <code id="thigmophobe3d_+3A_y">y</code>, <code id="thigmophobe3d_+3A_z">z</code></td>
<td>
<p>point coordinates.  Any reasonable way of defining
the coordinates is acceptable.  See the function <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code> for details.
</p>
</td></tr>
<tr><td><code id="thigmophobe3d_+3A_p">P</code>, <code id="thigmophobe3d_+3A_m">M</code>, <code id="thigmophobe3d_+3A_windowrect">windowRect</code></td>
<td>

<p>The projection and modelview matrices, and the size and position of 
the display in pixels.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since <code>thigmophobe3d</code> projects using fixed <code>P</code> and <code>M</code>,
it will not necessarily choose good directions if the user rotates
the display or makes any other change to the projection.</p>


<h3>Value</h3>

<p>A vector of values from 1 to 4 to be used as the <code>pos</code> argument
in <code><a href="#topic+text3d">text3d</a></code>.
</p>


<h3>Note</h3>

<p>The example
below shows how to update the directions during an animation; 
I find that the moving labels are distracting, and prefer to live with 
fixed ones.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p><a href="https://CRAN.R-project.org/package=plotrix"><span class="pkg">plotrix</span></a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+text3d">text3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("plotrix", quietly = TRUE)) {
  # Simulate some data
  xyz &lt;- matrix(rnorm(30), ncol = 3)
  
  # Plot the data first, to establish the projection
  plot3d(xyz)
  
  # Now thigmophobe3d can choose directions
  textid &lt;- text3d(xyz, texts = 1:10, pos = thigmophobe3d(xyz))
  
  # Update the label positions during an animation
  if (interactive() &amp;&amp; !rgl.useNULL()) {
    spin &lt;- spin3d(rpm = 5)
    f &lt;- function(time) {
      par3d(skipRedraw = TRUE)
      on.exit(par3d(skipRedraw = FALSE))
      pop3d(id = textid)
      # Need to rotate before thigmophobe3d is called
      result &lt;- spin(time)
      par3d(userMatrix = result$userMatrix)
      textid &lt;&lt;- text3d(xyz, texts = 1:10, pos = thigmophobe3d(xyz))
      result
    }
    play3d(f, duration = 5)
  } else
    textid   # just print the static display
}
</code></pre>

<hr>
<h2 id='tkpar3dsave'> Modal dialog for saving par3d settings </h2><span id='topic+tkpar3dsave'></span><span id='topic+par3dsave'></span>

<h3>Description</h3>

<p>This function opens a TCL/TK modal dialog to allow particular views of an RGL scene
to be saved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkpar3dsave(params = c("userMatrix", "scale", "zoom", "FOV"),
          times = FALSE, dev = cur3d(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkpar3dsave_+3A_params">params</code></td>
<td>
<p> Which parameters to save </p>
</td></tr>
<tr><td><code id="tkpar3dsave_+3A_times">times</code></td>
<td>
<p> Should times be saved as well? </p>
</td></tr>
<tr><td><code id="tkpar3dsave_+3A_dev">dev</code></td>
<td>
<p> Which RGL device to work with </p>
</td></tr>
<tr><td><code id="tkpar3dsave_+3A_...">...</code></td>
<td>
<p> Additional parameters to pass to <code><a href="tcltk.html#topic+TkWidgets">tktoplevel</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This opens a TCL/TK modal dialog box with <code>Record</code> and <code>Quit</code> buttons.  Each time
<code>Record</code> is clicked, a snapshot is taken of current <code><a href="#topic+par3d">par3d</a></code> settings.  When
<code>Quit</code> is clicked, the dialog closes and the values are returned in a list.
</p>
<p>If <code>times == TRUE</code>, then the times at which the views are recorded will also be saved, so that
the <code><a href="#topic+play3d">play3d</a></code> function will play back with the same timing.
</p>


<h3>Value</h3>

<p>A list of the requested components.  Each one will consist of a list of values that were
current when the <code>Record</code> button was clicked.  These are suitable to be passed directly
to the <code><a href="#topic+par3dinterp">par3dinterp</a></code> function.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

 <p><code><a href="#topic+par3d">par3d</a></code>, <code><a href="#topic+par3dinterp">par3dinterp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive() &amp;&amp; !in_pkgdown_example()) {

  # Record a series of positions, and then play them back immediately
  # at evenly spaced times, in an oscillating loop
  example(plot3d)
  play3d( par3dinterp( tkpar3dsave() ) )

  # As above, but preserve the click timings

  # play3d( par3dinterp( tkpar3dsave(times=TRUE) ) )
}
</code></pre>

<hr>
<h2 id='tkrgl'>
The former tkrgl package
</h2><span id='topic+tkrgl'></span>

<h3>Description</h3>

<p>Functions from the former <span class="pkg">tkrgl</span> package.
</p>


<h3>Details</h3>

<p>The <span class="pkg">tkrgl</span> package contained functions to use TCL/TK to control
an RGL scene on screen.  These functions have now been merged
into the <span class="pkg">rgl</span> package, and the <span class="pkg">tkrgl</span> package has
been archived.
</p>
<p>To avoid conflicts with RGL names and to indicate the TCL/TK 
nature of these functions, they have all been prefixed with <code>tk</code>:
</p>

<dl>
<dt><code><a href="#topic+tkpar3dsave">tkpar3dsave</a></code></dt><dd><p>Formerly <code>tkrgl::par3dsave</code>, allows interactive
saving of scene parameters.</p>
</dd>
<dt><code><a href="#topic+tkspin3d">tkspin3d</a>, <a href="#topic+tkspinControl">tkspinControl</a></code></dt><dd><p>Formerly 
<code>tkrgl::spin3d</code> and <code>tkrgl::spinControl</code>, create buttons
to spin the scene.</p>
</dd>
</dl>

<p>History:
</p>

<table>
<tr>
 <td style="text-align: left;">
0.2-2 </td><td style="text-align: left;"> First public release </td>
</tr>
<tr>
 <td style="text-align: left;">
0.3   </td><td style="text-align: left;"> Added possibility to control multiple windows </td>
</tr>
<tr>
 <td style="text-align: left;">
0.4   </td><td style="text-align: left;"> Compatibility with 2.0.0 tcltk package </td>
</tr>
<tr>
 <td style="text-align: left;">
0.5   </td><td style="text-align: left;"> Added continuous rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
0.6   </td><td style="text-align: left;"> Added par3dsave </td>
</tr>
<tr>
 <td style="text-align: left;">
0.7   </td><td style="text-align: left;"> Added parameters to <code><a href="#topic+tkspinControl">tkspinControl</a></code>, fixed startup </td>
</tr>
<tr>
 <td style="text-align: left;">
0.8   </td><td style="text-align: left;"> Minor fixes to pass checks </td>
</tr>
<tr>
 <td style="text-align: left;">
0.9   </td><td style="text-align: left;"> Merge functions into <span class="pkg">rgl</span> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<hr>
<h2 id='tkspin3d'>Create TCL/TK controller for RGL window</h2><span id='topic+tkspin3d'></span>

<h3>Description</h3>

<p>This function creates a TCL/TK window containing buttons to spin and 
resize one or more RGL windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkspin3d(dev = cur3d(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkspin3d_+3A_dev">dev</code></td>
<td>
<p>A vector of one or more RGL device numbers to control </p>
</td></tr>
<tr><td><code id="tkspin3d_+3A_...">...</code></td>
<td>
<p>Named parameters in that match named formal arguments
to <code><a href="#topic+tkspinControl">tkspinControl</a></code> are passed there, while others are passed to <code><a href="tcltk.html#topic+TkWidgets">tktoplevel</a></code></p>
</td></tr></table>


<h3>Author(s)</h3>

<p> Ming Chen and Duncan Murdoch </p>


<h3>See Also</h3>

 <p><code><a href="#topic+tkspinControl">tkspinControl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive() &amp;&amp; !in_pkgdown_example()) {
    open3d()
    points3d(rnorm(100), rnorm(100), rnorm(100), size=3)
    axes3d()
    box3d()
    tkspin3d()
}
</code></pre>

<hr>
<h2 id='tkspinControl'>Create a spin control in a TCL/TK window</h2><span id='topic+tkspinControl'></span>

<h3>Description</h3>

<p>This function may be used to embed a spin control in a TCL/TK window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkspinControl(base, dev = cur3d(), 
	continue=FALSE, speed=30, scale=100, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkspinControl_+3A_base">base</code></td>
<td>
<p>The TCL/TK frame in which to insert this control.  </p>
</td></tr>
<tr><td><code id="tkspinControl_+3A_dev">dev</code></td>
<td>
<p>A vector of one or more RGL device numbers to control. </p>
</td></tr>
<tr><td><code id="tkspinControl_+3A_continue">continue</code></td>
<td>
<p>Initial setting for continuous rotation checkbox. </p>
</td></tr>
<tr><td><code id="tkspinControl_+3A_speed">speed</code></td>
<td>
<p>Initial setting for speed slider. </p>
</td></tr>
<tr><td><code id="tkspinControl_+3A_scale">scale</code></td>
<td>
<p>Initial setting for scale slider. </p>
</td></tr>
<tr><td><code id="tkspinControl_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code><a href="tcltk.html#topic+TkWidgets">tkframe</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Ming Chen and Duncan Murdoch </p>


<h3>See Also</h3>

<p><code><a href="#topic+spin3d">spin3d</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive() &amp;&amp; !in_pkgdown_example()) { 
    library(tcltk)
    open3d()
    win1 &lt;- cur3d()
    plot3d(rexp(100), rexp(100), rexp(100), size=3, col='green')
    
    open3d()
    win2 &lt;- cur3d()
    plot3d(rt(100,2), rt(100,2), rt(100, 2), size=3, col='yellow')
    
    open3d()
    win3 &lt;- cur3d()
    plot3d(rexp(100), rexp(100), rexp(100), size=3, col='red')
        
    open3d()
    win4 &lt;- cur3d()
    plot3d(rbinom(100,10,0.5), rbinom(100,10,0.5), rbinom(100,10,0.5), size=3, col='cyan')
    
    base &lt;- tktoplevel()
    tkwm.title(base, "Spinners")
    con1 &lt;- tkspinControl(base, dev=c(win1,win2))
    con2 &lt;- tkspinControl(base, dev=c(win3,win4))
    tkpack(con1, con2)
}
</code></pre>

<hr>
<h2 id='toggleWidget'>
An HTML widget to toggle display of elements of a scene
</h2><span id='topic+toggleWidget'></span>

<h3>Description</h3>

<p>This function produces a button in an HTML scene
that will toggle the display of items in the scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toggleWidget(sceneId, 
             ids = tagged3d(tags), tags = NULL, hidden = integer(),
             subscenes = NULL, 
             label, 
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toggleWidget_+3A_sceneid">sceneId</code></td>
<td>

<p>The HTML id of the RGL scene being controlled,
or an object as in <code><a href="#topic+playwidget">playwidget</a></code>.
</p>
</td></tr>
<tr><td><code id="toggleWidget_+3A_ids">ids</code>, <code id="toggleWidget_+3A_hidden">hidden</code></td>
<td>

<p>The RGL id numbers of the objects to toggle.  Those in <code>ids</code>
are initially shown; those in <code>hidden</code> are initially hidden.
</p>
</td></tr>
<tr><td><code id="toggleWidget_+3A_tags">tags</code></td>
<td>

<p>Alternate way to specify <code>ids</code>.  Ignored if <code>ids</code> is
given.
</p>
</td></tr>
<tr><td><code id="toggleWidget_+3A_subscenes">subscenes</code></td>
<td>

<p>The subscenes in which to toggle the objects.
</p>
</td></tr>
<tr><td><code id="toggleWidget_+3A_label">label</code></td>
<td>

<p>The label to put on the button.  The default is set
from the expression passed to <code>ids</code> or the value of <code>tags</code>. 
</p>
</td></tr>
<tr><td><code id="toggleWidget_+3A_...">...</code></td>
<td>

<p>Additional arguments to pass to <code><a href="#topic+playwidget">playwidget</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Like <code><a href="#topic+playwidget">playwidget</a></code>, this function is designed
to work within the <span class="pkg">htmlwidgets</span> framework.  
If the value is printed, the button will be inserted
into the output.
</p>
<p>It is also designed to work with <span class="pkg">magrittr</span>-style
pipes:  the result of <code><a href="#topic+rglwidget">rglwidget</a></code> or
other widgets can be piped into it to add it 
to a display.  It can also appear first in the 
pipeline, if <code>sceneId</code> is set to <code>NA</code>.
</p>


<h3>Value</h3>

<p>A widget suitable for use in an <span class="pkg">Rmarkdown</span>-generated web
page, or elsewhere.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+toggleButton">toggleButton</a></code> for the older style
of HTML control.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theplot &lt;- plot3d(rnorm(100), rnorm(100), rnorm(100), col = "red")
widget &lt;- rglwidget(height = 300, width = 300) %&gt;%
  toggleWidget(theplot["data"], 
               hidden = theplot[c("xlab", "ylab", "zlab")], 
               label = "Points")
if (interactive() || in_pkgdown_example())
  widget
</code></pre>

<hr>
<h2 id='triangulate'>
Triangulate a two-dimensional polygon
</h2><span id='topic+triangulate'></span>

<h3>Description</h3>

<p>This algorithm decomposes a general polygon into simple
polygons and uses the &ldquo;ear-clipping&rdquo; algorithm to triangulate it.
Polygons with holes are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangulate(x, y = NULL, z = NULL, random = TRUE, plot = FALSE, partial = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangulate_+3A_x">x</code>, <code id="triangulate_+3A_y">y</code>, <code id="triangulate_+3A_z">z</code></td>
<td>

<p>Coordinates of a two-dimensional polygon in a format supported by <code><a href="grDevices.html#topic+xyz.coords">xyz.coords</a></code>.  
See Details for how <code>z</code> is handled.
</p>
</td></tr>
<tr><td><code id="triangulate_+3A_random">random</code></td>
<td>

<p>Whether to use a random or deterministic triangulation.
</p>
</td></tr>
<tr><td><code id="triangulate_+3A_plot">plot</code></td>
<td>

<p>Whether to plot the triangulation; mainly for debugging purposes.
</p>
</td></tr>
<tr><td><code id="triangulate_+3A_partial">partial</code></td>
<td>

<p>If the triangulation fails, should partial results be returned?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normally <code>triangulate</code> looks only at the <code>x</code> and <code>y</code>
coordinates.  However, if one of those is constant, it is replaced
with the <code>z</code> coordinate if present.
</p>
<p>The algorithm works as follows.  First, it breaks the polygon into 
pieces separated by <code>NA</code> values in <code>x</code> or <code>y</code>.
Each of these pieces should be a simple, non-self-intersecting
polygon, separate from the other pieces. 
(Though some minor exceptions to this rule may work, none
are guaranteed).  The nesting of these pieces is determined.
</p>
<p>The &ldquo;outer&rdquo; polygon(s) are then merged with the
polygons that they immediately contain, and each of these
pieces is triangulated using the ear-clipping algorithm.  
</p>
<p>Finally, all the triangulated pieces are put together into one
result.
</p>


<h3>Value</h3>

<p>A three-by-n array giving the indices of the vertices of 
each triangle.  (No vertices are added; only the original
vertices are used in the triangulation.)
</p>
<p>The array has an integer vector attribute <code>"nextvert"</code>
with one entry per vertex, giving the index of the next 
vertex to proceed counter-clockwise around outer
polygon boundaries, clockwise around inner boundaries.
</p>


<h3>Note</h3>

<p>Not all inputs will succeed, even when a triangulation is
possible.  Generally using <code>random = TRUE</code> will find
a successful triangulation if one exists, but it may
occasionally take more than one try.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>See the Wikipedia article &ldquo;polygon triangulation&rdquo;
for a description of the ear-clipping algorithm. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extrude3d">extrude3d</a></code> for a solid extrusion of a polygon, <code><a href="#topic+polygon3d">polygon3d</a></code> for
a flat display; both use <code>triangulate</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- seq(0, 2*pi, length.out = 25)[-25]
theta &lt;- c(theta, NA, theta, NA, theta, NA, theta, NA, theta)
r &lt;- c(rep(1.5, 24), NA, rep(0.5, 24), NA, rep(0.5, 24), NA, rep(0.3, 24), NA, rep(0.1, 24))
dx &lt;- c(rep(0, 24), NA, rep(0.6, 24), NA, rep(-0.6, 24), NA, rep(-0.6, 24), NA, rep(-0.6, 24))
x &lt;- r*cos(theta) + dx
y &lt;- r*sin(theta)
plot(x, y, type = "n")
polygon(x, y)
triangulate(x, y, plot = TRUE)
open3d()
polygon3d(x, y, x - y, col = "red")
</code></pre>

<hr>
<h2 id='turn3d'>
Create a solid of rotation from a two-dimensional curve
</h2><span id='topic+turn3d'></span>

<h3>Description</h3>

<p>This function &ldquo;turns&rdquo; the curve (as on a lathe) to form a 
solid of rotation along the x axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turn3d(x, y = NULL, n = 12, smooth = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="turn3d_+3A_x">x</code>, <code id="turn3d_+3A_y">y</code></td>
<td>

<p>Points on the curve, in a form suitable for <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>.
The <code>y</code> values must be non-negative.
</p>
</td></tr>
<tr><td><code id="turn3d_+3A_n">n</code></td>
<td>

<p>How many steps in the rotation?
</p>
</td></tr>
<tr><td><code id="turn3d_+3A_smooth">smooth</code></td>
<td>

<p>logical; whether to add normals for a smooth appearance.
</p>
</td></tr>
<tr><td><code id="turn3d_+3A_...">...</code></td>
<td>

<p>Additional parameters to pass to <code><a href="#topic+tmesh3d">tmesh3d</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mesh object containing triangles and/or quadrilaterals.
</p>


<h3>Author(s)</h3>

<p>Fang He and Duncan Murdoch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extrude3d">extrude3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
y &lt;- rnorm(10)^2
open3d()
shade3d(turn3d(x, y), col = "green")
</code></pre>

<hr>
<h2 id='vertexControl'>
Set attributes of vertices
</h2><span id='topic+vertexControl'></span>

<h3>Description</h3>

<p>This is a function to produce actions in a web display.  A
<code><a href="#topic+playwidget">playwidget</a></code> or Shiny
input control (e.g. a <code><a href="shiny.html#topic+sliderInput">sliderInput</a></code> control)
sets a value which controls attributes of a selection of vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertexControl(value = 0, values = NULL, vertices = 1, attributes,
              objid = tagged3d(tag), tag,
              param = seq_len(NROW(values)) - 1, interp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertexControl_+3A_value">value</code></td>
<td>
<p>The value to use for input (typically <code>input$value</code>
in a Shiny app.)  Not needed with <code><a href="#topic+playwidget">playwidget</a></code>.</p>
</td></tr>
<tr><td><code id="vertexControl_+3A_values">values</code></td>
<td>

<p>A matrix of values, each row corresponding to an input value.
</p>
</td></tr>
<tr><td><code id="vertexControl_+3A_vertices">vertices</code></td>
<td>

<p>Which vertices are being controlled?  Specify <code>vertices</code> as a number from 1 to
the number of vertices in the <code>objid</code>.
</p>
</td></tr>
<tr><td><code id="vertexControl_+3A_attributes">attributes</code></td>
<td>
<p>A vector of attributes of a vertex,
from <code>c("x", "y", "z", "red", "green", "blue", "alpha", "nx", "ny", "nz",
               "radii", "ox", "oy", "oz", "ts", "tt", "offset")</code>.  See
Details.</p>
</td></tr>
<tr><td><code id="vertexControl_+3A_objid">objid</code></td>
<td>

<p>A single RGL object id.
</p>
</td></tr>
<tr><td><code id="vertexControl_+3A_tag">tag</code></td>
<td>

<p>An alternate way to specify <code>objid</code>.
</p>
</td></tr>
<tr><td><code id="vertexControl_+3A_param">param</code></td>
<td>

<p>Parameter values corresponding to each row of <code>values</code>.
</p>
</td></tr>
<tr><td><code id="vertexControl_+3A_interp">interp</code></td>
<td>

<p>Whether to interpolate between rows of <code>values</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function
modifies attributes of vertices in a single
object.  The <code>attributes</code> are properties of each vertex
in a scene; not all are applicable to all objects. In order,
they are: coordinates of the vertex <code>"x", "y", "z"</code>, color
of the vertex <code>"red", "green", "blue", "alpha"</code>, normal at the vertex
<code>"nx", "ny", "nz"</code>, radius of a sphere at the vertex
<code>"radius"</code>, origin within a texture <code>"ox", "oy"</code> and
perhaps <code>"oz"</code>, texture coordinates <code>"ts", "tt"</code>.
</p>
<p>Planes are handled specially.  The coefficients <code>a, b, c</code>
in the <code><a href="#topic+planes3d">planes3d</a></code> or <code><a href="#topic+clipplanes3d">clipplanes3d</a></code> 
specification are controlled 
using <code>"nx", "ny", "nz"</code>, and <code>d</code> is handled as
<code>"offset"</code>.  The <code>vertices</code> argument is interpreted
as the indices of the planes when these attributes are set.
</p>
<p>If only one attribute of one vertex is specified, <code>values</code> may
be given as a vector and will be treated as a one-column matrix.  Otherwise
<code>values</code> must be given as a matrix with <code>ncol(values) == max(length(vertices),
length(attributes))</code>.  The <code>vertices</code> and <code>attributes</code> vectors will be recycled to the same length, and entries from column <code>j</code> of <code>values</code> will be applied to 
vertex <code>vertices[j]</code>, attribute <code>attributes[j]</code>.
</p>
<p>The <code>value</code> argument is translated into a row (or two rows if
<code>interp = TRUE</code>) of <code>values</code>
by finding its location in <code>param</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>"rglControl"</code> of cleaned up parameter
values, to be used in an RGL widget.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  saveopts &lt;- options(rgl.useNULL = TRUE)

  theta &lt;- seq(0, 6*pi, length.out = 100)
  xyz &lt;- cbind(sin(theta), cos(theta), theta)
  plot3d(xyz, type="l")
  id &lt;- spheres3d(xyz[1,,drop=FALSE], col="red")

  widget &lt;- rglwidget(width=500, height=300) %&gt;%
  playwidget(vertexControl(values=xyz,
                           attributes=c("x", "y", "z"),
                           objid = id, param=1:100),
             start = 1, stop = 100, rate=10)
  if (interactive() || in_pkgdown_example())
    widget
  options(saveopts)
</code></pre>

<hr>
<h2 id='viewpoint'>Set up viewpoint</h2><span id='topic+view3d'></span>

<h3>Description</h3>

<p>Set the viewpoint orientation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view3d( theta = 0, phi = 15, fov = 60, zoom = 1, 
        scale = par3d("scale"), interactive = TRUE, userMatrix, 
        type = c("userviewpoint", "modelviewpoint") )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viewpoint_+3A_theta">theta</code>, <code id="viewpoint_+3A_phi">phi</code></td>
<td>
<p>polar coordinates in degrees. <code>theta</code> rotates round the vertical axis. <code>phi</code> rotates round the horizontal axis.</p>
</td></tr>
<tr><td><code id="viewpoint_+3A_fov">fov</code></td>
<td>
<p>field-of-view angle in degrees</p>
</td></tr>
<tr><td><code id="viewpoint_+3A_zoom">zoom</code></td>
<td>
<p>zoom factor</p>
</td></tr>
<tr><td><code id="viewpoint_+3A_scale">scale</code></td>
<td>
<p>real length 3 vector specifying the rescaling to apply to each axis</p>
</td></tr>
<tr><td><code id="viewpoint_+3A_interactive">interactive</code></td>
<td>
<p>logical, specifying if interactive navigation is allowed</p>
</td></tr>
<tr><td><code id="viewpoint_+3A_usermatrix">userMatrix</code></td>
<td>
<p>4x4 matrix specifying user point of view</p>
</td></tr>
<tr><td><code id="viewpoint_+3A_type">type</code></td>
<td>
<p>which viewpoint to set?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data model can be rotated using the polar coordinates <code>theta</code>
and <code>phi</code>.  Alternatively, it can be set in a completely general way using the 4x4 matrix
<code>userMatrix</code>.  If <code>userMatrix</code> is specified, <code>theta</code> and <code>phi</code> are ignored.
</p>
<p>The pointing device of your graphics user-interface can also be used to 
set the viewpoint interactively. With the pointing device the buttons are by default set as follows:
</p>

<dl>
<dt>left</dt><dd><p>adjust viewpoint position</p>
</dd>
<dt>middle</dt><dd><p>adjust field of view angle</p>
</dd>
<dt>right or wheel</dt><dd><p>adjust zoom factor</p>
</dd>
</dl>

<p>The user's view can be set with <code>fov</code> and <code>zoom</code>.
</p>
<p>If the <code>fov</code> angle is set to 0, a parallel or orthogonal
projection is used. Small non-zero values (e.g. 0.01 or less, but not
0.0) are likely to lead to rendering errors due to OpenGL limitations.
</p>
<p>Prior to version 0.94, all of these characteristics were stored in 
one viewpoint object.  With that release the characteristics are split
into those that affect the projection (the user viewpoint) and those that
affect the model (the model viewpoint).  By default, this function
sets both, but the <code>type</code> argument can be used to limit the effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+par3d">par3d</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# animated round trip tour for 10 seconds

open3d()
shade3d(oh3d(), color = "red")

start &lt;- proc.time()[3]
while ((i &lt;- 36*(proc.time()[3] - start)) &lt; 360) {
  view3d(i, i/4); 
}

## End(Not run)
</code></pre>

<hr>
<h2 id='writeASY'>
Write Asymptote code for an RGL scene
</h2><span id='topic+writeASY'></span>

<h3>Description</h3>

<p>Asymptote is a language for 3D graphics that
is highly integrated with LaTeX.  This is
an experimental function to
write an Asymptote program to approximate 
an RGL scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeASY(scene = scene3d(),
         title = "scene", 
         outtype = c("pdf", "eps", "asy", "latex", "pdflatex"), 
         prc = TRUE, 
         runAsy = "asy %filename%", 
         defaultFontsize = 12,
         width = 7, height = 7,
         ppi = 100,
         ids = tagged3d(tags),
         tags = NULL, 
         version = "2.65")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeASY_+3A_scene">scene</code></td>
<td>
<p>RGL scene object</p>
</td></tr>
<tr><td><code id="writeASY_+3A_outtype">outtype</code></td>
<td>

<p>What type of file to write?  See Details.
</p>
</td></tr>
<tr><td><code id="writeASY_+3A_prc">prc</code></td>
<td>

<p>Whether to produce an interactive PRC scene.
</p>
</td></tr>
<tr><td><code id="writeASY_+3A_title">title</code></td>
<td>

<p>The base of the filename to produce.
</p>
</td></tr>
<tr><td><code id="writeASY_+3A_runasy">runAsy</code></td>
<td>

<p>Code to run the Asymptote program.
</p>
</td></tr>
<tr><td><code id="writeASY_+3A_defaultfontsize">defaultFontsize</code></td>
<td>

<p>The default fontsize for text. 
</p>
</td></tr>
<tr><td><code id="writeASY_+3A_width">width</code>, <code id="writeASY_+3A_height">height</code></td>
<td>

<p>Width and height of the output image, in inches.
</p>
</td></tr>
<tr><td><code id="writeASY_+3A_ppi">ppi</code></td>
<td>

<p>&ldquo;Pixels per inch&rdquo; to assume when converting
line widths and point sizes (which RGL measures in 
pixels).
</p>
</td></tr>
<tr><td><code id="writeASY_+3A_ids">ids</code></td>
<td>

<p>If not <code>NULL</code>, write out just these
RGL objects.
</p>
</td></tr>
<tr><td><code id="writeASY_+3A_tags">tags</code></td>
<td>

<p>Alternate way to specify <code>ids</code>.  Ignored if <code>ids</code> is
given.
</p>
</td></tr>
<tr><td><code id="writeASY_+3A_version">version</code></td>
<td>

<p>Asymptote version 2.44 had a definition for its &ldquo;light()&rdquo; function
that was incompatibly changed in versions 2.47 and 2.50.  
The current code has been tested with version 2.65.
If you are using an older version, set <code>version</code>
to your version number and it may work better.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Asymptote is both a language describing a 
2D or 3D graphic, and a program to interpret
that language and produce output in a variety
of formats including EPS, PDF (interactive
or static), etc.
</p>
<p>The interactive scene produced with <code>prc = TRUE</code>
requires <code>outtype = "pdf"</code>, and (as of this
writing) has a number of limitations:
</p>

<ul>
<li><p>As far as we know, only Adobe Acrobat Reader of a sufficiently recent version can display 
these scenes.
</p>
</li>
<li><p>Current versions ignore lighting settings.
</p>
</li></ul>



<h3>Value</h3>

<p>The filename of the output file is returned
invisibly.
</p>


<h3>Note</h3>

<p>This function is currently under development and limited in the quality
of output it produces.  Arguments will likely
change.
</p>
<p>There are a number of differences between the interactive display in 
Asymptote and the display in RGL.  In particular, many objects that are
a fixed size in RGL will scale with the image in Asymptote.  Defaults
have been chosen somewhat arbitrarily; tweaking will likely be needed.
</p>
<p>Material properties of surfaces are not yet implemented.
</p>
<p>On some systems, the program  <code>asy</code>  used
to process the output has bugs and may fail.  Run the example
at your own risk!
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>J. C. Bowman and A. Hammerlindl (2008). Asymptote: A vector graphics language, 
TUGBOAT: The Communications of the TeX Users Group, 29:2, 288-294.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scene3d">scene3d</a></code> saves a copy of a scene to an R variable; <code><a href="#topic+rglwidget">rglwidget</a></code>,
<code><a href="#topic+writePLY">writePLY</a></code>, <code><a href="#topic+writeOBJ">writeOBJ</a></code> and <code><a href="#topic+writeSTL">writeSTL</a></code>
write the scene to a file in various other formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# On some systems, the program  "asy"  used
# to process the output has bugs, so this may fail.
x &lt;- rnorm(20)
y &lt;- rnorm(20)
z &lt;- rnorm(20)
plot3d(x, y, z, type = "s", col = "red")
olddir &lt;- setwd(tempdir())
writeASY(title = "interactive")  # Produces interactive.pdf
writeASY(title = "noninteractive", prc = FALSE) # Produces noninteractive.pdf
setwd(olddir)

## End(Not run)
</code></pre>

<hr>
<h2 id='writeOBJ'>
Read and write Wavefront OBJ format files
</h2><span id='topic+writeOBJ'></span><span id='topic+readOBJ'></span>

<h3>Description</h3>

<p><code>writeOBJ</code> writes OBJ files.  This is a file format that
is commonly used in 3D graphics applications.  It does not represent text,
but does represent points, lines, polygons (and many other types that
RGL doesn't support).  <code>readOBJ</code> reads only some parts
of OBJ files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeOBJ(con, 
         pointRadius = 0.005, pointShape = icosahedron3d(), 
         lineRadius = pointRadius, lineSides = 20, 
         pointsAsPoints = FALSE, linesAsLines = FALSE, 
         withNormals = TRUE, withTextures = TRUE, 
         separateObjects = TRUE,
         ids = tagged3d(tags),
         tags = NULL)
readOBJ(con, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeOBJ_+3A_con">con</code></td>
<td>

<p>A connection or filename.
</p>
</td></tr>
<tr><td><code id="writeOBJ_+3A_pointradius">pointRadius</code>, <code id="writeOBJ_+3A_lineradius">lineRadius</code></td>
<td>

<p>The radius of points and lines relative to the overall scale of the figure,
if they are converted to polyhedra.
</p>
</td></tr>
<tr><td><code id="writeOBJ_+3A_pointshape">pointShape</code></td>
<td>

<p>A mesh shape to use for points if they are converted.  It is scaled by the <code>pointRadius</code>.
</p>
</td></tr>
<tr><td><code id="writeOBJ_+3A_linesides">lineSides</code></td>
<td>

<p>Lines are rendered as cylinders with this many sides.
</p>
</td></tr>
<tr><td><code id="writeOBJ_+3A_pointsaspoints">pointsAsPoints</code>, <code id="writeOBJ_+3A_linesaslines">linesAsLines</code></td>
<td>

<p>Whether to convert points and lines to &ldquo;point&rdquo; and &ldquo;line&rdquo; records in the OBJ output.
</p>
</td></tr>
<tr><td><code id="writeOBJ_+3A_withnormals">withNormals</code></td>
<td>

<p>Whether to output vertex normals for smooth shading.
</p>
</td></tr>
<tr><td><code id="writeOBJ_+3A_separateobjects">separateObjects</code></td>
<td>

<p>Whether to mark each RGL object as a separate object in the file.
</p>
</td></tr>
<tr><td><code id="writeOBJ_+3A_withtextures">withTextures</code></td>
<td>

<p>Whether to output texture coordinates.
</p>
</td></tr>
<tr><td><code id="writeOBJ_+3A_ids">ids</code></td>
<td>

<p>The identifiers (from <code><a href="#topic+ids3d">ids3d</a></code>) of the
objects to write.  If <code>NULL</code>, try to write everything.
</p>
</td></tr>
<tr><td><code id="writeOBJ_+3A_tags">tags</code></td>
<td>

<p>Alternate way to specify <code>ids</code>.  Ignored if <code>ids</code> is
given.
</p>
</td></tr>
<tr><td><code id="writeOBJ_+3A_...">...</code></td>
<td>

<p>Additional arguments (typically just <code>material</code>) to pass to
<code><a href="#topic+tmesh3d">tmesh3d</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current <code>writeOBJ</code> implementation only outputs triangles, quads, planes, spheres,
points, line segments, line strips and surfaces.  It does not output material
properties such as colors, since the OBJ format does not support the per-vertex
colors that RGL uses.  
</p>
<p>The <code>readOBJ</code> implementation can
read faces, normals, and textures coordinates, but ignores
material properties (including the specification of the texture
file to use).  To read a file that uses a single texture,
specify it in the <code>material</code> argument, e.g.
<code>readOBJ("model.OBJ", material = list(color = "white", texture = "texture.png"))</code>.  There is no support for files that use
multiple textures.
</p>
<p>The defaults for <code>pointsAsPoints</code> and <code>linesAsLines</code> have been
chosen because Blender (<a href="https://www.blender.org">https://www.blender.org</a>) does not import
points or lines, only polygons.  If you are exporting to other software you
may want to change them.
</p>
<p>If present, texture coordinates are output by default, but the
textures themselves are not.
</p>
<p>Individual RGL objects are output as separate objects in the file when 
<code>separateObjects = TRUE</code>, the default.
</p>
<p>The output file should be readable by Blender and Meshlab; the latter can write in
a number of other formats, including U3D, suitable for import into a PDF document.
</p>


<h3>Value</h3>

<p><code>writeObj</code> invisibly returns the name of the connection to which the 
data was written.
</p>
<p><code>readObj</code> returns a mesh object constructed
from the input file.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>The file format was found at <a href="http://www.martinreddy.net/gfx/3d/OBJ.spec">http://www.martinreddy.net/gfx/3d/OBJ.spec</a>
on November 11, 2012.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scene3d">scene3d</a></code> saves a copy of a scene to an R variable; <code><a href="#topic+rglwidget">rglwidget</a></code>, <code><a href="#topic+writeASY">writeASY</a></code>,
<code><a href="#topic+writePLY">writePLY</a></code> and <code><a href="#topic+writeSTL">writeSTL</a></code>
write the scene to a file in various other formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename &lt;- tempfile(fileext = ".obj")
open3d()
shade3d( icosahedron3d() )
writeOBJ(filename)

# The motivation for writing readObj() was to read a shape
# file of Comet 67P/Churyumov-Gerasimenko, from the ESA.
# The file no longer appears to be online, but may still be
# available on archive.org.  Here was the original URL:
#   cometurl &lt;- "http://sci.esa.int/science-e/www/object/doc.cfm?fobjectid=54726"
# This code would read and display it:
#   open3d()
#   shade3d(readOBJ(url(cometurl), 
#                   material = list(col = "gray")))


# Textures are used in a realistic hand image available from
# https://free3d.com/3d-model/freerealsichand-85561.html
# Thanks to Monte Shaffer for pointing this out.
# Decompress the files into the current directory, convert
# hand_mapNew.jpg to hand_mapNew.png, then use
## Not run: 
open3d()
shade3d(readOBJ("hand.OBJ", material = list(color = "white", 
shininess = 1, texture = "hand_mapNew.png")))

## End(Not run)
</code></pre>

<hr>
<h2 id='writePLY'>
Write Stanford PLY format files
</h2><span id='topic+writePLY'></span>

<h3>Description</h3>

<p>This function writes PLY files.  This is a simple file format that
is commonly used in 3D printing.  It does not represent text,
only edges and polygons.  The <code>writePLY</code> function 
does the necessary conversions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writePLY(con, format = c("little_endian", "big_endian", "ascii"), 
         pointRadius = 0.005, pointShape = icosahedron3d(), 
         lineRadius = pointRadius, lineSides = 20, 
         pointsAsEdges = FALSE, linesAsEdges = pointsAsEdges, 
         withColors = TRUE, withNormals = !(pointsAsEdges || linesAsEdges), 
         ids = tagged3d(tags), tags = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writePLY_+3A_con">con</code></td>
<td>

<p>A connection or filename.
</p>
</td></tr>
<tr><td><code id="writePLY_+3A_format">format</code></td>
<td>

<p>Which output format.  Defaults to little-endian binary.
</p>
</td></tr>
<tr><td><code id="writePLY_+3A_pointradius">pointRadius</code>, <code id="writePLY_+3A_lineradius">lineRadius</code></td>
<td>

<p>The radius of points and lines relative to the overall scale of the figure,
if they are converted to polyhedra.
</p>
</td></tr>
<tr><td><code id="writePLY_+3A_pointshape">pointShape</code></td>
<td>

<p>A mesh shape to use for points if they are converted.  It is scaled by the <code>pointRadius</code>.
</p>
</td></tr>
<tr><td><code id="writePLY_+3A_linesides">lineSides</code></td>
<td>

<p>Lines are rendered as cylinders with this many sides.
</p>
</td></tr>
<tr><td><code id="writePLY_+3A_pointsasedges">pointsAsEdges</code>, <code id="writePLY_+3A_linesasedges">linesAsEdges</code></td>
<td>

<p>Whether to convert points and lines to &ldquo;Edge&rdquo; records in the PLY output.
</p>
</td></tr>
<tr><td><code id="writePLY_+3A_withcolors">withColors</code></td>
<td>

<p>Whether to output vertex color information.
</p>
</td></tr>
<tr><td><code id="writePLY_+3A_withnormals">withNormals</code></td>
<td>

<p>Whether to output vertex normals for smooth shading.
</p>
</td></tr>
<tr><td><code id="writePLY_+3A_ids">ids</code></td>
<td>

<p>The identifiers (from <code><a href="#topic+ids3d">ids3d</a></code>) of the
objects to write.  If <code>NULL</code>, try to write everything.
</p>
</td></tr>
<tr><td><code id="writePLY_+3A_tags">tags</code></td>
<td>

<p>Select objects with matching tags.  Ignored
if <code>ids</code> is specified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current implementation only outputs triangles, quads, planes, spheres,
points, line segments, line strips and surfaces.
</p>
<p>The defaults for <code>pointsAsEdges</code> and <code>linesAsEdges</code> have been
chosen because Blender (<a href="https://www.blender.org">https://www.blender.org</a>) does not import
lines, only polygons.  If you are exporting to other software you
may want to change them.
</p>
<p>Since the PLY format only allows one object per file, all RGL objects
are combined into a single object when output.
</p>
<p>The output file is readable by Blender and Meshlab; the latter can write in
a number of other formats, including U3D, suitable for import into a PDF document.
</p>


<h3>Value</h3>

<p>Invisibly returns the name of the connection to which the 
data was written.
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>The file format was found on <a href="https://www.mathworks.com">https://www.mathworks.com</a> on November 10, 2012
at a URL that no longer exists; currently the
format is described at <a href="https://www.mathworks.com/help/vision/ug/the-ply-format.html">https://www.mathworks.com/help/vision/ug/the-ply-format.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scene3d">scene3d</a></code> saves a copy of a scene to an R variable;
<code><a href="#topic+rglwidget">rglwidget</a></code>, <code><a href="#topic+writeASY">writeASY</a></code>, <code><a href="#topic+writeOBJ">writeOBJ</a></code> and <code><a href="#topic+writeSTL">writeSTL</a></code>
write the scene to a file in various other formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename &lt;- tempfile(fileext = ".ply")
open3d()
shade3d( icosahedron3d(col = "magenta") )
writePLY(filename)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
