<!DOCTYPE html><html lang="en"><head><title>Help for package anomalize</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {anomalize}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anomalize_package'><p>anomalize: Tidy anomaly detection</p></a></li>
<li><a href='#anomalize'><p>Detect anomalies using the tidyverse</p></a></li>
<li><a href='#anomalize_methods'><p>Methods that power anomalize()</p></a></li>
<li><a href='#clean_anomalies'><p>Clean anomalies from anomalized data</p></a></li>
<li><a href='#decompose_methods'><p>Methods that power time_decompose()</p></a></li>
<li><a href='#plot_anomalies'><p>Visualize the anomalies in one or multiple time series</p></a></li>
<li><a href='#plot_anomaly_decomposition'><p>Visualize the time series decomposition with anomalies shown</p></a></li>
<li><a href='#prep_tbl_time'><p>Automatically create tibbletime objects from tibbles</p></a></li>
<li><a href='#set_time_scale_template'><p>Get and modify time scale template</p></a></li>
<li><a href='#tidyverse_cran_downloads'><p>Downloads of various &quot;tidyverse&quot; packages from CRAN</p></a></li>
<li><a href='#time_apply'><p>Apply a function to a time series by period</p></a></li>
<li><a href='#time_decompose'><p>Decompose a time series in preparation for anomaly detection</p></a></li>
<li><a href='#time_frequency'><p>Generate a time series frequency from a periodicity</p></a></li>
<li><a href='#time_recompose'><p>Recompose bands separating anomalies from &quot;normal&quot; observations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tidy Anomaly Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>
    The 'anomalize' package enables a "tidy" workflow for detecting anomalies in data.
    The main functions are time_decompose(), anomalize(), and time_recompose().
    When combined, it's quite simple to decompose time series, detect anomalies,
    and create bands separating the "normal" data from the anomalous data at scale (i.e. for multiple time series). 
    Time series decomposition is used to remove trend and seasonal components via the time_decompose() function
    and methods include seasonal decomposition of time series by Loess ("stl") and 
    seasonal decomposition by piecewise medians ("twitter"). The anomalize() function implements
    two methods for anomaly detection of residuals including using an inner quartile range ("iqr")
    and generalized extreme studentized deviation ("gesd"). These methods are based on
    those used in the 'forecast' package and the Twitter 'AnomalyDetection' package. 
    Refer to the associated functions for specific references for these methods. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/business-science/anomalize">https://github.com/business-science/anomalize</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/business-science/anomalize/issues">https://github.com/business-science/anomalize/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, glue, timetk, sweep, tibbletime (&ge; 0.1.5), purrr,
rlang, tibble, tidyr (&ge; 1.0.0), ggplot2</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tidyverse, tidyquant, stringr, testthat (&ge; 2.1.0), covr,
knitr, rmarkdown, devtools, roxygen2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-31 20:39:32 UTC; mdancho</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Dancho [aut, cre],
  Davis Vaughan [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Dancho &lt;mdancho@business-science.io&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-31 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anomalize_package'>anomalize: Tidy anomaly detection</h2><span id='topic+anomalize_package'></span><span id='topic+anomalize-package'></span>

<h3>Description</h3>

<p>The 'anomalize' package enables a &quot;tidy&quot; workflow for detecting anomalies in data.
The main functions are time_decompose(), anomalize(), and time_recompose().
When combined, it's quite simple to decompose time series, detect anomalies,
and create bands separating the &quot;normal&quot; data from the anomalous data at scale (i.e. for multiple time series).
Time series decomposition is used to remove trend and seasonal components via the time_decompose() function
and methods include seasonal decomposition of time series by Loess and
seasonal decomposition by piecewise medians. The anomalize() function implements
two methods for anomaly detection of residuals including using an inner quartile range
and generalized extreme studentized deviation. These methods are based on
those used in the <code>forecast</code> package and the Twitter <code>AnomalyDetection</code> package.
Refer to the associated functions for specific references for these methods.
</p>


<h3>Details</h3>

<p>To learn more about <code>anomalize</code>, start with the vignettes:
<code>browseVignettes(package = "anomalize")</code>
</p>

<hr>
<h2 id='anomalize'>Detect anomalies using the tidyverse</h2><span id='topic+anomalize'></span>

<h3>Description</h3>

<p>The <code>anomalize()</code> function is used to detect outliers in a distribution
with no trend or seasonality present. It takes the output of <code><a href="#topic+time_decompose">time_decompose()</a></code>,
which has be de-trended and applies anomaly detection methods to identify outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anomalize(
  data,
  target,
  method = c("iqr", "gesd"),
  alpha = 0.05,
  max_anoms = 0.2,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anomalize_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> or <code>tbl_time</code> object.</p>
</td></tr>
<tr><td><code id="anomalize_+3A_target">target</code></td>
<td>
<p>A column to apply the function to</p>
</td></tr>
<tr><td><code id="anomalize_+3A_method">method</code></td>
<td>
<p>The anomaly detection method. One of <code>"iqr"</code> or <code>"gesd"</code>.
The IQR method is faster at the expense of possibly not being quite as accurate.
The GESD method has the best properties for outlier detection, but is loop-based
and therefore a bit slower.</p>
</td></tr>
<tr><td><code id="anomalize_+3A_alpha">alpha</code></td>
<td>
<p>Controls the width of the &quot;normal&quot; range.
Lower values are more conservative while higher values are less prone
to incorrectly classifying &quot;normal&quot; observations.</p>
</td></tr>
<tr><td><code id="anomalize_+3A_max_anoms">max_anoms</code></td>
<td>
<p>The maximum percent of anomalies permitted to be identified.</p>
</td></tr>
<tr><td><code id="anomalize_+3A_verbose">verbose</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, will return a list containing useful information
about the anomalies. If <code>FALSE</code>, just returns the data expanded with the anomalies and
the lower (l1) and upper (l2) bounds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The return has three columns:
&quot;remainder_l1&quot; (lower limit for anomalies), &quot;remainder_l2&quot; (upper limit for
anomalies), and &quot;anomaly&quot; (Yes/No).
</p>
<p>Use <code><a href="#topic+time_decompose">time_decompose()</a></code> to decompose a time series prior to performing
anomaly detection with <code>anomalize()</code>.  Typically, <code>anomalize()</code> is
performed on the &quot;remainder&quot; of the time series decomposition.
</p>
<p>For non-time series data (data without trend), the <code>anomalize()</code> function can
be used without time series decomposition.
</p>
<p>The <code>anomalize()</code> function uses two methods for outlier detection
each with benefits.
</p>
<p><strong>IQR</strong>:
</p>
<p>The IQR Method uses an innerquartile range of 25% and 75% to establish a baseline distribution around
the median. With the default <code>alpha = 0.05</code>, the limits are established by expanding
the 25/75 baseline by an IQR Factor of 3 (3X). The IQR Factor = 0.15 / alpha (hense 3X with alpha = 0.05).
To increase the IQR Factor controling the limits, decrease the alpha, which makes
it more difficult to be an outlier. Increase alpha to make it easier to be an outlier.
</p>
<p>The IQR method is used in <a href="https://github.com/robjhyndman/forecast"><code>forecast::tsoutliers()</code></a>.
</p>
<p><strong>GESD</strong>:
</p>
<p>The GESD Method (Generlized Extreme Studentized Deviate Test) progressively
eliminates outliers using a Student's T-Test comparing the test statistic to a critical value.
Each time an outlier is removed, the test statistic is updated. Once test statistic
drops below the critical value, all outliers are considered removed. Because this method
involves continuous updating via a loop, it is slower than the IQR method. However, it
tends to be the best performing method for outlier removal.
</p>
<p>The GESD method is used in <a href="https://github.com/twitter/AnomalyDetection"><code>AnomalyDection::AnomalyDetectionTs()</code></a>.
</p>


<h3>Value</h3>

<p>Returns a <code>tibble</code> / <code>tbl_time</code> object or list depending on the value of <code>verbose</code>.
</p>


<h3>References</h3>


<ol>
<li> <p><a href="https://stats.stackexchange.com/questions/69874/how-to-correct-outliers-once-detected-for-time-series-data-forecasting">How to correct outliers once detected for time series data forecasting? Cross Validated, https://stats.stackexchange.com</a>
</p>
</li>
<li> <p><a href="https://stats.stackexchange.com/questions/1142/simple-algorithm-for-online-outlier-detection-of-a-generic-time-series?">Cross Validated: Simple algorithm for online outlier detection of a generic time series. Cross Validated, https://stats.stackexchange.com</a>
</p>
</li>
<li> <p><a href="https://www.usenix.org/system/files/conference/hotcloud14/hotcloud14-vallis.pdf">Owen S. Vallis, Jordan Hochenbaum and Arun Kejariwal (2014). A Novel Technique for Long-Term Anomaly Detection in the Cloud. Twitter Inc.</a>
</p>
</li>
<li> <p><a href="https://github.com/twitter/AnomalyDetection">Owen S. Vallis, Jordan Hochenbaum and Arun Kejariwal (2014). AnomalyDetection: Anomaly Detection Using Seasonal Hybrid Extreme Studentized Deviate Test. R package version 1.0.</a>
</p>
</li>
<li><p> Alex T.C. Lau (November/December 2015). GESD - A Robust and Effective Technique for Dealing with Multiple Outliers. ASTM Standardization News. www.astm.org/sn
</p>
</li></ol>



<h3>See Also</h3>

<p>Anomaly Detection Methods (Powers <code>anomalize</code>)
</p>

<ul>
<li> <p><code><a href="#topic+iqr">iqr()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+gesd">gesd()</a></code>
</p>
</li></ul>

<p>Time Series Anomaly Detection Functions (anomaly detection workflow):
</p>

<ul>
<li> <p><code><a href="#topic+time_decompose">time_decompose()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+time_recompose">time_recompose()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dplyr)

# Needed to pass CRAN check / This is loaded by default
set_time_scale_template(time_scale_template())

data(tidyverse_cran_downloads)

tidyverse_cran_downloads %&gt;%
    time_decompose(count, method = "stl") %&gt;%
    anomalize(remainder, method = "iqr")

## End(Not run)

</code></pre>

<hr>
<h2 id='anomalize_methods'>Methods that power anomalize()</h2><span id='topic+anomalize_methods'></span><span id='topic+iqr'></span><span id='topic+gesd'></span>

<h3>Description</h3>

<p>Methods that power anomalize()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iqr(x, alpha = 0.05, max_anoms = 0.2, verbose = FALSE)

gesd(x, alpha = 0.05, max_anoms = 0.2, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anomalize_methods_+3A_x">x</code></td>
<td>
<p>A vector of numeric data.</p>
</td></tr>
<tr><td><code id="anomalize_methods_+3A_alpha">alpha</code></td>
<td>
<p>Controls the width of the &quot;normal&quot; range.
Lower values are more conservative while higher values are less prone
to incorrectly classifying &quot;normal&quot; observations.</p>
</td></tr>
<tr><td><code id="anomalize_methods_+3A_max_anoms">max_anoms</code></td>
<td>
<p>The maximum percent of anomalies permitted to be identified.</p>
</td></tr>
<tr><td><code id="anomalize_methods_+3A_verbose">verbose</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, will return a list containing useful information
about the anomalies. If <code>FALSE</code>, just returns a vector of &quot;Yes&quot; / &quot;No&quot; values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns character vector or list depending on the value of <code>verbose</code>.
</p>


<h3>References</h3>


<ul>
<li><p> The IQR method is used in <a href="https://github.com/robjhyndman/forecast/blob/master/R/clean.R"><code>forecast::tsoutliers()</code></a>
</p>
</li>
<li><p> The GESD method is used in Twitter's <a href="https://github.com/twitter/AnomalyDetection"><code>AnomalyDetection</code></a> package and is also available as a function in <a href="https://github.com/raunakms/GESD/blob/master/runGESD.R">@raunakms's GESD method</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+anomalize">anomalize()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(100)
x &lt;- rnorm(100)
idx_outliers &lt;- sample(100, size = 5)
x[idx_outliers] &lt;- x[idx_outliers] + 10

iqr(x, alpha = 0.05, max_anoms = 0.2)
iqr(x, alpha = 0.05, max_anoms = 0.2, verbose = TRUE)

gesd(x, alpha = 0.05, max_anoms = 0.2)
gesd(x, alpha = 0.05, max_anoms = 0.2, verbose = TRUE)


</code></pre>

<hr>
<h2 id='clean_anomalies'>Clean anomalies from anomalized data</h2><span id='topic+clean_anomalies'></span>

<h3>Description</h3>

<p>Clean anomalies from anomalized data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_anomalies(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_anomalies_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> or <code>tbl_time</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>clean_anomalies()</code> function is used to replace outliers with the seasonal and trend component.
This is often desirable when forecasting with noisy time series data to improve trend detection.
</p>
<p>To clean anomalies, the input data must be detrended with <code>time_decompose()</code> and anomalized with <code>anomalize()</code>.
The data can also be recomposed with <code>time_recompose()</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>tibble</code> / <code>tbl_time</code> object with a new column &quot;observed_cleaned&quot;.
</p>


<h3>See Also</h3>

<p>Time Series Anomaly Detection Functions (anomaly detection workflow):
</p>

<ul>
<li> <p><code><a href="#topic+time_decompose">time_decompose()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+anomalize">anomalize()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+time_recompose">time_recompose()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(dplyr)

# Needed to pass CRAN check / This is loaded by default
set_time_scale_template(time_scale_template())

data(tidyverse_cran_downloads)

tidyverse_cran_downloads %&gt;%
    time_decompose(count, method = "stl") %&gt;%
    anomalize(remainder, method = "iqr") %&gt;%
    clean_anomalies()

## End(Not run)

</code></pre>

<hr>
<h2 id='decompose_methods'>Methods that power time_decompose()</h2><span id='topic+decompose_methods'></span><span id='topic+decompose_twitter'></span><span id='topic+decompose_stl'></span>

<h3>Description</h3>

<p>Methods that power time_decompose()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decompose_twitter(
  data,
  target,
  frequency = "auto",
  trend = "auto",
  message = TRUE
)

decompose_stl(data, target, frequency = "auto", trend = "auto", message = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decompose_methods_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> or <code>tbl_time</code> object.</p>
</td></tr>
<tr><td><code id="decompose_methods_+3A_target">target</code></td>
<td>
<p>A column to apply the function to</p>
</td></tr>
<tr><td><code id="decompose_methods_+3A_frequency">frequency</code></td>
<td>
<p>Controls the seasonal adjustment (removal of seasonality).
Input can be either &quot;auto&quot;, a time-based definition (e.g. &quot;1 week&quot;),
or a numeric number of observations per frequency (e.g. 10).
Refer to <code><a href="#topic+time_frequency">time_frequency()</a></code>.</p>
</td></tr>
<tr><td><code id="decompose_methods_+3A_trend">trend</code></td>
<td>
<p>Controls the trend component
For stl, the trend controls the sensitivity of the lowess smoother, which is used to remove the remainder.
For twitter, the trend controls the period width of the median, which are used to remove the trend and center the remainder.</p>
</td></tr>
<tr><td><code id="decompose_methods_+3A_message">message</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, will output information related to <code>tbl_time</code> conversions, frequencies,
and trend / median spans (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tbl_time</code> object containing the time series decomposition.
</p>


<h3>References</h3>


<ul>
<li><p> The &quot;twitter&quot; method is used in Twitter's <a href="https://github.com/twitter/AnomalyDetection"><code>AnomalyDetection</code> package</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+time_decompose">time_decompose()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

tidyverse_cran_downloads %&gt;%
    ungroup() %&gt;%
    filter(package == "tidyquant") %&gt;%
    decompose_stl(count)


</code></pre>

<hr>
<h2 id='plot_anomalies'>Visualize the anomalies in one or multiple time series</h2><span id='topic+plot_anomalies'></span>

<h3>Description</h3>

<p>Visualize the anomalies in one or multiple time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_anomalies(
  data,
  time_recomposed = FALSE,
  ncol = 1,
  color_no = "#2c3e50",
  color_yes = "#e31a1c",
  fill_ribbon = "grey70",
  alpha_dots = 1,
  alpha_circles = 1,
  alpha_ribbon = 1,
  size_dots = 1.5,
  size_circles = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_anomalies_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> or <code>tbl_time</code> object.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_time_recomposed">time_recomposed</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, will use the <code>time_recompose()</code> bands to
place bands as approximate limits around the &quot;normal&quot; data.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns to display. Set to 1 for single column by default.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_color_no">color_no</code></td>
<td>
<p>Color for non-anomalous data.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_color_yes">color_yes</code></td>
<td>
<p>Color for anomalous data.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_fill_ribbon">fill_ribbon</code></td>
<td>
<p>Fill color for the time_recomposed ribbon.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_alpha_dots">alpha_dots</code></td>
<td>
<p>Controls the transparency of the dots. Reduce when too many dots on the screen.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_alpha_circles">alpha_circles</code></td>
<td>
<p>Controls the transparency of the circles that identify anomalies.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_alpha_ribbon">alpha_ribbon</code></td>
<td>
<p>Controls the transparency of the time_recomposed ribbon.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_size_dots">size_dots</code></td>
<td>
<p>Controls the size of the dots.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_size_circles">size_circles</code></td>
<td>
<p>Controls the size of the circles that identify anomalies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotting function for visualizing anomalies on one or more time series.
Multiple time series must be grouped using <code>dplyr::group_by()</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_anomaly_decomposition">plot_anomaly_decomposition()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(dplyr)
library(ggplot2)

data(tidyverse_cran_downloads)

#### SINGLE TIME SERIES ####
tidyverse_cran_downloads %&gt;%
    filter(package == "tidyquant") %&gt;%
    ungroup() %&gt;%
    time_decompose(count, method = "stl") %&gt;%
    anomalize(remainder, method = "iqr") %&gt;%
    time_recompose() %&gt;%
    plot_anomalies(time_recomposed = TRUE)


#### MULTIPLE TIME SERIES ####
tidyverse_cran_downloads %&gt;%
    time_decompose(count, method = "stl") %&gt;%
    anomalize(remainder, method = "iqr") %&gt;%
    time_recompose() %&gt;%
    plot_anomalies(time_recomposed = TRUE, ncol = 3)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_anomaly_decomposition'>Visualize the time series decomposition with anomalies shown</h2><span id='topic+plot_anomaly_decomposition'></span>

<h3>Description</h3>

<p>Visualize the time series decomposition with anomalies shown
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_anomaly_decomposition(
  data,
  ncol = 1,
  color_no = "#2c3e50",
  color_yes = "#e31a1c",
  alpha_dots = 1,
  alpha_circles = 1,
  size_dots = 1.5,
  size_circles = 4,
  strip.position = "right"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_anomaly_decomposition_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> or <code>tbl_time</code> object.</p>
</td></tr>
<tr><td><code id="plot_anomaly_decomposition_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns to display. Set to 1 for single column by default.</p>
</td></tr>
<tr><td><code id="plot_anomaly_decomposition_+3A_color_no">color_no</code></td>
<td>
<p>Color for non-anomalous data.</p>
</td></tr>
<tr><td><code id="plot_anomaly_decomposition_+3A_color_yes">color_yes</code></td>
<td>
<p>Color for anomalous data.</p>
</td></tr>
<tr><td><code id="plot_anomaly_decomposition_+3A_alpha_dots">alpha_dots</code></td>
<td>
<p>Controls the transparency of the dots. Reduce when too many dots on the screen.</p>
</td></tr>
<tr><td><code id="plot_anomaly_decomposition_+3A_alpha_circles">alpha_circles</code></td>
<td>
<p>Controls the transparency of the circles that identify anomalies.</p>
</td></tr>
<tr><td><code id="plot_anomaly_decomposition_+3A_size_dots">size_dots</code></td>
<td>
<p>Controls the size of the dots.</p>
</td></tr>
<tr><td><code id="plot_anomaly_decomposition_+3A_size_circles">size_circles</code></td>
<td>
<p>Controls the size of the circles that identify anomalies.</p>
</td></tr>
<tr><td><code id="plot_anomaly_decomposition_+3A_strip.position">strip.position</code></td>
<td>
<p>Controls the placement of the strip that identifies the time series decomposition components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first step in reviewing the anomaly detection process is to evaluate
a single times series to observe how the algorithm is selecting anomalies.
The <code>plot_anomaly_decomposition()</code> function is used to gain
an understanding as to whether or not the method is detecting anomalies correctly and
whether or not parameters such as decomposition method, anomalize method,
alpha, frequency, and so on should be adjusted.
</p>


<h3>Value</h3>

<p>Returns a <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_anomalies">plot_anomalies()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

data(tidyverse_cran_downloads)

tidyverse_cran_downloads %&gt;%
    filter(package == "tidyquant") %&gt;%
    ungroup() %&gt;%
    time_decompose(count, method = "stl") %&gt;%
    anomalize(remainder, method = "iqr") %&gt;%
    plot_anomaly_decomposition()

</code></pre>

<hr>
<h2 id='prep_tbl_time'>Automatically create tibbletime objects from tibbles</h2><span id='topic+prep_tbl_time'></span>

<h3>Description</h3>

<p>Automatically create tibbletime objects from tibbles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_tbl_time(data, message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_tbl_time_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code>.</p>
</td></tr>
<tr><td><code id="prep_tbl_time_+3A_message">message</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, returns a message indicating any
conversion details important to know during the conversion to <code>tbl_time</code> class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Detects a date or datetime index column and automatically
</p>


<h3>Value</h3>

<p>Returns a <code>tibbletime</code> object of class <code>tbl_time</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(tibbletime)

data_tbl &lt;- tibble(
    date  = seq.Date(from = as.Date("2018-01-01"), by = "day", length.out = 10),
    value = rnorm(10)
    )

prep_tbl_time(data_tbl)

</code></pre>

<hr>
<h2 id='set_time_scale_template'>Get and modify time scale template</h2><span id='topic+set_time_scale_template'></span><span id='topic+get_time_scale_template'></span><span id='topic+time_scale_template'></span>

<h3>Description</h3>

<p>Get and modify time scale template
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_time_scale_template(data)

get_time_scale_template()

time_scale_template()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_time_scale_template_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> with a &quot;time_scale&quot;, &quot;frequency&quot;, and &quot;trend&quot; columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used to get and set the time scale template, which is used by <code>time_frequency()</code>
and <code>time_trend()</code> when <code>period = "auto"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+time_frequency">time_frequency()</a></code>, <code><a href="#topic+time_trend">time_trend()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
get_time_scale_template()

set_time_scale_template(time_scale_template())

</code></pre>

<hr>
<h2 id='tidyverse_cran_downloads'>Downloads of various &quot;tidyverse&quot; packages from CRAN</h2><span id='topic+tidyverse_cran_downloads'></span>

<h3>Description</h3>

<p>A dataset containing the daily download counts from 2017-01-01 to 2018-03-01
for the following tidyverse packages:
</p>

<ul>
<li> <p><code>tidyr</code>
</p>
</li>
<li> <p><code>lubridate</code>
</p>
</li>
<li> <p><code>dplyr</code>
</p>
</li>
<li> <p><code>broom</code>
</p>
</li>
<li> <p><code>tidyquant</code>
</p>
</li>
<li> <p><code>tidytext</code>
</p>
</li>
<li> <p><code>ggplot2</code>
</p>
</li>
<li> <p><code>purrr</code>
</p>
</li>
<li> <p><code>stringr</code>
</p>
</li>
<li> <p><code>forcats</code>
</p>
</li>
<li> <p><code>knitr</code>
</p>
</li>
<li> <p><code>readr</code>
</p>
</li>
<li> <p><code>tibble</code>
</p>
</li>
<li> <p><code>tidyverse</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>tidyverse_cran_downloads
</code></pre>


<h3>Format</h3>

<p>A <code>grouped_tbl_time</code> object with 6,375 rows and 3 variables:
</p>

<dl>
<dt>date</dt><dd><p>Date of the daily observation</p>
</dd>
<dt>count</dt><dd><p>Number of downloads that day</p>
</dd>
<dt>package</dt><dd><p>The package corresponding to the daily download number</p>
</dd>
</dl>



<h3>Source</h3>

<p>The package downloads come from CRAN by way of the <code>cranlogs</code> package.
</p>

<hr>
<h2 id='time_apply'>Apply a function to a time series by period</h2><span id='topic+time_apply'></span>

<h3>Description</h3>

<p>Apply a function to a time series by period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_apply(
  data,
  target,
  period,
  .fun,
  ...,
  start_date = NULL,
  side = "end",
  clean = FALSE,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_apply_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> with a date or datetime index.</p>
</td></tr>
<tr><td><code id="time_apply_+3A_target">target</code></td>
<td>
<p>A column to apply the function to</p>
</td></tr>
<tr><td><code id="time_apply_+3A_period">period</code></td>
<td>
<p>A time-based definition (e.g. &quot;1 week&quot;).
or a numeric number of observations per frequency (e.g. 10).
See <code><a href="tibbletime.html#topic+collapse_by">tibbletime::collapse_by()</a></code> for period notation.</p>
</td></tr>
<tr><td><code id="time_apply_+3A_.fun">.fun</code></td>
<td>
<p>A function to apply (e.g. <code>median</code>)</p>
</td></tr>
<tr><td><code id="time_apply_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the function, <code>.fun</code></p>
</td></tr>
<tr><td><code id="time_apply_+3A_start_date">start_date</code></td>
<td>
<p>Optional argument used to
specify the start date for the
first group. The default is to start at the closest period boundary
below the minimum date in the supplied index.</p>
</td></tr>
<tr><td><code id="time_apply_+3A_side">side</code></td>
<td>
<p>Whether to return the date at the beginning or the end of
the new period. By default, the &quot;end&quot; of the period.
Use &quot;start&quot; to change to the start of the period.</p>
</td></tr>
<tr><td><code id="time_apply_+3A_clean">clean</code></td>
<td>
<p>Whether or not to round the collapsed index up / down to the next
period boundary. The decision to round up / down is controlled by the side
argument.</p>
</td></tr>
<tr><td><code id="time_apply_+3A_message">message</code></td>
<td>
<p>A boolean. If <code>message = TRUE</code>, the frequency used is output
along with the units in the scale of the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a time-based period to apply functions to. This is useful in circumstances where you want to
compare the observation values to aggregated values such as <code>mean()</code> or <code>median()</code>
during a set time-based period. The returned output extends the
length of the data frame so the differences can easily be computed.
</p>


<h3>Value</h3>

<p>Returns a <code>tibbletime</code> object of class <code>tbl_time</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

data(tidyverse_cran_downloads)

# Basic Usage
tidyverse_cran_downloads %&gt;%
    time_apply(count, period = "1 week", .fun = mean, na.rm = TRUE)

</code></pre>

<hr>
<h2 id='time_decompose'>Decompose a time series in preparation for anomaly detection</h2><span id='topic+time_decompose'></span>

<h3>Description</h3>

<p>Decompose a time series in preparation for anomaly detection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_decompose(
  data,
  target,
  method = c("stl", "twitter"),
  frequency = "auto",
  trend = "auto",
  ...,
  merge = FALSE,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_decompose_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> or <code>tbl_time</code> object.</p>
</td></tr>
<tr><td><code id="time_decompose_+3A_target">target</code></td>
<td>
<p>A column to apply the function to</p>
</td></tr>
<tr><td><code id="time_decompose_+3A_method">method</code></td>
<td>
<p>The time series decomposition method. One of <code>"stl"</code> or <code>"twitter"</code>.
The STL method uses seasonal decomposition (see <code><a href="#topic+decompose_stl">decompose_stl()</a></code>).
The Twitter method uses <code>trend</code> to remove the trend (see <code><a href="#topic+decompose_twitter">decompose_twitter()</a></code>).</p>
</td></tr>
<tr><td><code id="time_decompose_+3A_frequency">frequency</code></td>
<td>
<p>Controls the seasonal adjustment (removal of seasonality).
Input can be either &quot;auto&quot;, a time-based definition (e.g. &quot;1 week&quot;),
or a numeric number of observations per frequency (e.g. 10).
Refer to <code><a href="#topic+time_frequency">time_frequency()</a></code>.</p>
</td></tr>
<tr><td><code id="time_decompose_+3A_trend">trend</code></td>
<td>
<p>Controls the trend component
For stl, the trend controls the sensitivity of the lowess smoother, which is used to remove the remainder.
For twitter, the trend controls the period width of the median, which are used to remove the trend and center the remainder.</p>
</td></tr>
<tr><td><code id="time_decompose_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the underlying method functions.</p>
</td></tr>
<tr><td><code id="time_decompose_+3A_merge">merge</code></td>
<td>
<p>A boolean. <code>FALSE</code> by default. If <code>TRUE</code>, will append results to the original data.</p>
</td></tr>
<tr><td><code id="time_decompose_+3A_message">message</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, will output information related to <code>tbl_time</code> conversions, frequencies,
and trend / median spans (if applicable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>time_decompose()</code> function generates a time series decomposition on
<code>tbl_time</code> objects. The function is &quot;tidy&quot; in the sense that it works
on data frames. It is designed to work with time-based data, and as such
must have a column that contains date or datetime information. The function
also works with grouped data. The function implements several methods
of time series decomposition, each with benefits.
</p>
<p><strong>STL</strong>:
</p>
<p>The STL method (<code>method = "stl"</code>) implements time series decomposition using
the underlying <code><a href="#topic+decompose_stl">decompose_stl()</a></code> function. If you are familiar with <code><a href="stats.html#topic+stl">stats::stl()</a></code>,
the function is a &quot;tidy&quot; version that is designed to work with <code>tbl_time</code> objects.
The decomposition separates the &quot;season&quot; and &quot;trend&quot; components from
the &quot;observed&quot; values leaving the &quot;remainder&quot; for anomaly detection.
The user can control two parameters: <code>frequency</code> and <code>trend</code>.
The <code>frequency</code> parameter adjusts the &quot;season&quot; component that is removed
from the &quot;observed&quot; values. The <code>trend</code> parameter adjusts the
trend window (<code>t.window</code> parameter from <code>stl()</code>) that is used.
The user may supply both <code>frequency</code>
and <code>trend</code> as time-based durations (e.g. &quot;90 days&quot;) or numeric values
(e.g. 180) or &quot;auto&quot;, which predetermines the frequency and/or trend
based on the scale of the time series.
</p>
<p><strong>Twitter</strong>:
</p>
<p>The Twitter method (<code>method = "twitter"</code>) implements time series decomposition using
the methodology from the Twitter <a href="https://github.com/twitter/AnomalyDetection">AnomalyDetection</a> package.
The decomposition separates the &quot;seasonal&quot; component and then removes
the median data, which is a different approach than the STL method for removing
the trend. This approach works very well for low-growth + high seasonality data.
STL may be a better approach when trend is a large factor.
The user can control two parameters: <code>frequency</code> and <code>trend</code>.
The <code>frequency</code> parameter adjusts the &quot;season&quot; component that is removed
from the &quot;observed&quot; values. The <code>trend</code> parameter adjusts the
period width of the median spans that are used. The user may supply both <code>frequency</code>
and <code>trend</code> as time-based durations (e.g. &quot;90 days&quot;) or numeric values
(e.g. 180) or &quot;auto&quot;, which predetermines the frequency and/or median spans
based on the scale of the time series.
</p>


<h3>Value</h3>

<p>Returns a <code>tbl_time</code> object.
</p>


<h3>References</h3>


<ol>
<li><p> CLEVELAND, R. B., CLEVELAND, W. S., MCRAE, J. E., AND TERPENNING, I.
STL: A Seasonal-Trend Decomposition Procedure Based on Loess. Journal of Official Statistics, Vol. 6, No. 1 (1990), pp. 3-73.
</p>
</li>
<li> <p><a href="https://www.usenix.org/system/files/conference/hotcloud14/hotcloud14-vallis.pdf">Owen S. Vallis, Jordan Hochenbaum and Arun Kejariwal (2014). A Novel Technique for Long-Term Anomaly Detection in the Cloud. Twitter Inc.</a>
</p>
</li>
<li> <p><a href="https://github.com/twitter/AnomalyDetection">Owen S. Vallis, Jordan Hochenbaum and Arun Kejariwal (2014). AnomalyDetection: Anomaly Detection Using Seasonal Hybrid Extreme Studentized Deviate Test. R package version 1.0.</a>
</p>
</li></ol>



<h3>See Also</h3>

<p>Decomposition Methods (Powers <code>time_decompose</code>)
</p>

<ul>
<li> <p><code><a href="#topic+decompose_stl">decompose_stl()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+decompose_twitter">decompose_twitter()</a></code>
</p>
</li></ul>

<p>Time Series Anomaly Detection Functions (anomaly detection workflow):
</p>

<ul>
<li> <p><code><a href="#topic+anomalize">anomalize()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+time_recompose">time_recompose()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

data(tidyverse_cran_downloads)

# Basic Usage
tidyverse_cran_downloads %&gt;%
    time_decompose(count, method = "stl")

# twitter
tidyverse_cran_downloads %&gt;%
    time_decompose(count,
                   method       = "twitter",
                   frequency    = "1 week",
                   trend        = "2 months",
                   merge        = TRUE,
                   message      = FALSE)

</code></pre>

<hr>
<h2 id='time_frequency'>Generate a time series frequency from a periodicity</h2><span id='topic+time_frequency'></span><span id='topic+time_trend'></span>

<h3>Description</h3>

<p>Generate a time series frequency from a periodicity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_frequency(data, period = "auto", message = TRUE)

time_trend(data, period = "auto", message = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_frequency_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> with a date or datetime index.</p>
</td></tr>
<tr><td><code id="time_frequency_+3A_period">period</code></td>
<td>
<p>Either &quot;auto&quot;, a time-based definition (e.g. &quot;14 days&quot;),
or a numeric number of observations per frequency (e.g. 10).
See <code><a href="tibbletime.html#topic+collapse_by">tibbletime::collapse_by()</a></code> for period notation.</p>
</td></tr>
<tr><td><code id="time_frequency_+3A_message">message</code></td>
<td>
<p>A boolean. If <code>message = TRUE</code>, the frequency used is output
along with the units in the scale of the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A frequency is loosely defined as the number of observations that comprise a cycle
in a data set. The trend is loosely defined as time span that can
be aggregated across to visualize the central tendency of the data.
It's often easiest to think of frequency and trend in terms of the time-based units
that the data is already in. <strong>This is what <code>time_frequency()</code> and <code>time_trend()</code>
enable: using time-based periods to define the frequency or trend.</strong>
</p>
<p><strong>Frequency</strong>:
</p>
<p>As an example, a weekly cycle is often 5-days (for working
days) or 7-days (for calendar days). Rather than specify a frequency of 5 or 7,
the user can specify <code>period = "1 week"</code>, and
time_frequency()' will detect the scale of the time series and return 5 or 7
based on the actual data.
</p>
<p>The <code>period</code> argument has three basic options for returning a frequency.
Options include:
</p>

<ul>
<li> <p><code>"auto"</code>: A target frequency is determined using a pre-defined template (see <code>template</code> below).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;time-based duration&#8288;</code>: (e.g. &quot;1 week&quot; or &quot;2 quarters&quot; per cycle)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;numeric number of observations&#8288;</code>: (e.g. 5 for 5 observations per cycle)
</p>
</li></ul>

<p>The <code>template</code> argument is only used when <code>period = "auto"</code>. The template is a tibble
of three features: <code>time_scale</code>, <code>frequency</code>, and <code>trend</code>. The algorithm will inspect
the scale of the time series and select the best frequency that matches the scale and
number of observations per target frequency. A frequency is then chosen on be the
best match. The predefined template is stored in a function <code>time_scale_template()</code>.
However, the user can come up with his or her own template changing the values
for frequency in the data frame and saving it to <code>anomalize_options$time_scale_template</code>.
</p>
<p><strong>Trend</strong>:
</p>
<p>As an example, the trend of daily data is often best aggregated by evaluating
the moving average over a quarter or a month span. Rather than specify the number
of days in a quarter or month, the user can specify &quot;1 quarter&quot; or &quot;1 month&quot;,
and the <code>time_trend()</code> function will return the correct number of observations
per trend cycle. In addition, there is an option, <code>period = "auto"</code>, to
auto-detect an appropriate trend span depending on the data. The <code>template</code>
is used to define the appropriate trend span.
</p>


<h3>Value</h3>

<p>Returns a scalar numeric value indicating the number of observations in the frequency or trend span.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

data(tidyverse_cran_downloads)

#### FREQUENCY DETECTION ####

# period = "auto"
tidyverse_cran_downloads %&gt;%
    filter(package == "tidyquant") %&gt;%
    ungroup() %&gt;%
    time_frequency(period = "auto")

time_scale_template()

# period = "1 month"
tidyverse_cran_downloads %&gt;%
    filter(package == "tidyquant") %&gt;%
    ungroup() %&gt;%
    time_frequency(period = "1 month")

#### TREND DETECTION ####

tidyverse_cran_downloads %&gt;%
    filter(package == "tidyquant") %&gt;%
    ungroup() %&gt;%
    time_trend(period = "auto")
</code></pre>

<hr>
<h2 id='time_recompose'>Recompose bands separating anomalies from &quot;normal&quot; observations</h2><span id='topic+time_recompose'></span>

<h3>Description</h3>

<p>Recompose bands separating anomalies from &quot;normal&quot; observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_recompose(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_recompose_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> or <code>tbl_time</code> object that has been
processed with <code>time_decompose()</code> and <code>anomalize()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>time_recompose()</code> function is used to generate bands around the
&quot;normal&quot; levels of observed values. The function uses the remainder_l1
and remainder_l2 levels produced during the <code><a href="#topic+anomalize">anomalize()</a></code> step
and the season and trend/median_spans values from the <code><a href="#topic+time_decompose">time_decompose()</a></code>
step to reconstruct bands around the normal values.
</p>
<p>The following key names are required: observed:remainder from the
<code>time_decompose()</code> step and remainder_l1 and remainder_l2 from the
<code>anomalize()</code> step.
</p>


<h3>Value</h3>

<p>Returns a <code>tbl_time</code> object.
</p>


<h3>See Also</h3>

<p>Time Series Anomaly Detection Functions (anomaly detection workflow):
</p>

<ul>
<li> <p><code><a href="#topic+time_decompose">time_decompose()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+anomalize">anomalize()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

data(tidyverse_cran_downloads)

# Basic Usage
tidyverse_cran_downloads %&gt;%
    time_decompose(count, method = "stl") %&gt;%
    anomalize(remainder, method = "iqr") %&gt;%
    time_recompose()


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
