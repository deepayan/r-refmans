<!DOCTYPE html><html><head><title>Help for package nat.templatebrains</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nat.templatebrains}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_reg_folders'><p>Set or list local folders containing registrations for nat.templatebrains</p></a></li>
<li><a href='#add_reglist'><p>Add reglist object describing a bridging/mirroring registration</p></a></li>
<li><a href='#all_templatebrains'><p>Find all template brains or those matching a given image volume</p></a></li>
<li><a href='#allreg_dataframe'><p>Make data.frame with details of all registrations</p></a></li>
<li><a href='#as.templatebrain'><p>Use image file or other object to initialise template brain</p></a></li>
<li><a href='#bridging_graph'><p>Make or query connected graph of bridging registrations</p></a></li>
<li><a href='#bridging_sequence'><p>Find sequence of one or more bridging registrations</p></a></li>
<li><a href='#display_slice'><p>Display an image slice in 3D</p></a></li>
<li><a href='#download_reg_repo'><p>Download and register git repository containing registrations</p></a></li>
<li><a href='#FCWB.demo'><p>Sample template brain: FlyCircuit Whole Brain</p></a></li>
<li><a href='#fit_xform'><p>Fit affine or thin plate spline transform to arbitrary transformation</p></a></li>
<li><a href='#fit_xform_brain'><p>Fit a single transform to a bridging registration between brains</p></a></li>
<li><a href='#local_reg_dir_for_url'><p>Standard local checkout location for extra registration directories</p></a></li>
<li><a href='#mirror_brain'><p>Mirror 3D object around a given axis, optionally using a warping registration</p></a></li>
<li><a href='#nat.templatebrains-package'><p>NeuroAnatomy Toolbox add-on package for handling template brains</p></a></li>
<li><a href='#plot3d.templatebrain'><p>Plot 3D surface of a template brain</p></a></li>
<li><a href='#regtemplate'><p>Get or set the registration template space in which an object lives</p></a></li>
<li><a href='#templatebrain'><p>Construct templatebrain object for an image registration template</p></a></li>
<li><a href='#templatebrain-meths'><p>Template brain methods</p></a></li>
<li><a href='#update_reg_repos'><p>Update local copy of git repository containing registrations</p></a></li>
<li><a href='#xform_brain'><p>Transform 3D object between template brains</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>NeuroAnatomy Toolbox ('nat') Extension for Handling Template
Brains</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Extends package 'nat' (NeuroAnatomy Toolbox) by
    providing objects and functions for handling template brains.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://natverse.org/nat.templatebrains/">http://natverse.org/nat.templatebrains/</a>,
<a href="https://github.com/natverse/nat.templatebrains">https://github.com/natverse/nat.templatebrains</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>nat (&ge; 1.8.6), R (&ge; 2.10), rgl</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, igraph, memoise, rappdirs, Morpho</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, git2r (&ge; 0.22.1), nabor, testthat (&ge; 2.1.0), covr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/natverse/nat.templatebrains/issues">https://github.com/natverse/nat.templatebrains/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-14 05:42:36 UTC; jefferis</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory Jefferis <a href="https://orcid.org/0000-0002-0587-9355"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  James Manton <a href="https://orcid.org/0000-0001-9260-3156"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregory Jefferis &lt;jefferis@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-14 08:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_reg_folders'>Set or list local folders containing registrations for nat.templatebrains</h2><span id='topic+add_reg_folders'></span><span id='topic+extra_reg_folders'></span>

<h3>Description</h3>

<p><code>add_reg_folders</code> sets
options('nat.templatebrains.regdirs') appropriately so that registrations
can be found by e.g. <code>xform_brain</code>.
</p>
<p><code>extra_reg_folders</code> lists extra registration folders
present in standard location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_reg_folders(dir = extra_reg_folders(), first = TRUE)

extra_reg_folders(full.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_reg_folders_+3A_dir">dir</code></td>
<td>
<p>Path to one or more folders containing registrations. Default
value will scan for registration folders in a standard location. (Please
see <b>Details</b> and <b>File layout</b> sections)</p>
</td></tr>
<tr><td><code id="add_reg_folders_+3A_first">first</code></td>
<td>
<p>Whether the new folder should be added to the start (default) or
end of the search list.</p>
</td></tr>
<tr><td><code id="add_reg_folders_+3A_full.names">full.names</code></td>
<td>
<p>Whether to list full path to registration folders</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>dir</code> is unset then it will default to the value of
<code>extra_reg_folders()</code> i.e. any folders / cloned repositories in the
standard location
</p>


<h3>Value</h3>

<p>This function is principally called for its side effect. A path to
the location on disk containing added registrations is returned invisibly.
</p>


<h3>File layout</h3>

<p>You must pass a folder containing one or more
registrations, not the registration folder itself. So if you have this
situation on disk </p>

<ul>
<li><p> myregistrations/
</p>
</li>
<li><p> myregistrations/reg1.list
</p>
</li>
<li><p> myregistrations/reg2.list
</p>
</li></ul>

<p>you should write <code>add_reg_folders("/path/to/myregistrations")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  add_reg_folders("myextraregistrations")

## End(Not run)
# adding a non-existent folder will generate an error
tools::assertError(add_reg_folders(tempfile()))
</code></pre>

<hr>
<h2 id='add_reglist'>Add reglist object describing a bridging/mirroring registration</h2><span id='topic+add_reglist'></span>

<h3>Description</h3>

<p>By specifying either <code>reference, sample</code> <em>or</em>
<code>mirror</code> arguments, you can add a bridging or mirroring registration,
respectively, to the list of those in use for <code><a href="#topic+xform_brain">xform_brain</a></code> and
<code><a href="#topic+mirror_brain">mirror_brain</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_reglist(
  x,
  reference = NULL,
  sample = NULL,
  mirror = NULL,
  temp = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_reglist_+3A_x">x</code></td>
<td>
<p>A single <code><a href="nat.html#topic+reglist">reglist</a></code> object (which )</p>
</td></tr>
<tr><td><code id="add_reglist_+3A_reference">reference</code>, <code id="add_reglist_+3A_sample">sample</code></td>
<td>
<p>The reference and sample brains (in <code>character</code>
or <code>templatebrain</code> form) for a bridging registration.</p>
</td></tr>
<tr><td><code id="add_reglist_+3A_mirror">mirror</code></td>
<td>
<p>The reference brain (in <code>character</code> or
<code>templatebrain</code> form) for a mirroring registration.</p>
</td></tr>
<tr><td><code id="add_reglist_+3A_temp">temp</code></td>
<td>
<p>Whether to store the on disk representation in a session-specific
temporary folder (that will be removed when R closes). Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_reglist_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+saveRDS">saveRDS</a></code> e.g. to
control compression when the reglist object is saved to disk.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is called for its side effect and has no return value.
</p>


<h3>See Also</h3>

<p>add_reg_folders
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(nat.flybrains)
# mirroring registration for a specific template brain object
add_reglist(mirroring, mirror=JFRC2013)
# equivalent but withhout needing to construct the template
add_reglist(mirroring, mirror="JFRC2013")

# add a bridging registration between two brains
add_reglist(bridging, reference=JFRC2, sample=JFRC2013)


## End(Not run)
</code></pre>

<hr>
<h2 id='all_templatebrains'>Find all template brains or those matching a given image volume</h2><span id='topic+all_templatebrains'></span><span id='topic+guess_templatebrain'></span>

<h3>Description</h3>

<p><code>all_templatebrains</code> returns a data.frame detailing all
<code>templatebrain</code> objects on the search path (including those inside
packages).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_templatebrains(cached = TRUE, remove.duplicates = FALSE)

guess_templatebrain(
  x,
  rval = c("templatebrain", "name"),
  cached = TRUE,
  mustWork = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_templatebrains_+3A_cached">cached</code></td>
<td>
<p>When <code>TRUE</code> returns precomputed (memoised) results,
otherwise rescans searching for all template brains.</p>
</td></tr>
<tr><td><code id="all_templatebrains_+3A_remove.duplicates">remove.duplicates</code></td>
<td>
<p>Whether to remove duplicate template brains (as
determined by md5 hash) from the result list</p>
</td></tr>
<tr><td><code id="all_templatebrains_+3A_x">x</code></td>
<td>
<p>A <code><a href="nat.html#topic+im3d">im3d</a></code> image object, array or matrix compatible with
<code><a href="#topic+as.templatebrain">as.templatebrain</a></code> OR a 2 or 3-vector defining the dimensions
of an image or image stack.</p>
</td></tr>
<tr><td><code id="all_templatebrains_+3A_rval">rval</code></td>
<td>
<p>Whether to return the <code><a href="#topic+templatebrain">templatebrain</a></code> object itself
or just its name.</p>
</td></tr>
<tr><td><code id="all_templatebrains_+3A_mustwork">mustWork</code></td>
<td>
<p>Whether to insist that exactly one template brain is found</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>all_templatebrains</code>, a <code>data.frame</code> containing the
following columns: </p>

<ul>
<li><p> object The name of the <code>templatebrain</code> object
</p>
</li>
<li><p> pos An integer specifying the environment
</p>
</li>
<li><p> package Character vector naming the environment
</p>
</li>
<li><p> md5 md5 hash of the <code>templatebrain</code> object
</p>
</li>
<li><p> name
</p>
</li>
<li><p> W,H,D Width, height and depth of image stack (pixels)
</p>
</li></ul>

<p><code>guess_templatebrain</code> returns a <code><a href="#topic+templatebrain">templatebrain</a></code>
object when <code>rval='templatebrain'</code> or a character vector when
<code>rval='name'</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+templatebrain">templatebrain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
all_templatebrains()

guess_templatebrain(im3d(dims=c(30,40,50)))
# or
guess_templatebrain(c(30,40,50))
guess_templatebrain('path/to/my/image.nrrd')

if(require('nat.flybrains')){
  guess_templatebrain(im3d(dims=c(1024,512,218)), rval = 'name')
  # get the matching template brain
  tb=guess_templatebrain(im3d(dims=c(1024,512,218)))
  # get its voxel dimensions
  voxdims(tb)

  tb=guess_templatebrain(c(1024,512))
  tb
}

## End(Not run)
</code></pre>

<hr>
<h2 id='allreg_dataframe'>Make data.frame with details of all registrations</h2><span id='topic+allreg_dataframe'></span>

<h3>Description</h3>

<p>Make data.frame with details of all registrations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allreg_dataframe(regdirs = getOption("nat.templatebrains.regdirs"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allreg_dataframe_+3A_regdirs">regdirs</code></td>
<td>
<p>Character vector of directories to search for registrations
(see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>by default <code>regdirs</code> is set to
getOption('nat.templatebrains.regdirs')
</p>


<h3>Value</h3>

<p>data.frame with one row for each observed registration and columns
</p>

<ul>
<li><p> path
</p>
</li>
<li><p> name
</p>
</li>
<li><p> dup
</p>
</li>
<li><p> bridge
</p>
</li>
<li><p> reference
</p>
</li>
<li><p> sample </p>
</li></ul>

<p>If there are no registrations, there will be a data.frame with 0 rows and
these columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
allreg_dataframe()

## End(Not run)
</code></pre>

<hr>
<h2 id='as.templatebrain'>Use image file or other object to initialise template brain</h2><span id='topic+as.templatebrain'></span><span id='topic+as.templatebrain.character'></span><span id='topic+as.templatebrain.im3d'></span><span id='topic+as.templatebrain.templatebrain'></span>

<h3>Description</h3>

<p>Use image file or other object to initialise template brain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.templatebrain(x, ...)

## S3 method for class 'character'
as.templatebrain(x, ...)

## S3 method for class 'im3d'
as.templatebrain(x, regName = NULL, name = regName, ...)

## S3 method for class 'templatebrain'
as.templatebrain(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.templatebrain_+3A_x">x</code></td>
<td>
<p>object used to construct the templatebrain, either a character
vector with the path to a file or an <code><a href="nat.html#topic+im3d">im3d</a></code> object.</p>
</td></tr>
<tr><td><code id="as.templatebrain_+3A_...">...</code></td>
<td>
<p>additional named arguments passed to methods and then on to
<code><a href="#topic+templatebrain">templatebrain</a></code> that will be added as fields to the
<code>templatebrain</code> object.</p>
</td></tr>
<tr><td><code id="as.templatebrain_+3A_name">name</code>, <code id="as.templatebrain_+3A_regname">regName</code></td>
<td>
<p>name and short name of the template brain. Will use the
filename (minus final extension) by default for both fields.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.templatebrain</code> can extract the key fields defining an
template space from an image file. This is generally a much more convenient
approach to defining a <code>templatebrain</code> object than specifying all
fields by hand.
</p>


<h3>Value</h3>

<p>A list with class <code><a href="#topic+templatebrain">templatebrain</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+templatebrain">templatebrain</a></code>, <code><a href="nat.html#topic+im3d">im3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make templatebrain object using image info from the template brain NRRD file
nhdr=system.file('images','FCWB.nhdr', package='nat.templatebrains')
as.templatebrain(nhdr, name = "FlyCircuit Whole Brain")
</code></pre>

<hr>
<h2 id='bridging_graph'>Make or query connected graph of bridging registrations</h2><span id='topic+bridging_graph'></span><span id='topic+shortest_bridging_seq'></span>

<h3>Description</h3>

<p>These functions are designed for expert use. In general it is
recommended to use <code>xform_brain</code>.
</p>
<p><code>bridging_graph</code> creates an igraph::graph representing all known
template brains (vertices) and the bridging registrations connecting them
(edges).
</p>
<p><code>shortest_bridging_seq</code> finds the shortest bridging
sequence on a graph of all available bridging registrations, subject to
constraints defined by graph connectivity and the <code>reciprocal
  parameter</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bridging_graph(
  regdirs = getOption("nat.templatebrains.regdirs"),
  reciprocal = NA
)

shortest_bridging_seq(
  sample,
  reference,
  via = NULL,
  checkboth = TRUE,
  imagedata = FALSE,
  reciprocal = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bridging_graph_+3A_regdirs">regdirs</code></td>
<td>
<p>Character vector of directories to search for registrations
(see details)</p>
</td></tr>
<tr><td><code id="bridging_graph_+3A_reciprocal">reciprocal</code></td>
<td>
<p>Sets the weight of reciprocal edges in the graph (and
thereby whether inverse registrations will be considered).</p>
</td></tr>
<tr><td><code id="bridging_graph_+3A_sample">sample</code></td>
<td>
<p>Source template brain (e.g. IS2) that data is currently in.
Specified either as character vector or a <code>templatebrain</code> object.</p>
</td></tr>
<tr><td><code id="bridging_graph_+3A_reference">reference</code></td>
<td>
<p>Target template brain (e.g. IS2) that data should be
transformed into.</p>
</td></tr>
<tr><td><code id="bridging_graph_+3A_via">via</code></td>
<td>
<p>(optional) intermediate template brain that the registration
sequence must pass through.</p>
</td></tr>
<tr><td><code id="bridging_graph_+3A_checkboth">checkboth</code></td>
<td>
<p>When <code>TRUE</code> will look for registrations in both
directions. See details.</p>
</td></tr>
<tr><td><code id="bridging_graph_+3A_imagedata">imagedata</code></td>
<td>
<p>Whether <code>x</code> should be treated as image data (presently
only supported as a file on disk) or 3D object vertices - see details.</p>
</td></tr>
<tr><td><code id="bridging_graph_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="#topic+bridging_graph">bridging_graph</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>reciprocal != NA</code> we create a graph where each forward
transformation is matched by a corresponding inverse transformation with
the specified edge weight. The edge weight for forward transforms will
always be 1.0.
</p>
<p>By default <code>regdirs</code> is set to getOption('nat.templatebrains.regdirs')
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allreg_dataframe">allreg_dataframe</a></code>, <code><a href="#topic+xform_brain">xform_brain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(bridging_graph(), vertex.size=25, edge.arrow.size=0.5)
# with reciprocal edges
plot(bridging_graph(reciprocal=3), vertex.size=25)

## End(Not run)
## Not run: 
shortest_bridging_seq(FCWB, IS2)
# or
shortest_bridging_seq('FCWB', 'IS2')

shortest_bridging_seq(sample='FCWB', reference='IS2', via="JFRC2")

## End(Not run)
</code></pre>

<hr>
<h2 id='bridging_sequence'>Find sequence of one or more bridging registrations</h2><span id='topic+bridging_sequence'></span>

<h3>Description</h3>

<p>This function is primarily intended for developer use (it is
used inside <code>xform_brain</code>) but may be useful for end users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bridging_sequence(
  sample,
  reference,
  via = NULL,
  imagedata = FALSE,
  checkboth = !imagedata,
  mustWork = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bridging_sequence_+3A_sample">sample</code></td>
<td>
<p>Source template brain (e.g. IS2) that data is currently in.
Specified either as character vector or a <code>templatebrain</code> object.</p>
</td></tr>
<tr><td><code id="bridging_sequence_+3A_reference">reference</code></td>
<td>
<p>Target template brain (e.g. IS2) that data should be
transformed into.</p>
</td></tr>
<tr><td><code id="bridging_sequence_+3A_via">via</code></td>
<td>
<p>(optional) intermediate template brain that the registration
sequence must pass through.</p>
</td></tr>
<tr><td><code id="bridging_sequence_+3A_imagedata">imagedata</code></td>
<td>
<p>Whether <code>x</code> should be treated as image data (presently
only supported as a file on disk) or 3D object vertices - see details.</p>
</td></tr>
<tr><td><code id="bridging_sequence_+3A_checkboth">checkboth</code></td>
<td>
<p>whether to look for registrations in both
directions. The default (<code>checkboth=FALSE</code>) will only return
registrations in the forward direction (see details).</p>
</td></tr>
<tr><td><code id="bridging_sequence_+3A_mustwork">mustWork</code></td>
<td>
<p>whether to error out if appropriate registrations are not
found.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>checkboth=FALSE</code>, only registrations that can be directly
used to map image data from sample to reference are returned. When working
with 3D points, use <code>checkboth=TRUE</code>. Note that all possible
directories will first be scanned for registrations in the preferred
direction and then rescanned for the opposite direction if nothing is
found.
</p>


<h3>Registration direction</h3>

<p>When mapping points from JFRC2 -&gt; IS2 -&gt; FCWB
(i.e. sample=JFRC2, via=IS2, ref=FCWB) the command line passed to CMTK's streamxform
should look like:
<code style="white-space: pre;">&#8288;streamxform -- JFRC2_IS2.list --inverse FCWB_IS2.list&#8288;</code>
However when mapping image data
the command line for CMTK's reformatx should look like:
<code style="white-space: pre;">&#8288;reformatx  -o out.nrrd --floating JFRC2.nrrd FCWB.nrrd FCWB_IS2.list --inverse JFRC2_IS2.list&#8288;</code>
<code>bridging_sequence</code> produces output like <code style="white-space: pre;">&#8288;
list(JFRC2 = structure(
       "/GD/dev/R/nat.flybrains/inst/extdata/bridgingregistrations/JFRC2_IS2.list",
       swap = TRUE),
     IS2 = "/GD/dev/R/nat.flybrains/inst/extdata/bridgingregistrations/FCWB_IS2.list")
&#8288;</code>
in these circumstances, which xformpoints.cmtkreg turns into &quot;&ndash; JFRC2_IS2.list &ndash;inverse FCWB_IS2.list&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bridging_sequence(sample=JFRC2, ref=FCWB, checkboth = TRUE)
bridging_sequence(sample=JFRC2, via=IS2, ref=FCWB, checkboth = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='display_slice'>Display an image slice in 3D</h2><span id='topic+display_slice'></span>

<h3>Description</h3>

<p>Display an image slice in 3D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display_slice(brain, slice, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display_slice_+3A_brain">brain</code></td>
<td>
<p>template brain (e.g. IS2) of the slice.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_slice">slice</code></td>
<td>
<p>Path to PNG image containing slice to display.</p>
</td></tr>
<tr><td><code id="display_slice_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to <code><a href="rgl.html#topic+persp3d">persp3d</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is principally called for its side effect of adding to
the plot. A vector of rgl shape IDs is returned invisibly.
</p>

<hr>
<h2 id='download_reg_repo'>Download and register git repository containing registrations</h2><span id='topic+download_reg_repo'></span>

<h3>Description</h3>

<p>Note that these extra registrations will be downloaded to a standard location
on your hard drive that will be used for one session to the next. See
examples and <code><a href="#topic+local_reg_dir_for_url">local_reg_dir_for_url</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_reg_repo(url, localdir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_reg_repo_+3A_url">url</code></td>
<td>
<p>Location of one or more remote git repositories. Can accept
partial github specifications of the form &quot;&lt;user&gt;/&lt;repo&gt;&quot;.</p>
</td></tr>
<tr><td><code id="download_reg_repo_+3A_localdir">localdir</code></td>
<td>
<p>Full path to local checkout location of git repository. When
<code>localdir=NULL</code>, the default, a sensible location is chosen using the
rappdirs function.</p>
</td></tr>
<tr><td><code id="download_reg_repo_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>git2r::clone</code> e.g.
credentials for private repo.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is principally called for its side effect. A path to
the location on disk containing added registrations is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_reg_folders">add_reg_folders</a></code>, <code><a href="#topic+local_reg_dir_for_url">local_reg_dir_for_url</a></code>,
<code>git2r::<a href="git2r.html#topic+clone">clone</a></code>
</p>
<p><code><a href="#topic+update_reg_repos">update_reg_repos</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## find the root location of all registration directories
local_reg_dir_for_url()
## Not run: 
## Add the two main jefferislab bridging and mirroring registration
# collections for Drosophila brains from github.com.
download_reg_repo("jefferislab/BridgingRegistrations")
download_reg_repo("jefferislab/MirrorRegistrations")

## update all current registration repositories
update_reg_repos()

## End(Not run)
</code></pre>

<hr>
<h2 id='FCWB.demo'>Sample template brain: FlyCircuit Whole Brain</h2><span id='topic+FCWB.demo'></span>

<h3>Description</h3>

<p>This is a sample template brain for testing purposes which is equivalent to
the FCWB template brain defined by the <code>nat.flybrains</code>, which should be
considered the canonical version.
</p>

<hr>
<h2 id='fit_xform'>Fit affine or thin plate spline transform to arbitrary transformation</h2><span id='topic+fit_xform'></span>

<h3>Description</h3>

<p>Fit affine or thin plate spline transform to arbitrary transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_xform(
  reg,
  samplepts,
  refpts = NULL,
  type = c("affine", "rigid", "similarity", "tps"),
  subsample = FALSE,
  scale = c(1, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_xform_+3A_reg">reg</code></td>
<td>
<p>Any registration compatible with <code>nat::<a href="nat.html#topic+xform">xform</a></code>,
including non-rigid and multi-step registrations. You must either supply
this or the <code>refpts</code> argument.</p>
</td></tr>
<tr><td><code id="fit_xform_+3A_samplepts">samplepts</code></td>
<td>
<p>A set of points in the sample (floating) space. Can be any
object compatible with <code>nat::<a href="nat.html#topic+xyzmatrix">xyzmatrix</a></code>.</p>
</td></tr>
<tr><td><code id="fit_xform_+3A_refpts">refpts</code></td>
<td>
<p>An optional set of points in the target (fixed) space matching
<code>samplepts</code>. You must either supply this or the <code>reg</code> argument.</p>
</td></tr>
<tr><td><code id="fit_xform_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of registration. See
<code><a href="Morpho.html#topic+computeTransform">computeTransform</a></code> for details.</p>
</td></tr>
<tr><td><code id="fit_xform_+3A_subsample">subsample</code></td>
<td>
<p>A number of points to subsample from
<code>samplepts,refpts</code>. The default value of <code>FALSE</code> means use all
provided points to calculate the new transform.</p>
</td></tr>
<tr><td><code id="fit_xform_+3A_scale">scale</code></td>
<td>
<p>a 2-vector indicating the amount to scale the sample and
reference points. You can supply one vector if this is the same. If the
transform expects points in microns and returns points in microns then you
would need <code>scale=c(1000,1)</code> if you want the input to be in microns
and the output to be in nm.</p>
</td></tr>
<tr><td><code id="fit_xform_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="Morpho.html#topic+computeTransform">computeTransform</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A homogeneous affine matrix or a <code>nat::tpsreg</code> object
n.b. only in development nat (&gt;= 1.10.1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(nat.flybrains)
reg=shortest_bridging_seq(sample='FCWB', reference="JFRC2")
fit_xform(reg, nat::kcs20, subsample=200, type='affine')
# compute transform with translations in nm not microns
fit_xform(reg, nat::kcs20, subsample=200, type='affine', scale=1000)

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_xform_brain'>Fit a single transform to a bridging registration between brains</h2><span id='topic+fit_xform_brain'></span>

<h3>Description</h3>

<p>Fit a single transform to a bridging registration between brains
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_xform_brain(
  sample,
  reference,
  via = NULL,
  type = c("affine", "rigid", "similarity", "tps"),
  pts = NULL,
  npts = if (is.null(pts)) 1000 else NULL,
  scale = c(1, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_xform_brain_+3A_sample">sample</code></td>
<td>
<p>Source template brain (e.g. IS2) that data is currently in.
Specified either as character vector or a <code>templatebrain</code> object.</p>
</td></tr>
<tr><td><code id="fit_xform_brain_+3A_reference">reference</code></td>
<td>
<p>Target template brain (e.g. IS2) that data should be
transformed into.</p>
</td></tr>
<tr><td><code id="fit_xform_brain_+3A_via">via</code></td>
<td>
<p>(optional) intermediate template brain that the registration
sequence must pass through.</p>
</td></tr>
<tr><td><code id="fit_xform_brain_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of registration. See
<code><a href="Morpho.html#topic+computeTransform">computeTransform</a></code> for details.</p>
</td></tr>
<tr><td><code id="fit_xform_brain_+3A_pts">pts</code></td>
<td>
<p>Optional set of points to use for the fit. If they are not
specified they will be randomly sampled (see details).</p>
</td></tr>
<tr><td><code id="fit_xform_brain_+3A_npts">npts</code></td>
<td>
<p>Number of points to use for fit (defaults to 1000 when no
<code>pts</code> argument is specified).</p>
</td></tr>
<tr><td><code id="fit_xform_brain_+3A_scale">scale</code></td>
<td>
<p>a 2-vector indicating the amount to scale the sample and
reference points. You can supply one vector if this is the same. If the
transform expects points in microns and returns points in microns then you
would need <code>scale=c(1000,1)</code> if you want the input to be in microns
and the output to be in nm.</p>
</td></tr>
<tr><td><code id="fit_xform_brain_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+fit_xform">fit_xform</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>pts</code> are supplied these will be used to construct the fit.
This might be useful if you are focussing on a particular brain region and
supply relevant neurons. But if you want to work with one registration to
use for the whole brain then it's better to use points across the brain.
</p>
<p>When points are not provided then <code>fit_xform_brain</code> will first check
to see if it can find a neuropil surface model for the <code>sample</code>. If it
can, it will sample a number of points that lie inside the surface model.
If no surface model can be found, then it will look for a
<code><a href="#topic+templatebrain">templatebrain</a></code> object specifying a bounding box around the
sample brain. If successful, it will sample <code>npts</code> within that
bounding box. If not there will be an error and you will have to supply the
points.
</p>


<h3>Value</h3>

<p>A homogeneous affine matrix or a <code>nat::tpsreg</code> object
n.b. only in development nat (&gt;= 1.10.1)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_xform">fit_xform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(nat.flybrains)
t1=fit_xform_brain(sample='FCWB', reference="JFRC2", type='affine')
t1
# the same but for points in nm
fit_xform_brain(sample='FCWB', reference="JFRC2", type='affine', scale=1000)
# run the fit based on a particular group of Kenyon cells
t2=fit_xform_brain(sample='FCWB', reference="JFRC2",
  pts=nat::kcs20, npts=300, type='affine')

nclear3d()
mfrow3d(1, 2, sharedMouse = TRUE)
plot3d(JFRC2)
plot3d(xform(FCWB.surf, t1))
next3d()
plot3d(JFRC2)
plot3d(xform(FCWB.surf, t2))
# the whole brain surfaces clearly match better when you fit on the whole brain

## End(Not run)
</code></pre>

<hr>
<h2 id='local_reg_dir_for_url'>Standard local checkout location for extra registration directories</h2><span id='topic+local_reg_dir_for_url'></span>

<h3>Description</h3>

<p>Standard local checkout location for extra registration directories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_reg_dir_for_url(url = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_reg_dir_for_url_+3A_url">url</code></td>
<td>
<p>Character vector containing a url. When <code>url=NULL</code> defaults
to giving the base path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When called without any argument returns the root directory that
will be inspected for extra registrations. You can put a sub-folder
yourself there manually and then call add_reg_folders, but you are much
better off in general using <code><a href="#topic+download_reg_repo">download_reg_repo</a></code> to install from
a github repository such as this one of ours:.
<a href="https://github.com/jefferislab/BridgingRegistrations">jefferislab/BridgingRegistrations</a>
</p>
<p>Note that this folder will always be the same place on a machine i.e. this
defines a consistent, persistent location on disk to store data across
sessions. You can modify the location of this folder by editing the
<code>R_USER_DATA_DIR</code> environment variable. While this is not recommended
on a personal machine, it may be necessary on a server. See
<code>rappdirs::<a href="rappdirs.html#topic+user_data_dir">user_data_dir</a></code> for details.
</p>
<p>When called with a url, a SHA1 hash will be calculated for the URL and
appended to the basepath. This should ensure that locations derived from
different URLs do not clash.
</p>


<h3>Value</h3>

<p>path(s) containing registrations on disk.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+download_reg_repo">download_reg_repo</a></code>,
<code>rappdirs::<a href="rappdirs.html#topic+user_data_dir">user_data_dir</a></code>
</p>

<hr>
<h2 id='mirror_brain'>Mirror 3D object around a given axis, optionally using a warping registration</h2><span id='topic+mirror_brain'></span>

<h3>Description</h3>

<p>Mirror 3D object around a given axis, optionally using a warping registration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirror_brain(
  x,
  brain = regtemplate(x),
  mirrorAxis = c("X", "Y", "Z"),
  transform = c("warp", "affine", "flip"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mirror_brain_+3A_x">x</code></td>
<td>
<p>the 3D object to be mirrored.</p>
</td></tr>
<tr><td><code id="mirror_brain_+3A_brain">brain</code></td>
<td>
<p>source template brain (e.g. IS2) that data is in.</p>
</td></tr>
<tr><td><code id="mirror_brain_+3A_mirroraxis">mirrorAxis</code></td>
<td>
<p>the axis to mirror (default <code>"X"</code>).</p>
</td></tr>
<tr><td><code id="mirror_brain_+3A_transform">transform</code></td>
<td>
<p>whether to use warp (default) or affine component of
registration, or simply flip about midplane of axis.</p>
</td></tr>
<tr><td><code id="mirror_brain_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to <code><a href="nat.html#topic+mirror">mirror</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transformed version of <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xform_brain">xform_brain</a></code>, <code><a href="#topic+regtemplate">regtemplate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FCWB.demo)
# Simple mirror along the x i.e. medio-lateral axis
kcs20.flip=mirror_brain(kcs20, FCWB.demo, transform='flip')

## Full non-rigid mirroring to account for differences in shape/centering of
## template brain.
## Depends on nat.flybrains package and system CMTK installation
## Not run: 
library(nat.flybrains)
kcs20.right=mirror_brain(kcs20, FCWB, .progress='text')
plot3d(kcs20, col='red')
plot3d(kcs20.right, col='green')
# include surface plot of brain
plot3d(FCWB)

# Compare simple flip with full mirror
# This template brain is highly symmetric so these are almost identical
clear3d()
plot3d(kcs20.flip, col='blue')
plot3d(kcs20.right, col='green')

# Convert to JFRC2 and do the same
kcs20.jfrc2=xform_brain(kcs20, sample = FCWB, reference=JFRC2, .progress='text')
kcs20.jfrc2.right=mirror_brain(kcs20.jfrc2, JFRC2, .progress='text')
kcs20.jfrc2.flip=mirror_brain(kcs20.jfrc2, JFRC2, transform='flip')
clear3d()
# This time there is a bigger difference between the two transformations
plot3d(kcs20.jfrc2.flip, col='blue')
plot3d(kcs20.jfrc2.right, col='green')
# plot mushroom body neuropils as well
plot3d(JFRC2NP.surf, "MB.*_R", alpha=0.3, col='grey')

# Compare Euclidean distance between corresponding points in all neurons
diffs=xyzmatrix(kcs20.jfrc2.flip)-xyzmatrix(kcs20.jfrc2.right)
hist(sqrt(rowSums(diffs^2)), xlab='Distance /microns')

## End(Not run)
</code></pre>

<hr>
<h2 id='nat.templatebrains-package'>NeuroAnatomy Toolbox add-on package for handling template brains</h2><span id='topic+nat.templatebrains-package'></span><span id='topic+nat.templatebrains'></span>

<h3>Description</h3>

<p>This package provides a class <code>templatebrain</code> that stores key
information about reference brains along with helper functions to simplify
transformation of data between template brains (a.k.a bridging) and mirroring
of data within a template brain.
</p>
<p>Extends package 'nat' (NeuroAnatomy Toolbox) by providing objects and functions for handling template brains.
</p>


<h3>Helper functions</h3>

<p>Easy-to-use functions for transforming data from
one template brain to another, displaying slices alongside 3D data, etc.
are provided.
</p>
<p>For transforming between spaces, see especially <code><a href="#topic+xform_brain">xform_brain</a></code>,
<code><a href="#topic+mirror_brain">mirror_brain</a></code>. The <code><a href="#topic+regtemplate">regtemplate</a></code> functions allow
an R object containing neuroanatomical data to be tagged as in a particular
template brain space.
</p>
<p><code><a href="#topic+plot3d.templatebrain">plot3d.templatebrain</a></code> provides a simple way to plot a surface
object representing a given template brain.
</p>


<h3>Registrations</h3>

<p>Functions such as <code><a href="#topic+xform_brain">xform_brain</a></code> provided
by <code>nat.templatebrains</code> are not very useful unless you tell the
package about bridging/mirroring registrations that you have available.
There are 4 supported ways to add registrations to the search list that
will be considered: </p>

<ul>
<li><p> Install a package (e.g. nat.flybrains) that bundles registrations.
</p>
</li>
<li> <p><code><a href="#topic+download_reg_repo">download_reg_repo</a></code> to download pre-packaged registration
folders from github. This will automatically add the new folders to the
registration search list both in the current session and on package
startup.
</p>
</li>
<li> <p><code><a href="#topic+add_reg_folders">add_reg_folders</a></code> to add additional local directories to
the registration search list. You will need to do this each time your start
an R session unless you add it to your <code><a href="base.html#topic+Rprofile">Rprofile</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+add_reglist">add_reglist</a></code> to add an in-memory
<code><a href="nat.html#topic+reglist">reglist</a></code> containing an arbitrary sequence of
registrations. By default this will not persist across R sessions but this
behaviour can be changed.
</p>
</li></ul>

<p>Note that the package implements a cache to avoid rescanning the
directories in the registration search list all the time. The functions
mentioned above will automatically ensure that the cache is reset whenever
a new set of registrations are added to the search list.
</p>


<h3>Package options</h3>


<ul>
<li><p> options('nat.templatebrains.regdirs') specifies a character vector of
directories containing registrations i.e. a registration search list.
</p>
</li></ul>

<p>It is strongly recommended that you use the functions mentioned above
rather than manipulating the registration search list directly.
</p>
<p>Note that registration directories will be searched in the order that they
are listed. It is therefore strongly recommended that individual
registrations have globally unique names.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gregory Jefferis <a href="mailto:jefferis@gmail.com">jefferis@gmail.com</a> (<a href="https://orcid.org/0000-0002-0587-9355">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> James Manton <a href="mailto:ajd.manton@googlemail.com">ajd.manton@googlemail.com</a> (<a href="https://orcid.org/0000-0001-9260-3156">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="nat.html#topic+nat">nat</a></code>
</p>
<p>Useful links:
</p>

<ul>
<li> <p><a href="http://natverse.org/nat.templatebrains/">http://natverse.org/nat.templatebrains/</a>
</p>
</li>
<li> <p><a href="https://github.com/natverse/nat.templatebrains">https://github.com/natverse/nat.templatebrains</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/natverse/nat.templatebrains/issues">https://github.com/natverse/nat.templatebrains/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Plot all known registrations
plot(bridging_graph(), vertex.size=25)

## manually add a new directory containing registrations to the search list
# Don't do this unless essential!
options(nat.templatebrains.regdirs=union(
  getOption('nat.templatebrains.regdirs'), "/my/new/path"))
# NB after mucking around with paths manually you must also manually update
# the cache so that new registrations are actually used.
nat.templatebrains:::reset_cache()

## same, but override any built-in registration by putting the new path
# at the first position in the search list
options(nat.templatebrains.regdirs=union("/my/new/path"),
  getOption('nat.templatebrains.regdirs'))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot3d.templatebrain'>Plot 3D surface of a template brain</h2><span id='topic+plot3d.templatebrain'></span>

<h3>Description</h3>

<p>Plot 3D surface of a template brain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'templatebrain'
plot3d(x, col = "grey", alpha = 0.3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.templatebrain_+3A_x">x</code></td>
<td>
<p>the template brain to plot.</p>
</td></tr>
<tr><td><code id="plot3d.templatebrain_+3A_col">col</code></td>
<td>
<p>the color of the surface.</p>
</td></tr>
<tr><td><code id="plot3d.templatebrain_+3A_alpha">alpha</code></td>
<td>
<p>the alpha value of the surface.</p>
</td></tr>
<tr><td><code id="plot3d.templatebrain_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to <code><a href="rgl.html#topic+plot3d">plot3d</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will work immediately for the standard
<a href="#topic+templatebrain">templatebrain</a> defined in the package documentation. If passed an
object called e.g. FCWB it expects to find another object named FCWB.surf
containing the surface information. If you follow this naming convention
for user-defined refbrains it will work for them as well.
</p>


<h3>Value</h3>

<p>This function is principally called for its side effect of adding to
the plot. A vector of rgl shape IDs is returned invisibly.?
</p>

<hr>
<h2 id='regtemplate'>Get or set the registration template space in which an object lives</h2><span id='topic+regtemplate'></span><span id='topic+regtemplate+3C-'></span>

<h3>Description</h3>

<p>Get or set the registration template space in which an object lives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regtemplate(x)

regtemplate(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regtemplate_+3A_x">x</code></td>
<td>
<p>The 3D object whose registration space will be set/returned</p>
</td></tr>
<tr><td><code id="regtemplate_+3A_value">value</code></td>
<td>
<p>The registration template brain (either a character vector
naming the space or a <code><a href="#topic+templatebrain">templatebrain</a></code> object)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to facilitate transformations between objects in defined
anatomical spaces these functions allow the registration template for an
object to be specified. Most of the time you will not need to use these
functions manually since the appropriate space will be set by the function
xform_brain and friends.
</p>


<h3>Value</h3>

<p>Either a <code>templatebrain</code> object or the newly tagged object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(nat.flybrains)
kcs3=kcs20[1:3]
regtemplate(kcs3)=FCWB
regtemplate(kcs3)

kcs3m=mirror_brain(kcs3, brain=regtemplate(kcs20))
plot3d(kcs3, col='red')
plot3d(kcs3m, col='green')

## End(Not run)
</code></pre>

<hr>
<h2 id='templatebrain'>Construct templatebrain object for an image registration template</h2><span id='topic+templatebrain'></span>

<h3>Description</h3>

<p><code>templatebrain</code> objects encapsulate key information for the reference
brain in an image registration. Usually this will be a standard template
brain used for many registrations. <strong>It will normally be much more
convenient to use  <code><a href="#topic+as.templatebrain">as.templatebrain</a></code> methods to convert an image
file or an im3d object into a <code>templatebrain</code></strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>templatebrain(
  name,
  regName = name,
  type = NULL,
  sex = NULL,
  dims = NULL,
  BoundingBox = NULL,
  voxdims = NULL,
  origin = NULL,
  units = NULL,
  description = NULL,
  doi = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="templatebrain_+3A_name">name</code></td>
<td>
<p>the full name of the template.</p>
</td></tr>
<tr><td><code id="templatebrain_+3A_regname">regName</code></td>
<td>
<p>the short name. This will be the stem used to prefix
registrations (e.g. JFRC2_someimage.list) for this template brain and
likely also the stem of the template brain image (e.g. JFRC2.nrrd).</p>
</td></tr>
<tr><td><code id="templatebrain_+3A_type">type</code></td>
<td>
<p>one of <code>c('single brain', 'average')</code>, indicating whether
the template brain has been created from just one image, or is the average
of multiple images.</p>
</td></tr>
<tr><td><code id="templatebrain_+3A_sex">sex</code></td>
<td>
<p>the sex of the template brain. For templates with
<code>type=='average'</code>, the possibility of <code>sex='intersex'</code> exists.</p>
</td></tr>
<tr><td><code id="templatebrain_+3A_dims">dims</code></td>
<td>
<p>dimensions of the image (number of voxels).</p>
</td></tr>
<tr><td><code id="templatebrain_+3A_boundingbox">BoundingBox</code></td>
<td>
<p>physical dimensions of the image (see
<code><a href="nat.html#topic+boundingbox">boundingbox</a></code>).</p>
</td></tr>
<tr><td><code id="templatebrain_+3A_voxdims">voxdims</code></td>
<td>
<p>physical spacing between voxels.</p>
</td></tr>
<tr><td><code id="templatebrain_+3A_origin">origin</code></td>
<td>
<p>the physical location of the first voxel</p>
</td></tr>
<tr><td><code id="templatebrain_+3A_units">units</code></td>
<td>
<p>units of physical measurements (e.g. microns).</p>
</td></tr>
<tr><td><code id="templatebrain_+3A_description">description</code></td>
<td>
<p>details of the template.</p>
</td></tr>
<tr><td><code id="templatebrain_+3A_doi">doi</code></td>
<td>
<p>a DOI for the original template brain image.</p>
</td></tr>
<tr><td><code id="templatebrain_+3A_...">...</code></td>
<td>
<p>additional named arguments that will be added as fields to the
<code>templatebrain</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A variety of methods are available to work on <code>templatebrain</code> objects. See
<code><a href="#topic+templatebrain-meths">templatebrain-meths</a></code> for basic methods. The two main functions
that are available for using template brains are <code><a href="#topic+xform_brain">xform_brain</a></code> and
<code><a href="#topic+mirror_brain">mirror_brain</a></code>.
</p>
<p><code>templatebrain</code> objects are only useful for transformation processes
when the <code>BoundingBox</code> is specified to define the physical extent of the
volume. We use the definition of the Amira 3D visualisation and analysis
software. This corresponds to the <strong>node</strong> centers option in the
<a href="https://teem.sourceforge.net/nrrd/format.html">NRRD format</a>. The
bounding box can be obtained from NRRD or AmiraMesh format files. See
<code><a href="nat.html#topic+boundingbox">boundingbox</a></code> for details.
</p>


<h3>Value</h3>

<p>A list with class <code>templatebrain</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.templatebrain">as.templatebrain</a></code>, <code><a href="#topic+templatebrain-meths">templatebrain-meths</a></code>,
<code><a href="#topic+xform_brain">xform_brain</a></code>, <code><a href="#topic+mirror_brain">mirror_brain</a></code>.
</p>

<hr>
<h2 id='templatebrain-meths'>Template brain methods</h2><span id='topic+templatebrain-meths'></span><span id='topic+is.templatebrain'></span><span id='topic+as.character.templatebrain'></span><span id='topic+print.templatebrain'></span><span id='topic+as.im3d.templatebrain'></span><span id='topic+origin.templatebrain'></span><span id='topic+dim.templatebrain'></span><span id='topic+voxdims.templatebrain'></span><span id='topic+boundingbox.templatebrain'></span>

<h3>Description</h3>

<p><code>is.templatebrain</code> tests if object is of class
templatebrain
</p>
<p><code>as.character.templatebrain</code> converts template brain to
character vector representation (normally used to extract the short name
i.e. <code>regName</code>).
</p>
<p><code>print.templatebrain</code> prints templatebrain information in
human-readable form
</p>
<p><code>as.im3d</code> converts a template brain to a
<code>nat::<a href="nat.html#topic+im3d">im3d</a></code> object; this is probably useful for
developers.
</p>
<p><code>origin</code> extracts the space origin of a <code>templatebrain</code>
object.
</p>
<p><code>dim</code> extracts the dimensions (in number of pixels) of the
image associated with a <code>templatebrain</code> object.
</p>
<p><code>voxdims</code> extracts the dimensions (in calibrated spatial
units, e.g. microns) of voxels in the image associated with a
<code>templatebrain</code> object.
</p>
<p><code>boundingbox</code> extracts the boundingbox (in calibrated
spatial units, e.g. microns) of the image associated with a templatebrain
object. See <code><a href="nat.html#topic+boundingbox">boundingbox</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.templatebrain(x)

## S3 method for class 'templatebrain'
as.character(x, field = c("regName", "name"), ...)

## S3 method for class 'templatebrain'
print(x, ...)

## S3 method for class 'templatebrain'
as.im3d(x, ...)

## S3 method for class 'templatebrain'
origin(x, ...)

## S3 method for class 'templatebrain'
dim(x, ...)

## S3 method for class 'templatebrain'
voxdims(x, ...)

## S3 method for class 'templatebrain'
boundingbox(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="templatebrain-meths_+3A_x">x</code></td>
<td>
<p>an object (usually a <code>templatebrain</code>).</p>
</td></tr>
<tr><td><code id="templatebrain-meths_+3A_field">field</code></td>
<td>
<p>which field to use (defaults to <code>'regName'</code>).</p>
</td></tr>
<tr><td><code id="templatebrain-meths_+3A_...">...</code></td>
<td>
<p>additional arguments for methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return values are documented in the generic methods.
<code>is.templatebrain</code> returns a logical indicating whether or not the
object is a <code>templatebrain</code>.
</p>
<p><code>as.character.templatebrain</code> returns a character vector with the
name of the template brain.
</p>
<p><code>dim.templatebrain</code> returns a 3-value integer vector.
</p>


<h3>See Also</h3>

<p><code><a href="nat.html#topic+im3d">im3d</a></code>
</p>
<p><code><a href="nat.html#topic+origin">origin</a></code>
</p>
<p><code><a href="nat.html#topic+voxdims">voxdims</a></code>
</p>
<p><code><a href="nat.html#topic+boundingbox">boundingbox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FCWB.demo)
is.templatebrain(FCWB.demo)
origin(FCWB.demo)
dim(FCWB.demo)
voxdims(FCWB.demo)
boundingbox(FCWB.demo)
# print method
FCWB.demo
</code></pre>

<hr>
<h2 id='update_reg_repos'>Update local copy of git repository containing registrations</h2><span id='topic+update_reg_repos'></span>

<h3>Description</h3>

<p>When <code>x=NULL</code> all repositories listed in
options(nat.templatebrains.regdirs) are checked to see if they are git
repositories and, if yes, they are pulled to update.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_reg_repos(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_reg_repos_+3A_x">x</code></td>
<td>
<p>Path to local checkout of a registration git repository. See details
for meaning of default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is principally called for its side effect, but does
return a <code>git2r::repository</code> object containing the path on disk to the
location of the git repository with registration.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+download_reg_repo">download_reg_repo</a></code>
</p>

<hr>
<h2 id='xform_brain'>Transform 3D object between template brains</h2><span id='topic+xform_brain'></span>

<h3>Description</h3>

<p>Transform 3D object between template brains
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xform_brain(
  x,
  sample = regtemplate(x),
  reference,
  via = NULL,
  imagedata = is.character(x),
  checkboth = NULL,
  target = NULL,
  Verbose = interactive(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xform_brain_+3A_x">x</code></td>
<td>
<p>the 3D object to be transformed</p>
</td></tr>
<tr><td><code id="xform_brain_+3A_sample">sample</code></td>
<td>
<p>Source template brain (e.g. IS2) that data is currently in.
Specified either as character vector or a <code>templatebrain</code> object.</p>
</td></tr>
<tr><td><code id="xform_brain_+3A_reference">reference</code></td>
<td>
<p>Target template brain (e.g. IS2) that data should be
transformed into.</p>
</td></tr>
<tr><td><code id="xform_brain_+3A_via">via</code></td>
<td>
<p>(optional) intermediate template brain that the registration
sequence must pass through.</p>
</td></tr>
<tr><td><code id="xform_brain_+3A_imagedata">imagedata</code></td>
<td>
<p>Whether <code>x</code> should be treated as image data (presently
only supported as a file on disk) or 3D object vertices - see details.</p>
</td></tr>
<tr><td><code id="xform_brain_+3A_checkboth">checkboth</code></td>
<td>
<p>When <code>TRUE</code> will look for registrations in both
directions. See details.</p>
</td></tr>
<tr><td><code id="xform_brain_+3A_target">target</code></td>
<td>
<p>When transforming image data, this specifies the target space
(defaults to <code>reference</code> when <code>imagedata=TRUE</code>). See Details.</p>
</td></tr>
<tr><td><code id="xform_brain_+3A_verbose">Verbose</code></td>
<td>
<p>Whether to show a message with the sequence of template brains</p>
</td></tr>
<tr><td><code id="xform_brain_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to <code><a href="nat.html#topic+xform">xform</a></code> and then on to
<code><a href="nat.html#topic+xformpoints">xformpoints</a></code> or <code><a href="nat.html#topic+xformimage">xformimage</a></code> which will
eventually hand off to <code><a href="nat.html#topic+cmtk.reformatx">cmtk.reformatx</a></code> when using CMTK.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NB the <code>sample</code>, <code>reference</code> and <code>via</code> brains can
either be <code>templatebrain</code> objects or a character string containing the
short name of the template e.g. <code>"IS2"</code>.
</p>
<p><code>xform_brain</code> uses the helper function
<code><a href="#topic+shortest_bridging_seq">shortest_bridging_seq</a></code> to find the shortest path between
different template brains based on the set of bridging registrations that
the natverse has been informed about (see <code><a href="#topic+bridging_graph">bridging_graph</a></code>).
You can specify a <code>via</code> argument to ensure that the registrations
passes through one or more intermediate templates. Note that when multiple
brains are passed to <code>via</code> they should be in order from sample to
reference. If you are passing multiple <code><a href="#topic+templatebrain">templatebrain</a></code> objects,
they must be wrapped in a list.
</p>
<p>When transforming image data (<code>imagedata=TRUE</code>), the <code>target</code>
argument should normally be specified. This defines the absolute/voxel
dimensions of the target space. This can be calculated from a
<code>templatebrain</code> object, so by default it will be set to the value of
the <code>reference</code> argument. Alternatively an image file on disk can be
specified; this is essential if the <code>reference</code> argument does not
specify a <code><a href="#topic+templatebrain">templatebrain</a></code> object but instead just names a
template space (i.e. is a string).
</p>
<p>The significance of the <code>imagedata</code> and <code>checkboth</code> arguments is
that CMTK registrations are not directly invertible although they can be
numerically inverted in most cases (unless there are regions where folding
occurred). For image data, numerical inversion is <em>much</em> slower.
</p>
<p>You can control whether you want to allow inverse registrations manually by
setting <code>checkboth</code> explicitly. Otherwise when <code>checkboth=NULL</code>
the default is to act as if <code>checkboth=TRUE</code> but issue a warning if an
inversion must be used.
</p>


<h3>Value</h3>

<p>A transformed version of <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mirror_brain">mirror_brain</a></code>, <code><a href="#topic+shortest_bridging_seq">shortest_bridging_seq</a></code>
<code><a href="#topic+bridging_graph">bridging_graph</a></code>, <code><a href="#topic+regtemplate">regtemplate</a></code>,
<code><a href="nat.html#topic+xform">xform</a></code>. <code><a href="nat.html#topic+xformpoints">xformpoints</a></code>, <code><a href="nat.html#topic+xformimage">xformimage</a></code>,
<code><a href="nat.html#topic+cmtk.reformatx">cmtk.reformatx</a></code> (for transforming image data with CMTK).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## depends on nat.flybrains package and system CMTK installation
## Not run: 
## reformat neurons
##
library(nat.flybrains)
# Plot Kenyon cells in their original FCWB template brain
nopen3d()
plot3d(kcs20)
plot3d(FCWB)
# Convert to JFCR2 template brain
kcs20.jfrc2=xform_brain(kcs20, sample = FCWB, reference=JFRC2)
# now plot in the new JFRC2 space
nopen3d()
plot3d(kcs20.jfrc2)
plot3d(JFRC2)
# compare with the untransformed neurons
plot3d(kcs20)
# plot with neuropil sub regions for the left mushroom body
clear3d()
plot3d(kcs20.jfrc2)
# nb "MB.*_L" is a regular expression
plot3d(JFRC2NP.surf, "MB.*_L", alpha=0.3)
# compare with originals - bridging registration is no perfect in peduncle
nopen3d()
plot3d(kcs20)
plot3d(FCWBNP.surf, "MB.*_L", alpha=0.3)

# insist on using a specific intermediate template brain
# this would nor be an improvement in this case
kcs20.jfrc2viais2=xform_brain(kcs20, sample = FCWB, via=IS2, reference=JFRC2)


## reformat image examples
# see ?cmtk.reformatx for details of any additional arguments
# note that for image data a target space defining the dimensions of the
# output image must be specified - this happens by default using the
# reference templatebrain object
xform_brain('in.nrrd', sample=FCWB, ref=JFRC2, output='out.nrrd')
# or you can specify an image file explicitly as target
xform_brain('in.nrrd', sample=FCWB, ref=JFRC2, output='out.nrrd',
            target='JFRC2.nrrd')

# use partial volume interpolation for label field
xform_brain('labels.nrrd', sample=FCWB, ref=JFRC2, output='out.nrrd',
            interpolation='pv')

# use binary mask to restrict (and speed up) reformatting
xform_brain('in.nrrd', sample=FCWB, ref=JFRC2, output='out.nrrd', mask='neuropil.nrrd')

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
