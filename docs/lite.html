<!DOCTYPE html><html><head><title>Help for package lite</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lite}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bernoulli'><p>Frequentist inference for the Bernoulli distribution</p></a></li>
<li><a href='#blite'><p>Bayesian threshold-based inference for time series extremes</p></a></li>
<li><a href='#bliteMethods'><p>Methods for objects of class <code>"blite"</code></p></a></li>
<li><a href='#estfun'><p>Functions for the <code>estfun</code> method</p></a></li>
<li><a href='#flite'><p>Frequentist threshold-based inference for time series extremes</p></a></li>
<li><a href='#fliteMethods'><p>Methods for objects of class <code>"flite"</code></p></a></li>
<li><a href='#generalisedPareto'><p>Frequentist inference for the generalised Pareto distribution</p></a></li>
<li><a href='#lite-internal'><p>Internal lite functions</p></a></li>
<li><a href='#lite-package'><p>lite: Likelihood-Based Inference for Time Series Extremes</p></a></li>
<li><a href='#logLikVector'><p>Functions for log-likelihood contributions</p></a></li>
<li><a href='#predict.blite'><p>Predictive inference for the largest value observed in <code class="reqn">N</code> years.</p></a></li>
<li><a href='#returnLevel'><p>Frequentist threshold-based inference for return levels</p></a></li>
<li><a href='#returnLevelMethods'><p>Methods for objects of class <code>"returnLevel"</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Likelihood-Based Inference for Time Series Extremes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs likelihood-based inference for stationary time series 
    extremes.  The general approach follows Fawcett and Walshaw (2012)
    &lt;<a href="https://doi.org/10.1002%2Fenv.2133">doi:10.1002/env.2133</a>&gt;.  Marginal extreme value inferences are adjusted for 
    cluster dependence in the data using the methodology in Chandler and Bate 
    (2007) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasm015">doi:10.1093/biomet/asm015</a>&gt;, producing an adjusted log-likelihood 
    for the model parameters.  A log-likelihood for the extremal index is 
    produced using the K-gaps model of Suveges and Davison (2010) 
    &lt;<a href="https://doi.org/10.1214%2F09-AOAS292">doi:10.1214/09-AOAS292</a>&gt;. These log-likelihoods are combined to make 
    inferences about extreme values. Both maximum likelihood and Bayesian 
    approaches are available.</td>
</tr>
<tr>
<td>Imports:</td>
<td>chandwich, exdex, graphics, revdbayes, rust, sandwich, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://paulnorthrop.github.io/lite/">https://paulnorthrop.github.io/lite/</a>,
<a href="https://github.com/paulnorthrop/lite">https://github.com/paulnorthrop/lite</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paulnorthrop/lite/issues">https://github.com/paulnorthrop/lite/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-27 00:08:36 UTC; paul</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul J. Northrop [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul J. Northrop &lt;p.northrop@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-27 00:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='Bernoulli'>Frequentist inference for the Bernoulli distribution</h2><span id='topic+Bernoulli'></span><span id='topic+fitBernoulli'></span><span id='topic+coef.Bernoulli'></span><span id='topic+vcov.Bernoulli'></span><span id='topic+nobs.Bernoulli'></span><span id='topic+logLik.Bernoulli'></span>

<h3>Description</h3>

<p>Functions involved in making inferences about the probability of success
in a Bernoulli distribution using maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitBernoulli(data)

## S3 method for class 'Bernoulli'
coef(object, ...)

## S3 method for class 'Bernoulli'
vcov(object, ...)

## S3 method for class 'Bernoulli'
nobs(object, ...)

## S3 method for class 'Bernoulli'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bernoulli_+3A_data">data</code></td>
<td>
<p>A numeric vector of outcomes from Bernoulli trials: 0 for a
failure, 1 for a success.  Alternatively, a logical vector with FALSE
for a failure and TRUE for a success. Missing values are removed using
<code><a href="stats.html#topic+na.fail">na.omit</a></code>.</p>
</td></tr>
<tr><td><code id="Bernoulli_+3A_object">object</code></td>
<td>
<p>A fitted model object returned from <code>fitBernoulli()</code>.</p>
</td></tr>
<tr><td><code id="Bernoulli_+3A_...">...</code></td>
<td>
<p>Further arguments. None are used currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitBernoulli</code>: fit a Bernoulli distribution using maximum likelihood
estimation, using an <strong>independence</strong> log-likelihood formed by
summing contributions from individual observations. No adjustment for
cluster dependence has been made in estimating the variance-covariance
matrix stored as component in <code>vcov</code> in the returned object.
</p>
<p><code>coef, vcov, nobs</code> and <code>logLik</code> methods are provided.
</p>


<h3>Value</h3>

<p><code>fitBernoulli</code> returns an object of class <code>"Bernoulli"</code>, a list
with components: <code>maxLogLik</code>, <code>mle</code>, <code>nobs</code>, <code>vcov</code>,
<code>n0</code>, <code>n1</code>, <code>data</code>, <code>obs_data</code>, where <code>data</code> are
the input data and, <code>obs_data</code> are the input data after any missing
values have been removed, using <code><a href="stats.html#topic+na.fail">na.omit</a></code> and
<code>n0</code> and <code>n1</code> are, respectively, the number of failures and the
number of successes.
</p>
<p><code>coef.Bernoulli</code>: a numeric vector of length 1 with name <code>prob</code>.
The MLE of the probability of success.
</p>
<p><code>vcov.Bernoulli</code>: a <code class="reqn">1 \times 1</code> matrix with row
and column name <code>prob</code>.  The estimated variance of the estimator of
the probability of success. No adjustment for cluster dependence has
been made.
</p>
<p><code>nobs.Bernoulli</code>: a numeric vector of length 1 with name <code>prob</code>.
The number of observations used to estimate the probability of success.
</p>
<p><code>logLik.Bernoulli</code>: an object of class <code>"logLik"</code>: a numeric
scalar with value equal to the maximised log-likelihood. The returned
object also has attributes <code>nobs</code>, the numbers of observations used
in this model fit, and <code>"df"</code> (degrees of freedom), which is equal
to the number of total number of parameters estimated (1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up data
cdata &lt;- c(exdex::cheeseboro)
u &lt;- 45
exc &lt;- cdata &gt; u

# Fit a Bernoulli distribution
fit &lt;- fitBernoulli(exc)

# Calculate the log-likelihood at the MLE
res &lt;- logLikVector(fit)

# The logLik method sums the individual log-likelihood contributions.
logLik(res)

# nobs, coef, vcov, logLik methods for objects returned from fitBernoulli()
nobs(fit)
coef(fit)
vcov(fit)
logLik(fit)
</code></pre>

<hr>
<h2 id='blite'>Bayesian threshold-based inference for time series extremes</h2><span id='topic+blite'></span>

<h3>Description</h3>

<p>Performs threshold-based Bayesian inference for 3 aspects of stationary
time series extremes: the probability that the threshold is exceeded, the
marginal distribution of threshold excesses and the extent of clustering of
extremes, as summarised by the extremal index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blite(
  data,
  u,
  cluster,
  k = 1,
  inc_cens = TRUE,
  ny,
  gp_prior = revdbayes::set_prior(prior = "mdi", model = "gp"),
  b_prior = revdbayes::set_bin_prior(prior = "jeffreys"),
  theta_prior_pars = c(1, 1),
  n = 1000,
  type = c("vertical", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blite_+3A_data">data</code></td>
<td>
<p>A numeric vector or numeric matrix of raw data.  If <code>data</code>
is a matrix then the log-likelihood is constructed as the sum of
(independent) contributions from different columns. A common situation is
where each column relates to a different year.
</p>
<p>If <code>data</code> contains missing values then <code>split_by_NAs</code> is
used to divide the data further into sequences of non-missing values,
stored in different columns in a matrix.  Again, the log-likelihood
is constructed as a sum of contributions from different columns.</p>
</td></tr>
<tr><td><code id="blite_+3A_u">u</code></td>
<td>
<p>A numeric scalar.  The extreme value threshold applied to the data.
See <strong>Details</strong> for information about choosing <code>u</code>.</p>
</td></tr>
<tr><td><code id="blite_+3A_cluster">cluster</code></td>
<td>
<p>This argument is used to set the argument <code>cluster</code> to
<code><a href="sandwich.html#topic+vcovCL">meatCL</a></code>, which calculates the matrix <code class="reqn">V</code>
passed as the argument <code>V</code> to <code><a href="chandwich.html#topic+adjust_loglik">adjust_loglik</a></code>.
If <code>data</code> is a matrix and <code>cluster</code> is missing then
<code>cluster</code> is set so that data in different columns are in different
clusters.  If <code>data</code> is a vector and <code>cluster</code> is missing then
cluster is set so that each observation forms its own cluster.
</p>
<p>If <code>cluster</code> is supplied then it must have the same structure as
<code>data</code>: if <code>data</code> is a matrix then <code>cluster</code> must be a
matrix with the same dimensions as <code>data</code> and if  <code>data</code> is a
vector then <code>cluster</code> must be a vector of the same length as
<code>data</code>.  Each entry in <code>cluster</code> sets the cluster of the
corresponding component of <code>data</code>.</p>
</td></tr>
<tr><td><code id="blite_+3A_k">k</code>, <code id="blite_+3A_inc_cens">inc_cens</code></td>
<td>
<p>Arguments passed to <code><a href="exdex.html#topic+kgaps">kgaps</a></code>.
<code>k</code> sets the value of the run parameter <code class="reqn">K</code> in the <code class="reqn">K</code>-gaps
model for the extremal index.
<code>inc_cens</code> determines whether contributions from right-censored
inter-exceedance times are used. See <strong>Details</strong> for information
about choosing <code>k</code>.</p>
</td></tr>
<tr><td><code id="blite_+3A_ny">ny</code></td>
<td>
<p>A numeric scalar.  The (mean) number of observations per year.
Setting this appropriately is important when making predictive inferences
using <code><a href="#topic+predict.blite">predict.blite</a></code>, but <code>ny</code> is not used by
<code>blite</code> so it need not be supplied now.  If <code>ny</code> is supplied to
<code>blite</code> then it is stored for use by <code><a href="#topic+predict.blite">predict.blite</a></code>.
Alternatively, <code>ny</code> can be supplied in a later call to
<code><a href="#topic+predict.blite">predict.blite</a></code>.  If <code>ny</code> is supplied to
both <code>blite</code> and <code><a href="#topic+predict.blite">predict.blite</a></code> then the value supplied
to <code><a href="#topic+predict.blite">predict.blite</a></code> will take precedence, with no warning
given.</p>
</td></tr>
<tr><td><code id="blite_+3A_gp_prior">gp_prior</code></td>
<td>
<p>A list to specify a prior distribution for the GP parameters
(<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code>), set using <code><a href="revdbayes.html#topic+set_prior">set_prior</a></code>.</p>
</td></tr>
<tr><td><code id="blite_+3A_b_prior">b_prior</code></td>
<td>
<p>A list to specify a prior distribution for the Bernoulli
parameter <code class="reqn">p</code><sub>u</sub>, set
using <code><a href="revdbayes.html#topic+set_bin_prior">set_bin_prior</a></code>.</p>
</td></tr>
<tr><td><code id="blite_+3A_theta_prior_pars">theta_prior_pars</code></td>
<td>
<p>A numerical vector of length 2 containing the
respective values of the parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> of a
Beta(<code class="reqn">\alpha</code>, <code class="reqn">\beta</code>) prior for the extremal index <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code id="blite_+3A_n">n</code></td>
<td>
<p>An integer scalar.  The size of posterior sample required.</p>
</td></tr>
<tr><td><code id="blite_+3A_type">type</code></td>
<td>
<p>A character scalar.  Either <code>"vertical"</code> to adjust the
independence log-likelihood vertically, or <code>"none"</code> for no
adjustment.  Horizontal adjustment is not offered because it does not
preserve the correct support of the posterior distribution.</p>
</td></tr>
<tr><td><code id="blite_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the function
<code><a href="sandwich.html#topic+vcovCL">meatCL</a></code> in the sandwich package.
In particular, the clustering adjustment argument <code>cadjust</code>
may make a difference if the number of clusters is not large.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+flite">flite</a></code> for details of the (adjusted) likelihoods
on which these Bayesian inferences are based.
</p>
<p>The likelihood is based on a model for 3 independent aspects.
</p>

<ol>
<li><p>A Bernoulli(<code class="reqn">p</code><sub>u</sub>) model
for whether a given observation exceeds the threshold <code class="reqn">u</code>.
</p>
</li>
<li><p>A generalised Pareto,
GP(<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code>), model for the marginal distribution of threshold
excesses.
</p>
</li>
<li><p>The <code class="reqn">K</code>-gaps model for the extremal index <code class="reqn">\theta</code>.
</p>
</li></ol>

<p>The general approach follows Fawcett and Walshaw (2012).
</p>
<p>The contributions to the likelihood for
<code class="reqn">p</code><sub>u</sub> and
(<code class="reqn">\sigma</code><sub>u</sub>, <code class="reqn">\xi</code>)
are based on the vertically-adjusted likelihoods described in
<code><a href="#topic+flite">flite</a></code>.  This is an example of Bayesian inference using a
composite likelihood Ribatet et al (2012). Priors for
<code class="reqn">p</code><sub>u</sub>
(<code class="reqn">\sigma</code><sub>u</sub>, <code class="reqn">\xi</code>)
and <code class="reqn">\theta</code> are set using the arguments <code>gp_prior</code>,
<code>b_prior</code> and <code>theta_prior_pars</code>.
Currently, only priors where
<code class="reqn">p</code><sub>u</sub>
(<code class="reqn">\sigma</code><sub>u</sub>, <code class="reqn">\xi</code>)
and <code class="reqn">\theta</code> are independent a priori are allowed.
</p>
<p>Two tuning parameters need to be chosen: a threshold <code class="reqn">u</code> and the
<code class="reqn">K</code>-gaps run parameter <code class="reqn">K</code>.  The <code><a href="exdex.html#topic+exdex">exdex</a></code>
package has a function <code><a href="exdex.html#topic+choose_uk">choose_uk</a></code> to inform this
choice.
</p>
<p>Random samples are simulated from the posteriors for
<code class="reqn">p</code><sub>u</sub> and
(<code class="reqn">\sigma</code><sub>u</sub>, <code class="reqn">\xi</code>)
(using <code><a href="rust.html#topic+ru">ru</a></code>) and <code class="reqn">\theta</code> (using
<code><a href="revdbayes.html#topic+kgaps_post">kgaps_post</a></code>).
</p>


<h3>Value</h3>

<p>An object of class <code>c("blite", "lite", "chandwich")</code>.
This object is an <code>n</code> <code class="reqn">\times 4</code> matrix containing the
posterior samples, with column names
<code>c("p[u]", "sigma[u]", "xi", "theta")</code>.
</p>
<p>The object also has the attributes <code>"Bernoulli"</code>, <code>"gp"</code>,
<code>"theta"</code>, which provide the fitted model objects returned from
<code><a href="chandwich.html#topic+adjust_loglik">adjust_loglik</a></code> (for <code>"Bernoulli"</code> and
<code>"gp"</code>) and <code><a href="exdex.html#topic+kgaps">kgaps</a></code> (for <code>"theta"</code>).
The named input arguments are returned in a list as the attribute
<code>inputs</code>.  If <code>ny</code> was not supplied then its value is <code>NA</code>.
The call to <code>blite</code> is provided in the attribute <code>"call"</code>.
A call to <code><a href="#topic+flite">flite</a></code> is used to create adjusted log-likelihoods
for <code class="reqn">p</code><sub>u</sub> and
(<code class="reqn">\sigma</code><sub>u</sub>, <code class="reqn">\xi</code>).
The object returned from the call is provided as the attribute
<code>"flite_object"</code>.
</p>
<p>Objects inheriting from class <code>"blite"</code> have <code>coef</code>,
<code>nobs</code>, <code>plot</code>, <code>summary</code>, <code>vcov</code> and <code>confint</code>
methods.  See <code><a href="#topic+bliteMethods">bliteMethods</a></code>.
</p>
<p><code><a href="#topic+predict.blite">predict.blite</a></code> can be used to make predictive inferences about
the largest value to be observed in <em>N</em> years.
</p>


<h3>References</h3>

<p>Fawcett, L. and Walshaw, D. (2012), Estimating return levels
from serially dependent extremes. <em>Environmetrics</em>, <strong>23</strong>,
272-283. <a href="https://doi.org/10.1002/env.2133">doi:10.1002/env.2133</a>
</p>
<p>Ribatet, M., Cooley, D., &amp; Davison, A. C. (2012). Bayesian
inference from composite likelihoods, with an application to spatial
extremes. <em>Statistica Sinica</em>, <strong>22</strong>(2), 813-845.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bliteMethods">bliteMethods</a></code>, including plotting the posterior
samples.
</p>
<p><code><a href="#topic+predict.blite">predict.blite</a></code> to make predictive inferences about
future extreme values.
</p>
<p><code><a href="#topic+flite">flite</a></code> for frequentist threshold-based inference
for time series extremes.
</p>
<p><code><a href="exdex.html#topic+choose_uk">choose_uk</a></code> to inform the choice of the
threshold <code class="reqn">u</code> and run parameter <code class="reqn">K</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Cheeseboro wind gusts

cdata &lt;- exdex::cheeseboro
# Each column of the matrix cdata corresponds to data from a different year
# blite() sets cluster automatically to correspond to column (year)
cpost &lt;- blite(cdata, u = 45, k = 3)
summary(cpost)

## Plots of posterior samples
plot(cpost)

## Credible intervals
confint(cpost)
</code></pre>

<hr>
<h2 id='bliteMethods'>Methods for objects of class <code>"blite"</code></h2><span id='topic+bliteMethods'></span><span id='topic+plot.blite'></span><span id='topic+coef.blite'></span><span id='topic+vcov.blite'></span><span id='topic+nobs.blite'></span><span id='topic+summary.blite'></span><span id='topic+print.summary.blite'></span><span id='topic+confint.blite'></span>

<h3>Description</h3>

<p>Methods for objects of class <code>"blite"</code> returned from
<code><a href="#topic+blite">blite</a></code>. <code>confint.blite</code> is a misnomer: it returns
(equi-tailed) Bayesian credible intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blite'
plot(x, which = c("all", "pu", "gp", "xi", "theta"), ...)

## S3 method for class 'blite'
coef(object, fun, ...)

## S3 method for class 'blite'
vcov(object, ...)

## S3 method for class 'blite'
nobs(object, ...)

## S3 method for class 'blite'
summary(
  object,
  short = TRUE,
  mean = TRUE,
  digits = max(3, getOption("digits") - 3L),
  ...
)

## S3 method for class 'summary.blite'
print(x, ...)

## S3 method for class 'blite'
confint(object, parm = "all", level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bliteMethods_+3A_x">x</code></td>
<td>
<p>An object inheriting from class <code>"blite"</code>, a result of a
call to <code><a href="#topic+blite">blite</a></code>.</p>
</td></tr>
<tr><td><code id="bliteMethods_+3A_which">which</code></td>
<td>
<p>A character scalar indicating which plot(s) to produce.
If <code>which = "all"</code> then all 4 plots described in <strong>Details</strong>
are produced.  Otherwise, only one of these plots is produced, with the
possible names of the arguments being in the order that the plots are
described in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="bliteMethods_+3A_...">...</code></td>
<td>
<p>For <code>plot.blite</code>: arguments passed to
<code><a href="graphics.html#topic+plot.default">plot</a></code>, such as graphical parameters.
</p>
<p>For <code>coef.blite</code>: additional arguments passed to <code>fun</code>.
</p>
<p>For <code>print.summary.blite</code>: additional arguments passed to
<code><a href="base.html#topic+print.default">print.default</a></code>.
</p>
<p>Otherwise <code>...</code> is unused.</p>
</td></tr>
<tr><td><code id="bliteMethods_+3A_object">object</code></td>
<td>
<p>An object of class <code>"blite"</code>, returned by
<code><a href="#topic+blite">blite</a></code>.</p>
</td></tr>
<tr><td><code id="bliteMethods_+3A_fun">fun</code></td>
<td>
<p>A summary function to be applied to each column of the simulated
values in <code>object</code>.  If <code>fun</code> is missing then
<code><a href="base.html#topic+mean">mean</a></code> is used.</p>
</td></tr>
<tr><td><code id="bliteMethods_+3A_short">short</code></td>
<td>
<p>A logical scalar that determines the form of the output. See
<strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="bliteMethods_+3A_mean">mean</code></td>
<td>
<p>A logical scalar.  Determines the form of the output if
<code>short = TRUE</code>. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="bliteMethods_+3A_digits">digits</code></td>
<td>
<p>An integer. Passed to <code><a href="base.html#topic+Round">signif</a></code> to
round the values in the summary.</p>
</td></tr>
<tr><td><code id="bliteMethods_+3A_parm">parm</code></td>
<td>
<p>A character vector specifying the parameters for which
confidence intervals are required. The default, <code>which = "all"</code>,
produces confidence intervals for all the parameters, that is,
<code class="reqn">p</code><sub>u</sub>,
<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code> and <code class="reqn">\theta</code>. If <code>which = "gp"</code> then intervals are
produced only for
<code class="reqn">\sigma</code><sub>u</sub> and
<code class="reqn">\xi</code>. Otherwise, <code>parm</code> must be a subset of
<code>c("pu", "sigmau", "xi", "theta")</code>.</p>
</td></tr>
<tr><td><code id="bliteMethods_+3A_level">level</code></td>
<td>
<p>The credible level required.  A numeric scalar in (0, 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>plot.blite</code>, if <code>which = "all"</code> then 4 plots are produced.
</p>

<ul>
<li><p>Top left: histogram of the posterior sample for the threshold
exceedance probability
<code class="reqn">p</code><sub>u</sub>.
</p>
</li>
<li><p>Top right: scatter plot of posterior sample for the GP
parameters
(<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code>).
The linear constraint
<code class="reqn">\xi</code> &gt; -<code class="reqn">\sigma</code><sub>u</sub> / <code class="reqn">x</code>
<sub>(n)</sub>
is drawn on the plot.
</p>
</li>
<li><p>Bottom left: histogram of the posterior sample for the GP shape
parameter <code class="reqn">\xi</code>.
</p>
</li>
<li><p>Bottom right: histogram of the posterior sample for the extremal
index <code class="reqn">\theta</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>plot.blite</code>: No return value, only the plot is produced.
</p>
<p><code>coef.blite</code>: a numeric vector of length 4 with names
<code>c("p[u]", "sigma[u]", "xi", "theta")</code>.  The values of summary
statistics calculated using the function <code>fun</code>.
</p>
<p><code>vcov.blite</code>: a <code class="reqn">4 \times 4</code> matrix with row and
column names <code>c("p[u]", "sigma[u]", "xi", "theta")</code>.  An estimate
of the posterior covariance matrix, calculated using
<code><a href="stats.html#topic+cov">cov</a></code>.
</p>
<p><code>nobs.blite</code>: a numeric vector of length 3 with names
<code>c("p[u]", "gp", "theta")</code>.  The respective number of observations
used to infer <code class="reqn">p</code><sub>u</sub>,
(<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code>) and <code class="reqn">\theta</code>.
</p>
<p><code>summary.blite</code>: an object containing the original function call and
a matrix of summaries of the posterior samples for each of the
parameters.  If <code>short = TRUE</code> then there are 2 columns, containing
either the sample posterior means and standard deviations
(<code>mean = TRUE</code>) or the sample posterior medians and inter-quartile
ranges (<code>mean = FALSE</code>).  If <code>short = FALSE</code> then there are 4
columns, with each column containing the usual 6-number summary produced
by <code><a href="base.html#topic+summary">summary</a></code>. The object is printed by
<code><a href="#topic+print.summary.blite">print.summary.blite</a></code>.
</p>
<p><code>print.summary.blite</code>: the argument <code>x</code> is returned, invisibly.
</p>
<p><code>confint.blite</code>: a numeric matrix with 2 columns giving the lower and
upper credible limits for each parameter. These columns are labelled
as <code>(1-level)/2</code> and <code>1-(1-level)/2</code>, expressed as a
percentage, by default <code>2.5%</code> and <code>97.5%</code>.  The row names
are the names of the parameters supplied in <code>parm</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blite">blite</a></code> to perform frequentist threshold-based
inference for time series extremes.
</p>
<p><code><a href="#topic+predict.blite">predict.blite</a></code>: for predictive inference for the
largest value observed in <code class="reqn">N</code> years.
</p>

<hr>
<h2 id='estfun'>Functions for the <code>estfun</code> method</h2><span id='topic+estfun'></span><span id='topic+estfun.Bernoulli'></span><span id='topic+estfun.GP'></span>

<h3>Description</h3>

<p>Functions to calculate contributions to the score vector from individual
observations for a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bernoulli'
estfun(x, ...)

## S3 method for class 'GP'
estfun(x, eps = 1e-05, m = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estfun_+3A_x">x</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="estfun_+3A_...">...</code></td>
<td>
<p>Further arguments.  None are used for
<code>estfun.Bernoulli</code> or <code>estfun.GP</code>.</p>
</td></tr>
<tr><td><code id="estfun_+3A_eps">eps</code>, <code id="estfun_+3A_m">m</code></td>
<td>
<p>These control the estimation of the observed
information in <code>gpObsInfo</code> when the GP shape parameter <code class="reqn">\xi</code> is
very close to zero.  In these cases, direct calculation is unreliable.
<code>eps</code> is a (small, positive) numeric scalar.  If the absolute value
of the input value of <code class="reqn">\xi</code>, that is, <code>pars[2]</code>, is smaller than
<code>eps</code> then we approximate the <code>[2, 2]</code> element using a Taylor
series expansion in <code class="reqn">\xi</code>, evaluated up to and including the
<code>m</code>th term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code><a href="sandwich.html#topic+estfun">estfun</a></code> method is used by
<code><a href="sandwich.html#topic+vcovCL">meatCL</a></code> to calculate the
<code><a href="sandwich.html#topic+meat">meat</a></code> in the sandwich covariance estimator on which
the log-likelihood adjustments in <code><a href="#topic+flite">flite</a></code> are based.
Specifically, <code><a href="sandwich.html#topic+vcovCL">meatCL</a></code> is used to calculate
the argument <code>V</code> passed to <code><a href="chandwich.html#topic+adjust_loglik">adjust_loglik</a></code>.
</p>


<h3>Value</h3>

<p>An <code class="reqn">n \times k</code> matrix containing contributions
to the score function from <code class="reqn">n</code> observations for each of the <code class="reqn">k</code>
parameters.
</p>
<p><code>estfun.Bernoulli</code>: an <code class="reqn">n \times 2</code> matrix, where
<code class="reqn">n</code> is the sample size, the length of the input <code>data</code> to
<code><a href="#topic+fitBernoulli">fitBernoulli</a></code>.  The column is named <code>prob</code>.
</p>
<p><code>estfun.GP</code>: an <code class="reqn">n \times 2</code> matrix, where <code class="reqn">n</code> is the
sample size, the length of the input <code>data</code> to <code><a href="#topic+fitGP">fitGP</a></code>.
The columns are named <code>sigma[u]</code> and <code>xi</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bernoulli">Bernoulli</a></code> for maximum likelihood inference for the
Bernoulli distribution.
</p>
<p><code><a href="#topic+generalisedPareto">generalisedPareto</a></code> for maximum likelihood inference
for the generalised Pareto distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sandwich)

# estfun.Bernoulli
bfit &lt;- fitBernoulli(c(exdex::cheeseboro) &gt; 45)
head(estfun(bfit))

# estfun.generalisedPareto
gpfit &lt;- fitGP(c(exdex::cheeseboro), u = 45)
head(estfun(gpfit))
</code></pre>

<hr>
<h2 id='flite'>Frequentist threshold-based inference for time series extremes</h2><span id='topic+flite'></span>

<h3>Description</h3>

<p>Performs threshold-based frequentist inference for 3 aspects of stationary
time series extremes: the probability that the threshold is exceeded, the
marginal distribution of threshold excesses and the extent of clustering of
extremes, as summarised by the extremal index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flite(data, u, cluster, k = 1, inc_cens = TRUE, ny, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flite_+3A_data">data</code></td>
<td>
<p>A numeric vector or numeric matrix of raw data.  If <code>data</code>
is a matrix then the log-likelihood is constructed as the sum of
(independent) contributions from different columns. A common situation is
where each column relates to a different year.
</p>
<p>If <code>data</code> contains missing values then <code>split_by_NAs</code> is
used to divide the data further into sequences of non-missing values,
stored in different columns in a matrix.  Again, the log-likelihood
is constructed as a sum of contributions from different columns.</p>
</td></tr>
<tr><td><code id="flite_+3A_u">u</code></td>
<td>
<p>A numeric scalar.  The extreme value threshold applied to the data.
See <strong>Details</strong> for information about choosing <code>u</code>.</p>
</td></tr>
<tr><td><code id="flite_+3A_cluster">cluster</code></td>
<td>
<p>This argument is used to set the argument <code>cluster</code> to
<code><a href="sandwich.html#topic+vcovCL">meatCL</a></code>, which calculates the matrix <code class="reqn">V</code>
passed as the argument <code>V</code> to <code><a href="chandwich.html#topic+adjust_loglik">adjust_loglik</a></code>.
If <code>data</code> is a matrix and <code>cluster</code> is missing then
<code>cluster</code> is set so that data in different columns are in different
clusters.  If <code>data</code> is a vector and <code>cluster</code> is missing then
cluster is set so that each observation forms its own cluster.
</p>
<p>If <code>cluster</code> is supplied then it must have the same structure as
<code>data</code>: if <code>data</code> is a matrix then <code>cluster</code> must be a
matrix with the same dimensions as <code>data</code> and if  <code>data</code> is a
vector then <code>cluster</code> must be a vector of the same length as
<code>data</code>.  Each entry in <code>cluster</code> sets the cluster of the
corresponding component of <code>data</code>.</p>
</td></tr>
<tr><td><code id="flite_+3A_k">k</code>, <code id="flite_+3A_inc_cens">inc_cens</code></td>
<td>
<p>Arguments passed to <code><a href="exdex.html#topic+kgaps">kgaps</a></code>.
<code>k</code> sets the value of the run parameter <code class="reqn">K</code> in the <code class="reqn">K</code>-gaps
model for the extremal index.
<code>inc_cens</code> determines whether contributions from right-censored
inter-exceedance times are used. See <strong>Details</strong> for information
about choosing <code>k</code>.</p>
</td></tr>
<tr><td><code id="flite_+3A_ny">ny</code></td>
<td>
<p>A numeric scalar.  The (mean) number of observations per year.
Setting this appropriately is important when making inferences about
return levels, using <code><a href="#topic+returnLevel">returnLevel</a></code>, but <code>ny</code> is not
used by <code>flite</code> so it need not be supplied now.  If <code>ny</code> is
supplied to <code>flite</code> then it is stored for use by
<code><a href="#topic+returnLevel">returnLevel</a></code>.  Alternatively, <code>ny</code> can be supplied in
a later call to <code><a href="#topic+returnLevel">returnLevel</a></code>.  If <code>ny</code> is supplied to
both <code>flite</code> and <code><a href="#topic+returnLevel">returnLevel</a></code> then the value supplied to
<code><a href="#topic+returnLevel">returnLevel</a></code> will take precedence, with no warning given.</p>
</td></tr>
<tr><td><code id="flite_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the function
<code><a href="sandwich.html#topic+vcovCL">meatCL</a></code> in the sandwich package.
In particular, the clustering adjustment argument <code>cadjust</code>
may make a difference if the number of clusters is not large.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 3 independent parts to the inference, all performed using
maximum likelihood estimation.
</p>

<ol>
<li><p>A Bernoulli(<code class="reqn">p</code><sub>u</sub>)
model for whether a given observation exceeds the threshold
<code class="reqn">u</code>.
</p>
</li>
<li><p>A generalised Pareto,
GP(<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code>), model for the marginal distribution of threshold
excesses.
</p>
</li>
<li><p>The <code class="reqn">K</code>-gaps model for the extremal index <code class="reqn">\theta</code>.
</p>
</li></ol>

<p>The general approach follows Fawcett and Walshaw (2012).
</p>
<p>For parts 1 and 2, inferences based on a mis-specified independence
log-likelihood are adjusted to account for clustering in the data. Here,
we follow Chandler and Bate (2007) to estimate adjusted log-likelihood
functions for <code class="reqn">p</code><sub>u</sub>
and for (<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code>), with the
argument <code>cluster</code> defining the clusters. This aspect of the
calculations is performed using the <code><a href="chandwich.html#topic+adjust_loglik">adjust_loglik</a></code>
in the <code><a href="chandwich.html#topic+chandwich">chandwich</a></code> package (Northrop and Chandler,
2021). The GP distribution initial fit of the GP distribution to threshold
excesses is performed using the <code><a href="revdbayes.html#topic+grimshaw_gp_mle">grimshaw_gp_mle</a></code>
function in the <code><a href="revdbayes.html#topic+revdbayes">revdbayes</a></code> package
(Northrop, 2020).
</p>
<p>In part 3, the methodology described in Suveges and Davison (2010) is
implemented using the <code><a href="exdex.html#topic+exdex">exdex</a></code> package
(Northrop and Christodoulides, 2022).
</p>
<p>Two tuning parameters need to be chosen: a threshold <code class="reqn">u</code> and the
<code class="reqn">K</code>-gaps run parameter <code class="reqn">K</code>.  The <code><a href="exdex.html#topic+exdex">exdex</a></code>
package has a function <code><a href="exdex.html#topic+choose_uk">choose_uk</a></code> to inform this
choice.
</p>
<p>Each part of the inference produces a log-likelihood function (adjusted
for parts 1 and 2).  These log-likelihoods are combined (summed) to form
a log-likelihood function for the parameter vector
(<code class="reqn">p</code><sub>u</sub>,
<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code>, <code class="reqn">\theta</code>).  Return levels are a function of these
parameters and therefore inferences for return levels can be based on
this log-likelihood.
</p>


<h3>Value</h3>

<p>An object of class <code>c("flite", "lite", "chandwich")</code>.
This object is a function with 2 arguments:
</p>

<ul>
<li><p><code>pars</code>, a numeric vector of length 4 to supply the value of
the parameter vector
(<code class="reqn">p</code><sub>u</sub>,
<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code>, <code class="reqn">\theta</code>),
</p>
</li>
<li><p><code>type</code>, a character scalar specifying the type of
adjustment made to the independence log-likelihood in parts
1 and 2, one of <code>"vertical"</code>, <code>"none"</code>, <code>"cholesky"</code>,
or <code>"spectral"</code>.  For details see Chandler and Bate (2007).
The default is <code>"vertical"</code> for the reason given in
the description of the argument <code>adj_type</code> in
<code><a href="#topic+plot.flite">plot.flite</a></code>.
</p>
</li></ul>

<p>The object also has the attributes <code>"Bernoulli"</code>, <code>"gp"</code>,
<code>"theta"</code>, which provide the fitted model objects returned from
<code><a href="chandwich.html#topic+adjust_loglik">adjust_loglik</a></code> (for <code>"Bernoulli"</code> and
<code>"gp"</code>) and <code><a href="exdex.html#topic+kgaps">kgaps</a></code> (for <code>"theta"</code>).
The named input arguments are returned in a list as the attribute
<code>inputs</code>.  If <code>ny</code> was not supplied then its value is <code>NA</code>.
The call to <code>flite</code> is provided in the attribute <code>"call"</code>.
</p>
<p>Objects inheriting from class <code>"flite"</code> have <code>coef</code>,
<code>logLik</code>, <code>nobs</code>, <code>plot</code>, <code>summary</code>, <code>vcov</code>
and <code>confint</code> methods.  See <code><a href="#topic+fliteMethods">fliteMethods</a></code>.
</p>
<p><code><a href="#topic+returnLevel">returnLevel</a></code> can be used to make frequentist inferences about
return levels.
</p>


<h3>References</h3>

<p>Chandler, R. E. and Bate, S. (2007). Inference for clustered.
data using the independence loglikelihood. <em>Biometrika</em>,
<strong>94</strong>(1), 167-183. <a href="https://doi.org/10.1093/biomet/asm015">doi:10.1093/biomet/asm015</a>
</p>
<p>Fawcett, L. and Walshaw, D. (2012), Estimating return levels
from serially dependent extremes. <em>Environmetrics</em>, <strong>23</strong>,
272-283. <a href="https://doi.org/10.1002/env.2133">doi:10.1002/env.2133</a>
</p>
<p>Northrop, P. J. and Chandler, R. E. (2021).
chandwich: Chandler-Bate Sandwich Loglikelihood Adjustment. R package
version 1.1.5. <a href="https://CRAN.R-project.org/package=chandwich">https://CRAN.R-project.org/package=chandwich</a>.
</p>
<p>Northrop, P. J. and Christodoulides, C. (2022). exdex:
Estimation of the Extremal Index. R package version 1.1.1.
<a href="https://CRAN.R-project.org/package=exdex/">https://CRAN.R-project.org/package=exdex/</a>.
</p>
<p>Northrop, P. J. (2020). revdbayes: Ratio-of-Uniforms Sampling
for Bayesian Extreme Value Analysis. R package version 1.3.9.
<a href="https://paulnorthrop.github.io/revdbayes/">https://paulnorthrop.github.io/revdbayes/</a>
</p>
<p>Suveges, M. and Davison, A. C. (2010) Model
misspecification in peaks over threshold analysis, <em>Annals of
Applied Statistics</em>, <strong>4</strong>(1), 203-221.
<a href="https://doi.org/10.1214/09-AOAS292">doi:10.1214/09-AOAS292</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fliteMethods">fliteMethods</a></code>, including plotting (adjusted)
log-likelihoods for
(<code class="reqn">p</code><sub>u</sub>,
<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code>, <code class="reqn">\theta</code>).
</p>
<p><code><a href="#topic+returnLevel">returnLevel</a></code> to make frequentist inferences about
return levels.
</p>
<p><code><a href="#topic+blite">blite</a></code> for Bayesian threshold-based inference
for time series extremes.
</p>
<p><code><a href="#topic+Bernoulli">Bernoulli</a></code> for maximum likelihood inference for the
Bernoulli distribution.
</p>
<p><code><a href="#topic+generalisedPareto">generalisedPareto</a></code> for maximum likelihood inference
for the generalised Pareto distribution.
</p>
<p><code><a href="exdex.html#topic+kgaps">kgaps</a></code> for maximum likelihood inference from
the <code class="reqn">K</code>-gaps model for the extremal index.
</p>
<p><code><a href="exdex.html#topic+choose_uk">choose_uk</a></code> to inform the choice of the
threshold <code class="reqn">u</code> and run parameter <code class="reqn">K</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Cheeseboro wind gusts

# Make inferences
cdata &lt;- exdex::cheeseboro
# Each column of the matrix cdata corresponds to data from a different year
# flite() sets cluster automatically to correspond to column (year)
cfit &lt;- flite(cdata, u = 45, k = 3)
summary(cfit)

# 2 ways to find the maximised log-likelihood value
cfit(coef(cfit))
logLik(cfit)

# Plots of (adjusted) log-likelihoods
plot(cfit)
plot(cfit, which = "gp")

## Confidence intervals
# Based on an adjusted profile log-likelihood
confint(cfit)
# Symmetric intervals based on large sample normality
confint(cfit, profile= FALSE)
</code></pre>

<hr>
<h2 id='fliteMethods'>Methods for objects of class <code>"flite"</code></h2><span id='topic+fliteMethods'></span><span id='topic+plot.flite'></span><span id='topic+coef.flite'></span><span id='topic+vcov.flite'></span><span id='topic+nobs.flite'></span><span id='topic+logLik.flite'></span><span id='topic+summary.flite'></span><span id='topic+print.summary.flite'></span><span id='topic+confint.flite'></span>

<h3>Description</h3>

<p>Methods for objects of class <code>"flite"</code> returned from
<code><a href="#topic+flite">flite</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flite'
plot(
  x,
  which = c("all", "pu", "gp", "xi", "theta"),
  adj_type = c("vertical", "none", "cholesky", "spectral"),
  ...
)

## S3 method for class 'flite'
coef(object, ...)

## S3 method for class 'flite'
vcov(object, adjust = TRUE, ...)

## S3 method for class 'flite'
nobs(object, ...)

## S3 method for class 'flite'
logLik(object, ...)

## S3 method for class 'flite'
summary(object, adjust = TRUE, digits = max(3, getOption("digits") - 3L), ...)

## S3 method for class 'summary.flite'
print(x, ...)

## S3 method for class 'flite'
confint(
  object,
  parm = "all",
  level = 0.95,
  adj_type = c("vertical", "none", "cholesky", "spectral"),
  profile = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fliteMethods_+3A_x">x</code></td>
<td>
<p>An object inheriting from class <code>"flite"</code>, a result of a
call to <code><a href="#topic+flite">flite</a></code>.</p>
</td></tr>
<tr><td><code id="fliteMethods_+3A_which">which</code></td>
<td>
<p>A character scalar indicating which plot(s) to produce.
If <code>which = "all"</code> then all 4 plots described in <strong>Details</strong>
are produced.  Otherwise, only one of these plots is produced, with the
possible names of the arguments being in the order that the plots are
described in <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="fliteMethods_+3A_adj_type">adj_type</code></td>
<td>
<p>A character scalar passed to
<code><a href="chandwich.html#topic+conf_intervals">conf_intervals</a></code> and
<code><a href="chandwich.html#topic+conf_region">conf_region</a></code> as the argument <code>type</code> to select
the type of adjustment applied to the independence log-likelihood.  Of the
3 adjustments, <code>"vertical"</code> is preferred because it preserves
constraints on the parameters, whereas the <code>"cholesky"</code> and
<code>"spectral"</code> adjustment do not.  In the generalised Pareto case the
constraint that
<code class="reqn">\xi</code> &gt; -<code class="reqn">\sigma</code><sub>u</sub> /
<code class="reqn">x</code><sub>(n)</sub>
where <code class="reqn">x</code><sub>(n)</sub>
is the largest excesses of the threshold <code class="reqn">u</code>, is preserved.</p>
</td></tr>
<tr><td><code id="fliteMethods_+3A_...">...</code></td>
<td>
<p>For <code>plot.flite</code>: arguments passed to
<code><a href="graphics.html#topic+plot.default">plot</a></code>, such as graphical parameters.
</p>
<p>For <code>print.summary.flite</code>: additional arguments passed to
<code><a href="base.html#topic+print.default">print.default</a></code>.
</p>
<p>Otherwise <code>...</code> is unused.</p>
</td></tr>
<tr><td><code id="fliteMethods_+3A_object">object</code></td>
<td>
<p>An object of class <code>"flite"</code>, returned by
<code><a href="#topic+flite">flite</a></code>.</p>
</td></tr>
<tr><td><code id="fliteMethods_+3A_adjust">adjust</code></td>
<td>
<p>A logical scalar.  If <code>adjust = TRUE</code> then the elements
of the variance-covariance matrix corresponding to
(<code class="reqn">p</code><sub>u</sub>,
<code class="reqn">\sigma</code><sub>u</sub>, <code class="reqn">\xi</code>),
are estimated using a sandwich estimator. See <code><a href="#topic+flite">flite</a></code>.
Otherwise, this matrix is the inverse of the observed information matrix.</p>
</td></tr>
<tr><td><code id="fliteMethods_+3A_digits">digits</code></td>
<td>
<p>An integer. Passed to <code><a href="base.html#topic+Round">signif</a></code> to
round the values in the summary.</p>
</td></tr>
<tr><td><code id="fliteMethods_+3A_parm">parm</code></td>
<td>
<p>A character vector specifying the parameters for which
confidence intervals are required. The default, <code>which = "all"</code>,
produces confidence intervals for all the parameters, that is,
<code class="reqn">p</code><sub>u</sub>,
<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code> and <code class="reqn">\theta</code>. If <code>which = "gp"</code> then intervals are
produced only for
<code class="reqn">\sigma</code><sub>u</sub> and
<code class="reqn">\xi</code>. Otherwise, <code>parm</code> must be a subset of
<code>c("pu", "sigmau", "xi", "theta")</code>.</p>
</td></tr>
<tr><td><code id="fliteMethods_+3A_level">level</code></td>
<td>
<p>The confidence level required.  A numeric scalar in (0, 1).</p>
</td></tr>
<tr><td><code id="fliteMethods_+3A_profile">profile</code></td>
<td>
<p>A logical scalar. If <code>TRUE</code> then confidence intervals
based on an (adjusted) profile loglikelihood are returned.  If
<code>FALSE</code> then intervals based on approximate large sample normal
theory, which are symmetric about the MLE, are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>plot.flite</code>, if <code>which = "all"</code> then 4 plots are
produced.
</p>

<ul>
<li><p>Top left: (adjusted) log-likelihood for the threshold exceedence
probability <code class="reqn">p</code><sub>u</sub>,
with a horizontal line indicating a 95% confidence interval for
<code class="reqn">p</code><sub>u</sub>.
</p>
</li>
<li><p>Top right: contour plot of the (adjusted) log-likelihood for the
GP parameters
(<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code>),
showing (25, 50, 75, 90, 95)% confidence regions. The linear
constraint
<code class="reqn">\xi</code> &gt; -<code class="reqn">\sigma</code><sub>u</sub> / <code class="reqn">x</code>
<sub>(n)</sub> is drawn on
the plot.
</p>
</li>
<li><p>Bottom left: (adjusted) log-likelihood for <code class="reqn">\xi</code>, with a
horizontal line indicating a 95% confidence interval for
<code class="reqn">\xi</code>.
</p>
</li>
<li><p>Bottom right: log-likelihood for the extremal index
<code class="reqn">\theta</code>, with a horizontal line indicating a 95% confidence
interval for <code class="reqn">\theta</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>plot.flite</code>: No return value, only the plot is produced.
</p>
<p><code>coef.flite</code>: a numeric vector of length 4 with names
<code>c("p[u]", "sigma[u]", "xi", "theta")</code>.  The MLEs of the parameters
<code class="reqn">p</code><sub>u</sub>,
<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code> and <code class="reqn">\theta</code>.
</p>
<p><code>vcov.flite</code>: a <code class="reqn">4 \times 4</code> matrix with row and
column names <code>c("p[u]", "sigma[u]", "xi", "theta")</code>.  The estimated
variance-covariance matrix for the model parameters.  If
<code>adjust = TRUE</code> then the elements corresponding to
<code class="reqn">p</code><sub>u</sub>,
<code class="reqn">\sigma</code><sub>u</sub>,
and <code class="reqn">\xi</code> are adjusted for cluster dependence using
a sandwich estimator; otherwise they are not adjusted.
</p>
<p><code>nobs.flite</code>: a numeric vector of length 3 with names
<code>c("p[u]", "gp", "theta")</code>.  The respective number of observations
used to estimate <code class="reqn">p</code><sub>u</sub>,
(<code class="reqn">\sigma</code><sub>u</sub>,
<code class="reqn">\xi</code>) and <code class="reqn">\theta</code>.
</p>
<p><code>logLik.flite</code>: an object of class <code>"logLik"</code>: a numeric scalar
with value equal to the maximised log-likelihood.  This is the sum of
contributions from three fitted models, from a Bernoulli model for
occurrences of threshold exceedances, a generalised Pareto model for
threshold excesses and a <code class="reqn">K</code>-gaps model for the extremal index.
The returned object also has attributes <code>nobs</code>, the numbers of
observations used in each of these model fits, and <code>"df"</code> (degrees
of freedom), which is equal to the number of total number of parameters
estimated (4).
</p>
<p><code>summary.flite</code>: an object containing the original function call and
a matrix of estimates and estimated standard errors with row names
<code>c("p[u]", "sigma[u]", "xi", "theta")</code>.  The object is printed by
<code><a href="#topic+print.summary.flite">print.summary.flite</a></code>.
</p>
<p><code>print.summary.flite</code>: the argument <code>x</code> is returned, invisibly.
</p>
<p><code>confint.flite</code>: a numeric matrix with 2 columns giving the lower and
upper confidence limits for each parameter. These columns are labelled
as <code>(1-level)/2</code> and <code>1-(1-level)/2</code>, expressed as a
percentage, by default <code>2.5%</code> and <code>97.5%</code>.  The row names
are the names of the parameters supplied in <code>parm</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flite">flite</a></code> to perform frequentist threshold-based
inference for time series extremes.
</p>

<hr>
<h2 id='generalisedPareto'>Frequentist inference for the generalised Pareto distribution</h2><span id='topic+generalisedPareto'></span><span id='topic+fitGP'></span><span id='topic+coef.GP'></span><span id='topic+vcov.GP'></span><span id='topic+nobs.GP'></span><span id='topic+logLik.GP'></span><span id='topic+gpObsInfo'></span>

<h3>Description</h3>

<p>Functions involved in making inferences about the scale and shape
parameters of a generalised Pareto distribution using maximum likelihood
estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGP(data, u)

## S3 method for class 'GP'
coef(object, ...)

## S3 method for class 'GP'
vcov(object, ...)

## S3 method for class 'GP'
nobs(object, ...)

## S3 method for class 'GP'
logLik(object, ...)

gpObsInfo(pars, excesses, eps = 1e-05, m = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generalisedPareto_+3A_data">data</code></td>
<td>
<p>A numeric vector of raw data.  Missing values are removed using
<code><a href="stats.html#topic+na.fail">na.omit</a></code>.</p>
</td></tr>
<tr><td><code id="generalisedPareto_+3A_u">u</code></td>
<td>
<p>A numeric scalar.  The extremal value threshold.</p>
</td></tr>
<tr><td><code id="generalisedPareto_+3A_object">object</code></td>
<td>
<p>A fitted model object returned from <code>fitGP()</code>.</p>
</td></tr>
<tr><td><code id="generalisedPareto_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the functions in the
sandwich package <code><a href="sandwich.html#topic+meat">meat</a></code> (if <code>cluster = NULL</code>),
or <code><a href="sandwich.html#topic+vcovCL">meatCL</a></code> (if <code>cluster</code> is not
<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="generalisedPareto_+3A_pars">pars</code></td>
<td>
<p>A numeric parameter vector of length 2 containing the values of
the generalised Pareto scale and shape parameters.</p>
</td></tr>
<tr><td><code id="generalisedPareto_+3A_excesses">excesses</code></td>
<td>
<p>A numeric vector of threshold excesses, that is, amounts
by which exceedances of <code>u</code> exceed <code>u</code>.</p>
</td></tr>
<tr><td><code id="generalisedPareto_+3A_eps">eps</code>, <code id="generalisedPareto_+3A_m">m</code></td>
<td>
<p>These control the estimation of the observed
information in <code>gpObsInfo</code> when the GP shape parameter <code class="reqn">\xi</code> is
very close to zero.  In these cases, direct calculation is unreliable.
<code>eps</code> is a (small, positive) numeric scalar.  If the absolute value
of the input value of <code class="reqn">\xi</code>, that is, <code>pars[2]</code>, is smaller than
<code>eps</code> then we approximate the <code>[2, 2]</code> element using a Taylor
series expansion in <code class="reqn">\xi</code>, evaluated up to and including the
<code>m</code>th term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitGP</code>: fit a generalised Pareto distribution using maximum likelihood
estimation, using an <strong>independence</strong> log-likelihood formed by
summing contributions from individual observations. No adjustment for
cluster dependence has been made in estimating the variance-covariance
matrix stored as component in <code>vcov</code> in the returned object. This
function calls <code><a href="revdbayes.html#topic+grimshaw_gp_mle">grimshaw_gp_mle</a></code>.
</p>
<p><code>coef</code>, <code>vcov</code>, <code>nobs</code> and <code>logLik</code> methods are
provided for objects of class <code>"GP"</code> returned from <code>fitGP</code>.
</p>
<p><code>gpObsInfo</code>: calculates the observed information matrix for a random
sample <code>excesses</code> from the generalized Pareto distribution, that is,
the negated Hessian matrix of the generalized Pareto independence
log-likelihood, evaluated at <code>pars</code>.
</p>


<h3>Value</h3>

<p><code>fitGP</code> returns an object of class <code>"GP"</code>, a list
with components: <code>maxLogLik</code>, <code>threshold</code>, <code>mle</code>,
<code>vcov</code>, <code>exceedances</code>, <code>nexc</code>,
where <code>exceedances</code> is a vector containing the values that exceed the
threshold <code>threshold</code> and <code>nexc</code> is the length of this vector.
</p>
<p><code>coef.GP</code>: a numeric vector of length 2 with names
<code>c("sigma[u]", "xi")</code>.  The MLEs of the GP parameters
<code class="reqn">\sigma_u</code> and <code class="reqn">\xi</code>.
</p>
<p><code>vcov.GP</code>: a <code class="reqn">2 \times 2</code> matrix with row and
column names <code>c("sigma[u]", "xi")</code>.  The estimated
variance-covariance matrix for the model parameters. No adjustment for
cluster dependence has been made.
</p>
<p><code>nobs.GP</code>: a numeric vector of length 1.  The number of
observations used to estimate (<code class="reqn">\sigma_u</code>, <code class="reqn">\xi</code>).
</p>
<p><code>logLik.GP</code>: an object of class <code>"logLik"</code>: a numeric scalar
with value equal to the maximised log-likelihood. The returned object
also has attributes <code>nobs</code>, the numbers of observations used in
each of these model fits, and <code>"df"</code> (degrees of freedom), which is
equal to the number of total number of parameters estimated (2).
</p>
<p><code>gpObsInfo</code> returns a 2 by 2 matrix with row and columns names
<code>c("sigma[u]", "xi")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up data and set a threshold
cdata &lt;- c(exdex::cheeseboro)

# Fit a generalised Pareto distribution
fit &lt;- fitGP(cdata, 45)

# Calculate the log-likelihood at the MLE
res &lt;- logLikVector(fit)

# The logLik method sums the individual log-likelihood contributions.
logLik(res)

# nobs, coef, vcov, logLik methods for objects returned from fitGP()
nobs(fit)
coef(fit)
vcov(fit)
logLik(fit)
</code></pre>

<hr>
<h2 id='lite-internal'>Internal lite functions</h2><span id='topic+lite-internal'></span><span id='topic+adjust_object'></span><span id='topic+kgaps_loglik'></span><span id='topic+check_logLik_flite'></span><span id='topic+return_level_bingp'></span><span id='topic+bingp_rl_CI'></span><span id='topic+bingp_rl_prof'></span><span id='topic+box_cox_deriv'></span><span id='topic+make_ru_list'></span>

<h3>Description</h3>

<p>Internal lite functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_object(x, cluster = NULL, ...)

kgaps_loglik(theta, N0, N1, sum_qs, n_kgaps)

check_logLik_flite(object, ...)

return_level_bingp(x, m, level, ny, prof, inc, type, ny_given)

bingp_rl_CI(x, m, level, ny, type, u)

bingp_rl_prof(x, m, level, ny, inc, type, rl_sym, u)

box_cox_deriv(x, lambda = 1, lambda_tol = 1/50, poly_order = 3)

make_ru_list(model, trans, rotate, min_xi, max_xi)
</code></pre>


<h3>Details</h3>

<p>These functions are not intended to be called by the user.
</p>

<hr>
<h2 id='lite-package'>lite: Likelihood-Based Inference for Time Series Extremes</h2><span id='topic+lite-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Performs likelihood-Based inference for stationary time series extremes.
The general approach follows Fawcett and Walshaw (2012). Marginal extreme
value inferences are adjusted for cluster dependence in the data using the
methodology in Chandler and Bate (2007), producing an adjusted
log-likelihood for the model parameters.  A log-likelihood for the extremal
index is produced using the K-gaps model of Suveges and Davison (2010).
These log-likelihoods are combined to make inferences about return levels.
</p>


<h3>Details</h3>

<p>The main functions are <code><a href="#topic+flite">flite</a></code> and <code><a href="#topic+blite">blite</a></code>,
which perform frequentist and Bayesian inference for time series extremes,
respectively.
</p>
<p>See the vignettes
<code>vignette("lite-1-frequentist", package = "lite")</code> and <br />
<code>vignette("lite-2-bayesian", package = "lite")</code>
for an overview of the package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Paul J. Northrop <a href="mailto:p.northrop@ucl.ac.uk">p.northrop@ucl.ac.uk</a> [copyright holder]
</p>


<h3>References</h3>

<p>Chandler, R. E. and Bate, S. (2007). Inference for clustered.
data using the independence loglikelihood. <em>Biometrika</em>,
<strong>94</strong>(1), 167-183. <a href="https://doi.org/10.1093/biomet/asm015">doi:10.1093/biomet/asm015</a>
</p>
<p>Fawcett, L. and Walshaw, D. (2012), Estimating return levels
from serially dependent extremes. <em>Environmetrics</em>, <strong>23</strong>,
272-283. <a href="https://doi.org/10.1002/env.2133">doi:10.1002/env.2133</a>
</p>
<p>Suveges, M. and Davison, A. C. (2010) Model
misspecification in peaks over threshold analysis, <em>Annals of
Applied Statistics</em>, <strong>4</strong>(1), 203-221.
<a href="https://doi.org/10.1214/09-AOAS292">doi:10.1214/09-AOAS292</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flite">flite</a></code> for frequentist threshold-based inference for
time series extremes.
</p>
<p><code><a href="#topic+returnLevel">returnLevel</a></code> for frequentist threshold-based inference
for return levels.
</p>
<p><code><a href="#topic+blite">blite</a></code> for Bayesian threshold-based inference for
time series extremes.
</p>
<p><code><a href="#topic+predict.blite">predict.blite</a></code> for predictive inference for the
largest value observed in <code class="reqn">N</code> years.
</p>

<hr>
<h2 id='logLikVector'>Functions for log-likelihood contributions</h2><span id='topic+logLikVector'></span><span id='topic+logLikVector.Bernoulli'></span><span id='topic+logLikVector.GP'></span><span id='topic+logLik.logLikVector'></span>

<h3>Description</h3>

<p>Generic function for calculating log-likelihood contributions from
individual observations for a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLikVector(object, ...)

## S3 method for class 'Bernoulli'
logLikVector(object, pars = NULL, ...)

## S3 method for class 'GP'
logLikVector(object, pars = NULL, ...)

## S3 method for class 'logLikVector'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLikVector_+3A_object">object</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="logLikVector_+3A_...">...</code></td>
<td>
<p>Further arguments. None are used for either
<code>logLikVector.Bernoulli</code> or <br />
<code>logLikVector.GP</code>.</p>
</td></tr>
<tr><td><code id="logLikVector_+3A_pars">pars</code></td>
<td>
<p>A numeric parameter vector.
</p>
<p>For <code>logLikVector.Bernoulli</code> this is a vector of length 1 containing
a value of the Bernoulli success probability.
</p>
<p>For <code>logLikVector.GP</code> this is a numeric vector of length 2 containing
the values of the generalised Pareto scale (<code class="reqn">\sigma_u</code>) and shape
(<code class="reqn">\xi</code>) parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>logLikVector</code> method is used to construct a log-likelihood
function to supply as the argument <code>loglik</code> to the function
<code><a href="chandwich.html#topic+adjust_loglik">adjust_loglik</a></code>, which performs log-likelihood
adjustment for parts 1 and 2 of the inferences performed by
<code><a href="#topic+flite">flite</a></code>.
</p>
<p>The <code>logLik</code> method <code>logLik.LogLikVector</code> sums the
log-likelihood contributions from individual observations.
</p>


<h3>Value</h3>

<p>For <code>logLikVector</code>: an object of class <code>logLikVec</code>.
This is a numeric vector of length <code class="reqn">n</code> containing contributions to the
the independence log-likelihood from <code class="reqn">n</code> observations, with attributes
<code>"df"</code> (degrees of freedom), giving the number of estimated
parameters in the model, and <code>"nobs"</code>, giving the number observations
used to perform the estimation.
</p>
<p>For <code>logLik.logLikVector</code>: an object of class <code>logLik</code>.  This is
a number with the attributes <code>"df"</code> and <code>"nobs"</code> as described
above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bernoulli">Bernoulli</a></code> for maximum likelihood inference for the
Bernoulli distribution.
</p>
<p><code><a href="#topic+generalisedPareto">generalisedPareto</a></code> for maximum likelihood inference
for the generalised Pareto distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># logLikVector.Bernoulli
bfit &lt;- fitBernoulli(c(exdex::cheeseboro) &gt; 45)
bvec &lt;- logLikVector(bfit)
head(bvec)
logLik(bvec)
logLik(bfit)

# estfun.generalisedPareto
gpfit &lt;- fitGP(c(exdex::cheeseboro), u = 45)
gpvec &lt;- logLikVector(gpfit)
head(gpvec)
logLik(gpvec)
logLik(gpfit)
</code></pre>

<hr>
<h2 id='predict.blite'>Predictive inference for the largest value observed in <code class="reqn">N</code> years.</h2><span id='topic+predict.blite'></span>

<h3>Description</h3>

<p><code>predict</code> method for class &quot;blite&quot;.  Performs predictive inference
about the largest value to be observed over a future time period of
<code class="reqn">N</code> years.  Predictive inferences accounts for uncertainty in model
parameters and for uncertainty owing to the variability of future
observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blite'
predict(
  object,
  type = c("i", "p", "d", "q", "r"),
  x = NULL,
  x_num = 100,
  n_years = 100,
  ny = NULL,
  level = 95,
  hpd = FALSE,
  lower_tail = TRUE,
  log = FALSE,
  big_q = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.blite_+3A_object">object</code></td>
<td>
<p>An object of class <code>"blite"</code> returned from
<code><a href="#topic+blite">blite</a></code>.</p>
</td></tr>
<tr><td><code id="predict.blite_+3A_type">type</code></td>
<td>
<p>A character vector.  Indicates which type of inference is
required:
</p>

<ul>
<li><p> &quot;i&quot; for predictive intervals,
</p>
</li>
<li><p> &quot;p&quot; for the predictive distribution function,
</p>
</li>
<li><p> &quot;d&quot; for the predictive density function,
</p>
</li>
<li><p> &quot;q&quot; for the predictive quantile function,
</p>
</li>
<li><p> &quot;r&quot; for random generation from the predictive distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.blite_+3A_x">x</code></td>
<td>
<p>A numeric vector or a matrix with <code>n_years</code> columns.
The meaning of <code>x</code> depends on <code>type</code>.
</p>

<ul>
<li><p><code>type = "p"</code> or <code>type = "d"</code>: <code>x</code> contains
quantiles at which to evaluate the distribution or density function.
No element of <code>x</code> can be less than the threshold
<code>attr(object, "inputs")$u</code>.
</p>
<p>If <code>x</code> is not supplied then <code>n_year</code>-specific defaults are
set: vectors of length <code>x_num</code> from the 0.1% quantile to the
99% quantile, subject all values being greater than the threshold.
</p>
</li>
<li><p><code>type = "q"</code>: <code>x</code> contains probabilities in (0,1)
at which to evaluate the quantile function.  Any values outside
(0, 1) will be removed without warning. No element of <code>p</code> can
correspond to a predictive quantile that is below the threshold,
<code>attr(object, "inputs")$u</code>.  That is, no element of <code>p</code> can
be less than the value of <code>predict.evpost(object,</code>
<code>type = "q", x = attr(object, "inputs")$u)</code>.
</p>
<p>If <code>x</code> is not supplied then a default value of
<code>c(0.025, 0.25, 0.5, 0.75, 0.975)</code> is used.
</p>
</li>
<li><p><code>type = "i"</code> or <code>type = "r"</code>: <code>x</code> is not relevant.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.blite_+3A_x_num">x_num</code></td>
<td>
<p>A numeric scalar.  If <code>type = "p"</code> or <code>type = "d"</code>
and <code>x</code> is not supplied then <code>x_num</code> gives the number of values
in <code>x</code> for each value in <code>n_years</code>.</p>
</td></tr>
<tr><td><code id="predict.blite_+3A_n_years">n_years</code></td>
<td>
<p>A numeric vector. Values of <code class="reqn">N</code>.</p>
</td></tr>
<tr><td><code id="predict.blite_+3A_ny">ny</code></td>
<td>
<p>A numeric scalar.  The (mean) number of observations per year.
<strong>Setting this appropriately is important</strong>. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="predict.blite_+3A_level">level</code></td>
<td>
<p>A numeric vector of values in (0, 100).
Only relevant when <code>type = "i"</code>.
Levels of predictive intervals for the largest value observed in
<code class="reqn">N</code> years, i.e. level% predictive intervals are returned.</p>
</td></tr>
<tr><td><code id="predict.blite_+3A_hpd">hpd</code></td>
<td>
<p>A logical scalar.
Only relevant when <code>type = "i"</code>.
</p>
<p>If <code>hpd = FALSE</code> then the interval is
equi-tailed, with its limits produced by <br />
<code>predict.evpost(</code><code>object, type ="q", x = p)</code>,
where <code>p = c((1-level/100)/2,</code> <code>(1+level/100)/2)</code>.
</p>
<p>If <code>hpd = TRUE</code> then, in addition to the equi-tailed interval,
the shortest possible level% interval is calculated.
If the predictive distribution is unimodal then this
is a highest predictive density (HPD) interval.</p>
</td></tr>
<tr><td><code id="predict.blite_+3A_lower_tail">lower_tail</code></td>
<td>
<p>A logical scalar.
Only relevant when <code>type = "p"</code> or <code>type = "q"</code>.
If TRUE (default), (output or input) probabilities are
<code class="reqn">P[X \leq x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="predict.blite_+3A_log">log</code></td>
<td>
<p>A logical scalar.  Only relevant when <code>type = "d"</code>.
If TRUE the log-density is returned.</p>
</td></tr>
<tr><td><code id="predict.blite_+3A_big_q">big_q</code></td>
<td>
<p>A numeric scalar.  Only relevant when <code>type = "q"</code>.
An initial upper bound for the desired quantiles to be passed to
<code><a href="stats.html#topic+uniroot">uniroot</a></code> (its argument <code>upper</code>) in the
search for the predictive quantiles.  If this is not sufficiently large
then it is increased until it does provide an upper bound.</p>
</td></tr>
<tr><td><code id="predict.blite_+3A_...">...</code></td>
<td>
<p>Additional optional arguments. At present no optional
arguments are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="revdbayes.html#topic+predict.evpost">predict.evpost</a></code> in the
<code><a href="revdbayes.html#topic+revdbayes">revdbayes</a></code> package is used to perform the
predictive inferences.  The effect of adjusting for the values of the
extremal index <code class="reqn">\theta</code> in the posterior sample in
<code>object$sim_vals[, "theta"]</code> is to change the effective time horizon
from <code class="reqn">N</code> to <code class="reqn">\theta N</code>.
</p>
<p><code>ny</code> provides information about the (intended) frequency of
sampling in time, that is, the number of observations that would be
observed in a year if there are no missing values.  If the number of
observations may vary between years then <code>ny</code> should be set equal to
the mean number of observations per year.
</p>
<p><strong>Supplying <code>ny</code>.</strong>
The value of <code>ny</code> may have been set in the call to
<code><a href="#topic+blite">blite</a></code>.  If <code>ny</code> is supplied by the user in the call to
<code>predict.blite</code> then this will be used in preference to the value
stored in the fitted model object.  If these two values differ then no
warning will be given.
</p>


<h3>Value</h3>

<p>An object of class &quot;evpred&quot;, a list containing a subset of the
following components:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The argument <code>type</code> supplied to <code>predict.blite</code>.
Which of the following components are present depends <code>type</code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A matrix containing the argument <code>x</code> supplied to
<code>predict.blite</code>, or set within <code>predict.blite</code> if <code>x</code>
was not supplied, replicated to have <code>n_years</code> columns
if necessary.
Only present if <code>type</code> is <code>"p", "d"</code> or <code>"q"</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The content of <code>y</code> depends on <code>type</code>:
</p>

<ul>
<li><p><code>type = "p", "d", "q"</code>:  A matrix with the same
dimensions as <code>x</code>.  Contains distribution function values
(<code>type = "p"</code>), predictive density (<code>type = "d"</code>)
or quantiles (<code>type = "q"</code>).
</p>
</li>
<li><p><code>type = "r"</code>: A numeric matrix with <code>length(n_years)</code>
columns and number of rows equal to the size of the posterior sample.
</p>
</li>
<li><p><code>type = "i"</code>: <code>y</code> is not present.
</p>
</li></ul>
</td></tr>
<tr><td><code>long</code></td>
<td>
<p>A <code>length(n_years)*length(level)</code> by 4 numeric
matrix containing the equi-tailed limits with columns:
lower limit, upper limit, n_years, level.
Only present if <code>type = "i"</code>.  If an interval extends below
the threshold then <code>NA</code> is returned.</p>
</td></tr>
<tr><td><code>short</code></td>
<td>
<p>A matrix with the same structure as <code>long</code>
containing the HPD limits.  Only present if <code>type = "i"</code>.
Columns 1 and 2 contain <code>NA</code>s if <code>hpd = FALSE</code>
or if the corresponding equi-tailed interval extends below
the threshold.</p>
</td></tr>
</table>
<p>The arguments <code>n_years, level, hpd, lower_tail, log</code> supplied
to <code>predict.blite</code> are also included, as is the value of <code>ny</code>
and <code>model = "bingp"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Cheeseboro wind gusts

cdata &lt;- exdex::cheeseboro
# Each column of the matrix cdata corresponds to data from a different year
# blite() sets cluster automatically to correspond to column (year)
cpost &lt;- blite(cdata, u = 45, k = 3, ny = 31 * 24)

# Interval estimation
predict(cpost)$long
predict(cpost, hpd = TRUE)$short

# Density function
plot(predict(cpost, type = "d", n_years = c(100, 1000)))

# Distribution function
plot(predict(cpost, type = "p", n_years = c(100, 1000)))

# Quantiles
predict(cpost, type = "q", n_years = c(100, 1000))$y

# Random generation
plot(predict(cpost, type = "r"))
</code></pre>

<hr>
<h2 id='returnLevel'>Frequentist threshold-based inference for return levels</h2><span id='topic+returnLevel'></span>

<h3>Description</h3>

<p>Calculates point estimates and confidence intervals for <code>m</code>-year
return levels for stationary time series fitted extreme value model objects
returned from <code><a href="#topic+flite">flite</a></code>.  Two types of interval may be returned:
(a) intervals based on approximate large-sample normality of the maximum
likelihood estimator for return level, which are symmetric about the point
estimate, and (b) profile likelihood-based intervals based on an (adjusted)
log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returnLevel(
  x,
  m = 100,
  level = 0.95,
  ny,
  prof = TRUE,
  inc = NULL,
  type = c("vertical", "cholesky", "spectral", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="returnLevel_+3A_x">x</code></td>
<td>
<p>An object inheriting from class <code>"flite"</code> returned from
<code><a href="#topic+flite">flite</a></code>.</p>
</td></tr>
<tr><td><code id="returnLevel_+3A_m">m</code></td>
<td>
<p>A numeric scalar.  The return period, in years.</p>
</td></tr>
<tr><td><code id="returnLevel_+3A_level">level</code></td>
<td>
<p>A numeric scalar in (0, 1).  The confidence level required for
confidence interval for the <code>m</code>-year return level.</p>
</td></tr>
<tr><td><code id="returnLevel_+3A_ny">ny</code></td>
<td>
<p>A numeric scalar.  The (mean) number of observations per year.
<strong>Setting this appropriately is important</strong>. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="returnLevel_+3A_prof">prof</code></td>
<td>
<p>A logical scalar.  Should we calculate intervals based on
profile log-likelihood?</p>
</td></tr>
<tr><td><code id="returnLevel_+3A_inc">inc</code></td>
<td>
<p>A numeric scalar. Only relevant if <code>prof = TRUE</code>. The
increment in return level by which we move upwards and downwards from the
MLE for the return level in the search for the lower and upper confidence
limits.  If this is not supplied then <code>inc</code> is set to one hundredth
of the length of the symmetric confidence interval for return level.</p>
</td></tr>
<tr><td><code id="returnLevel_+3A_type">type</code></td>
<td>
<p>A character scalar.  The argument <code>type</code> to the function
returned by the function <code><a href="chandwich.html#topic+adjust_loglik">adjust_loglik</a></code>, that is,
the type of adjustment made to the independence log-likelihood function in
creating an adjusted log-likelihood function.  See <strong>Details</strong> and
<strong>Value</strong> in <code><a href="chandwich.html#topic+adjust_loglik">adjust_loglik</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For information about return levels see the &quot;Introducing lite&quot;
vignette.
</p>
<p><code>ny</code> provides information about the (intended) frequency of
sampling in time, that is, the number of observations that would be
observed in a year if there are no missing values.  If the number of
observations may vary between years then <code>ny</code> should be set equal to
the mean number of observations per year.
</p>
<p><strong>Supplying <code>ny</code>.</strong>
The value of <code>ny</code> may have been set in the call to
<code><a href="#topic+flite">flite</a></code>.  If <code>ny</code> is supplied by the user in the call to
<code>returnLevel</code> then this will be used in preference to the value
stored in the fitted model object.  If these two values differ then no
warning will be given.
</p>
<p>For details of the definition and estimation of return levels see the
Inference for return levels vignette.
</p>
<p>The profile likelihood-based intervals are calculated by
reparameterising in terms of the <code>m</code>-year return level and estimating
the values at which the (adjusted) profile log-likelihood reaches
the critical value <code>logLik(x) - 0.5 * stats::qchisq(level, 1)</code>.
This is achieved by calculating the profile log-likelihood for a sequence
of values of this return level as governed by <code>inc</code>. Once the profile
log-likelihood drops below the critical value the lower and upper limits are
estimated by interpolating linearly between the cases lying either side of
the critical value. The smaller <code>inc</code> the more accurate (but slower)
the calculation will be.
</p>


<h3>Value</h3>

<p>A object (a list) of class <code>"returnLevel", "lite"</code> with the
components
</p>
<table>
<tr><td><code>rl_sym</code>, <code>rl_prof</code></td>
<td>
<p>Named numeric vectors containing the respective
lower 100<code>level</code>% limit, the MLE and the upper
100<code>level</code>% limit for the return level.
If <code>prof = FALSE</code> then <code>rl_prof</code> will be missing.</p>
</td></tr>
<tr><td><code>rl_se</code></td>
<td>
<p>Estimated standard error of the return level.</p>
</td></tr>
<tr><td><code>max_loglik</code>, <code>crit</code>, <code>for_plot</code></td>
<td>
<p>If <code>prof = TRUE</code> then
these components will be present, containing respectively: the maximised
log-likelihood; the critical value and a matrix with return levels in
the first column (<code>ret_levs</code>) and the corresponding values of the
(adjusted) profile log-likelihood (<code>prof_loglik</code>).</p>
</td></tr>
<tr><td><code>m</code>, <code>level</code></td>
<td>
<p>The input values of <code>m</code> and <code>level</code>.</p>
</td></tr>
<tr><td><code>ny</code></td>
<td>
<p>The value of <code>ny</code> used to infer the return level.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call to <code>returnLevel</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Coles, S. G. (2001) <em>An Introduction to Statistical
Modeling of Extreme Values</em>, Springer-Verlag, London.
<a href="https://doi.org/10.1007/978-1-4471-3675-0_3">doi:10.1007/978-1-4471-3675-0_3</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+returnLevelMethods">returnLevelMethods</a></code>, including plotting the (adjusted)
profile log-likelihood for a return level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Cheeseboro wind gusts

# Make inferences
cdata &lt;- exdex::cheeseboro
# Each column of the matrix cdata corresponds to data from a different year
# flite() sets cluster automatically to correspond to column (year)
cfit &lt;- flite(cdata, u = 45, k = 3)

# These data are hourly for one month (January) year so ny = 31 * 24
# Large inc set here for speed, sacrificing accuracy
# Default 95% confidence intervals
rl &lt;- returnLevel(cfit, inc = 2.5, ny = 31 * 24)
summary(rl)
rl
oldrl &lt;- plot(rl)
oldrl

# Quickly recalculate/replot the intervals based on profile log-likelihood
# provided that level is smaller than that used to produce rl
newrl &lt;- plot(rl, level = 0.9)
newrl
</code></pre>

<hr>
<h2 id='returnLevelMethods'>Methods for objects of class <code>"returnLevel"</code></h2><span id='topic+returnLevelMethods'></span><span id='topic+plot.returnLevel'></span><span id='topic+print.returnLevel'></span><span id='topic+summary.returnLevel'></span><span id='topic+print.summary.returnLevel'></span>

<h3>Description</h3>

<p>Methods for objects of class <code>"returnLevel"</code> returned from
<code><a href="#topic+returnLevel">returnLevel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'returnLevel'
plot(x, level = NULL, legend = TRUE, digits = 3, plot = TRUE, ...)

## S3 method for class 'returnLevel'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'returnLevel'
summary(object, digits, ...)

## S3 method for class 'summary.returnLevel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="returnLevelMethods_+3A_x">x</code></td>
<td>
<p>an object of class <code>c("returnLevel", "lite")</code>, a result
of a call to <code><a href="#topic+returnLevel">returnLevel</a></code>, using <code>prof = TRUE</code>.</p>
</td></tr>
<tr><td><code id="returnLevelMethods_+3A_level">level</code></td>
<td>
<p>A numeric scalar in (0, 1).  The confidence level required for
the confidence interval for the <code>m</code>-year return level.
If <code>level</code> is not supplied then <code>x$level</code> is used.
<code>level</code> must be no larger than <code>x$level</code>.</p>
</td></tr>
<tr><td><code id="returnLevelMethods_+3A_legend">legend</code></td>
<td>
<p>A logical scalar.  Should we add a legend (in the top right
of the plot) that gives the approximate values of the MLE and
100<code>level</code>% confidence limits?</p>
</td></tr>
<tr><td><code id="returnLevelMethods_+3A_digits">digits</code></td>
<td>
<p>For <code>plot.returnLevel</code>: an integer. Passed to
<code><a href="base.html#topic+Round">signif</a></code> to round the values in the legend.
</p>
<p>For <code>print.returnLevel</code>: the argument <code>digits</code> to
<code><a href="base.html#topic+print.default">print.default</a></code>.
</p>
<p>For <code>summary.returnLevel</code>: an integer. For number formatting
with <code><a href="base.html#topic+Round">signif</a></code>.  If <code>digits</code> is not specified
(i.e. <code><a href="base.html#topic+missing">missing</a></code>) then <code>signif()</code> will not be called
(i.e. no rounding will be performed).</p>
</td></tr>
<tr><td><code id="returnLevelMethods_+3A_plot">plot</code></td>
<td>
<p>A logical scalar.  If <code>TRUE</code> then the plot is produced.
Otherwise, it is not, but the MLE and confidence limits are returned.</p>
</td></tr>
<tr><td><code id="returnLevelMethods_+3A_...">...</code></td>
<td>
<p>For <code>plot.returnLevel</code>: arguments passed to
<code><a href="graphics.html#topic+plot.default">plot</a></code>, such as graphical parameters.
</p>
<p>For <code>print.summary.returnLevel</code>: arguments passed to
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="returnLevelMethods_+3A_object">object</code></td>
<td>
<p>an object of class <code>c("returnLevel", "lite")</code>, a result
of a call to <code><a href="#topic+returnLevel">returnLevel</a></code>, using <code>prof = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.returnLevel</code> plots the profile log-likelihood for a
return level, provided that <code>x</code> returned by a call to
<code><a href="#topic+returnLevel">returnLevel</a></code> using <code>prof = TRUE</code>.  Horizontal lines
indicate the values of the maximised log-likelihood and the critical level
used to calculate the confidence limits.
If <code>level</code> is smaller than <code>x$level</code> then approximate
100<code>level</code>% confidence limits are recalculated based on the
information contained in <code>x$for_plot</code>.
</p>
<p><code>print.returnLevel</code> prints the call to
<code><a href="#topic+returnLevel">returnLevel</a></code> and the estimates and 100<code>x$level</code>%
confidence limits for the <code>x$m</code>-year return level.
</p>


<h3>Value</h3>

<p><code>plot.returnLevel</code>: a numeric vector of length 3 containing the
lower 100<code>level</code>% confidence limit, the MLE and the upper
100<code>level</code>% confidence limit is returned invisibly.
</p>
<p><code>print.returnLevel</code>: the argument <code>x</code> is returned, invisibly.
</p>
<p><code>summary.returnLevel</code>: a list containing the list element
<code>object$call</code> and a matrix <code>matrix</code> containing the MLE
and estimated SE of the return level.
</p>
<p><code>print.summary.returnLevel</code>: the argument <code>x</code> is returned,
invisibly.
</p>


<h3>Examples</h3>

<p>See <code><a href="#topic+returnLevel">returnLevel</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+returnLevel">returnLevel</a></code> to perform frequentist threshold-based
inference for return levels.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
