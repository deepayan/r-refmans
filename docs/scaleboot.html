<!DOCTYPE html><html><head><title>Help for package scaleboot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scaleboot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef'><p>Extract Model Coefficients</p></a></li>
<li><a href='#interface'><p>Interface to External Packages</p></a></li>
<li><a href='#lung73'><p>Clustering of 73 Lung Tumors</p></a></li>
<li><a href='#mam15'><p>Mammal Phylogenetic Analysis for 15 trees</p></a></li>
<li><a href='#plot.scaleboot'><p>Plot Diagnostics for Multiscale Bootstrap</p></a></li>
<li><a href='#relltest'><p>RELL Test for Phylogenetic Inference</p></a></li>
<li><a href='#sbaic'><p>Akaike's Information Criterion</p></a></li>
<li><a href='#sbconf'><p>Bootstrap Confidence Intervals</p></a></li>
<li><a href='#sbfit'><p>Fitting Models to Bootstrap Probabilities</p></a></li>
<li><a href='#sboptions'><p>Options for Multiscale Bootstrap</p></a></li>
<li><a href='#sbphylo'><p>Tables for phylogenetic inference</p></a></li>
<li><a href='#sbpsi'><p>Model Specification Functions</p></a></li>
<li><a href='#sbpval'><p>Extract P-values</p></a></li>
<li><a href='#scaleboot'><p>Multiscale Bootstrap Resampling</p></a></li>
<li><a href='#scaleboot-package'>
<p>Approximately Unbiased P-values via Multiscale Bootstrap</p></a></li>
<li><a href='#summary.scaleboot'><p>P-value Calculation for Multiscale Bootstrap</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Approximately Unbiased P-Values via Multiscale Bootstrap</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Hidetoshi Shimodaira &lt;shimo@i.kyoto-u.ac.jp&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hidetoshi Shimodaira &lt;shimo@i.kyoto-u.ac.jp&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>pvclust (&ge; 2.2-0), mvtnorm</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculating approximately unbiased (AU) p-values
	from multiscale bootstrap probabilities. See
	Shimodaira (2004) &lt;<a href="https://doi.org/10.1214%2F009053604000000823">doi:10.1214/009053604000000823</a>&gt;,
	Shimodaira (2008) &lt;<a href="https://doi.org/10.1016%2Fj.jspi.2007.04.001">doi:10.1016/j.jspi.2007.04.001</a>&gt;, 
	Terada ans Shimodaira (2017) &lt;<a href="https://arxiv.org/abs/1711.00949">arXiv:1711.00949</a>&gt;, and
	Shimodaira and Terada (2019) &lt;doi.org/10.3389/fevo.2019.00174&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://stat.sys.i.kyoto-u.ac.jp/prog/scaleboot/">http://stat.sys.i.kyoto-u.ac.jp/prog/scaleboot/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-03 18:05:42 UTC; shimo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-04 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef'>Extract Model Coefficients</h2><span id='topic+coef.scaleboot'></span><span id='topic+coef.scalebootv'></span>

<h3>Description</h3>

<p>Extract the estimated parameters from <code>"scaleboot"</code> or
<code>"scalebootv"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'scaleboot'
coef(object,sd=FALSE,...)

## S3 method for class 'scalebootv'
coef(object,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>  
<tr><td><code id="coef_+3A_sd">sd</code></td>
<td>
<p>logical. Should standard errors be returned as well?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>coef</code> method for the class <code>"scaleboot"</code> returns a
matrix consisting of row vectors of beta's for models. If
<code>sd=TRUE</code>, it returns a list with components <code>estimate</code> and
<code>sd</code> for the beta matrix and its standard error respectively.
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbfit">sbfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mam15)
a &lt;- mam15.relltest[["t4"]] # an object of class "scaleboot"
coef(a) # print the estimated beta values
coef(a,sd=TRUE) # with sd
</code></pre>

<hr>
<h2 id='interface'>Interface to External Packages</h2><span id='topic+interface.scaleboot'></span><span id='topic+read.mt'></span><span id='topic+read.ass'></span><span id='topic+read.cnt'></span><span id='topic+sbfit.pvclust'></span><span id='topic+sbpvclust'></span>

<h3>Description</h3>

<p>Interface for other packages such as
CONSEL (phylogenetic inference), and pvclust (hierarchical clustering)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.mt(file,tlab="t")

read.ass(file,identity=TRUE,tlab="t",elab="e") 

read.cnt(file)


## S3 method for class 'pvclust'
sbfit(x,...)

sbpvclust(x,mbs,k=3,select="average",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface_+3A_file">file</code></td>
<td>
<p>character of a file name to be read.</p>
</td></tr>
<tr><td><code id="interface_+3A_identity">identity</code></td>
<td>
<p>logical. Should the identity association be included?</p>
</td></tr>
<tr><td><code id="interface_+3A_tlab">tlab</code></td>
<td>
<p>character for basename of tree labels.</p>
</td></tr>
<tr><td><code id="interface_+3A_elab">elab</code></td>
<td>
<p>character for basename of edge labels.</p>
</td></tr>
<tr><td><code id="interface_+3A_x">x</code></td>
<td>
<p>an object of class <code>"pvclust"</code>.</p>
</td></tr>
<tr><td><code id="interface_+3A_mbs">mbs</code></td>
<td>
<p>an object of class <code>"scalebootv"</code>.</p>
</td></tr>
<tr><td><code id="interface_+3A_k">k</code></td>
<td>
<p>numeric of <code class="reqn">k</code> for a AU p-value.</p>
</td></tr>
<tr><td><code id="interface_+3A_select">select</code></td>
<td>
<p>character of model name (such as &quot;poly.3&quot;) or one of
&quot;average&quot; and &quot;best&quot;.</p>
</td></tr>
<tr><td><code id="interface_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CONSEL is a program package consisting of small programs written in
the C language for assessing the confidence of phylogenetic tree selection.
Some functions for interfacing with CONSEL are:
<code>read.mt</code>,   <code>read.ass</code>,  and <code>read.cnt</code>
for reading, respectively, <code>mt</code>, <code>ass</code>, and <code>cnt</code>
format. Once <code>mt</code> file is read, we can calculate improved
versions of approximately unbiased p-values by <code>relltest</code>in
<code>scaleboot</code> instead of CONSEL.
</p>
<p>pvclust is a R package for hierarchical clustering with p-values.
Functions for interface to pvclust are: <code>sbfit</code> method for an
object of class <code>"pvclust"</code> to convert it to <code>"scalebootv"</code> class,
and <code>sbpvclust</code> for writing back the result to a
<code>"pvclust"</code> object with additional class <code>"sbclust"</code>.
<code>plot</code> method for class <code>"sbclust"</code> overwrites that for <code>"pvclust"</code>.
</p>


<h3>Value</h3>

<p><code>read.mt</code> returns a matrix of dimension sequence-length by tree-number.
If <code>identity=FALSE</code>, then <code>read.ass</code> returns a list containing components
<code>x</code> for edge-&gt;tree associations and <code>y</code> for tree<code class="reqn">\to</code>edge associations.
If <code>identity=TRUE</code>, <code>read.ass</code> returns a list vector of edge<code class="reqn">\to</code>tree
associations, where the identity associations for tree<code class="reqn">\to</code>tree are included.
<code>read.cnt</code> returns a list containing components <code>bps</code>,
<code>nb</code>, and <code>sa</code> to be used for <code>sbfit</code>. The list also contains
components <code>cnt</code>, <code>id</code>, and <code>val</code>.
</p>
<p><code>sbfit.pvclust</code> returns an object of class
<code>"scalebootv"</code>. <code>sbpvclust</code> returns an object of class
<code>"sbclust"</code> added to the class <code>"pvclust"</code>.
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>References</h3>

<p>Shimodaira, H. and Hasegawa, M. (2001). CONSEL: for
assessing the confidence of phylogenetic tree selection,
<em>Bioinformatics</em>, 17, 1246-1247 (software is available from
<a href="http://stat.sys.i.kyoto-u.ac.jp/prog/consel/">http://stat.sys.i.kyoto-u.ac.jp/prog/consel/</a>).
</p>
<p>Suzuki, R. and Shimodaira, H. (2006).
pvclust: An R package for hierarchical clustering with p-values,
<em>Bioinformatics</em>, 22, 1540-1542 (software is available from CRAN or
<a href="http://stat.sys.i.kyoto-u.ac.jp/prog/pvclust/">http://stat.sys.i.kyoto-u.ac.jp/prog/pvclust/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lung73">lung73</a></code>, <code><a href="#topic+mam15">mam15</a></code>, <code><a href="#topic+relltest">relltest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## replace au/bp entries in pvclust object
## see help(lung73) for details
library(pvclust)
data(lung73)
plot(lung73.pvclust) # draw dendrogram of pvlcust object
pvrect(lung73.pvclust)
lung73.new &lt;- sbpvclust(lung73.pvclust,lung73.sb) # au &lt;- k.3
plot(lung73.new) # redraw dendrogram with the new au/bp values
pvrect(lung73.new)

## Not run: 
## reading CONSEL files
## sample files are found in mam15 subdirectory
## see help(mam15) for details
mam15.mt &lt;- read.mt("mam15.mt")
mam15.ass &lt;- read.ass("mam15.ass")
mam15.cnt &lt;- read.cnt("mam15.cnt")

## End(Not run)

</code></pre>

<hr>
<h2 id='lung73'>Clustering of 73 Lung Tumors</h2><span id='topic+lung73'></span><span id='topic+lung73.pvclust'></span><span id='topic+lung73.sb'></span><span id='topic+lung.pvclust'></span><span id='topic+lung.sb'></span>

<h3>Description</h3>

<p>Bootstrapping hierarchical clustering of the DNA microarray data set
of 73 lung tissue samples each containing 916 observed genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lung73)
</code></pre>


<h3>Format</h3>

<p><code>lung73.pvclust</code> and <code>lung.pvclust</code> are objects of class <code>"pvclust"</code>
defined in <span class="pkg">pvclust</span> of Suzuki and Shimodaira (2006).
</p>
<p><code>lung73.sb</code> and <code>lung.sb</code> are an object of class <code>"scalebootv"</code> of length
72.
</p>


<h3>Details</h3>

<p>The microarray dataset of Garber et al. (2001) is reanalyzed in Suzuki
and Shimodaira (2006), and is found in <code>data(lung)</code> of
the <span class="pkg">pvclust</span> package. We reanalyze it, again, by the script shown in
Examples. The result of <code>pvclust</code> is stored in
<code>lung73.pvclust</code> and <code>lung.pvclust</code>, and model fitting to bootstrap probabilities
by the <span class="pkg">scaleboot</span> package
is stored in <code>lung73.sb</code> and <code>lung.sb</code>.
A wide scale range is used in lung73.pvclust and lung73.sb, and the default scale range of pvclust is used in lung.pvclust and lung.sb.
The microarray
dataset is not included in <code>data(lung73)</code>, but it is found in
<code>data(lung)</code> of the <span class="pkg">pvclust</span> package.
</p>


<h3>Source</h3>

<p>Garber, M. E. et al. (2001)
Diversity of gene expression in adenocarcinoma of the lung,
<em>Proceedings of the National Academy of Sciences</em>,
98, 13784-13789 (dataset is available from
<a href="http://genome-www.stanford.edu/lung_cancer/adeno/">http://genome-www.stanford.edu/lung_cancer/adeno/</a>).
</p>


<h3>References</h3>

<p>Suzuki, R. and Shimodaira, H. (2006).
pvclust: An R package for hierarchical clustering with p-values,
<em>Bioinformatics</em>, 22, 1540-1542 (software is available from
CRAN or
<a href="http://stat.sys.i.kyoto-u.ac.jp/prog/pvclust/">http://stat.sys.i.kyoto-u.ac.jp/prog/pvclust/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbpvclust">sbpvclust</a></code>, <code><a href="#topic+sbfit.pvclust">sbfit.pvclust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Parallel setup
library(parallel)
length(cl &lt;- makeCluster(detectCores()))
## script to create lung73.pvclust and lung73.sb
## multiscale bootstrap resampling of hierarchical clustering
library(pvclust)
data(lung)
### default pvclust scales
lung.pvclust &lt;- pvclust(lung, nboot=10000, parallel=cl)
lung.sb &lt;- sbfit(lung.pvclust,cluster=cl) # model fitting
### wider range of scales than pvclust default
sa &lt;- 9^seq(-1,1,length=13) 
lung73.pvclust &lt;- pvclust(lung,r=1/sa,nboot=10000,parallel=cl) 
lung73.sb &lt;- sbfit(lung73.pvclust,cluster=cl) # model fitting

## End(Not run)

## replace si/au/bp entries in pvclust object
library(pvclust)
data(lung73) # loading the previously computed bootstrap

### the original pvclust result
plot(lung.pvclust, print.pv = c("si", "au", "bp"), cex=0.5, cex.pv=0.5)
pvrect(lung.pvclust, pv="si") #  (defualt pvclust uses pv="au")

### default pvclust scales with p-values of k=2
lung.k2 &lt;- sbpvclust(lung73.pvclust,lung73.sb, k=2)
plot(lung.k2, print.pv = c("si", "au", "bp"), cex=0.5, cex.pv=0.5)
pvrect(lung.k2, pv="si")

### wider scales with p-values of k=3 (default of scaleboot)
lung73.k3 &lt;- sbpvclust(lung73.pvclust,lung73.sb)
plot(lung73.k3, print.pv = c("si", "au", "bp"), cex=0.5, cex.pv=0.5)
pvrect(lung73.k3, pv="si")

## diagnostics of fitting

### diagnose edges 61,...,69
lung73.sb[61:69] # print fitting details
plot(lung73.sb[61:69]) # plot curve fitting
summary(lung73.sb[61:69]) # print raw(=bp)/si/au p-values

### diagnose edge 67
lung73.sb[[67]] # print fitting
plot(lung73.sb[[67]],legend="topleft") # plot curve fitting
summary(lung73.sb[[67]]) # print au p-values

</code></pre>

<hr>
<h2 id='mam15'>Mammal Phylogenetic Analysis for 15 trees</h2><span id='topic+mam15'></span><span id='topic+mam15.relltest'></span><span id='topic+mam15.mt'></span><span id='topic+mam15.ass'></span><span id='topic+mam15.aux'></span><span id='topic+mam105'></span><span id='topic+mam105.relltest'></span><span id='topic+mam105.mt'></span><span id='topic+mam105.ass'></span><span id='topic+mam105.aux'></span><span id='topic+mam26'></span><span id='topic+mam26.mt'></span><span id='topic+mam26.ass'></span><span id='topic+mam26.aux'></span>

<h3>Description</h3>

<p>Phylogenetic analysis of six mammal species for 15 trees and 105 trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mam15)
</code></pre>


<h3>Format</h3>

<p>mam15.mt is a matrix of size 3414 * 15.  The (i,j) element is the
site-wise log-likelihood value at site-i for tree-j for i=1,...,3414,
and j=1,...,15. They are constrained trees with clade (cow, seal) being fixed.
</p>
<p>mam15.ass is a list of length 25 for association vectors. The
components are t1, t2, ..., t15 for trees, and e1, e2, ..., e10 for
edges.
</p>
<p>mam15.relltest is an object of class <code>"relltest"</code> of length 25.
</p>
<p>mam15.aux is a list of tree topologies (tpl), clade patterns (cld), taxa names(tax).
</p>
<p>mam105.mt, mam105.ass, mam105.relltst, mam105.aux are those for
105 unconstrained trees.
</p>
<p>mam26.mt, mam26.ass, mam26.aux are those for 26 trees including
the 15 constrained trees, 10 partially resolved trees corresponding to 
the 10 internal edges, and the star topology.
</p>


<h3>Details</h3>

<p>An example of phylogenetic analysis of six mammal species:
Homo sapiens (human), Phoca vitulina (harbor seal), Bos taurus (cow),
Oryctolagus cuniculus (rabbit), Mus musculus (mouse), Didelphis
virginiana (opossum).  The data is stored in the file &lsquo;<span class="file">mam15.aa</span>&rsquo;,
which contains amino acid sequences of length N=3414 for the six
species obtained from mtDNA (see Note below).
Here we fix (Phovi,Bosta) as a group of taxa.
With this constraint, we consider 15 tree topologies of the six mammals as stored in the
file &lsquo;<span class="file">mam15.tpl</span>&rsquo;; 
</p>
<pre>  
((Homsa,(Phovi,Bosta)),Orycu,(Musmu,Didvi)); t1
(Homsa,Orycu,((Phovi,Bosta),(Musmu,Didvi))); t2
(Homsa,((Phovi,Bosta),Orycu),(Musmu,Didvi)); t3
(Homsa,(Orycu,Musmu),((Phovi,Bosta),Didvi)); t4
((Homsa,(Phovi,Bosta)),(Orycu,Musmu),Didvi); t5
(Homsa,((Phovi,Bosta),(Orycu,Musmu)),Didvi); t6
(Homsa,(((Phovi,Bosta),Orycu),Musmu),Didvi); t7
(((Homsa,(Phovi,Bosta)),Musmu),Orycu,Didvi); t8
(((Homsa,Musmu),(Phovi,Bosta)),Orycu,Didvi); t9
(Homsa,Orycu,(((Phovi,Bosta),Musmu),Didvi)); t10
(Homsa,(((Phovi,Bosta),Musmu),Orycu),Didvi); t11
((Homsa,((Phovi,Bosta),Musmu)),Orycu,Didvi); t12
(Homsa,Orycu,(((Phovi,Bosta),Didvi),Musmu)); t13
((Homsa,Musmu),Orycu,((Phovi,Bosta),Didvi)); t14
((Homsa,Musmu),((Phovi,Bosta),Orycu),Didvi); t15
</pre>  
<p>The log-likelihood values are calculated using the PAML software (Ziheng 1997)
for phylogenetic inference. The two files &lsquo;<span class="file">mam15.aa</span>&rsquo; and
&lsquo;<span class="file">mam15.tpl</span>&rsquo; are fed into PAML to generate the file
&lsquo;<span class="file">mam15.lnf</span>&rsquo; of site-wise log-likelihood values.
</p>
<p>Using the CONSEL software (Shimodaira and Hasegawa 2001), we convert
&lsquo;<span class="file">mam15.lnf</span>&rsquo; and &lsquo;<span class="file">mam15.tpl</span>&rsquo; to a format suitable for the <span class="pkg">scaleboot</span>
package. We do not use CONSEL for calculating AU p-values, but
use it only for file conversion. We type
</p>
<pre>
seqmt --paml mam15.lnf
treeass --outgroup 6 mam15.tpl &gt; mam15.log
</pre>
<p>The first line above generates &lsquo;<span class="file">mam15.mt</span>&rsquo;, which is a simple text
file containing a matrix of site-wise log-likelihood values. The
second line above generates &lsquo;<span class="file">mam15.ass</span>&rsquo; and &lsquo;<span class="file">mam15.log</span>&rsquo;, which
contain information regarding which edges are included in a tree.  A
part of &lsquo;<span class="file">mam15.log</span>&rsquo; is as follows.
</p>
<pre>  
# leaves: 6
6
  1 Homsa
  2 Phovi
  3 Bosta
  4 Orycu
  5 Musmu
  6 Didvi

# base edges: 10
10 6
          
    123456
  1 +++---  ;
  2 ++++--  ;
  3 +--+--  ;
  4 -+++--  ;
  5 ---++-  ;
  6 +--++-  ;
  7 -++++-  ;
  8 +++-+-  ;
  9 +---+-  ;
 10 -++-+-  ;
</pre>
<p>The above defines edges named e1,...e10 (base edges) as clusters for six
mammal species. For example, e1 = +++&mdash; = (Homsa, Phovi, Bosta).
</p>
<p>The converted files are read by the <span class="pkg">scaleboot</span> package in <span class="rlang"><b>R</b></span>:
</p>
<pre>  
mam15.mt &lt;- read.mt("mam15.mt")
mam15.ass &lt;- read.ass("mam15.ass")
</pre>
<p><code>mam15.mt</code> is a matrix of size 3414 * 6 for the site-wise
log-likelihood values. For testing trees, we need only <code>mam15.mt</code>.
<code>mam15.ass</code> is used for testing edges, and it is
a list of length 25 for association vectors for t1,t2,...,t15, and
e1,e2,...,e10.  For example, <code>mam15.ass$t1 = 1</code>, indicating tree
&quot;t1&quot; is included in tree &quot;t1&quot;, and <code>mam15.ass$e1 = c(1, 5, 8)</code>,
indicating edge &quot;e1&quot; is included in trees &quot;t1&quot;, &quot;t5&quot;, and &quot;t8&quot;.
</p>
<p>Multiscale bootstrap resampling is performed by the function
<code>relltest</code>. The simplest way to get AU p-values for trees is:
</p>
<pre>
mam15.trees &lt;- relltest(mam15.mt) # resampling and fitting
summary(mam15.trees) # calculates AU p-values
</pre>
<p>The <code><a href="#topic+relltest">relltest</a></code> returns an object of class <code>"relltest"</code>.
It calls the function <code><a href="#topic+scaleboot">scaleboot</a></code> internally with
the number of bootstrap replicates <code>nb=10000</code>, and takes about 20
mins. Typically, <code>nb=10000</code> is large enough, but it would be safe
to use larger value, say <code>nb=100000</code> as in the examples below.
</p>
<p>Note that the default value of scales in <code><a href="#topic+relltest">relltest</a></code> has
a much wider range than that of CONSEL. It is
<code>sa=9^seq(-1,1,length=13)</code> for <code><a href="#topic+relltest">relltest</a></code>, and
is <code>sa=1/seq(from=0.5,to=1.4,by=0.1)</code> for CONSEL.
</p>
<p>The <code>mam15.relltest</code> object in <code>data(mam15)</code> is similar
to <code>mam15.trees</code> above, but is also calculated for
edges using <code>mam15.ass</code>. We can extract the result for trees by
</p>
<pre>
mam15.trees &lt;- mam15.relltest[1:15]
</pre>
<p>The results for trees stored in the <code>mam15.trees</code> object above are in
the order specified in the columns of <code>mam15.mt</code>. To sort it by
increasing order of the log-likelihood difference, we can type
</p>
<pre>
stat &lt;- attr(mam15.trees,"stat")  # the log-likelihood differences
o &lt;- order(stat) # sort it in increasing order
mam15.trees &lt;- mam15.trees[o] # same as mam15.trees in Examples
</pre>
<p>Results of the fitting are shown by using the <code>print</code> method.
</p>
<pre>
&gt; mam15.trees

Test Statistic, and Shimodaira-Hasegawa test:
    stat  shtest       
t1  -2.66 94.51 (0.07) 
t3   2.66 80.25 (0.13) 
t2   7.40 57.85 (0.16) 
t5  17.57 17.30 (0.12) 
t6  18.93 14.32 (0.11) 
t7  20.11 11.49 (0.10) 
t4  20.60 10.98 (0.10) 
t15 22.22  7.34 (0.08) 
t8  25.38  3.31 (0.06) 
t14 26.32  3.29 (0.06) 
t13 28.86  1.71 (0.04) 
t9  31.64  0.61 (0.02) 
t11 31.75  0.57 (0.02) 
t10 34.74  0.20 (0.01) 
t12 36.25  0.12 (0.01) 

Multiscale Bootstrap Probabilities (percent):
    1  2  3  4  5  6  7  8  9  10 11 12 13 
t1  86 81 77 73 68 63 58 52 46 41 36 31 28 
t3  14 19 23 27 30 32 32 31 30 27 25 22 20 
t2   0  0  0  0  1  2  4  5  7  9 10 11 11 
t5   0  0  0  0  0  1  1  2  3  5  6  6  7 
t6   0  0  0  0  1  2  3  5  6  7  8  9  9 
t7   0  0  0  0  0  0  0  1  2  3  4  5  5 
t4   0  0  0  0  0  1  2  3  4  4  5  6  6 
t15  0  0  0  0  0  0  0  0  1  1  2  2  3 
t8   0  0  0  0  0  0  0  0  0  0  1  1  1 
t14  0  0  0  0  0  0  0  1  1  2  3  4  4 
t13  0  0  0  0  0  0  0  0  0  0  1  1  2 
t9   0  0  0  0  0  0  0  0  0  0  0  1  1 
t11  0  0  0  0  0  0  0  0  0  0  0  1  1 
t10  0  0  0  0  0  0  0  0  0  0  0  0  0 
t12  0  0  0  0  0  0  0  0  0  0  0  0  0 

Numbers of Bootstrap Replicates:
1     2     3     4     5     6     7     8     9     10    11    12    13    
1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 

Scales (Sigma Squared):
1      2      3      4      5      6      7 8     9     10 11    12    13    
0.1111 0.1603 0.2311 0.3333 0.4808 0.6933 1 1.442 2.080 3  4.327 6.241 9.008 

AIC values of Model Fitting:
    poly.1   poly.2  poly.3  sing.3  
t1  89483.40  964.33  964.75  966.33 
t3  75434.97 1750.22 1306.50 1752.22 
t2  29361.29  403.41   36.33   -6.21 
t5  23893.19  260.44   -0.22  -14.11 
t6  35791.26  330.50    4.31   -2.49 
t7  15221.10   93.59  -10.33  -12.04 
t4  29790.60  453.95    5.22   -7.57 
t15  6874.98   46.16  -10.48  -17.08 
t8   1747.13   -6.88  -12.39  -13.68 
t14 10905.94  131.48    2.65  -10.79 
t13  3411.26   27.66   -8.30  -15.14 
t9   1494.58   19.46  -13.78  -15.86 
t11   914.42  -19.65  -19.71  -19.61 
t10   259.68  -14.79  -17.27  -16.76 
t12   178.79  -19.19  -19.61  -19.30 
</pre>
<p>The AU p-values are shown by the <code>summary</code> method.
</p>
<pre>
&gt; summary(mam15.trees)

Corrected P-values (percent):
    raw          k.1          k.2          k.3          model  aic     
t1  57.58 (0.16) 56.16 (0.04) 74.55 (0.05) 74.55 (0.05) poly.2  964.33 
t3  31.86 (0.15) 30.26 (0.05) 46.41 (0.09) 45.33 (0.13) poly.3 1306.50 
t2   3.68 (0.06)  3.68 (0.03) 12.97 (0.20) 16.12 (0.45) sing.3   -6.21 
t5   1.34 (0.04)  1.33 (0.02)  7.92 (0.25) 10.56 (0.56) sing.3  -14.11 
t6   3.18 (0.06)  3.15 (0.02) 13.15 (0.21) 15.86 (0.44) sing.3   -2.49 
t7   0.49 (0.02)  0.52 (0.01)  3.66 (0.21)  4.75 (0.42) sing.3  -12.04 
t4   1.55 (0.04)  1.53 (0.02) 10.54 (0.27) 14.84 (0.66) sing.3   -7.57 
t15  0.08 (0.01)  0.07 (0.00)  1.11 (0.19)  1.85 (0.48) sing.3  -17.08 
t8   0.00 (0.00)  0.00 (0.00)  0.04 (0.03)  0.07 (0.07) sing.3  -13.68 
t14  0.22 (0.01)  0.23 (0.01)  2.76 (0.26)  4.59 (0.71) sing.3  -10.79 
t13  0.02 (0.00)  0.01 (0.00)  0.50 (0.20)  1.30 (0.83) sing.3  -15.14 
t9   0.00 (0.00)  0.00 (0.00)  0.23 (0.05)  1.41 (0.29) sing.3  -15.86 
t11  0.00 (0.00)  0.00 (0.00)  0.00 (0.00)  0.00 (0.00) poly.3  -19.71 
t10  0.00 (0.00)  0.00 (0.00)  0.00 (0.00)  0.00 (0.00) poly.3  -17.27 
t12  0.00 (0.00)  0.00 (0.00)  0.00 (0.00)  0.00 (0.00) poly.3  -19.61 
</pre>
<p>The p-values for 15 trees are shown above.  &quot;raw&quot; is
the ordinary bootstrap probability, &quot;k.1&quot; is equivalent to &quot;raw&quot; but
calculated from the multiscale bootstrap, &quot;k.2&quot; is equivalent to the
third-order AU p-value of CONSEL, and finally &quot;k.3&quot; is an improved
version of AU p-value.
</p>
<p>The details for each tree are shown by extracting the corresponding element. For
example, details for the seventh largest tree in the
log-likelihood value (&quot;t4&quot;) is obtained by
</p>
<pre>
&gt; mam15.trees[[7]] # same as mam15.trees$t4

Multiscale Bootstrap Probabilities (percent):
1    2    3    4    5    6    7    8    9    10   11   12   13   
0.00 0.00 0.01 0.08 0.27 0.80 1.55 2.55 3.58 4.42 5.22 6.00 6.38 

Numbers of Bootstrap Replicates:
1     2     3     4     5     6     7     8     9     10    11    12    13    
1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 1e+05 

Scales (Sigma Squared):
1      2      3      4      5      6      7 8     9     10 11    12    13    
0.1111 0.1603 0.2311 0.3333 0.4808 0.6933 1 1.442 2.080 3  4.327 6.241 9.008 

Coefficients:
       beta0           beta1           beta2            
poly.1 2.8388 (0.0048)                                  
poly.2 1.8556 (0.0061) 0.3259 (0.0019)                  
poly.3 1.7157 (0.0085) 0.4508 (0.0061) -0.0152 (0.0007) 
sing.3 1.6178 (0.0153) 0.5435 (0.0143)  0.3261 (0.0201) 

Model Fitting:
       rss      df pfit   aic      
poly.1 29814.60 12 0.0000 29790.60 
poly.2   475.95 11 0.0000   453.95 
poly.3    25.22 10 0.0050     5.22 
sing.3    12.43 10 0.2571    -7.57 

Best Model:  sing.3 
&gt; summary(mam15.trees[[7]])

Raw Bootstrap Probability:  1.55 (0.04) 

Corrected P-values (percent):
       k.1         k.2          k.3          aic      
poly.1 0.23 (0.00)  0.23 (0.00)  0.23 (0.00) 29790.60 
poly.2 1.46 (0.02)  6.30 (0.09)  6.30 (0.09)   453.95 
poly.3 1.57 (0.02)  9.50 (0.21) 10.57 (0.27)     5.22 
sing.3 1.53 (0.02) 10.54 (0.27) 14.84 (0.66)    -7.57 

Best Model:  sing.3 

&gt; plot(mam15.trees[[7]],legend="topleft")
</pre>  
<p>The plot diagnostics found in the bottom line are especially useful
for confirming which model is fitting best.
</p>
<p>See other examples below.
</p>


<h3>Note</h3>

<p>Dataset files for phylogenetic inference are found at
<a href="http://github.com/shimo-lab/scaleboot">http://github.com/shimo-lab/scaleboot</a>.
Look at the subdirectory &lsquo;<span class="file">dataset/mam15-files</span>&rsquo;.
This dataset
was originally used in Shimodaira and Hasegawa (1999).
</p>


<h3>Source</h3>

<p>H. Shimodaira and M. Hasegawa (1999). Multiple comparisons of
log-likelihoods with applications to phylogenetic inference, <em>Molecular
Biology and Evolution</em>, 16, 1114-1116.
</p>


<h3>References</h3>

<p>Yang, Z. (1997). PAML: a program package for phylogenetic analysis by
maximum likelihood, <em>Computer Applications in BioSciences</em>,
13:555-556 (software is available from
<a href="http://abacus.gene.ucl.ac.uk/software/paml.html">http://abacus.gene.ucl.ac.uk/software/paml.html</a>).
</p>
<p>Shimodaira, H. and Hasegawa, M. (2001). CONSEL: for assessing the
confidence of phylogenetic tree selection, <em>Bioinformatics</em>, 17,
1246-1247 (software is available from
<a href="http://stat.sys.i.kyoto-u.ac.jp/prog/consel/">http://stat.sys.i.kyoto-u.ac.jp/prog/consel/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mam105">mam105</a></code>, <code><a href="#topic+relltest">relltest</a></code>, 
<code><a href="#topic+summary.scalebootv">summary.scalebootv</a></code>,
<code><a href="#topic+read.mt">read.mt</a></code>, <code><a href="#topic+read.ass">read.ass</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mam15)

## show the results for trees and edges
mam15.relltest # print stat, shtest, bootstrap probabilities, and AIC
summary(mam15.relltest) # print AU p-values

## Not run: 
## simpler script to create mam15.trees
mam15.mt &lt;- read.mt("mam15.mt")
mam15.ass &lt;- read.ass("mam15.ass")
mam15.trees &lt;- relltest(mam15.mt,nb=100000)

## End(Not run)

## Not run: 
## script to create mam15.relltest
mam15.mt &lt;- read.mt("mam15.mt")
mam15.ass &lt;- read.ass("mam15.ass")
mam15.relltest &lt;- relltest(mam15.mt,nb=100000,ass=mam15.ass)

## End(Not run)

## Not run: 
## Parallel version of the above script (but different in random seed)
## It took 13 mins (40 cpu's of Athlon MP 2000+)
mam15.mt &lt;- read.mt("mam15.mt")
mam15.ass &lt;- read.ass("mam15.ass")
library(parallel)
cl &lt;- makeCluster(40)
mam15.relltest &lt;- relltest(mam15.mt,nb=100000,ass=mam15.ass,cluster=cl)

## End(Not run)


</code></pre>

<hr>
<h2 id='plot.scaleboot'>Plot Diagnostics for Multiscale Bootstrap</h2><span id='topic+plot.scaleboot'></span><span id='topic+plot.summary.scaleboot'></span><span id='topic+lines.scaleboot'></span><span id='topic+sblegend'></span><span id='topic+plot.scalebootv'></span><span id='topic+plot.summary.scalebootv'></span><span id='topic+sbplotbeta'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code>"scaleboot"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'scaleboot'
plot(x, models=NULL, select=NULL, sort.by=c("aic","none"),
     k=NULL, s=NULL, sp=NULL, lambda=NULL, bpk=NULL,
     xval = c("square", "inverse","sigma"),
     yval = c("psi", "zvalue", "pvalue"), xlab = NULL,
     ylab = NULL,log.xy = "", xlim = NULL, ylim = NULL,
     add = F, length.x = 300, main=NULL,
     col =1:6, lty = 1:5, lwd = par("lwd"), ex.pch=2:7,
     pch = 1, cex = 1, pt.col = col[1],pt.lwd = lwd[1],
     legend.x = NULL, inset = 0.1, cex.legend=1,...)

## S3 method for class 'summary.scaleboot'
plot(x, select="average",
     k=x$parex$k,s=x$parex$s,sp=x$parex$sp,lambda=x$parex$lambda, ...)


## S3 method for class 'scalebootv'
plot(x,models=attr(x,"models"),sort.by="none",...)

## S3 method for class 'summary.scalebootv'
plot(x, select="average",...)


## S3 method for class 'scaleboot'
lines(x,z,models=names(x$fi), k=NULL,s=NULL,sp=NULL,lambda=NULL,
      bpk=NULL, length.x=z$length.x, col=z$col,lty=z$lty,lwd=z$lwd,... )

sblegend(x="topright",y=NULL,z,inset=0.1,...)

sbplotbeta(beta, p=0.05, col.contour=c("blue","red","green"),
                     drawcontours = TRUE, drawlabels = TRUE,
                     labcex=1,length=100, cex=1, col="black",
                     xlim=NULL, ylim=NULL, lim.countourexpand=0 ) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.scaleboot_+3A_x">x</code></td>
<td>
<p>an object used to select a method. 
For <code>sblegend</code>,
<code>x</code> is a numeric or character such as &quot;lefttop&quot; or &quot;righttop&quot;, which
is passed to <code>legend</code>.
</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_models">models</code></td>
<td>
<p>character vector of model names. Numeric is also allowed.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_select">select</code></td>
<td>
<p>&quot;average&quot;, &quot;best&quot;, or one of the fitted models.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_sort.by">sort.by</code></td>
<td>
<p>&quot;aic&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_k">k</code></td>
<td>
<p>k for extrapolation.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_s">s</code></td>
<td>
<p>s for extrapolation.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_sp">sp</code></td>
<td>
<p>sp for extrapolation.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_lambda">lambda</code></td>
<td>
<p>a numeric of specifying the type of p-values; Bayesian (lambda=0) Frequentist (lambda=1).</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_bpk">bpk</code></td>
<td>
<p>(experimental for 2-step bootstrap)</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_xval">xval</code></td>
<td>
<p>specifies x-axis.
&quot;square&quot; for <code class="reqn">\sigma^2</code>,
&quot;inverse&quot; for <code class="reqn">1/\sigma</code>,
&quot;sigma&quot; for <code class="reqn">\sigma</code>.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_yval">yval</code></td>
<td>
<p>specifies y-axis. &quot;zvalue&quot; for
<code class="reqn">\psi(\sigma^2|\beta)/\sigma</code> or <code>qnorm(1-bp[i])</code>,
&quot;pvalue&quot; for <code class="reqn">1-\Phi(\psi(\sigma^2|\beta)/\sigma)</code> or <code>bp[i]</code>,
&quot;psi&quot; for <code class="reqn">\psi(\sigma^2|\beta)</code> or <code>sqrt(sa[i])*qnorm(1-bp[i])</code>.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_xlab">xlab</code></td>
<td>
<p>label for x-axis.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_log.xy">log.xy</code></td>
<td>
<p>character to specify log-scale. &quot;&quot;, &quot;x&quot;, &quot;y&quot;, or &quot;xy&quot;.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_xlim">xlim</code></td>
<td>
<p>range for x-axis.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_ylim">ylim</code></td>
<td>
<p>range for y-axis.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_add">add</code></td>
<td>
<p>logical for adding another plot.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_length.x">length.x</code></td>
<td>
<p>the number of segments to draw curves.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_main">main</code></td>
<td>
<p>for title.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_col">col</code></td>
<td>
<p>color for model curves.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_lty">lty</code></td>
<td>
<p>lty for model curves.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_lwd">lwd</code></td>
<td>
<p>lwd for model curves.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_ex.pch">ex.pch</code></td>
<td>
<p>pch for extrapolation.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_pch">pch</code></td>
<td>
<p>pch for bp points.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_cex">cex</code></td>
<td>
<p>cex for bp points.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_pt.col">pt.col</code></td>
<td>
<p>col for bp points.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_pt.lwd">pt.lwd</code></td>
<td>
<p>lwd for bp points.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_legend.x">legend.x</code></td>
<td>
<p>passed to sblegend as the first argument.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>  
<tr><td><code id="plot.scaleboot_+3A_z">z</code></td>
<td>
<p>output from previous <code>plot.scaleboot</code>.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_y">y</code></td>
<td>
<p>numeric passed to <code>legend</code>.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_inset">inset</code></td>
<td>
<p>inset distance from the margins, which is passed to
<code>legend</code>.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>cex for legend</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_beta">beta</code></td>
<td>
<p>matrix of beta values. beta[,1] is beta0, beta[,2] is beta1.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_p">p</code></td>
<td>
<p>significance level for drawing contour lines.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_col.contour">col.contour</code></td>
<td>
<p>colors for SI, AU, BP.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_drawcontours">drawcontours</code></td>
<td>
<p>draw contours when TRUE.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_drawlabels">drawlabels</code></td>
<td>
<p>draw labels at contours when TRUE.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_labcex">labcex</code></td>
<td>
<p>cex for contours.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_length">length</code></td>
<td>
<p>grid size for drawing contours.</p>
</td></tr>
<tr><td><code id="plot.scaleboot_+3A_lim.countourexpand">lim.countourexpand</code></td>
<td>
<p>expand contour plotting region</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> method plots bootstrap probabilities and calls the <code>lines</code>
method, which draws fitted curves for models.
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbfit">sbfit</a></code>, <code><a href="#topic+sbphylo">sbphylo</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mam15)
## a single plot
a &lt;- mam15.relltest[["t4"]] # an object of class "scaleboot"
plot(a,legend="topleft") # x=sigma^2, y=psi
plot(a,xval="inverse",yval="zvalue",
     legend="topleft") # x=1/sigma, y=z-value
plot(a,xval="sigma",log="x",yval="pvalue",
     legend="topleft") # x=log(sigma), y=probability
## plot of extrapolation
plot(summary(a),legend="topleft")
## multiple plots
b &lt;- mam15.relltest[1:15] # an object of class "scalebootv"
plot(b) # x=sigma^2, y=psi
</code></pre>

<hr>
<h2 id='relltest'>RELL Test for Phylogenetic Inference</h2><span id='topic+relltest'></span><span id='topic+summary.relltest'></span>

<h3>Description</h3>

<p>Performs the RELL test for finding the largest item. This
calculates AU p-values for each item via the multiscale bootstrap resampling.
This is particularly useful for testing tree topologies in phylogenetic analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
relltest(dat,nb=10000,sa=9^seq(-1,1,length=13),ass=NULL,
         cluster=NULL,nofit=FALSE,models=NULL,seed=100)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relltest_+3A_dat">dat</code></td>
<td>
<p>a matrix. Row vectors are to be resampled. Each column
vector gives score values to be evaluated for an item. For the
phylogenetic analysis, <code>dat[i,j]</code> is the site-wise log-likelihood value
at site-i for tree-j, and we are to find the tree with the largest
expected value of <code>sum(dat[,j])</code>.</p>
</td></tr>
<tr><td><code id="relltest_+3A_nb">nb</code></td>
<td>
<p>Number of replicates for each scale.</p>
</td></tr>
<tr><td><code id="relltest_+3A_sa">sa</code></td>
<td>
<p>Scales in sigma squared (<code class="reqn">\sigma^2</code>).</p>
</td></tr>
<tr><td><code id="relltest_+3A_ass">ass</code></td>
<td>
<p>A list of association vectors for testing edges as well as
trees. If <code>ass=NULL</code>, then only the results for trees are returned.</p>
</td></tr>
<tr><td><code id="relltest_+3A_cluster">cluster</code></td>
<td>
<p><span class="pkg">parallel</span> cluster object which may be generated by
function <code>makeCluster</code>.</p>
</td></tr>
<tr><td><code id="relltest_+3A_nofit">nofit</code></td>
<td>
<p>logical. Passed to <code><a href="#topic+sbfit">sbfit</a></code>.</p>
</td></tr>
<tr><td><code id="relltest_+3A_models">models</code></td>
<td>
<p>character vectors. Passed to <code><a href="#topic+sbfit">sbfit</a></code>.</p>
</td></tr>
<tr><td><code id="relltest_+3A_seed">seed</code></td>
<td>
<p>If non NULL, then a random seed is set. Specifying a seed is
particularly important when <code>cluster</code> is non NULL, in this
case <code>seed + seq(along=cluster)</code> are set to cluster nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>relltest</code> performs the resampling of estimated log-likelihoods
(RELL) method of Kishino et al. (1990). For resampling indices stored
in a vector <code>i</code>, the resampled log-likelihood for a tree-j is
approximately calculated by <code>sum(dat[i,j])</code>. This approximation
avoids time-consuming recalculation of the maximum likelihood
estimates of tree parameters, which are to be calculated by an
external phylogenetic software such as PAML as described in
<code><a href="#topic+mam15">mam15</a></code>. In the implementation of <code>relltest</code>, the
resampled log-likelihood is calculated by
<code>sum(dat[i,j])</code><code>*nrow(dat)/length(i)</code> so that the statistic is
comparable to the case when <code class="reqn">n'=n</code>.
</p>
<p><code>relltest</code> first calls <code><a href="#topic+scaleboot">scaleboot</a></code> internally for
multiscale bootstrap resampling, and then <code><a href="#topic+scaleboot">scaleboot</a></code>
calls <code><a href="#topic+sbfit">sbfit</a></code> for fitting models to the bootstrap
probabilities. The AU p-values (named &quot;k.3&quot;) produced
by the <code>summary</code> method are improvements
of the third-order p-values calculated by CONSEL software (Shimodaira
and Hasegawa 2001).  In addition,
<code>relltest</code> calls <code><a href="#topic+scaleboot">scaleboot</a></code> with <code>sa=1</code> for
calculating p-values via the Shimodaira-Hasegawa test (SH-test) of
Shimodaira and Hasegawa (1999).
</p>
<p>See <code><a href="#topic+mam15">mam15</a></code> for details through an example.
</p>


<h3>Value</h3>

<p><code>relltest</code> returns an object of class <code>"relltest"</code> that is
inherited from the class
<code>"scalebootv"</code> by adding two extra components called &quot;stat&quot;
and &quot;shtest&quot;. &quot;stat&quot; is a vector of the test statistics from the
SH-test (i.e., the log-likelihood differences), and
&quot;shtest&quot; is a list with two components: &quot;pv&quot;, a vector of SH-test
p-values, and &quot;pe&quot;, a vector of standard errors of the
p-values.  The results of multiscale bootstrap resampling are stored
in the <code>"scalebootv"</code> components returned by a call to
<code><a href="#topic+sbfit">sbfit</a></code>.
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>References</h3>

<p>Kishino, H., Miyata, T. and Hasegawa, M. (1990). Maximum likelihood
inference of  protein phylogeny and the origin of
chloroplasts.,  <em>J. Mol. Evol.</em>, 30, 151-160.
</p>
<p>Shimodaira, H. and Hasegawa, M. (1999). Multiple comparisons of
log-likelihoods with applications to phylogenetic inference,
<em>Molecular Biology and Evolution</em>, 16, 1114-1116.
</p>
<p>Shimodaira, H. and Hasegawa, M. (2001). CONSEL: for assessing the
confidence of phylogenetic tree selection, <em>Bioinformatics</em>, 17,
1246-1247 (software is available from
<a href="http://stat.sys.i.kyoto-u.ac.jp/prog/consel/">http://stat.sys.i.kyoto-u.ac.jp/prog/consel/</a>).
</p>
<p>Luke Tierney, A. J. Rossini, Na Li and H. Sevcikova. snow: Simple
Network of Workstations. R package version 0.2-1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbfit">sbfit</a></code>, <code><a href="#topic+scaleboot">scaleboot</a></code>, <code><a href="#topic+mam15">mam15</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## a quick example
data(mam15) # loading mam15.mt
mam15.trees &lt;- relltest(mam15.mt,nb=1000) # nb=10000 is default
mam15.trees # SH-test p-values and result of fitting
summary(mam15.trees) # AU p-values

## End(Not run)

## Not run: 
## An example from data(mam15).
## It may take 20 mins to run relltest below.
mam15.mt &lt;- read.mt("mam15.mt") # site-wise log-likelihoods
mam15.trees &lt;- relltest(mam15.mt) # resampling and fitting
summary(mam15.trees) # AU p-values

## End(Not run)

</code></pre>

<hr>
<h2 id='sbaic'>Akaike's Information Criterion</h2><span id='topic+sbaic'></span><span id='topic+sbaic+3C-'></span><span id='topic+sbaic.scaleboot'></span><span id='topic+sbaic.scalebootv'></span><span id='topic+sbaic+3C-.scaleboot'></span><span id='topic+sbaic+3C-.scalebootv'></span>

<h3>Description</h3>

<p>Extract or modify the AIC values for models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbaic(x,...)
## S3 method for class 'scaleboot'
sbaic(x,k,...)
## S3 method for class 'scalebootv'
sbaic(x,...)

sbaic(x) &lt;- value
## S3 replacement method for class 'scaleboot'
sbaic(x) &lt;- value
## S3 replacement method for class 'scalebootv'
sbaic(x) &lt;- value

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbaic_+3A_x">x</code></td>
<td>
<p>an object used to select a method. </p>
</td></tr>
<tr><td><code id="sbaic_+3A_k">k</code></td>
<td>
<p>numeric, the penalty per parameter to be used.</p>
</td></tr>
<tr><td><code id="sbaic_+3A_value">value</code></td>
<td>
<p>numeric vector of AIC values for models.</p>
</td></tr>
<tr><td><code id="sbaic_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sbaic</code> can be used to modify the <code>aic</code> components for
models in <code>x</code> as shown in the examples below. 
</p>


<h3>Value</h3>

<p>For an object of class <code>"scaleboot"</code>,
<code>sbaic</code> returns a numeric vector of AIC values for
models.  If
<code>k</code> is missing, then the <code>aic</code> components in the <code>fi</code> vector of
<code>x</code> are returned.  If <code>k</code> is specified, <code>rss-k*df</code> is
calculated for each model. For the usual AIC, k=2.  For the BIC
(Schwarz's Bayesian information criterion), <code>k=log(sum(x$nb))</code>.
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>References</h3>

<p>Sakamoto, Y., Ishiguro, M., and Kitagawa G. (1986).
<em>Akaike Information Criterion Statistics</em>.
D. Reidel Publishing Company.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbfit">sbfit</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mam15)
a &lt;- mam15.relltest[["t4"]] # an object of class "scaleboot"
sbaic(a) # print AIC for models
sbaic(a,k=log(sum(a$nb))) # print BIC for models
sbaic(a) &lt;- sbaic(a,k=log(sum(a$nb))) # set BIC
sbaic(a) # print BIC for models
</code></pre>

<hr>
<h2 id='sbconf'>Bootstrap Confidence Intervals</h2><span id='topic+sbconf'></span><span id='topic+sbconf.default'></span><span id='topic+sbconf.sbconf'></span><span id='topic+print.sbconf'></span><span id='topic+plot.sbconf'></span>

<h3>Description</h3>

<p>A confidence interval for a scalar parameter is obtained by inverting
the approximately unbiased p-value. This function is very slow,
and it is currently experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbconf(x, ...)

## Default S3 method:
sbconf(x,sa, probs=c(0.05,0.95), model="poly.2",
       k=2,s=1,sp=-1, cluster=NULL,...)

## S3 method for class 'sbconf'
sbconf(x, probs=x$probs,model=x$model,
       k=x$k,s=x$s,sp=x$sp, nofit=FALSE, ...)

## S3 method for class 'sbconf'
plot(x,model=x$model,k=x$k,s=x$s,sp=x$sp,
     models = attr(x$fits,"models"), log.xy = "",
     xlab="test statistic",ylab=NULL, type.plot = c("p","l","b"),
     yval=c("aic","zvalue","pvalue"), sd=2,add=FALSE, col=1:6,
     pch=NULL,lty=1:5,lwd=par("lwd"), mk.col=col[1],
     mk.lwd=lwd[1], mk.lty=lty[1], ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbconf_+3A_x">x</code></td>
<td>
<p>an object used to select a method. For <code>sbconf.default</code>,
<code>x</code> is a list vector of size <code>length{sa}</code> 
with each element being a vector of bootstrap replicates of a
statistic or a list vector of a scalar component.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>  
<tr><td><code id="sbconf_+3A_sa">sa</code></td>
<td>
<p>vector of scales in sigma squared (<code class="reqn">\sigma^2</code>).</p>
</td></tr>
<tr><td><code id="sbconf_+3A_probs">probs</code></td>
<td>
<p>a vector of probabilities at which p-values are inverted.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_model">model</code></td>
<td>
<p>a character to specify a model for an AU p-value. This
should be included in <code>sboptions("models")</code>, for which
model fitting is made internally.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_k">k</code></td>
<td>
<p>a numeric to specify an order of AU p-value.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_s">s</code></td>
<td>
<p><code class="reqn">\sigma_0^2</code></p>
</td></tr>
<tr><td><code id="sbconf_+3A_sp">sp</code></td>
<td>
<p><code class="reqn">\sigma_p^2</code></p>
</td></tr>
<tr><td><code id="sbconf_+3A_cluster">cluster</code></td>
<td>
<p><span class="pkg">parallel</span> cluster object which may be generated by
function <code>makeCluster</code>.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_nofit">nofit</code></td>
<td>
<p>logical. No further calls to <code>sbfit</code> are made.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_models">models</code></td>
<td>
<p>AIC values are plotted for these models.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_log.xy">log.xy</code></td>
<td>
<p>character string to be passed to <code>plot.default</code>.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_type.plot">type.plot</code></td>
<td>
<p>a character to be passed to <code>plot.default</code>.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_yval">yval</code></td>
<td>
<p>determines y-axis. &quot;aic&quot; for AIC values of models, &quot;zvalue&quot;
for AU corrected z-values, and &quot;pvalue&quot; for AU corrected p-values.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_sd">sd</code></td>
<td>
<p>If positive, draws curves +-sd*standard error for z-values
and p-values.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_add">add</code></td>
<td>
<p>logical. Should not the frame be drawn?</p>
</td></tr>
<tr><td><code id="sbconf_+3A_col">col</code></td>
<td>
<p>vector of colors of plots.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_pch">pch</code></td>
<td>
<p>vector of pch's of plots.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_lty">lty</code></td>
<td>
<p>vector of lty's of plots.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_lwd">lwd</code></td>
<td>
<p>numeric of lwd of plots.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_mk.col">mk.col</code></td>
<td>
<p>color for crosses drawn at <code>probs</code>.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_mk.lwd">mk.lwd</code></td>
<td>
<p>lwd for crosses drawn at <code>probs</code>.</p>
</td></tr>
<tr><td><code id="sbconf_+3A_mk.lty">mk.lty</code></td>
<td>
<p>lty for crosses drawn at <code>probs</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code>x[[i]]</code> be a vector of bootstrap replicates for a statistic
with scale <code>sa[i]</code>. For a threshold value <code>y</code>, the bootstrap
probability is
<code>bp[i]=sum(x[[i]]&lt;y)/length(x[[i]])</code>. <code>sbconf</code> computes
<code>bp</code> for several <code>y</code> values, and finds a value <code>y</code> at
which the AU p-value, given by <code>sbfit</code>, equals a probability value
specified in <code>probs</code>.  In this manner, AU p-values are inverted to obtain
bootstrap confidence intervals.
</p>
<p>See the examples below for details.
</p>


<h3>Value</h3>

<p><code>sbconf</code> method returns an object of class <code>"sbconf"</code>.
</p>
<p>The <code>print</code> method for an object of class <code>"sbconf"</code> prints
the confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>See Also</h3>

<p><code><a href="#topic+scaleboot">scaleboot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## An example to calculate confidence intervals
## The test statistic is that for "t4" in data(mam15)

data(mam15) # load mam15.mt
sa &lt;- 10^seq(-2,2,length=13) # parameter for multiscale bootstrap

## Definition of a test statistic of interest.
## "myfun" returns the maximum difference of log-likelihood value
## for a tree named a.
myfun &lt;- function(x,w,a) maxdif(wsumrow(x,w))[[a]]
maxdif &lt;- function(x) {
  i1 &lt;- which.max(x)  # the largest element
  x &lt;- -x + x[i1]
  x[i1] &lt;- -min(x[-i1])  # the second largest value
  x
}
wsumrow &lt;- function(x,w) {
  apply(w*x,2,sum)*nrow(x)/sum(w)
}

## Not run: 
## a quick example with nb=1000 (fairely fast in 2017)
## Compute multiscale bootstrap replicates
nb &lt;- 1000 # nb = 10000 is better but slower
# the following line takes some time (less than 1 minute in 2017)
sim &lt;- scaleboot(mam15.mt,nb,sa,myfun,"t4",count=FALSE,onlyboot=TRUE)

## show 90
## each tail is also interpreted as 95
(conf1 &lt;- sbconf(sim$stat,sim$sa,model="sing.3",k=1)) # with k=1
(conf2 &lt;- sbconf(conf1,model="sing.3",k=2)) # with k=2
(conf3 &lt;- sbconf(conf2,model="sing.3",k=3)) # with k=3

## plot diagnostics for computing the confidence limits
plot(conf3) # AIC values for models v.s. test statistic value
plot(conf3,yval="zval",type="l") # corrected "k.3" z-value

## End(Not run)


## Not run: 
## a longer example with nb=10000 (it was slow in 2010)
## In the following, we used 40 cpu's.
nb &lt;- 10000

library(parallel)
cl &lt;- makeCluster(40)
clusterExport(cl,c("maxdif","wsumrow"))

## Compute multiscale bootstrap replicates
## (It took 80 secs using 40 cpu's)
sim &lt;- scaleboot(mam15.mt,nb,sa,myfun,"t4",count=FALSE,
                 cluster=cl,onlyboot=TRUE)

## Modify option "probs0" to a fine grid with 400 points
## default: 0.001 0.010 0.100 0.900 0.990 0.999
## NOTE: This modification is useful only when cl != NULL,
##   in which case calls to sbfit for the grid points
##   are made in parallel, although iterations seen later
##   are made sequentially.
sboptions("probs0",pnorm(seq(qnorm(0.001),qnorm(0.999),length=400)))

## Calculate bootstrap confidence intervals using "k.1" p-value.
## (It took 70 secs using 40 cpu's)
## First, sbfit is applied to bp's determined by option "probs0"
## Then, additional fitting is made only twice for iteration.
## p[1]=0.05 iter=1 t=4.342723 e=0.0003473446 r=0.0301812
## p[2]=0.95 iter=1 t=42.76558 e=0.002572495 r=0.1896809
conf1 &lt;- sbconf(sim$stat,sim$sa,model="sing.3",k=1,cluster=cl)

## The confidence interval with "k.1" is printed as
##     0.05      0.95 
## 4.342723 42.765582 
conf1 

## Calculate bootstrap confidence intervals
##                        using "k.2" and "k.3" p-values.
## (It took only 10 secs)
## p[1]=0.05 iter=1 t=-2.974480 e=0.003729190 r=0.04725755
## p[2]=0.95 iter=1 t=39.51767 e=0.001030929 r=0.06141937
##      0.05      0.95 
## -2.974480 39.517671 
conf2 &lt;- sbconf(conf1,model="sing.3",k=2)
conf2
## p[1]=0.05 iter=1 t=-3.810157 e=0.01068678 r=0.08793868
## p[2]=0.95 iter=1 t=39.32669 e=0.001711107 r=0.09464663
##      0.05      0.95 
## -3.810157 39.326686 
conf3 &lt;- sbconf(conf2,model="sing.3",k=3)
conf3

## plot diagnostics
plot(conf3) # AIC values for models v.s. test statistic value
plot(conf3,yval="zval",type="l") # corrected "k.3" z-value

stopCluster(cl)

## End(Not run)

</code></pre>

<hr>
<h2 id='sbfit'>Fitting Models to Bootstrap Probabilities</h2><span id='topic+sbfit'></span><span id='topic+sbfit.scaleboot'></span><span id='topic+sbfit.scalebootv'></span><span id='topic+sbfit.default'></span><span id='topic+sbfit.matrix'></span><span id='topic+sbfit.data.frame'></span><span id='topic+print.scaleboot'></span><span id='topic+print.scalebootv'></span>

<h3>Description</h3>

<p><code>sbfit</code> is used to fit parametric models to multiscale bootstrap
probabilities by the maximum likelihood method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbfit(x, ...)

## Default S3 method:
sbfit(x,nb,sa,models=NULL,nofit=FALSE,bpm=NULL,sam=NULL,...)

## S3 method for class 'matrix'
sbfit(x,nb,sa,models=NULL,names.hp=rownames(x),
  bpms=NULL,sam=NULL,nofit=FALSE,cluster=NULL,...)

## S3 method for class 'data.frame'
sbfit(x,...)

## S3 method for class 'scaleboot'
sbfit(x,models=names(x$fi),...)

## S3 method for class 'scalebootv'
sbfit(x,models=attr(x,"models"),...)

## S3 method for class 'scaleboot'
print(x,sort.by=c("aic","none"),...)

## S3 method for class 'scalebootv'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbfit_+3A_x">x</code></td>
<td>
<p>an object used to select a method. For <code>sbfit.default</code>,
<code>x</code> is denoted by <code>nb</code> and is a vector of bootstrap
probabilities for a hypothesis. For <code>sbfit.matrix</code>, <code>x</code> is
denoted by <code>bps</code> and is a matrix with row vectors of <code>bp</code>
for several hypotheses.
</p>
</td></tr>
<tr><td><code id="sbfit_+3A_nb">nb</code></td>
<td>
<p>vector of numbers of bootstrap replicates. A short vector
(or scalar) is cyclically extended to match the size of <code>bp</code>.</p>
</td></tr>
<tr><td><code id="sbfit_+3A_sa">sa</code></td>
<td>
<p>vector of scales in sigma squared (<code class="reqn">\sigma^2</code>). Should
be the same size as <code>bp</code>.</p>
</td></tr>
<tr><td><code id="sbfit_+3A_models">models</code></td>
<td>
<p>character vector of model names. Valid model names are
<code>poly.m</code> for m&gt;=1 and <code>sing.m</code> for
m&gt;=3. The default is set by <code>sboptions()$models</code>, whose
default is c(&quot;poly.1&quot;,&quot;poly.2&quot;,&quot;poly.3&quot;,&quot;sing.3&quot;,&quot;sphe.3&quot;).
If <code>models</code> is an integer value, <code>sbmodelnames(m=models)</code> is
used.</p>
</td></tr>
<tr><td><code id="sbfit_+3A_nofit">nofit</code></td>
<td>
<p>logical. If TRUE, fitting is not performed.</p>
</td></tr>
<tr><td><code id="sbfit_+3A_bpm">bpm</code></td>
<td>
<p>(experimental: bootstrap probabilities for 2-step bootstrap)</p>
</td></tr>
<tr><td><code id="sbfit_+3A_sam">sam</code></td>
<td>
<p>(experimental: scales for 2-step bootstrap)</p>
</td></tr>
<tr><td><code id="sbfit_+3A_bpms">bpms</code></td>
<td>
<p>(experimental: bootstrap probabilities for 2-step bootstrap)</p>
</td></tr>
<tr><td><code id="sbfit_+3A_names.hp">names.hp</code></td>
<td>
<p>character vector of hypotheses names.</p>
</td></tr>
<tr><td><code id="sbfit_+3A_cluster">cluster</code></td>
<td>
<p><span class="pkg">parallel</span> cluster object which may be generated by
function <code>makeCluster</code>.</p>
</td></tr>
<tr><td><code id="sbfit_+3A_sort.by">sort.by</code></td>
<td>
<p>sort key.</p>
</td></tr>
<tr><td><code id="sbfit_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from other methods.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p><code>sbfit.default</code> fits parametric models to <code>bp</code>
by maximizing the log-likelihood value of a binomial model.
A set of multiscale bootstrap resampling
should be performed before a call to <code>sbfit</code> for preparing
<code>bp</code>, where <code>bp[i]</code> is a bootstrap probability of a
hypothesis calculated with a number of bootstrap
replicates <code>nb[i]</code> and a scale <code class="reqn">\sigma^2</code>=<code>sa[i]</code>.
The scale is defined as <code class="reqn">\sigma^2=n/n'</code>,
where <code class="reqn">n</code> is the sample size of data, and <code class="reqn">n'</code> is the sample
size of replicated data for bootstrap resampling.
</p>
<p>Each model specifies a <code>psi(beta,s)</code>=<code class="reqn">\psi(\sigma^2 | \beta)</code>
function with a parameter vector <code class="reqn">\beta</code>. The model
may describe how the bootstrap probability changes along the scale.
Let <code>cnt[i]=bp[i]*nb[i]</code> be the frequency indicating how many
times the hypothesis of interest is observed in bootstrap replicates
at scale <code>sa[i]</code>. Then we assume that <code>cnt[i]</code> is binomially
distributed with number of trials <code>nb[i]</code> and success
probability <code>1-pnorm(psi(beta,s=sa[i])/sqrt(sa[i]))</code>. Currently,
<code>sbpsi.poly</code> and <code>sbpsi.sing</code> are available as <code class="reqn">\psi</code>
functions. The estimated model parameters are accessed by the
<code><a href="#topic+coef.scaleboot">coef.scaleboot</a></code> method.
</p>
<p>The model fitting is performed in the order
specified in <code>models</code>, and the initial values for numerical
optimization of the likelihood function are prepared by using
previously estimated model parameters. Thus, &quot;poly.(m-1)&quot;
should be specified before &quot;poly.m&quot;, and &quot;poly.(m-1)&quot; and &quot;sing.(m-1)&quot;
should be specified before &quot;sing.m&quot;.
</p>
<p><code>sbfit.matrix</code> calls <code>sbfit.default</code> repeatedly, once for each row
vector <code>bp</code> of the matrix <code>bps</code>.  Parallel
computing is performed when <code>cluster</code> is non NULL.
</p>
<p><code>sbfit.scaleboot</code> calls <code>sbfit.default</code> with <code>bp</code>,
<code>nb</code>, and <code>sa</code> components in <code>x</code> object for refitting by
giving another <code>models</code> argument. It discards the previous result
of fitting, and recomputes the model parameters.
</p>
<p><code>sbfit.scalebootv</code> calls <code>sbfit.matrix</code> with the <code>bps</code>,
<code>nb</code>, and <code>sa</code> components in the attributes of <code>x</code>.
</p>


<h3>Value</h3>

<p><code>sbfit.default</code> and <code>sbfit.scaleboot</code> return an object of
class <code>"scaleboot"</code>, and <code>sbfit.matrix</code> and
<code>sbfit.scalebootv</code> return an object of
class <code>"scalebootv"</code>. 
</p>
<p>An object of class <code>"scaleboot"</code> is a list containing at least the
following components:
</p>
<table>
<tr><td><code>bp</code></td>
<td>
<p>the vector of bootstrap probabilities used.</p>
</td></tr>
<tr><td><code>nb</code></td>
<td>
<p>the <code>rep(nb,length=length(bp))</code> used.</p>
</td></tr>
<tr><td><code>sa</code></td>
<td>
<p>the <code>sa</code> used. </p>
</td></tr>
<tr><td><code>fi</code></td>
<td>
<p>list vector of fitted results for <code>models</code> used.  Each
list consists of components <code>"par"</code> (estimated parameter),
<code>"mag"</code> (magnification factor for <code>"par"</code> to make the actual
parameter vector <code>beta=par*mag</code>),
<code>"value"</code> (maximum log-likelihood), <code>"hessian"</code> (hessian
matrix), <code>"var"</code> (variance estimate of <code>"par"</code>),
<code>"mask"</code> (logical vector indicating parameter elements which are
not at boundaries),
<code>"init"</code> (initial values used for optimization),
<code>"psi"</code> (psi function name of the model), <code>"df"</code>
(degrees of freedom), <code>"rss"</code> (equivalent to the residual sum
of squares, but actually defined as 2*(lik0-lik) where lik0 and lik
are the log-likelihood function of the non-restricted model and the
model of interest, respectively), <code>"pfit"</code> (p-value for
<code>"rss"</code>),
<code>"aic"</code> (aic value of the model relative to the non-restricted
model).</p>
</td></tr>
</table>
<p>An object of class <code>"scalebootv"</code> is a vector of
<code>"scaleboot"</code> objects, and in addition, it has attributes
<code>"models"</code>, <code>"bps"</code>, <code>"nb"</code>, and <code>"sa"</code>. 
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira &lt;shimo@i.kyoto-u.ac.jp&gt;</p>


<h3>References</h3>

<p>Shimodaira, H. (2002).  An approximately unbiased test of phylogenetic
tree selection, <em>Systematic Biology</em>, 51, 492-508.
</p>
<p>Shimodaira, H. (2004).  Approximately unbiased tests of
regions using multistep-multiscale bootstrap resampling,
<em>Annals of Statistics</em>, 32, 2616-2641. 
</p>
<p>Shimodaira, H. (2008). Testing Regions with Nonsmooth Boundaries via
Multiscale Bootstrap, <em>Journal of Statistical Planning and
Inference</em>, 138, 1227-1241.
(<a href="http://dx.doi.org/10.1016/j.jspi.2007.04.001">http://dx.doi.org/10.1016/j.jspi.2007.04.001</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbpsi">sbpsi</a></code>, <code><a href="#topic+summary.scaleboot">summary.scaleboot</a></code>,
<code><a href="#topic+plot.scaleboot">plot.scaleboot</a></code>, <code><a href="#topic+coef.scaleboot">coef.scaleboot</a></code>,
<code><a href="#topic+sbaic">sbaic</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Testing a hypothesis
## Examples of fitting models to a vector of bp's
## mam15.relltest$t4 of data(mam15), but
## using a different set of scales (sigma^2 values).
## In the below, sigma^2 ranges 0.01 to 100 in sa[i]
## This very large range is only for illustration.
## Typically, the range around 0.1 to 10
## is recommended for much better model fitting.
## In other examples, we have used
## sa = 9^seq(-1,1,length=13).

cnt &lt;- c(0,0,0,0,6,220,1464,3565,5430,6477,6754,
         6687,5961) # observed frequencies at scales
nb &lt;- 100000 # number of replicates at each scale
bp &lt;- cnt/nb # bootstrap probabilities (bp's)
sa &lt;- 10^seq(-2,2,length=13) # scales (sigma squared)
## model fitting to bp's 
f &lt;- sbfit(bp,nb,sa) # model fitting ("scaleboot" object)
f # print the result of fitting
plot(f,legend="topleft") # observed bp's and fitted curves
## approximately unbiased p-values
summary(f) # calculate and print p-values
## refitting with models up to "poly.4" and "sing.4"
f &lt;- sbfit(f,models=1:4)
f # print the result of fitting
plot(f,legend="topleft") # observed bp's and fitted curves
summary(f) # calculate and print p-values

## Not run: 
## Testing multiple hypotheses (only two here)
## Examples of fitting models to vectors of bp's
## mam15.relltest[c("t1,t2")]
cnt1 &lt;- c(85831,81087,76823,72706,67946,62685,57576,51682,
       45887,41028,35538,31232,27832)  # cnt for "t1"
cnt2 &lt;- c(2,13,100,376,975,2145,3682,5337,7219,8559,
       10069,10910,11455)  # cnt for "t2"
cnts &lt;- rbind(cnt1,cnt2)
nb &lt;- 100000 # number of replicates at each scale
bps &lt;- cnts/nb # row vectors are bp's
sa &lt;- 9^seq(-1,1,length=13) # scales (sigma squared)
fv &lt;- sbfit(bps,nb,sa) # returns a "scalebootv" object
fv # print the result of fitting
plot(fv) # multiple plots
summary(fv) # calculate and print p-values

## End(Not run)
</code></pre>

<hr>
<h2 id='sboptions'>Options for Multiscale Bootstrap</h2><span id='topic+sboptions'></span>

<h3>Description</h3>

<p>To set and examine global options for <code>scaleboot</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sboptions(x, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sboptions_+3A_x">x</code></td>
<td>
<p>character of an option name.</p>
</td></tr>
<tr><td><code id="sboptions_+3A_value">value</code></td>
<td>
<p>When specified, this value is set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Invoking <code>sboptions()</code> with no arguments returns a list with the
current values of the options. Otherwise it returns option(s) with name(s)
specified by <code>x</code>.  When <code>value</code> is specified, it is
set to the option named <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>Examples</h3>

<pre><code class='language-R'>sboptions() # show all the options
sboptions("models") # show the default model names
new.models &lt;- sbmodelnames(m=1:2) # character vector c("poly.1","poly.2")
old.models &lt;- sboptions("models",new.models) # set the new model names
sboptions("models") # show the default model names
sboptions("models",old.models) # set back the default value
sboptions("models") # show the default model names
</code></pre>

<hr>
<h2 id='sbphylo'>Tables for phylogenetic inference</h2><span id='topic+sbphylo'></span><span id='topic+summary.sbphylo'></span><span id='topic+print.sbphylo'></span><span id='topic+print.summary.sbphylo'></span>

<h3>Description</h3>

<p>Creating tables of p-values and tree/edge associaitons for phylogenetic inference.
Trees and edges are sorted by the likelihood value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbphylo(relltest,ass,trees,edges,edge2tree,
                   treename=NULL,edgename=NULL,taxaname=NULL,mt=NULL,sort=TRUE) 

## S3 method for class 'sbphylo'
summary(object, k = 2,...)

## S3 method for class 'sbphylo'
print(x,...)

## S3 method for class 'summary.sbphylo'
print(x,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbphylo_+3A_relltest">relltest</code></td>
<td>
<p><code>relltest</code> output.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_ass">ass</code></td>
<td>
<p><code>read.ass</code> output.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_trees">trees</code></td>
<td>
<p><code>relltest</code> output for trees.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_edges">edges</code></td>
<td>
<p><code>relltest</code> output for edges.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_edge2tree">edge2tree</code></td>
<td>
<p><code>read.ass</code> output for &quot;edge to tree&quot; association.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_treename">treename</code></td>
<td>
<p>character vector for tree descriptions.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_edgename">edgename</code></td>
<td>
<p>character vector for edge descriptions.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_taxaname">taxaname</code></td>
<td>
<p>character vector for taxa names.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_mt">mt</code></td>
<td>
<p><code>read.mt</code> output for the site-wise log-likelhiood values.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_sort">sort</code></td>
<td>
<p>sorting trees and edges by likelhiood when TRUE.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_object">object</code></td>
<td>
<p>output of <code>sbphylo</code>.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_k">k</code></td>
<td>
<p>integer of <code class="reqn">k</code> for calculating p-values.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_x">x</code></td>
<td>
<p>sbphylo or summary.sbphylo objects.</p>
</td></tr>
<tr><td><code id="sbphylo_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from other methods.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>First, apply <code>sbphylo</code> to consel results, and <code>summary</code> will make tables.
Output tables are suitable for publication.
For the input of <code>sbphylo</code>, you should specify either of (<code>relltest</code>, <code>ass</code>) or
(<code>trees</code>, <code>edges</code>, <code>edge2tree</code>). 
</p>


<h3>Value</h3>

<p><code>sbphylo</code> returns a list of several information of multiscale bootstrap.
It does not do actual computation, but only sort trees and edges in decreasing order of likelihood values. The compied information is then passed to 
<code>summary</code> method, which returns a list containing character tables and its numerical values of p-values.
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>See Also</h3>

<p><code><a href="#topic+relltest">relltest</a></code>, <code><a href="#topic+read.ass">read.ass</a></code>, <code><a href="#topic+read.mt">read.mt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## working with CONSEL outputs
data(mam15)
mam15.trees &lt;- mam15.relltest[attr(mam15.ass,"trees")]  # 15 trees
mam15.edges &lt;- mam15.relltest[attr(mam15.ass,"edges")]  # 10 edges
mam15.edge2tree &lt;- mam15.ass[attr(mam15.ass,"edges")] # 10 edges
mam15 &lt;- sbphylo(trees=mam15.trees,edges=mam15.edges,
                edge2tree=mam15.edge2tree) # sort trees and edges by likelihood
mam15 # print method for sbphylo
tab &lt;- summary(mam15) # summary method for sbphylo
tab # prints character table

## plot (beta0,beta1)
a1 &lt;- attr(summary(mam15$trees,k=2),"table")
a2 &lt;- attr(summary(mam15$edges,k=2),"table")
beta &lt;- rbind(a1$value,a2$value)[,c("beta0","beta1")]
sbplotbeta(beta) # for diagnostics of p-values
</code></pre>

<hr>
<h2 id='sbpsi'>Model Specification Functions</h2><span id='topic+sbpsi'></span><span id='topic+sbpsi.poly'></span><span id='topic+sbpsi.sing'></span><span id='topic+sbpsi.sphe'></span><span id='topic+sbpsi.generic'></span><span id='topic+sbmodelnames'></span>

<h3>Description</h3>

<p><code>sbpsi.poly</code> and <code>sbpsi.sing</code> are <code class="reqn">\psi</code> functions to
specify a polynomial model and a singular model, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
sbpsi.poly(beta,s=1,k=1,sp=-1,lambda=NULL,aux=NULL,check=FALSE)

sbpsi.sing(beta,s=1,k=1,sp=-1,lambda=NULL,aux=NULL,check=FALSE)

sbpsi.sphe(beta,s=1,k=1,sp=-1,lambda=NULL,aux=NULL,check=FALSE)

sbpsi.generic(beta,s=1,k=1,sp=-1,lambda=NULL,aux=NULL,check=FALSE,zfun,eps=0.01)

sbmodelnames(m=1:3,one.sided=TRUE,two.sided=FALSE,rev.sided=FALSE,
  poly,sing,poa,pob,poc,pod,sia,sib,sic,sid,sphe,pom,sim)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbpsi_+3A_beta">beta</code></td>
<td>
<p>numeric vector of parameters;
<code class="reqn">\beta_0</code>=<code>beta[1]</code>, <code class="reqn">\beta_1</code>=<code>beta[2]</code>,...
<code class="reqn">\beta_{m-1}</code>=<code>beta[m]</code>, where <code class="reqn">m</code> is the number of
parameters.
</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_s">s</code></td>
<td>
<p><code class="reqn">\sigma_0^2</code>.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_k">k</code></td>
<td>
<p>numeric to specify the order of derivatives.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_sp">sp</code></td>
<td>
<p><code class="reqn">\sigma_p^2</code>.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_lambda">lambda</code></td>
<td>
<p>a numeric of specifying the type of p-values; Bayesian (lambda=0) Frequentist (lambda=1).</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_aux">aux</code></td>
<td>
<p>auxiliary parameter. Currently not used.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_check">check</code></td>
<td>
<p>logical for boundary check.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_zfun">zfun</code></td>
<td>
<p>z-value function with (s,beta) as parameters.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_eps">eps</code></td>
<td>
<p>delta for numerical computation of derivatives.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_m">m</code></td>
<td>
<p>numeric vector to specify the numbers of parameters.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_one.sided">one.sided</code></td>
<td>
<p>logical to include poly and sing models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_two.sided">two.sided</code></td>
<td>
<p>logical to include poa and sia models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_rev.sided">rev.sided</code></td>
<td>
<p>logical to include pob and sib models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_poly">poly</code></td>
<td>
<p>maximum number of parameters in poly models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_sing">sing</code></td>
<td>
<p>maximum number of parameters in sing models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_sphe">sphe</code></td>
<td>
<p>maximum number of parameters in sphe models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_poa">poa</code></td>
<td>
<p>maximum number of parameters in poa models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_pob">pob</code></td>
<td>
<p>maximum number of parameters in pob models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_poc">poc</code></td>
<td>
<p>maximum number of parameters in poc models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_pod">pod</code></td>
<td>
<p>maximum number of parameters in pod models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_sia">sia</code></td>
<td>
<p>maximum number of parameters in sia models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_sib">sib</code></td>
<td>
<p>maximum number of parameters in sib models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_sic">sic</code></td>
<td>
<p>maximum number of parameters in sic models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_sid">sid</code></td>
<td>
<p>maximum number of parameters in sid models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_pom">pom</code></td>
<td>
<p>maximum number of parameters in pom models.</p>
</td></tr>
<tr><td><code id="sbpsi_+3A_sim">sim</code></td>
<td>
<p>maximum number of parameters in sim models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code class="reqn">k=1</code>, the <code>sbpsi</code> functions return their <code class="reqn">\psi</code> function
values at <code class="reqn">\sigma^2=\sigma_0^2</code>.  Currently, four types of
<code>sbpsi</code> functions are
implemented. <code>sbpsi.poly</code> defines the polynomial model;
</p>
<p style="text-align: center;"><code class="reqn">\psi(\sigma^2 | \beta) =
    \sum_{j=0}^{m-1} \beta_j \sigma^{2j}</code>
</p>

<p>for <code class="reqn">m\ge1</code>.
<code>sbpsi.sing</code> defines the singular model;
</p>
<p style="text-align: center;"><code class="reqn">\psi(\sigma^2 | \beta) = \beta_0 +
    \sum_{j=1}^{m-2} \frac{\beta_j \sigma^{2j}}{1 + \beta_{m-1}(\sigma-1)}</code>
</p>

<p>for <code class="reqn">m\ge3</code> and <code class="reqn">0\le\beta_{m-1}\le1</code>.
<code>sbpsi.sphe</code> defines the spherical model; currently the number of
parameters must be $m=3$.
<code>sbpsi.generic</code> is a generic sbpsi function for specified <code>zfun</code>.
</p>
<p>For <code class="reqn">k&gt;1</code>, the <code>sbpsi</code> functions return values extrapolated at
<code class="reqn">\sigma^2=\sigma_p^2</code> using derivatives up to order <code class="reqn">k-1</code>
evaluated at <code class="reqn">\sigma^2=\sigma_0^2</code>;
</p>
<p style="text-align: center;"><code class="reqn">q_k = \sum_{j=0}^{k-1} \frac{(\sigma_p^2-\sigma_0^2)^j}{j!}
    \frac{d^j \psi(x|\beta)}{d x^j}\Bigr|_{\sigma_0^2},</code>
</p>

<p>which reduces to <code class="reqn">\psi(\sigma_0^2|\beta)</code> for <code class="reqn">k=1</code>. In the
<code><a href="#topic+summary.scaleboot">summary.scaleboot</a></code>, the AU p-values are defined
by <code class="reqn">p_k = 1-\Phi(q_k)</code> for <code class="reqn">k\ge1</code>.
</p>


<h3>Value</h3>

<p><code>sbpsi.poly</code> and <code>sbpsi.sing</code> are examples of a sbpsi
function; users can develop their own sbpsi functions for better
model fitting by preparing <code>sbpsi.foo</code> and <code>sbini.foo</code>
functions for model <code>foo</code>.
If check=FALSE, a sbpsi function returns
the <code class="reqn">\psi</code> function value or the extrapolation value.
If check=TRUE, a sbpsi function returns NULL when all
the elements of beta are included in the their valid
intervals. Otherwise, a <code>sbpsi</code> function returns a list with components
<code>beta</code> for the parameter value being modified to be on a boundary
of the interval and <code>mask</code>, a logical vector indicating which
elements are not on the boundary.
</p>
<p><code>sbmodelnames</code> returns a character vector of model names.
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbfit">sbfit</a></code>.</p>

<hr>
<h2 id='sbpval'>Extract P-values</h2><span id='topic+sbpval'></span><span id='topic+sbpval.summary.scaleboot'></span><span id='topic+sbpval.summary.scalebootv'></span>

<h3>Description</h3>

<p><code>sbpval</code> extracts p-values from <code>"summary.scaleboot"</code> or
<code>"summary.scalebootv"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbpval(x, ...)

## S3 method for class 'summary.scaleboot'
sbpval(x,select=c("average","best","all"),...)

## S3 method for class 'summary.scalebootv'
sbpval(x,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbpval_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="sbpval_+3A_select">select</code></td>
<td>
<p>character. If &quot;average&quot; or &quot;best&quot;, only the p-values of
corresponding models are returned. If &quot;all&quot;, then p-values of all
the models are returned.</p>
</td></tr>
<tr><td><code id="sbpval_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>This method is used only to extract previously calculated p-values from the
summary object.
</p>


<h3>Value</h3>

<p>The <code>sbpval</code> method for the class <code>"summary.scaleboot"</code> returns a
list of three components (pvalue, sd, hypothesis).
pvalue is a vector of pvalues 
<code class="reqn">p_k</code> for <code class="reqn">k</code> as specified in the <code>summary</code> method.
sd is a vector of their standard errors.
hypothesis is either &quot;null&quot; or &quot;alternative&quot; for the selective inference.
</p>
<p>The <code>sbpval</code> method for the class <code>"summary.scalebootv"</code> returns a
list of the three components, where pvalue and sd are matrices
and hypothesis is a vector.
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.scaleboot">summary.scaleboot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mam15)
a &lt;- mam15.relltest[["t4"]] # an object of class "scaleboot"
b &lt;- summary(a) # calculate p-values
b # print the p-values
sbpval(b) # extract a vector of p-values which are averaged by Akaike weights.
sbpval(b,select="all") # extract a matrix of p-values
</code></pre>

<hr>
<h2 id='scaleboot'>Multiscale Bootstrap Resampling</h2><span id='topic+scaleboot'></span><span id='topic+countw.assmax'></span><span id='topic+countw.shtest'></span><span id='topic+countw.shtestass'></span>

<h3>Description</h3>

<p>Performs multiscale bootstrap resampling for a specified statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
scaleboot(dat,nb,sa,fun,parm=NULL,count=TRUE,weight=TRUE,
          cluster=NULL,onlyboot=FALSE,seed=NULL,...)

countw.assmax(x,w,ass)

countw.shtest(x,w,obs)

countw.shtestass(x,w,assobs)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleboot_+3A_dat">dat</code></td>
<td>
<p>data matrix or data-frame. Row vectors are to be resampled.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_nb">nb</code></td>
<td>
<p>vector of the numbers of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_sa">sa</code></td>
<td>
<p>vector of scales in sigma squared (<code class="reqn">\sigma^2</code>).</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_fun">fun</code></td>
<td>
<p>function for a statistic.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_parm">parm</code></td>
<td>
<p>parameter to be passed to <code>fun</code> above.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_count">count</code></td>
<td>
<p>logical. Should only the accumulative counts be returned?
Otherwise, raw statistic vectors are returned.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_weight">weight</code></td>
<td>
<p>logical. In <code>fun</code> above, resampling is specified by
a weight vector. Otherwise, resampling is specified by a vector of indices.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_cluster">cluster</code></td>
<td>
<p><span class="pkg">parallel</span> cluster object which may be generated by
function <code>makeCluster</code>.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_onlyboot">onlyboot</code></td>
<td>
<p>logical. Should only bootstrap resampling be
performed? Otherwise, <code><a href="#topic+sbfit">sbfit</a></code> or <code><a href="#topic+sbconf">sbconf</a></code>
is called internally.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_seed">seed</code></td>
<td>
<p>If non NULL, random seed is set. Specifying a seed is
particularly important when <code>cluster</code> is non NULL, in which
case <code>seed + seq(along=cluster)</code> are set to cluster nodes.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from other methods.</p>
</td></tr>  
<tr><td><code id="scaleboot_+3A_x">x</code></td>
<td>
<p>data matrix or data-frame passed from <code><a href="#topic+scaleboot">scaleboot</a></code>.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_w">w</code></td>
<td>
<p>weight vector for resampling.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_ass">ass</code></td>
<td>
<p>a list of association vectors. An example of <code>parm</code> above.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_obs">obs</code></td>
<td>
<p>a vector of observed test statistics. An example of <code>parm</code> above.</p>
</td></tr>
<tr><td><code id="scaleboot_+3A_assobs">assobs</code></td>
<td>
<p>a list of ass and obs above. An example of <code>parm</code> above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used internally by <code><a href="#topic+relltest">relltest</a></code>
for computing raw bootstrap probabilities of phylogenetic inference.
Alternatively, we used <code>pvclust</code> to get raw bootstrap probabilities
of hierarchical clustering. In other cases, users may utilize
<code>scaleboot</code> function or prepare their own functions.
</p>
<p><code>scaleboot</code> performs multiscale bootstrap resampling for a
statistic defined by <code>fun</code>, which should be one of the two
possible forms <code>fun(x,w,parm)</code> and <code>fun(x,i,parm)</code>. The former
is used when <code>weight=TRUE</code>, and the weight
vector <code>w</code> is generated by a multinomial distribution. The latter
is used when <code>weight=FALSE</code>, and the index
vector <code>i</code> is generated by resampling <code class="reqn">n'</code> elements from
<code class="reqn">\{1,...,n\}</code>. When <code>count=TRUE</code>, <code>fun</code> should return
a logical, or a vector of logicals.
</p>
<p>Examples of <code>fun(x,w,parm)</code> are <code>countw.assmax</code> for AU p-values,
<code>countw.shtest</code> for SH-test of trees, and <code>countw.shtestass</code>
for SH-test of both trees and edges. The definitions are given below.
</p>
<pre>
countw.assmax &lt;- function(x,w,ass) {
  y &lt;- maxdif(wsumrow(x,w)) &lt;= 0 # countw.max
  if(is.null(ass)) y
  else {
    z &lt;- vector("logical",length(ass))
    for(i in seq(along=ass)) z[i] &lt;- any(y[ass[[i]]])
    z
  }
}

countw.shtest &lt;- function(x,w,obs)  maxdif(wsumrow(x,w)) &gt;= obs

countw.shtestass &lt;- function(x,w,assobs)
  unlist(assmaxdif(wsumrow(x,w),assobs$ass)) &gt;= assobs$obs
    
### weighted sum of row vectors
##
## x = matrix (array of row vectors)
## w = weight vector (for rows)
##
wsumrow &lt;- function(x,w) {
  apply(w*x,2,sum)*nrow(x)/sum(w)
}

### calc max diff
##
## y[i] := max_{j neq i} x[j] - x[i]
##
maxdif &lt;- function(x) {
  i1 &lt;- which.max(x)  # the largest element
  x &lt;- -x + x[i1]
  x[i1] &lt;- -min(x[-i1])  # the second largest value
  x
}

### calc assmaxdif
##
## y[[i]][j] := max_{k neq ass[[i]]} x[k] - x[ass[[i]][j]]
##
assmaxdif &lt;-  function(x,a) {
  y &lt;- vector("list",length(a))
  names(y) &lt;- names(a)
  for(i in seq(along=a))  y[[i]] &lt;- max(x[-a[[i]]]) - x[a[[i]]]
  y
}
</pre>
<p>When <code>count=TRUE</code>, the summation of outputs from <code>fun</code> is
calculated. This gives the frequencies for how many times the
hypotheses are supported by the bootstrap replicates.
</p>


<h3>Value</h3>

<p>If <code>onlyboot=TRUE</code>, then a list of raw results from the multiscale bootstrap
resampling is returned. The components are &quot;stat&quot; for list vectors of
outputs from <code>fun</code> (only when <code>count=FALSE</code>), &quot;bps&quot; for a
matrix of multiscale bootstrap probabilities (only when
<code>count=FALSE</code>), &quot;nb&quot; for the number of bootstrap replicates used,
and &quot;sa&quot; for the scales used. Note that scales are redefined by
<code>sa &lt;- nsize/round(nsize/sa)</code>, where <code>nsize</code> is the sample size.
</p>
<p>If <code>onlyboot=FALSE</code>, then the result of a call to 
<code><a href="#topic+sbfit">sbfit</a></code> is returned when  <code>count=TRUE</code>, otherwise
the result of <code><a href="#topic+sbconf">sbconf</a></code> is returned when  <code>count=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbfit">sbfit</a></code>, <code><a href="#topic+sbconf">sbconf</a></code>, <code><a href="#topic+relltest">relltest</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## An example to calculate AU p-values for phylogenetic trees
## See also the Examples of "sbconf"
data(mam15) # load mam15.mt
sa &lt;- 9^seq(-1,1,length=13) # parameter for multiscale bootstrap
nb &lt;- 1000 # nb=10000 is better but slower
# Now compute bootstrap probabilities and fit models to them
sim &lt;- scaleboot(mam15.mt,nb,sa,countw.assmax) # takes some time (&lt; 1 min)
sim # show bootstrap probabilities and model fitting
summary(sim) # show AU p-vaslues

## End(Not run)

## Not run: 
## The following lines are only for illustration purpose
## a line from the definition of relltest
scaleboot(dat,nb,sa,countw.assmax,ass,cluster=cluster,
                 names.hp=na,nofit=nofit,models=models,seed=seed)

## two lines from rell.shtest (internal function)
scaleboot(z,nb,1,countw.shtest,tobs,cluster=cluster,
                 onlyboot=TRUE,seed=seed)
scaleboot(z,nb,1,countw.shtestass,pa,cluster=cluster,
                 onlyboot=TRUE,seed=seed)

## End(Not run)
</code></pre>

<hr>
<h2 id='scaleboot-package'>
Approximately Unbiased P-values via Multiscale Bootstrap
</h2><span id='topic+scaleboot-package'></span>

<h3>Description</h3>

<p>Calculating approximately unbiased (AU) p-values from
multiscale bootstrap probabilities.
</p>


<h3>Details</h3>

<p>For a complete
list, use <code>library(help="scaleboot")</code>.
</p>
<p>The methodology is described in Shimodiara (2008). For the use of
<code>scaleboot</code>, Shimodaira (2008) may be referenced.
</p>
<p>Further information is available in the following vignette:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>usesb</code> </td><td style="text-align: left;"> Multiscale Bootstrap using Scaleboot Package</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira
</p>
<p>Maintainer: Hidetoshi Shimodaira &lt;shimo@i.kyoto-u.ac.jp&gt;
</p>
<p>I thank Paul A. Sheridan for his comments to improve the manual pages.
</p>


<h3>References</h3>

<p>Shimodaira, H. (2008). Testing Regions with Nonsmooth Boundaries via
Multiscale Bootstrap, <em>Journal of Statistical Planning and
Inference</em>, 138, 1227-1241.
(<a href="http://dx.doi.org/10.1016/j.jspi.2007.04.001">http://dx.doi.org/10.1016/j.jspi.2007.04.001</a>).
</p>

<hr>
<h2 id='summary.scaleboot'>P-value Calculation for Multiscale Bootstrap</h2><span id='topic+summary.scaleboot'></span><span id='topic+summary.scalebootv'></span><span id='topic+print.summary.scaleboot'></span><span id='topic+print.summary.scalebootv'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"scaleboot"</code> and <code>"scalebootv"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'scaleboot'
summary(object,models=names(object$fi),k=3,sk=k,s=1,sp=-1,
              hypothesis=c("auto","null","alternative"),
              type=c("Frequentist","Bayesian"),...)

## S3 method for class 'scalebootv'
summary(object,models=attr(object,"models"),k=3,sk=k,
              hypothesis="auto",type="Frequentist", select="average",...)

## S3 method for class 'summary.scaleboot'
print(x,sort.by=c("aic","none"),verbose=FALSE,...)

## S3 method for class 'summary.scalebootv'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.scaleboot_+3A_object">object</code></td>
<td>
<p>an object used to select a method. </p>
</td></tr>
<tr><td><code id="summary.scaleboot_+3A_models">models</code></td>
<td>
<p>character vector of model names. If numeric,
<code>names(object$fi)[models]</code> is used for each <code>"scaleboot"</code> object.</p>
</td></tr>
<tr><td><code id="summary.scaleboot_+3A_k">k</code></td>
<td>
<p>numeric vector of <code class="reqn">k</code> for calculating p-values.</p>
</td></tr>
<tr><td><code id="summary.scaleboot_+3A_sk">sk</code></td>
<td>
<p>numeric vector of <code class="reqn">k</code> for calculating selective inference p-values.</p>
</td></tr>
<tr><td><code id="summary.scaleboot_+3A_s">s</code></td>
<td>
<p><code class="reqn">\sigma_0^2</code></p>
</td></tr>
<tr><td><code id="summary.scaleboot_+3A_sp">sp</code></td>
<td>
<p><code class="reqn">\sigma_p^2</code></p>
</td></tr>
<tr><td><code id="summary.scaleboot_+3A_hypothesis">hypothesis</code></td>
<td>
<p>specifies type of selective infernece.
&quot;null&quot; takes the region as null hypothesis, and &quot;alternative&quot; takes the region as alternative hypothesis.
&quot;auto&quot; determins it by the sign of beta0. The selectice pvalues (<code>sk.1</code>, <code>sk.2</code>, ...) are selective pvalues when &quot;null&quot;, and they are one minus selective pvalues when &quot;alternative&quot;.</p>
</td></tr>
<tr><td><code id="summary.scaleboot_+3A_type">type</code></td>
<td>
<p>If numeric, it is passed to <code>sbpsi</code> functions as
<code>lambda</code> to specify p-value type. If &quot;Frequentist&quot; or
&quot;Bayesian&quot;, then equivalent to specifying <code>lambda</code> = 1 or 0,
respectively.</p>
</td></tr>
<tr><td><code id="summary.scaleboot_+3A_select">select</code></td>
<td>
<p>character of model name (such as &quot;poly.3&quot;) or one of
&quot;average&quot; and &quot;best&quot;. If &quot;average&quot; or &quot;best&quot;, then the averaging by
Akaike weights or the best model is used, respectively.</p>
</td></tr>
<tr><td><code id="summary.scaleboot_+3A_x">x</code></td>
<td>
<p>object.</p>
</td></tr>
<tr><td><code id="summary.scaleboot_+3A_sort.by">sort.by</code></td>
<td>
<p>sort key.</p>
</td></tr>
<tr><td><code id="summary.scaleboot_+3A_verbose">verbose</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="summary.scaleboot_+3A_...">...</code></td>
<td>
<p>further arguments passed to and from other methods.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p> For each model, a class of approximately unbiased p-values,
indexed by <code class="reqn">k=1,2,...</code>, is calculaed.  The p-values are named 
<code>k.1</code>, <code>k.2</code>, ..., where <code class="reqn">k=1</code> (<code>k.1</code>) corresponds to
the ordinary bootstrap probability, and <code class="reqn">k=2</code> (<code>k.2</code>)
corresponds to the third-order accurate p-value of Shimodaira (2002). As the
<code class="reqn">k</code> value increases, the bias of testing decreases, although the
p-value becomes less stable numerically and the monotonicity of rejection
regions becomes worse. Typically, <code class="reqn">k=3</code> provides a reasonable
compromise. The <code><a href="#topic+sbpval">sbpval</a></code> method is available to extract p-values from
the <code>"summary.scaleboot"</code> object.
</p>
<p>The p-value is defined as
</p>
<p style="text-align: center;"><code class="reqn"> p_k = 1 - \Phi\left( \sum_{j=0}^{k-1}
\frac{(\sigma_p^2-\sigma_0^2)^j}{j!}  \frac{d^j \psi(x|\beta)}{d
x^j}\Bigr|_{\sigma_0^2} \right),</code>
</p>
<p> where <code class="reqn">\psi(\sigma^2|\beta)</code> is the
model specification function, <code class="reqn">\sigma_0^2</code> is the evaluation point
for the Taylor series, and <code class="reqn">\sigma_p^2</code> is an additional
parameter. Typically, we do not change the default values
<code class="reqn">\sigma_0^2=1</code> and <code class="reqn">\sigma_p^2=-1</code>.
</p>
<p>The p-values are justified only for good fitting models. By default,
the model which minimizes the AIC value is selected. We can modify the
AIC value by using the <code>sbaic</code> function. We also diagnose the
fitting by using the <code>plot</code> method.
</p>
<p>Now includes selective inference p-values.
The method is described in Terada and Shimodaira (2017; arXiv:1711.00949)
&quot;Selective inference for the problem of regions via multiscale bootstrap&quot;.
</p>


<h3>Value</h3>

<p><code>summary.scaleboot</code> returns
an object of the class <code>"summary.scaleboot"</code>, which is inherited
from the class <code>"scaleboot"</code>. It is a list containing all the components of class
<code>"scaleboot"</code> and the following components:
</p>
<table>
<tr><td><code>pv</code></td>
<td>
<p>matrix of p-values of size <code>length(models)</code> *
<code>length(k)</code> with elements <code class="reqn">p_k</code>.</p>
</td></tr>
<tr><td><code>pe</code></td>
<td>
<p>matrix of standard errors of p-values.</p>
</td></tr>
<tr><td><code>spv</code></td>
<td>
<p>matrix of selective inference p-values of size <code>length(models)</code> *
<code>length(sk)</code> with elements <code class="reqn">sp_k</code>.</p>
</td></tr>
<tr><td><code>spe</code></td>
<td>
<p>matrix of standard errors of selective inference p-values.</p>
</td></tr>
<tr><td><code>betapar</code></td>
<td>
<p>list array containing (beta0, beta1) and its covariance matrix
for each model. They are obtained by linear extrapolation.
This will be used for interpreting the fitting in terms of signed distance and curvature.</p>
</td></tr>
<tr><td><code>best</code></td>
<td>
<p> a list consisting of components <code>model</code> for the best
fitting model name, <code>aic</code> for its AIC value, <code>pv</code> and <code>spv</code> for 
vector of p-values, and <code>pe</code> and <code>spe</code> for vectors of standard errors.
Also includes <code>betapar</code> for the best model.</p>
</td></tr>
<tr><td><code>average</code></td>
<td>
<p> a list of results for the average model computed by Akaike weight.</p>
</td></tr>
<tr><td><code>parex</code></td>
<td>
<p>a list of components <code>k</code>, <code>s</code>, and <code>sp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hidetoshi Shimodaira</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbfit">sbfit</a></code>, <code><a href="#topic+sbpsi">sbpsi</a></code>, <code><a href="#topic+sbpval">sbpval</a></code>,
<code><a href="#topic+sbaic">sbaic</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mam15)
## For a single hypothesis
a &lt;- mam15.relltest[["t4"]] # an object of class "scaleboot"
summary(a) # calculate and print p-values (k=3)
summary(a,k=2) # calculate and print p-values (k=2)
summary(a,k=1:4) # up to "k.4" p-value.

## For multiple hypotheses
b &lt;- mam15.relltest[1:15] # an object of class "scalebootv"
summary(b) # calculate and print p-values (k=3)
summary(b,k=1:4) # up to "k.4" p-value.

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
