<!DOCTYPE html><html><head><title>Help for package BaSTA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BaSTA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BaSTA-package'>
<p>BaSTA: Parametric Bayesian estimation of age-specific survival for truncated and censored capture-recapture or census data.</p></a></li>
<li><a href='#basta'>
<p>Parametric Bayesian estimation of age-specific survival for left-truncated and</p>
right-censored capture-mark-recapture or census data.</a></li>
<li><a href='#bastaCensDat'>
<p>Example of census data for BaSTA analysis.</p></a></li>
<li><a href='#bastaCensOut'>
<p>Output from a Bayesian Survival Trajectory Analysis (BaSTA) analysis on a simulated census dataset.</p></a></li>
<li><a href='#bastaCMRdat'>
<p>Example of capture-mark-recapture data for BaSTA analysis.</p></a></li>
<li><a href='#bastaCMRout'>
<p>Output from a Bayesian Survival Trajectory Analysis (BaSTA) analysis on a simulated capture-mark-recapture (CMR) dataset.</p></a></li>
<li><a href='#CensusToCaptHist'>
<p>Constructs a capture-history matrix from repeated individual observations to be used in Bayesian Survival Trajectory Analysis (BaSTA).</p></a></li>
<li><a href='#DataCheck'>
<p>Error checking for BaSTA input data.</p></a></li>
<li><a href='#FixCMRdata'>
<p>Fix issues on CMR input data for BaSTA.</p></a></li>
<li><a href='#summary.basta'>
<p>Summarizing and plotting Bayesian Survival Trajectory Analysis (BaSTA) model outputs.</p></a></li>
<li><a href='#summary.bastaCheckCMR'>
<p>Summary of outputs from the data checking function in BaSTA.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Age-Specific Bayesian Survival Trajectory Analysis from
Incomplete Census or Capture-Recapture/Recovery Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-05</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>snowfall (&ge; 1.84-6-2)</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates survival and mortality with covariates from census or capture-recapture/recovery data in a Bayesian framework when many individuals are of unknown age. It includes tools for data checking, model diagnostics and outputs such as life-tables and plots, as described in Colchero, Jones, and Rebke (2012) &lt;<a href="https://doi.org/10.1111%2Fj.2041-210X.2012.00186.x">doi:10.1111/j.2041-210X.2012.00186.x</a>&gt; and Colchero et al. (2021) &lt;<a href="https://doi.org/10.1038%2Fs41467-021-23894-3">doi:10.1038/s41467-021-23894-3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-08 08:47:00 UTC; fernando_colchero</td>
</tr>
<tr>
<td>Author:</td>
<td>Fernando Colchero [aut, cre],
  Owen Jones [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fernando Colchero &lt;fernando_colchero@eva.mpg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-08 11:00:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='BaSTA-package'>
BaSTA: Parametric Bayesian estimation of age-specific survival for truncated and censored capture-recapture or census data.
</h2><span id='topic+BaSTA-package'></span><span id='topic+BaSTA'></span>

<h3>Description</h3>

<p>This package estimates age-specific mortality and survival trajectories with covariates from capture-recapture/recovery or census data under a Bayesian framework when many individuals are of unknown age. It includes tools for data checking, model diagnostics, and outputs such as life-tables and plots.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
	Package: </td><td style="text-align: left;"> BaSTA </td>
</tr>
<tr>
 <td style="text-align: left;">
	Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
	Version: </td><td style="text-align: left;"> 2.0.0</td>
</tr>
<tr>
 <td style="text-align: left;">
	Date: </td><td style="text-align: left;"> 2024-07-05</td>
</tr>
<tr>
 <td style="text-align: left;">
	License: </td><td style="text-align: left;"> GNU General Public Licence</td>
</tr>
<tr>
 <td style="text-align: left;">
	LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Parametric estimation of age-specific survival and mortality from capture-mark-recapture or census data including individuals with unknown times of birth and death.
</p>


<h3>Author(s)</h3>

<p>Fernando Colchero <a href="mailto:fernando_colchero@eva.mpg.de">fernando_colchero@eva.mpg.de</a></p>


<h3>References</h3>

<p>Colchero, F. and J.S. Clark (2012) Bayesian inference on age-specific survival from capture-recapture data for censored and truncated data. <em>Journal of Animal Ecology</em> 81, 139-149.
</p>
<p>Colchero, F., O.R Jones and M. Rebke. (2012) BaSTA: an R package for Bayesian estimation of age-specific survival from incomplete mark-recapture/recovery data with covariates. <em>Methods in Ecology and Evolution</em> 3, 466-470.
</p>
<p>Colchero, F., <em>et al.</em>  (2021) The long lives of primates and the &quot;invariant rate of aging&quot; hypothesis. <em>Nature Communications</em> 12:3666
</p>

<hr>
<h2 id='basta'>
Parametric Bayesian estimation of age-specific survival for left-truncated and 
right-censored capture-mark-recapture or census data.
</h2><span id='topic+basta'></span><span id='topic+basta.default'></span>

<h3>Description</h3>

<p>This function performs multiple Markov Chain Monte Carlo (MCMC) simulations for the Bayesian estimation of age-specific mortality and survival when a large proportion of records have unknown times of birth and/or death. Survival parameters and unknown (i.e. latent) birth (and death, for CMR data) times are estimated, allowing the user to test a range of mortality patterns, and to test the effect of continuous and/or discrete covariates following Colchero and Clark's (2012) general approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basta(object, ...)

## Default S3 method:
 basta(object, dataType = "CMR", model = "GO", 
  shape = "simple",  studyStart = NULL, studyEnd = NULL, 
  minAge = 0, covarsStruct = "fused",  formulaMort = NULL, 
  formulaRecap = NULL, recaptTrans = studyStart,  niter = 22000, 
  burnin = 2001, thinning = 40, nsim = 1, parallel = FALSE,  
  ncpus = 2, updateJumps = TRUE, negSenescence = FALSE,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basta_+3A_object">object</code></td>
<td>
<p>A <code>data.frame</code> to be used as an input data file for BaSTA. Note: BaSTA can take two types of datasets, namely capture-mark-recapture (CMR) or census data. See <code>details</code> for a description of the data structures. </p>
</td></tr>
<tr><td><code id="basta_+3A_datatype">dataType</code></td>
<td>
<p>A <code>character string</code> indicating if the data are for capture-mark-recapture (CMR) or census. Options are &ldquo;<code>CMR</code>&rdquo; (default) or &ldquo;<code>census</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="basta_+3A_model">model</code></td>
<td>
<p>The underlying mortality model to be used. <code>"EX"</code> = exponential,<code>"GO"</code> = Gompertz, <code>"WE"</code> = Weibull and <code>"LO"</code> = logistic (see <code>details</code>).</p>
</td></tr>
<tr><td><code id="basta_+3A_shape">shape</code></td>
<td>
<p>The overall shape of the model. Values are: <code>simple</code> = no extra parameters added; <code>Makeham</code> = a constant parameter is added to the mortality; and <code>bathtub</code> = a Gompertz declining mortality for early ages and a constant parameter are added to the mortality model (see <code>details</code>).</p>
</td></tr>
<tr><td><code id="basta_+3A_studystart">studyStart</code></td>
<td>
<p>Only required for <code>dataType =</code> &ldquo;<code>CMR</code>&rdquo;, an integer indicating the first year of the study.</p>
</td></tr>
<tr><td><code id="basta_+3A_studyend">studyEnd</code></td>
<td>
<p>Only required for <code>dataType =</code> &ldquo;<code>CMR</code>&rdquo;, an integer indicating the last year of the study.</p>
</td></tr>
<tr><td><code id="basta_+3A_minage">minAge</code></td>
<td>
<p>Age at which the analysis should start (see <code>details</code>).</p>
</td></tr>
<tr><td><code id="basta_+3A_covarsstruct">covarsStruct</code></td>
<td>
<p>Character string that indicates how covariates should be evaluated. The options are: &ldquo;<code>fused</code>&rdquo;, which defines all categorical variables as covariates for each mortality parameter and all continuous covariates under a proportional hazards structure; &ldquo;<code>prop.haz</code>&rdquo;, which puts all covariates under a proportional hazards structure; and &ldquo;<code>all.in.mort</code>&rdquo; puts all covariates as a multilevel function of the mortality parameters (see <code>details</code>).</p>
</td></tr>
<tr><td><code id="basta_+3A_formulamort">formulaMort</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code> specifying the covariates to be included on the mortality part of the model. Note that the syntax should not include a dependent variable. If <code>formulaMort = NULL</code>, then no covariates are included in the analysis. See <code>details</code>.</p>
</td></tr>
<tr><td><code id="basta_+3A_formularecap">formulaRecap</code></td>
<td>
<p><em>Not yet implemented</em>, an object of class <code><a href="stats.html#topic+formula">formula</a></code> specifying the covariates to be included on the recapture part of the model. Note that the syntax should not include a dependent variable. If <code>formulaMort = NULL</code>, then no covariates are included in the analysis.</p>
</td></tr>
<tr><td><code id="basta_+3A_recapttrans">recaptTrans</code></td>
<td>
<p>A vector (of maximum length equal to the duration of the study) defining the recapture probability transition times (RPTP). These are points (years) where the recapture probability is thought to change.  The default setting is for the recapture probability to be constant throughout the study, so the <code>recaptTrans</code> is simply defined as a single element vector of the first year of the observation period (e.g. c(1985)). If recapture probabilities were known to change at year say, 1990, the RPTP should be defined as c(1985, 1990).</p>
</td></tr>
<tr><td><code id="basta_+3A_niter">niter</code></td>
<td>
<p>The total number of MCMC steps.</p>
</td></tr>
<tr><td><code id="basta_+3A_burnin">burnin</code></td>
<td>
<p>The number of iterations for the burn in (see <code>details</code>).</p>
</td></tr>
<tr><td><code id="basta_+3A_thinning">thinning</code></td>
<td>
<p>The number of skipped MCMC steps to minimize serial autocorrelation (see <code>details</code>).</p>
</td></tr>
<tr><td><code id="basta_+3A_nsim">nsim</code></td>
<td>
<p>A numerical value for the number of simulations to be run.</p>
</td></tr>
<tr><td><code id="basta_+3A_parallel">parallel</code></td>
<td>
<p>A logical argument indicating whether the multiple simulations should be run in parallel or not. If <code>TRUE</code>, package <span class="pkg">snowfall</span> is called and multiple simulations are run in parallel. If <span class="pkg">snowfall</span> is not installed, the model is ran in series.</p>
</td></tr>
<tr><td><code id="basta_+3A_ncpus">ncpus</code></td>
<td>
<p>a numerical value that indicates the number of cpus to be used if <code>parallel</code> is <code>TRUE</code> and package <span class="pkg">snowfall</span> is installed. The default is 2 cpus. If package <span class="pkg">snowfall</span> is not installed, the simulations are run in series.</p>
</td></tr>
<tr><td><code id="basta_+3A_updatejumps">updateJumps</code></td>
<td>
<p>A logical argument indicating wheter to update jump standard deviations (adaptive independent Metropolis) until an update rate of 0.25 is achieved (see <code>details</code>). </p>
</td></tr>
<tr><td><code id="basta_+3A_negsenescence">negSenescence</code></td>
<td>
<p>Logical indicating if negative senescence should be allowed, only applicable for <code>model</code> = &ldquo;<code>GO</code>&rdquo; and <code>shape</code> = &ldquo;<code>Makeham</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="basta_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to function <code>basta</code> (see <code>details</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>1) DATA TYPES:</b>
</p>
<p>The input <code>object</code> required by BaSTA needs to be constructed differently whether the data are of capture-mark-recapture or census. 
</p>
<p><code>1.1) capture-mark-recapture (CMR):</code>
</p>
<p>If <code>dataType</code> = &ldquo;<code>CMR</code>&rdquo;, then the data frame requires the following structure. The first column is a vector of individual unique IDs, the second and third columns are birth and death years respectively. Columns <code class="reqn">4, \dots, T+3</code> represent the observation window (i.e., recapture matrix) of <code class="reqn">T</code> years. This is followed (optionally) by columns for categorical and continuous covariates (see <code><a href="#topic+bastaCMRdat">bastaCMRdat</a></code> for a CMR dataset example).
</p>
<p><code>1.2) Census:</code>
</p>
<p>If <code>dataType</code> = &ldquo;<code>census</code>&rdquo;, then the input data <code>object</code> requires at least five dates columns, namely &ldquo;Birth.Date&rdquo;, &ldquo;Min.Birth.Date&rdquo;, &ldquo;Max.Birth.Date&rdquo;, &ldquo;Entry.Date&rdquo;, and &ldquo;Depart.Date&rdquo;. All dates need to be format as &ldquo;%Y-%m-%d&rdquo;. In addition, a &ldquo;Depart.Type&rdquo; column is required with two types of departures &ldquo;C&rdquo; for Censored and &ldquo;D&rdquo; for dead (see <code><a href="#topic+bastaCensDat">bastaCensDat</a></code> for a census dataset example).
</p>
<p><b>2) AGE-SPECIFIC MORTALITY MODELS:</b>
</p>
<p><code>basta</code> performs Bayesian inference on parametric age-specific mortality and survival when not all ages are known (Colchero and Clark 2012, Colchero <em>et al.</em> 2012, Colchero <em>et al.</em> 2021). The mortality function describes how the risk of mortality changes with age, and is defined as 
</p>
<p style="text-align: center;"><code class="reqn">
\mu(x | \theta) = \lim_{\Delta x \rightarrow 0} \frac{\Pr[x &lt; X &lt; x + \Delta x | X &gt; x]}{\Delta x},
</code>
</p>

<p>where <code class="reqn">X</code> is a random variable for ages at death, <code class="reqn">x \geq 0</code> are ages and <code class="reqn">\theta</code> is the vector of mortality parameters. From the mortality function, the survival function is then given by
</p>
<p style="text-align: center;"><code class="reqn">
S(x | \bm{\theta}) = \exp[-\int_0^x \mu(t | \bm{\theta}) dt].
</code>
</p>

<p><code>2.1)</code><code>Argument </code>&ldquo;<code>model</code>&rdquo;<code>:</code>
</p>
<p>The <code>model</code> argument allows the user to choose between four basic mortality functions, namely 
</p>
<p>(a) <code>model = </code>&ldquo;<code>EX</code>&rdquo;: The exponential model (Cox and Oakes 1974), with constant mortality with age, specified as
</p>
<p style="text-align: center;"><code class="reqn">\mu_b(x | \bm{\theta}) = b,</code>
</p>

<p>where <code class="reqn">b &gt; 0</code>, with survival 
</p>
<p style="text-align: center;"><code class="reqn">
S_b(x | \bm{\theta}) = \exp[-b x].
</code>
</p>

<p>(b) <code>model = </code>&ldquo;<code>GO</code>&rdquo;: The Gompertz mortality model (Gompertz 1925, Pletcher 1999), calculated as 
</p>
<p style="text-align: center;"><code class="reqn">\mu_b(x | \bm{\theta}) = \exp(b_0 + b_1 x),</code>
</p>

<p>where <code class="reqn">-\infty &lt; b_0, b_1 &lt; \infty</code>, with survival
</p>
<p style="text-align: center;"><code class="reqn">
S_b(x | \bm{\theta}) = \exp\left[\frac{e^{b_0}}{b_1}\left(1 - e^{b_1 x}\right)\right].
</code>
</p>

<p>(c) <code>model = </code>&ldquo;<code>WE</code>&rdquo;: The Weibull mortality model (Pinder III <em>et al.</em> 1978) calculated as
</p>
<p style="text-align: center;"><code class="reqn">\mu_b(x | \bm{\theta}) = b_0 b_1^{b_0} x^{b_0 -1},</code>
</p>

<p>where <code class="reqn">b_0, b_1 &gt; 0</code>, with survival
</p>
<p style="text-align: center;"><code class="reqn">
S_b(x | \bm{\theta}) = \exp\left[-(b_1 x)^{b_0}\right].
</code>
</p>

<p>(d) <code>model = </code>&ldquo;<code>LO</code>&rdquo;: The logistic mortality model (Pletcher 1999), calculated as 
</p>
<p style="text-align: center;"><code class="reqn">\mu_b(x | \bm{\theta}) = \frac{\exp(b_0 + b_1 x)}{1 + b_2 \frac{e^{b_0}}{b_1} \left(e^{b_1 x}-1\right)},</code>
</p>

<p>where <code class="reqn">b_0, b_1, b_2 &gt; 0</code>, with survival
</p>
<p style="text-align: center;"><code class="reqn">
S_b(x | \bm{\theta}) = \left[1 + b_2 \frac{e^{b_0}}{b_1} \left(e^{b_1 x} - 1\right)\right]^{-1 / b_2}.
</code>
</p>

<p><code>2.2)</code><code>Argument </code>&ldquo;<code>shape</code>&rdquo;<code>:</code>
</p>
<p>The <code>shape</code> argument allows the user to extend these models in order to explore more complex mortality shapes. 
</p>
<p>(a) <code>shape = </code>&ldquo;<code>simple</code>&rdquo;: (default) Leaves the model as defined above, with mortality given by
</p>
<p style="text-align: center;"><code class="reqn">
\mu(x | \bm{\theta}) = \mu_b(x | \bm{\theta})
</code>
</p>

<p>and survival
</p>
<p style="text-align: center;"><code class="reqn">
S(x | \bm{\theta}) = S_b(x | \bm{\theta}.
</code>
</p>

<p>(b) <code>shape = </code>&ldquo;<code>Makeham</code>&rdquo;: A constant is added to the mortality, such that the mortality is given by
</p>
<p style="text-align: center;"><code class="reqn">
\mu(x | \bm{\theta}) = c + \mu_b(x | \bm{\theta}_1),
</code>
</p>

<p>where <code class="reqn">\bm{\theta} = [c, \bm{\theta}_1]</code>, and with survival
</p>
<p style="text-align: center;"><code class="reqn">
S(x | \bm{\theta}) = e^{-cx} S_b(x | \bm{\theta}_1)
</code>
</p>

<p>The most common models with this shape is the Gompertz-Makeham model (Gompertz 1825, Makeham 1866).
</p>
<p>(c) <code>shape = </code>&ldquo;<code>bathtub</code>&rdquo;: produces a concave shapes in mortality by adding a declining Gompertz term and a constant parameter to the basic mortality model, where the mortality function is
</p>
<p style="text-align: center;"><code class="reqn">
\mu(x | \bm{\theta}) = \exp(a_0 - a_1 x) + c + \mu_b(x | \bm{\theta}_1),
</code>
</p>

<p>where <code class="reqn">a_0 \in \mathbb{R}</code>, <code class="reqn">a_1, c \geq 0</code> and <code class="reqn">\bm{\theta}_1 \subset \bm{\theta}</code> are specified based on argument <code>model</code>, and with survival
</p>
<p style="text-align: center;"><code class="reqn">
S(x | \theta) = \exp\left[\frac{e^{a_0}}{a_1}\left(e^{a_1 x} - 1\right)-cx\right] S_b(x | \theta_1).
</code>
</p>

<p>The most widely use &ldquo;<code>bathtub</code>&rdquo; shaped model is the <b>Siler mortality model</b> (Siler 1979), which provides considerably good fits to mammalian data. The arguments for the Siler model are:
</p>
<pre>basta(..., model = "GO", shape = "bathtub", ...)</pre>
<p><b>3) COVARIATES:</b>
</p>
<p>Covariates are selected by means of the argument <code>formulaMort</code>, which requires an object of class formula, just as with other statistical inference functions such as <code>lm</code> or <code>glm</code>.
</p>
<p>When covariates are included in the dataset, the <code>basta</code> function provides three different ways in which these can be evaluated by using argument <code>covarsStruct</code>: 
</p>
<p><code>3.1)</code> &ldquo;<code>fused</code>&rdquo;: 
</p>
<p>This option will make the mortality parameters linear functions of all categorical covariates (analogous to a generalised linear model (GLM) structure) and will put all continuous covariates under a proportional hazards structure. Thus, for a simple exponential model with constant mortality of the form <code class="reqn">\mu_0(x | b) = b</code>, the parameter is equal to <code class="reqn">b = b_1 z_1 + \dots, b_k z_k</code>, where <code class="reqn">[b_1, \dots, b_k]</code> are paramters that link the mortality parameter <code class="reqn">b</code> with the categorical covariates <code class="reqn">[z_1,\dots,z_k]</code>.
</p>
<p><code>3.2</code> &ldquo;<code>prop.haz</code>&rdquo;: 
</p>
<p>This setting will put all covariates under a proportional hazards structure irrespective of the type of variable. In this case, the mortality model is be further extended by including a proportional hazards structure, of the form 
</p>
<p style="text-align: center;"><code class="reqn">\mu(x | \theta, \gamma, Z_a, Z_c) = \mu_0(x | \theta, Z_a) \exp(Z_c \gamma),</code>
</p>

<p>where <code class="reqn">\mu_0(x | \theta, Z_a)</code> represents the baseline mortality as defined above, while the second term <code class="reqn">\exp(Z_c \gamma)</code> corresponds to the proportional hazards function.  <code class="reqn">Z_a</code> and <code class="reqn">Z_c</code> are covariate (design) matrices for categorical and continuous covariates, respectively, while <code class="reqn">\gamma</code> is a vector of proportional hazards parameters.
</p>
<p><code>3.3</code> &ldquo;<code>all.in.mort</code>&rdquo;:
</p>
<p>This specification will put all covariates as linear functions of the survival parameters as explained above. Since most models require the lower bounds for the mortality parameters to be equal to 0, the only model that can be used for this test is Gompertz with <code>shape</code> set to &ldquo;<code>simple</code>&rdquo;. In case these arguments are specified differently, a warning message is printed noting that <code>model</code> will be forced to be &ldquo;<code>GO</code>&rdquo; and <code>shape</code> will be set to &ldquo;<code>simple</code>&rdquo;.
</p>
<p><code>4) MCMC SETTINGS:</code>
</p>
<p>The <code>burnin</code> argument represents the number of steps at the begining of the MCMC run that is be discarded. This sequence commonly corresponds to the non-converged section of the MCMC sequence. Convergence and model selection measures are calculated from the remaining thinned parameter chains if multiple simulations are run, and all if all of them run to completion.
</p>
<p>The <code>thinning</code> argument specifies the number of steps to be skipped in order to reduce serial autocorrelation. The thinned sequence, which only includes steps after burn in, is then used to calculate convergence statistics and model for selection.
</p>
<p>The <code>updateJumps</code> argument specifies wether to run a simulation to find appropriate jump standard deviations for theta and gamma parameters. If argument &ldquo;<code>nsim</code>&rdquo; is set to 1, then the simulation runs with the update jumps routine active. If &ldquo;<code>nsim</code>&rdquo; is larger than 1, then an initial simulation is ran to find apropriate jumps before the main analysis is ran. 
</p>
<p><code>5) ADDITIONAL ARGUMENTS:</code>
</p>
<p>Additional arguments for priors, jumps and start values can be passed on the ... section. For instance, argument <code>thetaStart</code> can be specified as a vector defining the initial values for each parameter in the survival model. If this argument is not specified, a set of random parameters is generated for each simulation. Similarly, argument <code>gammaStart</code> can be specified for all parameters in the proportional hazards section of the model. Jump standard deviations (i.e. the standard error in the Metropolis step) can be specified with arguments <code>thetaJumps</code> and <code>gammaJumps</code>. As with <code>thetaStart</code>, default values are assigned if these arguments are not specified. 
</p>
<p>To specify priors, arguments <code>thetaPriorMean</code>, <code>thetaPriorSd</code>, <code>gammaPriorMean</code> and <code>gammaPriorSd</code> can be used for prior means and standard errors for each survival and proportional hazards parameters. If not specified, default values are assigned.
</p>
<p>The number of parameters in <code>thetaStart</code>, <code>thetaJumps</code>, <code>thetaPriorMean</code> and <code>thetaPriorSd</code> should be a vector or matrix for the parameters in the mortality function. The number of parameters will depend on the model chosen with <code>model</code> (see above). If the number of parameters specified does not match the number of parameters inherent to the model and shape selected, the function returns an error. 
</p>
<p>As described above, the number of parameters for <code>gammaStart</code>, <code>gammaJumps</code>, <code>gammaPriorMean</code> and <code>gammaPriorSd</code> arguments (i.e. section b), namely the proportional hazards section, will be a function of the number of continuous covariates if argument <code>covarsStruct</code> is &ldquo;<code>fused</code>&rdquo;, or to the total number of covariates when <code>covarsStruct</code> is &ldquo;<code>prop.haz</code>&rdquo;.
</p>
<p><b>6) SUMMARY STATISTICS:</b>
From the converged sequence of mortality parameters, BaSTA calculates a number of summary statistics, their standard errors and their lower and upper 95% credible intervals. 
</p>
<p><code>6.1) Remaining life expectancy:</code>
</p>
<p>The function calculates remaining life expectancy as
</p>
<p style="text-align: center;"><code class="reqn">
e_{0} = \int_{0}^{\infty} S(t) dt.
</code>
</p>

<p><code>6.2) Measures of inequality and equality:</code>
</p>
<p>The function calculates different measures of inequality and equality in the distribution of ages at death that results from the parametric model:
</p>
<p>- <code>Lifespan inequality:</code> (Demetrius 1974, Keyfitz and Caswell 2005) given by
</p>
<p style="text-align: center;"><code class="reqn">
H = -\frac{\int_{0}^{\infty} S(x) \ln [S(x)] dx}{e_0}
</code>
</p>

<p>- <code>Lifespan equality:</code> (Colchero <em>et al.</em> 2016, Colchero <em>et al.</em> 2021) given by
</p>
<p style="text-align: center;"><code class="reqn">
\varepsilon = - \ln H.
</code>
</p>

<p>- <code>Gini coefficient:</code> (Gini 1912, Shkolnikov <em>et al.</em> 2003) given by
</p>
<p style="text-align: center;"><code class="reqn">
G = 1 - \frac{1}{e_0} \int_0^{\infty} [l(x)]^2 dx
</code>
</p>

<p>- <code>Coefficient of variation:</code> given by
</p>
<p style="text-align: center;"><code class="reqn">
CV = \frac{\sqrt{\sigma^2}}{e_0},
</code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the variance in ages at death.
</p>


<h3>Value</h3>

<table>
<tr><td><code>params</code></td>
<td>
<p>If requested, a matrix with the thinned, converged parameter traces of all runs. This matrix is used to calculate quantiles for parameters, survival probability and mortality (see below).</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>If requested, a matrix with only the parameters of the mortality function after convergence and thinning.</p>
</td></tr> 
<tr><td><code>coefficients</code></td>
<td>
<p>A matrix with estimated coefficients (i.e. mean values per parameter on the thinned sequences after burnin), which includes standard errors, upper and lower 95% credible intervals, update rates per parameter, serial autocorrelation on the thinned sequences and the potential scale reduction factor for convergence (see <code>Convergence</code> value below). </p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>Names of all parameters</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>Basic deviance information criterion (DIC) calculations to be used for model selection (Spiegelhalter <em>et al.</em> 2002, Celeux <em>et al.</em> 2006). Small differences between values should only be used as a reference (see comments in Spiegelhalter <em>et al.</em> 2002). If any of the parameter chains did not converge, then the returned value is &ldquo;<code>Not calculated</code>&rdquo;.</p>
</td></tr>
<tr><td><code>KullbackLeibler</code></td>
<td>
<p>If called by <code>summary</code>, list with Kullback-Leibler discrepancy matrices between pair of parameters for categorical covariates (McCulloch 1989, Burnham and Anderson 2001) and McCulloch's (1989) calibration measure. If only one simulation was run or if no convergence is reached, then the returned value is &ldquo;<code>Not calculated</code>&rdquo;.</p>
</td></tr>
<tr><td><code>PS</code></td>
<td>
<p>If requested, a list with summary statistics of the PDF of ages at death, including the life expectancy, lifespan inequality, lifespan equality, and Gini index. These are separated by categorical covariate and, if continuous covariates are provided, they are evaluated at the average value of each continous covariate. The list object provides a table with the mean and lower and upper 95% credible intervals and vectors of the converged and thinned values for each variable.</p>
</td></tr>
<tr><td><code>mort</code></td>
<td>
<p>If requested or called by functions <code>plot</code> or <code><a href="#topic+plot.basta">plot.basta</a></code> median and 95% predictive intervals for the estimated mortality rates separated by categorical covariate and calculated at the mean for each continuous covariate, if provided.</p>
</td></tr>
<tr><td><code>surv</code></td>
<td>
<p>If requested or called by functions <code>plot</code> or <code><a href="#topic+plot.basta">plot.basta</a></code> median and 95% predictive intervals for the estimated survival probability, separated by categorical covariate and calculated at the mean for each continuous covariate, if provided.</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>If requested, median and 95% predictive intervals for the estimated probability density function of ages at death, separated by categorical covariate and calculated at the mean for each continuous covariate, if provided.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>If requested, a vector of the ages used to calculate <code>mort</code>, <code>surv</code>, and <code>dens</code>.</p>
</td></tr>
<tr><td><code>cuts</code></td>
<td>
<p>An index vector per categorical covariate of the ages where the survival is larger than 0.05, used for display purposes when producing the plots with function <code>plot</code>.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>If requested, a matrix with convergence coefficients based on potential scale reduction as described by Gelman <em>et al.</em> (2004). If only one simulation was ran, then the returned value is &ldquo;<code>Not calculated</code>&rdquo;.</p>
</td></tr>
<tr><td><code>convmessage</code></td>
<td>
<p>Only used with functions <code>summary</code> and <code>print</code> to indicate whether the parameter traces converged appropriately.</p>
</td></tr>
<tr><td><code>runs</code></td>
<td>
<p>A list object with the outputs of each individual MCMC run. Used with function <code>plot</code>.</p>
</td></tr>
<tr><td><code>fullpar</code></td>
<td>
<p>A list object with the input parameter information for the model, including starting values, priors, initial jumps, lower bound, among other. Used with functions <code>summary</code> and <code>print</code>.</p>
</td></tr>
<tr><td><code>simthe</code></td>
<td>
<p>A list object with information on the basic mortality model. Used with function <code>plot</code>.</p>
</td></tr>
<tr><td><code>jumps</code></td>
<td>
<p>A list object with the final jump standard deviations for each parameter.</p>
</td></tr>
<tr><td><code>covs</code></td>
<td>
<p>A list object with general information on the type of covariates, i.e., <code>cat</code> and <code>cont</code>, and the type of <code>covarStruct</code> used.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>If called by <code>summary</code>, this is a vector indicating the number of iterations for each MCMC, the burn in sequence, the thinning interval, and the number of simulations that were run.</p>
</td></tr>
<tr><td><code>modelSpecs</code></td>
<td>
<p>Model specifications inidicating the <code>model</code>, the <code>shape</code>, the covariate structure and the minimum age that were specified by the user.</p>
</td></tr>
<tr><td><code>lifeTable</code></td>
<td>
<p>A period life table calculated from the estimated times of birth (and death for &ldquo;<code>CMR</code>&rdquo;) accounting for truncation and censoring.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fernando Colchero <a href="mailto:fernando_colchero@eva.mpg.de">fernando_colchero@eva.mpg.de</a></p>


<h3>References</h3>

<p>Burnham, K.P. and Anderson, D.R. (2001) Kullback-Leibler information as a basis for strong inference in ecological studies. <em>Widlife Research</em>, 28, 111-119.
</p>
<p>Celeux, G., Forbes, F., Robert, C. P., and Titterington, D. M. (2006) Deviance information criteria for missing data models. <em>Bayesian Analysis</em>, 1(4), 651-673. 
</p>
<p>Colchero, F. and J.S. Clark (2012) Bayesian inference on age-specific survival from capture-recapture data for censored and truncated data. <em>Journal of Animal Ecology</em>. 81, 139-149.
</p>
<p>Colchero, F., O.R. Jones and M. Rebke. (2012) BaSTA: an R package for Bayesian estimation of age-specific survival from incomplete mark-recapture/recovery data with covariates. <em>Method in Ecology and Evolution</em>. 3, 466-470. 
</p>
<p>Colchero, F., <em>et al.</em>  (2021) The long lives of primates and the &quot;invariant rate of aging&quot; hypothesis. <em>Nature Communications</em> 12:3666
</p>
<p>Cox, D. R., and Oakes D. (1984) <em>Analysis of Survival Data</em>. Chapman and Hall, London.
</p>
<p>Demetrius, L. (1974) Demographic parameters and natural selection. <em>PNAS</em> 71, 4645-4647.
</p>
<p>Gelman, A., Carlin, J.B., Stern, H.S. and Rubin, D.B. (2004) <em>Bayesian data analysis</em>. 2nd edn. Chapman &amp; Hall/CRC, Boca Raton, Florida, USA.
</p>
<p>Gompertz, B. (1825) On the nature of the function expressive of the law of human mortality, and on a new mode of determining the value of life contingencies. <em>Philosophical Transactions of the Royal Society of London</em>, 115, 513-583.
</p>
<p>Keyfitz, N., Caswell, H. (2005) Applied Mathematical Demography. (Springer-Verlag).
</p>
<p>King, R. and Brooks, S.P. (2002) Bayesian model discrimination for multiple strata capture-recapture data. <em>Biometrika</em>, 89, 785-806. 
</p>
<p>Makeham, W. M. On the law of mortality (1866). <em>Journal of the Institute of Actuaries</em> 13, 1-34.
</p>
<p>McCulloch, R.E. (1989) Local model influence. <em>Journal of the American Statistical Association</em>, 84, 473-478.
</p>
<p>Pinder III, J.E., Wiener, J.G. and Smith, M.H. (1978) The Weibull distribution: a new method of summarizing survivorship data. <em>Ecology</em>, 59, 175-179.
</p>
<p>Shkolnikov, V., Andreev, E. &amp; Begun, A. Z. (2003) Gini coefficient as a life table function. <em>Demographic Research</em> 8, 305-358.
</p>
<p>Siler, W. A (1979) competing-risk model for animal mortality. <em>Ecology</em> 60, 750-757.
</p>
<p>Spiegelhalter, D.J., Best, N.G., Carlin, B.P. and van der Linde, A. (2002) Bayesian measures of model complexity and fit. <em>Journal of the Royal Statistical Society: Series B</em>, 64, 583-639.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.basta">summary.basta</a></code>, <code>print.basta</code>, <code>plot.basta</code> to visualise summary outputs for objects of class &ldquo;<code>basta</code>&rdquo;. 
</p>
<p><code><a href="#topic+bastaCMRdat">bastaCMRdat</a></code> and <code><a href="#topic+bastaCensDat">bastaCensDat</a></code> for examples of input CMR and census datasets, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ---------- #
## CMR data:
## ---------- #

## Load data:
data("bastaCMRdat", package = "BaSTA")

## Check data consistency:
checkedData &lt;- DataCheck(bastaCMRdat, dataType = "CMR", 
                              studyStart = 51, studyEnd = 70)

## Run short version of BaSTA on the data:
out &lt;- basta(bastaCMRdat, studyStart = 51, studyEnd = 70)


## ------------- #
## Census data:
## ------------- #

## Load data:
data("bastaCensDat", package = "BaSTA")

## Check data consistency:
checkedData &lt;- DataCheck(bastaCensDat, dataType = "census")

## Run short version of BaSTA on the data:
out &lt;- basta(bastaCensDat, dataType = "census")




## --------------------- #
## Check BaSTA outputs:
## --------------------- #
## Print results:
summary(out, digits = 3)

## Plot traces for survival parameters:
plot(out)

## Plot posterior densities of survival parameters:
plot(out, densities = TRUE)

## Plot survival and mortality curves:
plot(out, plot.type = "demorates")

</code></pre>

<hr>
<h2 id='bastaCensDat'>
Example of census data for BaSTA analysis.
</h2><span id='topic+bastaCensDat'></span>

<h3>Description</h3>

<p>Simulated census data (i.e., continuous observation of individuals) for Bayesian Survival Trajectory Analysis (BaSTA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bastaCensDat")</code></pre>


<h3>Format</h3>

<p>A data frame with 500 observations on the following 8 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>ID for each individual.</p>
</dd>
<dt><code>Birth.Date</code></dt><dd><p>Dates of birth, formated as &ldquo;<code>YYYY-mm-dd</code>&rdquo;.</p>
</dd>
<dt><code>Min.Birth.Date</code></dt><dd><p>Minimum estimated dates of birth, formated as &ldquo;<code>YYYY-mm-dd</code>&rdquo;. If the date of birth is known, then <code>Min.Birth.Date</code> is equal to <code>Birth.Date</code>.</p>
</dd>
<dt><code>Max.Birth.Date</code></dt><dd><p>Maximum estimated dates of birth, formated as &ldquo;<code>YYYY-mm-dd</code>&rdquo;. If the date of birth is known, then <code>Max.Birth.Date</code> is equal to <code>Birth.Date</code></p>
</dd>
<dt><code>Entry.Date</code></dt><dd><p>Dates of entry to the study, formated as &ldquo;<code>YYYY-mm-dd</code>&rdquo;.</p>
</dd>
<dt><code>Depart.Date</code></dt><dd><p>Dates of departure from the study, formated as &ldquo;<code>YYYY-mm-dd</code>&rdquo;.</p>
</dd>
<dt><code>Depart.Type</code></dt><dd><p>a character vector indicating whether the <code>Depart.Date</code> is because of death (i.e., &ldquo;<code>D</code>&rdquo;) or censored (i.e., &ldquo;<code>C</code>&rdquo;).</p>
</dd>
<dt><code>Sex</code></dt><dd><p>a character vector indicating the sex covariate.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset was created by stochastically simulating a hypothetical population with different mortality patterns between males and females and with proportional decreases in mortality as a function of a hypothetical continuous covariate (e.g. birth weight, average adult weight, etc.). The population was simulated for 40 years, with uniform times of birth within this period. Sex ratios were assumed to be 1:1.  The time of death for each individual was inversed sampled from a Gompertz CDF of ages at death. The Gompertz parameters for females were: <code class="reqn">b_0 = -3</code> and <code class="reqn">b_1 = 0.15</code>; and for males at <code class="reqn">b_0 = -2</code> and <code class="reqn">b_1 = 0.2</code>.
</p>
<p>The resulting dataset includes individuals where the data are left-truncated and/or right-censored. This is typical of capture mark recovery datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data:
data("bastaCensDat", package = "BaSTA")

## Check data consistency:
checkedData  &lt;- DataCheck(bastaCensDat, dataType = "census")

</code></pre>

<hr>
<h2 id='bastaCensOut'>
Output from a Bayesian Survival Trajectory Analysis (BaSTA) analysis on a simulated census dataset.
</h2><span id='topic+bastaCensOut'></span>

<h3>Description</h3>

<p>This dataset is the output of a BaSTA analysis on the simulated dataset <code><a href="#topic+bastaCensDat">bastaCensDat</a></code>. The analysis consisted of four independent simulations run in parallel. The model chosen was Gompertz (&ldquo;<code>GO</code>&rdquo;) with the <code>shape</code> argument set to &ldquo;<code>simple</code>&rdquo; and <code>covarStruct</code> set to &ldquo;<code>fused</code>&rdquo;.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bastaCensOut")</code></pre>


<h3>Format</h3>

<p>A BaSTA output list (see details in <code><a href="#topic+basta">basta</a></code>). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load BaSTA output:
data("bastaCensOut", package = "BaSTA")

## Plot traces for survival parameters:
plot(bastaCensOut)

## Plot posterior densities of survival parameters:
plot(bastaCensOut, densities = TRUE)

## Plot survival and mortality curves:
plot(bastaCensOut, plot.type = "demorates")
</code></pre>

<hr>
<h2 id='bastaCMRdat'>
Example of capture-mark-recapture data for BaSTA analysis.
</h2><span id='topic+bastaCMRdat'></span>

<h3>Description</h3>

<p>Simulated capture-mark-recapture (<code>CMR</code>) data for Bayesian Survival Trajectory Analysis (BaSTA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bastaCMRdat")</code></pre>


<h3>Format</h3>

<p>A data frame with 500 observations on the following 25 variables (see <code>details</code>).
</p>


<h3>Details</h3>

<p>This dataset was created by stochastically simulating a hypothetical population with different mortality patterns between males and females and with proportional decreases in mortality as a function of a hypothetical continuous covariate (e.g. birth weight). The population was simulated for 100 years, at each one of which 100 individuals were born. The number of females per generation was randomly drawn from a binomial distribution using function <code>rbinom</code> with probability of 0.5 (i.e. 1:1 sex ratio). The individual continuous covariate was randomly drawn from a random normal distribution (with function <code>rnorm</code>) with mean parameter equal to 0 (e.g. anomaly of weights) and standard deviation equal to 1.  The time of death for each individual was inversed sampled from a Gompertz CDF of ages at death. The Gompertz parameters for females were: <code class="reqn">b_0 = -4</code> and <code class="reqn">b_1 = 0.15</code>; and for males at <code class="reqn">b_0 = -3</code> and <code class="reqn">b_1 = 0.15</code>. The gamma parameter for the continuous covariate was <code class="reqn">\gamma = 0.2</code>.
</p>
<p>The study was assumed to start at year 51 and to finish at year 70. Recapture probability was set to 0.6 and thus each observation per individual was randomly drawn from a Bernoulli trial with parameter <code class="reqn">p = 0.6</code>. Captures at birth and recoveries were randomly drawn from a Bernoulli trial with parameters <code class="reqn">p = 0.5</code> and <code class="reqn">p = 0.2</code>, respectively. 
</p>
<p>Therefore, the resulting dataset includes individuals where the data are left-truncated and/or right-censored. This is typical of capture mark recovery datasets.
</p>
<p>Here is the description of each column:
</p>
<p><code>id</code>: ID for each individual.
</p>
<p><code>birth</code>: Integer times of birth or <code>NA</code> when unknown.
</p>
<p><code>death</code>: Integer times of death or <code>NA</code> when unknown.
</p>
<p><code>Y.51 - Y.70</code>: Columns of the recapture matrix
</p>
<p><code>Sex</code>: Character string indicating the sex for the individual record (i.e., &ldquo;<code>Female</code>&rdquo; and &ldquo;<code>Male</code>&rdquo;)
</p>
<p><code>Weight</code>: Simumated body weights at birth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data:
data("bastaCMRdat", package = "BaSTA")

## Check data consistency:
checkedData  &lt;- DataCheck(bastaCMRdat, dataType = "CMR", studyStart = 51, 
                          studyEnd = 70)
</code></pre>

<hr>
<h2 id='bastaCMRout'>
Output from a Bayesian Survival Trajectory Analysis (BaSTA) analysis on a simulated capture-mark-recapture (CMR) dataset.
</h2><span id='topic+bastaCMRout'></span>

<h3>Description</h3>

<p>This dataset is the output of a BaSTA analysis on the simulated dataset <code><a href="#topic+bastaCMRdat">bastaCMRdat</a></code>. The analysis consisted of four independent simulations run in parallel. Each simulation was run for 20,000 iterations. The model chosen was Gompertz (&ldquo;<code>GO</code>&rdquo;) with the <code>shape</code> argument set to &ldquo;<code>simple</code>&rdquo; and <code>covarStruct</code> set to &ldquo;<code>fused</code>&rdquo;.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bastaCMRout")</code></pre>


<h3>Format</h3>

<p>A BaSTA output list (see details in <code><a href="#topic+basta">basta</a></code>). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load BaSTA output:
data("bastaCMRout", package = "BaSTA")

## Plot traces for survival parameters:
plot(bastaCMRout)

## Plot posterior densities of survival parameters:
plot(bastaCMRout, densities = TRUE)

## Plot traces for proportional hazards parameter:
plot(bastaCMRout, trace.name = "gamma")

## Plot survival and mortality curves:
plot(bastaCMRout, plot.type = "demorates")
</code></pre>

<hr>
<h2 id='CensusToCaptHist'>
Constructs a capture-history matrix from repeated individual observations to be used in Bayesian Survival Trajectory Analysis (BaSTA).
</h2><span id='topic+CensusToCaptHist'></span>

<h3>Description</h3>

<p>This function takes a table of repeated observations per individual (e.g., discrete interval census), consisting of a pair of vectors with ID and observation date (e.g., year), and converts it into a capture-history matrix to be used as part of a BaSTA CMR data input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CensusToCaptHist(ID, d, dformat = "%Y", timeInt = "Y")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CensusToCaptHist_+3A_id">ID</code></td>
<td>

<p>A vector with individual IDs.
</p>
</td></tr>
<tr><td><code id="CensusToCaptHist_+3A_d">d</code></td>
<td>

<p>A vector of dates when each individual was observed (see <code>details</code>). 
</p>
</td></tr>
<tr><td><code id="CensusToCaptHist_+3A_dformat">dformat</code></td>
<td>

<p>Defines the date format for <code>d</code> when <code>d</code> is of class <code>character</code> (see <code>details</code>).</p>
</td></tr>
<tr><td><code id="CensusToCaptHist_+3A_timeint">timeInt</code></td>
<td>

<p>A one character string specifying which time interval should be used between capture occasions. Arguments are &ldquo;<code>Y</code>&rdquo; for years, &ldquo;<code>M</code>&rdquo; for months, &ldquo;<code>W</code>&rdquo; for weeks and &ldquo;<code>D</code>&rdquo; for days (see <code>details</code>).. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>d</code> argument can be specified as an object of class <code>POSIXct</code> or <code>POSIXlt</code>, as a vector of integer time intervals or as a character string indicating the day, month and year. (e.g. <code>dd/mm/yyyy</code>, <code>mmddyyyy</code>, <code>mm-dd-yyyy</code> etc.). When <code>d</code> is of class <code>character</code> then argument <code>dformat</code> needs to be specified using the same conventions as in function <code>format.POSIXct</code> for objects of class <code>POSIXct</code> or <code>POSIXlt</code>.
</p>


<h3>Value</h3>

<p>Creates an object of class &ldquo;<code>data.frame</code>&rdquo; with the reconstructed capture recapture matrix.
</p>


<h3>Author(s)</h3>

<p>Owen R. Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DataCheck">DataCheck</a></code> for running a data check on the input data for function <code><a href="#topic+basta">basta</a></code>.<code><a href="#topic+FixCMRdata">FixCMRdata</a></code> to fix potential issues for capture-mark-recapture data. <code><a href="#topic+bastaCMRdat">bastaCMRdat</a></code> for an example of input CMR datasets. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a simulated vector of repeated IDs:
IDvec &lt;- sort(sample(1:5, size = 15, replace = TRUE))

## Simulate dates (e.g., years) of observation per individual:
dVec &lt;- rep(0, length(IDvec))
for(i in unique(IDvec)) {
  svec &lt;- which(IDvec == i)
  dVec[svec] &lt;- sort(sample(1990:1995, length(svec)))
}

## Construct the capture-recapture matrix:
Y &lt;- CensusToCaptHist(ID = IDvec,  d = dVec)
</code></pre>

<hr>
<h2 id='DataCheck'>
Error checking for BaSTA input data.
</h2><span id='topic+DataCheck'></span>

<h3>Description</h3>

<p>A function to check the input data file for a Bayesian Survival Trajectory Analysis (BaSTA) for capture-mark-recapture (CMR) or census data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataCheck (object, dataType = "CMR", studyStart = NULL, studyEnd = NULL,  silent = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DataCheck_+3A_object">object</code></td>
<td>
<p>A <code>data.frame</code> to be used as an input data file for BaSTA. Note: BaSTA can take two types of datasets, namely capture-mark-recapture (<code>CMR</code>) or census data.</p>
</td></tr>
<tr><td><code id="DataCheck_+3A_datatype">dataType</code></td>
<td>
<p>A <code>character string</code> indicating if the data are capture-mark-recapture (CMR) or census. Options are &ldquo;<code>CMR</code>&rdquo; (default) or &ldquo;<code>census</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="DataCheck_+3A_studystart">studyStart</code></td>
<td>
<p>Only required for <code>dataType =</code> &ldquo;<code>CMR</code>&rdquo;, an integer indicating the first year of the study.</p>
</td></tr>
<tr><td><code id="DataCheck_+3A_studyend">studyEnd</code></td>
<td>
<p>Only required for <code>dataType =</code> &ldquo;<code>CMR</code>&rdquo;, an integer indicating the last year of the study.</p>
</td></tr>
<tr><td><code id="DataCheck_+3A_silent">silent</code></td>
<td>
<p>Logical to indicate whether the results should be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks for inconsistencies in the dataset and reports them back. See <code>value</code> section for details on the types of errors detected by the function. 
</p>
<p><code>DATA SPECIFICATIONS:</code>
</p>
<p><code>1) CMR data:</code>
The input data <code>object</code> requires the following structure: the first column should be a vector of individual unique IDs, the second and third columns are birth and death years respectively. Columns <code class="reqn">4, \dots, T+3</code> represent the observation window (i.e., recapture matrix) of <code class="reqn">T</code> years.  This is followed (optionally) by columns for categorical and continuous covariates.
</p>
<p><code>2) census data:</code>
The input data <code>object</code> requires at least five dates columns, namely &ldquo;Birth.Date&rdquo;, &ldquo;Min.Birth.Date&rdquo;, &ldquo;Max.Birth.Date&rdquo;, &ldquo;Entry.Date&rdquo;, and &ldquo;Depart.Date&rdquo;. All dates need to be format as &ldquo;%Y-%m-%d&rdquo;. In addition, a &ldquo;Depart.Type&rdquo; column is required with two types of departures &ldquo;C&rdquo; for Censored and &ldquo;D&rdquo; for dead.
</p>


<h3>Value</h3>

<p><code>1) CMR data:</code>
</p>
<table>
<tr><td><code>newData</code></td>
<td>
<p>The original data frame (for consistency with previous versions of BaSTA).</p>
</td></tr>
<tr><td><code>type1</code></td>
<td>
<p>A vector of row numbers in the original data frame where there are deaths occurring before the study starts.</p>
</td></tr>
<tr><td><code>type2</code></td>
<td>
<p>A vector of row numbers in the original data frame where there are no birth/death AND no obervations.</p>
</td></tr>
<tr><td><code>type3</code></td>
<td>
<p>A vector of row numbers in the original data frame where there are births recorded after death.</p>
</td></tr>
<tr><td><code>type4</code></td>
<td>
<p>A vector of row numbers in the original data frame where there are observations (i.e. recaptures) after death.</p>
</td></tr>
<tr><td><code>type5</code></td>
<td>
<p>A vector of row numbers in the original data frame where there are observations (i.e. recaptures) before birth.</p>
</td></tr>
<tr><td><code>type6</code></td>
<td>
<p>A vector of row numbers in the original data frame where the year of birth is not a zero in the recapture matrix.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>List with summary information, e.g., sample size, number of records with known birth, number of records with known death, etc. </p>
</td></tr>
<tr><td><code>stopExec</code></td>
<td>
<p>Logical that indicates if the data are free of errors or not. i.e. <code>TRUE</code> = the data have no apparent errors, and <code>FALSE</code> = there is at leat one error.</p>
</td></tr>
<tr><td><code>probDescr</code></td>
<td>
<p>Character vector explaining the six types of problems the <code><a href="#topic+DataCheck">DataCheck</a></code> functions looks for.</p>
</td></tr>
<tr><td><code>dataType</code></td>
<td>
<p>Type of dataset, i.e., &ldquo;<code>CMR</code>&rdquo;.</p>
</td></tr>
<tr><td><code>studyStart</code></td>
<td>
<p>Integer indicating the study start time.</p>
</td></tr>
<tr><td><code>studyEnd</code></td>
<td>
<p>Integer indicating the study end time.</p>
</td></tr>
</table>
<p><code>2) census data:</code>
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>Integer for the number of rows (i.e., records) in the dataset.</p>
</td></tr>
<tr><td><code>stopExec</code></td>
<td>
<p>Logical that indicates if the data are free of errors or not. i.e. <code>TRUE</code> = the data have no apparent errors, and <code>FALSE</code> = there is at leat one error.</p>
</td></tr>
<tr><td><code>nas</code></td>
<td>
<p>List organised by column indicating whether <code>NA</code>s were detected in a given column.</p>
</td></tr>
<tr><td><code>DateRan</code></td>
<td>
<p>Matrix of dates ranges (as character strings) for each date column in the dataset.</p>
</td></tr>
<tr><td><code>probDescr</code></td>
<td>
<p>Character vector explaining the seven types of problems the <code><a href="#topic+DataCheck">DataCheck</a></code> functions looks for.</p>
</td></tr>
<tr><td><code>MinBBirth</code></td>
<td>
<p>Vector of indices of rows where &ldquo;<code>Min.Birth.Date</code>&rdquo; was larger than &ldquo;<code>Birth.Date</code>&rdquo;.</p>
</td></tr>
<tr><td><code>BirthMaxB</code></td>
<td>
<p>Vector of indices of rows where &ldquo;<code>Birth.Date</code>&rdquo; was larger than &ldquo;<code>Max.Birth.Date</code>&rdquo;.</p>
</td></tr>
<tr><td><code>MinBMaxB</code></td>
<td>
<p>Vector of indices of rows where &ldquo;<code>Min.Birth.Date</code>&rdquo; was larger than  &ldquo;<code>Max.Birth.Date</code>&rdquo;.</p>
</td></tr>
<tr><td><code>BirthEntr</code></td>
<td>
<p>Vector of indices of rows where &ldquo;<code>Birth.Date</code>&rdquo; was larger than &ldquo;<code>Endtry.Date</code>&rdquo;.</p>
</td></tr>
<tr><td><code>MinBEntr</code></td>
<td>
<p>Vector of indices of rows where &ldquo;<code>Min.Birth.Date</code>&rdquo; was larger than  &ldquo;<code>Entry.Date</code>&rdquo;.</p>
</td></tr>
<tr><td><code>MaxBEntr</code></td>
<td>
<p>Vector of indices of rows where &ldquo;<code>Max.Birth.Date</code>&rdquo; was larger than  &ldquo;<code>Entry.Date</code>&rdquo;.</p>
</td></tr>
<tr><td><code>EntrDep</code></td>
<td>
<p>Vector of indices of rows where &ldquo;<code>Entry.Date</code>&rdquo; was larger than  &ldquo;<code>Depart.Date</code>&rdquo;.</p>
</td></tr>
<tr><td><code>DepartType</code></td>
<td>
<p>Vector of indices of rows where &ldquo;<code>Depart.Type</code>&rdquo; does not fall within the &ldquo;<code>C</code>&rdquo; (i.e., censored) or &ldquo;<code>D</code>&rdquo; (i.e., uncensored or death) categories.</p>
</td></tr>
<tr><td><code>idUnCens</code></td>
<td>
<p>Vector of indices of rows for uncensored (i.e., death) records.</p>
</td></tr>
<tr><td><code>nUnCens</code></td>
<td>
<p>Integer indicating the number of uncensored records.</p>
</td></tr>
<tr><td><code>idCens</code></td>
<td>
<p>Vector of indices of rows for censored records.</p>
</td></tr>
<tr><td><code>nCens</code></td>
<td>
<p>Integer indicating the number of uncensored records.</p>
</td></tr>
<tr><td><code>idNoBirth</code></td>
<td>
<p>Vector of indices of rows for records with uncertain birth date.</p>
</td></tr>
<tr><td><code>nNoBirth</code></td>
<td>
<p>Integer indicating the number of records with uncertain birth date.</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Fernando Colchero <a href="mailto:fernando_colchero@eva.mpg.de">fernando_colchero@eva.mpg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+FixCMRdata">FixCMRdata</a></code> to fix potential issues for capture-mark-recapture data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## CMR data:
## --------- #
## Load data:
data("bastaCMRdat", package = "BaSTA")

## Check data consistency:
checkedData  &lt;- DataCheck(bastaCMRdat, dataType = "CMR", studyStart = 51, 
                          studyEnd = 70)

## census data:
## ------------ #
## Load data:
data("bastaCensDat", package = "BaSTA")

## Check data consistency:
checkedData  &lt;- DataCheck(object = bastaCensDat, dataType = "census")

## Printed output:
## --------------- #
## Print DataCheck results:
print(checkedData)

</code></pre>

<hr>
<h2 id='FixCMRdata'>
Fix issues on CMR input data for BaSTA.
</h2><span id='topic+FixCMRdata'></span>

<h3>Description</h3>

<p>This function provides general fixes to common issues of capture-mark-recapture (CMR) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FixCMRdata(object, studyStart, studyEnd, autofix = rep(0, 6), 
                       silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FixCMRdata_+3A_object">object</code></td>
<td>
<p>A data.frame to be used as an input data file for BaSTA for <code>dataType =</code> &ldquo;<code>CMR</code>&rdquo;. The first column is the individual's ID, the second and third columns are birth and death years respectively. Columns 4 to <code>nt+3</code> represent the observation window of nt years. This is followed (optionally) by columns for covariate. </p>
</td></tr>
<tr><td><code id="FixCMRdata_+3A_studystart">studyStart</code></td>
<td>
<p>An integer indicating the first year of the study.</p>
</td></tr>
<tr><td><code id="FixCMRdata_+3A_studyend">studyEnd</code></td>
<td>
<p>An integer indicating the last year of the study.</p>
</td></tr>
<tr><td><code id="FixCMRdata_+3A_autofix">autofix</code></td>
<td>
<p>A vector argument with a length of 6 indicating whether to automatically fix any errors (see <code>details</code>). This should be used with extreme caution. We recommend going back to the individual-based data and fixing each error &ldquo;by hand&rdquo;.</p>
</td></tr>
<tr><td><code id="FixCMRdata_+3A_silent">silent</code></td>
<td>
<p>A logical argument indicating whether to print a detailed report to the screen or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>autofix</code> allows the user to fix the potential errors by specifying a code for each fix. Below are the descriptions of the actions that are taken depending on the error type and the fix code:
</p>
<p>Type 1: 0 = do nothing; 1 = remove from dataframe.
</p>
<p>Type 2: 0 = do nothing; 1 = remove from dataframe.
</p>
<p>Type 3: 0 = do nothing; 1 = replace death records with 0; 2 = replace birth records with 0; 3 = replace both birth and death records with 0.
</p>
<p>Type 4: 0 = do nothing; 1 = remove spurious post-death observations.
</p>
<p>Type 5: 0 = do nothing; 1 = remove observations that pre-date year of birth.
</p>
<p>Type 6: 0 = do nothing; 1 = replace birth year element of observation matrix with 0.
</p>


<h3>Value</h3>

<p>For <code>dataType</code> = &ldquo;<code>CMR</code>&rdquo;:
</p>
<table>
<tr><td><code>newData</code></td>
<td>
<p>A corrected data frame.</p>
</td></tr>
<tr><td><code>type1</code></td>
<td>
<p>A vector of row numbers in the original data frame where there are deaths occurring before the study starts.</p>
</td></tr>
<tr><td><code>type2</code></td>
<td>
<p>A vector of row numbers in the original data frame where there are no birth/death AND no obervations.</p>
</td></tr>
<tr><td><code>type3</code></td>
<td>
<p>A vector of row numbers in the original data frame where there are births recorded after death.</p>
</td></tr>
<tr><td><code>type4</code></td>
<td>
<p>A vector of row numbers in the original data frame where there are observations (i.e. recaptures) after death.</p>
</td></tr>
<tr><td><code>type5</code></td>
<td>
<p>A vector of row numbers in the original data frame where there are observations (i.e. recaptures) before birth.</p>
</td></tr>
<tr><td><code>type6</code></td>
<td>
<p>A vector of row numbers in the original data frame where the year of birth is not a zero in the recapture matrix.</p>
</td></tr>
<tr><td><code>stopExec</code></td>
<td>
<p>Logical that indicates if the data are free of errors or not. i.e. <code>TRUE</code> = the data have no apparent errors, and <code>FALSE</code> = there is at leat one error.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fernando Colchero <a href="mailto:fernando_colchero@eva.mpg.de">fernando_colchero@eva.mpg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DataCheck">DataCheck</a></code> for running a data check on the input data for function <code><a href="#topic+basta">basta</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data:
data("bastaCMRdat", package = "BaSTA")

## Fix data:
fixedData  &lt;- FixCMRdata(bastaCMRdat, studyStart = 51, 
                          studyEnd = 70, autofix = rep(1, 6))
</code></pre>

<hr>
<h2 id='summary.basta'>
Summarizing and plotting Bayesian Survival Trajectory Analysis (BaSTA) model outputs.
</h2><span id='topic+summary.basta'></span><span id='topic+print.basta'></span><span id='topic+plot.basta'></span>

<h3>Description</h3>

<p>These functions are all generic methods for class <code>basta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basta'
summary(object, ...)
## S3 method for class 'basta'
print(x, ...)
## S3 method for class 'basta'
plot(x, plot.type = "traces", trace.name = "theta",
                       densities = FALSE, noCIs = FALSE, minSurv = NULL,
                       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.basta_+3A_object">object</code></td>
<td>
<p>An object of class <code>basta</code>.</p>
</td></tr>
<tr><td><code id="summary.basta_+3A_x">x</code></td>
<td>
<p>An object of class <code>basta</code>.</p>
</td></tr>
<tr><td><code id="summary.basta_+3A_plot.type">plot.type</code></td>
<td>
<p>A character vector indicating the type of plot to be produced. Options are: &ldquo;<code>traces</code>&rdquo; for the MCMC traces; &ldquo;<code>demorates</code>&rdquo; for the resulting survival and mortality curves; and &ldquo;<code>gof</code>&rdquo; for a comparison between the estimated parametric survival function and the life table <code>lx</code> variable. </p>
</td></tr>
<tr><td><code id="summary.basta_+3A_trace.name">trace.name</code></td>
<td>
<p>Character string indicating the set of parameters or posteriors to be plotted. The options are: &ldquo;<code>theta</code>&rdquo; to plot the survival model parameters; &ldquo;<code>gamma</code>&rdquo; to plot the proportional hazards parameters (if it applies, else <code>plot.basta</code> returns an error); &ldquo;<code>pi</code>&rdquo; to plot the recapture probabilities.</p>
</td></tr>
<tr><td><code id="summary.basta_+3A_densities">densities</code></td>
<td>
<p>Logical indicating whether to plot the parameter posterior densities instead of the traces.</p>
</td></tr>
<tr><td><code id="summary.basta_+3A_nocis">noCIs</code></td>
<td>
<p>Logical indicating whether the 95% credible intervals should be included in the plot.</p>
</td></tr>
<tr><td><code id="summary.basta_+3A_minsurv">minSurv</code></td>
<td>
<p>Numerical value for the minimum survival level, acts as <code>xlim</code> using the survival as reference.</p>
</td></tr>
<tr><td><code id="summary.basta_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to functions <code>print</code>, <code>summary</code> and <code>plot</code> (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For objects of class <code>basta</code>, the <code>print</code> function returns three summary elements describing the model and its results, namely: <code>call</code>, <code>run</code>, <code>coefficients</code> and, if convergence was reached, the <code>DIC</code> values for model fit. <code>call</code> describes the basic model used (i.e. exponential, Gompertz, Weibull or logistic), the shape chosen, &ldquo;<code>simple</code>&rdquo;, &ldquo;<code>Makeham</code>&rdquo; or &ldquo;<code>bathtub</code>&rdquo;, the covariate structure chosen, &ldquo;<code>fused</code>&rdquo;, &ldquo;<code>prop.haz</code>&rdquo; or &ldquo;<code>all.in.mort</code>&rdquo; and which covariates (if any) were categorical and which continuous. Argument <code>digits</code> can be used for number formatting (see <code>summary</code>() or <code>signif</code>() for details).  
</p>
<p>The summary element <code>coefficients</code> prints out the estimated coefficients for all parameters in the model, as well as their standard errors and 95% upper and lower credible intervals. It also includes a measure of serial autocorrelation for each parameter calculated from the thinned parameter chains, an update rate per parameter, and the potential scale reduction factor for each parameter as a measure of convergence (Gelman <em>et al.</em> 2004). 
</p>
<p>Function <code>summary</code> includes all the previous elements, as well as a summary description of the priors and jump standard deviations for all survival parameters, a calibration of the Kullback-Leibler discrepancy as a measure of parameter similarities for those parameters associated to categorical covariates (McCulloch 1989), and a measure of model fit based on the deviance information criterion (DIC) (Spiegelhalter <em>et al.</em> 2002). 
</p>
<p>Function <code>plot</code> takes objects of class <code>basta</code> to create trace plots or, if the argument for <code>plot.type</code> is set to &ldquo;<code>demorates</code>&rdquo;, it plots estimated survival probabilities and mortality rates with their 95% predictive intervals. If argument <code>plot.trace</code> is set to <code>FALSE</code>, argument <code>xlim</code> can be used to define a range of ages to visualize survival and mortality trends. Also, if logical argument <code>noCI</code> is set to <code>TRUE</code>, credible intervals around survival and mortality are not plotted, leaving only the mean trends. This can be handy when several categorical covariates have been evaluated and the plots get too crowded.  
</p>
<p>Other arguments for <code>plot</code> include <code>names.legend</code> to indicate alternative names for the legend of vital rates plots. Also, when <code>plot.trace</code> is <code>FALSE</code>, argument <code>xlim</code> can be changed to display only a subest of the support. When argument <code>noCI</code> is <code>TRUE</code>, then the credible intervals around the vital rates are not displayed.
</p>


<h3>Value</h3>

 
<p>Function <code>summary</code>() outputs the folowing values:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Matrix with estimated coefficients (i.e. mean values per parameter on the thinned sequences after burnin), which includes standard errors, upper and lower 95% credible intervals, update rates per parameter (commonly the same for all survival and proportional hazards parameters), serial autocorrelation on the thinned sequences and the potential scale reduction factor for convergence (see <code>Convergence</code> value below). </p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>Numeric vector with basic deviance information criterion (DIC) calculations to be used for model selection (Spiegelhalter <em>et al.</em> 2002).</p>
</td></tr>
<tr><td><code>KullbackLeibler</code></td>
<td>
<p>List with Kullback-Leibler discrepancy matrices between pair of parameters for categorical covariates (McCulloch 1989, Burnham and Anderson 2001) and McCulloch's (1989) calibration measure. If only one simulation was ran or if no convergence was reached, then the returned value is &ldquo;<code>Not calculated</code>&rdquo;.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>A matrix with convergence coefficients based on potential scale reduction as described by Gelman <em>et al.</em> (2004). If only one simulation was ran, then the returned value is &ldquo;<code>Not calculated</code>&rdquo;.</p>
</td></tr>
<tr><td><code>modelSpecs</code></td>
<td>
<p>Model specifications inidicating the <code>model</code>, the <code>shape</code> and the covariate structure that were specified by the user.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A vector indicating the number of iterations for each MCMC, the burn in sequence, the thinning interval, and the number of simulations that were run.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fernando Colchero <a href="mailto:fernando_colchero@eva.mpg.de">fernando_colchero@eva.mpg.de</a>, Owen R. Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a>
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S. and Rubin, D.B. (2004) <em>Bayesian data analysis</em>. 2nd edn. Chapman &amp; Hall/CRC, Boca Raton, Florida, USA.
</p>
<p>McCulloch, R.E. (1989) Local model influence. <em>Journal of the American Statistical Association</em>, 84, 473-478.
</p>
<p>Spiegelhalter, D.J., Best, N.G., Carlin, B.P. and Van Der Linde, A. (2002) Bayesian measures of model complexity and fit. <em>Journal of the Royal Statistical Society: Series B</em> 64, 583-639.
</p>
<p>See also:
</p>
<p>Colchero, F. and J.S. Clark (2012) Bayesian inference on age-specific survival from capture-recapture data for censored and truncated data. <em>Journal of Animal Ecology</em>. 81(1):139-149.
</p>
<p>Colchero, F., O.R. Jones and M. Rebke. (2012) BaSTA: an R package for Bayesian estimation of age-specific survival from incomplete mark-recapture/recovery data with covariates. <em>Method in Ecology and Evolution</em>. DOI: 10.1111/j.2041-210X.2012.00186.x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basta">basta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load BaSTA output:
data("bastaCMRout", package = "BaSTA")

## Print summary output:
summary(bastaCMRout)

## Plot traces for mortality parameters (theta):
plot(bastaCMRout)

## Plot traces for proportional hazards parameters (gamma):
plot(bastaCMRout, trace.name = "gamma")

## Plot traces for recapture probability(ies) (pi):
plot(bastaCMRout, trace.name = "pi")

## Plot predicted mortality and survival:
plot(bastaCMRout, plot.type = "demorates")

## Change the color for each covariate on 
## the predicted vital rates:
plot(bastaCMRout, plot.type = "demorates", 
     col = c("dark green", "dark blue"))

## Change the color and the legend text:
plot(bastaCMRout, plot.type = "demorates", 
     col = c("dark green", "dark blue"),
     names.legend = c("Females", "Males"))

## Plot predicted mortality and survival 
## between 2 and 8 years of age:
plot(bastaCMRout, plot.trace = FALSE, xlim = c(2, 8))

## Plot predicted mortality and survival 
## between 2 and 8 years of age without
## credible intervals:
plot(bastaCMRout, plot.trace = FALSE, xlim = c(2, 8), 
     noCI = TRUE)

## Plot parameter densities and predicted vital  
## rates in the same plot (i.e. fancy):
plot(bastaCMRout, fancy = TRUE)

## Change colors and legend names for the 
## "fancy" plot:
plot(bastaCMRout, fancy = TRUE, col = c("dark green", "dark blue"),
     names.legend = c("Females", "Males"))
</code></pre>

<hr>
<h2 id='summary.bastaCheckCMR'>
Summary of outputs from the data checking function in BaSTA.
</h2><span id='topic+summary.bastaCheckCMR'></span><span id='topic+summary.bastaCheckCens'></span><span id='topic+print.bastaCheckCMR'></span><span id='topic+print.bastaCheckCens'></span>

<h3>Description</h3>

<p>These function provide general information about the input data set to be used for BaSTA, as well as detailes on potential issues that could have been found on the data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'bastaCheckCMR'
summary(object, ...)

## S3 method for class 'bastaCheckCens'
summary(object, ...)

## S3 method for class 'bastaCheckCMR'
print(x, ...)

## S3 method for class 'bastaCheckCens'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bastaCheckCMR_+3A_object">object</code></td>
<td>
<p>Output from function <code><a href="#topic+DataCheck">DataCheck</a></code></p>
</td></tr>
<tr><td><code id="summary.bastaCheckCMR_+3A_x">x</code></td>
<td>
<p>Output from function <code><a href="#topic+DataCheck">DataCheck</a></code></p>
</td></tr>
<tr><td><code id="summary.bastaCheckCMR_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to functions <code>print</code> and <code>summary</code> (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions print to the screen the results of the <code><a href="#topic+DataCheck">DataCheck</a></code> function.
</p>


<h3>Value</h3>

<p>No return value, prints output to the console
</p>


<h3>Author(s)</h3>

<p>Fernando Colchero <a href="mailto:fernando_colchero@eva.mpg.de">fernando_colchero@eva.mpg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+DataCheck">DataCheck</a></code> for running a data check on the input data for function <code><a href="#topic+basta">basta</a></code>, <code><a href="#topic+FixCMRdata">FixCMRdata</a></code> to fix potential issues for capture-mark-recapture data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## CMR data:
## --------- #
## Load data:
data("bastaCMRdat", package = "BaSTA")

## Check data consistency:
checkedData  &lt;- DataCheck(bastaCMRdat, dataType = "CMR", studyStart = 51, 
                          studyEnd = 70)

## census data:
## ------------ #
## Load data:
data("bastaCensDat", package = "BaSTA")

## Check data consistency:
checkedData  &lt;- DataCheck(object = bastaCensDat, dataType = "census")

## Printed output:
## --------------- #
## Print DataCheck results:
print(checkedData)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
