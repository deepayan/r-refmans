<!DOCTYPE html><html><head><title>Help for package MESS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MESS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MESS'><p>Collection of miscellaneous useful and semi-useful functions</p></a></li>
<li><a href='#adaptive.weights'><p>Compute weights for use with adaptive lasso.</p></a></li>
<li><a href='#add_torows'><p>Fast addition of vector to each row of matrix</p></a></li>
<li><a href='#age'><p>Compute the age of a person from two dates.</p></a></li>
<li><a href='#auc'><p>Compute the area under the curve for two vectors.</p></a></li>
<li><a href='#bdstat'><p>Danish live births and deaths</p></a></li>
<li><a href='#bees'><p>Bee data. Number of different types of bees caught.</p></a></li>
<li><a href='#bin'><p>Fast binning of numeric vector into equidistant bins</p></a></li>
<li><a href='#categorize'><p>A table function to use with magrittr pipes</p></a></li>
<li><a href='#clipit'><p>Copy an object as R-code to the clipboard</p></a></li>
<li><a href='#clotting'><p>Blood clotting for 158 rats</p></a></li>
<li><a href='#cmd'><p>Correlation matrix distance</p></a></li>
<li><a href='#col.alpha'><p>Add and set alpha channel for RGB color</p></a></li>
<li><a href='#col.shade'><p>Shade an RGB color</p></a></li>
<li><a href='#col.tint'><p>Tint an RGB color</p></a></li>
<li><a href='#colCumSum'><p>Apply cumsum to each column of matrix</p></a></li>
<li><a href='#common.shared'><p>Compute a common shared environment matrix</p></a></li>
<li><a href='#conditional_rowMeans'><p>Form row means conditional on number of non-missing</p></a></li>
<li><a href='#cumsumbinning'><p>Binning based on cumulative sum with reset above threshold</p></a></li>
<li><a href='#dCor'><p>Fast distance correlation matrix</p></a></li>
<li><a href='#dCov'><p>Fast distance covariance matrix</p></a></li>
<li><a href='#drop1.geeglm'><p>Drop All Possible Single Terms to a geeglm Model Using Wald or Score Test</p></a></li>
<li><a href='#drop1.geem'><p>Drop All Possible Single Terms to a geem Model Using Wald or Score Test</p></a></li>
<li><a href='#earthquakes'><p>Earthquakes in 2015</p></a></li>
<li><a href='#expand_table'><p>Expand table or matrix to data frame</p></a></li>
<li><a href='#extended.shared'><p>Compute a common shared environment matrix</p></a></li>
<li><a href='#fac2num'><p>Convert factor to numeric vector</p></a></li>
<li><a href='#feature.test'><p>Inference for features identified by the Lasso</p></a></li>
<li><a href='#filldown'><p>Fill down NA with the last observed observation</p></a></li>
<li><a href='#founder.shared'><p>Compute a common shared environment matrix</p></a></li>
<li><a href='#geekin'><p>Fit a generalized estimating equation (GEE) model with fixed additive</p>
correlation structure</a></li>
<li><a href='#gkgamma'><p>Goodman-Kruskal's gamma statistic for a two-dimensional table</p></a></li>
<li><a href='#greenland'><p>Average yearly summer air temperature for Tasiilaq, Greenland</p></a></li>
<li><a href='#happiness'><p>Happiness score and tax rates for 148 countries</p></a></li>
<li><a href='#ht'><p>Show the head and tail of an object</p></a></li>
<li><a href='#hwe_frequencies'><p>Fast estimation of allele and genotype frequencies under Hardy-Weinberg equilibrium</p></a></li>
<li><a href='#icecreamads'><p>Ice cream consumption and advertising</p></a></li>
<li><a href='#ks_cumtest'><p>Kolmogorov-Smirnov goodness of fit test for cumulative discrete data</p></a></li>
<li><a href='#kwdata'><p>Non-parametric Kruskal Wallis data example</p></a></li>
<li><a href='#lifeexpect'><p>Estimated life expectancy for Danish newborns</p></a></li>
<li><a href='#loadRData'><p>Load and extract object from RData file</p></a></li>
<li><a href='#lower.tri.vector'><p>Split Matrix by Clusters and Return Lower Triangular Parts as Vector</p></a></li>
<li><a href='#matched'><p>Flu hospitalization</p></a></li>
<li><a href='#maximum_subarray'><p>Fast computation of maximum sum subarray</p></a></li>
<li><a href='#mfastLmCpp'><p>Fast marginal simple regresion analyses</p></a></li>
<li><a href='#monte_carlo_chisq_test'><p>Two-sided table test with fixed margins</p></a></li>
<li><a href='#nh4'><p>Ammonia nitrogen found in river</p></a></li>
<li><a href='#ordered.clusters'><p>Check if unique elements of a vector appear in contiguous clusters</p></a></li>
<li><a href='#pairwise_combination_indices'><p>Compute all pairwise combinations of indices</p></a></li>
<li><a href='#pairwise_Schur_product'><p>Compute Schur products (element-wise) of all pairwise combinations of columns in matrix</p></a></li>
<li><a href='#pairwise.cor.test'><p>Pairwise Tests for Association/Correlation Between Paired Samples</p></a></li>
<li><a href='#panel.hist'><p>Panel plot of histogram and density curve</p></a></li>
<li><a href='#panel.r2'><p>Panel plot of R2 values for pairs</p></a></li>
<li><a href='#picea'><p>Ozone concentration damage to picea spruce</p></a></li>
<li><a href='#plr'><p>Fast computation of several simple linear regressions</p></a></li>
<li><a href='#power_binom_test'><p>Power Calculations for Exact Test of a simple null hypothesis in a Bernoulli</p>
experiment</a></li>
<li><a href='#power_mcnemar_test'><p>Power Calculations for Exact and Asymptotic McNemar Test in a 2 by 2 table</p></a></li>
<li><a href='#power_prop_test'><p>Power Calculations for Two-Sample Test for Proportions with unequal sample size</p></a></li>
<li><a href='#power_t_test'><p>Power calculations for one and two sample t tests with unequal sample size</p></a></li>
<li><a href='#prepost.test'><p>Pretest-posttest RCT for quantitative observations with possible missing values</p></a></li>
<li><a href='#qdiag'><p>Fast extraction of matrix diagonal</p></a></li>
<li><a href='#QIC.geeglm'><p>Quasi Information Criterion</p></a></li>
<li><a href='#qpcr'><p>Gene expression from real-time quantitative PCR</p></a></li>
<li><a href='#quadform'><p>Fast quadratic form computation</p></a></li>
<li><a href='#rainman'><p>Perception of points in a swarm</p></a></li>
<li><a href='#repmat'><p>Fast replication of a matrix</p></a></li>
<li><a href='#residual_plot'><p>Plots a standardized residual</p></a></li>
<li><a href='#residualplot.default'><p>Plots a standardized residual</p></a></li>
<li><a href='#rmvt.pedigree'><p>Simulate residual multivariate t-distributed data from a polygenic model</p></a></li>
<li><a href='#rmvtnorm.pedigree'><p>Simulate residual multivariate Gaussian data from a polygenic model</p></a></li>
<li><a href='#rnorm_perfect'><p>Simulate values from a perfect normal distribution</p></a></li>
<li><a href='#rootonorm'><p>Hanging rootogram for normal distribution</p></a></li>
<li><a href='#round_percent'><p>Round vector of number to percentages</p></a></li>
<li><a href='#rud'><p>Simulate randomized urn design</p></a></li>
<li><a href='#scorefct'><p>Internal functions for the MESS package</p></a></li>
<li><a href='#screen_variables'><p>Screen variable before penalized regression</p></a></li>
<li><a href='#segregate.genes'><p>Segregate genes through a pedigree</p></a></li>
<li><a href='#sinv'><p>Invert a symmetric positive-definite matrix</p></a></li>
<li><a href='#smokehealth'><p>Effect of smoking on self reported health</p></a></li>
<li><a href='#soccer'><p>Danish national soccer players</p></a></li>
<li><a href='#superroot2'><p>Gene expression data from two-color dye-swap experiment</p></a></li>
<li><a href='#tracemp'><p>Fast computation of trace of matrix product</p></a></li>
<li><a href='#usd'><p>Unbiased standard deviation</p></a></li>
<li><a href='#wallyplot.default'><p>Plots a Wally plot</p></a></li>
<li><a href='#write.xml'><p>Write a data frame in XML format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Miscellaneous Esoteric Statistical Scripts</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.12</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Claus Thorn Ekstrøm &lt;claus@rprimer.dk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Matrix, Rcpp, clipr, geepack, geeM, ggplot2, ggformula,
glmnet, kinship2, methods, mvtnorm, parallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, lme4, magrittr, rmarkdown, testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>A mixed collection of useful and semi-useful diverse
    statistical functions, some of which may even be referenced in
    The R Primer book.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ekstroem/MESS">https://github.com/ekstroem/MESS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ekstroem/MESS/issues">https://github.com/ekstroem/MESS/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-20 18:07:44 UTC; ekstrom</td>
</tr>
<tr>
<td>Author:</td>
<td>Claus Thorn Ekstrøm [aut, cre],
  Niels Aske Lundtorp Olsen [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-20 22:52:48 UTC</td>
</tr>
</table>
<hr>
<h2 id='MESS'>Collection of miscellaneous useful and semi-useful functions</h2><span id='topic+MESS'></span><span id='topic+MESS-package'></span>

<h3>Description</h3>

<p>Collection of miscellaneous useful and semi-useful functions and add-on
functions that enhances a number of existing packages and provides In
particular in relation to statistical genetics
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> MESS</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.0</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2012-03-29</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
 
<p>how to use the package, including the most important ~~ 
</p>


<h3>Author(s)</h3>

<p>Claus Thorn Ekstrøm <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a><br /> Maintainer: Claus Thorn Ekstrøm
<a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Ekstrøm, C. (2011). The R Primer. Chapman &amp; Hall.
</p>

<hr>
<h2 id='adaptive.weights'>Compute weights for use with adaptive lasso.</h2><span id='topic+adaptive.weights'></span>

<h3>Description</h3>

<p>Fast computation of weights needed for adaptive lasso based on Gaussian
family data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptive.weights(x, y, nu = 1, weight.method = c("multivariate", "univariate"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptive.weights_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an observation
vector.</p>
</td></tr>
<tr><td><code id="adaptive.weights_+3A_y">y</code></td>
<td>
<p>response variable.</p>
</td></tr>
<tr><td><code id="adaptive.weights_+3A_nu">nu</code></td>
<td>
<p>non-negative tuning parameter</p>
</td></tr>
<tr><td><code id="adaptive.weights_+3A_weight.method">weight.method</code></td>
<td>
<p>Should the weights be computed for multivariate
regression model (only possible when the number of observations is larger
than the number of parameters) or by individual marginal/&quot;univariate&quot;
regression coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weights returned are 1/abs(beta_hat)^nu where the beta-parameters are
estimated from the corresponding linear model (either multivariate or
univariate).
</p>


<h3>Value</h3>

<p>Returns a list with two elements: </p>
<table>
<tr><td><code>weights</code></td>
<td>
<p>the computed
weights</p>
</td></tr> <tr><td><code>nu</code></td>
<td>
<p>the value of nu used for the computations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Xou, H (2006). The Adaptive Lasso and Its Oracle Properties.
JASA, Vol. 101.
</p>


<h3>See Also</h3>

<p><code>glmnet</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
x &lt;- matrix(rnorm(50000), nrow=50)
y &lt;- rnorm(50, mean=x[,1])
weights &lt;- adaptive.weights(x, y)

if (requireNamespace("glmnet", quietly = TRUE)) {
    res &lt;- glmnet::glmnet(x, y, penalty.factor=weights$weights)
    head(res)
}

</code></pre>

<hr>
<h2 id='add_torows'>Fast addition of vector to each row of matrix</h2><span id='topic+add_torows'></span>

<h3>Description</h3>

<p>Fast addition of vector to each row of a matrix. This corresponds to t(t(x) + v)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_torows(x, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_torows_+3A_x">x</code></td>
<td>
<p>A matrix with dimensions n*k.</p>
</td></tr>
<tr><td><code id="add_torows_+3A_v">v</code></td>
<td>
<p>A vector of length k.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension n*k where v is added to each row of x
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- matrix(1:12, ncol=3)
B &lt;- c(1, 2, 3)

add_torows(A, B)

</code></pre>

<hr>
<h2 id='age'>Compute the age of a person from two dates.</h2><span id='topic+age'></span>

<h3>Description</h3>

<p>Compute the age in years of an individual based on the birth date and another (subsequent) date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age_+3A_from">from</code></td>
<td>
<p>a vector of dates (birth dates)</p>
</td></tr>
<tr><td><code id="age_+3A_to">to</code></td>
<td>
<p>a vector of current dates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the full number of years that a person is old on a given date.
</p>


<h3>Value</h3>

<p>A vector of ages (in years)
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.POSIXlt">as.POSIXlt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
born &lt;- c("1971-08-18", "2000-02-28", "2001-12-20")
check &lt;- c("2016-08-28")
age(born, check)

</code></pre>

<hr>
<h2 id='auc'>Compute the area under the curve for two vectors.</h2><span id='topic+auc'></span>

<h3>Description</h3>

<p>Compute the area under the curve using linear or natural spline
interpolation for two vectors where one corresponds to the x values and the
other corresponds to the y values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(
  x,
  y,
  from = min(x, na.rm = TRUE),
  to = max(x, na.rm = TRUE),
  type = c("linear", "spline"),
  absolutearea = FALSE,
  subdivisions = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_+3A_x">x</code></td>
<td>
<p>a numeric vector of x values.</p>
</td></tr>
<tr><td><code id="auc_+3A_y">y</code></td>
<td>
<p>a numeric vector of y values of the same length as x.</p>
</td></tr>
<tr><td><code id="auc_+3A_from">from</code></td>
<td>
<p>The value from where to start calculating the area under the
curve. Defaults to the smallest x value.</p>
</td></tr>
<tr><td><code id="auc_+3A_to">to</code></td>
<td>
<p>The value from where to end the calculation of the area under the
curve. Defaults to the greatest x value.</p>
</td></tr>
<tr><td><code id="auc_+3A_type">type</code></td>
<td>
<p>The type of interpolation. Defaults to &quot;linear&quot; for area under
the curve for linear interpolation. The value &quot;spline&quot; results in the area
under the natural cubic spline interpolation.</p>
</td></tr>
<tr><td><code id="auc_+3A_absolutearea">absolutearea</code></td>
<td>
<p>A logical value that determines if negative
areas should be added to the total area under the curve.  By
default the auc function subtracts areas that have negative y
values. Set <code>absolutearea=TRUE</code> to _add_ the absolute value of the negative areas to the total area.</p>
</td></tr>
<tr><td><code id="auc_+3A_subdivisions">subdivisions</code></td>
<td>
<p>an integer telling how many subdivisions should be used for integrate (for non-linear approximations)</p>
</td></tr>
<tr><td><code id="auc_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to approx (for linear approximations). In particular rule can be set to determine how values outside the range of x is handled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For linear interpolation the auc function computes the area under the curve
using the composite trapezoid rule.  For area under a spline interpolation,
auc uses the splinefun function in combination with the integrate to
calculate a numerical integral. The auc function can handle unsorted time
values, missing observations, ties for the time values, and integrating over
part of the area or even outside the area.
</p>


<h3>Value</h3>

<p>The value of the area under the curve.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+approx">approx</a></code>, <code><a href="stats.html#topic+splinefun">splinefun</a></code>,
<code><a href="stats.html#topic+integrate">integrate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1:4
y &lt;- c(0, 1, 1, 5)
auc(x, y)

# AUC from 0 to max(x) where we allow for extrapolation
auc(x, y, from=0, rule=2)

# Use value 0 to the left
auc(x, y, from=0, rule=2, yleft=0)

# Use 1/2 to the left
auc(x, y, from=0, rule=2, yleft=.5)

# Use 1/2 to the left with spline interpolation
auc(x, y, from=0, rule=2, yleft=.5)


</code></pre>

<hr>
<h2 id='bdstat'>Danish live births and deaths</h2><span id='topic+bdstat'></span>

<h3>Description</h3>

<p>Monthly live births and deaths in Denmark from January 1901 to March 2013.
</p>


<h3>Format</h3>

<p>A data frame with 1356 observations on the following 4 variables.
</p>
 <dl>
<dt>year</dt><dd><p>a numeric vector giving the month</p>
</dd>
<dt>month</dt><dd><p>a numeric vector giving the year</p>
</dd>
<dt>births</dt><dd><p>a numeric vector. The number of births for the given
month and year</p>
</dd> <dt>dead</dt><dd><p>a numeric vector. The number of deaths
for the given month and year</p>
</dd> </dl>



<h3>Source</h3>

<p>Data were obtained from the StatBank from Danmarks Statistik, see
<a href="http://www.statbank.dk">http://www.statbank.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bdstat)

plot(bdstat$year + bdstat$month/13, bdstat$birth, type="l")

# Create a table of births
# Remove year 2013 as it is incomplete
btable &lt;- xtabs(births ~ year + month, data=bdstat, subset=(year&lt;2013))

# Compute yearly birth frequencies per month
btable.freq &lt;- prop.table(btable, margin=1)

</code></pre>

<hr>
<h2 id='bees'>Bee data. Number of different types of bees caught.</h2><span id='topic+bees'></span>

<h3>Description</h3>

<p>Number of different types of bees caught in plates of different colours.
There are four locations and within each location there are three replicates
consisting of three plates of the three different colours (yellow, white and
blue). Data are collected at 5 different dates over the summer season. Only
data from one date available until data has been published.
</p>


<h3>Format</h3>

<p>A data frame with 72 observations on the following 7 variables.
</p>
 <dl>
<dt>Locality</dt><dd><p>a factor with levels <code>Havreholm</code>
<code>Kragevig</code> <code>Saltrup</code> <code>Svaerdborg</code>. Four different localities
in Denmark.</p>
</dd> <dt>Replicate</dt><dd><p>a factor with levels <code>A</code> <code>B</code>
<code>C</code></p>
</dd> <dt>Color</dt><dd><p>a factor with levels <code>Blue</code> <code>White</code>
<code>Yellow</code>. Colour of plates</p>
</dd> <dt>Time</dt><dd><p>a factor with levels
<code>july1</code> <code>july14</code> <code>june17</code> <code>june3</code> <code>june6</code>. Data
collected at different dates in summer season. Only one day is present in
the current data frame until the full data has been released.</p>
</dd>
<dt>Type</dt><dd><p>a factor with levels <code>Bumblebees</code> <code>Solitary</code>.
Type of bee.</p>
</dd> <dt>Number</dt><dd><p>a numeric vector. The response variable
with number of bees catched.</p>
</dd> <dt>id</dt><dd><p>a numeric vector. The id of
the clusters (each containg three plates).</p>
</dd> </dl>



<h3>Source</h3>

<p>Data were kindly provided by Casper Ingerslev Henriksen, Department
of Agricultural Sciences, KU-LIFE. Added by Torben Martinussen
&lt;tma@life.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bees)
model &lt;- glm(Number ~ Locality + Type*Color,
             family=poisson, data=bees)

</code></pre>

<hr>
<h2 id='bin'>Fast binning of numeric vector into equidistant bins</h2><span id='topic+bin'></span>

<h3>Description</h3>

<p>Fast binning of numeric vector into equidistant bins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin(x, width, origin = 0, missinglast = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_+3A_x">x</code></td>
<td>
<p>A matrix of regressor variables. Must have the same number of rows as the length of y.</p>
</td></tr>
<tr><td><code id="bin_+3A_width">width</code></td>
<td>
<p>The width of the bins</p>
</td></tr>
<tr><td><code id="bin_+3A_origin">origin</code></td>
<td>
<p>The starting point for the bins. Any number smaller than origin will be disregarded</p>
</td></tr>
<tr><td><code id="bin_+3A_missinglast">missinglast</code></td>
<td>
<p>Boolean. Should the missing observations be added as a separate element at the end of the returned count vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values (NA, Inf, NaN) are added at the end of the vector as the last bin returned if missinglast is set to TRUE
</p>


<h3>Value</h3>

<p>An list with elements counts (the frequencies), origin (the origin), width (the width), missing (the number of missings), and last_bin_is_missing (boolean) telling whether the missinglast is true or not.
</p>


<h3>Author(s)</h3>

<p>Hadley Wickham (from SO: https://stackoverflow.com/questions/13661065/superimpose-histogram-fits-in-one-plot-ggplot) - adapted here by Claus Ekstrøm &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
x &lt;- sample(10, 20, replace = TRUE)
bin(x, 15)

</code></pre>

<hr>
<h2 id='categorize'>A table function to use with magrittr pipes</h2><span id='topic+categorize'></span>

<h3>Description</h3>

<p>Accepts a data frame as input and computes a contingency table for direct use in combination with the magrittr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>categorize(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="categorize_+3A_.data">.data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="categorize_+3A_...">...</code></td>
<td>
<p>A formula (as in xtabs) or one or more objects which can be interpreted as factors (including character strings), or a list (or data frame) whose components can be so interpreted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>categorize is a wrapper to xtabs or table such that a data frame can be given as the first argument.
</p>


<h3>Value</h3>

<p>A table (possibly as an xtabs class if a model formula was used)
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("magrittr", quietly = TRUE)) {
    library(magrittr)

    esoph %&gt;% categorize(alcgp, agegp)
    esoph %&gt;% categorize(~ alcgp + agegp)
}

</code></pre>

<hr>
<h2 id='clipit'>Copy an object as R-code to the clipboard</h2><span id='topic+clipit'></span>

<h3>Description</h3>

<p>Copies an R object to the clipboard so it can be pasted in elsewhere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clipit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clipit_+3A_x">x</code></td>
<td>
<p>object to copy</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns nothing but will place the object in the clipboard
</p>


<h3>Value</h3>

<p>Nothing but will put the R object into the clipboard as a side effect
</p>


<h3>Author(s)</h3>

<p>Jonas LindeLøv posted on twitter. Copied shamelessly by Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
clipit(mtcars$mpg)

## End(Not run)

</code></pre>

<hr>
<h2 id='clotting'>Blood clotting for 158 rats</h2><span id='topic+clotting'></span>

<h3>Description</h3>

<p>Blood clotting activity (PCA) is measured for 158 Norway rats from two
locations just before (baseline) and four days after injection of an
anticoagulant (bromadiolone). Normally this would cause reduced blood
clotting after 4 days compared to the baseline, but these rats are known to
possess anticoagulent resistence to varying extent. The purpose is to relate
anticoagulent resistence to gender and location and perhaps weight. Dose of
injection is, however, admistered according to weight and gender.
</p>


<h3>Format</h3>

<p>A data frame with 158 observations on the following 6 variables.
</p>
 <dl>
<dt>rat</dt><dd><p>a numeric vector</p>
</dd> <dt>locality</dt><dd><p>a
factor with levels <code>Loc1</code> <code>Loc2</code></p>
</dd> <dt>sex</dt><dd><p>a factor with
levels <code>F</code> <code>M</code></p>
</dd> <dt>weight</dt><dd><p>a numeric vector</p>
</dd>
<dt>PCA0</dt><dd><p>a numeric vector with percent blood clotting activity at
baseline</p>
</dd> <dt>PCA4</dt><dd><p>a numeric vector with percent blood clotting
activity on day 4</p>
</dd> </dl>



<h3>Source</h3>

<p>Ann-Charlotte Heiberg, project at The Royal Veterinary and
Agricultural University, 1999. <br /> Added by Ib M. Skovgaard &lt;ims@life.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(clotting)
 dim(clotting)
 head(clotting)
 day0= transform(clotting, day=0, pca=PCA0)
 day4= transform(clotting, day=4, pca=PCA4)
 day.both= rbind(day0,day4)
 m1= lm(pca ~ rat + day*locality + day*sex, data=day.both)
 anova(m1)
 summary(m1)
 m2= lm(pca ~ rat + day, data=day.both)
 anova(m2)
## Log transformation suggested.
## Random effect of rat.
## maybe str(clotting) ; plot(clotting) ...

</code></pre>

<hr>
<h2 id='cmd'>Correlation matrix distance</h2><span id='topic+cmd'></span>

<h3>Description</h3>

<p>Computes the correlation matrix distance between two correlation matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_+3A_x">x</code></td>
<td>
<p>First correlation matrix</p>
</td></tr>
<tr><td><code id="cmd_+3A_y">y</code></td>
<td>
<p>Second correlation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the correlation matrix distance, which is a value between 0 and 1. The correlation matrix distance becomes
zero for equal correlation matrices and unity if they differ to a maximum extent.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Herdin, M., and Czink, N., and Ozcelik, H., and Bonek, E. (2005). <em>Correlation matrix distance, a meaningful measure for
evaluation of non-stationary mimo channels</em>. IEEE VTC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m1 &lt;- matrix(rep(1, 16), 4)
m2 &lt;- matrix(c(1, 0, .5, .5, 0, 1, .5, .5, .5, .5, 1, .5, .5, .5, .5, 1), 4)
m3 &lt;- matrix(c(1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), 4)
cmd(m1, m1)
cmd(m1, m2)
cmd(m2, m3)

</code></pre>

<hr>
<h2 id='col.alpha'>Add and set alpha channel for RGB color</h2><span id='topic+col.alpha'></span>

<h3>Description</h3>

<p>Add and set alpha channel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col.alpha(col, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col.alpha_+3A_col">col</code></td>
<td>
<p>a vector of RGB color(s)</p>
</td></tr>
<tr><td><code id="col.alpha_+3A_alpha">alpha</code></td>
<td>
<p>numeric value between 0 and 1. Zero results fully transparent and 1 means full opacity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds and set an alpha channel to a RGB color
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Ekstrom, CT (2011) <em>The R Primer</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
newcol &lt;- col.alpha("blue", .5)

</code></pre>

<hr>
<h2 id='col.shade'>Shade an RGB color</h2><span id='topic+col.shade'></span>

<h3>Description</h3>

<p>Shades an RBG color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col.shade(col, shade = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col.shade_+3A_col">col</code></td>
<td>
<p>a vector of RGB color(s)</p>
</td></tr>
<tr><td><code id="col.shade_+3A_shade">shade</code></td>
<td>
<p>numeric value between 0 and 1. Zero means no change and 1 results in black</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function shades an RGB color and returns the shaded RGB color (with alpha channel added)
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Ekstrom, CT (2011) <em>The R Primer</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
newcol &lt;- col.shade("blue")

</code></pre>

<hr>
<h2 id='col.tint'>Tint an RGB color</h2><span id='topic+col.tint'></span>

<h3>Description</h3>

<p>Tints an RBG color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col.tint(col, tint = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col.tint_+3A_col">col</code></td>
<td>
<p>a vector of RGB color(s)</p>
</td></tr>
<tr><td><code id="col.tint_+3A_tint">tint</code></td>
<td>
<p>numeric value between 0 and 1. Zero results in white and 1 means no change</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tints an RGB color and returns the tinted RGB color (with alpha channel added)
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Ekstrom, CT (2011) <em>The R Primer</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
newcol &lt;- col.tint("blue")

</code></pre>

<hr>
<h2 id='colCumSum'>Apply cumsum to each column of matrix</h2><span id='topic+colCumSum'></span>

<h3>Description</h3>

<p>Fast computation of apply(m, 2, cumsum)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colCumSum(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colCumSum_+3A_m">m</code></td>
<td>
<p>A matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix the same size as m with the column-wise cumulative sums.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Generate a 100 by 10000 matrix
  x &lt;- matrix(rnorm(100*10000), nrow=100)
  result &lt;- colCumSum(x)

</code></pre>

<hr>
<h2 id='common.shared'>Compute a common shared environment matrix</h2><span id='topic+common.shared'></span><span id='topic+common.shared.pedigreeList'></span><span id='topic+common.shared.pedigree'></span>

<h3>Description</h3>

<p>Compute the common shared environment matrix for a set of related subjects.
The function is generic, and can accept a pedigree, or pedigreeList as the
first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common.shared(id, ...)

## S3 method for class 'pedigreeList'
common.shared(id, ...)

## S3 method for class 'pedigree'
common.shared(id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="common.shared_+3A_id">id</code></td>
<td>
<p>either a pedigree object or pedigreeList object</p>
</td></tr>
<tr><td><code id="common.shared_+3A_...">...</code></td>
<td>
<p>Any number of optional arguments. Not used at the moment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When called with a pedigreeList, i.e., with multiple families, the routine
will create a block-diagonal-symmetric &lsquo;bdsmatrix&rsquo; object.  Since the [i,j]
value of the result is 0 for any two unrelated individuals i and j and a
&lsquo;bdsmatix&rsquo; utilizes sparse representation, the resulting object is often
orders of magnitude smaller than an ordinary matrix.  When called with a
single pedigree and ordinary matrix is returned.
</p>


<h3>Value</h3>

<p>a matrix of shared environment coefficients
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>See Also</h3>

<p><code>pedigree</code>, <code>kinship</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(kinship2)
test1 &lt;- data.frame(id  =c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14),
                    mom =c(0, 0, 0, 0, 2, 2, 4, 4, 6,  2,  0,  0, 12, 13),
                    dad =c(0, 0, 0, 0, 1, 1, 3, 3, 3,  7,  0,  0, 11, 10),
                    sex =c(1, 2, 1, 2, 1, 2, 1, 2, 1,  1,  1,  2,  2,  2))
tped &lt;- with(test1, pedigree(id, dad, mom, sex))
common.shared(tped)

</code></pre>

<hr>
<h2 id='conditional_rowMeans'>Form row means conditional on number of non-missing</h2><span id='topic+conditional_rowMeans'></span>

<h3>Description</h3>

<p>Form row means for multiple vectors, numeric arrays (or data frames) conditional on the number of non-missing observations.
NA is returned unless a minimum number of observations is observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_rowMeans(..., minobs = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditional_rowMeans_+3A_...">...</code></td>
<td>
<p>a series of numeric vectors, arrays, or data frames that have can be combined with cbind</p>
</td></tr>
<tr><td><code id="conditional_rowMeans_+3A_minobs">minobs</code></td>
<td>
<p>an integer stating the minimum number of non-NA observations necessary to compute the row mean. Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the row sums or NA if not enough non-NA observations are present
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conditional_rowMeans(1:5, c(1:4, NA), c(1:3, NA, NA))
conditional_rowMeans(1:5, c(1:4, NA), c(1:3, NA, NA), minobs=0)
conditional_rowMeans(1:5, c(1:4, NA), c(1:3, NA, NA), minobs=2)

</code></pre>

<hr>
<h2 id='cumsumbinning'>Binning based on cumulative sum with reset above threshold</h2><span id='topic+cumsumbinning'></span>

<h3>Description</h3>

<p>Fast binning of cumulative vector sum with new groups when the sum passes a threshold or the group size becomes too large
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumsumbinning(x, threshold, cutwhenpassed = FALSE, maxgroupsize = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumsumbinning_+3A_x">x</code></td>
<td>
<p>A matrix of regressor variables. Must have the same number of rows as the length of y.</p>
</td></tr>
<tr><td><code id="cumsumbinning_+3A_threshold">threshold</code></td>
<td>
<p>The value of the threshold that the cumulative group sum must not cross OR the threshold that each group sum must pass (when the argument cuwhatpassed is set to TRUE).</p>
</td></tr>
<tr><td><code id="cumsumbinning_+3A_cutwhenpassed">cutwhenpassed</code></td>
<td>
<p>A boolean. Should the threshold be the upper limit of the group sum (the default) or the value that each group sum needs to pass (when set to TRUE).</p>
</td></tr>
<tr><td><code id="cumsumbinning_+3A_maxgroupsize">maxgroupsize</code></td>
<td>
<p>An integer that defines the maximum number of elements in each group. NAs count as part of each group but do not add to the group sum. NULL (the default) corresponds to no group size limits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values (NA, Inf, NaN) are completely disregarded and pairwise complete cases are used f
</p>


<h3>Value</h3>

<p>An integer vector giving the group indices
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
x &lt;- sample(10, 20, replace = TRUE)
cumsumbinning(x, 15)
cumsumbinning(x, 15, 3)

x &lt;- c(3, 4, 5, 12, 1, 5, 3)
cumsumbinning(x, 10)
cumsumbinning(x, 10, cutwhenpassed=TRUE)

</code></pre>

<hr>
<h2 id='dCor'>Fast distance correlation matrix</h2><span id='topic+dCor'></span>

<h3>Description</h3>

<p>Fast computation of the distance correation matrix between two matrices with the same number of rows. Note that this is not the same as the correlation matrix distance that can be computed with the cmd function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCor(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCor_+3A_x">x</code></td>
<td>
<p>A matrix with dimensions n*k.</p>
</td></tr>
<tr><td><code id="dCor_+3A_y">y</code></td>
<td>
<p>A matrix with dimensions n*l.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number between 0 and 1 representing the distance covariance between x and y
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>

<hr>
<h2 id='dCov'>Fast distance covariance matrix</h2><span id='topic+dCov'></span>

<h3>Description</h3>

<p>Fast computation of the distance covariance between two matrices with the same number of rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCov(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCov_+3A_x">x</code></td>
<td>
<p>A matrix with dimensions n*k.</p>
</td></tr>
<tr><td><code id="dCov_+3A_y">y</code></td>
<td>
<p>A matrix with dimensions n*l.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number representing the distance covariance between x and y
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>

<hr>
<h2 id='drop1.geeglm'>Drop All Possible Single Terms to a geeglm Model Using Wald or Score Test</h2><span id='topic+drop1.geeglm'></span>

<h3>Description</h3>

<p>Compute all the single terms in the scope argument that can dropped from the
model, and compute a table of the corresponding Wald test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geeglm'
drop1(
  object,
  scope,
  test = c("Wald", "none", "score", "sasscore"),
  method = c("robust", "naive", "sandwich"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop1.geeglm_+3A_object">object</code></td>
<td>
<p>a fitted object of class geese.</p>
</td></tr>
<tr><td><code id="drop1.geeglm_+3A_scope">scope</code></td>
<td>
<p>a formula giving the terms to be considered for adding or dropping.</p>
</td></tr>
<tr><td><code id="drop1.geeglm_+3A_test">test</code></td>
<td>
<p>the type of test to include.</p>
</td></tr>
<tr><td><code id="drop1.geeglm_+3A_method">method</code></td>
<td>
<p>Indicates which method is used for computing the standard
error. <code>robust</code> is the default and corresponds to the modified sandwich
estimator. <code>naive</code> is the classical naive cariance estimate.
<code>sandwich</code> is an alias for <code>robust</code>.</p>
</td></tr>
<tr><td><code id="drop1.geeglm_+3A_...">...</code></td>
<td>
<p>other arguments. Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;anova&quot; summarizing the differences in fit
between the models.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@ekstroem.dk">claus@ekstroem.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+drop1">drop1</a></code>, <code>geeglm</code>, <code>geese</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(geepack)
data(ohio)
fit &lt;- geeglm(resp ~ age + smoke + age:smoke, id=id, data=ohio,
             family=binomial, corstr="exch", scale.fix=TRUE)
drop1(fit)

</code></pre>

<hr>
<h2 id='drop1.geem'>Drop All Possible Single Terms to a geem Model Using Wald or Score Test</h2><span id='topic+drop1.geem'></span>

<h3>Description</h3>

<p>Compute all the single terms in the scope argument that can dropped from the
model, and compute a table of the corresponding Wald test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geem'
drop1(
  object,
  scope,
  test = c("Wald", "none", "score", "sasscore"),
  method = c("robust", "naive", "sandwich"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop1.geem_+3A_object">object</code></td>
<td>
<p>a fitted object of class geese.</p>
</td></tr>
<tr><td><code id="drop1.geem_+3A_scope">scope</code></td>
<td>
<p>a formula giving the terms to be considered for adding or dropping.</p>
</td></tr>
<tr><td><code id="drop1.geem_+3A_test">test</code></td>
<td>
<p>the type of test to include.</p>
</td></tr>
<tr><td><code id="drop1.geem_+3A_method">method</code></td>
<td>
<p>Indicates which method is used for computing the standard
error. <code>robust</code> is the default and corresponds to the modified sandwich
estimator. <code>naive</code> is the classical naive cariance estimate.
<code>sandwich</code> is an alias for <code>robust</code>.</p>
</td></tr>
<tr><td><code id="drop1.geem_+3A_...">...</code></td>
<td>
<p>other arguments. Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;anova&quot; summarizing the differences in fit
between the models.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@ekstroem.dk">claus@ekstroem.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+drop1">drop1</a></code>, <code>geem</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(geeM)
library(geepack)
data(ohio)
## Not run: 
fit &lt;- geem(resp ~ age + smoke + age:smoke, id=id, data=ohio,
            family="binomial", corstr="exch", scale.fix=TRUE)
drop1(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='earthquakes'>Earthquakes in 2015</h2><span id='topic+earthquakes'></span>

<h3>Description</h3>

<p>Information on earthquakes worldwide in 2015 with a magnitude greater than 3 on the Richter scale. The variables are just a subset of the variables available at the source
</p>


<h3>Format</h3>

<p>A data frame with 19777 observations on the following 22 variables.
</p>
 <dl>
<dt>time</dt><dd><p>a factor with time of the earthquake</p>
</dd>
<dt><code>latitude</code></dt><dd><p>a numeric vector giving the decimal degrees latitude. Negative values for southern latitudes</p>
</dd>
<dt><code>longitude</code></dt><dd><p>a numeric vector giving the decimal degrees longitude. Negative values for western longitudes</p>
</dd>
<dt><code>depth</code></dt><dd><p>Depth of the event in kilometers</p>
</dd>
<dt><code>mag</code></dt><dd><p>The magnitude for the event</p>
</dd>
<dt><code>place</code></dt><dd><p>a factor giving a textual description of named geographic region near to the event. </p>
</dd>
<dt><code>type</code></dt><dd><p>a factor with levels <code>earthquake</code> <code>mining explosion</code> <code>rock burst</code></p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.usgs.gov/programs/earthquake-hazards">https://www.usgs.gov/programs/earthquake-hazards</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(earthquakes)
with(earthquakes, place[which.max(mag)])

</code></pre>

<hr>
<h2 id='expand_table'>Expand table or matrix to data frame</h2><span id='topic+expand_table'></span>

<h3>Description</h3>

<p>Expands a contingency table to a data frame where each observation in the table becomes a single observation in the data frame with corresponding information for each for each combination of the table dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_table(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_table_+3A_x">x</code></td>
<td>
<p>A table or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the table or matrix expanded
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
expand_table(diag(3))
m &lt;- matrix(c(2, 1, 3, 0, 0, 2), 3)
expand_table(m)
result &lt;- expand_table(UCBAdmissions)
head(result)

# Combine into table again
xtabs(~Admit + Gender + Dept, data=result)

</code></pre>

<hr>
<h2 id='extended.shared'>Compute a common shared environment matrix</h2><span id='topic+extended.shared'></span><span id='topic+extended.shared.pedigreeList'></span><span id='topic+extended.shared.pedigree'></span>

<h3>Description</h3>

<p>Compute the common shared environment matrix for a set of related subjects.
The function is generic, and can accept a pedigree, or pedigreeList as the
first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extended.shared(id, rho = 1, theta = 1, ...)

## S3 method for class 'pedigreeList'
extended.shared(id, rho = 1, theta = 1, ...)

## S3 method for class 'pedigree'
extended.shared(id, rho = 1, theta = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extended.shared_+3A_id">id</code></td>
<td>
<p>either a pedigree object or pedigreeList object</p>
</td></tr>
<tr><td><code id="extended.shared_+3A_rho">rho</code></td>
<td>
<p>The correlation between spouses</p>
</td></tr>
<tr><td><code id="extended.shared_+3A_theta">theta</code></td>
<td>
<p>The partial path coefficient from parents to offspring</p>
</td></tr>
<tr><td><code id="extended.shared_+3A_...">...</code></td>
<td>
<p>Any number of optional arguments. Not used at the moment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When called with a pedigreeList, i.e., with multiple families, the routine
will create a block-diagonal-symmetric &lsquo;bdsmatrix&rsquo; object.  Since the [i,j]
value of the result is 0 for any two unrelated individuals i and j and a
&lsquo;bdsmatix&rsquo; utilizes sparse representation, the resulting object is often
orders of magnitude smaller than an ordinary matrix.  When called with a
single pedigree and ordinary matrix is returned.
</p>


<h3>Value</h3>

<p>a matrix of shared environment coefficients
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>See Also</h3>

<p><code>pedigree</code>, <code>kinship</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(kinship2)
test1 &lt;- data.frame(id  =c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14),
                    mom =c(0, 0, 0, 0, 0, 2, 2, 4, 0,  6,  8,  0, 10, 11),
                    dad =c(0, 0, 0, 0, 0, 1, 1, 3, 0,  5,  7,  0,  9, 12),
                    sex =c(1, 2, 1, 2, 1, 2, 1, 2, 1,  2,  2,  1,  2,  2))

tped &lt;- with(test1, pedigree(id, dad, mom, sex))
extended.shared(tped)

</code></pre>

<hr>
<h2 id='fac2num'>Convert factor to numeric vector</h2><span id='topic+fac2num'></span>

<h3>Description</h3>

<p>Converts the factor labels to numeric values and returns the factor as a numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac2num(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac2num_+3A_x">x</code></td>
<td>
<p>A factor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a vector of numeric values. Elements in the input factor that cannot be converted to numeric will produce NA.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of the same length as x
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- factor(c(1,2,1,3,2,1,2,3,1))
fac2num(f)

</code></pre>

<hr>
<h2 id='feature.test'>Inference for features identified by the Lasso</h2><span id='topic+feature.test'></span>

<h3>Description</h3>

<p>Performs randomization tests of features identified by the Lasso
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feature.test(
  x,
  y,
  B = 100,
  type.measure = "deviance",
  s = "lambda.min",
  keeplambda = FALSE,
  olsestimates = TRUE,
  penalty.factor = rep(1, nvars),
  alpha = 1,
  control = list(trace = FALSE, maxcores = 24),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feature.test_+3A_x">x</code></td>
<td>
<p>input matrix, of dimension nobs x nvars; each row is an observation
vector.</p>
</td></tr>
<tr><td><code id="feature.test_+3A_y">y</code></td>
<td>
<p>quantitative response variable of length nobs</p>
</td></tr>
<tr><td><code id="feature.test_+3A_b">B</code></td>
<td>
<p>The number of randomizations used in the computations</p>
</td></tr>
<tr><td><code id="feature.test_+3A_type.measure">type.measure</code></td>
<td>
<p>loss to use for cross-validation. See <code>cv.glmnet</code>
for more information</p>
</td></tr>
<tr><td><code id="feature.test_+3A_s">s</code></td>
<td>
<p>Value of the penalty parameter 'lambda' at which predictions are
required. Default is the entire sequence used to create the model. See
<code>coef.glmnet</code> for more information</p>
</td></tr>
<tr><td><code id="feature.test_+3A_keeplambda">keeplambda</code></td>
<td>
<p>If set to <code>TRUE</code> then the estimated lambda from cross
validation from the original dataset is kept and used for evaluation in the
subsequent randomization datasets. This reduces computation time
substantially as it is not necessary to perform cross validation for each
randomization. If set to a value then that value is used for the value of
lambda. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="feature.test_+3A_olsestimates">olsestimates</code></td>
<td>
<p>Logical. Should the test statistic be based on OLS
estimates from the model based on the variables selected by the lasso.
Defaults to <code>TRUE</code>. If set to <code>FALSE</code> then the coefficients from
the lasso is used as test statistics.</p>
</td></tr>
<tr><td><code id="feature.test_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>a vector of weights used for adaptive lasso. See
<code>glmnet</code> for more information.</p>
</td></tr>
<tr><td><code id="feature.test_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter. See <code>glmnet</code> for more
information.</p>
</td></tr>
<tr><td><code id="feature.test_+3A_control">control</code></td>
<td>
<p>A list of options that control the algorithm. Currently
<code>trace</code> is a logical and if set to <code>TRUE</code> then the function
produces more output. <code>maxcores</code> sets the maximum number of cores to
use with the <code>parallel</code> package</p>
</td></tr>
<tr><td><code id="feature.test_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>glmnet</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of 7 variables: </p>
<table>
<tr><td><code>p.full</code></td>
<td>
<p>The p-value for the
test of the full set of variables selected by the lasso (based on the OLS
estimates)</p>
</td></tr> <tr><td><code>ols.selected</code></td>
<td>
<p>A vector of the indices of the non-zero
variables selected by <code>glmnet</code> sorted from (numerically) highest to
lowest based on their ols test statistic.</p>
</td></tr> <tr><td><code>p.maxols</code></td>
<td>
<p>The p-value for
the maximum of the OLS test statistics</p>
</td></tr> <tr><td><code>lasso.selected</code></td>
<td>
<p>A vector of
the indices of the non-zero variables selected by <code>glmnet</code> sorted from
(numerically) highest to lowest based on their absolute lasso coefficients.</p>
</td></tr>
<tr><td><code>p.maxlasso</code></td>
<td>
<p>The p-value for the maximum of the lasso test statistics</p>
</td></tr>
<tr><td><code>lambda.orig</code></td>
<td>
<p>The value of lambda used in the computations</p>
</td></tr> <tr><td><code>B</code></td>
<td>
<p>The number of permutations used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:ekstrom@sund.ku.dk">ekstrom@sund.ku.dk</a> and Kasper Brink-Jensen
<a href="mailto:kbrink@life.ku.dk">kbrink@life.ku.dk</a>
</p>


<h3>References</h3>

<p>Brink-Jensen, K and Ekstrom, CT 2014. <em>Inference for
feature selection using the Lasso with high-dimensional data</em>.
<a href="https://arxiv.org/abs/1403.4296">https://arxiv.org/abs/1403.4296</a>
</p>


<h3>See Also</h3>

<p><code>glmnet</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Simulate some data
x &lt;- matrix(rnorm(30*100), nrow=30)
y &lt;- rnorm(30, mean=1*x[,1])

# Make inference for features
## Not run: 
feature.test(x, y)

## End(Not run)


</code></pre>

<hr>
<h2 id='filldown'>Fill down NA with the last observed observation</h2><span id='topic+filldown'></span>

<h3>Description</h3>

<p>Fill down missing values with the latest non-missing value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filldown(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filldown_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or list with the NA's replaced by the last observed value.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- c(1:5, "Howdy", NA, NA, 2:3, NA)
filldown(a)
filldown(c(NA, NA, NA, 3:5))

</code></pre>

<hr>
<h2 id='founder.shared'>Compute a common shared environment matrix</h2><span id='topic+founder.shared'></span><span id='topic+founder.shared.pedigreeList'></span><span id='topic+founder.shared.pedigree'></span>

<h3>Description</h3>

<p>Compute the common shared environment matrix for a set of related subjects.
The function is generic, and can accept a pedigree, or pedigreeList as the
first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>founder.shared(id, ...)

## S3 method for class 'pedigreeList'
founder.shared(id, ...)

## S3 method for class 'pedigree'
founder.shared(id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="founder.shared_+3A_id">id</code></td>
<td>
<p>either a pedigree object or pedigreeList object</p>
</td></tr>
<tr><td><code id="founder.shared_+3A_...">...</code></td>
<td>
<p>Any number of optional arguments. Not used at the moment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When called with a pedigreeList, i.e., with multiple families, the routine
will create a block-diagonal-symmetric &lsquo;bdsmatrix&rsquo; object.  Since the [i,j]
value of the result is 0 for any two unrelated individuals i and j and a
&lsquo;bdsmatix&rsquo; utilizes sparse representation, the resulting object is often
orders of magnitude smaller than an ordinary matrix.  When called with a
single pedigree and ordinary matrix is returned.
</p>


<h3>Value</h3>

<p>a matrix of shared environment coefficients
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>See Also</h3>

<p><code>pedigree</code>, <code>kinship</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(kinship2)
test1 &lt;- data.frame(id  =c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14),
                    mom =c(0, 0, 0, 0, 2, 2, 4, 4, 6,  2,  0,  0, 12, 13),
                    dad =c(0, 0, 0, 0, 1, 1, 3, 3, 3,  7,  0,  0, 11, 10),
                    sex =c(1, 2, 1, 2, 1, 2, 1, 2, 1,  1,  1,  2,  2,  2))
tped &lt;- with(test1, pedigree(id, dad, mom, sex))
founder.shared(tped)

</code></pre>

<hr>
<h2 id='geekin'>Fit a generalized estimating equation (GEE) model with fixed additive
correlation structure</h2><span id='topic+geekin'></span><span id='topic+print.geekin'></span>

<h3>Description</h3>

<p>The geekin function fits generalized estimating equations but where the
correlation structure is given as linear function of (scaled) fixed
correlation structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geekin(
  formula,
  family = gaussian,
  data,
  weights,
  subset,
  id,
  na.action,
  control = geepack::geese.control(...),
  varlist,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geekin_+3A_formula">formula</code></td>
<td>
<p>See corresponding documentation to <code>glm</code>.</p>
</td></tr>
<tr><td><code id="geekin_+3A_family">family</code></td>
<td>
<p>See corresponding documentation to <code>glm</code>.</p>
</td></tr>
<tr><td><code id="geekin_+3A_data">data</code></td>
<td>
<p>See corresponding documentation to <code>glm</code>.</p>
</td></tr>
<tr><td><code id="geekin_+3A_weights">weights</code></td>
<td>
<p>See corresponding documentation to <code>glm</code>.</p>
</td></tr>
<tr><td><code id="geekin_+3A_subset">subset</code></td>
<td>
<p>See corresponding documentation to <code>glm</code>.</p>
</td></tr>
<tr><td><code id="geekin_+3A_id">id</code></td>
<td>
<p>a vector which identifies the clusters. The length of <code>id</code>
should be the same as the number of observations. Data must be sorted so
that observations on a cluster are contiguous rows for all entities in the
formula. If not the function will give an error</p>
</td></tr>
<tr><td><code id="geekin_+3A_na.action">na.action</code></td>
<td>
<p>See corresponding documentation to <code>glm</code>.</p>
</td></tr>
<tr><td><code id="geekin_+3A_control">control</code></td>
<td>
<p>See corresponding documentation to <code>glm</code>.</p>
</td></tr>
<tr><td><code id="geekin_+3A_varlist">varlist</code></td>
<td>
<p>a list containing one or more matrix or bdsmatrix objects
that represent the correlation structures</p>
</td></tr>
<tr><td><code id="geekin_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The geekin function is essentially a wrapper function to <code>geeglm</code>.
Through the varlist argument, it allows for correlation structures of the
form
</p>
<p>R = sum_i=1^k alpha_i R_i
</p>
<p>where alpha_i are(nuisance) scale parameters that are used to scale the
off-diagonal elements of the individual correlation matrices, R_i.
</p>


<h3>Value</h3>

<p>Returns an object of type <code>geeglm</code>.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>See Also</h3>

<p><code>lmekin</code>, <code>geeglm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # Get dataset
 library(kinship2)
 library(mvtnorm)
 data(minnbreast)

 breastpeda &lt;- with(minnbreast[order(minnbreast$famid), ], pedigree(id,
                   fatherid, motherid, sex,
                   status=(cancer&amp; !is.na(cancer)), affected=proband,
                   famid=famid))

set.seed(10)

nfam &lt;- 6
breastped &lt;- breastpeda[1:nfam]

 # Simulate a response

# Make dataset for lme4
df &lt;- lapply(1:nfam, function(xx) {
            as.data.frame(breastped[xx])
            })

mydata &lt;- do.call(rbind, df)
mydata$famid &lt;- rep(1:nfam, times=unlist(lapply(df, nrow)))

y &lt;- lapply(1:nfam, function(xx) {
            x &lt;- breastped[xx]
            rmvtnorm.pedigree(1, x, h2=0.3, c2=0)
            })
yy &lt;- unlist(y)

library(geepack)

geekin(yy ~ 1, id=mydata$famid, varlist=list(2*kinship(breastped)))

# lmekin(yy ~ 1 + (1|id), data=mydata, varlist=list(2*kinship(breastped)),method="REML")




</code></pre>

<hr>
<h2 id='gkgamma'>Goodman-Kruskal's gamma statistic for a two-dimensional table</h2><span id='topic+gkgamma'></span>

<h3>Description</h3>

<p>Compute Goodman-Kruskal's gamma statistic for a two-dimensional table of
ordered categories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gkgamma(x, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gkgamma_+3A_x">x</code></td>
<td>
<p>A matrix or table representing the two-dimensional ordered
contingency table of observations</p>
</td></tr>
<tr><td><code id="gkgamma_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of confidence interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value the test statistic for testing no association</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test</p>
</td></tr> <tr><td><code>estimate</code></td>
<td>
<p>the value the
gamma estimate</p>
</td></tr> <tr><td><code>conf.int</code></td>
<td>
<p>the confidence interval for the gamma
estimate</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>a character string indicating the type of test
performed</p>
</td></tr> <tr><td><code>data.name</code></td>
<td>
<p>a character string indicating the name of the
data input</p>
</td></tr> <tr><td><code>observed</code></td>
<td>
<p>the observed counts</p>
</td></tr> <tr><td><code>s0</code></td>
<td>
<p>the SE used
when computing the test statistics</p>
</td></tr> <tr><td><code>s1</code></td>
<td>
<p>the SE used when computing
the confidence interval</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Goodman, Leo A. and Kruskal, William H. (1954). &quot;Measures of
Association for Cross Classifications&quot;. Journal of the American Statistical
Association 49 (268): 732-764.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data from the Glostrup study comparing smoking to overall health in males
smoke &lt;- matrix(c(16, 15, 13, 10, 1, 73, 75, 59, 81, 29, 6, 6, 7, 17, 3, 1, 0, 1, 3, 1), ncol=4)
colnames(smoke) &lt;- c("VGood", "Good", "Fair", "Bad") # General health status
rownames(smoke) &lt;- c("Never", "No more", "1-14", "15-24", "25+")  # Smoke amount
gkgamma(smoke)
chisq.test(smoke)

</code></pre>

<hr>
<h2 id='greenland'>Average yearly summer air temperature for Tasiilaq, Greenland</h2><span id='topic+greenland'></span>

<h3>Description</h3>

<p>Average yearly summer (June, July, August) air temperature for Tasiilaq,
Greenland
</p>


<h3>Format</h3>

<p>A data frame with 51 observations on the following 2 variables.
</p>
 <dl>
<dt>year</dt><dd><p>year</p>
</dd> <dt>airtemp</dt><dd><p>average air
temperature (degrees Celcius)</p>
</dd> </dl>



<h3>Source</h3>

<p>Data provided by Sebastian Mernild.<br /> Originally obtained from
http://www.dmi.dk/dmi/index/gronland/vejrarkiv-gl.htm. <br /> Added by Claus
Ekstrom &lt;ekstrom@life.ku.dk&gt;
</p>


<h3>References</h3>

<p>Aktuelt Naturvidenskab september 2010. <br />
http://aktuelnaturvidenskab.dk/fileadmin/an/nr-4/an4_2010gletscher.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(greenland)
model &lt;- lm(airtemp ~ year, data=greenland)
plot(greenland$year, greenland$airtemp, xlab="Year", ylab="Air temperature")
abline(model, col="red")

</code></pre>

<hr>
<h2 id='happiness'>Happiness score and tax rates for 148 countries</h2><span id='topic+happiness'></span>

<h3>Description</h3>

<p>Dataset on subjective happiness, tax rates, population sizes, continent, and
major religion for 148 countries
</p>


<h3>Format</h3>

<p>A data frame with 148 observations on the following 6 variables.
</p>
 <dl>
<dt>country</dt><dd><p>a factor with 148 levels that contain the
country names</p>
</dd> <dt>happy</dt><dd><p>a numeric vector with the average
subject happiness score (on a scale from 0-10)</p>
</dd> <dt>tax</dt><dd><p>a numeric
vector showing the tax revenue as percentage of GDP</p>
</dd>
<dt>religion</dt><dd><p>a factor with levels <code>Buddhist</code>
<code>Christian</code> <code>Hindu</code> <code>Muslim</code> <code>None</code> or <code>Other</code></p>
</dd>
<dt>continent</dt><dd><p>a factor with levels <code>AF</code>, <code>AS</code>,
<code>EU</code>, <code>NA</code>, <code>OC</code>, <code>SA</code>, corresponding to the continents
Africa, Asia, Europe, North America, Ocenaia, South American, respectively</p>
</dd>
<dt>population</dt><dd><p>a numeric vector showing the population (in
millions)</p>
</dd> </dl>



<h3>Source</h3>

<p>Data collected by Ellen Ekstroem. <br /> Population sizes are from
Wikipedia per August 2nd, 2012
<a href="https://en.wikipedia.org/wiki/List_of_countries_by_population">https://en.wikipedia.org/wiki/List_of_countries_by_population</a> <br /> Major
religions are from Wikipedia per August 2nd, 2012
<a href="https://en.wikipedia.org/wiki/Religions_by_country">https://en.wikipedia.org/wiki/Religions_by_country</a> <br /> Tax rates are
from Wikipedia per August 2nd, 2012
<a href="https://en.wikipedia.org/wiki/List_of_countries_by_tax_revenue_as_percentage_of_GDP">https://en.wikipedia.org/wiki/List_of_countries_by_tax_revenue_as_percentage_of_GDP</a>
<br /> Average happiness scores are from &quot;Veenhoven, R. Average happiness in
148 nations 2000-2009, World Database of Happiness, Erasmus University
Rotterdam, The Netherlands&quot;. Assessed on August 2nd, 2012 at:
<a href="https://worlddatabaseofhappiness-archive.eur.nl/hap_nat/findingreports/RankReport_AverageHappiness.php">https://worlddatabaseofhappiness-archive.eur.nl/hap_nat/findingreports/RankReport_AverageHappiness.php</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(happiness)
with(happiness, symbols(tax, happy, circles=sqrt(population)/8, inches=FALSE, bg=continent))

#
# Make a prettier image with transparent colors
#

newcols &lt;- rgb(t(col2rgb(palette())),
               alpha=100, maxColorValue=255)

with(happiness, symbols(tax, happy, circles=sqrt(population)/8,
                inches=FALSE, bg=newcols[continent],
                xlab="Tax (% of GDP)", ylab="Happiness"))

#
# Simple analysis
#
res &lt;- lm(happy ~ religion + population + tax:continent, data=happiness)
summary(res)


</code></pre>

<hr>
<h2 id='ht'>Show the head and tail of an object</h2><span id='topic+ht'></span>

<h3>Description</h3>

<p>Show both the head and tail of an R object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ht(x, n = 6L, m = n, returnList = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ht_+3A_x">x</code></td>
<td>
<p>The object to show</p>
</td></tr>
<tr><td><code id="ht_+3A_n">n</code></td>
<td>
<p>The number of elements to list for the head</p>
</td></tr>
<tr><td><code id="ht_+3A_m">m</code></td>
<td>
<p>The number of elements to list for the tail</p>
</td></tr>
<tr><td><code id="ht_+3A_returnlist">returnList</code></td>
<td>
<p>Logical. Should the result be returned as a list</p>
</td></tr>
<tr><td><code id="ht_+3A_...">...</code></td>
<td>
<p>additional arguments passed to functions (not used at the moment)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does no error checking and it is up to the user to ensure that the input is indeed symmetric, positive-definite, and a matrix.
</p>


<h3>Value</h3>

<p>NULL unless returnList is set to TRUE in which case a list is returned
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom, <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ht(trees)
ht(diag(20))
ht(1:20)
ht(1:20, returnList=TRUE)

</code></pre>

<hr>
<h2 id='hwe_frequencies'>Fast estimation of allele and genotype frequencies under Hardy-Weinberg equilibrium</h2><span id='topic+hwe_frequencies'></span>

<h3>Description</h3>

<p>Alleles are assumed to be numerated from 1 and up with no missing label. Thus if the largest value in either allele1 or allele2 is K then we assume that there can be at least K possible alleles.
Genotypes are sorted such the the smallest allele comes first, i.e., 2x1 -&gt; 1x2, and 2x3 -&gt; 2x3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwe_frequencies(allele1, allele2, min_alleles = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hwe_frequencies_+3A_allele1">allele1</code></td>
<td>
<p>An integer vector (starting with values 1 upwards) of first alleles</p>
</td></tr>
<tr><td><code id="hwe_frequencies_+3A_allele2">allele2</code></td>
<td>
<p>An integer vector (starting with values 1 upwards) of second alleles</p>
</td></tr>
<tr><td><code id="hwe_frequencies_+3A_min_alleles">min_alleles</code></td>
<td>
<p>A minimum number of unique alleles available</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three variables: allele_freq for estimated allele frequencies, genotype_freq for estimated genotype_frequencies (under HWE assumption), obs_genotype is the frequency of the genotypes, available_genotypes is the number of available genotypes used for the estimation, and unique_alleles is the number of unique alleles (matches the length of allele_freq)
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>al1 &lt;- sample(1:5, size=1000, replace=TRUE, prob=c(.4, .2, .2, .1, .1))
al2 &lt;- sample(1:5, size=1000, replace=TRUE, prob=c(.4, .2, .2, .1, .1))
hwe_frequencies(al1, al2)

</code></pre>

<hr>
<h2 id='icecreamads'>Ice cream consumption and advertising</h2><span id='topic+icecreamads'></span>

<h3>Description</h3>

<p>The impact of advertizing impact, temperature, and price on ice cream consumption
</p>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 4 variables.
</p>
<dl>
<dt>Price</dt><dd><p>a numeric vector character vector giving the standardized price</p>
</dd>
<dt>Temperature</dt><dd><p>temperature in degrees Fahrenheit</p>
</dd>
<dt>Consumption</dt><dd><p>a factor with levels <code>1_low</code> <code>2_medium</code> <code>3_high</code></p>
</dd>
<dt>Advertise</dt><dd><p>a factor with levels <code>posters</code> <code>radio</code> <code>television</code></p>
</dd></dl>



<h3>Source</h3>

<p>Unknown origin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("icecreamads")

</code></pre>

<hr>
<h2 id='ks_cumtest'>Kolmogorov-Smirnov goodness of fit test for cumulative discrete data</h2><span id='topic+ks_cumtest'></span>

<h3>Description</h3>

<p>Kolmogorov-Smirnov goodness of fit test for cumulative discrete data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks_cumtest(x, B = 10000L, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ks_cumtest_+3A_x">x</code></td>
<td>
<p>A vector representing the contingency table.</p>
</td></tr>
<tr><td><code id="ks_cumtest_+3A_b">B</code></td>
<td>
<p>The number of simulations used to compute the p-value.</p>
</td></tr>
<tr><td><code id="ks_cumtest_+3A_prob">prob</code></td>
<td>
<p>A positive vector of the same length as x representing the distribution under the null hypothesis. It will be scaled to sum to 1. If NULL (the default) then a uniform distribution is assumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name of the function might change in the future so keep that in mind!
</p>
<p>Simulation is done by random sampling from the null hypothesis.
</p>


<h3>Value</h3>

<p>A list of class &quot;htest&quot; giving the simulation results.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1:6
ks_cumtest(x)

</code></pre>

<hr>
<h2 id='kwdata'>Non-parametric Kruskal Wallis data example</h2><span id='topic+kwdata'></span>

<h3>Description</h3>

<p>Artificial dataset to show that the p-value obtained for the Kruskal Wallis is only valid _after_ the distributional form
has been checked to be the same for all groups.
</p>


<h3>Format</h3>

<p>An artificial data frame with 18 observations in each of three groups.
</p>
 <dl>
<dt>x</dt><dd><p>measurements for group 1</p>
</dd>
<dt>y</dt><dd><p>measurements for group 2</p>
</dd>
<dt>z</dt><dd><p>measurements for group 3</p>
</dd></dl>



<h3>Source</h3>

<p>Data example found on the internet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(kwdata)
newdata &lt;- stack(kwdata)
kruskal.test(values ~ ind, newdata)

</code></pre>

<hr>
<h2 id='lifeexpect'>Estimated life expectancy for Danish newborns</h2><span id='topic+lifeexpect'></span>

<h3>Description</h3>

<p>The estimated life expectancy for newborn Danes split according to gender.
</p>


<h3>Format</h3>

<p>A data frame with 70 observations on the following 3 variables.
</p>

<dl>
<dt><code>year</code></dt><dd><p>a character vector</p>
</dd></dl>
<p> giving the calendar interval on which the estimation was based.
</p>
<dl>
<dt><code>male</code></dt><dd><p>a numeric vector</p>
</dd></dl>
<p> Life expectancy for males (in years).
</p>
<dl>
<dt><code>female</code></dt><dd><p>a numeric vector</p>
</dd></dl>
<p> Life expectancy for females (in years)
</p>
<dl>
<dt><code>myear</code></dt><dd><p>a numeric vector</p>
</dd></dl>
<p> The midpoint of the year interval

</p>


<h3>Source</h3>

<p>Data collected from Danmarks Statistik.
See <a href="https://www.dst.dk/en">https://www.dst.dk/en</a> for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lifeexpect)
plot(lifeexpect$myear, lifeexpect$male)


</code></pre>

<hr>
<h2 id='loadRData'>Load and extract object from RData file</h2><span id='topic+loadRData'></span>

<h3>Description</h3>

<p>Loads and extracts an object from an RData file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadRData(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadRData_+3A_filename">filename</code></td>
<td>
<p>The path to the RData file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an R object
</p>


<h3>Value</h3>

<p>An R object
</p>


<h3>Author(s)</h3>

<p>ricardo (from GitHub)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+load">load</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  d &lt;- loadRData("~/blah/ricardo.RData")

## End(Not run)

</code></pre>

<hr>
<h2 id='lower.tri.vector'>Split Matrix by Clusters and Return Lower Triangular Parts as Vector</h2><span id='topic+lower.tri.vector'></span>

<h3>Description</h3>

<p>Split a matrix into block diagonal sub matrices according to clusters and
combine the lower triangular parts into a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lower.tri.vector(x, cluster = rep(1, nrow(x)), diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lower.tri.vector_+3A_x">x</code></td>
<td>
<p>a square matrix</p>
</td></tr>
<tr><td><code id="lower.tri.vector_+3A_cluster">cluster</code></td>
<td>
<p>numeric or factor. Is used to identify the sub-matrices of
<code>x</code> from which the lower triangular parts are extracted. Defaults to
the full matrix.</p>
</td></tr>
<tr><td><code id="lower.tri.vector_+3A_diag">diag</code></td>
<td>
<p>logical. Should the diagonal be included?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector containing the elements of the lower
triangular sub matrices.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@ekstroem.dk">claus@ekstroem.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+lower.tri">lower.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(1:64, ncol=8)
cluster &lt;- c(1, 1, 1, 1, 2, 2, 3, 3)
lower.tri.vector(m, cluster)

</code></pre>

<hr>
<h2 id='matched'>Flu hospitalization</h2><span id='topic+matched'></span>

<h3>Description</h3>

<p>Researchers in a Midwestern county tracked flu cases requiring hospitalization in those residents aged 65
and older during a two-month period one winter. They matched each case with 2 controls by sex and age (150 cases,
300 controls). They used medical records to determine whether cases and controls had received a flu vaccine shot
and whether they had underlying lung disease. They wanted to know whether flu vaccination prevents hospitalization
for flu (severe cases of flu). Underlying lung disease is a potential confounder.
</p>


<h3>Format</h3>

<p>A data frame with 450 observations on the following 4 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>iscase</code></dt><dd><p>a factor with levels <code>Control</code> <code>Case</code></p>
</dd>
<dt><code>vaccine</code></dt><dd><p>a factor with levels <code>Not</code> <code>Vaccinated</code></p>
</dd>
<dt><code>lung</code></dt><dd><p>a factor with levels <code>None</code> <code>Disease</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Modified from: Stokes, Davis, Koch (2000). &quot;Categorical Data Analysis Using the SAS System,&quot; Chapter 10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(matched)

</code></pre>

<hr>
<h2 id='maximum_subarray'>Fast computation of maximum sum subarray</h2><span id='topic+maximum_subarray'></span>

<h3>Description</h3>

<p>Fast computation of the maximum subarray sum of a vector using Kadane's algorithm. The implementation handles purely negative numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximum_subarray(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximum_subarray_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements: sum (the maximum subarray sum), start (the starting index of the subarray) and end (the ending index of the subarray)
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
maximum_subarray(1:4)

maximum_subarray(c(-2, 1, -3, 4, -1, 2, 1, -5, 4))
 
maximum_subarray(rnorm(100000))

</code></pre>

<hr>
<h2 id='mfastLmCpp'>Fast marginal simple regresion analyses</h2><span id='topic+mfastLmCpp'></span>

<h3>Description</h3>

<p>Fast computation of simple regression slopes for each predictor represented by a column in a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfastLmCpp(y, x, addintercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfastLmCpp_+3A_y">y</code></td>
<td>
<p>A vector of outcomes.</p>
</td></tr>
<tr><td><code id="mfastLmCpp_+3A_x">x</code></td>
<td>
<p>A matrix of regressor variables. Must have the same number of rows as the length of y.</p>
</td></tr>
<tr><td><code id="mfastLmCpp_+3A_addintercept">addintercept</code></td>
<td>
<p>A logical that determines if the intercept should be included in all analyses (TRUE) or not (FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No error checking is done
</p>


<h3>Value</h3>

<p>A data frame with three variables: coefficients, stderr, and tstat that gives the slope estimate, the corresponding standard error, and their ratio for each column in x.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  // Generate 100000 predictors and 100 observations
  x &lt;- matrix(rnorm(100*100000), nrow=100)
  y &lt;- rnorm(100, mean=x[,1])
  mfastLmCpp(y, x)


## End(Not run)
</code></pre>

<hr>
<h2 id='monte_carlo_chisq_test'>Two-sided table test with fixed margins</h2><span id='topic+monte_carlo_chisq_test'></span>

<h3>Description</h3>

<p>Monte Carlo test in a two-way contingency table with the total number of observations fixed, row margin fixed, or both margins fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monte_carlo_chisq_test(x, margin = c("N", "rows", "both"), B = 100000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monte_carlo_chisq_test_+3A_x">x</code></td>
<td>
<p>A matrix representing the contingency table.</p>
</td></tr>
<tr><td><code id="monte_carlo_chisq_test_+3A_margin">margin</code></td>
<td>
<p>A string that determines which margin is fixed: Either &quot;N&quot; for the total number of observations (the default), &quot;rows&quot; for fixed row sums, and &quot;both&quot; for simultaneously fixed row and column sums.</p>
</td></tr>
<tr><td><code id="monte_carlo_chisq_test_+3A_b">B</code></td>
<td>
<p>The number of simulations used to compute the p-value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulation is done by random sampling from the set of all tables with given marginal(s), and works only if the relevant marginal(s) are strictly positive. Continuity correction is never used, and the statistic is quoted without it.
</p>


<h3>Value</h3>

<p>A list of class &quot;htest&quot; giving the simulation results.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(c(12, 4, 8, 6), 2)
chisq.test(m)
chisq.test(m, correct=FALSE)
monte_carlo_chisq_test(m)

fisher.test(m)
monte_carlo_chisq_test(m, margin="both")

m2 &lt;- matrix(c(9, 3, 3, 7), 2)
monte_carlo_chisq_test(m, margin="N")
monte_carlo_chisq_test(m, margin="both") 

</code></pre>

<hr>
<h2 id='nh4'>Ammonia nitrogen found in river</h2><span id='topic+nh4'></span>

<h3>Description</h3>

<p>Monthly levels of ammonia nitrogen in a river over two years
</p>


<h3>Format</h3>

<p>A data frame with 120 observations on the following 3 variables.
</p>
<dl>
<dt>nh4</dt><dd><p>The ammonia nitrogen levels (mg/l). A value of zero corresponds to a censoring, but it really is censored at &lt;0.01</p>
</dd>
<dt>cens</dt><dd><p>A logical vector indicating if the value was censored</p>
</dd>
<dt>year</dt><dd><p>The year</p>
</dd></dl>



<h3>Source</h3>

<p>Found on the internet and partly simulated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nh4)

</code></pre>

<hr>
<h2 id='ordered.clusters'>Check if unique elements of a vector appear in contiguous clusters</h2><span id='topic+ordered.clusters'></span>

<h3>Description</h3>

<p><code>ordered.clusters</code> determines if identical elements of a vector appear
in contiguous clusters, and returns <code>TRUE</code> if the do and <code>FALSE</code>
otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordered.clusters(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordered.clusters_+3A_id">id</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns TRUE if the elements appear in contiguous
clusters and FALSE otherwise
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@ekstroem.dk">claus@ekstroem.dk</a> with suggestions from Peter
Dalgaard.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+duplicated">duplicated</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1, 1, 1, 2, 2, 3, 4, 1, 5, 5, 5)
ordered.clusters(x)
ordered.clusters(sort(x))
ordered.clusters(x[order(x)])

</code></pre>

<hr>
<h2 id='pairwise_combination_indices'>Compute all pairwise combinations of indices</h2><span id='topic+pairwise_combination_indices'></span>

<h3>Description</h3>

<p>Fast computation of indices of all pairwise element of a vector of length n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_combination_indices(n, self = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise_combination_indices_+3A_n">n</code></td>
<td>
<p>A number giving the number of elements to create all pairwise indices from</p>
</td></tr>
<tr><td><code id="pairwise_combination_indices_+3A_self">self</code></td>
<td>
<p>A logical that determines whether a column should also be multiplied by itself.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the output order of columns corresponds to the order of the columns in x. First column 1 is multiplied with each of the other columns, then column 2 with the remaining columns etc.
</p>


<h3>Value</h3>

<p>A matrix with n*(n+1)/2 rows (if self=TRUE) or n*(n-1)/2 rows (if self=FALSE, the default) and two columns gicing all possible combinations of indices.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pairwise_combination_indices(3)
pairwise_combination_indices(4, self=TRUE)

</code></pre>

<hr>
<h2 id='pairwise_Schur_product'>Compute Schur products (element-wise) of all pairwise combinations of columns in matrix</h2><span id='topic+pairwise_Schur_product'></span>

<h3>Description</h3>

<p>Fast computation of all pairwise element-wise column products of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_Schur_product(x, self = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise_Schur_product_+3A_x">x</code></td>
<td>
<p>A matrix with dimensions r*c.</p>
</td></tr>
<tr><td><code id="pairwise_Schur_product_+3A_self">self</code></td>
<td>
<p>A logical that determines whether a column should also be multiplied by itself.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the output order of columns corresponds to the order of the columns in x. First column 1 is multiplied with each of the other columns, then column 2 with the remaining columns etc.
</p>


<h3>Value</h3>

<p>A matrix with the same number of rows as x and a number of columns corresponding to c choose 2 (+ c if self is TRUE), where c is the number of columns of x.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- cbind(rep(1, 4), 1:4, 4:1)
pairwise_Schur_product(X)
pairwise_Schur_product(X, self=TRUE)

</code></pre>

<hr>
<h2 id='pairwise.cor.test'>Pairwise Tests for Association/Correlation Between Paired Samples</h2><span id='topic+pairwise.cor.test'></span>

<h3>Description</h3>

<p>Calculate pairwise correlations between group levels with corrections for multiple testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.cor.test(
  x,
  g,
  p.adjust.method = p.adjust.methods,
  method = c("pearson", "kendall", "spearman"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.cor.test_+3A_x">x</code></td>
<td>
<p>response vector.</p>
</td></tr>
<tr><td><code id="pairwise.cor.test_+3A_g">g</code></td>
<td>
<p>grouping vector or factor.</p>
</td></tr>
<tr><td><code id="pairwise.cor.test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p values (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>). Can be abbreviated.</p>
</td></tr>
<tr><td><code id="pairwise.cor.test_+3A_method">method</code></td>
<td>
<p>string argument to set the method to compute the correlation. Possibilities are &quot;pearson&quot; (the default), &quot;kendall&quot;, and &quot;spearman&quot;</p>
</td></tr>
<tr><td><code id="pairwise.cor.test_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="stats.html#topic+cor.test">cor.test</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that correlation tests require that the two vectors examined are of the same length.
Thus, if the grouping defines groups of varying lengths then the specific correlation is
not computed and a <code>NA</code> is returned instead. The adjusted p values are only based on
the actual correlation that are computed.
Extra arguments that are passed on to <code>cor.test</code> may or may not be sensible in this context.
</p>


<h3>Value</h3>

<p>Object of class <code>pairwise.htest</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
attach(airquality)
Month &lt;- factor(Month, labels = month.abb[5:9])
pairwise.cor.test(Ozone, Month)
pairwise.cor.test(Ozone, Month, p.adj = "bonf")
detach()
</code></pre>

<hr>
<h2 id='panel.hist'>Panel plot of histogram and density curve</h2><span id='topic+panel.hist'></span>

<h3>Description</h3>

<p>Prints the histogram and corresponding density curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.hist(x, col.bar = "gray", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.hist_+3A_x">x</code></td>
<td>
<p>a numeric vector of x values</p>
</td></tr>
<tr><td><code id="panel.hist_+3A_col.bar">col.bar</code></td>
<td>
<p>the color of the bars</p>
</td></tr>
<tr><td><code id="panel.hist_+3A_...">...</code></td>
<td>
<p>options passed to hist</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints a combined histogram and density curve for use with
the pairs function
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Ekstrom, CT (2011) <em>The R Primer</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pairs(~ Ozone + Temp + Wind + Solar.R, data=airquality,
      lower.panel=panel.smooth, diag.panel=panel.hist,
      upper.panel=panel.r2)

</code></pre>

<hr>
<h2 id='panel.r2'>Panel plot of R2 values for pairs</h2><span id='topic+panel.r2'></span>

<h3>Description</h3>

<p>Prints the R2 with text size depending on the size of R2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.r2(x, y, digits = 2, cex.cor, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.r2_+3A_x">x</code></td>
<td>
<p>a numeric vector of x values</p>
</td></tr>
<tr><td><code id="panel.r2_+3A_y">y</code></td>
<td>
<p>a numeric vector of y values</p>
</td></tr>
<tr><td><code id="panel.r2_+3A_digits">digits</code></td>
<td>
<p>a numeric value giving the number of digits to present</p>
</td></tr>
<tr><td><code id="panel.r2_+3A_cex.cor">cex.cor</code></td>
<td>
<p>scaling fator for the size of text</p>
</td></tr>
<tr><td><code id="panel.r2_+3A_...">...</code></td>
<td>
<p>extra options (not used at the moment)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a slight modification of the panel.cor
function defined on the pairs help page. It calculated and
prints the squared correlation, R2, with text size depending
on the proportion of explained variation.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Ekstrom, CT (2011) <em>The R Primer</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pairs(~ Ozone + Temp + Wind + Solar.R, data=airquality,
      lower.panel=panel.smooth, upper.panel=panel.r2)

</code></pre>

<hr>
<h2 id='picea'>Ozone concentration damage to picea spruce</h2><span id='topic+picea'></span>

<h3>Description</h3>

<p>Damage scores (ordinal scale) for Picea Sitchesis shoots at two dates, at four temperatures, and 4 ozone Levels
</p>


<h3>Format</h3>

<p>An artificial data frame with 18 observations in each of three groups.
</p>
<dl>
<dt>date</dt><dd><p>a character vector giving the date</p>
</dd>
<dt>temp</dt><dd><p>temperature in degrees Celcius</p>
</dd>
<dt>conc</dt><dd><p>Ozone concentration at 4 different levels</p>
</dd>
<dt>damage</dt><dd><p>the damage score from 0-4, higher is more damage</p>
</dd>
<dt>count</dt><dd><p>The number of occurrences of this group</p>
</dd></dl>



<h3>Source</h3>

<p>P.W. Lucas, D.A. Cottam, L.J. Sheppard, B.J. Francis (1988). &quot;Growth
Responses and Delayed Winter Hardening in Sitka Spruce Following Summer
Exposure to Ozone,&quot; New Phytologist, Vol. 108, pp. 495-504.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(picea)

</code></pre>

<hr>
<h2 id='plr'>Fast computation of several simple linear regressions</h2><span id='topic+plr'></span><span id='topic+plr.numeric'></span><span id='topic+plr.matrix'></span>

<h3>Description</h3>

<p>Fast computation of several simple linear regression, where the outcome is analyzed with several 
marginal analyses, or where several outcome are analyzed separately, or a combination of both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plr(y, x, addintercept = TRUE)

## S3 method for class 'numeric'
plr(y, x, addintercept = TRUE)

## S3 method for class 'matrix'
plr(y, x, addintercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plr_+3A_y">y</code></td>
<td>
<p>either a vector (of length N) or a matrix (with N rows)</p>
</td></tr>
<tr><td><code id="plr_+3A_x">x</code></td>
<td>
<p>a matrix with N rows</p>
</td></tr>
<tr><td><code id="plr_+3A_addintercept">addintercept</code></td>
<td>
<p>boolean. Should the intercept be included in the model by default (TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame (if Y is a vector) or list of data frames (if Y is a matrix)
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:ekstrom@sund.ku.dk">ekstrom@sund.ku.dk</a>
</p>


<h3>See Also</h3>

<p><code>mfastLmCpp</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 1000  # Number of observations
Nx &lt;- 20   # Number of independent variables
Ny &lt;- 80   # Number of dependent variables

# Simulate outcomes that are all standard Gaussians
Y &lt;- matrix(rnorm(N*Ny), ncol=Ny)  
X &lt;- matrix(rnorm(N*Nx), ncol=Nx)

plr(Y, X)

</code></pre>

<hr>
<h2 id='power_binom_test'>Power Calculations for Exact Test of a simple null hypothesis in a Bernoulli
experiment</h2><span id='topic+power_binom_test'></span>

<h3>Description</h3>

<p>Compute power of test, or determine parameters to obtain target power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_binom_test(
  n = NULL,
  p0 = NULL,
  pa = NULL,
  sig.level = 0.05,
  power = NULL,
  alternative = c("two.sided", "less", "greater")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_binom_test_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="power_binom_test_+3A_p0">p0</code></td>
<td>
<p>Probability under the null</p>
</td></tr>
<tr><td><code id="power_binom_test_+3A_pa">pa</code></td>
<td>
<p>Probability under the alternative</p>
</td></tr>
<tr><td><code id="power_binom_test_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power_binom_test_+3A_power">power</code></td>
<td>
<p>Power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power_binom_test_+3A_alternative">alternative</code></td>
<td>
<p>One- or two-sided test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure uses uniroot to find the root of a discontinuous function so
some errors may pop up due to the given setup that causes the root-finding
procedure to fail. Also, since exact binomial tests are used we have
discontinuities in the function that we use to find the root of but despite
this the function is usually quite stable.
</p>


<h3>Value</h3>

<p>Object of class <code>power.htest</code>, a list of the arguments
(including the computed one) augmented with method and note elements.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+binom.test">binom.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
power_binom_test(n = 50, p0 = .50, pa = .75)      ## =&gt; power = 0.971
power_binom_test(p0 = .50, pa = .75, power = .90) ## =&gt;     n = 41
power_binom_test(n = 50, p0 = .25, power = .90, alternative="less")  ## =&gt; pa = 0.0954

</code></pre>

<hr>
<h2 id='power_mcnemar_test'>Power Calculations for Exact and Asymptotic McNemar Test in a 2 by 2 table</h2><span id='topic+power_mcnemar_test'></span>

<h3>Description</h3>

<p>Compute power of test, or determine parameters to obtain target power for
matched case-control studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_mcnemar_test(
  n = NULL,
  paid = NULL,
  psi = NULL,
  sig.level = 0.05,
  power = NULL,
  alternative = c("two.sided", "one.sided"),
  method = c("normal", "exact", "cond.exact")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_mcnemar_test_+3A_n">n</code></td>
<td>
<p>Number of observations (number of pairs)</p>
</td></tr>
<tr><td><code id="power_mcnemar_test_+3A_paid">paid</code></td>
<td>
<p>The probability that a case patient is not exposed and that the
corresponding control patient was exposed (specifying p_12 in the 2 x 2 table). It is assumed that this is the _smaller_ of the two discordant probabilities.</p>
</td></tr>
<tr><td><code id="power_mcnemar_test_+3A_psi">psi</code></td>
<td>
<p>The relative probability that a control patient is not exposed and that the corresponding case patient was exposed compared to the probability that a case patient is not exposed and that the corresponding control patient was exposed (i.e., p_21 / p_12 in the 2x2 table). Also called the discordant proportion ratio. psi must be larger than or equal to 1 since paid was the smaller of the two discordant probabilities.</p>
</td></tr>
<tr><td><code id="power_mcnemar_test_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power_mcnemar_test_+3A_power">power</code></td>
<td>
<p>Power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power_mcnemar_test_+3A_alternative">alternative</code></td>
<td>
<p>One- or two-sided test</p>
</td></tr>
<tr><td><code id="power_mcnemar_test_+3A_method">method</code></td>
<td>
<p>Power calculations based on exact or asymptotic test. The default (normal) corresponds to an approximative test, &quot;exact&quot; is the unconditional exact test, while &quot;cond.exact&quot; is a conditional exact test (given fixed n). The &quot;exact&quot; method is very slow for large values of n so it is most useful for fixed (and moderately-sized) n.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>power.htest</code>, a list of the arguments
(including the computed one) augmented with method and note elements.
</p>


<h3>Note</h3>

<p><code>uniroot</code> is used to solve power equation for unknowns, so you
may see errors from it, notably about inability to bracket the root when
invalid arguments are given.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Duffy, S (1984). Asymptotic and Exact Power for the McNemar Test
and its Analogue with R Controls per Case
</p>
<p>Fagerland MW, Lydersen S, Laake P. (2013) The McNemar test for binary matched-pairs data: mid-p and asymptotic
are better than exact conditional. BMC Medical Research Methodology.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+mcnemar.test">mcnemar.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Assume that pi_12 is 0.125 and we wish to detect an OR of 2.
# This implies that pi_12=0.25, and with alpha=0.05, and a power of 90% you get
power_mcnemar_test(n=NULL, paid=.125, psi=2, power=.9)

power_mcnemar_test(n=NULL, paid=.1, psi=2, power=.8, method="normal")
power_mcnemar_test(n=NULL, paid=.1, psi=2, power=.8)



</code></pre>

<hr>
<h2 id='power_prop_test'>Power Calculations for Two-Sample Test for Proportions with unequal sample size</h2><span id='topic+power_prop_test'></span>

<h3>Description</h3>

<p>Compute power of test, or determine parameters to obtain target
power for equal and unequal sample sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_prop_test(
  n = NULL,
  p1 = NULL,
  p2 = NULL,
  sig.level = 0.05,
  power = NULL,
  ratio = 1,
  alternative = c("two.sided", "one.sided"),
  tol = .Machine$double.eps^0.25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_prop_test_+3A_n">n</code></td>
<td>
<p>Number of observations (in group 1)</p>
</td></tr>
<tr><td><code id="power_prop_test_+3A_p1">p1</code></td>
<td>
<p>Probability in one group</p>
</td></tr>
<tr><td><code id="power_prop_test_+3A_p2">p2</code></td>
<td>
<p>Probability in other group</p>
</td></tr>
<tr><td><code id="power_prop_test_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power_prop_test_+3A_power">power</code></td>
<td>
<p>Power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power_prop_test_+3A_ratio">ratio</code></td>
<td>
<p>The ratio n2/n1 between the larger group and the smaller group. Should be a value equal to or greater than 1 since n2 is the larger group. Defaults to 1 (equal group sizes)</p>
</td></tr>
<tr><td><code id="power_prop_test_+3A_alternative">alternative</code></td>
<td>
<p>String. Can be one- or two-sided test. Can be abbreviated.</p>
</td></tr>
<tr><td><code id="power_prop_test_+3A_tol">tol</code></td>
<td>
<p>Numerical tolerance used in root finding, the default providing (at least) four significant digits</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n</code>, <code>delta</code>, <code>power</code>, <code>sd</code>, <code>sig.level</code>, <code>ratio</code> <code>sd.ratio</code>
must be passed as NULL, and that parameter is determined from the others. Notice that the last two have non-NULL defaults
so NULL must be explicitly passed if you want to compute them.
</p>


<h3>Value</h3>

<p>Object of class <code>power.htest</code>, a list of the arguments (including the computed one) augmented with <code>method</code> and <code>note</code> elements.
</p>


<h3>Note</h3>

<p><code>uniroot</code> is used to solve power equation for unknowns, so you may
see errors from it, notably about inability to bracket the root
when invalid arguments are given.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+power.prop.test">power.prop.test</a></code>, <code><a href="#topic+power_t_test">power_t_test</a></code>, <code><a href="stats.html#topic+power.t.test">power.t.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>power_prop_test(n=NULL, p1=.65, p2=.85, power=.8, ratio=2)
</code></pre>

<hr>
<h2 id='power_t_test'>Power calculations for one and two sample t tests with unequal sample size</h2><span id='topic+power_t_test'></span>

<h3>Description</h3>

<p>Compute power of test, or determine parameters to obtain target
power for equal and unequal sample sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_t_test(
  n = NULL,
  delta = NULL,
  sd = 1,
  sig.level = 0.05,
  power = NULL,
  ratio = 1,
  sd.ratio = 1,
  type = c("two.sample", "one.sample", "paired"),
  alternative = c("two.sided", "one.sided"),
  df.method = c("welch", "classical"),
  strict = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_t_test_+3A_n">n</code></td>
<td>
<p>Number of observations (in the smallest group if two groups)</p>
</td></tr>
<tr><td><code id="power_t_test_+3A_delta">delta</code></td>
<td>
<p>True difference in means</p>
</td></tr>
<tr><td><code id="power_t_test_+3A_sd">sd</code></td>
<td>
<p>Standard deviation</p>
</td></tr>
<tr><td><code id="power_t_test_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power_t_test_+3A_power">power</code></td>
<td>
<p>Power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power_t_test_+3A_ratio">ratio</code></td>
<td>
<p>The ratio n2/n1 between the larger group and the smaller group. Should be a value equal to or greater than 1 since n2 is the larger group. Defaults to 1 (equal group sizes). If ratio is set to NULL (i.e., find the ratio) then the ratio might be smaller than 1 depending on the desired power and ratio of the sd's.</p>
</td></tr>
<tr><td><code id="power_t_test_+3A_sd.ratio">sd.ratio</code></td>
<td>
<p>The ratio sd2/sd1 between the standard deviations in the larger group and the smaller group. Defaults to 1 (equal standard deviations in the two groups)</p>
</td></tr>
<tr><td><code id="power_t_test_+3A_type">type</code></td>
<td>
<p>Type of t test</p>
</td></tr>
<tr><td><code id="power_t_test_+3A_alternative">alternative</code></td>
<td>
<p>One- or two-sided test</p>
</td></tr>
<tr><td><code id="power_t_test_+3A_df.method">df.method</code></td>
<td>
<p>Method for calculating the degrees of default. Possibilities are welch (the default) or classical.</p>
</td></tr>
<tr><td><code id="power_t_test_+3A_strict">strict</code></td>
<td>
<p>Use strict interpretation in two-sided case. Defaults to TRUE unlike the standard power.t.test function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n</code>, <code>delta</code>, <code>power</code>, <code>sd</code>, <code>sig.level</code>, <code>ratio</code> <code>sd.ratio</code>
must be passed as NULL,
and that parameter is determined from the others. Notice that the last two have non-NULL defaults
so NULL must be explicitly passed if you want to compute them.
</p>
<p>The default <code>strict = TRUE</code> ensures that the power will include the probability
of rejection in the opposite direction of the true effect, in the
two-sided case. Without this the power will be half the
significance level if the true difference is zero.
</p>


<h3>Value</h3>

<p>Object of class <code>power.htest</code>, a list of the arguments (including the computed one)
augmented with <code>method</code> and <code>note</code> elements.
</p>


<h3>Note</h3>

<p><code>uniroot</code> is used to solve power equation for unknowns, so you may
see errors from it, notably about inability to bracket the root
when invalid arguments are given.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+power.t.test">power.t.test</a></code>, <code><a href="#topic+power_prop_test">power_prop_test</a></code>, <code><a href="stats.html#topic+power.prop.test">power.prop.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sampling with a ratio of 1:4
power_t_test(delta=300, sd=450, power=.8, ratio=4)

# Equal group sizes but different sd's
# The sd in the second group is twice the sd in the second group
power_t_test(delta=300, sd=450, power=.8, sd.ratio=2)

# Fixed group one size to 50 individuals, but looking for the number of individuals in the
# second group. Different sd's with twice the sd in the larger group
power_t_test(n=50, delta=300, sd=450, power=.8, ratio=NULL, sd.ratio=2)
</code></pre>

<hr>
<h2 id='prepost.test'>Pretest-posttest RCT for quantitative observations with possible missing values</h2><span id='topic+prepost.test'></span>

<h3>Description</h3>

<p>In a typical pretest-posttest RCT, subjects are randomized to two treatments, and response is measured at baseline,
prior to intervention with the randomized treatment (pretest), and at prespecified follow-up time (posttest).
Interest focuses on the effect of treatments on the change between mean baseline and follow-up response.
Missing posttest response for some subjects is routine, and disregarding missing cases can lead to invalid inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepost.test(baseline, post, treatment, conf.level = 0.95, delta = "estimate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepost.test_+3A_baseline">baseline</code></td>
<td>
<p>A vector of quantitative baseline measurements</p>
</td></tr>
<tr><td><code id="prepost.test_+3A_post">post</code></td>
<td>
<p>A vector of quantitative post-test measurements with same length as baseline. May contain missing values</p>
</td></tr>
<tr><td><code id="prepost.test_+3A_treatment">treatment</code></td>
<td>
<p>A vector of 0s and 1s corresponding to treatment indicator. 1 = treated, Same length as baseline</p>
</td></tr>
<tr><td><code id="prepost.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval</p>
</td></tr>
<tr><td><code id="prepost.test_+3A_delta">delta</code></td>
<td>
<p>A numeric between 0 and 1 OR the string &quot;estimate&quot; (the default). The proportion of observation treated.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:ekstrom@sund.ku.dk">ekstrom@sund.ku.dk</a>
</p>


<h3>References</h3>

<p>Marie Davidian, Anastasios A. Tsiatis and Selene Leon (2005).
&quot;Semiparametric Estimation of Treatment Effect in a Pretest-Posttest Study
with Missing Data&quot;. Statistical Science 20, 261-301.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># From Altman
expo = c(rep(1,9),rep(0,7))
bp1w = c(137,120,141,137,140,144,134,123,142,139,134,136,151,147,137,149)
bp_base = c(147,129,158,164,134,155,151,141,153,133,129,152,161,154,141,156)
diff = bp1w-bp_base
prepost.test(bp_base, bp1w, expo)

</code></pre>

<hr>
<h2 id='qdiag'>Fast extraction of matrix diagonal</h2><span id='topic+qdiag'></span>

<h3>Description</h3>

<p>Fast extraction of matrix diagonal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdiag(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdiag_+3A_x">x</code></td>
<td>
<p>The matrix to extract the diagonal from</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note this function can only be used for extraction
</p>


<h3>Value</h3>

<p>A vector with the diagonal elements
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>

<hr>
<h2 id='QIC.geeglm'>Quasi Information Criterion</h2><span id='topic+QIC.geeglm'></span><span id='topic+QIC'></span><span id='topic+QIC.geekin'></span><span id='topic+QIC.ordgee'></span>

<h3>Description</h3>

<p>Function for calculating the quasi-likelihood under the independence model
information criterion (QIC), quasi-likelihood, correlation information
criterion (CIC), and corrected QIC for one or several fitted geeglm model
object from the geepack package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geeglm'
QIC(object, tol = .Machine$double.eps, ...)

## S3 method for class 'ordgee'
QIC(object, tol = .Machine$double.eps, ...)

## S3 method for class 'geekin'
QIC(object, tol = .Machine$double.eps, ...)

QIC(object, tol = .Machine$double.eps, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QIC.geeglm_+3A_object">object</code></td>
<td>
<p>a fitted GEE model from the geepack package. Currently only
works on geeglm objects</p>
</td></tr>
<tr><td><code id="QIC.geeglm_+3A_tol">tol</code></td>
<td>
<p>the tolerance used for matrix inversion</p>
</td></tr>
<tr><td><code id="QIC.geeglm_+3A_...">...</code></td>
<td>
<p>optionally more fitted geeglm model objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>QIC is used to select a correlation structure. The QICu is used to compare
models that have the same working correlation matrix and the same
quasi-likelihood form but different mean specifications. CIC has been
suggested as a more robust alternative to QIC when the model for the mean
may not fit the data very well and when models with different correlation
structures are compared.
</p>
<p>Models with smaller values of QIC, CIC, QICu, or QICC are preferred.
</p>
<p>If the MASS package is loaded then the <code><a href="MASS.html#topic+ginv">ginv</a></code> function is used
for matrix inversion. Otherwise the standard <code><a href="base.html#topic+solve">solve</a></code> function is
used.
</p>


<h3>Value</h3>

<p>A vector or matrix with the QIC, QICu, quasi likelihood, CIC, the
number of mean effect parameters, and the corrected QIC for each GEE object
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>, Brian McLoone <a href="mailto:bmcloone@pdx.edu">bmcloone@pdx.edu</a>, and Steven Orzack <a href="mailto:orzack@freshpond.org">orzack@freshpond.org</a>
</p>


<h3>References</h3>

<p>Pan, W. (2001). <em>Akaike's information criterion in
generalized estimating equations</em>. Biometrics, 57, 120-125.<br /> Hardin, J.W.
and Hilbe, J.M. (2012). <em>Generalized Estimating Equations, 2nd
Edition</em>, Chapman and Hall/CRC: New York. <br /> Hin, L.-Y. and Wang, Y-G.
(2009). <em>Working-correlation-structure identification in generalized
estimating equations</em>, Statistics in Medicine 28: 642-658. <br /> Thall, P.F.
and Vail, S.C. (1990). <em>Some Covariance Models for Longitudinal Count
Data with Overdispersion</em>.  Biometrics, 46, 657-671.
</p>


<h3>See Also</h3>

<p><code>geeglm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(geepack)
data(ohio)
fit &lt;- geeglm(resp ~ age + smoke + age:smoke, id=id, data=ohio,
             family=binomial, corstr="exch", scale.fix=TRUE)
QIC(fit)

</code></pre>

<hr>
<h2 id='qpcr'>Gene expression from real-time quantitative PCR</h2><span id='topic+qpcr'></span>

<h3>Description</h3>

<p>Gene expression levels from real-time quantitative polymerase chain reaction
(qPCR) experiments on two different plant lines. Each line was used for 7
experiments each with 45 cycles.
</p>


<h3>Format</h3>

<p>A data frame with 630 observations on the following 4 variables.
</p>

<table>
<tr>
 <td style="text-align: left;"> <code>flour</code> </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Fluorescence level</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>line</code> </td><td style="text-align: left;"> factor </td><td style="text-align: left;"> Plant lines <code>rnt</code> (mutant) and <code>wt</code>
(wildtype)</td>
</tr>
<tr>
 <td style="text-align: left;"> <code>cycle</code> </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Cycle number for the
experiment</td>
</tr>
<tr>
 <td style="text-align: left;"> <code>transcript</code></td><td style="text-align: left;"> factor </td><td style="text-align: left;"> Transcript used for the
different runs</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Source</h3>

<p>Data provided by Kirsten Jorgensen &lt;kij@life.ku.dk&gt;. <br /> Added by Claus Ekstrom &lt;ekstrom@life.ku.dk&gt;
</p>


<h3>References</h3>

<p>Morant, M. et al. (2010). Metabolomic, Transcriptional, Hormonal
and Signaling Cross-Talk in Superroot2. <em>Molecular Plant</em>. 3,
p.192&ndash;211.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(qpcr)

#
# Analyze a single run for the wt line, transcript 1
#
run1 &lt;- subset(qpcr, transcript==1 &amp; line=="wt")

model &lt;- nls(flour ~ fmax/(1+exp(-(cycle-c)/b))+fb,
             start=list(c=25, b=1, fmax=100, fb=0), data=run1)

print(model)

plot(run1$cycle, run1$flour, xlab="Cycle", ylab="Fluorescence")
lines(run1$cycle, predict(model))

</code></pre>

<hr>
<h2 id='quadform'>Fast quadratic form computation</h2><span id='topic+quadform'></span>

<h3>Description</h3>

<p>Fast computation of a quadratic form  <code class="reqn">t(x) * M * x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadform(x, M, invertM = FALSE, transposex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadform_+3A_x">x</code></td>
<td>
<p>A matrix with dimensions n*k.</p>
</td></tr>
<tr><td><code id="quadform_+3A_m">M</code></td>
<td>
<p>A matrix with dimenions n*n. If it is to be inverted then the matrix should be symmetric and positive difinite (no check is done for this)</p>
</td></tr>
<tr><td><code id="quadform_+3A_invertm">invertM</code></td>
<td>
<p>A logical. If set to TRUE then M will be inverted before computations (defaults to FALSE)</p>
</td></tr>
<tr><td><code id="quadform_+3A_transposex">transposex</code></td>
<td>
<p>A logical. Should the matrix be transposed before computations (defaults to FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with dimensions k * k giving the quadratic form
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>

<hr>
<h2 id='rainman'>Perception of points in a swarm</h2><span id='topic+rainman'></span>

<h3>Description</h3>

<p>Five raters were asked to guess the number of points in a swarm for 10
different figures (which - unknown to the raters - were each repeated three
times).
</p>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 6 variables.
</p>
 <dl>
<dt>SAND</dt><dd><p>The true number of points in the swarm. Each
picture is replicated thrice</p>
</dd> <dt>ME</dt><dd><p>Ratings from judge 1</p>
</dd>
<dt>TM</dt><dd><p>Ratings from judge 2</p>
</dd> <dt>AJ</dt><dd><p>Ratings from judge
3</p>
</dd> <dt>BM</dt><dd><p>Ratings from judge 4</p>
</dd> <dt>LO</dt><dd><p>Ratings from
judge 5</p>
</dd> </dl>



<h3>Details</h3>

<p>The raters har approximately 10 seconds to judge each picture, and the
thought it was 30 different pictures. Before starting the experiment they
were shown 6 (unrelated) pictures and were told the number of points in each
of those pictures. The SAND column contains the picture id and the true
number of points in the swarm.
</p>


<h3>Source</h3>

<p>Collected by Claus Ekstrom.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(rainman)
long &lt;- data.frame(stack(rainman[,2:6]), figure=factor(rep(rainman$SAND,5)))
figind &lt;- interaction(long$figure,long$ind)
# Use a linear random effect model from the
# lme4 package if available
if(require(lme4)) {
  model &lt;- lmer(values ~ (1|ind) + (1|figure) + (1|figind), data=long)
}

#
# Point swarms were generated by the following program
#
## Not run: 
set.seed(2) # Original
npoints &lt;- sample(4:30)*4
nplots &lt;- 10
pdf(file="swarms.pdf", onefile=TRUE)

s1 &lt;- sample(npoints[1:nplots])
print(s1)
for (i in 1:nplots) {
  n &lt;- s1[i]
  set.seed(n)
  x &lt;- runif(n)
  y &lt;- runif(n)
  plot(x,y, xlim=c(-.15, 1.15), ylim=c(-.15, 1.15), pch=20, axes=FALSE,
       xlab="", ylab="")
}
s1 &lt;- sample(npoints[1:nplots])
print(s1)
for (i in 1:nplots) {
  n &lt;- s1[i]
  set.seed(n)
  x &lt;- runif(n)
  y &lt;- runif(n)
  plot(y,x, xlim=c(-.15, 1.15), ylim=c(-.15, 1.15), pch=20, axes=FALSE,
       xlab="", ylab="")
}
s1 &lt;- sample(npoints[1:nplots])
print(s1)
for (i in 1:nplots) {
  n &lt;- s1[i]
  set.seed(n)
  x &lt;- runif(n)
  y &lt;- runif(n)
  plot(-x,y, xlim=c(-1.15, .15), ylim=c(-.15, 1.15), pch=20, axes=FALSE,
       xlab="", ylab="")
}
dev.off()

## End(Not run)

</code></pre>

<hr>
<h2 id='repmat'>Fast replication of a matrix</h2><span id='topic+repmat'></span>

<h3>Description</h3>

<p>Fast generation of a matrix by replicating a matrix row- and column-wise in a block-like fashion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repmat(x, nrow = 1L, ncol = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repmat_+3A_x">x</code></td>
<td>
<p>A matrix with dimensions r*c.</p>
</td></tr>
<tr><td><code id="repmat_+3A_nrow">nrow</code></td>
<td>
<p>An integer giving the number of times the matrix is replicated row-wise</p>
</td></tr>
<tr><td><code id="repmat_+3A_ncol">ncol</code></td>
<td>
<p>An integer giving the number of times the matrix is replicated column-wise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with dimensions (r*nrow) x (c*ncol)
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- matrix(1:6, ncol=3)
repmat(m, 2)     # Stack two copies of m on top of each other
repmat(m, 2, 3)  # Replicate m with two copies on top and three copies side-by-side 

</code></pre>

<hr>
<h2 id='residual_plot'>Plots a standardized residual</h2><span id='topic+residual_plot'></span><span id='topic+residual_plot.lm'></span><span id='topic+residual_plot.default'></span><span id='topic+residual_plot.glm'></span>

<h3>Description</h3>

<p>Plots a standardized residual plot from an lm or glm object and provides additional
graphics to help evaluate the variance homogeneity and mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residual_plot(
  x,
  y = NULL,
  candy = TRUE,
  bandwidth = 0.3,
  xlab = "Fitted values",
  ylab = "Std.res.",
  col.sd = "blue",
  alpha = 0.1,
  ylim = NA,
  ...
)

## Default S3 method:
residual_plot(
  x,
  y = NULL,
  candy = TRUE,
  bandwidth = 0.3,
  xlab = "Fitted values",
  ylab = "Std.res.",
  col.sd = "blue",
  alpha = 0.1,
  ylim = NA,
  ...
)

## S3 method for class 'lm'
residual_plot(
  x,
  y,
  candy = TRUE,
  bandwidth = 0.3,
  xlab = "Fitted values",
  ylab = "Stud.res.",
  col.sd = "blue",
  alpha = 0.1,
  ...
)

## S3 method for class 'glm'
residual_plot(
  x,
  y,
  candy = TRUE,
  bandwidth = 0.4,
  xlab = "Fitted values",
  ylab = "Std. dev. res.",
  col.sd = "blue",
  alpha = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residual_plot_+3A_x">x</code></td>
<td>
<p>lm object or a numeric vector</p>
</td></tr>
<tr><td><code id="residual_plot_+3A_y">y</code></td>
<td>
<p>numeric vector for the y axis values</p>
</td></tr>
<tr><td><code id="residual_plot_+3A_candy">candy</code></td>
<td>
<p>logical. Should a lowess curve and local standard deviation of
the residual be added to the plot. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="residual_plot_+3A_bandwidth">bandwidth</code></td>
<td>
<p>The width of the window used to calculate the local
smoothed version of the mean and the variance. Value should be between 0 and
1 and determines the percentage of the window width used</p>
</td></tr>
<tr><td><code id="residual_plot_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="residual_plot_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="residual_plot_+3A_col.sd">col.sd</code></td>
<td>
<p>color for the background residual deviation</p>
</td></tr>
<tr><td><code id="residual_plot_+3A_alpha">alpha</code></td>
<td>
<p>number between 0 and 1 determining the transprency of the
standard deviation plotting color</p>
</td></tr>
<tr><td><code id="residual_plot_+3A_ylim">ylim</code></td>
<td>
<p>pair of observations that set the minimum and maximum of the y axis. If set to NA (the default) then the limits are computed from the data.</p>
</td></tr>
<tr><td><code id="residual_plot_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The y axis shows the studentized residuals (for lm objects) or
standardized deviance residuals (for glm objects). The x axis shows the linear predictor, i.e., the
predicted values for lm objects.
</p>
<p>The blue area is a smoothed estimate of 1.96*SD of the standardized
residuals in a window around the predicted value. The blue area should
largely be rectangular if the standardized residuals have more or less the
same variance.
</p>
<p>The dashed line shows the smoothed mean of the standardized residuals and
should generally follow the horizontal line through (0,0).
</p>
<p>Solid circles correspond to standardized residuals outside the range from [-1.96; 1.96] while open circles are inside that interval. Roughly 5
</p>


<h3>Value</h3>

<p>Produces a standardized residual plot
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rstandard">rstandard</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linear regression example
data(trees)
model &lt;- lm(Volume ~ Girth + Height, data=trees)
residual_plot(model)
model2 &lt;- lm(Volume ~ Girth + I(Girth^2) + Height, data=trees)
residual_plot(model2)

# Add extra information about points by adding geom_text to the object produced

m &lt;- lm(mpg ~ hp + factor(vs), data=mtcars)
residual_plot(m) + ggplot2::geom_point(ggplot2::aes(color=factor(cyl)), data=mtcars) 

</code></pre>

<hr>
<h2 id='residualplot.default'>Plots a standardized residual</h2><span id='topic+residualplot.default'></span><span id='topic+residualplot.lm'></span><span id='topic+residualplot.glm'></span><span id='topic+residualplot'></span>

<h3>Description</h3>

<p>Plots a standardized residual plot from an lm or glm object and provides additional
graphics to help evaluate the variance homogeneity and mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
residualplot(
  x,
  y = NULL,
  candy = TRUE,
  bandwidth = 0.3,
  xlab = "Fitted values",
  ylab = "Std.res.",
  col.sd = "blue",
  col.alpha = 0.3,
  ylim = NA,
  ...
)

## S3 method for class 'lm'
residualplot(
  x,
  y,
  candy = TRUE,
  bandwidth = 0.3,
  xlab = "Fitted values",
  ylab = "Stud.res.",
  col.sd = "blue",
  col.alpha = 0.3,
  ...
)

## S3 method for class 'glm'
residualplot(
  x,
  y,
  candy = TRUE,
  bandwidth = 0.4,
  xlab = "Fitted values",
  ylab = "Std. dev. res.",
  col.sd = "blue",
  col.alpha = 0.3,
  ...
)

residualplot(
  x,
  y = NULL,
  candy = TRUE,
  bandwidth = 0.3,
  xlab = "Fitted values",
  ylab = "Std.res.",
  col.sd = "blue",
  col.alpha = 0.3,
  ylim = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residualplot.default_+3A_x">x</code></td>
<td>
<p>lm object or a numeric vector</p>
</td></tr>
<tr><td><code id="residualplot.default_+3A_y">y</code></td>
<td>
<p>numeric vector for the y axis values</p>
</td></tr>
<tr><td><code id="residualplot.default_+3A_candy">candy</code></td>
<td>
<p>logical. Should a lowess curve and local standard deviation of
the residual be added to the plot. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="residualplot.default_+3A_bandwidth">bandwidth</code></td>
<td>
<p>The width of the window used to calculate the local
smoothed version of the mean and the variance. Value should be between 0 and
1 and determines the percentage of the window width used</p>
</td></tr>
<tr><td><code id="residualplot.default_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="residualplot.default_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="residualplot.default_+3A_col.sd">col.sd</code></td>
<td>
<p>color for the background residual deviation</p>
</td></tr>
<tr><td><code id="residualplot.default_+3A_col.alpha">col.alpha</code></td>
<td>
<p>number between 0 and 1 determining the transprency of the
standard deviation plotting color</p>
</td></tr>
<tr><td><code id="residualplot.default_+3A_ylim">ylim</code></td>
<td>
<p>pair of observations that set the minimum and maximum of the y axis. If set to NA (the default) then the limits are computed from the data.</p>
</td></tr>
<tr><td><code id="residualplot.default_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The y axis shows the studentized residuals (for lm objects) or
standardized deviance residuals (for glm objects). The x axis shows the linear predictor, i.e., the
predicted values for lm objects.
</p>
<p>The blue area is a smoothed estimate of 1.96*SD of the standardized
residuals in a window around the predicted value. The blue area should
largely be rectangular if the standardized residuals have more or less the
same variance.
</p>
<p>The dashed line shows the smoothed mean of the standardized residuals and
should generally follow the horizontal line through (0,0).
</p>
<p>Solid circles correspond to standardized residuals outside the range from [-1.96; 1.96] while open circles are inside that interval. Roughly 5
</p>


<h3>Value</h3>

<p>Produces a standardized residual plot
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rstandard">rstandard</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linear regression example
data(trees)
model &lt;- lm(Volume ~ Girth + Height, data=trees)
residualplot(model)
model2 &lt;- lm(Volume ~ Girth + I(Girth^2) + Height, data=trees)
residualplot(model2)

</code></pre>

<hr>
<h2 id='rmvt.pedigree'>Simulate residual multivariate t-distributed data from a polygenic model</h2><span id='topic+rmvt.pedigree'></span>

<h3>Description</h3>

<p>Simulates residual multivariate t-distributed response data from a pedigree
where the additive genetic, dominance genetic, and shared environmental
effects are taken into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvt.pedigree(n = 1, pedigree, h2 = 0, c2 = 0, d2 = 0, df = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvt.pedigree_+3A_n">n</code></td>
<td>
<p>numeric. The number of simulations to generate</p>
</td></tr>
<tr><td><code id="rmvt.pedigree_+3A_pedigree">pedigree</code></td>
<td>
<p>a <code>pedigree</code> object</p>
</td></tr>
<tr><td><code id="rmvt.pedigree_+3A_h2">h2</code></td>
<td>
<p>numeric. The heritability</p>
</td></tr>
<tr><td><code id="rmvt.pedigree_+3A_c2">c2</code></td>
<td>
<p>numeric. The environmentability</p>
</td></tr>
<tr><td><code id="rmvt.pedigree_+3A_d2">d2</code></td>
<td>
<p>numeric. The dominance deviance effect</p>
</td></tr>
<tr><td><code id="rmvt.pedigree_+3A_df">df</code></td>
<td>
<p>numeric. The degrees of freedom for the t distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three parameters should have a sum: h2+c2+d2 that is less than 1. The
total variance is set to 1, and the mean is zero.
</p>


<h3>Value</h3>

<p>Returns a matrix with the simulated values with n columns (one for
each simulation) and each row matches the corresponding individual from the
pedigree
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>See Also</h3>

<p><code>pedigree</code>, <code>kinship</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(kinship2)
library(mvtnorm)
mydata &lt;- data.frame(id=1:5,
                     dadid=c(NA, NA, 1, 1, 1),
                     momid=c(NA, NA, 2, 2, 2),
                     sex=c("male", "female", "male", "male", "male"),
                     famid=c(1,1,1,1,1))
relation &lt;- data.frame(id1=c(3), id2=c(4), famid=c(1), code=c(1))
ped &lt;- pedigree(id=mydata$id, dadid=mydata$dadid, momid=mydata$momid,
                sex=mydata$sex, relation=relation)
rmvt.pedigree(2, ped, h2=.25, df=4)

</code></pre>

<hr>
<h2 id='rmvtnorm.pedigree'>Simulate residual multivariate Gaussian data from a polygenic model</h2><span id='topic+rmvtnorm.pedigree'></span>

<h3>Description</h3>

<p>Simulates residual multivariate Gaussian response data from a pedigree where
the additive genetic, dominance genetic, and shared environmental effects
are taken into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvtnorm.pedigree(n = 1, pedigree, h2 = 0, c2 = 0, d2 = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvtnorm.pedigree_+3A_n">n</code></td>
<td>
<p>numeric. The number of simulations to generate</p>
</td></tr>
<tr><td><code id="rmvtnorm.pedigree_+3A_pedigree">pedigree</code></td>
<td>
<p>a <code>pedigree</code> object</p>
</td></tr>
<tr><td><code id="rmvtnorm.pedigree_+3A_h2">h2</code></td>
<td>
<p>numeric. The heritability</p>
</td></tr>
<tr><td><code id="rmvtnorm.pedigree_+3A_c2">c2</code></td>
<td>
<p>numeric. The environmentability</p>
</td></tr>
<tr><td><code id="rmvtnorm.pedigree_+3A_d2">d2</code></td>
<td>
<p>numeric. The dominance deviance effect</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three parameters should have a sum: h2+c2+d2 that is less than 1. The
total variance is set to 1, and the mean is zero.
</p>


<h3>Value</h3>

<p>Returns a matrix with the simulated values with n columns (one for
each simulation) and each row matches the corresponding individual from the
pedigree
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>See Also</h3>

<p><code>pedigree</code>, <code>kinship</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(kinship2)
library(mvtnorm)
mydata &lt;- data.frame(id=1:5,
                     dadid=c(NA, NA, 1, 1, 1),
                     momid=c(NA, NA, 2, 2, 2),
                     sex=c("male", "female", "male", "male", "male"),
                     famid=c(1,1,1,1,1))
relation &lt;- data.frame(id1=c(3), id2=c(4), famid=c(1), code=c(1))
ped &lt;- pedigree(id=mydata$id, dadid=mydata$dadid, momid=mydata$momid,
                sex=mydata$sex, relation=relation)
rmvtnorm.pedigree(2, ped, h2=.25)

</code></pre>

<hr>
<h2 id='rnorm_perfect'>Simulate values from a perfect normal distribution</h2><span id='topic+rnorm_perfect'></span>

<h3>Description</h3>

<p>Random generation for a perfect normal distribution with mean equal to mean and standard deviation equal to sd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnorm_perfect(n, mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnorm_perfect_+3A_n">n</code></td>
<td>
<p>number of observations. If length(n) &gt; 1, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rnorm_perfect_+3A_mean">mean</code></td>
<td>
<p>number of mean.</p>
</td></tr>
<tr><td><code id="rnorm_perfect_+3A_sd">sd</code></td>
<td>
<p>number of standard deviation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will return the same set of quantiles for fixed n. In that sense there is not much randomness going on, and the function is mostly useful for illustrative purposes.
</p>


<h3>Value</h3>

<p>Returns a vector of values from a perfect normal distribution
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rnorm_perfect(30, mean=10, sd=2)

</code></pre>

<hr>
<h2 id='rootonorm'>Hanging rootogram for normal distribution</h2><span id='topic+rootonorm'></span><span id='topic+rootogram'></span>

<h3>Description</h3>

<p>Create a hanging rootogram for a quantitative numeric vector and compare it
to a Gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rootonorm(
  x,
  breaks = "Sturges",
  type = c("hanging", "deviation"),
  scale = c("sqrt", "raw"),
  zeroline = TRUE,
  linecol = "red",
  rectcol = "lightgrey",
  xlab = xname,
  ylab = "Sqrt(frequency)",
  yaxt = "n",
  ylim = NULL,
  mu = mean(x),
  s = sd(x),
  gap = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rootonorm_+3A_x">x</code></td>
<td>
<p>a numeric vector of values for which the rootogram is desired</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_breaks">breaks</code></td>
<td>
<p>Either the character string &lsquo;Sturges&rsquo; to use Sturges'
algorithm to decide the number of breaks or a positive integer that sets the
number of breaks.</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_type">type</code></td>
<td>
<p>if <code>"hanging"</code> then a hanging rootogram is plotted, and if
<code>"deviation"</code> then deviations from zero are plotted.</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_scale">scale</code></td>
<td>
<p>The type of transformation. Defaults to <code>"sqrt"</code> which
takes square roots of the frequencies. <code>"raw"</code> yields untransformed
frequencies.</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_zeroline">zeroline</code></td>
<td>
<p>logical; if <code>TRUE</code> a horizontal line is added at zero.</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_linecol">linecol</code></td>
<td>
<p>The color of the density line for the normal distribution.
The default is to make a <code>red</code> density line.</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_rectcol">rectcol</code></td>
<td>
<p>a colour to be used to fill the bars.  The default of
<code>lightgray</code> yields lightgray bars.</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_xlab">xlab</code>, <code id="rootonorm_+3A_ylab">ylab</code></td>
<td>
<p>plot labels.  The <code>xlab</code> and <code>ylab</code> refer to the
x and y axes respectively</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_yaxt">yaxt</code></td>
<td>
<p>Should y axis text be printed. Defaults to <code>n</code>.</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_ylim">ylim</code></td>
<td>
<p>the range of y values with sensible defaults.</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_mu">mu</code></td>
<td>
<p>the mean of the Gaussian distribution. Defaults to the sample mean
of <code>x</code>.</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_s">s</code></td>
<td>
<p>the standard deivation of the Gaussian distribution. Defaults to
the sample std.dev. of <code>x</code>.</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_gap">gap</code></td>
<td>
<p>The distance between the rectangles in the histogram.</p>
</td></tr>
<tr><td><code id="rootonorm_+3A_...">...</code></td>
<td>
<p>further arguments and graphical parameters passed to
<code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean and standard deviation of the Gaussian distribution are calculated
from the observed data unless the <code>mu</code> and <code>s</code> arguments are
given. 
</p>


<h3>Value</h3>

<p>Returns a vector of counts of each bar. This may be changed in the
future. The plot is the primary output of the function.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Tukey, J. W. 1972. <em>Some Graphic and Semigraphic Displays</em>.
In <em>Statistical Papers in Honor of George W. Snedecor</em>, p. 293-316.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
oldpar &lt;- par()
par(mfrow=c(2,2))
rootonorm(rnorm(200))
rootonorm(rnorm(200), type="deviation", scale="raw")
rootonorm(rnorm(200), mu=1)
rootonorm(rexp(200), mu=1)
par(oldpar)

</code></pre>

<hr>
<h2 id='round_percent'>Round vector of number to percentages</h2><span id='topic+round_percent'></span>

<h3>Description</h3>

<p>Rounds a vector of numeric values to percentages ensuring that they add up to 100
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_percent(x, decimals = 0L, ties = c("random", "last"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_percent_+3A_x">x</code></td>
<td>
<p>A numeric vector with non-negative values.</p>
</td></tr>
<tr><td><code id="round_percent_+3A_decimals">decimals</code></td>
<td>
<p>An integer giving the number of decimals that are used</p>
</td></tr>
<tr><td><code id="round_percent_+3A_ties">ties</code></td>
<td>
<p>A string that is either 'random' (the default) or 'last'. Determines how to break ties. Random is random, last prefers to break ties at the last position</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a vector of numeric values.
</p>


<h3>Value</h3>

<p>Returns a numeric vector of the same length as x
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- c(1,2,1,3,2,1,2,3,1)
round_percent(f)


</code></pre>

<hr>
<h2 id='rud'>Simulate randomized urn design</h2><span id='topic+rud'></span>

<h3>Description</h3>

<p>Simulates a randomized treatment based on an urn model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rud(
  n,
  alpha = c(1, 1),
  beta = 1,
  labels = seq(1, length(alpha)),
  data.frame = FALSE,
  startid = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rud_+3A_n">n</code></td>
<td>
<p>the number of individuals to randomize</p>
</td></tr>
<tr><td><code id="rud_+3A_alpha">alpha</code></td>
<td>
<p>a non-negative integer vector of weights for each treatment group. The length of the vector corresponds to the number of treatment groups.</p>
</td></tr>
<tr><td><code id="rud_+3A_beta">beta</code></td>
<td>
<p>a non-negative integer of weights added to the groups that were not given treatment</p>
</td></tr>
<tr><td><code id="rud_+3A_labels">labels</code></td>
<td>
<p>a vector of treatment labels. Must be the same length as the length of alpha.</p>
</td></tr>
<tr><td><code id="rud_+3A_data.frame">data.frame</code></td>
<td>
<p>A logical that determines if the function should return a vector of group indices (the default, if FALSE) or a data frame (if TRUE).</p>
</td></tr>
<tr><td><code id="rud_+3A_startid">startid</code></td>
<td>
<p>margin paramaters; vector of length 4 (see <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The urn model can be described as follows: For k different treatments, the urn design is initiated with a number of balls in an urn corresponding to the start weight (the alpha argument), where each treatment has a specific colour. Whenever a patient arrives, a random ball is drawn from the urn and the colour decides the treatment for the patient. For each of the treatments that weren't chosen we add beta balls of the corresponding colour(s) to the urn to update the probabilities for the next patient.
</p>


<h3>Value</h3>

<p>A vector with group indices. If the argument <code>data.frame=TRUE</code> is used then a data frame with three variables is returned: id, group, and treatment (the group label).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rud(5)
rud(5, alpha=c(1,1,10), beta=5)

</code></pre>

<hr>
<h2 id='scorefct'>Internal functions for the MESS package</h2><span id='topic+scorefct'></span>

<h3>Description</h3>

<p>Internal functions for the MESS package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scorefct(o, beta = NULL, testidx = NULL, sas = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scorefct_+3A_o">o</code></td>
<td>
<p>input geepack object from a geeglm fit.</p>
</td></tr>
<tr><td><code id="scorefct_+3A_beta">beta</code></td>
<td>
<p>The estimated parameters. If set to <code>NULL</code> then the parameter estimates are extracted from the model fit object o.</p>
</td></tr>
<tr><td><code id="scorefct_+3A_testidx">testidx</code></td>
<td>
<p>Indices of the beta parameters that should be tested equal to zero</p>
</td></tr>
<tr><td><code id="scorefct_+3A_sas">sas</code></td>
<td>
<p>Logical. Should the SAS version of the score test be computed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>

<hr>
<h2 id='screen_variables'>Screen variable before penalized regression</h2><span id='topic+screen_variables'></span>

<h3>Description</h3>

<p>Expands a contingency table to a data frame where each observation in the table becomes a single observation in the data frame with corresponding information for each for each combination of the table dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>screen_variables(x, y, lambda = 0.1, method = c("global-strong", "global-DPP"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screen_variables_+3A_x">x</code></td>
<td>
<p>A table or matrix</p>
</td></tr>
<tr><td><code id="screen_variables_+3A_y">y</code></td>
<td>
<p>A vector of outcomes</p>
</td></tr>
<tr><td><code id="screen_variables_+3A_lambda">lambda</code></td>
<td>
<p>a vector of positive values used for the penalization parameter.</p>
</td></tr>
<tr><td><code id="screen_variables_+3A_method">method</code></td>
<td>
<p>a string giving the method used for screening. Two possibilities are &quot;global-strong&quot; and &quot;global-DPP&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that no standardization is done (not necessary?)
</p>


<h3>Value</h3>

<p>A list with three elements: lambda which contains the lambda values, selected which contains the indices of the selected variables, and method a string listing the method used.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Hastie, Tibshirani and Wainwright (2015). &quot;Statistical Learning with Sparsity&quot;. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(rnorm(50*100), nrow=50)
y &lt;- rnorm(50, mean=x[,1])
screen_variables(x, y, lambda=c(.1, 1, 2))

</code></pre>

<hr>
<h2 id='segregate.genes'>Segregate genes through a pedigree</h2><span id='topic+segregate.genes'></span>

<h3>Description</h3>

<p>Segregate di-allelic genes down through the generations of a pedigree. It is
assumed that the founders are independent and that the genes are in Hardy
Weinberg equilibrium in the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segregate.genes(pedigree, maf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segregate.genes_+3A_pedigree">pedigree</code></td>
<td>
<p>a <code>pedigree</code> object</p>
</td></tr>
<tr><td><code id="segregate.genes_+3A_maf">maf</code></td>
<td>
<p>a vector of minor allele frequencies for each diallelic gene to
segregate through the pedigree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame. Each row matches the order of the individuals
in the pedigree and each column corresponds to each of the segregated genes.
The data frame contains values 0, 1, or 2 corresponding to the number of
copies of the minor allele frequency allele that person has.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>See Also</h3>

<p><code>pedigree</code>, <code>kinship</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(kinship2)
mydata &lt;- data.frame(id=1:5, 
                     dadid=c(NA, NA, 1, 1, 1), 
                     momid=c(NA, NA, 2, 2, 2), 
                     sex=c("male", "female", "male", "male", "male"), 
                     famid=c(1,1,1,1,1))
relation &lt;- data.frame(id1=c(3), id2=c(4), famid=c(1), code=c(1))
ped &lt;- pedigree(id=mydata$id, dadid=mydata$dadid, momid=mydata$momid, 
                sex=mydata$sex, relation=relation)
segregate.genes(ped, c(.1, .3, .5))

</code></pre>

<hr>
<h2 id='sinv'>Invert a symmetric positive-definite matrix</h2><span id='topic+sinv'></span>

<h3>Description</h3>

<p>Inverts a symmetric positive-definite matrix without requiring the Matrix package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinv(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinv_+3A_obj">obj</code></td>
<td>
<p>The symmetric positive-definite matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does no error checking and it is up to the user to ensure that the input is indeed symmetric, positive-definite, and a matrix.
</p>


<h3>Value</h3>

<p>A matrix of the same size as the input object
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom, <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1, 0, .5, .5, 0, 1, .5, .5, .5, .5, 1, .5, .5, .5, .5, 1), 4)
sinv(m)

</code></pre>

<hr>
<h2 id='smokehealth'>Effect of smoking on self reported health</h2><span id='topic+smokehealth'></span>

<h3>Description</h3>

<p>Effect of smoking at 45 years of age on self reported health five years later. Data are on a sample of males from the Glostrup survey.
</p>


<h3>Format</h3>

<p>A table with daily smoking categories for the rows and self reported health five years later as the columns.
</p>


<h3>Source</h3>

<p>Data example found on the internet but originates from Svend Kreiner
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(smokehealth)
m &lt;- smokehealth
m[,3] &lt;- m[,3]+ m[,4]
m[4,] &lt;- m[4,] + m[5,]
m &lt;- m[1:4,1:3]
gkgamma(m)
chisq.test(m)

</code></pre>

<hr>
<h2 id='soccer'>Danish national soccer players</h2><span id='topic+soccer'></span>

<h3>Description</h3>

<p>Players on the Danish national soccer team. The dataset consists of all
players who have been picked to play on the men's senior A-team, their
position, date-of-birth, goals and matches.
</p>


<h3>Format</h3>

<p>A data frame with 805 observations on the following 5 variables.
</p>
 <dl>
<dt>name</dt><dd><p>a factor with names of the players</p>
</dd>
<dt>DoB</dt><dd><p>a Date. The date-of-birth of the player</p>
</dd>
<dt>position</dt><dd><p>a factor with levels <code>Forward</code> <code>Defender</code>
<code>Midfielder</code> <code>Goalkeeper</code></p>
</dd> <dt>matches</dt><dd><p>a numeric
vector. The number of A matches played by the player</p>
</dd> <dt>goals</dt><dd><p>a
numeric vector. The number of goals scored by the player in A matches</p>
</dd> </dl>



<h3>Source</h3>

<p>Data collected from the player database of DBU on March 21st, 2014.
See <a href="https://www.dbu.dk">https://www.dbu.dk</a> for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(soccer)

birthmonth &lt;- as.numeric(format(soccer$DoB, "%m"))
birthyear &lt;- as.numeric(format(soccer$DoB, "%Y"))


</code></pre>

<hr>
<h2 id='superroot2'>Gene expression data from two-color dye-swap experiment</h2><span id='topic+superroot2'></span>

<h3>Description</h3>

<p>Gene expression levels from two-color dye-swap experiment on 6 microarrays.
Arrays 1 and 2 represent the first biological sample (ie, the first dye
swap), 3 and 4 the second, and arrays 5 and 6 the third.
</p>


<h3>Format</h3>

<p>A data frame with 258000 observations on the following 5 variables.
</p>
 <dl>
<dt>color</dt><dd><p>a factor with levels <code>green</code> <code>red</code>
representing the dye used for the gene expression</p>
</dd> <dt>array</dt><dd><p>a
factor with levels <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code>
corresponding to the 6 arrays</p>
</dd> <dt>gene</dt><dd><p>a factor with 21500
levels representing the genes on the arrays</p>
</dd> <dt>plant</dt><dd><p>a factor
with levels <code>rnt</code> <code>wt</code> for the two types of plants: runts and wild
type</p>
</dd> <dt>signal</dt><dd><p>a numeric vector with the gene expression level
(normalized but not log transformed)</p>
</dd> </dl>



<h3>Source</h3>

<p>Data provided by Soren Bak &lt;bak@life.ku.dk&gt;. <br /> Added by Claus
Ekstrom &lt;ekstrom@sund.ku.dk&gt;
</p>


<h3>References</h3>

<p>Morant, M. et al. (2010). Metabolomic, Transcriptional, Hormonal
and Signaling Cross-Talk in Superroot2. <em>Molecular Plant</em>. 3,
p.192&ndash;211.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(superroot2)
# Select one gene
g1 &lt;- superroot2[superroot2$gene=="AT2G24000.1",]
model &lt;- lm(log(signal) ~ plant + color + array, data=g1)
summary(model)

</code></pre>

<hr>
<h2 id='tracemp'>Fast computation of trace of matrix product</h2><span id='topic+tracemp'></span>

<h3>Description</h3>

<p>Fast computation of the trace of the matrix product trace(t(A) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracemp(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tracemp_+3A_a">A</code></td>
<td>
<p>A matrix with dimensions n*k.</p>
</td></tr>
<tr><td><code id="tracemp_+3A_b">B</code></td>
<td>
<p>A matrix with dimenions n*k.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The trace of the matrix product
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom &lt;claus@rprimer.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- matrix(1:12, ncol=3)
tracemp(A, A)

</code></pre>

<hr>
<h2 id='usd'>Unbiased standard deviation</h2><span id='topic+usd'></span>

<h3>Description</h3>

<p>This function computes the unbiased standard deviation of the values in x. If <code>na.rm</code> is TRUE then missing values are removed before computation proceeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usd(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="usd_+3A_x">x</code></td>
<td>
<p>a numeric vector or an R object but not a factor coercible to numeric by as.double(x)</p>
</td></tr>
<tr><td><code id="usd_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Like var this uses denominator n - 1.
The standard deviation of a length-one or zero-length vector is NA.
</p>


<h3>Value</h3>

<p>A scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sd(1:5)
usd(1:5)

</code></pre>

<hr>
<h2 id='wallyplot.default'>Plots a Wally plot</h2><span id='topic+wallyplot.default'></span><span id='topic+wallyplot.lm'></span><span id='topic+wallyplot'></span>

<h3>Description</h3>

<p>Produces a 3x3 grid of residual- or qq-plots plots from a lm object. One of
the nine subfigures is the true residual plot/qqplot while the remaining are
plots that fulfill the assumptions of the linear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
wallyplot(
  x,
  y = x,
  FUN = residualplot,
  hide = TRUE,
  simulateFunction = rnorm,
  model = NULL,
  ...
)

## S3 method for class 'lm'
wallyplot(
  x,
  y = x,
  FUN = residualplot,
  hide = TRUE,
  simulateFunction = lmsimresiduals,
  ...
)

wallyplot(
  x,
  y = x,
  FUN = residualplot,
  hide = TRUE,
  simulateFunction = rnorm,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wallyplot.default_+3A_x">x</code></td>
<td>
<p>a numeric vector of x values, or an lm object.</p>
</td></tr>
<tr><td><code id="wallyplot.default_+3A_y">y</code></td>
<td>
<p>a numeric vector of y values of the same length as x or a n * 9
matrix of y values - one column for each of the nine plots to make. The
first column is the one corresponding to the results from the dataset</p>
</td></tr>
<tr><td><code id="wallyplot.default_+3A_fun">FUN</code></td>
<td>
<p>a function that accepts an <code>x</code>, <code>y</code> and <code>...</code>
argument and produces a graphical model validation plots from the <code>x</code>
and <code>y</code> values.</p>
</td></tr>
<tr><td><code id="wallyplot.default_+3A_hide">hide</code></td>
<td>
<p>logical; if <code>TRUE</code> (the default) then the identity of the
true residual plot is hidden until the user presses a key. If <code>FALSE</code>
then the true residual plot is shown in the center.</p>
</td></tr>
<tr><td><code id="wallyplot.default_+3A_simulatefunction">simulateFunction</code></td>
<td>
<p>The function used to produce y values under the null
hypothesis. Defaults to rnorm</p>
</td></tr>
<tr><td><code id="wallyplot.default_+3A_model">model</code></td>
<td>
<p>Optional input to simulateFunction</p>
</td></tr>
<tr><td><code id="wallyplot.default_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the plot function <code>FUN</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users who look at residual plots or qqnorm plots for the first time often
feel they lack the experience to determine if the residual plot is okay or
if the model assumptions are indeed violated. One way to convey &quot;experience&quot;
is to plot a series of graphical model validation plots simulated under the
model assumption together with the corresponding plot from the real data and
see if the user can pinpoint one of them that looks like an odd-one-out. If
the proper plot from the real data does not stand out then the assumptions
are not likely to be violated.
</p>
<p>The Wallyplot produces a 3x3 grid of plots from a lm object or from a set of
pairs of x and y values. One of the nine subfigures is the true plot while
the remaining are plots that fulfill the assumptions of the linear model.
After the user interactively hits a key the correct residual plot
(correponding to the provided data) is shown.
</p>
<p>The plotting function can be set using the <code>FUN</code> argument which should
be a function that accepts <code>x</code>, <code>y</code> and <code>...</code> arguments and
plots the desired figure. When <code>y</code> is a single vector the same length
as <code>x</code> then the function <code>simulateFunction</code> is used to generate
the remaining y values corresponding the situations under the null.
</p>
<p>For a description of the features of the default residual plot see the help page for <code><a href="#topic+residualplot">residualplot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>
</p>


<h3>References</h3>

<p>Ekstrom, CT (2014) <em>Teaching 'Instant Experience' with
Graphical Model Validation Techniques</em>. Teaching Statistics (36), p 23-26
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(trees)
res &lt;- lm(Volume ~ Height + Girth, data=trees)
wallyplot(res)


# Create a grid of QQ-plot figures
# Define function to plot a qq plot with an identity line
qqnorm.wally &lt;- function(x, y, ...) { qqnorm(y, ...) ; abline(a=0, b=1) }
wallyplot(res, FUN=qqnorm.wally, main="")

# Define function to simulate components+residuals for Girth
cprsimulate &lt;- function(n) {rnorm(n)+trees$Girth}
# Create the cpr plotting function
cprplot &lt;- function(x, y, ...) {plot(x, y, pch=20, ...) ;
                                 lines(lowess(x, y), lty=3)}
# Create the Wallyplot
wallyplot(trees$Girth, trees$Girth+rstudent(res), FUN=cprplot,
          simulateFunction=cprsimulate, xlab="Girth")

## End(Not run)

</code></pre>

<hr>
<h2 id='write.xml'>Write a data frame in XML format</h2><span id='topic+write.xml'></span>

<h3>Description</h3>

<p>Writes the data frame to a file in the XML format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.xml(data, file = NULL, collapse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.xml_+3A_data">data</code></td>
<td>
<p>the data frame object to save</p>
</td></tr>
<tr><td><code id="write.xml_+3A_file">file</code></td>
<td>
<p>the file name to be written to.</p>
</td></tr>
<tr><td><code id="write.xml_+3A_collapse">collapse</code></td>
<td>
<p>logical. Should the output file be collapsed to make it fill less? (Defaults to TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not require the <span class="pkg">XML</span> package to be installed to function properly.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom, <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a> based on previous work by Duncan Temple Lang.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(trees)
write.xml(trees, file="mydata.xml")

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
