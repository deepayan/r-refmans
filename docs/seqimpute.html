<!DOCTYPE html><html><head><title>Help for package seqimpute</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {seqimpute}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addcluster'><p>Function that adds the clustering result to a <code>seqimp</code> object</p>
obtained with the <code>seqimpute</code> function</a></li>
<li><a href='#fromseqimp'><p>Transform an object of class <code>seqimp</code> into a dataframe or a <code>mids</code></p>
object</a></li>
<li><a href='#gameadd'><p>Example data set: Game addiction</p></a></li>
<li><a href='#plot.seqimp'><p>Plot a <code>seqimp</code> object</p></a></li>
<li><a href='#print.seqimp'><p>Print a <code>seqimp</code> object</p></a></li>
<li><a href='#seqaddNA'><p>Generation of missing on longitudinal categorical data.</p></a></li>
<li><a href='#seqcomplete'><p>Extract all the trajectories without missing value.</p></a></li>
<li><a href='#seqimpute'><p>seqimpute: Imputation of missing data in longitudinal categorical data</p></a></li>
<li><a href='#seqmissfplot'><p>Plot the most common patterns of missing data.</p></a></li>
<li><a href='#seqmissimplic'><p>Identification and visualization of states that best characterize sequences</p>
with missing data</a></li>
<li><a href='#seqmissIplot'><p>Plot all the patterns of missing data.</p></a></li>
<li><a href='#seqQuickLook'><p>Summary of the types of gaps among a dataset</p></a></li>
<li><a href='#seqTrans'><p>Spotting impossible transitions in longitudinal categorical data</p></a></li>
<li><a href='#seqwithmiss'><p>Extract all the trajectories with at least one missing value</p></a></li>
<li><a href='#summary.seqimp'><p>Summary of a <code>seqimp</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Imputation of Missing Data in Sequence Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiple imputation of missing data present in a dataset
    through the prediction based on either a random forest or a
    multinomial regression model. Covariates and time-dependent covariates
    can be included in the model. The prediction of the missing values is
    based on the method of Halpin (2012)
    <a href="https://researchrepository.ul.ie/articles/report/Multiple_imputation_for_life-course_sequence_data/19839736">https://researchrepository.ul.ie/articles/report/Multiple_imputation_for_life-course_sequence_data/19839736</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Amelia, cluster, dfidx, doRNG, doSNOW, dplyr, foreach,
graphics, mlr, nnet, parallel, plyr, ranger, rms, stats,
stringr, TraMineR, TraMineRextras, utils, mice</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-25 21:03:27 UTC; Kevin</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Emery [aut, cre],
  Anthony Guinchard [aut],
  Andre Berchtold [aut],
  Kamyar Taher [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Emery &lt;kevin.emery@unige.ch&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-27 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addcluster'>Function that adds the clustering result to a <code>seqimp</code> object
obtained with the <code>seqimpute</code> function</h2><span id='topic+addcluster'></span>

<h3>Description</h3>

<p>Function that adds the clustering result to a <code>seqimp</code> object
obtained with the <code>seqimpute</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addcluster(impdata, clustering)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addcluster_+3A_impdata">impdata</code></td>
<td>
<p>An object of class <code>seqimp</code> as created by the 
<code>seqimpute</code> function</p>
</td></tr>
<tr><td><code id="addcluster_+3A_clustering">clustering</code></td>
<td>
<p>clustering made on the multiple imputed dataset. Can 
either be a dataframe or a matrix, where each row correspond to an
observation and each column to a multiple imputed dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>seqimp</code> object containing the cluster to which each 
sequence in each imputed dataset belongs. Specifically, a column named 
cluster is added to the imputed datasets.
</p>

<hr>
<h2 id='fromseqimp'>Transform an object of class <code>seqimp</code> into a dataframe or a <code>mids</code>
object</h2><span id='topic+fromseqimp'></span>

<h3>Description</h3>

<p>The function converts a <code>seqimp</code> object into a specified format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromseqimp(data, format = "long", include = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromseqimp_+3A_data">data</code></td>
<td>
<p>An object of class seqimp as created by the 
function <a href="#topic+seqimpute">seqimpute</a></p>
</td></tr>
<tr><td><code id="fromseqimp_+3A_format">format</code></td>
<td>
<p>The format in which the seqimp object should be returned. It 
could be: <code>"long"</code>, <code>"stacked"</code> and <code>"mids"</code>.
See the Details section for the interpretation.</p>
</td></tr>
<tr><td><code id="fromseqimp_+3A_include">include</code></td>
<td>
<p>logical that indicates if the original dataset with missing
value should be included or not. This parameter does not apply 
if <code>format="mids"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>format</code> specifies the object that should be returned
by the function. It can take the following values
</p>

<dl>
<dt><code>"long"</code></dt><dd>
<p>produces a data set in which imputed data sets are stacked vertically. 
The following columns are added: 1) <code>.imp</code> referring to the 
imputation number, and 2) <code>.id</code> the row names of the original dataset</p>
</dd>
<dt><code>"stacked"</code></dt><dd>
<p>the same as <code>"long"</code>, but without the inclusion of 
the two columns <code>.imp</code> and <code>.id</code></p>
</dd>
<dt><code>"mids"</code></dt><dd>
<p>produces an object of class <code>mids</code>, which is the format
used by the <code>mice</code> package.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Transform a <code>seqimp</code> object into the desired format.
</p>


<h3>Author(s)</h3>

<p>Kevin Emery
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Imputation with the MICT algorithm
imp &lt;- seqimpute(data = gameadd, var = 1:4)

# The object imp is transformed to a dataframe, where completed datasets are
# stacked vertically

imp.stacked &lt;- fromseqimp(data = imp, 
    format = "stacked", include = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='gameadd'>Example data set: Game addiction</h2><span id='topic+gameadd'></span>

<h3>Description</h3>

<p>Dataset containing variables on the gaming addiction of young people. 
The data consists of gaming addiction, coded as either 'no' or 'yes', 
measured over four consecutive years for 500 individuals, three covariates
and one time-dependent covariate. The yearly states
are recorded in columns 1 (<code>T1_abuse</code>) to 4 (<code>T4_abuse</code>).
</p>
<p>The three covariates are 
</p>

<ul>
<li> <p><code>Gender</code> (female or male),
</p>
</li>
<li> <p><code>Age</code> (measured at time 1), 
</p>
</li>
<li> <p><code>Track</code> (school or apprenticeship).
</p>
</li></ul>

<p>The time-varying covariate consists of the individual's relationship to 
gambling at each of the four time points, appearing in columns
<code>T1_gambling</code>, <code>T2_gambling</code>, 
<code>T3_gambling</code>, and <code>T4_gambling</code>. The states are either 
no, gambler or problematic gambler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gameadd)
</code></pre>


<h3>Format</h3>

<p>A data frame containing 500 rows, 4 states variable, 3 covariates
and a time-dependent covariate.
</p>

<hr>
<h2 id='plot.seqimp'>Plot a <code>seqimp</code> object</h2><span id='topic+plot.seqimp'></span>

<h3>Description</h3>

<p>Plot a <code>seqimp</code> object. The state distribution plot of the first 
<code>m</code> completed datasets is shown, possibly alongside the original 
dataset with missing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqimp'
plot(x, m = 5, include = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.seqimp_+3A_x">x</code></td>
<td>
<p>Object of class <code>seqimp</code></p>
</td></tr>
<tr><td><code id="plot.seqimp_+3A_m">m</code></td>
<td>
<p>Number of completed datasets to show</p>
</td></tr>
<tr><td><code id="plot.seqimp_+3A_include">include</code></td>
<td>
<p>logical that indicates if the original dataset with missing
value should be plotted or not</p>
</td></tr>
<tr><td><code id="plot.seqimp_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the seqdplot function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kevin Emery
</p>

<hr>
<h2 id='print.seqimp'>Print a <code>seqimp</code> object</h2><span id='topic+print.seqimp'></span>

<h3>Description</h3>

<p>Print a <code>seqimp</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqimp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.seqimp_+3A_x">x</code></td>
<td>
<p>Object of class <code>seqimp</code></p>
</td></tr>
<tr><td><code id="print.seqimp_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kevin Emery
</p>

<hr>
<h2 id='seqaddNA'>Generation of missing on longitudinal categorical data.</h2><span id='topic+seqaddNA'></span>

<h3>Description</h3>

<p>Generation of missing data under the form of gaps, which
is the typical form of missing data with longitudinal data.
It simulates MCAR or MAR missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqaddNA(
  data,
  var = NULL,
  states.high = NULL,
  propdata = 1,
  pstart.high = 0.1,
  pstart.low = 0.005,
  maxgap = 3,
  only.traj = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqaddNA_+3A_data">data</code></td>
<td>
<p>a data frame containing sequences of a multinomial 
variable with missing data (coded as <code>NA</code>)</p>
</td></tr>
<tr><td><code id="seqaddNA_+3A_var">var</code></td>
<td>
<p>the list of columns containing the trajectories. 
Default is <code>NULL</code>, i.e. all the columns.</p>
</td></tr>
<tr><td><code id="seqaddNA_+3A_states.high">states.high</code></td>
<td>
<p>list of states that have a larger probability of 
triggering a subsequent missing data gap</p>
</td></tr>
<tr><td><code id="seqaddNA_+3A_propdata">propdata</code></td>
<td>
<p>proportion  observations for which missing data is simulated</p>
</td></tr>
<tr><td><code id="seqaddNA_+3A_pstart.high">pstart.high</code></td>
<td>
<p>probability to start a missing data for the 
states specified with the <code>states.high</code> argument</p>
</td></tr>
<tr><td><code id="seqaddNA_+3A_pstart.low">pstart.low</code></td>
<td>
<p>probability to start a missing data for the 
other states</p>
</td></tr>
<tr><td><code id="seqaddNA_+3A_maxgap">maxgap</code></td>
<td>
<p>maximum length of a missing data gap</p>
</td></tr>
<tr><td><code id="seqaddNA_+3A_only.traj">only.traj</code></td>
<td>
<p>logical that specifies whether only the trajectories should 
be returned (<code>only.traj=TRUE</code>), or 
the whole data (<code>only.traj=FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame on which missing data were simulated
</p>


<h3>Author(s)</h3>

<p>Kevin Emery
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate MCAR missing data on the mvad dataset 
# from the TraMineR package

## Not run: 
data(mvad, package = "TraMineR")
mvad.miss &lt;- seqaddNA(mvad, var = 17:86)


# Generate missing data on mvad where joblessness is more likely to trigger 
# a missing data gap
mvad.miss2 &lt;- seqaddNA(mvad, var = 17:86,  states.high = "joblessness")

## End(Not run)

</code></pre>

<hr>
<h2 id='seqcomplete'>Extract all the trajectories without missing value.</h2><span id='topic+seqcomplete'></span>

<h3>Description</h3>

<p>Extract all the trajectories without missing value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqcomplete(data, var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqcomplete_+3A_data">data</code></td>
<td>
<p>either a data frame containing sequences of a multinomial 
variable with missing data (coded as <code>NA</code>) or a state sequence 
object built with the TraMineR package</p>
</td></tr>
<tr><td><code id="seqcomplete_+3A_var">var</code></td>
<td>
<p>the list of columns containing the trajectories. 
Default is NULL, i.e. all the columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a data frame or a state sequence object, depending
the type of data that was provided to the function
</p>


<h3>Author(s)</h3>

<p>Kevin Emery
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Game addiction dataset
data(gameadd)
# Extract the trajectories without any missing data
gameadd.complete &lt;- seqcomplete(gameadd, var = 1:4)



</code></pre>

<hr>
<h2 id='seqimpute'>seqimpute: Imputation of missing data in longitudinal categorical data</h2><span id='topic+seqimpute'></span>

<h3>Description</h3>

<p>The seqimpute package implements the MICT and MICT-timing 
methods. These are multiple imputation methods for longitudinal data. 
The core idea of the algorithms is to fills gaps of missing data, which is 
the typical form of missing data in a longitudinal setting, recursively from 
their edges. The prediction is based on either a multinomial or a 
random forest regression model. Covariates and time-dependent covariates 
can be included in the model. 
</p>
<p>The MICT-timing algorithm is an extension of the MICT algorithm designed 
to address a key limitation of the latter: its assumption that position in 
the trajectory is irrelevant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqimpute(
  data,
  var = NULL,
  np = 1,
  nf = 1,
  m = 5,
  timing = FALSE,
  frame.radius = 0,
  covariates = NULL,
  time.covariates = NULL,
  regr = "multinom",
  npt = 1,
  nfi = 1,
  ParExec = FALSE,
  ncores = NULL,
  SetRNGSeed = FALSE,
  verbose = TRUE,
  available = TRUE,
  pastDistrib = FALSE,
  futureDistrib = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqimpute_+3A_data">data</code></td>
<td>
<p>a data frame containing sequences of a categorical
variable with missing data (coded as <code>NA</code>)</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_var">var</code></td>
<td>
<p>the list of columns containing the trajectories. 
Default is NULL, i.e. all the columns.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_np">np</code></td>
<td>
<p>number of previous observations in the imputation model 
of the internal gaps.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_nf">nf</code></td>
<td>
<p>number of future observations in the imputation model 
of the internal gaps.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_m">m</code></td>
<td>
<p>number of multiple imputations  (default: <code>5</code>).</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_timing">timing</code></td>
<td>
<p>a logical value that specifies if the MICT algorithm 
(timing=FALSE) or the MICT-timing algorithm (timing=TRUE) should be used.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_frame.radius">frame.radius</code></td>
<td>
<p>parameter relative to the MICT-timing algorithm 
specifying the radius of the timeframe.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_covariates">covariates</code></td>
<td>
<p>the list of columns containing the covariates to include
in the imputation process</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_time.covariates">time.covariates</code></td>
<td>
<p>the list of columns containing the time-varying 
covariates to include in the imputation process</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_regr">regr</code></td>
<td>
<p>a character specifying the imputation method. If 
<code>regr="multinom"</code>, multinomial models are used, while 
if <code>regr="rf"</code>, random forest models are used.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_npt">npt</code></td>
<td>
<p>number of previous observations in the imputation model 
of the terminal gaps.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_nfi">nfi</code></td>
<td>
<p>number of future observations in the imputation model 
of the initial gaps.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_parexec">ParExec</code></td>
<td>
<p>logical. If <code>TRUE</code>, the multiple imputations are run 
in parallel. This allows faster run time depending of how many cores 
the processor has.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_ncores">ncores</code></td>
<td>
<p>integer. Number of cores to be used for the parallel 
computation. If no value is set for this parameter, the number of cores 
will be set to the maximum number of CPU cores minus 1.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_setrngseed">SetRNGSeed</code></td>
<td>
<p>an integer that is used to set the seed in the case of 
parallel computation. Note that setting <code>set.seed()</code> alone before the 
seqimpute function won't work in case of parallel computation.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, seqimpute will print history and 
warnings on console. Use <code>verbose=FALSE</code> for silent computation.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_available">available</code></td>
<td>
<p>a logical value allowing the user to choose whether 
to consider the already imputed data in the predictive model 
(<code>available = TRUE</code>) or not (<code>available = FALSE</code>).</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_pastdistrib">pastDistrib</code></td>
<td>
<p>a logical indicating if the past distribution should be 
used as predictor in the imputation model.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_futuredistrib">futureDistrib</code></td>
<td>
<p>a logical indicating if the future distribution 
should be used as predictor in the imputation model.</p>
</td></tr>
<tr><td><code id="seqimpute_+3A_...">...</code></td>
<td>
<p>Named arguments that are passed down to the imputation functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The imputation process is divided into several steps, depending on
the type of gaps of missing data. The order of imputation of the gaps are:
</p>

<dl>
<dt><code>Internal gap: </code></dt><dd><p>there is at least <code>np</code> observations 
before an internal gap and <code>nf</code> after the gap</p>
</dd>
<dt><code>Initial gap: </code></dt><dd><p>gaps situated at the very beginning 
of a trajectory</p>
</dd>
<dt><code>Terminal gap: </code></dt><dd><p>gaps situated at the very end
of a trajectory</p>
</dd>
<dt><code>Left-hand side specifically located gap (SLG): </code></dt><dd><p>gaps 
that have at least <code>nf</code> observations after the gap, but less than
<code>np</code> observation before it</p>
</dd>
<dt><code>Right-hand side SLG: </code></dt><dd><p>gaps 
that have at least <code>np</code> observations before the gap, but less than
<code>nf</code> observation after it</p>
</dd>
<dt><code>Both-hand side SLG: </code></dt><dd><p>gaps 
that have less than <code>np</code> observations before the gap, and less than
<code>nf</code> observations after it</p>
</dd>
</dl>

<p>The primary difference between the MICT and MICT-timing 
algorithms lies in their approach to selecting patterns from other 
sequences for fitting the multinomial model. While the MICT algorithm 
considers all similar patterns regardless of their temporal placement, 
MICT-timing restricts pattern selection to those that are temporally 
closest to the missing value. This refinement ensures that the 
imputation process adequately accounts for temporal dynamics, resulting 
in more accurate imputed values.
</p>


<h3>Value</h3>

<p>Returns an S3 object of class <code>seqimp</code>.
</p>


<h3>Author(s)</h3>

<p>Kevin Emery &lt;kevin.emery@unige.ch&gt;, Andre Berchtold,  
Anthony Guinchard, and Kamyar Taher
</p>


<h3>References</h3>

<p>HALPIN, Brendan (2012). Multiple imputation for life-course 
sequence data. Working Paper WP2012-01, Department of Sociology, 
University of Limerick. http://hdl.handle.net/10344/3639.
</p>
<p>HALPIN, Brendan (2013). Imputing sequence data: Extensions to 
initial and terminal gaps, Stata's. Working Paper WP2013-01, 
Department of Sociology, 
University of Limerick. http://hdl.handle.net/10344/3620
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Default multiple imputation of the trajectories of game addiction with the
# MICT algorithm

## Not run: 
set.seed(5)
imp1 &lt;- seqimpute(data = gameadd, var = 1:4)


# Default multiple imputation with the MICT-timing algorithm
set.seed(3)
imp2 &lt;- seqimpute(data = gameadd, var = 1:4, timing = TRUE)


# Inclusion in the MICt-timing imputation process of the three background 
# characteristics (Gender, Age and Track), and the time-varying covariate 
# about gambling


set.seed(4)
imp3 &lt;- seqimpute(data = gameadd, var = 1:4, covariates = 5:7, 
  time.covariates = 8:11)

  
# Parallel computation


imp4 &lt;- seqimpute(data = gameadd, var = 1:4, covariates = 5:7, 
  time.covariates = 8:11, ParExec = TRUE, ncores=5, SetRNGSeed = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='seqmissfplot'>Plot the most common patterns of missing data.</h2><span id='topic+seqmissfplot'></span>

<h3>Description</h3>

<p>Plot function that renders the most frequent patterns of missing data. This
function is based on the <a href="TraMineR.html#topic+seqfplot">seqfplot</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqmissfplot(data, var = NULL, with.complete = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqmissfplot_+3A_data">data</code></td>
<td>
<p>a data.frame where missing data are coded as <code>NA</code> or 
a state sequence object built with <a href="TraMineR.html#topic+seqdef">seqdef</a> function</p>
</td></tr>
<tr><td><code id="seqmissfplot_+3A_var">var</code></td>
<td>
<p>the list of columns containing the trajectories. 
Default is NULL, i.e. all the columns.</p>
</td></tr>
<tr><td><code id="seqmissfplot_+3A_with.complete">with.complete</code></td>
<td>
<p>a logical stating if complete trajectories 
should be included or not in the plot</p>
</td></tr>
<tr><td><code id="seqmissfplot_+3A_...">...</code></td>
<td>
<p>parameters to be passed to the <a href="TraMineR.html#topic+seqfplot">seqfplot</a> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot function is based on the <a href="TraMineR.html#topic+seqfplot">seqfplot</a> function. 
To see which arguments can be changed, see the <a href="TraMineR.html#topic+seqfplot">seqfplot</a> 
help. In particular, the number of most frequent 
patterns to be plotted can be changed with the argument <code>idxs</code>. By 
default, the 10 most frequent patterns are plotted.
</p>


<h3>Author(s)</h3>

<p>Kevin Emery
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the 10 most common patterns of missing data

seqmissfplot(gameadd, var=1:4)

# Plot the 10 most common patterns of missing data discarding 
# complete trajectories

seqmissfplot(gameadd, var=1:4, with.missing = FALSE)

# Plot only the 5 most common patterns of missing data discarding 
# complete trajectories

seqmissfplot(gameadd, var=1:4, with.missing = FALSE, idxs = 1:5)

</code></pre>

<hr>
<h2 id='seqmissimplic'>Identification and visualization of states that best characterize sequences
with missing data</h2><span id='topic+seqmissimplic'></span>

<h3>Description</h3>

<p>Function based on the <a href="TraMineRextras.html#topic+seqimplic">seqimplic</a>. 
Identification and visualization of the states that best characterize the 
sequence with missing data vs. the sequences without missing data at each 
position (time point). See the <a href="TraMineRextras.html#topic+seqimplic">seqimplic</a> help 
for more details on how it works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqmissimplic(data, var = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqmissimplic_+3A_data">data</code></td>
<td>
<p>a data frame where missing data are coded as <code>NA</code> or 
a state sequence object built with <a href="TraMineR.html#topic+seqdef">seqdef</a> function</p>
</td></tr>
<tr><td><code id="seqmissimplic_+3A_var">var</code></td>
<td>
<p>the list of columns containing the trajectories. 
Default is NULL, i.e. all the columns.</p>
</td></tr>
<tr><td><code id="seqmissimplic_+3A_...">...</code></td>
<td>
<p>parameters to be passed to the <a href="TraMineRextras.html#topic+seqimplic">seqimplic</a>
function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a <code>seqimplic</code> object that can be plotted and printed.
</p>


<h3>Author(s)</h3>

<p>Kevin Emery
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For illustration purpose, we simulate missing data on the mvad dataset,
# available in the TraMineR package. The state "joblessness" state has a 
# higher probability of triggering a missing gap

## Not run: 
data(mvad, package = "TraMineR")
mvad.miss &lt;- seqaddNA(mvad, var = 17:86, states.high = "joblessness")

# The states that best characterize sequences with missing data
implic &lt;- seqmissimplic(mvad.miss, var = 17:86)

# Visualization of the results
plot(implic)

## End(Not run)

</code></pre>

<hr>
<h2 id='seqmissIplot'>Plot all the patterns of missing data.</h2><span id='topic+seqmissIplot'></span>

<h3>Description</h3>

<p>#' @description
Plot function that renders all the patterns of missing data. This
function is based on the <a href="TraMineR.html#topic+seqIplot">seqIplot</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqmissIplot(data, var = NULL, with.complete = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqmissIplot_+3A_data">data</code></td>
<td>
<p>a data.frame where missing data are coded as <code>NA</code> or 
a state sequence object built with <a href="TraMineR.html#topic+seqdef">seqdef</a> function</p>
</td></tr>
<tr><td><code id="seqmissIplot_+3A_var">var</code></td>
<td>
<p>the list of columns containing the trajectories. 
Default is NULL, i.e. all the columns.</p>
</td></tr>
<tr><td><code id="seqmissIplot_+3A_with.complete">with.complete</code></td>
<td>
<p>a logical stating if complete trajectories 
should be included or not in the plot</p>
</td></tr>
<tr><td><code id="seqmissIplot_+3A_...">...</code></td>
<td>
<p>parameters to be passed to the <a href="TraMineR.html#topic+seqIplot">seqIplot</a>function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kevin Emery
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot all the patterns of missing data

seqmissIplot(gameadd, var=1:4)

# Plot all the patterns of missing data discarding 
# complete trajectories

seqmissIplot(gameadd, var=1:4, with.missing = FALSE)
</code></pre>

<hr>
<h2 id='seqQuickLook'>Summary of the types of gaps among a dataset</h2><span id='topic+seqQuickLook'></span>

<h3>Description</h3>

<p>The <code>seqQuickLook()</code> function aimed at providing an overview of the
number and size of the different types of gaps 
spread in the original dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqQuickLook(data, var = NULL, np = 1, nf = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqQuickLook_+3A_data">data</code></td>
<td>
<p>a data.frame where missing data are coded as NA or 
a state sequence object built with <a href="TraMineR.html#topic+seqdef">seqdef</a> function</p>
</td></tr>
<tr><td><code id="seqQuickLook_+3A_var">var</code></td>
<td>
<p>the list of columns containing the trajectories. 
Default is NULL, i.e. all the columns.</p>
</td></tr>
<tr><td><code id="seqQuickLook_+3A_np">np</code></td>
<td>
<p>number of previous observations in the imputation model of the 
internal gaps.</p>
</td></tr>
<tr><td><code id="seqQuickLook_+3A_nf">nf</code></td>
<td>
<p>number of future observations in the imputation model of the 
internal gaps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distinction between internal and SLG gaps depends on the 
number of previous (<code>np</code>) and future (<code>nf</code>) observations that are 
set for the <code>MICT</code> and <code>MICT-timing</code> algorithms.
</p>


<h3>Value</h3>

<p>Returns a  <code>data.frame</code> object that summarizes, for each 
type of gaps (Internal Gaps, Initial Gaps, Terminal Gaps, 
LEFT-hand side SLG, RIGHT-hand side SLG, Both-hand side SLG),
the minimum length, the maximum length, the total number of gaps and
the total number of missing they contain.
</p>


<h3>Author(s)</h3>

<p>Andre Berchtold and Kevin Emery
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gameadd)

seqQuickLook(data = gameadd, var = 1:4, np = 1, nf = 1)

</code></pre>

<hr>
<h2 id='seqTrans'>Spotting impossible transitions in longitudinal categorical data</h2><span id='topic+seqTrans'></span>

<h3>Description</h3>

<p>The purpose of <code>seqTrans</code> is to spot impossible transitions
in longitudinal categorical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqTrans(data, var = NULL, trans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqTrans_+3A_data">data</code></td>
<td>
<p>a data frame containing sequences of a multinomial 
variable with missing data (coded as <code>NA</code>)</p>
</td></tr>
<tr><td><code id="seqTrans_+3A_var">var</code></td>
<td>
<p>the list of columns containing the trajectories. 
Default is NULL, i.e. all the columns.</p>
</td></tr>
<tr><td><code id="seqTrans_+3A_trans">trans</code></td>
<td>
<p><code>character</code> vector gathering the impossible transitions. 
For example: trans &lt;- c(&quot;1-&gt;3&quot;,&quot;1-&gt;4&quot;,&quot;2-&gt;1&quot;,&quot;4-&gt;1&quot;,&quot;4-&gt;3&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a matrix where each row is the position of an 
impossible transition.
</p>


<h3>Author(s)</h3>

<p>Andre Berchtold and Kevin Emery
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gameadd)

seqTransList &lt;- seqTrans(data = gameadd, var = 1:4, trans = c("yes-&gt;no"))

</code></pre>

<hr>
<h2 id='seqwithmiss'>Extract all the trajectories with at least one missing value</h2><span id='topic+seqwithmiss'></span>

<h3>Description</h3>

<p>Extract all the trajectories with at least one missing value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqwithmiss(data, var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqwithmiss_+3A_data">data</code></td>
<td>
<p>either a data frame containing sequences of a multinomial 
variable with missing data (coded as <code>NA</code>) or a state sequence 
object built with the TraMineR package</p>
</td></tr>
<tr><td><code id="seqwithmiss_+3A_var">var</code></td>
<td>
<p>the list of columns containing the trajectories. 
Default is NULL, i.e. all the columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a data frame or a state sequence object, 
depending the type of data that was provided to the function
</p>


<h3>Author(s)</h3>

<p>Kevin Emery
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Game addiction dataset
data(gameadd)
# Extract the trajectories without any missing data
gameadd.withmiss &lt;- seqwithmiss(gameadd, var = 1:4)

</code></pre>

<hr>
<h2 id='summary.seqimp'>Summary of a <code>seqimp</code> object</h2><span id='topic+summary.seqimp'></span>

<h3>Description</h3>

<p>Summary of a <code>seqimp</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqimp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.seqimp_+3A_object">object</code></td>
<td>
<p>Object of class <code>seqimp</code></p>
</td></tr>
<tr><td><code id="summary.seqimp_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kevin Emery
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
