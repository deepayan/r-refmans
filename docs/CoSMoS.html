<!DOCTYPE html><html><head><title>Help for package CoSMoS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CoSMoS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acs'><p>AutoCorrelation Structure</p></a></li>
<li><a href='#ACSfunctions'><p>Autocorrelation structure functions</p></a></li>
<li><a href='#actf'><p>ACTF auto-correlation transformation function</p></a></li>
<li><a href='#actfdiscrete'><p>ACTF auto-correlation transformation function for discrete distributions</p></a></li>
<li><a href='#actfdiscreteInv'><p>Inverse of ACTF auto-correlation transformation function</p></a></li>
<li><a href='#actfInv'><p>Inverse of ACTF auto-correlation transformation function</p></a></li>
<li><a href='#acti'><p>ACTI - autocorrelation transformation integral function</p></a></li>
<li><a href='#actpnts'><p>AutoCorrelation Transformed Points</p></a></li>
<li><a href='#advectionF'><p>Advection fields</p></a></li>
<li><a href='#advectionF2'><p>Advection fields</p></a></li>
<li><a href='#advectionFhyperbolic'><p>Hyperbolic advection field</p></a></li>
<li><a href='#advectionFradial'><p>Radial advection field</p></a></li>
<li><a href='#advectionFrotation'><p>Rotational advection field</p></a></li>
<li><a href='#advectionFspiral'><p>Spiraling advection field</p></a></li>
<li><a href='#advectionFspiralCE'><p>Spiraling advection field satisfying continuity equation</p></a></li>
<li><a href='#advectionFuniform'><p>Uniform advection field</p></a></li>
<li><a href='#analyzeTS'><p>The Functions analyzeTS, reportTS, and simulateTS</p></a></li>
<li><a href='#anisotropyT'><p>Anisotropy transformation</p></a></li>
<li><a href='#anisotropyT2'><p>Anisotropy transformation</p></a></li>
<li><a href='#anisotropyTaffine'><p>Affine anisotropy transformation</p></a></li>
<li><a href='#anisotropyTswirl'><p>Swirl anisotropy transformation</p></a></li>
<li><a href='#anisotropyTwave'><p>Wave anisotropy transformation</p></a></li>
<li><a href='#AR1'><p>Autoregressive model of first order</p></a></li>
<li><a href='#ARp'><p>Autoregressive model of order <em>p</em></p></a></li>
<li><a href='#BurrIII'><p>Burr Type III distribution</p></a></li>
<li><a href='#BurrXII'><p>Burr Type XII distribution</p></a></li>
<li><a href='#checkRF'><p>Numerical and visual check of generated random fields</p></a></li>
<li><a href='#checkTS'><p>Check generated timeseries</p></a></li>
<li><a href='#CoSMoS-package'><p>CoSMoS: Complete Stochastic Modelling Solution</p></a></li>
<li><a href='#disch'><p>Daily streamflow data data</p></a></li>
<li><a href='#ECDF'><p>Empirical cummulative distrubution function</p></a></li>
<li><a href='#erfc'><p>Complementary (inverse) error function</p></a></li>
<li><a href='#fitACS'><p>Autocorrelation structure fit</p></a></li>
<li><a href='#fitactf'><p>Fit the AutoCorrelation Transformation Function</p></a></li>
<li><a href='#fitDist'><p>Distribution fitting</p></a></li>
<li><a href='#fitVAR'><p>VAR model parameters to simulate correlated parent Gaussian random vectors and fields</p></a></li>
<li><a href='#generateMTS'><p>Simulation of multiple time series with given marginals and spatiotemporal properties</p></a></li>
<li><a href='#generateMTSFast'><p>Faster simulation of multiple time series with approximately separable spatiotemporal</p>
correlation structure</a></li>
<li><a href='#generateRF'><p>Simulation of random field with given marginals and spatiotemporal properties</p></a></li>
<li><a href='#generateRFFast'><p>Faster simulation of random fields with approximately separable spatiotemporal</p>
correlation structure</a></li>
<li><a href='#generateTS'><p>Generate timeseries</p></a></li>
<li><a href='#getACSArg'><p>Get names of autocorrelation structure (ACS) function arguments</p></a></li>
<li><a href='#getDistArg'><p>Get names of distribution function arguments</p></a></li>
<li><a href='#GEV'><p>Generalized extreme value distribution</p></a></li>
<li><a href='#GGamma'><p>Generalized gamma distribution</p></a></li>
<li><a href='#lmom'><p>L-Moments calculation</p></a></li>
<li><a href='#moments'><p>Numerical estimation of moments</p></a></li>
<li><a href='#N'><p>Norm - function to be minimized during distrubution fit</p></a></li>
<li><a href='#ParetoII'><p>Pareto type II distribution</p></a></li>
<li><a href='#plot.acti'><p>AutoCorrelation Transformation Function visualisation</p></a></li>
<li><a href='#plot.checkTS'><p>Plot method for check results</p></a></li>
<li><a href='#plot.cosmosts'><p>Plot generated Timeseries</p></a></li>
<li><a href='#plot.fitACS'><p>Plot method for fitACS</p></a></li>
<li><a href='#plot.fitDist'><p>Plot method for fitDist</p></a></li>
<li><a href='#PopulationStat'><p>Population statistics</p></a></li>
<li><a href='#precip'><p>Hourly station precipitation data</p></a></li>
<li><a href='#quickTSPlot'><p>Quick visualization of basic timeseries properties</p></a></li>
<li><a href='#regenerateTS'><p>Bulk Timeseries generation</p></a></li>
<li><a href='#rMSE'><p>Ratio mean square error</p></a></li>
<li><a href='#sample.moments'><p>Estimation of sample moments</p></a></li>
<li><a href='#seasonalACF'><p>Calculate seasonal ACF</p></a></li>
<li><a href='#seasonalAR'><p>Seasonal AR model</p></a></li>
<li><a href='#stcfclayton'><p>Clayton SpatioTemporal Correlation Structure</p></a></li>
<li><a href='#stcfgneiting14'><p>Gneiting-14 SpatioTemporal Correlation Structure</p></a></li>
<li><a href='#stcfgneiting16'><p>Gneiting-16 SpatioTemporal Correlation Structure</p></a></li>
<li><a href='#stcs'><p>SpatioTemporal Correlation Structure</p></a></li>
<li><a href='#stcs2'><p>SpatioTemporal Correlation Structure</p></a></li>
<li><a href='#stratifySeasonData'><p>Stratify timeseries by season</p></a></li>
<li><a href='#YW'><p>Yule-Walker solver</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Complete Stochastic Modelling Solution</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Makes univariate, multivariate, or random fields simulations precise and simple. Just select the desired time series or random fieldsâ€™ properties and it will do the rest. CoSMoS is based on the framework described in Papalexiou (2018, &lt;<a href="https://doi.org/10.1016%2Fj.advwatres.2018.02.013">doi:10.1016/j.advwatres.2018.02.013</a>&gt;), extended for random fields in Papalexiou and Serinaldi (2020, &lt;<a href="https://doi.org/10.1029%2F2019WR026331">doi:10.1029/2019WR026331</a>&gt;), and further advanced in Papalexiou et al. (2021, &lt;<a href="https://doi.org/10.1029%2F2020WR029466">doi:10.1029/2020WR029466</a>&gt;) to allow fine-scale space-time simulation of storms (or even cyclone-mimicking fields).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ggplot2, data.table</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, methods, stats, grDevices, nloptr, MBA, Matrix, mAr,
matrixcalc, mvtnorm, cowplot, directlabels, animation,
ggquiver, pracma, plot3D</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Michael Papalexiou [aut],
  Francesco Serinaldi [aut],
  Filip Strnad [aut],
  Yannis Markonis [aut],
  Kevin Shook [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Shook &lt;kevin.shook@usask.ca&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TycheLab/CoSMoS">https://github.com/TycheLab/CoSMoS</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-29 16:49:14 UTC; kevin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-29 23:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='acs'>AutoCorrelation Structure</h2><span id='topic+acs'></span>

<h3>Description</h3>

<p>Provides a parametric function that describes the values of the linear autocorrelation up to desired lags. For more details on the parametric autocorrelation structures see section 3.2 in Papalexiou (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acs(id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acs_+3A_id">id</code></td>
<td>
<p>autocorrelation structure id</p>
</td></tr>
<tr><td><code id="acs_+3A_...">...</code></td>
<td>
<p>other arguments (t as lag and acs parameters)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Papalexiou, S.M. (2018). Unified theory for stochastic modelling of hydroclimatic
processes: Preserving marginal distributions, correlation structures,
and intermittency. Advances in Water Resources, 115, 234-252, doi: <a href="https://doi.org/10.1016/j.advwatres.2018.02.013">10.1016/j.advwatres.2018.02.013</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## specify lag
t &lt;- 0:10

## get the ACS
f &lt;- acs('fgn', t = t, H = .75)
b &lt;- acs('burrXII', t = t, scale = 1, shape1 = .6, shape2 = .4)
w &lt;- acs('weibull', t = t, scale = 2, shape = 0.8)
p &lt;- acs('paretoII', t = t, scale = 3, shape = 0.3)

## visualize the ACS
dta &lt;- data.table(t, f, b, w, p)

m.dta &lt;- melt(dta, id.vars = 't')

ggplot(m.dta,
       aes(x = t,
           y = value,
           group = variable,
           colour = variable)) +
  geom_point(size = 2.5) +
  geom_line(lwd = 1) +
  scale_color_manual(values = c('steelblue4', 'red4', 'green4', 'darkorange'),
                     labels = c('FGN', 'Burr XII', 'Weibull', 'Pareto II'),
                     name = '') +
  labs(x = bquote(lag ~ tau),
       y = 'Acf') +
  scale_x_continuous(breaks = t) +
  theme_classic()

</code></pre>

<hr>
<h2 id='ACSfunctions'>Autocorrelation structure functions</h2><span id='topic+ACSfunctions'></span><span id='topic+acfburrXII'></span><span id='topic+acfparetoII'></span><span id='topic+acffgn'></span><span id='topic+acfweibull'></span>

<h3>Description</h3>

<p>Autocorrelation structure functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfburrXII(t, scale, shape1, shape2)

acfparetoII(t, scale, shape)

acffgn(t, H)

acfweibull(t, scale, shape)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>
t &lt;- 1

H &lt;- .75
scale &lt;- .2
shape &lt;- .3
shape1 &lt;- .5
shape2 &lt;- .2

acfburrXII(t, scale, shape1, shape2)

acfparetoII(t, scale, shape)

acffgn(t, H)

acfweibull(t, scale, shape)

</code></pre>

<hr>
<h2 id='actf'>ACTF auto-correlation transformation function</h2><span id='topic+actf'></span>

<h3>Description</h3>

<p>Provides tranformation for continuous distributions, based on two parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actf(rhox, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="actf_+3A_rhox">rhox</code></td>
<td>
<p>marginal correlation value</p>
</td></tr>
<tr><td><code id="actf_+3A_b">b</code></td>
<td>
<p>1st line parameter</p>
</td></tr>
<tr><td><code id="actf_+3A_c">c</code></td>
<td>
<p>2nd line parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
actf(.4, 1, 0)

</code></pre>

<hr>
<h2 id='actfdiscrete'>ACTF auto-correlation transformation function for discrete distributions</h2><span id='topic+actfdiscrete'></span>

<h3>Description</h3>

<p>Provides tranformation for discrete distributions, based on two parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actfdiscrete(rhox, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="actfdiscrete_+3A_rhox">rhox</code></td>
<td>
<p>marginal correlation value</p>
</td></tr>
<tr><td><code id="actfdiscrete_+3A_b">b</code></td>
<td>
<p>1st line parameter</p>
</td></tr>
<tr><td><code id="actfdiscrete_+3A_c">c</code></td>
<td>
<p>2nd line parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
actfdiscrete(.4, .2, 1)

</code></pre>

<hr>
<h2 id='actfdiscreteInv'>Inverse of ACTF auto-correlation transformation function</h2><span id='topic+actfdiscreteInv'></span>

<h3>Description</h3>

<p>Provides inverse transformation for continuous distributions, based on two parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actfdiscreteInv(rhoz, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="actfdiscreteInv_+3A_rhoz">rhoz</code></td>
<td>
<p>marginal correlation value of the parent Gaussian process</p>
</td></tr>
<tr><td><code id="actfdiscreteInv_+3A_b">b</code></td>
<td>
<p>1st line parameter</p>
</td></tr>
<tr><td><code id="actfdiscreteInv_+3A_c">c</code></td>
<td>
<p>2nd line parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
actfdiscreteInv(.4, .2, 1)

</code></pre>

<hr>
<h2 id='actfInv'>Inverse of ACTF auto-correlation transformation function</h2><span id='topic+actfInv'></span>

<h3>Description</h3>

<p>Provides inverse transformation for continuous distributions, based on two parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actfInv(rhoz, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="actfInv_+3A_rhoz">rhoz</code></td>
<td>
<p>marginal correlation value of the parent Gaussian process</p>
</td></tr>
<tr><td><code id="actfInv_+3A_b">b</code></td>
<td>
<p>1st line parameter</p>
</td></tr>
<tr><td><code id="actfInv_+3A_c">c</code></td>
<td>
<p>2nd line parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
actfInv(.4, 1, 0)

</code></pre>

<hr>
<h2 id='acti'>ACTI - autocorrelation transformation integral function</h2><span id='topic+acti'></span>

<h3>Description</h3>

<p>Expression supplied to double integral.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acti(x, y, dist, distarg, rhoz, p0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acti_+3A_x">x</code></td>
<td>
<p>x-plain value</p>
</td></tr>
<tr><td><code id="acti_+3A_y">y</code></td>
<td>
<p>y-plain value</p>
</td></tr>
<tr><td><code id="acti_+3A_dist">dist</code></td>
<td>
<p>distribution</p>
</td></tr>
<tr><td><code id="acti_+3A_distarg">distarg</code></td>
<td>
<p>a list of distribution arguments</p>
</td></tr>
<tr><td><code id="acti_+3A_rhoz">rhoz</code></td>
<td>
<p>Gaussian correlation</p>
</td></tr>
<tr><td><code id="acti_+3A_p0">p0</code></td>
<td>
<p>probability od zero values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
acti(1, -1, 'norm', list(), .3, 0)

</code></pre>

<hr>
<h2 id='actpnts'>AutoCorrelation Transformed Points</h2><span id='topic+actpnts'></span>

<h3>Description</h3>

<p>Transforms a Gaussian process in order to match a target marginal lowers its
autocorrelation values. The actpnts evaluates the corresponding autocorrelations
for the given target marginal for a set of Gaussian correlations, i.e., it returns
(<code class="reqn">\rho_x , \rho_z</code>) points where <code class="reqn">\rho_x</code> and <code class="reqn">\rho_z</code> represent,
respectively, the autocorrelations of the target and Gaussian process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actpnts(margdist, margarg, p0 = 0, distbounds = c(-Inf, Inf))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="actpnts_+3A_margdist">margdist</code></td>
<td>
<p>target marginal distribution</p>
</td></tr>
<tr><td><code id="actpnts_+3A_margarg">margarg</code></td>
<td>
<p>list of marginal distribution arguments</p>
</td></tr>
<tr><td><code id="actpnts_+3A_p0">p0</code></td>
<td>
<p>probability zero</p>
</td></tr>
<tr><td><code id="actpnts_+3A_distbounds">distbounds</code></td>
<td>
<p>distribution bounds (default set to c(-Inf, Inf))</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## here we target to a process that has the Pareto type II
## marginal distribution with scale parameter 1 and shape parameter 0.3
## (note that all parameters have to be named)
dist &lt;- 'paretoII'
distarg &lt;- list(scale = 1, shape = .3)

x &lt;- actpnts(margdist = dist, margarg = distarg, p0 = 0)
x

## you can see the points by using
ggplot(x,
       aes(x = rhox,
           y = rhoz)) +
  geom_point(colour = 'royalblue4', size = 2.5) +
  geom_abline(lty = 5) +
  labs(x = bquote(Autocorrelation ~ rho[x]),
       y = bquote(Gaussian ~ rho[z])) +
  scale_x_continuous(limits = c(0, 1)) +
  scale_y_continuous(limits = c(0, 1)) +
  theme_classic()

</code></pre>

<hr>
<h2 id='advectionF'>Advection fields</h2><span id='topic+advectionF'></span>

<h3>Description</h3>

<p>Provides parametric functions that describe different types of advection fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advectionF(id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="advectionF_+3A_id">id</code></td>
<td>
<p>advection type id (<code>uniform</code>, <code>rotation</code>, <code>spiral</code>, <code>spiralCE</code>, <code>radial</code>, and <code>hyperbolic</code>)</p>
</td></tr>
<tr><td><code id="advectionF_+3A_...">...</code></td>
<td>
<p>other arguments (vector of coordinates and parameters of advection field functions)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggquiver)
library(ggplot2)

## specify coordinates
m = 25
aux &lt;- seq(0, m - 1, length = m)
coord &lt;- expand.grid(aux, aux)

## get the advection field
af &lt;- advectionF('spiral',
                 spacepoints = coord,
                 x0 = floor(m / 2),
                 y0 = floor(m / 2),
                 a = 3,
                 b = 2,
                 rotation = 1)

## visualize advection field
dta &lt;- data.frame(lon = coord[ ,1], lat = coord[ ,2], u = af[ ,1], v = af[ ,2])
ggplot(dta, aes(x = lon, y = lat, u = u, v = v)) +
geom_quiver() +
theme_light()

</code></pre>

<hr>
<h2 id='advectionF2'>Advection fields</h2><span id='topic+advectionF2'></span>

<h3>Description</h3>

<p>Provides parametric functions that describe different types of advection fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advectionF2(id, arglist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="advectionF2_+3A_id">id</code></td>
<td>
<p>advection type id</p>
</td></tr>
<tr><td><code id="advectionF2_+3A_arglist">arglist</code></td>
<td>
<p>list of additional arguments (vector of coordinates and parameters of advection field functions)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>

<hr>
<h2 id='advectionFhyperbolic'>Hyperbolic advection field</h2><span id='topic+advectionFhyperbolic'></span>

<h3>Description</h3>

<p>Provides an advection field with hyperbolic trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advectionFhyperbolic(spacepoints, x0, y0, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="advectionFhyperbolic_+3A_spacepoints">spacepoints</code></td>
<td>
<p>vector of coordinates (2 x d), where d is the number of locations/grid points</p>
</td></tr>
<tr><td><code id="advectionFhyperbolic_+3A_x0">x0</code></td>
<td>
<p>x coordinate of the center of hyperbola</p>
</td></tr>
<tr><td><code id="advectionFhyperbolic_+3A_y0">y0</code></td>
<td>
<p>y coordinate of the center of hyperbola</p>
</td></tr>
<tr><td><code id="advectionFhyperbolic_+3A_a">a</code></td>
<td>
<p>parameter controlling the x component of rotational velocity</p>
</td></tr>
<tr><td><code id="advectionFhyperbolic_+3A_b">b</code></td>
<td>
<p>parameter controlling the y component of rotational velocity</p>
</td></tr>
</table>


<h3>Note</h3>


<ul>
<li><p> if a &gt; 0, b &gt; 0: toward bottom-left and top-right corner
</p>
</li>
<li><p> if a &lt; 0, b &lt; 0: toward top-left and bottom-right corner
</p>
</li></ul>



<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggquiver)
library(ggplot2)
## specify coordinates
m = 25
aux &lt;- seq(0, m - 1, length = m)
coord &lt;- expand.grid(aux, aux)

af &lt;- advectionFhyperbolic(spacepoints = coord,
                           x0 = floor(m / 2),
                           y0 = floor(m / 2),
                           a = 3,
                           b = 2)

## visualize advection field
dta &lt;- data.frame(lon = coord[ ,1], lat = coord[ ,2], u = af[ ,1], v = af[ ,2])
ggplot(dta, aes(x = lon, y = lat, u = u, v = v)) +
geom_quiver() +
theme_light()
</code></pre>

<hr>
<h2 id='advectionFradial'>Radial advection field</h2><span id='topic+advectionFradial'></span>

<h3>Description</h3>

<p>Provides an advection field corresponding to radial motion from or towards a specified reference point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advectionFradial(spacepoints, x0, y0, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="advectionFradial_+3A_spacepoints">spacepoints</code></td>
<td>
<p>vector of coordinates (2 x d), where d is the number of locations/grid points</p>
</td></tr>
<tr><td><code id="advectionFradial_+3A_x0">x0</code></td>
<td>
<p>x coordinate of the center of radial motion</p>
</td></tr>
<tr><td><code id="advectionFradial_+3A_y0">y0</code></td>
<td>
<p>y coordinate of the center of radial motion</p>
</td></tr>
<tr><td><code id="advectionFradial_+3A_a">a</code></td>
<td>
<p>parameter controlling the x component of radial velocity</p>
</td></tr>
<tr><td><code id="advectionFradial_+3A_b">b</code></td>
<td>
<p>parameter controlling the y component of radial velocity</p>
</td></tr>
</table>


<h3>Note</h3>


<ul>
<li><p> if a &gt; 0, b &gt; 0: divergence from (x0, y0) (source point effect)
</p>
</li>
<li><p> if a &lt; 0, b &lt; 0: convergence to (x0, y0) (sink effect)
</p>
</li></ul>



<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggquiver)
library(ggplot2)

## specify coordinates
m = 25
aux &lt;- seq(0, m - 1, length = m)
coord &lt;- expand.grid(aux, aux)

af &lt;- advectionFradial(spacepoints = coord,
                        x0 = floor(m / 2),
                        y0 = floor(m / 2),
                        a = 3,
                        b = 2)

## visualize advection field
dta &lt;- data.frame(lon = coord[ ,1], lat = coord[ ,2], u = af[ ,1], v = af[ ,2])
ggplot(dta, aes(x = lon, y = lat, u = u, v = v)) +
geom_quiver() +
theme_light()
</code></pre>

<hr>
<h2 id='advectionFrotation'>Rotational advection field</h2><span id='topic+advectionFrotation'></span>

<h3>Description</h3>

<p>Provides an advection field corresponding to rotation around a specified center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advectionFrotation(spacepoints, x0, y0, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="advectionFrotation_+3A_spacepoints">spacepoints</code></td>
<td>
<p>vector of coordinates (2 x d), where d is the number of locations/grid points</p>
</td></tr>
<tr><td><code id="advectionFrotation_+3A_x0">x0</code></td>
<td>
<p>x coordinate of the center of rotation</p>
</td></tr>
<tr><td><code id="advectionFrotation_+3A_y0">y0</code></td>
<td>
<p>y coordinate of the center of rotation</p>
</td></tr>
<tr><td><code id="advectionFrotation_+3A_a">a</code></td>
<td>
<p>parameter controlling the x component of rotational velocity</p>
</td></tr>
<tr><td><code id="advectionFrotation_+3A_b">b</code></td>
<td>
<p>parameter controlling the y component of rotational velocity</p>
</td></tr>
</table>


<h3>Note</h3>


<ul>
<li><p> if a &gt; 0, b &gt; 0: clockwise rotation around (x0, y0)
</p>
</li>
<li><p> if a &lt; 0, b &lt; 0: counter-clockwise rotation around (x0, y0)
</p>
</li></ul>



<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggquiver)
library(ggplot2)
## specify coordinates
m = 25
aux &lt;- seq(0, m - 1, length = m)
coord &lt;- expand.grid(aux, aux)

af &lt;- advectionFrotation(spacepoints = coord,
                        x0 = floor(m / 2),
                        y0 = floor(m / 2),
                        a = 3,
                        b = 2)

## visualize advection field
dta &lt;- data.frame(lon = coord[ ,1], lat = coord[ ,2], u = af[ ,1], v = af[ ,2])
ggplot(dta, aes(x = lon, y = lat, u = u, v = v)) +
geom_quiver() +
theme_light()
</code></pre>

<hr>
<h2 id='advectionFspiral'>Spiraling advection field</h2><span id='topic+advectionFspiral'></span>

<h3>Description</h3>

<p>Provides an advection field corresponding to a spiral motion to/from a specified reference point (sink).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advectionFspiral(spacepoints, x0, y0, a, b, rotation = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="advectionFspiral_+3A_spacepoints">spacepoints</code></td>
<td>
<p>vector of coordinates (2 x d), where d is the number of locations/grid points</p>
</td></tr>
<tr><td><code id="advectionFspiral_+3A_x0">x0</code></td>
<td>
<p>x coordinate of reference point (sink)</p>
</td></tr>
<tr><td><code id="advectionFspiral_+3A_y0">y0</code></td>
<td>
<p>y coordinate of reference point (sink)</p>
</td></tr>
<tr><td><code id="advectionFspiral_+3A_a">a</code></td>
<td>
<p>parameter controlling the x component of rotational velocity</p>
</td></tr>
<tr><td><code id="advectionFspiral_+3A_b">b</code></td>
<td>
<p>parameter controlling the y component of rotational velocity</p>
</td></tr>
<tr><td><code id="advectionFspiral_+3A_rotation">rotation</code></td>
<td>
<p>parameter controlling the rotational direction. The following combinations hold: <br />
</p>

<ul>
<li><p> if a &gt; 0, b &gt; 0, and direction = 1: spiraling CLOCKWISE TO (x0, y0)
</p>
</li>
<li><p> if a &lt; 0, b &lt; 0, and direction = 1: spiraling COUNTER-CLOCKWISE FROM (x0, y0)
</p>
</li>
<li><p> if a &gt; 0, b &gt; 0, and direction = 2: spiraling COUNTER-CLOCKWISE TO (x0, y0)
</p>
</li>
<li><p> if a &lt; 0, b &lt; 0, and direction = 2: spiraling CLOCKWISE FROM (x0, y0)
</p>
</li></ul>
</td></tr>
</table>


<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggquiver)
library(ggplot2)
## specify coordinates
m = 25
aux &lt;- seq(0, m - 1, length = m)
coord &lt;- expand.grid(aux, aux)

af &lt;- advectionFspiral(spacepoints = coord,
                        x0 = floor(m / 2),
                        y0 = floor(m / 2),
                        a = 3,
                        b = 2,
                        rotation = 1)

## visualize advection field
dta &lt;- data.frame(lon = coord[ ,1], lat = coord[ ,2], u = af[ ,1], v = af[ ,2])
ggplot(dta, aes(x = lon, y = lat, u = u, v = v)) +
geom_quiver() +
theme_light()
</code></pre>

<hr>
<h2 id='advectionFspiralCE'>Spiraling advection field satisfying continuity equation</h2><span id='topic+advectionFspiralCE'></span>

<h3>Description</h3>

<p>Provides an advection field corresponding to a spiral motion to/from a specified reference point (sink) satisfying continuity equation (from <a href="https://people.sc.fsu.edu/~jburkardt/f77_src/spiral_data/spiral_data.html">John Burkardt's website</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advectionFspiralCE(spacepoints, a, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="advectionFspiralCE_+3A_spacepoints">spacepoints</code></td>
<td>
<p>vector of coordinates (2 x d), where d is the number of locations/grid points</p>
</td></tr>
<tr><td><code id="advectionFspiralCE_+3A_a">a</code></td>
<td>
<p>parameter controlling the intensity of rotational velocity (a &gt; 0 clokwise; a &lt; 0 conter-clockwise)</p>
</td></tr>
<tr><td><code id="advectionFspiralCE_+3A_c">C</code></td>
<td>
<p>parameter ranging in (0, 2*pi)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggquiver)
library(ggplot2)
## specify coordinates
m = 25
aux &lt;- seq(0, m - 1, length = m)
coord &lt;- expand.grid(aux, aux)

af &lt;- advectionFspiralCE(spacepoints = coord,
                        a = 5,
                        C = 1)

## visualize advection field
dta &lt;- data.frame(lon = coord[ ,1], lat = coord[ ,2], u = af[ ,1], v = af[ ,2])
ggplot(dta, aes(x = lon, y = lat, u = u, v = v)) +
geom_quiver() +
theme_light()
</code></pre>

<hr>
<h2 id='advectionFuniform'>Uniform advection field</h2><span id='topic+advectionFuniform'></span>

<h3>Description</h3>

<p>Provides an advection field with constant orthogonal (u and v) components at each grid point. This mimics rigid translation in a given direction according to the components u and v of the velocity vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advectionFuniform(spacepoints, u, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="advectionFuniform_+3A_spacepoints">spacepoints</code></td>
<td>
<p>vector of coordinates (2 x d), where d is the number of locations/grid points</p>
</td></tr>
<tr><td><code id="advectionFuniform_+3A_u">u</code></td>
<td>
<p>velocity component along the x axis</p>
</td></tr>
<tr><td><code id="advectionFuniform_+3A_v">v</code></td>
<td>
<p>velocity component along the y axis</p>
</td></tr>
</table>


<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggquiver)
library(ggplot2)
## specify coordinates
m = 25
aux &lt;- seq(0, m - 1, length = m)
coord &lt;- expand.grid(aux, aux)

af &lt;- advectionFuniform(spacepoints = coord,
                       u = 2,
                       v = 6)

## visualize advection field
dta &lt;- data.frame(lon = coord[ ,1], lat = coord[ ,2], u = af[ ,1], v = af[ ,2])
ggplot(dta, aes(x = lon, y = lat, u = u, v = v)) +
geom_quiver() +
theme_light()

</code></pre>

<hr>
<h2 id='analyzeTS'>The Functions analyzeTS, reportTS, and simulateTS</h2><span id='topic+analyzeTS'></span><span id='topic+reportTS'></span><span id='topic+simulateTS'></span>

<h3>Description</h3>

<p>Provide a complete set of tools to make time series analysis a piece of cake -
<code>analyzeTS</code> automatically performs seasonal analysis, fits distributions
and correlation structures, <code>reportTS</code> provides visualizations of the fitted
distributions and correlation structures, and a table with the values of the fitted
parameters and basic descriptive statistics, <code>simulateTS</code> automatically takes
the results of <code>analyzeTS</code> and generates synthetic ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyzeTS(
  TS,
  season = "month",
  dist = "ggamma",
  acsID = "weibull",
  norm = "N1",
  n.points = 30,
  lag.max = 30,
  constrain = FALSE,
  opts = NULL
)

reportTS(aTS, method = "dist")

simulateTS(aTS, from = NULL, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyzeTS_+3A_ts">TS</code></td>
<td>
<p>time series in format - date, value</p>
</td></tr>
<tr><td><code id="analyzeTS_+3A_season">season</code></td>
<td>
<p>name of the season (e.g. month, week)</p>
</td></tr>
<tr><td><code id="analyzeTS_+3A_dist">dist</code></td>
<td>
<p>name of the distribution to be fitted</p>
</td></tr>
<tr><td><code id="analyzeTS_+3A_acsid">acsID</code></td>
<td>
<p>ID of the autocorrelation structure to be fitted</p>
</td></tr>
<tr><td><code id="analyzeTS_+3A_norm">norm</code></td>
<td>
<p>norm used for distribution fitting - id ('N1', 'N2', 'N3', 'N4')</p>
</td></tr>
<tr><td><code id="analyzeTS_+3A_n.points">n.points</code></td>
<td>
<p>number of points to be subsetted from ecdf</p>
</td></tr>
<tr><td><code id="analyzeTS_+3A_lag.max">lag.max</code></td>
<td>
<p>max lag for the empirical autocorrelation structure</p>
</td></tr>
<tr><td><code id="analyzeTS_+3A_constrain">constrain</code></td>
<td>
<p>logical - constrain shape2 parametes for finite tails</p>
</td></tr>
<tr><td><code id="analyzeTS_+3A_opts">opts</code></td>
<td>
<p>minimization options</p>
</td></tr>
<tr><td><code id="analyzeTS_+3A_ats">aTS</code></td>
<td>
<p>analyzed timeseries</p>
</td></tr>
<tr><td><code id="analyzeTS_+3A_method">method</code></td>
<td>
<p>report method - <code>dist</code> for distribution fits, <code>acs</code> for ACS fits and <code>stat</code> for basic statistical report</p>
</td></tr>
<tr><td><code id="analyzeTS_+3A_from">from</code></td>
<td>
<p>starting date/time of the simulation</p>
</td></tr>
<tr><td><code id="analyzeTS_+3A_to">to</code></td>
<td>
<p>end date/time of the simulation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In practice, we usually want to simulate a natural process using some sampled time series.
To generate a synthetic time series with similar characteristics to the observed values,
we have to determine marginal distribution, autocorrelation structure and probability zero
for each individual month. This can is done by fitting distributions and autocorrelation
structures with <code>analyzeTS</code>. Result can be checked with <code>reportTS</code>.
Syynthetic time series with the same statistical properties can be produced with
<code>simulateTS</code>.
</p>
<p>Recomended distributions for variables:
</p>

<ul>
<li> <p><em>precipitation</em>: ggamma (Generalized Gamma), burr### (Burr type)
</p>
</li>
<li> <p><em>streamflow</em>: ggamma (Generalized Gamma), burr### (Burr type)
</p>
</li>
<li> <p><em>relative humidity</em>: beta
</p>
</li>
<li> <p><em>temperature</em>: norm (Normal distribution)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## Load data included in the package
## (to find out more about the data use ?precip)
data('precip')

## Fit seasonal ACSs and distributions to the data
a &lt;- analyzeTS(precip)

reportTS(a, 'dist') ## show seasonal distribution fit
reportTS(a, 'acs') ## show seasonal ACS fit
reportTS(a, 'stat') ## display basic descriptive statisctics

######################################
## 'duplicate' analyzed time series ##
sim &lt;- simulateTS(a)

## plot the result
precip[, id := 'observed']
sim[, id := 'simulated']

dta &lt;- rbind(precip, sim)

ggplot(dta) +
  geom_line(aes(x = date, y = value)) +
  facet_wrap(~id, ncol = 1) +
  theme_classic()

################################################
## or simulate timeseries of different length ##
sim &lt;- simulateTS(a,
                  from = as.POSIXct('1978-12-01 00:00:00'),
                  to = as.POSIXct('2008-12-01 00:00:00'))

## and plot the result
precip[, id := 'observed']
sim[, id := 'simulated']

dta &lt;- rbind(precip, sim)

ggplot(dta) +
  geom_line(aes(x = date, y = value)) +
  facet_wrap(~id, ncol = 1) +
  theme_classic()



</code></pre>

<hr>
<h2 id='anisotropyT'>Anisotropy transformation</h2><span id='topic+anisotropyT'></span>

<h3>Description</h3>

<p>Provides parametric functions that describe different types of planar deformation fields, including affine (rotation and stretching), and swirl-like deformation. For more details see Papalexiou et al.(2021) and references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anisotropyT(id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anisotropyT_+3A_id">id</code></td>
<td>
<p>anisotropy type id (<code>affine</code>, <code>swirl</code>, and <code>wave</code>)</p>
</td></tr>
<tr><td><code id="anisotropyT_+3A_...">...</code></td>
<td>
<p>additional arguments (vector of coordinates and parameters of the anisotropy transformations)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Papalexiou, S. M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond,
Water Resources Research, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## specify coordinates
m = 25
aux &lt;- seq(0, m - 1, length = m)
coord &lt;- expand.grid(aux, aux)

## get the anisotropy field
at1 &lt;- anisotropyT('affine',
                 spacepoints = coord,
                 phi1 = 0.5,
                 phi2 = 2,
                 phi12 = 0,
                 theta = -pi/3)
at2 &lt;- anisotropyT('swirl',
                 spacepoints = coord,
                 x0 = floor(m / 2),
                 y0 = floor(m / 2),
                 b = 10,
                 alpha = 1.5 * pi)
at3 &lt;- anisotropyT('wave',
                 spacepoints = coord,
                 phi1 = 0.5,
                 phi2 = 2,
                 beta = 3,
                 theta = 0)

## visualize anisotropy field
aux = data.frame(lon = at2[ ,1], lat = at2[ ,2], id1 = rep(1:m, each = m), id2 = rep(1:m, m))
ggplot(aux, aes(x = lon, y = lat)) +
geom_path(aes(group = id1)) +
geom_path(aes(group = id2)) +
geom_point(col = 2) +
theme_light()

</code></pre>

<hr>
<h2 id='anisotropyT2'>Anisotropy transformation</h2><span id='topic+anisotropyT2'></span>

<h3>Description</h3>

<p>Provides parametric functions that describe different types of planar deformation fields, including affine (rotation and stretching), and swirl-like deformation. For more details see Papalexiou et al.(2021) and references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anisotropyT2(id, arglist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anisotropyT2_+3A_id">id</code></td>
<td>
<p>anisotropy type id</p>
</td></tr>
<tr><td><code id="anisotropyT2_+3A_arglist">arglist</code></td>
<td>
<p>list of additional arguments (vector of coordinates and parameters of the anisotropy transformations)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>

<hr>
<h2 id='anisotropyTaffine'>Affine anisotropy transformation</h2><span id='topic+anisotropyTaffine'></span>

<h3>Description</h3>

<p>Affine anisotropy transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anisotropyTaffine(spacepoints, phi1, phi2, phi12, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anisotropyTaffine_+3A_spacepoints">spacepoints</code></td>
<td>
<p>vector of coordinates (2 x d), where d is the number of locations/grid points</p>
</td></tr>
<tr><td><code id="anisotropyTaffine_+3A_phi1">phi1</code></td>
<td>
<p>stretching parameter along the x axis</p>
</td></tr>
<tr><td><code id="anisotropyTaffine_+3A_phi2">phi2</code></td>
<td>
<p>stretching parameter along the y axis</p>
</td></tr>
<tr><td><code id="anisotropyTaffine_+3A_phi12">phi12</code></td>
<td>
<p>shear effect</p>
</td></tr>
<tr><td><code id="anisotropyTaffine_+3A_theta">theta</code></td>
<td>
<p>rotation angle</p>
</td></tr>
</table>


<h3>References</h3>

<p>Allard, D., Senoussi, R., Porcu, E. (2016). Anisotropy Models for
Spatial Data. Mathematical Geosciences, 48(3), 305-328, doi: <a href="https://doi.org/10.1007/s11004-015-9594-x">10.1007/s11004-015-9594-x</a>
</p>
<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## specify coordinates
m = 25
aux &lt;- seq(0, m - 1, length = m)
coord &lt;- expand.grid(aux, aux)

at &lt;- anisotropyTaffine(spacepoints = coord,
                       phi1 = 0.5,
                       phi2 = 2,
                       phi12 = 0,
                       theta = -pi/3)

## visualize transformed coordinate system
aux = data.frame(lon = at[ ,1], lat = at[ ,2], id1 = rep(1:m, each = m), id2 = rep(1:m, m))
ggplot(aux, aes(x = lon, y = lat)) +
geom_path(aes(group = id1)) +
geom_path(aes(group = id2)) +
geom_point(col = 2) +
theme_light()

</code></pre>

<hr>
<h2 id='anisotropyTswirl'>Swirl anisotropy transformation</h2><span id='topic+anisotropyTswirl'></span>

<h3>Description</h3>

<p>Swirl anisotropy transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anisotropyTswirl(spacepoints, x0, y0, b, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anisotropyTswirl_+3A_spacepoints">spacepoints</code></td>
<td>
<p>vector of coordinates (2 x d), where d is the number of locations/grid points</p>
</td></tr>
<tr><td><code id="anisotropyTswirl_+3A_x0">x0</code></td>
<td>
<p>x coordinate of the center of the swirl deformation</p>
</td></tr>
<tr><td><code id="anisotropyTswirl_+3A_y0">y0</code></td>
<td>
<p>y coordinate of the center of the swirl deformation</p>
</td></tr>
<tr><td><code id="anisotropyTswirl_+3A_b">b</code></td>
<td>
<p>scaling parameter controlling the swirl deformation</p>
</td></tr>
<tr><td><code id="anisotropyTswirl_+3A_alpha">alpha</code></td>
<td>
<p>rotation angle</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ligas, M., Banas, M., Szafarczyk, A. (2019). A method for local
approximation of a planar deformation field. Reports on Geodesy and
Geoinformatics, 108(1), 1-8, doi: <a href="https://doi.org/10.2478/rgg-2019-0007">10.2478/rgg-2019-0007</a>
</p>
<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## specify coordinates
m = 25
aux &lt;- seq(0, m - 1, length = m)
coord &lt;- expand.grid(aux, aux)

at &lt;- anisotropyTswirl(spacepoints = coord,
                      x0 = floor(m / 2),
                      y0 = floor(m / 2),
                      b = 10,
                      alpha = 1.5 * pi)

## visualize transformed coordinate system
aux = data.frame(lon = at[ ,1], lat = at[ ,2], id1 = rep(1:m, each = m), id2 = rep(1:m, m))
ggplot(aux, aes(x = lon, y = lat)) +
geom_path(aes(group = id1)) +
geom_path(aes(group = id2)) +
geom_point(col = 2) +
theme_light()
</code></pre>

<hr>
<h2 id='anisotropyTwave'>Wave anisotropy transformation</h2><span id='topic+anisotropyTwave'></span>

<h3>Description</h3>

<p>Wave anisotropy transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anisotropyTwave(spacepoints, phi1, phi2, beta, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anisotropyTwave_+3A_spacepoints">spacepoints</code></td>
<td>
<p>vector of coordinates (2 x d), where d is the number of locations/grid points</p>
</td></tr>
<tr><td><code id="anisotropyTwave_+3A_phi1">phi1</code></td>
<td>
<p>stretching parameter along the x axis</p>
</td></tr>
<tr><td><code id="anisotropyTwave_+3A_phi2">phi2</code></td>
<td>
<p>stretching parameter along the y axis</p>
</td></tr>
<tr><td><code id="anisotropyTwave_+3A_beta">beta</code></td>
<td>
<p>amplitude of sinusoidal wave</p>
</td></tr>
<tr><td><code id="anisotropyTwave_+3A_theta">theta</code></td>
<td>
<p>rotation angle</p>
</td></tr>
</table>


<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## specify coordinates
m = 25
aux &lt;- seq(0, m - 1, length = m)
coord &lt;- expand.grid(aux, aux)

at &lt;- anisotropyTwave(spacepoints = coord,
                     phi1 = 0.5,
                     phi2 = 2,
                     beta = 3,
                     theta = 0)

## visualize transformed coordinate system
aux = data.frame(lon = at[ ,1], lat = at[ ,2], id1 = rep(1:m, each = m), id2 = rep(1:m, m))
ggplot(aux, aes(x = lon, y = lat)) +
geom_path(aes(group = id1)) +
geom_path(aes(group = id2)) +
geom_point(col = 2) +
theme_light()

</code></pre>

<hr>
<h2 id='AR1'>Autoregressive model of first order</h2><span id='topic+AR1'></span>

<h3>Description</h3>

<p>Generates time series from an AR1 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AR1(n, alpha, mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AR1_+3A_n">n</code></td>
<td>
<p>number of values</p>
</td></tr>
<tr><td><code id="AR1_+3A_alpha">alpha</code></td>
<td>
<p>lag-1 autocorrelation</p>
</td></tr>
<tr><td><code id="AR1_+3A_mean">mean</code></td>
<td>
<p>mean</p>
</td></tr>
<tr><td><code id="AR1_+3A_sd">sd</code></td>
<td>
<p>standard deviation</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## generate 500 values from an AR1 having lag-1 autocorrelation 0.8,
## mean value equal to 0, and standard deviation equal to 1.
n &lt;- 500

## generate white noise for comparsion
x &lt;- rnorm(n)
ggplot() +
 geom_line(aes(x = 1:n,
               y = x)) +
   labs(x = '',
        y = 'value') +
   theme_classic()

## generete values using AR1
y &lt;- AR1(n, .8)
ggplot() +
  geom_line(aes(x = 1:n,
                y = y)) +
  labs(x = '',
       y = 'value') +
  theme_classic()

</code></pre>

<hr>
<h2 id='ARp'>Autoregressive model of order <em>p</em></h2><span id='topic+ARp'></span>

<h3>Description</h3>

<p>Generates time series from an Autoregressive model of order <em>p</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARp(margdist, margarg, acsvalue, actfpara, n, p = NULL, p0 = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARp_+3A_margdist">margdist</code></td>
<td>
<p>target marginal distribution</p>
</td></tr>
<tr><td><code id="ARp_+3A_margarg">margarg</code></td>
<td>
<p>list of marginal distribution arguments</p>
</td></tr>
<tr><td><code id="ARp_+3A_acsvalue">acsvalue</code></td>
<td>
<p>target auto-correlation structure (from lag 0)</p>
</td></tr>
<tr><td><code id="ARp_+3A_actfpara">actfpara</code></td>
<td>
<p>auto-correlation structure transformation parameters</p>
</td></tr>
<tr><td><code id="ARp_+3A_n">n</code></td>
<td>
<p>number of values</p>
</td></tr>
<tr><td><code id="ARp_+3A_p">p</code></td>
<td>
<p>integer - model order (if NULL - limits maximum model order according to auto-correlation structure values)</p>
</td></tr>
<tr><td><code id="ARp_+3A_p0">p0</code></td>
<td>
<p>probability zero</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## choose the marginal distribution as Pareto type II with corresponding parameters
dist &lt;- 'paretoII'
distarg &lt;- list(scale = 1, shape = .3)
p0 &lt;- .5

## estimate rho 'x' and 'z' points using ACTI
pnts &lt;- actpnts(margdist = dist, margarg = distarg, p0 = p0)

## fit ACTF
fit &lt;- fitactf(pnts)

## define target auto-correlation structure and model order
order &lt;- 1000
acsvalue &lt;- acs(id = 'weibull', t = 0:order, scale = 10, shape = .75)

## limit ACS lag (recomended)
system.time(val &lt;- ARp(margdist = dist,
                       margarg = distarg,
                       acsvalue = acsvalue,
                       actfpara = fit,
                       n = 5000,
                       p0 = p0))

## order w/o limit
system.time(val &lt;- ARp(margdist = dist,
                       margarg = distarg,
                       acsvalue = acsvalue,
                       actfpara = fit,
                       n = 5000,
                       p = order,
                       p0 = p0))


## see the result
ggplot() +
  geom_col(aes(x = seq_along(val),
               y = val)) +
  labs(x = '',
       y = 'value') +
  theme_classic()

</code></pre>

<hr>
<h2 id='BurrIII'>Burr Type III distribution</h2><span id='topic+BurrIII'></span><span id='topic+dburrIII'></span><span id='topic+pburrIII'></span><span id='topic+qburrIII'></span><span id='topic+rburrIII'></span><span id='topic+mburrIII'></span>

<h3>Description</h3>

<p>Provides density, distribution function, quantile function, random value generation,
and raw moments of order <em>r</em> for the Burr Type III distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dburrIII(x, scale, shape1, shape2, log = FALSE)

pburrIII(q, scale, shape1, shape2, lower.tail = TRUE, log.p = FALSE)

qburrIII(p, scale, shape1, shape2, lower.tail = TRUE, log.p = FALSE)

rburrIII(n, scale, shape1, shape2)

mburrIII(r, scale, shape1, shape2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BurrIII_+3A_x">x</code>, <code id="BurrIII_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="BurrIII_+3A_scale">scale</code>, <code id="BurrIII_+3A_shape1">shape1</code>, <code id="BurrIII_+3A_shape2">shape2</code></td>
<td>
<p>scale and shape parameters; the shape arguments cannot be a vectors (must have length one).</p>
</td></tr>
<tr><td><code id="BurrIII_+3A_log">log</code>, <code id="BurrIII_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="BurrIII_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="BurrIII_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="BurrIII_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="BurrIII_+3A_r">r</code></td>
<td>
<p>raw moment order</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## plot the density

ggplot(data.frame(x = c(1, 15)),
       aes(x)) +
  stat_function(fun = dburrIII,
                args = list(scale = 5,
                            shape1 = .25,
                            shape2 = .75),
                colour = 'royalblue4') +
  labs(x = '',
       y = 'Density') +
  theme_classic()
</code></pre>

<hr>
<h2 id='BurrXII'>Burr Type XII distribution</h2><span id='topic+BurrXII'></span><span id='topic+dburrXII'></span><span id='topic+pburrXII'></span><span id='topic+qburrXII'></span><span id='topic+rburrXII'></span><span id='topic+mburrXII'></span>

<h3>Description</h3>

<p>Provides density, distribution function, quantile function, random value generation,
and raw moments of order <em>r</em> for the Burr Type XII distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dburrXII(x, scale, shape1, shape2, log = FALSE)

pburrXII(q, scale, shape1, shape2, lower.tail = TRUE, log.p = FALSE)

qburrXII(p, scale, shape1, shape2, lower.tail = TRUE, log.p = FALSE)

rburrXII(n, scale, shape1, shape2)

mburrXII(r, scale, shape1, shape2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BurrXII_+3A_x">x</code>, <code id="BurrXII_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="BurrXII_+3A_scale">scale</code>, <code id="BurrXII_+3A_shape1">shape1</code>, <code id="BurrXII_+3A_shape2">shape2</code></td>
<td>
<p>scale and shape parameters; the shape arguments cannot be a vector (must have length one).</p>
</td></tr>
<tr><td><code id="BurrXII_+3A_log">log</code>, <code id="BurrXII_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="BurrXII_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="BurrXII_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="BurrXII_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="BurrXII_+3A_r">r</code></td>
<td>
<p>raw moment order</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## plot the density

ggplot(data.frame(x = c(0, 10)),
       aes(x)) +
  stat_function(fun = dburrXII,
                args = list(scale = 5,
                            shape1 = .25,
                            shape2 = .75),
                colour = 'royalblue4') +
  labs(x = '',
       y = 'Density') +
  theme_classic()

</code></pre>

<hr>
<h2 id='checkRF'>Numerical and visual check of generated random fields</h2><span id='topic+checkRF'></span>

<h3>Description</h3>

<p>Compares generated random fields sample statistics with the theoretically
expected values (similar to <code><a href="#topic+checkTS">checkTS</a></code>). It also returns graphical output for
visual check.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkRF(RF, lags = 30, nfields = 49, method = "stat")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkRF_+3A_rf">RF</code></td>
<td>
<p>output of <code><a href="#topic+generateRF">generateRF</a></code></p>
</td></tr>
<tr><td><code id="checkRF_+3A_lags">lags</code></td>
<td>
<p>number of lags of empirical STCF to be considered in the
graphical output (default set to 30)</p>
</td></tr>
<tr><td><code id="checkRF_+3A_nfields">nfields</code></td>
<td>
<p>number of fields to be used in the numerical and graphical
output (default set to 49). As the plots are arranged in a matrix with nrows as close as possible to ncol, we suggest using values such as 3x3, 3x4, 7x8, etc.</p>
</td></tr>
<tr><td><code id="checkRF_+3A_method">method</code></td>
<td>
<p>report method - <code>'stat'</code> for basic statistical report,
<code>'statplot'</code> for graphical check of lagged SCS, target STCS, and marginal
distribution, <code>'field'</code> for plotting a matrix of the first <code>nfields</code>,
and <code>'movie'</code> to save the first <code>nfields</code> as a GIF file named &quot;movieRF.gif&quot;
in the current working directory</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## The example below refers to the fitting and simulation of 10 random fields
## of size 10x10 with AR(1) temporal correlation. As the fitting algorithm has
## O((mxm)^3) complexity for a mxm field, this setting allows for quick fitting
## and simulation (short CPU time). However, for a more effective visualization
## and reliable performance assessment, we suggest to generate a larger number
## of fields (e.g. 100 or more) of size about 30X30. This setting needs more
## CPU time but enables more effective comparison of theoretical and
## empirical statistics. Sizes larger than about 50x50 can be unpractical
##  on standard machines.

fit &lt;- fitVAR(
  spacepoints = 10,
  p = 1,
  margdist ='burrXII',
  margarg = list(scale = 3, shape1 = .9, shape2 = .2),
  p0 = 0.8,
  stcsid = "clayton",
  stcsarg = list(scfid = "weibull", tcfid = "weibull",
                 copulaarg = 2,
                 scfarg = list(scale = 20, shape = 0.7),
                tcfarg = list(scale = 1.1, shape = 0.8))
)

sim &lt;- generateRF(n = 12,
                    STmodel = fit)
checkRF(RF = sim,
          lags = 10,
          nfields = 12)


</code></pre>

<hr>
<h2 id='checkTS'>Check generated timeseries</h2><span id='topic+checkTS'></span>

<h3>Description</h3>

<p>Compares generated time series sample statistics with the theoretically expected values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkTS(TS, distbounds = c(-Inf, Inf))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkTS_+3A_ts">TS</code></td>
<td>
<p>generated timeseries</p>
</td></tr>
<tr><td><code id="checkTS_+3A_distbounds">distbounds</code></td>
<td>
<p>distribution bounds (default set to c(-Inf, Inf))</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## check your generated timeseries
x &lt;- generateTS(margdist = 'burrXII',
                margarg = list(scale = 1,
                               shape1 = .75,
                               shape2 = .25),
                acsvalue = acs(id = 'weibull',
                               t = 0:30,
                               scale = 10,
                               shape = .75),
                n = 1000, p = 30, p0 = .5, TSn = 5)

checkTS(x)

</code></pre>

<hr>
<h2 id='CoSMoS-package'>CoSMoS: Complete Stochastic Modelling Solution</h2><span id='topic+CoSMoS-package'></span>

<h3>Description</h3>

<p>CoSMoS is an R package that makes time series generation with desired properties easy. Just choose the characteristics of the time series you want to generate, and it will do the rest.
</p>


<h3>Details</h3>

<p>The generated time series preserve any probability distribution and any linear autocorrelation structure. Users can generate as many and as long time series from processes such as precipitation, wind, temperature, relative humidity etc. It is based on a framework that unified, extended, and improved a modelling strategy that generates time series by transforming &quot;parent&quot; Gaussian time series having specific characteristics (Papalexiou, 2018).
</p>


<h3>Funding</h3>

<p>The package was partly funded by the Global institute for Water Security (GIWS; <a href="https://water.usask.ca/">https://water.usask.ca/</a>) and the Global Water Futures (GWF; <a href="https://gwf.usask.ca/">https://gwf.usask.ca/</a>) program.
</p>


<h3>Author(s)</h3>

<p><strong>Coded by:</strong> Filip Strnad <a href="mailto:strnadf@fzp.czu.cz">strnadf@fzp.czu.cz</a> and Francesco Serinaldi <a href="mailto:francesco.serinaldi@ncl.ac.uk">francesco.serinaldi@ncl.ac.uk</a>
</p>
<p><strong>Conceptual design by:</strong> Simon Michael Papalexiou <a href="mailto:sm.papalexiou@usask.ca">sm.papalexiou@usask.ca</a>
</p>
<p><strong>Tested and documented by:</strong> Yannis Markonis <a href="mailto:markonis@fzp.czu.cz">markonis@fzp.czu.cz</a>
</p>
<p><strong>Maintained by:</strong> Kevin Shook <a href="mailto:kevin.shook@usask.ca">kevin.shook@usask.ca</a>
</p>


<h3>References</h3>

<p>Papalexiou, S.M. (2018). Unified theory for stochastic modelling of hydroclimatic processes: Preserving marginal distributions, correlation structures, and intermittency. Advances in Water Resources 115, 234-252, doi: <a href="https://doi.org/10.1016/j.advwatres.2018.02.013">10.1016/j.advwatres.2018.02.013</a>
</p>
<p>Papalexiou, S.M., Markonis, Y., Lombardo, F., AghaKouchak, A., Foufoula-Georgiou, E. (2018). Precise Temporal Disaggregation Preserving Marginals and Correlations (DiPMaC) for Stationary and Nonstationary Processes. Water Resources Research, 54(10), 7435-7458, doi: <a href="https://doi.org/10.1029/2018WR022726">10.1029/2018WR022726</a>
</p>
<p>Papalexiou, S.M., Serinaldi, F. (2020). Random Fields Simplified: Preserving Marginal Distributions, Correlations, and Intermittency, With Applications From Rainfall to Humidity. Water Resources Research, 56(2), e2019WR026331, doi: <a href="https://doi.org/10.1029/2019WR026331">10.1029/2019WR026331</a>
</p>
<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond. Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>

<hr>
<h2 id='disch'>Daily streamflow data data</h2><span id='topic+disch'></span>

<h3>Description</h3>

<p>Station details
</p>

<ul>
<li><p> Name: Nassawango Creek near Snow Hill, Worcester County, Maryland, Hydrologic Unit 02080111
</p>
</li>
<li><p> Network Id: , USGS 01485500
</p>
</li>
<li><p> Latitude/Longitude: 38Â°13'44.1&quot;, 75Â°28'17.2&quot;
</p>
</li>
<li><p> Elevation: 11.49 ft above North American Vertical Datum of 1988.
</p>
</li>
<li><p> Measurement unit: cubic feet per second
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>disch
</code></pre>


<h3>Format</h3>

<p>A data.table with 23315 rows and 2 variables:
</p>

<dl>
<dt>date</dt><dd><p>POSIXct format date/time</p>
</dd>
<dt>value</dt><dd><p>daily avarage values</p>
</dd>
</dl>



<h3>Details</h3>

<p>more details can be found <a href="https://waterdata.usgs.gov/nwis/dv?referred_module=sw&amp;site_no=01485500">here</a>.
</p>


<h3>Source</h3>

<p>The United States Geological Survey (USGS) National Water Information System (NWIS)
</p>

<hr>
<h2 id='ECDF'>Empirical cummulative distrubution function</h2><span id='topic+ECDF'></span>

<h3>Description</h3>

<p>Calculates ecdf based on weibull plotting position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ECDF(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ECDF_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
ECDF(round(rnorm(100)))

</code></pre>

<hr>
<h2 id='erfc'>Complementary (inverse) error function</h2><span id='topic+erfc'></span><span id='topic+inv.erfc'></span>

<h3>Description</h3>

<p>Complementary (inverse) error function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erfc(x)

inv.erfc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erfc_+3A_x">x</code></td>
<td>
<p>number vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
erfc(1)
inv.erfc(1)

</code></pre>

<hr>
<h2 id='fitACS'>Autocorrelation structure fit</h2><span id='topic+fitACS'></span><span id='topic+optimACS'></span>

<h3>Description</h3>

<p>Autocorrelation structure fit
</p>
<p>Auxiliary function passed to fitACS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitACS(acf, ID, start = NULL, lag = NULL)

optimACS(par, id, eACS, error = "MSE")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitACS_+3A_acf">acf</code></td>
<td>
<p>vector of autocorrelation function values from lag 0</p>
</td></tr>
<tr><td><code id="fitACS_+3A_id">ID</code></td>
<td>
<p>ACS id</p>
</td></tr>
<tr><td><code id="fitACS_+3A_start">start</code></td>
<td>
<p>starting parameter value</p>
</td></tr>
<tr><td><code id="fitACS_+3A_lag">lag</code></td>
<td>
<p>acf lag</p>
</td></tr>
<tr><td><code id="fitACS_+3A_par">par</code></td>
<td>
<p>parameter value</p>
</td></tr>
<tr><td><code id="fitACS_+3A_id">id</code></td>
<td>
<p>ACS id</p>
</td></tr>
<tr><td><code id="fitACS_+3A_eacs">eACS</code></td>
<td>
<p>empirical ACS</p>
</td></tr>
<tr><td><code id="fitACS_+3A_error">error</code></td>
<td>
<p>which error to minimize</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- AR1(1000, .8)

acsfit &lt;- fitACS(acf(x, plot = FALSE)$acf, 'weibull', c(1, 1))

</code></pre>

<hr>
<h2 id='fitactf'>Fit the AutoCorrelation Transformation Function</h2><span id='topic+fitactf'></span>

<h3>Description</h3>

<p>Fits the ACTF (Autocorrelation Transformation Function) to the estimated points (<code class="reqn">\rho_x, \rho_z</code>) using <code>nls</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitactf(actpnts, discrete = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitactf_+3A_actpnts">actpnts</code></td>
<td>
<p>estimated ACT points</p>
</td></tr>
<tr><td><code id="fitactf_+3A_discrete">discrete</code></td>
<td>
<p>logical - is the marginal distribution discrete?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## choose the marginal distribution as Pareto type II
## with corresponding parameters
dist &lt;- 'paretoII'
distarg &lt;- list(scale = 1, shape = .3)

## estimate rho 'x' and 'z' points using ACTI
p &lt;- actpnts(margdist = dist, margarg = distarg, p0 = 0)

## fit ACTF
fit &lt;- fitactf(p)

## plot the result
plot(fit)

</code></pre>

<hr>
<h2 id='fitDist'>Distribution fitting</h2><span id='topic+fitDist'></span>

<h3>Description</h3>

<p>Uses Nelder-Mead simplex algorithm to minimize fitting norms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitDist(
  data,
  dist,
  n.points,
  norm,
  constrain,
  opts = list(algorithm = "NLOPT_LN_NELDERMEAD", xtol_rel = 1e-08, maxeval = 10000)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitDist_+3A_data">data</code></td>
<td>
<p>value to be fitted</p>
</td></tr>
<tr><td><code id="fitDist_+3A_dist">dist</code></td>
<td>
<p>name of the distribution to be fitted</p>
</td></tr>
<tr><td><code id="fitDist_+3A_n.points">n.points</code></td>
<td>
<p>number of points to be subsetted from ecdf</p>
</td></tr>
<tr><td><code id="fitDist_+3A_norm">norm</code></td>
<td>
<p>norm used for distribution fitting - id ('N1', 'N2', 'N3', 'N4')</p>
</td></tr>
<tr><td><code id="fitDist_+3A_constrain">constrain</code></td>
<td>
<p>logical - constrain shape2 parametes for finite tails</p>
</td></tr>
<tr><td><code id="fitDist_+3A_opts">opts</code></td>
<td>
<p>minimization options</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- fitDist(rnorm(1000), 'norm', 30, 'N1', FALSE)
x

</code></pre>

<hr>
<h2 id='fitVAR'>VAR model parameters to simulate correlated parent Gaussian random vectors and fields</h2><span id='topic+fitVAR'></span>

<h3>Description</h3>

<p>Compute VAR model parameters to simulate parent Gaussian random vectors with specified spatiotemporal correlation structure using the method described by Biller and Nelson (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitVAR(
  spacepoints,
  p,
  margdist,
  margarg,
  p0,
  distbounds = c(-Inf, Inf),
  stcsid,
  stcsarg,
  scalefactor = 1,
  anisotropyid = "affine",
  anisotropyarg = list(phi1 = 1, phi2 = 1, phi12 = 0, theta = 0),
  advectionid = "uniform",
  advectionarg = list(u = 0, v = 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitVAR_+3A_spacepoints">spacepoints</code></td>
<td>
<p>it can be a numeric integer, which is interpreted as the side length m of the square field (m x m), or a matrix (d x 2) of coordinates (e.g. longitude and latitude) of d spatial locations (e.g. d gauge stations)</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_p">p</code></td>
<td>
<p>order of VAR(p) model</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_margdist">margdist</code></td>
<td>
<p>target marginal distribution of the field</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_margarg">margarg</code></td>
<td>
<p>list of marginal distribution arguments. Please consult the documentation of the selected marginal distribution indicated in the argument <code>margdist</code> for the list of required parameters</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_p0">p0</code></td>
<td>
<p>probability zero</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_distbounds">distbounds</code></td>
<td>
<p>distribution bounds (default set to <code>c(-Inf, Inf)</code>)</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_stcsid">stcsid</code></td>
<td>
<p>spatiotemporal correlation structure ID</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_stcsarg">stcsarg</code></td>
<td>
<p>list of spatiotemporal correlation structure arguments. Please consult the documentation of the selected spatiotemporal correlation structure indicated in the argument <code>stcsid</code> for the list of required parameters</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_scalefactor">scalefactor</code></td>
<td>
<p>factor specifying the distance between the centers of two pixels (default set to 1)</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_anisotropyid">anisotropyid</code></td>
<td>
<p>spatial anisotropy ID (<code>affine</code> by default, <code>swirl</code> or <code>wave</code>)</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_anisotropyarg">anisotropyarg</code></td>
<td>
<p>list of arguments characterizing the spatial anisotropy according to the syntax of the function <code><a href="#topic+anisotropyT">anisotropyT</a></code>. Isotropic fields by default</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_advectionid">advectionid</code></td>
<td>
<p>advection field ID (<code>uniform</code> by default, <code>rotation</code>, <code>spiral</code>, <code>spiralCE</code>, <code>radial</code>, or <code>hyperbolic</code>)</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_advectionarg">advectionarg</code></td>
<td>
<p>list of arguments characterizing the advection field according to the syntax of the function <code><a href="#topic+advectionF">advectionF</a></code>. No advection by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitting algorithm has <code class="reqn">O(m*m)^3</code> complexity for a <code class="reqn">(m*m)</code> field
or equivalently <code class="reqn">O(d^3)</code> complexity for a <code class="reqn">d</code>-dimensional vector.
Very large values of <code class="reqn">(m*m)</code> (or <code class="reqn">d</code>) and high order AR correlation
structures can be unpractical on standard machines.
</p>
<p>Here, we give indicative CPU times for some settings, referring to a
Windows 10 Pro x64 laptop with Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz,
4-core, 8 logical processors, and 32GB RAM. <br />:
CPU time:<br />
d = 100 or m = 10, p = 1: ~  0.4s <br />
d = 900 or m = 30, p = 1: ~  6.0s <br />
d = 900 or m = 30, p = 5: ~ 47.0s <br />
d = 2500 or m = 50, p = 1: ~100.0s
</p>


<h3>Note</h3>

<p>While all the advection types can be applied to isotropic random fields,
anisotropic random fields require more care. We suggest combining <code>affine</code>
anysotropy with <code>uniform</code> advection, and <code>swirl</code> anisotropy
with <code>rotation</code> or <code>spiral</code> advection with the same rotation center.
</p>


<h3>References</h3>

<p>Biller, B., Nelson, B.L. (2003). Modeling and generating multivariate
time-series input processes using a vector autoregressive technique.
ACM Trans. Model. Comput. Simul. 13(3), 211-237, doi: <a href="https://doi.org/10.1145/937332.937333">10.1145/937332.937333</a>
</p>
<p>Papalexiou, S.M. (2018). Unified theory for stochastic modelling of
hydroclimatic processes: Preserving marginal distributions, correlation structures,
and intermittency. Advances in Water Resources, 115, 234-252,
doi: <a href="https://doi.org/10.1016/j.advwatres.2018.02.013">10.1016/j.advwatres.2018.02.013</a>
</p>
<p>Papalexiou, S.M.,  Serinaldi, F. (2020). Random Fields Simplified:
Preserving Marginal Distributions, Correlations, and Intermittency,
With Applications From Rainfall to Humidity. Water Resources Research, 56(2),
e2019WR026331, doi: <a href="https://doi.org/10.1029/2019WR026331">10.1029/2019WR026331</a>
</p>
<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## for multivariate simulation
coord &lt;- cbind(runif(4)*30, runif(4)*30)

fit &lt;- fitVAR(
  spacepoints = coord,
  p = 1,
  margdist ='burrXII',
  margarg = list(scale = 3,
                 shape1 = .9,
                 shape2 = .2),
  p0 = 0.8,
  stcsid = "clayton",
  stcsarg = list(scfid = "weibull",
                 tcfid = "weibull",
                 copulaarg = 2,
                 scfarg = list(scale = 20,
                               shape = 0.7),
                 tcfarg = list(scale = 1.1,
                               shape = 0.8))
)

dim(fit$alpha)
dim(fit$res.cov)

fit$m
fit$margarg
fit$margdist

## for random fields simulation
fit &lt;- fitVAR(
  spacepoints = 10,
  p = 1,
  margdist ='burrXII',
  margarg = list(scale = 3, shape1 = .9, shape2 = .2),
  p0 = 0.8,
  stcsid = "clayton",
  stcsarg = list(scfid = "weibull", tcfid = "weibull",
                 copulaarg = 2,
                 scfarg = list(scale = 20, shape = 0.7),
                 tcfarg = list(scale = 1.1, shape = 0.8))
)

dim(fit$alpha)
dim(fit$res.cov)

fit$m
fit$margarg
fit$margdist

</code></pre>

<hr>
<h2 id='generateMTS'>Simulation of multiple time series with given marginals and spatiotemporal properties</h2><span id='topic+generateMTS'></span>

<h3>Description</h3>

<p>Generates multiple time series with given marginals and spatiotemporal properties,
just provide (1) the output of <code><a href="#topic+fitVAR">fitVAR</a></code> function, and (2) the number of time
steps to simulate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateMTS(n, STmodel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateMTS_+3A_n">n</code></td>
<td>
<p>number of fields (time steps) to simulate</p>
</td></tr>
<tr><td><code id="generateMTS_+3A_stmodel">STmodel</code></td>
<td>
<p>list of arguments resulting from <code><a href="#topic+fitVAR">fitVAR</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Referring to the documentation of <code><a href="#topic+fitVAR">fitVAR</a></code> for details on
computational complexity of the fitting algorithm, here we report indicative
simulation CPU times for some settings, assuming that the model parameters are
already evaluated.
CPU times refer to a Windows 10 Pro x64 laptop with
Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz, 4-core, 8 logical processors, and 32GB RAM. <br />
CPU time:<br />
d = 900, p = 1, n = 1000: ~17s <br />
d = 900, p = 1, n = 10000: ~75s <br />
d = 900, p = 5, n = 100: ~280s <br />
d = 900, p = 5, n = 1000: ~302s <br />
d = 2500, p = 1, n = 1000 : ~160s <br />
d = 2500, p = 1, n = 10000 : ~570s <br />
where <code class="reqn">d</code> denotes the number of spatial locations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulation of a 4-dimensional vector with VAR(1) correlation structure
coord &lt;- cbind(runif(4)*30, runif(4)*30)

fit &lt;- fitVAR(
  spacepoints = coord,
  p = 1,
  margdist ='burrXII',
  margarg = list(scale = 3,
                 shape1 = .9,
                 shape2 = .2),
  p0 = 0.8,
  stcsid = "clayton",
  stcsarg = list(scfid = "weibull",
                 tcfid = "weibull",
                 copulaarg = 2,
                 scfarg = list(scale = 20,
                               shape = 0.7),
                 tcfarg = list(scale = 1.1,
                               shape = 0.8))
)

sim &lt;- generateMTS(n = 100,
                     STmodel = fit)

</code></pre>

<hr>
<h2 id='generateMTSFast'>Faster simulation of multiple time series with approximately separable spatiotemporal
correlation structure</h2><span id='topic+generateMTSFast'></span>

<h3>Description</h3>

<p>For more details see section 6 in Serinaldi and Kilsby (2018), and section 2.4 in
Papalexiou and Serinaldi (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateMTSFast(
  n,
  spacepoints,
  margdist,
  margarg,
  p0,
  distbounds = c(-Inf, Inf),
  stcsid,
  stcsarg,
  scalefactor = 1,
  anisotropyid = "affine",
  anisotropyarg = list(phi1 = 1, phi2 = 1, phi12 = 0, theta = 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateMTSFast_+3A_n">n</code></td>
<td>
<p>number of fields (time steps) to simulate</p>
</td></tr>
<tr><td><code id="generateMTSFast_+3A_spacepoints">spacepoints</code></td>
<td>
<p>matrix <code>(d x 2)</code> of coordinates (e.g. longitude and latitude) of <code>d</code> spatial locations (e.g. <code>d</code> gauge stations)</p>
</td></tr>
<tr><td><code id="generateMTSFast_+3A_margdist">margdist</code></td>
<td>
<p>target marginal distribution</p>
</td></tr>
<tr><td><code id="generateMTSFast_+3A_margarg">margarg</code></td>
<td>
<p>list of marginal distribution arguments. Please consult the documentation of the selected marginal distribution indicated in the argument <code>margdist</code> for the list of required parameters</p>
</td></tr>
<tr><td><code id="generateMTSFast_+3A_p0">p0</code></td>
<td>
<p>probability zero</p>
</td></tr>
<tr><td><code id="generateMTSFast_+3A_distbounds">distbounds</code></td>
<td>
<p>distribution bounds (default set to <code>c(-Inf, Inf)</code>)</p>
</td></tr>
<tr><td><code id="generateMTSFast_+3A_stcsid">stcsid</code></td>
<td>
<p>spatiotemporal correlation structure ID</p>
</td></tr>
<tr><td><code id="generateMTSFast_+3A_stcsarg">stcsarg</code></td>
<td>
<p>list of spatiotemporal correlation structure arguments. Please consult the documentation of the selected spatiotemporal correlation structure indicated in the argument <code>stcsid</code> for the list of required parameters</p>
</td></tr>
<tr><td><code id="generateMTSFast_+3A_scalefactor">scalefactor</code></td>
<td>
<p>factor specifying the distance between the centers of two pixels (default set to 1)</p>
</td></tr>
<tr><td><code id="generateMTSFast_+3A_anisotropyid">anisotropyid</code></td>
<td>
<p>spatial anisotropy ID (<code>affine</code> by default, <code>swirl</code> or <code>wave</code>)</p>
</td></tr>
<tr><td><code id="generateMTSFast_+3A_anisotropyarg">anisotropyarg</code></td>
<td>
<p>list of arguments characterizing the spatial anisotropy according to the syntax of the function <code><a href="#topic+anisotropyT">anisotropyT</a></code>. Isotropic fields by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+generateMTSFast">generateMTSFast</a></code> provides a faster approach to multivariate simulation
compared to <code><a href="#topic+generateMTS">generateMTS</a></code> by exploiting circulant embedding
fast Fourier transformation.
However, this approach is feasible only for approximately
separable target spatiotemporal correlation functions.
<code><a href="#topic+generateMTSFast">generateMTSFast</a></code> comprises fitting and simulation in a single function.
Here, we give indicative CPU times for some settings, referring to a
Windows 10 Pro x64 laptop with Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz,
4-core, 8 logical processors, and 32GB RAM. <br />
CPU time:<br />
d = 2500, n = 1000: ~58s <br />
d = 2500, n = 10000: ~160s <br />
d = 10000, n = 1000: ~2955s (~50min) <br />
</p>


<h3>References</h3>

<p>Serinaldi, F., Kilsby, C.G. (2018). Unsurprising Surprises:
The Frequency of Record-breaking and Overthreshold Hydrological Extremes Under
Spatial and Temporal Dependence. Water Resources Research, 54(9), 6460-6487,
doi: <a href="https://doi.org/10.1029/2018WR023055">10.1029/2018WR023055</a>
</p>
<p>Papalexiou, S.M., Serinaldi, F. (2020). Random Fields Simplified:
Preserving Marginal Distributions, Correlations, and Intermittency,
With Applications From Rainfall to Humidity. Water Resources Research, 56(2),
e2019WR026331, doi: <a href="https://doi.org/10.1029/2019WR026331">10.1029/2019WR026331</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coord &lt;- cbind(runif(4)*30, runif(4)*30)

sim &lt;- generateMTSFast(
    n = 50,
    spacepoints = coord,
    p0 = 0.7,
    margdist ='paretoII',
    margarg = list(scale = 1,
                   shape = .3),
    stcsarg = list(scfid = "weibull",
                   tcfid = "weibull",
                   scfarg = list(scale = 20,
                                 shape = 0.7),
                   tcfarg = list(scale = 1.1,
                                 shape = 0.8))
)


</code></pre>

<hr>
<h2 id='generateRF'>Simulation of random field with given marginals and spatiotemporal properties</h2><span id='topic+generateRF'></span>

<h3>Description</h3>

<p>Generates random field with given marginals and spatiotemporal properties,
just provide (1) the output of <code><a href="#topic+fitVAR">fitVAR</a></code> function, and (2) the number of time
steps to simulate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateRF(n, STmodel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateRF_+3A_n">n</code></td>
<td>
<p>number of fields (time steps) to simulate</p>
</td></tr>
<tr><td><code id="generateRF_+3A_stmodel">STmodel</code></td>
<td>
<p>list of arguments resulting from <code><a href="#topic+fitVAR">fitVAR</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Referring to the documentation of <code><a href="#topic+fitVAR">fitVAR</a></code> for details on
computational complexity of the fitting algorithm, here we report indicative
simulation CPU times for some settings, assuming that the model parameters are
already evaluated. CPU times refer to a Windows 10 Pro x64 laptop with
Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz, 4-core, 8 logical processors, and 32GB RAM. <br />
CPU time:<br />
m = 30, p = 1, n = 1000: ~17s <br />
m = 30, p = 1, n = 10000: ~75s <br />
m = 30, p = 5, n = 100: ~280s <br />
m = 30, p = 5, n = 1000: ~302s <br />
m = 50, p = 1, n = 1000 : ~160s <br />
m = 50, p = 1, n = 10000 : ~570s
where m denotes the side length of a square field (mxm)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The example below refers to the simulation of few random fields of
## size 10x10 with AR(1) temporal correlation for the sake of illustration.
## For a more effective visualization and reliable performance assessment,
## we suggest to generate a larger number of fields (e.g. 100 or more)
## of size about 30X30.
## See section 'Details' for additional information on running times
## with different settings.

fit &lt;- fitVAR(
  spacepoints = 10,
  p = 1,
  margdist ='burrXII',
  margarg = list(scale = 3, shape1 = .9, shape2 = .2),
  p0 = 0.8,
  stcsid = "clayton",
  stcsarg = list(scfid = "weibull", tcfid = "weibull",
                 copulaarg = 2,
                 scfarg = list(scale = 20, shape = 0.7),
                tcfarg = list(scale = 1.1, shape = 0.8))
)

sim &lt;- generateRF(n = 12,
                    STmodel = fit)
checkRF(sim,
          lags = 10,
          nfields = 12)

</code></pre>

<hr>
<h2 id='generateRFFast'>Faster simulation of random fields with approximately separable spatiotemporal
correlation structure</h2><span id='topic+generateRFFast'></span>

<h3>Description</h3>

<p>For more details see section 6 in Serinaldi and Kilsby (2018), and section 2.4
in Papalexiou and Serinaldi (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateRFFast(
  n,
  spacepoints,
  margdist,
  margarg,
  p0,
  distbounds = c(-Inf, Inf),
  stcsid,
  stcsarg,
  scalefactor = 1,
  anisotropyid = "affine",
  anisotropyarg = list(phi1 = 1, phi2 = 1, phi12 = 0, theta = 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateRFFast_+3A_n">n</code></td>
<td>
<p>number of fields (time steps) to simulate</p>
</td></tr>
<tr><td><code id="generateRFFast_+3A_spacepoints">spacepoints</code></td>
<td>
<p>side length m of the square field <code>(m x m)</code></p>
</td></tr>
<tr><td><code id="generateRFFast_+3A_margdist">margdist</code></td>
<td>
<p>target marginal distribution of the field</p>
</td></tr>
<tr><td><code id="generateRFFast_+3A_margarg">margarg</code></td>
<td>
<p>list of marginal distribution arguments. Please consult the documentation of the selected marginal distribution indicated in the argument <code>margdist</code> for the list of required parameters</p>
</td></tr>
<tr><td><code id="generateRFFast_+3A_p0">p0</code></td>
<td>
<p>probability zero</p>
</td></tr>
<tr><td><code id="generateRFFast_+3A_distbounds">distbounds</code></td>
<td>
<p>distribution bounds (default set to <code>c(-Inf, Inf)</code>)</p>
</td></tr>
<tr><td><code id="generateRFFast_+3A_stcsid">stcsid</code></td>
<td>
<p>spatiotemporal correlation structure ID</p>
</td></tr>
<tr><td><code id="generateRFFast_+3A_stcsarg">stcsarg</code></td>
<td>
<p>list of spatiotemporal correlation structure arguments. Please consult the documentation of the selected spatiotemporal correlation structure indicated in the argument <code>stcsid</code> for the list of required parameters</p>
</td></tr>
<tr><td><code id="generateRFFast_+3A_scalefactor">scalefactor</code></td>
<td>
<p>factor specifying the distance between the centers of two pixels (default set to 1)</p>
</td></tr>
<tr><td><code id="generateRFFast_+3A_anisotropyid">anisotropyid</code></td>
<td>
<p>spatial anisotropy ID (<code>affine</code> by default, <code>swirl</code> or <code>wave</code>)</p>
</td></tr>
<tr><td><code id="generateRFFast_+3A_anisotropyarg">anisotropyarg</code></td>
<td>
<p>list of arguments characterizing the spatial anisotropy according to the syntax of the function <code><a href="#topic+anisotropyT">anisotropyT</a></code>. Isotropic fields by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+generateRFFast">generateRFFast</a></code> provides a faster approach to RF simulation
compared to <code><a href="#topic+generateRF">generateRF</a></code> by exploiting circulant embedding
fast Fourier transformation.
However, this approach is feasible only for approximately
separable target spatiotemporal correlation functions.
<code><a href="#topic+generateRFFast">generateRFFast</a></code> comprises fitting and simulation in a single function.
Here, we give indicative CPU times for some settings, referring to a
Windows 10 Pro x64 laptop with Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz,
4-core, 8 logical processors, and 32GB RAM. <br />
CPU time:<br />
m = 50, n = 1000: ~58s <br />
m = 50, n = 10000: ~160s <br />
m = 100, n = 1000: ~2955s (~50min) <br />
</p>


<h3>References</h3>

<p>Serinaldi, F., Kilsby, C.G. (2018). Unsurprising Surprises:
The Frequency of Record-breaking and Overthreshold Hydrological Extremes Under
Spatial and Temporal Dependence. Water Resources Research, 54(9), 6460-6487,
doi: <a href="https://doi.org/10.1029/2018WR023055">10.1029/2018WR023055</a>
</p>
<p>Papalexiou, S.M., Serinaldi, F. (2020). Random Fields Simplified:
Preserving Marginal Distributions, Correlations, and Intermittency,
With Applications From Rainfall to Humidity. Water Resources Research, 56(2),
e2019WR026331, doi: <a href="https://doi.org/10.1029/2019WR026331">10.1029/2019WR026331</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim &lt;- generateRFFast(
    n = 50,
    spacepoints = 3,
    p0 = 0.7,
    margdist ='paretoII',
    margarg = list(scale = 1,
                   shape = .3),
    stcsarg = list(scfid = "weibull",
                   tcfid = "weibull",
                   scfarg = list(scale = 20,
                                 shape = 0.7),
                   tcfarg = list(scale = 1.1,
                                 shape = 0.8))
)

checkRF(sim,
          lags = 10,
          nfields = 49)

</code></pre>

<hr>
<h2 id='generateTS'>Generate timeseries</h2><span id='topic+generateTS'></span>

<h3>Description</h3>

<p>Generates timeseries with given properties, just provide (1) the target marginal
distribution and its parameters, (2) the target autocorrelation structure or
individual autocorrelation values up to a desired lag, and (3) the probablility
zero if you wish to simulate an intermittent process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateTS(
  n,
  margdist,
  margarg,
  p = NULL,
  p0 = 0,
  TSn = 1,
  distbounds = c(-Inf, Inf),
  acsvalue = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateTS_+3A_n">n</code></td>
<td>
<p>number of values</p>
</td></tr>
<tr><td><code id="generateTS_+3A_margdist">margdist</code></td>
<td>
<p>target marginal distribution</p>
</td></tr>
<tr><td><code id="generateTS_+3A_margarg">margarg</code></td>
<td>
<p>list of marginal distribution arguments</p>
</td></tr>
<tr><td><code id="generateTS_+3A_p">p</code></td>
<td>
<p>integer - model order (if NULL - limits maximum model order according to auto-correlation structure values)</p>
</td></tr>
<tr><td><code id="generateTS_+3A_p0">p0</code></td>
<td>
<p>probability zero</p>
</td></tr>
<tr><td><code id="generateTS_+3A_tsn">TSn</code></td>
<td>
<p>number of timeseries to be generated</p>
</td></tr>
<tr><td><code id="generateTS_+3A_distbounds">distbounds</code></td>
<td>
<p>distribution bounds (default set to c(-Inf, Inf))</p>
</td></tr>
<tr><td><code id="generateTS_+3A_acsvalue">acsvalue</code></td>
<td>
<p>target auto-correlation structure (from lag 0)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A step-by-step guide:
</p>

<ul>
<li><p> First define the target marginal (<code>margdist</code>), that is, the probability distribution
of the generated data. For example set <code>margdist = 'ggamma'</code> if you wish to generate
data following the Generalized Gamma distribution, <code>margidst = 'burrXII'</code> for Burr
type XII distribution etc. For a full list of the distributions we support see the
help <a href="https://CRAN.R-project.org/package=CoSMoS/vignettes/vignette.html">vignette</a>.
In general, the package supports all build-in distribution functions of R and of other packages.
</p>
</li>
<li><p> Define the parameters' values (<code>margarg</code>) of the distribution you selected. For example
the Generalized Gamma has one scale and two shape parameters so set the desired value,
e.g., <code>margarg = list(scale = 2, shape1 = 0.9, shape2 = 0.8)</code>. Note distributions might
have different number of parameters and different type of parameters (location, scale, shape).
See the help <a href="https://CRAN.R-project.org/package=CoSMoS/vignettes/vignette.html">vignette</a>
for details on the parameters of each distribution we support.
</p>
</li>
<li><p> If you wish your time series to be intermittent (e.g., precipitation), then define the
probability zero. For example, set p0 = 0.9, if you wish your generated data to have
90% of zero values (dry days).
</p>
</li>
<li><p> Define your linear autocorrelations.
</p>

<ul>
<li><p> You can supply specific lag autocorrelations starting from lag 0
and up to a desired lag, e.g., <code>acs = c(1, 0.9, 0.8, 0.7)</code>; this will generate
a process with lag1, 2 and 3 autocorrelations equal with 0.9, 0.8 and 0.7.
</p>
</li>
<li><p> Alternatively, you can use a parametric autocorrelation structure (see section 3.2 in
Papalexiou (2018).
We support the following autocorrelation structures (acs) weibull, paretoII,
fgn and burrXII. See also <code><a href="#topic+acs">acs</a></code> examples.
</p>
</li></ul>

</li>
<li><p> Define the order to the autoregressive model p. For example if you aim to preserve
the first 10 lag autocorrelations then just set p = 10. Otherwise set it p = NULL and
the model will decide the value of p in order to preserve the whole autocorrelation
structure.
</p>
</li>
<li><p> Lastly just define the time series length, e.g., <code>n = 1000</code> and number of time series
you wish to generate, e.g., <code>TSn = 10</code>.
</p>
</li></ul>

<p>Play around with the following given examples which will make the whole
process a piece of cake.
</p>


<h3>References</h3>

<p>Papalexiou, S.M. (2018). Unified theory for stochastic modelling of
hydroclimatic processes: Preserving marginal distributions, correlation structures,
and intermittency. Advances in Water Resources, 115, 234-252,
doi: <a href="https://doi.org/10.1016/j.advwatres.2018.02.013">10.1016/j.advwatres.2018.02.013</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## Case1:
## You wish to generate 3 time series of size 1000 each
## that follow the Generalized Gamma distribution with parameters
## scale = 1, shape1 = 0.8, shape2 = 0.8
## and autocorrelation structure the ParetoII
## with parameters scale = 1 and shape = .75
x &lt;- generateTS(margdist = 'ggamma',
                margarg = list(scale = 1,
                               shape1 = .8,
                               shape2 = .8),
                acsvalue = acs(id = 'paretoII',
                               t = 0:30,
                               scale = 1,
                               shape = .75),
                n = 1000,
                p = 30,
                TSn = 3)

## see the results
plot(x)



## Case2:
## You wish to generate time series the same distribution
## and autocorrelations as is Case1 but intermittent
## with probability zero equal to 90%
y &lt;- generateTS(margdist = 'ggamma',
                margarg = list(scale = 1,
                               shape1 = .8,
                               shape2 = .8),
                acsvalue = acs(id = 'paretoII',
                               t = 0:30,
                               scale = 1,
                               shape = .75),
                p0 = .9,
                n = 1000,
                p = 30,
                TSn = 3)

## see the results
plot(y)

## Case3:
## You wish to generate a time series of size 1000
## that follows the Beta distribution
## (e.g., relative humidity ranging from 0 to 1)
## with parameters shape1 = 0.8, shape2 = 0.8, is defined from 0 to 1
## and autocorrelation structure the ParetoII
## with parameters scale = 1 and shape = .75
z &lt;- generateTS(margdist = 'beta',
                margarg = list(shape1 = .6,
                               shape2 = .8),
                distbounds = c(0, 1),
                acsvalue = acs(id = 'paretoII',
                               t = 0:30,
                               scale = 1,
                               shape = .75),
                n = 1000,
                p = 20)

## see the results
plot(z)

## Case4:
## Same in previous case but now you provide specific
## autocorrelation values for the first three lags,
## ie.., lag 1 to 3 equal to 0.9, 0.8 and 0.7

z &lt;- generateTS(margdist = 'beta',
                margarg = list(shape1 = .6,
                               shape2 = .8),
                distbounds = c(0, 1),
                acsvalue = c(1, .9, .8, .7),
                n = 1000,
                p = TRUE)

## see the results
plot(z)



</code></pre>

<hr>
<h2 id='getACSArg'>Get names of autocorrelation structure (ACS) function arguments</h2><span id='topic+getACSArg'></span>

<h3>Description</h3>

<p>Get names of autocorrelation structure (ACS) function arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getACSArg(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getACSArg_+3A_id">id</code></td>
<td>
<p>ACS id</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
getACSArg('weibull')

</code></pre>

<hr>
<h2 id='getDistArg'>Get names of distribution function arguments</h2><span id='topic+getDistArg'></span>

<h3>Description</h3>

<p>Get names of distribution function arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDistArg(dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDistArg_+3A_dist">dist</code></td>
<td>
<p>distribution name</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
getDistArg('norm')

</code></pre>

<hr>
<h2 id='GEV'>Generalized extreme value distribution</h2><span id='topic+GEV'></span><span id='topic+dgev'></span><span id='topic+pgev'></span><span id='topic+qgev'></span><span id='topic+rgev'></span><span id='topic+mgev'></span>

<h3>Description</h3>

<p>Provides density, distribution function, quantile function,
and random value generation, for the generalized extreme value distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgev(x, loc, scale, shape, log = FALSE)

pgev(q, loc, scale, shape, lower.tail = TRUE, log.p = FALSE)

qgev(p, loc, scale, shape, lower.tail = TRUE, log.p = FALSE)

rgev(n, loc, scale, shape)

mgev(r, loc, scale, shape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEV_+3A_x">x</code>, <code id="GEV_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="GEV_+3A_loc">loc</code>, <code id="GEV_+3A_scale">scale</code>, <code id="GEV_+3A_shape">shape</code></td>
<td>
<p>location, scale and shape parameters.</p>
</td></tr>
<tr><td><code id="GEV_+3A_log">log</code>, <code id="GEV_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="GEV_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="GEV_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="GEV_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="GEV_+3A_r">r</code></td>
<td>
<p>raw moment order</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## plot the density

ggplot(data.frame(x = c(0, 20)),
       aes(x)) +
  stat_function(fun = dgev,
                args = list(loc = 1,
                            scale = .5,
                            shape = .15),
                colour = 'royalblue4') +
  labs(x = '',
       y = 'Density') +
  theme_classic()
</code></pre>

<hr>
<h2 id='GGamma'>Generalized gamma distribution</h2><span id='topic+GGamma'></span><span id='topic+dggamma'></span><span id='topic+pggamma'></span><span id='topic+qggamma'></span><span id='topic+rggamma'></span><span id='topic+mggamma'></span>

<h3>Description</h3>

<p>Provides density, distribution function, quantile function, random value generation,
and raw moments of order <em>r</em> for the generalized gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dggamma(x, scale, shape1, shape2, log = FALSE)

pggamma(q, scale, shape1, shape2, lower.tail = TRUE, log.p = FALSE)

qggamma(p, scale, shape1, shape2, lower.tail = TRUE, log.p = FALSE)

rggamma(n, scale, shape1, shape2)

mggamma(r, scale, shape1, shape2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GGamma_+3A_x">x</code>, <code id="GGamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="GGamma_+3A_scale">scale</code>, <code id="GGamma_+3A_shape1">shape1</code>, <code id="GGamma_+3A_shape2">shape2</code></td>
<td>
<p>scale and shape parameters; the shape arguments cannot be a vectors (must have length one).</p>
</td></tr>
<tr><td><code id="GGamma_+3A_log">log</code>, <code id="GGamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="GGamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="GGamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="GGamma_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="GGamma_+3A_r">r</code></td>
<td>
<p>raw moment order</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## plot the density

ggplot(data.frame(x = c(0, 20)),
       aes(x)) +
  stat_function(fun = dggamma,
                args = list(scale = 5,
                            shape1 = .25,
                            shape2 = .75),
                colour = 'royalblue4') +
  labs(x = '',
       y = 'Density') +
  theme_classic()
</code></pre>

<hr>
<h2 id='lmom'>L-Moments calculation</h2><span id='topic+lmom'></span>

<h3>Description</h3>

<p>L-Moments calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmom(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmom_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
lmom(rnorm(100))

</code></pre>

<hr>
<h2 id='moments'>Numerical estimation of moments</h2><span id='topic+moments'></span>

<h3>Description</h3>

<p>Uses numerical integration to caclulate the theoretical raw or central moments
of the specified distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moments(
  dist,
  distarg,
  p0 = 0,
  raw = T,
  central = T,
  coef = T,
  distbounds = c(-Inf, Inf),
  order = 1:4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moments_+3A_dist">dist</code></td>
<td>
<p>distribution</p>
</td></tr>
<tr><td><code id="moments_+3A_distarg">distarg</code></td>
<td>
<p>list of distribution arguments</p>
</td></tr>
<tr><td><code id="moments_+3A_p0">p0</code></td>
<td>
<p>probability zero</p>
</td></tr>
<tr><td><code id="moments_+3A_raw">raw</code></td>
<td>
<p>logical - calculate raw moments?</p>
</td></tr>
<tr><td><code id="moments_+3A_central">central</code></td>
<td>
<p>logical - calculate central moments?</p>
</td></tr>
<tr><td><code id="moments_+3A_coef">coef</code></td>
<td>
<p>logical - calculate coefficients (coefficient of variation, skewness and kurtosis)?</p>
</td></tr>
<tr><td><code id="moments_+3A_distbounds">distbounds</code></td>
<td>
<p>distribution bounds (default set to c(-Inf, Inf))</p>
</td></tr>
<tr><td><code id="moments_+3A_order">order</code></td>
<td>
<p>vector of integers - raw moment orders</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## Normal Distribution
moments('norm', list(mean = 2, sd = 1))

## Pareto type II
scale &lt;- 1
shape &lt;- .2

moments(dist = 'paretoII',
        distarg = list(shape = shape,
                       scale = scale))

</code></pre>

<hr>
<h2 id='N'>Norm - function to be minimized during distrubution fit</h2><span id='topic+N'></span>

<h3>Description</h3>

<p>Norm - function to be minimized during distrubution fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>N(par, val, dist, norm, n.points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="N_+3A_par">par</code></td>
<td>
<p>parameter value</p>
</td></tr>
<tr><td><code id="N_+3A_val">val</code></td>
<td>
<p>empirical value</p>
</td></tr>
<tr><td><code id="N_+3A_dist">dist</code></td>
<td>
<p>name of the distribution to be fitted</p>
</td></tr>
<tr><td><code id="N_+3A_norm">norm</code></td>
<td>
<p>norm used for distribution fitting - id ('N1', 'N2', 'N3', 'N4')</p>
</td></tr>
<tr><td><code id="N_+3A_n.points">n.points</code></td>
<td>
<p>number of points to be subsetted from ecdf</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
N(c(0,1), rnorm(1000), 'norm', 'N2', 30)

</code></pre>

<hr>
<h2 id='ParetoII'>Pareto type II distribution</h2><span id='topic+ParetoII'></span><span id='topic+dparetoII'></span><span id='topic+pparetoII'></span><span id='topic+qparetoII'></span><span id='topic+rparetoII'></span><span id='topic+mparetoII'></span>

<h3>Description</h3>

<p>Provides density, distribution function, quantile function, random value generation
and raw moments of order <em>r</em> for the Pareto type II distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dparetoII(x, scale, shape, log = FALSE)

pparetoII(q, scale, shape, lower.tail = TRUE, log.p = FALSE)

qparetoII(p, scale, shape, lower.tail = TRUE, log.p = FALSE)

rparetoII(n, scale, shape)

mparetoII(r, scale, shape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ParetoII_+3A_x">x</code>, <code id="ParetoII_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ParetoII_+3A_scale">scale</code>, <code id="ParetoII_+3A_shape">shape</code></td>
<td>
<p>scale and shape parameters; the shape argument cannot be a vector (must have length one).</p>
</td></tr>
<tr><td><code id="ParetoII_+3A_log">log</code>, <code id="ParetoII_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ParetoII_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="ParetoII_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ParetoII_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="ParetoII_+3A_r">r</code></td>
<td>
<p>raw moment order</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## plot the density

ggplot(data.frame(x = c(0, 20)),
       aes(x)) +
  stat_function(fun = dparetoII,
                args = list(scale = 1,
                            shape = .3),
                colour = 'royalblue4') +
  labs(x = '',
       y = 'Density') +
  theme_classic()

</code></pre>

<hr>
<h2 id='plot.acti'>AutoCorrelation Transformation Function visualisation</h2><span id='topic+plot.acti'></span>

<h3>Description</h3>

<p>Visualizes the autocorrelation tranformation integral
(there are two possible methods for plotting - base graphics and ggplot2 package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'acti'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.acti_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+fitactf">fitactf</a></code> result object</p>
</td></tr>
<tr><td><code id="plot.acti_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## choose the marginal distribution as Pareto type II with corresponding parameters
dist &lt;- 'paretoII'
distarg &lt;- list(scale = 1, shape = .3)

## estimate rho 'x' and 'z' points using ACTI
p &lt;- actpnts(margdist = dist, margarg = distarg, p0 = 0)

## fit ACTF
fit &lt;- fitactf(p)

## plot the results
plot(fit)
plot(fit, main = 'Pareto type II distribution \nautocorrelation tranformation')

</code></pre>

<hr>
<h2 id='plot.checkTS'>Plot method for check results</h2><span id='topic+plot.checkTS'></span>

<h3>Description</h3>

<p>Plot method for check results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'checkTS'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.checkTS_+3A_x">x</code></td>
<td>
<p>check result</p>
</td></tr>
<tr><td><code id="plot.checkTS_+3A_...">...</code></td>
<td>
<p>other args</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## check your generated timeseries
x &lt;- generateTS(margdist = 'burrXII',
                margarg = list(scale = 1,
                               shape1 = .75,
                               shape2 = .15),
                acsvalue = acs(id = 'weibull',
                               t = 0:30,
                               scale = 10,
                               shape = .75),
                n = 1000, p = 30, p0 = .25, TSn = 100)

chck &lt;- checkTS(x)

plot(chck)

</code></pre>

<hr>
<h2 id='plot.cosmosts'>Plot generated Timeseries</h2><span id='topic+plot.cosmosts'></span>

<h3>Description</h3>

<p>Visualizes Timeseries generated by the package CoSMoS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cosmosts'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cosmosts_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+fitactf">fitactf</a></code> result object</p>
</td></tr>
<tr><td><code id="plot.cosmosts_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## generate TS
ts &lt;- generateTS(margdist = 'ggamma',
                 margarg = list(scale = 1,
                                shape1 = .8,
                                shape2 = .8),
                 acsvalue = acs(id = 'paretoII',
                                t = 0:30,
                               scale = 1,
                                shape = .75),
                 n = 1000,
                 p = 30,
                 TSn = 2)

## plot the TS
plot(ts)
</code></pre>

<hr>
<h2 id='plot.fitACS'>Plot method for fitACS</h2><span id='topic+plot.fitACS'></span>

<h3>Description</h3>

<p>Plot method for fitACS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitACS'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fitACS_+3A_x">x</code></td>
<td>
<p>fitACS obbject</p>
</td></tr>
<tr><td><code id="plot.fitACS_+3A_...">...</code></td>
<td>
<p>other args</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- AR1(1000, .8)

acsfit &lt;- fitACS(acf(x, plot = FALSE)$acf, 'weibull', c(1, 1))

plot(acsfit)

</code></pre>

<hr>
<h2 id='plot.fitDist'>Plot method for fitDist</h2><span id='topic+plot.fitDist'></span>

<h3>Description</h3>

<p>Plot method for fitDist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitDist'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fitDist_+3A_x">x</code></td>
<td>
<p>fitDist object</p>
</td></tr>
<tr><td><code id="plot.fitDist_+3A_...">...</code></td>
<td>
<p>other args</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- fitDist(rnorm(1000), 'norm', 30, 'N1', FALSE)

plot(x)

</code></pre>

<hr>
<h2 id='PopulationStat'>Population statistics</h2><span id='topic+PopulationStat'></span><span id='topic+populationstat'></span><span id='topic+popmean'></span><span id='topic+popsd'></span><span id='topic+popvar'></span><span id='topic+popcvar'></span><span id='topic+popskew'></span><span id='topic+popkurt'></span>

<h3>Description</h3>

<p>Provides theoretical descriptive statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>populationstat(stat = "mean", dist, distarg, p0 = 0, distbounds = c(-Inf, Inf))

popmean(dist, distarg, p0 = 0, distbounds = c(-Inf, Inf))

popsd(dist, distarg, p0 = 0, distbounds = c(-Inf, Inf))

popvar(dist, distarg, p0 = 0, distbounds = c(-Inf, Inf))

popcvar(dist, distarg, p0 = 0, distbounds = c(-Inf, Inf))

popskew(dist, distarg, p0 = 0, distbounds = c(-Inf, Inf))

popkurt(dist, distarg, p0 = 0, distbounds = c(-Inf, Inf))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PopulationStat_+3A_stat">stat</code></td>
<td>
<p>define what you what to calculate - possible population desc. statistics ('mean', 'sd', 'var', 'cvar', 'skew', 'kurt')</p>
</td></tr>
<tr><td><code id="PopulationStat_+3A_dist">dist</code></td>
<td>
<p>distribution</p>
</td></tr>
<tr><td><code id="PopulationStat_+3A_distarg">distarg</code></td>
<td>
<p>list of distribution arguments</p>
</td></tr>
<tr><td><code id="PopulationStat_+3A_p0">p0</code></td>
<td>
<p>probability zero</p>
</td></tr>
<tr><td><code id="PopulationStat_+3A_distbounds">distbounds</code></td>
<td>
<p>distribution bounds (default set to c(-Inf, Inf))</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## check population statistics
populationstat('mean', 'norm', list(mean = 2, sd = 1))
populationstat('sd', 'norm', list(mean = 2, sd = 1))
populationstat('var', 'norm', list(mean = 2, sd = 1))
populationstat('cvar', 'norm', list(mean = 2, sd = 1))
populationstat('skew', 'norm', list(mean = 2, sd = 1))
populationstat('kurt', 'norm', list(mean = 2, sd = 1))

</code></pre>

<hr>
<h2 id='precip'>Hourly station precipitation data</h2><span id='topic+precip'></span>

<h3>Description</h3>

<p>Station details
</p>

<ul>
<li><p> Name: Philadelphia International Airport
</p>
</li>
<li><p> Network ID: COOP:366889
</p>
</li>
<li><p> Latitude/Longitude:	39.87327Â°, -75.22678Â°
</p>
</li>
<li><p> Elevation: 3m
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>precip
</code></pre>


<h3>Format</h3>

<p>A data.table with 79633 rows and 2 variables:
</p>

<dl>
<dt>date</dt><dd><p>POSIXct format date/time</p>
</dd>
<dt>value</dt><dd><p>precipitation totals</p>
</dd>
</dl>



<h3>Details</h3>

<p>more details can be found <a href="https://www.ncdc.noaa.gov/cdo-web/datasets/PRECIP_HLY/stations/COOP:366889/detail">here</a>.
</p>


<h3>Source</h3>

<p>The National Oceanic and Atmospheric Administration (NOAA)
</p>

<hr>
<h2 id='quickTSPlot'>Quick visualization of basic timeseries properties</h2><span id='topic+quickTSPlot'></span>

<h3>Description</h3>

<p>Return timeseries diagram, empirical density function, and empirical autocorrelation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickTSPlot(TS, ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quickTSPlot_+3A_ts">TS</code></td>
<td>
<p>timeseries to plot</p>
</td></tr>
<tr><td><code id="quickTSPlot_+3A_ci">ci</code></td>
<td>
<p>confidence interval around the zero autocorrelation value (default set to 0.95, i.e. 95% CI)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>no &lt;- 1000
ggamma_sim &lt;- rggamma(n = no, scale = 1, shape1 = 1, shape2 = .5)
quickTSPlot(ggamma_sim)

</code></pre>

<hr>
<h2 id='regenerateTS'>Bulk Timeseries generation</h2><span id='topic+regenerateTS'></span>

<h3>Description</h3>

<p>Resamples given timeseries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regenerateTS(ts, TSn = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regenerateTS_+3A_ts">ts</code></td>
<td>
<p>generated timeseries using ARp</p>
</td></tr>
<tr><td><code id="regenerateTS_+3A_tsn">TSn</code></td>
<td>
<p>number of timeseries to be (re)generated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You have used the <code><a href="#topic+generateTS">generateTS</a></code> function and you wish to generate more time
series. Instead of re-running <code><a href="#topic+generateTS">generateTS</a></code> you can use <code><a href="#topic+regenerateTS">regenerateTS</a></code>,
which generates timeseries using the parameters previously calculated by the
<code><a href="#topic+generateTS">generateTS</a></code> function,  and thus it is faster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

## define marginal distribution and arguments with target
## autocorrelation structure
x &lt;- generateTS(margdist = 'burrXII',
                margarg = list(scale = 1,
                               shape1 = .75,
                               shape2 = .25),
                acsvalue = acs(id = 'weibull',
                               t = 0:30,
                               scale = 10,
                               shape = .75),
                n = 1000, p = 30, p0 = .5, TSn = 3)

## generate new values with same parameters
r &lt;- regenerateTS(x)

plot(r)

</code></pre>

<hr>
<h2 id='rMSE'>Ratio mean square error</h2><span id='topic+rMSE'></span><span id='topic+MSE'></span>

<h3>Description</h3>

<p>Ratio mean square error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMSE(x, y)

MSE(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMSE_+3A_x">x</code></td>
<td>
<p>vector of observed values</p>
</td></tr>
<tr><td><code id="rMSE_+3A_y">y</code></td>
<td>
<p>vector of simulated values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
rMSE(rnorm(10), rnorm(10))

MSE(rnorm(10), rnorm(10))

</code></pre>

<hr>
<h2 id='sample.moments'>Estimation of sample moments</h2><span id='topic+sample.moments'></span>

<h3>Description</h3>

<p>Estimation of sample moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.moments(x, na.rm = FALSE, raw = T, central = T, coef = T, order = 1:4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.moments_+3A_x">x</code></td>
<td>
<p>a numeric vector of values</p>
</td></tr>
<tr><td><code id="sample.moments_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds</p>
</td></tr>
<tr><td><code id="sample.moments_+3A_raw">raw</code></td>
<td>
<p>logical - calculate raw moments?</p>
</td></tr>
<tr><td><code id="sample.moments_+3A_central">central</code></td>
<td>
<p>logical - calculate central moments?</p>
</td></tr>
<tr><td><code id="sample.moments_+3A_coef">coef</code></td>
<td>
<p>logical - calculate coefficients (coefficient of variation, skewness and kurtosis)?</p>
</td></tr>
<tr><td><code id="sample.moments_+3A_order">order</code></td>
<td>
<p>vector of integers - raw moment orders</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CoSMoS)

x &lt;- rnorm(1000)
sample.moments(x)

y &lt;- rparetoII(1000, 10, .1)
sample.moments(y)

</code></pre>

<hr>
<h2 id='seasonalACF'>Calculate seasonal ACF</h2><span id='topic+seasonalACF'></span>

<h3>Description</h3>

<p>Calculate seasonal ACF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasonalACF(TS, season, lag.max = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasonalACF_+3A_ts">TS</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="seasonalACF_+3A_season">season</code></td>
<td>
<p>name of the season</p>
</td></tr>
<tr><td><code id="seasonalACF_+3A_lag.max">lag.max</code></td>
<td>
<p>max lag for acf</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data('precip')


seasonalACF(precip, 'month')

</code></pre>

<hr>
<h2 id='seasonalAR'>Seasonal AR model</h2><span id='topic+seasonalAR'></span>

<h3>Description</h3>

<p>Seasonal AR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasonalAR(x, ACS, season = "month")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasonalAR_+3A_x">x</code></td>
<td>
<p>vector of dates for gaussian process generation</p>
</td></tr>
<tr><td><code id="seasonalAR_+3A_acs">ACS</code></td>
<td>
<p>list of ACS for each season</p>
</td></tr>
<tr><td><code id="seasonalAR_+3A_season">season</code></td>
<td>
<p>season name</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data('precip')


x &lt;- seasonalACF(precip, 'month')

seasonalAR(precip$date, x)

</code></pre>

<hr>
<h2 id='stcfclayton'>Clayton SpatioTemporal Correlation Structure</h2><span id='topic+stcfclayton'></span>

<h3>Description</h3>

<p>Provides spatiotemporal correlation structure function based on Clayton copula.
For more details on the parametric spatiotemporal correlation structures
see section 2.3 and 2.4 in Papalexiou and Serinaldi (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stcfclayton(t, s, scfid, tcfid, copulaarg, scfarg, tcfarg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stcfclayton_+3A_t">t</code></td>
<td>
<p>time lag</p>
</td></tr>
<tr><td><code id="stcfclayton_+3A_s">s</code></td>
<td>
<p>spatial lag (distance)</p>
</td></tr>
<tr><td><code id="stcfclayton_+3A_scfid">scfid</code></td>
<td>
<p>ID of the spatial (marginal) correlation structure (e.g. weibull)</p>
</td></tr>
<tr><td><code id="stcfclayton_+3A_tcfid">tcfid</code></td>
<td>
<p>ID of the temporal (marginal) correlation structure (e.g. weibull)</p>
</td></tr>
<tr><td><code id="stcfclayton_+3A_copulaarg">copulaarg</code></td>
<td>
<p>parameter of the Clayton copula linking the marginal correlation structures</p>
</td></tr>
<tr><td><code id="stcfclayton_+3A_scfarg">scfarg</code></td>
<td>
<p>parameters of spatial (marginal) correlation structure</p>
</td></tr>
<tr><td><code id="stcfclayton_+3A_tcfarg">tcfarg</code></td>
<td>
<p>parameters of temporal (marginal) correlation structure</p>
</td></tr>
</table>


<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F. (2020). Random Fields Simplified:
Preserving Marginal Distributions, Correlations, and Intermittency,
With Applications From Rainfall to Humidity. Water Resources Research, 56(2),
e2019WR026331, doi: <a href="https://doi.org/10.1029/2019WR026331">10.1029/2019WR026331</a>
</p>
<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(plot3D)

## specify grid of spatial and temporal lags
d &lt;- 31
st &lt;- expand.grid(0:(d - 1),
                  0:(d - 1))

## get the STCS
wc &lt;- stcfclayton(t = st[, 1],
                  s = st[, 2],
                  scfid = 'weibull',
                  tcfid = 'weibull',
                  copulaarg = 2,
                  scfarg = list(scale = 20,
                                shape = 0.7),
                  tcfarg = list(scale = 1.1,
                                shape = 0.8))

## visualize the STCS
wc.m &lt;- matrix(wc,
               nrow = d)

persp3D(z = wc.m, x = 1: nrow(wc.m), y = 1:ncol(wc.m),
        expand = 1, main = "", scale = TRUE, facets = TRUE,
        xlab="Time lag", ylab = "Distance", zlab = "STCF",
        colkey = list(side = 4, length = 0.5), phi = 20, theta = 120,
        resfac = 5,  col= gg2.col(100))

</code></pre>

<hr>
<h2 id='stcfgneiting14'>Gneiting-14 SpatioTemporal Correlation Structure</h2><span id='topic+stcfgneiting14'></span>

<h3>Description</h3>

<p>Provides spatiotemporal correlation structure function proposed by
Gneiting (2002; Eq.14 at p. 593).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stcfgneiting14(t, s, a, c, alpha, beta, gamma, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stcfgneiting14_+3A_t">t</code></td>
<td>
<p>time lag</p>
</td></tr>
<tr><td><code id="stcfgneiting14_+3A_s">s</code></td>
<td>
<p>spatial lag (distance)</p>
</td></tr>
<tr><td><code id="stcfgneiting14_+3A_a">a</code></td>
<td>
<p>nonnegative scaling parameter of time</p>
</td></tr>
<tr><td><code id="stcfgneiting14_+3A_c">c</code></td>
<td>
<p>nonnegative scaling parameter of space</p>
</td></tr>
<tr><td><code id="stcfgneiting14_+3A_alpha">alpha</code></td>
<td>
<p>smoothness parameter of time. Valid range: <code class="reqn">(0,1]</code></p>
</td></tr>
<tr><td><code id="stcfgneiting14_+3A_beta">beta</code></td>
<td>
<p>space-time interaction parameter. Valid range: <code class="reqn">[0,1]</code></p>
</td></tr>
<tr><td><code id="stcfgneiting14_+3A_gamma">gamma</code></td>
<td>
<p>smoothness parameter of space. Valid range: <code class="reqn">(0,1]</code></p>
</td></tr>
<tr><td><code id="stcfgneiting14_+3A_tau">tau</code></td>
<td>
<p>space-time interaction parameter. Valid range: <code class="reqn">\ge 1</code> (for 2-dimensional fields)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gneiting, T. (2002). Nonseparable, Stationary Covariance Functions
for Space-Time Data, Journal of the American Statistical Association,
97:458, 590-600, doi: <a href="https://doi.org/10.1198/016214502760047113">10.1198/016214502760047113</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(plot3D)

## specify grid of spatial and temporal lags
d &lt;- 31
st &lt;- expand.grid(0:(d - 1),
                  0:(d - 1))

## get the STCS
g14 &lt;- stcfgneiting14(t = st[, 1],
                      s = st[, 2],
                      a = 1/50,
                      c = 1/10,
                      alpha = 1,
                      beta = 1,
                      gamma = 0.5,
                      tau = 1)

## visualize the STCS

g14.m &lt;- matrix(g14,
                nrow = d)

persp3D(z = g14.m, x = 1: nrow(g14.m), y = 1:ncol(g14.m),
        expand = 1, main = "", scale = TRUE, facets = TRUE,
        xlab="Time lag", ylab = "Distance", zlab = "STCF",
        colkey = list(side = 4, length = 0.5), phi = 20, theta = 120,
        resfac = 5,  col= gg2.col(100))

</code></pre>

<hr>
<h2 id='stcfgneiting16'>Gneiting-16 SpatioTemporal Correlation Structure</h2><span id='topic+stcfgneiting16'></span>

<h3>Description</h3>

<p>Provides spatiotemporal correlation structure function proposed by
Gneiting (2002; Eq.16 at p. 594).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stcfgneiting16(t, s, a, c, alpha, beta, nu, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stcfgneiting16_+3A_t">t</code></td>
<td>
<p>time lag</p>
</td></tr>
<tr><td><code id="stcfgneiting16_+3A_s">s</code></td>
<td>
<p>spatial lag (distance)</p>
</td></tr>
<tr><td><code id="stcfgneiting16_+3A_a">a</code></td>
<td>
<p>nonnegative scaling parameter of time</p>
</td></tr>
<tr><td><code id="stcfgneiting16_+3A_c">c</code></td>
<td>
<p>nonnegative scaling parameter of space</p>
</td></tr>
<tr><td><code id="stcfgneiting16_+3A_alpha">alpha</code></td>
<td>
<p>smoothness parameter of time. Valid range: <code class="reqn">(0,1]</code></p>
</td></tr>
<tr><td><code id="stcfgneiting16_+3A_beta">beta</code></td>
<td>
<p>space-time interaction parameter. Valid range: <code class="reqn">[0,1]</code></p>
</td></tr>
<tr><td><code id="stcfgneiting16_+3A_nu">nu</code></td>
<td>
<p>smoothness parameter of space. Valid range: <code class="reqn">&gt;0</code></p>
</td></tr>
<tr><td><code id="stcfgneiting16_+3A_tau">tau</code></td>
<td>
<p>space-time interaction parameter. Valid range: <code class="reqn">\ge 1</code> (for 2-dimensional fields)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gneiting, T. (2002). Nonseparable, Stationary Covariance Functions
for Space-Time Data, Journal of the American Statistical Association,
97:458, 590-600, doi: <a href="https://doi.org/10.1198/016214502760047113">10.1198/016214502760047113</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(plot3D)

## specify grid of spatial and temporal lags
d &lt;- 31
st &lt;- expand.grid(0:(d - 1),
                  0:(d - 1))

## get the STCS
g16 &lt;- stcfgneiting16(t = st[, 1],
                      s = st[, 2],
                      a = 1/50,
                      c = 1/10,
                      alpha = 1,
                      beta = 1,
                      nu = 0.5, tau = 1)

## visualize the STCS

g16.m &lt;- matrix(g16,
                nrow = d)

persp3D(z = g16.m, x = 1: nrow(g16.m), y = 1:ncol(g16.m),
        expand = 1, main = "", scale = TRUE, facets = TRUE,
        xlab="Time lag", ylab = "Distance", zlab = "STCF",
        colkey = list(side = 4, length = 0.5), phi = 20, theta = 120,
        resfac = 5,  col= gg2.col(100))

</code></pre>

<hr>
<h2 id='stcs'>SpatioTemporal Correlation Structure</h2><span id='topic+stcs'></span>

<h3>Description</h3>

<p>Provides a parametric function that describes the values of the linear
spatiotemporal autocorrelation up to desired lags.
For more details on the parametric spatiotemporal correlation structures see
section 2.3 and 2.4 in Papalexiou and Serinaldi (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stcs(id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stcs_+3A_id">id</code></td>
<td>
<p>spatiotemporal correlation structure ID</p>
</td></tr>
<tr><td><code id="stcs_+3A_...">...</code></td>
<td>
<p>additional arguments (t as time lag, s as spatial lag (distance),  and stcs parameters)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F. (2020). Random Fields Simplified:
Preserving Marginal Distributions, Correlations, and Intermittency,
With Applications From Rainfall to Humidity. Water Resources Research, 56(2),
e2019WR026331, doi: <a href="https://doi.org/10.1029/2019WR026331">10.1029/2019WR026331</a>
</p>
<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(plot3D)

## specify grid of spatial and temporal lags
d &lt;- 31
st &lt;- expand.grid(0:(d-1),
                  0:(d-1))

## get the STCS
wc &lt;- stcs("clayton",
           t = st[, 1],
           s = st[, 2],
           scfid = 'weibull',
           tcfid = 'weibull',
           copulaarg = 2,
           scfarg = list(scale = 20,
                         shape = 0.7),
           tcfarg = list(scale = 1.1,
                         shape = 0.8))

g14 &lt;- stcs("gneiting14",
            t = st[, 1],
            s = st[, 2],
            a = 1/50,
            c = 1/10,
            alpha = 1,
            beta = 1,
            gamma = 0.5,
            tau = 1)

g16 &lt;- stcs("gneiting16",
            t = st[, 1],
            s = st[, 2],
            a = 1/50,
            c = 1/10,
            alpha = 1,
            beta = 1,
            nu = 0.5,
            tau = 1)

## note: for nu = 0.5 stcfgneiting16 is equivalent to
## stcfgneiting14 with gamma = 0.5

## visualize the STCS

wc.m &lt;- matrix(wc,
               nrow = d)

persp3D(z = wc.m, x = 1: nrow(wc.m), y = 1:ncol(wc.m),
        expand = 1, main = "", scale = TRUE, facets = TRUE,
        xlab="Time lag", ylab = "Distance", zlab = "STCF",
        colkey = list(side = 4, length = 0.5), phi = 20, theta = 120,
        resfac = 5,  col= gg2.col(100))

g14.m &lt;- matrix(g14,
                nrow = d)

persp3D(z = g14.m, x = 1: nrow(wc.m), y = 1:ncol(wc.m),
        expand = 1, main = "", scale = TRUE, facets = TRUE,
        xlab="Time lag", ylab = "Distance", zlab = "STCF",
        colkey = list(side = 4, length = 0.5), phi = 20, theta = 120,
        resfac = 5,  col= gg2.col(100))

</code></pre>

<hr>
<h2 id='stcs2'>SpatioTemporal Correlation Structure</h2><span id='topic+stcs2'></span>

<h3>Description</h3>

<p>Provides a parametric function that describes the values of the linear
spatiotemporal autocorrelation up to desired lags.
For more details on the parametric spatiotemporal correlation structures see
section 2.3 and 2.4 in Papalexiou and Serinaldi (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stcs2(id, arglist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stcs2_+3A_id">id</code></td>
<td>
<p>spatiotemporal correlation structure ID</p>
</td></tr>
<tr><td><code id="stcs2_+3A_arglist">arglist</code></td>
<td>
<p>list of additional arguments (t as time lag, s as spatial lag (distance),  and stcs parameters)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Papalexiou, S.M., Serinaldi, F. (2020). Random Fields Simplified:
Preserving Marginal Distributions, Correlations, and Intermittency,
With Applications From Rainfall to Humidity. Water Resources Research, 56(2),
e2019WR026331, doi: <a href="https://doi.org/10.1029/2019WR026331">10.1029/2019WR026331</a>
</p>
<p>Papalexiou, S.M., Serinaldi, F., Porcu, E. (2021). Advancing
Space-Time Simulation of Random Fields: From Storms to Cyclones and Beyond.
Water Resources Research, 57, e2020WR029466, doi: <a href="https://doi.org/10.1029/2020WR029466">10.1029/2020WR029466</a>
</p>

<hr>
<h2 id='stratifySeasonData'>Stratify timeseries by season</h2><span id='topic+stratifySeasonData'></span>

<h3>Description</h3>

<p>Stratify timeseries by season
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratifySeasonData(TS, season)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratifySeasonData_+3A_ts">TS</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="stratifySeasonData_+3A_season">season</code></td>
<td>
<p>name of the season</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(date = seq(Sys.Date(), by = 'day', length.out = 1000),
                value = rnorm(1000))

stratifySeasonData(x, 'month')
</code></pre>

<hr>
<h2 id='YW'>Yule-Walker solver</h2><span id='topic+YW'></span>

<h3>Description</h3>

<p>Yule-Walker solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YW(ACS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="YW_+3A_acs">ACS</code></td>
<td>
<p>vector of ACS values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
YW(rev(exp(seq(-1, 0, .1))))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
