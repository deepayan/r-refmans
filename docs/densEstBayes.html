<!DOCTYPE html><html><head><title>Help for package densEstBayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {densEstBayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checkChains'><p>Check Markov chain Monte Carlo samples</p></a></li>
<li><a href='#densEstBayes'><p>Density estimation via Bayesian inference engines</p></a></li>
<li><a href='#densEstBayes.control'><p>Controlling density estimation via Bayesian inference engines</p></a></li>
<li><a href='#densEstBayesVignette'><p>Display the package's vignette.</p></a></li>
<li><a href='#dMarronWand'><p>Marron and Wand density function</p></a></li>
<li><a href='#incomeUK'><p>Incomes of United Kingdom citizens</p></a></li>
<li><a href='#OldFaithful2011'><p>Intervals between geyser eruptions</p></a></li>
<li><a href='#plot.densEstBayes'><p>Plot the Bayesian density estimate from a <code>densEstBayes()</code> fit</p></a></li>
<li><a href='#predict.densEstBayes'><p>Obtain the Bayesian density estimate from a <code>densEstBayes()</code> fit at new abscissae</p></a></li>
<li><a href='#rMarronWand'><p>Marron and Wand random sample</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-08-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Density Estimation via Bayesian Inference Engines</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt P. Wand &lt;matt.wand@uts.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian density estimates for univariate continuous random samples are provided using the Bayesian inference engine paradigm. The engine options are: Hamiltonian Monte Carlo, the no U-turn sampler, semiparametric mean field variational Bayes and slice sampling. The methodology is described in Wand and Yu (2020) &lt;<a href="https://doi.org/10.48550/arXiv.2009.06182">doi:10.48550/arXiv.2009.06182</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, nlme, Rcpp, methods, rstan, rstantools</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, Rcpp, RcppArmadillo, RcppEigen, RcppParallel,
StanHeaders, rstan</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-30 08:37:26 UTC; andrew</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt P. Wand <a href="https://orcid.org/0000-0003-2555-896X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-31 06:43:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='checkChains'>Check Markov chain Monte Carlo samples</h2><span id='topic+checkChains'></span>

<h3>Description</h3>

<p>Facilitates a graphical check of the Markov chain Monte Carlo samples (&quot;chains&quot;) corresponding to vertical slices of the log-density function estimate at five representative abscissa values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkChains(fitObject,locations = "equally-spaced")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkChains_+3A_fitobject">fitObject</code></td>
<td>
<p><code>densEstBayes()</code> fit object.</p>
</td></tr>
<tr><td><code id="checkChains_+3A_locations">locations</code></td>
<td>
<p>Character string that specifies the locations of the vertical slices for the chains to be displayed. The
options are:<br />
&quot;equally-spaced&quot; for 5 equally-spaced locations over the range of the data.<br /> 
&quot;hexiles&quot; for the locations being the sample hexiles of the data.<br />
The default value is &quot;equally-spaced&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A graphic is produced that summarises the Markov chain Monte Carlo samples (&quot;chains&quot;) corresponding to vertical slices of the log-density function estimate at five representative abscissae. If the location is specified to be &quot;equally-spaced&quot; and the range.x array of the density estimate is the interval [a,b] then the abscissae are a + j(b-a)/6 for j=1,2,3,4,5. If the location is specified to be &quot;hexiles&quot; then the abscissae are the sample hexiles of the data. The columns of the graphic are the following summaries of each chain: (1) trace (time series) plot, (2) lag-1 plot in which each chain value is plotted against its previous value and (3) sample autocorrelation function plot as produced by the R function acf().</p>


<h3>Author(s)</h3>

<p>Matt P. Wand <a href="mailto:matt.wand@uts.edu.au">matt.wand@uts.edu.au</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(densEstBayes) ; data(OldFaithful2011)

# Obtain a density estimate for the `OldFaithful2011' data:

dest &lt;- densEstBayes(OldFaithful2011)

# Obtain a graphic for checking the chains:

checkChains(dest)

</code></pre>

<hr>
<h2 id='densEstBayes'>Density estimation via Bayesian inference engines</h2><span id='topic+densEstBayes'></span>

<h3>Description</h3>

<p>Construction of a high quality density estimate from a random sample is a fundamental problem in Statistics. This function delivers solutions to this problem by calling upon Bayesian inference engine algorithms with roots in the Machine Learning literature. Both stochastic and faster deterministic algorithms are provided. The stochastic options are Hamiltonian Monte Carlo and the no U-turn sampler (through the Stan inference engine) and slice sampling. The deterministic option is semiparametric mean field variational Bayes. The last of these options provides a very quick Bayesian density estimate, whereas the other options take longer to compute but, according to extensive simulation testing, are highly accurate. The essence of the approach is conversion of the density estimation problem to a Bayesian Poisson mixed model problem via binning on a fine grid. An attractive by-product of the binning approach is the ability to handle very large sample sizes. The number of bins, rather than the sample size, is the limiting factor.</p>


<h3>Usage</h3>

<pre><code class='language-R'>densEstBayes(x,method,verbose,control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densEstBayes_+3A_x">x</code></td>
<td>
<p>Vector containing a continuous univariate data set.</p>
</td></tr>
<tr><td><code id="densEstBayes_+3A_method">method</code></td>
<td>
<p>Character string for specifying the method to be used:<br />
&quot;HMC&quot; = Hamiltonian Monte Carlo,<br />
&quot;NUTS&quot; = the no U-turn sampler,<br />
&quot;slice&quot; = slice sampling,<br />
&quot;SMFVB&quot; = semiparametric mean field variational Bayes.</p>
</td></tr>
<tr><td><code id="densEstBayes_+3A_verbose">verbose</code></td>
<td>
<p>Boolean variable for specifying whether or not progress messages are printed to the console. The default is TRUE.</p>
</td></tr>
<tr><td><code id="densEstBayes_+3A_control">control</code></td>
<td>
<p>Function for controlling Markov chain Monte Carlo sample sizes and other specifications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The crux of the Bayesian density estimation approach is to bin the input data on a fine equally-spaced grid and treat the bin counts as response data in a Bayesian Poisson mixed model-based penalized splines model. Section 8 of Eilers and Marx (1996) provides details on couching the density estimation problem as a Poisson penalized splines problem.<br />
</p>
<p>Fitting and inference for the resultant Bayesian Poisson mixed model is carried out using one of four possible approaches as specified by the <code>method</code> argument; one of which is deterministic (&quot;SMFVB&quot;) and three of which are stochastic (&quot;HMC&quot;, &quot;NUTS&quot; and &quot;slice&quot;).
</p>
<p>The settings <code>method</code> = &quot;HMC&quot; and <code>method</code> = &quot;NUTS&quot; correspond, respectively, to the Markov chain Monte Carlo approaches Hamiltonian Monte Carlo (e.g. Neal, 2011) and the no-U-turn sampler (Hoffman and Gelman, 2014) and fitting and inference is performed using the Stan Bayesian inference engine via the <code>rstan</code> package (Stan Development Team, 2017). 
</p>
<p>The setting <code>method</code> = &quot;slice&quot; corresponds to slice sampling (e.g. Neal, 2003).
</p>
<p>The setting <code>method</code> = &quot;SMFVB&quot; uses a semiparametric mean field variational Bayes approach as summarised in Algorithm 1 of Luts and Wand (2015). Comparatively speaking, this method leads to a very quick density estimate but at some accuracy and convergence reliability costs.
</p>


<h3>Value</h3>

<p>An object of class <code>densEstBayes</code>, which is a list with the following components:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>the value of <code>method</code>.</p>
</td></tr> 
<tr><td><code>range.x</code></td>
<td>
<p>a numerical vector with 2 entries such that range.x[1] is the lower limit and range.x[2] is the upper limit of the interval over which the density estimate was computed.</p>
</td></tr>
<tr><td><code>intKnots</code></td>
<td>
<p>a numerical vector containing the locations of the interior knots used in the cubic O'Sullivan spline basis</p>
</td></tr>
<tr><td><code>determFitObj</code></td>
<td>
<p>if <code>method</code> is &quot;SMFVB&quot; then <code>determFitObj</code> is a list with the following components:<br />
mu.q.betau: numerical vector containing the mean vector of the Multivariate Normal approximate posterior density function of the linear component coefficients (first two entries) and penalised spline coefficients (remainining entries).<br />
Sigma.q.betau: numerical matrix containing the covariance matrix of the Multivariate Normal approximate posterior density function of linear and penalised spline coefficients vector.<br /> 
kappa.q.sigsq: numerical scalar containing the shape parameter of the Inverse Gamma approximate posterior density function of the variance parameter in the mixed model-based penalised spline model.<br />
lambda.q.sigsq: numerical scalar containing the scale parameter of the Inverse Gamma approximate posterior density function of the variance parameter in the mixed model-based penalised spline model.<br />
If <code>method</code> is &quot;HMC&quot;, &quot;NUTS&quot; or &quot;slice&quot; then <code>determFitObj</code> is returned as NULL.
</p>
</td></tr>
<tr><td><code>stochaFitObj</code></td>
<td>
<p>if <code>method</code> is &quot;HMC&quot;, &quot;NUTS&quot; or &quot;slice&quot; then <code>stochaFitObj</code> is a list with the following components:<br />
betauMCMC: numerical matrix containing Markov chain Monte Carlo draws from the posterior distribution of the basis function coefficients, with rows corresponding to the linear component coefficients (first two rows) and penalised spline coefficients (remainining rows) and columns corresponding to the samples.<br />
sigsqMCMC: numerical vector containing Markov chain Monte Carlo draws from the posterior distribution of the variance parameter in the mixed model-based penalised spline model.<br />
If <code>method</code> is &quot;SMFVB&quot; then <code>stochaFitObj</code> is returned as NULL.</p>
</td></tr>
<tr><td><code>xname</code></td>
<td>
<p>A character string that matches the <code>x</code> object. For example, if the call to <code>densEstBayes()</code> is <code>dest &lt;- densEstBayes(alexandrina)</code> then <code>xname</code> is &quot;alexandrina&quot;.</p>
</td></tr>
<tr><td><code>sampHexTran</code></td>
<td>
<p>Sample hexiles of the transformed input data to be used for possible checking Markov chains Monte Carlo samples.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt P. Wand <a href="mailto:matt.wand@uts.edu.au">matt.wand@uts.edu.au</a></p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (1996).
Flexible smoothing with B-splines and penalties (with discussion).
<em>Statistical Science</em>, <b>11</b>, 89-121.
</p>
<p>Hoffman, M.D. and Gelman, A. (2014). The no-U-turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo.
<em>Journal of Machine Learning Research</em>, <b>15</b>, 1593-1623.
</p>
<p>Minka, T. (2005). Divergence measures and message passing. <em>Microsoft Research Technical Report Series</em>, 
<b>MSR-TR-2005-173</b>, 1-17.
</p>
<p>Luts, J. and Wand, M.P. (2015). Variational inference for count response semiparametric regression.
<em>Bayesian Analysis</em>, <b>10</b>, 991-1023.
</p>
<p>Neal, R. (2003). Slice sampling (with discussion). <em>The Annals of Statistics</em>, <b>31</b>, 705-767.
</p>
<p>Neal, R. (2011). MCMC using Hamiltonian dynamics. In <em>Handbook of Markov Chain Monte Carlo</em>, eds. S. Brooks, A. Gelman, G.L. Jones and X.-L. Meng. Boca Raton, Florida: Chapman &amp; Hall/CRC Press.
</p>
<p>Stan Development Team. (2020). <em>Stan Modeling Language
User's Guide and Reference Manual</em>, <a href="https://mc-stan.org">https://mc-stan.org</a>.
</p>
<p>Wainwright, M.J. and Jordan, M.I. (2008). Graphical models, exponential families, and variational inference.
<em>Foundations and Trends in Machine Learning</em>, <b>1</b>, 1-305.
</p>
<p>Wand, M.P. and Yu, J.C.F. (2020). Density estimation via Bayesian inference engines. Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(densEstBayes) ; set.seed(1)
x &lt;- rMarronWand(1000,8)
dest &lt;- densEstBayes(x,method = "SMFVB")
plot(dest) ; rug(x,col = "dodgerblue",quiet = TRUE)
xg &lt;- seq(-3,3,length = 1001)
trueDensg &lt;- dMarronWand(xg,8)
lines(xg,trueDensg,col = "indianred3")

if (require("rstan"))
{
   dest &lt;- densEstBayes(x,method = "NUTS")
   plot(dest) ; rug(x,col = "dodgerblue")
   xg &lt;- seq(-3,3,length = 1001)
   trueDensg &lt;- dMarronWand(xg,8)
   lines(xg,trueDensg,col = "indianred3")
}

</code></pre>

<hr>
<h2 id='densEstBayes.control'>Controlling density estimation via Bayesian inference engines</h2><span id='topic+densEstBayes.control'></span>

<h3>Description</h3>

<p>Function for optional use in calls to <code>densEstBayes()</code> to control convergence values and other specifications for density estimation using Bayesian inference engines.</p>


<h3>Usage</h3>

<pre><code class='language-R'>densEstBayes.control(range.x = NULL,numBins = 401,numBasis = 50,sigmabeta = 1e5,
                     ssigma = 1000,convToler = 1e-5,maxIter = 500,nWarm = NULL,
                     nKept = NULL,nThin = 1,msgCode = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densEstBayes.control_+3A_range.x">range.x</code></td>
<td>
<p>A two-component array such that the density estimate is obtained over the interval between range.x[1] and range.x[2]. The default value of range.x[1] is 1.05*min(x)-0.05*max(x) and the default value of range.x[2] is 1.05*max(x)-0.05*min(x).</p>
</td></tr>
<tr><td><code id="densEstBayes.control_+3A_numbins">numBins</code></td>
<td>
<p>The number of bins used for binning of the data. The default is 401.</p>
</td></tr>
<tr><td><code id="densEstBayes.control_+3A_numbasis">numBasis</code></td>
<td>
<p>The number of cubic O'Sullivan spline basis functions. The default is 50.</p>
</td></tr>
<tr><td><code id="densEstBayes.control_+3A_sigmabeta">sigmabeta</code></td>
<td>
<p>The prior standard deviation of the fixed effects coefficients corresponding to the linear component of the fit. The default is 100000.</p>
</td></tr>
<tr><td><code id="densEstBayes.control_+3A_ssigma">ssigma</code></td>
<td>
<p>The prior scale parameter of the standard deviation parameter. The default is 1000.</p>
</td></tr>
<tr><td><code id="densEstBayes.control_+3A_convtoler">convToler</code></td>
<td>
<p>The convergence tolerance value used for determination of convergence of when the method is semiparametric mean field variational Bayes. Convergence is deemed to have occured when the relative change in the q-density expectation of the reciprocal variance parameter is below convToler. The default is 0.00001.</p>
</td></tr>
<tr><td><code id="densEstBayes.control_+3A_maxiter">maxIter</code></td>
<td>
<p>The maximum number of iterations when the method is mean field variational Bayes. The default is 500.</p>
</td></tr>
<tr><td><code id="densEstBayes.control_+3A_nwarm">nWarm</code></td>
<td>
<p>The size of the Markov chain Monte Carlo warmup, a positive integer, when the method is Markov chain Monte Carlo. The default for method = &quot;HMC&quot; and method = &quot;NUTS&quot; is 1000 and the default for method = &quot;slice&quot; is 100.</p>
</td></tr>
<tr><td><code id="densEstBayes.control_+3A_nkept">nKept</code></td>
<td>
<p>The size of the kept Markov chain Monte Carlo samples, a positive integer, when the method is Markov chain Monte Carlo. The default is 1000.</p>
</td></tr>
<tr><td><code id="densEstBayes.control_+3A_nthin">nThin</code></td>
<td>
<p>The thinning factor for the kept Markov chain Monte Carlo samples, a positive integer, when the method is Markov chain Monte Carlo. The default is 1.</p>
</td></tr>
<tr><td><code id="densEstBayes.control_+3A_msgcode">msgCode</code></td>
<td>
<p>Code for the nature of progress messages printed to the screen when the method is either &quot;HMC&quot;, &quot;NUTS&quot; or &quot;sl
ice&quot;. If msgCode=0 then no progress messages are printed. If msgCode=1 then a messages printed each time approximately each 10% of the sampling is completed. If msgCode=2 then a messages printed each time approximately each 10% of the sampling is completed. The default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing values of each of the fifteen control parameters, packaged to supply the <code>control</code> argument to <code>densEstBayes</code>. The values for <code>densEstBayes.control</code> can be specified in the call to <code>densEstBayes</code>.
</p>


<h3>Author(s)</h3>

<p>Matt P. Wand <a href="mailto:matt.wand@uts.edu.au">matt.wand@uts.edu.au</a></p>


<h3>References</h3>

<p>Wand, M.P. and Yu, J.C.F. (2020). 
Density estimation via Bayesian inference engines. Submitted.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(densEstBayes) ; set.seed(1)
x &lt;- rMarronWand(1000,8)
dest &lt;- densEstBayes(x,method = "SMFVB")
plot(dest) ; rug(x,col="dodgerblue",quiet = TRUE)
xg &lt;- seq(-3,3,length = 1001)
trueDensg &lt;- dMarronWand(xg,8)
lines(xg,trueDensg,col = "indianred3")

# Now modify some of the control values:

destControlled &lt;- densEstBayes(x,method = "SMFVB",control = densEstBayes.control(numBins = 201,
                               numBasis = 35,sigmabeta = 1000,ssigma = 100,convToler = 1e-4))
plot(destControlled) ; rug(x,col = "dodgerblue",quiet = TRUE)
lines(xg,trueDensg,col = "indianred3")
</code></pre>

<hr>
<h2 id='densEstBayesVignette'>Display the package's vignette.</h2><span id='topic+densEstBayesVignette'></span>

<h3>Description</h3>

<p>The vignette of the densEstBayes package is displayed using the default PDF file browser. It provides a detailed description of use of the package for Bayesian density estimation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>densEstBayesVignette()
</code></pre>


<h3>Author(s)</h3>

<p>Matt P. Wand <a href="mailto:matt.wand@uts.edu.au">matt.wand@uts.edu.au</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>densEstBayesVignette()
</code></pre>

<hr>
<h2 id='dMarronWand'>Marron and Wand density function</h2><span id='topic+dMarronWand'></span>

<h3>Description</h3>

<p>Returns ordinates of a member of the family of Normal Mixture density functions devised in Marron and Wand (1992).</p>


<h3>Usage</h3>

<pre><code class='language-R'>dMarronWand(x,densNum,drv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dMarronWand_+3A_x">x</code></td>
<td>
<p>Vector of abscissae values.</p>
</td></tr>
<tr><td><code id="dMarronWand_+3A_densnum">densNum</code></td>
<td>
<p>An integer between 1 and 15 that specifies the density function according to Table 1 of Marron and Wand (1992).</p>
</td></tr>
<tr><td><code id="dMarronWand_+3A_drv">drv</code></td>
<td>
<p>Either -1,0,1,2 depending on the order of the derivative required, with <code>drv = -1</code> corresponding to the anti-derivative. The default value is <code>drv = 0</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt P. Wand <a href="mailto:matt.wand@uts.edu.au">matt.wand@uts.edu.au</a></p>


<h3>References</h3>

<p>Marron, J.S. and Wand, M.P. (1992). Exact mean integrated squared error. <em>The Annals of Statistics</em>, <b>20</b>, 712-736.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(densEstBayes)
xg &lt;- seq(-3,3,length = 1001)
densg &lt;- dMarronWand(xg,8)
plot(xg,densg,type = "l")
</code></pre>

<hr>
<h2 id='incomeUK'>Incomes of United Kingdom citizens</h2><span id='topic+incomeUK'></span>

<h3>Description</h3>

<p>The <code>incomeUK</code> numeric vector has 7,201 incomes of United Kingdom citizens for the year 1975. The data have been divided by average income.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(incomeUK)</code></pre>


<h3>Format</h3>

<p>Each entry of the numeric vector is the ratio of the income of a British citizen and the average income of the sample.
</p>


<h3>Source</h3>

<p>The Economic and Social Research Council Data Archive at the University of Essex, United Kingdom, Family Expenditure Survey, Annual Tapes, 1968-1983, Department of Employment, Statistics Division, Her Majesty's Stationery Office, London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(densEstBayes)
data(incomeUK) 
hist(incomeUK,breaks = 100,col = "gold")

# Obtain and plot ordinary density estimate:

dest &lt;- densEstBayes(incomeUK,method = "SMFVB",
                     control = densEstBayes.control(range.x = c(0,4)))
plot(dest,xlab = "income (multiple of average income)")
rug(incomeUK,col = "dodgerblue",quiet = TRUE)

# Now obtain and plot improved density estimate using log transformation:

destlogScale &lt;- densEstBayes(log(incomeUK),method = "SMFVB",
                          control = densEstBayes.control(range.x = c(-3,1.2)))
plotVecs &lt;- plot(destlogScale,plotIt = FALSE)
xLogScaleg &lt;- plotVecs$xg
densLowLogScaleg &lt;- plotVecs$densLowg
densEstLogScaleg &lt;- plotVecs$densEstg
densUppLogScaleg &lt;- plotVecs$densUppg
xg &lt;- exp(xLogScaleg)
densLowg &lt;- densLowLogScaleg/xg
densEstg &lt;- densEstLogScaleg/xg
densUppg &lt;- densUppLogScaleg/xg
plot(0,xlim = range(xg),ylim = range(c(densLowg,densUppg)),type = "n",bty = "l",
     xlab = "income (multiple of average income)",ylab = "density")
polygon(c(xg,rev(xg)),c(densLowg,rev(densUppg)),
        col="palegreen",border = FALSE)
lines(xg,densEstg,col = "darkgreen",lwd = 2)
abline(0,0,col = "slateblue")
rug(incomeUK,col = "dodgerblue",quiet = TRUE)
</code></pre>

<hr>
<h2 id='OldFaithful2011'>Intervals between geyser eruptions</h2><span id='topic+OldFaithful2011'></span>

<h3>Description</h3>

<p>The <code>OldFaithful2011</code> array has time interval between eruptions (minutes) for all 3,507 eruptions of the Old Faithful Geyser (Yellowstone National Park, U.S.A.) in the year 2011.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OldFaithful2011)</code></pre>


<h3>Format</h3>

<p>Each entry of the array is the time interval in minutes between each geyser eruption in chronological order.
</p>


<h3>Source</h3>

<p>The Geyser Observation and Study Association (www.geyserstudy.org).</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(densEstBayes) ; data(OldFaithful2011) 
hist(OldFaithful2011,breaks = 25,col = "gold",
     xlab = "time interval between geyser eruptions (minutes)")
dest &lt;- densEstBayes(OldFaithful2011,method="SMFVB")
plot(dest,xlab = "time interval between geyser eruptions (minutes)")
rug(OldFaithful2011,col = "dodgerblue",quiet = TRUE)
</code></pre>

<hr>
<h2 id='plot.densEstBayes'>Plot the Bayesian density estimate from a <code>densEstBayes()</code> fit</h2><span id='topic+plot.densEstBayes'></span>

<h3>Description</h3>

<p>The estimated density function obtained via <code>densEstBayes</code> is plotted.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'densEstBayes'
plot(x,plotIt=TRUE,credLev=0.95,gridSize=1001,varBand=TRUE,
                         shade=TRUE,estCol="darkgreen",varBandCol=NULL,
                         axisCol="slateblue",add=FALSE,lwd=2,xlab=NULL,ylab=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.densEstBayes_+3A_x">x</code></td>
<td>
<p>A <code>densEstBayes()</code> fit object.</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_plotit">plotIt</code></td>
<td>
<p>Boolean flag:<br />
TRUE = plot the density estimate and return nothing (the default)<br />
FALSE = do not plot the density estimate and, instead, return a list containing an equally-spaced grid of abscissae values and three grids of ordinate values corresponding to the estimate and lower and uppwer limits of pointwise (100*credLev)% sets.</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_credlev">credLev</code></td>
<td>
<p>The number between 0 and 1 such that the credible interval band has (100*credLev)% approximate pointwise coverage. The default value is 0.95.</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_gridsize">gridSize</code></td>
<td>
<p>The number of grid points used to display the density estimate curve and the pointwise credible interval band. The default value is 1001.</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_varband">varBand</code></td>
<td>
<p>Boolean flag:<br />
TRUE = add a pointwise approximate (100*credLev)% credible set variability band (the default)<br />
FALSE = only plot the density estimate, without a variability band.</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_shade">shade</code></td>
<td>
<p>Boolean flag:<br />
TRUE = display the variability band using shading (the default)<br />
FALSE = display the variability band using dashed curves.</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_estcol">estCol</code></td>
<td>
<p>Colour of the density estimate curve. The default value is &quot;darkgreen&quot;.</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_varbandcol">varBandCol</code></td>
<td>
<p>Colour of the pointwise credible interval variability band. If <code>shade</code>=TRUE then the default value is &quot;palegreen&quot;. If <code>shade</code>=FALSE then the default value is <code>estCol</code>.</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_axiscol">axisCol</code></td>
<td>
<p>colour of the horizontal axis. The default value is &quot;slateblue&quot;.</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_add">add</code></td>
<td>
<p>Boolean flag:<br />
TRUE = add the density estimate curve(s) to an existing plot<br />
FALSE = create a new plot for display of the density estimate (the default).</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_lwd">lwd</code></td>
<td>
<p>A positive integer indicating the line width of plotted curves. The default value is 2.</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_xlab">xlab</code></td>
<td>
<p>A character string spedifying the horizontal axis label.</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_ylab">ylab</code></td>
<td>
<p>A character string specifying the vertical axis label.</p>
</td></tr>
<tr><td><code id="plot.densEstBayes_+3A_...">...</code></td>
<td>
<p>Place-holder for other graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plotIt</code>=TRUE then a plot is produced on the current device and no numerical values are returned. If <code>plotIt</code>=FALSE then a list is returned with the following components:
</p>
<table>
<tr><td><code>xg</code></td>
<td>
<p>numerical vector of abscissae values</p>
</td></tr>
<tr><td><code>densEstg</code></td>
<td>
<p>numerical vector of ordinate values corresponding to the density estimate</p>
</td></tr>
<tr><td><code>densLowg</code></td>
<td>
<p>numerical vector of ordinate values corresponding to the lower limits of the pointwise approximate (100*credLev)% credible set variability band</p>
</td></tr>
<tr><td><code>densUppg</code></td>
<td>
<p>numerical vector of ordinate values corresponding to the upper limits of the pointwise approximate (100*credLev)% credible set variability band</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt P. Wand <a href="mailto:matt.wand@uts.edu.au">matt.wand@uts.edu.au</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(densEstBayes) ; data(OldFaithful2011)

# Obtain a density estimate for the `OldFaithful2011' data:

dest &lt;- densEstBayes(OldFaithful2011,method = "SMFVB")

# Plot the density estimate using default settings:

plot(dest,xlab = "time interval between geyser eruptions (minutes)")
rug(jitter(OldFaithful2011,amount=0.2),col = "dodgerblue")

# Plot the density estimate with some user-specified settings:

plot(dest,credLev = 0.999,estCol = "purple",
     varBandCol = "pink",axisCol = "navy",
     xlab = "time interval between geyser eruptions (minutes)")
rug(jitter(OldFaithful2011,amount= 0.2),col = "darkkhaki")

# Plot the density estimate as a black and white line plot:

plot(dest,estCol = "black",shade = FALSE,axisCol = "black",
     xlab = "time interval between geyser eruptions (minutes)")
rug(jitter(OldFaithful2011,amount = 0.2))
</code></pre>

<hr>
<h2 id='predict.densEstBayes'>Obtain the Bayesian density estimate from a <code>densEstBayes()</code> fit at new abscissae</h2><span id='topic+predict.densEstBayes'></span>

<h3>Description</h3>

<p>Values of the estimated density function, obtained via <code>densEstBayes</code>, are computed for new abscissae.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'densEstBayes'
predict(object,newdata,cred.fit = FALSE,credLev = 0.95,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.densEstBayes_+3A_object">object</code></td>
<td>
<p>A <code>densEstBayes()</code> fit object.</p>
</td></tr>
<tr><td><code id="predict.densEstBayes_+3A_newdata">newdata</code></td>
<td>
<p>A numerical vector of abscissae values.</p>
</td></tr>
<tr><td><code id="predict.densEstBayes_+3A_cred.fit">cred.fit</code></td>
<td>
<p>Boolean flag:<br />
TRUE = compute the lower and upper limits of (100*credLev)% pointwise credible intervals at 'newdata',<br />
FALSE = do not computer credible interval limits (the default).</p>
</td></tr>
<tr><td><code id="predict.densEstBayes_+3A_credlev">credLev</code></td>
<td>
<p>number between 0 and 1 such that the credible interval band has (100*credLev)% approximate coverage. The default value is 0.95.</p>
</td></tr>
<tr><td><code id="predict.densEstBayes_+3A_...">...</code></td>
<td>
<p>A place-holder for other prediction parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned with the following components:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>numerical vector of ordinate values corresponding to the density estimate.</p>
</td></tr>
<tr><td><code>credLow.fit</code></td>
<td>
<p>numerical vector of ordinate values corresponding to the lower limits of the pointwise approximate (100*credLev)% credible set variability band.</p>
</td></tr>
<tr><td><code>credUpp.fit</code></td>
<td>
<p>numerical vector of ordinate values corresponding to the upper limits of the pointwise approximate (100*credLev)% credible set variability band.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt P. Wand <a href="mailto:matt.wand@uts.edu.au">matt.wand@uts.edu.au</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(densEstBayes) ; data(OldFaithful2011)

# Obtain a density estimate for the `OldFaithful2011' data:

dest &lt;- densEstBayes(OldFaithful2011,method = "SMFVB")

# Plot the density estimate:

plot(dest,xlab = "time interval between geyser eruptions (minutes)")
rug(jitter(OldFaithful2011,amount = 0.2),col = "dodgerblue")

# Obtain predictions at 60,70,80,90,100 and 110 seconds and
# add to them plot:

newdataVec &lt;- seq(60,110,by = 10)
predictObj &lt;- predict(dest,newdata = newdataVec,cred.fit = TRUE)
print(predictObj$fit)
points(newdataVec,predictObj$fit,col = "blue")

# Print and add to the plot the lower and upper limits of 
# the pointwise 95% credible intervals:

print(predictObj$credLow.fit)
print(predictObj$credUpp.fit)
points(newdataVec,predictObj$credLow.fit,col = "red")
points(newdataVec,predictObj$credUpp.fit,col = "red")
</code></pre>

<hr>
<h2 id='rMarronWand'>Marron and Wand random sample</h2><span id='topic+rMarronWand'></span>

<h3>Description</h3>

<p>Returns a random sample from a member of the family of Normal Mixture density functions devised in Marron and Wand (1992).</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMarronWand(n,densNum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMarronWand_+3A_n">n</code></td>
<td>
<p>The sample size, which is a positive integer.</p>
</td></tr>
<tr><td><code id="rMarronWand_+3A_densnum">densNum</code></td>
<td>
<p>An integer between 1 and 15 that specifies the density function according to Table 1 of Marron and Wand (1992).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt P. Wand <a href="mailto:matt.wand@uts.edu.au">matt.wand@uts.edu.au</a></p>


<h3>References</h3>

<p>Marron, J.S. and Wand, M.P. (1992). Exact mean integrated squared error. <em>The Annals of Statistics</em>, <b>20</b>, 712-736.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(densEstBayes)
x &lt;- rMarronWand(1000,8)
hist(x,breaks = 50,col = "gold")
dest &lt;- densEstBayes(x,method = "SMFVB")
plot(dest) ; rug(x,col = "dodgerblue",quiet = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
