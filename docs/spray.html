<!DOCTYPE html><html><head><title>Help for package spray</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spray}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spray-package'>
<p>Sparse arrays and multivariate polynomials</p></a></li>
<li><a href='#arity'>
<p>The arity of a spray object</p></a></li>
<li><a href='#as.array'><p>Coerce spray objects to arrays</p></a></li>
<li><a href='#as.character'><p>Coerce spray objects to character</p></a></li>
<li><a href='#as.function.spray'><p>Coerce a spray object to a function</p></a></li>
<li><a href='#asum'>
<p>Sum over dimension margins</p></a></li>
<li><a href='#constant'>
<p>Get or set the constant term of a spray object</p></a></li>
<li><a href='#deriv'>
<p>Partial differentiation of spray objects</p></a></li>
<li><a href='#Extract.spray'><p>Extract or Replace Parts of a spray</p></a></li>
<li><a href='#homog'>
<p>Various functions to create simple spray objects</p></a></li>
<li><a href='#knight'>
<p>Generating function for a chess knight and king</p></a></li>
<li><a href='#nterms'><p>Number of nonzero terms in a <code>spray</code> object</p></a></li>
<li><a href='#ooom'><p>One-over-one-minus for spray objects</p></a></li>
<li><a href='#Ops.spray'><p>Arithmetic Ops Group Methods for sprays</p></a></li>
<li><a href='#pmax'><p>Parallel maxima and minima for sprays</p></a></li>
<li><a href='#print.spray'>
<p>Print methods for spray objects</p></a></li>
<li><a href='#rspray'>
<p>Random spray objects</p></a></li>
<li><a href='#spray'>
<p>Sparse arrays: <code>spray</code> objects</p></a></li>
<li><a href='#spray_cpp'>
<p>Low-level functions that call C++ source code</p></a></li>
<li><a href='#spray_missing_accessor'><p>Discussion document</p></a></li>
<li><a href='#spray-class'><p>Class &ldquo;spray&rdquo;</p></a></li>
<li><a href='#spraycross'><p>Cross product for spray objects</p></a></li>
<li><a href='#subs'><p>Substitute values into a spray object</p></a></li>
<li><a href='#summary.spray'><p>Summaries of spray objects</p></a></li>
<li><a href='#zap'><p>Zap small values in a spray object</p></a></li>
<li><a href='#zero'>
<p>The zero polynomial</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Arrays and Multivariate Polynomials</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-25</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Sparse arrays interpreted as multivariate polynomials.
    Uses 'disordR' discipline (Hankin, 2022,
    &lt;<a href="https://doi.org/10.48550%2FARXIV.2210.03856">doi:10.48550/ARXIV.2210.03856</a>&gt;).  To cite the package in
    publications please use Hankin (2022) &lt;<a href="https://doi.org/10.48550%2FARXIV.2210.10848">doi:10.48550/ARXIV.2210.10848</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>polynom, testthat, covr</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.3),partitions,magic,mathjaxr,disordR (&ge; 0.9-6)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/spray">https://github.com/RobinHankin/spray</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/spray/issues">https://github.com/RobinHankin/spray/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 08:13:38 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-12 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spray-package'>
Sparse arrays and multivariate polynomials
</h2><span id='topic+spray-package'></span>

<h3>Description</h3>

<p>Functionality for sparse arrays, with emphasis on their interpretation
as multivariate polynomials.
</p>


<h3>Details</h3>

<p>Base <span class="rlang"><b>R</b></span> has the capability of dealing with arbitrary dimensioned
numerical arrays, with the <code>array</code> class.
</p>
<p>A <dfn>sparse array</dfn> is a type of array in which nonzero elements are
stored along with an index vector describing their coordinates.  This
allows for efficient storage and manipulation as base arrays often
require the storing of many zero elements which consume computational
and memory resources.
</p>
<p>In the package, sparse arrays are represented as objects of class
<code>spray</code>.  They use the C++ standard template library
(STL) <code>map</code> class, with keys being (unsigned) integer vectors, and
values floats.
</p>
<p>One natural application of sparse arrays, for which the package was
written, is multivariate polynomials and the package vignette presents
an extended discussion.  Note that other interpretations exist: the
<a href="https://CRAN.R-project.org/package=stokes"><span class="pkg">stokes</span></a> and <a href="https://CRAN.R-project.org/package=weyl"><span class="pkg">weyl</span></a> packages interpret <code>spray</code>
objects as differential forms and elements of a Weyl algebra
respectively.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define a spray using a matrix of indices and a vector of values:
M &lt;- matrix(sample(0:3,21,replace=TRUE),ncol=3)
a &lt;- spray(M,sample(7))

# there are many pre-defined simple sprays:
b &lt;- homog(3,4)

# arithmetic operators work:
a + 2*b
a - a*b^2/4
a+b

#  we can sum over particular dimensions:
asum(a+b,1)

# differentiation is supported:
deriv(a^6,2)

# extraction and replacement work as expected:

b[1,2,1]
b[1,2,1,drop=TRUE]

b[diag(3)] &lt;- 3



</code></pre>

<hr>
<h2 id='arity'>
The arity of a spray object
</h2><span id='topic+arity'></span>

<h3>Description</h3>

<p>The arity of a spray object: the number of indices needed to retrieve an
entry, or the number of columns in the index matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arity(S)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arity_+3A_s">S</code></td>
<td>
<p>a spray object</p>
</td></tr></table>


<h3>Value</h3>

<p>Returns an integer</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>(a &lt;- rspray())
arity(a)

</code></pre>

<hr>
<h2 id='as.array'>Coerce spray objects to arrays
</h2><span id='topic+as.array'></span><span id='topic+as.array.spray'></span><span id='topic+dim.spray'></span>

<h3>Description</h3>

<p>Coerces spray objects to arrays.  Includes off-by-one functionality via
option <code>offbyone</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spray'
as.array(x, offbyone=FALSE, compact=FALSE, ...)
## S3 method for class 'spray'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.array_+3A_x">x</code></td>
<td>
<p>spray object</p>
</td></tr>
<tr><td><code id="as.array_+3A_offbyone">offbyone</code></td>
<td>
<p>Boolean with default <code>FALSE</code> meaning to interpret
the index entries as positions in their dimension, and <code>TRUE</code>
meaning to add one to index values so that zero entries appear in
the first place</p>
</td></tr>
<tr><td><code id="as.array_+3A_compact">compact</code></td>
<td>
<p>Boolean with default <code>FALSE</code> meaning to translate
the spray as is, and <code>TRUE</code> meaning to add constants to each
column of the index matrix so that the resulting array is as small
as possible</p>
</td></tr>
<tr><td><code id="as.array_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>offbyone</code> defaults to <code>FALSE</code>; but if it is set to
<code>TRUE</code>, it effectively adds one from the index matrix, so a zero
entry in the index matrix means the first position in that dimension.
</p>
<p>After the subtraction, if performed, the function will not operate if
any index is less than 1.
</p>


<h3>Value</h3>

<p>Returns an array of dimension <code>dim(S)</code>.  The &ldquo;meat&rdquo; of the
function is
</p>
<pre>
    out &lt;- array(0, dS)
    out[ind] &lt;- coeffs(S)
</pre>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(M &lt;- matrix(sample(0:4,28,replace=TRUE),ncol=4))
(S &lt;- spray(M,sample(7),addrepeats=TRUE))
as.array(S,offbyone=TRUE)      # a large object!  sprays are terse


S &lt;- spray(matrix(sample(1:4,28,replace=TRUE),ncol=4),sample(7))
A &lt;- as.array(S)   # S has no zero indices [if it did, we would need to use offbyone=TRUE]

stopifnot(all(S[index(S),drop=TRUE] == A[index(S)])) 
</code></pre>

<hr>
<h2 id='as.character'>Coerce spray objects to character</h2><span id='topic+as.character'></span><span id='topic+as.character.spray'></span>

<h3>Description</h3>

<p>Coerces spray objects to a character string or <code>disord</code> character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spray'
as.character(x, ..., split=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character_+3A_x">x</code></td>
<td>
<p>spray object</p>
</td></tr>
<tr><td><code id="as.character_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
<tr><td><code id="as.character_+3A_split">split</code></td>
<td>
<p>Boolean with default <code>FALSE</code> meaning to return a
length-one character vector, and <code>TRUE</code> meaning to return a
<code>disord</code> object with elements being terms, coerced to
character</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method uses <code>print_spray_polyform()</code> and as such is sensitive
to option <code>sprayvars</code>, but not <code>polyform</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.character(rspray())
as.character(rspray(),split=TRUE)
</code></pre>

<hr>
<h2 id='as.function.spray'>Coerce a spray object to a function</h2><span id='topic+as.function.spray'></span>

<h3>Description</h3>

<p>Coerce a spray object to a function</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spray'
as.function(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.function.spray_+3A_x">x</code></td>
<td>
<p>spray object, interpreted as a multivariate polynomial</p>
</td></tr>
<tr><td><code id="as.function.spray_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function; this function returns a numeric vector.
</p>


<h3>Note</h3>

<p>Coercion is possible even if some indices are zero or negative.  The
function is not vectorized in the arity of its argument.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(S &lt;- spray(matrix(1:6,3,2),1:3))
(f &lt;- as.function(S))
f(2:3) == 3*2^3*3^6 + 2*2^2*3^5 + 1*2^1*3^4  # should be TRUE


S1 &lt;- spray(matrix(sample(-2:2,replace=TRUE,21),ncol=3),rnorm(7),addrepeats=TRUE)
S2 &lt;- spray(matrix(sample(-2:2,replace=TRUE,15),ncol=3),rnorm(5),addrepeats=TRUE)

f1 &lt;- as.function(S1)
f2 &lt;- as.function(S2)

f3 &lt;- as.function(S1*S2)


x &lt;- 4:6

f1(x)*f2(x)-f3(x)  # should be zero



# coercion is vectorized:

f1(matrix(1:33,ncol=3))
  
</code></pre>

<hr>
<h2 id='asum'>
Sum over dimension margins
</h2><span id='topic+asum'></span><span id='topic+asum.spray'></span><span id='topic+asum_inverted'></span><span id='topic+process_dimensions'></span>

<h3>Description</h3>

<p>Sum over specified dimension margins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spray'
asum(S, dims, drop=TRUE, ...)
asum_inverted(S, dims)
process_dimensions(S,dims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asum_+3A_s">S</code></td>
<td>
<p>spray object</p>
</td></tr>
<tr><td><code id="asum_+3A_dims">dims</code></td>
<td>
<p>Vector of strictly positive integers corresponding to
dimensions to be summed over
</p>
</td></tr>
<tr><td><code id="asum_+3A_drop">drop</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to drop the
summed dimensions, and <code>FALSE</code> meaning to retain them.
</p>
</td></tr>
<tr><td><code id="asum_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>asum.spray()</code> is the method for <code>asum()</code>.  This
takes a spray, and a vector of integers corresponding to dimensions to
be summed over.
</p>
<p>Function <code>asum_inverted()</code> is the same, but takes a vector of
integers corresponding to dimensions not to sum over.  This function is
here because  there is nice <code>C++</code> idiom for it.
</p>
<p>Function <code>process_dimensions()</code> ensures that the <code>dims</code>
argument is consistent with the spray <code>S</code> and returns a cleaned
version thereof.
</p>


<h3>Value</h3>

<p>Returns a spray object.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
S &lt;- spray(matrix(sample(0:2,60,replace=TRUE),ncol=3),addrepeats=TRUE)
S

asum(S,1)
asum(S,1:2)

asum(S,1:2,drop=FALSE)


asum(S,c(1,3)) == asum_inverted(S,2)


</code></pre>

<hr>
<h2 id='constant'>
Get or set the constant term of a spray object
</h2><span id='topic+constant'></span><span id='topic+is.constant'></span><span id='topic+scalar'></span><span id='topic+is.scalar'></span><span id='topic+constant'></span><span id='topic+const'></span><span id='topic+constant.spray'></span><span id='topic+constant+2Cspray-method'></span><span id='topic+constant+3C-'></span><span id='topic+constant+3C-.spray'></span><span id='topic+constant+3C-+2Cspray-method'></span><span id='topic+drop'></span><span id='topic+drop+2Cspray-method'></span>

<h3>Description</h3>

<p>The constant term of a spray object is the coefficient corresponding to
an index of all zeros.  These functions get or set the constant of a
spray object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.constant(x)
constant(x,drop=FALSE)
constant(x) &lt;- value
drop(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constant_+3A_x">x</code></td>
<td>
<p>Object of class spray</p>
</td></tr>
<tr><td><code id="constant_+3A_value">value</code></td>
<td>
<p>Numeric value to set the constant coefficient to</p>
</td></tr>
<tr><td><code id="constant_+3A_drop">drop</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return a
spray object and <code>TRUE</code> meaning to return a numeric value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In function <code>constant()</code>, return the coefficient, or a constant
multivariate polynomial, depending on the value of <code>drop</code>.
</p>


<h3>Note</h3>

<p>The behaviour of the <code>drop</code> argument (sort of) matches that of the
spray extractor method.  Function <code>drop()</code> returns the elements of
the coefficients.
</p>
<p>Function <code>constant()</code> ensures that zero spray objects retain the
argument's arity.
</p>
<p>It might have been better to call <code>is.constant()</code>
<code>is.scalar()</code>, for consistency with the <code>stokes</code> and
<code>clifford</code> packages.  But this is not clear.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Extract">Extract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(S &lt;- spray(partitions::blockparts(rep(2,3),3,TRUE)))

constant(S)
constant(S) &lt;- 33

S

drop(constant(S,drop=FALSE))
</code></pre>

<hr>
<h2 id='deriv'>
Partial differentiation of spray objects
</h2><span id='topic+deriv'></span><span id='topic+deriv.spray'></span><span id='topic+aderiv'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Partial differentiation of spray objects interpreted as multivariate
polynomials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spray'
deriv(expr, i , derivative = 1, ...)
aderiv(S,orders)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_+3A_expr">expr</code></td>
<td>
<p>A spray object, interpreted as a multivariate polynomial</p>
</td></tr>
<tr><td><code id="deriv_+3A_i">i</code></td>
<td>
<p>Dimension to differentiate with respect to</p>
</td></tr>
<tr><td><code id="deriv_+3A_derivative">derivative</code></td>
<td>
<p>How many times to differentiate</p>
</td></tr>
<tr><td><code id="deriv_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
<tr><td><code id="deriv_+3A_s">S</code></td>
<td>
<p>spray object</p>
</td></tr>
<tr><td><code id="deriv_+3A_orders">orders</code></td>
<td>
<p>The orders of the differentials</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>deriv.spray()</code> is the method for generic <code>spray()</code>;
if <code>S</code> is a spray object, then <code>spray(S,i,n)</code> returns
\(\partial^n S/\partial x_i^n =
S^{\left(x_i,\ldots,x_i\right)}\).
</p>
<p>Function <code>aderiv()</code> is the generalized derivative; if <code>S</code> is a
spray of arity 3, then <code>aderiv(S,c(i,j,k))</code> returns
\(\frac{\partial^{i+j+k} S}{\partial x_1^i\partial x_2^j\partial
x_3^k}\).
</p>


<h3>Value</h3>

<p>Both functions return a spray object.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asum">asum</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

(S &lt;- spray(matrix(sample(-2:2,15,replace=TRUE),ncol=3),addrepeats=TRUE))

deriv(S,1)
deriv(S,2,2)

# differentiation is invariant under order:
aderiv(S,1:3) == deriv(deriv(deriv(S,1,1),2,2),3,3)

# Leibniz's rule:
S1 &lt;- spray(matrix(sample(0:3,replace=TRUE,21),ncol=3),sample(7),addrepeats=TRUE)
S2 &lt;- spray(matrix(sample(0:3,replace=TRUE,15),ncol=3),sample(5),addrepeats=TRUE)

S1*deriv(S2,1) + deriv(S1,1)*S2 == deriv(S1*S2,1)

# Generalized Leibniz:
aderiv(S1*S2,c(1,1,0)) == (
aderiv(S1,c(0,0,0))*aderiv(S2,c(1,1,0)) +
aderiv(S1,c(0,1,0))*aderiv(S2,c(1,0,0)) +
aderiv(S1,c(1,0,0))*aderiv(S2,c(0,1,0)) +
aderiv(S1,c(1,1,0))*aderiv(S2,c(0,0,0)) 
)

</code></pre>

<hr>
<h2 id='Extract.spray'>Extract or Replace Parts of a spray</h2><span id='topic++5B.spray'></span><span id='topic+extract.spray'></span><span id='topic+extract'></span><span id='topic+replace.spray'></span><span id='topic+replace'></span><span id='topic++5B+3C-.spray'></span><span id='topic+spray_extract_disord'></span><span id='topic+spray_replace_disord'></span>

<h3>Description</h3>

<p>Extract or replace subsets of sprays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spray'
S[..., drop=FALSE]
## S3 replacement method for class 'spray'
S[index, ...] &lt;- value
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.spray_+3A_s">S</code></td>
<td>
<p>A spray object</p>
</td></tr>
<tr><td><code id="Extract.spray_+3A_index">index</code></td>
<td>
<p>elements to extract or replace</p>
</td></tr>
<tr><td><code id="Extract.spray_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
<tr><td><code id="Extract.spray_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
<tr><td><code id="Extract.spray_+3A_drop">drop</code></td>
<td>
<p>Boolean, with default <code>FALSE</code>  meaning to return a
spray object and <code>TRUE</code> meaning to drop the spray structure and
return a numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods should work as expected, although the off-by-one issue
might be a gotcha.  <a href="https://CRAN.R-project.org/package=disordR"><span class="pkg">disordR</span></a> discipline is enforced where
appropriate.
</p>
<p>In <code>S[index,...]</code>, argument <code>drop</code> is <code>FALSE</code> by
default, in which case a <code>spray</code> object is returned.  If
<code>drop</code> is <code>TRUE</code> a numeric vector is returned, with elements
corresponding to the rows of <code>index</code>.  Compare <code>coeffs(S)</code>,
which returns a <code>disord</code> object; in <code>S[index,drop=TRUE]</code>,
the rows of <code>index</code> specify a unique order for the return value.
</p>
<p>If <code>a &lt;- spray(diag(3))</code>, for example, then idiom such as
<code>a[c(1,2,3)]</code> cannot work, because one would like <code>a[1,2,3]</code>
and <code>a[1:3,2,3]</code> to work.
</p>
<p>If <code>p &lt;- 1:3</code>, then one might expect idiom such as
<code>S[1,,p,1:3]</code> to work but this is problematic and a discussion is
given in <code>inst/missing_accessor.txt</code>.
</p>
<p>Functions <code>spray_extract_disord()</code> and
<code>spray_replace_disord()</code> are low-level helper functions which
implement idiom such as <code>a[coeffs(a) &lt; 3]</code> and<code>a[coeffs(a) &lt;
  3] &lt;- 99</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(a &lt;- spray(diag(5)))
a[rbind(rep(1,5))] &lt;- 5
a

a[3,4,5,3,1]  # the NULL polynomial

a[0,1,0,0,0]
a[0,1,0,0,0,drop=TRUE]

a[2,3:5,4,3,3] &lt;- 9
a

options(polyform = TRUE)   # print as a multivariate polynomial
a

options(polyform = FALSE)  # print in sparse array form
a

(S1 &lt;- spray(diag(5),1:5))
(S2 &lt;- spray(1-diag(5),11:15))
(S3 &lt;- spray(rbind(c(1,0,0,0,0),c(1,2,1,1,1))))

S1[] &lt;- 3
S1[] &lt;- S2

S1[S3] &lt;- 99
S1

S &lt;- rspray()
S[coeffs(S) &gt; 4]
S[coeffs(S) &lt; 6] &lt;- 99
S


</code></pre>

<hr>
<h2 id='homog'>
Various functions to create simple spray objects
</h2><span id='topic+homog'></span><span id='topic+product'></span><span id='topic+homog'></span><span id='topic+linear'></span><span id='topic+lone'></span><span id='topic+one'></span><span id='topic+as.id'></span><span id='topic+as.id.spray'></span><span id='topic+xyz'></span>

<h3>Description</h3>

<p>Various functions to create simple spray objects such as single-term,
homogeneous, and constant multivariate polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>product(power)
homog(d,power=1)
linear(x,power=1)
lone(n,d=n)
one(d)
as.id(S)
xyz(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homog_+3A_d">d</code></td>
<td>
<p>An integer; generally, the dimension or arity of the resulting spray object</p>
</td></tr>
<tr><td><code id="homog_+3A_power">power</code></td>
<td>
<p>Integer vector of powers</p>
</td></tr>
<tr><td><code id="homog_+3A_x">x</code></td>
<td>
<p>Numeric vector of coefficients</p>
</td></tr>
<tr><td><code id="homog_+3A_s">S</code></td>
<td>
<p>A spray object</p>
</td></tr>
<tr><td><code id="homog_+3A_n">n</code></td>
<td>
<p>In function <code>lone()</code>, the term to raise to power 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All functions documented here return a spray object
</p>


<h3>Note</h3>

<p>The functions here are related to their equivalents in the
<a href="https://CRAN.R-project.org/package=multipol"><span class="pkg">multipol</span></a> package, but are not exactly the same.
</p>
<p>Function <code>zero()</code> is documented at <code>zero.Rd</code>, but is listed
below for convenience.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constant">constant</a></code>, <code><a href="#topic+zero">zero</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>product(1:3)                   #      x * y^2 * z^3
homog(3)                       #      x + y + z
homog(3,2)                     #      x^2  + xy + xz + y^2 + yz + z^2
linear(1:3)                    #      1*x + 2*y + 3*z
linear(1:3,2)                  #      1*x^2 + 2*y^2 + 3*z^2
lone(3)                        #      z
lone(2,3)                      #      y
one(3)                         #      1
zero(3)                        #      0
xyz(3)                         #      xyz
</code></pre>

<hr>
<h2 id='knight'>
Generating function for a chess knight and king
</h2><span id='topic+knight'></span><span id='topic+king'></span><span id='topic+chess_knight'></span>

<h3>Description</h3>

<p>Generating function for a chess knight and king on an
arbitrarily-dimensioned chessboard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knight(d=2)
king(d=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knight_+3A_d">d</code></td>
<td>
<p>Dimensionality of the board, defaulting to 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the generating function of the piece in question.
</p>


<h3>Note</h3>

<p>The pieces are forced to move; if they have the option of not moving,
add 1 to the returned spray.  The vignette contains a short discussion.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
knight()  # default 2D chess board
king()    # ditto

knight()^2  # generating function for two knight's moves

## How many ways can a knight return to its starting square in 6 moves?
constant(knight()^6)

## How many in 6 or fewer?
constant((1+knight())^6)

## Where does a randomly-moving knight end up?
d &lt;- xyz(2)
kt &lt;- (1+knight())*d^2/9
persp(1:25,1:25,as.array(d*kt^6))


## what is the probability that a 4D king is a knight's move from
##   (0,0,0,0) after 6 moves?

sum(coeffs(((king(4)/80)^4)[knight(4)]))

</code></pre>

<hr>
<h2 id='nterms'>Number of nonzero terms in a <code>spray</code> object</h2><span id='topic+nterms'></span><span id='topic+length'></span><span id='topic+length.spray'></span>

<h3>Description</h3>

<p>Number of nonzero terms in a <code>spray</code> object</p>


<h3>Usage</h3>

<pre><code class='language-R'>nterms(x)
## S3 method for class 'spray'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nterms_+3A_x">x</code></td>
<td>
<p>Object of class <code>spray</code></p>
</td></tr></table>


<h3>Details</h3>

<p>Number of nonzero terms in a <code>spray</code> object.  Function
<code>length()</code> is defined so that <code>seq_along()</code> works as
expected
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(a &lt;- rspray())
nterms(a)


seq_along(a)
</code></pre>

<hr>
<h2 id='ooom'>One-over-one-minus for spray objects</h2><span id='topic+ooom'></span>

<h3>Description</h3>

<p>One-over-one-minus for spray objects; the nearest to &lsquo;division&rsquo;
that we can get.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ooom(S, n)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ooom_+3A_s">S</code></td>
<td>
<p>object of class spray</p>
</td></tr>
<tr><td><code id="ooom_+3A_n">n</code></td>
<td>
<p>Order of the approximation</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Returns the Taylor expansion to order <code class="reqn">n</code> of \(1/(1-S)\), that
is, \(1+S+S^2+S^3+\cdots +S^n\).
</p>


<h3>Value</h3>

<p>Returns a spray object of the same arity as <code>S</code>.</p>


<h3>Note</h3>

<p>Uses Horner's method for efficiency</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(x &lt;- spray(matrix(1)))
ooom(x,5)  # 1 + x + x^2 + x^3 + x^4 + x^5


(a &lt;- homog(4,2))
d &lt;- (1-a)*ooom(a,3)

constant(d)    # should be 1
rowSums(index(d))   # a single 0 and lots of 8s.
</code></pre>

<hr>
<h2 id='Ops.spray'>Arithmetic Ops Group Methods for sprays</h2><span id='topic+Ops.spray'></span><span id='topic+Ops'></span><span id='topic+spray_negative'></span><span id='topic+spray_times_spray'></span><span id='topic+spray_times_scalar'></span><span id='topic+spray_plus_spray'></span><span id='topic+spray_plus_scalar'></span><span id='topic+spray_power_scalar'></span><span id='topic+spray_eq_spray'></span><span id='topic+spray_eq_numeric'></span>

<h3>Description</h3>

<p>Allows arithmetic operators to be used for spray calculations, 
such as addition, multiplication, division, integer powers, etc.
Objects of class spray are interpreted as sparse multivariate polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spray'
Ops(e1, e2 = NULL)
spray_negative(S)
spray_times_spray(S1,S2)
spray_times_scalar(S,x)
spray_plus_spray(S1,S2)
spray_plus_scalar(S,x)
spray_power_scalar(S,n)
spray_eq_spray(S1,S2)
spray_eq_numeric(S1,x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.spray_+3A_e1">e1</code>, <code id="Ops.spray_+3A_e2">e2</code>, <code id="Ops.spray_+3A_s">S</code>, <code id="Ops.spray_+3A_s1">S1</code>, <code id="Ops.spray_+3A_s2">S2</code></td>
<td>
<p>Objects of class spray, here interpreted as
sparse multivariate polynomials</p>
</td></tr>
<tr><td><code id="Ops.spray_+3A_x">x</code></td>
<td>
<p>Real valued scalar</p>
</td></tr>
<tr><td><code id="Ops.spray_+3A_n">n</code></td>
<td>
<p>Non-negative integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Ops.spray()</code> passes unary and binary arithmetic
operators (&ldquo;<code>+</code>&rdquo;, &ldquo;<code>-</code>&rdquo;, &ldquo;<code>*</code>&rdquo;,
&ldquo;<code>/</code>&rdquo;,&ldquo;<code>==</code>&rdquo;, and &ldquo;<code>^</code>&rdquo;) to the
appropriate specialist function.
</p>
<p>The most interesting operators are &ldquo;<code>*</code>&rdquo; and
&ldquo;<code>+</code>&rdquo; which execute multivariate polynomial multiplication
and addition respectively.
</p>
<p>Testing for equality uses <code>spray_eq_spray()</code>.  Note that
<code>spray_eq_spray(S1,S2)</code> is algebraically equivalent to
<code>is.zero(S1-S2)</code>, but faster (<code>FALSE</code> is returned as soon as
a mismatch is found).
</p>


<h3>Value</h3>

<p>The functions all return spray objects except  &ldquo;<code>==</code>&rdquo;, which
returns a logical.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ooom">ooom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

M &lt;- matrix(sample(0:3,21,replace=TRUE),ncol=3)
a &lt;- spray(M,sample(7))
b &lt;- homog(3,4)


# arithmetic operators mostly work as expected:
a + 2*b
a - a*b^2/4
a+b

S1 &lt;- spray(partitions::compositions(4,3))
S2 &lt;- spray(diag(3))  # S2 = x+y+z


stopifnot( (S1+S2)^3 == S1^3 + 3*S1^2*S2 + 3*S1*S2^2 + S2^3 )






</code></pre>

<hr>
<h2 id='pmax'>Parallel maxima and minima for sprays</h2><span id='topic+pmax'></span><span id='topic+pmin'></span><span id='topic+maxpair_spray'></span><span id='topic+minpair_spray'></span><span id='topic+pmax.spray'></span><span id='topic+pmin.spray'></span><span id='topic+pmax.default'></span><span id='topic+pmin.default'></span>

<h3>Description</h3>

<p>Parallel (pairwise) maxima and minima for sprays. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxpair_spray(S1,S2)
minpair_spray(S1,S2)
## S3 method for class 'spray'
pmax(x, ...)
## S3 method for class 'spray'
pmin(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmax_+3A_x">x</code>, <code id="pmax_+3A_s1">S1</code>, <code id="pmax_+3A_s2">S2</code></td>
<td>
<p>Spray objects</p>
</td></tr>
<tr><td><code id="pmax_+3A_...">...</code></td>
<td>
<p>spray objects to be compared</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Function <code>maxpair_spray()</code> finds the pairwise maximum for two
sprays.  Specifically, if <code>S3 &lt;- maxpair_spray(S1,S2)</code>, then
<code>S3[v] == max(S1[v],S2[v])</code> for every index vector <code>v</code>.
</p>
<p>Function <code>pmax.spray()</code> is the method for the generic
<code>pmax()</code>, which takes any number of arguments.  If <code>S3 &lt;-
maxpair_spray(S1,S2,...)</code>, then <code>S3[v] == max(S1[v],S2[v],...)</code> for
every index vector <code>v</code>.
</p>
<p>Function <code>pmax.spray()</code> operates right-associatively:
</p>
<p><code>pmax(S1,S2,S3,S4) == f(S1,f(S2,f(S3,S4)))</code> where <code>f()</code> is
short for <code>maxpair_spray()</code>.  So if performance is important, put
the smallest spray (in terms of number of nonzero entries) last.
</p>
<p>In these functions, a scalar is interpreted as a sort of global maximum.
Thus if <code>S3 &lt;- pmax(S,x)</code> we have <code>S3[v] == max(S[v],x)</code> for
every index <code>v</code>.  Observe that this operation is not defined if
<code>x&gt;0</code>, for then there would be an infinity of <code>v</code> for which
<code>S3[v] != 0</code>, an impossibility (or at least counter to the
principles of a sparse array).  Note also that <code>x</code> cannot have
length \(>1\) as the elements of a spray object are stored in an
arbitrary order, following <code>disordR</code> discipline.
</p>
<p>Functions <code>minpair_spray()</code> and <code>pmin.spray()</code> are analogous.
Note that <code>minpair_spray(S1,S2)</code> is algebraically equivalent to
<code>-pmax_spray(-S1,-S2)</code>; see the examples.
</p>
<p>The value of <code>pmax(S)</code> is problematic.  Suppose
<code>all(coeffs(S)&lt;0)</code>; the current implementation returns
<code>pmax(S)==S</code> but there is a case for returning the null polynomial.
</p>


<h3>Value</h3>

<p>Returns a spray object</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
S1 &lt;- rspray(100,vals=sample(100)-50)
S2 &lt;- rspray(100,vals=sample(100)-50)
S3 &lt;- rspray(100,vals=sample(100)-50)


# following comparisons should all be TRUE:

jj &lt;- pmax(S1,S2,S3)
jj ==  maxpair_spray(S1,maxpair_spray(S2,S3))
jj ==  maxpair_spray(maxpair_spray(S1,S2),S3)

pmax(S1,S2,S3)  == -pmin(-S1,-S2,-S3)
pmin(S1,S2,S3)  == -pmax(-S1,-S2,-S3)

pmax(S1,-Inf) == S1
pmin(S1, Inf) == S2


pmax(S1,-3)

## Not run: 
pmax(S1,3) # not defined

## End(Not run)


</code></pre>

<hr>
<h2 id='print.spray'>
Print methods for spray objects
</h2><span id='topic+print.spray'></span><span id='topic+sprayvars'></span><span id='topic+print_spray_matrixform'></span><span id='topic+print_spray_polyform'></span>

<h3>Description</h3>

<p>Print methods for spray objects with options for printing in matrix form
or multivariate polynomial form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spray'
print(x, ...)
print_spray_matrixform(S)
print_spray_polyform(S,give=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spray_+3A_x">x</code>, <code id="print.spray_+3A_s">S</code></td>
<td>
<p>spray object</p>
</td></tr>
<tr><td><code id="print.spray_+3A_give">give</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to print the
value of <code>S</code>, and <code>TRUE</code> meaning to return a string
(without nice formatting); used in <code>as.character.spray()</code></p>
</td></tr>
<tr><td><code id="print.spray_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print method, <code>print.spray()</code>, dispatches to helper functions
<code>print_spray_matrixform()</code> and <code>print_spray_polyform()</code>
depending on the value of option <code>polyform</code>; see the examples
section.
</p>
<p>Option <code>sprayvars</code> is a character vector with entries
corresponding to the variable names for printing.  The <code>sprayvars</code>
option has no algebraic significance: all it does is affect the print
method.
</p>
<p>Note that printing a spray object (in either matrix form or polynomial
form) generally takes much longer than calculating it.
</p>


<h3>Value</h3>

<p>Returns its argument invisibly.</p>


<h3>Note</h3>

<p>There are a couple of hard-wired symbols for multiplication and
equality which are defined near the top of the helper functions.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(a &lt;- spray(diag(3)))


options(polyform = FALSE)
a^3

options(polyform = TRUE)
a^3


options(sprayvars=letters)
a &lt;- diag(26)
spray(a)

## Following example from mpoly:
a[1 + cbind(0:25, 1:26) %% 26] &lt;- 2
spray(a)

</code></pre>

<hr>
<h2 id='rspray'>
Random spray objects
</h2><span id='topic+rspray'></span>

<h3>Description</h3>

<p>Creates random spray objects as quick-and-dirty examples of multivariate polynomials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspray(n=9, vals = seq_len(n), arity = 3, powers = 0:2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspray_+3A_n">n</code></td>
<td>

<p>Number of distinct rows (maximum); repeated rows are merged
(argument <code>addrepeats</code> is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="rspray_+3A_vals">vals</code></td>
<td>
<p>Values to use for coefficients</p>
</td></tr>
<tr><td><code id="rspray_+3A_arity">arity</code></td>
<td>
<p>Arity of the spray; the number of columns in the index matrix</p>
</td></tr>
<tr><td><code id="rspray_+3A_powers">powers</code></td>
<td>
<p>Set from which to sample the entries of the index matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a spray object</p>


<h3>Note</h3>

<p>If the index matrix contains repeated rows, the returned spray object
will contain fewer than <code>n</code> entries
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+spray">spray</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
rspray()

rspray(4)*rspray(3,rnorm(3))

rspray(3,arity=7,powers=-2:2)^3

rspray(1000,vals=rnorm(1000))

</code></pre>

<hr>
<h2 id='spray'>
Sparse arrays: <code>spray</code> objects
</h2><span id='topic+spray'></span><span id='topic+as.spray'></span><span id='topic+is.spray'></span><span id='topic+spraymaker'></span><span id='topic+is_valid_spray'></span><span id='topic+index'></span><span id='topic+value'></span><span id='topic+values'></span><span id='topic+coeff'></span><span id='topic+coeffs'></span><span id='topic+coeffs+3C-'></span><span id='topic+coeffs.spray'></span><span id='topic+coeffs+3C-.spray'></span><span id='topic+coeffs+2Cspray-method'></span><span id='topic+value'></span><span id='topic+value+3C-'></span><span id='topic+value.spray'></span><span id='topic+value+3C-.spray'></span><span id='topic+value+2Cspray-method'></span><span id='topic+coeffs+3C-+2Cspray-method'></span>

<h3>Description</h3>

<p>Create, coerce, and test for sparse array objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spray(M, x, addrepeats=FALSE)
spraymaker(L, addrepeats=FALSE, arity=ncol(L[[1]]))
is.spray(S)
as.spray(arg1, arg2, addrepeats=FALSE, offbyone=FALSE)
index(S)
coeffs(S)
coeffs(S) &lt;- value
is_valid_spray(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spray_+3A_m">M</code></td>
<td>
<p>Integer matrix with rows corresponding to index positions</p>
</td></tr>
<tr><td><code id="spray_+3A_x">x</code></td>
<td>
<p>Numeric value with elements corresponding to spray entries</p>
</td></tr>
<tr><td><code id="spray_+3A_s">S</code></td>
<td>
<p>Object to be tested for being a spray</p>
</td></tr>
<tr><td><code id="spray_+3A_l">L</code></td>
<td>
<p>A list, nominally of two elements (index matrix and value)
which is to be tested for acceptability to be coerce to class spray</p>
</td></tr>
<tr><td><code id="spray_+3A_arg1">arg1</code>, <code id="spray_+3A_arg2">arg2</code></td>
<td>
<p>Various arguments to be coerced to a spray</p>
</td></tr>
<tr><td><code id="spray_+3A_addrepeats">addrepeats</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to check
for repeated index rows and, if any are found, return an error</p>
</td></tr>
<tr><td><code id="spray_+3A_value">value</code></td>
<td>
<p>In the assignment operator <code>coeffs&lt;-()</code>, a
<code>disord</code> object (or a length-one numeric vector), so that
<code>coeffs(S) &lt;- x</code> works as expected</p>
</td></tr>
<tr><td><code id="spray_+3A_offbyone">offbyone</code></td>
<td>
<p>In function <code>as.spray()</code>, when converting from an
array.  Argument <code>offbyone</code> is Boolean with default
<code>FALSE</code> meaning to insert array elements in positions
corresponding to index elements, and <code>TRUE</code> meaning to add
one</p>
</td></tr>
<tr><td><code id="spray_+3A_arity">arity</code></td>
<td>
<p>In function <code>spraymaker()</code>, integer specifying the
arity (number of columns of the index matrix <code>L[[1]]</code>); ignored
if <code>L</code> is non-empty.  See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spray objects are sparse arrays interpreted as multivariate
polynomials.  They can be added and subtracted; &ldquo;<code>*</code>&rdquo; is
interpreted as polynomial multiplication.
</p>
<p>To create a spray object the user should use <code>spray()</code>, if a
matrix of indices and vector of values is available, or
<code>as.spray()</code> which tries hard to do the Right Thing (tm).
</p>
<p>Function <code>spraymaker()</code> is the formal creator function, and it is
written to take the output of the C++ routines and return a
spray object.  The reason this needs an <code>arity</code> argument is that
C++ sometimes returns <code>NULL</code> (in lieu of a zero-row
matrix, which it cannot deal with).  In this case, we need some way to
tell <span class="rlang"><b>R</b></span> the arity of the corresponding spray object.
</p>
<p>Functions <code>index()</code> and <code>coeffs()</code> are accessor methods.
</p>
<p>There is an extensive vignette available; type
<code>vignette("spray")</code> at the command line.
</p>


<h3>Note</h3>

<p>Function <code>coeffs()</code> was formerly known as <code>value()</code>.
</p>
<p>Technically, <code>index()</code> breaks <code>disordR</code> discipline.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ops">Ops</a></code>,<code><a href="#topic+spray-package">spray-package</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
S &lt;- spray(diag(5))    # missing second argument interpreted as '1'.
as.array(S,offbyone=TRUE) # zero indices interpreted as ones.

M &lt;- matrix(1:5,6,5) # note first row matches the sixth row

## Not run:  spray(M,1:6)  # will not work because addrepeats is not TRUE


spray(M,1:6,addrepeats=TRUE)  # 7=1:6 


S &lt;- spray(matrix(1:7,5,7))
a &lt;- as.array(S)    # will not work if any(M&lt;1)
S1 &lt;- as.spray(a)
stopifnot(S==S1)

a &lt;- rspray(20)
coeffs(a)[coeffs(a) %% 2 == 1] &lt;- 99  # every odd coefficient -&gt; 99


</code></pre>

<hr>
<h2 id='spray_cpp'>
Low-level functions that call C++ source code
</h2><span id='topic+spray_rcpp'></span><span id='topic+spray_accessor'></span><span id='topic+spray_add'></span><span id='topic+spray_crush'></span><span id='topic+spray_maker'></span><span id='topic+spray_mult'></span><span id='topic+spray_overwrite'></span><span id='topic+spray_setter'></span><span id='topic+spray_equality'></span><span id='topic+spray_asum_include'></span><span id='topic+spray_asum_exclude'></span><span id='topic+spray_deriv'></span><span id='topic+spray_pmax'></span><span id='topic+spray_pmin'></span><span id='topic+spray_power'></span><span id='topic+spray_spray_accessor'></span><span id='topic+spray_spray_add'></span><span id='topic+spray_spray_asum_exclude'></span><span id='topic+spray_spray_asum_include'></span><span id='topic+spray_spray_crush'></span><span id='topic+spray_spray_deriv'></span><span id='topic+spray_spray_equality'></span><span id='topic+spray_spray_maker'></span><span id='topic+spray_spray_mult'></span><span id='topic+spray_spray_overwrite'></span><span id='topic+spray_spray_pmax'></span><span id='topic+spray_spray_pmin'></span><span id='topic+spray_spray_setter'></span><span id='topic+spray_spray_power'></span>

<h3>Description</h3>

<p>Low-level functions that call C++ source code, as detailed in the
automatically generated <code>RcppExports.R</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spray_maker(M, d)
spray_add(M1, d1, M2, d2)
spray_mult(M1, d1, M2, d2)
spray_overwrite(M1, d1, M2, d2)
spray_accessor(M, d, Mindex)
spray_setter(M1, d1, M2, d2)
spray_equality(M1, d1, M2, d2)
spray_asum_include(M,d,n)
spray_asum_exclude(M,d,n)
spray_deriv(M,d,n)
spray_pmax(M1,d1,M2,d2)
spray_pmin(M1,d1,M2,d2)
spray_power(M,d,pow)
spray_spray_accessor()
spray_spray_add()
spray_spray_asum_exclude()
spray_spray_asum_include()
spray_spray_deriv()
spray_spray_equality()
spray_spray_maker()
spray_spray_mult()
spray_spray_overwrite()
spray_spray_pmax()
spray_spray_pmin()
spray_spray_setter()
spray_spray_power()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spray_cpp_+3A_m">M</code>, <code id="spray_cpp_+3A_m1">M1</code>, <code id="spray_cpp_+3A_m2">M2</code>, <code id="spray_cpp_+3A_mindex">Mindex</code></td>
<td>
<p>Integer valued matrices with rows corresponding to
array indices</p>
</td></tr>
<tr><td><code id="spray_cpp_+3A_d">d</code>, <code id="spray_cpp_+3A_d1">d1</code>, <code id="spray_cpp_+3A_d2">d2</code></td>
<td>
<p>Vector of values corresponding to nonzero array
entries</p>
</td></tr>
<tr><td><code id="spray_cpp_+3A_n">n</code></td>
<td>
<p>Integer vector corresponding to dimensions to sum over for
the sum functions</p>
</td></tr>
<tr><td><code id="spray_cpp_+3A_pow">pow</code></td>
<td>
<p>Nonnegative integer for <code>spray_power()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions return a two-element list which is coerced to
an object of class <code>spray</code>  by function <code>spraymaker()</code>.
</p>


<h3>Note</h3>

<p>These functions aren't really designed for the end-user.
</p>
<p>Function <code>spray_equality()</code> cannot simply check for equality of
<code>$value</code> because the order of the index rows is not specified in
a spray object.  Function <code>spray_crush()</code> has been removed as it
is redundant.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+spraymaker">spraymaker</a></code>,<code><a href="#topic+spray">spray</a></code>
</p>

<hr>
<h2 id='spray_missing_accessor'>Discussion document</h2><span id='topic+spray_missing_accessor'></span>

<h3>Description</h3>

<p>Discussion about the difficulties of implementing idiom like
<code>S[1,,5,,]</code> in the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spray_missing_accessor(S, dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spray_missing_accessor_+3A_s">S</code></td>
<td>
<p>Object of class spray</p>
</td></tr>
<tr><td><code id="spray_missing_accessor_+3A_dots">dots</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>File <code>inst/missing_accessor.txt</code> presents an extended discussion
of the difficulties of implementing idiom like <code>S[1,,5,,]</code> in the
package.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>

<hr>
<h2 id='spray-class'>Class &ldquo;spray&rdquo;</h2><span id='topic+spray-class'></span>

<h3>Description</h3>

<p>The formal S4 class for sprays.</p>


<h3>Objects from the Class</h3>

<p>Objects <em>can</em> be created by calls of the form <code>new("spray",
  ...)</code> but this is not encouraged.  Use functions <code>spray()</code> or
<code>as.spray()</code> instead.
</p>


<h3>Slots</h3>


<dl>
<dt><code>index</code>:</dt><dd><p>Index matrix</p>
</dd>
<dt><code>value</code>:</dt><dd><p>Numeric vector holding coefficients</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+spray">spray</a></code></p>

<hr>
<h2 id='spraycross'>Cross product for spray objects</h2><span id='topic+spraycross'></span><span id='topic+spraycross2'></span><span id='topic+cross'></span><span id='topic+cross_product'></span>

<h3>Description</h3>

<p>Provides a natural cross product for spray objects, useful for tensors
and <code class="reqn">k</code>-forms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spraycross(S, ...)
spraycross2(S1,S2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spraycross_+3A_s">S</code>, <code id="spraycross_+3A_s1">S1</code>, <code id="spraycross_+3A_s2">S2</code>, <code id="spraycross_+3A_...">...</code></td>
<td>
<p>spray objects</p>
</td></tr></table>


<h3>Details</h3>

<p>Tensor products for sprays.  This is <em>not</em> an algebraic product of
sprays interpreted as multivariate polynomials.  The function is used in
the <a href="https://CRAN.R-project.org/package=stokes"><span class="pkg">stokes</span></a> package.
</p>
<p>Function <code>spraycross2()</code> is a helper function that takes exactly
two arguments.  Function <code>spraycross()</code> is a more general function
that takes any number of arguments.
</p>


<h3>Value</h3>

<p>Returns a spray object</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- spray(matrix(1:4,2,2),c(2,5))
b &lt;- spray(matrix(c(10,11,12,13),2,2),c(7,11))
a
b
spraycross2(a,b)
spraycross2(b,a)

spraycross(a,b,b)

</code></pre>

<hr>
<h2 id='subs'>Substitute values into a spray object</h2><span id='topic+subs'></span><span id='topic+substitute'></span>

<h3>Description</h3>

<p>Substitute values into a spray object, interpreted as a multivariate polynomial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subs(S, dims, x, drop=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subs_+3A_s">S</code></td>
<td>
<p>spray object</p>
</td></tr>
<tr><td><code id="subs_+3A_dims">dims</code></td>
<td>
<p>Integer or logical vector with entries corresponding to
the dimensions to be substituted</p>
</td></tr>
<tr><td><code id="subs_+3A_x">x</code></td>
<td>
<p>Numeric vector of values to be substituted</p>
</td></tr>
<tr><td><code id="subs_+3A_drop">drop</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return the
<code>drop()</code> of the result, and <code>FALSE</code> meaning to return a
<code>spray</code> object consistently</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is much easier if argument <code>dims</code> is sorted into increasing
order.  If not, caveat emptor!
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+process_dimensions">process_dimensions</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
(S &lt;- spray(matrix(sample(0:3,60,replace=TRUE),nrow=12)))

subs(S,c(2,5),1:2)

P &lt;- homog(3,3)
subs(P,1,2)
</code></pre>

<hr>
<h2 id='summary.spray'>Summaries of spray objects</h2><span id='topic+summary.spray'></span><span id='topic+summary'></span><span id='topic+print.summary.spray'></span>

<h3>Description</h3>

<p>A summary method for spray objects, and a print method for summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spray'
summary(object, ...)
## S3 method for class 'summary.spray'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spray_+3A_object">object</code>, <code id="summary.spray_+3A_x">x</code></td>
<td>
<p>Object of class <code>spray</code></p>
</td></tr>
<tr><td><code id="summary.spray_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code>head()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>summary.spray</code> object is summary of a <code>spray</code> object
<code>x</code>: a list with first element being a <code>summary()</code> of the
coefficients (which is a <code>disord</code> object), and the second being a
<code>spray</code> object comprising a few selected index-coefficient
pairs.  The selection is done by <code>head()</code>.
</p>


<h3>Note</h3>

<p>The &ldquo;representative selection&rdquo; is impementation-specific, as it
uses <code>disordR::elements()</code> to extract rows of the index matrix
and coefficients.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rspray()^2
a
summary(a)
summary(a,2)

options(polyform=TRUE)
summary(a^4,3)
options(polyform=FALSE) # restore default
</code></pre>

<hr>
<h2 id='zap'>Zap small values in a spray object</h2><span id='topic+zap'></span><span id='topic+zapsmall'></span><span id='topic+zaptiny'></span><span id='topic+zap.spray'></span><span id='topic+zapsmall.spray'></span><span id='topic+zapsmall+2Cspray-method'></span><span id='topic+zapsmall+2CANY-method'></span>

<h3>Description</h3>

<p>Generic version of <code>zapsmall()</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>zap(x, digits = getOption("digits"))
## S4 method for signature 'spray'
zapsmall(x, digits = getOption("digits"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zap_+3A_x">x</code></td>
<td>
<p>spray object</p>
</td></tr>
<tr><td><code id="zap_+3A_digits">digits</code></td>
<td>
<p>number of digits to retain</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a spray object, coefficients close to zero are &lsquo;zapped&rsquo;,
i.e., replaced by &lsquo;0&rsquo;, using <code>base::zapsmall()</code>.  Function
<code>zap()</code> is an easily-typed alias; <code>zapsmall()</code> is the
<code>S4</code> generic.
</p>
<p>Note, <code>zap()</code> actually changes the numeric value, it is not just
a print method.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(S &lt;- spray(matrix(sample(1:50),ncol=2),10^-(1:25)))
zap(S)

S-zap(S)        # print method will probably print zeros...
coeffs(S-zap(S)) # ...but they are nevertheless nonzero
</code></pre>

<hr>
<h2 id='zero'>
The zero polynomial
</h2><span id='topic+zero'></span><span id='topic+empty'></span><span id='topic+is.zero'></span><span id='topic+is.empty'></span>

<h3>Description</h3>

<p>Test for the zero, or empty, polynomial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero(d)
is.zero(x)
is.empty(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_+3A_l">L</code>, <code id="zero_+3A_x">x</code></td>
<td>
<p>A two-element list of indices and values, possibly a spray
object or numeric vector</p>
</td></tr>
<tr><td><code id="zero_+3A_d">d</code></td>
<td>
<p>Integer specifying dimensionality of the spray (the arity)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>is.empty()</code> and <code>is.zero()</code> are synonyms.  If spray
objects are interpreted as multivariate polynomials,
&ldquo;<code>is.zero()</code>&rdquo; is more intuitive, if sprays are interpreted
as sparse arrays, &ldquo;<code>is.empty()</code>&rdquo; is better (for me).
</p>
<p>Passing a zero-row index matrix can have unexpected effects:
</p>
<pre>
&gt; dput(spray(matrix(0,0,5),9))
structure(list(structure(numeric(0), .Dim = c(0L, 5L)), numeric(0)), class = "spray")
</pre>
<p>Above, the index matrix has zero rows (and no elements) but the fact
that it has five columns is retained.  Arguably <code>spray()</code> should
return an error here, as the number of rows of the index matrix should
match the length of the coefficient vector and they do not: the index
has zero rows and the coefficient vector has length 1 (although they
match in the returned value).  The returned <code>spray</code> object has no
coefficients [specifically, <code>numeric(0)</code>]; this is consistent with
the index matrix having zero rows.
</p>
<p>Zero coefficients are discarded by the back end:
</p>
<pre>
&gt; spray(matrix(1,1,5),0)
empty sparse array with 5 columns
&gt; dput(spray(matrix(1,1,5),0))
structure(list(structure(numeric(0), dim = c(0L, 5L)), numeric(0)), class = "spray")
</pre>
<p>Above, the index matrix given to <code>spray()</code> has one row but the
coefficient is a length-one vector with element zero.  The resulting
<code>spray</code> object has a <code>NULL</code> index matrix [because rows with
zero coefficients are removed] and a <code>NULL</code> coefficient.  It is
also permissible to pass a a zero-row matrix:
</p>
<pre>
   spray(matrix(0,0,5),0)
empty sparse array with 5 columns

   dput(spray(matrix(0,0,5),0))
structure(list(structure(numeric(0), dim = c(0L, 5L)), numeric(0)), class = "spray")
</pre>
<p>In previous versions of the package, the index matrix in the returned
<code>spray</code> object could be <code>NULL</code> under some circumstances.  If
so, the arity of the spray object is lost.  It is probably worth noting
that <code>spray()</code>, given a zero-row index matrix, loses a length one
coefficients vector, but complains about a length-two coefficient
vector:
</p>
<pre>
&gt; dput(spray(matrix(0,0,5),0))
structure(list(structure(numeric(0), dim = c(0L, 5L)), numeric(0)), class = "spray")
&gt; dput(spray(matrix(0,0,5),3))
structure(list(structure(numeric(0), dim = c(0L, 5L)), numeric(0)), class = "spray")
&gt; dput(spray(matrix(0,0,5),1:2))
Error in is_valid_spray(L) : nrow(L[[1]]) == length(L[[2]]) is not TRUE
&gt; 
&gt; identical(spray(matrix(0,0,5),0),spray(matrix(0,0,5),3))
[1] TRUE
</pre>


<h3>Examples</h3>

<pre><code class='language-R'>
(a &lt;- lone(1,3))

is.zero(a-a)  # should be TRUE

is.zero(zero(6))

x &lt;- spray(t(0:1))
y &lt;- spray(t(1:0))

is.zero((x+y)*(x-y)-(x^2-y^2)) # TRUE

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
