<!DOCTYPE html><html><head><title>Help for package simdd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simdd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simdd-package'>
<p>simdd &ndash; Simulation of Fisher Bingham and Related Directional Distributions</p></a></li>
<li><a href='#Simulate+20Fisher+20Bingham+20and+20related+20distributions'><p>Simulate Fisher Bingham and related distributions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation of Fisher Bingham and Related Directional
Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-31</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulation methods for the Fisher Bingham distribution on the unit sphere, the matrix Bingham distribution on a Grassmann manifold, the matrix Fisher distribution on SO(3), and the bivariate von Mises sine model on the torus.
 The methods use an acceptance/rejection simulation algorithm for the Bingham distribution and are described fully by Kent, Ganeiber and Mardia (2018) &lt;<a href="https://doi.org/10.1080%2F10618600.2017.1390468">doi:10.1080/10618600.2017.1390468</a>&gt;.
 These methods supersede earlier MCMC simulation methods and are more general than earlier simulation methods.
 The methods can be slower in specific situations where there are existing non-MCMC simulation methods (see Section 8 of Kent, Ganeiber and Mardia (2018) &lt;<a href="https://doi.org/10.1080%2F10618600.2017.1390468">doi:10.1080/10618600.2017.1390468</a>&gt; for further details).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>CircStats, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-31 01:27:58 UTC; kassel</td>
</tr>
<tr>
<td>Author:</td>
<td>John Kent [aut, cph],
  Kassel Liam Hingee [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kassel Liam Hingee &lt;kassel.hingee@anu.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-31 03:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='simdd-package'>
simdd &ndash; Simulation of Fisher Bingham and Related Directional Distributions
</h2><span id='topic+simdd-package'></span><span id='topic+simdd'></span>

<h3>Description</h3>

<p>Simulation methods for the Fisher Bingham distribution on the unit sphere, the matrix Bingham distribution on a Grassmann manifold, the matrix Fisher distribution on SO(3), and the bivariate von Mises sine model on the torus.
The methods use the first ever general purpose acceptance/rejection simulation algorithm for the Bingham distribution and are described fully by Kent, Ganeiber and Mardia (2018).
These methods superseded earlier MCMC simulation methods and are more general than earlier simulation methods.
The methods can be slower in specific situations where there are existing non-MCMC simulation methods (see Section 8 of Kent, Ganeiber and Mardia (2018) for further details).
</p>


<h3>Author(s)</h3>

<p>John Kent &lt;j.t.kent@leeds.ac.uk&gt;
</p>


<h3>References</h3>

<p>John T. Kent, Asaad M. Ganeiber &amp; Kanti V. Mardia (2018) A New Unified Approach for the Simulation of a Wide Class of Directional Distributions, Journal of Computational and Graphical Statistics, 27:2, 291-301, DOI: <a href="https://doi.org/10.1080/10618600.2017.1390468">doi:10.1080/10618600.2017.1390468</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate 20 random unit vectors from a Bingham distribution
# with concentration matrix diag(c(1,2,-3)).
X=rBingham(20,c(1,2,-3))
# check the efficiency of the simulation algorithm
attr(X,"summary")
</code></pre>

<hr>
<h2 id='Simulate+20Fisher+20Bingham+20and+20related+20distributions'>Simulate Fisher Bingham and related distributions</h2><span id='topic+rFisherBingham'></span><span id='topic+rBingham'></span><span id='topic+rBingham.Grassmann'></span><span id='topic+rFisher.SO3'></span><span id='topic+rvMsin.torus'></span><span id='topic+rBessel'></span>

<h3>Description</h3>

<p>Simulate the Fisher Bingham distribution on the unit sphere,
the matrix Bingham distribution on a Grassmann manifold,
the matrix Fisher distribution on SO(3), and the bivariate
von Mises sin model on the torus = product of two circles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rFisherBingham(nsim, mu = 0, Aplus = 0, q = dimset(mu, Aplus), mtop = 1000)
rBingham(nsim, Aplus, q = dimq(Aplus), mtop = 1000)
rBingham.Grassmann(nsim, Aplus = 0, q = dimq(Aplus), r = 1, mtop = 1000)
rFisher.SO3(nsim, Fmat, mtop = 1000)
rvMsin.torus(nsim, k1, k2, alpha, mtop=1000)
rBessel(nsim, k1, k2, alpha, mtop=1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulate+2B20Fisher+2B20Bingham+2B20and+2B20related+2B20distributions_+3A_nsim">nsim</code></td>
<td>
<p>the desired number of simulations
</p>
</td></tr>
<tr><td><code id="Simulate+2B20Fisher+2B20Bingham+2B20and+2B20related+2B20distributions_+3A_mu">mu</code></td>
<td>
<p>a vector of length <code>q</code>.  If <code>mu</code> is entered as a scalar, it
is interpreted as the vector <code>(0,...,0,mu)</code> with zeros except in the
final coordinate.
</p>
</td></tr>
<tr><td><code id="Simulate+2B20Fisher+2B20Bingham+2B20and+2B20related+2B20distributions_+3A_aplus">Aplus</code></td>
<td>
<p>a symmetric <code>q</code> by <code>q</code> matrix.  If <code>Aplus</code> is given as a scalar,
it is interpreted as the <code>q</code> by <code>q</code> matrix of zeros.  If <code>Aplus</code> is given as
a vector, it is interpreted as the matrix <code>diag(Aplus)</code>.</p>
</td></tr>
<tr><td><code id="Simulate+2B20Fisher+2B20Bingham+2B20and+2B20related+2B20distributions_+3A_q">q</code></td>
<td>
<p>The simulation is done on the unit sphere in <code class="reqn">R^q</code>.  Thus for the
circle, <code>q=2</code>.  Note that <code>q</code> only needs to be given explicitly if 
both <code>mu</code> and <code>Aplus</code> are scalars.  In the default setting
the internal function <code>dimset</code>, <code>q=dimset(mu,Aplus)</code>, determines <code>q</code> from the
length of <code>mu</code> or the dimension of <code>Aplus</code>, if it can.</p>
</td></tr>
<tr><td><code id="Simulate+2B20Fisher+2B20Bingham+2B20and+2B20related+2B20distributions_+3A_r">r</code></td>
<td>
<p>For <code>rBingham.Grassmann</code>, <code>r</code> denotes the number of columns (<code>1 &lt;= r &lt;= q-1</code>) in the matrix Bingham distribution</p>
</td></tr>
<tr><td><code id="Simulate+2B20Fisher+2B20Bingham+2B20and+2B20related+2B20distributions_+3A_mtop">mtop</code></td>
<td>
<p>The maximum number of attempts to generate <code>nsim</code> simulations. A finite <code>mtop</code> prevents infinite loops in extreme situations. If <code>mtop</code> is reached there will be a warning.</p>
</td></tr>
<tr><td><code id="Simulate+2B20Fisher+2B20Bingham+2B20and+2B20related+2B20distributions_+3A_fmat">Fmat</code></td>
<td>
<p>The 3 by 3 parameter matrix for the matrix Fisher
distribution in the function <code>rFisher.SO3</code>.</p>
</td></tr>
<tr><td><code id="Simulate+2B20Fisher+2B20Bingham+2B20and+2B20related+2B20distributions_+3A_k1">k1</code>, <code id="Simulate+2B20Fisher+2B20Bingham+2B20and+2B20related+2B20distributions_+3A_k2">k2</code>, <code id="Simulate+2B20Fisher+2B20Bingham+2B20and+2B20related+2B20distributions_+3A_alpha">alpha</code></td>
<td>
<p>The two concentration parameters and the
interaction parameter in  the function <code>rvMsin.torus</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Fisher Bingham distribution on the unit sphere in <code class="reqn">R^q</code> has density
proportional to
</p>
<p style="text-align: center;"><code class="reqn">\exp(\code{mu}^T x + x^T \code{Aplus} x)</code>
</p>

<p>where <code class="reqn">x</code> is a unit vector in <code class="reqn">R^q</code>, and <code>mu</code> (<code class="reqn">q</code>-dimensional vector) and
<code>Aplus</code> (<code class="reqn">q</code> by <code class="reqn">q</code> symmetric) are parameters.
</p>
<p>The matrix Bingham distribution on <code class="reqn">q</code> by <code class="reqn">r</code> matrices <code class="reqn">X</code> whose columns are
orthonormal, is given by the density proportional to 
</p>
<p style="text-align: center;"><code class="reqn">\exp(trace(X^T \code{Aplus} X)).</code>
</p>

<p>The Bingham distribution on the unit sphere in <code class="reqn">R^q</code> can be simulated
using (a) <code>rBingham</code>, (b) <code>rFisherBingham</code> with <code>mu=0</code>, and (c)
<code>rBingham.Grassmann</code> with <code>r=1</code>.  Choice (a) will be fastest.
</p>
<p>The Fisher distribution can be simulated using <code>rFisherBingham</code> with
<code>Aplus=0</code>.
</p>
<p>The matrix Fisher distribution on SO(3) has density proportional to 
</p>
<p style="text-align: center;"><code class="reqn">\exp(trace(\code{Fmat}^T X))</code>
</p>

<p>where X is a 3 by 3 rotation matrix, and <code>Fmat</code> is a 3 by 3 parameter
matrix.
</p>
<p>The bivariate von Mises sine model on the torus has density
proportional to
</p>
<p style="text-align: center;"><code class="reqn">\exp(\code{k1} \cos(\theta) + \code{k2} cos(\phi) + \code{alpha} sin(\theta) \sin(\phi))</code>
</p>

<p>for two angles <code class="reqn">\theta</code>, <code class="reqn">\phi</code>.  The Bessel density is obtained from the
bivariate von Mises sine model as the marginal density of <code class="reqn">\theta</code>.
</p>
<p>If <code>mtop</code> is reached before obtaining <code>nsim</code> simulations then a warning is created and the returned array will have fewer than <code>nsim</code> rows.
</p>


<h3>Value</h3>

<p>For <code>rBingham</code> and <code>rFisherBingham</code>, the output is an <code>nsim</code> by <code>q</code>
matrix.  Each row is a simulated unit vector.
</p>
<p>For <code>rBingham.Grassmann</code>, the output is an <code>nsim</code> by <code>q</code> by <code>r</code> array.  For
each value of the first index, the result is a simulated <code>q</code> by <code>r</code> matrix with
orthonormal columns.
</p>
<p>For <code>rFisher.SO3</code>,  the output is an <code>nsim</code> by <code>r</code> by <code>r</code> array.  For
each value of the first index, the result is a simulated  <code>r</code> by <code>r</code> matrix
rotation matrix.
</p>
<p>For <code>rvMsin.torus</code>, the output is an <code>nsim</code> by 4 matrix, with each row
containing the simulated value of <code class="reqn">(\cos(\theta), \sin(\theta), \cos(\phi),
  \sin(\phi))</code>.
</p>
<p>For <code>rBessel</code>, the output is an <code>nsim</code> by 2 matrix containing the marginal
simulated values of <code class="reqn">(\cos(\theta), \sin(\theta))</code>.
</p>
<p>In all cases, the output has an attribute <code>summary</code>, which is a vector
of length 6 summarizing some details about the number of simulations
needed in the acceptance/rejection algorithm.  The key element of this
vector is called <code>efficiency</code>, a number between 0 and 1, where 1 means
that all the simulated values from the envelope distribution have been
accepted.
</p>

<ul>
<li> <p><code>ntry</code> is the number of simulations drawn from the envelope distribution.
</p>
</li>
<li> <p><code>efficiency</code> is the proportion of simulations drawn from the envelope distribution that were accepted.
</p>
</li>
<li> <p><code>success</code> is <code>1</code> when simulations were completed, and <code>0</code> otherwise. Usually the simulations are incomplete because the number of iterations (in entry <code>mloops</code>) has reached the maximum <code>mtop</code>.
</p>
</li>
<li> <p><code>mloops</code> is the number of iterations used.
</p>
</li>
<li> <p><code>minfg</code> is the smallest observed value of the envelope.
</p>
</li>
<li> <p><code>maxfg</code> is the largest observed value of the envelope.</p>
</li></ul>



<h3>Author(s)</h3>

<p>J T Kent
</p>


<h3>References</h3>

<p>John T. Kent, Asaad M. Ganeiber &amp; Kanti V. Mardia (2018) A New Unified Approach for the Simulation of a Wide Class of Directional Distributions, Journal of Computational and Graphical Statistics, 27:2, 291-301, DOI: <a href="https://doi.org/10.1080/10618600.2017.1390468">doi:10.1080/10618600.2017.1390468</a> 
</p>


<h3>See Also</h3>

<p>The function <code><a href="CircStats.html#topic+rvm">rvm</a></code> in the CRAN library <code>CircStats</code> provides a more
efficient method to simulate from the von Mises distribution (i.e. the
Fisher distribution with q=2) than <code>rFisherBingham</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1=rBingham(10,c(1,2,-3))
attr(X1,"summary")
X2=rFisherBingham(10,c(3,2,1),c(1,2,-3))
X3=rBingham.Grassmann(10,c(1,2,-3),r=2)
X4=rFisher.SO3(10,matrix(c(1,2,3,4,2,1,0,1,2),3,3))
X5=rvMsin.torus(10,2.2,3.1,1.3)
X6=rBessel(10,2.2,3.1,1.3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
