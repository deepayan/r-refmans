<!DOCTYPE html><html lang="en"><head><title>Help for package priorsense</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {priorsense}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#priorsense-package'><p>priorsense: Prior (and likelihood) diagnostics and sensitivity</p>
analysis</a></li>
<li><a href='#cjs_dist'><p>Cumulative Jensen-Shannon divergence</p></a></li>
<li><a href='#create-priorsense-data'><p>Create data structure for priorsense</p></a></li>
<li><a href='#example_powerscale_model'><p>Example Stan model for power-scaling</p></a></li>
<li><a href='#log_lik_draws'><p>Extract log likelihood draws</p></a></li>
<li><a href='#log_prior_draws'><p>Extract log prior draws</p></a></li>
<li><a href='#measure_divergence'><p>Calculate specified divergence measures for each posterior</p></a></li>
<li><a href='#powerscale_derivative'><p>Derivative with respect to power-scaling</p></a></li>
<li><a href='#powerscale_plots'><p>Diagnostic plots for power-scaling sensitivity</p></a></li>
<li><a href='#powerscale-gradients'><p>Power-scale gradients</p></a></li>
<li><a href='#powerscale-overview'><p>Prior/likelihood power-scaling perturbation</p></a></li>
<li><a href='#powerscale-sensitivity'><p>Power-scaling sensitivity analysis</p></a></li>
<li><a href='#predictions_as_draws'><p>brms predictions as draws</p></a></li>
<li><a href='#scaled_log_ratio'><p>Calculate importance ratios based on scaling of component</p></a></li>
<li><a href='#weighted_quantities'><p>Weighted quantities</p></a></li>
<li><a href='#weighted_summary_measures'><p>Weighted summary measures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Prior Diagnostics and Sensitivity Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for prior and likelihood sensitivity analysis in Bayesian models. Currently it implements methods to determine the sensitivity of the posterior to power-scaling perturbations of the prior and likelihood.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 2.3.1), ggdist (&ge; 3.3.2), ggh4x (&ge; 0.2.5),
ggplot2 (&ge; 3.5.1), matrixStats (&ge; 1.3.0), methods, posterior
(&ge; 1.6.0), rlang (&ge; 1.1.4), stats, tibble (&ge; 3.2.1), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bayesplot (&ge; 1.11.1), brms (&ge; 2.22.0), cmdstanr (&ge; 0.8.1),
iwmm (&ge; 0.0.1), knitr (&ge; 1.47), philentropy (&ge; 0.8.0), rstan
(&ge; 2.32.6), testthat (&ge; 3.0.0), transport (&ge; 0.15),
rmarkdown (&ge; 2.27)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://topipa.r-universe.dev">https://topipa.r-universe.dev</a>,
<a href="https://stan-dev.r-universe.dev">https://stan-dev.r-universe.dev</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://n-kall.github.io/priorsense/">https://n-kall.github.io/priorsense/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-01 12:13:51 UTC; kallion6</td>
</tr>
<tr>
<td>Author:</td>
<td>Noa Kallioinen [aut, cre, cph],
  Topi Paananen [aut],
  Paul-Christian Bürkner [aut],
  Aki Vehtari [aut],
  Frank Weber [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Noa Kallioinen &lt;noa.kallioinen@aalto.fi&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-01 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='priorsense-package'>priorsense: Prior (and likelihood) diagnostics and sensitivity
analysis</h2><span id='topic+priorsense-package'></span><span id='topic+priorsense'></span>

<h3>Description</h3>

<p>The <span class="pkg">priorsense</span> package provides functions for
prior and likelihood sensitivity analysis of Bayesian
models. Currently it implements methods to determine the
sensitivity of the posterior to power-scaling perturbations of
the prior and likelihood.
</p>


<h3>Details</h3>

<p>The main diagnostic function provided by <span class="pkg">priorsense</span>
is <code><a href="#topic+powerscale_sensitivity">powerscale_sensitivity</a></code>. Given a fitted model
or draws object, it computes the powerscaling sensitivity
diagnostic described in Kallioinen et al. (2023). It does so by
perturbing the prior and likelihood and computing the effect on
the posterior, without needing to refit the model (using Pareto
smoothed importance sampling and importance weighted moment
matching; Vehtari et al. 2022, Paananen et al. 2021).
</p>
<p>In addition, visual diagnostics are available by first using
<code><a href="#topic+powerscale_sequence">powerscale_sequence</a></code> to create a sequence of perturbed
posteriors, and then a plot function such as
<code><a href="#topic+powerscale_plot_ecdf">powerscale_plot_ecdf</a></code> to visualise the change.
</p>
<p>The following global options are available:
</p>

<ul>
<li> <p><code>priorsense.plot_help_text</code>: If <code>TRUE</code> (the default), priorsense plots will include a title and explanatory text. If <code>FALSE</code> they will not.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Noa Kallioinen <a href="mailto:noa.kallioinen@aalto.fi">noa.kallioinen@aalto.fi</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Topi Paananen
</p>
</li>
<li><p> Paul-Christian Bürkner
</p>
</li>
<li><p> Aki Vehtari
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Frank Weber [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Kallioinen, N., Paananen, T., Bürkner, P-C., Vehtari, A. (2023).
Detecting and diagnosing prior and likelihood sensitivity with
power-scaling perturbations.  <em>Statistics and
Computing</em>. 34(57).  <code>doi:10.1007/s11222-023-10366-5</code>
</p>
<p>Vehtari, A., Simpson, D., Gelman, A., Yao, Y., and Gabry,
J. (2024).  Pareto smoothed importance sampling. <em>Journal of
Machine Learning Research</em>. 25(72).
<code>https://jmlr.org/papers/v25/19-556.html</code>
</p>
<p>Paananen, T., Piironen, J., Bürkner, P-C., Vehtari, A. (2021).
Implicitly adaptive importance sampling.  <em>Statistics and
Computing</em>. 31(16).  <code>doi:10.1007/s11222-020-09982-2</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+powerscale_sensitivity">powerscale_sensitivity</a></code>
<code><a href="#topic+powerscale_sequence">powerscale_sequence</a></code>
<code><a href="#topic+powerscale">powerscale</a></code>
<code><a href="#topic+powerscale_plot_ecdf">powerscale_plot_ecdf</a></code>
<code><a href="#topic+powerscale_plot_dens">powerscale_plot_dens</a></code>
<code><a href="#topic+powerscale_plot_quantities">powerscale_plot_quantities</a></code>
</p>

<hr>
<h2 id='cjs_dist'>Cumulative Jensen-Shannon divergence</h2><span id='topic+cjs_dist'></span>

<h3>Description</h3>

<p>Computes the cumulative Jensen-Shannon distance between two
samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjs_dist(
  x,
  y,
  x_weights = NULL,
  y_weights = NULL,
  metric = TRUE,
  unsigned = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cjs_dist_+3A_x">x</code></td>
<td>
<p>numeric vector of samples from first distribution</p>
</td></tr>
<tr><td><code id="cjs_dist_+3A_y">y</code></td>
<td>
<p>numeric vector of samples from second distribution</p>
</td></tr>
<tr><td><code id="cjs_dist_+3A_x_weights">x_weights</code></td>
<td>
<p>numeric vector of weights of first distribution</p>
</td></tr>
<tr><td><code id="cjs_dist_+3A_y_weights">y_weights</code></td>
<td>
<p>numeric vector of weights of second distribution</p>
</td></tr>
<tr><td><code id="cjs_dist_+3A_metric">metric</code></td>
<td>
<p>Logical; if TRUE, return square-root of CJS</p>
</td></tr>
<tr><td><code id="cjs_dist_+3A_unsigned">unsigned</code></td>
<td>
<p>Logical; if TRUE then return max of CJS(P(x) ||
Q(x)) and CJS(P(-x) || Q(-x)). This ensures invariance to
transformations such as PCA.</p>
</td></tr>
<tr><td><code id="cjs_dist_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cumulative Jensen-Shannon distance is a symmetric metric based
on the cumulative Jensen-Shannon divergence. The divergence CJS(P || Q)
between two cumulative distribution functions P and Q is defined as:
</p>
<p style="text-align: center;"><code class="reqn">CJS(P || Q) = \sum P(x) \log \frac{P(x)}{0.5 (P(x) + Q(x))} +
\frac{1}{2 \ln 2} \sum (Q(x) - P(x))</code>
</p>

<p>The symmetric metric is defined as:
</p>
<p style="text-align: center;"><code class="reqn">CJS_{dist}(P || Q) = \sqrt{CJS(P || Q) + CJS(Q || P)}</code>
</p>

<p>This has an upper bound of <code class="reqn">\sqrt{ \sum (P(x) + Q(x))}</code>
</p>


<h3>Value</h3>

<p>distance value based on CJS computation.
</p>


<h3>References</h3>

<p>Nguyen H-V., Vreeken J. (2015).  Non-parametric
Jensen-Shannon Divergence.  In: Appice A., Rodrigues P., Santos
Costa V., Gama J., Jorge A., Soares C. (eds) Machine Learning
and Knowledge Discovery in Databases.  ECML PKDD 2015. Lecture
Notes in Computer Science, vol 9285.  Springer, Cham.
<code>doi:10.1007/978-3-319-23525-7_11</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- rnorm(100, 2, 2)
cjs_dist(x, y, x_weights = NULL, y_weights = NULL)
</code></pre>

<hr>
<h2 id='create-priorsense-data'>Create data structure for priorsense</h2><span id='topic+create-priorsense-data'></span><span id='topic+create_priorsense_data'></span><span id='topic+create_priorsense_data.default'></span><span id='topic+create_priorsense_data.stanfit'></span><span id='topic+create_priorsense_data.CmdStanFit'></span><span id='topic+create_priorsense_data.draws'></span>

<h3>Description</h3>

<p>Create a data structure that contains all required data and
functions for priorsense
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_priorsense_data(x, ...)

## Default S3 method:
create_priorsense_data(
  x,
  fit = NULL,
  log_prior_fn = log_prior_draws,
  log_lik_fn = log_lik_draws,
  log_prior = NULL,
  log_lik = NULL,
  log_ratio_fn = NULL,
  ...
)

## S3 method for class 'stanfit'
create_priorsense_data(x, ...)

## S3 method for class 'CmdStanFit'
create_priorsense_data(x, ...)

## S3 method for class 'draws'
create_priorsense_data(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create-priorsense-data_+3A_x">x</code></td>
<td>
<p>an object for which the method is defined</p>
</td></tr>
<tr><td><code id="create-priorsense-data_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
<tr><td><code id="create-priorsense-data_+3A_fit">fit</code></td>
<td>
<p>a model fit object (only used if x is not a fit object)</p>
</td></tr>
<tr><td><code id="create-priorsense-data_+3A_log_prior_fn">log_prior_fn</code></td>
<td>
<p>function to derive log prior from object</p>
</td></tr>
<tr><td><code id="create-priorsense-data_+3A_log_lik_fn">log_lik_fn</code></td>
<td>
<p>function to derive log likelihood from object</p>
</td></tr>
<tr><td><code id="create-priorsense-data_+3A_log_prior">log_prior</code></td>
<td>
<p>draws from log prior</p>
</td></tr>
<tr><td><code id="create-priorsense-data_+3A_log_lik">log_lik</code></td>
<td>
<p>draws from log likelihood</p>
</td></tr>
<tr><td><code id="create-priorsense-data_+3A_log_ratio_fn">log_ratio_fn</code></td>
<td>
<p>function for moment matching</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>priorsense_data</code> object, which contains the data and
functions to run sensitivity analyses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- example_powerscale_model()
drw &lt;- x$draws

psd &lt;- create_priorsense_data(drw)
</code></pre>

<hr>
<h2 id='example_powerscale_model'>Example Stan model for power-scaling</h2><span id='topic+example_powerscale_model'></span>

<h3>Description</h3>

<p>Provides example models (with data) that are ready for use with
power-scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_powerscale_model(model = "univariate_normal")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="example_powerscale_model_+3A_model">model</code></td>
<td>
<p>Character specifying which model code to
return. Currently &quot;univariate_normal&quot; and &quot;eight_schools&quot; are
implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing model code and corresponding data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex_normal &lt;- example_powerscale_model(model = "univariate_normal")

ex_eightschools &lt;- example_powerscale_model(model = "eight_schools")
</code></pre>

<hr>
<h2 id='log_lik_draws'>Extract log likelihood draws</h2><span id='topic+log_lik_draws'></span><span id='topic+log_lik_draws.stanfit'></span><span id='topic+log_lik_draws.CmdStanFit'></span><span id='topic+log_lik_draws.draws'></span>

<h3>Description</h3>

<p>Extract log likelihood from fitted model and return as a draws object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_lik_draws(x, ...)

## S3 method for class 'stanfit'
log_lik_draws(x, joint = FALSE, log_lik_name = "log_lik", ...)

## S3 method for class 'CmdStanFit'
log_lik_draws(x, joint = FALSE, log_lik_name = "log_lik", ...)

## S3 method for class 'draws'
log_lik_draws(x, joint = FALSE, log_lik_name = "log_lik", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_lik_draws_+3A_x">x</code></td>
<td>
<p>Model fit or draws object.</p>
</td></tr>
<tr><td><code id="log_lik_draws_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods.</p>
</td></tr>
<tr><td><code id="log_lik_draws_+3A_joint">joint</code></td>
<td>
<p>Logical indicating whether to return the joint log
likelihood or array. Default is FALSE.</p>
</td></tr>
<tr><td><code id="log_lik_draws_+3A_log_lik_name">log_lik_name</code></td>
<td>
<p>Name of parameter in Stan model corresponding
to log likelihood, default is &quot;log_lik&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A draws_array object containing log_lik values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- example_powerscale_model()
drw &lt;- ex$draws

log_lik_draws(drw)

</code></pre>

<hr>
<h2 id='log_prior_draws'>Extract log prior draws</h2><span id='topic+log_prior_draws'></span><span id='topic+log_prior_draws.stanfit'></span><span id='topic+log_prior_draws.CmdStanFit'></span><span id='topic+log_prior_draws.draws'></span>

<h3>Description</h3>

<p>Extract log likelihood from fitted model and return as a draws object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_prior_draws(x, ...)

## S3 method for class 'stanfit'
log_prior_draws(x, joint = FALSE, log_prior_name = "lprior", ...)

## S3 method for class 'CmdStanFit'
log_prior_draws(x, joint = FALSE, log_prior_name = "lprior", ...)

## S3 method for class 'draws'
log_prior_draws(x, joint = FALSE, log_prior_name = "lprior", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_prior_draws_+3A_x">x</code></td>
<td>
<p>Model fit or draws object.</p>
</td></tr>
<tr><td><code id="log_prior_draws_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods.</p>
</td></tr>
<tr><td><code id="log_prior_draws_+3A_joint">joint</code></td>
<td>
<p>Logical indicating whether to return the joint log prior
or array. Default is FALSE.</p>
</td></tr>
<tr><td><code id="log_prior_draws_+3A_log_prior_name">log_prior_name</code></td>
<td>
<p>Name of parameter in Stan model
corresponding to log prior, default is &quot;lprior&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A draws_array object containing log_prior values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- example_powerscale_model()
drw &lt;- ex$draws

log_prior_draws(drw)

</code></pre>

<hr>
<h2 id='measure_divergence'>Calculate specified divergence measures for each posterior</h2><span id='topic+measure_divergence'></span>

<h3>Description</h3>

<p>Calculate specified divergence measures for each posterior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure_divergence(draws1, draws2, measure, measure_args = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measure_divergence_+3A_draws1">draws1</code></td>
<td>
<p>draws of first distribution</p>
</td></tr>
<tr><td><code id="measure_divergence_+3A_draws2">draws2</code></td>
<td>
<p>draws of second distribution</p>
</td></tr>
<tr><td><code id="measure_divergence_+3A_measure">measure</code></td>
<td>
<p>divergence measure</p>
</td></tr>
<tr><td><code id="measure_divergence_+3A_measure_args">measure_args</code></td>
<td>
<p>arguments for divergence measure</p>
</td></tr>
<tr><td><code id="measure_divergence_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble
</p>

<hr>
<h2 id='powerscale_derivative'>Derivative with respect to power-scaling</h2><span id='topic+powerscale_derivative'></span>

<h3>Description</h3>

<p>Calculate the analytical derivative of a quantity with respect to
power-scaling prior or likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerscale_derivative(x, log_component, quantity = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerscale_derivative_+3A_x">x</code></td>
<td>
<p>Posterior draws.</p>
</td></tr>
<tr><td><code id="powerscale_derivative_+3A_log_component">log_component</code></td>
<td>
<p>Log likelihood or log prior values.</p>
</td></tr>
<tr><td><code id="powerscale_derivative_+3A_quantity">quantity</code></td>
<td>
<p>Character specifying quantity of interest (default
is &quot;mean&quot;). Options are &quot;mean&quot;, &quot;sd&quot;, &quot;var&quot;.</p>
</td></tr>
<tr><td><code id="powerscale_derivative_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Derivative of the quantity with respect to log2 of the
power-scaling factor (alpha).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_model &lt;- example_powerscale_model()
draws &lt;- example_model$draws
log_prior &lt;- log_prior_draws(draws, joint = TRUE)
posterior::summarise_draws(
    posterior::subset_draws(draws, variable = c("mu", "sigma")),
    mean,
    mean_sens = ~powerscale_derivative(.x, log_prior, quantity = "mean")
)
</code></pre>

<hr>
<h2 id='powerscale_plots'>Diagnostic plots for power-scaling sensitivity</h2><span id='topic+powerscale_plots'></span><span id='topic+powerscale_plot_dens'></span><span id='topic+powerscale_plot_ecdf'></span><span id='topic+powerscale_plot_ecdf.powerscaled_sequence'></span><span id='topic+powerscale_plot_quantities'></span><span id='topic+powerscale_plot_quantities.powerscaled_sequence'></span>

<h3>Description</h3>

<p>Various diagnostic plots for power-scaling sensitivity. See <strong>Plot Descriptions</strong> below for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerscale_plot_dens(x, ...)

powerscale_plot_ecdf(x, ...)

## S3 method for class 'powerscaled_sequence'
powerscale_plot_ecdf(
  x,
  variable = NULL,
  resample = FALSE,
  length = 3,
  facet_rows = "component",
  help_text = getOption("priorsense.plot_help_text", TRUE),
  colors = NULL,
  ...
)

powerscale_plot_quantities(x, ...)

## S3 method for class 'powerscaled_sequence'
powerscale_plot_quantities(
  x,
  variable = NULL,
  quantity = c("mean", "sd"),
  div_measure = "cjs_dist",
  resample = FALSE,
  measure_args = NULL,
  mcse = TRUE,
  quantity_args = NULL,
  help_text = getOption("priorsense.plot_help_text", TRUE),
  colors = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerscale_plots_+3A_x">x</code></td>
<td>
<p>An object of class <code>powerscaled_sequence</code> or an object
for which <code>powerscale_sequence</code> will first be run on.</p>
</td></tr>
<tr><td><code id="powerscale_plots_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>powerscale_sequence</code> if <code>x</code> is not
of class <code>powerscaled_sequence</code>.</p>
</td></tr>
<tr><td><code id="powerscale_plots_+3A_variable">variable</code></td>
<td>
<p>A character vector of variable names. If <code>NULL</code>
(the default) all variables will be plotted.</p>
</td></tr>
<tr><td><code id="powerscale_plots_+3A_resample">resample</code></td>
<td>
<p>Logical; Indicate whether or not draws should be
resampled based on calculated importance weights.</p>
</td></tr>
<tr><td><code id="powerscale_plots_+3A_length">length</code></td>
<td>
<p>Numeric specifying how many alpha values should be
used. Ignored of the object is of class <code>powerscaled_sequence</code>.</p>
</td></tr>
<tr><td><code id="powerscale_plots_+3A_facet_rows">facet_rows</code></td>
<td>
<p>Character defining the rows of the plot facets,
either &quot;variable&quot; or &quot;component&quot;. Default is &quot;variable&quot;.</p>
</td></tr>
<tr><td><code id="powerscale_plots_+3A_help_text">help_text</code></td>
<td>
<p>Logical indicating whether title and subtitle
with explanatory description should be included in the
plot. Default is TRUE. Can be set via option
&quot;priorsense.show_help_text&quot;.</p>
</td></tr>
<tr><td><code id="powerscale_plots_+3A_colors">colors</code></td>
<td>
<p>Character vector of colors to be used for
plots. Either length 3 for <code>powerscale_plot_ecdf</code> and
<code>powerscale_plot_dens</code> with order lowest, base, highest; or
length 2 for <code>powerscale_plot_quantities</code> with order low Pareto
k, high Pareto k. If <code>NULL</code> the defaults will be used.</p>
</td></tr>
<tr><td><code id="powerscale_plots_+3A_quantity">quantity</code></td>
<td>
<p>A character vector specifying one or several
quantities to plot. Options are &quot;mean&quot;, &quot;median&quot;, &quot;sd&quot;, &quot;mad&quot;,
&quot;quantile&quot;.</p>
</td></tr>
<tr><td><code id="powerscale_plots_+3A_div_measure">div_measure</code></td>
<td>
<p>The divergence measure to use. The
following methods are implemented:
</p>

<ul>
<li> <p><code>"cjs_dist"</code>: Cumulative Jensen-Shannon distance. Default
method. See function <code>cjs_dist</code> for more details.
</p>
</li>
<li> <p><code>"js_dist"</code>: Jensen-Shannon distance.
</p>
</li>
<li> <p><code>"js_div"</code>: Jensen-Shannon divergence.
</p>
</li>
<li> <p><code>"hellinger_dist"</code>: Hellinger distance.
</p>
</li>
<li> <p><code>"kl_dist"</code>: Kullback-Leibler distance.
</p>
</li>
<li> <p><code>"kl_div"</code>: Kullback-Leibler divergence.
</p>
</li>
<li> <p><code>"ks_dist"</code>: Kolmogorov-Smirnov distance.
</p>
</li>
<li> <p><code>"hellinger_dist"</code>: Hellinger distance.
</p>
</li>
<li> <p><code>"ws_dist"</code>: Wassterstein distance (pass <code>measure_args = list(p = N)</code>)
for a different order, where N is the order.
</p>
</li></ul>
</td></tr>
<tr><td><code id="powerscale_plots_+3A_measure_args">measure_args</code></td>
<td>
<p>Named list of further arguments passed to divergence measure functions.</p>
</td></tr>
<tr><td><code id="powerscale_plots_+3A_mcse">mcse</code></td>
<td>
<p>Boolean; If TRUE will plot +/- 2 * Monte Carlo
standard error of the base quantity on the quantities plot.</p>
</td></tr>
<tr><td><code id="powerscale_plots_+3A_quantity_args">quantity_args</code></td>
<td>
<p>Named list of further arguments passed to
quantity functions. Passed as <code>.args</code> to
<code style="white-space: pre;">&#8288;[posterior::summarise_draws]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object that can be further customized using the <strong>ggplot2</strong> package.
</p>


<h3>Plot Descriptions</h3>


<dl>
<dt><code>powerscale_plot_dens()</code></dt><dd><p> Kernel density plot of
power-scaled posterior draws with respect to power-scaling.  </p>
</dd>
<dt><code>powerscale_plot_ecdf()</code></dt><dd><p> Empirical cumulative
distribution function plot of power-scaled posterior draws with
respect to power-scaling.  </p>
</dd>
<dt><code>powerscale_plot_quantities()</code></dt><dd><p> Plot of posterior
quantities with respect to power-scaling.</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- example_powerscale_model()

powerscale_plot_dens(ex$draws)
</code></pre>

<hr>
<h2 id='powerscale-gradients'>Power-scale gradients</h2><span id='topic+powerscale-gradients'></span><span id='topic+powerscale_gradients'></span><span id='topic+powerscale_gradients.default'></span><span id='topic+powerscale_gradients.priorsense_data'></span>

<h3>Description</h3>

<p>Calculate the numerical derivative of posterior
quantities/divergence with respect to power-scaling the specified
component (prior or likelihood). This is done using importance
sampling (and optionally moment matching).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerscale_gradients(x, ...)

## Default S3 method:
powerscale_gradients(x, ...)

## S3 method for class 'priorsense_data'
powerscale_gradients(
  x,
  variable = NULL,
  component = c("prior", "likelihood"),
  type = c("quantities", "divergence"),
  lower_alpha = 0.99,
  upper_alpha = 1.01,
  div_measure = "cjs_dist",
  measure_args = list(),
  moment_match = FALSE,
  k_threshold = 0.5,
  resample = FALSE,
  transform = NULL,
  prediction = NULL,
  scale = FALSE,
  prior_selection = NULL,
  likelihood_selection = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerscale-gradients_+3A_x">x</code></td>
<td>
<p>Model fit or draws object.</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_...">...</code></td>
<td>
<p>Further arguments passed to functions.</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_variable">variable</code></td>
<td>
<p>Variables to compute sensitivity of. If NULL
(default) sensitivity is computed for all variables.</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_component">component</code></td>
<td>
<p>Component to power-scale (prior or likelihood).</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_type">type</code></td>
<td>
<p>type of sensitivity to measure (&quot;distance&quot;,
&quot;quantity&quot;).  Multiple options can be specified at the same
time.</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_lower_alpha">lower_alpha</code></td>
<td>
<p>lower power to scale component by, should be &lt;
1 (default is 0.9).</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_upper_alpha">upper_alpha</code></td>
<td>
<p>upper power to scale component by, should be &gt;
1 (default is 1.1).</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_div_measure">div_measure</code></td>
<td>
<p>The divergence measure to use. The
following methods are implemented:
</p>

<ul>
<li> <p><code>"cjs_dist"</code>: Cumulative Jensen-Shannon distance. Default
method. See function <code>cjs_dist</code> for more details.
</p>
</li>
<li> <p><code>"js_dist"</code>: Jensen-Shannon distance.
</p>
</li>
<li> <p><code>"js_div"</code>: Jensen-Shannon divergence.
</p>
</li>
<li> <p><code>"hellinger_dist"</code>: Hellinger distance.
</p>
</li>
<li> <p><code>"kl_dist"</code>: Kullback-Leibler distance.
</p>
</li>
<li> <p><code>"kl_div"</code>: Kullback-Leibler divergence.
</p>
</li>
<li> <p><code>"ks_dist"</code>: Kolmogorov-Smirnov distance.
</p>
</li>
<li> <p><code>"hellinger_dist"</code>: Hellinger distance.
</p>
</li>
<li> <p><code>"ws_dist"</code>: Wassterstein distance (pass <code>measure_args = list(p = N)</code>)
for a different order, where N is the order.
</p>
</li></ul>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_measure_args">measure_args</code></td>
<td>
<p>Named list of further arguments passed to divergence measure functions.</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_moment_match">moment_match</code></td>
<td>
<p>Logical; Indicate whether or not moment
matching should be performed. Can only be TRUE if <code>is_method</code> is
&quot;psis&quot;.</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_k_threshold">k_threshold</code></td>
<td>
<p>Threshold value for Pareto k values above which
the moment matching algorithm is used. Default is 0.5.</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_resample">resample</code></td>
<td>
<p>Logical; Indicate whether or not draws should be
resampled based on calculated importance weights.</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_transform">transform</code></td>
<td>
<p>Indicate a transformation of posterior draws to
perform before sensitivity analysis. Either &quot;scale&quot; or &quot;whiten&quot;.</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_prediction">prediction</code></td>
<td>
<p>Function taking the model fit and returning a
draws_df of predictions to be appended to the posterior draws</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_scale">scale</code></td>
<td>
<p>logical scale quantity gradients by base posterior
standard deviation.</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_prior_selection">prior_selection</code></td>
<td>
<p>Numeric vector specifying which priors to
consider.</p>
</td></tr>
<tr><td><code id="powerscale-gradients_+3A_likelihood_selection">likelihood_selection</code></td>
<td>
<p>Numeric vector specifying which likelihoods to
consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maximum of the absolute derivatives above and below alpha
= 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- example_powerscale_model()
drw &lt;- ex$draws

powerscale_gradients(drw)
</code></pre>

<hr>
<h2 id='powerscale-overview'>Prior/likelihood power-scaling perturbation</h2><span id='topic+powerscale-overview'></span><span id='topic+powerscale'></span><span id='topic+powerscale.default'></span><span id='topic+powerscale.priorsense_data'></span><span id='topic+powerscale_sequence'></span><span id='topic+powerscale_sequence.default'></span><span id='topic+powerscale_sequence.priorsense_data'></span>

<h3>Description</h3>

<p>Estimate posterior draws based on power-scaling perturbations of
prior or likelihood using importance sampling (and optionally
moment matching).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerscale(x, ...)

## Default S3 method:
powerscale(
  x,
  component,
  alpha,
  moment_match = FALSE,
  k_threshold = NULL,
  resample = FALSE,
  transform = NULL,
  prediction = NULL,
  variable = NULL,
  selection = NULL,
  ...
)

## S3 method for class 'priorsense_data'
powerscale(
  x,
  component,
  alpha,
  moment_match = FALSE,
  k_threshold = NULL,
  resample = FALSE,
  transform = NULL,
  prediction = NULL,
  variable = NULL,
  selection = NULL,
  ...
)

powerscale_sequence(x, ...)

## Default S3 method:
powerscale_sequence(
  x,
  lower_alpha = 0.8,
  upper_alpha = 1/lower_alpha,
  length = 3,
  variable = NULL,
  component = c("prior", "likelihood"),
  moment_match = FALSE,
  k_threshold = 0.5,
  resample = FALSE,
  transform = NULL,
  prediction = NULL,
  auto_alpha_range = FALSE,
  symmetric = TRUE,
  prior_selection = NULL,
  likelihood_selection = NULL,
  ...
)

## S3 method for class 'priorsense_data'
powerscale_sequence(
  x,
  lower_alpha = 0.8,
  upper_alpha = 1/lower_alpha,
  length = 3,
  variable = NULL,
  component = c("prior", "likelihood"),
  moment_match = FALSE,
  k_threshold = 0.5,
  resample = FALSE,
  transform = NULL,
  prediction = NULL,
  auto_alpha_range = FALSE,
  symmetric = TRUE,
  prior_selection = NULL,
  likelihood_selection = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerscale-overview_+3A_x">x</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_...">...</code></td>
<td>
<p>Further arguments passed to internal functions.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_component">component</code></td>
<td>
<p>Component to be power-scaled (either &quot;prior&quot; or
&quot;likelihood&quot;). For powerscale_sequence, this can be both &quot;prior&quot;
and &quot;likelihood&quot;.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_alpha">alpha</code></td>
<td>
<p>Value by which to power-scale specified
component. (likelihood/prior).</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_moment_match">moment_match</code></td>
<td>
<p>Logical; Indicate whether or not moment
matching should be performed. Can only be TRUE if <code>is_method</code> is
&quot;psis&quot;.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_k_threshold">k_threshold</code></td>
<td>
<p>Threshold value for Pareto k values above which
the moment matching algorithm is used. Default is 0.5.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_resample">resample</code></td>
<td>
<p>Logical; Indicate whether or not draws should be
resampled based on calculated importance weights.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_transform">transform</code></td>
<td>
<p>Indicate a transformation of posterior draws to
perform before sensitivity analysis. Either &quot;scale&quot; or &quot;whiten&quot;.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_prediction">prediction</code></td>
<td>
<p>Function taking the model fit and returning a
draws_df of predictions to be appended to the posterior draws</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_variable">variable</code></td>
<td>
<p>Vector of variable names to return estimated
posterior draws for. If <code>NULL</code> all variables will be included.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_selection">selection</code></td>
<td>
<p>Numeric vector specifying partitions of component
to be included in power-scaling. Default is NULL, which takes
all partitions.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_lower_alpha">lower_alpha</code></td>
<td>
<p>Lower power-scaling alpha value in sequence.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_upper_alpha">upper_alpha</code></td>
<td>
<p>Upper power-scaling alpha value in sequence.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_length">length</code></td>
<td>
<p>Length of alpha sequence.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_auto_alpha_range">auto_alpha_range</code></td>
<td>
<p>Boolean. Restrict range to ensure Pareto-k
values below threshold?</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_symmetric">symmetric</code></td>
<td>
<p>Boolean. Should the alpha range be symmetrical
around alpha = 1, on log-space?</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_prior_selection">prior_selection</code></td>
<td>
<p>Numeric vector of prior partitions to include in power-scaling. Default is NULL, which takes all partitions.</p>
</td></tr>
<tr><td><code id="powerscale-overview_+3A_likelihood_selection">likelihood_selection</code></td>
<td>
<p>Numeric vector of likelihood partitions to include in power-scaling. Default is NULL, which takes all partitions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>powerscaled_draws</code> or <code>powerscaled_sequence</code> object,
which contains the estimated posterior draws resulting from the
power-scaling perturbations and details of the perturbation and
estimation methods.
</p>


<h3>References</h3>

<p>Kallioinen, N., Paananen, T., Bürkner, P-C., Vehtari, A. (2023).
Detecting and diagnosing prior and likelihood sensitivity with
power-scaling perturbations.  <em>Statistics and
Computing</em>. 34(57).  <code>doi:10.1007/s11222-023-10366-5</code>
</p>
<p>Vehtari, A., Simpson, D., Gelman, A., Yao, Y., and Gabry,
J. (2024).  Pareto smoothed importance sampling. <em>Journal of
Machine Learning Research</em>. 25(72).
<code>https://jmlr.org/papers/v25/19-556.html</code>
</p>
<p>Paananen, T., Piironen, J., Bürkner, P-C., Vehtari, A. (2021).
Implicitly adaptive importance sampling.  <em>Statistics and
Computing</em>. 31(16).  <code>doi:10.1007/s11222-020-09982-2</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- example_powerscale_model()

powerscale(ex$draws, component = "prior", alpha = 0.5)

powerscale_sequence(ex$draws)
</code></pre>

<hr>
<h2 id='powerscale-sensitivity'>Power-scaling sensitivity analysis</h2><span id='topic+powerscale-sensitivity'></span><span id='topic+powerscale_sensitivity'></span><span id='topic+powerscale_sensitivity.default'></span><span id='topic+powerscale_sensitivity.priorsense_data'></span><span id='topic+powerscale_sensitivity.CmdStanFit'></span><span id='topic+powerscale_sensitivity.stanfit'></span>

<h3>Description</h3>

<p>Calculates the prior/likelihood sensitivity based on power-scaling
perturbations. This is done using importance sampling (and
optionally moment matching).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerscale_sensitivity(x, ...)

## Default S3 method:
powerscale_sensitivity(
  x,
  variable = NULL,
  lower_alpha = 0.99,
  upper_alpha = 1.01,
  div_measure = "cjs_dist",
  measure_args = list(),
  component = c("prior", "likelihood"),
  sensitivity_threshold = 0.05,
  moment_match = FALSE,
  k_threshold = 0.5,
  resample = FALSE,
  transform = NULL,
  prediction = NULL,
  prior_selection = NULL,
  likelihood_selection = NULL,
  num_args = NULL,
  ...
)

## S3 method for class 'priorsense_data'
powerscale_sensitivity(
  x,
  variable = NULL,
  lower_alpha = 0.99,
  upper_alpha = 1.01,
  div_measure = "cjs_dist",
  measure_args = list(),
  component = c("prior", "likelihood"),
  sensitivity_threshold = 0.05,
  moment_match = FALSE,
  k_threshold = 0.5,
  resample = FALSE,
  transform = NULL,
  prediction = NULL,
  prior_selection = NULL,
  likelihood_selection = NULL,
  num_args = NULL,
  ...
)

## S3 method for class 'CmdStanFit'
powerscale_sensitivity(x, ...)

## S3 method for class 'stanfit'
powerscale_sensitivity(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerscale-sensitivity_+3A_x">x</code></td>
<td>
<p>Model fit object or priorsense_data object.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_...">...</code></td>
<td>
<p>Further arguments passed to functions.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_variable">variable</code></td>
<td>
<p>Character vector of variables to check.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_lower_alpha">lower_alpha</code></td>
<td>
<p>Lower alpha value for gradient calculation.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_upper_alpha">upper_alpha</code></td>
<td>
<p>Upper alpha value for gradient calculation.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_div_measure">div_measure</code></td>
<td>
<p>The divergence measure to use. The
following methods are implemented:
</p>

<ul>
<li> <p><code>"cjs_dist"</code>: Cumulative Jensen-Shannon distance. Default
method. See function <code>cjs_dist</code> for more details.
</p>
</li>
<li> <p><code>"js_dist"</code>: Jensen-Shannon distance.
</p>
</li>
<li> <p><code>"js_div"</code>: Jensen-Shannon divergence.
</p>
</li>
<li> <p><code>"hellinger_dist"</code>: Hellinger distance.
</p>
</li>
<li> <p><code>"kl_dist"</code>: Kullback-Leibler distance.
</p>
</li>
<li> <p><code>"kl_div"</code>: Kullback-Leibler divergence.
</p>
</li>
<li> <p><code>"ks_dist"</code>: Kolmogorov-Smirnov distance.
</p>
</li>
<li> <p><code>"hellinger_dist"</code>: Hellinger distance.
</p>
</li>
<li> <p><code>"ws_dist"</code>: Wassterstein distance (pass <code>measure_args = list(p = N)</code>)
for a different order, where N is the order.
</p>
</li></ul>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_measure_args">measure_args</code></td>
<td>
<p>Named list of further arguments passed to divergence measure functions.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_component">component</code></td>
<td>
<p>Character vector specifying component(s) to scale
(default is both &quot;prior&quot; and &quot;likelihood&quot;).</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_sensitivity_threshold">sensitivity_threshold</code></td>
<td>
<p>Threshold for flagging variable as
sensitive to power-scaling.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_moment_match">moment_match</code></td>
<td>
<p>Logical; Indicate whether or not moment
matching should be performed. Can only be TRUE if <code>is_method</code> is
&quot;psis&quot;.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_k_threshold">k_threshold</code></td>
<td>
<p>Threshold value for Pareto k values above which
the moment matching algorithm is used. Default is 0.5.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_resample">resample</code></td>
<td>
<p>Logical; Indicate whether or not draws should be
resampled based on calculated importance weights.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_transform">transform</code></td>
<td>
<p>Indicate a transformation of posterior draws to
perform before sensitivity analysis. Either &quot;scale&quot; or &quot;whiten&quot;.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_prediction">prediction</code></td>
<td>
<p>Function taking the model fit and returning a
draws_df of predictions to be appended to the posterior draws</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_prior_selection">prior_selection</code></td>
<td>
<p>Numeric vector of prior partitions to include in power-scaling. Default is NULL, which takes all partitions.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_likelihood_selection">likelihood_selection</code></td>
<td>
<p>Numeric vector of likelihood partitions to include in power-scaling. Default is NULL, which takes all partitions.</p>
</td></tr>
<tr><td><code id="powerscale-sensitivity_+3A_num_args">num_args</code></td>
<td>
<p>(named list) Optional arguments passed to
<a href="tibble.html#topic+num">num()</a> for pretty printing of summaries. Can be
controlled globally via the <code>posterior.num_args</code>
<a href="base.html#topic+options">option</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Table of sensitivity values for each specified variable.
</p>


<h3>References</h3>

<p>Kallioinen, N., Paananen, T., Bürkner, P-C., Vehtari, A. (2023).
Detecting and diagnosing prior and likelihood sensitivity with
power-scaling perturbations.  <em>Statistics and
Computing</em>. 34(57).  <code>doi:10.1007/s11222-023-10366-5</code>
</p>
<p>Vehtari, A., Simpson, D., Gelman, A., Yao, Y., and Gabry,
J. (2024).  Pareto smoothed importance sampling. <em>Journal of
Machine Learning Research</em>. 25(72).
<code>https://jmlr.org/papers/v25/19-556.html</code>
</p>
<p>Paananen, T., Piironen, J., Bürkner, P-C., Vehtari, A. (2021).
Implicitly adaptive importance sampling.  <em>Statistics and
Computing</em>. 31(16).  <code>doi:10.1007/s11222-020-09982-2</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- example_powerscale_model()
powerscale_sensitivity(ex$draws)
</code></pre>

<hr>
<h2 id='predictions_as_draws'>brms predictions as draws</h2><span id='topic+predictions_as_draws'></span>

<h3>Description</h3>

<p>Create predictions using brms functions and convert them into
draws format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictions_as_draws(
  x,
  predict_fn,
  prediction_names = NULL,
  warn_dims = getOption("priorsense.warn", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictions_as_draws_+3A_x">x</code></td>
<td>
<p>brmsfit object</p>
</td></tr>
<tr><td><code id="predictions_as_draws_+3A_predict_fn">predict_fn</code></td>
<td>
<p>function for predictions</p>
</td></tr>
<tr><td><code id="predictions_as_draws_+3A_prediction_names">prediction_names</code></td>
<td>
<p>optional names of the predictions</p>
</td></tr>
<tr><td><code id="predictions_as_draws_+3A_warn_dims">warn_dims</code></td>
<td>
<p>throw a warning when coercing predict_fn's output from 3
margins to 2 margins?</p>
</td></tr>
<tr><td><code id="predictions_as_draws_+3A_...">...</code></td>
<td>
<p>further arguments passed to predict_fn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>draws array of predictions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(brms)

if ("log_prior_draws.brmsfit" %in% methods(log_prior_draws) &amp;&amp;
    ("log_lik_draws.brmsfit" %in% methods(log_lik_draws))) {
  fit &lt;- brm(
    yield ~ N * P * K,
    data = npk,
    prior = prior(normal(0, 1), class = "b"),
    refresh = 0
  )

  powerscale_sensitivity(
      fit,
      variable = "_pred",
      prediction = function(x) predictions_as_draws(
                                 x, brms::posterior_epred
                               )
  )
}

## End(Not run)
</code></pre>

<hr>
<h2 id='scaled_log_ratio'>Calculate importance ratios based on scaling of component</h2><span id='topic+scaled_log_ratio'></span>

<h3>Description</h3>

<p>Calculate importance ratios based on scaling of component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaled_log_ratio(component_draws, alpha, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaled_log_ratio_+3A_component_draws">component_draws</code></td>
<td>
<p>draws from component to powerscale</p>
</td></tr>
<tr><td><code id="scaled_log_ratio_+3A_alpha">alpha</code></td>
<td>
<p>scaling factor</p>
</td></tr>
<tr><td><code id="scaled_log_ratio_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log ratio
</p>

<hr>
<h2 id='weighted_quantities'>Weighted quantities</h2><span id='topic+weighted_quantities'></span>

<h3>Description</h3>

<p>Weighted version of common quantities of interest.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_quantities_+3A_x">x</code></td>
<td>
<p>Numeric vector to calculate quantity from.</p>
</td></tr>
<tr><td><code id="weighted_quantities_+3A_weights">weights</code></td>
<td>
<p>Vector of weights corresponding to values in x.</p>
</td></tr>
<tr><td><code id="weighted_quantities_+3A_probs">probs</code></td>
<td>
<p>Vector of probabilities for quantiles.</p>
</td></tr>
<tr><td><code id="weighted_quantities_+3A_type">type</code></td>
<td>
<p>Character vector specifying type of quantiles (either
&quot;7&quot; for Type 7 (default) or &quot;hd&quot; for Harrell-Davis)</p>
</td></tr>
<tr><td><code id="weighted_quantities_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector of calculated quantity.
</p>

<hr>
<h2 id='weighted_summary_measures'>Weighted summary measures</h2><span id='topic+weighted_summary_measures'></span>

<h3>Description</h3>

<p>Returns weighted versions of
<code>posterior::default_summary_measures()</code> to be used with
<code>posterior::summarise_draws()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_summary_measures(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_summary_measures_+3A_x">x</code></td>
<td>
<p>draws object to extract weights from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of formulas for use with <code>posterior::summarise_draws()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
