<!DOCTYPE html><html><head><title>Help for package smoof</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smoof}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#smoof-package'><p>smoof: Single and Multi-Objective Optimization test functions.</p></a></li>
<li><a href='#addCountingWrapper'><p>Return a function which counts its function evaluations.</p></a></li>
<li><a href='#addLoggingWrapper'><p>Return a function which internally stores x or y values.</p></a></li>
<li><a href='#autoplot.smoof_function'><p>Generate ggplot2 object.</p></a></li>
<li><a href='#computeExpectedRunningTime'><p>Compute the Expected Running Time (ERT) performance measure.</p></a></li>
<li><a href='#conversion'><p>Conversion between minimization and maximization problems.</p></a></li>
<li><a href='#doesCountEvaluations'><p>Check whether the function is counting its function evaluations.</p></a></li>
<li><a href='#filterFunctionsByTags'><p>Get a list of implemented test functions with specific tags.</p></a></li>
<li><a href='#getAvailableTags'><p>Returns a character vector of possible function tags.</p></a></li>
<li><a href='#getDescription'><p>Return the description of the function.</p></a></li>
<li><a href='#getGlobalOptimum'><p>Returns the global optimum and its value.</p></a></li>
<li><a href='#getID'><p>Return the ID / short name of the function or <code>NA</code> if no ID is set.</p></a></li>
<li><a href='#getLocalOptimum'><p>Returns the local optima of a single objective smoof function.</p></a></li>
<li><a href='#getLoggedValues'><p>Extract logged values of a function wrapped by a logging wrapper.</p></a></li>
<li><a href='#getLowerBoxConstraints'><p>Return lower box constaints.</p></a></li>
<li><a href='#getMeanFunction'><p>Return the true mean function in the noisy case.</p></a></li>
<li><a href='#getName'><p>Return the name of the function.</p></a></li>
<li><a href='#getNumberOfEvaluations'><p>Return the number of function evaluations performed by the wrapped</p>
<code>smoof_function</code>.</a></li>
<li><a href='#getNumberOfObjectives'><p>Determine the number of objectives.</p></a></li>
<li><a href='#getNumberOfParameters'><p>Determine the number of parameters.</p></a></li>
<li><a href='#getParamSet'><p>Get parameter set.</p></a></li>
<li><a href='#getRefPoint'><p>Returns the reference point of a multi-objective function.</p></a></li>
<li><a href='#getTags'><p>Returns vector of associated tags.</p></a></li>
<li><a href='#getUpperBoxConstraints'><p>Return upper box constaints.</p></a></li>
<li><a href='#getWrappedFunction'><p>Extract wrapped function.</p></a></li>
<li><a href='#hasBoxConstraints'><p>Checks whether the objective function has box constraints.</p></a></li>
<li><a href='#hasConstraints'><p>Checks whether the objective function has constraints.</p></a></li>
<li><a href='#hasGlobalOptimum'><p>Checks whether global optimum is known.</p></a></li>
<li><a href='#hasLocalOptimum'><p>Checks whether local optima are known.</p></a></li>
<li><a href='#hasOtherConstraints'><p>Checks whether the objective function has other constraints.</p></a></li>
<li><a href='#hasTags'><p>Check if function has assigend special tags.</p></a></li>
<li><a href='#isMultiobjective'><p>Checks whether the given function is multi-objective.</p></a></li>
<li><a href='#isNoisy'><p>Checks whether the given function is noisy.</p></a></li>
<li><a href='#isSingleobjective'><p>Checks whether the given function is single-objective.</p></a></li>
<li><a href='#isSmoofFunction'><p>Checks whether the given object is a <code>smoof_function</code> or a</p>
<code>smoof_wrapped_function</code>.</a></li>
<li><a href='#isVectorized'><p>Checks whether the given function accept &ldquo;vectorized&rdquo; input.</p></a></li>
<li><a href='#isWrappedSmoofFunction'><p>Checks whether the function is of type <code>smoof_wrapped_function</code>.</p></a></li>
<li><a href='#makeAckleyFunction'><p>Ackley Function</p></a></li>
<li><a href='#makeAdjimanFunction'><p>Adjiman function</p></a></li>
<li><a href='#makeAlpine01Function'><p>Alpine01 function</p></a></li>
<li><a href='#makeAlpine02Function'><p>Alpine02 function</p></a></li>
<li><a href='#makeAluffiPentiniFunction'><p>Aluffi-Pentini function.</p></a></li>
<li><a href='#makeBartelsConnFunction'><p>Bartels Conn Function</p></a></li>
<li><a href='#makeBBOBFunction'><p>Generator for the noiseless function set of the real-parameter Black-Box</p>
Optimization Benchmarking (BBOB).</a></li>
<li><a href='#makeBealeFunction'><p>Beale Function</p></a></li>
<li><a href='#makeBentCigarFunction'><p>Bent-Cigar Function</p></a></li>
<li><a href='#makeBiObjBBOBFunction'><p>Generator for the function set of the real-parameter Bi-Objective</p>
Black-Box Optimization Benchmarking (BBOB).</a></li>
<li><a href='#makeBirdFunction'><p>Bird Function</p></a></li>
<li><a href='#makeBiSphereFunction'><p>Bi-objective Sphere function</p></a></li>
<li><a href='#makeBK1Function'><p>BK1 function generator</p></a></li>
<li><a href='#makeBohachevskyN1Function'><p>Bohachevsky function N. 1</p></a></li>
<li><a href='#makeBoothFunction'><p>Booth Function</p></a></li>
<li><a href='#makeBraninFunction'><p>Branin RCOS function</p></a></li>
<li><a href='#makeBrentFunction'><p>Brent Function</p></a></li>
<li><a href='#makeBrownFunction'><p>Brown Function</p></a></li>
<li><a href='#makeBukinN2Function'><p>Bukin function N. 2</p></a></li>
<li><a href='#makeBukinN4Function'><p>Bukin function N. 4</p></a></li>
<li><a href='#makeBukinN6Function'><p>Bukin function N. 6</p></a></li>
<li><a href='#makeCarromTableFunction'><p>Carrom Table Function</p></a></li>
<li><a href='#makeChichinadzeFunction'><p>Chichinadze Function</p></a></li>
<li><a href='#makeChungReynoldsFunction'><p>Chung Reynolds Function</p></a></li>
<li><a href='#makeComplexFunction'><p>Complex function.</p></a></li>
<li><a href='#makeCosineMixtureFunction'><p>Cosine Mixture Function</p></a></li>
<li><a href='#makeCrossInTrayFunction'><p>Cross-In-Tray Function</p></a></li>
<li><a href='#makeCubeFunction'><p>Cube Function</p></a></li>
<li><a href='#makeDeckkersAartsFunction'><p>Deckkers-Aarts Function</p></a></li>
<li><a href='#makeDeflectedCorrugatedSpringFunction'><p>Deflected Corrugated Spring function</p></a></li>
<li><a href='#makeDentFunction'><p>Dent Function</p></a></li>
<li><a href='#makeDixonPriceFunction'><p>Dixon-Price Function</p></a></li>
<li><a href='#makeDoubleSumFunction'><p>Double-Sum Function</p></a></li>
<li><a href='#makeDTLZ1Function'><p>DTLZ1 Function (family)</p></a></li>
<li><a href='#makeDTLZ2Function'><p>DTLZ2 Function (family)</p></a></li>
<li><a href='#makeDTLZ3Function'><p>DTLZ3 Function (family)</p></a></li>
<li><a href='#makeDTLZ4Function'><p>DTLZ4 Function (family)</p></a></li>
<li><a href='#makeDTLZ5Function'><p>DTLZ5 Function (family)</p></a></li>
<li><a href='#makeDTLZ6Function'><p>DTLZ6 Function (family)</p></a></li>
<li><a href='#makeDTLZ7Function'><p>DTLZ7 Function (family)</p></a></li>
<li><a href='#makeEasomFunction'><p>Easom Function</p></a></li>
<li><a href='#makeED1Function'><p>ED1 Function</p></a></li>
<li><a href='#makeED2Function'><p>ED2 Function</p></a></li>
<li><a href='#makeEggCrateFunction'><p>Egg Crate Function</p></a></li>
<li><a href='#makeEggholderFunction'><p>Egg Holder function</p></a></li>
<li><a href='#makeElAttarVidyasagarDuttaFunction'><p>El-Attar-Vidyasagar-Dutta Function</p></a></li>
<li><a href='#makeEngvallFunction'><p>Complex function.</p></a></li>
<li><a href='#makeExponentialFunction'><p>Exponential Function</p></a></li>
<li><a href='#makeFreudensteinRothFunction'><p>Freudenstein Roth Function</p></a></li>
<li><a href='#makeFunctionsByName'><p>Generate smoof function by passing a character vector of generator</p>
names.</a></li>
<li><a href='#makeGeneralizedDropWaveFunction'><p>Generalized Drop-Wave Function</p></a></li>
<li><a href='#makeGiuntaFunction'><p>Giunta Function</p></a></li>
<li><a href='#makeGoldsteinPriceFunction'><p>Goldstein-Price Function</p></a></li>
<li><a href='#makeGOMOPFunction'><p>GOMOP function generator.</p></a></li>
<li><a href='#makeGriewankFunction'><p>Griewank Function</p></a></li>
<li><a href='#makeHansenFunction'><p>Hansen Function</p></a></li>
<li><a href='#makeHartmannFunction'><p>Hartmann Function</p></a></li>
<li><a href='#makeHimmelblauFunction'><p>Himmelblau Function</p></a></li>
<li><a href='#makeHolderTableN1Function'><p>Holder Table function N. 1</p></a></li>
<li><a href='#makeHolderTableN2Function'><p>Holder Table function N. 2</p></a></li>
<li><a href='#makeHosakiFunction'><p>Hosaki Function</p></a></li>
<li><a href='#makeHyperEllipsoidFunction'><p>Hyper-Ellipsoid function</p></a></li>
<li><a href='#makeInvertedVincentFunction'><p>Inverted Vincent Function</p></a></li>
<li><a href='#makeJennrichSampsonFunction'><p>Jennrich-Sampson function.</p></a></li>
<li><a href='#makeJudgeFunction'><p>Judge function.</p></a></li>
<li><a href='#makeKeaneFunction'><p>Keane Function</p></a></li>
<li><a href='#makeKearfottFunction'><p>Kearfott function.</p></a></li>
<li><a href='#makeKursaweFunction'><p>Kursawe Function</p></a></li>
<li><a href='#makeLeonFunction'><p>Leon Function</p></a></li>
<li><a href='#makeMatyasFunction'><p>Matyas Function</p></a></li>
<li><a href='#makeMcCormickFunction'><p>McCormick Function</p></a></li>
<li><a href='#makeMichalewiczFunction'><p>Michalewicz Function</p></a></li>
<li><a href='#makeMMF10Function'><p>MMF10 Function</p></a></li>
<li><a href='#makeMMF11Function'><p>MMF11 Function</p></a></li>
<li><a href='#makeMMF12Function'><p>MMF12 Function</p></a></li>
<li><a href='#makeMMF13Function'><p>MMF13 Function</p></a></li>
<li><a href='#makeMMF14aFunction'><p>MMF14a Function</p></a></li>
<li><a href='#makeMMF14Function'><p>MMF14 Function</p></a></li>
<li><a href='#makeMMF15aFunction'><p>MMF15a Function</p></a></li>
<li><a href='#makeMMF15Function'><p>MMF15 Function</p></a></li>
<li><a href='#makeMMF1eFunction'><p>MMF1e Function</p></a></li>
<li><a href='#makeMMF1Function'><p>MMF1 Function</p></a></li>
<li><a href='#makeMMF1zFunction'><p>MMF1z Function</p></a></li>
<li><a href='#makeMMF2Function'><p>MMF2 Function</p></a></li>
<li><a href='#makeMMF3Function'><p>MMF3 Function</p></a></li>
<li><a href='#makeMMF4Function'><p>MMF4 Function</p></a></li>
<li><a href='#makeMMF5Function'><p>MMF5 Function</p></a></li>
<li><a href='#makeMMF6Function'><p>MMF6 Function</p></a></li>
<li><a href='#makeMMF7Function'><p>MMF7 Function</p></a></li>
<li><a href='#makeMMF8Function'><p>MMF8 Function</p></a></li>
<li><a href='#makeMMF9Function'><p>MMF9 Function</p></a></li>
<li><a href='#makeModifiedRastriginFunction'><p>Rastrigin Function</p></a></li>
<li><a href='#makeMOP1Function'><p>MOP1 function generator.</p></a></li>
<li><a href='#makeMOP2Function'><p>MOP2 function generator.</p></a></li>
<li><a href='#makeMOP3Function'><p>MOP3 function generator.</p></a></li>
<li><a href='#makeMOP4Function'><p>MOP4 function generator.</p></a></li>
<li><a href='#makeMOP5Function'><p>MOP5 function generator.</p></a></li>
<li><a href='#makeMOP6Function'><p>MOP6 function generator.</p></a></li>
<li><a href='#makeMOP7Function'><p>MOP7 function generator.</p></a></li>
<li><a href='#makeMPM2Function'><p>Generator for function with multiple peaks following the multiple peaks model 2.</p></a></li>
<li><a href='#makeMultiObjectiveFunction'><p>Generator for multi-objective target functions.</p></a></li>
<li><a href='#makeOmniTestFunction'><p>MMF13 Function</p></a></li>
<li><a href='#makePeriodicFunction'><p>Periodic Function</p></a></li>
<li><a href='#makePowellSumFunction'><p>Powell-Sum Function</p></a></li>
<li><a href='#makePriceN1Function'><p>Price Function N. 1</p></a></li>
<li><a href='#makePriceN2Function'><p>Price Function N. 2</p></a></li>
<li><a href='#makePriceN4Function'><p>Price Function N. 4</p></a></li>
<li><a href='#makeRastriginFunction'><p>Rastrigin Function</p></a></li>
<li><a href='#makeRosenbrockFunction'><p>Rosenbrock Function</p></a></li>
<li><a href='#makeSchafferN2Function'><p>Modified Schaffer Function N. 2</p></a></li>
<li><a href='#makeSchafferN4Function'><p>Schaffer Function N. 4</p></a></li>
<li><a href='#makeSchwefelFunction'><p>Schwefel function</p></a></li>
<li><a href='#makeShekelFunction'><p>Shekel functions</p></a></li>
<li><a href='#makeShubertFunction'><p>Shubert Function</p></a></li>
<li><a href='#makeSingleObjectiveFunction'><p>Generator for single-objective target functions.</p></a></li>
<li><a href='#makeSixHumpCamelFunction'><p>Three-Hump Camel Function</p></a></li>
<li><a href='#makeSphereFunction'><p>Sphere Function</p></a></li>
<li><a href='#makeStyblinkskiTangFunction'><p>Styblinkski-Tang function</p></a></li>
<li><a href='#makeSumOfDifferentSquaresFunction'><p>Sum of Different Squares Function</p></a></li>
<li><a href='#makeSwiler2014Function'><p>Swiler2014 function.</p></a></li>
<li><a href='#makeSYMPARTrotatedFunction'><p>MMF13 Function</p></a></li>
<li><a href='#makeSYMPARTsimpleFunction'><p>MMF13 Function</p></a></li>
<li><a href='#makeThreeHumpCamelFunction'><p>Three-Hump Camel Function</p></a></li>
<li><a href='#makeTrecanniFunction'><p>Trecanni Function</p></a></li>
<li><a href='#makeUFFunction'><p>Generator for the functions UF1, ..., UF10 of the CEC 2009.</p></a></li>
<li><a href='#makeViennetFunction'><p>Viennet function generator</p></a></li>
<li><a href='#makeWFG1Function'><p>WFG1 Function</p></a></li>
<li><a href='#makeWFG2Function'><p>WFG2 Function</p></a></li>
<li><a href='#makeWFG3Function'><p>WFG3 Function</p></a></li>
<li><a href='#makeWFG4Function'><p>WFG4 Function</p></a></li>
<li><a href='#makeWFG5Function'><p>WFG5 Function</p></a></li>
<li><a href='#makeWFG6Function'><p>WFG6 Function</p></a></li>
<li><a href='#makeWFG7Function'><p>WFG7 Function</p></a></li>
<li><a href='#makeWFG8Function'><p>WFG8 Function</p></a></li>
<li><a href='#makeWFG9Function'><p>WFG9 Function</p></a></li>
<li><a href='#makeZDT1Function'><p>ZDT1 Function</p></a></li>
<li><a href='#makeZDT2Function'><p>ZDT2 Function</p></a></li>
<li><a href='#makeZDT3Function'><p>ZDT3 Function</p></a></li>
<li><a href='#makeZDT4Function'><p>ZDT4 Function</p></a></li>
<li><a href='#makeZDT6Function'><p>ZDT6 Function</p></a></li>
<li><a href='#makeZettlFunction'><p>Zettl Function</p></a></li>
<li><a href='#mnof'><p>Helper function to create numeric multi-objective optimization test function.</p></a></li>
<li><a href='#plot.smoof_function'><p>Generate ggplot2 object.</p></a></li>
<li><a href='#plot1DNumeric'><p>Plot an one-dimensional function.</p></a></li>
<li><a href='#plot2DNumeric'><p>Plot a two-dimensional numeric function.</p></a></li>
<li><a href='#plot3D'><p>Surface plot of two-dimensional test function.</p></a></li>
<li><a href='#resetEvaluationCounter'><p>Reset evaluation counter.</p></a></li>
<li><a href='#shouldBeMinimized'><p>Check if function should be minimized.</p></a></li>
<li><a href='#smoof_function'><p>Smoof function</p></a></li>
<li><a href='#snof'><p>Helper function to create numeric single-objective optimization test function.</p></a></li>
<li><a href='#violatesConstraints'><p>Checks whether constraints are violated.</p></a></li>
<li><a href='#visualizeParetoOptimalFront'><p>Pareto-optimal front visualization.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Single and Multi-Objective Optimization Test Functions</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides generators for a high number of both single- and multi-
    objective test functions which are frequently used for the benchmarking of
    (numerical) optimization algorithms. Moreover, it offers a set of convenient
    functions to generate, plot and work with objective functions.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakob Bossek &lt;j.bossek@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jakobbossek.github.io/smoof/">https://jakobbossek.github.io/smoof/</a>,
<a href="https://github.com/jakobbossek/smoof">https://github.com/jakobbossek/smoof</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jakobbossek/smoof/issues">https://github.com/jakobbossek/smoof/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>ParamHelpers (&ge; 1.8), checkmate (&ge; 1.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>BBmisc (&ge; 1.6), ggplot2 (&ge; 2.2.1), Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, plot3D, plotly, mco, RColorBrewer, reticulate, covr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-08 15:45:18 UTC; bossek</td>
</tr>
<tr>
<td>Author:</td>
<td>Jakob Bossek <a href="https://orcid.org/0000-0002-4121-4668"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Pascal Kerschke <a href="https://orcid.org/0000-0003-2862-1418"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-10 14:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='smoof-package'>smoof: Single and Multi-Objective Optimization test functions.</h2><span id='topic+smoof-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">smoof</span> R package provides generators for huge set of single- and
multi-objective test functions, which are frequently used in the literature
to benchmark optimization algorithms. Moreover the package provides methods
to create arbitrary objective functions in an object-orientated manner, extract
their parameters sets and visualize them graphically.
</p>


<h3>Some more details</h3>

<p>Given a set of criteria <code class="reqn">\mathcal{F} = \{f_1, \ldots, f_m\}</code> with each
<code class="reqn">f_i : S \subseteq \mathbf{R}^d \to \mathbf{R} , i = 1, \ldots, m</code> being an
objective-function, the goal in <em>Global Optimization (GO)</em> is to find the best
solution <code class="reqn">\mathbf{x}^* \in S</code>. The set <code class="reqn">S</code> is termed the <em>set of
feasible soluations</em>. In the case of only a single objective function <code class="reqn">f</code>,
- which we want to restrict ourself in this brief description - the goal is to
minimize the objective, i. e., </p>
<p style="text-align: center;"><code class="reqn">\min_{\mathbf{x}} f(\mathbf{x}).</code>
</p>

<p>Sometimes we may be interested in maximizing the objective function value, but
since <code class="reqn">min(f(\mathbf{x})) = -\min(-f(\mathbf{x}))</code>, we do not have to tackle
this separately.
To compare the robustness of optimization algorithms and to investigate their behaviour
in different contexts, a common approach in the literature is to use <em>artificial
benchmarking functions</em>, which are mostly deterministic, easy to evaluate and given
by a closed mathematical formula.
A recent survey by Jamil and Yang lists 175 single-objective benchmarking functions
in total for global optimization [1]. The <span class="pkg">smoof</span> package offers implementations
of a subset of these functions beside some other functions as well as
generators for large benchmarking sets like the noiseless BBOB2009 function set [2]
or functions based on the multiple peaks model 2 [3].
</p>


<h3>References</h3>

<p>[1] Momin Jamil and Xin-She Yang, A literature survey of benchmark
functions for global optimization problems, Int. Journal of Mathematical
Modelling and Numerical Optimisation, Vol. 4, No. 2, pp. 150-194 (2013).
[2] Hansen, N., Finck, S., Ros, R. and Auger, A. Real-Parameter Black-Box
Optimization Benchmarking 2009: Noiseless Functions Definitions. Technical report
RR-6829. INRIA, 2009.
[3] Simon Wessing, The Multiple Peaks Model 2, Algorithm Engineering Report
TR15-2-001, TU Dortmund University, 2015.
</p>

<hr>
<h2 id='addCountingWrapper'>Return a function which counts its function evaluations.</h2><span id='topic+addCountingWrapper'></span>

<h3>Description</h3>

<p>This is a counting wrapper for a <code>smoof_function</code>, i.e., the returned function
first checks whether the given argument is a vector or matrix, saves the
number of function evaluations of the wrapped function to compute the function
values and finally passes down the argument to the wrapped <code>smoof_function</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCountingWrapper(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCountingWrapper_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Smoof function which should be wrapped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_counting_function</code>]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getNumberOfEvaluations">getNumberOfEvaluations</a></code>, <code><a href="#topic+resetEvaluationCounter">resetEvaluationCounter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn = makeBBOBFunction(dimensions = 2L, fid = 1L, iid = 1L)
fn = addCountingWrapper(fn)

# we get a value of 0 since the function has not been called yet
print(getNumberOfEvaluations(fn))

# now call the function 10 times consecutively
for (i in seq(10L)) {
  fn(runif(2))
}
print(getNumberOfEvaluations(fn))

# Here we pass a (2x5) matrix to the function with each column representing
# one input vector
x = matrix(runif(10), ncol = 5L)
fn(x)
print(getNumberOfEvaluations(fn))
</code></pre>

<hr>
<h2 id='addLoggingWrapper'>Return a function which internally stores x or y values.</h2><span id='topic+addLoggingWrapper'></span>

<h3>Description</h3>

<p>Often it is desired and useful to store the optimization path, i.e., the evaluated
function values and/or the parameters. Not all optimization algorithms offer
such a trace. This wrapper makes a smoof function handle x/y-values itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLoggingWrapper(fn, logg.x = FALSE, logg.y = TRUE, size = 100L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLoggingWrapper_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Smoof function.</p>
</td></tr>
<tr><td><code id="addLoggingWrapper_+3A_logg.x">logg.x</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should x-values be logged?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="addLoggingWrapper_+3A_logg.y">logg.y</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should objective values be logged?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="addLoggingWrapper_+3A_size">size</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Initial size of the internal data structures used for logging.
Default is 100. I.e., there is space reserved for 100 function evaluations.
In case of an overflow (i.e., more function evaluations than space reserved)
the data structures are re-initialized by adding space for another <code>size</code> evaluations.
This comes handy if you know the number of function evaluations (or at least
an upper bound thereof) a-priori and may serve to reduce the time complextity
of logging values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_logging_function</code>]
</p>


<h3>Note</h3>

<p>Logging values, in particular logging x-values, will substantially slow
down the evaluation of the function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We first build the smoof function and apply the logging wrapper to it
fn = makeSphereFunction(dimensions = 2L)
fn = addLoggingWrapper(fn, logg.x = TRUE)

# We now apply an optimization algorithm to it and the logging wrapper keeps
# track of the evaluated points.
res = optim(fn, par = c(1, 1), method = "Nelder-Mead")

# Extract the logged values
log.res = getLoggedValues(fn)
print(log.res$pars)
print(log.res$obj.vals)
log.res = getLoggedValues(fn, compact = TRUE)
print(log.res)

</code></pre>

<hr>
<h2 id='autoplot.smoof_function'>Generate ggplot2 object.</h2><span id='topic+autoplot.smoof_function'></span>

<h3>Description</h3>

<p>This function expects a smoof function and returns a ggplot object depicting
the function landscape. The output depends highly on the decision space of the
smoof function or more technically on the <code><a href="ParamHelpers.html#topic+ParamSet">ParamSet</a></code>
of the function. The following destinctions regarding the parameter types are
made. In case of a single numeric parameter a simple line plot is drawn. For
two numeric parameters or a single numeric vector parameter of length 2 either a
contour plot or a heatmap (or a combination of both depending on the choice
of additional parameters) is depicted. If there are both up to two numeric
and at least one discrete vector parameter, ggplot facetting is used to
generate subplots of the above-mentioned types for all combinations of discrete
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smoof_function'
autoplot(
  object,
  ...,
  show.optimum = FALSE,
  main = getName(x),
  render.levels = FALSE,
  render.contours = TRUE,
  log.scale = FALSE,
  length.out = 50L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.smoof_function_+3A_object">object</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
<tr><td><code id="autoplot.smoof_function_+3A_...">...</code></td>
<td>
<p>[any]<br />
Not used.</p>
</td></tr>
<tr><td><code id="autoplot.smoof_function_+3A_show.optimum">show.optimum</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If the function has a known global optimum, should its location be
plotted by a point or multiple points in case of multiple global optima?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.smoof_function_+3A_main">main</code></td>
<td>
<p>[<code>character(1L)</code>]<br />
Plot title.
Default is the name of the smoof function.</p>
</td></tr>
<tr><td><code id="autoplot.smoof_function_+3A_render.levels">render.levels</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
For 2D numeric functions only: Should an image map be plotted? Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.smoof_function_+3A_render.contours">render.contours</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
For 2D numeric functions only: Should contour lines be plotted? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.smoof_function_+3A_log.scale">log.scale</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the z-axis be plotted on log-scale?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.smoof_function_+3A_length.out">length.out</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Desired length of the sequence of equidistant values generated for numeric parameters.
Higher values lead to more smooth resolution in particular if <code>render.levels</code>
is <code>TRUE</code>. Avoid using a very high value here especially if the function
at hand has many parameters.
Default is 50.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>]
</p>


<h3>Note</h3>

<p>Keep in mind, that the plots for mixed parameter spaces may be very large and
computationally expensive if the number of possible discrete parameter values
is large. I.e., if we have d discrete parameter with each n_1, n_2, ..., n_d
possible values we end up with n_1 x n_2 x ... x n_d subplots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

# Simple 2D contour plot with activated heatmap for the Himmelblau function
fn = makeHimmelblauFunction()
print(autoplot(fn))
print(autoplot(fn, render.levels = TRUE, render.contours = FALSE))
print(autoplot(fn, show.optimum = TRUE))

# Now we create 4D function with a mixed decision space (two numeric, one discrete,
# and one logical parameter)
fn.mixed = makeSingleObjectiveFunction(
  name = "4d SOO function",
  fn = function(x) {
    if (x$disc1 == "a") {
      (x$x1^2 + x$x2^2) + 10 * as.numeric(x$logic)
    } else {
      x$x1 + x$x2 - 10 * as.numeric(x$logic)
    }
  },
  has.simple.signature = FALSE,
  par.set = makeParamSet(
    makeNumericParam("x1", lower = -5, upper = 5),
    makeNumericParam("x2", lower = -3, upper = 3),
    makeDiscreteParam("disc1", values = c("a", "b")),
    makeLogicalParam("logic")
  )
)
pl = autoplot(fn.mixed)
print(pl)

# Since autoplot returns a ggplot object we can modify it, e.g., add a title
# or hide the legend
pl + ggtitle("My fancy function") + theme(legend.position = "none")
</code></pre>

<hr>
<h2 id='computeExpectedRunningTime'>Compute the Expected Running Time (ERT) performance measure.</h2><span id='topic+computeExpectedRunningTime'></span>

<h3>Description</h3>

<p>The functions can be called in two different ways
</p>

<ul>
<li><p>1. Pass a vector of function evaluations and a logical vector which
indicates which runs were successful (see details).
</p>
</li>
<li><p>2. Pass a vector of function evaluation, a vector of reached target
values and a single target value. In this case the logical vector of
option 1. is computed internally.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>computeExpectedRunningTime(
  fun.evals,
  fun.success.runs = NULL,
  fun.reached.target.values = NULL,
  fun.target.value = NULL,
  penalty.value = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeExpectedRunningTime_+3A_fun.evals">fun.evals</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector containing the number of function evaluations.</p>
</td></tr>
<tr><td><code id="computeExpectedRunningTime_+3A_fun.success.runs">fun.success.runs</code></td>
<td>
<p>[<code>logical</code>]<br />
Boolean vector indicating which algorithm runs were successful,
i. e., which runs reached the desired target value. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="computeExpectedRunningTime_+3A_fun.reached.target.values">fun.reached.target.values</code></td>
<td>
<p>[<code>numeric</code> | <code>NULL</code>]<br />
Numeric vector with the objective values reached in the runs. Default is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="computeExpectedRunningTime_+3A_fun.target.value">fun.target.value</code></td>
<td>
<p>[<code>numeric(1)</code> | <code>NULL</code>]<br />
Target value which shall be reached. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="computeExpectedRunningTime_+3A_penalty.value">penalty.value</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Penalty value which should be returned if none of the algorithm runs
was successful. Default is <code>Inf</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Expected Running Time (ERT) is one of the most popular performance
measures in optimization. It is defined as the expected number of function
evaluations needed to reach a given precision level, i. e., to reach a certain
objective value for the first time.
</p>


<h3>Value</h3>

<p>[<code>numeric(1)</code>]
Estimated Expected Running Time.
</p>


<h3>References</h3>

<p>A. Auger and N. Hansen. Performance evaluation of an advanced local
search evolutionary algorithm. In Proceedings of the IEEE Congress on Evolutionary
Computation (CEC 2005), pages 1777-1784, 2005.
</p>

<hr>
<h2 id='conversion'>Conversion between minimization and maximization problems.</h2><span id='topic+conversion'></span><span id='topic+convertToMaximization'></span><span id='topic+convertToMinimization'></span>

<h3>Description</h3>

<p>We can minimize f by maximizing -f. The majority of predefined objective functions
in <span class="pkg">smoof</span> should be minimized by default. However, there is a handful of
functions, e.g., Keane or Alpine02, which shall be maximized by default.
For benchmarking studies it might be beneficial to inverse the direction.
The functions <code>convertToMaximization</code> and <code>convertToMinimization</code>
do exactly that keeping the attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertToMaximization(fn)

convertToMinimization(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conversion_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Smoof function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_function</code>]
</p>


<h3>Note</h3>

<p>Both functions will quit with an error if multi-objective functions are passed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a function which should be minimized by default
fn = makeSphereFunction(1L)
print(shouldBeMinimized(fn))
# Now invert the objective direction ...
fn2 = convertToMaximization(fn)
# and invert it again
fn3 = convertToMinimization(fn2)
# Now to convince ourselves we render some plots
opar = par(mfrow = c(1, 3))
plot(fn)
plot(fn2)
plot(fn3)
par(opar)
</code></pre>

<hr>
<h2 id='doesCountEvaluations'>Check whether the function is counting its function evaluations.</h2><span id='topic+doesCountEvaluations'></span>

<h3>Description</h3>

<p>In this case the function is of type <code>smoof_counting_function</code> or it
is further wrapped by another wrapper. This function then checks recursively,
if there is a counting wrapper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doesCountEvaluations(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doesCountEvaluations_+3A_object">object</code></td>
<td>
<p>[any]<br />
Arbitrary R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical(1)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addCountingWrapper">addCountingWrapper</a></code>
</p>

<hr>
<h2 id='filterFunctionsByTags'>Get a list of implemented test functions with specific tags.</h2><span id='topic+filterFunctionsByTags'></span>

<h3>Description</h3>

<p>Single objective functions can be tagged, e.g., as unimodal. Searching for all
functions with a specific tag by hand is tedious. The <code>filterFunctionsByTags</code>
function helps to filter all single objective smoof function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterFunctionsByTags(tags, or = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterFunctionsByTags_+3A_tags">tags</code></td>
<td>
<p>[<code>character</code>]<br />
Character vector of tags. All available tags can be determined with a call
to <code><a href="#topic+getAvailableTags">getAvailableTags</a></code>.</p>
</td></tr>
<tr><td><code id="filterFunctionsByTags_+3A_or">or</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should all <code>tags</code> be assigned to the function or are single tags allowed
as well?
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>character</code>]
Named vector of function names with the given tags.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># list all functions which are unimodal
filterFunctionsByTags("unimodal")
# list all functions which are both unimodal and separable
filterFunctionsByTags(c("unimodal", "separable"))
# list all functions which are unimodal or separable
filterFunctionsByTags(c("multimodal", "separable"), or = TRUE)
</code></pre>

<hr>
<h2 id='getAvailableTags'>Returns a character vector of possible function tags.</h2><span id='topic+getAvailableTags'></span>

<h3>Description</h3>

<p>Test function are frequently distinguished by characteristic high-level properties,
e.g., unimodal or multimodal, continuous or discontinuous, separable or non-separable.
The <span class="pkg">smoof</span> package offers the possibility to associate a set of properties,
termed &ldquo;tags&rdquo; to a <code>smoof_function</code>. This helper function returns
a character vector of all possible tags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAvailableTags()
</code></pre>


<h3>Value</h3>

<p>[<code>character</code>]
</p>

<hr>
<h2 id='getDescription'>Return the description of the function.</h2><span id='topic+getDescription'></span>

<h3>Description</h3>

<p>Return the description of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDescription(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDescription_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>character(1)</code>]
</p>

<hr>
<h2 id='getGlobalOptimum'>Returns the global optimum and its value.</h2><span id='topic+getGlobalOptimum'></span>

<h3>Description</h3>

<p>Returns the global optimum and its value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGlobalOptimum(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGlobalOptimum_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] List containing the following entries:
</p>

<ul>
<li><p>param [<code>list</code>]Named list of parameter value(s).
</p>
</li>
<li><p>value [<code>numeric(1)</code>]Optimal value.
</p>
</li>
<li><p>is.minimum [<code>logical(1)</code>]Is the global optimum a minimum or maximum?
</p>
</li></ul>



<h3>Note</h3>

<p>Keep in mind, that this method makes sense only for single-objective target function.
</p>

<hr>
<h2 id='getID'>Return the ID / short name of the function or <code>NA</code> if no ID is set.</h2><span id='topic+getID'></span>

<h3>Description</h3>

<p>Return the ID / short name of the function or <code>NA</code> if no ID is set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getID(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getID_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>character(1)</code>] or <code>NA</code>
</p>

<hr>
<h2 id='getLocalOptimum'>Returns the local optima of a single objective smoof function.</h2><span id='topic+getLocalOptimum'></span>

<h3>Description</h3>

<p>This function returns the parameters and objective values of
all local optima (including the global one).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLocalOptimum(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLocalOptimum_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] List containing the following entries:
</p>

<ul>
<li><p>param [<code>list</code>]List of parameter values per local optima.
</p>
</li>
<li><p>value [<code>list</code>]List of objective values per local optima.
</p>
</li>
<li><p>is.minimum [<code>logical(1)</code>]Are the local optima minima or maxima?
</p>
</li></ul>



<h3>Note</h3>

<p>Keep in mind, that this method makes sense only for single-objective target functions.
</p>

<hr>
<h2 id='getLoggedValues'>Extract logged values of a function wrapped by a logging wrapper.</h2><span id='topic+getLoggedValues'></span>

<h3>Description</h3>

<p>Extract logged values of a function wrapped by a logging wrapper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLoggedValues(fn, compact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLoggedValues_+3A_fn">fn</code></td>
<td>
<p>[<code>wrapped_smoof_function</code>]<br />
Wrapped smoof function.</p>
</td></tr>
<tr><td><code id="getLoggedValues_+3A_compact">compact</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Wrap all logged values in a single data frame? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code> || <code>data.frame</code>]
If <code>compact</code> is <code>TRUE</code>, a single data frame. Otherwise the function
returns a list containing the following values:
</p>

<dl>
<dt>pars</dt><dd><p>Data frame of parameter values, i.e., x-values or the empty
data frame if x-values were not logged.</p>
</dd>
<dt>obj.vals</dt><dd><p>Numeric vector of objective vals in the single-objective
case respectively a matrix of objective vals for multi-objective functions.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+addLoggingWrapper">addLoggingWrapper</a></code>
</p>

<hr>
<h2 id='getLowerBoxConstraints'>Return lower box constaints.</h2><span id='topic+getLowerBoxConstraints'></span>

<h3>Description</h3>

<p>Return lower box constaints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLowerBoxConstraints(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLowerBoxConstraints_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric</code>]
</p>

<hr>
<h2 id='getMeanFunction'>Return the true mean function in the noisy case.</h2><span id='topic+getMeanFunction'></span>

<h3>Description</h3>

<p>Return the true mean function in the noisy case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMeanFunction(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMeanFunction_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>function</code>]
</p>

<hr>
<h2 id='getName'>Return the name of the function.</h2><span id='topic+getName'></span>

<h3>Description</h3>

<p>Return the name of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getName(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getName_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>character(1)</code>]
</p>

<hr>
<h2 id='getNumberOfEvaluations'>Return the number of function evaluations performed by the wrapped
<code>smoof_function</code>.</h2><span id='topic+getNumberOfEvaluations'></span>

<h3>Description</h3>

<p>Return the number of function evaluations performed by the wrapped
<code>smoof_function</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumberOfEvaluations(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumberOfEvaluations_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_counting_function</code>]<br />
Wrapped <code>smoof_function</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer(1)</code>]
</p>

<hr>
<h2 id='getNumberOfObjectives'>Determine the number of objectives.</h2><span id='topic+getNumberOfObjectives'></span>

<h3>Description</h3>

<p>Determine the number of objectives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumberOfObjectives(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumberOfObjectives_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer(1)</code>]
</p>

<hr>
<h2 id='getNumberOfParameters'>Determine the number of parameters.</h2><span id='topic+getNumberOfParameters'></span>

<h3>Description</h3>

<p>Determine the number of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumberOfParameters(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumberOfParameters_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>integer(1)</code>]
</p>

<hr>
<h2 id='getParamSet'>Get parameter set.</h2><span id='topic+getParamSet'></span>

<h3>Description</h3>

<p>Each smoof function contains a parameter set of type <code><a href="ParamHelpers.html#topic+ParamSet">ParamSet</a></code>
assigned to it, which describes types and bounds of the function parameters.
This function returns the parameter set.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParamSet_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="ParamHelpers.html#topic+ParamSet">ParamSet</a></code>]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn = makeSphereFunction(3L)
ps = getParamSet(fn)
print(ps)
</code></pre>

<hr>
<h2 id='getRefPoint'>Returns the reference point of a multi-objective function.</h2><span id='topic+getRefPoint'></span>

<h3>Description</h3>

<p>Returns the reference point of a multi-objective function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRefPoint(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRefPoint_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric</code>]
</p>


<h3>Note</h3>

<p>Keep in mind, that this method makes sense only for multi-objective target functions.
</p>

<hr>
<h2 id='getTags'>Returns vector of associated tags.</h2><span id='topic+getTags'></span>

<h3>Description</h3>

<p>Returns vector of associated tags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTags(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTags_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>character</code>]
</p>

<hr>
<h2 id='getUpperBoxConstraints'>Return upper box constaints.</h2><span id='topic+getUpperBoxConstraints'></span>

<h3>Description</h3>

<p>Return upper box constaints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUpperBoxConstraints(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUpperBoxConstraints_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric</code>]
</p>

<hr>
<h2 id='getWrappedFunction'>Extract wrapped function.</h2><span id='topic+getWrappedFunction'></span>

<h3>Description</h3>

<p>The <span class="pkg">smoof</span> package offers means to let a function log its evaluations or
even store to points and function values it has been evaluated on. This is done
by wrapping the function with other functions. This helper function extract
the wrapped function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWrappedFunction(fn, deepest = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWrappedFunction_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_wrapped_function</code>]<br />
Wrapping function.</p>
</td></tr>
<tr><td><code id="getWrappedFunction_+3A_deepest">deepest</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Function may be wrapped with multiple wrappers. If <code>deepest</code> is set to
<code>TRUE</code> the function unwraps recursively until the &ldquo;deepest&rdquo; wrapped
<code>smoof_function</code> is reached. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>function</code>]
</p>


<h3>Note</h3>

<p>If this function is applied to a simple <code>smoof_function</code>, the
<code>smoof_function</code> itself is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addCountingWrapper">addCountingWrapper</a></code>, <code><a href="#topic+addLoggingWrapper">addLoggingWrapper</a></code>
</p>

<hr>
<h2 id='hasBoxConstraints'>Checks whether the objective function has box constraints.</h2><span id='topic+hasBoxConstraints'></span>

<h3>Description</h3>

<p>Checks whether the objective function has box constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasBoxConstraints(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasBoxConstraints_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='hasConstraints'>Checks whether the objective function has constraints.</h2><span id='topic+hasConstraints'></span>

<h3>Description</h3>

<p>Checks whether the objective function has constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasConstraints(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasConstraints_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='hasGlobalOptimum'>Checks whether global optimum is known.</h2><span id='topic+hasGlobalOptimum'></span>

<h3>Description</h3>

<p>Checks whether global optimum is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasGlobalOptimum(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasGlobalOptimum_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='hasLocalOptimum'>Checks whether local optima are known.</h2><span id='topic+hasLocalOptimum'></span>

<h3>Description</h3>

<p>Checks whether local optima are known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasLocalOptimum(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasLocalOptimum_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='hasOtherConstraints'>Checks whether the objective function has other constraints.</h2><span id='topic+hasOtherConstraints'></span>

<h3>Description</h3>

<p>Checks whether the objective function has other constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasOtherConstraints(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasOtherConstraints_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='hasTags'>Check if function has assigend special tags.</h2><span id='topic+hasTags'></span>

<h3>Description</h3>

<p>Each single-objective smoof function has tags assigned to it (see
<code><a href="#topic+getAvailableTags">getAvailableTags</a></code>). This little helper returns a vector of
assigned tags from a smoof function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasTags(fn, tags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasTags_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]
Function of <code>smoof_function</code>, a <code>smoof_generator</code> or a string.</p>
</td></tr>
<tr><td><code id="hasTags_+3A_tags">tags</code></td>
<td>
<p>[<code>character</code>]<br />
Vector of tags/properties to check <code>fn</code> for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='isMultiobjective'>Checks whether the given function is multi-objective.</h2><span id='topic+isMultiobjective'></span>

<h3>Description</h3>

<p>Checks whether the given function is multi-objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isMultiobjective(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isMultiobjective_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>] <code>TRUE</code> if function is multi-objective.
</p>

<hr>
<h2 id='isNoisy'>Checks whether the given function is noisy.</h2><span id='topic+isNoisy'></span>

<h3>Description</h3>

<p>Checks whether the given function is noisy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNoisy(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNoisy_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='isSingleobjective'>Checks whether the given function is single-objective.</h2><span id='topic+isSingleobjective'></span>

<h3>Description</h3>

<p>Checks whether the given function is single-objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isSingleobjective(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isSingleobjective_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>] <code>TRUE</code> if function is single-objective.
</p>

<hr>
<h2 id='isSmoofFunction'>Checks whether the given object is a <code>smoof_function</code> or a
<code>smoof_wrapped_function</code>.</h2><span id='topic+isSmoofFunction'></span>

<h3>Description</h3>

<p>Checks whether the given object is a <code>smoof_function</code> or a
<code>smoof_wrapped_function</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isSmoofFunction(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isSmoofFunction_+3A_object">object</code></td>
<td>
<p>[any]<br />
Arbitrary R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addCountingWrapper">addCountingWrapper</a></code>, <code><a href="#topic+addLoggingWrapper">addLoggingWrapper</a></code>
</p>

<hr>
<h2 id='isVectorized'>Checks whether the given function accept &ldquo;vectorized&rdquo; input.</h2><span id='topic+isVectorized'></span>

<h3>Description</h3>

<p>Checks whether the given function accept &ldquo;vectorized&rdquo; input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isVectorized(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isVectorized_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='isWrappedSmoofFunction'>Checks whether the function is of type <code>smoof_wrapped_function</code>.</h2><span id='topic+isWrappedSmoofFunction'></span>

<h3>Description</h3>

<p>Checks whether the function is of type <code>smoof_wrapped_function</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isWrappedSmoofFunction(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isWrappedSmoofFunction_+3A_object">object</code></td>
<td>
<p>[any]<br />
Arbitrary R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='makeAckleyFunction'>Ackley Function</h2><span id='topic+makeAckleyFunction'></span>

<h3>Description</h3>

<p>Also known as &ldquo;Ackley's Path Function&rdquo;.
Multimodal test function with its global optimum in the center of the defintion
space. The implementation is based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = -a \cdot \exp\left(-b \cdot \sqrt{\left(\frac{1}{n} \sum_{i=1}^{n} \mathbf{x}_i\right)}\right) - \exp\left(\frac{1}{n} \sum_{i=1}^{n} \cos(c \cdot \mathbf{x}_i)\right),</code>
</p>

<p>with <code class="reqn">a = 20</code>, <code class="reqn">b = 0.2</code> and <code class="reqn">c = 2\pi</code>. The feasible region is
given by the box constraints <code class="reqn">\mathbf{x}_i \in [-32.768, 32.768]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAckleyFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeAckleyFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>Ackley, D. H.: A connectionist machine for genetic hillclimbing.
Boston: Kluwer Academic Publishers, 1987.
</p>

<hr>
<h2 id='makeAdjimanFunction'>Adjiman function</h2><span id='topic+makeAdjimanFunction'></span>

<h3>Description</h3>

<p>This two-dimensional multimodal test function follows the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \cos(\mathbf{x}_1)\sin(\mathbf{x}_2) - \frac{\mathbf{x}_1}{(\mathbf{x}_2^2 + 1)}</code>
</p>

<p>with <code class="reqn">\mathbf{x}_1 \in [-1, 2], \mathbf{x}_2 \in [2, 1]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAdjimanFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>C. S. Adjiman, S. Sallwig, C. A. Flouda, A. Neumaier, A Global Optimization
Method, aBB for General Twice-Differentiable NLPs-1, Theoretical Advances, Computers
Chemical Engineering, vol. 22, no. 9, pp. 1137-1158, 1998.
</p>

<hr>
<h2 id='makeAlpine01Function'>Alpine01 function</h2><span id='topic+makeAlpine01Function'></span>

<h3>Description</h3>

<p>Highly multimodal single-objective optimization test function. It is defined
as </p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i = 1}^{n} |\mathbf{x}_i \sin(\mathbf{x}_i) + 0.1\mathbf{x}_i|</code>
</p>

<p>with box constraints <code class="reqn">\mathbf{x}_i \in [-10, 10]</code> for <code class="reqn">i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAlpine01Function(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeAlpine01Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>S. Rahnamyan, H. R. Tizhoosh, N. M. M. Salama, A Novel Population
Initialization Method for Accelerating Evolutionary Algorithms, Computers and
Mathematics with Applications, vol. 53, no. 10, pp. 1605-1614, 2007.
</p>

<hr>
<h2 id='makeAlpine02Function'>Alpine02 function</h2><span id='topic+makeAlpine02Function'></span>

<h3>Description</h3>

<p>Another multimodal optimization test function. The implementation is based on
the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \prod_{i = 1}^{n} \sqrt{\mathbf{x}_i}\sin(\mathbf{x}_i)</code>
</p>

<p>with <code class="reqn">\mathbf{x}_i \in [0, 10]</code> for <code class="reqn">i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAlpine02Function(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeAlpine02Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>M. Clerc, The Swarm and the Queen, Towards a Deterministic and
Adaptive Particle Swarm Optimization, IEEE Congress on Evolutionary Computation,
Washington DC, USA, pp. 1951-1957, 1999.
</p>

<hr>
<h2 id='makeAluffiPentiniFunction'>Aluffi-Pentini function.</h2><span id='topic+makeAluffiPentiniFunction'></span>

<h3>Description</h3>

<p>Two-dimensional test function based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 0.25 x_1^4 - 0.5 x_1^2 + 0.1 x_1 + 0.5 x_2^2</code>
</p>

<p>with <code class="reqn">\mathbf{x}_1, \mathbf{x}_2 \in [-10, 10]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAluffiPentiniFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>Note</h3>

<p>This functions is also know as the Zirilli function.
</p>


<h3>References</h3>

<p>See <a href="https://al-roomi.org/benchmarks/unconstrained/2-dimensions/26-aluffi-pentini-s-or-zirilli-s-function">https://al-roomi.org/benchmarks/unconstrained/2-dimensions/26-aluffi-pentini-s-or-zirilli-s-function</a>.
</p>

<hr>
<h2 id='makeBartelsConnFunction'>Bartels Conn Function</h2><span id='topic+makeBartelsConnFunction'></span>

<h3>Description</h3>

<p>The Bartels Conn Function is defined as
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = |\mathbf{x}_1^2 + \mathbf{x}_2^2 + \mathbf{x}_1\mathbf{x}_2| + |\sin(\mathbf{x}_1)| + |\cos(\mathbf{x})|</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-500, 500]</code> for <code class="reqn">i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBartelsConnFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>

<hr>
<h2 id='makeBBOBFunction'>Generator for the noiseless function set of the real-parameter Black-Box
Optimization Benchmarking (BBOB).</h2><span id='topic+makeBBOBFunction'></span>

<h3>Description</h3>

<p>Generator for the noiseless function set of the real-parameter Black-Box
Optimization Benchmarking (BBOB).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBBOBFunction(dimensions, fid, iid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeBBOBFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Problem dimension. Integer value between 2 and 40.</p>
</td></tr>
<tr><td><code id="makeBBOBFunction_+3A_fid">fid</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Function identifier. Integer value between 1 and 24.</p>
</td></tr>
<tr><td><code id="makeBBOBFunction_+3A_iid">iid</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Instance identifier. Integer value greater than or equal 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>Note</h3>

<p>It is possible to pass a matrix of parameters to the functions, where
each column consists of one parameter setting.
</p>


<h3>References</h3>

<p>See the <a href="http://numbbo.github.io/coco/?id=bbob-2009-downloads">BBOB website</a>
for a detailed description of the BBOB functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the first instance of the 2D Sphere function
fn = makeBBOBFunction(dimensions = 2L, fid = 1L, iid = 1L)
if (require(plot3D)) {
  plot3D(fn, contour = TRUE)
}
</code></pre>

<hr>
<h2 id='makeBealeFunction'>Beale Function</h2><span id='topic+makeBealeFunction'></span>

<h3>Description</h3>

<p>Multimodal single-objective test function for optimization. It is based on
the mathematic formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (1.5 - \mathbf{x}_1 + \mathbf{x}_1\mathbf{x}_2)^2 + (2.25 - \mathbf{x}_1 + \mathbf{x}_1\mathbf{x}_2^2)^2 + (2.625 - \mathbf{x}_1 + \mathbf{x}_1\mathbf{x}_2^3)^2</code>
</p>

<p>usually evaluated within the bounds <code class="reqn">\mathbf{x}_i \in [-4.5, 4.5], i = 1, 2</code>.
The function has a flat but multimodal region aroung the single global optimum
and large peaks in the edges of its definition space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBealeFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>

<hr>
<h2 id='makeBentCigarFunction'>Bent-Cigar Function</h2><span id='topic+makeBentCigarFunction'></span>

<h3>Description</h3>

<p>Scalable test function <code class="reqn">f</code> with
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = x_1^2 + 10^6 \sum_{i = 2}^{n} x_i^2</code>
</p>

<p>subject to <code class="reqn">-100 \leq \mathbf{x}_i \leq 100</code> for <code class="reqn">i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBentCigarFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeBentCigarFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>See <a href="https://al-roomi.org/benchmarks/unconstrained/n-dimensions/164-bent-cigar-function">https://al-roomi.org/benchmarks/unconstrained/n-dimensions/164-bent-cigar-function</a>.
</p>

<hr>
<h2 id='makeBiObjBBOBFunction'>Generator for the function set of the real-parameter Bi-Objective
Black-Box Optimization Benchmarking (BBOB).</h2><span id='topic+makeBiObjBBOBFunction'></span>

<h3>Description</h3>

<p>Generator for the function set of the real-parameter Bi-Objective
Black-Box Optimization Benchmarking (BBOB).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBiObjBBOBFunction(dimensions, fid, iid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeBiObjBBOBFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Problem dimensions. Integer value between 2 and 40.</p>
</td></tr>
<tr><td><code id="makeBiObjBBOBFunction_+3A_fid">fid</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Function identifier. Integer value between 1 and 55.</p>
</td></tr>
<tr><td><code id="makeBiObjBBOBFunction_+3A_iid">iid</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Instance identifier. Integer value greater than or equal 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>Note</h3>

<p>Concatenation of single-objective BBOB functions into
a bi-objective problem.
</p>


<h3>References</h3>

<p>See the <a href="http://numbbo.github.io/coco-doc/bbob-biobj/functions/">COCO website</a>
for a detailed description of the bi-objective BBOB functions.
An overview of which pair of single-objective BBOB functions creates
which of the 55 bi-objective BBOB functions can be found <a href="http://numbbo.github.io/coco-doc/bbob-biobj/functions/#the-bbob-biobj-test-functions-and-their-properties">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get the fifth instance of the concatenation of the
# 3D versions of sphere and Rosenbrock
fn = makeBiObjBBOBFunction(dimensions = 3L, fid = 4L, iid = 5L)
fn(c(3, -1, 0))
# compare to the output of its single-objective pendants
f1 = makeBBOBFunction(dimensions = 3L, fid = 1L, iid = 2L * 5L + 1L)
f2 = makeBBOBFunction(dimensions = 3L, fid = 8L, iid = 2L * 5L + 2L)
identical(fn(c(3, -1, 0)), c(f1(c(3, -1, 0)), f2(c(3, -1, 0))))
</code></pre>

<hr>
<h2 id='makeBirdFunction'>Bird Function</h2><span id='topic+makeBirdFunction'></span>

<h3>Description</h3>

<p>Multimodal single-objective test function. The implementation is based on the
mathematical formulation
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (\mathbf{x}_1 - \mathbf{x}_2)^2 + \exp((1 - \sin(\mathbf{x}_1))^2)\cos(\mathbf{x}_2) + \exp((1 - \cos(\mathbf{x}_2))^2)\sin(\mathbf{x}_1).</code>
</p>

<p>The function is restricted to two dimensions with <code class="reqn">\mathbf{x}_i \in [-2\pi, 2\pi], i = 1, 2.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBirdFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>S. K. Mishra, Global Optimization By Differential Evolution and
Particle Swarm Methods: Evaluation On Some Benchmark Functions, Munich Research
Papers in Economics.
</p>

<hr>
<h2 id='makeBiSphereFunction'>Bi-objective Sphere function</h2><span id='topic+makeBiSphereFunction'></span>

<h3>Description</h3>

<p>Builds and returns the bi-objective Sphere test problem:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \left(\sum_{i=1}^{n} \mathbf{x}_i^2, \sum_{i=1}^{n} (\mathbf{x}_i - \mathbf{a})^2\right)</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">\mathbf{a} \in R^n</code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBiSphereFunction(dimensions, a = rep(0, dimensions))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeBiSphereFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeBiSphereFunction_+3A_a">a</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Shift parameter for the second objective. Default is (0,...,0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>

<hr>
<h2 id='makeBK1Function'>BK1 function generator</h2><span id='topic+makeBK1Function'></span>

<h3>Description</h3>

<p>...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBK1Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>...
</p>

<hr>
<h2 id='makeBohachevskyN1Function'>Bohachevsky function N. 1</h2><span id='topic+makeBohachevskyN1Function'></span>

<h3>Description</h3>

<p>Highly multimodal single-objective test function. The mathematical formula is
given by
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i = 1}^{n - 1} (\mathbf{x}_i^2 + 2 \mathbf{x}_{i + 1}^2 - 0.3\cos(3\pi\mathbf{x}_i) - 0.4\cos(4\pi\mathbf{x}_{i + 1}) + 0.7)</code>
</p>

<p>with box-constraints <code class="reqn">\mathbf{x}_i  \in [-100, 100]</code> for <code class="reqn">i = 1, \ldots, n</code>.
The multimodality will be visible by &ldquo;zooming in&rdquo; in the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBohachevskyN1Function(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeBohachevskyN1Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>I. O. Bohachevsky, M. E. Johnson, M. L. Stein, General Simulated
Annealing for Function Optimization, Technometrics, vol. 28, no. 3, pp. 209-217, 1986.
</p>

<hr>
<h2 id='makeBoothFunction'>Booth Function</h2><span id='topic+makeBoothFunction'></span>

<h3>Description</h3>

<p>This function is based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (\mathbf{x}_1 + 2\mathbf{x}_2 - 7)^2 + (2\mathbf{x}_1 + \mathbf{x}_2 - 5)^2</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-10, 10], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBoothFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>

<hr>
<h2 id='makeBraninFunction'>Branin RCOS function</h2><span id='topic+makeBraninFunction'></span>

<h3>Description</h3>

<p>Popular 2-dimensional single-objective test function based on the formula:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = a \left(\mathbf{x}_2 - b \mathbf{x}_1^2 + c \mathbf{x_1} - d\right)^2 + e\left(1 - f\right)\cos(\mathbf{x}_1) + e,</code>
</p>

<p>where <code class="reqn">a = 1, b = \frac{5.1}{4\pi^2}, c = \frac{5}{\pi}, d = 6, e = 10</code> and
<code class="reqn">f = \frac{1}{8\pi}</code>. The box constraints are given by <code class="reqn">\mathbf{x}_1 \in [-5, 10]</code>
and <code class="reqn">\mathbf{x}_2 \in [0, 15]</code>. The function has three global minima.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBraninFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>F. H. Branin. Widely convergent method for finding
multiple solutions of simultaneous nonlinear equations.
IBM J. Res. Dev. 16, 504-522, 1972.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
fn = makeBraninFunction()
print(fn)
print(autoplot(fn, show.optimum = TRUE))
</code></pre>

<hr>
<h2 id='makeBrentFunction'>Brent Function</h2><span id='topic+makeBrentFunction'></span>

<h3>Description</h3>

<p>Single-objective two-dimensional test function. The formula is given as
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (\mathbf{x}_1 + 10)^2 + (\mathbf{x}_2 + 10)^2 + exp(-\mathbf{x}_1^2 - \mathbf{x}_2^2)</code>
</p>

<p>subject to the constraints <code class="reqn">\mathbf{x}_i \in [-10, 10], i = 1, 2.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBrentFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>F. H. Branin Jr., Widely Convergent Method of Finding Multiple
Solutions of Simul- taneous Nonlinear Equations, IBM Journal of Research and
Development, vol. 16, no. 5, pp. 504-522, 1972.
</p>

<hr>
<h2 id='makeBrownFunction'>Brown Function</h2><span id='topic+makeBrownFunction'></span>

<h3>Description</h3>

<p>This function belongs the the unimodal single-objective test functions. The
function is forumlated as
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i = 1}^{n} (\mathbf{x}_i^2)^{(\mathbf{x}_{i + 1} + 1)} + (\mathbf{x}_{i + 1})^{(\mathbf{x}_i + 1)}</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-1, 4]</code> for <code class="reqn">i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBrownFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeBrownFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>O. Begambre, J. E. Laier, A hybrid Particle Swarm Optimization -
Simplex Algorithm (PSOS) for Structural Damage Identification, Journal of
Advances in Engineering Software, vol. 40, no. 9, pp. 883-891, 2009.
</p>

<hr>
<h2 id='makeBukinN2Function'>Bukin function N. 2</h2><span id='topic+makeBukinN2Function'></span>

<h3>Description</h3>

<p>Muldimodal, non-scalable, continous optimization test function given by:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 100 (\mathbf{x}_2 - 0.01 * \mathbf{x}_1^2 + 1) + 0.01 (\mathbf{x}_1 + 10)^2</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_1 \in [-15, -5]</code> and <code class="reqn">\mathbf{x}_2 \in [-3, 3]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBukinN2Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>Z. K. Silagadze, Finding Two-Dimensional Peaks, Physics of Particles
and Nuclei Letters, vol. 4, no. 1, pp. 73-80, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeBukinN4Function">makeBukinN4Function</a></code>, <code><a href="#topic+makeBukinN6Function">makeBukinN6Function</a></code>
</p>

<hr>
<h2 id='makeBukinN4Function'>Bukin function N. 4</h2><span id='topic+makeBukinN4Function'></span>

<h3>Description</h3>

<p>Second continous Bukin function test function. The formula is given by
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 100 \mathbf{x}_2^2 + 0.01 * ||\mathbf{x}_1 +10||</code>
</p>

<p>and the box constraints <code class="reqn">mathbf{x}_1 \in [-15, 5], \mathbf{x}_2 \in [-3, 3]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBukinN4Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>Z. K. Silagadze, Finding Two-Dimesnional Peaks, Physics of Particles
and Nuclei Letters, vol. 4, no. 1, pp. 73-80, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeBukinN2Function">makeBukinN2Function</a></code>, <code><a href="#topic+makeBukinN6Function">makeBukinN6Function</a></code>
</p>

<hr>
<h2 id='makeBukinN6Function'>Bukin function N. 6</h2><span id='topic+makeBukinN6Function'></span>

<h3>Description</h3>

<p>Beside Bukin N. 2 and N. 4 this is the last &ldquo;Bukin family&rdquo; function.
It is given by the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 100 \sqrt{||\mathbf{x}_2 - 0.01 \mathbf{x}_1^2||} + 0.01 ||\mathbf{x}_1 + 10||</code>
</p>

<p>and the box constraints <code class="reqn">mathbf{x}_1 \in [-15, 5], \mathbf{x}_2 \in [-3, 3]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBukinN6Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>Z. K. Silagadze, Finding Two-Dimesnional Peaks, Physics of Particles
and Nuclei Letters, vol. 4, no. 1, pp. 73-80, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeBukinN2Function">makeBukinN2Function</a></code>, <code><a href="#topic+makeBukinN4Function">makeBukinN4Function</a></code>
</p>

<hr>
<h2 id='makeCarromTableFunction'>Carrom Table Function</h2><span id='topic+makeCarromTableFunction'></span>

<h3>Description</h3>

<p>This function is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = -\frac{1}{30} \left((\cos(\mathbf{x}_1)\exp(|1 - ((\mathbf{x}_1^2 + \mathbf{x}_2^2)^{0.5} / \pi)^2)|\right).</code>
</p>

<p>The box-constraints are given by <code class="reqn">\mathbf{x}_i \in [-10, 10], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCarromTableFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>S. K. Mishra, Global Optimization By Differential Evolution and
Particle Swarm Methods: Evaluation On Some Benchmark Functions, Munich
Research Papers in Economics.
</p>

<hr>
<h2 id='makeChichinadzeFunction'>Chichinadze Function</h2><span id='topic+makeChichinadzeFunction'></span>

<h3>Description</h3>

<p>Continuous single-objective test function <code class="reqn">f</code> with
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \mathbf{x}_1^2 - 12 \mathbf{x}_1 + 11 + 10\cos(0.5\pi\mathbf{x}_1) + 8\sin(2.5\pi\mathbf{x}_1) - (0.25)^{0.5}\exp(-0.5(\mathbf{x}_2 - 0.5)^2)</code>
</p>

<p>with <code class="reqn">-30 \leq \mathbf{x}_i \leq 30, i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeChichinadzeFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>

<hr>
<h2 id='makeChungReynoldsFunction'>Chung Reynolds Function</h2><span id='topic+makeChungReynoldsFunction'></span>

<h3>Description</h3>

<p>The defintion is given by
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \left(\sum_{i=1}^{n} \mathbf{x}_i^2\right)^2</code>
</p>

<p>with box-constraings <code class="reqn">\mathbf{x}_i \in [-100, 100], i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeChungReynoldsFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeChungReynoldsFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>C. J. Chung, R. G. Reynolds, CAEP: An Evolution-Based Tool for
Real-Valued Func- tion Optimization Using Cultural Algorithms, International
Journal on Artificial In- telligence Tool, vol. 7, no. 3, pp. 239-291, 1998.
</p>

<hr>
<h2 id='makeComplexFunction'>Complex function.</h2><span id='topic+makeComplexFunction'></span>

<h3>Description</h3>

<p>Two-dimensional test function based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (x_1^3 - 3 x_1 x_2^2 - 1)^2 + (3 x_2 x_1^2 - x_2^3)^2</code>
</p>

<p>with <code class="reqn">\mathbf{x}_1, \mathbf{x}_2 \in [-2, 2]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeComplexFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>See <a href="https://al-roomi.org/benchmarks/unconstrained/2-dimensions/43-complex-function">https://al-roomi.org/benchmarks/unconstrained/2-dimensions/43-complex-function</a>.
</p>

<hr>
<h2 id='makeCosineMixtureFunction'>Cosine Mixture Function</h2><span id='topic+makeCosineMixtureFunction'></span>

<h3>Description</h3>

<p>Single-objective test function based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = -0.1 \sum_{i = 1}^{n} \cos(5\pi\mathbf{x}_i) - \sum_{i = 1}^{n} \mathbf{x}_i^2</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-1, 1]</code> for <code class="reqn">i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCosineMixtureFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeCosineMixtureFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>M. M. Ali, C. Khompatraporn, Z. B. Zabinsky, A Numerical Evaluation
of Several Stochastic Algorithms on Selected Continuous Global Optimization
Test Problems, Journal of Global Optimization, vol. 31, pp. 635-672, 2005.
</p>

<hr>
<h2 id='makeCrossInTrayFunction'>Cross-In-Tray Function</h2><span id='topic+makeCrossInTrayFunction'></span>

<h3>Description</h3>

<p>Non-scalable, two-dimensional test function for numerical optimization with
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = -0.0001\left(|\sin(\mathbf{x}_1\mathbf{x}_2\exp(|100 - [(\mathbf{x}_1^2 + \mathbf{x}_2^2)]^{0.5} / \pi|)| + 1\right)^{0.1}</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-15, 15]</code> for <code class="reqn">i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCrossInTrayFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>S. K. Mishra, Global Optimization By Differential Evolution and
Particle Swarm Methods: Evaluation On Some Benchmark Functions, Munich
Research Papers in Economics.
</p>

<hr>
<h2 id='makeCubeFunction'>Cube Function</h2><span id='topic+makeCubeFunction'></span>

<h3>Description</h3>

<p>The Cube Function is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 100 (\mathbf{x}_2 - \mathbf{x}_1^3)^2 + (1 - \mathbf{x}_1)^2.</code>
</p>

<p>The box-constraints are given by <code class="reqn">\mathbf{x}_i \in [-10, 10], i = 1, 2.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCubeFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>A. Lavi, T. P. Vogel (eds), Recent Advances in Optimization
Techniques, John Wliley &amp; Sons, 1966.
</p>

<hr>
<h2 id='makeDeckkersAartsFunction'>Deckkers-Aarts Function</h2><span id='topic+makeDeckkersAartsFunction'></span>

<h3>Description</h3>

<p>This continuous single-objective test function is defined by the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 10^5\mathbf{x}_1^2 + \mathbf{x}_2^2 - (\mathbf{x}_1^2 + \mathbf{x}_2^2)^2 + 10^{-5} (\mathbf{x}_1^2 + \mathbf{x}_2^2)^4</code>
</p>

<p>with the bounding box <code class="reqn">-20 \leq \mathbf{x}_i \leq 20</code> for <code class="reqn">i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDeckkersAartsFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>M. M. Ali, C. Khompatraporn, Z. B. Zabinsky, A Numerical Evaluation
of Several Stochastic Algorithms on Selected Continuous Global Optimization
Test Problems, Journal of Global Optimization, vol. 31, pp. 635-672, 2005.
</p>

<hr>
<h2 id='makeDeflectedCorrugatedSpringFunction'>Deflected Corrugated Spring function</h2><span id='topic+makeDeflectedCorrugatedSpringFunction'></span>

<h3>Description</h3>

<p>Scalable single-objective test function based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 0.1 \sum_{i = 1}^{n} (x_i - \alpha)^2 - \cos\left(K \sqrt{\sum_{i = 1}^{n} (x_i - \alpha)^2}\right)</code>
</p>

<p>with <code class="reqn">\mathbf{x}_i \in [0, 2\alpha], i = 1, \ldots, n</code> and <code class="reqn">\alpha = K = 5</code>
by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDeflectedCorrugatedSpringFunction(dimensions, K = 5, alpha = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDeflectedCorrugatedSpringFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
<tr><td><code id="makeDeflectedCorrugatedSpringFunction_+3A_k">K</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Parameter.
Default is 5.</p>
</td></tr>
<tr><td><code id="makeDeflectedCorrugatedSpringFunction_+3A_alpha">alpha</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Parameter.
Default is 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>See <a href="https://al-roomi.org/benchmarks/unconstrained/n-dimensions/238-deflected-corrugated-spring-function">https://al-roomi.org/benchmarks/unconstrained/n-dimensions/238-deflected-corrugated-spring-function</a>.
</p>

<hr>
<h2 id='makeDentFunction'>Dent Function</h2><span id='topic+makeDentFunction'></span>

<h3>Description</h3>

<p>Builds and returns the bi-objective Dent test problem, which is defined as
follows:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \left(f_1(\mathbf{x}_1), f_2(\mathbf{x})\right)</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">f_1(\mathbf{x}_1) = 0.5 \left( \sqrt(1 + (x_1 + x_2)^2) + \sqrt(1 + (x_1 - x_2)^2) + x_1 - x_2\right) + d</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">f_1(\mathbf{x}_1) = 0.5 \left( \sqrt(1 + (x_1 + x_2)^2) + \sqrt(1 + (x_1 - x_2)^2) - x_1 + x_2\right) + d</code>
</p>

<p>where <code class="reqn">d = \lambda * \exp(-(x_1 - x_2)^2)</code> and <code class="reqn">\mathbf{x}_i \in [-1.5, 1.5], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDentFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>

<hr>
<h2 id='makeDixonPriceFunction'>Dixon-Price Function</h2><span id='topic+makeDixonPriceFunction'></span>

<h3>Description</h3>

<p>Dixon and Price defined the function
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (\mathbf{x}_1 - 1)^2 + \sum_{i = 1}^{n} i (2\mathbf{x}_i^2 - \mathbf{x}_{i - 1})</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-10, 10]</code> for <code class="reqn">i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDixonPriceFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDixonPriceFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>L. C. W. Dixon, R. C. Price, The Truncated Newton Method for
Sparse Unconstrained Optimisation Using Automatic Differentiation, Journal of
Optimization Theory and Applications, vol. 60, no. 2, pp. 261-275, 1989.
</p>

<hr>
<h2 id='makeDoubleSumFunction'>Double-Sum Function</h2><span id='topic+makeDoubleSumFunction'></span>

<h3>Description</h3>

<p>Also known as the rotated hyper-ellipsoid function. The formula is given by
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i=1}^n \left( \sum_{j=1}^{i} \mathbf{x}_j \right)^2</code>
</p>

<p>with <code class="reqn">\mathbf{x}_i \in [-65.536, 65.536], i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDoubleSumFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDoubleSumFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>H.-P. Schwefel. Evolution and Optimum Seeking.
John Wiley &amp; Sons, New York, 1995.
</p>

<hr>
<h2 id='makeDTLZ1Function'>DTLZ1 Function (family)</h2><span id='topic+makeDTLZ1Function'></span>

<h3>Description</h3>

<p>Builds and returns the multi-objective DTLZ1 test problem.
</p>
<p>The DTLZ1 test problem is defined as follows:
</p>
<p>Minimize <code class="reqn">f_1(\mathbf{x}) = \frac{1}{2} x_1 x_2 \cdots x_{M-1} (1+g(\mathbf{x}_M),</code>
</p>
<p>Minimize <code class="reqn">f_2(\mathbf{x}) = \frac{1}{2} x_1 x_2 \cdots (1-x_{M-1}) (1+g(\mathbf{x}_M)),</code>
</p>
<p><code class="reqn">\vdots\\</code>
</p>
<p>Minimize <code class="reqn">f_{M-1}(\mathbf{x}) = \frac{1}{2} x_1 (1-x_2) (1+g(\mathbf{x}_M)),</code>
</p>
<p>Minimize <code class="reqn">f_{M}(\mathbf{x}) = \frac{1}{2} (1-x_1) (1+g(\mathbf{x}_M)),</code>
</p>
<p>with <code class="reqn">0 \leq x_i \leq 1</code>, for <code class="reqn">i=1,2,\dots,n,</code>
</p>
<p>where <code class="reqn">g(\mathbf{x}_M) = 100 \left[|\mathbf{x}_M| + \sum\limits_{x_i \in \mathbf{x}_M} (x_i - 0.5)^2 - \cos(20\pi(x_i - 0.5))\right]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDTLZ1Function(dimensions, n.objectives)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDTLZ1Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeDTLZ1Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>K. Deb and L. Thiele and M. Laumanns and E. Zitzler. Scalable
Multi-Objective Optimization Test Problems. Computer Engineering and Networks
Laboratory (TIK), Swiss Federal Institute of Technology (ETH) Zurich, 112, 2001
</p>

<hr>
<h2 id='makeDTLZ2Function'>DTLZ2 Function (family)</h2><span id='topic+makeDTLZ2Function'></span>

<h3>Description</h3>

<p>Builds and returns the multi-objective DTLZ2 test problem.
</p>
<p>The DTLZ2 test problem is defined as follows:
</p>
<p>Minimize <code class="reqn">f_1(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(x_1\pi/2) \cos(x_2\pi/2) \cdots \cos(x_{M-2}\pi/2) \cos(x_{M-1}\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_2(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(x_1\pi/2) \cos(x_2\pi/2) \cdots \cos(x_{M-2}\pi/2) \sin(x_{M-1}\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_3(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(x_1\pi/2) \cos(x_2\pi/2) \cdots \sin(x_{M-2}\pi/2),</code>
</p>
<p><code class="reqn">\vdots\\</code>
</p>
<p>Minimize <code class="reqn">f_{M-1}(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(x_1\pi/2) \sin(x_2\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_{M}(\mathbf{x}) = (1+g(\mathbf{x}_M)) \sin(x_1\pi/2),</code>
</p>
<p>with <code class="reqn">0 \leq x_i \leq 1</code>, for <code class="reqn">i=1,2,\dots,n,</code>
</p>
<p>where <code class="reqn">g(\mathbf{x}_M) = \sum\limits_{x_i\in \mathbf{x}_M}(x_i-0.5)^2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDTLZ2Function(dimensions, n.objectives)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDTLZ2Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeDTLZ2Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>Note</h3>

<p>Note that in case of a bi-objective scenario (<code>n.objectives = 2L</code>) DTLZ2 and DTLZ5 are identical.
</p>


<h3>References</h3>

<p>K. Deb and L. Thiele and M. Laumanns and E. Zitzler. Scalable
Multi-Objective Optimization Test Problems. Computer Engineering and Networks
Laboratory (TIK), Swiss Federal Institute of Technology (ETH) Zurich, 112, 2001
</p>

<hr>
<h2 id='makeDTLZ3Function'>DTLZ3 Function (family)</h2><span id='topic+makeDTLZ3Function'></span>

<h3>Description</h3>

<p>Builds and returns the multi-objective DTLZ3 test problem. The formula
is very similar to the formula of DTLZ2, but it uses the <code class="reqn">g</code> function
of DTLZ1, which introduces a lot of local Pareto-optimal fronts. Thus, this
problems is well suited to check the ability of an optimizer to converge
to the global Pareto-optimal front.
</p>
<p>The DTLZ3 test problem is defined as follows:
</p>
<p>Minimize <code class="reqn">f_1(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(x_1\pi/2) \cos(x_2\pi/2) \cdots \cos(x_{M-2}\pi/2) \cos(x_{M-1}\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_2(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(x_1\pi/2) \cos(x_2\pi/2) \cdots \cos(x_{M-2}\pi/2) \sin(x_{M-1}\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_3(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(x_1\pi/2) \cos(x_2\pi/2) \cdots \sin(x_{M-2}\pi/2),</code>
</p>
<p><code class="reqn">\vdots\\</code>
</p>
<p>Minimize <code class="reqn">f_{M-1}(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(x_1\pi/2) \sin(x_2\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_{M}(\mathbf{x}) = (1+g(\mathbf{x}_M)) \sin(x_1\pi/2),</code>
</p>
<p>with <code class="reqn">0 \leq x_i \leq 1</code>, for <code class="reqn">i=1,2,\dots,n,</code>
</p>
<p>where <code class="reqn">g(\mathbf{x}_M) = 100 \left[|\mathbf{x}_M| + \sum\limits_{x_i \in \mathbf{x}_M} (x_i - 0.5)^2 - \cos(20\pi(x_i - 0.5))\right]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDTLZ3Function(dimensions, n.objectives)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDTLZ3Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeDTLZ3Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>K. Deb and L. Thiele and M. Laumanns and E. Zitzler. Scalable
Multi-Objective Optimization Test Problems. Computer Engineering and Networks
Laboratory (TIK), Swiss Federal Institute of Technology (ETH) Zurich, 112, 2001
</p>

<hr>
<h2 id='makeDTLZ4Function'>DTLZ4 Function (family)</h2><span id='topic+makeDTLZ4Function'></span>

<h3>Description</h3>

<p>Builds and returns the multi-objective DTLZ4 test problem. It is a slight
modification of the DTLZ2 problems by introducing the parameter <code class="reqn">\alpha</code>.
The parameter is used to map <code class="reqn">\mathbf{x}_i \rightarrow \mathbf{x}_i^{\alpha}</code>.
</p>
<p>The DTLZ4 test problem is defined as follows:
</p>
<p>Minimize <code class="reqn">f_1(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(x_1^\alpha\pi/2) \cos(x_2^\alpha\pi/2) \cdots \cos(x_{M-2}^\alpha\pi/2) \cos(x_{M-1}^\alpha\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_2(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(x_1^\alpha\pi/2) \cos(x_2^\alpha\pi/2) \cdots \cos(x_{M-2}^\alpha\pi/2) \sin(x_{M-1}^\alpha\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_3(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(x_1^\alpha\pi/2) \cos(x_2^\alpha\pi/2) \cdots \sin(x_{M-2}^\alpha\pi/2),</code>
</p>
<p><code class="reqn">\vdots\\</code>
</p>
<p>Minimize <code class="reqn">f_{M-1}(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(x_1^\alpha\pi/2) \sin(x_2^\alpha\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_{M}(\mathbf{x}) = (1+g(\mathbf{x}_M)) \sin(x_1^\alpha\pi/2),</code>
</p>
<p>with <code class="reqn">0 \leq x_i \leq 1</code>, for <code class="reqn">i=1,2,\dots,n,</code>
</p>
<p>where <code class="reqn">g(\mathbf{x}_M) = \sum\limits_{x_i\in \mathbf{x}_M}(x_i-0.5)^2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDTLZ4Function(dimensions, n.objectives, alpha = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDTLZ4Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeDTLZ4Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeDTLZ4Function_+3A_alpha">alpha</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Optional parameter. Default is 100, which is recommended by Deb et al.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>K. Deb and L. Thiele and M. Laumanns and E. Zitzler. Scalable
Multi-Objective Optimization Test Problems. Computer Engineering and Networks
Laboratory (TIK), Swiss Federal Institute of Technology (ETH) Zurich, 112, 2001
</p>

<hr>
<h2 id='makeDTLZ5Function'>DTLZ5 Function (family)</h2><span id='topic+makeDTLZ5Function'></span>

<h3>Description</h3>

<p>Builds and returns the multi-objective DTLZ5 test problem. This problem
can be characterized by a disconnected Pareto-optimal front in the search
space. This introduces a new challenge to evolutionary multi-objective
optimizers, i.e., to maintain different subpopulations within the search
space to cover the entire Pareto-optimal front.
</p>
<p>The DTLZ5 test problem is defined as follows:
</p>
<p>Minimize <code class="reqn">f_1(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(\theta_1\pi/2) \cos(\theta_2\pi/2) \cdots \cos(\theta_{M-2}\pi/2) \cos(\theta_{M-1}\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_2(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(\theta_1\pi/2) \cos(\theta_2\pi/2) \cdots \cos(\theta_{M-2}\pi/2) \sin(\theta_{M-1}\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_3(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(\theta_1\pi/2) \cos(\theta_2\pi/2) \cdots \sin(\theta_{M-2}\pi/2),</code>
</p>
<p><code class="reqn">\vdots\\</code>
</p>
<p>Minimize <code class="reqn">f_{M-1}(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(\theta_1\pi/2) \sin(\theta_2\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_{M}((1+g(\mathbf{x}_M)) \sin(\theta_1\pi/2),</code>
</p>
<p>with <code class="reqn">0 \leq x_i \leq 1</code>, for <code class="reqn">i=1,2,\dots,n,</code>
</p>
<p>where <code class="reqn">\theta_i = \frac{\pi}{4(1+ g(\mathbf{x}_M))} (1+2g(\mathbf{x}_M)x_i),</code>
for <code class="reqn">i = 2,3,\dots,(M-1)</code>
</p>
<p>and <code class="reqn">g(\mathbf{x}_M) = \sum\limits_{x_i\in\mathbf{x}_M}(x_i-0.5)^2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDTLZ5Function(dimensions, n.objectives)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDTLZ5Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeDTLZ5Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>Note</h3>

<p>This problem definition does not exist in the succeeding work of Deb et al. (K. Deb
and L. Thiele and M. Laumanns and E. Zitzler (2002). Scalable multi-objective optimization
test problems, Proceedings of the IEEE Congress on Evolutionary Computation, pp. 825-830).<br />
Also, note that in case of a bi-objective scenario (<code>n.objectives = 2L</code>) DTLZ2 and DTLZ5 are identical.
</p>


<h3>References</h3>

<p>K. Deb and L. Thiele and M. Laumanns and E. Zitzler. Scalable
Multi-Objective Optimization Test Problems. Computer Engineering and Networks
Laboratory (TIK), Swiss Federal Institute of Technology (ETH) Zurich, 112, 2001
</p>

<hr>
<h2 id='makeDTLZ6Function'>DTLZ6 Function (family)</h2><span id='topic+makeDTLZ6Function'></span>

<h3>Description</h3>

<p>Builds and returns the multi-objective DTLZ6 test problem. This problem
can be characterized by a disconnected Pareto-optimal front in the search
space. This introduces a new challenge to evolutionary multi-objective
optimizers, i.e., to maintain different subpopulations within the search
space to cover the entire Pareto-optimal front.
</p>
<p>The DTLZ6 test problem is defined as follows:
</p>
<p>Minimize <code class="reqn">f_1(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(\theta_1\pi/2) \cos(\theta_2\pi/2) \cdots \cos(\theta_{M-2}\pi/2) \cos(\theta_{M-1}\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_2(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(\theta_1\pi/2) \cos(\theta_2\pi/2) \cdots \cos(\theta_{M-2}\pi/2) \sin(\theta_{M-1}\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_3(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(\theta_1\pi/2) \cos(\theta_2\pi/2) \cdots \sin(\theta_{M-2}\pi/2),</code>
</p>
<p><code class="reqn">\vdots\\</code>
</p>
<p>Minimize <code class="reqn">f_{M-1}(\mathbf{x}) = (1+g(\mathbf{x}_M)) \cos(\theta_1\pi/2) \sin(\theta_2\pi/2),</code>
</p>
<p>Minimize <code class="reqn">f_{M}((1+g(\mathbf{x}_M)) \sin(\theta_1\pi/2),</code>
</p>
<p>with <code class="reqn">0 \leq x_i \leq 1</code>, for <code class="reqn">i=1,2,\dots,n,</code>
</p>
<p>where <code class="reqn">\theta_i = \frac{\pi}{4(1+ g(\mathbf{x}_M))} (1+2g(\mathbf{x}_M)x_i),</code>
for <code class="reqn">i = 2,3,\dots,(M-1)</code>
</p>
<p>and <code class="reqn">g(\mathbf{x}_M) = \sum\limits_{x_i\in\mathbf{x}_M}x_i^{0.1}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDTLZ6Function(dimensions, n.objectives)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDTLZ6Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeDTLZ6Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>Note</h3>

<p>Attention: Within the succeeding work of Deb et al. (K. Deb and L. Thiele and
M. Laumanns and E. Zitzler (2002). Scalable multi-objective optimization test problems,
Proceedings of the IEEE Congress on Evolutionary Computation, pp. 825-830)
this problem was called DTLZ5.
</p>


<h3>References</h3>

<p>K. Deb and L. Thiele and M. Laumanns and E. Zitzler. Scalable
Multi-Objective Optimization Test Problems. Computer Engineering and Networks
Laboratory (TIK), Swiss Federal Institute of Technology (ETH) Zurich, 112, 2001
</p>

<hr>
<h2 id='makeDTLZ7Function'>DTLZ7 Function (family)</h2><span id='topic+makeDTLZ7Function'></span>

<h3>Description</h3>

<p>Builds and returns the multi-objective DTLZ7 test problem. This problem
can be characterized by a disconnected Pareto-optimal front in the search
space. This introduces a new challenge to evolutionary multi-objective
optimizers, i.e., to maintain different subpopulations within the search
space to cover the entire Pareto-optimal front.
</p>
<p>The DTLZ7 test problem is defined as follows:
</p>
<p>Minimize <code class="reqn">f_1(\mathbf{x}) = x_1,</code>
</p>
<p>Minimize <code class="reqn">f_2(\mathbf{x}) = x_2,</code>
</p>
<p><code class="reqn">\vdots\\</code>
</p>
<p>Minimize <code class="reqn">f_{M-1}(\mathbf{x}) = x_{M-1},</code>
</p>
<p>Minimize <code class="reqn">f_{M}(\mathbf{x}) = (1+g(\mathbf{x}_M)) h(f_1,f_2,\cdots,f_{M-1}, g),</code>
</p>
<p>with <code class="reqn">0 \leq x_i \leq 1</code>, for <code class="reqn">i=1,2,\dots,n,</code>
</p>
<p>where <code class="reqn">g(\mathbf{x}_M) = 1 + \frac{9}{|\mathbf{x}_M|} \sum_{x_i\in\mathbf{x}_M} x_i</code>
</p>
<p>and <code class="reqn">h(f_1,f_2,\cdots,f_{M-1}, g) = M - \sum_{i=1}^{M-1}\left[\frac{f_i}{1+g}(1 + sin(3\pi f_i))\right]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDTLZ7Function(dimensions, n.objectives)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDTLZ7Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeDTLZ7Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>Note</h3>

<p>Attention: Within the succeeding work of Deb et al. (K. Deb and L. Thiele and
M. Laumanns and E. Zitzler (2002). Scalable multi-objective optimization test problems,
Proceedings of the IEEE Congress on Evolutionary Computation, pp. 825-830)
this problem was called DTLZ6.
</p>


<h3>References</h3>

<p>K. Deb and L. Thiele and M. Laumanns and E. Zitzler. Scalable
Multi-Objective Optimization Test Problems. Computer Engineering and Networks
Laboratory (TIK), Swiss Federal Institute of Technology (ETH) Zurich, 112, 2001
</p>

<hr>
<h2 id='makeEasomFunction'>Easom Function</h2><span id='topic+makeEasomFunction'></span>

<h3>Description</h3>

<p>Unimodal function with its global optimum in the center of the search space.
The attraction area of the global optimum is very small in relation to the
search space:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = -\cos(\mathbf{x}_1)\cos(\mathbf{x}_2)\exp\left(-\left((\mathbf{x}_1 - \pi)^2 + (\mathbf{x}_2 - pi)^2\right)\right)</code>
</p>

<p>with <code class="reqn">\mathbf{x}_i \in [-100, 100], i = 1,2.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeEasomFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>Easom, E. E.: A survey of global optimization techniques. M. Eng.
thesis, University of Louisville, Louisville, KY, 1990.
</p>

<hr>
<h2 id='makeED1Function'>ED1 Function</h2><span id='topic+makeED1Function'></span>

<h3>Description</h3>

<p>Builds and returns the multi-objective ED1 test problem.
</p>
<p>The ED1 test problem is defined as follows:
</p>
<p>Minimize <code class="reqn">f_j(\mathbf{x}) = \frac{1}{r(\mathbf{x}) + 1} \cdot \tilde{p}(\Theta (\mathbf{X}))</code>, for <code class="reqn">j = 1, \ldots, m</code>,
</p>
<p>with <code class="reqn">\mathbf{x} = (x_1, \ldots, x_n)^T</code>, where <code class="reqn">0 \leq x_i \leq 1</code>,
and <code class="reqn">\Theta = (\theta_1, \ldots, \theta_{m-1})</code>,
where <code class="reqn">0 \le \theta_j \le \frac{\pi}{2}</code>, for <code class="reqn">i = 1, \ldots, n,</code> and <code class="reqn">j = 1, \ldots, m - 1</code>.
</p>
<p>Moreover <code class="reqn">r(\mathbf{X}) = \sqrt{x_m^2 + \ldots, x_n^2}</code>,
</p>
<p><code class="reqn">\tilde{p}_1(\Theta) = \cos(\theta_1)^{2/\gamma}</code>,
</p>
<p><code class="reqn">\tilde{p}_j(\Theta) = \left( \sin(\theta_1) \cdot \ldots \cdot \sin(\theta_{j - 1}) \cdot \cos(\theta_j) \right)^{2/\gamma}</code>,
for <code class="reqn">2 \le j \le m - 1</code>,
</p>
<p>and <code class="reqn">\tilde{p}_m(\Theta) = \left( \sin(\theta_1) \cdot \ldots \cdot \sin(\theta_{m - 1}) \right)^{2/\gamma}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeED1Function(dimensions, n.objectives, gamma = 2, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeED1Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeED1Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeED1Function_+3A_gamma">gamma</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Optional parameter. Default is 2, which is recommended by Emmerich and Deutz.</p>
</td></tr>
<tr><td><code id="makeED1Function_+3A_theta">theta</code></td>
<td>
<p>[<code>numeric(dimensions)</code>]<br />
Parameter vector, whose components have to be between <code>0</code> and <code>0.5*pi</code>.
The default is <code>theta = (pi/2) * x</code> (with <code>x</code> being the point from the decision space) as recommended by Emmerich and Deutz.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>M. T. M. Emmerich and A. H. Deutz. Test Problems based on Lame
Superspheres. Proceedings of the International Conference on Evolutionary
Multi-Criterion Optimization (EMO 2007), pp. 922-936, Springer, 2007.
</p>

<hr>
<h2 id='makeED2Function'>ED2 Function</h2><span id='topic+makeED2Function'></span>

<h3>Description</h3>

<p>Builds and returns the multi-objective ED2 test problem.
</p>
<p>The ED2 test problem is defined as follows:
</p>
<p>Minimize <code class="reqn">f_j(\mathbf{x}) = \frac{1}{F_{natmin}(\mathbf{x}) + 1} \cdot \tilde{p}(\Theta (\mathbf{X}))</code>, for <code class="reqn">j = 1, \ldots, m</code>,
</p>
<p>with <code class="reqn">\mathbf{x} = (x_1, \ldots, x_n)^T</code>, where <code class="reqn">0 \leq x_i \leq 1</code>,
and <code class="reqn">\Theta = (\theta_1, \ldots, \theta_{m-1})</code>,
where <code class="reqn">0 \le \theta_j \le \frac{\pi}{2}</code>, for <code class="reqn">i = 1, \ldots, n,</code> and <code class="reqn">j = 1, \ldots, m - 1</code>.
</p>
<p>Moreover <code class="reqn">F_{natmin}(\mathbf{x}) = b + (r(\mathbf{x}) - a) + 0.5 + 0.5 \cdot (2 \pi \cdot (r(\mathbf{x}) - a) + \pi)</code>
</p>
<p>with <code class="reqn">a \approx 0.051373</code>, <code class="reqn">b \approx 0.0253235</code>, and <code class="reqn">r(\mathbf{X}) = \sqrt{x_m^2 + \ldots, x_n^2}</code>, as well as
</p>
<p><code class="reqn">\tilde{p}_1(\Theta) = \cos(\theta_1)^{2/\gamma}</code>,
</p>
<p><code class="reqn">\tilde{p}_j(\Theta) = \left( \sin(\theta_1) \cdot \ldots \cdot \sin(\theta_{j - 1}) \cdot \cos(\theta_j) \right)^{2/\gamma}</code>,
for <code class="reqn">2 \le j \le m - 1</code>,
</p>
<p>and <code class="reqn">\tilde{p}_m(\Theta) = \left( \sin(\theta_1) \cdot \ldots \cdot \sin(\theta_{m - 1}) \right)^{2/\gamma}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeED2Function(dimensions, n.objectives, gamma = 2, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeED2Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeED2Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeED2Function_+3A_gamma">gamma</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Optional parameter. Default is 2, which is recommended by Emmerich and Deutz.</p>
</td></tr>
<tr><td><code id="makeED2Function_+3A_theta">theta</code></td>
<td>
<p>[<code>numeric(dimensions)</code>]<br />
Parameter vector, whose components have to be between <code>0</code> and <code>0.5*pi</code>.
The default is <code>theta = (pi/2) * x</code> (with <code>x</code> being the point from the decision space) as recommended by Emmerich and Deutz.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>M. T. M. Emmerich and A. H. Deutz. Test Problems based on Lame
Superspheres. Proceedings of the International Conference on Evolutionary
Multi-Criterion Optimization (EMO 2007), pp. 922-936, Springer, 2007.
</p>

<hr>
<h2 id='makeEggCrateFunction'>Egg Crate Function</h2><span id='topic+makeEggCrateFunction'></span>

<h3>Description</h3>

<p>This single-objective function follows the definition
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \mathbf{x}_1^2 + \mathbf{x}_2^2 + 25(\sin^2(\mathbf{x}_1) + \sin^2(\mathbf{x}_2))</code>
</p>

<p>with <code class="reqn">\mathbf{x}_i \in [-5, 5]</code> for <code class="reqn">i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeEggCrateFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>

<hr>
<h2 id='makeEggholderFunction'>Egg Holder function</h2><span id='topic+makeEggholderFunction'></span>

<h3>Description</h3>

<p>The Egg Holder function is a difficult to optimize function based on the
definition
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i = 1}^{n-1} \left[-(\mathbf{x}_{i + 1} + 47)\sin\sqrt{|\mathbf{x}_{i + 1} + 0.5 \mathbf{x}_{i} + 47|} - \mathbf{x}_i\sin(\sqrt{|\mathbf{x}_i - (\mathbf{x}_{i + 1} - 47)|})\right]</code>
</p>

<p>subject to <code class="reqn">-512 \leq \mathbf{x}_i \leq 512</code> for <code class="reqn">i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeEggholderFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>

<hr>
<h2 id='makeElAttarVidyasagarDuttaFunction'>El-Attar-Vidyasagar-Dutta Function</h2><span id='topic+makeElAttarVidyasagarDuttaFunction'></span>

<h3>Description</h3>

<p>This function is based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (\mathbf{x}_1^2 + \mathbf{x}_2 - 10)^2 + (\mathbf{x}_1 + \mathbf{x}_2^2 - 7)^2 + (\mathbf{x}_1^2 + \mathbf{x}_2^3 - 1)^2</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-500, 500], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeElAttarVidyasagarDuttaFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>R. A. El-Attar, M. Vidyasagar, S. R. K. Dutta, An Algorithm for
II-norm Minimiza- tion With Application to Nonlinear II-approximation, SIAM
Journal on Numverical Analysis, vol. 16, no. 1, pp. 70-86, 1979.
</p>

<hr>
<h2 id='makeEngvallFunction'>Complex function.</h2><span id='topic+makeEngvallFunction'></span>

<h3>Description</h3>

<p>Two-dimensional test function based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (x_1^4 + x_2^4 + 2 x_1^2 x_2^2 - 4 x_1 + 3</code>
</p>

<p>with <code class="reqn">\mathbf{x}_1, \mathbf{x}_2 \in [-2000, 2000]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeEngvallFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>See <a href="https://al-roomi.org/benchmarks/unconstrained/2-dimensions/116-engvall-s-function">https://al-roomi.org/benchmarks/unconstrained/2-dimensions/116-engvall-s-function</a>.
</p>

<hr>
<h2 id='makeExponentialFunction'>Exponential Function</h2><span id='topic+makeExponentialFunction'></span>

<h3>Description</h3>

<p>This scalable test function is based on the definition
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = -\exp\left(-0.5 \sum_{i = 1}^{n} \mathbf{x}_i^2\right)</code>
</p>

<p>with the box-constraints <code class="reqn">\mathbf{x}_i \in [-1, 1], i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeExponentialFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeExponentialFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>S. Rahnamyan, H. R. Tizhoosh, N. M. M. Salama, Opposition-Based
Differential Evolution (ODE) with Variable Jumping Rate, IEEE Sympousim
Foundations Com- putation Intelligence, Honolulu, HI, pp. 81-88, 2007.
</p>

<hr>
<h2 id='makeFreudensteinRothFunction'>Freudenstein Roth Function</h2><span id='topic+makeFreudensteinRothFunction'></span>

<h3>Description</h3>

<p>This test function is based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (\mathbf{x}_1 - 13 + ((5 - \mathbf{x}_2)\mathbf{x}_2 - 2)\mathbf{x}_2)^2 + (\mathbf{x}_1 - 29 + ((\mathbf{x}_2 + 1)\mathbf{x}_2 - 14)\mathbf{x}_2)^2</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-10, 10], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFreudensteinRothFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>S. S. Rao, Engineering Optimization: Theory and Practice,
John Wiley &amp; Sons, 2009.
</p>

<hr>
<h2 id='makeFunctionsByName'>Generate smoof function by passing a character vector of generator
names.</h2><span id='topic+makeFunctionsByName'></span>

<h3>Description</h3>

<p>This function is especially useful in combination with
<code><a href="#topic+filterFunctionsByTags">filterFunctionsByTags</a></code> to generate a test set of functions
with certain properties, e.~g., multimodality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFunctionsByName(fun.names, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFunctionsByName_+3A_fun.names">fun.names</code></td>
<td>
<p>[<code>character</code>]<br />
Non empty character vector of generator function names.</p>
</td></tr>
<tr><td><code id="makeFunctionsByName_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further arguments passed to generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_function</code>]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterFunctionsByTags">filterFunctionsByTags</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a testset of multimodal 2D functions
## Not run: 
test.set = makeFunctionsByName(filterFunctionsByTags("multimodal"), dimensions = 2L, m = 5L)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeGeneralizedDropWaveFunction'>Generalized Drop-Wave Function</h2><span id='topic+makeGeneralizedDropWaveFunction'></span>

<h3>Description</h3>

<p>Multimodal single-objective function following the formula:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{x} = -\frac{1 + \cos(\sqrt{\sum_{i = 1}^{n} \mathbf{x}_i^2})}{2 + 0.5 \sum_{i = 1}^{n} \mathbf{x}_i^2}</code>
</p>

<p>with <code class="reqn">\mathbf{x}_i \in [-5.12, 5.12], i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGeneralizedDropWaveFunction(dimensions = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeGeneralizedDropWaveFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>

<hr>
<h2 id='makeGiuntaFunction'>Giunta Function</h2><span id='topic+makeGiuntaFunction'></span>

<h3>Description</h3>

<p>Multimodal test function based on the definition
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 0.6 + \sum_{i = 1}^{n} \left[\sin(\frac{16}{15} \mathbf{x}_i - 1) + \sin^2(\frac{16}{15}\mathbf{x}_i - 1) + \frac{1}{50} \sin(4(\frac{16}{15}\mathbf{x}_i - 1))\right]</code>
</p>

<p>with box-constraints <code class="reqn">\mathbf{x}_i \in [-1, 1]</code> for <code class="reqn">i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGiuntaFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>S. K. Mishra, Global Optimization By Differential Evolution and
Particle Swarm Methods: Evaluation On Some Benchmark Functions, Munich
Research Papers in Economics.
</p>

<hr>
<h2 id='makeGoldsteinPriceFunction'>Goldstein-Price Function</h2><span id='topic+makeGoldsteinPriceFunction'></span>

<h3>Description</h3>

<p>Two-dimensional test function for global optimization. The implementation
follows the formula:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \left(1 + (\mathbf{x}_1 + \mathbf{x}_2 + 1)^2 \cdot (19 - 14\mathbf{x}_1 + 3\mathbf{x}_1^2 - 14\mathbf{x}_2 + 6\mathbf{x}_1\mathbf{x}_2 + 3\mathbf{x}_2^2)\right)\\ \qquad \cdot \left(30 + (2\mathbf{x}_1 - 3\mathbf{x}_2)^2 \cdot (18 - 32\mathbf{x}_1 + 12\mathbf{x}_1^2 + 48\mathbf{x}_2 - 36\mathbf{x}_1\mathbf{x}_2 + 27\mathbf{x}_2^2)\right)</code>
</p>

<p>with <code class="reqn">\mathbf{x}_i \in [-2, 2], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGoldsteinPriceFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>Goldstein, A. A. and Price, I. F.: On descent from local minima.
Math. Comput., Vol. 25, No. 115, 1971.
</p>

<hr>
<h2 id='makeGOMOPFunction'>GOMOP function generator.</h2><span id='topic+makeGOMOPFunction'></span>

<h3>Description</h3>

<p>Construct a multi-objective function by putting together multiple single-objective
smoof functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGOMOPFunction(dimensions = 2L, funs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeGOMOPFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
<tr><td><code id="makeGOMOPFunction_+3A_funs">funs</code></td>
<td>
<p>[<code>list</code>]<br />
List of single-objective smoof functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decision space of the resulting function is restricted
to <code class="reqn">[0,1]^d</code>. Each parameter <code class="reqn">x</code> is stretched for each objective function.
I.e., if <code class="reqn">f_1, \ldots, f_n</code> are the single objective smoof functions with
box constraints <code class="reqn">[l_i, u_i], i = 1, \ldots, n</code>, then
</p>
<p style="text-align: center;"><code class="reqn">
  f(x) = \left(f_1(l_1 + x * (u_1 - l_1)), \ldots, f_1(l_1 + x * (u_1 - l_1))\right)
</code>
</p>

<p>for <code class="reqn">x \in [0,1]^d</code> where the additions and multiplication are performed
component-wise.
</p>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>

<hr>
<h2 id='makeGriewankFunction'>Griewank Function</h2><span id='topic+makeGriewankFunction'></span>

<h3>Description</h3>

<p>Highly multimodal function with a lot of regularly distributed local minima.
The corresponding formula is:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i=1}^{n} \frac{\mathbf{x}_i^2}{4000} - \prod_{i=1}^{n} \cos\left(\frac{\mathbf{x}_i}{\sqrt{i}}\right) + 1</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-100, 100], i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGriewankFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeGriewankFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>A. O. Griewank, Generalized Descent for Global Optimization,
Journal of Optimization Theory and Applications, vol. 34, no. 1,
pp. 11-39, 1981.
</p>

<hr>
<h2 id='makeHansenFunction'>Hansen Function</h2><span id='topic+makeHansenFunction'></span>

<h3>Description</h3>

<p>Test function with multiple global optima based on the definition
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i = 1}^{4} (i + 1)\cos(i\mathbf{x}_1 + i - 1) \sum_{j = 1}^{4} (j + 1)\cos((j + 2) \mathbf{x}_2 + j + 1)</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-10, 10], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeHansenFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>C. Fraley, Software Performances on Nonlinear lems, Technical
Report no. STAN-CS-89-1244, Computer Science, Stanford University, 1989.
</p>

<hr>
<h2 id='makeHartmannFunction'>Hartmann Function</h2><span id='topic+makeHartmannFunction'></span>

<h3>Description</h3>

<p>Unimodal single-objective test function with six local minima.
The implementation is based on the mathematical formulation
</p>
<p style="text-align: center;"><code class="reqn">f(x) = - \sum_{i=1}^4 \alpha_i \ exp \left(-\sum_{j=1}^6 A_{ij}(x_j-P_{ij})^2 \right)</code>
</p>
<p>, where
</p>
<p style="text-align: center;"><code class="reqn">\alpha = (1.0, 1.2, 3.0, 3.2)^T, \\
 A = \left( \begin{array}{rrrrrr}
  10   &amp; 3    &amp; 17   &amp; 3.50 &amp; 1.7  &amp; 8 \\
  0.05 &amp; 10   &amp; 17   &amp; 0.1  &amp; 8    &amp; 14 \\
  3    &amp; 3.5  &amp; 1.7  &amp; 10   &amp; 17   &amp; 8 \\
  17   &amp; 8    &amp; 0.05 &amp; 10   &amp; 0.1  &amp; 14
 \end{array} \right), \\
  P = 10^{-4} \cdot \left(\begin{array}{rrrrrr}
  1312 &amp; 1696 &amp; 5569 &amp; 124  &amp; 8283 &amp; 5886 \\
  2329 &amp; 4135 &amp; 8307 &amp; 3736 &amp; 1004 &amp; 9991 \\
  2348 &amp; 1451 &amp; 3522 &amp; 2883 &amp; 3047 &amp; 6650 \\
  4047 &amp; 8828 &amp; 8732 &amp; 5743 &amp; 1091 &amp; 381
 \end{array} \right)</code>
</p>

<p>The function is restricted to six dimensions with <code class="reqn">\mathbf{x}_i \in [0,1], i = 1, \ldots, 6.</code>
The function is not normalized in contrast to some benchmark applications in the literature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeHartmannFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeHartmannFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>Picheny, V., Wagner, T., &amp; Ginsbourger, D. (2012). A benchmark
of kriging-based infill criteria for noisy optimization.
</p>

<hr>
<h2 id='makeHimmelblauFunction'>Himmelblau Function</h2><span id='topic+makeHimmelblauFunction'></span>

<h3>Description</h3>

<p>Two-dimensional test function based on the function defintion
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (\mathbf{x}_1^2 + \mathbf{x}_2 - 11)^2 + (\mathbf{x}_1 + \mathbf{x}_2^2 - 7)^2</code>
</p>

<p>with box-constraings <code class="reqn">\mathbf{x}_i \in [-5, 5], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeHimmelblauFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>D. M. Himmelblau, Applied Nonlinear Programming, McGraw-Hill, 1972.
</p>

<hr>
<h2 id='makeHolderTableN1Function'>Holder Table function N. 1</h2><span id='topic+makeHolderTableN1Function'></span>

<h3>Description</h3>

<p>This multimodal function is defined as
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = -\left|\cos(\mathbf{x}_1)\cos(\mathbf{x}_2)\exp(|1 - \sqrt{\mathbf{x}_1 + \mathbf{x}_2}/\pi|)\right|</code>
</p>

<p>with box-constraints <code class="reqn">\mathbf{x}_i \in [-10, 10], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeHolderTableN1Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>S. K. Mishra, Global Optimization By Differential Evolution and
Particle Swarm Methods: Evaluation On Some Benchmark Functions, Munich
Research Papers in Economics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeHolderTableN2Function">makeHolderTableN2Function</a></code>
</p>

<hr>
<h2 id='makeHolderTableN2Function'>Holder Table function N. 2</h2><span id='topic+makeHolderTableN2Function'></span>

<h3>Description</h3>

<p>This multimodal function is defined as
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = -\left|\sin(\mathbf{x}_1)\cos(\mathbf{x}_2)\exp(|1 - \sqrt{\mathbf{x}_1 + \mathbf{x}_2}/\pi|)\right|</code>
</p>

<p>with box-constraints <code class="reqn">\mathbf{x}_i \in [-10, 10], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeHolderTableN2Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>S. K. Mishra, Global Optimization By Differential Evolution and
Particle Swarm Methods: Evaluation On Some Benchmark Functions, Munich
Research Papers in Economics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeHolderTableN1Function">makeHolderTableN1Function</a></code>
</p>

<hr>
<h2 id='makeHosakiFunction'>Hosaki Function</h2><span id='topic+makeHosakiFunction'></span>

<h3>Description</h3>

<p>Two-dimensional test function <code class="reqn">f</code> with
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (1 - 8 \mathbf{x}_1 + 7 \mathbf{x}_1^2 - 7/3 \mathbf{x}_1^3 + 1/4 \mathbf{x}_1^4)\mathbf{x}_2^2e^{-\mathbf{x}_2}</code>
</p>

<p>subject to <code class="reqn">0 \leq \mathbf{x}_1 \leq 5</code> and <code class="reqn">0 \leq \mathbf{x}_2 \leq 6</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeHosakiFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>G. A. Bekey, M. T. Ung, A Comparative Evaluation of Two Global
Search Algorithms, IEEE Transaction on Systems, Man and Cybernetics, vol. 4,
no. 1, pp. 112- 116, 1974.
</p>

<hr>
<h2 id='makeHyperEllipsoidFunction'>Hyper-Ellipsoid function</h2><span id='topic+makeHyperEllipsoidFunction'></span>

<h3>Description</h3>

<p>Unimodal, convex test function similar to the Sphere function (see <code><a href="#topic+makeSphereFunction">makeSphereFunction</a></code>).
Calculated via the formula: </p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i=1}^{n} i \cdot \mathbf{x}_i.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>makeHyperEllipsoidFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeHyperEllipsoidFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>

<hr>
<h2 id='makeInvertedVincentFunction'>Inverted Vincent Function</h2><span id='topic+makeInvertedVincentFunction'></span>

<h3>Description</h3>

<p>Single-objective test function based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \frac{1}{n} \sum_{i = 1}^{n} \sin(10 \log(\mathbf{x}_i))</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [0.25, 10]</code> for <code class="reqn">i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeInvertedVincentFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeInvertedVincentFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>Xiadong Li, Andries Engelbrecht, and Michael G. Epitropakis. Benchmark
functions for CEC2013 special session and competition on niching methods for
multimodal function optimization. Technical report, RMIT University, Evolutionary
Computation and Machine Learning Group, Australia, 2013.
</p>

<hr>
<h2 id='makeJennrichSampsonFunction'>Jennrich-Sampson function.</h2><span id='topic+makeJennrichSampsonFunction'></span>

<h3>Description</h3>

<p>Two-dimensional test function based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i=1}^{10} \left[2 + 2i - (e^{ix_1} + e^{ix_2})\right]^2</code>
</p>

<p>with <code class="reqn">\mathbf{x}_1, \mathbf{x}_2 \in [-1, 1]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeJennrichSampsonFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>See <a href="https://al-roomi.org/benchmarks/unconstrained/2-dimensions/134-jennrich-sampson-s-function">https://al-roomi.org/benchmarks/unconstrained/2-dimensions/134-jennrich-sampson-s-function</a>.
</p>

<hr>
<h2 id='makeJudgeFunction'>Judge function.</h2><span id='topic+makeJudgeFunction'></span>

<h3>Description</h3>

<p>Two-dimensional test function based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i=1}^{20} \left[(x_1 + B_i x_2 + C_i x_2^2) - A_i\right]^2</code>
</p>

<p>with <code class="reqn">\mathbf{x}_1, \mathbf{x}_2 \in [-10, 10]</code>. For details on <code class="reqn">A, B, C</code>
see the referenced website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeJudgeFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>See <a href="https://al-roomi.org/benchmarks/unconstrained/2-dimensions/133-judge-s-function">https://al-roomi.org/benchmarks/unconstrained/2-dimensions/133-judge-s-function</a>.
</p>

<hr>
<h2 id='makeKeaneFunction'>Keane Function</h2><span id='topic+makeKeaneFunction'></span>

<h3>Description</h3>

<p>Two-dimensional test function based on the defintion
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \frac{\sin^2(\mathbf{x}_1 - \mathbf{x}_2)\sin^2(\mathbf{x}_1 + \mathbf{x}_2)}{\sqrt{\mathbf{x}_1^2 + \mathbf{x}_2^2}}.</code>
</p>

<p>The domain of definition is bounded by the box constraints
<code class="reqn">\mathbf{x}_i \in [0, 10], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeKeaneFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>

<hr>
<h2 id='makeKearfottFunction'>Kearfott function.</h2><span id='topic+makeKearfottFunction'></span>

<h3>Description</h3>

<p>Two-dimensional test function based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (x_1^2 + x_2^2 - 2)^2 + (x_1^2 - x_2^2 - 1)^2</code>
</p>

<p>with <code class="reqn">\mathbf{x}_1, \mathbf{x}_2 \in [-3, 4]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeKearfottFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>See <a href="https://al-roomi.org/benchmarks/unconstrained/2-dimensions/59-kearfott-s-function">https://al-roomi.org/benchmarks/unconstrained/2-dimensions/59-kearfott-s-function</a>.
</p>

<hr>
<h2 id='makeKursaweFunction'>Kursawe Function</h2><span id='topic+makeKursaweFunction'></span>

<h3>Description</h3>

<p>Builds and returns the bi-objective Kursawe test problem.
</p>
<p>The Kursawe test problem is defined as follows:
</p>
<p>Minimize <code class="reqn">f_1(\mathbf{x}) = \sum\limits_{i = 1}^{n - 1} (-10 \cdot \exp(-0.2 \cdot \sqrt{x_i^2 + x_{i + 1}^2})),</code>
</p>
<p>Minimize <code class="reqn">f_2(\mathbf{x}) = \sum\limits_{i = 1}^{n} ( |x_i|^{0.8} + 5 \cdot \sin^3(x_i)),</code>
</p>
<p>with <code class="reqn">-5 \leq x_i \leq 5</code>, for <code class="reqn">i = 1, 2, \ldots, n,</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeKursaweFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeKursaweFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>F. Kursawe. A Variant of Evolution Strategies for Vector
Optimization. Proceedings of the International Conference on Parallel
Problem Solving from Nature, pp. 193-197, Springer, 1990.
</p>

<hr>
<h2 id='makeLeonFunction'>Leon Function</h2><span id='topic+makeLeonFunction'></span>

<h3>Description</h3>

<p>The function is based on the defintion
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 100 (\mathbf{x}_2 - \mathbf{x}_1^2)^2 + (1 - \mathbf{x}_1)^2</code>
</p>
<p>.
Box-constraints: <code class="reqn">\mathbf{x}_i \in [-1.2, 1.2]</code> for <code class="reqn">i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeLeonFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>A. Lavi, T. P. Vogel (eds), Recent Advances in Optimization
Techniques, John Wliley &amp; Sons, 1966.
</p>

<hr>
<h2 id='makeMatyasFunction'>Matyas Function</h2><span id='topic+makeMatyasFunction'></span>

<h3>Description</h3>

<p>Two-dimensional, unimodal test function
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 0.26 (\mathbf{x}_1^2 + \mathbf{x}_2^2) - 0.48\mathbf{x}_1\mathbf{x}_2</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-10, 10], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMatyasFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>A.-R. Hedar, Global Optimization Test Problems.
</p>

<hr>
<h2 id='makeMcCormickFunction'>McCormick Function</h2><span id='topic+makeMcCormickFunction'></span>

<h3>Description</h3>

<p>Two-dimensional, multimodal test function. The defintion is given by
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sin(\mathbf{x}_1 + \mathbf{x}_2) + (\mathbf{x}_1 - \mathbf{x}_2)^2 - 1.5 \mathbf{x}_1 + 2.5 \mathbf{x}_2 + 1</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_1 \in [-1.5, 4], \mathbf{x}_2 \in [-3, 3]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMcCormickFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>F. A. Lootsma (ed.), Numerical Methods for Non-Linear
Optimization, Academic Press, 1972.
</p>

<hr>
<h2 id='makeMichalewiczFunction'>Michalewicz Function</h2><span id='topic+makeMichalewiczFunction'></span>

<h3>Description</h3>

<p>Highly multimodal single-objective test function with <code class="reqn">n!</code> local minima
with the formula:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = -\sum_{i=1}^{n} \sin(\mathbf{x}_i) \cdot \left(\sin\left(\frac{i \cdot \mathbf{x}_i}{\pi}\right)\right)^{2m}.</code>
</p>

<p>The recommended value <code class="reqn">m = 10</code>, which is used as a default in the
implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMichalewiczFunction(dimensions, m = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMichalewiczFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
<tr><td><code id="makeMichalewiczFunction_+3A_m">m</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
&ldquo;Steepness&rdquo; parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>Note</h3>

<p>The location of the global optimum s varying based on both
the dimension and <code class="reqn">m</code> parameter and is thus not provided in the
implementation.
</p>


<h3>References</h3>

<p>Michalewicz, Z.: Genetic Algorithms + Data Structures = Evolution
Programs. Berlin, Heidelberg, New York: Springer-Verlag, 1992.
</p>

<hr>
<h2 id='makeMMF10Function'>MMF10 Function</h2><span id='topic+makeMMF10Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF10Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF11Function'>MMF11 Function</h2><span id='topic+makeMMF11Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF11Function(np = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMMF11Function_+3A_np">np</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of global Pareto sets. In the CEC2019 competition, the organizers used
<code>np = 2L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF12Function'>MMF12 Function</h2><span id='topic+makeMMF12Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF12Function(np = 2L, q = 4L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMMF12Function_+3A_np">np</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of global Pareto sets. In the CEC2019 competition, the organizers used
<code>np = 2L</code>.</p>
</td></tr>
<tr><td><code id="makeMMF12Function_+3A_q">q</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of discontinuous pieces in each Pareto front. In the CEC2019 competition,
the organizers used <code>q = 4L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF13Function'>MMF13 Function</h2><span id='topic+makeMMF13Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF13Function(np = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMMF13Function_+3A_np">np</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of global Pareto sets. In the CEC2019 competition, the organizers used
<code>np = 2L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF14aFunction'>MMF14a Function</h2><span id='topic+makeMMF14aFunction'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF14aFunction(dimensions, n.objectives, np = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMMF14aFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeMMF14aFunction_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeMMF14aFunction_+3A_np">np</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of global Pareto sets. In the CEC2019 competition, the organizers used
<code>np = 2L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF14Function'>MMF14 Function</h2><span id='topic+makeMMF14Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF14Function(dimensions, n.objectives, np = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMMF14Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeMMF14Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeMMF14Function_+3A_np">np</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of global Pareto sets. In the CEC2019 competition, the organizers used
<code>np = 2L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF15aFunction'>MMF15a Function</h2><span id='topic+makeMMF15aFunction'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF15aFunction(dimensions, n.objectives, np = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMMF15aFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeMMF15aFunction_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeMMF15aFunction_+3A_np">np</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of global Pareto sets. In the CEC2019 competition, the organizers used
<code>np = 2L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF15Function'>MMF15 Function</h2><span id='topic+makeMMF15Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF15Function(dimensions, n.objectives, np = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMMF15Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
<tr><td><code id="makeMMF15Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeMMF15Function_+3A_np">np</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of global Pareto sets. In the CEC2019 competition, the organizers used
<code>np = 2L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF1eFunction'>MMF1e Function</h2><span id='topic+makeMMF1eFunction'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF1eFunction(a = exp(1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMMF1eFunction_+3A_a">a</code></td>
<td>
<p>[<code>double</code>(1)]<br />
Parametrizable factor. In the CEC2019 competition, the organizers used
<code>a = exp(1L)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF1Function'>MMF1 Function</h2><span id='topic+makeMMF1Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF1Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF1zFunction'>MMF1z Function</h2><span id='topic+makeMMF1zFunction'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF1zFunction(k = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMMF1zFunction_+3A_k">k</code></td>
<td>
<p>[<code>double</code>(1)]<br />
Parametrizable factor. In the CEC2019 competition, the organizers used
<code>k = 3</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF2Function'>MMF2 Function</h2><span id='topic+makeMMF2Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF2Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF3Function'>MMF3 Function</h2><span id='topic+makeMMF3Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF3Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF4Function'>MMF4 Function</h2><span id='topic+makeMMF4Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF4Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF5Function'>MMF5 Function</h2><span id='topic+makeMMF5Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF5Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF6Function'>MMF6 Function</h2><span id='topic+makeMMF6Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF6Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF7Function'>MMF7 Function</h2><span id='topic+makeMMF7Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF7Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF8Function'>MMF8 Function</h2><span id='topic+makeMMF8Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF8Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeMMF9Function'>MMF9 Function</h2><span id='topic+makeMMF9Function'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMMF9Function(np = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMMF9Function_+3A_np">np</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of global Pareto sets. In the CEC2019 competition, the organizers used
<code>np = 2L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeModifiedRastriginFunction'>Rastrigin Function</h2><span id='topic+makeModifiedRastriginFunction'></span>

<h3>Description</h3>

<p>A modified version of the Rastrigin function following the formula:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i=1}^{n} 10\left(1 + \cos(2\pi k_i \mathbf{x}_i)\right) + 2 k_i \mathbf{x}_i^2.</code>
</p>

<p>The box-constraints are given by <code class="reqn">\mathbf{x}_i \in [0, 1]</code> for
<code class="reqn">i = 1, \ldots, n</code> and <code class="reqn">k</code> is a numerical vector. Deb et al. (see references)
use, e.g., <code class="reqn">k = (2, 2, 3, 4)</code> for <code class="reqn">n = 4</code>. See the reference for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeModifiedRastriginFunction(dimensions, k = rep(1, dimensions))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeModifiedRastriginFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
<tr><td><code id="makeModifiedRastriginFunction_+3A_k">k</code></td>
<td>
<p>[numeric]<br />
Vector of numerical values of length <code>dimensions</code>.
Default is <code>rep(1, dimensions)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>Kalyanmoy Deb and Amit Saha. Multimodal optimization using a bi-
objective evolutionary algorithm. Evolutionary Computation, 20(1):27-62, 2012.
</p>

<hr>
<h2 id='makeMOP1Function'>MOP1 function generator.</h2><span id='topic+makeMOP1Function'></span>

<h3>Description</h3>

<p>MOP1 function from Van Valedhuizen's test suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMOP1Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>J. D. Schaffer, &quot;Multiple objective optimization with vector evaluated
genetic algorithms,&quot; in Proc. 1st Int. Conf. Genetic Algorithms and Their
Applications, J. J. Grenfenstett, Ed., 1985, pp. 93-100.
</p>

<hr>
<h2 id='makeMOP2Function'>MOP2 function generator.</h2><span id='topic+makeMOP2Function'></span>

<h3>Description</h3>

<p>MOP2 function from Van Valedhuizen's test suite due to Fonseca and Fleming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMOP2Function(dimensions = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMOP2Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>C. M. Fonseca and P. J. Fleming, &quot;Multiobjective genetic algorithms
made easy: Selection, sharing and mating restriction,&quot; Genetic Algorithms
in Engineering Systems: Innovations and Applications, pp. 45-52, Sep. 1995. IEE.
</p>

<hr>
<h2 id='makeMOP3Function'>MOP3 function generator.</h2><span id='topic+makeMOP3Function'></span>

<h3>Description</h3>

<p>MOP3 function from Van Valedhuizen's test suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMOP3Function(dimensions = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMOP3Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>C. Poloni, G. Mosetti, and S. Contessi, &quot;Multi objective optimization by
GAs: Application to system and component design,&quot; in Proc. Comput.
Methods in Applied Sciences'96: Invited Lectures and Special Technological
Sessions of the 3rd ECCOMAS Comput. Fluid Dynamics Conf.
and the 2nd ECCOMAS Conf. Numerical Methods in Engineering, Sep.
1996, pp. 258-264
</p>

<hr>
<h2 id='makeMOP4Function'>MOP4 function generator.</h2><span id='topic+makeMOP4Function'></span>

<h3>Description</h3>

<p>MOP4 function from Van Valedhuizen's test suite based on Kursawe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMOP4Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>F. Kursawe, &quot;A variant of evolution strategies for vector optimization,&quot;
in Lecture Notes in Computer Science, H.-P. Schwefel and R. Maenner,
Eds. Berlin, Germany: Springer-Verlag, 1991, vol. 496, Proc. Parallel
Problem Solving From Nature. 1st Workshop, PPSN I, pp. 193-197.
</p>

<hr>
<h2 id='makeMOP5Function'>MOP5 function generator.</h2><span id='topic+makeMOP5Function'></span>

<h3>Description</h3>

<p>MOP5 function from Van Valedhuizen's test suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMOP5Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>Note</h3>

<p>Original box constraints where <code class="reqn">[-3, 3]</code>.
</p>


<h3>References</h3>

<p>R. Viennet, C. Fonteix, and I. Marc, &quot;Multicriteria optimization using a
genetic algorithm for determining a Pareto set,&quot; Int. J. Syst. Sci., vol. 27,
no. 2, pp. 255-260, 1996
</p>

<hr>
<h2 id='makeMOP6Function'>MOP6 function generator.</h2><span id='topic+makeMOP6Function'></span>

<h3>Description</h3>

<p>MOP6 function from Van Valedhuizen's test suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMOP6Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>

<hr>
<h2 id='makeMOP7Function'>MOP7 function generator.</h2><span id='topic+makeMOP7Function'></span>

<h3>Description</h3>

<p>MOP7 function from Van Valedhuizen's test suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMOP7Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>R. Viennet, C. Fonteix, and I. Marc, &quot;Multicriteria optimization using a
genetic algorithm for determining a Pareto set,&quot; Int. J. Syst. Sci., vol. 27,
no. 2, pp. 255-260, 1996
</p>

<hr>
<h2 id='makeMPM2Function'>Generator for function with multiple peaks following the multiple peaks model 2.</h2><span id='topic+makeMPM2Function'></span>

<h3>Description</h3>

<p>Generator for function with multiple peaks following the multiple peaks model 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMPM2Function(
  n.peaks,
  dimensions,
  topology,
  seed,
  rotated = TRUE,
  peak.shape = "ellipse"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMPM2Function_+3A_n.peaks">n.peaks</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Desired number of peaks, i. e., number of (local) optima.</p>
</td></tr>
<tr><td><code id="makeMPM2Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
<tr><td><code id="makeMPM2Function_+3A_topology">topology</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Type of topology. Possible values are &ldquo;random&rdquo; and &ldquo;funnel&rdquo;.</p>
</td></tr>
<tr><td><code id="makeMPM2Function_+3A_seed">seed</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Seed for the random numbers generator.</p>
</td></tr>
<tr><td><code id="makeMPM2Function_+3A_rotated">rotated</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the peak shapes be rotated? This parameter is only relevant in case
of elliptically shaped peaks.</p>
</td></tr>
<tr><td><code id="makeMPM2Function_+3A_peak.shape">peak.shape</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Shape of peak(s). Possible values are &ldquo;ellipse&rdquo; and &ldquo;sphere&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>Author(s)</h3>

<p><span class="rlang"><b>R</b></span> interface by Jakob Bossek. Original python code provided by the Simon Wessing.
</p>


<h3>References</h3>

<p>See the technical report of multiple peaks model 2 for an in-depth
description of the underlying algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fn = makeMPM2Function(n.peaks = 10L, dimensions = 2L,
  topology = "funnel", seed = 123, rotated = TRUE, peak.shape = "ellipse")
if (require(plot3D)) {
  plot3D(fn)
}

## End(Not run)
## Not run: 
fn = makeMPM2Function(n.peaks = 5L, dimensions = 2L,
  topology = "random", seed = 134, rotated = FALSE)
plot(fn, render.levels = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='makeMultiObjectiveFunction'>Generator for multi-objective target functions.</h2><span id='topic+makeMultiObjectiveFunction'></span>

<h3>Description</h3>

<p>Generator for multi-objective target functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMultiObjectiveFunction(
  name = NULL,
  id = NULL,
  description = NULL,
  fn,
  has.simple.signature = TRUE,
  par.set,
  n.objectives = NULL,
  noisy = FALSE,
  fn.mean = NULL,
  minimize = NULL,
  vectorized = FALSE,
  constraint.fn = NULL,
  ref.point = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMultiObjectiveFunction_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Function name. Used for the title of plots for example.</p>
</td></tr>
<tr><td><code id="makeMultiObjectiveFunction_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code> | <code>NULL</code>]<br />
Optional short function identifier. If provided, this should be a short
name without whitespaces and now special characters beside the underscore.
Default is <code>NULL</code>, which means no ID at all.</p>
</td></tr>
<tr><td><code id="makeMultiObjectiveFunction_+3A_description">description</code></td>
<td>
<p>[<code>character(1)</code> | <code>NULL</code>]<br />
Optional function description.</p>
</td></tr>
<tr><td><code id="makeMultiObjectiveFunction_+3A_fn">fn</code></td>
<td>
<p>[<code>function</code>]<br />
Objective function.</p>
</td></tr>
<tr><td><code id="makeMultiObjectiveFunction_+3A_has.simple.signature">has.simple.signature</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Set this to <code>TRUE</code> if the objective function expects a vector as input and <code>FALSE</code>
if it expects a named list of values. The latter is needed if the function depends on mixed
parameters. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="makeMultiObjectiveFunction_+3A_par.set">par.set</code></td>
<td>
<p>[<code><a href="ParamHelpers.html#topic+ParamSet">ParamSet</a></code>]<br />
Parameter set describing different aspects of the objective function parameters, i.~e.,
names, lower and/or upper bounds, types and so on. See <code><a href="ParamHelpers.html#topic+makeParamSet">makeParamSet</a></code>
for further information.</p>
</td></tr>
<tr><td><code id="makeMultiObjectiveFunction_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives of the multi-objective function.</p>
</td></tr>
<tr><td><code id="makeMultiObjectiveFunction_+3A_noisy">noisy</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Is the function noisy? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="makeMultiObjectiveFunction_+3A_fn.mean">fn.mean</code></td>
<td>
<p>[<code>function</code>]<br />
Optional true mean function in case of a noisy objective function. This functions should
have the same mean as <code>fn</code>.</p>
</td></tr>
<tr><td><code id="makeMultiObjectiveFunction_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical</code>]<br />
Logical vector of length <code>n.objectives</code> indicating if the corresponding
objectives shall be minimized or maximized.
Default is the vector with all components set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="makeMultiObjectiveFunction_+3A_vectorized">vectorized</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Can the objective function handle &ldquo;vector&rdquo; input, i.~e., does it
accept matrix of parameters? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="makeMultiObjectiveFunction_+3A_constraint.fn">constraint.fn</code></td>
<td>
<p>[<code>function | NULL</code>]<br />
Function which returns a logical vector indicating whether certain conditions
are met or not. Default is <code>NULL</code>, which means, that there are no constraints
beside possible box constraints defined via the <code>par.set</code> argument.</p>
</td></tr>
<tr><td><code id="makeMultiObjectiveFunction_+3A_ref.point">ref.point</code></td>
<td>
<p>[<code>numeric</code>]<br />
Optional reference point in the objective space, e.g., for hypervolume computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>function</code>] Target function with additional stuff attached as attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn = makeMultiObjectiveFunction(
  name = "My test function",
  fn = function(x) c(sum(x^2), exp(x)),
  n.objectives = 2L,
  par.set = makeNumericParamSet("x", len = 1L, lower = -5L, upper = 5L)
)
print(fn)
</code></pre>

<hr>
<h2 id='makeOmniTestFunction'>MMF13 Function</h2><span id='topic+makeOmniTestFunction'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeOmniTestFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makePeriodicFunction'>Periodic Function</h2><span id='topic+makePeriodicFunction'></span>

<h3>Description</h3>

<p>Single-objective two-dimensional test function. The formula is given as
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 1 + \sin^2(\mathbf{x}_1) + \sin^2(\mathbf{x}_2) - 0.1e^{-(\mathbf{x}_1^2 + \mathbf{x}_2^2)}</code>
</p>

<p>subject to the constraints <code class="reqn">\mathbf{x}_i \in [-10, 10], i = 1, 2.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePeriodicFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>M. M. Ali, C. Khompatraporn, Z. B. Zabinsky, A Numerical
Evaluation of Several Stochastic Algorithms on Selected Continuous Global
Optimization Test Problems, Journal of Global Optimization, vol. 31, pp.
635-672, 2005.
</p>

<hr>
<h2 id='makePowellSumFunction'>Powell-Sum Function</h2><span id='topic+makePowellSumFunction'></span>

<h3>Description</h3>

<p>The formula that underlies the implementation is given by
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i=1}^n |\mathbf{x}_i|^{i+1}</code>
</p>

<p>with <code class="reqn">\mathbf{x}_i \in [-1, 1], i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePowellSumFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePowellSumFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>S. Rahnamyan, H. R. Tizhoosh, N. M. M. Salama, A Novel Population
Initialization Method for Accelerating Evolutionary Algorithms, Computers and
Mathematics with Applications, vol. 53, no. 10, pp. 1605-1614, 2007.
</p>

<hr>
<h2 id='makePriceN1Function'>Price Function N. 1</h2><span id='topic+makePriceN1Function'></span>

<h3>Description</h3>

<p>Second function by Price. The implementation is based on the defintion
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (|\mathbf{x}_1| - 5)^2 + (|\mathbf{x}_2 - 5)^2</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-500, 500], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePriceN1Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>W. L. Price, A Controlled Random Search Procedure for Global
Optimisation, Computer journal, vol. 20, no. 4, pp. 367-370, 1977.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makePriceN2Function">makePriceN2Function</a></code>, <code><a href="#topic+makePriceN4Function">makePriceN4Function</a></code>
</p>

<hr>
<h2 id='makePriceN2Function'>Price Function N. 2</h2><span id='topic+makePriceN2Function'></span>

<h3>Description</h3>

<p>Second function by Price. The implementation is based on the defintion
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 1 + \sin^2(\mathbf{x}_1) + \sin^2(\mathbf{x}_2) - 0.1 \exp(-\mathbf{x}^2 - \mathbf{x}_2^2)</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-10, 10], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePriceN2Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>W. L. Price, A Controlled Random Search Procedure for Global
Optimisation, Computer journal, vol. 20, no. 4, pp. 367-370, 1977.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makePriceN1Function">makePriceN1Function</a></code>, <code><a href="#topic+makePriceN4Function">makePriceN4Function</a></code>
</p>

<hr>
<h2 id='makePriceN4Function'>Price Function N. 4</h2><span id='topic+makePriceN4Function'></span>

<h3>Description</h3>

<p>Fourth function by Price. The implementation is based on the defintion
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (2\mathbf{x}_1^3 \mathbf{x}_2 - \mathbf{x}_2^3)^2 + (6\mathbf{x}_1 - \mathbf{x}_2^2 + \mathbf{x}_2)^2</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-500, 500]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePriceN4Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>W. L. Price, A Controlled Random Search Procedure for Global
Optimisation, Computer journal, vol. 20, no. 4, pp. 367-370, 1977.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makePriceN1Function">makePriceN1Function</a></code>, <code><a href="#topic+makePriceN2Function">makePriceN2Function</a></code>
</p>

<hr>
<h2 id='makeRastriginFunction'>Rastrigin Function</h2><span id='topic+makeRastriginFunction'></span>

<h3>Description</h3>

<p>One of the most popular single-objective test functions consists of many
local optima and is thus highly multimodal with a global structure.
The implementation follows the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 10n + \sum_{i=1}^{n} \left(\mathbf{x}_i^2 - 10 \cos(2\pi \mathbf{x}_i)\right).</code>
</p>

<p>The box-constraints are given by <code class="reqn">\mathbf{x}_i \in [-5.12, 5.12]</code> for
<code class="reqn">i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeRastriginFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeRastriginFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>L. A. Rastrigin. Extremal control systems. Theoretical Foundations
of Engineering Cybernetics Series. Nauka, Moscow, 1974.
</p>

<hr>
<h2 id='makeRosenbrockFunction'>Rosenbrock Function</h2><span id='topic+makeRosenbrockFunction'></span>

<h3>Description</h3>

<p>Also known as the &ldquo;De Jong's function 2&rdquo; or the &ldquo;(Rosenbrock)
banana/valley function&rdquo; due to its shape. The global optimum is located within
a large flat valley and thus it is hard for optimization algorithms to find it.
The following formula underlies the implementation:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i=1}^{n-1} 100 \cdot (\mathbf{x}_{i+1} - \mathbf{x}_i^2)^2 + (1 - \mathbf{x}_i)^2.</code>
</p>

<p>The domain is given by the constraints <code class="reqn">\mathbf{x}_i \in [-30, 30], i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeRosenbrockFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeRosenbrockFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>H. H. Rosenbrock, An Automatic Method for Finding the Greatest or
least Value of a Function, Computer Journal, vol. 3, no. 3, pp. 175-184, 1960.
</p>

<hr>
<h2 id='makeSchafferN2Function'>Modified Schaffer Function N. 2</h2><span id='topic+makeSchafferN2Function'></span>

<h3>Description</h3>

<p>Second function by Schaffer. The defintion is given by the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 0.5 + \frac{\sin^2(\mathbf{x}_1^2 - \mathbf{x}_2^2) - 0.5}{(1 + 0.001(\mathbf{x}_1^2 + \mathbf{x}_2^2))^2}</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-100, 100], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSchafferN2Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>S. K. Mishra, Some New Test Functions For Global Optimization
And Performance of Repulsive Particle Swarm Method.
</p>

<hr>
<h2 id='makeSchafferN4Function'>Schaffer Function N. 4</h2><span id='topic+makeSchafferN4Function'></span>

<h3>Description</h3>

<p>Second function by Schaffer. The defintion is given by the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 0.5 + \frac{\cos^2(sin(|\mathbf{x}_1^2 - \mathbf{x}_2^2|)) - 0.5}{(1 + 0.001(\mathbf{x}_1^2 + \mathbf{x}_2^2))^2}</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-100, 100], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSchafferN4Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>S. K. Mishra, Some New Test Functions For Global Optimization
And Performance of Repulsive Particle Swarm Method.
</p>

<hr>
<h2 id='makeSchwefelFunction'>Schwefel function</h2><span id='topic+makeSchwefelFunction'></span>

<h3>Description</h3>

<p>Highly multimodal test function. The cursial thing about this function is, that
the global optimum is far away from the next best local optimum.
The function is computed via:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i=1}^{n} -\mathbf{x}_i \sin\left(\sqrt(|\mathbf{x}_i|)\right)</code>
</p>

<p>with <code class="reqn">\mathbf{x}_i \in [-500, 500], i = 1, \ldots, n.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSchwefelFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSchwefelFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>Schwefel, H.-P.: Numerical optimization of computer models.
Chichester: Wiley &amp; Sons, 1981.
</p>

<hr>
<h2 id='makeShekelFunction'>Shekel functions</h2><span id='topic+makeShekelFunction'></span>

<h3>Description</h3>

<p>Single-objective test function based on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = -\sum_{i=1}^{m} \left(\sum_{j=1}^{4} (x_j - C_{ji})^2 + \beta_{i}\right)^{-1}</code>
</p>
<p>.
Here, <code class="reqn">m \in \{5, 7, 10\}</code> defines the number of local optima, <code class="reqn">C</code> is a <code class="reqn">4 x 10</code> matrix
and <code class="reqn">\beta = \frac{1}{10}(1, 1, 2, 2, 4, 4, 6, 3, 7, 5, 5)</code> is a vector. See <a href="https://www.sfu.ca/~ssurjano/shekel.html">https://www.sfu.ca/~ssurjano/shekel.html</a>
for a defintion of <code class="reqn">C</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeShekelFunction(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeShekelFunction_+3A_m">m</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Integer parameter (defines the number of local optima).
Possible values are 5, 7 or 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>

<hr>
<h2 id='makeShubertFunction'>Shubert Function</h2><span id='topic+makeShubertFunction'></span>

<h3>Description</h3>

<p>The defintion of this two-dimensional function is given by
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \prod_{i = 1}^{2} \left(\sum_{j = 1}^{5} \cos((j + 1)\mathbf{x}_i + j\right)</code>
</p>

<p>subject to <code class="reqn">\mathbf{x}_i \in [-10, 10], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeShubertFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>J. P. Hennart (ed.), Numerical Analysis, Proc. 3rd AS Workshop,
Lecture Notes in Mathematics, vol. 90, Springer, 1982.
</p>

<hr>
<h2 id='makeSingleObjectiveFunction'>Generator for single-objective target functions.</h2><span id='topic+makeSingleObjectiveFunction'></span>

<h3>Description</h3>

<p>Generator for single-objective target functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSingleObjectiveFunction(
  name = NULL,
  id = NULL,
  description = NULL,
  fn,
  has.simple.signature = TRUE,
  vectorized = FALSE,
  par.set,
  noisy = FALSE,
  fn.mean = NULL,
  minimize = TRUE,
  constraint.fn = NULL,
  tags = character(0),
  global.opt.params = NULL,
  global.opt.value = NULL,
  local.opt.params = NULL,
  local.opt.values = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSingleObjectiveFunction_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Function name. Used for the title of plots for example.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code> | <code>NULL</code>]<br />
Optional short function identifier. If provided, this should be a short
name without whitespaces and now special characters beside the underscore.
Default is <code>NULL</code>, which means no ID at all.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_description">description</code></td>
<td>
<p>[<code>character(1)</code> | <code>NULL</code>]<br />
Optional function description.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_fn">fn</code></td>
<td>
<p>[<code>function</code>]<br />
Objective function.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_has.simple.signature">has.simple.signature</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Set this to <code>TRUE</code> if the objective function expects a vector as input and <code>FALSE</code>
if it expects a named list of values. The latter is needed if the function depends on mixed
parameters. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_vectorized">vectorized</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Can the objective function handle &ldquo;vector&rdquo; input, i.~e., does it
accept matrix of parameters? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_par.set">par.set</code></td>
<td>
<p>[<code><a href="ParamHelpers.html#topic+ParamSet">ParamSet</a></code>]<br />
Parameter set describing different aspects of the objective function parameters, i.~e.,
names, lower and/or upper bounds, types and so on. See <code><a href="ParamHelpers.html#topic+makeParamSet">makeParamSet</a></code>
for further information.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_noisy">noisy</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Is the function noisy? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_fn.mean">fn.mean</code></td>
<td>
<p>[<code>function</code>]<br />
Optional true mean function in case of a noisy objective function. This functions should
have the same mean as <code>fn</code>.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Set this to <code>TRUE</code> if the function should be minimized and to
<code>FALSE</code> otherwise.
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_constraint.fn">constraint.fn</code></td>
<td>
<p>[<code>function | NULL</code>]<br />
Function which returns a logical vector indicating whether certain conditions
are met or not. Default is <code>NULL</code>, which means, that there are no constraints
beside possible box constraints defined via the <code>par.set</code> argument.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_tags">tags</code></td>
<td>
<p>[<code>character</code>]<br />
Optional character vector of tags or keywords which characterize the function,
e.~g. &ldquo;unimodal&rdquo;, &ldquo;separable&rdquo;. See <code><a href="#topic+getAvailableTags">getAvailableTags</a></code> for
a character vector of allowed tags.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_global.opt.params">global.opt.params</code></td>
<td>
<p>[<code>list</code> | <code>numeric</code> | <code>data.frame</code> | <code>matrix</code> | <code>NULL</code>]<br />
Default is <code>NULL</code> which means unknown. Passing a <code>numeric</code> vector will
be the most frequent case (numeric only functions). In this case there is only a
single global optimum. If there are multiple global optima, passing a numeric
<code>matrix</code> is the best choice. Passing a <code>list</code> or a <code>data.frame</code>
is necessary if your function is mixed, e.g., it expects both numeric and discrete
parameters. Internally, however, each representation is casted to a <code>data.frame</code>
for reasons of consistency.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_global.opt.value">global.opt.value</code></td>
<td>
<p>[<code>numeric(1)</code> | <code>NULL</code>]<br />
Global optimum value if known. Default is <code>NULL</code>, which means unknown. If
only the <code>global.opt.params</code> are passed, the value is computed automatically.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_local.opt.params">local.opt.params</code></td>
<td>
<p>[<code>list</code> | <code>numeric</code> | <code>data.frame</code> | <code>matrix</code> | <code>NULL</code>]<br />
Default is <code>NULL</code>, which means the function has no local optima or they are
unknown. For details see the description of <code>global.opt.params</code>.</p>
</td></tr>
<tr><td><code id="makeSingleObjectiveFunction_+3A_local.opt.values">local.opt.values</code></td>
<td>
<p>[<code>numeric</code> | <code>NULL</code>]<br />
Value(s) of local optima. Default is <code>NULL</code>, which means unknown. If
only the <code>local.opt.params</code> are passed, the values are computed automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>function</code>] Objective function with additional stuff attached as attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

fn = makeSingleObjectiveFunction(
  name = "Sphere Function",
  fn = function(x) sum(x^2),
  par.set = makeNumericParamSet("x", len = 1L, lower = -5L, upper = 5L),
  global.opt.params = list(x = 0)
)
print(fn)
print(autoplot(fn))

fn.num2 = makeSingleObjectiveFunction(
  name = "Numeric 2D",
  fn = function(x) sum(x^2),
  par.set = makeParamSet(
    makeNumericParam("x1", lower = -5, upper = 5),
    makeNumericParam("x2", lower = -10, upper = 20)
  )
)
print(fn.num2)
print(autoplot(fn.num2))

fn.mixed = makeSingleObjectiveFunction(
  name = "Mixed 2D",
  fn = function(x) x$num1^2 + as.integer(as.character(x$disc1) == "a"),
  has.simple.signature = FALSE,
  par.set = makeParamSet(
    makeNumericParam("num1", lower = -5, upper = 5),
    makeDiscreteParam("disc1", values = c("a", "b"))
  ),
  global.opt.params = list(num1 = 0, disc1 = "b")
)
print(fn.mixed)
print(autoplot(fn.mixed))
</code></pre>

<hr>
<h2 id='makeSixHumpCamelFunction'>Three-Hump Camel Function</h2><span id='topic+makeSixHumpCamelFunction'></span>

<h3>Description</h3>

<p>Two dimensional single-objective test function with six local minima oh which
two are global. The surface is similar to the back of a camel. That is why it
is called Camel function. The implementation is based on the formula:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \left(4 - 2.1\mathbf{x}_1^2 + \mathbf{x}_1^{0.75}\right)\mathbf{x}_1^2 + \mathbf{x}_1 \mathbf{x}_2 + \left(-4 + 4\mathbf{x}_2^2\right)\mathbf{x}_2^2</code>
</p>

<p>with box constraints <code class="reqn">\mathbf{x}_1 \in [-3, 3]</code> and <code class="reqn">\mathbf{x}_2 \in [-2, 2]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSixHumpCamelFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>Dixon, L. C. W. and Szego, G. P.: The optimization problem: An introduction.
In: Towards Global Optimization II, New York: North Holland, 1978.
</p>

<hr>
<h2 id='makeSphereFunction'>Sphere Function</h2><span id='topic+makeSphereFunction'></span>

<h3>Description</h3>

<p>Also known as the the &ldquo;De Jong function 1&rdquo;. Convex, continous function
calculated via the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i=1}^{n} \mathbf{x}_i^2</code>
</p>

<p>with box-constraings <code class="reqn">\mathbf{x}_i \in [-5.12, 5.12], i = 1, \ldots, n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSphereFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSphereFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>M. A. Schumer, K. Steiglitz, Adaptive Step Size Random Search,
IEEE Transactions on Automatic Control. vol. 13, no. 3, pp. 270-276, 1968.
</p>

<hr>
<h2 id='makeStyblinkskiTangFunction'>Styblinkski-Tang function</h2><span id='topic+makeStyblinkskiTangFunction'></span>

<h3>Description</h3>

<p>This function is based on the defintion
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \frac{1}{2} \sum_{i = 1}^{2} (\mathbf{x}_i^4 - 16 \mathbf{x}_i^2 + 5\mathbf{x}_i)</code>
</p>

<p>with box-constraints given by <code class="reqn">\mathbf{x}_i \in [-5, 5], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeStyblinkskiTangFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>Z. K. Silagadze, Finding Two-Dimesnional Peaks, Physics of
Particles and Nuclei Letters, vol. 4, no. 1, pp. 73-80, 2007.
</p>

<hr>
<h2 id='makeSumOfDifferentSquaresFunction'>Sum of Different Squares Function</h2><span id='topic+makeSumOfDifferentSquaresFunction'></span>

<h3>Description</h3>

<p>Simple unimodal test function similar to the Sphere and Hyper-Ellipsoidal functions.
Formula:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \sum_{i=1}^{n} |\mathbf{x}_i|^{i+1}.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>makeSumOfDifferentSquaresFunction(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSumOfDifferentSquaresFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>

<hr>
<h2 id='makeSwiler2014Function'>Swiler2014 function.</h2><span id='topic+makeSwiler2014Function'></span>

<h3>Description</h3>

<p>Mixed parameter space with one discrete parameter <code class="reqn">x_1 \in \{1, 2, 3, 4, 5\}</code>
and two numerical parameters <code class="reqn">x_1, x_2 \in [0, 1]</code>. The function is defined
as follows:
</p>
<p style="text-align: center;"><code class="reqn">
f(\mathbf{x}) = \\
\sin(2\pi x_3 - \pi) + 7 \sin^2(2 \pi x_2 - \pi) \, if \, x_1 = 1 \\
\sin(2\pi x_3 - \pi) + 7 \sin^2(2 \pi x_2 - \pi) + 12 \sin(2 \pi x_3 - \pi) \, if \, x_1 = 2 \\
\sin(2\pi x_3 - \pi) + 7 \sin^2(2 \pi x_2 - \pi) + 0.5 \sin(2 \pi x_3 - \pi) \, if \, x_1 = 3 \\
\sin(2\pi x_3 - \pi) + 7 \sin^2(2 \pi x_2 - \pi) + 8.0 \sin(2 \pi x_3 - \pi) \, if \, x_1 = 4 \\
\sin(2\pi x_3 - \pi) + 7 \sin^2(2 \pi x_2 - \pi) + 3.5 \sin(2 \pi x_3 - \pi) \, if \, x_1 = 5.
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>makeSwiler2014Function()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>

<hr>
<h2 id='makeSYMPARTrotatedFunction'>MMF13 Function</h2><span id='topic+makeSYMPARTrotatedFunction'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSYMPARTrotatedFunction(w = pi/4, a = 1, b = 10, c = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSYMPARTrotatedFunction_+3A_w">w</code></td>
<td>
<p>[<code>double</code>(1)]<br />
Parametrizable factor. In the CEC2019 competition, the organizers used
<code>w = pi / 4</code>.</p>
</td></tr>
<tr><td><code id="makeSYMPARTrotatedFunction_+3A_a">a</code></td>
<td>
<p>[<code>double</code>(1)]<br />
Parametrizable factor. In the CEC2019 competition, the organizers used
<code>a = 1</code>.</p>
</td></tr>
<tr><td><code id="makeSYMPARTrotatedFunction_+3A_b">b</code></td>
<td>
<p>[<code>double</code>(1)]<br />
Parametrizable factor. In the CEC2019 competition, the organizers used
<code>b = 10</code>.</p>
</td></tr>
<tr><td><code id="makeSYMPARTrotatedFunction_+3A_c">c</code></td>
<td>
<p>[<code>double</code>(1)]<br />
Parametrizable factor. In the CEC2019 competition, the organizers used
<code>c = 8</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeSYMPARTsimpleFunction'>MMF13 Function</h2><span id='topic+makeSYMPARTsimpleFunction'></span>

<h3>Description</h3>

<p>Test problem from the set of &quot;multimodal multiobjective functions&quot; as for
instance used in the CEC2019 competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSYMPARTsimpleFunction(a = 1, b = 10, c = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSYMPARTsimpleFunction_+3A_a">a</code></td>
<td>
<p>[<code>double</code>(1)]<br />
Parametrizable factor. In the CEC2019 competition, the organizers used
<code>a = 1</code>.</p>
</td></tr>
<tr><td><code id="makeSYMPARTsimpleFunction_+3A_b">b</code></td>
<td>
<p>[<code>double</code>(1)]<br />
Parametrizable factor. In the CEC2019 competition, the organizers used
<code>b = 10</code>.</p>
</td></tr>
<tr><td><code id="makeSYMPARTsimpleFunction_+3A_c">c</code></td>
<td>
<p>[<code>double</code>(1)]<br />
Parametrizable factor. In the CEC2019 competition, the organizers used
<code>c = 8</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Caitong Yue, Boyang Qu, Kunjie Yu, Jing Liang, and Xiaodong Li, &quot;A novel
scalable test problem suite for multimodal multiobjective optimization,&quot; in
Swarm and Evolutionary Computation, Volume 48, August 2019, pp. 62–71, Elsevier.
</p>

<hr>
<h2 id='makeThreeHumpCamelFunction'>Three-Hump Camel Function</h2><span id='topic+makeThreeHumpCamelFunction'></span>

<h3>Description</h3>

<p>This two-dimensional function is based on the defintion
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = 2 \mathbf{x}_1^2 - 1.05 \mathbf{x}_1^4 + \frac{\mathbf{x}_1^6}{6} + \mathbf{x}_1\mathbf{x}_2 + \mathbf{x}_2^2</code>
</p>

<p>subject to <code class="reqn">-5 \leq \mathbf{x}_i \leq 5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeThreeHumpCamelFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>F. H. Branin Jr., Widely Convergent Method of Finding Multiple
Solutions of Simul- taneous Nonlinear Equations, IBM Journal of Research
and Development, vol. 16, no. 5, pp. 504-522, 1972.
</p>

<hr>
<h2 id='makeTrecanniFunction'>Trecanni Function</h2><span id='topic+makeTrecanniFunction'></span>

<h3>Description</h3>

<p>The Trecanni function belongs to the unimodal test functions. It is based
on the formula
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf(x)) = \mathbf(x)_1^4 - 4 \mathbf(x)_1^3 + 4 \mathbf(x)_1 + \mathbf(x)_2^2.</code>
</p>

<p>The box-constraints <code class="reqn">\mathbf{x}_i \in [-5, 5], i = 1, 2</code> define the
domain of defintion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTrecanniFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>L. C. W. Dixon, G. P. Szego (eds.), Towards Global Optimization 2,
Elsevier, 1978.
</p>

<hr>
<h2 id='makeUFFunction'>Generator for the functions UF1, ..., UF10 of the CEC 2009.</h2><span id='topic+makeUFFunction'></span>

<h3>Description</h3>

<p>Generator for the functions UF1, ..., UF10 of the CEC 2009.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeUFFunction(dimensions, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeUFFunction_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Size of corresponding parameter space.</p>
</td></tr>
<tr><td><code id="makeUFFunction_+3A_id">id</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Instance identifier. Integer value between 1 and 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>Note</h3>

<p>The implementation is based on the original CPP implemenation by Qingfu
Zhang, Aimin Zhou, Shizheng Zhaoy, Ponnuthurai Nagaratnam Suganthany, Wudong Liu
and Santosh Tiwar.
</p>


<h3>Author(s)</h3>

<p>Jakob Bossek <a href="mailto:j.bossek@gmail.com">j.bossek@gmail.com</a>
</p>

<hr>
<h2 id='makeViennetFunction'>Viennet function generator</h2><span id='topic+makeViennetFunction'></span>

<h3>Description</h3>

<p>The Viennet test problem VNT is designed for three objectives only. It has
a discrete set of Pareto fronts. It is defined by the following formulae.
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \left(f_1(\mathbf{x}), f_2(\mathbf{x}, f_3(\mathbf{x}\right)</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">f_1(\mathbf{x}) = 0.5(\mathbf{x}_1^2 + \mathbf{x}_2^2) + \sin(\mathbf{x}_1^2 + \mathbf{x}_2^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f_2(\mathbf{x}) = \frac{(3\mathbf{x}_1 + 2\mathbf{x}_2 + 4)^2}{8} + \frac{(\mathbf{x}_1 - \mathbf{x}_2 + 1)^2}{27} + 15</code>
</p>

<p style="text-align: center;"><code class="reqn">f_3(\mathbf{x}) = \frac{1}{\mathbf{x}_1^2 + \mathbf{x}_2^2 + 1} - 1.1\exp(-(\mathbf{x}_1^1 + \mathbf{x}_2^2))</code>
</p>

<p>with box constraints <code class="reqn">-3 \leq \mathbf{x}_1, \mathbf{x}_2 \leq 3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeViennetFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>Viennet, R. (1996). Multicriteria optimization using a genetic algorithm for determining the
Pareto set. International Journal of Systems Science 27 (2), 255-260.
</p>

<hr>
<h2 id='makeWFG1Function'>WFG1 Function</h2><span id='topic+makeWFG1Function'></span>

<h3>Description</h3>

<p>First test problem from the &quot;Walking Fish Group&quot; problem generator toolkit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeWFG1Function(n.objectives, k, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeWFG1Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeWFG1Function_+3A_k">k</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of position-related parameters. These will automatically be the
first <code>k</code> elements from the input vector. This value has to be a
multiple of <code>n.objectives - 1</code>.</p>
</td></tr>
<tr><td><code id="makeWFG1Function_+3A_l">l</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of distance-related parameters. These will automatically be
the last <code>l</code> elements from the input vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Huband et al. recommend a value of <code>k = 4L</code> position-related
parameters for bi-objective problems and <code>k = 2L * (n.objectives - 1L)</code>
for many-objective problems. Furthermore the authors recommend a value of
<code>l = 20</code> distance-related parameters. Therefore, if <code>k</code> and/or
<code>l</code> are not explicitly defined by the user, their values will be set
to the recommended values per default.
</p>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>S. Huband, P. Hingston, L. Barone, and L. While, &quot;A Review of Multi-objective
Test Problems and a Scalable Test Problem Toolkit,&quot; in IEEE Transactions on
Evolutionary Computation, Volume 10, No 5, October 2006, pp. 477-506. IEEE.
</p>

<hr>
<h2 id='makeWFG2Function'>WFG2 Function</h2><span id='topic+makeWFG2Function'></span>

<h3>Description</h3>

<p>Second test problem from the &quot;Walking Fish Group&quot; problem generator toolkit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeWFG2Function(n.objectives, k, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeWFG2Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeWFG2Function_+3A_k">k</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of position-related parameters. These will automatically be the
first <code>k</code> elements from the input vector. This value has to be a
multiple of <code>n.objectives - 1</code>.</p>
</td></tr>
<tr><td><code id="makeWFG2Function_+3A_l">l</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of distance-related parameters. These will automatically be
the last <code>l</code> elements from the input vector. This value has to
be a multiple of 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Huband et al. recommend a value of <code>k = 4L</code> position-related
parameters for bi-objective problems and <code>k = 2L * (n.objectives - 1L)</code>
for many-objective problems. Furthermore the authors recommend a value of
<code>l = 20</code> distance-related parameters. Therefore, if <code>k</code> and/or
<code>l</code> are not explicitly defined by the user, their values will be set
to the recommended values per default.
</p>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>S. Huband, P. Hingston, L. Barone, and L. While, &quot;A Review of Multi-objective
Test Problems and a Scalable Test Problem Toolkit,&quot; in IEEE Transactions on
Evolutionary Computation, Volume 10, No 5, October 2006, pp. 477-506. IEEE.
</p>

<hr>
<h2 id='makeWFG3Function'>WFG3 Function</h2><span id='topic+makeWFG3Function'></span>

<h3>Description</h3>

<p>Third test problem from the &quot;Walking Fish Group&quot; problem generator toolkit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeWFG3Function(n.objectives, k, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeWFG3Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeWFG3Function_+3A_k">k</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of position-related parameters. These will automatically be the
first <code>k</code> elements from the input vector. This value has to be a
multiple of <code>n.objectives - 1</code>.</p>
</td></tr>
<tr><td><code id="makeWFG3Function_+3A_l">l</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of distance-related parameters. These will automatically be
the last <code>l</code> elements from the input vector. This value has to
be a multiple of 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Huband et al. recommend a value of <code>k = 4L</code> position-related
parameters for bi-objective problems and <code>k = 2L * (n.objectives - 1L)</code>
for many-objective problems. Furthermore the authors recommend a value of
<code>l = 20</code> distance-related parameters. Therefore, if <code>k</code> and/or
<code>l</code> are not explicitly defined by the user, their values will be set
to the recommended values per default.
</p>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>S. Huband, P. Hingston, L. Barone, and L. While, &quot;A Review of Multi-objective
Test Problems and a Scalable Test Problem Toolkit,&quot; in IEEE Transactions on
Evolutionary Computation, Volume 10, No 5, October 2006, pp. 477-506. IEEE.
</p>

<hr>
<h2 id='makeWFG4Function'>WFG4 Function</h2><span id='topic+makeWFG4Function'></span>

<h3>Description</h3>

<p>Fourth test problem from the &quot;Walking Fish Group&quot; problem generator toolkit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeWFG4Function(n.objectives, k, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeWFG4Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeWFG4Function_+3A_k">k</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of position-related parameters. These will automatically be the
first <code>k</code> elements from the input vector. This value has to be a
multiple of <code>n.objectives - 1</code>.</p>
</td></tr>
<tr><td><code id="makeWFG4Function_+3A_l">l</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of distance-related parameters. These will automatically be
the last <code>l</code> elements from the input vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Huband et al. recommend a value of <code>k = 4L</code> position-related
parameters for bi-objective problems and <code>k = 2L * (n.objectives - 1L)</code>
for many-objective problems. Furthermore the authors recommend a value of
<code>l = 20</code> distance-related parameters. Therefore, if <code>k</code> and/or
<code>l</code> are not explicitly defined by the user, their values will be set
to the recommended values per default.
</p>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>S. Huband, P. Hingston, L. Barone, and L. While, &quot;A Review of Multi-objective
Test Problems and a Scalable Test Problem Toolkit,&quot; in IEEE Transactions on
Evolutionary Computation, Volume 10, No 5, October 2006, pp. 477-506. IEEE.
</p>

<hr>
<h2 id='makeWFG5Function'>WFG5 Function</h2><span id='topic+makeWFG5Function'></span>

<h3>Description</h3>

<p>Fifth test problem from the &quot;Walking Fish Group&quot; problem generator toolkit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeWFG5Function(n.objectives, k, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeWFG5Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeWFG5Function_+3A_k">k</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of position-related parameters. These will automatically be the
first <code>k</code> elements from the input vector. This value has to be a
multiple of <code>n.objectives - 1</code>.</p>
</td></tr>
<tr><td><code id="makeWFG5Function_+3A_l">l</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of distance-related parameters. These will automatically be
the last <code>l</code> elements from the input vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Huband et al. recommend a value of <code>k = 4L</code> position-related
parameters for bi-objective problems and <code>k = 2L * (n.objectives - 1L)</code>
for many-objective problems. Furthermore the authors recommend a value of
<code>l = 20</code> distance-related parameters. Therefore, if <code>k</code> and/or
<code>l</code> are not explicitly defined by the user, their values will be set
to the recommended values per default.
</p>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>S. Huband, P. Hingston, L. Barone, and L. While, &quot;A Review of Multi-objective
Test Problems and a Scalable Test Problem Toolkit,&quot; in IEEE Transactions on
Evolutionary Computation, Volume 10, No 5, October 2006, pp. 477-506. IEEE.
</p>

<hr>
<h2 id='makeWFG6Function'>WFG6 Function</h2><span id='topic+makeWFG6Function'></span>

<h3>Description</h3>

<p>Sixth test problem from the &quot;Walking Fish Group&quot; problem generator toolkit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeWFG6Function(n.objectives, k, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeWFG6Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeWFG6Function_+3A_k">k</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of position-related parameters. These will automatically be the
first <code>k</code> elements from the input vector. This value has to be a
multiple of <code>n.objectives - 1</code>.</p>
</td></tr>
<tr><td><code id="makeWFG6Function_+3A_l">l</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of distance-related parameters. These will automatically be
the last <code>l</code> elements from the input vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Huband et al. recommend a value of <code>k = 4L</code> position-related
parameters for bi-objective problems and <code>k = 2L * (n.objectives - 1L)</code>
for many-objective problems. Furthermore the authors recommend a value of
<code>l = 20</code> distance-related parameters. Therefore, if <code>k</code> and/or
<code>l</code> are not explicitly defined by the user, their values will be set
to the recommended values per default.
</p>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>S. Huband, P. Hingston, L. Barone, and L. While, &quot;A Review of Multi-objective
Test Problems and a Scalable Test Problem Toolkit,&quot; in IEEE Transactions on
Evolutionary Computation, Volume 10, No 5, October 2006, pp. 477-506. IEEE.
</p>

<hr>
<h2 id='makeWFG7Function'>WFG7 Function</h2><span id='topic+makeWFG7Function'></span>

<h3>Description</h3>

<p>Seventh test problem from the &quot;Walking Fish Group&quot; problem generator toolkit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeWFG7Function(n.objectives, k, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeWFG7Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeWFG7Function_+3A_k">k</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of position-related parameters. These will automatically be the
first <code>k</code> elements from the input vector. This value has to be a
multiple of <code>n.objectives - 1</code>.</p>
</td></tr>
<tr><td><code id="makeWFG7Function_+3A_l">l</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of distance-related parameters. These will automatically be
the last <code>l</code> elements from the input vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Huband et al. recommend a value of <code>k = 4L</code> position-related
parameters for bi-objective problems and <code>k = 2L * (n.objectives - 1L)</code>
for many-objective problems. Furthermore the authors recommend a value of
<code>l = 20</code> distance-related parameters. Therefore, if <code>k</code> and/or
<code>l</code> are not explicitly defined by the user, their values will be set
to the recommended values per default.
</p>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>S. Huband, P. Hingston, L. Barone, and L. While, &quot;A Review of Multi-objective
Test Problems and a Scalable Test Problem Toolkit,&quot; in IEEE Transactions on
Evolutionary Computation, Volume 10, No 5, October 2006, pp. 477-506. IEEE.
</p>

<hr>
<h2 id='makeWFG8Function'>WFG8 Function</h2><span id='topic+makeWFG8Function'></span>

<h3>Description</h3>

<p>Eighth test problem from the &quot;Walking Fish Group&quot; problem generator toolkit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeWFG8Function(n.objectives, k, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeWFG8Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeWFG8Function_+3A_k">k</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of position-related parameters. These will automatically be the
first <code>k</code> elements from the input vector. This value has to be a
multiple of <code>n.objectives - 1</code>.</p>
</td></tr>
<tr><td><code id="makeWFG8Function_+3A_l">l</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of distance-related parameters. These will automatically be
the last <code>l</code> elements from the input vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Huband et al. recommend a value of <code>k = 4L</code> position-related
parameters for bi-objective problems and <code>k = 2L * (n.objectives - 1L)</code>
for many-objective problems. Furthermore the authors recommend a value of
<code>l = 20</code> distance-related parameters. Therefore, if <code>k</code> and/or
<code>l</code> are not explicitly defined by the user, their values will be set
to the recommended values per default.
</p>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>S. Huband, P. Hingston, L. Barone, and L. While, &quot;A Review of Multi-objective
Test Problems and a Scalable Test Problem Toolkit,&quot; in IEEE Transactions on
Evolutionary Computation, Volume 10, No 5, October 2006, pp. 477-506. IEEE.
</p>

<hr>
<h2 id='makeWFG9Function'>WFG9 Function</h2><span id='topic+makeWFG9Function'></span>

<h3>Description</h3>

<p>Ninth test problem from the &quot;Walking Fish Group&quot; problem generator toolkit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeWFG9Function(n.objectives, k, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeWFG9Function_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives.</p>
</td></tr>
<tr><td><code id="makeWFG9Function_+3A_k">k</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of position-related parameters. These will automatically be the
first <code>k</code> elements from the input vector. This value has to be a
multiple of <code>n.objectives - 1</code>.</p>
</td></tr>
<tr><td><code id="makeWFG9Function_+3A_l">l</code></td>
<td>
<p>[<code>integer</code>(1)]<br />
Number of distance-related parameters. These will automatically be
the last <code>l</code> elements from the input vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Huband et al. recommend a value of <code>k = 4L</code> position-related
parameters for bi-objective problems and <code>k = 2L * (n.objectives - 1L)</code>
for many-objective problems. Furthermore the authors recommend a value of
<code>l = 20</code> distance-related parameters. Therefore, if <code>k</code> and/or
<code>l</code> are not explicitly defined by the user, their values will be set
to the recommended values per default.
</p>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>S. Huband, P. Hingston, L. Barone, and L. While, &quot;A Review of Multi-objective
Test Problems and a Scalable Test Problem Toolkit,&quot; in IEEE Transactions on
Evolutionary Computation, Volume 10, No 5, October 2006, pp. 477-506. IEEE.
</p>

<hr>
<h2 id='makeZDT1Function'>ZDT1 Function</h2><span id='topic+makeZDT1Function'></span>

<h3>Description</h3>

<p>Builds and returns the two-objective ZDT1 test problem. For <code class="reqn">m</code> objective it
is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \left(f_1(\mathbf{x}_1), f_2(\mathbf{x})\right)</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">f_1(\mathbf{x}_1) = \mathbf{x}_1, f_2(\mathbf{x}) = g(\mathbf{x}) h(f_1(\mathbf{x}_1), g(\mathbf{x}))</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">g(\mathbf{x}) = 1 + \frac{9}{m - 1} \sum_{i = 2}^m \mathbf{x}_i, h(f_1, g) = 1 - \sqrt{\frac{f_1}{g}}</code>
</p>

<p>and <code class="reqn">\mathbf{x}_i \in [0,1], i = 1, \ldots, m</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeZDT1Function(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeZDT1Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>E. Zitzler, K. Deb, and L. Thiele. Comparison of Multiobjective
Evolutionary Algorithms: Empirical Results. Evolutionary Computation, 8(2):173-195, 2000
</p>

<hr>
<h2 id='makeZDT2Function'>ZDT2 Function</h2><span id='topic+makeZDT2Function'></span>

<h3>Description</h3>

<p>Builds and returns the two-objective ZDT2 test problem. The function is
nonconvex and resembles the ZDT1 function. For <code class="reqn">m</code> objective it
is defined as follows
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \left(f_1(\mathbf{x}_1), f_2(\mathbf{x})\right)</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">f_1(\mathbf{x}_1) = \mathbf{x}_1, f_2(\mathbf{x}) = g(\mathbf{x}) h(f_1(\mathbf{x}_1), g(\mathbf{x}))</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">g(\mathbf{x}) = 1 + \frac{9}{m - 1} \sum_{i = 2}^m \mathbf{x}_i, h(f_1, g) = 1 - \left(\frac{f_1}{g}\right)^2</code>
</p>

<p>and <code class="reqn">\mathbf{x}_i \in [0,1], i = 1, \ldots, m</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeZDT2Function(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeZDT2Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>E. Zitzler, K. Deb, and L. Thiele. Comparison of Multiobjective
Evolutionary Algorithms: Empirical Results. Evolutionary Computation, 8(2):173-195, 2000
</p>

<hr>
<h2 id='makeZDT3Function'>ZDT3 Function</h2><span id='topic+makeZDT3Function'></span>

<h3>Description</h3>

<p>Builds and returns the two-objective ZDT3 test problem. For <code class="reqn">m</code> objective it
is defined as follows
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \left(f_1(\mathbf{x}_1), f_2(\mathbf{x})\right)</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">f_1(\mathbf{x}_1) = \mathbf{x}_1, f_2(\mathbf{x}) = g(\mathbf{x}) h(f_1(\mathbf{x}_1), g(\mathbf{x}))</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">g(\mathbf{x}) = 1 + \frac{9}{m - 1} \sum_{i = 2}^m \mathbf{x}_i, h(f_1, g) = 1 - \sqrt{\frac{f_1(\mathbf{x})}{g(\mathbf{x})}} - \left(\frac{f_1(\mathbf{x})}{g(\mathbf{x})}\right)\sin(10\pi f_1(\mathbf{x}))</code>
</p>

<p>and <code class="reqn">\mathbf{x}_i \in [0,1], i = 1, \ldots, m</code>.
This function has some discontinuities in the Pareto-optimal front introduced
by the sine term in the <code class="reqn">h</code> function (see above). The front consists of
multiple convex parts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeZDT3Function(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeZDT3Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>E. Zitzler, K. Deb, and L. Thiele. Comparison of Multiobjective
Evolutionary Algorithms: Empirical Results. Evolutionary Computation, 8(2):173-195, 2000
</p>

<hr>
<h2 id='makeZDT4Function'>ZDT4 Function</h2><span id='topic+makeZDT4Function'></span>

<h3>Description</h3>

<p>Builds and returns the two-objective ZDT4 test problem. For <code class="reqn">m</code> objective it
is defined as follows
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \left(f_1(\mathbf{x}_1), f_2(\mathbf{x})\right)</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">f_1(\mathbf{x}_1) = \mathbf{x}_1, f_2(\mathbf{x}) = g(\mathbf{x}) h(f_1(\mathbf{x}_1), g(\mathbf{x}))</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">g(\mathbf{x}) = 1 + 10 (m - 1) + \sum_{i = 2}^{m} (\mathbf{x}_i^2 - 10\cos(4\pi\mathbf{x}_i)), h(f_1, g) = 1 - \sqrt{\frac{f_1(\mathbf{x})}{g(\mathbf{x})}}</code>
</p>

<p>and <code class="reqn">\mathbf{x}_i \in [0,1], i = 1, \ldots, m</code>.
This function has many Pareto-optimal fronts and is thus suited to test the
algorithms ability to tackle multimodal problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeZDT4Function(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeZDT4Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>E. Zitzler, K. Deb, and L. Thiele. Comparison of Multiobjective
Evolutionary Algorithms: Empirical Results. Evolutionary Computation, 8(2):173-195, 2000
</p>

<hr>
<h2 id='makeZDT6Function'>ZDT6 Function</h2><span id='topic+makeZDT6Function'></span>

<h3>Description</h3>

<p>Builds and returns the two-objective ZDT6 test problem. For <code class="reqn">m</code> objective it
is defined as follows
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = \left(f_1(\mathbf{x}), f_2(\mathbf{x})\right)</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">f_1(\mathbf{x}) = 1 - \exp(-4\mathbf{x}_1)\sin^6(6\pi\mathbf{x}_1), f_2(\mathbf{x}) = g(\mathbf{x}) h(f_1(\mathbf{x}_1), g(\mathbf{x}))</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">g(\mathbf{x}) = 1 + 9 \left(\frac{\sum_{i = 2}^{m}\mathbf{x}_i}{m - 1}\right)^{0.25}, h(f_1, g) = 1 - \left(\frac{f_1(\mathbf{x})}{g(\mathbf{x})}\right)^2</code>
</p>

<p>and <code class="reqn">\mathbf{x}_i \in [0,1], i = 1, \ldots, m</code>.
This function introduced two difficulities (see reference):
1. the density of solutions decreases with the closeness to the Pareto-optimal front and
2. the Pareto-optimal solutions are nonuniformly distributed along the front.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeZDT6Function(dimensions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeZDT6Function_+3A_dimensions">dimensions</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of decision variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>smoof_multi_objective_function</code>]
</p>


<h3>References</h3>

<p>E. Zitzler, K. Deb, and L. Thiele. Comparison of Multiobjective
Evolutionary Algorithms: Empirical Results. Evolutionary Computation, 8(2):173-195, 2000
</p>

<hr>
<h2 id='makeZettlFunction'>Zettl Function</h2><span id='topic+makeZettlFunction'></span>

<h3>Description</h3>

<p>The unimodal Zettl Function is based on the defintion
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{x}) = (\mathbf{x}_1^2 + \mathbf{x}_2^2 - 2\mathbf{x}_1)^2 + 0.25 \mathbf{x}_1</code>
</p>

<p>with box-constraints <code class="reqn">\mathbf{x}_i \in [-5, 10], i = 1, 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeZettlFunction()
</code></pre>


<h3>Value</h3>

<p>[<code>smoof_single_objective_function</code>]
</p>


<h3>References</h3>

<p>H. P. Schwefel, Evolution and Optimum Seeking, John Wiley Sons, 1995.
</p>

<hr>
<h2 id='mnof'>Helper function to create numeric multi-objective optimization test function.</h2><span id='topic+mnof'></span>

<h3>Description</h3>

<p>This is a simplifying wrapper around <code><a href="#topic+makeMultiObjectiveFunction">makeMultiObjectiveFunction</a></code>.
It can be used if the function to generate is purely numeric to save some lines
of code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mnof(
  name = NULL,
  id = NULL,
  par.len = NULL,
  par.id = "x",
  par.lower = NULL,
  par.upper = NULL,
  n.objectives,
  description = NULL,
  fn,
  vectorized = FALSE,
  noisy = FALSE,
  fn.mean = NULL,
  minimize = rep(TRUE, n.objectives),
  constraint.fn = NULL,
  ref.point = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mnof_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Function name. Used for the title of plots for example.</p>
</td></tr>
<tr><td><code id="mnof_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code> | <code>NULL</code>]<br />
Optional short function identifier. If provided, this should be a short
name without whitespaces and now special characters beside the underscore.
Default is <code>NULL</code>, which means no ID at all.</p>
</td></tr>
<tr><td><code id="mnof_+3A_par.len">par.len</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Length of parameter vector.</p>
</td></tr>
<tr><td><code id="mnof_+3A_par.id">par.id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Optional name of parameter vector.
Default is &ldquo;x&rdquo;.</p>
</td></tr>
<tr><td><code id="mnof_+3A_par.lower">par.lower</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of lower bounds. A single value of length 1 is automatically replicated
to <code>n.pars</code>.
Default is -Inf.</p>
</td></tr>
<tr><td><code id="mnof_+3A_par.upper">par.upper</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of upper bounds. A singe value of length 1 is automatically replicated
to <code>n.pars</code>.
Default is Inf.</p>
</td></tr>
<tr><td><code id="mnof_+3A_n.objectives">n.objectives</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of objectives of the multi-objective function.</p>
</td></tr>
<tr><td><code id="mnof_+3A_description">description</code></td>
<td>
<p>[<code>character(1)</code> | <code>NULL</code>]<br />
Optional function description.</p>
</td></tr>
<tr><td><code id="mnof_+3A_fn">fn</code></td>
<td>
<p>[<code>function</code>]<br />
Objective function.</p>
</td></tr>
<tr><td><code id="mnof_+3A_vectorized">vectorized</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Can the objective function handle &ldquo;vector&rdquo; input, i.~e., does it
accept matrix of parameters? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mnof_+3A_noisy">noisy</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Is the function noisy? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mnof_+3A_fn.mean">fn.mean</code></td>
<td>
<p>[<code>function</code>]<br />
Optional true mean function in case of a noisy objective function. This functions should
have the same mean as <code>fn</code>.</p>
</td></tr>
<tr><td><code id="mnof_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical</code>]<br />
Logical vector of length <code>n.objectives</code> indicating if the corresponding
objectives shall be minimized or maximized.
Default is the vector with all components set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mnof_+3A_constraint.fn">constraint.fn</code></td>
<td>
<p>[<code>function | NULL</code>]<br />
Function which returns a logical vector indicating whether certain conditions
are met or not. Default is <code>NULL</code>, which means, that there are no constraints
beside possible box constraints defined via the <code>par.set</code> argument.</p>
</td></tr>
<tr><td><code id="mnof_+3A_ref.point">ref.point</code></td>
<td>
<p>[<code>numeric</code>]<br />
Optional reference point in the objective space, e.g., for hypervolume computation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># first we generate the 10d sphere function the long way
fn = makeMultiObjectiveFunction(
  name = "Testfun",
  fn = function(x) c(sum(x^2), exp(sum(x^2))),
  par.set = makeNumericParamSet(
    len = 10L, id = "a",
    lower = rep(-1.5, 10L), upper = rep(1.5, 10L)
  ),
  n.objectives = 2L
)

# ... and now the short way
fn = mnof(
 name = "Testfun",
 fn = function(x) c(sum(x^2), exp(sum(x^2))),
 par.len = 10L, par.id = "a", par.lower = -1.5, par.upper = 1.5,
 n.objectives = 2L
)
</code></pre>

<hr>
<h2 id='plot.smoof_function'>Generate ggplot2 object.</h2><span id='topic+plot.smoof_function'></span>

<h3>Description</h3>

<p>Generate ggplot2 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smoof_function'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smoof_function_+3A_x">x</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Function.</p>
</td></tr>
<tr><td><code id="plot.smoof_function_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further parameters passed to the corresponding plot functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='plot1DNumeric'>Plot an one-dimensional function.</h2><span id='topic+plot1DNumeric'></span>

<h3>Description</h3>

<p>Plot an one-dimensional function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot1DNumeric(
  x,
  show.optimum = FALSE,
  main = getName(x),
  n.samples = 500L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot1DNumeric_+3A_x">x</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Function.</p>
</td></tr>
<tr><td><code id="plot1DNumeric_+3A_show.optimum">show.optimum</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If the function has a known global optimum, should its location be
plotted by a point or multiple points in case of multiple global optima?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot1DNumeric_+3A_main">main</code></td>
<td>
<p>[<code>character(1L)</code>]<br />
Plot title.
Default is the name of the smoof function.</p>
</td></tr>
<tr><td><code id="plot1DNumeric_+3A_n.samples">n.samples</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of locations to be sampled. Default is 500.</p>
</td></tr>
<tr><td><code id="plot1DNumeric_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further paramerters passed to plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='plot2DNumeric'>Plot a two-dimensional numeric function.</h2><span id='topic+plot2DNumeric'></span>

<h3>Description</h3>

<p>Either a contour-plot or a level-plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot2DNumeric(
  x,
  show.optimum = FALSE,
  main = getName(x),
  render.levels = FALSE,
  render.contours = TRUE,
  n.samples = 100L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot2DNumeric_+3A_x">x</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Function.</p>
</td></tr>
<tr><td><code id="plot2DNumeric_+3A_show.optimum">show.optimum</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If the function has a known global optimum, should its location be
plotted by a point or multiple points in case of multiple global optima?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot2DNumeric_+3A_main">main</code></td>
<td>
<p>[<code>character(1L)</code>]<br />
Plot title.
Default is the name of the smoof function.</p>
</td></tr>
<tr><td><code id="plot2DNumeric_+3A_render.levels">render.levels</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Show a level-plot? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot2DNumeric_+3A_render.contours">render.contours</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Render contours? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot2DNumeric_+3A_n.samples">n.samples</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Number of locations per dimension to be sampled. Default is 100.</p>
</td></tr>
<tr><td><code id="plot2DNumeric_+3A_...">...</code></td>
<td>
<p>[any]<br />
Further paramerters passed to <code>image</code> respectively <code>contour</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='plot3D'>Surface plot of two-dimensional test function.</h2><span id='topic+plot3D'></span>

<h3>Description</h3>

<p>Surface plot of two-dimensional test function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3D(x, length.out = 100L, package = "plot3D", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3D_+3A_x">x</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Two-dimensional snoof function.</p>
</td></tr>
<tr><td><code id="plot3D_+3A_length.out">length.out</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Determines the &ldquo;smoothness&rdquo; of the grid. The higher the value, the
smoother the function landscape looks like. However, you should avoid setting
this parameter to high, since with the <code>contour</code> option set to <code>TRUE</code>
the drawing can take quite a lot of time. Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="plot3D_+3A_package">package</code></td>
<td>
<p>[<code>character(1)</code>]<br />
String describing the package to use for 3D visualization.
At the moment &ldquo;plot3D&rdquo; (package <span class="pkg">plot3D</span>) and
&ldquo;plotly&rdquo; (package <span class="pkg">plotly</span>) are supported.
The latter opens a highly interactive plot in a web brower
and is thus suited well to explore a function by hand.
Default is &ldquo;plot3D&rdquo;.</p>
</td></tr>
<tr><td><code id="plot3D_+3A_...">...</code></td>
<td>
<p>[any]<br />
Furhter parameters passed to method used for visualization
(which is determined by the <code>package</code> argument.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(plot3D)
fn = makeRastriginFunction(dimensions = 2L)
## Not run: 
# use the plot3D::persp3D method (default behaviour)
plot3D(fn)
plot3D(fn, contour = TRUE)
plot3D(fn, image = TRUE, phi = 30)

# use plotly::plot_ly for interactive plot
plot3D(fn, package = "plotly")

## End(Not run)
</code></pre>

<hr>
<h2 id='resetEvaluationCounter'>Reset evaluation counter.</h2><span id='topic+resetEvaluationCounter'></span>

<h3>Description</h3>

<p>Reset evaluation counter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetEvaluationCounter(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resetEvaluationCounter_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_counting_function</code>]<br />
Wrapped <code>smoof_function</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='shouldBeMinimized'>Check if function should be minimized.</h2><span id='topic+shouldBeMinimized'></span>

<h3>Description</h3>

<p>Functions can have an associated global optimum. In this case
one needs to know whether the optimum is a minimum or a maximum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shouldBeMinimized(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shouldBeMinimized_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical</code>] Each component indicates whether the corresponding
objective should be minimized.
</p>

<hr>
<h2 id='smoof_function'>Smoof function</h2><span id='topic+smoof_function'></span><span id='topic+smoof_single_objective_function'></span><span id='topic+smoof_multi_objective_function'></span>

<h3>Description</h3>

<p>Regular R function with additional classes <code>smoof_function</code> and one of <code>smoof_single_objective_function</code>
or codesmoof_multi_objective_function. Both single- and multi-objective functions share the following attributes.
</p>

<dl>
<dt>name [<code>character(1)</code>]</dt><dd><p>Optional function name.</p>
</dd>
<dt>id [<code>character(1)</code>]</dt><dd><p>Short identifier.</p>
</dd>
<dt>description [<code>character(1)</code>]</dt><dd><p>Optional function description.</p>
</dd>
<dt>has.simple.signature</dt><dd><p><code>TRUE</code> if the target function expects a vector as input and <code>FALSE</code>
if it expects a named list of values.</p>
</dd>
<dt>par.set [<code><a href="ParamHelpers.html#topic+ParamSet">ParamSet</a></code>]</dt><dd><p>Parameter set describing different ascpects of the target function parameters, i. e.,
names, lower and/or upper bounds, types and so on.</p>
</dd>
<dt>n.objectives [<code>integer(1)</code>]</dt><dd><p>Number of objectives.</p>
</dd>
<dt>noisy [<code>logical(1)</code>]</dt><dd><p>Boolean indicating whether the function is noisy or not.</p>
</dd>
<dt>fn.mean [<code>function</code>]</dt><dd><p>Optional true mean function in case of a noisy objective function.</p>
</dd>
<dt>minimize [<code>logical(1)</code>]</dt><dd><p>Logical vector of length <code>n.objectives</code> indicating which objectives shall
be minimzed/maximized.</p>
</dd>
<dt>vectorized [<code>logical(1)</code>]</dt><dd><p>Can the handle &ldquo;vector&rdquo; input, i. e., does it accept matrix of
parameters?</p>
</dd>
<dt>constraint.fn [<code>function</code>]</dt><dd><p>Optional function which returns a logical vector with each component indicating
whether the corresponding constraint is violated.</p>
</dd>
</dl>

<p>Futhermore, single-objective function may contain additional parameters with information on
local and/or global optima as well as characterizing tags.
</p>

<dl>
<dt>tags [<code>character</code>]</dt><dd><p>Optional character vector of tags or keywords.</p>
</dd>
<dt>global.opt.params [<code>data.frame</code>]</dt><dd><p>Data frame of parameter values of global optima.</p>
</dd>
<dt>global.opt.value [<code>numeric(1)</code>]</dt><dd><p>Function value of global optima.</p>
</dd>
<dt>local.opt.params [<code>data.frame</code>]</dt><dd><p>Data frame of parameter values of local optima.</p>
</dd>
<dt>global.opt.value [<code>numeric</code>]</dt><dd><p>Function values of local optima.</p>
</dd>
</dl>

<p>Currenlty tagging is not possible for multi-objective functions. The only additional attribute may be
a reference point:
</p>

<dl>
<dt>ref.point [<code>numeric</code>]</dt><dd><p>Optional reference point of length <code>n.objectives</code></p>
</dd></dl>
<p>.

</p>

<hr>
<h2 id='snof'>Helper function to create numeric single-objective optimization test function.</h2><span id='topic+snof'></span>

<h3>Description</h3>

<p>This is a simplifying wrapper around <code><a href="#topic+makeSingleObjectiveFunction">makeSingleObjectiveFunction</a></code>.
It can be used if the function to generte is purely numeric to save some lines
of code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snof(
  name = NULL,
  id = NULL,
  par.len = NULL,
  par.id = "x",
  par.lower = NULL,
  par.upper = NULL,
  description = NULL,
  fn,
  vectorized = FALSE,
  noisy = FALSE,
  fn.mean = NULL,
  minimize = TRUE,
  constraint.fn = NULL,
  tags = character(0),
  global.opt.params = NULL,
  global.opt.value = NULL,
  local.opt.params = NULL,
  local.opt.values = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snof_+3A_name">name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Function name. Used for the title of plots for example.</p>
</td></tr>
<tr><td><code id="snof_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code> | <code>NULL</code>]<br />
Optional short function identifier. If provided, this should be a short
name without whitespaces and now special characters beside the underscore.
Default is <code>NULL</code>, which means no ID at all.</p>
</td></tr>
<tr><td><code id="snof_+3A_par.len">par.len</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Length of parameter vector.</p>
</td></tr>
<tr><td><code id="snof_+3A_par.id">par.id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Optional name of parameter vector.
Default is &ldquo;x&rdquo;.</p>
</td></tr>
<tr><td><code id="snof_+3A_par.lower">par.lower</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of lower bounds. A single value of length 1 is automatically replicated
to <code>n.pars</code>.
Default is -Inf.</p>
</td></tr>
<tr><td><code id="snof_+3A_par.upper">par.upper</code></td>
<td>
<p>[<code>numeric</code>]<br />
Vector of upper bounds. A singe value of length 1 is automatically replicated
to <code>n.pars</code>.
Default is Inf.</p>
</td></tr>
<tr><td><code id="snof_+3A_description">description</code></td>
<td>
<p>[<code>character(1)</code> | <code>NULL</code>]<br />
Optional function description.</p>
</td></tr>
<tr><td><code id="snof_+3A_fn">fn</code></td>
<td>
<p>[<code>function</code>]<br />
Objective function.</p>
</td></tr>
<tr><td><code id="snof_+3A_vectorized">vectorized</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Can the objective function handle &ldquo;vector&rdquo; input, i.~e., does it
accept matrix of parameters? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="snof_+3A_noisy">noisy</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Is the function noisy? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="snof_+3A_fn.mean">fn.mean</code></td>
<td>
<p>[<code>function</code>]<br />
Optional true mean function in case of a noisy objective function. This functions should
have the same mean as <code>fn</code>.</p>
</td></tr>
<tr><td><code id="snof_+3A_minimize">minimize</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Set this to <code>TRUE</code> if the function should be minimized and to
<code>FALSE</code> otherwise.
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="snof_+3A_constraint.fn">constraint.fn</code></td>
<td>
<p>[<code>function | NULL</code>]<br />
Function which returns a logical vector indicating whether certain conditions
are met or not. Default is <code>NULL</code>, which means, that there are no constraints
beside possible box constraints defined via the <code>par.set</code> argument.</p>
</td></tr>
<tr><td><code id="snof_+3A_tags">tags</code></td>
<td>
<p>[<code>character</code>]<br />
Optional character vector of tags or keywords which characterize the function,
e.~g. &ldquo;unimodal&rdquo;, &ldquo;separable&rdquo;. See <code><a href="#topic+getAvailableTags">getAvailableTags</a></code> for
a character vector of allowed tags.</p>
</td></tr>
<tr><td><code id="snof_+3A_global.opt.params">global.opt.params</code></td>
<td>
<p>[<code>list</code> | <code>numeric</code> | <code>data.frame</code> | <code>matrix</code> | <code>NULL</code>]<br />
Default is <code>NULL</code> which means unknown. Passing a <code>numeric</code> vector will
be the most frequent case (numeric only functions). In this case there is only a
single global optimum. If there are multiple global optima, passing a numeric
<code>matrix</code> is the best choice. Passing a <code>list</code> or a <code>data.frame</code>
is necessary if your function is mixed, e.g., it expects both numeric and discrete
parameters. Internally, however, each representation is casted to a <code>data.frame</code>
for reasons of consistency.</p>
</td></tr>
<tr><td><code id="snof_+3A_global.opt.value">global.opt.value</code></td>
<td>
<p>[<code>numeric(1)</code> | <code>NULL</code>]<br />
Global optimum value if known. Default is <code>NULL</code>, which means unknown. If
only the <code>global.opt.params</code> are passed, the value is computed automatically.</p>
</td></tr>
<tr><td><code id="snof_+3A_local.opt.params">local.opt.params</code></td>
<td>
<p>[<code>list</code> | <code>numeric</code> | <code>data.frame</code> | <code>matrix</code> | <code>NULL</code>]<br />
Default is <code>NULL</code>, which means the function has no local optima or they are
unknown. For details see the description of <code>global.opt.params</code>.</p>
</td></tr>
<tr><td><code id="snof_+3A_local.opt.values">local.opt.values</code></td>
<td>
<p>[<code>numeric</code> | <code>NULL</code>]<br />
Value(s) of local optima. Default is <code>NULL</code>, which means unknown. If
only the <code>local.opt.params</code> are passed, the values are computed automatically.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># first we generate the 10d sphere function the long way
fn = makeSingleObjectiveFunction(
  name = "Testfun",
  fn = function(x) sum(x^2),
  par.set = makeNumericParamSet(
    len = 10L, id = "a",
    lower = rep(-1.5, 10L), upper = rep(1.5, 10L)
  )
)

# ... and now the short way
fn = snof(
 name = "Testfun",
 fn = function(x) sum(x^2),
 par.len = 10L, par.id = "a", par.lower = -1.5, par.upper = 1.5
)
</code></pre>

<hr>
<h2 id='violatesConstraints'>Checks whether constraints are violated.</h2><span id='topic+violatesConstraints'></span>

<h3>Description</h3>

<p>Checks whether constraints are violated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>violatesConstraints(fn, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="violatesConstraints_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_function</code>]<br />
Objective function.</p>
</td></tr>
<tr><td><code id="violatesConstraints_+3A_values">values</code></td>
<td>
<p>[<code>numeric</code>]<br />
List of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>logical(1)</code>]
</p>

<hr>
<h2 id='visualizeParetoOptimalFront'>Pareto-optimal front visualization.</h2><span id='topic+visualizeParetoOptimalFront'></span>

<h3>Description</h3>

<p>Quickly visualize the Pareto-optimal front of a bi-criteria objective
function by calling the EMOA <code><a href="mco.html#topic+nsga2">nsga2</a></code> and extracting the
approximated Pareto-optimal front.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualizeParetoOptimalFront(fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualizeParetoOptimalFront_+3A_fn">fn</code></td>
<td>
<p>[<code>smoof_multi_objective_function</code>]<br />
Multi-objective smoof function.</p>
</td></tr>
<tr><td><code id="visualizeParetoOptimalFront_+3A_...">...</code></td>
<td>
<p>[any]<br />
Arguments passed to <code><a href="mco.html#topic+nsga2">nsga2</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here we visualize the Pareto-optimal front of the bi-objective ZDT3 function
fn = makeZDT3Function(dimensions = 3L)
vis = visualizeParetoOptimalFront(fn)

# Alternatively we can pass some more algorithm parameters to the NSGA2 algorithm
vis = visualizeParetoOptimalFront(fn, popsize = 1000L)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
