<!DOCTYPE html><html><head><title>Help for package tidybayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidybayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_draws'><p>Add draws to a data frame in tidy format</p></a></li>
<li><a href='#add_epred_draws'><p>Add draws from the posterior fit, predictions, or residuals of a model to a data frame</p></a></li>
<li><a href='#add_epred_rvars'><p>Add <code>rvar</code>s for the linear predictor, posterior expectation, posterior predictive, or residuals of a model to a data frame</p></a></li>
<li><a href='#combine_chains'><p>Combine the chain and iteration columns of tidy data frames of draws</p></a></li>
<li><a href='#compare_levels'><p>Compare the value of draws of some variable from a Bayesian model for</p>
different levels of a factor</a></li>
<li><a href='#compose_data'><p>Compose data for input into a Bayesian model</p></a></li>
<li><a href='#data_list'><p>Data lists for input into Bayesian models</p></a></li>
<li><a href='#density_bins'><p>Density bins and histogram bins as data frames</p></a></li>
<li><a href='#emmeans_comparison'><p>Use emmeans contrast methods with compare_levels</p></a></li>
<li><a href='#gather_draws'><p>Extract draws of variables in a Bayesian model fit into a tidy data format</p></a></li>
<li><a href='#gather_emmeans_draws'><p>Extract a tidy data frame of draws of posterior distributions of &quot;estimated marginal means&quot; (emmeans/lsmeans) from</p>
a Bayesian model fit.</a></li>
<li><a href='#gather_pairs'><p>Gather pairwise combinations of values from key/value columns in a long-format data frame</p></a></li>
<li><a href='#gather_rvars'><p>Extract draws from a Bayesian model into tidy data frames of random variables</p></a></li>
<li><a href='#gather_variables'><p>Gather variables from a tidy data frame of draws from variables into a single column</p></a></li>
<li><a href='#get_variables'><p>Get the names of the variables in a fitted Bayesian model</p></a></li>
<li><a href='#n_prefix'><p>Prefix function generator for composing dimension index columns</p></a></li>
<li><a href='#nest_rvars'><p>Nest and unnest <code>rvar</code> columns in data frames</p></a></li>
<li><a href='#predict_curve'><p>Deprecated: Prediction curves for arbitrary functions of posteriors</p></a></li>
<li><a href='#recover_types'><p>Decorate a model fit or sample with data types recovered from the input data</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#sample_draws'><p>Sample draws from a tidy-format data frame of draws</p></a></li>
<li><a href='#summarise_draws.grouped_df'><p>Summaries of draws in <code>grouped_df</code> objects</p></a></li>
<li><a href='#tidy_draws'><p>Get a sample of posterior draws from a model as a tibble</p></a></li>
<li><a href='#tidybayes-deprecated'><p>Deprecated functions, arguments, and column names in tidybayes</p></a></li>
<li><a href='#tidybayes-models'><p>Models supported by tidybayes</p></a></li>
<li><a href='#tidybayes-package'><p>Tidy Data and 'Geoms' for Bayesian Models</p></a></li>
<li><a href='#ungather_draws'><p>Turn tidy data frames of variables from a Bayesian model back into untidy data</p></a></li>
<li><a href='#x_at_y'><p>Generate lookup vectors for composing nested indices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tidy Data and 'Geoms' for Bayesian Models</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Kay &lt;mjskay@northwestern.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Compose data for and extract, manipulate, and visualize posterior draws from Bayesian models
    ('JAGS', 'Stan', 'rstanarm', 'brms', 'MCMCglmm', 'coda', ...) in a tidy data format. Functions are provided
    to help extract tidy data frames of draws from Bayesian models and that generate point
    summaries and intervals in a tidy format. In addition, 'ggplot2' 'geoms' and 'stats' are provided for
    common visualization primitives like points with multiple uncertainty intervals, eye plots (intervals plus
    densities), and fit curves with multiple, arbitrary uncertainty bands.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, ggdist (&ge; 3.0.0), dplyr (&ge; 1.1.0), tidyr (&ge;
1.0.0), ggplot2 (&ge; 3.3.5), coda, rlang (&ge; 0.3.0),
arrayhelpers, tidyselect, tibble, magrittr, posterior (&ge;
1.0.1), withr, cli, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, purrr (&ge; 0.2.3), forcats, vdiffr (&ge;
1.0.0), svglite, rstan (&ge; 2.17.0), rstantools (&ge; 2.1.0),
runjags, rjags, jagsUI, rstanarm (&ge; 2.19.2), emmeans, broom
(&ge; 0.4.3), dotwhisker, MCMCglmm, bayesplot, modelr, brms (&ge;
2.16.0), cowplot, covr, rmarkdown, ggrepel, bindrcpp,
RColorBrewer, gganimate, gifski, png, pkgdown, distributional,
transformr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mjskay/tidybayes/issues/new">https://github.com/mjskay/tidybayes/issues/new</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mjskay.github.io/tidybayes/">https://mjskay.github.io/tidybayes/</a>,
<a href="https://github.com/mjskay/tidybayes/">https://github.com/mjskay/tidybayes/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>"ggdist-curve_interval.R" "ggdist-cut_cdf_qi.R"
"ggdist-geom_slabinterval.R" "ggdist-geom_dotsinterval.R"
"ggdist-geom_interval.R" "ggdist-geom_lineribbon.R"
"ggdist-geom_pointinterval.R" "ggdist-lkjcorr_marginal.R"
"ggdist-parse_dist.R" "ggdist-scales.R"
"ggdist-stat_slabinterval.R" "ggdist-stat_dist_slabinterval.R"
"ggdist-stat_sample_slabinterval.R"
"ggdist-stat_dotsinterval.R" "ggdist-stat_pointinterval.R"
"ggdist-stat_interval.R" "ggdist-stat_lineribbon.R"
"ggdist-student_t.R" "ggdist-theme_ggdist.R"
"ggdist-tidy_format_translators.R" "tidybayes-package.R"
"add_draws.R" "combine_chains.R" "compare_levels.R"
"compose_data.R" "density_bins.R" "emmeans_comparison.R"
"epred_draws.R" "epred_rvars.R" "flip_aes.R" "gather_draws.R"
"gather_emmeans_draws.R" "gather_pairs.R" "gather_rvars.R"
"gather_variables.R" "get_variables.R" "global_variables.R"
"linpred_draws.R" "linpred_rvars.R" "nest_rvars.R" "onAttach.R"
"point_interval.R" "predict_curve.R" "predicted_draws.R"
"predicted_rvars.R" "recover_types.R" "residual_draws.R"
"sample_draws.R" "spread_draws.R" "spread_rvars.R"
"summarise_draws.R" "testthat.R" "tidy_draws.R"
"tidybayes-models.R" "ungather_draws.R" "unspread_draws.R"
"util.R" "x_at_y.R" "deprecated.R"</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-12 21:10:49 UTC; mjskay</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Kay [aut, cre],
  Timothy Mastny [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-12 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_draws'>Add draws to a data frame in tidy format</h2><span id='topic+add_draws'></span>

<h3>Description</h3>

<p>Add draws from a matrix of draws (usually draws from a predictive distribution) to a data frame in tidy format. This is
a generic version of <code><a href="#topic+add_predicted_draws">add_predicted_draws()</a></code> that can be used with model types
that have their own prediction functions that are not yet supported by tidybayes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_draws(data, draws, value = ".value")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_draws_+3A_data">data</code></td>
<td>
<p>Data frame to add draws to, with M rows.</p>
</td></tr>
<tr><td><code id="add_draws_+3A_draws">draws</code></td>
<td>
<p>N by M matrix of draws, with M columns corresponding to the M rows in <code>data</code>, and N draws in each column.</p>
</td></tr>
<tr><td><code id="add_draws_+3A_value">value</code></td>
<td>
<p>The name of the output column; default <code>".value"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a data frame with M rows and an N by M matrix of N draws, adds a <code>.row</code>, <code>.draw</code>, and <code>.value</code>
column (or another name if <code>value</code> is set) to <code>data</code>, and expands <code>data</code> into a long-format dataframe of draws.
</p>
<p><code>add_epred_draws(df, m)</code> is roughly equivalent to <code>add_draws(df, posterior_epred(m, newdata = df))</code>, except
that <code>add_epred_draws</code> standardizes argument names and values across packages and has additional features for some
model types (like handling ordinal responses and distributional parameters in brms).
</p>
<p><code>add_predicted_draws(df, m)</code> is roughly equivalent to <code>add_draws(df, posterior_predict(m, newdata = df))</code>, except
that <code>add_predicted_draws</code> standardizes argument names and values across packages.
</p>


<h3>Value</h3>

<p>A data frame (actually, a <a href="tibble.html#topic+tibble">tibble</a>) with a <code>.row</code> column (a
factor grouping rows from the input <code>data</code>), a <code>.draw</code> column (a unique index corresponding to each draw
from the distribution), and a column with its name specified by the <code>value</code> argument (default is <code>.value</code>)
containing the values of draws from <code>draws</code>. The data frame is grouped by all rows in <code>data</code> plus the <code>.row</code> column.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_predicted_draws">add_predicted_draws()</a></code>, <code><a href="#topic+add_draws">add_draws()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(ggplot2)
library(dplyr)
library(brms)
library(modelr)

theme_set(theme_light())

m_mpg = brm(mpg ~ hp * cyl, data = mtcars,
  # 1 chain / few iterations just so example runs quickly
  # do not use in practice
  chains = 1, iter = 500)

# plot posterior predictive intervals
mtcars %&gt;%
  group_by(cyl) %&gt;%
  data_grid(hp = seq_range(hp, n = 101)) %&gt;%
  # the line below is roughly equivalent to add_epred_draws(m_mpg), except
  # that it does not standardize arguments across model types.
  add_draws(posterior_epred(m_mpg, newdata = .)) %&gt;%
  ggplot(aes(x = hp, y = mpg, color = ordered(cyl))) +
  stat_lineribbon(aes(y = .value), alpha = 0.25) +
  geom_point(data = mtcars) +
  scale_fill_brewer(palette = "Greys")


## End(Not run)
</code></pre>

<hr>
<h2 id='add_epred_draws'>Add draws from the posterior fit, predictions, or residuals of a model to a data frame</h2><span id='topic+add_epred_draws'></span><span id='topic+epred_draws'></span><span id='topic+epred_draws.default'></span><span id='topic+epred_draws.stanreg'></span><span id='topic+epred_draws.brmsfit'></span><span id='topic+add_linpred_draws'></span><span id='topic+linpred_draws'></span><span id='topic+linpred_draws.default'></span><span id='topic+linpred_draws.stanreg'></span><span id='topic+linpred_draws.brmsfit'></span><span id='topic+add_predicted_draws'></span><span id='topic+predicted_draws'></span><span id='topic+predicted_draws.default'></span><span id='topic+predicted_draws.stanreg'></span><span id='topic+predicted_draws.brmsfit'></span><span id='topic+add_residual_draws'></span><span id='topic+residual_draws'></span><span id='topic+residual_draws.default'></span><span id='topic+residual_draws.brmsfit'></span>

<h3>Description</h3>

<p>Given a data frame and a model, adds draws from the linear/link-level predictor,
the expectation of the posterior predictive, the posterior predictive, or the residuals of a model to
the data frame in a long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_epred_draws(
  newdata,
  object,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL
)

epred_draws(
  object,
  newdata,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL
)

## Default S3 method:
epred_draws(
  object,
  newdata,
  ...,
  value = ".epred",
  seed = NULL,
  category = NULL
)

## S3 method for class 'stanreg'
epred_draws(
  object,
  newdata,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL
)

## S3 method for class 'brmsfit'
epred_draws(
  object,
  newdata,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL
)

add_linpred_draws(
  newdata,
  object,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL,
  n
)

linpred_draws(
  object,
  newdata,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL,
  n,
  scale
)

## Default S3 method:
linpred_draws(
  object,
  newdata,
  ...,
  value = ".linpred",
  seed = NULL,
  category = NULL
)

## S3 method for class 'stanreg'
linpred_draws(
  object,
  newdata,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL
)

## S3 method for class 'brmsfit'
linpred_draws(
  object,
  newdata,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL
)

add_predicted_draws(
  newdata,
  object,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  n
)

predicted_draws(
  object,
  newdata,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  n,
  prediction
)

## Default S3 method:
predicted_draws(
  object,
  newdata,
  ...,
  value = ".prediction",
  seed = NULL,
  category = ".category"
)

## S3 method for class 'stanreg'
predicted_draws(
  object,
  newdata,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category"
)

## S3 method for class 'brmsfit'
predicted_draws(
  object,
  newdata,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category"
)

add_residual_draws(
  newdata,
  object,
  ...,
  value = ".residual",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  n
)

residual_draws(
  object,
  newdata,
  ...,
  value = ".residual",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  n,
  residual
)

## Default S3 method:
residual_draws(object, newdata, ...)

## S3 method for class 'brmsfit'
residual_draws(
  object,
  newdata,
  ...,
  value = ".residual",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_epred_draws_+3A_newdata">newdata</code></td>
<td>
<p>Data frame to generate predictions from.</p>
</td></tr>
<tr><td><code id="add_epred_draws_+3A_object">object</code></td>
<td>
<p>A supported Bayesian model fit that can provide fits and predictions. Supported models
are listed in the second section of <a href="#topic+tidybayes-models">tidybayes-models</a>: <em>Models Supporting Prediction</em>. While other
functions in this package (like <code><a href="#topic+spread_draws">spread_draws()</a></code>) support a wider range of models, to work with
<code>add_epred_draws()</code>, <code>add_predicted_draws()</code>, etc. a model must provide an interface for generating
predictions, thus more generic Bayesian modeling interfaces like <code>runjags</code> and <code>rstan</code> are not directly
supported for these functions (only wrappers around those languages that provide predictions, like <code>rstanarm</code>
and <code>brm</code>, are supported here).</p>
</td></tr>
<tr><td><code id="add_epred_draws_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying prediction method for the type of
model given.</p>
</td></tr>
<tr><td><code id="add_epred_draws_+3A_value">value</code></td>
<td>
<p>The name of the output column:
</p>

<ul>
<li><p> for <code style="white-space: pre;">&#8288;[add_]epred_draws()&#8288;</code>, defaults to <code>".epred"</code>.
</p>
</li>
<li><p> for <code style="white-space: pre;">&#8288;[add_]predicted_draws()&#8288;</code>, defaults to <code>".prediction"</code>.
</p>
</li>
<li><p> for <code style="white-space: pre;">&#8288;[add_]linpred_draws()&#8288;</code>, defaults to <code>".linpred"</code>.
</p>
</li>
<li><p> for <code style="white-space: pre;">&#8288;[add_]residual_draws()&#8288;</code>, defaults to <code>".residual"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="add_epred_draws_+3A_ndraws">ndraws</code></td>
<td>
<p>The number of draws to return, or <code>NULL</code> to return all draws.</p>
</td></tr>
<tr><td><code id="add_epred_draws_+3A_seed">seed</code></td>
<td>
<p>A seed to use when subsampling draws (i.e. when <code>ndraws</code> is not <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="add_epred_draws_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in the prediction.
If <code>NULL</code> (default), include all group-level effects; if <code>NA</code>, include no group-level effects.
Some model types (such as <a href="brms.html#topic+brmsfit-class">brms::brmsfit</a> and <a href="rstanarm.html#topic+stanreg-objects">rstanarm::stanreg-objects</a>) allow
marginalizing over grouping factors by specifying new levels of a factor in <code>newdata</code>. In the case of
<code><a href="brms.html#topic+brm">brms::brm()</a></code>, you must also pass <code>allow_new_levels = TRUE</code> here to include new levels (see
<code><a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict()</a></code>).</p>
</td></tr>
<tr><td><code id="add_epred_draws_+3A_category">category</code></td>
<td>
<p>For <em>some</em> ordinal, multinomial, and multivariate models (notably, <code><a href="brms.html#topic+brm">brms::brm()</a></code> models but
<em>not</em> <code><a href="rstanarm.html#topic+stan_polr">rstanarm::stan_polr()</a></code> models), multiple sets of rows will be returned per input row for
<code>epred_draws()</code> or <code>predicted_draws()</code>, depending on the model type. For ordinal/multinomial models,
these rows correspond to different categories of the response variable. For multivariate models, these correspond to
different response variables. The <code>category</code> argument specifies the name of the column
to put the category names (or variable names) into in the resulting data frame. The default name of this column
(<code>".category"</code>) reflects the fact that this functionality was originally used only for ordinal models and
has been re-used for multivariate models. The fact that multiple rows per response are returned only for some
model types reflects the fact that tidybayes takes the approach of tidying whatever output is given to us, and
the output from different modeling functions differs on this point.
See <code>vignette("tidy-brms")</code> and <code>vignette("tidy-rstanarm")</code> for examples of dealing with output
from ordinal models using both approaches.</p>
</td></tr>
<tr><td><code id="add_epred_draws_+3A_dpar">dpar</code></td>
<td>
<p>For <code>add_epred_draws()</code> and <code>add_linpred_draws()</code>: Should distributional regression
parameters be included in the output? Valid only for models that support distributional regression parameters,
such as submodels for variance parameters (as in <code>brms::brm()</code>). If <code>TRUE</code>, distributional regression
parameters are included in the output as additional columns named after each parameter
(alternative names can be provided using a list or named vector, e.g. <code>c(sigma.hat = "sigma")</code>
would output the <code>"sigma"</code> parameter from a model as a column named <code>"sigma.hat"</code>).
If <code>NULL</code> or <code>FALSE</code> (the default), distributional regression parameters are not included.</p>
</td></tr>
<tr><td><code id="add_epred_draws_+3A_n">n</code></td>
<td>
<p>(Deprecated). Use <code>ndraws</code>.</p>
</td></tr>
<tr><td><code id="add_epred_draws_+3A_scale">scale</code></td>
<td>
<p>(Deprecated). Use the appropriate function (<code>epred_draws()</code> or <code>linpred_draws()</code>)
depending on what type of distribution you want. For <code>linpred_draws()</code>, you may want the
<code>transform</code> argument. See <code>rstanarm::posterior_linpred()</code> or <code>brms::posterior_linpred()</code>.</p>
</td></tr>
<tr><td><code id="add_epred_draws_+3A_prediction">prediction</code>, <code id="add_epred_draws_+3A_residual">residual</code></td>
<td>
<p>(Deprecated). Use <code>value</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a model like:
</p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rcl}
y &amp;\sim&amp; \textrm{SomeDist}(\theta_1, \theta_2)\\
f_1(\theta_1) &amp;=&amp; \alpha_1 + \beta_1 x\\
f_2(\theta_2) &amp;=&amp; \alpha_2 + \beta_2 x
\end{array}</code>
</p>

<p>This model has:
</p>

<ul>
<li><p> an outcome variable, <code class="reqn">y</code>
</p>
</li>
<li><p> a response distribution, <code class="reqn">\textrm{SomeDist}</code>, having parameters <code class="reqn">\theta_1</code>
(with link function <code class="reqn">f_1</code>) and <code class="reqn">\theta_2</code> (with link function <code class="reqn">f_2</code>)
</p>
</li>
<li><p> a single predictor, <code class="reqn">x</code>
</p>
</li>
<li><p> coefficients <code class="reqn">\alpha_1</code>, <code class="reqn">\beta_1</code>, <code class="reqn">\alpha_2</code>, and <code class="reqn">\beta_2</code>
</p>
</li></ul>

<p>We fit this model to some observed data, <code class="reqn">y_\textrm{obs}</code>, and predictors,
<code class="reqn">x_\textrm{obs}</code>. Given new values of predictors, <code class="reqn">x_\textrm{new}</code>,
supplied in the data frame <code>newdata</code>, the functions for posterior draws are
defined as follows:
</p>

<ul>
<li> <p><code>add_predicted_draws()</code> adds draws from the <strong>posterior predictive distribution</strong>,
<code class="reqn">p(y_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>,
to the data.
It corresponds to <code><a href="rstanarm.html#topic+posterior_predict.stanreg">rstanarm::posterior_predict()</a></code> or <code><a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict()</a></code>.
</p>
</li>
<li> <p><code>add_epred_draws()</code> adds draws from the <strong>expectation of the posterior predictive
distribution</strong>, aka the conditional expectation,
<code class="reqn">E(y_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>,
to the data.
It corresponds to <code><a href="rstanarm.html#topic+posterior_linpred.stanreg">rstanarm::posterior_epred()</a></code> or <code><a href="brms.html#topic+posterior_epred.brmsfit">brms::posterior_epred()</a></code>.
Not all models support this function.
</p>
</li>
<li> <p><code>add_linpred_draws()</code> adds draws from the <strong>posterior linear predictors</strong> to the data.
It corresponds to <code><a href="rstanarm.html#topic+posterior_linpred.stanreg">rstanarm::posterior_linpred()</a></code> or <code><a href="brms.html#topic+posterior_linpred.brmsfit">brms::posterior_linpred()</a></code>.
Depending on the model type and additional parameters passed, this may be:
</p>

<ul>
<li><p> The untransformed linear predictor, e.g.
<code class="reqn">p(f_1(\theta_1) | x_\textrm{new}, y_\textrm{obs})</code> =
<code class="reqn">p(\alpha_1 + \beta_1 x_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>.
This is returned by <code>add_linpred_draws(transform = FALSE)</code> for <span class="pkg">brms</span> and <span class="pkg">rstanarm</span> models.
It is analogous to <code>type = "link"</code> in <code><a href="stats.html#topic+predict.glm">predict.glm()</a></code>.
</p>
</li>
<li><p> The inverse-link transformed linear predictor, e.g.
<code class="reqn">p(\theta_1 | x_\textrm{new}, y_\textrm{obs})</code> =
<code class="reqn">p(f_1^{-1}(\alpha_1 + \beta_1 x_\textrm{new}) | x_\textrm{new}, y_\textrm{obs})</code>.
This is returned by <code>add_linpred_draws(transform = TRUE)</code> for <span class="pkg">brms</span> and <span class="pkg">rstanarm</span> models.
It is analogous to <code>type = "response"</code> in <code><a href="stats.html#topic+predict.glm">predict.glm()</a></code>.
</p>
</li></ul>

<p><strong>NOTE:</strong> <code>add_linpred_draws(transform = TRUE)</code> and <code>add_epred_draws()</code> may be equivalent but
are not guaranteed to be. They are equivalent when the expectation of the response
distribution is equal to its first parameter, i.e. when <code class="reqn">E(y) = \theta_1</code>. Many
distributions have this property (e.g. Normal distributions, Bernoulli distributions),
but not all. If you want the expectation of the posterior predictive, it is best to
use <code>add_epred_draws()</code> if available, and if not available, verify this property holds prior
to using <code>add_linpred_draws()</code>.
</p>
</li>
<li> <p><code>add_residual_draws()</code> adds draws from residuals,
<code class="reqn">p(y_\textrm{obs} - y_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>,
to the data.
It corresponds to <code><a href="brms.html#topic+residuals.brmsfit">brms::residuals.brmsfit()</a></code>.
</p>
</li></ul>

<p>The corresponding functions without <code>add_</code> as a prefix are alternate spellings
with the opposite order of the first two arguments: e.g. <code>add_predicted_draws(newdata, object)</code>
versus <code>predicted_draws(object, newdata)</code>. This facilitates use in data
processing pipelines that start either with a data frame or a model.
</p>
<p>Given equal choice between the two, the spellings prefixed with <code>add_</code>
are preferred.
</p>


<h3>Value</h3>

<p>A data frame (actually, a <a href="tibble.html#topic+tibble">tibble</a>) with a <code>.row</code> column (a
factor grouping rows from the input <code>newdata</code>), <code>.chain</code> column (the chain
each draw came from, or <code>NA</code> if the model does not provide chain information),
<code>.iteration</code> column (the iteration the draw came from, or <code>NA</code> if the model does
not provide iteration information), and a <code>.draw</code> column (a unique index corresponding to each draw
from the distribution). In addition, <code>epred_draws</code> includes a column with its name specified by
the <code>epred</code> argument (default <code>".epred"</code>); <code>linpred_draws</code> includes a column with its name
specified by the <code>linpred</code> argument (default <code>".linpred"</code>), and
<code>predicted_draws</code> contains a column with its name specified by the <code>.prediction</code> argument (default
<code>".prediction"</code>). For convenience, the resulting data frame comes grouped by the original input rows.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_draws">add_draws()</a></code> for the variant of these functions for use with packages that do not have
explicit support for these functions yet. See <code><a href="#topic+spread_draws">spread_draws()</a></code> for manipulating posteriors directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(ggplot2)
library(dplyr)
library(brms)
library(modelr)

theme_set(theme_light())

m_mpg = brm(mpg ~ hp * cyl, data = mtcars,
  # 1 chain / few iterations just so example runs quickly
  # do not use in practice
  chains = 1, iter = 500)

# draw 100 lines from the posterior means and overplot them
mtcars %&gt;%
  group_by(cyl) %&gt;%
  data_grid(hp = seq_range(hp, n = 101)) %&gt;%
  # NOTE: only use ndraws here when making spaghetti plots; for
  # plotting intervals it is always best to use all draws (omit ndraws)
  add_epred_draws(m_mpg, ndraws = 100) %&gt;%
  ggplot(aes(x = hp, y = mpg, color = ordered(cyl))) +
  geom_line(aes(y = .epred, group = paste(cyl, .draw)), alpha = 0.25) +
  geom_point(data = mtcars)

# plot posterior predictive intervals
mtcars %&gt;%
  group_by(cyl) %&gt;%
  data_grid(hp = seq_range(hp, n = 101)) %&gt;%
  add_predicted_draws(m_mpg) %&gt;%
  ggplot(aes(x = hp, y = mpg, color = ordered(cyl))) +
  stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), alpha = 0.25) +
  geom_point(data = mtcars) +
  scale_fill_brewer(palette = "Greys")


## End(Not run)
</code></pre>

<hr>
<h2 id='add_epred_rvars'>Add <code>rvar</code>s for the linear predictor, posterior expectation, posterior predictive, or residuals of a model to a data frame</h2><span id='topic+add_epred_rvars'></span><span id='topic+epred_rvars'></span><span id='topic+epred_rvars.default'></span><span id='topic+epred_rvars.stanreg'></span><span id='topic+epred_rvars.brmsfit'></span><span id='topic+add_linpred_rvars'></span><span id='topic+linpred_rvars'></span><span id='topic+linpred_rvars.default'></span><span id='topic+linpred_rvars.stanreg'></span><span id='topic+linpred_rvars.brmsfit'></span><span id='topic+add_predicted_rvars'></span><span id='topic+predicted_rvars'></span><span id='topic+predicted_rvars.default'></span><span id='topic+predicted_rvars.stanreg'></span><span id='topic+predicted_rvars.brmsfit'></span>

<h3>Description</h3>

<p>Given a data frame and a model, adds <code><a href="posterior.html#topic+rvar">rvar</a></code>s of draws from the linear/link-level predictor,
the expectation of the posterior predictive, or the posterior predictive to
the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_epred_rvars(
  newdata,
  object,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

epred_rvars(
  object,
  newdata,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

## Default S3 method:
epred_rvars(
  object,
  newdata,
  ...,
  value = ".epred",
  seed = NULL,
  dpar = NULL,
  columns_to = NULL
)

## S3 method for class 'stanreg'
epred_rvars(
  object,
  newdata,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

## S3 method for class 'brmsfit'
epred_rvars(
  object,
  newdata,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

add_linpred_rvars(
  newdata,
  object,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

linpred_rvars(
  object,
  newdata,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

## Default S3 method:
linpred_rvars(
  object,
  newdata,
  ...,
  value = ".linpred",
  seed = NULL,
  dpar = NULL,
  columns_to = NULL
)

## S3 method for class 'stanreg'
linpred_rvars(
  object,
  newdata,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

## S3 method for class 'brmsfit'
linpred_rvars(
  object,
  newdata,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

add_predicted_rvars(
  newdata,
  object,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  columns_to = NULL
)

predicted_rvars(
  object,
  newdata,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  columns_to = NULL
)

## Default S3 method:
predicted_rvars(
  object,
  newdata,
  ...,
  value = ".prediction",
  seed = NULL,
  columns_to = NULL
)

## S3 method for class 'stanreg'
predicted_rvars(
  object,
  newdata,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  columns_to = NULL
)

## S3 method for class 'brmsfit'
predicted_rvars(
  object,
  newdata,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  columns_to = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_epred_rvars_+3A_newdata">newdata</code></td>
<td>
<p>Data frame to generate predictions from.</p>
</td></tr>
<tr><td><code id="add_epred_rvars_+3A_object">object</code></td>
<td>
<p>A supported Bayesian model fit that can provide fits and predictions. Supported models
are listed in the second section of <a href="#topic+tidybayes-models">tidybayes-models</a>: <em>Models Supporting Prediction</em>. While other
functions in this package (like <code><a href="#topic+spread_rvars">spread_rvars()</a></code>) support a wider range of models, to work with
<code>add_epred_rvars()</code>, <code>add_predicted_rvars()</code>, etc. a model must provide an interface for generating
predictions, thus more generic Bayesian modeling interfaces like <code>runjags</code> and <code>rstan</code> are not directly
supported for these functions (only wrappers around those languages that provide predictions, like <code>rstanarm</code>
and <code>brm</code>, are supported here).</p>
</td></tr>
<tr><td><code id="add_epred_rvars_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying prediction method for the type of
model given.</p>
</td></tr>
<tr><td><code id="add_epred_rvars_+3A_value">value</code></td>
<td>
<p>The name of the output column:
</p>

<ul>
<li><p> for <code style="white-space: pre;">&#8288;[add_]epred_rvars()&#8288;</code>, defaults to <code>".epred"</code>.
</p>
</li>
<li><p> for <code style="white-space: pre;">&#8288;[add_]predicted_rvars()&#8288;</code>, defaults to <code>".prediction"</code>.
</p>
</li>
<li><p> for <code style="white-space: pre;">&#8288;[add_]linpred_rvars()&#8288;</code>, defaults to <code>".linpred"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="add_epred_rvars_+3A_ndraws">ndraws</code></td>
<td>
<p>The number of draws to return, or <code>NULL</code> to return all draws.</p>
</td></tr>
<tr><td><code id="add_epred_rvars_+3A_seed">seed</code></td>
<td>
<p>A seed to use when subsampling draws (i.e. when <code>ndraws</code> is not <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="add_epred_rvars_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in the prediction.
If <code>NULL</code> (default), include all group-level effects; if <code>NA</code>, include no group-level effects.
Some model types (such as <a href="brms.html#topic+brmsfit-class">brms::brmsfit</a> and <a href="rstanarm.html#topic+stanreg-objects">rstanarm::stanreg-objects</a>) allow
marginalizing over grouping factors by specifying new levels of a factor in <code>newdata</code>. In the case of
<code><a href="brms.html#topic+brm">brms::brm()</a></code>, you must also pass <code>allow_new_levels = TRUE</code> here to include new levels (see
<code><a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict()</a></code>).</p>
</td></tr>
<tr><td><code id="add_epred_rvars_+3A_dpar">dpar</code></td>
<td>
<p>For <code>add_epred_rvars()</code> and <code>add_linpred_rvars()</code>: Should distributional regression
parameters be included in the output? Valid only for models that support distributional regression parameters,
such as submodels for variance parameters (as in <code>brms::brm()</code>). If <code>TRUE</code>, distributional regression
parameters are included in the output as additional columns named after each parameter
(alternative names can be provided using a list or named vector, e.g. <code>c(sigma.hat = "sigma")</code>
would output the <code>"sigma"</code> parameter from a model as a column named <code>"sigma.hat"</code>).
If <code>NULL</code> or <code>FALSE</code> (the default), distributional regression parameters are not included.</p>
</td></tr>
<tr><td><code id="add_epred_rvars_+3A_columns_to">columns_to</code></td>
<td>
<p>For <em>some</em> models, such as ordinal, multinomial, and multivariate models (notably, <code><a href="brms.html#topic+brm">brms::brm()</a></code> models but
<em>not</em> <code><a href="rstanarm.html#topic+stan_polr">rstanarm::stan_polr()</a></code> models), the column of predictions in the resulting data frame may include nested columns.
For example, for ordinal/multinomial models, these columns correspond to different categories of the response variable.
It may be more convenient to turn these nested columns into rows in the output; if this is desired, set
<code>columns_to</code> to a string representing the name of a column you would like the column names to be placed in.
In this case, a <code>.row</code> column will also be added to the result indicating which rows of the output
correspond to the same row in <code>newdata</code>.
See <code>vignette("tidy-posterior")</code> for examples of dealing with output ordinal models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a model like:
</p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rcl}
y &amp;\sim&amp; \textrm{SomeDist}(\theta_1, \theta_2)\\
f_1(\theta_1) &amp;=&amp; \alpha_1 + \beta_1 x\\
f_2(\theta_2) &amp;=&amp; \alpha_2 + \beta_2 x
\end{array}</code>
</p>

<p>This model has:
</p>

<ul>
<li><p> an outcome variable, <code class="reqn">y</code>
</p>
</li>
<li><p> a response distribution, <code class="reqn">\textrm{SomeDist}</code>, having parameters <code class="reqn">\theta_1</code>
(with link function <code class="reqn">f_1</code>) and <code class="reqn">\theta_2</code> (with link function <code class="reqn">f_2</code>)
</p>
</li>
<li><p> a single predictor, <code class="reqn">x</code>
</p>
</li>
<li><p> coefficients <code class="reqn">\alpha_1</code>, <code class="reqn">\beta_1</code>, <code class="reqn">\alpha_2</code>, and <code class="reqn">\beta_2</code>
</p>
</li></ul>

<p>We fit this model to some observed data, <code class="reqn">y_\textrm{obs}</code>, and predictors,
<code class="reqn">x_\textrm{obs}</code>. Given new values of predictors, <code class="reqn">x_\textrm{new}</code>,
supplied in the data frame <code>newdata</code>, the functions for posterior draws are
defined as follows:
</p>

<ul>
<li> <p><code>add_predicted_rvars()</code> adds <code><a href="posterior.html#topic+rvar">rvar</a></code>s containing draws from the <strong>posterior predictive distribution</strong>,
<code class="reqn">p(y_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>,
to the data.
It corresponds to <code><a href="rstanarm.html#topic+posterior_predict.stanreg">rstanarm::posterior_predict()</a></code> or <code><a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict()</a></code>.
</p>
</li>
<li> <p><code>add_epred_rvars()</code> adds <code><a href="posterior.html#topic+rvar">rvar</a></code>s containing draws from the <strong>expectation of the posterior predictive
distribution</strong>, aka the conditional expectation,
<code class="reqn">E(y_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>,
to the data.
It corresponds to <code><a href="rstanarm.html#topic+posterior_linpred.stanreg">rstanarm::posterior_epred()</a></code> or <code><a href="brms.html#topic+posterior_epred.brmsfit">brms::posterior_epred()</a></code>.
Not all models support this function.
</p>
</li>
<li> <p><code>add_linpred_rvars()</code> adds <code><a href="posterior.html#topic+rvar">rvar</a></code>s containing draws from the <strong>posterior linear predictors</strong> to the data.
It corresponds to <code><a href="rstanarm.html#topic+posterior_linpred.stanreg">rstanarm::posterior_linpred()</a></code> or <code><a href="brms.html#topic+posterior_linpred.brmsfit">brms::posterior_linpred()</a></code>.
Depending on the model type and additional parameters passed, this may be:
</p>

<ul>
<li><p> The untransformed linear predictor, e.g.
<code class="reqn">p(f_1(\theta_1) | x_\textrm{new}, y_\textrm{obs})</code> =
<code class="reqn">p(\alpha_1 + \beta_1 x_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>.
This is returned by <code>add_linpred_rvars(transform = FALSE)</code> for <span class="pkg">brms</span> and <span class="pkg">rstanarm</span> models.
It is analogous to <code>type = "link"</code> in <code><a href="stats.html#topic+predict.glm">predict.glm()</a></code>.
</p>
</li>
<li><p> The inverse-link transformed linear predictor, e.g.
<code class="reqn">p(\theta_1 | x_\textrm{new}, y_\textrm{obs})</code> =
<code class="reqn">p(f_1^{-1}(\alpha_1 + \beta_1 x_\textrm{new}) | x_\textrm{new}, y_\textrm{obs})</code>.
This is returned by <code>add_linpred_rvars(transform = TRUE)</code> for <span class="pkg">brms</span> and <span class="pkg">rstanarm</span> models.
It is analogous to <code>type = "response"</code> in <code><a href="stats.html#topic+predict.glm">predict.glm()</a></code>.
</p>
</li></ul>

<p><strong>NOTE:</strong> <code>add_linpred_rvars(transform = TRUE)</code> and <code>add_epred_rvars()</code> may be equivalent but
are not guaranteed to be. They are equivalent when the expectation of the response
distribution is equal to its first parameter, i.e. when <code class="reqn">E(y) = \theta_1</code>. Many
distributions have this property (e.g. Normal distributions, Bernoulli distributions),
but not all. If you want the expectation of the posterior predictive, it is best to
use <code>add_epred_rvars()</code> if available, and if not available, verify this property holds prior
to using <code>add_linpred_rvars()</code>.
</p>
</li></ul>

<p>The corresponding functions without <code>add_</code> as a prefix are alternate spellings
with the opposite order of the first two arguments: e.g. <code>add_predicted_rvars(newdata, object)</code>
versus <code>predicted_rvars(object, newdata)</code>. This facilitates use in data
processing pipelines that start either with a data frame or a model.
</p>
<p>Given equal choice between the two, the spellings prefixed with <code>add_</code>
are preferred.
</p>


<h3>Value</h3>

<p>A data frame (actually, a <a href="tibble.html#topic+tibble">tibble</a>) equal to the input <code>newdata</code> with
additional columns added containing <code><a href="posterior.html#topic+rvar">rvar</a></code>s representing the requested predictions or fits.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_predicted_draws">add_predicted_draws()</a></code> for the analogous functions that use a long-data-frame-of-draws
format instead of a data-frame-of-<code>rvar</code>s format. See <code><a href="#topic+spread_rvars">spread_rvars()</a></code> for manipulating posteriors directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(ggplot2)
library(dplyr)
library(posterior)
library(brms)
library(modelr)

theme_set(theme_light())

m_mpg = brm(mpg ~ hp * cyl, data = mtcars, family = lognormal(),
  # 1 chain / few iterations just so example runs quickly
  # do not use in practice
  chains = 1, iter = 500)

# Look at mean predictions for some cars (epred) and compare to
# the exponeniated mu parameter of the lognormal distribution (linpred).
# Notice how they are NOT the same. This is because exp(mu) for a
# lognormal distribution is equal to its median, not its mean.
mtcars %&gt;%
  select(hp, cyl, mpg) %&gt;%
  add_epred_rvars(m_mpg) %&gt;%
  add_linpred_rvars(m_mpg, value = "mu") %&gt;%
  mutate(expmu = exp(mu), .epred - expmu)

# plot intervals around conditional means (epred_rvars)
mtcars %&gt;%
  group_by(cyl) %&gt;%
  data_grid(hp = seq_range(hp, n = 101)) %&gt;%
  add_epred_rvars(m_mpg) %&gt;%
  ggplot(aes(x = hp, color = ordered(cyl), fill = ordered(cyl))) +
  stat_lineribbon(aes(dist = .epred), .width = c(.95, .8, .5), alpha = 1/3) +
  geom_point(aes(y = mpg), data = mtcars) +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Set2")

# plot posterior predictive intervals (predicted_rvars)
mtcars %&gt;%
  group_by(cyl) %&gt;%
  data_grid(hp = seq_range(hp, n = 101)) %&gt;%
  add_predicted_rvars(m_mpg) %&gt;%
  ggplot(aes(x = hp, color = ordered(cyl), fill = ordered(cyl))) +
  stat_lineribbon(aes(dist = .prediction), .width = c(.95, .8, .5), alpha = 1/3) +
  geom_point(aes(y = mpg), data = mtcars) +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Set2")


## End(Not run)
</code></pre>

<hr>
<h2 id='combine_chains'>Combine the chain and iteration columns of tidy data frames of draws</h2><span id='topic+combine_chains'></span>

<h3>Description</h3>

<p>Combines the chain and iteration columns of a tidy data frame of draws from a Bayesian model fit into a new column
that can uniquely identify each draw. Generally speaking <strong>not needed for pure tidybayes code</strong>, as tidybayes
functions now automatically include a <code>.draw</code> column, but can be useful when interacting with packages that
do not provide such a column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_chains(data, chain = .chain, iteration = .iteration, into = ".draw")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_chains_+3A_data">data</code></td>
<td>
<p>Tidy data frame of draws with columns representing the chain and iteration of each draw.</p>
</td></tr>
<tr><td><code id="combine_chains_+3A_chain">chain</code></td>
<td>
<p>Bare name of column in <code>data</code> indicating the chain of each row. The default (<code>.chain</code>) is
the same as used by other functions in <code>tidybayes</code>.</p>
</td></tr>
<tr><td><code id="combine_chains_+3A_iteration">iteration</code></td>
<td>
<p>Bare name of column in <code>data</code> indicating the iteration of each row. The default
(<code>.iteration</code>) is the same as used by other functions in <code>tidybayes</code>.</p>
</td></tr>
<tr><td><code id="combine_chains_+3A_into">into</code></td>
<td>
<p>Name (as a character vector) of the column to combine chains into. The default, <code>NULL</code>, replaces the
<code>chain</code> column with <code>NA</code>s and writes the combined chain iteration numbers into <code>iteration</code>. If
provided, <code>chain</code> and <code>iteration</code> will not be modified, and the combined iteration number will be written
into a new column named <code>into</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of tidy draws with a combined iteration column
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(magrittr)
library(coda)

data(line, package = "coda")

# The `line` posterior has two chains with 200 iterations each:
line %&gt;%
  tidy_draws() %&gt;%
  summary()

# combine_chains combines the chain and iteration column into the .draw column.
line %&gt;%
  tidy_draws() %&gt;%
  combine_chains() %&gt;%
  summary()

</code></pre>

<hr>
<h2 id='compare_levels'>Compare the value of draws of some variable from a Bayesian model for
different levels of a factor</h2><span id='topic+compare_levels'></span>

<h3>Description</h3>

<p>Given posterior draws from a Bayesian model in long format (e.g. as
returned by <code><a href="#topic+spread_draws">spread_draws()</a></code>), compare the value of a variable in those draws
across different paired combinations of levels of a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_levels(
  data,
  variable,
  by,
  fun = `-`,
  comparison = "default",
  draw_indices = c(".chain", ".iteration", ".draw"),
  ignore_groups = ".row"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_levels_+3A_data">data</code></td>
<td>
<p>Long-format <code>data.frame</code> of draws such as returned by
<code><a href="#topic+spread_draws">spread_draws()</a></code> or <code><a href="#topic+gather_draws">gather_draws()</a></code>. If <code>data</code>
is a grouped data frame, comparisons will be made within groups (if
one of the groups in the data frame is the <code>by</code> column, that specific
group will be ignored, as it is not possible to make comparisons both
within some variable and across it simultaneously).</p>
</td></tr>
<tr><td><code id="compare_levels_+3A_variable">variable</code></td>
<td>
<p>Bare (unquoted) name of a column in data representing the
variable to compare across levels. Can be a numeric variable (as in
long-data-frame-of-draws format) or a <code><a href="posterior.html#topic+rvar">posterior::rvar</a></code>.</p>
</td></tr>
<tr><td><code id="compare_levels_+3A_by">by</code></td>
<td>
<p>Bare (unquoted) name of a column in data that is a
<code>factor</code> or <code>ordered</code>. The value of <code>variable</code> will be
compared across pairs of levels of this <code>factor</code>.</p>
</td></tr>
<tr><td><code id="compare_levels_+3A_fun">fun</code></td>
<td>
<p>Binary function to use for comparison. For each pair of levels of
<code>by</code> we are comparing (as determined by <code>comparison</code>), compute the
result of this function.</p>
</td></tr>
<tr><td><code id="compare_levels_+3A_comparison">comparison</code></td>
<td>
<p>One of (a) the comparison types <code>ordered</code>,
<code>control</code>, <code>pairwise</code>, or <code>default</code> (may also be given as
strings, e.g. <code>"ordered"</code>), see <em>Details</em>; (b) a user-specified
function that takes a <code>factor</code> and returns a list of pairs of names of
levels to compare (as strings) and/or unevaluated expressions containing
representing the comparisons to make; or (c) a list of pairs of names of
levels to compare (as strings) and/or unevaluated expressions representing
the comparisons to make, e.g.: <code>list(c("a", "b"), c("b", "c"))</code> or
<code>exprs(a - b, b - c)</code>, both of which would compare level <code>"a"</code> against
<code>"b"</code> and level <code>"b"</code> against <code>"c"</code>. Note that the
unevaluated expression syntax ignores the <code>fun</code> argument, can include
any other functions desired (e.g. variable transformations), and can even
include more than two levels or other columns in <code>data</code>. Types (b) and
(c) may use named lists, in which case the provided names are used
in the output <code>variable</code> column instead converting the unevaluated
expression to a string. You can also use <code><a href="#topic+emmeans_comparison">emmeans_comparison()</a></code> to generate
a comparison function based on contrast methods from the <code>emmeans</code> package.</p>
</td></tr>
<tr><td><code id="compare_levels_+3A_draw_indices">draw_indices</code></td>
<td>
<p>Character vector of column names in <code>data</code> that
should be treated as indices when making the comparison (i.e. values of
<code>variable</code> within each level of <code>by</code> will be compared at each
unique combination of levels of <code>draw_indices</code>). Columns in <code>draw_indices</code>
not found in <code>data</code> are ignored. The default is <code>c(".chain",".iteration",".draw")</code>,
which are the same names used for chain/iteration/draw indices returned by
<code><a href="#topic+spread_draws">spread_draws()</a></code> or <code><a href="#topic+gather_draws">gather_draws()</a></code>; thus if you are using <code>compare_levels</code>
with <code><a href="#topic+spread_draws">spread_draws()</a></code> or <code><a href="#topic+gather_draws">gather_draws()</a></code> you generally should not need to change this
value.</p>
</td></tr>
<tr><td><code id="compare_levels_+3A_ignore_groups">ignore_groups</code></td>
<td>
<p>character vector of names of groups to ignore by
default in the input grouping. This is primarily provided to make it
easier to pipe output of <code><a href="#topic+add_epred_draws">add_epred_draws()</a></code> into this function,
as that function provides a <code>".row"</code> output column that is grouped,
but which is virtually never desired to group by when using <code>compare_levels</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simplifies conducting comparisons across levels of some
variable in a tidy data frame of draws. It applies <code>fun</code> to all
values of <code>variable</code> for each pair of levels of <code>by</code> as selected
by <code>comparison</code>. By default, all pairwise comparisons are generated if
<code>by</code> is an unordered <code>factor</code> and ordered comparisons are made if
<code>by</code> is <code>ordered</code>.
</p>
<p>The included <code>comparison</code> types are: </p>
 <ul>
<li> <p><code>ordered</code>:
compare each level <code>i</code> with level <code>i - 1</code>; e.g. <code>fun(i, i - 1)</code> </p>
</li>
<li> <p><code>pairwise</code>: compare each level of <code>by</code> with every other
level.  </p>
</li>
<li> <p><code>control</code>: compare each level of <code>by</code> with the first
level of <code>by</code>.  If you wish to compare with a different level, you can
first apply <code><a href="stats.html#topic+relevel">relevel()</a></code> to <code>by</code> to set the control
(reference) level.  </p>
</li>
<li> <p><code>default</code>: use <code>ordered</code> if
<code>is.ordered(by)</code> and <code>pairwise</code> otherwise.  </p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.frame</code> with the same columns as <code>data</code>, except
that the <code>by</code> column contains a symbolic representation of the
comparison of pairs of levels of <code>by</code> in <code>data</code>, and
<code>variable</code> contains the result of that comparison.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emmeans_comparison">emmeans_comparison()</a></code> to use <code>emmeans</code>-style contrast methods with
<code><a href="#topic+compare_levels">compare_levels()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

data(RankCorr, package = "ggdist")

# Let's do all pairwise comparisons of b[i,1]:
RankCorr %&gt;%
  spread_draws(b[i,j]) %&gt;%
  filter(j == 1) %&gt;%
  compare_levels(b, by = i) %&gt;%
  median_qi()

# Or let's plot all comparisons against the first level (control):
RankCorr %&gt;%
  spread_draws(b[i,j]) %&gt;%
  filter(j == 1) %&gt;%
  compare_levels(b, by = i, comparison = control) %&gt;%
  ggplot(aes(x = b, y = i)) +
  stat_halfeye()

# Or let's plot comparisons of all levels of j within
# all levels of i
RankCorr %&gt;%
  spread_draws(b[i,j]) %&gt;%
  group_by(i) %&gt;%
  compare_levels(b, by = j) %&gt;%
  ggplot(aes(x = b, y = j)) +
  stat_halfeye() +
  facet_grid(cols = vars(i))

</code></pre>

<hr>
<h2 id='compose_data'>Compose data for input into a Bayesian model</h2><span id='topic+compose_data'></span>

<h3>Description</h3>

<p>Compose data into a list suitable to be passed into a Bayesian model (JAGS,
BUGS, Stan, etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose_data(..., .n_name = n_prefix("n"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compose_data_+3A_...">...</code></td>
<td>
<p>Data to be composed into a list suitable for being passed into
Stan, JAGS, etc. Named arguments will have their name used as the <code>name</code>
argument to <code>as_data_list</code> when translated; unnamed arguments that are
not lists or data frames will have their bare value (passed through
<code>make.names</code>) used as the <code>name</code> argument to <code>as_data_list</code>.
Each argument is evaluated using <code>eval_tidy</code> in an environment that
includes all list items composed so far.</p>
</td></tr>
<tr><td><code id="compose_data_+3A_.n_name">.n_name</code></td>
<td>
<p>A function that is used to form dimension index variables (a variable
whose value is number of levels in a factor or the length of a data frame in
<code>...</code>). For example, if a data frame with 20 rows and a factor <code>"foo"</code>
(having 3 levels) is passed to <code>compose_data</code>, the list returned by
<code>compose_data</code> will include an element named <code>.n_name("foo")</code>, which
by default would be &quot;n_foo&quot;, containing the value 3, and a column named &quot;n&quot;
containing the value 20. See <code><a href="#topic+n_prefix">n_prefix()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function recursively translates each argument into list elements using
<code><a href="#topic+as_data_list">as_data_list()</a></code>, merging all resulting lists together. By
default this means that:
</p>

<ul>
<li><p> numerics are included as-is.
</p>
</li>
<li><p> logicals are translated into numeric using <code><a href="base.html#topic+as.numeric">as.numeric()</a></code>.
</p>
</li>
<li><p> factors are translated into numeric using <code><a href="base.html#topic+as.numeric">as.numeric()</a></code>,
and an additional element named <code>.n_name(argument_name)</code> is added
with the number of levels in the factor. The default <code>.n_name</code>
function prefixes <code>"n_"</code> before the factor name; e.g. a factor
named <code>foo</code> will have an element named <code>n_foo</code> added containing
the number of levels in <code>foo</code>.
</p>
</li>
<li><p> character vectors are converted into factors then translated into numeric
in the same manner as factors are.
</p>
</li>
<li><p> lists are translated by translating all elements of the list
(recursively) and adding them to the result.
</p>
</li>
<li><p> data.frames are translated by translating every column of the data.frame
and adding them to the result.  A variable named <code>"n"</code> (or
<code>.n_name(argument_name)</code> if the data.frame is passed as a named
argument <code>argument_name</code>) is also added containing the number of rows
in the data frame.
</p>
</li>
<li> <p><code>NULL</code> values are dropped. Setting a named argument to <code>NULL</code>
can be used to drop that item from the resulting list (if an unwanted
element was added to the list by a previous argument, such as a column
from a data frame that is not needed in the model).
</p>
</li>
<li><p> all other types are dropped (and a warning given)
</p>
</li></ul>

<p>As in functions like <code><a href="dplyr.html#topic+mutate">mutate()</a></code>, each expression is evaluated in an
environment containing the data list built up so far.
</p>
<p>For example, this means that if the first argument to <code>compose_data</code>
is a data frame, subsequent arguments can include direct references to columns
from that data frame. This allows you, for example, to easily use
<code><a href="#topic+x_at_y">x_at_y()</a></code> to generate indices for nested models.
</p>
<p>If you wish to add support for additional types not described above,
provide an implementation of <code><a href="#topic+as_data_list">as_data_list()</a></code> for the type. See
the implementations of <code>as_data_list.numeric</code>,
<code>as_data_list.logical</code>, etc for examples.
</p>


<h3>Value</h3>

<p>A list where each element is a translated variable as described above.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+x_at_y">x_at_y()</a></code>, <code><a href="#topic+spread_draws">spread_draws()</a></code>,
<code><a href="#topic+gather_draws">gather_draws()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(magrittr)

df = data.frame(
  plot = factor(paste0("p", rep(1:8, times = 2))),
  site = factor(paste0("s", rep(1:4, each = 2, times = 2)))
)

# without changing `.n_name`, compose_data() will prefix indices
# with "n" by default
df %&gt;%
  compose_data()

# you can use n_prefix() to define a different prefix (e.g. "N"):
df %&gt;%
  compose_data(.n_name = n_prefix("N"))

# If you have nesting, you may want a nested index, which can be generated using x_at_y()
# Here, site[p] will give the site for plot p
df %&gt;%
  compose_data(site = x_at_y(site, plot))

</code></pre>

<hr>
<h2 id='data_list'>Data lists for input into Bayesian models</h2><span id='topic+data_list'></span><span id='topic+as_data_list'></span><span id='topic+as_data_list.default'></span><span id='topic+as_data_list.numeric'></span><span id='topic+as_data_list.logical'></span><span id='topic+as_data_list.factor'></span><span id='topic+as_data_list.character'></span><span id='topic+as_data_list.list'></span><span id='topic+as_data_list.data.frame'></span><span id='topic+as_data_list.data_list'></span>

<h3>Description</h3>

<p>Functions used by <code><a href="#topic+compose_data">compose_data()</a></code> to create lists of data suitable for
input into a Bayesian modeling function. <strong>These functions typically should not be called directly</strong>
(instead use <code><a href="#topic+compose_data">compose_data()</a></code>), but are exposed for the rare cases in which
you may need to provide your own conversion routines for a data type not already
supported (see <em>Details</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_list(...)

as_data_list(object, name = "", ...)

## Default S3 method:
as_data_list(object, name = "", ...)

## S3 method for class 'numeric'
as_data_list(object, name = "", scalar_as_array = FALSE, ...)

## S3 method for class 'logical'
as_data_list(object, name = "", ...)

## S3 method for class 'factor'
as_data_list(object, name = "", .n_name = n_prefix("n"), ...)

## S3 method for class 'character'
as_data_list(object, name = "", ...)

## S3 method for class 'list'
as_data_list(object, name = "", ...)

## S3 method for class 'data.frame'
as_data_list(object, name = "", .n_name = n_prefix("n"), ...)

## S3 method for class 'data_list'
as_data_list(object, name = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_list_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other implementations of
<code>as_data_list</code>, or for <code>data_list</code>, passed to <code><a href="base.html#topic+list">list()</a></code>.</p>
</td></tr>
<tr><td><code id="data_list_+3A_object">object</code></td>
<td>
<p>The object to convert (see <em>Details</em>).</p>
</td></tr>
<tr><td><code id="data_list_+3A_name">name</code></td>
<td>
<p>The name of the element in the returned list corresponding to
this object.</p>
</td></tr>
<tr><td><code id="data_list_+3A_scalar_as_array">scalar_as_array</code></td>
<td>
<p>If <code>TRUE</code>, returns single scalars as an
1-dimensional array with one element. This is used by
<code>as_data_list.data.frame</code> to ensure that columns from a data frame with
only one row are still returned as arrays instead of scalars.</p>
</td></tr>
<tr><td><code id="data_list_+3A_.n_name">.n_name</code></td>
<td>
<p>A function that is used to form variables storing the number of
rows in data frames or the number of levels in factors in <code>...</code>). For
example, if a factor with <code>name = "foo"</code> (having three levels) is
passed in, the list returned will include an element named
<code>.n_name("foo")</code>, which by default would be &quot;n_foo&quot;, containing the
value 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data_list</code> creates a list with class <code>c("data_list", "list")</code>
instead of <code>c("list")</code>, but largely otherwise acts like the <code><a href="base.html#topic+list">list()</a></code>
function.
</p>
<p><code>as_data_list</code> recursively translates its first argument into list elements,
concatenating all resulting lists together. By default this means that:
</p>

<ul>
<li><p> numerics are included as-is.
</p>
</li>
<li><p> logicals are translated into numeric using <code><a href="base.html#topic+as.numeric">as.numeric()</a></code>.
</p>
</li>
<li><p> factors are translated into numeric using <code><a href="base.html#topic+as.numeric">as.numeric()</a></code>, and an additional element named
<code>.n_name(name)</code> is added with the number of levels in the factor.
</p>
</li>
<li><p> character vectors are converted into factors then translated into numeric in the same manner as factors are.
</p>
</li>
<li><p> lists are translated by translating all elements of the list
(recursively) and adding them to the result.
</p>
</li>
<li><p> data.frames are translated by translating every column of the data.frame and adding them to
the result. A variable named <code>"n"</code> (or <code>.n_name(name)</code> if <code>name</code> is not <code>""</code>)
is also added containing the number of rows in the data frame.
</p>
</li>
<li><p> all other types are dropped (and a warning given)
</p>
</li></ul>

<p>If you wish to add support for additional types not described above, provide
an implementation of <code><a href="#topic+as_data_list">as_data_list()</a></code> for the type. See the
implementations of <code>as_data_list.numeric</code>, <code>as_data_list.logical</code>,
etc for examples.
</p>


<h3>Value</h3>

<p>An object of class <code>c("data_list", "list")</code>, where each element
is a translated variable as described above.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compose_data">compose_data()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Typically these functions should not be used directly.
# See the compose_data function for examples of how to translate
# data in lists for input to Bayesian modeling functions.

</code></pre>

<hr>
<h2 id='density_bins'>Density bins and histogram bins as data frames</h2><span id='topic+density_bins'></span><span id='topic+histogram_bins'></span>

<h3>Description</h3>

<p>Generates a data frame of bins representing the kernel density (or
histogram) of a vector, suitable for use in generating predictive
distributions for visualization. These functions were originally
designed for use with the now-deprecated <code>predict_curve()</code>, and
may be deprecated in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_bins(x, n = 101, ...)

histogram_bins(x, n = 30, breaks = n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_bins_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="density_bins_+3A_n">n</code></td>
<td>
<p>Number of bins</p>
</td></tr>
<tr><td><code id="density_bins_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="stats.html#topic+density">density()</a></code> or
<code><a href="graphics.html#topic+hist">hist()</a></code>.</p>
</td></tr>
<tr><td><code id="density_bins_+3A_breaks">breaks</code></td>
<td>
<p>Used to set bins for <code>histogram_bins</code>. Can be number of bins (by default it is set to the value
of <code>n</code>) or a method for setting bins. See the <code>breaks</code> argument of <code><a href="graphics.html#topic+hist">hist()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are simple wrappers to <code><a href="stats.html#topic+density">density()</a></code> and
<code><a href="graphics.html#topic+hist">hist()</a></code> that compute density estimates and return their results
in a consistent format: a data frame of bins suitable for use with
the now-deprecated <code><a href="#topic+predict_curve">predict_curve()</a></code>.
</p>
<p><code>density_bins</code> computes a kernel density estimate using
<code><a href="stats.html#topic+density">density()</a></code>.
</p>
<p><code>histogram_bins</code> computes a density histogram using <code><a href="graphics.html#topic+hist">hist()</a></code>.
</p>


<h3>Value</h3>

<p>A data frame representing bins and their densities with the
following columns: </p>
<table>
<tr><td><code>mid</code></td>
<td>
<p>Bin midpoint</p>
</td></tr> <tr><td><code>lower</code></td>
<td>
<p>Lower endpoint of
each bin</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper endpoint of each bin</p>
</td></tr> <tr><td><code>density</code></td>
<td>
<p>Density
estimate of the bin</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+add_predicted_draws">add_predicted_draws()</a></code> and <code><a href="#topic+stat_lineribbon">stat_lineribbon()</a></code> for a better approach. These
functions may be deprecated in the future.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(ggplot2)
library(dplyr)
library(brms)
library(modelr)

theme_set(theme_light())

m_mpg = brm(mpg ~ hp * cyl, data = mtcars)

step = 1
mtcars %&gt;%
  group_by(cyl) %&gt;%
  data_grid(hp = seq_range(hp, by = step)) %&gt;%
  add_predicted_draws(m_mpg) %&gt;%
  summarise(density_bins(.prediction), .groups = "drop") %&gt;%
  ggplot() +
  geom_rect(aes(
    xmin = hp - step/2, ymin = lower, ymax = upper, xmax = hp + step/2,
    fill = ordered(cyl), alpha = density
  )) +
  geom_point(aes(x = hp, y = mpg, fill = ordered(cyl)), shape = 21, data = mtcars) +
  scale_alpha_continuous(range = c(0, 1)) +
  scale_fill_brewer(palette = "Set2")


## End(Not run)
</code></pre>

<hr>
<h2 id='emmeans_comparison'>Use emmeans contrast methods with compare_levels</h2><span id='topic+emmeans_comparison'></span>

<h3>Description</h3>

<p>Convert <a href="emmeans.html#topic+emmc-functions">emmeans contrast methods</a> into comparison functions
suitable for use with <code><a href="#topic+compare_levels">compare_levels()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emmeans_comparison(method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emmeans_comparison_+3A_method">method</code></td>
<td>
<p>An emmeans-style contrast method. One of: (1) a string specifying
the name of an <a href="emmeans.html#topic+emmc-functions">emmeans contrast method</a>, like
<code>"pairwise"</code>, <code>"trt.vs.ctrl"</code>, <code>"eff"</code>; or (2) an emmeans-style contrast
function itself, like <a href="emmeans.html#topic+emmc-functions">emmeans::pairwise.emmc</a>, <a href="emmeans.html#topic+emmc-functions">emmeans::trt.vs.ctrl.emmc</a>, etc,
or a custom function that takes a vector of factor levels and returns a
contrast matrix.</p>
</td></tr>
<tr><td><code id="emmeans_comparison_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the contrast method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an <a href="emmeans.html#topic+emmc-functions">emmeans contrast method</a> name as a string
(e.g., <code>"pairwise"</code>, <code>"trt.vs.ctrl"</code>, etc) or an emmeans-style contrast function
(e.g., <a href="emmeans.html#topic+emmc-functions">emmeans::pairwise.emmc</a>, <a href="emmeans.html#topic+emmc-functions">emmeans::trt.vs.ctrl.emmc</a>, etc), <code>emmeans_comparison()</code>
returns a new function that can be used in the <code>comparison</code> argument to <code>compare_levels()</code>
to compute those contrasts.
</p>


<h3>Value</h3>

<p>A function that takes a single argument, <code>var</code>, containing a variable
to generate contrasts for (e.g., a factor or a character vector) and returns
a function that generates a list of named unevaluated expressions representing
different contrasts of that variable. This function is suitable to be used
as the <code>comparison</code> argument in <code>compare_levels()</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare_levels">compare_levels()</a></code>, <a href="emmeans.html#topic+emmc-functions">emmeans::contrast-methods</a>.
See <code><a href="#topic+gather_emmeans_draws">gather_emmeans_draws()</a></code> for a different approach to using <code>emmeans</code> with
<code>tidybayes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(dplyr)
library(ggplot2)

data(RankCorr, package = "ggdist")

# emmeans contrast methods return matrices. E.g. the "eff" comparison
# compares each level to the average of all levels:
emmeans:::eff.emmc(c("a","b","c","d"))

# tidybayes::compare_levels() can't use a contrast matrix like this
# directly; it takes arbitrary expressions of factor levels. But
# we can use `emmeans_comparison` to generate the equivalent expressions:
emmeans_comparison("eff")(c("a","b","c","d"))

# We can use the "eff" comparison type with `compare_levels()` as follows:
RankCorr %&gt;%
  spread_draws(b[i,j]) %&gt;%
  filter(j == 1) %&gt;%
  compare_levels(b, by = i, comparison = emmeans_comparison("eff")) %&gt;%
  median_qi()

</code></pre>

<hr>
<h2 id='gather_draws'>Extract draws of variables in a Bayesian model fit into a tidy data format</h2><span id='topic+gather_draws'></span><span id='topic+spread_draws'></span>

<h3>Description</h3>

<p>Extract draws from a Bayesian model for one or more variables (possibly with named
dimensions) into one of two types of long-format data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_draws(
  model,
  ...,
  regex = FALSE,
  sep = "[, ]",
  ndraws = NULL,
  seed = NULL,
  n
)

spread_draws(
  model,
  ...,
  regex = FALSE,
  sep = "[, ]",
  ndraws = NULL,
  seed = NULL,
  n
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_draws_+3A_model">model</code></td>
<td>
<p>A supported Bayesian model fit. Tidybayes supports a variety of model objects;
for a full list of supported models, see <a href="#topic+tidybayes-models">tidybayes-models</a>.</p>
</td></tr>
<tr><td><code id="gather_draws_+3A_...">...</code></td>
<td>
<p>Expressions in the form of
<code>variable_name[dimension_1, dimension_2, ...] | wide_dimension</code>. See <em>Details</em>.</p>
</td></tr>
<tr><td><code id="gather_draws_+3A_regex">regex</code></td>
<td>
<p>If <code>TRUE</code>, variable names are treated as regular expressions and all column matching the
regular expression and number of dimensions are included in the output. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gather_draws_+3A_sep">sep</code></td>
<td>
<p>Separator used to separate dimensions in variable names, as a regular expression.</p>
</td></tr>
<tr><td><code id="gather_draws_+3A_ndraws">ndraws</code></td>
<td>
<p>The number of draws to return, or <code>NULL</code> to return all draws.</p>
</td></tr>
<tr><td><code id="gather_draws_+3A_seed">seed</code></td>
<td>
<p>A seed to use when subsampling draws (i.e. when <code>ndraws</code> is not <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="gather_draws_+3A_n">n</code></td>
<td>
<p>(Deprecated). Use <code>ndraws</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imagine a JAGS or Stan fit named <code>model</code>. The model may contain a variable named
<code>b[i,v]</code> (in the JAGS or Stan language) with dimension <code>i</code> in <code>1:100</code> and
dimension <code>v</code> in <code>1:3</code>. However, the default format for draws returned from
JAGS or Stan in R will not reflect this indexing structure, instead
they will have multiple columns with names like <code>"b[1,1]"</code>, <code>"b[2,1]"</code>, etc.
</p>
<p><code>spread_draws</code> and <code>gather_draws</code> provide a straightforward
syntax to translate these columns back into properly-indexed variables in two different
tidy data frame formats, optionally recovering dimension types (e.g. factor levels) as it does so.
</p>
<p><code>spread_draws</code> and <code>gather_draws</code> return data frames already grouped by
all dimensions used on the variables you specify.
</p>
<p>The difference between <code>spread_draws</code> is that names of variables in the model will
be spread across the data frame as column names, whereas <code>gather_draws</code> will
gather variables into a single column named <code>".variable"</code> and place values of variables into a
column named <code>".value"</code>. To use naming schemes from other packages (such as <code>broom</code>), consider passing
results through functions like <code><a href="#topic+to_broom_names">to_broom_names()</a></code> or <code><a href="#topic+to_ggmcmc_names">to_ggmcmc_names()</a></code>.
</p>
<p>For example, <code>spread_draws(model, a[i], b[i,v])</code> might return a grouped
data frame (grouped by <code>i</code> and <code>v</code>), with:
</p>

<ul>
<li><p> column <code>".chain"</code>: the chain number. <code>NA</code> if not applicable to the model
type; this is typically only applicable to MCMC algorithms.
</p>
</li>
<li><p> column <code>".iteration"</code>: the iteration number. Guaranteed to be unique within-chain only.
<code>NA</code> if not applicable to the model type; this is typically only applicable to MCMC algorithms.
</p>
</li>
<li><p> column <code>".draw"</code>: a unique number for each draw from the posterior. Order is not
guaranteed to be meaningful.
</p>
</li>
<li><p> column <code>"i"</code>: value in <code>1:5</code>
</p>
</li>
<li><p> column <code>"v"</code>: value in <code>1:10</code>
</p>
</li>
<li><p> column <code>"a"</code>: value of <code>"a[i]"</code> for draw <code>".draw"</code>
</p>
</li>
<li><p> column <code>"b"</code>: value of <code>"b[i,v]"</code> for draw <code>".draw"</code>
</p>
</li></ul>

<p><code>gather_draws(model, a[i], b[i,v])</code> on the same model would return a grouped
data frame (grouped by <code>i</code> and <code>v</code>), with:
</p>

<ul>
<li><p> column <code>".chain"</code>: the chain number
</p>
</li>
<li><p> column <code>".iteration"</code>: the iteration number
</p>
</li>
<li><p> column <code>".draw"</code>: the draw number
</p>
</li>
<li><p> column <code>"i"</code>: value in <code>1:5</code>
</p>
</li>
<li><p> column <code>"v"</code>: value in <code>1:10</code>, or <code>NA</code>
if <code>".variable"</code> is <code>"a"</code>.
</p>
</li>
<li><p> column <code>".variable"</code>: value in <code>c("a", "b")</code>.
</p>
</li>
<li><p> column <code>".value"</code>: value of <code>"a[i]"</code> (when <code>".variable"</code> is <code>"a"</code>)
or <code>"b[i,v]"</code> (when <code>".variable"</code> is <code>"b"</code>) for draw <code>".draw"</code>
</p>
</li></ul>

<p><code>spread_draws</code> and <code>gather_draws</code> can use type information
applied to the <code>model</code> object by <code><a href="#topic+recover_types">recover_types()</a></code> to convert columns
back into their original types. This is particularly helpful if some of the dimensions in
your model were originally factors. For example, if the <code>v</code> dimension
in the original data frame <code>data</code> was a factor with levels <code>c("a","b","c")</code>,
then we could use <code>recover_types</code> before <code>spread_draws</code>:
</p>
<pre>model %&gt;%
 recover_types(data) 
 spread_draws(model, b[i,v])
</pre>
<p>Which would return the same data frame as above, except the <code>"v"</code> column
would be a value in <code>c("a","b","c")</code> instead of <code>1:3</code>.
</p>
<p>For variables that do not share the same subscripts (or share
some but not all subscripts), we can supply their specifications separately.
For example, if we have a variable <code>d[i]</code> with the same <code>i</code> subscript
as <code>b[i,v]</code>, and a variable <code>x</code> with no subscripts, we could do this:
</p>
<pre>spread_draws(model, x, d[i], b[i,v])</pre>
<p>Which is roughly equivalent to this:
</p>
<pre>spread_draws(model, x) %&gt;%
 inner_join(spread_draws(model, d[i])) %&gt;%
 inner_join(spread_draws(model, b[i,v])) %&gt;%
 group_by(i,v)
</pre>
<p>Similarly, this:
</p>
<pre>gather_draws(model, x, d[i], b[i,v])</pre>
<p>Is roughly equivalent to this:
</p>
<pre>bind_rows(
 gather_draws(model, x),
 gather_draws(model, d[i]),
 gather_draws(model, b[i,v])
)</pre>
<p>The <code>c</code> and <code>cbind</code> functions can be used to combine multiple variable names that have
the same dimensions. For example, if we have several variables with the same
subscripts <code>i</code> and <code>v</code>, we could do either of these:
</p>
<pre>spread_draws(model, c(w, x, y, z)[i,v])</pre>
<pre>spread_draws(model, cbind(w, x, y, z)[i,v])  # equivalent</pre>
<p>Each of which is roughly equivalent to this:
</p>
<pre>spread_draws(model, w[i,v], x[i,v], y[i,v], z[i,v])</pre>
<p>Besides being more compact, the <code>c()</code>-style syntax is currently also
faster (though that may change).
</p>
<p>Dimensions can be omitted from the resulting data frame by leaving their names
blank; e.g. <code>spread_draws(model, b[,v])</code> will omit the first dimension of
<code>b</code> from the output. This is useful if a dimension is known to contain all
the same value in a given model.
</p>
<p>The shorthand <code>..</code> can be used to specify one column that should be put
into a wide format and whose names will be the base variable name, plus a dot
(&quot;.&quot;), plus the value of the dimension at <code>..</code>. For example:
</p>
<p><code>spread_draws(model, b[i,..])</code> would return a grouped data frame
(grouped by <code>i</code>), with:
</p>

<ul>
<li><p> column <code>".chain"</code>: the chain number
</p>
</li>
<li><p> column <code>".iteration"</code>: the iteration number
</p>
</li>
<li><p> column <code>".draw"</code>: the draw number
</p>
</li>
<li><p> column <code>"i"</code>: value in <code>1:20</code>
</p>
</li>
<li><p> column <code>"b.1"</code>: value of <code>"b[i,1]"</code> for draw <code>".draw"</code>
</p>
</li>
<li><p> column <code>"b.2"</code>: value of <code>"b[i,2]"</code> for draw <code>".draw"</code>
</p>
</li>
<li><p> column <code>"b.3"</code>: value of <code>"b[i,3]"</code> for draw <code>".draw"</code>
</p>
</li></ul>

<p>An optional clause in the form <code style="white-space: pre;">&#8288;| wide_dimension&#8288;</code> can also be used to put
the data frame into a wide format based on <code>wide_dimension</code>. For example, this:
</p>
<pre>spread_draws(model, b[i,v] | v)</pre>
<p>is roughly equivalent to this:
</p>
<pre>spread_draws(model, b[i,v]) %&gt;% spread(v,b)</pre>
<p>The main difference between using the <code>|</code> syntax instead of the
<code>..</code> syntax is that the <code>|</code> syntax respects prototypes applied to
dimensions with <code><a href="#topic+recover_types">recover_types()</a></code>, and thus can be used to get
columns with nicer names. For example:
</p>
<div class="sourceCode"><pre>model %&gt;% recover_types(data) %&gt;% spread_draws(b[i,v] | v)
</pre></div>
<p>would return a grouped data frame
(grouped by <code>i</code>), with:
</p>

<ul>
<li><p> column <code>".chain"</code>: the chain number
</p>
</li>
<li><p> column <code>".iteration"</code>: the iteration number
</p>
</li>
<li><p> column <code>".draw"</code>: the draw number
</p>
</li>
<li><p> column <code>"i"</code>: value in <code>1:20</code>
</p>
</li>
<li><p> column <code>"a"</code>: value of <code>"b[i,1]"</code> for draw <code>".draw"</code>
</p>
</li>
<li><p> column <code>"b"</code>: value of <code>"b[i,2]"</code> for draw <code>".draw"</code>
</p>
</li>
<li><p> column <code>"c"</code>: value of <code>"b[i,3]"</code> for draw <code>".draw"</code>
</p>
</li></ul>

<p>The shorthand <code>.</code> can be used to specify columns that should be nested
into vectors, matrices, or n-dimensional arrays (depending on how many dimensions
are specified with <code>.</code>).
</p>
<p>For example, <code>spread_draws(model, a[.], b[.,.])</code> might return a
data frame, with:
</p>

<ul>
<li><p> column <code>".chain"</code>: the chain number.
</p>
</li>
<li><p> column <code>".iteration"</code>: the iteration number.
</p>
</li>
<li><p> column <code>".draw"</code>: a unique number for each draw from the posterior.
</p>
</li>
<li><p> column <code>"a"</code>: a list column of vectors.
</p>
</li>
<li><p> column <code>"b"</code>: a list column of matrices.
</p>
</li></ul>

<p>Ragged arrays are turned into non-ragged arrays with
missing entries given the value <code>NA</code>.
</p>
<p>Finally, variable names can be regular expressions by setting <code>regex = TRUE</code>; e.g.:
</p>
<pre>spread_draws(model, `b_.*`[i], regex = TRUE)</pre>
<p>Would return a tidy data frame with variables starting with <code>b_</code> and having one dimension.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread_rvars">spread_rvars()</a></code>, <code><a href="#topic+recover_types">recover_types()</a></code>, <code><a href="#topic+compose_data">compose_data()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(ggplot2)

data(RankCorr, package = "ggdist")

RankCorr %&gt;%
  spread_draws(b[i, j])

RankCorr %&gt;%
  spread_draws(b[i, j], tau[i], u_tau[i])


RankCorr %&gt;%
  gather_draws(b[i, j], tau[i], u_tau[i])

RankCorr %&gt;%
  gather_draws(tau[i], typical_r) %&gt;%
  median_qi()

</code></pre>

<hr>
<h2 id='gather_emmeans_draws'>Extract a tidy data frame of draws of posterior distributions of &quot;estimated marginal means&quot; (emmeans/lsmeans) from
a Bayesian model fit.</h2><span id='topic+gather_emmeans_draws'></span><span id='topic+gather_emmeans_draws.default'></span><span id='topic+gather_emmeans_draws.emm_list'></span>

<h3>Description</h3>

<p>Extract draws from the result of a call to <code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code> (formerly <code>lsmeans</code>)
or <code><a href="emmeans.html#topic+ref_grid">emmeans::ref_grid()</a></code> applied to a Bayesian model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_emmeans_draws(object, value = ".value", ...)

## Default S3 method:
gather_emmeans_draws(object, value = ".value", ...)

## S3 method for class 'emm_list'
gather_emmeans_draws(object, value = ".value", grid = ".grid", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_emmeans_draws_+3A_object">object</code></td>
<td>
<p>An <code>emmGrid</code> object such as returned by
<code><a href="emmeans.html#topic+ref_grid">emmeans::ref_grid()</a></code> or <code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code>.</p>
</td></tr>
<tr><td><code id="gather_emmeans_draws_+3A_value">value</code></td>
<td>
<p>The name of the output column to use to contain the values of draws. Defaults to <code>".value"</code>.</p>
</td></tr>
<tr><td><code id="gather_emmeans_draws_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying method for the type of object given.</p>
</td></tr>
<tr><td><code id="gather_emmeans_draws_+3A_grid">grid</code></td>
<td>
<p>If <code>object</code> is an <code><a href="emmeans.html#topic+emm_list-object">emmeans::emm_list()</a></code>, the name of the output column to use to contain the name of the
reference grid that a given row corresponds to. Defaults to <code>".grid"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code> provides a convenient syntax for generating draws from &quot;estimated marginal means&quot; from a model,
and can be applied to various Bayesian models, like <a href="rstanarm.html#topic+stanreg-objects">rstanarm::stanreg-objects</a> and
<code><a href="MCMCglmm.html#topic+MCMCglmm">MCMCglmm::MCMCglmm()</a></code>. Given a <code><a href="emmeans.html#topic+ref_grid">emmeans::ref_grid()</a></code> object as returned by functions like
<code><a href="emmeans.html#topic+ref_grid">emmeans::ref_grid()</a></code> or <code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code> applied to a Bayesian model,
<code>gather_emmeans_draws</code> returns a tidy format data frame of draws from
the marginal posterior distributions generated by <code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code>.
</p>


<h3>Value</h3>

<p>A tidy data frame of draws. The columns of the reference grid are returned as-is, with an
additional column called <code>.value</code> (by default) containing marginal draws. The resulting data
frame is grouped by the columns from the reference grid to make use of summary functions like
<code><a href="#topic+point_interval">point_interval()</a></code> straightforward.
</p>
<p>If <code>object</code> is an <code><a href="emmeans.html#topic+emm_list-object">emmeans::emm_list()</a></code>, which contains estimates from different reference grids,
an additional column with the default name of <code>".grid"</code> is added to indicate the reference grid for each row in the output.
The name of this column is controlled by the <code>grid</code> argument.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(dplyr)
library(magrittr)
library(brms)
library(emmeans)

# Here's an example dataset with a categorical predictor (`condition`) with several levels:
set.seed(5)
n = 10
n_condition = 5
ABC = tibble(
  condition = rep(c("A","B","C","D","E"), n),
  response = rnorm(n * 5, c(0,1,2,1,-1), 0.5)
)

m = brm(response ~ condition, data = ABC,
  # 1 chain / few iterations just so example runs quickly
  # do not use in practice
  chains = 1, iter = 500)

# Once we've fit the model, we can use emmeans() (and functions
# from that package) to get whatever marginal distributions we want.
# For example, we can get marginal means by condition:
m %&gt;%
  emmeans(~ condition) %&gt;%
  gather_emmeans_draws() %&gt;%
  median_qi()

# or we could get pairwise differences:
m %&gt;%
  emmeans(~ condition) %&gt;%
  contrast(method = "pairwise") %&gt;%
  gather_emmeans_draws() %&gt;%
  median_qi()

# see the documentation of emmeans() for more examples of types of
# contrasts supported by that packge.


## End(Not run)
</code></pre>

<hr>
<h2 id='gather_pairs'>Gather pairwise combinations of values from key/value columns in a long-format data frame</h2><span id='topic+gather_pairs'></span>

<h3>Description</h3>

<p>Fast method for producing combinations of values in a value column for different levels of a key column,
assuming long-format (tidy) data with an equal number of values per key. Among other things, this is
useful for producing scatter-plot matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_pairs(
  data,
  key,
  value,
  row = ".row",
  col = ".col",
  x = ".x",
  y = ".y",
  triangle = c("lower only", "upper only", "lower", "upper", "both only", "both")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_pairs_+3A_data">data</code></td>
<td>
<p>Tidy data frame.</p>
</td></tr>
<tr><td><code id="gather_pairs_+3A_key">key</code></td>
<td>
<p>Bare name of column in <code>data</code> containing the key .</p>
</td></tr>
<tr><td><code id="gather_pairs_+3A_value">value</code></td>
<td>
<p>Bare name of column in <code>data</code> containing the value.</p>
</td></tr>
<tr><td><code id="gather_pairs_+3A_row">row</code></td>
<td>
<p>Character vector giving the name of the output column identifying rows in the matrix
of pairs (takes values of <code>key</code>).</p>
</td></tr>
<tr><td><code id="gather_pairs_+3A_col">col</code></td>
<td>
<p>Character vector giving the name of the output column identifying columns in the matrix
of pairs (takes values of <code>key</code>).</p>
</td></tr>
<tr><td><code id="gather_pairs_+3A_x">x</code></td>
<td>
<p>Character vector giving the name of the output column with x values in the matrix
of pairs (takes values of <code>value</code>).</p>
</td></tr>
<tr><td><code id="gather_pairs_+3A_y">y</code></td>
<td>
<p>Character vector giving the name of the output column with y values in the matrix
of pairs (takes values of <code>value</code>).</p>
</td></tr>
<tr><td><code id="gather_pairs_+3A_triangle">triangle</code></td>
<td>
<p>Should the upper or lower triangle of the matrix of all possible combinations be returned?
The default, <code>"lower only"</code>, returns the lower triangle without the diagonal; <code>"lower"</code> returns
the lower triangle with the diagonal (<code>"upper"</code> and <code>"upper only"</code> operate analogously),
<code>"both"</code> returns the full set of possible combinations, and <code>"both only"</code> returns all
combinations except the diagonal.
</p>
<p>This method is particularly useful for constructing scatterplot matrices. See examples below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data frame of combinations of values in <code>key</code> and <code>value</code>, with columns <code>row</code>
and <code>col</code> (default names <code>".row"</code> and <code>".col"</code>) containing values from <code>key</code>,
and columns <code>y</code> and <code>x</code> (default names <code>".y"</code> and <code>".x"</code>) containing values
from <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ggplot2)
library(dplyr)

t_a = rnorm(100)
t_b = rnorm(100, t_a * 2)
t_c = rnorm(100)

df = rbind(
  data.frame(g = "a", t = t_a),
  data.frame(g = "b", t = t_b),
  data.frame(g = "c", t = t_c)
)

df %&gt;%
  gather_pairs(g, t, row = "g_row", col = "g_col", x = "t_x", y = "t_y") %&gt;%
  ggplot(aes(t_x, t_y)) +
  geom_point() +
  facet_grid(vars(g_row), vars(g_col))

df %&gt;%
  gather_pairs(g, t, triangle = "upper") %&gt;%
  ggplot(aes(.x, .y)) +
  geom_point() +
  facet_grid(vars(.row), vars(.col))

df %&gt;%
  gather_pairs(g, t, triangle = "both") %&gt;%
  ggplot(aes(.x, .y)) +
  geom_point() +
  facet_grid(vars(.row), vars(.col))

data(line, package = "coda")

line %&gt;%
  tidy_draws() %&gt;%
  gather_variables() %&gt;%
  gather_pairs(.variable, .value) %&gt;%
  ggplot(aes(.x, .y)) +
  geom_point(alpha = .25) +
  facet_grid(vars(.row), vars(.col))

line %&gt;%
  tidy_draws() %&gt;%
  gather_variables() %&gt;%
  gather_pairs(.variable, .value) %&gt;%
  ggplot(aes(.x, .y, color = factor(.chain))) +
  geom_density_2d(alpha = .5) +
  facet_grid(vars(.row), vars(.col))


</code></pre>

<hr>
<h2 id='gather_rvars'>Extract draws from a Bayesian model into tidy data frames of random variables</h2><span id='topic+gather_rvars'></span><span id='topic+spread_rvars'></span>

<h3>Description</h3>

<p>Extract draws from a Bayesian model for one or more variables (possibly with named
dimensions) into one of two types of long-format data frames of <a href="posterior.html#topic+rvar">posterior::rvar</a> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_rvars(model, ..., ndraws = NULL, seed = NULL)

spread_rvars(model, ..., ndraws = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_rvars_+3A_model">model</code></td>
<td>
<p>A supported Bayesian model fit. Tidybayes supports a variety of model objects;
for a full list of supported models, see <a href="#topic+tidybayes-models">tidybayes-models</a>.</p>
</td></tr>
<tr><td><code id="gather_rvars_+3A_...">...</code></td>
<td>
<p>Expressions in the form of
<code>variable_name[dimension_1, dimension_2, ...]</code>. See <em>Details</em>.</p>
</td></tr>
<tr><td><code id="gather_rvars_+3A_ndraws">ndraws</code></td>
<td>
<p>The number of draws to return, or <code>NULL</code> to return all draws.</p>
</td></tr>
<tr><td><code id="gather_rvars_+3A_seed">seed</code></td>
<td>
<p>A seed to use when subsampling draws (i.e. when <code>ndraws</code> is not <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imagine a JAGS or Stan fit named <code>model</code>. The model may contain a variable named
<code>b[i,v]</code> (in the JAGS or Stan language) with dimension <code>i</code> in <code>1:100</code> and
dimension <code>v</code> in <code>1:3</code>. However, the default format for draws returned from
JAGS or Stan in R will not reflect this indexing structure, instead
they will have multiple columns with names like <code>"b[1,1]"</code>, <code>"b[2,1]"</code>, etc.
</p>
<p><code>spread_rvars</code> and <code>gather_rvars</code> provide a straightforward
syntax to translate these columns back into properly-indexed <code><a href="posterior.html#topic+rvar">rvar</a></code>s in two different
tidy data frame formats, optionally recovering dimension types (e.g. factor levels) as it does so.
</p>
<p><code>spread_rvars</code> will spread names of variables in the model across the data frame as column names,
whereas <code>gather_rvars</code> will gather variable names into a single column named <code>".variable"</code> and place
values of variables into a column named <code>".value"</code>. To use naming schemes from other packages
(such as <code>broom</code>), consider passing
results through functions like <code><a href="#topic+to_broom_names">to_broom_names()</a></code> or <code><a href="#topic+to_ggmcmc_names">to_ggmcmc_names()</a></code>.
</p>
<p>For example, <code>spread_rvars(model, a[i], b[i,v])</code> might return a data frame with:
</p>

<ul>
<li><p> column <code>"i"</code>: value in <code>1:5</code>
</p>
</li>
<li><p> column <code>"v"</code>: value in <code>1:10</code>
</p>
</li>
<li><p> column <code>"a"</code>: <a href="posterior.html#topic+rvar">rvar</a> containing draws from <code>"a[i]"</code>
</p>
</li>
<li><p> column <code>"b"</code>: <a href="posterior.html#topic+rvar">rvar</a> containing draws from <code>"b[i,v]"</code>
</p>
</li></ul>

<p><code>gather_rvars(model, a[i], b[i,v])</code> on the same model would return a data frame with:
</p>

<ul>
<li><p> column <code>"i"</code>: value in <code>1:5</code>
</p>
</li>
<li><p> column <code>"v"</code>: value in <code>1:10</code>, or <code>NA</code>
on rows where <code>".variable"</code> is <code>"a"</code>.
</p>
</li>
<li><p> column <code>".variable"</code>: value in <code>c("a", "b")</code>.
</p>
</li>
<li><p> column <code>".value"</code>: <a href="posterior.html#topic+rvar">rvar</a> containing draws from <code>"a[i]"</code> (when <code>".variable"</code> is <code>"a"</code>)
or <code>"b[i,v]"</code> (when <code>".variable"</code> is <code>"b"</code>)
</p>
</li></ul>

<p><code>spread_rvars</code> and <code>gather_rvars</code> can use type information
applied to the <code>model</code> object by <code><a href="#topic+recover_types">recover_types()</a></code> to convert columns
back into their original types. This is particularly helpful if some of the dimensions in
your model were originally factors. For example, if the <code>v</code> dimension
in the original data frame <code>data</code> was a factor with levels <code>c("a","b","c")</code>,
then we could use <code>recover_types</code> before <code>spread_rvars</code>:
</p>
<pre>model %&gt;%
 recover_types(data) 
 spread_rvars(model, b[i,v])
</pre>
<p>Which would return the same data frame as above, except the <code>"v"</code> column
would be a value in <code>c("a","b","c")</code> instead of <code>1:3</code>.
</p>
<p>For variables that do not share the same subscripts (or share
some but not all subscripts), we can supply their specifications separately.
For example, if we have a variable <code>d[i]</code> with the same <code>i</code> subscript
as <code>b[i,v]</code>, and a variable <code>x</code> with no subscripts, we could do this:
</p>
<pre>spread_rvars(model, x, d[i], b[i,v])</pre>
<p>Which is roughly equivalent to this:
</p>
<pre>spread_rvars(model, x) %&gt;%
 inner_join(spread_rvars(model, d[i])) %&gt;%
 inner_join(spread_rvars(model, b[i,v]))
</pre>
<p>Similarly, this:
</p>
<pre>gather_rvars(model, x, d[i], b[i,v])</pre>
<p>Is roughly equivalent to this:
</p>
<pre>bind_rows(
 gather_rvars(model, x),
 gather_rvars(model, d[i]),
 gather_rvars(model, b[i,v])
)</pre>
<p>The <code>c</code> and <code>cbind</code> functions can be used to combine multiple variable names that have
the same dimensions. For example, if we have several variables with the same
subscripts <code>i</code> and <code>v</code>, we could do either of these:
</p>
<pre>spread_rvars(model, c(w, x, y, z)[i,v])</pre>
<pre>spread_rvars(model, cbind(w, x, y, z)[i,v])  # equivalent</pre>
<p>Each of which is roughly equivalent to this:
</p>
<pre>spread_rvars(model, w[i,v], x[i,v], y[i,v], z[i,v])</pre>
<p>Besides being more compact, the <code>c()</code>-style syntax is currently also slightly
faster (though that may change).
</p>
<p>Dimensions can be left nested in the resulting <a href="posterior.html#topic+rvar">rvar</a> objects by leaving their names
blank; e.g. <code>spread_rvars(model, b[i,])</code> will place the first index (<code>i</code>) into
rows of the data frame but leave the second index nested in the <code>b</code> column
(see <em>Examples</em> below).
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread_draws">spread_draws()</a></code>, <code><a href="#topic+recover_types">recover_types()</a></code>, <code><a href="#topic+compose_data">compose_data()</a></code>. See also
<code><a href="posterior.html#topic+rvar">posterior::rvar()</a></code> and <code><a href="posterior.html#topic+draws_rvars">posterior::as_draws_rvars()</a></code>, the functions that power
<code>spread_rvars</code> and <code>gather_rvars</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

data(RankCorr, package = "ggdist")

RankCorr %&gt;%
  spread_rvars(b[i, j])

# leaving an index out nests the index in the column containing the rvar
RankCorr %&gt;%
  spread_rvars(b[i, ])

RankCorr %&gt;%
  spread_rvars(b[i, j], tau[i], u_tau[i])

# gather_rvars places variables and values in a longer format data frame
RankCorr %&gt;%
  gather_rvars(b[i, j], tau[i], typical_r)

</code></pre>

<hr>
<h2 id='gather_variables'>Gather variables from a tidy data frame of draws from variables into a single column</h2><span id='topic+gather_variables'></span>

<h3>Description</h3>

<p>Given a data frame such as might be returned by <code><a href="#topic+tidy_draws">tidy_draws()</a></code> or <code><a href="#topic+spread_draws">spread_draws()</a></code>,
gather variables and their values from that data frame into a <code>".variable"</code> and <code>".value"</code> column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_variables(data, exclude = c(".chain", ".iteration", ".draw", ".row"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_variables_+3A_data">data</code></td>
<td>
<p>A data frame with variable names spread across columns, such as one returned by
<code><a href="#topic+tidy_draws">tidy_draws()</a></code> or <code><a href="#topic+spread_draws">spread_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="gather_variables_+3A_exclude">exclude</code></td>
<td>
<p>A character vector of names of columns to be excluded from the gather. Default
ignores several meta-data column names used in tidybayes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gathers every column except grouping columns and those matching the expression
<code>exclude</code> into key/value columns <code>".variable"</code> and <code>".value"</code>.
</p>
<p>Imagine a data frame <code>data</code> as returned by <code>spread_draws(fit, a[i], b[i,v])</code>, like this:
</p>

<ul>
<li><p> column <code>".chain"</code>: the chain number
</p>
</li>
<li><p> column <code>".iteration"</code>: the iteration number
</p>
</li>
<li><p> column <code>".draw"</code>: the draw number
</p>
</li>
<li><p> column <code>"i"</code>: value in <code>1:5</code>
</p>
</li>
<li><p> column <code>"v"</code>: value in <code>1:10</code>
</p>
</li>
<li><p> column <code>"a"</code>: value of <code>"a[i]"</code> for draw number <code>".draw"</code>
</p>
</li>
<li><p> column <code>"b"</code>: value of <code>"b[i,v]"</code> for draw number <code>".draw"</code>
</p>
</li></ul>

<p><code>gather_variables(data)</code> on that data frame would return a grouped
data frame (grouped by <code>i</code> and <code>v</code>), with:
</p>

<ul>
<li><p> column <code>".chain"</code>: the chain number
</p>
</li>
<li><p> column <code>".iteration"</code>: the iteration number
</p>
</li>
<li><p> column <code>".draw"</code>: the draw number
</p>
</li>
<li><p> column <code>"i"</code>: value in <code>1:5</code>
</p>
</li>
<li><p> column <code>"v"</code>: value in <code>1:10</code>
</p>
</li>
<li><p> column <code>".variable"</code>: value in <code>c("a", "b")</code>.
</p>
</li>
<li><p> column <code>".value"</code>: value of <code>"a[i]"</code> (when <code>".variable"</code> is <code>"a"</code>;
repeated for every value of <code>"v"</code>) or <code>"b[i,v]"</code> (when <code>".variable"</code> is
<code>"b"</code>) for draw number <code>".draw"</code>
</p>
</li></ul>

<p>In this example, this call:
</p>
<pre>gather_variables(data)</pre>
<p>Is roughly equivalent to:
</p>
<pre>data %&gt;%
  gather(.variable, .value, -c(.chain, .iteration, .draw, i, v)) %&gt;%
  group_by(.variable, .add = TRUE)
</pre>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread_draws">spread_draws()</a></code>, <code><a href="#topic+tidy_draws">tidy_draws()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(dplyr)

data(RankCorr, package = "ggdist")

RankCorr %&gt;%
  spread_draws(b[i,v], tau[i]) %&gt;%
  gather_variables() %&gt;%
  median_qi()

# the first three lines below are roughly equivalent to ggmcmc::ggs(RankCorr)
RankCorr %&gt;%
  tidy_draws() %&gt;%
  gather_variables() %&gt;%
  median_qi()


</code></pre>

<hr>
<h2 id='get_variables'>Get the names of the variables in a fitted Bayesian model</h2><span id='topic+get_variables'></span><span id='topic+get_variables.default'></span><span id='topic+get_variables.mcmc'></span><span id='topic+get_variables.mcmc.list'></span>

<h3>Description</h3>

<p>Get a character vector of the names of the variables in a variety of fitted
Bayesian model types. All models supported by <code><a href="#topic+tidy_draws">tidy_draws()</a></code> are
supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_variables(model)

## Default S3 method:
get_variables(model)

## S3 method for class 'mcmc'
get_variables(model)

## S3 method for class 'mcmc.list'
get_variables(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_variables_+3A_model">model</code></td>
<td>
<p>A supported Bayesian model fit. Tidybayes supports a variety of model objects;
for a full list of supported models, see <a href="#topic+tidybayes-models">tidybayes-models</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is often useful for inspecting a model interactively in order
to construct calls to <code><a href="#topic+spread_draws">spread_draws()</a></code> or <code><a href="#topic+gather_draws">gather_draws()</a></code>
in order to extract draws from models in a tidy format.
</p>


<h3>Value</h3>

<p>A character vector of variable names in the fitted model.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread_draws">spread_draws()</a></code>, <code><a href="#topic+gather_draws">gather_draws()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(line, package = "coda")
get_variables(line)

data(RankCorr, package = "ggdist")
get_variables(RankCorr)

</code></pre>

<hr>
<h2 id='n_prefix'>Prefix function generator for composing dimension index columns</h2><span id='topic+n_prefix'></span>

<h3>Description</h3>

<p>Generates a function for generating names of index columns for factors in
<code><a href="#topic+compose_data">compose_data()</a></code> by prefixing a character vector to the original
column name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_prefix(prefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_prefix_+3A_prefix">prefix</code></td>
<td>
<p>Character vector to be prepended to column names by
<code><a href="#topic+compose_data">compose_data()</a></code> to create index columns. Typically something
like <code>"n"</code> (that is the default used in the <code>.n_name</code> argument
of <code><a href="#topic+compose_data">compose_data()</a></code>).
</p>
<p>Returns a function. The function returned takes a character vector, <code>name</code>
and returns <code>paste0(prefix, "_", name)</code>, unless <code>name</code> is empty, in
which case it will return <code>prefix</code>.
</p>
<p><code>n_prefix("n")</code> is the default method that <code><a href="#topic+compose_data">compose_data()</a></code> uses to
generate column names for variables storing the number of levels in a factor. Under
this method, given a data frame
<code>df</code> with a factor column <code>"foo"</code> containing 5 levels, the results of
<code>compose_data(df)</code> will include an element named <code>"n"</code> (the result of
<code>n_prefix("n")("")</code>) equal to the number of rows in <code>df</code> and an element
named <code>"n_foo"</code> (the result of <code>n_prefix("n")("foo")</code>) equal to the
number of levels in <code>df$foo</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The <code>.n_name</code> argument of <code><a href="#topic+compose_data">compose_data()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(magrittr)

df = data.frame(
  plot = factor(paste0("p", rep(1:8, times = 2))),
  site = factor(paste0("s", rep(1:4, each = 2, times = 2)))
)

# without changing `.n_name`, compose_data() will prefix indices
# with "n" by default
df %&gt;%
  compose_data()

# you can use n_prefix() to define a different prefix (e.g. "N"):
df %&gt;%
  compose_data(.n_name = n_prefix("N"))

</code></pre>

<hr>
<h2 id='nest_rvars'>Nest and unnest <code>rvar</code> columns in data frames</h2><span id='topic+nest_rvars'></span><span id='topic+unnest_rvars'></span>

<h3>Description</h3>

<p>Converts between data-frame-of-<code>rvar</code>s format and long-data-frame-of-draws
formats by nesting or unnesting all columns containing <code><a href="posterior.html#topic+rvar">posterior::rvar</a></code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_rvars(data)

unnest_rvars(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_rvars_+3A_data">data</code></td>
<td>
<p>A data frame to nest or unnest.
</p>

<ul>
<li><p> For <code>nest_rvars()</code>, the data frame should be in long-data-frame-of-draws
format; i.e. it should contain a <code>.draw</code> column (and optionally <code>.chain</code>
and <code>.iteration</code> columns) indexing draws. It should be a grouped by any
columns that are not intended to be nested.
</p>
</li>
<li><p> For <code>unnest_rvars()</code>, the data frame should have at least one column that
is an <code><a href="posterior.html#topic+rvar">rvar</a></code>; all <code>rvar</code> columns will be unnested.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>nest_rvars()</code>, returns a data frame without <code>.chain</code>, <code>.iteration</code>, and
<code>.draw</code> columns, where all non-grouped columns have been converted to <code><a href="posterior.html#topic+rvar">rvar</a></code>s.
</p>
<p>For <code>unnest_rvars()</code>, returns a data frame with <code>.chain</code>, <code>.iteration</code>, and
<code>.draw</code> columns added, where every <code><a href="posterior.html#topic+rvar">rvar</a></code> column in the input has been
converted to (one or more) columns containing draws from those <code><a href="posterior.html#topic+rvar">rvar</a></code>s
in long format. The result is grouped by all non-<code><a href="posterior.html#topic+rvar">rvar</a></code> columns in the
input; this ensures that <code>nest_rvars(unnest_rvars(x))</code> returns <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

data(RankCorr, package = "ggdist")

# here's a data frame with some rvars
rvar_df = RankCorr %&gt;%
  spread_rvars(b[i,], tau[i])
rvar_df

# we can unnest it into long format.
# note how the result is grouped by all non-rvar input columns,
# and nested indices in `b` are converted into columns.
draws_df = rvar_df %&gt;%
  unnest_rvars()
draws_df

# calling nest_rvars() again on the result of unnest_rvars()
# recovers the original data frame
nest_rvars(draws_df)

</code></pre>

<hr>
<h2 id='predict_curve'>Deprecated: Prediction curves for arbitrary functions of posteriors</h2><span id='topic+predict_curve'></span><span id='topic+predict_curve_density'></span>

<h3>Description</h3>

<p>Deprecated function for generating prediction curves (or a density for a
prediction curve).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_curve(data, formula, summary = median, ...)

predict_curve_density(
  data,
  formula,
  summary = function(...) density_bins(..., n = n),
  n = 50,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_curve_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, <a href="dplyr.html#topic+tbl_df">tbl_df</a> or
<a href="dplyr.html#topic+grouped_df">grouped_df</a> representing posteriors from a Bayesian model as
might be obtained through <code><a href="#topic+spread_draws">spread_draws()</a></code>. Grouped data frames
as returned by <code><a href="dplyr.html#topic+group_by">group_by()</a></code> are supported.</p>
</td></tr>
<tr><td><code id="predict_curve_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the prediction curve. The left-hand side
of the formula should be a name representing the name of the column that
will hold the predicted response in the returned data frame. The right-hand
side is an expression that may include numeric columns from <code>data</code> and
variables passed into this function in <code>...</code>.</p>
</td></tr>
<tr><td><code id="predict_curve_+3A_summary">summary</code></td>
<td>
<p>The function to apply to summarize each predicted response.
Useful functions (if you just want a curve) might be <code><a href="stats.html#topic+median">median()</a></code>,
<code><a href="base.html#topic+mean">mean()</a></code>, or <code><a href="#topic+Mode">Mode()</a></code>. If you want predictive distribution
at each point on the curve, try <code><a href="#topic+density_bins">density_bins()</a></code> or
<code><a href="#topic+histogram_bins">histogram_bins()</a></code>.</p>
</td></tr>
<tr><td><code id="predict_curve_+3A_...">...</code></td>
<td>
<p>Variables defining the curve. The right-hand side of
<code>formula</code> is evaluated for every combination of values of variables in
<code>...</code>.</p>
</td></tr>
<tr><td><code id="predict_curve_+3A_n">n</code></td>
<td>
<p>For <code>predict_curve_density</code>, the number of bins to use to
represent the distribution at each point on the curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>This function is deprecated.</strong> Use <code><a href="modelr.html#topic+data_grid">modelr::data_grid()</a></code> combined
with <code><a href="#topic+point_interval">point_interval()</a></code> or <code><a href="dplyr.html#topic+do">dplyr::do()</a></code> and
<code><a href="#topic+density_bins">density_bins()</a></code> instead.
</p>
<p>The function generates a predictive curve given posterior draws
(<code>data</code>), an expression (<code>formula</code>), and a set of variables
defining the curve (<code>...</code>). For every group in <code>data</code> (if it is a
grouped data frame&mdash;see <code><a href="dplyr.html#topic+group_by">group_by()</a></code>; otherwise the entire data
frame is taken at once), and for each combination of values in <code>...</code>,
the right-hand side of <code>formula</code> is evaluated and its results passed to
the <code>summary</code> function. This allows a predictive curve to be generated,
given (e.g.) some samples of coefficients in <code>data</code> and a set of
predictors defining the space of the curve in <code>...</code>.
</p>
<p>Given a summary function like <code><a href="stats.html#topic+median">median()</a></code> or <code><a href="base.html#topic+mean">mean()</a></code>,
this function will produce the median (resp. mean) prediction at each point
on the curve.
</p>
<p>Given a summary function like <code><a href="#topic+density_bins">density_bins()</a></code>, this function will
produce a predictive distribution for each point on the curve.
<code>predict_curve_density</code> is a shorthand for such a call, with a
convenient argument for adjusting the number of bins per point on the
curve.
</p>


<h3>Value</h3>

<p>If <code>formula</code> is in the form <code>lhs ~ rhs</code> and <code>summary</code>
is a function that returns a single value, such as <code>median</code> or
<code>mode</code>, then <code>predict_curve</code> returns a <code>data.frame</code> with a
column for each group in <code>data</code> (if it was grouped), a column for each
variable in <code>...</code>, and a column named <code>lhs</code> with the value of
<code>summary(rhs)</code> evaluated for every group in <code>data</code> and combination
of variables in <code>...</code>.
</p>
<p>If <code>summary</code> is a function that returns a <code>data.frame</code>, such as
<code><a href="#topic+density_bins">density_bins()</a></code>, <code>predict_curve</code> has the same set of columns
as above, except that in place of the <code>lhs</code> column is a set of columns
named <code>lhs.x</code> for every column named <code>x</code> returned by
<code>summary</code>. For example, <code><a href="#topic+density_bins">density_bins()</a></code> returns a data frame
with the columns <code>mid</code>, <code>lower</code>, <code>upper</code>, and <code>density</code>,
so the data frame returned by <code>predict_curve</code> with <code>summary = density_bins</code> will have columns <code>lhs.mid</code>, <code>lhs.lower</code>,
<code>lhs.upper</code>, and <code>lhs.density</code> in place of <code>lhs</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+density_bins">density_bins()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Deprecated; see examples for density_bins

</code></pre>

<hr>
<h2 id='recover_types'>Decorate a model fit or sample with data types recovered from the input data</h2><span id='topic+recover_types'></span><span id='topic+apply_prototypes'></span>

<h3>Description</h3>

<p>Decorate a Bayesian model fit or a sample from it with types for
variable and dimension data types. Meant to be used before calling
<code><a href="#topic+spread_draws">spread_draws()</a></code> or <code><a href="#topic+gather_draws">gather_draws()</a></code> so that the values returned by
those functions are translated back into useful data types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recover_types(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recover_types_+3A_model">model</code></td>
<td>
<p>A supported Bayesian model fit. Tidybayes supports a variety of model objects;
for a full list of supported models, see <a href="#topic+tidybayes-models">tidybayes-models</a>.</p>
</td></tr>
<tr><td><code id="recover_types_+3A_...">...</code></td>
<td>
<p>Lists (or data frames) providing data prototypes used to convert
columns returned by <code><a href="#topic+spread_draws">spread_draws()</a></code> and <code><a href="#topic+gather_draws">gather_draws()</a></code> back into useful data types.
See <em>Details</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each argument in <code>...</code> specifies a list or data.frame. The <code>model</code>
is decorated with a list of constructors that can convert a numeric column
into the data types in the lists in <code>...</code>.
</p>
<p>Then, when <code><a href="#topic+spread_draws">spread_draws()</a></code> or <code><a href="#topic+gather_draws">gather_draws()</a></code> is called on the decorated
<code>model</code>, each list entry with the same name as the variable or a dimension
in <code>variable_spec</code> is a used as a prototype for that variable or dimension &mdash;
i.e., its type is taken to be the expected type of that variable or dimension.
Those types are used to translate numeric values of variables back into
useful values (for example, levels of a factor).
</p>
<p>The most common use of <code>recover_types</code> is to automatically translate
dimensions of a variable that correspond to levels of a factor in the original data back into
levels of that factor. The simplest way to do this is to pass in the data
frame from which the original data came.
</p>
<p>Supported types of prototypes are factor, ordered, and logical. For example:
</p>
 <ul>
<li><p> if <code>prototypes$v</code> is a factor, the v column in the
returned draws is translated into a factor using <code>factor(v, labels=levels(prototypes$v), ordered=is.ordered(prototypes$v))</code>.  </p>
</li>
<li><p> if
<code>prototypes$v</code> is a logical, the v column is translated into a logical
using <code>as.logical(v)</code>. </p>
</li></ul>

<p>Additional data types can be supported by providing a custom implementation
of the generic function <code>as_constructor</code>.
</p>


<h3>Value</h3>

<p>A decorated version of <code>model</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread_draws">spread_draws()</a></code>, <code><a href="#topic+gather_draws">gather_draws()</a></code>, <code><a href="#topic+compose_data">compose_data()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(dplyr)
library(magrittr)
library(rstan)

# Here's an example dataset with a categorical predictor (`condition`) with several levels:
set.seed(5)
n = 10
n_condition = 5
ABC = tibble(
  condition = factor(rep(c("A","B","C","D","E"), n)),
  response = rnorm(n * 5, c(0,1,2,1,-1), 0.5)
)

# We'll fit the following model to it:
stan_code = "
  data {
    int&lt;lower=1&gt; n;
    int&lt;lower=1&gt; n_condition;
    int&lt;lower=1, upper=n_condition&gt; condition[n];
    real response[n];
  }
  parameters {
    real overall_mean;
    vector[n_condition] condition_zoffset;
    real&lt;lower=0&gt; response_sd;
    real&lt;lower=0&gt; condition_mean_sd;
  }
  transformed parameters {
    vector[n_condition] condition_mean;
    condition_mean = overall_mean + condition_zoffset * condition_mean_sd;
  }
  model {
    response_sd ~ cauchy(0, 1);       // =&gt; half-cauchy(0, 1)
    condition_mean_sd ~ cauchy(0, 1); // =&gt; half-cauchy(0, 1)
    overall_mean ~ normal(0, 5);

    //=&gt; condition_mean ~ normal(overall_mean, condition_mean_sd)
    condition_zoffset ~ normal(0, 1);

    for (i in 1:n) {
      response[i] ~ normal(condition_mean[condition[i]], response_sd);
    }
  }
"

m = stan(model_code = stan_code, data = compose_data(ABC), control = list(adapt_delta=0.99),
  # 1 chain / few iterations just so example runs quickly
  # do not use in practice
  chains = 1, iter = 500)

# without using recover_types(), the `condition` column returned by spread_draws()
# will be an integer:
m %&gt;%
  spread_draws(condition_mean[condition]) %&gt;%
  median_qi()

# If we apply recover_types() first, subsequent calls to other tidybayes functions will
# automatically back-convert factors so that they are labeled with their original levels
# (assuming the same name is used)
m %&lt;&gt;% recover_types(ABC)

# now the `condition` column with be a factor with levels "A", "B", "C", ...
m %&gt;%
  spread_draws(condition_mean[condition]) %&gt;%
  median_qi()


## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+curve_interval'></span><span id='topic+cut_cdf_qi'></span><span id='topic+geom_slabinterval'></span><span id='topic+GeomSlabinterval'></span><span id='topic+geom_slab'></span><span id='topic+GeomSlab'></span><span id='topic+geom_dotsinterval'></span><span id='topic+GeomDotsinterval'></span><span id='topic+geom_dots'></span><span id='topic+GeomDots'></span><span id='topic+geom_interval'></span><span id='topic+GeomInterval'></span><span id='topic+geom_lineribbon'></span><span id='topic+GeomLineribbon'></span><span id='topic+geom_pointinterval'></span><span id='topic+GeomPointinterval'></span><span id='topic+dlkjcorr_marginal'></span><span id='topic+plkjcorr_marginal'></span><span id='topic+qlkjcorr_marginal'></span><span id='topic+rlkjcorr_marginal'></span><span id='topic+marginalize_lkjcorr'></span><span id='topic+parse_dist'></span><span id='topic+r_dist_name'></span><span id='topic+scale_point_colour_discrete'></span><span id='topic+scale_point_color_discrete'></span><span id='topic+scale_point_colour_continuous'></span><span id='topic+scale_point_color_continuous'></span><span id='topic+scale_point_fill_discrete'></span><span id='topic+scale_point_fill_continuous'></span><span id='topic+scale_point_alpha_continuous'></span><span id='topic+scale_point_alpha_discrete'></span><span id='topic+scale_point_size_continuous'></span><span id='topic+scale_point_size_discrete'></span><span id='topic+scale_interval_colour_discrete'></span><span id='topic+scale_interval_color_discrete'></span><span id='topic+scale_interval_colour_continuous'></span><span id='topic+scale_interval_color_continuous'></span><span id='topic+scale_interval_alpha_continuous'></span><span id='topic+scale_interval_alpha_discrete'></span><span id='topic+scale_interval_size_continuous'></span><span id='topic+scale_interval_size_discrete'></span><span id='topic+scale_interval_linetype_discrete'></span><span id='topic+scale_interval_linetype_continuous'></span><span id='topic+scale_slab_colour_discrete'></span><span id='topic+scale_slab_color_discrete'></span><span id='topic+scale_slab_colour_continuous'></span><span id='topic+scale_slab_color_continuous'></span><span id='topic+scale_slab_fill_discrete'></span><span id='topic+scale_slab_fill_continuous'></span><span id='topic+scale_slab_alpha_continuous'></span><span id='topic+scale_slab_alpha_discrete'></span><span id='topic+scale_slab_size_continuous'></span><span id='topic+scale_slab_size_discrete'></span><span id='topic+scale_slab_linetype_discrete'></span><span id='topic+scale_slab_linetype_continuous'></span><span id='topic+scale_slab_shape_discrete'></span><span id='topic+scale_slab_shape_continuous'></span><span id='topic+guide_colourbar2'></span><span id='topic+guide_colorbar2'></span><span id='topic+stat_slabinterval'></span><span id='topic+StatSlabinterval'></span><span id='topic+stat_dist_slabinterval'></span><span id='topic+StatDistSlabinterval'></span><span id='topic+stat_dist_halfeye'></span><span id='topic+stat_dist_eye'></span><span id='topic+stat_dist_ccdfinterval'></span><span id='topic+stat_dist_cdfinterval'></span><span id='topic+stat_dist_gradientinterval'></span><span id='topic+stat_dist_pointinterval'></span><span id='topic+stat_dist_interval'></span><span id='topic+stat_dist_slab'></span><span id='topic+stat_sample_slabinterval'></span><span id='topic+StatSampleSlabinterval'></span><span id='topic+stat_halfeye'></span><span id='topic+stat_eye'></span><span id='topic+stat_ccdfinterval'></span><span id='topic+stat_cdfinterval'></span><span id='topic+stat_gradientinterval'></span><span id='topic+stat_histinterval'></span><span id='topic+stat_slab'></span><span id='topic+stat_dotsinterval'></span><span id='topic+stat_dots'></span><span id='topic+stat_dist_dotsinterval'></span><span id='topic+stat_dist_dots'></span><span id='topic+stat_pointinterval'></span><span id='topic+StatPointinterval'></span><span id='topic+stat_interval'></span><span id='topic+StatInterval'></span><span id='topic+stat_lineribbon'></span><span id='topic+stat_dist_lineribbon'></span><span id='topic+dstudent_t'></span><span id='topic+pstudent_t'></span><span id='topic+qstudent_t'></span><span id='topic+rstudent_t'></span><span id='topic+theme_ggdist'></span><span id='topic+theme_tidybayes'></span><span id='topic+facet_title_left_horizontal'></span><span id='topic+facet_title_right_horizontal'></span><span id='topic+axis_titles_bottom_left'></span><span id='topic+to_broom_names'></span><span id='topic+from_broom_names'></span><span id='topic+to_ggmcmc_names'></span><span id='topic+from_ggmcmc_names'></span><span id='topic+point_interval'></span><span id='topic+qi'></span><span id='topic+hdi'></span><span id='topic+Mode'></span><span id='topic+hdci'></span><span id='topic+mean_qi'></span><span id='topic+median_qi'></span><span id='topic+mode_qi'></span><span id='topic+mean_hdi'></span><span id='topic+median_hdi'></span><span id='topic+mode_hdi'></span><span id='topic+mean_hdci'></span><span id='topic+median_hdci'></span><span id='topic+mode_hdci'></span><span id='topic+summarise_draws'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>ggdist</dt><dd><p><code><a href="ggdist.html#topic+theme_ggdist">axis_titles_bottom_left</a></code>, <code><a href="ggdist.html#topic+curve_interval">curve_interval</a></code>, <code><a href="ggdist.html#topic+cut_cdf_qi">cut_cdf_qi</a></code>, <code><a href="ggdist.html#topic+lkjcorr_marginal">dlkjcorr_marginal</a></code>, <code><a href="ggdist.html#topic+student_t">dstudent_t</a></code>, <code><a href="ggdist.html#topic+theme_ggdist">facet_title_left_horizontal</a></code>, <code><a href="ggdist.html#topic+theme_ggdist">facet_title_right_horizontal</a></code>, <code><a href="ggdist.html#topic+tidy-format-translators">from_broom_names</a></code>, <code><a href="ggdist.html#topic+tidy-format-translators">from_ggmcmc_names</a></code>, <code><a href="ggdist.html#topic+geom_dots">geom_dots</a></code>, <code><a href="ggdist.html#topic+geom_dotsinterval">geom_dotsinterval</a></code>, <code><a href="ggdist.html#topic+geom_interval">geom_interval</a></code>, <code><a href="ggdist.html#topic+geom_lineribbon">geom_lineribbon</a></code>, <code><a href="ggdist.html#topic+geom_pointinterval">geom_pointinterval</a></code>, <code><a href="ggdist.html#topic+geom_slab">geom_slab</a></code>, <code><a href="ggdist.html#topic+geom_slabinterval">geom_slabinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-ggproto">GeomDots</a></code>, <code><a href="ggdist.html#topic+ggdist-ggproto">GeomDotsinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-ggproto">GeomInterval</a></code>, <code><a href="ggdist.html#topic+ggdist-ggproto">GeomLineribbon</a></code>, <code><a href="ggdist.html#topic+ggdist-ggproto">GeomPointinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-ggproto">GeomSlab</a></code>, <code><a href="ggdist.html#topic+ggdist-ggproto">GeomSlabinterval</a></code>, <code><a href="ggdist.html#topic+scales">guide_colorbar2</a></code>, <code><a href="ggdist.html#topic+scales">guide_colourbar2</a></code>, <code><a href="ggdist.html#topic+point_interval">hdci</a></code>, <code><a href="ggdist.html#topic+point_interval">hdi</a></code>, <code><a href="ggdist.html#topic+marginalize_lkjcorr">marginalize_lkjcorr</a></code>, <code><a href="ggdist.html#topic+point_interval">mean_hdci</a></code>, <code><a href="ggdist.html#topic+point_interval">mean_hdi</a></code>, <code><a href="ggdist.html#topic+point_interval">mean_qi</a></code>, <code><a href="ggdist.html#topic+point_interval">median_hdci</a></code>, <code><a href="ggdist.html#topic+point_interval">median_hdi</a></code>, <code><a href="ggdist.html#topic+point_interval">median_qi</a></code>, <code><a href="ggdist.html#topic+point_interval">Mode</a></code>, <code><a href="ggdist.html#topic+point_interval">mode_hdci</a></code>, <code><a href="ggdist.html#topic+point_interval">mode_hdi</a></code>, <code><a href="ggdist.html#topic+point_interval">mode_qi</a></code>, <code><a href="ggdist.html#topic+parse_dist">parse_dist</a></code>, <code><a href="ggdist.html#topic+lkjcorr_marginal">plkjcorr_marginal</a></code>, <code><a href="ggdist.html#topic+point_interval">point_interval</a></code>, <code><a href="ggdist.html#topic+student_t">pstudent_t</a></code>, <code><a href="ggdist.html#topic+point_interval">qi</a></code>, <code><a href="ggdist.html#topic+lkjcorr_marginal">qlkjcorr_marginal</a></code>, <code><a href="ggdist.html#topic+student_t">qstudent_t</a></code>, <code><a href="ggdist.html#topic+parse_dist">r_dist_name</a></code>, <code><a href="ggdist.html#topic+lkjcorr_marginal">rlkjcorr_marginal</a></code>, <code><a href="ggdist.html#topic+student_t">rstudent_t</a></code>, <code><a href="ggdist.html#topic+scales">scale_interval_alpha_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_interval_alpha_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_interval_color_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_interval_color_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_interval_colour_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_interval_colour_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_interval_linetype_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_interval_linetype_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_interval_size_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_interval_size_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_point_alpha_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_point_alpha_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_point_color_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_point_color_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_point_colour_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_point_colour_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_point_fill_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_point_fill_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_point_size_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_point_size_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_alpha_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_alpha_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_color_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_color_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_colour_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_colour_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_fill_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_fill_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_linetype_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_linetype_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_shape_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_shape_discrete</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_size_continuous</a></code>, <code><a href="ggdist.html#topic+scales">scale_slab_size_discrete</a></code>, <code><a href="ggdist.html#topic+stat_ccdfinterval">stat_ccdfinterval</a></code>, <code><a href="ggdist.html#topic+stat_cdfinterval">stat_cdfinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_dist_ccdfinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_dist_cdfinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_dist_dots</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_dist_dotsinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_dist_eye</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_dist_gradientinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_dist_halfeye</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_dist_interval</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_dist_lineribbon</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_dist_pointinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_dist_slab</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_dist_slabinterval</a></code>, <code><a href="ggdist.html#topic+stat_dots">stat_dots</a></code>, <code><a href="ggdist.html#topic+stat_dotsinterval">stat_dotsinterval</a></code>, <code><a href="ggdist.html#topic+stat_eye">stat_eye</a></code>, <code><a href="ggdist.html#topic+stat_gradientinterval">stat_gradientinterval</a></code>, <code><a href="ggdist.html#topic+stat_halfeye">stat_halfeye</a></code>, <code><a href="ggdist.html#topic+stat_histinterval">stat_histinterval</a></code>, <code><a href="ggdist.html#topic+stat_interval">stat_interval</a></code>, <code><a href="ggdist.html#topic+stat_lineribbon">stat_lineribbon</a></code>, <code><a href="ggdist.html#topic+stat_pointinterval">stat_pointinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">stat_sample_slabinterval</a></code>, <code><a href="ggdist.html#topic+stat_slab">stat_slab</a></code>, <code><a href="ggdist.html#topic+stat_slabinterval">stat_slabinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">StatDistSlabinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-ggproto">StatInterval</a></code>, <code><a href="ggdist.html#topic+ggdist-ggproto">StatPointinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-deprecated">StatSampleSlabinterval</a></code>, <code><a href="ggdist.html#topic+ggdist-ggproto">StatSlabinterval</a></code>, <code><a href="ggdist.html#topic+theme_ggdist">theme_ggdist</a></code>, <code><a href="ggdist.html#topic+theme_ggdist">theme_tidybayes</a></code>, <code><a href="ggdist.html#topic+tidy-format-translators">to_broom_names</a></code>, <code><a href="ggdist.html#topic+tidy-format-translators">to_ggmcmc_names</a></code></p>
</dd>
<dt>posterior</dt><dd><p><code><a href="posterior.html#topic+draws_summary">summarise_draws</a></code></p>
</dd>
</dl>

<hr>
<h2 id='sample_draws'>Sample draws from a tidy-format data frame of draws</h2><span id='topic+sample_draws'></span>

<h3>Description</h3>

<p>Given a tidy-format data frame of draws with a column indexing each draw, subsample the data frame to a given size
based on a column indexing draws, ensuring that rows in sub-groups of a grouped data frame are sampled from the
same draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_draws(data, ndraws, draw = ".draw", seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_draws_+3A_data">data</code></td>
<td>
<p>Data frame to sample from</p>
</td></tr>
<tr><td><code id="sample_draws_+3A_ndraws">ndraws</code></td>
<td>
<p>The number of draws to return, or <code>NULL</code> to return all draws.</p>
</td></tr>
<tr><td><code id="sample_draws_+3A_draw">draw</code></td>
<td>
<p>The name of the column indexing the draws; default <code>".draw"</code>.</p>
</td></tr>
<tr><td><code id="sample_draws_+3A_seed">seed</code></td>
<td>
<p>A seed to use when subsampling draws (i.e. when <code>ndraws</code> is not <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sample_draws()</code> makes it easier to sub-sample a grouped, tidy-format data frame of draws. On a grouped data frame,
the naive approach of using <code>filter</code> with the <code>.draw</code> column will give incorrect results as it will
select a different sample within each group. <code>sample_draws()</code> ensures the same sample is selected within
each group.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(ggplot2)
library(dplyr)
library(brms)
library(modelr)

theme_set(theme_light())

m_mpg = brm(mpg ~ hp * cyl, data = mtcars,
  # 1 chain / few iterations just so example runs quickly
  # do not use in practice
  chains = 1, iter = 500)

# draw 100 fit lines from the posterior and overplot them
mtcars %&gt;%
  group_by(cyl) %&gt;%
  data_grid(hp = seq_range(hp, n = 101)) %&gt;%
  add_epred_draws(m_mpg) %&gt;%
  # NOTE: only use sample_draws here when making spaghetti plots; for
  # plotting intervals it is always best to use all draws
  sample_draws(100) %&gt;%
  ggplot(aes(x = hp, y = mpg, color = ordered(cyl))) +
  geom_line(aes(y = .epred, group = paste(cyl, .draw)), alpha = 0.25) +
  geom_point(data = mtcars)


## End(Not run)
</code></pre>

<hr>
<h2 id='summarise_draws.grouped_df'>Summaries of draws in <code>grouped_df</code> objects</h2><span id='topic+summarise_draws.grouped_df'></span>

<h3>Description</h3>

<p>An implementation of <code>posterior::summarise_draws()</code> for grouped data frames
(<code>dplyr::grouped_df</code> objects) such as returned by <code>dplyr::group_by()</code> and
the various grouped-data-aware functions in tidybayes, such as <code>spread_draws()</code>,
<code>gather_draws()</code>, <code>add_epred_draws()</code>, and <code>add_predicted_draws()</code>.
This function provides a quick way to get a variety of summary statistics
and diagnostics on draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grouped_df'
summarise_draws(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_draws.grouped_df_+3A_.x">.x</code></td>
<td>
<p>A grouped data frame (<code>dplyr::grouped_df</code> object) such as returned by
<code>dplyr::group_by()</code> where the data frame in each group (ignoring grouping columns)
has the structure of a <code>posterior::draws_df()</code> object: <code>".chain"</code>, <code>".iteration"</code>, and
<code>".draw"</code> columns, with the remaining (non-grouping) columns being draws
from variables.</p>
</td></tr>
<tr><td><code id="summarise_draws.grouped_df_+3A_...">...</code></td>
<td>
<p>Name-value pairs of summary or <a href="posterior.html#topic+diagnostics">diagnostic</a>
functions. The provided names will be used as the names of the columns in
the result <em>unless</em> the function returns a named vector, in which case the
latter names are used. The functions can be specified in any format
supported by <a href="rlang.html#topic+as_function">as_function()</a>. See <strong>Examples</strong>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While <code>posterior::summarise_draws()</code> can operate on tidy data frames of
draws in the <code>posterior::draws_df()</code> format, that format does not support
grouping columns. This provides an implementation of <code>summarise_draws()</code>
that does support grouped data tables, essentially applying
<code>posterior::summarise_draws()</code> to every sub-table of <code>.x</code> implied by the
groups defined on the data frame.
</p>
<p>See <code>posterior::summarise_draws()</code> for
more details on the summary statistics and diagnostics you can use with this
function. If you just want point summaries and intervals (not diagnostics),
particularly for plotting, see <code>point_interval()</code>, which returns long-format
data tables more suitable for that purpose (especially if you want to plot
multiple uncertainty levels).
</p>


<h3>Value</h3>

<p>A data frame (actually, a <a href="tibble.html#topic+tibble">tibble</a>) with all grouping
columns from <code>.x</code>, a <code>"variable"</code> column containing variable names from <code>.x</code>,
and the remaining columns containing summary statistics and diagnostics.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="posterior.html#topic+draws_summary">posterior::summarise_draws()</a></code>, <code><a href="#topic+point_interval">point_interval()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(posterior)
library(dplyr)

d = posterior::example_draws()

# The default posterior::summarise_draws() summarises all variables without
# splitting out indices:
summarise_draws(d)

# The grouped_df implementation of summarise_draws() in tidybayes can handle
# output from spread_draws(), which is a grouped data table with the indices
# (here, `i`) left as columns:
d %&gt;%
  spread_draws(theta[i]) %&gt;%
  summarise_draws()

# Summary functions can also be provided, as in posterior::summarise_draws():
d %&gt;%
  spread_draws(theta[i]) %&gt;%
  summarise_draws(median, mad, rhat, ess_tail)

</code></pre>

<hr>
<h2 id='tidy_draws'>Get a sample of posterior draws from a model as a tibble</h2><span id='topic+tidy_draws'></span><span id='topic+tidy_draws.default'></span><span id='topic+tidy_draws.draws'></span><span id='topic+tidy_draws.data.frame'></span><span id='topic+tidy_draws.mcmc.list'></span><span id='topic+tidy_draws.stanfit'></span><span id='topic+tidy_draws.stanreg'></span><span id='topic+tidy_draws.runjags'></span><span id='topic+tidy_draws.jagsUI'></span><span id='topic+tidy_draws.brmsfit'></span><span id='topic+tidy_draws.CmdStanFit'></span><span id='topic+tidy_draws.CmdStanMCMC'></span><span id='topic+tidy_draws.matrix'></span><span id='topic+tidy_draws.MCMCglmm'></span>

<h3>Description</h3>

<p>Extract draws from a Bayesian fit into a wide-format data frame with a
<code>.chain</code>, <code>.iteration</code>, and <code>.draw</code> column, as well as all variables
as columns. This function does not parse indices from variable names
(e.g. for variable names like <code>"x[1]"</code>); see <code><a href="#topic+spread_draws">spread_draws()</a></code> or
<code><a href="#topic+gather_draws">gather_draws()</a></code> for functions that parse variable indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_draws(model, ...)

## Default S3 method:
tidy_draws(model, ...)

## S3 method for class 'draws'
tidy_draws(model, ...)

## S3 method for class 'data.frame'
tidy_draws(model, ...)

## S3 method for class 'mcmc.list'
tidy_draws(model, ...)

## S3 method for class 'stanfit'
tidy_draws(model, ...)

## S3 method for class 'stanreg'
tidy_draws(model, ...)

## S3 method for class 'runjags'
tidy_draws(model, ...)

## S3 method for class 'jagsUI'
tidy_draws(model, ...)

## S3 method for class 'brmsfit'
tidy_draws(model, ...)

## S3 method for class 'CmdStanFit'
tidy_draws(model, ...)

## S3 method for class 'CmdStanMCMC'
tidy_draws(model, ...)

## S3 method for class 'matrix'
tidy_draws(model, ...)

## S3 method for class 'MCMCglmm'
tidy_draws(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_draws_+3A_model">model</code></td>
<td>
<p>A supported Bayesian model fit. Tidybayes supports a variety of model objects;
for a full list of supported models, see <a href="#topic+tidybayes-models">tidybayes-models</a>.</p>
</td></tr>
<tr><td><code id="tidy_draws_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other methods (mostly unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be useful for quick glances at models (especially
combined with <code><a href="#topic+gather_variables">gather_variables()</a></code> and <code><a href="#topic+median_qi">median_qi()</a></code>), and for models with
parameters without indices in their names (like <code>"x[1]"</code>).
<code><a href="#topic+spread_draws">spread_draws()</a></code> and <code><a href="#topic+gather_draws">gather_draws()</a></code>, which <em>do</em> parse variable name indices,
call this function internally if their input is not already a tidy data frame.
</p>
<p>To provide support for new models in tidybayes,
you must provide an implementation of this function <em>or</em> an implementation
of <code><a href="coda.html#topic+mcmc.list">coda::as.mcmc.list()</a></code> (<code>tidy_draws</code> should work on any model
with an implementation of <code><a href="coda.html#topic+mcmc.list">coda::as.mcmc.list()</a></code>)
</p>
<p><code>tidy_draws()</code> can be applied to a data frame that is already a tidy-format data frame
of draws, provided it has one row per draw. In other words, it can be applied to data frames
that have the same format it returns, and it will return the same data frame back, while
checking to ensure the <code>.chain</code>, <code>.iteration</code>, and <code>.draw</code> columns are all
integers (converting if possible) and that the <code>.draw</code> column is unique. This allows
you to pass already-tidy-format data frames into other tidybayes functions, like
<code><a href="#topic+spread_draws">spread_draws()</a></code> or <code><a href="#topic+gather_draws">gather_draws()</a></code>. This functionality can be useful if the
tidying step is expensive: you can tidy once, possibly subsetting to some
particular variables of interest, then call <code><a href="#topic+spread_draws">spread_draws()</a></code> or <code><a href="#topic+gather_draws">gather_draws()</a></code>
repeatedly to extract variables and indices from the already-tidied data frame.
</p>


<h3>Value</h3>

<p>A data frame (actually, a <a href="tibble.html#topic+tibble">tibble</a>) with a <code>.chain</code> column,
<code>.iteration</code> column, <code>.draw</code> column, and one column for every variable in <code>model</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread_draws">spread_draws()</a></code> or <code><a href="#topic+gather_draws">gather_draws()</a></code>, which use this function
internally and provides a friendly interface for extracting tidy data frames from model fits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(magrittr)

data(line, package = "coda")

line %&gt;%
  tidy_draws()

</code></pre>

<hr>
<h2 id='tidybayes-deprecated'>Deprecated functions, arguments, and column names in tidybayes</h2><span id='topic+tidybayes-deprecated'></span><span id='topic+ggeye'></span><span id='topic+add_fitted_draws'></span><span id='topic+fitted_draws'></span><span id='topic+fitted_draws.default'></span><span id='topic+fitted_samples'></span><span id='topic+add_fitted_samples'></span><span id='topic+predicted_samples'></span><span id='topic+add_predicted_samples'></span><span id='topic+gather_samples'></span><span id='topic+gather_lsmeans_samples'></span><span id='topic+gather_emmeans_samples'></span><span id='topic+gather_terms'></span><span id='topic+extract_samples'></span><span id='topic+tidy_samples'></span><span id='topic+spread_samples'></span><span id='topic+as_sample_tibble'></span><span id='topic+as_sample_data_frame'></span><span id='topic+ungather_samples'></span><span id='topic+unspread_samples'></span><span id='topic+parameters'></span><span id='topic+geom_eye'></span><span id='topic+geom_eyeh'></span><span id='topic+geom_halfeyeh'></span><span id='topic+geom_slabh'></span><span id='topic+geom_intervalh'></span><span id='topic+GeomIntervalh'></span><span id='topic+geom_pointintervalh'></span><span id='topic+GeomPointintervalh'></span><span id='topic+geom_dotsh'></span><span id='topic+geom_dotsintervalh'></span><span id='topic+stat_dist_eyeh'></span><span id='topic+stat_dist_halfeyeh'></span><span id='topic+stat_dist_slabh'></span><span id='topic+stat_dist_intervalh'></span><span id='topic+stat_dist_pointintervalh'></span><span id='topic+stat_dist_gradientintervalh'></span><span id='topic+stat_dist_cdfintervalh'></span><span id='topic+stat_dist_ccdfintervalh'></span><span id='topic+stat_dist_dotsh'></span><span id='topic+stat_dist_dotsintervalh'></span><span id='topic+stat_eyeh'></span><span id='topic+stat_halfeyeh'></span><span id='topic+stat_slabh'></span><span id='topic+stat_intervalh'></span><span id='topic+stat_pointintervalh'></span><span id='topic+stat_gradientintervalh'></span><span id='topic+stat_cdfintervalh'></span><span id='topic+stat_ccdfintervalh'></span><span id='topic+stat_dotsh'></span><span id='topic+stat_dotsintervalh'></span><span id='topic+stat_histintervalh'></span><span id='topic+point_intervalh'></span><span id='topic+mean_qih'></span><span id='topic+median_qih'></span><span id='topic+mode_qih'></span><span id='topic+mean_hdih'></span><span id='topic+median_hdih'></span><span id='topic+mode_hdih'></span><span id='topic+mean_hdcih'></span><span id='topic+median_hdcih'></span><span id='topic+mode_hdcih'></span>

<h3>Description</h3>

<p>Deprecated functions, arguments, and column names and their alternatives are listed below.
Many of the deprecations are due to a naming scheme overhaul in tidybayes version 1.0
(see <em>Deprecated Functions</em> and <em>Deprecated Arguments and Column Names</em> below) or due to
the deprecation of horizontal shortcut geoms and stats in tidybayes 2.1 (see
<em>Deprecated Horizontal Shortcut Geoms and Stats</em>).
</p>


<h3>Deprecated Functions</h3>

<p>Several deprecated versions of functions use slightly different output
formats (e.g., they use names like <code>term</code> and <code>estimate</code> where new
functions use <code>.variable</code> and <code>.value</code>; or they set <code>.iteration</code> even
when iteration information is not available &mdash; new functions always set <code>.draw</code>
but may not set <code>.iteration</code>), so be careful when upgrading to new function names.
See <em>Deprecated Arguments and Column Names</em>, below, for more information.
</p>
<p>Functions deprecated in tidybayes 3.0:
</p>

<ul>
<li> <p><code>fitted_draws</code> and <code>add_fitted_draws</code> are deprecated because their names
were confusing: it was unclear to many users if these functions returned
draws from the posterior predictive, the mean of the posterior predictive,
or the linear predictor (and depending on model type it might have been
either of the latter). Use <code><a href="#topic+epred_draws">epred_draws()</a></code>/<code><a href="#topic+add_epred_draws">add_epred_draws()</a></code> if you
want the expectation of the posterior predictive and use
<code><a href="#topic+linpred_draws">linpred_draws()</a></code>/<code><a href="#topic+add_linpred_draws">add_linpred_draws()</a></code> if you want the linear predictor.
</p>
</li></ul>

<p>Functions deprecated in tidybayes 1.0:
</p>

<ul>
<li> <p><code>spread_samples</code>, <code>extract_samples</code>, and <code>tidy_samples</code> are
deprecated names for <code><a href="#topic+spread_draws">spread_draws()</a></code>. The spread/gather terminology
better distinguishes the resulting data frame format, and <em>draws</em> is more
correct terminology than <em>samples</em> for describing multiple realizations from
a posterior distribution.
</p>
</li>
<li> <p><code>gather_samples</code> is a deprecated name for <code><a href="#topic+gather_draws">gather_draws()</a></code>,
reflecting a package-wide move to using <em>draws</em> instead of <em>samples</em> for
describing multiple realizations from a distribution.
</p>
</li>
<li> <p><code>unspread_samples</code> is a deprecated name for <code><a href="#topic+unspread_draws">unspread_draws()</a></code>,
reflecting a package-wide move to using <em>draws</em> instead of <em>samples</em> for
describing multiple realizations from a distribution.
</p>
</li>
<li> <p><code>ungather_samples</code> is a deprecated name for <code><a href="#topic+ungather_draws">ungather_draws()</a></code>,
reflecting a package-wide move to using <em>draws</em> instead of <em>samples</em> for
describing multiple realizations from a distribution.
</p>
</li>
<li> <p><code>fitted_samples</code> / <code>add_fitted_samples</code> are deprecated names for
<code>fitted_draws</code> / <code>add_fitted_draws</code>,
reflecting a package-wide move to using <em>draws</em> instead of <em>samples</em> for
describing multiple realizations from a distribution. (though see
the note above about the deprecation of <code>fitted_draws</code> in favor of
<code><a href="#topic+epred_draws">epred_draws()</a></code> and <code><a href="#topic+linpred_draws">linpred_draws()</a></code>).
</p>
</li>
<li> <p><code>predicted_samples</code> / <code>add_predicted_samples</code> are deprecated names for
<code><a href="#topic+predicted_draws">predicted_draws()</a></code> / <code><a href="#topic+add_predicted_draws">add_predicted_draws()</a></code>,
reflecting a package-wide move to using <em>draws</em> instead of <em>samples</em> for
describing multiple realizations from a distribution.
</p>
</li>
<li> <p><code>gather_lsmeans_samples</code> and <code>gather_emmeans_samples</code> are deprecated aliases
for <code><a href="#topic+gather_emmeans_draws">gather_emmeans_draws()</a></code>. The new name (estimated marginal means) is more
appropriate for Bayesian models than the old name (least-squares means), and reflects the
naming of the newer <code>emmeans</code> package. It also reflects
a package-wide move to using <em>draws</em> instead of <em>samples</em> for
describing multiple realizations from a distribution.
</p>
</li>
<li> <p><code>as_sample_tibble</code> and <code>as_sample_data_frame</code> are deprecated aliases
for <code><a href="#topic+tidy_draws">tidy_draws()</a></code>. The original intent of <code>as_sample_tibble</code> was to be
used primarily internally (hence its less user-friendly name); however, increasingly
I have come across use cases of <code>tidy_draws</code> that warrant a more user-friendly name.
It also reflects a package-wide move to using <em>draws</em> instead of <em>samples</em> for
describing multiple realizations from a distribution.
</p>
</li>
<li> <p><code>ggeye</code> is deprecated: for a package whose goal is flexible and customizable
visualization, monolithic functions are inflexible and do not sufficiently capitalize on users'
existing knowledge of ggplot; instead, I think it is more flexible to design geoms and stats
that can used within a complete ggplot workflow. <code><a href="#topic+stat_eye">stat_eye()</a></code> offers a horizontal
eye plot geom that can be used instead of <code>ggeye</code>.
</p>
</li>
<li><p> See the sections below for additional deprecated functions, including
horizontal geoms, stats, and point_intervals
</p>
</li></ul>



<h3>Deprecated Eye Geom Spellings</h3>

<p><code>geom_eye</code>, <code>geom_eyeh</code>, and <code>geom_halfeyeh</code> are deprecated spellings of <code><a href="#topic+stat_eye">stat_eye()</a></code> and
<code><a href="#topic+stat_halfeye">stat_halfeye()</a></code> from before name standardization of stats and geoms. Use those functions instead.
</p>


<h3>Deprecated Horizontal Shortcut Geoms and Stats</h3>

<p>Due to the introduction of automatic orientation detection in tidybayes 2.1,
shortcut geoms and stats (which end in <code>h</code>) are no longer necessary, and are
deprecated. In most cases, these can simply be replaced with the same
geom without the <code>h</code> suffix and they will remain horizontal; e.g.
<code>stat_halfeyeh(...)</code> can simply be replaced with <code>stat_halfeye(...)</code>.
If automatic orientation detection fails, override it with the <code>orientation</code>
parameter; e.g. <code>stat_halfeye(orientation = "horizontal")</code>.
</p>
<p>These deprecated stats and geoms include:
</p>

<ul>
<li> <p><code>stat_eyeh</code> / <code>stat_dist_eyeh</code>
</p>
</li>
<li> <p><code>stat_halfeyeh</code> / <code>stat_dist_halfeyeh</code>
</p>
</li>
<li> <p><code>geom_slabh</code> / <code>stat_slabh</code> / <code>stat_dist_slabh</code>
</p>
</li>
<li> <p><code>geom_intervalh</code> / <code>stat_intervalh</code> / <code>stat_dist_intervalh</code>
</p>
</li>
<li> <p><code>geom_pointintervalh</code> / <code>stat_pointintervalh</code> / <code>stat_dist_pointintervalh</code>
</p>
</li>
<li> <p><code>stat_gradientintervalh</code> / <code>stat_dist_gradientintervalh</code>
</p>
</li>
<li> <p><code>stat_cdfintervalh</code> / <code>stat_dist_cdfintervalh</code>
</p>
</li>
<li> <p><code>stat_ccdfintervalh</code> / <code>stat_dist_ccdfintervalh</code>
</p>
</li>
<li> <p><code>geom_dotsh</code> / <code>stat_dotsh</code> / <code>stat_dist_dotsh</code>
</p>
</li>
<li> <p><code>geom_dotsintervalh</code> / <code>stat_intervalh</code> / <code>stat_dist_intervalh</code>
</p>
</li>
<li> <p><code>stat_histintervalh</code>
</p>
</li></ul>



<h3>Deprecated Horizontal Point/Interval Functions</h3>

<p>These functions ending in <code>h</code> (e.g., <code>point_intervalh</code>, <code>median_qih</code>)
used to be needed for use with <code>ggstance::stat_summaryh</code>, but are
no longer necessary because <code>ggplot2::stat_summary()</code> supports
automatic orientation detection, so they have been deprecated.
They behave identically to the corresponding function without the <code>h</code>,
except that when passed a vector, they return a data frame with
<code>x</code>/<code>xmin</code>/<code>xmax</code> instead of <code>y</code>/<code>ymin</code>/<code>ymax</code>.
</p>

<ul>
<li> <p><code>point_intervalh</code>
</p>
</li>
<li> <p><code>mean_qih</code> / <code>median_qih</code> / <code>mode_qih</code>
</p>
</li>
<li> <p><code>mean_hdih</code> / <code>median_hdih</code> / <code>mode_hdih</code>
</p>
</li>
<li> <p><code>mean_hdcih</code> / <code>median_hdcih</code> / <code>mode_hdcih</code>
</p>
</li></ul>



<h3>Deprecated Arguments and Column Names</h3>

<p>Arguments deprecated in tidybayes 3.0 are:
</p>

<ul>
<li><p> The <code>n</code> argument is now called <code>ndraws</code> in <code>predicted_draws()</code>, <code>linpred_draws()</code>, etc.
This prevents some bugs due to partial matching of argument names where <code>n</code> might
be mistaken for <code>newdata</code>.
</p>
</li>
<li><p> The <code>value</code> argument in <code>linpred_draws()</code> is now spelled <code>linpred</code> and defaults to
<code>".linpred"</code> in the same way that the <code>predicted_draws()</code> and <code>epred_draws()</code> functions
work.
</p>
</li>
<li><p> The <code>scale</code> argument in <code>linpred_draws()</code> is no longer allowed (use <code>transform</code> instead)
as this naming scheme only made sense when <code>linpred_draws()</code> was an alias for
<code>fitted_draws()</code>, which it no longer is (see note above about the deprecation of
<code>fitted_draws()</code>).
</p>
</li></ul>

<p>Versions of tidybayes before version 1.0 used a different naming scheme for several
arguments and output columns.
</p>
<p>Arguments and column names deprecated in tidybayes 1.0 are:
</p>

<ul>
<li> <p><code>term</code> is now <code>.variable</code>
</p>
</li>
<li> <p><code>estimate</code> is now <code>.value</code>
</p>
</li>
<li> <p><code>pred</code> is now <code>.prediction</code>
</p>
</li>
<li> <p><code>conf.low</code> is now <code>.lower</code>
</p>
</li>
<li> <p><code>conf.high</code> is now <code>.upper</code>
</p>
</li>
<li> <p><code>.prob</code> is now <code>.width</code>
</p>
</li>
<li><p> The <code>.draw</code> column was added, and should be used instead of <code>.chain</code>
and <code>.iteration</code> to uniquely identify draws when you do not care about chains. (<code>.chain</code> and
<code>.iteration</code> are still provided for identifying draws <em>within</em> chains, if desired).
</p>
</li></ul>

<p>To translate to/from the old naming scheme in output, use <code><a href="#topic+to_broom_names">to_broom_names()</a></code>
and <code><a href="#topic+from_broom_names">from_broom_names()</a></code>.
</p>
<p>Many of these names were updated in version 1.0 in order to
make terminology more consistent and in order to satisfy these criteria:
</p>

<ul>
<li><p> Ignore compatibility with broom names on the assumption an adapter function can be created.
</p>
</li>
<li><p> Use names that could be compatible with frequentist approaches (hence <code>.width</code> instead of <code>.prob</code>).
</p>
</li>
<li><p> Always precede with &quot;.&quot; to avoid collisions with variable names in models.
</p>
</li>
<li><p> No abbreviations (remembering if something is abbreviated or not can be a pain).
</p>
</li>
<li><p> No two-word names (multi-word names can always be standardized on and used in documentation, but I think data frame output should be succinct).
</p>
</li>
<li><p> Names should be nouns (I made an exception for lower/upper because they are common).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew Kay
</p>

<hr>
<h2 id='tidybayes-models'>Models supported by tidybayes</h2><span id='topic+tidybayes-models'></span>

<h3>Description</h3>

<p>Tidybayes supports two classes of models and sample formats: Models/formats that provide prediction functions, and those that
do not.
</p>


<h3>All Supported Models/Sample Formats</h3>

<p><strong>All supported models/formats</strong> support the base tidybayes sample extraction functions, such as
<code><a href="#topic+tidy_draws">tidy_draws()</a></code>, <code><a href="#topic+spread_draws">spread_draws()</a></code>, <code><a href="#topic+gather_draws">gather_draws()</a></code>, <code><a href="#topic+spread_rvars">spread_rvars()</a></code>, and <code><a href="#topic+gather_rvars">gather_rvars()</a></code>.
These models/formats include:
</p>

<ul>
<li> <p><a href="rstan.html#topic+stan">rstan</a> models
</p>
</li>
<li> <p><a href="https://mc-stan.org/cmdstanr/">cmdstanr</a> models
</p>
</li>
<li> <p><code><a href="brms.html#topic+brm">brms::brm()</a></code> models
</p>
</li>
<li> <p><a href="rstanarm.html#topic+rstanarm-package">rstanarm</a> models
</p>
</li>
<li> <p><code><a href="runjags.html#topic+runjags-package">runjags::runjags()</a></code> models
</p>
</li>
<li> <p><code><a href="rjags.html#topic+jags.model">rjags::jags.model()</a></code> models, if sampled using <code><a href="rjags.html#topic+coda.samples">rjags::coda.samples()</a></code>
</p>
</li>
<li> <p><code><a href="jagsUI.html#topic+jags">jagsUI::jags()</a></code> models
</p>
</li>
<li> <p><code><a href="MCMCglmm.html#topic+MCMCglmm">MCMCglmm::MCMCglmm()</a></code> models
</p>
</li>
<li> <p><code><a href="coda.html#topic+mcmc">coda::mcmc()</a></code> and <code><a href="coda.html#topic+mcmc.list">coda::mcmc.list()</a></code> objects, which are output by several model
types.
</p>
</li>
<li> <p><a href="posterior.html#topic+draws">posterior::draws</a> objects
</p>
</li>
<li><p> Any object with an implementation of <code><a href="posterior.html#topic+draws_df">posterior::as_draws_df()</a></code> or <code><a href="posterior.html#topic+draws">posterior::as_draws()</a></code>.
For a list of those available in your environment, run <code>methods(as_draws_df)</code> or <code>methods(as_draws)</code>
</p>
</li>
<li><p> Any object with an implementation of <code><a href="coda.html#topic+mcmc.list">coda::as.mcmc.list()</a></code>.
For a list of those available in your environment, run <code>methods(as.mcmc.list)</code>
</p>
</li></ul>

<p>If you install the <a href="https://mjskay.github.io/tidybayes.rethinking/">tidybayes.rethinking</a> package, models from
the <a href="https://github.com/rmcelreath/rethinking">rethinking</a> package are also supported.
</p>


<h3>Models Supporting Prediction</h3>

<p>In addition, the <strong>following models support fit and prediction</strong> extraction functions, such as
<code><a href="#topic+add_epred_draws">add_epred_draws()</a></code>, <code><a href="#topic+add_predicted_draws">add_predicted_draws()</a></code>, <code><a href="#topic+add_linpred_draws">add_linpred_draws()</a></code>, <code><a href="#topic+add_epred_rvars">add_epred_rvars()</a></code>,
<code><a href="#topic+add_predicted_rvars">add_predicted_rvars()</a></code>, and <code><a href="#topic+add_linpred_rvars">add_linpred_rvars()</a></code>:
</p>

<ul>
<li> <p><code><a href="brms.html#topic+brm">brms::brm()</a></code> models
</p>
</li>
<li> <p><a href="rstanarm.html#topic+rstanarm-package">rstanarm</a> models
</p>
</li>
<li><p> any package with implementations of <code><a href="rstantools.html#topic+posterior_epred">rstantools::posterior_epred()</a></code>,
<code><a href="rstantools.html#topic+posterior_predict">rstantools::posterior_predict()</a></code>, or <code><a href="rstantools.html#topic+posterior_linpred">rstantools::posterior_linpred()</a></code> that
include an argument called <code>newdata</code> which takes a data frame of predictors.
</p>
</li></ul>

<p><strong>If your model type is not in the above list</strong>, you may still be able to use the <code><a href="#topic+add_draws">add_draws()</a></code>
function to turn matrices of predictive draws (or fit draws) into tidy data frames. Or,
you can wrap output from a prediction function in <code>posterior::rvar()</code> and add it
to a data frame so long as that output is a matrix with draws as rows.
</p>
<p>If you install the <a href="https://mjskay.github.io/tidybayes.rethinking/">tidybayes.rethinking</a> package, models from
the <a href="https://github.com/rmcelreath/rethinking">rethinking</a> package are also supported.
</p>


<h3>Extending tidybayes</h3>

<p>To include basic support for new models, one need only implement the <code><a href="#topic+tidy_draws">tidy_draws()</a></code> generic function
for that model. Alternatively, objects that support <code><a href="posterior.html#topic+draws">posterior::as_draws()</a></code> or <code><a href="coda.html#topic+mcmc.list">coda::as.mcmc.list()</a></code>
will automatically be supported by <code><a href="#topic+tidy_draws">tidy_draws()</a></code>.
</p>
<p>To include support for estimation and prediction, one must either implement the <code><a href="#topic+epred_draws">epred_draws()</a></code>,
<code><a href="#topic+predicted_draws">predicted_draws()</a></code>, and <code><a href="#topic+linpred_draws">linpred_draws()</a></code> functions or their correspond functions from
<span class="pkg">rstantools</span>: <code><a href="rstantools.html#topic+posterior_epred">rstantools::posterior_epred()</a></code>, <code><a href="rstantools.html#topic+posterior_predict">rstantools::posterior_predict()</a></code>, and
<code><a href="rstantools.html#topic+posterior_linpred">rstantools::posterior_linpred()</a></code>. If you take the latter approach, you should include
<code>newdata</code> and <code>ndraws</code> arguments that work as documented in <code>predicted_draws()</code>.
</p>

<hr>
<h2 id='tidybayes-package'>Tidy Data and 'Geoms' for Bayesian Models</h2><span id='topic+tidybayes-package'></span><span id='topic+tidybayes'></span>

<h3>Description</h3>

<p><code>tidybayes</code> is an R package that aims to make it easy to integrate
popular Bayesian modeling methods into a tidy data + ggplot workflow.
</p>


<h3>Details</h3>

<p>Tidy data frames (one observation per row) are particularly convenient for
use in a variety of R data manipulation and visualization packages (Wickham 2014).
However, when using Bayesian modeling functions like JAGS or Stan in R,
we often have to translate this data into a form the model understands,
and then after running the model, translate the resulting sample (or
predictions) into a more tidy format for use with other R functions.
<code>tidybayes</code> aims to simplify these two common (often tedious)
operations. It also provides a variety of ggplot geometries aimed
at making the visualization of model output easier.
</p>
<p>For a comprehensive overview of the package, see <code>vignette("tidybayes")</code>.
For overviews aimed at the <code>rstanarm</code> and <code>brms</code> packages, see
<code>vignette("tidy-rstanarm")</code> and <code>vignette("tidy-brms")</code>. For an overview
of the majority of geoms in the ggdist/tidybayes family, see
<code>vignette("slabinterval", package = "ggdist")</code>.
</p>
<p>For a list of supported models, see <a href="#topic+tidybayes-models">tidybayes-models</a>.
</p>


<h3>References</h3>

<p>Wickham, Hadley. (2014). Tidy data. <em>Journal of Statistical Software</em>,
59(10), 1-23. <a href="https://doi.org/10.18637/jss.v059.i10">doi:10.18637/jss.v059.i10</a>.
</p>

<hr>
<h2 id='ungather_draws'>Turn tidy data frames of variables from a Bayesian model back into untidy data</h2><span id='topic+ungather_draws'></span><span id='topic+unspread_draws'></span>

<h3>Description</h3>

<p>Inverse operations of <code><a href="#topic+spread_draws">spread_draws()</a></code> and <code><a href="#topic+gather_draws">gather_draws()</a></code>, giving
results that look like <code><a href="#topic+tidy_draws">tidy_draws()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ungather_draws(
  data,
  ...,
  variable = ".variable",
  value = ".value",
  draw_indices = c(".chain", ".iteration", ".draw"),
  drop_indices = FALSE
)

unspread_draws(
  data,
  ...,
  draw_indices = c(".chain", ".iteration", ".draw"),
  drop_indices = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ungather_draws_+3A_data">data</code></td>
<td>
<p>A tidy data frame of draws, such as one output by <code>spread_draws</code> or <code>gather_draws</code>.</p>
</td></tr>
<tr><td><code id="ungather_draws_+3A_...">...</code></td>
<td>
<p>Expressions in the form of
<code>variable_name[dimension_1, dimension_2, ...]</code>. See <code><a href="#topic+spread_draws">spread_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="ungather_draws_+3A_variable">variable</code></td>
<td>
<p>The name of the column in <code>data</code> that contains the names of variables from the model.</p>
</td></tr>
<tr><td><code id="ungather_draws_+3A_value">value</code></td>
<td>
<p>The name of the column in <code>data</code> that contains draws from the variables.</p>
</td></tr>
<tr><td><code id="ungather_draws_+3A_draw_indices">draw_indices</code></td>
<td>
<p>Character vector of column names in <code>data</code> that
should be treated as indices of draws. The default is <code>c(".chain",".iteration",".draw")</code>,
which are the same names used for chain, iteration, and draw indices returned by
<code><a href="#topic+spread_draws">spread_draws()</a></code> or <code><a href="#topic+gather_draws">gather_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="ungather_draws_+3A_drop_indices">drop_indices</code></td>
<td>
<p>Drop the columns specified by <code>draw_indices</code> from the resulting data frame. Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions take symbolic specifications of variable names and dimensions in the same format as
<code><a href="#topic+spread_draws">spread_draws()</a></code> and <code><a href="#topic+gather_draws">gather_draws()</a></code> and invert the tidy data frame back into
a data frame whose column names are variables with dimensions in them.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread_draws">spread_draws()</a></code>, <code><a href="#topic+gather_draws">gather_draws()</a></code>, <code><a href="#topic+tidy_draws">tidy_draws()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

data(RankCorr, package = "ggdist")

# We can use unspread_draws to allow us to manipulate draws with tidybayes
# and then transform the draws into a form we can use with packages like bayesplot.
# Here we subset b[i,j] to just values of i in 1:2 and j == 1, then plot with bayesplot
RankCorr %&gt;%
  spread_draws(b[i,j]) %&gt;%
  filter(i %in% 1:2, j == 1) %&gt;%
  unspread_draws(b[i,j], drop_indices = TRUE) %&gt;%
  bayesplot::mcmc_areas()

# As another example, we could use compare_levels to plot all pairwise comparisons
# of b[1,j] for j in 1:3
RankCorr %&gt;%
  spread_draws(b[i,j]) %&gt;%
  filter(i == 1, j %in% 1:3) %&gt;%
  compare_levels(b, by = j) %&gt;%
  unspread_draws(b[j], drop_indices = TRUE) %&gt;%
  bayesplot::mcmc_areas()

</code></pre>

<hr>
<h2 id='x_at_y'>Generate lookup vectors for composing nested indices</h2><span id='topic+x_at_y'></span>

<h3>Description</h3>

<p>Generates a lookup vector such that <code>x_at_y(x, y)[y] == x</code>. Particularly useful
for generating lookup tables for nested indices in conjunction with <code><a href="#topic+compose_data">compose_data()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_at_y(x, y, missing = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_at_y_+3A_x">x</code></td>
<td>
<p>Values in the resulting lookup vector. There should be only
one unique value of <code>x</code> for every corresponding value of <code>y</code>.</p>
</td></tr>
<tr><td><code id="x_at_y_+3A_y">y</code></td>
<td>
<p>Keys in the resulting lookup vector. Should be factors or integers.</p>
</td></tr>
<tr><td><code id="x_at_y_+3A_missing">missing</code></td>
<td>
<p>Missing levels from <code>y</code> will be filled in with this value
in the resulting lookup vector. Default <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x_at_y(x, y)</code> returns a vector <code>k</code> such that <code>k[y] == x</code>. It also
fills in missing values in <code>y</code>: if <code>y</code> is an integer, <code>k</code> will contain
entries for all values from <code>1</code> to <code>max(y)</code>; if <code>y</code> is a factor,
<code>k</code> will contain entries for all values from <code>1</code> to <code>nlevels(y)</code>.
Missing values are replaced with <code>missing</code> (default <code>NA</code>).
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compose_data">compose_data()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(magrittr)

df = data.frame(
  plot = factor(paste0("p", rep(1:8, times = 2))),
  site = factor(paste0("s", rep(1:4, each = 2, times = 2)))
)

# turns site into a nested index: site[p] gives the site for plot p
df %&gt;%
  compose_data(site = x_at_y(site, plot))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
