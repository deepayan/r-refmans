<!DOCTYPE html><html lang="en"><head><title>Help for package sched</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sched}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sched-package'><p>sched: Request Scheduler</p></a></li>
<li><a href='#get_url_request_result'><p>Send a request and get results.</p></a></li>
<li><a href='#make_post_request'><p>Make a POST request.</p></a></li>
<li><a href='#Request'><p>Class Request.</p></a></li>
<li><a href='#RequestResult'><p>Class RequestResult.</p></a></li>
<li><a href='#Rule'><p>Scheduling rule class.</p></a></li>
<li><a href='#Scheduler'><p>Class for scheduling web requests.</p></a></li>
<li><a href='#URL'><p>URL class.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Request Scheduler</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierrick Roger &lt;pierrick.roger@cea.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Offers classes and functions to contact web servers while enforcing scheduling rules required by the sites. The URL class makes it easy to construct a URL by providing parameters as a vector. The Request class allows to describes SOAP (Simple Object Access Protocol) or standard requests: URL, method (POST or GET), header, body. The Scheduler class controls the request frequency for each server address by mean of rules (Rule class). The RequestResult class permits to get the request status to handle error cases and the content.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/cnrgh/databases/r-sched">https://gitlab.com/cnrgh/databases/r-sched</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/cnrgh/databases/r-sched/-/issues">https://gitlab.com/cnrgh/databases/r-sched/-/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>roxygen2, testthat, knitr, rmarkdown, covr, lintr</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, fscache (&ge; 1.0.3), chk, lgr, methods, RCurl, tools,
openssl</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Request.R' 'RequestResult.R' 'Rule.R' 'URL.R'
'request_fcts.R' 'Scheduler.R' 'package.R' 'rule_fcts.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-01 13:19:07 UTC; pierrick</td>
</tr>
<tr>
<td>Author:</td>
<td>Pierrick Roger <a href="https://orcid.org/0000-0001-8177-4873"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-02 22:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='sched-package'>sched: Request Scheduler</h2><span id='topic+sched'></span><span id='topic+sched-package'></span>

<h3>Description</h3>

<p>Offers classes and functions to contact web servers while enforcing scheduling rules required by the sites. The URL class makes it easy to construct a URL by providing parameters as a vector. The Request class allows to describes SOAP (Simple Object Access Protocol) or standard requests: URL, method (POST or GET), header, body. The Scheduler class controls the request frequency for each server address by mean of rules (Rule class). The RequestResult class permits to get the request status to handle error cases and the content.
</p>


<h3>Details</h3>

<p><em>sched</em> package.
</p>
<p><em>sched</em> offers classes and functions to contact web servers while enforcing
scheduling rules required by the sites. The URL class makes it easy to
construct a URL by providing parameters as a vector. The Request class allows
to describes SOAP or standard requests: URL, method (POST or GET), header,
body. The Scheduler class controls the request frequency for each server
address by mean of rules (Rule class). The RequestResult class permits to get
the request status to handle error cases and the content.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pierrick Roger <a href="mailto:pierrick.roger@cea.fr">pierrick.roger@cea.fr</a> (<a href="https://orcid.org/0000-0001-8177-4873">ORCID</a>)
</p>


<h3>See Also</h3>

<p><a href="#topic+Rule">Rule</a>, <a href="#topic+URL">URL</a>.
</p>

<hr>
<h2 id='get_url_request_result'>Send a request and get results.</h2><span id='topic+get_url_request_result'></span>

<h3>Description</h3>

<p>Send the request described by a Request instance, using the provided user
agent, and return the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_url_request_result(
  request,
  useragent = NULL,
  ssl_verifypeer = TRUE,
  binary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_url_request_result_+3A_request">request</code></td>
<td>
<p>A <code>sched:Request</code> object.</p>
</td></tr>
<tr><td><code id="get_url_request_result_+3A_useragent">useragent</code></td>
<td>
<p>The user agent, as a character value. Example: &quot;myapp ;
my.name@my.addr&quot;</p>
</td></tr>
<tr><td><code id="get_url_request_result_+3A_ssl_verifypeer">ssl_verifypeer</code></td>
<td>
<p>Set to <code>FALSE</code> if you want to disable SSL
verification for https sites. <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="get_url_request_result_+3A_binary">binary</code></td>
<td>
<p>Set to TRUE if the content to be retrieved is binary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The request result, as a character value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Retrieve the content of a web page
u &lt;- sched::URL$new('https://httpbin.org/get')
content &lt;- sched::get_url_request_result(sched::Request$new(u))

</code></pre>

<hr>
<h2 id='make_post_request'>Make a POST request.</h2><span id='topic+make_post_request'></span>

<h3>Description</h3>

<p>Construct a sched::Request object with a valid header for a POST request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_post_request(url, body, mime, soap_action = NULL, encoding = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_post_request_+3A_url">url</code></td>
<td>
<p>A <code>sched::URL</code> object.</p>
</td></tr>
<tr><td><code id="make_post_request_+3A_body">body</code></td>
<td>
<p>The body of the POST request.</p>
</td></tr>
<tr><td><code id="make_post_request_+3A_mime">mime</code></td>
<td>
<p>The MIME type of the body. Example: &quot;text/xml&quot;,
&quot;application/json&quot;.</p>
</td></tr>
<tr><td><code id="make_post_request_+3A_soap_action">soap_action</code></td>
<td>
<p>In case of a SOAP request, the SOAP action to contact, as
a character string.</p>
</td></tr>
<tr><td><code id="make_post_request_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use. A valid integer or string as required by
RCurl.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sched::Request object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Prepare the URL and the request body
the_url &lt;- sched::URL$new('https://httpbin.org/anything')
the_body &lt;- '{"some_key": "my_value"}'

# Make the request object
my_request &lt;- sched::make_post_request(the_url, body = the_body,
                                       mime = "application/json")

</code></pre>

<hr>
<h2 id='Request'>Class Request.</h2><span id='topic+Request'></span>

<h3>Description</h3>

<p>Class Request.
</p>
<p>Class Request.
</p>


<h3>Details</h3>

<p>This class represents a Request object that can be used with the Request
Scheduler.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Request-new"><code>Request$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-getUrl"><code>Request$getUrl()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-getMethod"><code>Request$getMethod()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-getEncoding"><code>Request$getEncoding()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-getCurlOptions"><code>Request$getCurlOptions()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-getUniqueKey"><code>Request$getUniqueKey()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-getHeaderAsSingleString"><code>Request$getHeaderAsSingleString()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-getBody"><code>Request$getBody()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-print"><code>Request$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-toString"><code>Request$toString()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-clone"><code>Request$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Request-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$new(
  url,
  method = c("get", "post"),
  header = NULL,
  body = NULL,
  encoding = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>A <code>sched::URL</code> object.</p>
</dd>
<dt><code>method</code></dt><dd><p>HTTP method. Either &quot;get&quot; or &quot;post&quot;.</p>
</dd>
<dt><code>header</code></dt><dd><p>The header of the POST method as a named character vector.
The names are the fields of the header.</p>
</dd>
<dt><code>body</code></dt><dd><p>The body as a character single value.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>The encoding to use. A valid integer or string as
required by RCurl.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a GET request for the getCompleteEntity webservice of ChEBI
# database
request &lt;- sched::Request$new(
  sched::URL$new(
    'https://www.ebi.ac.uk/webservices/chebi/2.0/test/getCompleteEntity',
    params=c(chebiId=15440)))

# Create a POST Request object for the records-batch-post webservice of
# ChemSpider database
request &lt;- sched::Request$new(
  url=sched::URL$new(c('https://api.rsc.org/compounds/v1/', 'records',
                       'batch')),
  method='post', header=c('Content-Type'="", apikey='my-token'),
  body='{"recordIds": [2], "fields": ["SMILES","Formula","InChI"]}')

</pre>
</div>


<hr>
<a id="method-Request-getUrl"></a>



<h4>Method <code>getUrl()</code></h4>

<p>Gets the URL.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$getUrl()</pre></div>



<h5>Returns</h5>

<p>The URL of this Request object as a sched::URL object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a GET request
request &lt;- sched::Request$new(sched::URL$new('https://peakforest.org/'))

# Get the stored URL object
print(request$getUrl())
</pre>
</div>


<hr>
<a id="method-Request-getMethod"></a>



<h4>Method <code>getMethod()</code></h4>

<p>Gets the method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$getMethod()</pre></div>



<h5>Returns</h5>

<p>The method as a character value.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a GET request
request &lt;- sched::Request$new(sched::URL$new('https://peakforest.org/'))

# Get the stored method
print(request$getMethod())
</pre>
</div>


<hr>
<a id="method-Request-getEncoding"></a>



<h4>Method <code>getEncoding()</code></h4>

<p>Gets the encoding.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$getEncoding()</pre></div>



<h5>Returns</h5>

<p>The encoding.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a GET request
request &lt;- sched::Request$new(sched::URL$new('https://my.site.fr/'),
                              encoding='UTF-8')

# Get the stored encoding
print(request$getEncoding())
</pre>
</div>


<hr>
<a id="method-Request-getCurlOptions"></a>



<h4>Method <code>getCurlOptions()</code></h4>

<p>Gets the options object to pass to cURL library.
</p>
<p>Make a RCurl::CURLOptions object by calling RCurl::curlOptions()
function. Useragent, header and body are passed as options if not NULL.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$getCurlOptions(useragent = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>useragent</code></dt><dd><p>The user agent as a character value, or NULL.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An RCurl::CURLOptions object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a POST Request object for the records-batch-post webservice of
# ChemSpider database
request &lt;- sched::Request$new(
  url=sched::URL$new(c('https://api.rsc.org/compounds/v1/', 'records',
                       'batch')),
  method='post', header=c('Content-Type'="", apikey='my-token'),
  body='{"recordIds": [2], "fields": ["SMILES","Formula","InChI"]}')

# Get the associated RCurl options object
rcurl_opts &lt;- request$getCurlOptions('myapp ; me@my.address')

</pre>
</div>


<hr>
<a id="method-Request-getUniqueKey"></a>



<h4>Method <code>getUniqueKey()</code></h4>

<p>Gets a unique key to identify this request.
</p>
<p>The key is an MD5 sum computed from the string representation of this
request.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$getUniqueKey()</pre></div>



<h5>Returns</h5>

<p>A unique key as an MD5 sum.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a GET request
request &lt;- sched::Request$new(sched::URL$new('https://peakforest.org/'))

# Get the MD5 sum of this request
print(request$getUniqueKey())

</pre>
</div>


<hr>
<a id="method-Request-getHeaderAsSingleString"></a>



<h4>Method <code>getHeaderAsSingleString()</code></h4>

<p>Gets the HTTP header as a string, concatenating all its information
into a single string.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$getHeaderAsSingleString()</pre></div>



<h5>Returns</h5>

<p>The header as a single character value.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a POST Request object for the records-batch-post webservice of
# ChemSpider database
request &lt;- sched::Request$new(
  url=sched::URL$new(c('https://api.rsc.org/compounds/v1/', 'records',
                       'batch')),
  method='post', header=c('Content-Type'="", apikey='my-token'),
  body='{"recordIds": [2], "fields": ["SMILES","Formula","InChI"]}')

# Get back the POST header as a single string
print(request$getHeaderAsSingleString())

</pre>
</div>


<hr>
<a id="method-Request-getBody"></a>



<h4>Method <code>getBody()</code></h4>

<p>Gets the body.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$getBody()</pre></div>



<h5>Returns</h5>

<p>The body as a single character value.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a POST Request object for the records-batch-post webservice of
# ChemSpider database
request &lt;- sched::Request$new(
  url=sched::URL$new(c('https://api.rsc.org/compounds/v1/', 'records',
                       'batch')),
  method='post', header=c('Content-Type'="", apikey='my-token'),
  body='{"recordIds": [2], "fields": ["SMILES","Formula","InChI"]}')

# Get back the POST body
print(request$getBody())

</pre>
</div>


<hr>
<a id="method-Request-print"></a>



<h4>Method <code>print()</code></h4>

<p>Displays information about this instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$print()</pre></div>



<h5>Returns</h5>

<p>self as invisible.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a GET request
request &lt;- sched::Request$new(sched::URL$new('https://peakforest.org/'))

# Print the Request object
print(request)

</pre>
</div>


<hr>
<a id="method-Request-toString"></a>



<h4>Method <code>toString()</code></h4>

<p>Gets a string representation of this instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$toString()</pre></div>



<h5>Returns</h5>

<p>A single string giving a representation of this instance.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a GET request
request &lt;- sched::Request$new(sched::URL$new('https://peakforest.org/'))

# Get the string representation of this request
print(request$toString())

</pre>
</div>


<hr>
<a id="method-Request-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create a GET request for the getCompleteEntity webservice of ChEBI database
request &lt;- sched::Request$new(
  sched::URL$new(
    'https://www.ebi.ac.uk/webservices/chebi/2.0/test/getCompleteEntity',
    params=c(chebiId=15440)))

# Get an MD5 key, unique to this request
key &lt;- request$getUniqueKey()

# Print the request
print(request)


## ------------------------------------------------
## Method `Request$new`
## ------------------------------------------------

# Create a GET request for the getCompleteEntity webservice of ChEBI
# database
request &lt;- sched::Request$new(
  sched::URL$new(
    'https://www.ebi.ac.uk/webservices/chebi/2.0/test/getCompleteEntity',
    params=c(chebiId=15440)))

# Create a POST Request object for the records-batch-post webservice of
# ChemSpider database
request &lt;- sched::Request$new(
  url=sched::URL$new(c('https://api.rsc.org/compounds/v1/', 'records',
                       'batch')),
  method='post', header=c('Content-Type'="", apikey='my-token'),
  body='{"recordIds": [2], "fields": ["SMILES","Formula","InChI"]}')


## ------------------------------------------------
## Method `Request$getUrl`
## ------------------------------------------------

# Create a GET request
request &lt;- sched::Request$new(sched::URL$new('https://peakforest.org/'))

# Get the stored URL object
print(request$getUrl())

## ------------------------------------------------
## Method `Request$getMethod`
## ------------------------------------------------

# Create a GET request
request &lt;- sched::Request$new(sched::URL$new('https://peakforest.org/'))

# Get the stored method
print(request$getMethod())

## ------------------------------------------------
## Method `Request$getEncoding`
## ------------------------------------------------

# Create a GET request
request &lt;- sched::Request$new(sched::URL$new('https://my.site.fr/'),
                              encoding='UTF-8')

# Get the stored encoding
print(request$getEncoding())

## ------------------------------------------------
## Method `Request$getCurlOptions`
## ------------------------------------------------

# Create a POST Request object for the records-batch-post webservice of
# ChemSpider database
request &lt;- sched::Request$new(
  url=sched::URL$new(c('https://api.rsc.org/compounds/v1/', 'records',
                       'batch')),
  method='post', header=c('Content-Type'="", apikey='my-token'),
  body='{"recordIds": [2], "fields": ["SMILES","Formula","InChI"]}')

# Get the associated RCurl options object
rcurl_opts &lt;- request$getCurlOptions('myapp ; me@my.address')


## ------------------------------------------------
## Method `Request$getUniqueKey`
## ------------------------------------------------

# Create a GET request
request &lt;- sched::Request$new(sched::URL$new('https://peakforest.org/'))

# Get the MD5 sum of this request
print(request$getUniqueKey())


## ------------------------------------------------
## Method `Request$getHeaderAsSingleString`
## ------------------------------------------------

# Create a POST Request object for the records-batch-post webservice of
# ChemSpider database
request &lt;- sched::Request$new(
  url=sched::URL$new(c('https://api.rsc.org/compounds/v1/', 'records',
                       'batch')),
  method='post', header=c('Content-Type'="", apikey='my-token'),
  body='{"recordIds": [2], "fields": ["SMILES","Formula","InChI"]}')

# Get back the POST header as a single string
print(request$getHeaderAsSingleString())


## ------------------------------------------------
## Method `Request$getBody`
## ------------------------------------------------

# Create a POST Request object for the records-batch-post webservice of
# ChemSpider database
request &lt;- sched::Request$new(
  url=sched::URL$new(c('https://api.rsc.org/compounds/v1/', 'records',
                       'batch')),
  method='post', header=c('Content-Type'="", apikey='my-token'),
  body='{"recordIds": [2], "fields": ["SMILES","Formula","InChI"]}')

# Get back the POST body
print(request$getBody())


## ------------------------------------------------
## Method `Request$print`
## ------------------------------------------------

# Create a GET request
request &lt;- sched::Request$new(sched::URL$new('https://peakforest.org/'))

# Print the Request object
print(request)


## ------------------------------------------------
## Method `Request$toString`
## ------------------------------------------------

# Create a GET request
request &lt;- sched::Request$new(sched::URL$new('https://peakforest.org/'))

# Get the string representation of this request
print(request$toString())

</code></pre>

<hr>
<h2 id='RequestResult'>Class RequestResult.</h2><span id='topic+RequestResult'></span>

<h3>Description</h3>

<p>Class RequestResult.
</p>
<p>Class RequestResult.
</p>


<h3>Details</h3>

<p>Represents the result of a request.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RequestResult-new"><code>RequestResult$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestResult-getContent"><code>RequestResult$getContent()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestResult-getRetry"><code>RequestResult$getRetry()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestResult-getErrMsg"><code>RequestResult$getErrMsg()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestResult-getStatus"><code>RequestResult$getStatus()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestResult-getRetryAfter"><code>RequestResult$getRetryAfter()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestResult-getLocation"><code>RequestResult$getLocation()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestResult-processRequestErrors"><code>RequestResult$processRequestErrors()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestResult-clone"><code>RequestResult$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RequestResult-new"></a>



<h4>Method <code>new()</code></h4>

<p>New instance initializer.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestResult$new(
  content = NULL,
  retry = FALSE,
  err_msg = NULL,
  status = 0,
  status_msg = "",
  retry_after = NULL,
  location = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>content</code></dt><dd><p>The result content.</p>
</dd>
<dt><code>retry</code></dt><dd><p>If request should be resent.</p>
</dd>
<dt><code>err_msg</code></dt><dd><p>Error message.</p>
</dd>
<dt><code>status</code></dt><dd><p>HTTP status.</p>
</dd>
<dt><code>status_msg</code></dt><dd><p>Status message.</p>
</dd>
<dt><code>retry_after</code></dt><dd><p>Time after which to retry.</p>
</dd>
<dt><code>location</code></dt><dd><p>New location.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing.
</p>


<hr>
<a id="method-RequestResult-getContent"></a>



<h4>Method <code>getContent()</code></h4>

<p>Get content.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestResult$getContent()</pre></div>



<h5>Returns</h5>

<p>The content as a character value or NULL.
</p>


<hr>
<a id="method-RequestResult-getRetry"></a>



<h4>Method <code>getRetry()</code></h4>

<p>Get the retry flag.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestResult$getRetry()</pre></div>



<h5>Returns</h5>

<p>TRUE if the URL request should be sent again, FALSE otherwise.
</p>


<hr>
<a id="method-RequestResult-getErrMsg"></a>



<h4>Method <code>getErrMsg()</code></h4>

<p>Get the error message.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestResult$getErrMsg()</pre></div>



<h5>Returns</h5>

<p>The error message as a character value or NULL.
</p>


<hr>
<a id="method-RequestResult-getStatus"></a>



<h4>Method <code>getStatus()</code></h4>

<p>Get the HTTP status of the response.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestResult$getStatus()</pre></div>



<h5>Returns</h5>

<p>The status as an integer.
</p>


<hr>
<a id="method-RequestResult-getRetryAfter"></a>



<h4>Method <code>getRetryAfter()</code></h4>

<p>Get the time to wait before retrying.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestResult$getRetryAfter()</pre></div>



<h5>Returns</h5>

<p>The time.
</p>


<hr>
<a id="method-RequestResult-getLocation"></a>



<h4>Method <code>getLocation()</code></h4>

<p>Get the redirect location.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestResult$getLocation()</pre></div>



<h5>Returns</h5>

<p>The redirect location as a character value or NULL.
</p>


<hr>
<a id="method-RequestResult-processRequestErrors"></a>



<h4>Method <code>processRequestErrors()</code></h4>

<p>Process possible HTTP error.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestResult$processRequestErrors()</pre></div>



<h5>Returns</h5>

<p>Nothing.
</p>


<hr>
<a id="method-RequestResult-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestResult$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Rule'>Scheduling rule class.</h2><span id='topic+Rule'></span>

<h3>Description</h3>

<p>Scheduling rule class.
</p>
<p>Scheduling rule class.
</p>


<h3>Details</h3>

<p>This class represents a scheduling rule, used to limit the number of events
during a certain lap of time.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Rule-new"><code>Rule$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Rule-getN"><code>Rule$getN()</code></a>
</p>
</li>
<li> <p><a href="#method-Rule-getLapTime"><code>Rule$getLapTime()</code></a>
</p>
</li>
<li> <p><a href="#method-Rule-print"><code>Rule$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Rule-wait"><code>Rule$wait()</code></a>
</p>
</li>
<li> <p><a href="#method-Rule-clone"><code>Rule$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Rule-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializer.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rule$new(n = 3L, lap = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of events during a time lap.</p>
</dd>
<dt><code>lap</code></dt><dd><p>Duration of a time lap, in seconds.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a rule object with default parameters
r &lt;- Rule$new()

# Create a rule object with 5 events allowed each second (default time)
r2 &lt;- Rule$new(5L)

# Create a rule object with 5 events allowed each 3 seconds
r3 &lt;- Rule$new(5L, 3)
</pre>
</div>


<hr>
<a id="method-Rule-getN"></a>



<h4>Method <code>getN()</code></h4>

<p>Gets the number of events allowed during a lap time.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rule$getN()</pre></div>



<h5>Returns</h5>

<p>Returns the number of events as an integer.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>r &lt;- Rule$new()

#' Get the allowed number of events for a rule
print(r$getN())
</pre>
</div>


<hr>
<a id="method-Rule-getLapTime"></a>



<h4>Method <code>getLapTime()</code></h4>

<p>Gets the lap time.
</p>
<p>The number of seconds during which N events are allowed.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rule$getLapTime()</pre></div>



<h5>Returns</h5>

<p>Returns Lap time as a numeric.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a rule object with default parameters
r &lt;- Rule$new()

#' Get the configured lap time for a rule
print(r$getLapTime())
</pre>
</div>


<hr>
<a id="method-Rule-print"></a>



<h4>Method <code>print()</code></h4>

<p>Displays information about this instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rule$print()</pre></div>



<h5>Returns</h5>

<p>Nothing.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a rule object with default parameters
r &lt;- Rule$new()

# Print information about a rule object
print(r)
</pre>
</div>


<hr>
<a id="method-Rule-wait"></a>



<h4>Method <code>wait()</code></h4>

<p>Wait (sleep) until a new event is allowed.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rule$wait(do_sleep = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>do_sleep</code></dt><dd><p>Debug parameter that turns off the call to Sys.sleep().
Use only for testing.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The time passed to wait, in seconds.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a rule object that allows 3 events each 0.02 seconds
r &lt;- Rule$new(3, 0.02)

#' Loop for generating 20 events
i &lt;- 0 # event index
while (i &lt; 20) {
  # Wait until next event is allowed
  wait_time &lt;- r$wait()
  print(paste("We have waited", wait_time,
    "second(s) and are now allowed to process event number", i))
  i &lt;- i + 1
}
</pre>
</div>


<hr>
<a id="method-Rule-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Rule$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create a new Rule object:
rule &lt;- sched::Rule$new(n=1,lap=0.2) # 1 event allowed each 2 seconds

# Wait to be allowed to process with first event:
rule$wait() # The first event will be allowed directly, no waiting time.
# Process your first event here
rule$wait() # The second event will be delayed 0.2 seconds. This time
            # includes the time passed between the first call to wait() and
            # this one.
# Process your second event here


## ------------------------------------------------
## Method `Rule$new`
## ------------------------------------------------

# Create a rule object with default parameters
r &lt;- Rule$new()

# Create a rule object with 5 events allowed each second (default time)
r2 &lt;- Rule$new(5L)

# Create a rule object with 5 events allowed each 3 seconds
r3 &lt;- Rule$new(5L, 3)

## ------------------------------------------------
## Method `Rule$getN`
## ------------------------------------------------

r &lt;- Rule$new()

#' Get the allowed number of events for a rule
print(r$getN())

## ------------------------------------------------
## Method `Rule$getLapTime`
## ------------------------------------------------

# Create a rule object with default parameters
r &lt;- Rule$new()

#' Get the configured lap time for a rule
print(r$getLapTime())

## ------------------------------------------------
## Method `Rule$print`
## ------------------------------------------------

# Create a rule object with default parameters
r &lt;- Rule$new()

# Print information about a rule object
print(r)

## ------------------------------------------------
## Method `Rule$wait`
## ------------------------------------------------

# Create a rule object that allows 3 events each 0.02 seconds
r &lt;- Rule$new(3, 0.02)

#' Loop for generating 20 events
i &lt;- 0 # event index
while (i &lt; 20) {
  # Wait until next event is allowed
  wait_time &lt;- r$wait()
  print(paste("We have waited", wait_time,
    "second(s) and are now allowed to process event number", i))
  i &lt;- i + 1
}
</code></pre>

<hr>
<h2 id='Scheduler'>Class for scheduling web requests.</h2><span id='topic+Scheduler'></span>

<h3>Description</h3>

<p>Class for scheduling web requests.
</p>
<p>Class for scheduling web requests.
</p>


<h3>Details</h3>

<p>The Scheduler class controls the frequency of access to web sites, through
the definiton of access rules (<code>Rule</code> class).
It handles GET and POST requests, as well as file downloading.
It can use a cache system to store request results and avoid resending
identical requests.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Scheduler-new"><code>Scheduler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Scheduler-setRule"><code>Scheduler$setRule()</code></a>
</p>
</li>
<li> <p><a href="#method-Scheduler-sendRequest"><code>Scheduler$sendRequest()</code></a>
</p>
</li>
<li> <p><a href="#method-Scheduler-downloadFile"><code>Scheduler$downloadFile()</code></a>
</p>
</li>
<li> <p><a href="#method-Scheduler-getUrlString"><code>Scheduler$getUrlString()</code></a>
</p>
</li>
<li> <p><a href="#method-Scheduler-getUrl"><code>Scheduler$getUrl()</code></a>
</p>
</li>
<li> <p><a href="#method-Scheduler-deleteRules"><code>Scheduler$deleteRules()</code></a>
</p>
</li>
<li> <p><a href="#method-Scheduler-getNbRules"><code>Scheduler$getNbRules()</code></a>
</p>
</li>
<li> <p><a href="#method-Scheduler-setOffline"><code>Scheduler$setOffline()</code></a>
</p>
</li>
<li> <p><a href="#method-Scheduler-isOffline"><code>Scheduler$isOffline()</code></a>
</p>
</li>
<li> <p><a href="#method-Scheduler-clone"><code>Scheduler$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Scheduler-new"></a>



<h4>Method <code>new()</code></h4>

<p>New instance initializer.
</p>
<p>There should be only one Scheduler instance in an application. There is
no sense in having two or more instances, since they will ignore each
other and break the access frequency rules when they contact the same
sites.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scheduler$new(
  default_rule = Rule$new(),
  ssl_verifypeer = TRUE,
  nb_max_tries = 10L,
  cache_dir = tools::R_user_dir("sched", which = "cache"),
  user_agent = NULL,
  dwnld_timeout = 3600
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>default_rule</code></dt><dd><p>The default_rule to use when none has been defined
for a site.</p>
</dd>
<dt><code>ssl_verifypeer</code></dt><dd><p>If set to TRUE (default), SSL certificate will be
checked, otherwise certificates will be ignored.</p>
</dd>
<dt><code>nb_max_tries</code></dt><dd><p>Maximum number of tries when running a request.</p>
</dd>
<dt><code>cache_dir</code></dt><dd><p>Set the path to the file system cache. Set to NULL to
disable the cache system. The cache system will save downloaded content
and reuse it later for identical requests.</p>
</dd>
<dt><code>user_agent</code></dt><dd><p>The application name and contact address to send to the
contacted web server.</p>
</dd>
<dt><code>dwnld_timeout</code></dt><dd><p>The timeout used by <code>downloadFile()</code> method, in
seconds.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a scheduler instance with a custom default_rule
scheduler &lt;- sched::Scheduler$new(default_rule=sched::Rule$new(10, 1),
                                  cache_dir = NULL)

</pre>
</div>


<hr>
<a id="method-Scheduler-setRule"></a>



<h4>Method <code>setRule()</code></h4>

<p>Defines a rule for a site.
</p>
<p>Defines a rule for a site. The site is identified by its hostname. Each
time a request will be made to this host (i.e.: the URL contains the
defined hostname), the scheduling rule will be applied in order to wait
(sleep) if nedeed before sending the request.
</p>
<p>If a rule already exists for this hostname, it will be replaced.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scheduler$setRule(host, n = 3L, lap = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>host</code></dt><dd><p>The hostname of the site.</p>
</dd>
<dt><code>n</code></dt><dd><p>Number of events during a time lap.</p>
</dd>
<dt><code>lap</code></dt><dd><p>Duration of a time lap, in seconds.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Define a rule with default values
scheduler$setRule('www.ebi.ac.uk')

# Define a rule with custome values
scheduler$setRule('my.other.site', n=10, lap=3)

</pre>
</div>


<hr>
<a id="method-Scheduler-sendRequest"></a>



<h4>Method <code>sendRequest()</code></h4>

<p>Sends a request, and retrieves content result.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scheduler$sendRequest(request, cache_read = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>A <code>sched::Request</code> instance.</p>
</dd>
<dt><code>cache_read</code></dt><dd><p>If set to TRUE and the cache system is enabled, the
cache system will be searched for the request and the cached result
returned. In any case, if the the cache system is enabled, and the
request sent, the retrieved content will be stored into the cache.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The results returned by the contacted server, as a single string
value.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Define a scheduling rule of 7 requests every 2 seconds
scheduler$setRule('www.ebi.ac.uk', n=7, lap=2)

# Create a request object
u &lt;- 'https://www.ebi.ac.uk/webservices/chebi/2.0/test/getCompleteEntity'
url &lt;- sched::URL$new(url=u, params=c(chebiId=15440))
request &lt;- sched::Request$new(url)

# Send the request and get the content result
content &lt;- scheduler$sendRequest(request)

</pre>
</div>


<hr>
<a id="method-Scheduler-downloadFile"></a>



<h4>Method <code>downloadFile()</code></h4>

<p>Downloads the content of a URL and save it into the specified
destination file.
</p>
<p>This method works for any URL, even if it has been written with heavy
files in mind.
Since it uses <code>utils::download.file()</code> which saves the content
directly on disk, the cache system is not used.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scheduler$downloadFile(url, dest_file, quiet = FALSE, timeout = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>The URL to access, as a sched::URL object.</p>
</dd>
<dt><code>dest_file</code></dt><dd><p>A path to a destination file.</p>
</dd>
<dt><code>quiet</code></dt><dd><p>The quiet parameter for <code>utils::download.file()</code>.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>The timeout in seconds. Defaults to value provided in
initializer.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Create a temporary directory
tmp_dir &lt;- tempdir()

# Download a file
u &lt;- sched::URL$new(
    'https://gitlab.com/cnrgh/databases/r-sched/-/raw/main/README.md',
    c(ref_type='heads'))
scheduler$downloadFile(u, file.path(tmp_dir, 'README.md'))

# Remove the temporary directory
unlink(tmp_dir, recursive = TRUE)

</pre>
</div>


<hr>
<a id="method-Scheduler-getUrlString"></a>



<h4>Method <code>getUrlString()</code></h4>

<p>Builds a URL string, using a base URL and parameters to be passed.
</p>
<p>The provided base URL and parameters are combined into a full URL string.
</p>
<p>DEPRECATED. Use the <code>sched::URL</code> class and its method
<code>toString()</code> instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scheduler$getUrlString(url, params = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>A URL string.</p>
</dd>
<dt><code>params</code></dt><dd><p>A list of URL parameters.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The full URL string as a single character value.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Create a URL string
url.str &lt;- scheduler$getUrlString(
  'https://www.ebi.ac.uk/webservices/chebi/2.0/test/getCompleteEntity',
  params=c(chebiId=15440))

</pre>
</div>


<hr>
<a id="method-Scheduler-getUrl"></a>



<h4>Method <code>getUrl()</code></h4>

<p>Sends a request and get the result.
</p>
<p>DEPRECATED. Use method <code>sendRequest()</code> instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scheduler$getUrl(
  url,
  params = list(),
  method = c("get", "post"),
  header = NULL,
  body = NULL,
  encoding = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>A URL string.</p>
</dd>
<dt><code>params</code></dt><dd><p>A list of URL parameters.</p>
</dd>
<dt><code>method</code></dt><dd><p>The method to use. Either 'get' or 'post'.</p>
</dd>
<dt><code>header</code></dt><dd><p>The header to send.</p>
</dd>
<dt><code>body</code></dt><dd><p>The body to send.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>The encoding to use.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The results of the request.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Send request
content &lt;- scheduler$getUrl(
  'https://www.ebi.ac.uk/webservices/chebi/2.0/test/getCompleteEntity',
  params=c(chebiId=15440))

</pre>
</div>


<hr>
<a id="method-Scheduler-deleteRules"></a>



<h4>Method <code>deleteRules()</code></h4>

<p>Removes all defined rules, including the ones automatically defined using
default_rule.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scheduler$deleteRules()</pre></div>



<h5>Returns</h5>

<p>Nothing.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Define a rule with custome values
scheduler$setRule('my.other.site', n=10, lap=3)

# Delete all defined rules
scheduler$deleteRules()

</pre>
</div>


<hr>
<a id="method-Scheduler-getNbRules"></a>



<h4>Method <code>getNbRules()</code></h4>

<p>Gets the number of defined rules, including the ones automatically
defined using default_rule.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scheduler$getNbRules()</pre></div>



<h5>Returns</h5>

<p>The number of rules defined.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Get the number of defined rules
print(scheduler$getNbRules())

</pre>
</div>


<hr>
<a id="method-Scheduler-setOffline"></a>



<h4>Method <code>setOffline()</code></h4>

<p>Enables or disables offline mode.
</p>
<p>If the offline mode is enabled, an error will be raised when the class
attemps to send a request.
This mode is mainly useful when debugging the usage of the cache system.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scheduler$setOffline(offline)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>offline</code></dt><dd><p>Set to TRUE to enable offline mode, and FALSE otherwise.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Enable offline mode
scheduler$setOffline(TRUE)

</pre>
</div>


<hr>
<a id="method-Scheduler-isOffline"></a>



<h4>Method <code>isOffline()</code></h4>

<p>Tests if offline mode is enabled.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scheduler$isOffline()</pre></div>



<h5>Returns</h5>

<p>TRUE is offline mode is enabled, FALSE otherwise.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Test if offline mode is enabled
if (scheduler$isOffline())
  print("Scheduler is offline.")

</pre>
</div>


<hr>
<a id="method-Scheduler-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scheduler$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create a scheduler instance without cache
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Define a rule with default values
scheduler$setRule('www.ebi.ac.uk')

# Create a request object
u &lt;- 'https://www.ebi.ac.uk/webservices/chebi/2.0/test/getCompleteEntity'
url &lt;- sched::URL$new(url=u, params=c(chebiId=15440))
request &lt;- sched::Request$new(url)

# Send the request and get the content result
content &lt;- scheduler$sendRequest(request)


## ------------------------------------------------
## Method `Scheduler$new`
## ------------------------------------------------

# Create a scheduler instance with a custom default_rule
scheduler &lt;- sched::Scheduler$new(default_rule=sched::Rule$new(10, 1),
                                  cache_dir = NULL)


## ------------------------------------------------
## Method `Scheduler$setRule`
## ------------------------------------------------

# Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Define a rule with default values
scheduler$setRule('www.ebi.ac.uk')

# Define a rule with custome values
scheduler$setRule('my.other.site', n=10, lap=3)


## ------------------------------------------------
## Method `Scheduler$sendRequest`
## ------------------------------------------------

# Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Define a scheduling rule of 7 requests every 2 seconds
scheduler$setRule('www.ebi.ac.uk', n=7, lap=2)

# Create a request object
u &lt;- 'https://www.ebi.ac.uk/webservices/chebi/2.0/test/getCompleteEntity'
url &lt;- sched::URL$new(url=u, params=c(chebiId=15440))
request &lt;- sched::Request$new(url)

# Send the request and get the content result
content &lt;- scheduler$sendRequest(request)


## ------------------------------------------------
## Method `Scheduler$downloadFile`
## ------------------------------------------------

# Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Create a temporary directory
tmp_dir &lt;- tempdir()

# Download a file
u &lt;- sched::URL$new(
    'https://gitlab.com/cnrgh/databases/r-sched/-/raw/main/README.md',
    c(ref_type='heads'))
scheduler$downloadFile(u, file.path(tmp_dir, 'README.md'))

# Remove the temporary directory
unlink(tmp_dir, recursive = TRUE)


## ------------------------------------------------
## Method `Scheduler$getUrlString`
## ------------------------------------------------

# Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Create a URL string
url.str &lt;- scheduler$getUrlString(
  'https://www.ebi.ac.uk/webservices/chebi/2.0/test/getCompleteEntity',
  params=c(chebiId=15440))


## ------------------------------------------------
## Method `Scheduler$getUrl`
## ------------------------------------------------

# Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Send request
content &lt;- scheduler$getUrl(
  'https://www.ebi.ac.uk/webservices/chebi/2.0/test/getCompleteEntity',
  params=c(chebiId=15440))


## ------------------------------------------------
## Method `Scheduler$deleteRules`
## ------------------------------------------------

# Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Define a rule with custome values
scheduler$setRule('my.other.site', n=10, lap=3)

# Delete all defined rules
scheduler$deleteRules()


## ------------------------------------------------
## Method `Scheduler$getNbRules`
## ------------------------------------------------

# Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Get the number of defined rules
print(scheduler$getNbRules())


## ------------------------------------------------
## Method `Scheduler$setOffline`
## ------------------------------------------------

# Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Enable offline mode
scheduler$setOffline(TRUE)


## ------------------------------------------------
## Method `Scheduler$isOffline`
## ------------------------------------------------

# Create a scheduler instance
scheduler &lt;- sched::Scheduler$new(cache_dir = NULL)

# Test if offline mode is enabled
if (scheduler$isOffline())
  print("Scheduler is offline.")

</code></pre>

<hr>
<h2 id='URL'>URL class.</h2><span id='topic+URL'></span>

<h3>Description</h3>

<p>URL class.
</p>
<p>URL class.
</p>


<h3>Details</h3>

<p>This class represents a URL object that can be used in requests.
It handles parameters as a list, making it easy to build URLs for contacting
web services.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-URL-new"><code>URL$new()</code></a>
</p>
</li>
<li> <p><a href="#method-URL-getDomain"><code>URL$getDomain()</code></a>
</p>
</li>
<li> <p><a href="#method-URL-setUrl"><code>URL$setUrl()</code></a>
</p>
</li>
<li> <p><a href="#method-URL-setParam"><code>URL$setParam()</code></a>
</p>
</li>
<li> <p><a href="#method-URL-print"><code>URL$print()</code></a>
</p>
</li>
<li> <p><a href="#method-URL-toString"><code>URL$toString()</code></a>
</p>
</li>
<li> <p><a href="#method-URL-clone"><code>URL$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-URL-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initializer.
</p>


<h5>Usage</h5>

<div class="r"><pre>URL$new(url = character(), params = character(), chomp_extra_slashes = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>The URL to access, as a character vector.</p>
</dd>
<dt><code>params</code></dt><dd><p>The list of parameters to append to this URL. If it is an
unnamed list or vector, the values will be converted to strings and
concatenated with the <code>&amp;</code> separator. If it is a named list or vector, the
names will be used as keys as in &quot;name1=value1&amp;name2=value2&amp;...&quot;.</p>
</dd>
<dt><code>chomp_extra_slashes</code></dt><dd><p>If set to TRUE, then slashes at the end and
the beginning of each element of the url vector parameter will be removed
before proper concatenation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a URL object
url &lt;- sched::URL$new("https://www.my.server/", c(param1=12,
                      param2='abc'))

</pre>
</div>


<hr>
<a id="method-URL-getDomain"></a>



<h4>Method <code>getDomain()</code></h4>

<p>Etracts the domain name from the URL.
</p>


<h5>Usage</h5>

<div class="r"><pre>URL$getDomain()</pre></div>



<h5>Returns</h5>

<p>The domain.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create a URL object
url &lt;- sched::URL$new("https://www.my.server/",
                      c(param1=12, param2='abc'))

# Extract the domain name
print(url$getDomain())
</pre>
</div>


<hr>
<a id="method-URL-setUrl"></a>



<h4>Method <code>setUrl()</code></h4>

<p>Sets the base URL string.
</p>


<h5>Usage</h5>

<div class="r"><pre>URL$setUrl(url)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>The base URL string.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create an empty URL object
url &lt;- sched::URL$new()

# Set the URL
url$setUrl('https://www.my.server/')

# Convert the URL to a string
print(url$toString())
</pre>
</div>


<hr>
<a id="method-URL-setParam"></a>



<h4>Method <code>setParam()</code></h4>

<p>Sets a parameter.
</p>


<h5>Usage</h5>

<div class="r"><pre>URL$setParam(key, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>The parameter name.</p>
</dd>
<dt><code>value</code></dt><dd><p>The value of the parameter.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create an URL object
url &lt;- sched::URL$new('https://www.my.server/')

# Set a parameter
url$setParam('a', 12)

# Convert the URL to a string
print(url$toString())
</pre>
</div>


<hr>
<a id="method-URL-print"></a>



<h4>Method <code>print()</code></h4>

<p>Displays information about this instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>URL$print()</pre></div>



<h5>Returns</h5>

<p>self as invisible.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create an URL object
url &lt;- sched::URL$new('https://www.my.server/')

# Print the URL object
print(url)
</pre>
</div>


<hr>
<a id="method-URL-toString"></a>



<h4>Method <code>toString()</code></h4>

<p>Gets the URL as a string representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>URL$toString(encode = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>encode</code></dt><dd><p>If set to TRUE, then encodes the URL.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The URL as a string, with all parameters and values set.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Create an URL object
url &lt;- sched::URL$new('https://www.my.server/', c(a=12))

# Convert the URL to a string
print(url$toString())
</pre>
</div>


<hr>
<a id="method-URL-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>URL$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create a URL object from a base URL string and a list of parameters
base.url &lt;- c("https://www.uniprot.org", "uniprot")
params &lt;- c(query="reviewed:yes+AND+organism:9606",
       columns='id,entry name,protein names',
       format="tab")
url &lt;- sched::URL$new(url=base.url, params=params)

# Print the URL converted to a string
print(url$toString())


## ------------------------------------------------
## Method `URL$new`
## ------------------------------------------------

# Create a URL object
url &lt;- sched::URL$new("https://www.my.server/", c(param1=12,
                      param2='abc'))


## ------------------------------------------------
## Method `URL$getDomain`
## ------------------------------------------------

# Create a URL object
url &lt;- sched::URL$new("https://www.my.server/",
                      c(param1=12, param2='abc'))

# Extract the domain name
print(url$getDomain())

## ------------------------------------------------
## Method `URL$setUrl`
## ------------------------------------------------

# Create an empty URL object
url &lt;- sched::URL$new()

# Set the URL
url$setUrl('https://www.my.server/')

# Convert the URL to a string
print(url$toString())

## ------------------------------------------------
## Method `URL$setParam`
## ------------------------------------------------

# Create an URL object
url &lt;- sched::URL$new('https://www.my.server/')

# Set a parameter
url$setParam('a', 12)

# Convert the URL to a string
print(url$toString())

## ------------------------------------------------
## Method `URL$print`
## ------------------------------------------------

# Create an URL object
url &lt;- sched::URL$new('https://www.my.server/')

# Print the URL object
print(url)

## ------------------------------------------------
## Method `URL$toString`
## ------------------------------------------------

# Create an URL object
url &lt;- sched::URL$new('https://www.my.server/', c(a=12))

# Convert the URL to a string
print(url$toString())
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
