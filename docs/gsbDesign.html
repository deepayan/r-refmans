<!DOCTYPE html><html><head><title>Help for package gsbDesign</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gsbDesign}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gsb'><p>Group Sequential Bayesian Design</p></a></li>
<li><a href='#gsbBayesUpdate'>
<p>Bayesian Update</p></a></li>
<li><a href='#gsbCriteria'>
<p>Criteria on posterior scale</p></a></li>
<li><a href='#gsbDesign-package'><p>Group Sequential Bayesian Design</p></a></li>
<li><a href='#plot.gsbMainOut'>
<p>Plot methods</p></a></li>
<li><a href='#tab'>
<p>get tables.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-23</td>
</tr>
<tr>
<td>Title:</td>
<td>Group Sequential Bayes Design</td>
</tr>
<tr>
<td>Depends:</td>
<td>gsDesign, lattice, grid,</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, utils, ggplot2</td>
</tr>
<tr>
<td>Description:</td>
<td>Group Sequential Operating Characteristics for Clinical,
        Bayesian two-arm Trials with known Sigma and Normal Endpoints,
	as described in Gerber and Gsponer (2016) &lt;<a href="https://doi.org/10.18637%2Fjss.v069.i11">doi:10.18637/jss.v069.i11</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-27 15:48:33 UTC; bjoern</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-28 11:20:11 UTC</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Gerber [aut],
  Thomas Gsponer [aut],
  Bjoern Bornkamp [cre] (maintainer)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bjoern Bornkamp &lt;bbnkmp@mail.de&gt;</td>
</tr>
</table>
<hr>
<h2 id='gsb'>Group Sequential Bayesian Design</h2><span id='topic+gsb'></span><span id='topic+gsbDesign'></span><span id='topic+gsbSimulation'></span>

<h3>Description</h3>

<p>The <code>gsbDesign</code> package allows to evaluate the operating characteristics for a group sequential design with Bayesian success/futility criteria and prior information. A clinical trial with two arms, a normal endpoint and an arbitrary number of interim analyses can be evaluated. The success and futility criteria at each interim analysis are based on the posterior distribution for the true treatment difference (delta). An arbitrary number of success and futility criteria can be specified at each interim analysis. The success criteria are of the form:  
</p>
<p style="text-align: center;"><code class="reqn">P( \delta  &gt;  ds | data  )  &gt; ps</code>
</p>
 
<p>And the futility criteria are of the form:   
</p>
<p style="text-align: center;"><code class="reqn">P( \delta  &lt;  df | data  )  &gt; pf</code>
</p>
 
<p>Here ds and df are user-specified effect thresholds, and ps and pf are user-defined probability thresholds. <br />
Prior information can either be specified for the true treatment
difference (delta), or for the true effects in the two treatment
arms. Only normal prior distributions can be used. In all cases informative priors are specified in terms of a mean and an effective sample size defined relative to sigma.<br />
The user also has to specify the number of patients for each stage of
the group sequential design, and the standard deviation (sigma) of the endpoint (assumed to be known).<br />
The operating characteristics are either evaluated for a user-specified grid of true treatment differences, or for a grid or set of true treatment means for the two arms. The operating characteristics of main interest are the probabilities of success and futility at each interim analysis, and the expected sample size.<br />
The main function of the package is <code>gsb()</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsb(design = NULL, simulation = NULL)

gsbDesign(nr.stages = NULL,
          patients = NULL,
          sigma = 1,
          criteria.success = NULL,
          criteria.futility = NULL,
          prior.difference = "non-informative",
          prior.control = "non-informative",
          prior.treatment = "non-informative")

gsbSimulation(truth = NULL,
              type.update = c("treatment effect","per arm"),
              method = c("numerical integration", "simulation", "both"),
              grid.type = c("table","plot","sliced","manually"),
              nr.sim = 50000,
              warnings.sensitivity = 100,
              seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsb_+3A_design">design</code></td>
<td>

<p>an object of class <code>gsbDesign</code> containing information on the
trial design. I.e. information on the number of stages
(<code>nr.stages</code>), the number of patients
(<code>patients</code>), and the standard deviation
(<code>sigma</code>), the decision criteria
(<code>criteria.success</code>, <code>criteria.futility</code>) and
prior information (<code>prior.difference</code>,
<code>prior.control</code>, 
<code>prior.treatment</code>). This object can be created with
function <code>gsbDesign()</code> as shown in the examples below.
</p>
</td></tr>
<tr><td><code id="gsb_+3A_simulation">simulation</code></td>
<td>

<p>an object of class <code>gsbSimulation</code> containing information on
how to evaluate the operating characteristics. I.e. on the true
effects (<code>truth</code>, <code>grid.type</code>), the Bayesian
update (<code>type.update</code>), whether simulation or
numerical integration is used (<code>method</code>) and simulation parameters (<code>nr.sim</code>,
<code>warnings.sensitivity</code>, <code>seed</code>). This object can be created with function
<code>gsbSimulation()</code> as shown in the examples below.
</p>
</td></tr>
<tr><td><code id="gsb_+3A_nr.stages">nr.stages</code></td>
<td>

<p>a <code>numeric</code> of length 1 specifying the number of stages (interim and
final analyses). 
</p>
</td></tr>
<tr><td><code id="gsb_+3A_patients">patients</code></td>
<td>

<p>a <code>numeric</code> of length 1 in order to specify an equal number of
patients in the control and treatment arm in every stage.
Enter a <code>numeric</code> of length 2 in order to specify the number of
patients in the control and treatment arm separately. If the number
of patients is not equal for all stages enter a n x 2
<code>matrix</code>. n denotes the number of stages.
More details are shown in the examples below. 
</p>
</td></tr>
<tr><td><code id="gsb_+3A_sigma">sigma</code></td>
<td>

<p>a <code>numeric</code> of length 1 in order to specify an equal
standard deviation sigma for both arms. If the sigma is not equal in
both arms enter a <code>numeric</code> of length 2 specifying
c(sigma.control, sigma.treatment). More
details are shown in the examples below. 
</p>
</td></tr>
<tr><td><code id="gsb_+3A_criteria.success">criteria.success</code></td>
<td>

<p>a <code>numeric</code> or <code>matrix</code> containing the success criteria ds
and ps. More details are shown in the examples below.    
</p>
</td></tr>
<tr><td><code id="gsb_+3A_criteria.futility">criteria.futility</code></td>
<td>

<p>a <code>numeric</code> or <code>matrix</code> containing the futility criteria df
and pf. More details are shown in the examples below.    
</p>
</td></tr>
<tr><td><code id="gsb_+3A_prior.difference">prior.difference</code></td>
<td>

<p>if <code>prior.difference = "non-informative"</code> a non-informative (flat)
prior on difference is used. Enter an informative prior as <code>numeric</code> as shown
in the examples below. If this prior is specified the argument
<code>type.update</code> as to be on &quot;treatment effect&quot;.
</p>
</td></tr>
<tr><td><code id="gsb_+3A_prior.control">prior.control</code></td>
<td>

<p>if <code>prior.control = "non-informative"</code> a non-informative (flat)
prior is used in the control arm. Enter an informative prior as <code>numeric</code> as shown
in the examples below. If this prior is specified the argument <code>type.update</code> has to be &quot;per arm&quot;.
</p>
</td></tr>
<tr><td><code id="gsb_+3A_prior.treatment">prior.treatment</code></td>
<td>

<p>if <code>prior.treatment = "non-informative"</code> a non-informative (flat)
prior is used in the treatment arm. Enter an informative prior as <code>numeric</code> as shown
in the examples below. If this prior is specified the argument <code>type.update</code> has to be &quot;per arm&quot;.
</p>
</td></tr>
<tr><td><code id="gsb_+3A_truth">truth</code></td>
<td>

<p>specifies the truth to evaluate.<br />
</p>
<p>If <code>type.update = "treatment effect"</code> this argument specifies
the true treatment effect delta (= treatment - placebo). It has the form
<code>truth = c(min, max, n)</code> where <code>min</code> and <code>max</code>
indicates the range of the true treatment effect and <code>n</code>
specifies the number of true values. (See example 1 below.)<br />
Alternatively a <code>numeric</code> containing true delta values can be entered. To
use this set <code>grid.type = "manually"</code>. (example 2).
</p>
<p>If <code>type.update = "per arm"</code> and <code>grid.type = "table"</code> the
argument has to be specified as <code>list</code> containing a vector of true
control values and true treatment values.<br />
</p>
<p>If <code>type.update = "per arm"</code> and <code>grid.type = "sliced"</code> the
argument has to be specified as <code>list</code> containing a vector of true
control values and a vector of true deltas (= treatment - control).<br />    
</p>
<p>If <code>type.update = "per arm"</code> and <code>grid.type = "plot"</code> the
argument has to be specified as follows:<br /> <code>truth = c(min.placebo, max.placebo,min.treatment, max.treatment, n)</code>,
here <code>n</code> is the number of grid points.<br />
</p>
<p>If <code>type.update = "per arm"</code> and <code>grid.type = "manually"</code>
the argument has to be a n x 2 - matrix containing the true placebo
values in the first column and the corresponding treatment values in
the second column.
</p>
</td></tr>
<tr><td><code id="gsb_+3A_type.update">type.update</code></td>
<td>

<p>If <code>type.update = "treatment effect"</code>, the Bayesian update from prior to
posterior is calculated on treatment effect delta. If
<code>type.update = "per arm"</code>, the update is calculated separately
in the placebo and the treatment arm. In this case it is possible to
enter prior information in only one arm. For <code>type.update =
    "per arm"</code> only a simulation method is implemented. 
</p>
</td></tr>
<tr><td><code id="gsb_+3A_method">method</code></td>
<td>

<p>If the <code>type.update = "treatment effect"</code>, the operating characteristics
can be obtained by simulation or by numerical integration, which is
faster. So <code>method</code> can be set to <code>"simulation"</code>, <code>"numerical integration"</code> or
<code>"both"</code>. We used <code>method = "both"</code> to check, whether the different methods yield
the same results.
If <code>type.update = "per arm"</code> only a simulation method is implemented.
</p>
</td></tr>
<tr><td><code id="gsb_+3A_grid.type">grid.type</code></td>
<td>

<p>If <code>type.update = "per arm"</code>, there are 4 possibilities to
specify the truth: <br /> 
1. <code>grid.type = "table"</code> for presenting the results in a table.<br />
2. <code>grid.type = "sliced"</code> for presenting the results in a table.<br />
3. <code>grid.type = "plot"</code> optimized grid for plotting the results.<br />
4. <code>grid.type = "manually"</code> for specifying a grid in a matrix.<br />
If <code>type.update = "treatment effect"</code> only <code>grid.type =
    "table"</code> and <code>grid.type = "manually"</code> are valid inputs. 
The argument <code>truth</code> should be specified according to the argument
<code>grid.type</code>.
</p>
</td></tr>
<tr><td><code id="gsb_+3A_nr.sim">nr.sim</code></td>
<td>

<p>a <code>numeric</code> of length 1 specifying the number of simulations.
</p>
</td></tr>
<tr><td><code id="gsb_+3A_warnings.sensitivity">warnings.sensitivity</code></td>
<td>

<p>a <code>numeric</code> of length 1. If the number of (<code>nr.sim</code>) is smaller than this integer value during the simulation, a warning
message is printed. The number of simulations is
decreasing in each stage because only the simulated trials with no decision in
the precedent stages are remaining for simulation. Thus the accuracy decreases in
each stage. <code>warnings.sensitivity</code> has to be specified
if <code>method = "simulation"</code> or <code>method = "both"</code>.
</p>
</td></tr>
<tr><td><code id="gsb_+3A_seed">seed</code></td>
<td>

<p>a <code>numeric</code> of length 1 to set a seed value for the random
number generator. If <code>seed = "generate"</code> a new seed value is generated. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Gerber and Gsponer (2016) for more details.
</p>


<h3>Value</h3>

<table>
<tr><td><code>OC</code></td>
<td>
<p>a <code>data.frame</code> containing the resulting operating characteristics
per stage (i.e. the probabilities of success, of futility and of
success or futility), the cumulative operating characteristics per
stage and the expected sample size per stage. </p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>a <code>data.frame</code> containing the boundaries, i.e. the
bounds on posterior scale and the standardized bounds. This is
available if <code>type.update = "treatment effect"</code> and <code>method = "numerical integration"</code> or <code>method = "both"</code>.</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>same as input. </p>
</td></tr>
<tr><td><code>simulation</code></td>
<td>
<p>same as input. </p>
</td></tr>
<tr><td><code>delta.grid</code></td>
<td>
<p>an object of class <code>gsbDelta.grid</code> and
<code>matrix</code> containing the grid of true control and true
treatment values. Available if <code>type.update = "per arm"</code>.</p>
</td></tr>
<tr><td><code>warnings</code></td>
<td>
<p>a <code>matrix</code> containing warnings if any. If a simulation was done (i.e. <code>method = "simulation"</code> or
<code>method = "both"</code>) the number of simulations is
decreasing in each stage because only the simulated trials with no decision in
the precedent stages are remaining for simulation. Thus the accuracy decreases in
each stage. <code>warnings</code> indicates the stages (and the
deltas) for which the number of remaining simulations is below the threshold
specified in <code>warnings.sensitivity</code>.  
</p>
</td></tr>
<tr><td><code>system.time</code></td>
<td>
<p>contains information on the used time for the
simulation / numerical integration.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Gerber &lt;florian.gerber@math.uzh.ch&gt;, Thomas Gsponer
</p>


<h3>References</h3>


<ul>
<li><p> Gerber F, Gsponer T (2016). 
gsbDesign: An R Package for Evaluating the Operating Characteristics of a Group Sequential Bayesian Design.
Journal of Statistical Software, 69(11), 1-23, DOI: 10.18637/jss.v069.i11
</p>
</li>
<li><p> Gsponer T, Gerber F, Bornkamp B, Ohlssen D, Vandemeulebroecke M, Schmidli H (2014).
A Practical Guide to Bayesian Group Sequential Designs.
Pharmaceutical Statistics, 13(1) 71-80, DOI: 10.1002/pst.1593
</p>
</li>
<li><p> Berry SM, Carlin BP, Lee JJ, and Mueller P
(2010). Bayesian Adaptive Methods for Clinical Trials.
Chapman&amp;Hall/CRC, London.
</p>
</li>
<li><p> Jennison C, and Turnbull BW (2000). Group Sequential Methods
with Applications to Clinical Trials. Chapman&amp;Hall/CRC, London.
</p>
</li>
<li><p> Spiegelhalter DJ, Abrams KR, and Myles, JP (2004). Bayesian
Approaches to Clinical Trials and Health Care Evaluation. Wiley, New
York.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot.gsbMainOut">plot.gsbMainOut</a></code>, <code><a href="#topic+tab">tab</a></code>, <code><a href="#topic+gsbBayesUpdate">gsbBayesUpdate</a></code>, <code><a href="#topic+gsbCriteria">gsbCriteria</a></code>, <code><a href="#topic+gsbDesign-package">gsbDesign-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## E X A M P L E 1: Update on treatment effect, flat prior
##
## A. Trial Design:
## ----------------
## A.1 2 stages (interim + final):
##     --&gt; nr.stages = 2
## A.2 10 patients per arms and stages. (total 2*2*10 = 40 patients)
##     --&gt; patients = 10
## A.3 Sigma in both arms = 10
##     --&gt; sigma = 10
## A.3 Criteria:
##     stop for success, if P( delta &gt; 0 | data ) &gt;= 0.8
##                      AND P( delta &gt; 7 | data ) &gt;= 0.5 
##     --&gt; criteria.success = c(0,0.8,7,0.5)
##     stop for futility, if P( delta &lt; 2 | data ) &gt;= 0.8
##     --&gt; criteria.futility = c(2,0.8)
## A.4 Prior:
##     --&gt; prior = "non-informative"

design1 &lt;- gsbDesign(nr.stages = 2,
                     patients = 10,
                     sigma = 10,
                     criteria.success = c(0,0.8, 7, 0.5),
                     criteria.futility = c(2,0.8),
                     prior.difference = "non-informative")
design1

## B. Simulation Settings
## ----------------------
## B.1 True treatment effects to be evaluated = seq(-10,20,60)
##     --&gt; truth = c(-10,20,60)
## B.2 Bayesian update on treatment effect delta (= treatment - control)
##     --&gt; type.update = "treatment effect"

simulation1 &lt;- gsbSimulation(truth=c(-10,20,60),
                             type.update="treatment effect")
simulation1

## C.1 Calculate the operating characteristics
x1 &lt;- gsb(design=design1, simulation=simulation1)
x1

## D.1 Table the probabilities of success
t1.1 &lt;- tab(x1, "success", digits=2)
t1.1

## D.2 Table the cumulative probabilities of futility at delta = c(-5,0,5.57)
##     (for 5.57 a linear interpolation is used.)
t1.2 &lt;- tab(x1, "cumulative futility", atDelta = c(-5,0,5.57), digits=5)
t1.2

## D.3 Table the expected sample size (digits == 0 --&gt; ceiling)
t1.3 &lt;- tab(x1, "sample size", atDelta= c(-5,0,5,16), digits=0)
t1.3

## E.1 Plot the operating characteristics
plot(x1)

## E.2 Plot the operating characteristics
plot(x1,"cumulative all")

## E.3 Plot the expected sample size
plot(x1, what="sample size")

## F.1 Boundaries / criteria 
x1$boundary
plot(x1, what="boundary")
plot(x1, what="std.boundary")


## E X A M P L E 2: Update on treatment effect, informative prior
##
## A. Trial design:
## ----------------
## A.1 3 stages (interims + final):
##     --&gt; nr.stages = 3
## A.2 10 patients per stage in control arm
##     15 patients per stage in treatment arm
##     (i.e. total 3 * ( 10 + 15 ) = 75 patients)
##     --&gt; patients = c(10,15)
## A.3 Sigma in control arm = 9, sigma in treatment arm = 12
##     --&gt; sigma = c(9,12)
## A.3 Criteria:
##     stop for success, if P( delta &gt; 0 | data ) &gt;= 0.8
##                      AND P( delta &gt; 7 | data ) &gt;= 0.5 
##     --&gt; criteria.success = c(0,0.8,7,0.5)
##     not stop for futility, i.e. no futility criteria
##     --&gt; criteria.futility = NA
## A.4 Prior on difference:
##     prior difference = 3
##     informative prior equivalent to:
##     5 patients in control arm; 2 patients in treatment arm
##     --&gt; prior = c(3,5,2)

design2a &lt;- gsbDesign(nr.stages = 3,
                     patients = c(10,15),
                     sigma=c(9,12),
                     criteria.success = c(0,0.8,7,0.5),
                     criteria.futility = NA,
                     prior.diff = c(3,5,2))
design2a

## A similar design with 3 success criteria can be specified as follows
## A.3 criteria:
##     Stage 1: stop for success, if P( delta &gt; 0  | data ) &gt;= 0.8
##                            AND if P( delta &gt; 10 | data ) &gt;= 0.5
##                            AND if P( delta &gt; 14 | data ) &gt;= 0.4
##     Stage 2: stop for success, if P( delta &gt; 0  | data ) &gt;= 0.8
##                            AND if P( delta &gt; 9  | data ) &gt;= 0.5
##                            AND if P( delta &gt; 13 | data ) &gt;= 0.4
##     Stage 3: stop for success, if P( delta &gt; 0  | data ) &gt;= 0.8
##                            AND if P( delta &gt; 7  | data ) &gt;= 0.5
##                            AND if P( delta &gt; 12 | data ) &gt;= 0.4
##     --&gt; criteria.success = rbind(c(0,0.8, 10,0.5, 14,0.4),
##                                  c(0,0.8,  9,0.5, 13,0.4),
##                                  c(0,0.8,  7,0.5, 12,0.4))

design2b &lt;- gsbDesign(nr.stages = 3,
                      patients = c(10,15),
                      sigma = c(9,12),
                      criteria.success = rbind(c(0,0.8, 10,0.5, 14,0.4),
                                               c(0,0.8, 9,0.5,  13,0.4),
                                               c(0,0.8, 7,0.5,  12,0.4)),
                      criteria.futility = NA,
                      prior.diff = c(3,5,2))
design2b

## B. Simulation Settings
## ----------------------
## B.1 True treatment effects to be evaluated from -5 to 30
##     --&gt; truth = -5:30
## B.2 To enter the values in this format set grid.type = "manually"
##     --&gt; grid.type = "manually"

## B.2 Bayesian update on treatment effect delta (treatment - control)
##     --&gt; type.update = "treatment effect"

simulation2 &lt;- gsbSimulation(truth = -5:30,
                             grid.type ="manually",
                             type.update = "treatment effect")
simulation2

## C. Calculate the operating characteristics
x2a &lt;- gsb(design = design2a, simulation = simulation2)
x2b &lt;- gsb(design = design2b, simulation = simulation2)
x2a
x2b

## D. Table the cumulative probabilities of success of 'design2b'
##    at delta = c(-5,0,5.57). For 5.57 a linear interpolation is used.
t2b &lt;- tab(x2b, "cumulative success", atDelta = c(-5,0,5.57), digits=5)
t2b

## E. Plot the operating characteristics of 'design2a' and 'design2b'
plot(x2a)
plot(x2b)
plot(x2a,"cumulative all")

## F.1 Boundaries / criteria of 'design2b' 
x2b$boundary
plot(x2b, what="boundary")
plot(x2b, what="std.boundary")





## E X A M P L E 3: Update on treatment effect, informative prior
##
## A. Trial Design
## ---------------
## A.1 3 stages (interims + final):
##     --&gt; nr.stages = 3
## A.2 Patients:
##         Stage 1: 10 patients in control arm; 15 patients in treatment arm
##         Stage 2: 20 patients in control arm; 30 patients in treatment arm
##         Stage 3: 30 patients in control arm; 45 patients in treatment arm
##     --&gt; patients = rbind(c(10,15),c(20,30),c(30,45))
## A.3 Sigma in control arm = 9 ; in treatment arm = 12
##     --&gt; sigma = c(9,12)
## A.4 Success criteria for all stages:
##     stop for success, if P( delta &gt; 0 | data ) &gt;= 0.8
##                      AND P( delta &gt; 7 | data ) &gt;= 0.5
##      --&gt; criteria.success = c(0,0.8,7,0.5)
## A.5 Futility criteria:
##         Stage 1: no futility criteria
##         Stage 2: stop for futility, if P( delta &lt; 2 | data ) &gt;= 0.8
##         Stage 3: stop for futility, if P( delta &lt; 2 | data ) &gt;= 0.8
##     --&gt; criteria.futility = rbind(c(NA,NA),c(2,0.8),c(2,0.8))
## A.6 Prior on treatment effect:
##         difference  = 3;
##         informative prior equivalent to:
##         2 placebo patient; 1 treatment patient
##     --&gt; prior.difference = c(3,2,1)

design3 &lt;- gsbDesign(nr.stages = 3,
                     patients = rbind(c(10,15),c(20,30),c(30,45)),
                     sigma=c(9,12),
                     criteria.success = c(0,0.8,7,0.5),
                     criteria.futility = rbind(c(NA,NA),c(2,0.8),c(2,0.8)),
                     prior.difference = c(3,2,1))
design3

## B. Simulation Settings
## ----------------------
## B.1 True treatment effects to be evaluated at seq(-5,20,15)
##     --&gt; truth = c(-5,20,15)
## B.2 Bayesian update on treatment effect delta (= treatment - control)
##     --&gt; type.update = "treatment effect"
## B.3 Operating characteristics are evaluated by simulation and
##     numerical integration to double check the results
##     --&gt; method = "both"
## B.4 Number of simulations = 5000
##     --&gt; nr.sim = 5000
## B.5 If the number of simulated trials is smaller than 300
##     during the simulation print a warning.
##     --&gt; warnings.sensitivity = 300
## B.6 A seed value is set to 13
##     --&gt; seed = 13 

simulation3 &lt;- gsbSimulation(truth = c(-5,20,15),
                             type.update = "treatment effect",
                             method = "both",
                             nr.sim = 5000,
                             warnings.sensitivity = 300,
                             seed = 13)
simulation3

## C. Calculate the operating characteristics
x3 &lt;- gsb(design = design3, simulation = simulation3)
x3

## D. The summary(x3) is almost the same as print(x3) but its entries
##    can be saved as list.
s3 &lt;- summary(x3)
names(s3)

## E.1 Plot the operating characteristics
plot(x3)

## E.2 Plot the operating characteristics obtained by simulation and
##     numerical integration in one plot. The lines should be identical (then
##     only one line is visible)
plot(x3, "both")
plot(x3, "cumulative both")



## E X A M P L E 4 - Boundaries / Criteria
## See how the Bayesian boundaries change within 10 stages.
##
## A. Trial Design:
## ----------------
## A.1 10 stages (interims + final):
##     --&gt; nr.stages = 10
## A.2 10 patients per arm and stage. (total 2*10*10 = 200 patients)
##     --&gt; patients = 10
## A.3 sigma in both arms = 10
##     --&gt; sigma = 10
## A.3 Criteria:
##     stop for success, if P( delta &gt; 0 | data ) &gt;= 0.8
##                      AND P( delta &gt; 7 | data ) &gt;= 0.5 
##     --&gt; criteria.success = c(0,0.8,7,0.5)
##     stop for futility, if P( delta &lt; 2 | data ) &gt;= 0.8
##     --&gt; criteria.futility = c(2,0.8)
## A.4 Prior:
##     --&gt; prior = "non-informative"

design4 &lt;- gsbDesign(nr.stages=10,
                     patients=10,
                     sigma=10,
                     criteria.success=c(0,0.8, 7, 0.5),
                     criteria.futility=c(2,0.8),
                     prior.difference="non-informative")
design4


## B. Simulation Settings
## --------------------------------------------
## B.1 True treatment effects to be evaluated = seq(-10,20,60)
##     --&gt; truth = c(-10,20,60)
## B.2 Bayesian update on treatment effect delta (= treatment - control)
##     --&gt; type.update = "treatment effect"

simulation4 &lt;- gsbSimulation(truth=c(-10,20,60),
                             type.update="treatment effect")
simulation4

## C. Calculate the operating characteristics
x4 &lt;- gsb(design = design4, simulation = simulation4)
x4

## D. Boundaries / criteria 
x4$boundary
plot(x4, what="boundary")
plot(x4, what="std.boundary")


## E X A M P L E 5 - Bayesian update "per arm", 
## 
## A. Trial Design:
## ----------------
## A.1 3 stages (interims + final):
##     --&gt; nr.stages = 3
## A.2 12 patients per stage in control arm
##     20 patients per stage in treatment arm
##     (i.e. total 3 * ( 12 + 20 ) = 96 patients)
##     --&gt; patients = c(12,20)
## A.3 sigma in both arms = 10
##     --&gt; sigma = 10
## A.3 Criteria:
##     stop for success, if P( delta &gt; 0 | data ) &gt;= 0.8
##                      AND P( delta &gt; 7 | data ) &gt;= 0.5 
##     --&gt; criteria.success = c(0,0.8,7,0.5)
##     stop for futility, if P( delta &lt; 2 | data ) &gt;= 0.8
##     --&gt; criteria.futility = c(2,0.8)
## A.4 Prior:
##     informative prior equivalent to:
##     2 patients in control arm with mean = 0
##     --&gt; prior.control = c(0,2)
##     1 patient in treatment arm with mean = 7 
##     --&gt; prior.treatment = c(7,1)

design5 &lt;- gsbDesign(nr.stages=3,
                     patients=c(12,20),
                     sigma=10,
                     criteria.success=c(0,0.8,7,0.5),
                     criteria.futility=c(2,0.8),
                     prior.control=c(0,2),
                     prior.treatment=c(7,1)) 
design5

## B.  Simulation Settings: - with table grid
## --------------------------------------------
## B.1 True control/treatment values:
##       control = seq(1,5,0.5)
##       treatment = seq(1,7,1)
##       --&gt; truth = list(seq(1,5,0.5),seq(1,7,1))
## B.2 Output optimized to create table
##       --&gt; grid.type = "table"
## B.3 Bayesian update per arm
##       --&gt; type.update = "per arm"
## B.4 Number of simulations = 5000 (which is low)
##       --&gt; nr.sim = 5000
## B.5 If the number of simulations is smaller than 2000
##       print a warning.
##       --&gt; warnings.sensitivity = 2000
## B.6 A seed value is set to 13
##       --&gt; seed = 13

simulation5.table &lt;- gsbSimulation(truth = list(seq(1,5,0.5), seq(1,7,1)),
                                   grid.type = "table",
                                   type.update = "per arm",
                                   nr.sim = 5000,
                                   warnings.sensitivity = 2000,
                                   seed = 13)
simulation5.table

## The same grid can be specified manually by
simulation5.manually &lt;- gsbSimulation(truth = as.matrix(expand.grid(seq(1,5,0.5),seq(1,7,1))),
                                     grid.type = "manually",
                                     type.update = "per arm",
                                     nr.sim = 5000,
                                     warnings.sensitivity = 2000,
                                     seed = 13)
simulation5.manually

## To specify a grid optimized for sliced plotting with
## control values from -10 to 0 and treatment values from -10 to 25

simulation5.sliced &lt;- gsbSimulation(truth = list(control=seq(-10,0,2), delta=seq(-10,25,4)),
                                    grid.type = "sliced",
                                    type.update = "per arm",
                                    nr.sim = 5000,
                                    warnings.sensitivity = 2000,
                                    seed = 13)
simulation5.sliced

## To specify a grid optimized for plotting with
## control values from 1 to 5 and treatment values from 1 to 7
## with approximately 20 values enter: 
simulation5.plot &lt;- gsbSimulation(truth = c(1,5,1,7,20),
                                  grid.type = "plot",
                                  type.update = "per arm",
                                  nr.sim = 5000,
                                  warnings.sensitivity = 2000,
                                  seed = 13)
simulation5.plot

## C. Use function gsb
x5.table &lt;- gsb(design5,simulation5.table)
x5.sliced &lt;- gsb(design5,simulation5.sliced)
x5.plot &lt;- gsb(design5,simulation5.plot)
x5.table

## D. Tables
## D.1 For any grid a table in long format can be obtained  
t5.1 &lt;- tab(x5.table,"cumulative futility")
head(t5.1)

t5.2 &lt;- tab(x5.sliced,"all")
head(t5.2)

## D.2 For the "table" grid there are additionally tables in wide format available.
t5.3 &lt;- tab(x5.table,"success", wide=TRUE)
t5.3

## Fix a stage, e.g. stage 2, to get a matrix
t5.3[,,2]

## D.2 Set delta.control to '3' to get a matrix
t5.3["contr 3",,]

# D.3 Plot results
plot(x5.table)
plot(x5.plot)
plot(x5.sliced)
plot(x5.sliced, sliced=TRUE)
plot(x5.sliced, sliced=TRUE, range.control=c(-4,0))
plot(x5.sliced, what="success", sliced=TRUE, range.control=c(-4,0))

## the plot can differ because the number of simulations "nr.sim"
## is low and because the grids are different
plot(x5.plot,"sample size", color=FALSE)
head(tab(x5.table,"sample size"))

</code></pre>

<hr>
<h2 id='gsbBayesUpdate'>
Bayesian Update
</h2><span id='topic+gsbBayesUpdate'></span>

<h3>Description</h3>

<p>Bayesian update from prior and data to posterior for normally
distributed data with known sigma. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsbBayesUpdate(alpha, beta, meanData, precisionData, with.alpha = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsbBayesUpdate_+3A_alpha">alpha</code></td>
<td>

<p><code>vector</code> of prior means.
</p>
</td></tr>
<tr><td><code id="gsbBayesUpdate_+3A_beta">beta</code></td>
<td>

<p><code>vector</code> of prior precisions.
</p>
</td></tr>
<tr><td><code id="gsbBayesUpdate_+3A_meandata">meanData</code></td>
<td>

<p><code>vector</code> of means from data.
</p>
</td></tr>
<tr><td><code id="gsbBayesUpdate_+3A_precisiondata">precisionData</code></td>
<td>

<p><code>vector</code> of precisions from data.
</p>
</td></tr>
<tr><td><code id="gsbBayesUpdate_+3A_with.alpha">with.alpha</code></td>
<td>

<p><code>logical</code>. If <code>with.alpha = TRUE</code>, <code>alpha</code>, <code>beta</code>,
<code>meanData</code> and <code>precisionData</code> has to be specified and the
posterior means, posterior precisions and weights are returned. Else only <code>beta</code> and <code>precisionData</code> has to be specified and the posterior precisions and weights are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>alpha</code></td>
<td>
<p>posterior means. Only if <code>with.alpha = TRUE</code>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>posterior precisions.</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>weights of the priors relative to the whole information after updating.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is used in the function <code>gsb()</code>. 
</p>


<h3>Author(s)</h3>

<p>Florian Gerber &lt;florian.gerber@math.uzh.ch&gt;, Thomas Gsponer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsb">gsb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## One dimensional case, with.alpha = FALSE
gsbBayesUpdate(beta=10,precisionData=20, with.alpha=FALSE)

## Two dimensional case, with.alpha = TRUE
gsbBayesUpdate(alpha=c(5,6),beta=c(10,11),meanData=c(10,11),
               precisionData=c(20,21),with.alpha=TRUE)
</code></pre>

<hr>
<h2 id='gsbCriteria'>
Criteria on posterior scale
</h2><span id='topic+gsbCriteria'></span>

<h3>Description</h3>

<p>Transforms the criteria on posterior-scale. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsbCriteria(criteria, priorMean, postPrecision, weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsbCriteria_+3A_criteria">criteria</code></td>
<td>
<p>an <code>array</code> with criteria. Can be created with the function <code>gsbDesign()</code>.
</p>
</td></tr>
<tr><td><code id="gsbCriteria_+3A_priormean">priorMean</code></td>
<td>
<p>a <code>vector</code> of prior means.</p>
</td></tr>
<tr><td><code id="gsbCriteria_+3A_postprecision">postPrecision</code></td>
<td>
<p>a <code>vector</code> of posterior precisions. Can be created
with function <code>gsbBayesUpdate()</code>.</p>
</td></tr>
<tr><td><code id="gsbCriteria_+3A_weight">weight</code></td>
<td>
<p>a <code>vector</code> of weights from the bayesian update. Can be created with function <code>gsbBayesUpdate()</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>CS</code></td>
<td>
<p>vector of success criteria on posterior scale</p>
</td></tr>
<tr><td><code>CF</code></td>
<td>
<p>vector of futility criteria on posterior scale</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is used in function <code>gsb()</code>. 
</p>


<h3>Author(s)</h3>

<p>Florian Gerber &lt;florian.gerber@math.uzh.ch&gt;, Thomas Gsponer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsb">gsb</a></code>
</p>

<hr>
<h2 id='gsbDesign-package'>Group Sequential Bayesian Design</h2><span id='topic+gsbDesign-package'></span>

<h3>Description</h3>

<p>The <code>gsbDesign</code> package allows to evaluate the operating characteristics for a group sequential design with Bayesian success/futility criteria and prior information. A clinical trial with two arms, a normal endpoint and an arbitrary number of interim analyses can be evaluated. The success and futility criteria at each interim analysis are based on the posterior distribution for the true treatment difference (delta). An arbitrary number of success and futility criteria can be specified at each interim analysis. The success criteria are of the form:  
</p>
<p style="text-align: center;"><code class="reqn">P( \delta  &gt;  ds  | data  )  &gt; ps</code>
</p>
 
<p>And the futility criteria are of the form:   
</p>
<p style="text-align: center;"><code class="reqn">P( \delta  &lt;  df  | data  )  &gt; pf</code>
</p>
 
<p>Here ds and df are user-specified effect thresholds, and ps and pf are user-defined probability thresholds. <br />
Prior information can either be specified for the true treatment
difference (delta), or for the true effects in the two treatment
arms. Only normal prior distributions can be used. In all cases
informative priors are specified in terms of a mean and an effective
sample size defined relative to sigma.<br />
The user also has to specify the number of patients for each stage of
the group sequential design, and the standard deviation (sigma) of the endpoint (assumed to be known).<br />
The operating characteristics are either evaluated for a user-specified grid of true treatment differences, or for a grid or set of true treatment means for the two arms. The operating characteristics of main interest are the probabilities of success and futility at each interim analysis, and the expected sample size.<br />
The main function of the package is <code>gsb()</code>. More detailed information can be found in the help of function <code>gsb()</code>.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> gsbDesign</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 1.0-3</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2024-01-23</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GNU General Public License &gt;=3</td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Florian Gerber &lt;florian.gerber@math.uzh.ch&gt;, Thomas Gsponer
</p>


<h3>References</h3>


<ul>
<li><p> Gerber F, Gsponer T (2016). 
gsbDesign: An R Package for Evaluating the Operating Characteristics of a Group Sequential Bayesian Design.
Journal of Statistical Software, 69(11), 1-23, DOI: 10.18637/jss.v069.i11
</p>
</li>
<li><p> Gsponer T, Gerber F, Bornkamp B, Ohlssen D, Vandemeulebroecke M, Schmidli H (2014).
A Practical Guide to Bayesian Group Sequential Designs.
Pharmaceutical Statistics, 13(1) 71-80, DOI: 10.1002/pst.1593
</p>
</li>
<li><p> Berry SM, Carlin BP, Lee JJ, and Mueller P
(2010). Bayesian Adaptive Methods for Clinical Trials.
Chapman&amp;Hall/CRC, London.
</p>
</li>
<li><p> Jennison C, and Turnbull BW (2000). Group Sequential Methods
with Applications to Clinical Trials. Chapman&amp;Hall/CRC, London.
</p>
</li>
<li><p> Spiegelhalter DJ, Abrams KR, and Myles, J. P. (2004). Bayesian
Approaches to Clinical Trials and Health Care Evaluation. Wiley, New
York.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+gsb">gsb</a></code>
</p>

<hr>
<h2 id='plot.gsbMainOut'>
Plot methods
</h2><span id='topic+plot.gsbMainOut'></span><span id='topic+plot.gsbDesign'></span><span id='topic+plot.gsbSimulation'></span>

<h3>Description</h3>

<p>Methods for plotting the results of <code>gsb()</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsbMainOut'
plot(x,
     what=c("all", "cumulative all",
            "both", "cumulative both",
            "sample size", "success", "futility",
            "success or futility", "indeterminate", "cumulative success",
            "cumulative futility", "cumulative success or futility",
            "cumulative indeterminate", "boundary",
            "std.boundary","delta.grid","patients"),
     range.delta = "default",
     stages = "default",
     delta.grid = TRUE,
     color = TRUE,
     smooth = 100,
     contour = TRUE, 
     export = FALSE,
     path = tempdir(),
     sliced = FALSE,
     range.control="default", ...)

## S3 method for class 'gsbSimulation'
plot(x,...)

## S3 method for class 'gsbDesign'
plot(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gsbMainOut_+3A_x">x</code></td>
<td>

<p>object of appropriate class.  
</p>
</td></tr>
<tr><td><code id="plot.gsbMainOut_+3A_what">what</code></td>
<td>

<p>a <code>character string</code> to choose a plot. It should
correspond to one level of <code>OC$type</code> where <code>OC</code> is an
object of the output of <code>gsb()</code>. Additional possibilities are
<code>what = "all"</code> to plot the success-, futility- and success or
futility-probabilities, <code>what = "cumulative all"</code> to plot the
cumulative success-, cumulative futility- and cumulative success or
futility-probabilities, <code>what = "boundary"</code> or <code>what =
  "std.boundary"</code> to plot the bounds, <code>what = "patients"</code> for a histogram of
the patients per stage and <code>what = "delta.grid"</code> to plot the
grid of delta's.
</p>
</td></tr>
<tr><td><code id="plot.gsbMainOut_+3A_range.delta">range.delta</code></td>
<td>

<p>a <code>vector</code> of length 2. For choosing the plot limits manually
set <code>range.delta = c(min, max)</code> for a Bayesian update on
&quot;treatment effect&quot; or <br /> <code>range.delta = c(control.min, control.max, treatment.min, treatment.max)</code> for a Bayesian update &quot;per arm&quot;. If
<code>range.delta = "default"</code> the range of the
plot is chosen so that all delta's are covered.
</p>
</td></tr>
<tr><td><code id="plot.gsbMainOut_+3A_stages">stages</code></td>
<td>

<p>a <code>vector</code> of length 2 containing the number of the lowest and
highest stage, which should be plotted. If <code>stages = "default"</code>
all stages are plotted (expect for <code>what = "sample size"</code> where
only the last stage is plotted.)
</p>
</td></tr>
<tr><td><code id="plot.gsbMainOut_+3A_delta.grid">delta.grid</code></td>
<td>

<p><code>logical</code>. If <code>TRUE</code> the delta grid is plotted too.
</p>
</td></tr>
<tr><td><code id="plot.gsbMainOut_+3A_color">color</code></td>
<td>

<p><code>logical</code>. If <code>TRUE</code> the plot is colored.
</p>
</td></tr>
<tr><td><code id="plot.gsbMainOut_+3A_smooth">smooth</code></td>
<td>

<p>a <code>vector</code> of length 1. A higher number makes the plot
'smoother' if <code>type.update = "per arm"</code>.
</p>
</td></tr>
<tr><td><code id="plot.gsbMainOut_+3A_contour">contour</code></td>
<td>

<p><code>logical</code>. If <code>TRUE</code> contour lines are added to the plot.
</p>
</td></tr>
<tr><td><code id="plot.gsbMainOut_+3A_export">export</code></td>
<td>

<p><code>logical</code>. If <code>TRUE</code> the plot is save as .png-file.
</p>
</td></tr>
<tr><td><code id="plot.gsbMainOut_+3A_path">path</code></td>
<td>

<p><code>character</code>. to specify the location to which to table should
be exported. the default 'tempdir()' exports the table to a temporary
directory.
</p>
</td></tr>
<tr><td><code id="plot.gsbMainOut_+3A_sliced">sliced</code></td>
<td>

<p><code>logical</code>. If <code>TRUE</code> the contour plot for <code>type.update =
    "per arm"</code> is shown in several 2D plots. In order to use this option
the argument <code>grid.type</code> of <code>gsbSimulation()</code> has to be <code>sliced</code>.   
</p>
</td></tr>
<tr><td><code id="plot.gsbMainOut_+3A_range.control">range.control</code></td>
<td>

<p>a <code>vector</code> of length 2 or \&quot;default\&quot;. If <code>special = TRUE</code>
the range of the control values can be set manually as vector c(min, max). 
</p>
</td></tr>
<tr><td><code id="plot.gsbMainOut_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>"trellis"</code>
</p>


<h3>Author(s)</h3>

<p>Florian Gerber &lt;florian.gerber@math.uzh.ch&gt;, Thomas Gsponer
</p>


<h3>References</h3>

<p>uses the R-package 'lattice'. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsb">gsb</a></code>, <a href="lattice.html#topic+xyplot">xyplot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## please see examples of function 'gsb'. 
## --------------------------------------


## --------------------------------------
## alternative plots can be created for example
## with package 'ggplot2'.

des &lt;- gsbDesign(nr.stages=2,
                     patients=10,
                     sigma=10,
                     criteria.success=c(0,0.8, 7, 0.5),
                     criteria.futility=c(2,0.8),
                     prior.difference="non-informative")

sim &lt;- gsbSimulation(truth=c(-10,20,60),
                             type.update="treatment effect")


x &lt;- gsb(des,sim)

## get data.frame with operating characteristics
datgraph &lt;- x$OC


## prepare for plot
sub &lt;- c("success", "futility", "success or futility")
datgraph2 &lt;- subset(datgraph,datgraph$type %in% sub)
datgraph2$type &lt;- as.factor(paste(datgraph2$type))
datgraph2$value[datgraph2$type=="cumulative success or futility"] &lt;-
1-datgraph2$value[datgraph2$type=="cumulative success or futility"]
levels(datgraph2$type) &lt;- c("1)cumulative futility" ,"3)cumulative success","2)indeterminate")
datgraph2$type=as.factor(paste(datgraph2$type))
levels(datgraph2$type) &lt;- c("cumulative futility" ,"indeterminate","cumulative success")
datgraph2 &lt;- datgraph2[order(datgraph2$delta),]


## plots
library(ggplot2)
p1 &lt;- qplot(delta,value,geom="blank",color=type,facets=.~stage,data=datgraph2,
xlab=expression(delta))

p1+geom_line(size=1.5)+scale_color_manual(values = c("cumulative futility" = "dark red",
"indeterminate" = "orange", "cumulative success" = "dark green"))

p2=p1+geom_area(aes(x = delta,y=value,fill=type))

p2+scale_fill_manual(values = c("cumulative futility" = "dark red",
"indeterminate" = "orange", "cumulative success" = "dark green"))


</code></pre>

<hr>
<h2 id='tab'>
get tables.
</h2><span id='topic+tab'></span>

<h3>Description</h3>

<p>This function creates tables from the output of function
<code>gsb()</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab(x,
    what=c("all", "cumulative all", "success", "futility",
           "indeterminate", "success or futility", 
           "cumulative success", "cumulative futility",
           "cumulative indeterminate", "cumulative success or futility",
           "sample size"),
    atDelta = "default",
    wide=FALSE,
    digits = 3,
    export = FALSE,
    sep = ",",
    path = tempdir())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tab_+3A_x">x</code></td>
<td>

<p>object of class <code>gsbMainOut</code> which is returned by the function
<code>gsb()</code>.
</p>
</td></tr>
<tr><td><code id="tab_+3A_what">what</code></td>
<td>

<p><code>string</code> to specify the content of the table. It should correspond
one level of <code>OC$type</code> in the output of <code>gsb()</code>. 
</p>
</td></tr>
<tr><td><code id="tab_+3A_atdelta">atDelta</code></td>
<td>

<p>if <code>"default"</code> the table shows the operating characteristics
evaluated at the actually calculated true values entered in argument
<code>truth</code> of function <code>gsbSimulation</code>. Alternatively a
<code>numeric</code> of arbitrary length can be entered. Then the operating
characteristics are displayed for the true value delta entered in this
<code>numeric</code> using a linear interpolation. This only works if <code>type.update = "treatment effect"</code>.
</p>
</td></tr>
<tr><td><code id="tab_+3A_wide">wide</code></td>
<td>

<p><code>logical</code>. If TRUE a zable in wide format is produced. Only
possible if <code>grid.type = "table"</code>.
</p>
</td></tr>
<tr><td><code id="tab_+3A_digits">digits</code></td>
<td>

<p><code>numeric</code> of length 1 specifying the number of digits which should be
displayed in the table. The function <code>round()</code> is used. If <code>what = "sample size"</code> and <code>digits = 0</code>, the function uses <code>ceiling()</code> instead. 
</p>
</td></tr>
<tr><td><code id="tab_+3A_export">export</code></td>
<td>

<p><code>logical</code>. if <code>TRUE</code> the table is exported and saved as .cvs-file.   </p>
</td></tr>
<tr><td><code id="tab_+3A_sep">sep</code></td>
<td>

<p><code>character</code>. the field separator string. if the table is
exported the values are separated by this string.
</p>
</td></tr>
<tr><td><code id="tab_+3A_path">path</code></td>
<td>

<p><code>character</code>. to specify the location to which to table should
be exported. the default 'tempdir()' exports the table to a temporary
directory.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with the results from the output of function
<code>gsb()</code>. 
</p>


<h3>Author(s)</h3>

<p>Florian Gerber &lt;florian.gerber@math.uzh.ch&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## please see examples of function 'gsb'.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
