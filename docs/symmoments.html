<!DOCTYPE html><html lang="en"><head><title>Help for package symmoments</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {symmoments}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#symmoments-package'><p>Symbolically compute and numerically evaluate multivariate central moments</p></a></li>
<li><a href='#+20evaluate'><p> Evaluate a multivariate moment</p></a></li>
<li><a href='#+20evaluate_expected.polynomial'><p> Evaluate the expected value of a multivariate polynomial</p></a></li>
<li><a href='#+20evaluate_noncentral'><p> Evaluate a noncentral multivariate moment</p></a></li>
<li><a href='#+20multmoments'><p> Recursive function to compute a multivariate moment</p></a></li>
<li><a href='#callmultmoments'><p> Compute multivariate moment symbolically</p></a></li>
<li><a href='#convert.mpoly'><p> Convert between mpoly and list representations of multivariate polynomials</p></a></li>
<li><a href='#convert.multipol'><p> Convert between multipol and list representations of multivariate polynomials</p></a></li>
<li><a href='#integrate.polynomial'><p>Numerically integrate a multivariate polynomial</p></a></li>
<li><a href='#make.all.moments'><p> Create all moments up to specified size in environment symmoments</p></a></li>
<li><a href='#print.moment'><p> Print the representation of a multivariate moment</p></a></li>
<li><a href='#simulate.moment'><p> Method to compute a multivariate moment using Monte Carlo integration</p></a></li>
<li><a href='#toLatex_noncentral'><p>Compute a Latex expression for a noncentral moment</p></a></li>
<li><a href='#toLatex.moment'><p> LaTeX a multivariate moment</p></a></li>
<li><a href='#toMatching'><p>Convert representation of a phylogenetic tree as a moment L-matrix to matching form</p></a></li>
<li><a href='#toMoment'><p>Converts a tree from Newick or matching to moment format</p></a></li>
<li><a href='#toNewick'>
<p>convert representation of phylogenetic tree as a moment L-matrix to Newick form</p></a></li>
<li><a href='#tounsorted'><p>Compute an unsorted central moment object from a sorted object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Symbolic Central and Noncentral Moments of the Multivariate
Normal Distribution</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-01-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Kem Phillips</td>
</tr>
<tr>
<td>Depends:</td>
<td>mvtnorm, cubature, combinat, multipol</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape, mpoly</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kem Phillips &lt;kemphillips@comcast.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Symbolic central and non-central moments of the multivariate normal distribution. Computes a standard representation, LateX code, and values at specified mean and covariance matrices.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-05 13:46:35 UTC; Kem</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-05 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='symmoments-package'>Symbolically compute and numerically evaluate multivariate central moments</h2><span id='topic+symmoments-package'></span><span id='topic+symmoments'></span>

<h3>Description</h3>

<p>Symbolically computes and numerically evaluates multivariate normal moments  
E[X1**2 *...* Xn**n], where (X1,...,Xn) ~ N(mu,S), 
in terms of mu and S elements.
</p>
<p>Produces Latex code for the moment.
</p>
<p>Computes numerical moments at specified means and covariance matrices.
</p>
<p>Also converts between moment L-matrices, phylo objects, and matching objects.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> symmoments</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-05-30</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL 2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>

</table>

<p>A representation of a central moment of the multivariate normal distribution, given by a 
positive integer vector c(k1,k2,...,kn), is obtained from the function <code>callmultmoments</code>.
This function initializes variables and calls the function multmoments which determines 
a representation of a multivariate moment using a recursive algorithm.   
The representation is given class 'moment'.
</p>
<p>The <code>print</code> method prints the representation of a multivariate moment.
</p>
<p>The <code>toLatex</code> method uses the output of callmultmoments to determine the LaTeX code 
for the moment sorted lexicographically.  
</p>
<p>The generic <code>evaluate</code> method uses the output of callmultmoments to determine
the value of the moment for a specified covariance matrix.
</p>
<p>The <code>simulate</code> method is used to approximate a (possibly non-central) moment 
using Monte Carlo integration.
</p>
<p>The following functions compute non-central moments and do related computations:
</p>
<p>The <code>toLatex_noncentral</code> function computes the Latex representations of a non-central moment.  
</p>
<p>The <code>evaluate_noncentral</code> computes the value of a non-central moment.
</p>
<p>The <code>evaluate_expected.polynomial</code> function evaluates the expected value
of a multivariate polynomial defined by a list, multipol object, or mpoly object.
</p>
<p>The <code>convert.multipol</code> function converts between multipol objects and 
multivariate polynomials defined by lists.
</p>
<p>The <code>convert.mpoly</code> function converts between mpoly objects and 
multivariate polynomials defined by lists.
</p>
<p>The <code>tounsorted</code> function converts a sorted moment (e.g. m123) to an unsorted moment (e.g. m312).
</p>
<p>The <code>make.all.moments</code> function computes all moments up to a specified size and places them in the symmoments environment. 
</p>
<p>The <code>integrate.polynomial</code> function integrates a multivariate polynomial against
the normal distribution using ordinary integration.
</p>
<p>The functions <code>toMoment</code>, <code>toNewick</code>, and <code>toMatching</code>
convert among moment L-matrices, Newick trees, and <code>ape</code> matching objects.
</p>


<h3>Note</h3>

<p>The mvtnorm package must be loaded for the simulate method.
The cubature package must be loaded for the integrate.polynomial function.
The combinat package must be loaded for the toMoment function.</p>


<h3>Author(s)</h3>

<p>Maintainer: Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p>K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the moment for the 4-dimensional moment c(1,2,3,4):
callmultmoments(c(1,2,3,4)) 

# Print the representation of the 4-dimensional moment c(1,2,3,4):
print(callmultmoments(c(1,2,3,4))) 

# Compute the LaTeX representation of the central moment c(1,2,3,4):
toLatex(callmultmoments(c(1,2,3,4)))

# Write the LaTeX representation to a file using the standard R function (not run):
# writeLines(callmultmoments(c(1,2,3,4))),con="yourfilename", sep = "\n")

# evaluate the moment c(1,2,3,4) at the following variance-covariance matrix
  #  4 2 1 1
  #  2 3 1 1
  #  1 1 2 1

evaluate(callmultmoments(c(1,2,3,4)),c(4,2,1,1,3,1,1,2,1,2))

# Using 10000 samples, estimate the central moment for c(2,4) at the covariance matrix (not run)
#  2 1
#  1 4

# and mean (0,0)
library(mvtnorm)
simulate(callmultmoments(c(2,4)),10000,NULL,c(0,0),c(2,1,1,4))

# Compute Latex representation of a non-central moment
# as.matrix(toLatex_noncentral(c(1,3))) 

# Create all 2-dimensional moment objects with exponents up to 3 
# First create the symmoments environment if it does not exist
# symmoments &lt;- new.env()
# make.all.moments(c(3,3))

# Evaluate a non-central moment at a specified mean and covariance matrix
# Note that this invocation requires moments of order up to c(1,3)
# to exist in environment symmoments.
# evaluate_noncentral(c(1,3),c(1,2),c(1,0,1))

# Create an mpoly object 
library(mpoly)
t0 &lt;- mpoly(list(c(coef=3,x1=2),c(coef=2,x1=1,x2=3),
                   c(coef=-4,z=2),c(coef=1,x1=1,x2=2,z=1)))  
                     
# Convert an mpolyobject to a moment object
t1 &lt;&lt;- convert.mpoly(t0)      

# Convert a moment object to a multipol object
t2 &lt;&lt;- convert.multipol(t1)

# Convert from multipol back to mpoly through moment

mpoly(convert.mpoly(convert.multipol(t2)))     

# Evaluate the expected value of a multivariate polynomial
# Required moments must exist in environment symmoments.

# evaluate_expected.polynomial(t0,c(1,2,3),c(1,0,0,1,0,1))

# Create a Newick representation of a tree
exam.Newick      &lt;- "(((a,b),c),d);"

# Convert to phylo format
library(ape)
exam.phylo       &lt;- read.tree(text=exam.Newick)

# Convert to matching format
exam.matching    &lt;- as.matching(exam.phylo)

# Convert to L-matrix format
exam.L.matrix    &lt;- toMoment(exam.matching)



</code></pre>

<hr>
<h2 id='+20evaluate'> Evaluate a multivariate moment  </h2><span id='topic+evaluate.moment'></span><span id='topic+evaluate'></span>

<h3>Description</h3>

<p>Generic method for class moment to compute the numerical value of a moment at a specified covariance matrix from the output of callmultmoments</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'moment'
evaluate(object,sigma) </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B20evaluate_+3A_object">object</code></td>
<td>
<p> an object of class 'moment' </p>
</td></tr>
<tr><td><code id="+2B20evaluate_+3A_sigma">sigma</code></td>
<td>
<p>an upper-triangular matrix of covariance terms expressed as a vector at which the moment is to be evaluated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>object is normally the output of a call to callmultmoment.
This is a list with first component the moment itself,
the second component the set of upper-triangular matrices representing the moment,
and the third component containing their corresponding coefficients.
This is an object of class 'moment'.
</p>


<h3>Value</h3>

<p>numeric value of the moment at the specified covariance matrix</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, Journal of Statistical Software, 2010. 
</p>


<h3>See Also</h3>

<p> callmultmoments and the simulate and toLatex methods from the symmoments package</p>


<h3>Examples</h3>

<pre><code class='language-R'>
evaluate(callmultmoments(c(1,2,3,4)),c(4,2,1,1,3,1,1,2,1,2))
# evaluates the moment at c(1,2,3,4) at the following covariance matrix
#    4 2 1 1
#    2 3 1 1
#    1 1 2 1
#    1 1 1 2

</code></pre>

<hr>
<h2 id='+20evaluate_expected.polynomial'> Evaluate the expected value of a multivariate polynomial </h2><span id='topic+evaluate_expected.polynomial'></span>

<h3>Description</h3>

<p>Evaluate the expected value of a multivariate polynomial 
assuming a specified non-central multivariate distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'> evaluate_expected.polynomial(poly,mu,sigma, envir='symmoments') </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B20evaluate_expected.polynomial_+3A_poly">poly</code></td>
<td>
<p> either an object of class 'mpoly' or 'multipol', or a list with components for coefficients and powers.</p>
</td></tr>
<tr><td><code id="+2B20evaluate_expected.polynomial_+3A_mu">mu</code></td>
<td>
<p> a vector of real numbers representing the mean of the multivariate distribution </p>
</td></tr>
<tr><td><code id="+2B20evaluate_expected.polynomial_+3A_sigma">sigma</code></td>
<td>
<p>an vector giving an upper-triangular matrix representing the covariance matrix of the multivariate distribution </p>
</td></tr>
<tr><td><code id="+2B20evaluate_expected.polynomial_+3A_envir">envir</code></td>
<td>
<p>a character variable specifying the environment
containing the central moments needed for the calculation </p>
</td></tr>
</table>


<h3>Details</h3>

<p> This function looks in the environment specified in the envir
argument for the central moments needed in the calculation.  The default
is the symmoments environment. The computation stops with an error 
message if a required moment is not found in envir.</p>


<h3>Value</h3>

<p>expected value of the multivariate polynomial at the specified multivariate normal mean and covariance matrix</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, Journal of Statistical Software, 2010. 
</p>


<h3>See Also</h3>

<p> See the evaluate_noncentral and make.all.moments functions.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define a mpoly object for a multivariate polynomial and determine
# its expected value at specified mean and covariance matrix:
# note that all moments up to c(2,3,2) must exist in the symmoments
# environment.  Use make.all.moments(c(2,3,2)) if necessary.
# use library(mpoly) for first statement below.

# t0 &lt;- mpoly(list(c(coef=3,x1=2),c(coef=2,x1=1,x2=3),c(coef=-4,z=2),c(coef=1,x1=1,x2=2,z=1)))
# evaluate_expected.polynomial(t0,c(1,2,3),c(1,0,0,1,0,1))



</code></pre>

<hr>
<h2 id='+20evaluate_noncentral'> Evaluate a noncentral multivariate moment  </h2><span id='topic+evaluate_noncentral'></span>

<h3>Description</h3>

<p>Computes the numerical value of a non-central moment at a specfied mean and specified covariance matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_noncentral(moment,mu,sigma,envir='symmoments') </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B20evaluate_noncentral_+3A_moment">moment</code></td>
<td>
<p> a vector of non-negative integers representing the non-central moment to be evaluated</p>
</td></tr>
<tr><td><code id="+2B20evaluate_noncentral_+3A_mu">mu</code></td>
<td>
<p> a vector of real numbers representing the mean of the multivariate normal distribution </p>
</td></tr>
<tr><td><code id="+2B20evaluate_noncentral_+3A_sigma">sigma</code></td>
<td>
<p>an upper-triangular matrix of covariance terms for the 
multivariate normal distribution expressed as a vector at which the moment is to be evaluated</p>
</td></tr>
<tr><td><code id="+2B20evaluate_noncentral_+3A_envir">envir</code></td>
<td>
<p>a character variable specifying the environment
containing the central moments needed for the calculation </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function looks in the environment specified in the envir
argument for the central moments needed in the calculation.  The default
is the symmoments environment.  All even moments less than or equal to 
the moment argument are required.  The computation stops with an error 
message if a required moment is not found in envir.</p>


<h3>Value</h3>

<p>numeric value of the moment at the specified mean and covariance matrix</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, Journal of Statistical Software, 2010. 
</p>


<h3>See Also</h3>

<p> See the evaluate.moment and make.all.moments functions.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# evaluate_noncentral(c(3,1,2),c(3,4,1),c(4,2,1,3,1,2))
# evaluates the expected value of X1**3 X2 X3**2 at mean c(1,2,3) 
# and at the following covariance matrix
#    4 2 1 
#    2 3 1 
#    1 1 2 

#  requires all moments up to c(3,1,2) to exist in the symmoments environment.
#  use  make.all.moments(c(3,1,2)) if necessary.

# use moments in the global environment:
# evaluate_noncentral(c(3,1,2),c(3,4,1),c(4,2,1,3,1,2),'.GlobalEnv')

</code></pre>

<hr>
<h2 id='+20multmoments'> Recursive function to compute a multivariate moment </h2><span id='topic+multmoments'></span>

<h3>Description</h3>

<p>Called by callmultmoments to compute representation of a multivariate normal moment using recursive algorithm</p>


<h3>Usage</h3>

<pre><code class='language-R'>multmoments(moment,current.matrix,current.cell,moment.rep,row_col)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B20multmoments_+3A_moment">moment</code></td>
<td>
<p>vector c(k1,...,kn) specifying the moment X1**k1 *...* Xn**kn</p>
</td></tr>
<tr><td><code id="+2B20multmoments_+3A_current.matrix">current.matrix</code></td>
<td>
<p> upper-triangular integer matrix under consideration in recursion</p>
</td></tr>
<tr><td><code id="+2B20multmoments_+3A_current.cell">current.cell</code></td>
<td>
<p> cell in current matrix under consideration in recursion</p>
</td></tr>
<tr><td><code id="+2B20multmoments_+3A_moment.rep">moment.rep</code></td>
<td>
<p> current set of representations; mult.moments adds each satisfying matrix to moment.rep</p>
</td></tr>
<tr><td><code id="+2B20multmoments_+3A_row_col">row_col</code></td>
<td>
<p> matrix giving rows and columns for square matrix for each cell</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row of the representation gives the exponents for a single product of covariance terms. For example, (1,2,0) represents S11**1 S12**2 S22**0, where the Sij are the covariances.
</p>
<p>This function would normally only be called by callmultmoments.</p>


<h3>Value</h3>

<p> moment representation, moment.rep, augmented with additional representations</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010. 
</p>


<h3>See Also</h3>

<p> callmultmoments (symmoments) </p>

<hr>
<h2 id='callmultmoments'> Compute multivariate moment symbolically  </h2><span id='topic+callmultmoments'></span>

<h3>Description</h3>

<p>Computes a multivariate normal moment by initializing variables, calling multmoments, and constructing output</p>


<h3>Usage</h3>

<pre><code class='language-R'>callmultmoments(moment)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="callmultmoments_+3A_moment">moment</code></td>
<td>
<p> vector c(k1,... ,kn) specifying the moment X1**k1 *...* Xn**kn </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row of the representation gives the exponents for a single product of covariance terms.
For example, (1,2,0) represents S11**1 S12** S22**0, where the Sij are the covariances.  
The full moment is the sum of these terms multiplied by their respective coefficients.
If the sum of the exponents is odd, the moment is 0.  
</p>


<h3>Value</h3>

<p>A object of class 'moment', which is a list with three components:
</p>
<table role = "presentation">
<tr><td><code>moment</code></td>
<td>
<p>the input moment vector</p>
</td></tr>
<tr><td><code>representation</code></td>
<td>
<p>a matrix containing the representation in terms of upper-triangular matrices</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the coefficients corresponding to the rows of the representation</p>
</td></tr>
</table>
<p>If the sum of the exponents is odd, returns -1 and prints &quot;Sum of powers is odd. Moment is 0.&quot;
</p>
<p>If any exponent is negative, returns -2 and prints &quot;All components of the moment must be non-negative.&quot;
</p>
<p>If any exponent is not an integer, returns -3 and prints &quot;All components of the moment must be integers.&quot;
</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010.</p>


<h3>See Also</h3>

<p> multmoments and the methods toLatex, evaluate, and simulate in symmoments</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the moment for the 4-dimensional moment c(1,2,3,4):

m.1234 &lt;- callmultmoments(c(1,2,3,4))
</code></pre>

<hr>
<h2 id='convert.mpoly'> Convert between mpoly and list representations of multivariate polynomials  </h2><span id='topic+convert.mpoly'></span>

<h3>Description</h3>

<p>Converts an mpoly object to a simple list representing a multivariate polynomial or a simple list to an mpoly object</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.mpoly(poly)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.mpoly_+3A_poly">poly</code></td>
<td>
<p> an mpoly object or a list giving powers and coefficients defining the polynomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list representation consists of 2 components: 'powers' is a matrix with each row representing the powers of X in one term of the multivariate polynomial. 'coeff' is a vector with each element being the coefficient of the corresponding term in powers</p>


<h3>Value</h3>

<p>if poly is of class 'mpoly', it is a list with two components shown below.  If poly is such a list, the value is the corresponding mpoly object</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010.</p>


<h3>See Also</h3>

<p> convert.multipol, evaluate.expected.polynomial, integrate.polynomial</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an mpoly object here (requires library mpoly) (not run)

# convert from mpoly to list representation
# t0 &lt;- mpoly::mpoly(list(c(coef=3,x1=2),c(coef=2,x1=1,x2=3),
#                   c(coef=-4,z=2),c(coef=1,x1=1,x2=2,z=1)))  
# t1 &lt;- convert.mpoly(t0)    
# convert from list representation back to an mpoly object
# t2 &lt;- convert.mpoly(t1) 

</code></pre>

<hr>
<h2 id='convert.multipol'> Convert between multipol and list representations of multivariate polynomials  </h2><span id='topic+convert.multipol'></span>

<h3>Description</h3>

<p>Converts an multipol object to a simple list representing a multivariate polynomial or a simple list to an multipol object</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.multipol(poly)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.multipol_+3A_poly">poly</code></td>
<td>
<p> a multipol object or a list giving powers and coefficients defining the polynomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list representation consists of 2 components: 'powers' is a matrix with each row representing the powers of X in one term of the multivariate polynomial. 'coeff' is a vector with each element being the coefficient of the corresponding term in powers</p>


<h3>Value</h3>

<p>if poly is of class 'multipol', it is a list with two components described below.  If poly is such a list, the value is the corresponding multipol object</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010.</p>


<h3>See Also</h3>

<p> convert.multipol, evaluate.expected.polynomial, integrate.polynomial</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an mpoly object to work with (requires library mpoly) (not run)


# t0 &lt;- mpoly::mpoly(list(c(coef=3,x1=2),c(coef=2,x1=1,x2=3),
#                   c(coef=-4,z=2),c(coef=1,x1=1,x2=2,z=1))) 

# convert from mpoly to list representation (not run)
# t1 &lt;- convert.mpoly(t0)    
# convert from list representation to a multipol object(not run)

# t2 &lt;- convert.multipol(t1) 
# convert back to a list representation (not run)

# t3 &lt;- convert.multipol(t2) 
</code></pre>

<hr>
<h2 id='integrate.polynomial'>Numerically integrate a multivariate polynomial </h2><span id='topic+integrate.polynomial'></span>

<h3>Description</h3>

<p> Integrates a multivariate polynomial against a specified non-central multivariate distribution 
using 
ordinary integration by invoking the adaptIntegrate function from the cubature package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate.polynomial(poly,mu,sigma,lower=NULL,upper=NULL) </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="integrate.polynomial_+3A_poly">poly</code></td>
<td>
<p> either an object of class 'mpoly' or 'multipol', or a list with two components for coefficients and powers. </p>
</td></tr>
<tr><td><code id="integrate.polynomial_+3A_mu">mu</code></td>
<td>
<p> a vector giving the mean of the multivariate distribution </p>
</td></tr>
<tr><td><code id="integrate.polynomial_+3A_sigma">sigma</code></td>
<td>
<p> a square matrix giving the covariance matrix of the multivariate distribution </p>
</td></tr>
<tr><td><code id="integrate.polynomial_+3A_lower">lower</code></td>
<td>
<p> vectors of the lower limits of integration, one element for each dimension of the moment </p>
</td></tr>
<tr><td><code id="integrate.polynomial_+3A_upper">upper</code></td>
<td>
<p> vectors of the upper limits of integration, one element for each dimension of the moment </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Defaults for lower and upper are -/+ 6 times the standard deviations (square roots of diagonal elements of the covariance matrix).
If the polynomial is defined by a list, it has two components, coeff and powers.  
powers is a matrix.  Each row represents the powers for a term in the polynomial. 
coeff is a vector.  Each element is the coefficient of the corresponding power.
Example corresponding to example below:  list(coeff=c(3,2,-4,1),powers=matrix(c(2,0,0,1,3,0,0,0,2,1,2,1),ncol=3,byrow=TRUE))</p>


<h3>Value</h3>

<p>the expected value of the polynomial integrated against the multivariate normal distribution</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010.</p>


<h3>See Also</h3>

<p> evaluate.expected.polynomial, multmoments, evaluate, and simulate in symmoments</p>


<h3>Examples</h3>

<pre><code class='language-R'># define a mpoly object for a multivariate polynomial, and 
# determine its expected value at specified mean and covariance matrix:

# t0 &lt;- mpoly(list(c(coef=3,x1=2),c(coef=2,x1=1,x2=3),c(coef=-4,z=2),c(coef=1,x1=1,x2=2,z=1)))


# integrate.polynomial(t0,c(1,2,3),matrix(c(1,0,0,0,1,0,0,0,1),nrow=3,byrow=TRUE))


</code></pre>

<hr>
<h2 id='make.all.moments'> Create all moments up to specified size in environment symmoments  </h2><span id='topic+make.all.moments'></span>

<h3>Description</h3>

<p>Create all central moment objects of a specified or smaller size in environment symmoments</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.all.moments(moment,verbose=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.all.moments_+3A_moment">moment</code></td>
<td>
<p> vector c(k1,... ,kn) specifying the highest moment to compute </p>
</td></tr>
<tr><td><code id="make.all.moments_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE (default), the names of the moments are shown as the algorithm progresses; if FALSE, progress is not shown</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unsorted moments, those with exponents are not in numeric order,
are created in the symmoments environment using the <code>tounsorted</code>
function to transform from the sorted moment. If symmoments does not 
exist, the user is prompted to create it using symmoments &lt;- new.env().
</p>
<p>If the sorted moment does not exist, it is created.
</p>
<p>Moments of lower dimension are not created; for example, if c(2,4) is  input, m20 is created, but m2 is not.
</p>
<p>Moments are named mij..l, e.g., m136. 
If any exponent is greater than 9,
lower case letters and then upper case letters are used.  
For example,
m3bA is the name of the moment c(3,11,36).
</p>
<p>The largest exponent allowed by this scheme is 9+26+26=61,
</p>
<p>If an object with a name of this form exists but is not an object of class &quot;moment&quot;, 
it is replaced (overwritten) by the moment object.
</p>


<h3>Value</h3>

<p>all objects of class 'moment' up to the value given in moment are created in environment symmoments</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010.</p>


<h3>See Also</h3>

<p> callmultmoments, tounsorted</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute all moments up to c(3,3)
# First create the symmoments environment if it does not exist 
# symmoments &lt;- new.env()
# make.all.moments(c(3,3))
</code></pre>

<hr>
<h2 id='print.moment'> Print the representation of a multivariate moment </h2><span id='topic+print.moment'></span>

<h3>Description</h3>

<p>Prints an object of class 'moment'</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'moment'
print(x,...) </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.moment_+3A_x">x</code></td>
<td>
<p> an object of class 'moment', usually the output of callmultmoments</p>
</td></tr>
<tr><td><code id="print.moment_+3A_...">...</code></td>
<td>
<p>Included only for consistency with generic function</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Prints the moment as E[X1**k1 X2**k2 ...]:  followed by the lines of the representation
with the corresponding coefficient attached</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010. </p>


<h3>See Also</h3>

<p> callmultmoments (symmoments) </p>


<h3>Examples</h3>

<pre><code class='language-R'>print(callmultmoments(c(1,2,3)))</code></pre>

<hr>
<h2 id='simulate.moment'> Method to compute a multivariate moment using Monte Carlo integration  </h2><span id='topic+simulate.moment'></span>

<h3>Description</h3>

<p>Computes a multivariate normal moment by Monte Carlo integration</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'moment'
simulate(object,nsim,seed,Mean,Sigma,...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.moment_+3A_object">object</code></td>
<td>
<p>object of class 'moment' representing E[X1**k1,...,Xn**kn]</p>
</td></tr>
<tr><td><code id="simulate.moment_+3A_nsim">nsim</code></td>
<td>
<p>the number of samples to generate in computing the integral</p>
</td></tr>
<tr><td><code id="simulate.moment_+3A_seed">seed</code></td>
<td>
<p>integer for random number generator (set.seed)</p>
</td></tr>
<tr><td><code id="simulate.moment_+3A_mean">Mean</code></td>
<td>
<p>the mean of (X1,...,Xn)</p>
</td></tr>
<tr><td><code id="simulate.moment_+3A_sigma">Sigma</code></td>
<td>
<p>covariance of (X1**k1,...,Xn**kn), dimension nXn, expressed as a vector by row </p>
</td></tr>
<tr><td><code id="simulate.moment_+3A_...">...</code></td>
<td>
<p>Included only for consistency with generic function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Approximate value of the moment</p>


<h3>Note</h3>

<p>Non-central moments can be approximated by specifying Mean. For central moments, set Mean to a vector of 0s.
</p>
<p>The mvtnorm package must be loaded for the function rmvnorm.</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p>Rizzo ML (2008). Statistical Computing with R. Chapman &amp; Hall/CRC</p>


<h3>See Also</h3>

<p> callmultmoments and the methods toLatex and evaluate from symmoments </p>


<h3>Examples</h3>

<pre><code class='language-R'># Using 10000 samples, estimate the central moment for the moment c(2,4) at the covariance matrix
#  2 1
#  1 4

# and mean (0,0)
library(mvtnorm)
simulate(callmultmoments(c(2,4)),10000,NULL,c(0,0),c(2,1,1,4))
</code></pre>

<hr>
<h2 id='toLatex_noncentral'>Compute a Latex expression for a noncentral moment   </h2><span id='topic+toLatex_noncentral'></span>

<h3>Description</h3>

<p>Compute a Latex expression for a noncentral moment </p>


<h3>Usage</h3>

<pre><code class='language-R'>toLatex_noncentral(moment,envir='symmoments')</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toLatex_noncentral_+3A_moment">moment</code></td>
<td>
<p> vector c(k1,... ,kn) specifying the moment X1**k1 *...* Xn**kn </p>
</td></tr>
<tr><td><code id="toLatex_noncentral_+3A_envir">envir</code></td>
<td>
<p>character variable specifying the environment that contains the required central moments</p>
</td></tr>
</table>


<h3>Details</h3>

<p> All required moment objects must exist in the specified environment, with default 'symmoments'. 
However, if the sorted version of an unsorted moment exists, the tounsorted function is used to obtain it.</p>


<h3>Value</h3>

<p>A text value giving the Latex representation of moment where X is multivariate normal</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010.</p>


<h3>See Also</h3>

<p> make.all.moments, tounsorted, callmultmoments and the method toLatex</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the Latex representation of the 2-dimensional moment c(1,3) (not run).
# This requires that all moments up to c(1,3) exist in the symmoments environment.
# toLatex_noncentral(c(1,3))
</code></pre>

<hr>
<h2 id='toLatex.moment'> LaTeX a multivariate moment </h2><span id='topic+toLatex.moment'></span>

<h3>Description</h3>

<p>Computes a LaTeX representation sorted lexicographically of an object of class 'moment'</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'moment'
toLatex(object,...) </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toLatex.moment_+3A_object">object</code></td>
<td>
<p> an object of class 'moment', usually the output of callmultmoments</p>
</td></tr>
<tr><td><code id="toLatex.moment_+3A_...">...</code></td>
<td>
<p>Included only for consistency with generic function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first element of the result is the moment expressed as an expected value (E[...] =).
The remaining lines are the LaTex representation broken at appropriate intervals for printing.
(Individual terms for high dimensions will still overrun a printed line.)
Double backslashes are inserted where LaTeX requires a backslash.
These can be reset to single backslashes by writing the output to a file using the R function writeLines from the base package.
</p>


<h3>Value</h3>

<p>Character vector giving the LaTeX code for the symbolic moment</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010. </p>


<h3>See Also</h3>

<p> callmultmoments and the evaluate method (symmoments) </p>


<h3>Examples</h3>

<pre><code class='language-R'>toLatex(callmultmoments(c(1,2,3)))</code></pre>

<hr>
<h2 id='toMatching'>Convert representation of a phylogenetic tree as a moment L-matrix to matching form</h2><span id='topic+toMatching'></span>

<h3>Description</h3>

<p>Function converts a tree in moment format to matching format.
</p>
<p>The input can be an <code>L-matrix</code> object, 
a square L matrix,
or an L matrix in reduced upper-triangular (vector) form.
</p>
<p>The <code>toMatching</code> function sets its list output to class <code>L-matching</code>,
which has 5 components, 
including the tree in matching format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toMatching(L, type = NULL, tip.label = NULL) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toMatching_+3A_l">L</code></td>
<td>
<p>An <code>L-matrix</code> object, a square L matrix,
or an L matrix in reduced  upper-triangular (vector) form.</p>
</td></tr>
<tr><td><code id="toMatching_+3A_type">type</code></td>
<td>
<p>If object is not of class &quot;L-matrix&quot; and is a square L matrix,
then type should be &quot;square'.  If it is an L matrix in upper triangular form,
type should be &quot;ut&quot;. </p>
</td></tr>
<tr><td><code id="toMatching_+3A_tip.label">tip.label</code></td>
<td>
<p>Character vector containing labels for tips. 
If null, labels default to &quot;a&quot;-&quot;z&quot; it at most 26; otherwise,
3-letter labels of the form &quot;aaa&quot;, &quot;aab&quot;,... </p>
</td></tr>
</table>


<h3>Details</h3>

<p> An <code>L-matrix</code> object is a list with 5 components: &quot;L&quot; is the L-matrix in square form. &quot;L.ut&quot; is the L-matrix in upper-triangular form. &quot;Newick&quot; is the Newick representation of the tree.
&quot;tip.label&quot; is the character vector of tip labels. &quot;tip.label.n&quot; is the number of tips.</p>


<h3>Value</h3>

<p>a matching representation of the phylogenetic tree corresponding to the input</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010.
</p>
<p>P.W. Diaconis and S. Holmes, Matchings and Phylogenetic Trees,
Proc. Natl. Acad. Sci., 1998,
95(25), 14600-14602</p>


<h3>See Also</h3>

<p>functions toMoment and toNewick</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a Newick object
exam.Newick      &lt;- "(((a,b),c),d);"
# convert to a moment L-matrix
exam.moment &lt;- toMoment(exam.Newick)
# convert to matching format
exam.matching &lt;- toMatching(exam.moment)
</code></pre>

<hr>
<h2 id='toMoment'>Converts a tree from Newick or matching to moment format</h2><span id='topic+toMoment'></span>

<h3>Description</h3>

<p>Converts a tree from Newick or matching to moment format</p>


<h3>Usage</h3>

<pre><code class='language-R'>toMoment(inputobject, tip.label = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toMoment_+3A_inputobject">inputobject</code></td>
<td>
<p>a tree in Newick format or a <code>matching</code> object defined in the <span class="pkg">ape</span> package</p>
</td></tr>
<tr><td><code id="toMoment_+3A_tip.label">tip.label</code></td>
<td>
<p>rearranged labels for tips; these must be the original labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The L-matrix class consists of $5$ components:
&quot;L&quot; is the L-matrix in square form. &quot;L.ut&quot; is the L-matrix in upper-triangular form.
&quot;Newick&quot; is the Newick representation of the tree.
&quot;tip.label&quot; is the character vector of tip labels. &quot;tip.label.n&quot; is the number of tips.
</p>


<h3>Value</h3>

<p>a moment L-matrix corresponding to the input phylogentic tree object</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010.
</p>
<p>J. Felsenstein, The Newick tree format, 1990,
http://evolution.genetics.washington.edu/phylip/newicktree.html 
</p>
<p>P.W. Diaconis and S. Holmes, Matchings and Phylogenetic Trees,
Proc. Natl. Acad. Sci., 1998,
95(25), 14600-14602
</p>


<h3>See Also</h3>

<p>functions toNewick and toMatching</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a Newick object
exam.Newick      &lt;- "(((a,b),c),d);"
# convert to a moment L-matrix
exam.moment &lt;- toMoment(exam.Newick)
# convert to matching object
exam.matching &lt;- toMatching(exam.moment)
# convert back to moment object
backto.moment &lt;- toMoment(exam.matching)
</code></pre>

<hr>
<h2 id='toNewick'>
convert representation of phylogenetic tree as a moment L-matrix to Newick form 
</h2><span id='topic+toNewick'></span>

<h3>Description</h3>

<p>function converts a tree in moment format to Newick format.
</p>
<p>The input can be an <code>L-matrix</code> object, 
a square $L$ matrix,
or an $L$ matrix in reduced upper-triangular (vector) form.
</p>
<p>The <code>toNewick</code> function sets its list output to class <code>L-Newick</code>,
which has $5$ components, 
including the tree in Newick format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toNewick(L, type = NULL, tip.label = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toNewick_+3A_l">L</code></td>
<td>
<p>L can be an <code>L-matrix</code> object, a square $L$ matrix,
or an $L$ matrix in reduced upper-triangular (vector) form.</p>
</td></tr>
<tr><td><code id="toNewick_+3A_type">type</code></td>
<td>
<p>if L is not a <code>L-matrix</code> object, either 'square' or 'ut' as listed above</p>
</td></tr>
<tr><td><code id="toNewick_+3A_tip.label">tip.label</code></td>
<td>
<p>Character vector containing labels for tips. 
If null, labels default to &quot;a&quot;-&quot;z&quot; it at most 26; otherwise,
3-letter labels of the form &quot;aaa&quot;, &quot;aab&quot;,... </p>
</td></tr>
</table>


<h3>Details</h3>

<p> An <code>L-matrix</code> object is a list with 5 components: &quot;L&quot; is the L-matrix in square form. &quot;L.ut&quot; is the L-matrix in upper-triangular form. &quot;Newick&quot; is the Newick representation of the tree.
&quot;tip.label&quot; is the character vector of tip labels. &quot;tip.label.n&quot; is the number of tips.</p>


<h3>Value</h3>

<p>a Newick representation of the phylogenetic tree corresponding to the input</p>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010.
</p>
<p>J. Felsenstein, The Newick tree format,
1990,
http://evolution.genetics.washington.edu/phylip/newicktree.html 
</p>
<p>P.W. Diaconis and S. Holmes, Matchings and Phylogenetic Trees,
Proc. Natl. Acad. Sci., 1998,
95(25), 14600-14602
</p>


<h3>See Also</h3>

<p>functions toMoment and toMatching</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a Newick object
exam.Newick      &lt;- "(((a,b),c),d);"
# convert to a moment L-matrix
exam.moment &lt;- toMoment(exam.Newick)
# convert back to Newick format
backto.Newick &lt;- toNewick(exam.moment)
</code></pre>

<hr>
<h2 id='tounsorted'>Compute an unsorted central moment object from a sorted object </h2><span id='topic+tounsorted'></span>

<h3>Description</h3>

<p>Produces an unsorted central moment object from a sorted object of class &quot;moment&quot;.
</p>
<p>Unsorted moments are those with exponents not in numeric order, e.g., m312.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tounsorted(moment,sorted.moment)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tounsorted_+3A_moment">moment</code></td>
<td>
<p> unsorted moment to obtain moment is in vector form, eg, c(3,1,2)</p>
</td></tr>
<tr><td><code id="tounsorted_+3A_sorted.moment">sorted.moment</code></td>
<td>
<p> sorted moment to use in obtaining unsorted moment
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The unsorted moment is obtained by resorting the rows and columns of the sorted moment sucessively. 
</p>


<h3>Value</h3>

<p>A object of class 'moment', which is a list with three components:
</p>
<table role = "presentation">
<tr><td><code>moment</code></td>
<td>
<p>the input moment vector</p>
</td></tr>
<tr><td><code>representation</code></td>
<td>
<p>a matrix containing the representation in terms of upper-triangular matrices</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the coefficients corresponding to the rows of the representation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kem Phillips &lt;kemphillips@comcast.net&gt;</p>


<h3>References</h3>

<p> K Phillips, Symbolic Computation of the Central Moments of the Multivariate Normal Distribution, 
Journal of Statistical Software, 2010.</p>


<h3>See Also</h3>

<p> multmoments</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain moment m312 from m123
tounsorted(c(3,1,2),callmultmoments(c(1,2,3)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
