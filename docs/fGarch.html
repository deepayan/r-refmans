<!DOCTYPE html><html lang="en"><head><title>Help for package fGarch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fGarch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fGarch-package'><p>Modelling heterskedasticity in financial time series</p></a></li>
<li><a href='#absMoments'><p>Absolute moments of GARCH distributions</p></a></li>
<li><a href='#coef-methods'><p>GARCH coefficients methods</p></a></li>
<li><a href='#fGARCH-class'><p>Class &quot;fGARCH&quot;</p></a></li>
<li><a href='#fGarchData'><p>Time series datasets</p></a></li>
<li><a href='#fGARCHSPEC-class'><p>Class &quot;fGARCHSPEC&quot;</p></a></li>
<li><a href='#fitted-methods'><p>Extract GARCH model fitted values</p></a></li>
<li><a href='#formula-methods'><p>Extract GARCH model formula</p></a></li>
<li><a href='#fUGARCHSPEC-class'><p>Class 'fUGARCHSPEC'</p></a></li>
<li><a href='#garchFit'><p>Univariate or multivariate GARCH time series fitting</p></a></li>
<li><a href='#garchFitControl'><p>Control GARCH fitting algorithms</p></a></li>
<li><a href='#garchSim'><p>Simulate univariate GARCH/APARCH time series</p></a></li>
<li><a href='#garchSpec'><p>Univariate GARCH/APARCH time series specification</p></a></li>
<li><a href='#ged'><p>Standardized generalized error distribution</p></a></li>
<li><a href='#gedFit'><p>Generalized error distribution parameter estimation</p></a></li>
<li><a href='#gedSlider'><p>Generalized error distribution slider</p></a></li>
<li><a href='#plot-methods'><p>GARCH plot methods</p></a></li>
<li><a href='#predict-methods'><p>GARCH prediction function</p></a></li>
<li><a href='#residuals-methods'><p>Extract GARCH model residuals</p></a></li>
<li><a href='#sged'><p>Skew generalized error distribution</p></a></li>
<li><a href='#sgedFit'><p>Skew generalized error distribution parameter estimation</p></a></li>
<li><a href='#sgedSlider'><p>Skew GED distribution slider</p></a></li>
<li><a href='#snorm'><p>Skew normal distribution</p></a></li>
<li><a href='#snormFit'><p>Skew normal distribution parameter estimation</p></a></li>
<li><a href='#snormSlider'><p>Skew normal distribution slider</p></a></li>
<li><a href='#sstd'><p>Skew Student-t distribution</p></a></li>
<li><a href='#sstdFit'><p>Skew Student-t distribution parameter estimation</p></a></li>
<li><a href='#sstdSlider'><p>Skew Student-t distribution slider</p></a></li>
<li><a href='#stats-tsdiag'><p>Diagnostic plots and statistics for fitted GARCH models</p></a></li>
<li><a href='#std'><p>Standardized Student-t distribution</p></a></li>
<li><a href='#stdFit'><p>Student-t distribution parameter estimation</p></a></li>
<li><a href='#stdSlider'><p>Student-t distribution slider</p></a></li>
<li><a href='#summary-methods'><p>GARCH summary methods</p></a></li>
<li><a href='#VaR'><p>Compute Value-at-Risk (VaR) and expected shortfall (ES)</p></a></li>
<li><a href='#volatility-methods'><p>Extract GARCH model volatility</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Rmetrics - Autoregressive Conditional Heteroskedastic Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>4033.92</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyze and model heteroskedastic behavior in financial time series.</td>
</tr>
<tr>
<td>Imports:</td>
<td>fBasics, timeDate, timeSeries, fastICA, Matrix (&ge; 1.5-0),
cvar (&ge; 0.5), graphics, methods, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit, tcltk, goftest</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://geobosh.github.io/fGarchDoc/">https://geobosh.github.io/fGarchDoc/</a> (doc),
<a href="https://www.rmetrics.org">https://www.rmetrics.org</a> (devel)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://r-forge.r-project.org/projects/rmetrics">https://r-forge.r-project.org/projects/rmetrics</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-26 12:06:25 UTC; georgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Diethelm Wuertz [aut] (original code),
  Yohan Chalabi [aut],
  Tobias Setz [aut],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Chris Boudt [ctb],
  Pierre Chausse [ctb],
  Michal Miklovac [ctb],
  Georgi N. Boshnakov [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-26 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fGarch-package'>Modelling heterskedasticity in financial time series</h2><span id='topic+fGarch-package'></span><span id='topic+fGarch'></span>

<h3>Description</h3>

<p>The Rmetrics <span class="pkg">fGarch</span> package is a collection of functions to
analyze and model heteroskedastic behavior in financial time series.
</p>


<h3>1 Introduction</h3>

<p>GARCH, Generalized Autoregressive Conditional Heteroskedastic, models 
have become important in the analysis of time series data, particularly 
in financial applications when the goal is to analyze and forecast 
volatility. 
</p>
<p>For this purpose, the family of GARCH functions offers functions for
simulating, estimating and forecasting various univariate GARCH-type
time series models in the conditional variance and an ARMA
specification in the conditional mean. The function
<code><a href="#topic+garchFit">garchFit</a></code> is a numerical implementation of the maximum
log-likelihood approach under different assumptions, Normal,
Student-t, GED errors or their skewed versions.  The parameter
estimates are checked by several diagnostic analysis tools including
graphical features and hypothesis tests. Functions to compute n-step
ahead forecasts of both the conditional mean and variance are also
available.
</p>
<p>The number of GARCH models is immense, but the most influential models 
were the first. Beside the standard ARCH model introduced by Engle [1982] 
and the GARCH model introduced by Bollerslev [1986], the function
<code>garchFit</code> also includes the more general class of asymmetric power
ARCH models, named APARCH, introduced by Ding, Granger and Engle [1993]. 
The APARCH models include as special cases the TS-GARCH model of 
Taylor [1986] and Schwert [1989], the GJR-GARCH model of Glosten, 
Jaganathan, and Runkle [1993], the T-ARCH model of Zakoian [1993], the 
N-ARCH model of Higgins and Bera [1992], and the Log-ARCH model of
Geweke [1986] and Pentula [1986].
</p>
<p>There exist a collection of review articles by Bollerslev, Chou and 
Kroner [1992], Bera and Higgins [1993], Bollerslev, Engle and
Nelson [1994], Engle [2001], Engle and Patton [2001], and Li, Ling 
and McAleer [2002] which give a good overview of the scope of the 
research.
</p>


<h3>2 Time series simulation</h3>

<p>Functions to simulate artificial GARCH and APARCH time series
processes.
</p>

<table>
<tr>
 <td style="text-align: left;"> 
    <code><a href="#topic+garchSpec">garchSpec</a></code> </td><td style="text-align: left;"> specifies an univariate GARCH time series model</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+garchSim">garchSim</a></code>  </td><td style="text-align: left;"> simulates a GARCH/APARCH process
  </td>
</tr>

</table>



<h3>3 Parameter estimation</h3>

<p>Functions to fit the parameters of GARCH and APARCH time series
processes.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+garchFit">garchFit</a></code> </td><td style="text-align: left;"> fits the parameters of a GARCH process
  </td>
</tr>

</table>



<h4>Extractor Functions:</h4>


<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+residuals">residuals</a></code>  </td><td style="text-align: left;"> extracts residuals from a fitted <code>"fGARCH"</code> object</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+fitted">fitted</a></code>     </td><td style="text-align: left;"> extracts fitted values from a fitted <code>"fGARCH"</code> object</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+volatility">volatility</a></code> </td><td style="text-align: left;"> extracts conditional volatility from a fitted <code>"fGARCH"</code> object</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+coef">coef</a></code>       </td><td style="text-align: left;"> extracts coefficients from a fitted <code>"fGARCH"</code> object</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+formula">formula</a></code>    </td><td style="text-align: left;"> extracts formula expression from a fitted <code>"fGARCH"</code> object
    </td>
</tr>

</table>




<h3>4 Forecasting</h3>

<p>Functions to forcecast mean and variance of GARCH and APARCH
processes.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+predict">predict</a></code> </td><td style="text-align: left;"> forecasts from an object of class <code>"fGARCH"</code>
  </td>
</tr>

</table>



<h3>5 Standardized distributions</h3>

<p>This section contains functions to model standardized distributions.
</p>


<h4>Skew normal distribution:</h4>


<table>
<tr>
 <td style="text-align: left;">
      <code><a href="stats.html#topic+dnorm">[dpqr]norm</a></code>   </td><td style="text-align: left;"> Normal distribution (base R)</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+dsnorm">[dpqr]snorm</a></code> </td><td style="text-align: left;"> Skew normal distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+snormFit">snormFit</a></code>  </td><td style="text-align: left;"> fits parameters of Skew normal distribution
    </td>
</tr>

</table>




<h4>Skew generalized error distribution:</h4>


<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+dged">[dpqr]ged</a></code>   </td><td style="text-align: left;"> Generalized error distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+psged">[dpqr]sged</a></code>  </td><td style="text-align: left;"> Skew Generalized error  distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+gedFit">gedFit</a></code>     </td><td style="text-align: left;"> fits parameters of Generalized error distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+sgedFit">sgedFit</a></code> </td><td style="text-align: left;"> fits parameters of Skew generalized error distribution  </td>
</tr>

</table>

 


<h4>Skew standardized Student-t distribution:</h4>


<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+dstd">[dpqr]std</a></code>  </td><td style="text-align: left;"> Standardized Student-t distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+dsstd">[dpqr]sstd</a></code> </td><td style="text-align: left;"> Skew standardized Student-t distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+stdFit">stdFit</a></code>  </td><td style="text-align: left;"> fits parameters of Standardized Student-t distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+sstdFit">sstdFit</a></code>  </td><td style="text-align: left;"> fits parameters of Skew standardized Student-t distribution
    </td>
</tr>

</table>




<h4>Absolute moments:</h4>


<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+absMoments">absMoments</a></code>  </td><td style="text-align: left;"> computes absolute moments of these distribution
    </td>
</tr>

</table>




<h3>About Rmetrics</h3>

<p>The <code>fGarch</code> Rmetrics package is written for educational 
support in teaching &quot;Computational Finance and Financial Engineering&quot; 
and licensed under the GPL.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz [aut] (original code),
Yohan Chalabi [aut],
Tobias Setz [aut],
Martin Maechler [ctb] (&lt;https://orcid.org/0000-0002-8685-9910&gt;),
Chris Boudt [ctb]
Pierre Chausse [ctb],
Michal Miklovac [ctb],
Georgi N. Boshnakov [cre, ctb]
</p>
<p>Maintainer: Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;
</p>

<hr>
<h2 id='absMoments'>Absolute moments of GARCH distributions</h2><span id='topic+absMoments'></span>

<h3>Description</h3>

<p>Computes absolute moments of the standard normal, 
standardized GED, and standardized skew Student-t 
distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absMoments(n, density = c("dnorm", "dged", "dstd"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="absMoments_+3A_n">n</code></td>
<td>

<p>the order of the absolute moment, can be a vector to compute
several absolute moments at once.
</p>
</td></tr> 
<tr><td><code id="absMoments_+3A_density">density</code></td>
<td>

<p>a character string naming a symmetric density function.
</p>
</td></tr>
<tr><td><code id="absMoments_+3A_...">...</code></td>
<td>

<p>parameters passed to the density function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>absMoments</code> returns a numeric vector of length <code>n</code> with the
values of the absolute moments, as specified by <code>n</code>, of the
selected probability density function (pdf).
</p>
<p>If <code>density</code> names one of the densities in the signature of
<code>absMoments</code>, the moments are calculated from known
formulas.
</p>
<p>Otherwise, numerical integration is used and an attribute is attached
to the results to report an estimate of the error. Note that the
density is assumed symmetric wihtout a check.
</p>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ged">ged</a></code>,
<code><a href="#topic+std">std</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## absMoment -

absMoments(1, "dstd", nu = 6)
absMoments(1, "dstd", nu = 600)
absMoments(1, "dstd", nu = 60000)
absMoments(1, "dstd", nu = 600000)

absMoments(1, "dnorm")

## excess kurtosis of t_nu is  6/(nu - 4)
nu &lt;- 6
absMoments(2*2, "dstd", nu = nu) / absMoments(2*1, "dstd", nu = nu)^2 - 3
6/(nu-4)

## 4th moment for t_4 is infinite
absMoments(4, "dstd", nu = 4)

absMoments(1, "dged", nu = 4)
</code></pre>

<hr>
<h2 id='coef-methods'>GARCH coefficients methods</h2><span id='topic+coef-methods'></span><span id='topic+coef'></span><span id='topic+coef+2CfGARCH-method'></span><span id='topic+coef+2CfGARCHSPEC-method'></span>

<h3>Description</h3>

<p>Coefficients methods <code>coef()</code> for GARCH Models.
</p>


<h3>Methods</h3>

<p>Methods for <code>coef</code> defined in package <span class="pkg">fGarch</span>:
</p>

<dl>
<dt>object = &quot;fGARCH&quot;</dt><dd>
<p>Extractor function for coefficients from a fitted
GARCH model.
</p>
</dd>
<dt>object = &quot;fGARCHSPEC&quot;</dt><dd>
<p>Extractor function for coefficients from a GARCH
specification structure.
</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+coef">coef</a></code> is a generic function which extracts coefficients
from objects returned by modeling functions.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## garchSpec -
   # Use default parameters beside alpha:
   spec = garchSpec(model = list(alpha = c(0.05, 0.05)))
   spec
   coef(spec)

## garchSim -
   # Simulate an univariate "timeSeries" series from specification 'spec':
   x = garchSim(spec, n = 2000)
   x = x[,1]

## garchFit --
   fit = garchFit( ~ garch(1, 1), data = x, trace = FALSE)

## coef -
   coef(fit)
</code></pre>

<hr>
<h2 id='fGARCH-class'>Class &quot;fGARCH&quot;</h2><span id='topic+fGARCH-class'></span><span id='topic+show+2CfGARCH-method'></span><span id='topic+update+2CfGARCH-method'></span>

<h3>Description</h3>

 
<p>The class 'fGARCH' represents a model of an heteroskedastic time
series process.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the function <code>garchFit</code>.
This object is a parameter estimate of an empirical GARCH process.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code>: 
the call of the <code>garch</code> function.
</p>
</dd> 
<dt><code>formula</code>:</dt><dd><p>Object of class <code>"formula"</code>: 
a formula object specifying the mean and variance equations.
</p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code>: 
a string denoting the optimization method, by default
<code>"Max Log-Likelihood Estimation"</code>. 
</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"list"</code>: 
a list with one entry named <code>x</code>, containing the data of
the time series to be estimated, the same as given by the
input argument <code>series</code>.
</p>
</dd>
<dt><code>fit</code>:</dt><dd><p>Object of class <code>"list"</code>: 
a list with the results from the parameter estimation. The entries
of the list depend on the selected algorithm, see below.
</p>
</dd>
<dt><code>residuals</code>:</dt><dd><p>Object of class <code>"numeric"</code>: 
a numeric vector with the (raw, unstandardized) residual values.
</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Object of class <code>"numeric"</code>: 
a numeric vector with the fitted values.
</p>
</dd>
<dt><code>h.t</code>:</dt><dd><p>Object of class <code>"numeric"</code>: 
</p>
<p>a numeric vector with the conditional variances (<code class="reqn">h_t =
      \sigma_t^\delta</code>).
</p>
</dd>
<dt><code>sigma.t</code>:</dt><dd><p>Object of class <code>"numeric"</code>: 
a numeric vector with the conditional standard deviations.
</p>
</dd>
<dt><code>title</code>:</dt><dd><p>Object of class <code>"character"</code>: 
a title string.
</p>
</dd>
<dt><code>description</code>:</dt><dd><p>Object of class <code>"character"</code>: 
a string with a brief description.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "fGARCH", y = "missing")</code>: 
plots an object of class <code>"fGARCH"</code>.
</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "fGARCH")</code>: 
prints an object of class <code>"fGARCH"</code>.
</p>
</dd>      
<dt>summary</dt><dd><p><code>signature(object = "fGARCH")</code>: 
summarizes an object of class <code>"fGARCH"</code>.
</p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "fGARCH")</code>: 
forecasts mean and volatility from an object of class <code>"fGARCH"</code>.
</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "fGARCH")</code>: 
extracts fitted values from an object of class <code>"fGARCH"</code>.
</p>
</dd>     
<dt>residuals</dt><dd><p><code>signature(object = "fGARCH")</code>: 
extracts fresiduals from an object of class <code>"fGARCH"</code>.
</p>
</dd>
<dt>volatility</dt><dd><p><code>signature(object = "fGARCH")</code>: 
extracts conditional volatility from an object of class <code>"fGARCH"</code>.
</p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "fGARCH")</code>: 
extracts fitted coefficients from an object of class <code>"fGARCH"</code>.
</p>
</dd>
<dt>formula</dt><dd><p><code>signature(x = "fGARCH")</code>: 
extracts formula expression from an object of class <code>"fGARCH"</code>.
</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Diethelm Wuertz and Rmetrics Core Team
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchFit">garchFit</a></code>,
<code><a href="#topic+garchSpec">garchSpec</a></code>,
<code><a href="#topic+garchFitControl">garchFitControl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate a time series, fit a GARCH(1,1) model, and show it:
x &lt;- garchSim( garchSpec(), n = 500)
fit &lt;- garchFit(~ garch(1, 1), data = x, trace = FALSE)
fit # == print(fit) and also == show(fit)
</code></pre>

<hr>
<h2 id='fGarchData'>Time series datasets</h2><span id='topic+fGarchData'></span><span id='topic+dem2gbp'></span><span id='topic+sp500dge'></span>

<h3>Description</h3>

<p>Datasets used in the examples, including DEM/GBP foreign exchange
rates and data on SP500 index.
</p>


<h3>Format</h3>

<p><code>dem2gbp</code> is a data frame with one column <code>"DEM2GBP"</code> and
1974 rows (observations).
</p>
<p><code>sp500dge</code> is a data frame with one column <code>"SP500DGE"</code> and
17055 rows (observations).
</p>


<h3>Details</h3>

<p>The data represent retuns. No further details have been recorded.
</p>
<p>Further datasets are available in the packages that <span class="pkg">fGarch</span>
imports, see <code><a href="fBasics.html#topic+fBasicsData">fBasicsData</a></code> and
<code><a href="timeSeries.html#topic+TimeSeriesData">TimeSeriesData</a></code>.
</p>


<h3>See Also</h3>

<p><code>data(package = "fBasics")</code> and
<code>data(package = "timeSeries")</code> for related datasets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dem2gbp)
head(dem2gbp)
tail(dem2gbp)
str(dem2gbp)
plot(dem2gbp[[1]])

data(sp500dge)
head(sp500dge)
tail(sp500dge)
str(sp500dge)
plot(sp500dge[[1]])
</code></pre>

<hr>
<h2 id='fGARCHSPEC-class'>Class &quot;fGARCHSPEC&quot;</h2><span id='topic+fGARCHSPEC-class'></span><span id='topic+show+2CfGARCHSPEC-method'></span><span id='topic+update+2CfGARCHSPEC-method'></span>

<h3>Description</h3>

<p>Specification structure for an univariate GARCH time series model.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the function <code>garchSpec</code>.
This object specifies the parameters of an empirical GARCH process.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code>: 
the call of the <code>garch</code> function.
</p>
</dd> 
<dt><code>formula</code>:</dt><dd><p>Object of class <code>"formula"</code>: 
a list with two formula entries for the mean and variance 
equation.
</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"list"</code>: 
a list with the model parameters.
</p>
</dd>
<dt><code>presample</code>:</dt><dd><p>Object of class <code>"matrix"</code>: 
a numeric matrix with presample values.
</p>
</dd>
<dt><code>distribution</code>:</dt><dd><p>Object of class <code>"character"</code>: 
a character string with the name of the conditional distribution.
</p>
</dd>
<dt><code>rseed</code>:</dt><dd><p>Object of class <code>"numeric"</code>: 
an integer with the random number generator seed.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "fGARCHSPEC")</code>: 
prints an object of class 'fGARCHSPEC'.
</p>
</dd>      
</dl>



<h3>Note</h3>

<p>With Rmetrics Version 2.6.1 the class has been renamed from
<code>"garchSpec"</code> to <code>"fGARCHSPEC"</code>.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## garchSpec -
   spec = garchSpec()
   spec # print() or show() it
</code></pre>

<hr>
<h2 id='fitted-methods'>Extract GARCH model fitted values</h2><span id='topic+fitted-methods'></span><span id='topic+fitted'></span><span id='topic+fitted+2CfGARCH-method'></span>

<h3>Description</h3>

<p>Extracts fitted values from a fitted GARCH object.
</p>


<h3>Details</h3>

<p>The method for <code>"fGARCH"</code> objects extracts the <code>@fitted</code>
value slot from an object of class <code>"fGARCH"</code> as returned by the
function <code>garchFit</code>.
</p>


<h3>Methods</h3>

<p>Methods for <code>fitted</code> defined in package <span class="pkg">fGarch</span>:
</p>

<dl>
<dt>object = &quot;fGARCH&quot;</dt><dd>
<p>Extractor function for fitted values.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict</a></code>,
<code><a href="#topic+residuals">residuals</a></code>,
<code><a href="#topic+garchFit">garchFit</a></code>,
class <code><a href="#topic+fGARCH-class">fGARCH</a></code>,
</p>
<p><code><a href="#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for 'residuals()'
</code></pre>

<hr>
<h2 id='formula-methods'>Extract GARCH model formula</h2><span id='topic+formula-methods'></span><span id='topic+formula'></span><span id='topic+formula+2CfGARCH-method'></span>

<h3>Description</h3>

<p>Extracts formula from a formula GARCH object. 
</p>


<h3>Details</h3>

<p><code>formula</code> is a generic function which extracts the formula
expression from objects returned by modeling functions.
</p>
<p>The <code>"fGARCH"</code> method extracts the <code>@formula</code> expression
slot from an object of class <code>"fGARCH"</code> as returned by the
function <code>garchFit</code>.
</p>
<p>The returned formula has always a left hand side. If the argument
<code>data</code> was an univariate time series and no name was specified to
the series, then the left hand side is assigned the name of the
data.set. In the multivariate case the rectangular <code>data</code> object
must always have column names, otherwise the fitting will be stopped
with an error message
</p>
<p>The class of the returned value depends on the input to the
function <code>garchFit</code> who created the object. The returned
value is always of the same class as the input object to the
argument <code>data</code> in the function <code>garchFit</code>, i.e. if
you fit a <code>"timeSeries"</code> object, you will get back from 
the function <code>fitted</code> also a <code>"timeSeries"</code> object, 
if you fit an object of class <code>"zoo"</code>, you will get back 
again a <code>"zoo"</code> object. The same holds for a <code>"numeric"</code>
vector, for a <code>"data.frame"</code>, and for objects of class
<code>"ts", "mts"</code>.
</p>
<p>In contrast, the slot itself returns independent of the class 
of the data input always a numeric vector, i.e. the function 
call r<code>slot(object, "fitted")</code> will return a numeric vector.
</p>


<h3>Methods</h3>

<p>Methods for <code>formula</code> defined in package <span class="pkg">fGarch</span>:
</p>

<dl>
<dt>object = &quot;fGARCH&quot;</dt><dd>
<p>Extractor function for formula expression.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>(GNB) Contrary to the description of the returned value of the
<code>"fGARCH"</code> method, it is always <code>"numeric"</code>.
</p>
<p>TODO: either implement the documented behaviour or fix the
documentation.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchFit">garchFit</a></code>,
class <code><a href="#topic+fGARCH-class">fGARCH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## garchFit -
   fit = garchFit(~garch(1, 1), data = garchSim(), trace = FALSE)
   
## formula - 
   formula(fit)

## A Bivariate series and mis-specified formula:
   x = garchSim(n = 500)
   y = garchSim(n = 500)
   z = cbind(x, y)
   colnames(z)
   class(z)
   ## Not run: 
   garchFit(z ~garch(1, 1), data = z, trace = FALSE)
   
## End(Not run)
   # Returns:
   # Error in .garchArgsParser(formula = formula, data = data, trace = FALSE) :  
   #   Formula and data units do not match.
   
## Doubled column names in data set - formula can't fit:
   colnames(z) &lt;- c("x", "x")
   z[1:6,]
   ## Not run: 
   garchFit(x ~garch(1, 1), data = z, trace = FALSE)
   
## End(Not run)
   # Again the error will be noticed:
   # Error in garchFit(x ~ garch(1, 1), data = z) : 
   #   Column names of data are not unique.

## Missing column names in data set - formula can't fit:
   z.mat &lt;- as.matrix(z)
   colnames(z.mat) &lt;- NULL
   z.mat[1:6,]
   ## Not run: 
   garchFit(x ~ garch(1, 1), data = z.mat, trace = FALSE)
   
## End(Not run)
   # Again the error will be noticed:
   # Error in .garchArgsParser(formula = formula, data = data, trace = FALSE) : 
   #   Formula and data units do not match
</code></pre>

<hr>
<h2 id='fUGARCHSPEC-class'>Class 'fUGARCHSPEC'</h2><span id='topic+fUGARCHSPEC-class'></span><span id='topic+.ugarchFit'></span><span id='topic+.ugarchSpec'></span>

<h3>Description</h3>

<p>Class 'fUGARCHSPEC'.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("fUGARCHSPEC", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>distribution</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>optimization</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>documentation</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>

<p>No methods defined with class <code>"fUGARCHSPEC"</code> in the signature.
</p>


<h3>Note</h3>

<p>(GNB) This class seems to be meant for internal use by the package.
</p>


<h3>See Also</h3>

<p>class <code>"<a href="#topic+fGARCH-class">fGARCH</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("fUGARCHSPEC")
</code></pre>

<hr>
<h2 id='garchFit'>Univariate or multivariate GARCH time series fitting</h2><span id='topic+garchFit'></span><span id='topic+garchKappa'></span><span id='topic+.gogarchFit'></span>

<h3>Description</h3>

<p>Estimates the parameters of a univariate ARMA-GARCH/APARCH process, or
&mdash; experimentally &mdash; of a multivariate GO-GARCH process model.  The
latter uses an algorithm based on <code>fastICA()</code>, inspired from
Bernhard Pfaff's package <a href="https://CRAN.R-project.org/package=gogarch"><span class="pkg">gogarch</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garchFit(formula = ~ garch(1, 1), data,
	init.rec = c("mci", "uev"),
	delta = 2, skew = 1, shape = 4,
	cond.dist = c("norm", "snorm", "ged", "sged",
                      "std", "sstd", "snig", "QMLE"),
	include.mean = TRUE, include.delta = NULL, include.skew = NULL,
        include.shape = NULL,
        leverage = NULL, trace = TRUE,
	
	algorithm = c("nlminb", "lbfgsb", "nlminb+nm", "lbfgsb+nm"),
	hessian = c("ropt", "rcd"),
        control = list(),
        title = NULL, description = NULL, ...)

garchKappa(cond.dist = c("norm", "ged", "std", "snorm", "sged", "sstd", "snig"),
           gamma = 0, delta = 2, skew = NA, shape = NA)

.gogarchFit(formula = ~garch(1, 1), data, init.rec = c("mci", "uev"),
            delta = 2, skew = 1, shape = 4,
            cond.dist = c("norm", "snorm", "ged", "sged",
                          "std", "sstd", "snig", "QMLE"),
            include.mean = TRUE, include.delta = NULL, include.skew = NULL,
            include.shape = NULL,
            leverage = NULL, trace = TRUE,
            algorithm = c("nlminb", "lbfgsb", "nlminb+nm", "lbfgsb+nm"),
            hessian = c("ropt", "rcd"),
            control = list(),
            title = NULL, description = NULL, ...)
</code></pre>


<h3>Arguments</h3>






<table role = "presentation">
<tr><td><code id="garchFit_+3A_algorithm">algorithm</code></td>
<td>

<p>a string parameter that determines the algorithm used for maximum
likelihood estimation.







</p>
</td></tr>
<tr><td><code id="garchFit_+3A_cond.dist">cond.dist</code></td>
<td>

<p>a character string naming the desired conditional distribution.
Valid values are <code>"dnorm"</code>, <code>"dged"</code>, <code>"dstd"</code>,
<code>"dsnorm"</code>, <code>"dsged"</code>, <code>"dsstd"</code> and
<code>"QMLE"</code>. The default value is the normal distribution.  See
Details for more information.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_control">control</code></td>
<td>

<p>control parameters, the same as used for the functions from
<code>nlminb</code>, and 'bfgs' and 'Nelder-Mead' from <code>optim</code>.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_data">data</code></td>
<td>

<p>an optional timeSeries or data frame object containing the variables
in the model.  If not found in <code>data</code>, the variables are taken
from <code>environment(formula)</code>, typically the environment from which
<code>armaFit</code> is called.  If <code>data</code> is an univariate series, then
the series is converted into a numeric vector and the name of the
response in the formula will be neglected.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_delta">delta</code></td>
<td>

<p>a numeric value, the exponent <code>delta</code> of the variance recursion.
By default, this value will be fixed, otherwise the exponent will be
estimated together with the other model parameters if
<code>include.delta=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_description">description</code></td>
<td>
<p>optional character string with a brief description.</p>
</td></tr>
<tr><td><code id="garchFit_+3A_formula">formula</code></td>
<td>

<p><code><a href="#topic+formula">formula</a></code> object describing the mean and variance equation of the
ARMA-GARCH/APARCH model.  A pure GARCH(1,1) model is selected
e.g., for <code>formula = ~garch(1,1)</code>.  To specify an
ARMA(2,1)-APARCH(1,1) process, use <code> ~ arma(2,1) + aparch(1,1)</code>.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_gamma">gamma</code></td>
<td>

<p>APARCH leverage parameter entering into the formula for calculating
the expectation value.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_hessian">hessian</code></td>
<td>

<p>a string denoting how the Hessian matrix should be evaluated,
either <code>hessian ="rcd"</code>, or <code>"ropt"</code>.  The default,
<code>"rcd"</code>  is a central difference approximation implemented
in <span class="rlang"><b>R</b></span> and <code>"ropt"</code> uses the internal R function <code>optimhess</code>.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_include.delta">include.delta</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> determining if the
parameter for the recursion equation <code>delta</code> will be estimated
or not.  If false, the shape parameter will be kept fixed during the
process of parameter optimization.</p>
</td></tr>
<tr><td><code id="garchFit_+3A_include.mean">include.mean</code></td>
<td>

<p>this flag determines if the parameter for the mean will be estimated
or not. If <code>include.mean=TRUE</code> this will be the case, otherwise
the parameter will be kept fixed durcing the process
of parameter optimization.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_include.shape">include.shape</code></td>
<td>

<p>a logical flag which determines if the parameter for the shape
of the conditional distribution will be estimated or not. If
<code>include.shape=FALSE</code> then the shape parameter will be kept
fixed during the process of parameter optimization.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_include.skew">include.skew</code></td>
<td>

<p>a logical flag which determines if the parameter for the skewness
of the conditional distribution will be estimated or not. If
<code>include.skew=FALSE</code> then the skewness parameter will be kept
fixed during the process of parameter optimization.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_init.rec">init.rec</code></td>
<td>

<p>a character string indicating the method how to initialize the
mean and varaince recursion relation.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_leverage">leverage</code></td>
<td>

<p>a logical flag for APARCH models. Should the model be leveraged?
By default <code>leverage=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_shape">shape</code></td>
<td>

<p>a numeric value, the shape parameter of the conditional distribution.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_skew">skew</code></td>
<td>

<p>a numeric value, the skewness parameter of the conditional
distribution.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_title">title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_trace">trace</code></td>
<td>

<p>a logical flag. Should the optimization process of fitting the
model parameters be printed? By default <code>trace=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="garchFit_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"QMLE"</code> stands for Quasi-Maximum Likelihood Estimation, which
assumes normal distribution and uses robust standard errors for
inference. Bollerslev and Wooldridge (1992) proved that if the mean
and the volatility equations are correctly specified, the QML
estimates are consistent and asymptotically normally
distributed. However, the estimates are not efficient and &ldquo;the
efficiency loss can be marked under asymmetric ... distributions&rdquo;
(Bollerslev and Wooldridge (1992), p. 166). The robust
variance-covariance matrix of the estimates equals the (Eicker-White)
sandwich estimator, i.e.
</p>
<p style="text-align: center;"><code class="reqn">V = H^{-1} G^{\prime} G H^{-1},</code>
</p>

<p>where <code class="reqn">V</code> denotes the variance-covariance matrix, <code class="reqn">H</code>
stands for the Hessian and <code class="reqn">G</code> represents the matrix of
contributions to the gradient, the elements of which are defined as
</p>
<p style="text-align: center;"><code class="reqn">G_{t,i} = \frac{\partial l_{t}}{\partial \zeta_{i}},</code>
</p>

<p>where <code class="reqn">t_{t}</code> is the log likelihood of the t-th observation
and <code class="reqn">\zeta_{i}</code> is the i-th estimated parameter. See
sections 10.3 and 10.4 in Davidson and MacKinnon (2004) for a more
detailed description of the robust variance-covariance matrix.
</p>


<h3>Value</h3>

<p>for <code>garchFit</code>, an S4 object of class <code>"<a href="#topic+fGARCH-class">fGARCH</a>"</code>.
Slot <code>@fit</code> contains the results from the optimization.
</p>
<p>for <code>.gogarchFit()</code>: Similar definition for GO-GARCH modeling.
Here, <code>data</code> must be <em>multivariate</em>.  Still
&ldquo;preliminary&rdquo;, mostly undocumented, and untested(!).  At least
mentioned here...
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port,<br />
R Core Team for the 'optim' <span class="rlang"><b>R</b></span>-port,<br />
Douglas Bates and Deepayan Sarkar for the 'nlminb' <span class="rlang"><b>R</b></span>-port,<br />
Bell-Labs for the underlying PORT Library,<br />
Ladislav Luksan for the underlying Fortran SQP Routine, <br />
Zhu, Byrd, Lu-Chen and Nocedal for the underlying L-BFGS-B Routine.
</p>
<p>Martin Maechler for cleaning up; <em>mentioning</em>
<code>.gogarchFit()</code>.
</p>


<h3>References</h3>

<p>ATT (1984);
<em>PORT Library Documentation</em>,
http://netlib.bell-labs.com/netlib/port/.
</p>
<p>Bera A.K., Higgins M.L. (1993);
<em>ARCH Models: Properties, Estimation and Testing</em>,
J. Economic Surveys 7, 305&ndash;362.
</p>
<p>Bollerslev T. (1986);
<em>Generalized Autoregressive Conditional Heteroscedasticity</em>,
Journal of Econometrics 31, 307&ndash;327.
</p>
<p>Bollerslev T., Wooldridge J.M. (1992);
<em>Quasi-Maximum Likelihood Estimation and Inference in Dynamic
Models with Time-Varying Covariance</em>,
Econometric Reviews 11, 143&ndash;172.
</p>
<p>Byrd R.H., Lu P., Nocedal J., Zhu C. (1995);
<em>A Limited Memory Algorithm for Bound Constrained Optimization</em>,
SIAM Journal of Scientific Computing 16, 1190&ndash;1208.
</p>
<p>Davidson R., MacKinnon J.G. (2004);
<em>Econometric Theory and Methods</em>,
Oxford University Press, New York.
</p>
<p>Engle R.F. (1982);
<em>Autoregressive Conditional Heteroscedasticity with Estimates
of the Variance of United Kingdom Inflation</em>,
Econometrica 50, 987&ndash;1008.
</p>
<p>Nash J.C. (1990);
<em>Compact Numerical Methods for Computers</em>,
Linear Algebra and Function Minimisation,
Adam Hilger.
</p>
<p>Nelder J.A., Mead R. (1965);
<em>A Simplex Algorithm for Function Minimization</em>,
Computer Journal 7, 308&ndash;313.
</p>
<p>Nocedal J., Wright S.J. (1999);
<em>Numerical Optimization</em>,
Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchSpec">garchSpec</a></code>,
<code><a href="#topic+garchFitControl">garchFitControl</a></code>,
class <code>"<a href="#topic+fGARCH-class">fGARCH</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## UNIVARIATE TIME SERIES INPUT:
   # In the univariate case the lhs formula has not to be specified ...

   # A numeric Vector from default GARCH(1,1) - fix the seed:
   N = 200
   x.vec = as.vector(garchSim(garchSpec(rseed = 1985), n = N)[,1])
   garchFit(~ garch(1,1), data = x.vec, trace = FALSE)

   # An univariate timeSeries object with dummy dates:
   stopifnot(require("timeSeries"))
   x.timeSeries = dummyDailySeries(matrix(x.vec), units = "GARCH11")
   garchFit(~ garch(1,1), data = x.timeSeries, trace = FALSE)

## Not run: 
   # An univariate zoo object:
   require("zoo")
   x.zoo = zoo(as.vector(x.vec), order.by = as.Date(rownames(x.timeSeries)))
   garchFit(~ garch(1,1), data = x.zoo, trace = FALSE)

## End(Not run)

   # An univariate "ts" object:
   x.ts = as.ts(x.vec)
   garchFit(~ garch(1,1), data = x.ts, trace = FALSE)

## MULTIVARIATE TIME SERIES INPUT:
   # For multivariate data inputs the lhs formula must be specified ...

   # A numeric matrix binded with dummy random normal variates:
   X.mat = cbind(GARCH11 = x.vec, R = rnorm(N))
   garchFit(GARCH11 ~ garch(1,1), data = X.mat)

   # A multivariate timeSeries object with dummy dates:
   X.timeSeries = dummyDailySeries(X.mat, units = c("GARCH11", "R"))
   garchFit(GARCH11 ~ garch(1,1), data = X.timeSeries)

## Not run: 
   # A multivariate zoo object:
   X.zoo = zoo(X.mat, order.by = as.Date(rownames(x.timeSeries)))
   garchFit(GARCH11 ~ garch(1,1), data = X.zoo)

## End(Not run)

   # A multivariate "mts" object:
   X.mts = as.ts(X.mat)
   garchFit(GARCH11 ~ garch(1,1), data = X.mts)

## MODELING THE PERCENTUAL SPI/SBI SPREAD FROM LPP BENCHMARK:

   stopifnot(require("timeSeries"))
   X.timeSeries = as.timeSeries(data(LPP2005REC))
   X.mat = as.matrix(X.timeSeries)
   ## Not run: X.zoo = zoo(X.mat, order.by = as.Date(rownames(X.mat)))
   X.mts = ts(X.mat)
   garchFit(100*(SPI - SBI) ~ garch(1,1), data = X.timeSeries)
   # The remaining are not yet supported ...
   # garchFit(100*(SPI - SBI) ~ garch(1,1), data = X.mat)
   # garchFit(100*(SPI - SBI) ~ garch(1,1), data = X.zoo)
   # garchFit(100*(SPI - SBI) ~ garch(1,1), data = X.mts)

## MODELING HIGH/LOW RETURN SPREADS FROM MSFT PRICE SERIES:

   X.timeSeries = MSFT
   garchFit(Open ~ garch(1,1), data = returns(X.timeSeries))
   garchFit(100*(High-Low) ~ garch(1,1), data = returns(X.timeSeries))

## GO-GARCH Modelling  (not yet!!) % FIXME

  ## data(DowJones30, package="fEcofin") # no longer exists
  ## X = returns(as.timeSeries(DowJones30)); head(X)
  ## N = 5; ans = .gogarchFit(data = X[, 1:N], trace = FALSE); ans
  ## ans@h.t

</code></pre>

<hr>
<h2 id='garchFitControl'>Control GARCH fitting algorithms</h2><span id='topic+garchFitControl'></span>

<h3>Description</h3>

<p>Control parameters for the GARCH fitting algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garchFitControl(
    llh = c("filter", "internal", "testing"),
    nlminb.eval.max = 2000,
    nlminb.iter.max = 1500,
    nlminb.abs.tol = 1.0e-20,
    nlminb.rel.tol = 1.0e-14,
    nlminb.x.tol = 1.0e-14,
    nlminb.step.min = 2.2e-14,
    nlminb.scale = 1,
    nlminb.fscale = FALSE,
    nlminb.xscale = FALSE,
    sqp.mit = 200,
    sqp.mfv = 500,
    sqp.met = 2,
    sqp.mec = 2,
    sqp.mer = 1,
    sqp.mes = 4,
    sqp.xmax = 1.0e3,
    sqp.tolx = 1.0e-16,
    sqp.tolc = 1.0e-6,
    sqp.tolg = 1.0e-6,
    sqp.told = 1.0e-6,
    sqp.tols = 1.0e-4,
    sqp.rpf = 1.0e-4,
    lbfgsb.REPORT = 10,
    lbfgsb.lmm = 20,
    lbfgsb.pgtol = 1e-14,
    lbfgsb.factr = 1,
    lbfgsb.fnscale = FALSE,
    lbfgsb.parscale = FALSE,
    nm.ndeps = 1e-14,
    nm.maxit = 10000,
    nm.abstol = 1e-14,
    nm.reltol = 1e-14,
    nm.alpha = 1.0,
    nm.beta = 0.5,
    nm.gamma = 2.0,
    nm.fnscale = FALSE,
    nm.parscale = FALSE)
</code></pre>


<h3>Arguments</h3>


<table role = "presentation">
<tr><td><code id="garchFitControl_+3A_llh">llh</code></td>
<td>

<p><code>llh = c("filter", "internal", "testing")[1]</code>,
defaults to <code>"filter"</code>.
</p>
</td></tr>

<tr><td><code id="garchFitControl_+3A_nlminb.eval.max">nlminb.eval.max</code></td>
<td>

<p>maximum number of evaluations of the objective function,
defaults to 200.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nlminb.iter.max">nlminb.iter.max</code></td>
<td>

<p>maximum number of iterations, defaults to 150.
</p>
</td></tr>





<tr><td><code id="garchFitControl_+3A_nlminb.abs.tol">nlminb.abs.tol</code></td>
<td>

<p>absolute tolerance, defaults to 1e-20.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nlminb.rel.tol">nlminb.rel.tol</code></td>
<td>

<p>relative tolerance, defaults to 1e-10.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nlminb.x.tol">nlminb.x.tol</code></td>
<td>

<p>X tolerance, defaults to 1.5e-8.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nlminb.fscale">nlminb.fscale</code></td>
<td>

<p>defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nlminb.xscale">nlminb.xscale</code></td>
<td>

<p>defaulkts to FALSE.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nlminb.step.min">nlminb.step.min</code></td>
<td>

<p>minimum step size, defaults to 2.2e-14.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nlminb.scale">nlminb.scale</code></td>
<td>

<p>defaults to 1.
</p>
</td></tr>




<tr><td><code id="garchFitControl_+3A_sqp.mit">sqp.mit</code></td>
<td>

<p>maximum number of iterations, defaults to 200.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_sqp.mfv">sqp.mfv</code></td>
<td>

<p>maximum number of function evaluations, defaults to 500.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_sqp.met">sqp.met</code></td>
<td>

<p>specifies scaling strategy:<br />
sqp.met=1 - no scaling,<br />
sqp.met=2 - preliminary scaling in 1st iteration (default),<br />
sqp.met=3 - controlled scaling,<br />
sqp.met=4 - interval scaling,<br />
sqp.met=5 - permanent scaling in all iterations.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_sqp.mec">sqp.mec</code></td>
<td>

<p>correction for negative curvature:<br />
sqp.mec=1 - no correction,<br />
sqp.mec=2 - Powell correction (default).
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_sqp.mer">sqp.mer</code></td>
<td>

<p>restarts after unsuccessful variable metric updates:<br />
sqp.mer=0 - no restarts,<br />
sqp.mer=1 - standard restart.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_sqp.mes">sqp.mes</code></td>
<td>

<p>interpolation method selection in a line search:<br />
sqp.mes=1 - bisection,<br />
sqp.mes=2 - two point quadratic interpolation,<br />
sqp.mes=3 - three point quadratic interpolation,<br />
sqp.mes=4 - three point cubic interpolation (default).
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_sqp.xmax">sqp.xmax</code></td>
<td>

<p>maximum stepsize, defaults to 1.0e+3.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_sqp.tolx">sqp.tolx</code></td>
<td>

<p>tolerance for the change of the coordinate vector,
defaults to 1.0e-16.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_sqp.tolc">sqp.tolc</code></td>
<td>

<p>tolerance for the constraint violation,
defaults to 1.0e-6.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_sqp.tolg">sqp.tolg</code></td>
<td>

<p>tolerance for the Lagrangian function gradient,
defaults to 1.0e-6.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_sqp.told">sqp.told</code></td>
<td>

<p>defaults to 1.0e-6.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_sqp.tols">sqp.tols</code></td>
<td>

<p>defaults to 1.0e-4.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_sqp.rpf">sqp.rpf</code></td>
<td>

<p>value of the penalty coefficient,
default to1.0D-4.
The default velue may be relatively small. Therefore, larger
value, say one, can sometimes be more suitable.
</p>
</td></tr>

<tr><td><code id="garchFitControl_+3A_lbfgsb.report">lbfgsb.REPORT</code></td>
<td>

<p>the frequency of reports for the <code>"BFGS"</code> and <code>"L-BFGS-B"</code>
methods if <code>control$trace</code> is positive. Defaults to every 10
iterations.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_lbfgsb.lmm">lbfgsb.lmm</code></td>
<td>

<p>an integer giving the number of BFGS updates retained in
the <code>"L-BFGS-B"</code> method, It defaults to 5.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_lbfgsb.factr">lbfgsb.factr</code></td>
<td>

<p>controls the convergence of the <code>"L-BFGS-B"</code>
method. Convergence occurs when the reduction in the objective is
within this factor of the machine tolerance. Default is 1e7, that is
a tolerance of about 1.0e-8.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_lbfgsb.pgtol">lbfgsb.pgtol</code></td>
<td>

<p>helps control the convergence of the <code>"L-BFGS-B"</code> method. It is
a tolerance on the projected gradient in the current search
direction. This defaults to zero, when the check is suppressed.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_lbfgsb.fnscale">lbfgsb.fnscale</code></td>
<td>

<p>defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_lbfgsb.parscale">lbfgsb.parscale</code></td>
<td>

<p>defaults to FALSE.
</p>
</td></tr>








<tr><td><code id="garchFitControl_+3A_nm.ndeps">nm.ndeps</code></td>
<td>

<p>a vector of step sizes for the finite-difference approximation
to the gradient, on par/parscale scale. Defaults to 1e-3.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nm.maxit">nm.maxit</code></td>
<td>

<p>the maximum number of iterations. Defaults to 100 for the
derivative-based methods, and 500 for <code>"Nelder-Mead"</code>. For
<code>"SANN"</code> maxit gives the total number of function
evaluations. There is no other stopping criterion. Defaults to
10000.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nm.abstol">nm.abstol</code></td>
<td>

<p>the absolute convergence tolerance. Only useful for non-negative
functions, as a tolerance for reaching zero.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nm.reltol">nm.reltol</code></td>
<td>

<p>relative convergence tolerance. The algorithm stops if it is
unable to reduce the value by a factor of
<code>reltol * (abs(val) + reltol)</code> at a step. Defaults to
<code>sqrt(.Machine$double.eps)</code>, typically about 1e-8.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nm.alpha">nm.alpha</code>, <code id="garchFitControl_+3A_nm.beta">nm.beta</code>, <code id="garchFitControl_+3A_nm.gamma">nm.gamma</code></td>
<td>

<p>scaling parameters for the &quot;Nelder-Mead&quot; method.
alpha is the reflection factor (default 1.0),
beta the contraction factor (0.5), and
gamma the expansion factor (2.0).
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nm.fnscale">nm.fnscale</code></td>
<td>

<p>an overall scaling to be applied to the value of fn and gr
during optimization. If negative, turns the problem into a
maximization problem.  Optimization is performed on
<code>fn(par) / nm.fnscale</code>.
</p>
</td></tr>
<tr><td><code id="garchFitControl_+3A_nm.parscale">nm.parscale</code></td>
<td>

<p>a vector of scaling values for the parameters. Optimization is
performed on par/parscale and these should be comparable in the
sense that a unit change in any element produces about a unit
change in the scaled value.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port,<br />
R Core Team for the 'optim' <span class="rlang"><b>R</b></span>-port,<br />
Douglas Bates and Deepayan Sarkar for the 'nlminb' <span class="rlang"><b>R</b></span>-port,<br />
Bell-Labs for the underlying PORT Library,<br />
Ladislav Luksan for the underlying Fortran SQP Routine, <br />
Zhu, Byrd, Lu-Chen and Nocedal for the underlying L-BFGS-B Routine.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchFit">garchFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
</code></pre>

<hr>
<h2 id='garchSim'>Simulate univariate GARCH/APARCH time series</h2><span id='topic+garchSim'></span>

<h3>Description</h3>

<p>Simulates univariate GARCH/APARCH time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garchSim(spec = garchSpec(), n = 100, n.start = 100, extended = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="garchSim_+3A_spec">spec</code></td>
<td>

<p>a specification object of class <code>"<a href="#topic+fGARCHSPEC-class">fGARCHSPEC</a>"</code> as
returned by <code><a href="#topic+garchSpec">garchSpec</a></code>. See also below for further
details.
</p>
</td></tr>   
<tr><td><code id="garchSim_+3A_n">n</code></td>
<td>

<p>length of the output series, an integer value, by default
<code>n=100</code>.
</p>
</td></tr>
<tr><td><code id="garchSim_+3A_n.start">n.start</code></td>
<td>

<p>length of &lsquo;burn-in&rsquo; period, by default 100.
</p>
</td></tr>
<tr><td><code id="garchSim_+3A_extended">extended</code></td>
<td>

<p>logical parameter specifying what to return. If <code>FALSE</code>, return
the univariate GARCH/APARCH time series. If <code>TRUE</code>, return a
multivariate time series containing also the volatility and
conditional innovations time series.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>garchSim</code> simulates an univariate GARCH or APARCH time series
process as specified by argument <code>spec</code>.  The default model
specifies Bollerslev's GARCH(1,1) model with normally distributed
innovations.
</p>
<p><code>spec</code> is an object of class <code>"fGARCHSPEC"</code> as returned by
the function <code><a href="#topic+garchSpec">garchSpec</a></code>. It comes with a slot
<code>@model</code> which is a list of just the numeric parameter
entries. These are recognized and extracted for use by the function
<code>garchSim</code>.
</p>







<p>One can estimate the parameters of a GARCH process from empirical data
using the function <code>garchFit</code> and then simulate statistically
equivalent GARCH processes with the same set of model parameters using
the function <code>garchSim</code>.
</p>










<h3>Value</h3>

<p>the simulated time series as an objects of
class <code>"timeSeries"</code> with attribute <code>"spec"</code> containing the
specification of the model.
</p>
<p>If <code>extended</code> is <code>TRUE</code>, then the time series is
multivariate and contains also the volatility, <code>sigma</code>, and the
conditional innovations, <code>eps</code>.
</p>


<h3>Note</h3>

<p>An undocumented feature (so, it should not be relied on) is that the
returned time series is timed so that the last observation is the day
before the date when the function is executed. This probably should be
controlled by an additional argument in <code>garchSim</code>.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchSpec">garchSpec</a></code>,
<code><a href="#topic+garchFit">garchFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## garchSpec -
   spec = garchSpec()
   spec

## garchSim -
   # Simulate a "timeSeries" object:
   x = garchSim(spec, n = 50)
   class(x)
   print(x) 
   
## More simulations ...

   # Default GARCH(1,1) - uses default parameter settings
   spec = garchSpec(model = list())
   garchSim(spec, n = 10)
   
   # ARCH(2) - use default omega and specify alpha, set beta=0!
   spec = garchSpec(model = list(alpha = c(0.2, 0.4), beta = 0))
   garchSim(spec, n = 10)
   
   # AR(1)-ARCH(2) - use default mu, omega
   spec = garchSpec(model = list(ar = 0.5, alpha = c(0.3, 0.4), beta = 0))
   garchSim(spec, n = 10)
   
   # AR([1,5])-GARCH(1,1) - use default garch values and subset ar[.]
   spec = garchSpec(model = list(mu = 0.001, ar = c(0.5,0,0,0,0.1)))
   garchSim(spec, n = 10)
   
   # ARMA(1,2)-GARCH(1,1) - use default garch values
   spec = garchSpec(model = list(ar = 0.5, ma = c(0.3, -0.3)))  
   garchSim(spec, n = 10)
   
   # GARCH(1,1) - use default omega and specify alpha/beta
   spec = garchSpec(model = list(alpha = 0.2, beta = 0.7))
   garchSim(spec, n = 10)
   
   # GARCH(1,1) - specify omega/alpha/beta
   spec = garchSpec(model = list(omega = 1e-6, alpha = 0.1, beta = 0.8))
   garchSim(spec, n = 10)
   
   # GARCH(1,2) - use default omega and specify alpha[1]/beta[2]
   spec = garchSpec(model = list(alpha = 0.1, beta = c(0.4, 0.4)))
   garchSim(spec, n = 10)
   
   # GARCH(2,1) - use default omega and specify alpha[2]/beta[1]
   spec = garchSpec(model = list(alpha = c(0.12, 0.04), beta = 0.08))
   garchSim(spec, n = 10)
   
   # snorm-ARCH(1) - use defaults with skew Normal
   spec = garchSpec(model = list(beta = 0, skew = 0.8), cond.dist = "snorm")
   garchSim(spec, n = 10)
   
   # sged-GARCH(1,1) - using defaults with skew GED
   model = garchSpec(model = list(skew = 0.93, shape = 3), cond.dist = "sged")
   garchSim(model, n = 10)
   
   # Taylor Schwert GARCH(1,1) - this belongs to the family of APARCH Models
   spec = garchSpec(model = list(delta = 1))
   garchSim(spec, n = 10)
   
   # AR(1)-t-APARCH(2, 1) - a little bit more complex specification ...
   spec = garchSpec(model = list(mu = 1.0e-4, ar = 0.5, omega = 1.0e-6, 
       alpha = c(0.10, 0.05), gamma = c(0, 0), beta = 0.8, delta = 1.8, 
       shape = 4, skew = 0.85), cond.dist = "sstd")
   garchSim(spec, n = 10)

   garchSim(spec, n = 10, extended = TRUE)
   
</code></pre>

<hr>
<h2 id='garchSpec'>Univariate GARCH/APARCH time series specification</h2><span id='topic+garchSpec'></span>

<h3>Description</h3>

<p>Specifies an univariate ARMA-GARCH or ARMA-APARCH time series model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garchSpec(model = list(), presample = NULL, 
    cond.dist = c("norm", "ged", "std", "snorm", "sged", "sstd"), 
    rseed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="garchSpec_+3A_cond.dist">cond.dist</code></td>
<td>

<p>a character string naming the desired conditional distribution.
Valid values are <code>"norm"</code>, <code>"ged"</code>, <code>"std"</code>, 
<code>"snorm"</code>, <code>"sged"</code>, <code>"sstd"</code>. The default value 
is <code>"norm"</code>, the standard normal distribution.
</p>
</td></tr>
<tr><td><code id="garchSpec_+3A_model">model</code></td>
<td>

<p>a list of GARCH model parameters, see section &lsquo;Details&rsquo;.
The default <code>model=list()</code> specifies Bollerslev's 
GARCH(1,1) model with normal conditional distributed innovations.
</p>
</td></tr>   
<tr><td><code id="garchSpec_+3A_presample">presample</code></td>
<td>

<p>a numeric three column matrix with start values for the series, 
for the innovations, and for the conditional variances. For an 
ARMA(m,n)-GARCH(p,q) process the number of rows must be at least 
max(m,n,p,q)+1, longer presamples are truncated. Note, all presamples
are initialized by a normal-GARCH(p,q) process.
</p>
</td></tr>
<tr><td><code id="garchSpec_+3A_rseed">rseed</code></td>
<td>

<p>single integer argument, the seed for the intitialization of
the random number generator for the innovations. If
<code>rseed=NULL</code>,  the default, then the state of the random
number generator is not touched by this function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>garchSpec</code> specifies a GARCH or APARCH time series
process which we can use for simulating artificial GARCH and/or APARCH
models. This is very useful for testing the GARCH parameter estimation
results, since your model parameters are known and well specified.
</p>
<p>Argument <code>model</code> is a list of model parameters. For the GARCH
part of the model they are:
</p>

<dl>
<dt><code>omega</code></dt><dd><p>the constant coefficient of the variance
equation, by default <code>1e-6</code>;</p>
</dd>
<dt><code>alpha</code></dt><dd><p>the value or vector of autoregressive
coefficients, by default 0.1, specifying a model of order 1;</p>
</dd>
<dt><code>beta</code></dt><dd><p>the value or vector of variance coefficients, by
default 0.8, specifying a model of order 1.</p>
</dd>
</dl>

<p>If the model is APARCH, then the following additional parameters are
available:
</p>

<dl>
<dt>delta</dt><dd><p>a positive number, the power of sigma in the volatility
equation, it is 2 for GARCH models;</p>
</dd>
<dt>gamma</dt><dd><p>the leverage parameters, a vector of length
<code>alpha</code>, containing numbers in the interval <code class="reqn">(0,1)</code>.</p>
</dd>
</dl>

<p>The values for the linear part (conditional mean) are:
</p>

<dl>
<dt><code>mu</code></dt><dd><p>the mean value, by default NULL;</p>
</dd> 
<dt><code>ar</code></dt><dd><p>the autoregressive ARMA coefficients, by default NULL;</p>
</dd> 
<dt><code>ma</code></dt><dd><p>the moving average ARMA coefficients, by default NULL.</p>
</dd>
</dl>

<p>The parameters for the conditional distributions are:
</p>

<dl>
<dt><code>skew</code></dt><dd><p>the skewness parameter (also named &quot;xi&quot;), by
default 0.9, effective only for the <code>"dsnorm"</code>, the
<code>"dsged"</code>, and the <code>"dsstd"</code> skewed conditional
distributions;</p>
</dd>
<dt><code>shape</code></dt><dd><p>the shape parameter (also named &quot;nu&quot;), by
default 2 for the <code>"dged"</code> and <code>"dsged"</code>, and by default
4 for the <code>"dstd"</code> and <code>"dsstd"</code> conditional
distributions.</p>
</dd>
</dl>

<p>For example, specifying a subset AR(5[1,5])-GARCH(2,1) model with a
standardized Student-t distribution with four degrees of freedom will
return the following printed output:
</p>
<pre>
        garchSpec(model = list(ar = c(0.5,0,0,0,0.1), alpha =  
            c(0.1, 0.1), beta = 0.75, shape = 4), cond.dist = "std")  
        
        Formula: 
         ~ ar(5) + garch(2, 1)  
        Model: 
         ar:    0.5 0 0 0 0.1  
         omega: 1e-06  
         alpha: 0.1 0.1  
         beta:  0.75  
        Distribution:   
         std  
        Distributional Parameter:  
         nu = 4  
        Presample:  
           time          z     h y  
        0     0 -0.3262334 2e-05 0  
        -1   -1  1.3297993 2e-05 0  
        -2   -2  1.2724293 2e-05 0  
        -3   -3  0.4146414 2e-05 0  
        -4   -4 -1.5399500 2e-05 0  
        </pre>
<p>Its interpretation is as follows.  &lsquo;Formula&rsquo; describes the
formula expression specifying the generating process, &lsquo;Model&rsquo;
lists the associated model parameters, &lsquo;Distribution&rsquo; the type
of the conditional distribution function in use,
&lsquo;Distributional Parameters&rsquo; lists the distributional parameter
(if any), and the &lsquo;Presample&rsquo; shows the presample input matrix.
</p>
<p>If we have specified <code>presample = NULL</code> in the argument list,
then the presample is generated automatically by default as
norm-AR()-GARCH() process.
</p>


<h3>Value</h3>

<p>an object of class <code>"<a href="#topic+fGARCHSPEC-class">fGARCHSPEC</a>"</code>
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchSim">garchSim</a></code>,
<code><a href="#topic+garchFit">garchFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## garchSpec -

   # Normal Conditional Distribution:
   spec = garchSpec()
   spec
   
   # Skewed Normal Conditional Distribution:
   spec = garchSpec(model = list(skew = 0.8), cond.dist = "snorm")
   spec
   
   # Skewed GED Conditional Distribution:
   spec = garchSpec(model = list(skew = 0.9, shape = 4.8), cond.dist = "sged")
   spec
   
## More specifications ...

   # Default GARCH(1,1) - uses default parameter settings
   garchSpec(model = list())
   
   # ARCH(2) - use default omega and specify alpha, set beta=0!
   garchSpec(model = list(alpha = c(0.2, 0.4), beta = 0))
   
   # AR(1)-ARCH(2) - use default mu, omega
   garchSpec(model = list(ar = 0.5, alpha = c(0.3, 0.4), beta = 0))
   
   # AR([1,5])-GARCH(1,1) - use default garch values and subset ar[.]
   garchSpec(model = list(mu = 0.001, ar = c(0.5,0,0,0,0.1)))
   
   # ARMA(1,2)-GARCH(1,1) - use default garch values
   garchSpec(model = list(ar = 0.5, ma = c(0.3, -0.3)))  
   
   # GARCH(1,1) - use default omega and specify alpha/beta
   garchSpec(model = list(alpha = 0.2, beta = 0.7))
   
   # GARCH(1,1) - specify omega/alpha/beta
   garchSpec(model = list(omega = 1e-6, alpha = 0.1, beta = 0.8))
   
   # GARCH(1,2) - use default omega and specify alpha[1]/beta[2]
   garchSpec(model = list(alpha = 0.1, beta = c(0.4, 0.4)))
   
   # GARCH(2,1) - use default omega and specify alpha[2]/beta[1]
   garchSpec(model = list(alpha = c(0.12, 0.04), beta = 0.08))
   
   # snorm-ARCH(1) - use defaults with skew Normal
   garchSpec(model = list(beta = 0, skew = 0.8), cond.dist = "snorm")
   
   # sged-GARCH(1,1) - using defaults with skew GED
   garchSpec(model = list(skew = 0.93, shape = 3), cond.dist = "sged")
   
   # Taylor Schwert GARCH(1,1) - this belongs to the family of APARCH Models
   garchSpec(model = list(delta = 1))
   
   # AR(1)-t-APARCH(2, 1) - a little bit more complex specification ...
   garchSpec(model = list(mu = 1.0e-4, ar = 0.5, omega = 1.0e-6, 
       alpha = c(0.10, 0.05), gamma = c(0, 0), beta = 0.8, delta = 1.8, 
       shape = 4, skew = 0.85), cond.dist = "sstd")
</code></pre>

<hr>
<h2 id='ged'>Standardized generalized error distribution</h2><span id='topic+ged'></span><span id='topic+dged'></span><span id='topic+pged'></span><span id='topic+qged'></span><span id='topic+rged'></span>

<h3>Description</h3>

<p>Functions to compute density, distribution function, quantile function
and to generate random variates for the standardized generalized error
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dged(x, mean = 0, sd = 1, nu = 2, log = FALSE)
pged(q, mean = 0, sd = 1, nu = 2)
qged(p, mean = 0, sd = 1, nu = 2)
rged(n, mean = 0, sd = 1, nu = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ged_+3A_x">x</code>, <code id="ged_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="ged_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="ged_+3A_n">n</code></td>
<td>

<p>number of observations to simulate.
</p>
</td></tr> 
<tr><td><code id="ged_+3A_mean">mean</code></td>
<td>

<p>location parameter.
</p>
</td></tr>
<tr><td><code id="ged_+3A_sd">sd</code></td>
<td>

<p>scale parameter.
</p>
</td></tr>
<tr><td><code id="ged_+3A_nu">nu</code></td>
<td>

<p>shape parameter.
</p>
</td></tr>
<tr><td><code id="ged_+3A_log">log</code></td>
<td>

<p>logical; if <code>TRUE</code>, densities are given as log densities.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standardized GED is defined so that for a given <code>sd</code> it has
the same variance, <code>sd^2</code>, for all values of the shape parameter,
see the reference by Wuertz et al below.
</p>
<p><code>dged</code> computes the density,
<code>pged</code> the distribution function,
<code>qged</code> the quantile function,
and
<code>rged</code> generates random deviates from the standardized-t
distribution with the specified parameters.
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Nelson D.B. (1991);
<em>Conditional Heteroscedasticity in Asset Returns: A New Approach</em>,
Econometrica, 59, 347&ndash;370.
</p>
<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages.
</p>
<p>Wuertz D., Chalabi Y. and Luksan L. (????);
<em>Parameter estimation of ARMA  models with GARCH/APARCH errors: An R
and SPlus software implementation</em>,
Preprint, 41 pages,
<a href="https://github.com/GeoBosh/fGarchDoc/blob/master/WurtzEtAlGarch.pdf">https://github.com/GeoBosh/fGarchDoc/blob/master/WurtzEtAlGarch.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gedFit">gedFit</a></code>,
<code><a href="#topic+absMoments">absMoments</a></code>,
<code><a href="#topic+sged">sged</a></code> (skew GED),
</p>
<p><code><a href="#topic+gedSlider">gedSlider</a></code> for visualization
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## sged -
   par(mfrow = c(2, 2))
   set.seed(1953)
   r = rsged(n = 1000)
   plot(r, type = "l", main = "sged", col = "steelblue")
   
   # Plot empirical density and compare with true density:
   hist(r, n = 25, probability = TRUE, border = "white", col = "steelblue")
   box()
   x = seq(min(r), max(r), length = 201)
   lines(x, dsged(x), lwd = 2)
   
   # Plot df and compare with true df:
   plot(sort(r), (1:1000/1000), main = "Probability", col = "steelblue",
     ylab = "Probability")
   lines(x, psged(x), lwd = 2)
   
   # Compute quantiles:
   round(qsged(psged(q = seq(-1, 5, by = 1))), digits = 6)
       
</code></pre>

<hr>
<h2 id='gedFit'>Generalized error distribution parameter estimation</h2><span id='topic+gedFit'></span>

<h3>Description</h3>

<p>Function to fit the parameters of the generalized error distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gedFit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gedFit_+3A_x">x</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="gedFit_+3A_...">...</code></td>
<td>

<p>parameters parsed to the optimization function <code>nlm</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gedFit</code> returns a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>

<p>The best set of parameters found. 
</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>

<p>The value of objective corresponding to <code>par</code>.
</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>An integer code, 0 indicates successful convergence.
</p>
</td></tr>  
<tr><td><code>message</code></td>
<td>

<p>A character string giving any additional information returned by the
optimizer, or NULL. For details, see PORT documentation.
</p>
</td></tr>  
<tr><td><code>iterations</code></td>
<td>

<p>Number of iterations performed.
</p>
</td></tr> 
<tr><td><code>evaluations</code></td>
<td>

<p>Number of objective function and gradient function evaluations.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Nelson D.B. (1991);
<em>Conditional Heteroscedasticity in Asset Returns: A New Approach</em>,
Econometrica, 59, 347&ndash;370.
</p>
<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ged">ged</a></code>,
<code><a href="#topic+sgedFit">sgedFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## rged -
   set.seed(1953)
   r = rged(n = 1000)
       
## gedFit -
   gedFit(r)
</code></pre>

<hr>
<h2 id='gedSlider'>Generalized error distribution slider</h2><span id='topic+gedSlider'></span>

<h3>Description</h3>

<p>Displays interactively the dependence of the GED distribution on its
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gedSlider(type = c("dist", "rand"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gedSlider_+3A_type">type</code></td>
<td>

<p>a character string denoting which interactive plot should be
displayed. Either a distribution plot <code>type = "dist"</code>, the
default value, or a random variates plot, <code>type = "rand"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Tcl object
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Nelson D.B. (1991);
<em>Conditional Heteroscedasticity in Asset Returns: A New Approach</em>,
Econometrica, 59, 347&ndash;370.
</p>
<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ged">ged</a></code>,
<code><a href="#topic+gedFit">gedFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
## gedSlider -
   require(tcltk)
   gedSlider("dist")
   gedSlider("rand")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot-methods'>GARCH plot methods</h2><span id='topic+plot-methods'></span><span id='topic+plot'></span><span id='topic+plot+2CfGARCH+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot methods for GARCH modelling. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fGARCH,missing'
plot(x, which = "ask", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>

<p>an object of class <code>"fGARCH"</code>.
</p>
</td></tr> 
<tr><td><code id="plot-methods_+3A_which">which</code></td>
<td>

<p>a character string or a vector of positive integers specifying which
plot(s) should be displayed, see section &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>

<p>optional arguments to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> method for <code>"fGARCH"</code> objects offers a selection
of diagnostic, exploratory, and presentation plots from a menu.
Argument <code>which</code> can be used to request specific plots.  This is
particularly useful in scripts.
</p>
<p>If <code>which</code> is of length larger than one, all requested plots are
produced. For this to be useful, the graphics window should be split
beforehand in subwindows, e.g., using <code>par(mfrow = ...)</code>,
<code>par(mfcol = ...)</code>, or <code>layout()</code> (see section
&lsquo;Examples&rsquo;). If this is not done, then only the last plot will
be visible.
</p>
<p>The following graphs are available:
</p>

<table>
<tr>
 <td style="text-align: right;">
     1 </td><td style="text-align: left;"> Time SeriesPlot</td>
</tr>
<tr>
 <td style="text-align: right;">
     2 </td><td style="text-align: left;"> Conditional Standard Deviation Plot</td>
</tr>
<tr>
 <td style="text-align: right;">
     3 </td><td style="text-align: left;"> Series Plot with 2 Conditional SD Superimposed</td>
</tr>
<tr>
 <td style="text-align: right;">
     4 </td><td style="text-align: left;"> Autocorrelation function Plot of Observations</td>
</tr>
<tr>
 <td style="text-align: right;">
     5 </td><td style="text-align: left;"> Autocorrelation function Plot of Squared Observations</td>
</tr>
<tr>
 <td style="text-align: right;">
     6 </td><td style="text-align: left;"> Cross Correlation Plot</td>
</tr>
<tr>
 <td style="text-align: right;">
     7 </td><td style="text-align: left;"> Residuals Plot</td>
</tr>
<tr>
 <td style="text-align: right;">
     8 </td><td style="text-align: left;"> Conditional Standard Deviations Plot</td>
</tr>
<tr>
 <td style="text-align: right;">
     9 </td><td style="text-align: left;"> Standardized Residuals Plot</td>
</tr>
<tr>
 <td style="text-align: right;">
    10 </td><td style="text-align: left;"> ACF Plot of Standardized Residuals</td>
</tr>
<tr>
 <td style="text-align: right;">
    11 </td><td style="text-align: left;"> ACF Plot of Squared Standardized Residuals</td>
</tr>
<tr>
 <td style="text-align: right;">
    12 </td><td style="text-align: left;"> Cross Correlation Plot between $r^2$ and r</td>
</tr>
<tr>
 <td style="text-align: right;">
    13 </td><td style="text-align: left;"> Quantile-Quantile Plot of Standardized Residuals</td>
</tr>
<tr>
 <td style="text-align: right;">
    14 </td><td style="text-align: left;"> Series with -VaR Superimposed</td>
</tr>
<tr>
 <td style="text-align: right;">
    15 </td><td style="text-align: left;"> Series with -ES Superimposed</td>
</tr>
<tr>
 <td style="text-align: right;">
    16 </td><td style="text-align: left;"> Series with -VaR &amp; -ES Superimposed
  </td>
</tr>

</table>
        


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port;
</p>
<p>VaR and ES graphs were added by Georgi N. Boshnakov in v4033.92
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsdiag.fGARCH">fGARCH</a></code> method for <code>tsdiag</code>,
</p>
<p><code><a href="#topic+garchFit">garchFit</a></code>,
class <code><a href="#topic+fGARCH-class">fGARCH</a></code>,
</p>
<p><code><a href="#topic+predict">predict</a></code>,
<code><a href="#topic+fitted">fitted</a></code>,
<code><a href="#topic+residuals">residuals</a></code>
<code><a href="#topic+VaR">VaR</a></code>
<code><a href="#topic+ES">ES</a></code>
</p>
<p><code><a href="#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate a Garch(1,1) time series
x &lt;- garchSim(n = 200)
head(x) 

## fit GARCH(1,1) model
fit &lt;- garchFit(formula = ~ garch(1, 1), data = x, trace = FALSE)

## Not run: 
## choose plots interactively
plot(fit)

## End(Not run)
   
## Batch Plot:
plot(fit, which = 3)

## a 2 by 2 matrix of plots
op &lt;- par(mfrow = c(2,2))          # prepare 2x2 window
plot(fit, which = c(10, 11, 3, 16)) # plot
par(op)                            # restore the previous layout
</code></pre>

<hr>
<h2 id='predict-methods'>GARCH prediction function</h2><span id='topic+predict-methods'></span><span id='topic+predict'></span><span id='topic+predict+2CfGARCH-method'></span>

<h3>Description</h3>

<p>Predicts a time series from a fitted GARCH object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fGARCH'
predict(object, n.ahead = 10, trace = FALSE, mse = c("cond","uncond"),
        plot=FALSE, nx=NULL, crit_val=NULL, conf=NULL, ..., p_loss = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict-methods_+3A_n.ahead">n.ahead</code></td>
<td>
<p> an integer value, denoting the number of steps to be
forecasted, by default 10.</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_object">object</code></td>
<td>
<p> an object of class <code>"fGARCH"</code> as returned by the
function <code>garchFit</code>.</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_trace">trace</code></td>
<td>
<p> a logical flag. Should the prediction process be traced?
By default <code>trace=FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_mse">mse</code></td>
<td>
<p> If set to <code>"cond"</code>, <code>meanError</code> is defined as
the conditional mean errors
<code class="reqn">\sqrt{E_t[x_{t+h}-E_t(x_{t+h})]^2}</code>. If set to <code>"uncond"</code>,
it is defined as <code class="reqn">\sqrt{E[x_{t+h}-E_t(x_{t+h})]^2}</code>.</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_plot">plot</code></td>
<td>
<p>If set to <code>TRUE</code>, the confidence intervals are
computed and plotted</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_nx">nx</code></td>
<td>
<p>The number of observations to be plotted along with the
predictions. The default is <code>round(n*0.25)</code>, where n is the
sample size.</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_crit_val">crit_val</code></td>
<td>
<p>The critical values for the confidence intervals when
<code>plot</code> is set to <code>TRUE</code>. The intervals are defined as
<code class="reqn">\hat{x}_{t+h}</code> + <code>crit_val[2] * meanError</code> and
<code class="reqn">\hat{x}_{t+h}</code> + <code>crit_val[1] * meanError</code> if two critical
values are provided and <code class="reqn">\hat{x}_{t+h} \pm</code> <code>crit_val *
    meanError</code> if only one is given. If you do not provide critical
values, they will be computed automatically.  </p>
</td></tr>
<tr><td><code id="predict-methods_+3A_conf">conf</code></td>
<td>
<p>The confidence level for the confidence intervals if
<code>crit_val</code> is not provided.  By default it is set to 0.95. The
critical values are then computed using the conditional distribution
that was chosen to create the <code>object</code> with <code>garchFit</code>
using the same <code>shape</code> and <code>skew</code> parameters. If the
conditionnal distribution was set to <code>"QMLE"</code>, the critical
values are computed using the empirical distribution of the
standardized residuals.  </p>
</td></tr>
<tr><td><code id="predict-methods_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed. </p>
</td></tr>
<tr><td><code id="predict-methods_+3A_p_loss">p_loss</code></td>
<td>

<p>if not null, compute predictions for VaR and ES for loss level
<code>p_loss</code> (typically, 0.05 or 0.01).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predictions are returned as a data frame with columns
<code>"meanForecast"</code>, <code>"meanError"</code>, and
<code>"standardDeviation"</code>. Row <code>h</code> contains the predictions for
horizon <code>h</code> (so, <code>n.ahead</code> rows in total).
</p>
<p>If <code>plot = TRUE</code>, the data frame contain also the prediction
limits for each horizon in columns <code>lowerInterval</code> and
<code>upperInterval</code>.
</p>
<p>If <code>p_loss</code> is not NULL, predictions of Value-at-Risk (VaR) and
Expected Shortfall (ES) are returned in columns <code>VaR</code> and
<code>ES</code>. The data frame has attribute <code>"p_loss"</code> containing
<code>p_loss</code>. Typical values for <code>p_loss</code> are 0.01 and 0.05.
</p>
<p>These are somewhat experimental and the arguments and the returned
values may change.
</p>


<h3>Value</h3>

<p>a data frame containing <code>n.ahead</code> rows and 3 to 7 columns,
see section &lsquo;Details&rsquo;
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code> in base R
</p>
<p><code><a href="#topic+fitted">fitted</a></code>,
<code><a href="#topic+residuals">residuals</a></code>,
</p>
<p><code><a href="#topic+plot">plot</a></code>,
<code><a href="#topic+garchFit">garchFit</a></code>,
class <code><a href="#topic+fGARCH-class">fGARCH</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Parameter Estimation of Default GARCH(1,1) Model
set.seed(123)
fit = garchFit(~ garch(1, 1), data = garchSim(), trace = FALSE)
fit

## predict
predict(fit, n.ahead = 10)
predict(fit, n.ahead = 10, mse="uncond")

## predict with plotting: critical values = +/- 2
predict(fit, n.ahead = 10, plot=TRUE, crit_val = 2)

## include also VaR and ES at 5%
predict(fit, n.ahead = 10, plot=TRUE, crit_val = 2, p_loss = 0.05)

## predict with plotting: automatic critical values 
## for different conditional distributions
set.seed(321)
fit2 = garchFit(~ garch(1, 1), data = garchSim(), trace=FALSE, cond.dist="sged")

## 95% confidence level
predict(fit2, n.ahead=20, plot=TRUE) 

set.seed(444)
fit3 = garchFit(~ garch(1, 1), data = garchSim(), trace=FALSE, cond.dist="QMLE")

## 90% confidence level and nx=100
predict(fit3, n.ahead=20, plot=TRUE, conf=.9, nx=100) 
</code></pre>

<hr>
<h2 id='residuals-methods'>Extract GARCH model residuals</h2><span id='topic+residuals-methods'></span><span id='topic+residuals'></span><span id='topic+residuals+2CfGARCH-method'></span>

<h3>Description</h3>

<p>Extracts residuals from a fitted GARCH object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fGARCH'
residuals(object, standardize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals-methods_+3A_object">object</code></td>
<td>

<p>an object of class <code>"fGARCH"</code> as returned by
<code><a href="#topic+garchFit">garchFit</a></code>.
</p>
</td></tr>
<tr><td><code id="residuals-methods_+3A_standardize">standardize</code></td>
<td>

<p>a logical, indicating if the residuals should be standardized.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"fGARCH"</code> method extracts the <code>@residuals</code> slot from an
object of class <code>"fGARCH"</code> as returned by the function
<code>garchFit</code> and optionally standardizes them, using conditional
standard deviations.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted">fitted</a></code>,
<code><a href="#topic+predict">predict</a></code>,
<code><a href="#topic+garchFit">garchFit</a></code>,
class <code><a href="#topic+fGARCH-class">fGARCH</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stopifnot(require("timeSeries"))
## Swiss Pension fund Index
data(LPP2005REC, package = "timeSeries")
x &lt;- as.timeSeries(LPP2005REC)

## Fit LPP40 Bechmark:
fit &lt;- garchFit(LPP40 ~ garch(1, 1), data = 100*x, trace = FALSE)
fit

fitted &lt;- fitted(fit)
head(fitted)
class(fitted)

res &lt;- residuals(fit)
head(res)
class(res)
</code></pre>

<hr>
<h2 id='sged'>Skew generalized error distribution</h2><span id='topic+sged'></span><span id='topic+dsged'></span><span id='topic+psged'></span><span id='topic+qsged'></span><span id='topic+rsged'></span>

<h3>Description</h3>

<p>Functions to compute density, distribution function, quantile function
and to generate random variates for the skew generalized error
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsged(x, mean = 0, sd = 1, nu = 2, xi = 1.5, log = FALSE)
psged(q, mean = 0, sd = 1, nu = 2, xi = 1.5)
qsged(p, mean = 0, sd = 1, nu = 2, xi = 1.5)
rsged(n, mean = 0, sd = 1, nu = 2, xi = 1.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sged_+3A_mean">mean</code>, <code id="sged_+3A_sd">sd</code>, <code id="sged_+3A_nu">nu</code>, <code id="sged_+3A_xi">xi</code></td>
<td>

<p>location parameter <code>mean</code>,
scale parameter <code>sd</code>,
shape parameter <code>nu</code>, 
skewness parameter <code>xi</code>.
</p>
</td></tr>
<tr><td><code id="sged_+3A_n">n</code></td>
<td>

<p>the number of observations.
</p>
</td></tr> 
<tr><td><code id="sged_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="sged_+3A_x">x</code>, <code id="sged_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="sged_+3A_log">log</code></td>
<td>

<p>a logical; if TRUE, densities are given as log densities.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution is standardized as discussed in the reference by
Wuertz et al below.
</p>


<h3>Value</h3>

<p><code>d*</code> returns the density,
<code>p*</code> returns the distribution function,
<code>q*</code> returns the quantile function, and
<code>r*</code> generates random deviates, <br />
all values are numeric vectors.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Nelson D.B. (1991);
<em>Conditional Heteroscedasticity in Asset Returns: A New Approach</em>,
Econometrica, 59, 347&ndash;370.
</p>
<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>
<p>Wuertz D., Chalabi Y. and Luksan L. (????);
<em>Parameter estimation of ARMA  models with GARCH/APARCH errors: An R
and SPlus software implementation</em>,
Preprint, 41 pages,
<a href="https://github.com/GeoBosh/fGarchDoc/blob/master/WurtzEtAlGarch.pdf">https://github.com/GeoBosh/fGarchDoc/blob/master/WurtzEtAlGarch.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sgedFit">sgedFit</a></code> (fit),
<code><a href="#topic+sgedSlider">sgedSlider</a></code> (visualize),
</p>
<p><code><a href="#topic+ged">ged</a></code> (symmetric GED)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## sged -
   par(mfrow = c(2, 2))
   set.seed(1953)
   r = rsged(n = 1000)
   plot(r, type = "l", main = "sged", col = "steelblue")
   
   # Plot empirical density and compare with true density:
   hist(r, n = 25, probability = TRUE, border = "white", col = "steelblue")
   box()
   x = seq(min(r), max(r), length = 201)
   lines(x, dsged(x), lwd = 2)
   
   # Plot df and compare with true df:
   plot(sort(r), (1:1000/1000), main = "Probability", col = "steelblue",
     ylab = "Probability")
   lines(x, psged(x), lwd = 2)
   
   # Compute quantiles:
   round(qsged(psged(q = seq(-1, 5, by = 1))), digits = 6)
</code></pre>

<hr>
<h2 id='sgedFit'>Skew generalized error distribution parameter estimation</h2><span id='topic+sgedFit'></span>

<h3>Description</h3>

<p>Function to fit the parameters of the skew generalized error
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgedFit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sgedFit_+3A_x">x</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="sgedFit_+3A_...">...</code></td>
<td>

<p>parameters parsed to the optimization function <code>nlm</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sgedFit</code> returns a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>

<p>The best set of parameters found. 
</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>

<p>The value of objective corresponding to <code>par</code>.
</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>An integer code. 0 indicates successful convergence.
</p>
</td></tr>  
<tr><td><code>message</code></td>
<td>

<p>A character string giving any additional information returned by the
optimizer, or NULL. For details, see PORT documentation.
</p>
</td></tr>  
<tr><td><code>iterations</code></td>
<td>

<p>Number of iterations performed.
</p>
</td></tr> 
<tr><td><code>evaluations</code></td>
<td>

<p>Number of objective function and gradient function evaluations.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Nelson D.B. (1991);
<em>Conditional Heteroscedasticity in Asset Returns: A New Approach</em>,
Econometrica, 59, 347&ndash;370.
</p>
<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sged">sged</a></code>,
<code><a href="#topic+sgedSlider">sgedSlider</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## rsged -
   set.seed(1953)
   r = rsged(n = 1000)
       
## sgedFit -
   sgedFit(r)
</code></pre>

<hr>
<h2 id='sgedSlider'>Skew GED distribution slider</h2><span id='topic+sgedSlider'></span>

<h3>Description</h3>

<p>Displays interactively the dependence of the skew GED distribution
on its parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgedSlider(type = c("dist", "rand"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sgedSlider_+3A_type">type</code></td>
<td>

<p>a character string denoting which interactive plot should be
displayed. Either a distribution plot <code>type="dist"</code>, the
default value, or a random variates plot, <code>type="rand"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Tcl object
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Nelson D.B. (1991);
<em>Conditional Heteroscedasticity in Asset Returns: A New Approach</em>,
Econometrica, 59, 347&ndash;370.
</p>
<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sged">sged</a></code>,
<code><a href="#topic+sgedFit">sgedFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
## sgedSlider -
   require(tcltk)
   sgedSlider("dist")
   sgedSlider("rand")

## End(Not run)
</code></pre>

<hr>
<h2 id='snorm'>Skew normal distribution</h2><span id='topic+snorm'></span><span id='topic+dsnorm'></span><span id='topic+psnorm'></span><span id='topic+qsnorm'></span><span id='topic+rsnorm'></span>

<h3>Description</h3>

<p>Functions to compute density, distribution function, quantile function
and to generate random variates for the skew normal distribution.
</p>
<p>The distribution is standardized as discussed in the reference by
Wuertz et al below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsnorm(x, mean = 0, sd = 1, xi = 1.5, log = FALSE)
psnorm(q, mean = 0, sd = 1, xi = 1.5)
qsnorm(p, mean = 0, sd = 1, xi = 1.5)
rsnorm(n, mean = 0, sd = 1, xi = 1.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snorm_+3A_x">x</code>, <code id="snorm_+3A_q">q</code></td>
<td>
<p>a numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="snorm_+3A_p">p</code></td>
<td>
<p>a numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="snorm_+3A_n">n</code></td>
<td>
<p>the number of observations.</p>
</td></tr> 
<tr><td><code id="snorm_+3A_mean">mean</code></td>
<td>
<p>location parameter.</p>
</td></tr>
<tr><td><code id="snorm_+3A_sd">sd</code></td>
<td>
<p>scale parameter.</p>
</td></tr>
<tr><td><code id="snorm_+3A_xi">xi</code></td>
<td>
<p>skewness parameter.</p>
</td></tr>
<tr><td><code id="snorm_+3A_log">log</code></td>
<td>
<p>a logical; if TRUE, densities are given as log densities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dsnorm</code> computed the density,
<code>psnorm</code> the distribution function,
<code>qsnorm</code> the quantile function,
and
<code>rsnorm</code> generates random deviates.
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages.
</p>
<p>Wuertz D., Chalabi Y. and Luksan L. (????);
<em>Parameter estimation of ARMA  models with GARCH/APARCH errors: An R
and SPlus software implementation</em>,
Preprint, 41 pages,
<a href="https://github.com/GeoBosh/fGarchDoc/blob/master/WurtzEtAlGarch.pdf">https://github.com/GeoBosh/fGarchDoc/blob/master/WurtzEtAlGarch.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snormFit">snormFit</a></code> (fit),
<code><a href="#topic+snormSlider">snormSlider</a></code> (visualize),
</p>
<p><code><a href="#topic+sstd">sstd</a></code> (skew Student-t),
<code><a href="#topic+sged">sged</a></code> (skew GED)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## snorm -
   # Ranbdom Numbers:
   par(mfrow = c(2, 2))
   set.seed(1953)
   r = rsnorm(n = 1000)
   plot(r, type = "l", main = "snorm", col = "steelblue")
   
   # Plot empirical density and compare with true density:
   hist(r, n = 25, probability = TRUE, border = "white", col = "steelblue")
   box()
   x = seq(min(r), max(r), length = 201)
   lines(x, dsnorm(x), lwd = 2)
   
   # Plot df and compare with true df:
   plot(sort(r), (1:1000/1000), main = "Probability", col = "steelblue",
     ylab = "Probability")
   lines(x, psnorm(x), lwd = 2)
   
   # Compute quantiles:
   round(qsnorm(psnorm(q = seq(-1, 5, by = 1))), digits = 6)
</code></pre>

<hr>
<h2 id='snormFit'>Skew normal distribution parameter estimation</h2><span id='topic+snormFit'></span>

<h3>Description</h3>

<p>Fits the parameters of the skew normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snormFit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snormFit_+3A_x">x</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="snormFit_+3A_...">...</code></td>
<td>

<p>parameters passed to the optimization function <code>nlm</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>snormFit</code> returns a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>

<p>The best set of parameters found. 
</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>

<p>The value of objective corresponding to <code>par</code>.
</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>An integer code. 0 indicates successful convergence.
</p>
</td></tr>  
<tr><td><code>message</code></td>
<td>

<p>A character string giving any additional information returned by the
optimizer, or NULL. For details, see PORT documentation.
</p>
</td></tr>  
<tr><td><code>iterations</code></td>
<td>

<p>Number of iterations performed.
</p>
</td></tr> 
<tr><td><code>evaluations</code></td>
<td>

<p>Number of objective function and gradient function 
evaluations.
</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snormFit">snormFit</a></code> (fit),
<code><a href="#topic+snormSlider">snormSlider</a></code> (visualize),
<code><a href="#topic+absMoments">absMoments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## rsnorm -
   set.seed(1953)
   r = rsnorm(n = 1000)
       
## snormFit -
   snormFit(r)
</code></pre>

<hr>
<h2 id='snormSlider'>Skew normal distribution slider</h2><span id='topic+snormSlider'></span>

<h3>Description</h3>

<p>Displays interactively the dependence of the skew Normal distribution
on its parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snormSlider(type = c("dist", "rand"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snormSlider_+3A_type">type</code></td>
<td>

<p>a character string denoting which interactive plot should be
displayed. Either a distribution plot <code>type="dist"</code>, the
default value, or a random variates plot, <code>type="rand"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Tcl object
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snormFit">snormFit</a></code> (fit),
<code><a href="#topic+snorm">snorm</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
## snormSlider -
   require(tcltk)
   snormSlider("dist")
   snormSlider("rand")

## End(Not run)
</code></pre>

<hr>
<h2 id='sstd'>Skew Student-t distribution</h2><span id='topic+sstd'></span><span id='topic+dsstd'></span><span id='topic+psstd'></span><span id='topic+qsstd'></span><span id='topic+rsstd'></span>

<h3>Description</h3>

<p>Functions to compute density, distribution function, quantile function
and to generate random variates for the skew Student-t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsstd(x, mean = 0, sd = 1, nu = 5, xi = 1.5, log = FALSE)
psstd(q, mean = 0, sd = 1, nu = 5, xi = 1.5)
qsstd(p, mean = 0, sd = 1, nu = 5, xi = 1.5)
rsstd(n, mean = 0, sd = 1, nu = 5, xi = 1.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sstd_+3A_x">x</code>, <code id="sstd_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="sstd_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="sstd_+3A_n">n</code></td>
<td>

<p>number of observations to simulate.
</p>
</td></tr> 
<tr><td><code id="sstd_+3A_mean">mean</code></td>
<td>

<p>location parameter.
</p>
</td></tr>
<tr><td><code id="sstd_+3A_sd">sd</code></td>
<td>

<p>scale parameter.
</p>
</td></tr>
<tr><td><code id="sstd_+3A_nu">nu</code></td>
<td>

<p>shape parameter (degrees of freedom).
</p>
</td></tr>
<tr><td><code id="sstd_+3A_xi">xi</code></td>
<td>

<p>skewness parameter.
</p>
</td></tr>
<tr><td><code id="sstd_+3A_log">log</code></td>
<td>

<p>logical; if <code>TRUE</code>, densities are given as log densities.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution is standardized as discussed in the reference by
Wuertz et al below.
</p>
<p><code>dsstd</code> computes the density,
<code>psstd</code> the distribution function,
<code>qsstd</code> the quantile function, and
<code>rsstd</code> generates random deviates.
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>
<p>Wuertz D., Chalabi Y. and Luksan L. (????);
<em>Parameter estimation of ARMA  models with GARCH/APARCH errors: An R
and SPlus software implementation</em>,
Preprint, 41 pages,
<a href="https://github.com/GeoBosh/fGarchDoc/blob/master/WurtzEtAlGarch.pdf">https://github.com/GeoBosh/fGarchDoc/blob/master/WurtzEtAlGarch.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sstdFit">sstdFit</a></code> (fit),
<code><a href="#topic+sstdSlider">sstdSlider</a></code> (visualize)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## sstd -
   par(mfrow = c(2, 2))
   set.seed(1953)
   r = rsstd(n = 1000)
   plot(r, type = "l", main = "sstd", col = "steelblue")
   
   # Plot empirical density and compare with true density:
   hist(r, n = 25, probability = TRUE, border = "white", col = "steelblue")
   box()
   x = seq(min(r), max(r), length = 201)
   lines(x, dsstd(x), lwd = 2)
   
   # Plot df and compare with true df:
   plot(sort(r), (1:1000/1000), main = "Probability", col = "steelblue",
     ylab = "Probability")
   lines(x, psstd(x), lwd = 2)
   
   # Compute quantiles:
   round(qsstd(psstd(q = seq(-1, 5, by = 1))), digits = 6)
</code></pre>

<hr>
<h2 id='sstdFit'>Skew Student-t distribution parameter estimation</h2><span id='topic+sstdFit'></span>

<h3>Description</h3>

<p>Fits the parameters of the skew Student-t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sstdFit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sstdFit_+3A_x">x</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="sstdFit_+3A_...">...</code></td>
<td>

<p>parameters passed to the optimization function <code>nlm</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sstdFit</code> returns a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>

<p>The best set of parameters found. 
</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>

<p>The value of objective corresponding to <code>par</code>.
</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>An integer code. 0 indicates successful convergence.
</p>
</td></tr>  
<tr><td><code>message</code></td>
<td>

<p>A character string giving any additional information returned by the
optimizer, or NULL. For details, see PORT documentation.
</p>
</td></tr>  
<tr><td><code>iterations</code></td>
<td>

<p>Number of iterations performed.
</p>
</td></tr> 
<tr><td><code>evaluations</code></td>
<td>

<p>Number of objective function and gradient function evaluations.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sstd">sstd</a></code>,
<code><a href="#topic+stdFit">stdFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## sstd -
   set.seed(1953)
   r = rsstd(n = 1000)

       
## sstdFit -
   sstdFit(r)
</code></pre>

<hr>
<h2 id='sstdSlider'>Skew Student-t distribution slider</h2><span id='topic+sstdSlider'></span>

<h3>Description</h3>

<p>Displays interactively the dependence of the skew Student-t
distribution on its parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sstdSlider(type = c("dist", "rand"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sstdSlider_+3A_type">type</code></td>
<td>

<p>a character string denoting which interactive plot should be
displayed. Either a distribution plot <code>type="dist"</code>, the
default value, or a random variates plot, <code>type="rand"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Tcl object
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sstd">sstd</a></code>,
<code><a href="#topic+sstdFit">sstdFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
## sstdSlider -
   require(tcltk)
   sstdSlider("dist")
   sstdSlider("rand")

## End(Not run)
</code></pre>

<hr>
<h2 id='stats-tsdiag'>Diagnostic plots and statistics for fitted GARCH models</h2><span id='topic+stats-tsdiag'></span><span id='topic+tsdiag'></span><span id='topic+tsdiag.fGARCH'></span>

<h3>Description</h3>

<p>Produce diagnostics for fitted GARCH/APARCH models. The method offers
several tests, plots of autocorrelations and partial autocorrelations
of the standardised conditional residuals, ability to control which
graphs are produced (including interactively), as well as their
layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fGARCH'
tsdiag(object, gof.lag = NULL, ask = FALSE, ..., plot = c(4L, 5L, 7L), 
       layout = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stats-tsdiag_+3A_object">object</code></td>
<td>

<p>an object from class <code>"fGARCH"</code>, as returned by
<code><a href="#topic+garchFit">garchFit</a></code>. 
</p>
</td></tr>
<tr><td><code id="stats-tsdiag_+3A_gof.lag">gof.lag</code></td>
<td>
<p>maximal lag for portmanteau tests.</p>
</td></tr>
<tr><td><code id="stats-tsdiag_+3A_ask">ask</code></td>
<td>
<p>if <code>TRUE</code> present a menu of available plots, see Details.</p>
</td></tr>
<tr><td><code id="stats-tsdiag_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="stats-tsdiag_+3A_plot">plot</code></td>
<td>

<p>if <code>TRUE</code> all available plots; a vector of positive integers
specifies a subset of the available plots.
</p>
</td></tr>
<tr><td><code id="stats-tsdiag_+3A_layout">layout</code></td>
<td>

<p>a list with arguments for <code>graphics::layout</code> for the plots. The
default plots the autocorrelations of the standardised conditional
residuals and their squares, as well as a QQ-plot for the fitted
conditional distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute and graph diagnostics for fitted ARMA-GARCH/APARCH models.
</p>








<p><code>plot</code> can be <code>TRUE</code> to ask for all plots or a vector of
positive integers specifying which plots to consider. Currently the
following options are available:
</p>

<table>
<tr>
 <td style="text-align: right;">1 </td><td style="text-align: left;"> Residuals </td>
</tr>
<tr>
 <td style="text-align: right;">
 2 </td><td style="text-align: left;"> Conditional SDs </td>
</tr>
<tr>
 <td style="text-align: right;">
 3 </td><td style="text-align: left;"> Standardized Residuals </td>
</tr>
<tr>
 <td style="text-align: right;">
 4 </td><td style="text-align: left;"> ACF of Standardized Residuals </td>
</tr>
<tr>
 <td style="text-align: right;">
 5 </td><td style="text-align: left;"> ACF of Squared Standardized Residuals </td>
</tr>
<tr>
 <td style="text-align: right;">
 6 </td><td style="text-align: left;"> Cross Correlation between r^2 and r </td>
</tr>
<tr>
 <td style="text-align: right;">
 7 </td><td style="text-align: left;"> QQ-Plot of Standardized Residuals</td>
</tr>

</table>

<p> The
default produces plots of autocorrelations and partial
autocorrelations of the standardised conditional residuals, as well as
a QQ-plot for the fitted conditional distribution.  If <code>plot</code> is
<code>TRUE</code>, you probably need also <code>ask = TRUE</code>.
</p>
<p>If argument <code>plot</code> is of length two the graphics window is split
into 2 equal subwindows. Argument <code>layout</code> can still be used to
change this.  If argument <code>plot</code> is of length one the graphics
window is not split at all.
</p>
<p>In interactive sessions, if the number of requested graphs (as
specified by argument <code>plot</code>) is larger than the number of graphs
specified by the layout (by default 3), the function makes the first
graph and then presents a menu of the requested plots. 
</p>
<p>Argument <code>layout</code> can be used to change the layout of the plot,
for example to put two graphs per plot, see the examples. Currently it
should be a list of arguments for <code><a href="graphics.html#topic+layout">layout</a></code>, see <code>?layout</code>.
Don't call <code>layout</code> youself, as that will change the graphics
device prematurely.
</p>
<p>The computed results are returned (invisibly). This is another
difference from <code>stats::tsdiag</code> which doesn't return them.
</p>


<h3>Value</h3>

<p>(experimental, may change)
a list with components:
</p>
<table role = "presentation">
<tr><td><code>residuals</code></td>
<td>
<p>standardised conditional residuals,</p>
</td></tr>
<tr><td><code>gof</code></td>
<td>

<p>goodness-of-fit tests, pretending parameters are known,
</p>
</td></tr>
<tr><td><code>gof_composite</code></td>
<td>

<p>goodness-of-fit tests taking into account that the parameters are
estimated.
</p>
</td></tr>
</table>
<p>Only components that are actually computed are included, the rest are
NULL or absent.
</p>


<h3>Author(s)</h3>

<p>Georgi N. boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CfGARCH+2Cmissing-method">fGARCH</a></code> method for <code>plot</code>,
</p>
<p><code><a href="stats.html#topic+tsdiag">tsdiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20230612)
x &lt;- garchSim(n = 200)
fit &lt;- garchFit(formula = ~ garch(1, 1), data = x, trace = FALSE)
fit_test &lt;- tsdiag(fit)
fit_test

## 2x2 matrix with acf of r, r^2 on diag, cor(r,r^2) below it, and qq-plot
tsdiag(fit, plot = c(4, 6, 7, 5), layout = list(matrix(1:4, nrow = 2)))
</code></pre>

<hr>
<h2 id='std'>Standardized Student-t distribution</h2><span id='topic+std'></span><span id='topic+dstd'></span><span id='topic+pstd'></span><span id='topic+qstd'></span><span id='topic+rstd'></span>

<h3>Description</h3>

<p>Functions to compute density, distribution function, quantile function
and to generate random variates for the standardized Student-t
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dstd(x, mean = 0, sd = 1, nu = 5, log = FALSE)
pstd(q, mean = 0, sd = 1, nu = 5)
qstd(p, mean = 0, sd = 1, nu = 5)
rstd(n, mean = 0, sd = 1, nu = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="std_+3A_x">x</code>, <code id="std_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="std_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
</p>
</td></tr>
<tr><td><code id="std_+3A_n">n</code></td>
<td>

<p>number of observations to simulate.
</p>
</td></tr> 
<tr><td><code id="std_+3A_mean">mean</code></td>
<td>

<p>location parameter.
</p>
</td></tr>
<tr><td><code id="std_+3A_sd">sd</code></td>
<td>

<p>scale parameter.
</p>
</td></tr>
<tr><td><code id="std_+3A_nu">nu</code></td>
<td>

<p>shape parameter (degrees of freedom).
</p>
</td></tr>
<tr><td><code id="std_+3A_log">log</code></td>
<td>

<p>logical; if <code>TRUE</code>, densities are given as log densities.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standardized Student-t distribution is defined so that for a given
<code>sd</code> it has the same variance, <code>sd^2</code>, for all degrees of
freedom. For comparison, the variance of the usual Student-t
distribution is <code>nu/(nu-2)</code>, where <code>nu</code> is the degrees of
freedom.  The usual Student-t distribution is obtained by setting
<code>sd = sqrt(nu/(nu - 2))</code>.
</p>
<p>Argument <code>nu</code> must be greater than 2. Although there is a default
value for <code>nu</code>, it is rather arbitrary and relying on it is
strongly discouraged.
</p>
<p><code>dstd</code> computes the density,
<code>pstd</code> the distribution function,
<code>qstd</code> the quantile function,
and
<code>rstd</code> generates random deviates from the standardized-t
distribution with the specified parameters.
</p>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>
<p>Wuertz D., Chalabi Y. and Luksan L. (2006);
<em>Parameter estimation of ARMA  models with GARCH/APARCH errors: An R
and SPlus software implementation</em>,
Preprint, 41 pages,
<a href="https://github.com/GeoBosh/fGarchDoc/blob/master/WurtzEtAlGarch.pdf">https://github.com/GeoBosh/fGarchDoc/blob/master/WurtzEtAlGarch.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stdFit">stdFit</a></code> (fit).
<code><a href="#topic+stdSlider">stdSlider</a></code> (visualize),
</p>
<p><code><a href="#topic+absMoments">absMoments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## std -

pstd(1, sd = sqrt(5/(5-2)), nu = 5) == pt(1, df = 5) # TRUE

   par(mfrow = c(2, 2))
   set.seed(1953)
   r = rstd(n = 1000)
   plot(r, type = "l", main = "sstd", col = "steelblue")
   
   # Plot empirical density and compare with true density:
   hist(r, n = 25, probability = TRUE, border = "white", col = "steelblue")
   box()
   x = seq(min(r), max(r), length = 201)
   lines(x, dstd(x), lwd = 2)
   
   # Plot df and compare with true df:
   plot(sort(r), (1:1000/1000), main = "Probability", col = "steelblue",
     ylab = "Probability")
   lines(x, pstd(x), lwd = 2)
   
   # Compute quantiles:
   round(qstd(pstd(q = seq(-1, 5, by = 1))), digits = 6)
</code></pre>

<hr>
<h2 id='stdFit'>Student-t distribution parameter estimation</h2><span id='topic+stdFit'></span>

<h3>Description</h3>

<p>Fits the parameters of the standardized Student-t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdFit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stdFit_+3A_x">x</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="stdFit_+3A_...">...</code></td>
<td>

<p>parameters parsed to the optimization function <code>nlm</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>stdFit</code> returns a list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>

<p>The best set of parameters found. 
</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>

<p>The value of objective corresponding to <code>par</code>.
</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>An integer code. 0 indicates successful convergence.
</p>
</td></tr>  
<tr><td><code>message</code></td>
<td>

<p>A character string giving any additional information returned by the
optimizer, or NULL. For details, see PORT documentation.
</p>
</td></tr>  
<tr><td><code>iterations</code></td>
<td>

<p>Number of iterations performed.
</p>
</td></tr> 
<tr><td><code>evaluations</code></td>
<td>

<p>Number of objective function and gradient function evaluations.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>References</h3>

<p>Fernandez C., Steel M.F.J. (2000); 
<em>On Bayesian Modelling of Fat Tails and Skewness</em>,
Preprint, 31 pages. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+std">std</a></code>,
<code><a href="#topic+stdSlider">stdSlider</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## std -
   set.seed(1953)
   r = rstd(n = 1000)

       
## stdFit -
   stdFit(r)
</code></pre>

<hr>
<h2 id='stdSlider'>Student-t distribution slider</h2><span id='topic+stdSlider'></span>

<h3>Description</h3>

<p>Displays interactively the dependence of the Student-t distribution on
its parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdSlider(type = c("dist", "rand"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stdSlider_+3A_type">type</code></td>
<td>

<p>a character string denoting which interactive plot should be
displayed. Either a distribution plot <code>type="dist"</code>, the
default value, or a random variates plot, <code>type="rand"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Tcl object
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>See Also</h3>

<p><code><a href="#topic+std">std</a></code>,
<code><a href="#topic+stdFit">stdFit</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:   
## stdSlider -
   require(tcltk)
   stdSlider("dist")
   stdSlider("rand")

## End(Not run)
</code></pre>

<hr>
<h2 id='summary-methods'>GARCH summary methods</h2><span id='topic+summary-methods'></span><span id='topic+summary'></span><span id='topic+summary+2CfGARCH-method'></span>

<h3>Description</h3>

<p>Summary methods for GARCH modelling. 
</p>


<h3>Methods</h3>

<p>Methods for <code>summary</code> defined in package <span class="pkg">fGarch</span>:
</p>

<dl>
<dt>object = &quot;fGARCH&quot;</dt><dd>
<p>Summary function for objects of class <code>"fGARCH"</code>.
</p>
</dd>
</dl>



<h3>How to read a diagnostic summary report?</h3>

<p>The first five sections return the title, the call, the
mean and variance formula, the conditional distribution and the type of
standard errors:
</p>
<pre> 
        Title:
         GARCH Modelling 
        
        Call:
         garchFit(~ garch(1, 1), data = garchSim(), trace = FALSE) 
        
        Mean and Variance Equation:
         ~arch(0)
        
        Conditional Distribution:
         norm 
        
        Std. Errors:
         based on Hessian
        </pre>
<p>The next three sections return the estimated coefficients and
an error analysis including standard errors, t values, and
probabilities, as well as the log Likelihood values from 
optimization:
</p>
<pre>
        Coefficient(s):
                  mu         omega        alpha1         beta1  
        -5.79788e-05   7.93017e-06   1.59456e-01   2.30772e-01  
        
        Error Analysis:
                 Estimate  Std. Error  t value Pr(&gt;|t|)
        mu     -5.798e-05   2.582e-04   -0.225    0.822
        omega   7.930e-06   5.309e-06    1.494    0.135
        alpha1  1.595e-01   1.026e-01    1.554    0.120
        beta1   2.308e-01   4.203e-01    0.549    0.583
        
        Log Likelihood:
         -843.3991    normalized:  -Inf 
        </pre>
<p>The next section provides results on standardized residuals
tests, including statistic and p values, and on information
criterion statistic including AIC, BIC, SIC, and HQIC:
</p>
<pre> 
        Standardized Residuals Tests:
                                        Statistic p-Value    
         Jarque-Bera Test   R    Chi^2  0.4172129 0.8117146  
         Shapiro-Wilk Test  R    W      0.9957817 0.8566985  
         Ljung-Box Test     R    Q(10)  13.05581  0.2205680  
         Ljung-Box Test     R    Q(15)  14.40879  0.4947788  
         Ljung-Box Test     R    Q(20)  38.15456  0.008478302
         Ljung-Box Test     R^2  Q(10)  7.619134  0.6659837  
         Ljung-Box Test     R^2  Q(15)  13.89721  0.5333388  
         Ljung-Box Test     R^2  Q(20)  15.61716  0.7400728  
         LM Arch Test       R    TR^2   7.049963  0.8542942  
         
        Information Criterion Statistics:
                 AIC      BIC      SIC     HQIC 
            8.473991 8.539957 8.473212 8.500687  
        </pre>    


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## garchSim -
   x = garchSim(n = 200)

## garchFit - 
   fit = garchFit(formula = x ~ garch(1, 1), data = x, trace = FALSE)
   summary(fit)
</code></pre>

<hr>
<h2 id='VaR'>Compute Value-at-Risk (VaR) and expected shortfall (ES)</h2><span id='topic+VaR'></span><span id='topic+VaR.fGARCH'></span><span id='topic+ES'></span><span id='topic+ES.fGARCH'></span>

<h3>Description</h3>

<p>Compute Value-at-Risk (VaR) and Expected Shortfall (ES) for a fitted
GARCH-APARCH model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fGARCH'
VaR(dist, p_loss = 0.05, ..., tol)

## S3 method for class 'fGARCH'
ES(dist, p_loss = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VaR_+3A_dist">dist</code></td>
<td>

<p>an object from class <code>"fGARCH"</code>, obtained from <code>garchFit()</code>.
</p>
</td></tr>
<tr><td><code id="VaR_+3A_p_loss">p_loss</code></td>
<td>
<p>level, default is 0.05.</p>
</td></tr>
<tr><td><code id="VaR_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="VaR_+3A_tol">tol</code></td>
<td>
<p>tollerance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We provide methods for the generic functions <code>cvar::VaR</code> and
<code>cvar::ES</code>.
</p>


<h3>Note</h3>

<p>We use the traditional definition of VaR as the negated lower
quantile. For example, if <code class="reqn">X</code> are returns on an asset,
VAR<code class="reqn">{}_\alpha</code> = <code class="reqn">-q_\alpha</code>, where
<code class="reqn">q_\alpha</code> is the lower <code class="reqn">\alpha</code> quantile of <code class="reqn">X</code>.
Equivalently, VAR<code class="reqn">{}_\alpha</code> is equal to the lower
<code class="reqn">1-\alpha</code> quantile of <code class="reqn">-X</code> (the loss series).  For
details see the vignette in package <span class="pkg">cvar</span> availalble at
<a href="https://cran.r-project.org/package=cvar/vignettes/Guide_cvar.pdf">https://cran.r-project.org/package=cvar/vignettes/Guide_cvar.pdf</a>
(or by calling <code>vignette("Guide_cvar", package = "cvar")</code>).
</p>
<p>If you wish to overlay the VaR or ES over returns, just negate the
VaR/ES, see the examples.
</p>


<h3>See Also</h3>

<p><code><a href="cvar.html#topic+VaR">VaR</a></code> and <code><a href="cvar.html#topic+ES">ES</a></code> in package <span class="pkg">cvar</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate a time series of returns
x &lt;- garchSim( garchSpec(), n = 500)
class(x)
## fit a GARCH model
fit &lt;- garchFit(~ garch(1, 1), data = x, trace = FALSE)

head(VaR(fit))
head(ES(fit))

## use plot method for fitted GARCH models
plot(fit, which = 14) # VaR
plot(fit, which = 15) # ES
plot(fit, which = 16) # VaR &amp; ES
## plot(fit) # choose the plot interactively

## diy plots

## overlay VaR and ES over returns
## here x is from class 'timeSeries', so we convert VaR/ES to timeSeries
## don't forget to negate the result of VaR()/ES(),
plot(x)
lines(timeSeries(-VaR(fit)), col = "red")
lines(timeSeries(-ES(fit)), col = "blue")

## alternatively, plot losses (rather than returns) and don't negate VaR()/ES()
plot(-x)
lines(timeSeries(VaR(fit)), col = "red")
lines(timeSeries(ES(fit)), col = "blue")
</code></pre>

<hr>
<h2 id='volatility-methods'>Extract GARCH model volatility</h2><span id='topic+volatility'></span><span id='topic+volatility.fGARCH'></span>

<h3>Description</h3>

<p>Extracts volatility from a fitted GARCH object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fGARCH'
volatility(object, type = c("sigma", "h"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="volatility-methods_+3A_object">object</code></td>
<td>

<p>an object of class <code>"fGARCH"</code> as returned by
<code><a href="#topic+garchFit">garchFit</a>()</code>.
</p>
</td></tr>
<tr><td><code id="volatility-methods_+3A_type">type</code></td>
<td>

<p>a character string denoting if the conditional standard deviations
<code>"sigma"</code> or the variances <code>"h"</code> should be returned.
</p>
</td></tr>
<tr><td><code id="volatility-methods_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>volatility</code> is an S3 generic function for computation of
volatility, see <code><a href="fBasics.html#topic+volatility">volatility</a></code> for the default
method.
</p>
<p>The method for <code>"fGARCH"</code> objects, described here, extracts the
volatility from slot <code>@sigma.t</code> or <code>@h.t</code> of an
<code>"fGARCH"</code> object usually obtained from the function
<code><a href="#topic+garchFit">garchFit</a>()</code>.
</p>
<p>The class of the returned value depends on the input to the function
<code>garchFit</code> who created the object. The returned value is always
of the same class as the input object to the argument <code>data</code> in
the function <code>garchFit</code>, i.e. if you fit a <code>"timeSeries"</code>
object, you will get back from the function <code>fitted</code> also a
<code>"timeSeries"</code> object, if you fit an object of class
<code>"zoo"</code>, you will get back again a <code>"zoo"</code> object. The same
holds for a <code>"numeric"</code> vector, for a <code>"data.frame"</code>, and
for objects of class <code>"ts", "mts"</code>.
</p>
<p>In contrast, the slot itself always contains a numeric vector,
independently of the class of the input data input, i.e. the function
call <code>slot(object, "fitted")</code> will return a numeric vector.
</p>


<h3>Methods</h3>

<p>Methods for <code>volatility</code> defined in package <span class="pkg">fGarch</span>:
</p>

<dl>
<dt>object = &quot;fGARCH&quot;</dt><dd>
<p>Extractor function for volatility or standard deviation from
an object of class <code>"fGARCH"</code>.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>(GNB) Contrary to the description of the returned value of the
<code>"fGARCH"</code> method, it is always <code>"numeric"</code>.
</p>
<p>TODO: either implement the documented behaviour or fix the
documentation.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port
</p>


<h3>See Also</h3>

<p><code><a href="#topic+garchFit">garchFit</a></code>,
class <code><a href="#topic+fGARCH-class">fGARCH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Swiss Pension fund Index -
   stopifnot(require("timeSeries")) # need package 'timeSeries'
   x = as.timeSeries(data(LPP2005REC, package = "timeSeries"))

## garchFit
   fit = garchFit(LPP40 ~ garch(1, 1), data = 100*x, trace = FALSE)
   fit

## volatility -
   # Standard Deviation:
   vola = volatility(fit, type = "sigma")
   head(vola)
   class(vola)
   # Variance:
   vola = volatility(fit, type = "h")
   head(vola)
   class(vola)

## slot -
   vola = slot(fit, "sigma.t")
   head(vola)
   class(vola)
   vola = slot(fit, "h.t")
   head(vola)
   class(vola)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
