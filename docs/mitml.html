<!DOCTYPE html><html><head><title>Help for package mitml</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mitml}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mitml-package'><p>mitml: Tools for multiple imputation in multilevel modeling</p></a></li>
<li><a href='#amelia2mitml.list'><p>Convert objects of class <code>amelia</code> to <code>mitml.list</code></p></a></li>
<li><a href='#anova.mitml.result'><p>Compare several nested models</p></a></li>
<li><a href='#as.mitml.list'><p>Convert a list of data sets to <code>mitml.list</code></p></a></li>
<li><a href='#c.mitml.list'><p>Concatenate lists of imputed data sets</p></a></li>
<li><a href='#clusterMeans'><p>Calculate cluster means</p></a></li>
<li><a href='#confint.mitml.testEstimates'><p>Summarize and extract pooled parameter estimates</p></a></li>
<li><a href='#is.mitml.list'><p>Check if an object is of class <code>mitml.list</code></p></a></li>
<li><a href='#jomoImpute'><p>Impute single-level and multilevel missing data using <code>jomo</code></p></a></li>
<li><a href='#justice'><p>Example data set on employees' justice perceptions and satisfaction</p></a></li>
<li><a href='#leadership'><p>Example data set on leadership style and job satisfaction</p></a></li>
<li><a href='#long2mitml.list'><p>Convert imputations from long format to <code>mitml.list</code></p></a></li>
<li><a href='#mids2mitml.list'><p>Convert objects of class <code>mids</code> to <code>mitml.list</code></p></a></li>
<li><a href='#mitml.list2mids'><p>Convert objects of class <code>mitml.list</code> to <code>mids</code></p></a></li>
<li><a href='#mitmlComplete'><p>Extract imputed data sets</p></a></li>
<li><a href='#multilevelR2'><p>Calculate R-squared measures for multilevel models</p></a></li>
<li><a href='#panImpute'><p>Impute multilevel missing data using <code>pan</code></p></a></li>
<li><a href='#plot.mitml'><p>Print diagnostic plots</p></a></li>
<li><a href='#read.mitml'><p>Read <code>mitml</code> objects from file</p></a></li>
<li><a href='#sort.mitml.list'><p>Sort a list of imputed data sets</p></a></li>
<li><a href='#studentratings'><p>Example data set on student ratings and achievement</p></a></li>
<li><a href='#subset.mitml.list'><p>Subset a list of imputed data sets</p></a></li>
<li><a href='#summary.mitml'><p>Summary measures for imputation models</p></a></li>
<li><a href='#testConstraints'><p>Test functions and constraints of model parameters</p></a></li>
<li><a href='#testEstimates'><p>Compute final estimates and inferences</p></a></li>
<li><a href='#testModels'><p>Test multiple parameters and compare nested models</p></a></li>
<li><a href='#with.mitml.list'><p>Evaluate an expression in a list of imputed data sets</p></a></li>
<li><a href='#write.mitml'><p>Write <code>mitml</code> objects to file</p></a></li>
<li><a href='#write.mitmlMplus'><p>Write <code>mitml</code> objects to Mplus format</p></a></li>
<li><a href='#write.mitmlSAV'><p>Write <code>mitml</code> objects to native SPSS format</p></a></li>
<li><a href='#write.mitmlSPSS'><p>Write <code>mitml</code> objects to SPSS compatible format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Multiple Imputation in Multilevel Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Grund [aut,cre], Alexander Robitzsch [aut], Oliver Luedtke [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Grund &lt;simon.grund@uni-hamburg.de&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/simongrund1/mitml/issues">https://github.com/simongrund1/mitml/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>pan, jomo, haven, grDevices, graphics, stats, methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mice, miceadds, Amelia, lme4, nlme, lavaan, geepack, glmmTMB,
survival, knitr, rmarkdown</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for multiple imputation of missing data in multilevel
 modeling. Includes a user-friendly interface to the packages 'pan' and 'jomo',
 and several functions for visualization, data management and the analysis 
 of multiply imputed data sets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-08 15:18:05 UTC; simon</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-08 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mitml-package'>mitml: Tools for multiple imputation in multilevel modeling</h2><span id='topic+mitml-package'></span>

<h3>Description</h3>

<p>Provides tools for multiple imputation of missing data in multilevel modeling.
This package includes a user-friendly interface to the algorithms implemented in the R packages <code>pan</code> and <code>jomo</code> as well as several functions for visualizing, managing, and analyzing multiply imputed data sets.
</p>
<p>The main interface to <code>pan</code> is the function <code><a href="#topic+panImpute">panImpute</a></code>, which allows specifying imputation models for continuous variables with missing data at level 1.
In addition, the function <code><a href="#topic+jomoImpute">jomoImpute</a></code> provides an interface to <code>jomo</code>, which allows specifying imputation models for both continuous and categorical variables with missing data at levels 1 and 2 as well as single-level data.
The imputations and parameter values are stored in objects of class <code>mitml</code>.
To obtain the completed (i.e., imputed) data sets, <code><a href="#topic+mitmlComplete">mitmlComplete</a></code> is used, producing a list of imputed data sets of class <code>mitml.list</code> that can be used in further analyses.
</p>
<p>Several additional functions allow for convenient analysis of multiply imputed data sets including (bot not limited to) multilevel analyses with <code>lme4</code> or <code>nlme</code> and structural equation modeling with <code>lavaan</code>.
The functions <code><a href="#topic+with.mitml.list">within</a></code>, <code><a href="#topic+sort.mitml.list">sort</a></code>, and <code><a href="#topic+subset.mitml.list">subset</a></code> can be used to manage and manipulate multiply imputed data sets.
Statistical models are fitted using <code><a href="#topic+with.mitml.list">with</a></code>.
Pooled parameter estimates can be extracted with <code><a href="#topic+testEstimates">testEstimates</a></code>, and model comparisons as well as single- and multi-parameter hypotheses tests can be performed using the functions <code><a href="#topic+testModels">testModels</a></code> and <code><a href="#topic+testConstraints">testConstraints</a></code>.
In addition, the <code><a href="#topic+anova.mitml.result">anova</a></code> method provides a simple interface to model comparisons.
</p>
<p>Data sets can be imported and exported from or to different statistical software packages.
Currently, <code><a href="#topic+mids2mitml.list">mids2mitml.list</a></code>, <code><a href="#topic+amelia2mitml.list">amelia2mitml.list</a></code>, <code><a href="#topic+jomo2mitml.list">jomo2mitml.list</a></code>, and <code><a href="#topic+long2mitml.list">long2mitml.list</a></code> can be used for importing imputations for other packages in R.
In addition, <code><a href="#topic+write.mitmlMplus">write.mitmlMplus</a></code>, <code><a href="#topic+write.mitmlSAV">write.mitmlSAV</a></code>, and <code><a href="#topic+write.mitmlSPSS">write.mitmlSPSS</a></code> export data sets to M<em>plus</em> and SPSS, respectively.
</p>
<p>Finally, the package provides tools for summarizing and visualizing imputation models, which is useful for the assessment of convergence and the reporting of results.
</p>
<p>The data sets contained in this package are published under the same license as the package itself.
They contain simulated data and may be used by anyone free of charge as long as reference to this package is given.
</p>


<h3>Author(s)</h3>

<p>Authors: Simon Grund, Alexander Robitzsch, Oliver Luedtke
</p>
<p>Maintainer: Simon Grund &lt;grund@ipn.uni-kiel.de&gt;
</p>

<hr>
<h2 id='amelia2mitml.list'>Convert objects of class <code>amelia</code> to <code>mitml.list</code></h2><span id='topic+amelia2mitml.list'></span>

<h3>Description</h3>

<p>This function converts a <code>amelia</code> class object (as produced by the <code>Amelia</code> package) to <code>mitml.list</code>. The resulting object may be used in further analyses.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
amelia2mitml.list(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amelia2mitml.list_+3A_x">x</code></td>
<td>
<p>An object of class <code>amelia</code> as produced by <code>amelia</code> (see the <code>Amelia</code> package).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of imputed data sets with an additional class attribute <code>mitml.list</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>See Also</h3>

<p><code><a href="#topic+mitmlComplete">mitmlComplete</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

require(Amelia)
imp &lt;- amelia(x = studentratings[, c("ID", "MathAchiev", "ReadAchiev")], cs = "ID")

implist &lt;- amelia2mitml.list(imp)
</code></pre>

<hr>
<h2 id='anova.mitml.result'>Compare several nested models</h2><span id='topic+anova.mitml.result'></span>

<h3>Description</h3>

<p>Performs model comparisons for a series of nested statistical models fitted using <code>with.mitml.list</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'mitml.result'
anova(object, ..., method = c("D3", "D4", "D2"),
  ariv = c("default", "positive", "robust"),
  data = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.mitml.result_+3A_object">object</code></td>
<td>
<p>An object of class <code>mitml.result</code> as produced by <code><a href="#topic+with.mitml.list">with.mitml.list</a></code>.</p>
</td></tr>
<tr><td><code id="anova.mitml.result_+3A_...">...</code></td>
<td>
<p>Additional objects of class <code>mitml.result</code> to be compared.</p>
</td></tr>
<tr><td><code id="anova.mitml.result_+3A_method">method</code></td>
<td>
<p>A character string denoting the method used for the model comparison. Can be <code>"D3"</code>, <code>"D4"</code> or <code>"D2"</code> (see 'Details'). Default is <code>"D3"</code>.</p>
</td></tr>
<tr><td><code id="anova.mitml.result_+3A_ariv">ariv</code></td>
<td>
<p>A character string denoting how the ARIV is calculated. Can be <code>"default"</code>, <code>"positive"</code>, or <code>"robust"</code> (see 'Details').</p>
</td></tr>
<tr><td><code id="anova.mitml.result_+3A_data">data</code></td>
<td>
<p>(optional) A list of imputed data sets (see 'Details').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs likelihood-based comparisons between multiple statistical models fitted with <code><a href="#topic+with.mitml.list">with.mitml.list</a></code>.
If possible, the models are compared using the <code class="reqn">D_3</code> statistic (Meng &amp; Rubin, 1992).
If this method is unavailable, the <code class="reqn">D_4</code> or <code class="reqn">D_2</code> statistic is used instead (Chan &amp; Meng, 2019; Li, Meng, Raghunathan, &amp; Rubin, 1991).
</p>
<p>This function is essentially a wrapper for <code><a href="#topic+testModels">testModels</a></code> with the advantage that several models can be compared simultaneously.
For a list of supported models and further options for more specific model comparisons, see <code>testModels</code>.
</p>
<p>The <code>ariv</code> argument affects how the average relative increase in variance is calculated (see also <code>testModels</code>).
Note that the <code class="reqn">D_4</code> method can fail if the data to which the model was fitted cannot be found.
In such a case, the <code>data</code> argument can be used to specify the list of imputed data sets directly (see also <code>testModels</code>).
</p>


<h3>Value</h3>

<p>A list containing the results of each model comparison.
A <code>print</code> method is used for more readable output.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>References</h3>

<p>Meng, X.-L., &amp; Rubin, D. B. (1992). Performing likelihood ratio tests with multiply-imputed data sets. <em>Biometrika, 79</em>, 103-111. 
</p>
<p>Laird, N., Lange, N., &amp; Stram, D. (1987). Maximum likelihood computations with repeated measures: Application of the em algorithm. <em>Journal of the American Statistical Association, 82</em>, 97-105.
</p>
<p>Li, K. H., Raghunathan, T. E., &amp; Rubin, D. B. (1991). Large-sample significance levels from multiply imputed data using moment-based statistics and an F reference distribution. <em>Journal of the American Statistical Association, 86</em>, 1065-1073.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+with.mitml.list">with.mitml.list</a></code>, <code><a href="#topic+testModels">testModels</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(lme4)
data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

implist &lt;- mitmlComplete(imp)

# simple comparison (same as testModels)
fit0 &lt;- with(implist, lmer(ReadAchiev ~ (1|ID), REML = FALSE))
fit1 &lt;- with(implist, lmer(ReadAchiev ~ ReadDis + (1|ID), REML = FALSE))
anova(fit1, fit0)

## Not run: 
# multiple comparisons
fit2 &lt;- with(implist, lmer(ReadAchiev ~ ReadDis + (1 + ReadDis|ID), REML = FALSE))
anova(fit2, fit1, fit0)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.mitml.list'>Convert a list of data sets to <code>mitml.list</code></h2><span id='topic+as.mitml.list'></span>

<h3>Description</h3>

<p>This function adds a <code>mitml.list</code> class attribute to a list of data frames. The resulting object can be used in further analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
as.mitml.list(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mitml.list_+3A_x">x</code></td>
<td>
<p>A list of data frames.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original list with an additional class attribute <code>mitml.list</code>.
The list entries are converted into a <code>data.frame</code> if necessary, in which case a note is printed.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.mitml.list">is.mitml.list</a></code>, <code><a href="#topic+long2mitml.list">long2mitml.list</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># data frame with 'imputation' indicator
dat &lt;- data.frame(imputation = rep(1:10, each = 20), x = rnorm(200))

# split into a list and convert to 'mitml.list'
l &lt;- split(dat, dat$imputation)
l &lt;- as.mitml.list(l)

is.mitml.list(l)
# TRUE
</code></pre>

<hr>
<h2 id='c.mitml.list'>Concatenate lists of imputed data sets</h2><span id='topic+c.mitml.list'></span><span id='topic+rbind.mitml.list'></span><span id='topic+cbind.mitml.list'></span>

<h3>Description</h3>

<p>These functions allow concatenating lists of imputed data sets by data set, row, or column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'mitml.list'
c(...)
## S3 method for class 'mitml.list'
rbind(...)
## S3 method for class 'mitml.list'
cbind(...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.mitml.list_+3A_...">...</code></td>
<td>
<p>One or several lists of imputed data sets with class <code>mitml.list</code> as produced by <code>mitmlComplete</code> (or similar).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>c</code>, <code>cbind</code>, and <code>rbind</code> functions allow combining multiple lists of imputed data sets in different ways.
The <code>c</code> method concatenates by data set (i.e., by appending additional data sets to the list), <code>rbind</code> concatenates by row (i.e., appending additional rows to each data set), and <code>cbind</code> concatenates by column (i.e., by appending additional columns to each data set).
</p>
<p>These functions are intended for experienced users and should be used with caution.
Appending rows or columns from multiple imputation procedures is usually unsafe unless in special applications (see 'Examples').
</p>


<h3>Value</h3>

<p>A list of imputed data sets with an additional class attribute <code>mitml.list</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: manual imputation by grouping variable

data(studentratings)
fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)

imp1 &lt;- panImpute(subset(studentratings, FedState == "SH"), formula = fml,
                 n.burn = 1000, n.iter = 100, m = 5)

imp2 &lt;- panImpute(subset(studentratings, FedState == "B"), formula = fml,
                  n.burn = 1000, n.iter = 100, m = 5)

implist1 &lt;- mitmlComplete(imp1)
implist2 &lt;- mitmlComplete(imp2)

rbind(implist1, implist2)

# Example 2: predicted values from linear model

imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)
implist &lt;- mitmlComplete(imp)

pred &lt;- with(implist1, predict(lm(ReadDis ~ ReadAchiev)))
cbind(implist, pred.ReadDis = pred)
</code></pre>

<hr>
<h2 id='clusterMeans'>Calculate cluster means</h2><span id='topic+clusterMeans'></span>

<h3>Description</h3>

<p>Calculates the mean of a given variable within each cluster, possibly conditioning on an additional grouping variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
clusterMeans(x, cluster, adj = FALSE, group = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterMeans_+3A_x">x</code></td>
<td>
<p>A numeric vector for which cluster means should be calculated. Can also be supplied as a character string denoting a variable in the current environment (see 'Details').</p>
</td></tr>
<tr><td><code id="clusterMeans_+3A_cluster">cluster</code></td>
<td>
<p>A numeric vector or a factor denoting the cluster membership of each unit in <code>x</code>. Can also be supplied as a character string (see 'Details').</p>
</td></tr>
<tr><td><code id="clusterMeans_+3A_adj">adj</code></td>
<td>
<p>Logical flag indicating if person-adjusted group means should be calculated. If <code>TRUE</code>, cluster means are calculated for each unit by excluding that unit from calculating the cluster mean. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="clusterMeans_+3A_group">group</code></td>
<td>
<p>(optional) A grouping factor or a variable that can be interpreted as such. If specified, cluster means are calculated separately within the sub-groups defined by <code>group</code>. Can also be supplied as a character string (see 'Details').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the mean of a variable within each level of a cluster variable.
Any <code>NA</code> are omitted during calculation.
</p>
<p>The three main arguments of the function can also be supplied as (single) character strings, denoting the name of the respective variables in the current environment.
This is especially useful for calculating several cluster means simultaneously, for example using <code><a href="#topic+within.mitml.list">within.mitml.list</a></code> (see 'Example 2' below).
</p>


<h3>Value</h3>

<p>A numeric vector with the same length as <code>x</code> containing the cluster mean for all units.
</p>


<h3>Author(s)</h3>

<p>Simon Grund, Alexander Robitzsch</p>


<h3>See Also</h3>

<p><code><a href="#topic+within.mitml.list">within.mitml.list</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

implist &lt;- mitmlComplete(imp)

# * Example 1: single cluster means

# calculate cluster means (for each data set)
with(implist, clusterMeans(ReadAchiev, ID))

# ... person-adjusted cluster means
with(implist, clusterMeans(ReadAchiev, ID, adj = TRUE))

# ... groupwise cluster means
with(implist, clusterMeans(ReadAchiev, ID, group = Sex))

# * Example 2: automated cluster means using 'for' and 'assign'

# calculate multiple cluster means within multiply imputed data sets
within(implist,{
  vars &lt;- c("ReadAchiev", "MathAchiev", "CognAbility")
  for(i in vars) assign(paste(i, "Mean", sep = "."), clusterMeans(i, ID))
  rm(i, vars)
})
</code></pre>

<hr>
<h2 id='confint.mitml.testEstimates'>Summarize and extract pooled parameter estimates</h2><span id='topic+coef.mitml.testEstimates'></span><span id='topic+vcov.mitml.testEstimates'></span><span id='topic+confint.mitml.testEstimates'></span>

<h3>Description</h3>

<p>Functions for extracting results and computing confidence intervals from the pooled parameter estimates computed with <code><a href="#topic+testEstimates">testEstimates</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'mitml.testEstimates'
coef(object, ...)
## S3 method for class 'mitml.testEstimates'
vcov(object, ...)
## S3 method for class 'mitml.testEstimates'
confint(object, parm, level = 0.95, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.mitml.testEstimates_+3A_object">object</code></td>
<td>
<p>An object of class <code>mitml.testEstimates</code> as produced by <code>testEstimates</code>.</p>
</td></tr>
<tr><td><code id="confint.mitml.testEstimates_+3A_parm">parm</code></td>
<td>
<p>(optional) A reference to the parameters for which to calculate confidence intervals. Can be a character or integer vector denoting names or position of parameters, respectively.
If missing, all parameters are considered (the default).</p>
</td></tr>
<tr><td><code id="confint.mitml.testEstimates_+3A_level">level</code></td>
<td>
<p>The confidence level. Default is to <code>0.95</code> (i.e., 95%).</p>
</td></tr>
<tr><td><code id="confint.mitml.testEstimates_+3A_...">...</code></td>
<td>
<p>Not being used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used to extract information and compute additional results from pooled parameter estimates.
The <code>coef</code> and <code>vcov</code> methods extract the pooled parameter estimates and their pooled variance-covariance matrix (with the squared standard errors in the diagonal).
The <code>confint</code> method computes confidence intervals with the given confidence level for the pooled parameters on the basis of a <code class="reqn">t</code>-distribution, with estimates, standard errors, and degrees of freedom as returned by <code><a href="#topic+testEstimates">testEstimates</a></code>.
</p>


<h3>Value</h3>

<p>For <code>coef</code>: A vector containing the pooled parameter estimates
For <code>vcov</code>: A matrix containing the pooled variance-covariance matrix of the parameter estimates.
For <code>confint</code>: A matrix containing the lower and upper bounds of the confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>See Also</h3>

<p><code><a href="#topic+testEstimates">testEstimates</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

fml &lt;- ReadDis ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 500, n.iter = 100, m = 5)

implist &lt;- mitmlComplete(imp)

# fit regression model
fit &lt;- with(implist, lm(ReadDis ~ 1 + ReadAchiev))
est &lt;- testEstimates(fit)

# extract parameter estimates and variance-covariance matrix
coef(est)
vcov(est)

# compute confidence intervals
confint(est)

# ... with different confidence levels
confint(est, level = 0.90)
confint(est, level = 0.999)
</code></pre>

<hr>
<h2 id='is.mitml.list'>Check if an object is of class <code>mitml.list</code></h2><span id='topic+is.mitml.list'></span>

<h3>Description</h3>

<p>This function checks if its argument is a list of class <code>mitml.list</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
is.mitml.list(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mitml.list_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>.
A warning message is displayed if the contents of <code>x</code> do not appear to be data frames.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.mitml.list">as.mitml.list</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- list(data.frame(x = rnorm(20)))
l &lt;- as.mitml.list(l)
is.mitml.list(l)
# TRUE

l &lt;- as.list(1:10)
is.mitml.list(l)
# FALSE

class(l) &lt;- "mitml.list"
is.mitml.list(l)
# TRUE, with a warning
</code></pre>

<hr>
<h2 id='jomoImpute'>Impute single-level and multilevel missing data using <code>jomo</code></h2><span id='topic+jomoImpute'></span>

<h3>Description</h3>

<p>Performs single- and multilevel imputation for (mixed) continuous and categorical data using the <code>jomo</code> package
Supports imputation of missing data at level 1 and 2 as well as imputation using random (residual) covariance matrices.
See 'Details' for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
jomoImpute(data, type, formula, random.L1 = c("none", "mean", "full"),
  n.burn = 5000, n.iter = 100, m = 10, group = NULL, prior = NULL,
  seed = NULL, save.pred = FALSE, keep.chains = c("full", "diagonal"),
  silent = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jomoImpute_+3A_data">data</code></td>
<td>
<p>A data frame containing the incomplete data, the auxiliary variables, the cluster indicator variable, and any other variables that should be included in the imputed datasets.</p>
</td></tr>
<tr><td><code id="jomoImpute_+3A_type">type</code></td>
<td>
<p>An integer vector specifying the role of each variable in the imputation model or a list of two vectors specifying a two-level model (see 'Details').</p>
</td></tr>
<tr><td><code id="jomoImpute_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the role of each variable in the imputation model or a list of two formulas specifying a two-level model. The basic model is constructed by <code>model.matrix</code>, which allows including derived variables in the imputation model using <code>I()</code> (see 'Details' and 'Examples').</p>
</td></tr>
<tr><td><code id="jomoImpute_+3A_random.l1">random.L1</code></td>
<td>
<p>A character string denoting if the covariance matrix of residuals should vary across groups and how the values of these matrices are stored (see 'Details'). Can be <code>"none"</code> (common covariance matrix), <code>"mean"</code> (random covariance matrix, storing only mean values), or <code>"full"</code> (random covariance matrix, storing all values). Default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="jomoImpute_+3A_n.burn">n.burn</code></td>
<td>
<p>The number of burn-in iterations before any imputations are drawn. Default is 5,000.</p>
</td></tr>
<tr><td><code id="jomoImpute_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of iterations between imputations. Default is 100.</p>
</td></tr>
<tr><td><code id="jomoImpute_+3A_m">m</code></td>
<td>
<p>The number of imputed data sets to generate. Default is 10.</p>
</td></tr>
<tr><td><code id="jomoImpute_+3A_group">group</code></td>
<td>
<p>(optional) A character string denoting the name of an additional grouping variable to be used with the <code>formula</code> argument. If specified, the imputation is run separately within each of these groups.</p>
</td></tr>
<tr><td><code id="jomoImpute_+3A_prior">prior</code></td>
<td>
<p>(optional) A list with components <code>Binv</code>, <code>Dinv</code>, and <code>a</code> for specifying prior distributions for the covariance matrix of random effects and the covariance matrix of residuals (see 'Details'). Default is to use least-informative priors.</p>
</td></tr>
<tr><td><code id="jomoImpute_+3A_seed">seed</code></td>
<td>
<p>(optional) An integer value initializing R's random number generator for reproducible results. Default is to use the global seed.</p>
</td></tr>
<tr><td><code id="jomoImpute_+3A_save.pred">save.pred</code></td>
<td>
<p>(optional) Logical flag indicating if variables derived using <code>formula</code> should be included in the imputed data sets. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="jomoImpute_+3A_keep.chains">keep.chains</code></td>
<td>
<p>(optional) A character string denoting which chains of the MCMC algorithm to store. Can be <code>"full"</code> (stores chains for all parameters) or <code>"diagonal"</code> (stores chains for fixed effects and diagonal entries of the covariance matrices). Default is <code>"full"</code> (see 'Details').</p>
</td></tr>
<tr><td><code id="jomoImpute_+3A_silent">silent</code></td>
<td>
<p>(optional) Logical flag indicating if console output should be suppressed. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serves as an interface to the <code>jomo</code> package and supports imputation of single-level and multilevel continuous and categorical data at both level 1 and 2 (see Carpenter &amp; Kenward, 2013; Goldstein et al., 2009).
In order for categorical variables to be detected correctly, these must be formatted as a <code>factor</code> variables (see 'Examples').
The imputation model can be specified using either the <code>type</code> or the <code>formula</code> argument.
</p>
<p>The <code>type</code> interface is designed to provide quick-and-easy imputations using <code>jomo</code>. The <code>type</code> argument must be an integer vector denoting the role of each variable in the imputation model:
</p>

<ul>
<li><p><code>1</code>: target variables containing missing data
</p>
</li>
<li><p><code>2</code>: predictors with fixed effect on all targets (completely observed)
</p>
</li>
<li><p><code>3</code>: predictors with random effect on all targets (completely observed)
</p>
</li>
<li><p><code>-1</code>: grouping variable within which the imputation is run separately
</p>
</li>
<li><p><code>-2</code>: cluster indicator variable
</p>
</li>
<li><p><code>0</code>: variables not featured in the model
</p>
</li></ul>

<p>At least one target variable and, for multilevel imputation, the cluster indicator must be specified.
If the cluster indicator is omitted, single-level imputation will be performed.
The intercept is automatically included as both a fixed and (for multilevel models) a random effect.
If a variable of type <code>-1</code> is found, then separate imputations are performed within each level of that variable.
</p>
<p>The <code>formula</code> argument is intended as a more flexible and feature-rich interface to <code>jomo</code>.
Specifying the <code>formula</code> argument is similar to specifying other formulae in R.
Given below is a list of operators that <code>jomoImpute</code> currently understands:
</p>

<ul>
<li><p><code>~</code>: separates the target (left-hand) and predictor (right-hand) side of the model
</p>
</li>
<li><p><code>+</code>: adds target or predictor variables to the model
</p>
</li>
<li><p><code>*</code>: adds an interaction term of two or more predictors
</p>
</li>
<li><p><code>|</code>: denotes cluster-specific random effects and specifies the cluster indicator (e.g., <code>1|ID</code>)
</p>
</li>
<li><p><code>I()</code>: defines functions to be interpreted by <code>model.matrix</code>
</p>
</li></ul>

<p>If the cluster indicator is omitted, single-level imputation will be performed.
For multilevel imputation, predictors are allowed to have fixed effects, random effects, or both on all target variables.
The intercept is automatically included as both a fixed and (for multilevel models) a random effect.
Both can be suppressed if needed (see <code><a href="#topic+panImpute">panImpute</a></code>).
Note that, when specifying random effects other than the intercept, these will <em>not</em> be automatically added as fixed effects and must be included explicitly.
Any predictors defined by <code>I()</code> will be used for imputation but not included in the data set unless <code>save.pred = TRUE</code>.
</p>
<p>If missing data occur at both level 1 and 2, the imputation model is specified as a list of two <code>formula</code>s or <code>type</code>s, respectively.
The first element of this list denotes the model specification for variables at level 1.
The second element denotes the model specification for variables at level 2.
Missing data are imputed jointly at both levels (see 'Examples', see also Carpenter and Kenward, 2013; Goldstein et al., 2009).
</p>
<p>It is possible to model the covariance matrix of residuals at level 1 as random across clusters (Yucel, 2011; Carpenter &amp; Kenward, 2013).
The <code>random.L1</code> argument determines this behavior and how the values of these matrices are stored.
If set to <code>"none"</code>, a common covariance matrix is assumed across groups (similar to <code>panImpute</code>).
If set to <code>"mean"</code>, the covariance matrices are random, but only the average covariance matrix is stored at each iteration.
If set to <code>"full"</code>, the covariance matrices are random, and all variances and covariances from all clusters are stored.
</p>
<p>In order to run separate imputations for each level of an additional grouping variable, the <code>group</code> argument can be used.
The name of the grouping variable must be given as a character string (i.e., in quotation marks).
</p>
<p>The default prior distribution for the covariance matrices in <code>jomoImpute</code> are &quot;least informative&quot; inverse-Wishart priors with minimum positive degrees of freedom (largest dispersion) and the identity matrix for scale.
The <code>prior</code> argument can be used to specify alternative prior distributions.
These must be supplied as a list containing the following components:
</p>

<ul>
<li><p><code>Binv</code>: scale matrix for the covariance matrix of residuals at level 1
</p>
</li>
<li><p><code>Dinv</code>: scale matrix for the covariance matrix of random effects and residuals at level 2
</p>
</li>
<li><p><code>a</code>: starting value for the degrees of freedom of random covariance matrices of residuals (only used with <code>random.L1 = "mean"</code> or <code>random.L1 = "full"</code>)
</p>
</li></ul>

<p>Note that <code>jomo</code> does not allow for the degrees of freedom for the inverse-Wishart prior to be specified by the user.
These are always set to the lowest value possible (largest dispersion) or determined iteratively if the residuals at level 1 are modeled as random (see above).
For single-level imputation, only <code>Binv</code> is relevant.
</p>
<p>In imputation models with many parameters, the number of chains in the MCMC algorithm being stored can be reduced with the <code>keep.chains</code> argument (see also <code><a href="#topic+panImpute">panImpute</a></code>).
This setting influences the storage mode of parameters (e.g., dimensions and indices of arrays) and should be used with caution.
</p>


<h3>Value</h3>

<p>An object of class <code>mitml</code>, containing the following components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>The original (incomplete) data set, sorted according to the cluster variable and (if given) the grouping variable, with several attributes describing the original order (<code>"sort"</code>), grouping (<code>"group"</code>) and factor levels of categorical variables.</p>
</td></tr>
<tr><td><code>replacement.mat</code></td>
<td>
<p>A matrix containing the multiple replacements (i.e., imputations) for each missing value. The replacement matrix contains one row for each missing value and one one column for each imputed data set.</p>
</td></tr>
<tr><td><code>index.mat</code></td>
<td>
<p>A matrix containing the row and column index for each missing value. The index matrix is used to <em>link</em> the missing values in the data set with their corresponding rows in the replacement matrix.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched function call.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list containing the names of the cluster variable, the target variables, and the predictor variables with fixed and random effects, at level 1 and level 2, respectively.</p>
</td></tr>
<tr><td><code>random.L1</code></td>
<td>
<p>A character string denoting the handling of the (random) covariance matrix of residuals at level 1 (see 'Details').</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>The prior parameters used in the imputation model.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>A list containing the number of burn-in iterations, the number of iterations between imputations, and the number of imputed data sets.</p>
</td></tr>
<tr><td><code>par.burnin</code></td>
<td>
<p>A multi-dimensional array containing the parameters of the imputation model from the burn-in phase.</p>
</td></tr>
<tr><td><code>par.imputation</code></td>
<td>
<p>A multi-dimensional array containing the parameters of the imputation model from the imputation phase.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For objects of class <code>mitml</code>, methods for the generic functions <code>print</code>, <code>summary</code>, and <code>plot</code> are available to inspect the fitted imputation model.
<code>mitmlComplete</code> is used for extracting the imputed data sets.
</p>


<h3>Author(s)</h3>

<p>Simon Grund, Alexander Robitzsch, Oliver Luedtke</p>


<h3>References</h3>

<p>Carpenter, J. R., &amp; Kenward, M. G. (2013). <em>Multiple imputation and its application</em>. Hoboken, NJ: Wiley.
</p>
<p>Goldstein, H., Carpenter, J., Kenward, M. G., &amp; Levin, K. A. (2009). Multilevel models with multivariate mixed response types. <em>Statistical Modelling</em>, 9, 173-197.
</p>
<p>Yucel, R. M. (2011). Random covariances and mixed-effects models for imputing multivariate multilevel continuous data. <em>Statistical Modelling</em>, 11, 351-370.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panImpute">panImpute</a></code>, <code><a href="#topic+mitmlComplete">mitmlComplete</a></code>, <code><a href="#topic+summary.mitml">summary.mitml</a></code>, <code><a href="#topic+plot.mitml">plot.mitml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># NOTE: The number of iterations in these examples is much lower than it
# should be. This is done in order to comply with CRAN policies, and more
# iterations are recommended for applications in practice!

data(studentratings)
data(leadership)

# ***
# for further examples, see "panImpute"
#

?panImpute

# *** ................................
# the 'type' interface
# 

# * Example 1.1 (studentratings): 'ReadDis' and 'SES', predicted by 'ReadAchiev'
# (random slope)

type &lt;- c(-2, 0, 0, 0, 0, 1, 3, 1, 0, 0)
names(type) &lt;- colnames(studentratings)
type

imp &lt;- jomoImpute(studentratings, type = type, n.burn = 100, n.iter = 10, m = 5)

# * Example 1.2 (leadership): all variables (mixed continuous and categorical
# data with missing values at level 1 and level 2)

type.L1 &lt;- c(-2, 1, 0, 1, 1)   # imputation model at level 1
type.L2 &lt;- c(-2, 0, 1, 0, 0)   # imputation model at level 2
names(type.L1) &lt;- names(type.L2) &lt;- colnames(leadership)

type &lt;- list(type.L1, type.L2)
type

imp &lt;- jomoImpute(leadership, type = type, n.burn = 100, n.iter = 10, m = 5)

# * Example 1.3 (studentratings): 'ReadDis', 'ReadAchiev', and 'SES' predicted
# with empty model, groupwise for 'FedState' (single-level imputation)

type &lt;- c(0, -1, 0, 0, 0, 1, 1, 1, 0, 0)
names(type) &lt;- colnames(studentratings)
type

imp &lt;- jomoImpute(studentratings, type = type, group = "FedState", n.burn = 100,
                  n.iter = 10, m = 5)

# *** ................................
# the 'formula' interface
# 

# * Example 2.1 (studentratings): 'ReadDis' and 'SES' predicted by 'ReadAchiev'
# (random slope)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- jomoImpute(studentratings, formula = fml, n.burn = 100, n.iter = 10, m = 5)

# * Example 2.2 (studentratings): 'ReadDis' predicted by 'ReadAchiev' and the
# the cluster mean of 'ReadAchiev'

fml &lt;- ReadDis ~ ReadAchiev + I(clusterMeans(ReadAchiev, ID)) + (1|ID)
imp &lt;- jomoImpute(studentratings, formula = fml, n.burn = 100, n.iter = 10, m = 5)

# * Example 2.3 (studentratings): 'ReadDis' predicted by 'ReadAchiev', groupwise
# for 'FedState'

fml &lt;- ReadDis ~ ReadAchiev + (1|ID)
imp &lt;- jomoImpute(studentratings, formula = fml, group = "FedState", n.burn = 100,
                  n.iter = 10, m = 5)

# * Example 2.4 (leadership): all variables (mixed continuous and categorical
# data with missing values at level 1 and level 2)

fml &lt;- list( JOBSAT + NEGLEAD + WLOAD ~ 1 + (1|GRPID) , COHES ~ 1 )
imp &lt;- jomoImpute(leadership, formula = fml, n.burn = 100, n.iter = 10, m = 5)

# * Example 2.5 (studentratings): 'ReadDis', 'ReadAchiev', and 'SES' predicted
# with empty model, groupwise for 'FedState' (single-level imputation)

fml &lt;- ReadDis + ReadAchiev + SES ~ 1
imp &lt;- jomoImpute(studentratings, formula = fml, group = "FedState", n.burn = 100,
                  n.iter = 10, m = 5)
</code></pre>

<hr>
<h2 id='justice'>Example data set on employees' justice perceptions and satisfaction</h2><span id='topic+justice'></span>

<h3>Description</h3>

<p>Data set containing simulated data for employees nested within organizations, featuring employees' sex, ratings on individual justice orientation and ratings on job satisfaction.
The data set also includes scores for justice climate in each organization (defined at the level of organizations, level 2).
Different organizations are denoted by the variable <code>id</code>.
</p>
<p>The data were simulated based on the results by Liao and Rupp (2005), as well as the secondary analyses of the same data given in Mathieu, Aguinis, Culpepper, and Chen, (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(justice)</code></pre>


<h3>Format</h3>

<p>A data frame containing 1400 observations on 4 variables.</p>


<h3>References</h3>

<p>Liao, H., &amp; Rupp, D. E. (2005). The impact of justice climate and justice orientation on work outcomes: A cross-level multifoci framework. <em>Journal of Applied Psychology</em>, 90, 242.256.
</p>
<p>Mathieu, J. E., Aguinis, H., Culpepper, S. A., &amp; Chen, G. (2012). Understanding and estimating the power to detect cross-level interaction effects in multilevel modeling. <em>Journal of Applied Psychology</em>, 97, 951-966.
</p>

<hr>
<h2 id='leadership'>Example data set on leadership style and job satisfaction</h2><span id='topic+leadership'></span>

<h3>Description</h3>

<p>Data set based on the data simulated by Paul D. Bliese as described in Klein et al. (2000) with slight modifications.
The data set consists of 750 employees, nested within 50 work groups, and includes employees' ratings on negative leadership style, job satisfaction, and workload as well as a measure for each work group's cohesion.
</p>
<p>The original data set is available in the <code>multilevel</code> package and was modified by (a) transforming workload into a categorical variable, (b) transforming cohesion into a group-level variable, and (c) by inducing missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(leadership)</code></pre>


<h3>Format</h3>

<p>A data frame containing 750 observations on 5 variables.</p>


<h3>References</h3>

<p>Bliese, P. D. (2013). multilevel: Multilevel functions (Version 2.5) [Computer software]. Retrieved from <code>http://CRAN.R-project.org/package=multilevel</code>
</p>
<p>Klein, K. J., Bliese, P. D., Kozlowski, S. W. J., Dansereau, F., Gavin, M. B., Griffin, M. A., ... Bligh, M. C. (2000). Multilevel analytical techniques: Commonalities, differences, and continuing questions. In K. J. Klein &amp; S. W. J. Kozlowski (Eds.), <em>Multilevel theory, research, and methods in organizations: Foundations, extensions, and new directions</em> (pp. 512-553). San Francisco, CA: Jossey-Bass.
</p>

<hr>
<h2 id='long2mitml.list'>Convert imputations from long format to <code>mitml.list</code></h2><span id='topic+long2mitml.list'></span><span id='topic+jomo2mitml.list'></span>

<h3>Description</h3>

<p>These functions convert data sets containing multiple imputations in long format to objects of class <code>mitml.list</code>. The resulting object can be used in further analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
long2mitml.list(x, split, exclude = NULL)

jomo2mitml.list(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="long2mitml.list_+3A_x">x</code></td>
<td>
<p>A data frame in long format containing multiple imputations (see 'Details').</p>
</td></tr>
<tr><td><code id="long2mitml.list_+3A_split">split</code></td>
<td>
<p>A character string denoting the column in <code>x</code> that identifies different imputations (see 'Details').</p>
</td></tr>
<tr><td><code id="long2mitml.list_+3A_exclude">exclude</code></td>
<td>
<p>A vector denoting the values of <code>split</code> that should be excluded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>long2mitml.list</code> converts data frames from the long format to <code>mitml.list</code> (i.e., a list of imputed data sets).
In long format, all imputations are contained in a single data frame, where different imputations are denoted by <code>split</code>.
This function splits the data frame into a list of imputed data sets according to <code>split</code>, excluding the values specified by <code>exclude</code> (see the 'Examples').
</p>
<p>The <code>jomo2mitml.list</code> function is a special case of <code>long2mitml.list</code> which converts imputations that have been generated with <code>jomo</code> (see the <code>jomo</code> package)).
</p>


<h3>Value</h3>

<p>A list of imputed data sets with class <code>mitml.list</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>See Also</h3>

<p><code><a href="#topic+mitmlComplete">mitmlComplete</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)
require(jomo)

# impute data using jomo (native functions)
clus &lt;- studentratings[, "ID"]
Y &lt;- studentratings[, c("ReadAchiev", "ReadDis")]
imp &lt;- jomo(Y = Y, clus = clus, nburn = 1000, nbetween = 100, nimp = 5)

# split imputations
impList &lt;- long2mitml.list(imp, split = "Imputation", exclude = 0)
impList &lt;- jomo2mitml.list(imp)
</code></pre>

<hr>
<h2 id='mids2mitml.list'>Convert objects of class <code>mids</code> to <code>mitml.list</code></h2><span id='topic+mids2mitml.list'></span>

<h3>Description</h3>

<p>This function converts a <code>mids</code> class object (as produced by the <code>mice</code> package) to <code>mitml.list</code>. The resulting object may be used in further analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
mids2mitml.list(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mids2mitml.list_+3A_x">x</code></td>
<td>
<p>An object of class <code>mids</code> as produced by <code>mice</code> (see the <code>mice</code> package).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of imputed data sets with class <code>mitml.list</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>See Also</h3>

<p><code><a href="#topic+mitmlComplete">mitmlComplete</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

# imputation using mice
require(mice)
imp &lt;- mice(studentratings)

implist &lt;- mids2mitml.list(imp)
</code></pre>

<hr>
<h2 id='mitml.list2mids'>Convert objects of class <code>mitml.list</code> to <code>mids</code></h2><span id='topic+mitml.list2mids'></span>

<h3>Description</h3>

<p>This function converts a <code>mitml.list</code> class object to <code>mids</code> (as used in the <code>mice</code> package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mitml.list2mids(x, data, fill = FALSE, where = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mitml.list2mids_+3A_x">x</code></td>
<td>
<p>A list of imputed data sets with class <code>mitml.list</code> (as produced by <code><a href="#topic+mitmlComplete">mitmlComplete</a></code>, <code><a href="#topic+mids2mitml.list">mids2mitml.list</a></code>, or similar).</p>
</td></tr>
<tr><td><code id="mitml.list2mids_+3A_data">data</code></td>
<td>
<p>A data frame containing to original (incomplete) data (see 'Details').</p>
</td></tr>
<tr><td><code id="mitml.list2mids_+3A_fill">fill</code></td>
<td>
<p>A logical flag indicating whether variables in the imputed data that are not in the original data should be added and filled with <code>NA</code> (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="mitml.list2mids_+3A_where">where</code></td>
<td>
<p>(optional) A data frame or matrix of logicals indicating the location of missing values (see 'Details').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts objects of class <code>mitml.list</code> into <code>mids</code> objects (as used in the <code>mice</code> package).
The conversion requires a list of imputed data sets and the original (incomplete) data set.
If the imputed data sets have been appended with new variables (e.g., by <code><a href="#topic+within.mitml.list">within.mitml.list</a></code>), the new variables can be added to the original data set by setting <code>fill = TRUE</code>.
</p>
<p>This function is essentially a wrapper around <code><a href="mice.html#topic+as.mids">as.mids</a></code> that sets the case and imputation identifiers automatically and and passes the <code>where</code> argument as is (see also the documentation of <code><a href="mice.html#topic+as.mids">as.mids</a></code>).
</p>


<h3>Value</h3>

<p>An object of class <code>mids</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>See Also</h3>

<p><code><a href="#topic+mitmlComplete">mitmlComplete</a></code>, <code><a href="#topic+mids2mitml.list">mids2mitml.list</a></code>, <code><a href="#topic+within.mitml.list">within.mitml.list</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

implist &lt;- mitmlComplete(imp)

# * Example 1: simple conversion

# convert to 'mids'
impmids &lt;- mitml.list2mids(implist, data = studentratings)

# * Example 2: conversion with additional variables

# compute new variables
implist &lt;- within(implist, {
  M.ReadAchiev &lt;- clusterMeans(ReadAchiev, ID)
  C.ReadAchiev &lt;- ReadAchiev - M.ReadAchiev
})

# convert to 'mids'
impmids &lt;- mitml.list2mids(implist, data = studentratings, fill = TRUE)
</code></pre>

<hr>
<h2 id='mitmlComplete'>Extract imputed data sets</h2><span id='topic+mitmlComplete'></span>

<h3>Description</h3>

<p>This function extracts imputed data sets from <code>mitml</code> class objects as produced by <code>panImpute</code> and <code>jomoImpute</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
mitmlComplete(x, print = "all", force.list = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mitmlComplete_+3A_x">x</code></td>
<td>
<p>An object of class <code>mitml</code> as produced by <code>panImpute</code> or <code>jomoImpute</code>.</p>
</td></tr>
<tr><td><code id="mitmlComplete_+3A_print">print</code></td>
<td>
<p>Either an integer vector, <code>"list"</code>, or <code>"all"</code> denoting which data sets to extract. If set to <code>"list"</code> or <code>"all"</code>, all imputed data sets will be returned as a list. Negative values and zero return the original (incomplete) data set. Default is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="mitmlComplete_+3A_force.list">force.list</code></td>
<td>
<p>(optional) Logical flag indicating if single data sets should be enclosed in a list. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Usually a list of imputed data with class <code>mitml.list</code>
If only one data set is extracted: a data frame unless <code>force.list = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>See Also</h3>

<p><code><a href="#topic+panImpute">panImpute</a></code>, <code><a href="#topic+jomoImpute">jomoImpute</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

# extract original (incomplete) data set
mitmlComplete(imp, print = 0)

# extract first imputed data set (returned as mitml.list)
mitmlComplete(imp, print = 1, force.list = TRUE)

# extract all imputed data sets at once
implist &lt;- mitmlComplete(imp, print = "all")

## Not run: 
# ... alternatives with same results
implist &lt;- mitmlComplete(imp, print = 1:5)
implist &lt;- mitmlComplete(imp, print = "list")

## End(Not run)
</code></pre>

<hr>
<h2 id='multilevelR2'>Calculate R-squared measures for multilevel models</h2><span id='topic+multilevelR2'></span>

<h3>Description</h3>

<p>Calculates several measures for the proportion of explained variance in a fitted linear mixed-effects or multilevel model (or a list of fitted models).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
multilevelR2(model, print = c("RB1", "RB2", "SB", "MVP"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multilevelR2_+3A_model">model</code></td>
<td>
<p>Either a fitted linear mixed-effects model as produced by <code>lme4</code> or <code>nlme</code>, or a list of fitted models as produced by <code>with.mitml.list</code>.</p>
</td></tr>
<tr><td><code id="multilevelR2_+3A_print">print</code></td>
<td>
<p>A character vector denoting which measures should be calculated (see details). Default is to printing all measures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates several measures of explained variance (<code class="reqn">R^2</code>) for linear-mixed effects models.
It can be used with a single model, as produced by the packages <code>lme4</code> or <code>nlme</code>, or a list of fitted models produced by <code>with.mitml.list</code>.
In the latter case, the <code class="reqn">R^2</code> measures are calculated separately for each imputed data set and then averaged across data sets.
</p>
<p>Different <code class="reqn">R^2</code> measures can be requested using the <code>print</code> argument.
Specifying <code>RB1</code> and <code>RB2</code> returns the explained variance at level 1 and level 2, respectively, according to Raudenbush and Bryk (2002, pp. 74 and 79).
Specifying <code>SB</code> returns the total variance explained according to Snijders and Bosker (2012, p. 112).
Specifying <code>MVP</code> returns the total variance explained based on &ldquo;multilevel variance partitioning&rdquo; as proposed by LaHuis, Hartman, Hakoyama, and Clark (2014).
</p>


<h3>Value</h3>

<p>A numeric vector containing the <code class="reqn">R^2</code> measures requested in <code>print</code>.
</p>


<h3>Note</h3>

<p>Calculating <code class="reqn">R^2</code> measures is currently only supported for two-level models with a single cluster variable.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>References</h3>

<p>LaHuis, D. M., Hartman, M. J., Hakoyama, S., &amp; Clark, P. C. (2014). Explained variance measures for multilevel models. <em>Organizational Research Methods</em>, 17, 433-451.
</p>
<p>Raudenbush, S. W., &amp; Bryk, A. S. (2002). Hierarchical linear models: Applications and data analysis methods (2nd ed.). Thousand Oaks, CA: Sage.
</p>
<p>Snijders, T. A. B., &amp; Bosker, R. J. (2012). Multilevel analysis: An introduction to basic and advanced multilevel modeling. Thousand Oaks, CA: Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(lme4)
data(studentratings)

fml &lt;- MathAchiev + ReadAchiev + CognAbility ~ 1 + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

implist &lt;- mitmlComplete(imp)

fit &lt;- with(implist, lmer(MathAchiev ~ 1 + CognAbility + (1|ID)))
multilevelR2(fit)
</code></pre>

<hr>
<h2 id='panImpute'>Impute multilevel missing data using <code>pan</code></h2><span id='topic+panImpute'></span>

<h3>Description</h3>

<p>Performs multiple imputation of multilevel data using the <code>pan</code> package (Schafer &amp; Yucel, 2002).
Supports imputation of continuous multilevel data with missing values at level 1.
See 'Details' for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
panImpute(data, type, formula, n.burn = 5000, n.iter = 100, m = 10, group = NULL, 
  prior = NULL, seed = NULL, save.pred = FALSE, keep.chains = c("full", "diagonal"),
  silent = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panImpute_+3A_data">data</code></td>
<td>
<p>A data frame containing the incomplete data, the auxiliary variables, the cluster indicator variable, and any other variables that should be included in the imputed datasets.</p>
</td></tr>
<tr><td><code id="panImpute_+3A_type">type</code></td>
<td>
<p>An integer vector specifying the role of each variable in the imputation model (see 'Details').</p>
</td></tr>
<tr><td><code id="panImpute_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the role of each variable in the imputation model. The basic model is constructed by <code>model.matrix</code>, thus allowing to include derived variables in the imputation model using <code>I()</code> (see 'Details' and 'Examples').</p>
</td></tr>
<tr><td><code id="panImpute_+3A_n.burn">n.burn</code></td>
<td>
<p>The number of burn-in iterations before any imputations are drawn. Default is 5,000.</p>
</td></tr>
<tr><td><code id="panImpute_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of iterations between imputations. Default is 100.</p>
</td></tr>
<tr><td><code id="panImpute_+3A_m">m</code></td>
<td>
<p>The number of imputed data sets to generate.</p>
</td></tr>
<tr><td><code id="panImpute_+3A_group">group</code></td>
<td>
<p>(optional) A character string denoting the name of an additional grouping variable to be used with the <code>formula</code> argument. If specified, the imputation model is run separately within each of these groups.</p>
</td></tr>
<tr><td><code id="panImpute_+3A_prior">prior</code></td>
<td>
<p>(optional) A list with components <code>a</code>, <code>Binv</code>, <code>c</code>, and <code>Dinv</code> for specifying prior distributions for the covariance matrix of random effects and the covariance matrix of residuals (see 'Details'). Default is to use least-informative priors.</p>
</td></tr>
<tr><td><code id="panImpute_+3A_seed">seed</code></td>
<td>
<p>(optional) An integer value initializing <code>pan</code>'s random number generator for reproducible results. Default is to using a random seed.</p>
</td></tr>
<tr><td><code id="panImpute_+3A_save.pred">save.pred</code></td>
<td>
<p>(optional) Logical flag indicating if variables derived using <code>formula</code> should be included in the imputed data sets. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="panImpute_+3A_keep.chains">keep.chains</code></td>
<td>
<p>(optional) A character string denoting which chains of the MCMC algorithm to store. Can be <code>"full"</code> (stores chains for all parameters) or <code>"diagonal"</code> (stores chains for fixed effects and diagonal entries of the covariance matrices). Default is <code>"full"</code> (see 'Details').</p>
</td></tr>
<tr><td><code id="panImpute_+3A_silent">silent</code></td>
<td>
<p>(optional) Logical flag indicating if console output should be suppressed. Default is to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serves as an interface to the <code>pan</code> package and supports imputation of continuous multilevel data at level 1 (Schafer &amp; Yucel, 2002).
The imputation model can be specified using either the <code>type</code> or the <code>formula</code> argument.
</p>
<p>The <code>type</code> interface is designed to provide quick-and-easy imputations using <code>pan</code>.
The <code>type</code> argument must be an integer vector denoting the role of each variable in the imputation model:
</p>

<ul>
<li><p><code>1</code>: target variables containing missing data
</p>
</li>
<li><p><code>2</code>: predictors with fixed effect on all targets (completely observed)
</p>
</li>
<li><p><code>3</code>: predictors with random effect on all targets (completely observed)
</p>
</li>
<li><p><code>-1</code>: grouping variable within which the imputation is run separately
</p>
</li>
<li><p><code>-2</code>: cluster indicator variable
</p>
</li>
<li><p><code>0</code>: variables not featured in the model
</p>
</li></ul>

<p>At least one target variable and the cluster indicator must be specified.
The intercept is automatically included as both a fixed and a random effect.
If a variable of type <code>-1</code> is found, then separate imputations are performed within each level of that variable.
</p>
<p>The <code>formula</code> argument is intended as a more flexible and feature-rich interface to <code>pan</code>.
Specifying the <code>formula</code> argument is similar to specifying other formulae in R.
Given below is a list of operators that <code>panImpute</code> understands:
</p>

<ul>
<li><p><code>~</code>: separates the target (left-hand) and predictor (right-hand) side of the model
</p>
</li>
<li><p><code>+</code>: adds target or predictor variables to the model
</p>
</li>
<li><p><code>*</code>: adds an interaction term of two or more predictors
</p>
</li>
<li><p><code>|</code>: denotes cluster-specific random effects and specifies the cluster indicator (e.g., <code>1|ID</code>)
</p>
</li>
<li><p><code>I()</code>: defines functions to be interpreted by <code>model.matrix</code>
</p>
</li></ul>

<p>Predictors are allowed to have fixed effects, random effects, or both on all target variables.
The intercept is automatically included as both a fixed and a random effect, but it can be suppressed if needed (see 'Examples').
Note that, when specifying random effects other than the intercept, these will <em>not</em> be automatically added as fixed effects and must be included explicitly.
Any predictors defined by <code>I()</code> will be used for imputation but not included in the data set unless <code>save.pred = TRUE</code>.
</p>
<p>In order to run separate imputations for each level of an additional grouping variable, the <code>group</code> argument can be used.
The name of the grouping variable must be given as a character string (i.e., in quotation marks).
</p>
<p>The default prior distributions for the covariance matrices in <code>panImpute</code> are &quot;least informative&quot; inverse-Wishart priors with minimum positive degrees of freedom (largest dispersion) and the identity matrix for scale.
The <code>prior</code> argument can be used to specify alternative prior distributions.
These must be supplied as a list containing the following components:
</p>

<ul>
<li><p><code>a</code>: degrees of freedom for the covariance matrix of residuals
</p>
</li>
<li><p><code>Binv</code>: scale matrix for the covariance matrix of residuals
</p>
</li>
<li><p><code>c</code>: degrees of freedom for the covariance matrix of random effects
</p>
</li>
<li><p><code>Dinv</code>: scale matrix for the covariance matrix of random effects
</p>
</li></ul>

<p>A sensible choice for a diffuse non-default prior is to set the degrees of freedom to the lowest value possible, and the scale matrices according to a prior guess of the corresponding covariance matrices (see Schafer &amp; Yucel, 2002).
</p>
<p>In imputation models with many parameters, the number of chains in the MCMC algorithm being stored can be reduced with the <code>keep.chains</code> argument.
If set to <code>"full"</code> (the default), all chains are saved.
If set to <code>"diagonal"</code>, only chains pertaining to fixed effects and the diagonal entries of the covariance matrices are saved.
This setting influences the storage mode of parameters (e.g., dimensions and indices of arrays) and should be used with caution.
</p>


<h3>Value</h3>

<p>An object of class <code>mitml</code>, containing the following components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>The original (incomplete) data set, sorted according to the cluster variable and (if given) the grouping variable, with several attributes describing the original row order (<code>"sort"</code>) and grouping (<code>"group"</code>.</p>
</td></tr>
<tr><td><code>replacement.mat</code></td>
<td>
<p>A matrix containing the multiple replacements (i.e., imputations) for each missing value. The replacement matrix contains one row for each missing value and one one column for each imputed data set.</p>
</td></tr>
<tr><td><code>index.mat</code></td>
<td>
<p>A matrix containing the row and column index for each missing value. The index matrix is used to <em>link</em> the missing values in the data set with their corresponding rows in the replacement matrix.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched function call.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list containing the names of the cluster variable, the target variables, and the predictor variables with fixed and random effects, respectively.</p>
</td></tr>
<tr><td><code>random.L1</code></td>
<td>
<p>A character string denoting the handling of random residual covariance matrices (not used here; see <code>jomoImpute</code>).</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>The prior parameters used in the imputation model.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>A list containing the number of burn-in iterations, the number of iterations between imputations, and the number of imputed data sets.</p>
</td></tr>
<tr><td><code>par.burnin</code></td>
<td>
<p>A multi-dimensional array containing the parameters of the imputation model from the burn-in phase.</p>
</td></tr>
<tr><td><code>par.imputation</code></td>
<td>
<p>A multi-dimensional array containing the parameters of the imputation model from the imputation phase.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For objects of class <code>mitml</code>, methods for the generic functions <code>print</code>, <code>summary</code>, and <code>plot</code> are available to inspect the fitted imputation model.
<code>mitmlComplete</code> is used for extracting the imputed data sets.
</p>


<h3>Author(s)</h3>

<p>Simon Grund, Alexander Robitzsch, Oliver Luedtke</p>


<h3>References</h3>

<p>Schafer, J. L., and Yucel, R. M. (2002). Computational strategies for multivariate linear mixed-effects models with missing values. <em>Journal of Computational and Graphical Statistics, 11</em>, 437-457.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jomoImpute">jomoImpute</a></code>, <code><a href="#topic+mitmlComplete">mitmlComplete</a></code>, <code><a href="#topic+summary.mitml">summary.mitml</a></code>, <code><a href="#topic+plot.mitml">plot.mitml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># NOTE: The number of iterations in these examples is much lower than it
# should be! This is done in order to comply with CRAN policies, and more
# iterations are recommended for applications in practice!

data(studentratings)

# *** ................................
# the 'type' interface
# 

# * Example 1.1: 'ReadDis' and 'SES', predicted by 'ReadAchiev' and 
# 'CognAbility', with random slope for 'ReadAchiev'

type &lt;- c(-2, 0, 0, 0, 0, 0, 3, 1, 2, 0)
names(type) &lt;- colnames(studentratings)
type

imp &lt;- panImpute(studentratings, type = type, n.burn = 1000, n.iter = 100, m = 5)

# * Example 1.2: 'ReadDis' and 'SES' groupwise for 'FedState',
# and predicted by 'ReadAchiev'

type &lt;- c(-2, -1, 0, 0, 0, 0, 2, 1, 0, 0)
names(type) &lt;- colnames(studentratings)
type

imp &lt;- panImpute(studentratings, type = type, n.burn = 1000, n.iter = 100, m = 5)

# *** ................................
# the 'formula' interface
# 

# * Example 2.1: imputation of 'ReadDis', predicted by 'ReadAchiev'
# (random intercept)

fml &lt;- ReadDis ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

# ... the intercept can be suppressed using '0' or '-1' (here for fixed intercept)
fml &lt;- ReadDis ~ 0 + ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

# * Example 2.2: imputation of 'ReadDis', predicted by 'ReadAchiev'
# (random slope)

fml &lt;- ReadDis ~ ReadAchiev + (1+ReadAchiev|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

# * Example 2.3: imputation of 'ReadDis', predicted by 'ReadAchiev',
# groupwise for 'FedState'

fml &lt;- ReadDis ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, group = "FedState", n.burn = 1000,
                 n.iter = 100, m = 5)

# * Example 2.4: imputation of 'ReadDis', predicted by 'ReadAchiev'
# including the cluster mean of 'ReadAchiev' as an additional predictor

fml &lt;- ReadDis ~ ReadAchiev + I(clusterMeans(ReadAchiev, ID)) + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

# ... using 'save.pred' to save the calculated cluster means in the data set
fml &lt;- ReadDis ~ ReadAchiev + I(clusterMeans(ReadAchiev, ID)) + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5,
                 save.pred = TRUE)

head(mitmlComplete(imp, print = 1))
</code></pre>

<hr>
<h2 id='plot.mitml'>Print diagnostic plots</h2><span id='topic+plot.mitml'></span>

<h3>Description</h3>

<p>Generates diagnostic plots for assessing the convergence and autocorrelation behavior of <code>pan</code>'s and <code>jomo</code>'s MCMC algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'mitml'
plot(x, print = c("beta", "beta2", "psi", "sigma"), pos = NULL, group = "all",
  trace = c("imputation", "burnin", "all"), thin = 1, smooth = 3, n.Rhat = 3,
  export = c("none", "png", "pdf"), dev.args = list(), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mitml_+3A_x">x</code></td>
<td>
<p>An object of class <code>mitml</code> as produced by <code>panImpute</code> or <code>jomoImpute</code>.</p>
</td></tr>
<tr><td><code id="plot.mitml_+3A_print">print</code></td>
<td>
<p>A character vector containing one or several of <code>"beta"</code>, <code>"beta2"</code>, <code>"psi"</code> or <code>"sigma"</code> denoting which parameters should be plotted. Default is to plot all parameters.</p>
</td></tr>
<tr><td><code id="plot.mitml_+3A_pos">pos</code></td>
<td>
<p>Either <code>NULL</code> or an integer vector denoting a specific entry in <code>"beta"</code>, <code>"beta2"</code>, <code>"psi"</code> or <code>"sigma"</code>. Default is <code>NULL</code>, which plots all entries.</p>
</td></tr>
<tr><td><code id="plot.mitml_+3A_group">group</code></td>
<td>
<p>Either <code>"all"</code> or an integer denoting for which group the plots should be generated. Used only when groupwise imputation was used. Default is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="plot.mitml_+3A_trace">trace</code></td>
<td>
<p>One of <code>"imputation"</code>, <code>"burnin"</code> or <code>"all"</code> denoting which part of the chain should be used for the trace plot. Default is <code>"imputation"</code>, which plots only the iterations after burn-in.</p>
</td></tr>
<tr><td><code id="plot.mitml_+3A_thin">thin</code></td>
<td>
<p>An integer denoting the thinning factor that is applied before plotting. Default is <code>1</code>, which corresponds to no thinning.</p>
</td></tr>
<tr><td><code id="plot.mitml_+3A_smooth">smooth</code></td>
<td>
<p>A numeric value denoting the smoothing factor for the trend line in trace plots. Higher values correspond to less smoothing. Default is <code>3</code>. If set to <code>0</code> or <code>NULL</code>, the trend line is suppressed.</p>
</td></tr>
<tr><td><code id="plot.mitml_+3A_n.rhat">n.Rhat</code></td>
<td>
<p>An integer denoting the number of segments of each chain used for calculating the potential scale reduction factor. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="plot.mitml_+3A_export">export</code></td>
<td>
<p>(optional) A character string specifying if plots should be exported to a file. If <code>"png"</code> or <code>"pdf"</code>, then plots are printed into a folder named &quot;mitmlPlots&quot; in the current directory using either the <code>png</code> or the <code>pdf</code> device. Default is <code>"none"</code>, which does not export files.</p>
</td></tr>
<tr><td><code id="plot.mitml_+3A_dev.args">dev.args</code></td>
<td>
<p>(optional) A named list containing additional arguments that are passed to the graphics device.</p>
</td></tr>
<tr><td><code id="plot.mitml_+3A_...">...</code></td>
<td>
<p>Parameters passed to the plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> method generates a series of plots for the parameters of the imputation model which can be used for diagnostic purposes.
In addition, a short summary of the parameter chain is displayed.
</p>
<p>Setting <code>print</code> to <code>"beta"</code>, <code>"beta2"</code>, <code>"psi"</code> and <code>"sigma"</code> will plot the fixed effects, the variances and covariances of the random effects, and the variances and covariances of the residuals, respectively.
In this context, <code>"beta2"</code> refers to the fixed effects for target variables at level 2 and is only used when a two-part model was specified in (<code><a href="#topic+jomoImpute">jomoImpute</a></code>).
Each plotting window contains a trace plot (upper left), an autocorrelation plot (lower left), a kernel density approximation of the posterior distribution (upper right), and a posterior summary (lower right).
The summary includes the following quantities:
</p>

<dl>
<dt><code>EAP</code>:</dt><dd><p>Expected value a posteriori (i.e., the mean of the parameter chain)</p>
</dd>
<dt><code>MAP</code>:</dt><dd><p>Mode a posteriori (i.e., the mode of the parameter chain)</p>
</dd>
<dt><code>SD</code>:</dt><dd><p>Standard deviation of the parameter chain</p>
</dd>
<dt><code>2.5%</code>:</dt><dd><p>The 2.5% quantile of parameter values</p>
</dd>
<dt><code>97.5%</code>:</dt><dd><p>The 97.5% quantile of parameter values</p>
</dd>
<dt><code>Rhat</code>:</dt><dd><p>Estimated potential scale reduction factor (<code class="reqn">\hat{R}</code>)</p>
</dd>
<dt><code>ACF-k</code>:</dt><dd><p>Smoothed autocorrelation at lag <code class="reqn">k</code>, where <code class="reqn">k</code> is the number of iterations between imputations (see <code><a href="#topic+summary.mitml">summary.mitml</a></code>)</p>
</dd>
</dl>

<p>The <code>trace</code> and <code>smooth</code> arguments can be used to influence how the trace plot is drawn and what part of the chain should be used for it.
The <code>thin</code> argument can be used for thinning the chain before plotting, in which case the number of data points is reduced in the trace plot, and the autocorrelation is calculated up to lag <code class="reqn">k/thin</code> (see above).
The <code>n.Rhat</code> argument controls the number of segments that are used for calculating the potential scale reduction factor (<code class="reqn">\hat{R}</code>) in each plot (see <code>summary.mitml</code>).
Further aguments to the graphics device are supplied using the <code>dev.args</code> argument.
</p>
<p>The <code>plot</code> function computes and displays diagnostic information primarily for the imputation phase (i.e., for iterations after burn-in).
This is the default in the <code>plot</code> function and the recommended method for most users.
If <code>trace = "all"</code>, the full chain is displayed with emphasis on the imputation phase, and the posterior summary is calculated based on only the iterations after burn-in (as recommended).
If <code>trace = "burnin"</code>, the posterior summary and the trace plots are calculated based on only the burn-on interations, which is generally not sufficient to establish convergence and should be used with caution.
</p>


<h3>Value</h3>

<p>None (invisible <code>NULL</code>).
</p>


<h3>Note</h3>

<p>The plots are presented on-screen one at a time.
To proceed with the next plot, the user may left-click in the plotting window or press the &quot;enter&quot; key while in the R console, depending on the operating system.
No plots are displayed when exporting to file.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>See Also</h3>

<p><code><a href="#topic+panImpute">panImpute</a></code>, <code><a href="#topic+jomoImpute">jomoImpute</a></code>, <code><a href="#topic+summary.mitml">summary.mitml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(studentratings)

# * Example 1: simple imputation

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

# plot all parameters (default)
plot(imp)

# plot fixed effects only
plot(imp, print = "beta")

# export plots to file (using pdf device)
plot(imp, export = "pdf", dev.args = list(width = 9, height = 4, pointsize = 12))

# * Example 2: groupwise imputation

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, group = FedState, n.burn = 1000,
       n.iter = 100, m = 5)

# plot fixed effects for all groups (default for 'group')
plot(imp, print = "beta", group = "all")

# plot fixed effects for first group only
plot(imp, print = "beta", group = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.mitml'>Read <code>mitml</code> objects from file</h2><span id='topic+read.mitml'></span>

<h3>Description</h3>

<p>This function loads <code>mitml</code> class objects from R binary formats (similar to <code>?load</code>), usually produced by <code>write.mitml</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
read.mitml(filename)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.mitml_+3A_filename">filename</code></td>
<td>
<p>Name of the file to read, to be specified with file extension (e.g., <code>.R</code>, <code>.Rdata</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mitml</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>See Also</h3>

<p><code><a href="#topic+panImpute">panImpute</a></code>, <code><a href="#topic+jomoImpute">jomoImpute</a></code>, <code><a href="#topic+write.mitml">write.mitml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

# write 'mitml' object
write.mitml(imp, filename = "imputation.R")

# read previously saved 'mitml' object
old.imp &lt;- read.mitml("imputation.R")

class(old.imp)
old.imp

## End(Not run)
</code></pre>

<hr>
<h2 id='sort.mitml.list'>Sort a list of imputed data sets</h2><span id='topic+sort.mitml.list'></span>

<h3>Description</h3>

<p>Sorts a list of multiply imputed data sets according to an R expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'mitml.list'
sort(x, decreasing = FALSE, by, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort.mitml.list_+3A_x">x</code></td>
<td>
<p>A list of imputed data sets with class <code>mitml.list</code> as produced by <code>mitmlComplete</code> (or similar).</p>
</td></tr>
<tr><td><code id="sort.mitml.list_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical flag indicating if data sets should be sorted in decreasing (i.e., reversed) order. Default is '<code>FALSE</code>'.</p>
</td></tr>
<tr><td><code id="sort.mitml.list_+3A_by">by</code></td>
<td>
<p>An R expression or a list of multiple expressions by which to sort the imputed data sets (see 'Examples').</p>
</td></tr>
<tr><td><code id="sort.mitml.list_+3A_...">...</code></td>
<td>
<p>Further arguments to '<code>order</code>' (see 'Details').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sorts a list of imputed data sets according to the R expression given in the <code>by</code> argument.
The function is based on <code>order</code> and works in a similar manner.
Note that sorting is performed individually for each data set.
For this reason, the order of cases may differ across data sets if the variables used for sorting contain different values.
</p>


<h3>Value</h3>

<p>A list of imputed data sets with class <code>mitml.list</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

implist &lt;- mitmlComplete(imp)

# * Example 1: sort by ID
sort(implist, by = ID)

# * Example 2: sort by combination of variables
sort(implist, by = list(FedState, ID, -SES))
</code></pre>

<hr>
<h2 id='studentratings'>Example data set on student ratings and achievement</h2><span id='topic+studentratings'></span>

<h3>Description</h3>

<p>Contains simulated data for students nested within schools, featuring students' ratings of their teachers' behavior (i.e., disciplinary problems in mathematics and reading class) and their general learning environment (school climate) as well as mathematics and reading achievement scores, and scores for socio-economic status and cognitive ability.
</p>
<p>In addition, the data set features the ID of 50 different schools (i.e., clusters), the biological sex of all students, and a broad, additional grouping factor.
Different amounts of missing data have been inserted into the data set in a completely random fashion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(studentratings)</code></pre>


<h3>Format</h3>

<p>A data frame containing 750 observations on 10 variables.</p>

<hr>
<h2 id='subset.mitml.list'>Subset a list of imputed data sets</h2><span id='topic+subset.mitml.list'></span>

<h3>Description</h3>

<p>Creates data subsets for a list of multiply imputed data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'mitml.list'
subset(x, subset, select, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.mitml.list_+3A_x">x</code></td>
<td>
<p>A list of imputed data sets with class <code>mitml.list</code> as produced by <code>mitmlComplete</code> (or similar).</p>
</td></tr>
<tr><td><code id="subset.mitml.list_+3A_subset">subset</code></td>
<td>
<p>An R expression by which to subset each data set.</p>
</td></tr>
<tr><td><code id="subset.mitml.list_+3A_select">select</code></td>
<td>
<p>An R expression by which to select columns.</p>
</td></tr>
<tr><td><code id="subset.mitml.list_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to create subsets and select variables for a list of multiply imputed data sets according to the R expressions given in the <code>subset</code> and <code>select</code> arguments.
The function is based on the <code>subset</code> function for regular data sets and works in a similar manner.
Note that subsetting is performed individually for each data set.
For this reason, the cases included may differ across data sets if the variables used for subsetting contain different values.
</p>


<h3>Value</h3>

<p>A list of imputed data sets with class <code>mitml.list</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

implist &lt;- mitmlComplete(imp)

# * Example 1: subset by SES, select variables by name
subset(implist, SES &lt; 25, select = c(ID, FedState, Sex, SES, ReadAchiev, ReadDis))

# * Example 2: subset by FedState, select variables by column number
subset(implist, FedState == "SH", select = -c(6:7, 9:10))

## Not run: 
# * Example 3: subset by ID and Sex
subset(implist, ID 

# * Example 4: select variables by name range
subset(implist, select = ID:Sex)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.mitml'>Summary measures for imputation models</h2><span id='topic+summary.mitml'></span>

<h3>Description</h3>

<p>Provides summary statistics and additional information on imputations in objects of class <code>mitml</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'mitml'
summary(object, n.Rhat = 3, goodness.of.appr = FALSE, autocorrelation = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mitml_+3A_object">object</code></td>
<td>
<p>An object of class <code>mitml</code> as produced by <code>panImpute</code> or <code>jomoImpute</code>.</p>
</td></tr>
<tr><td><code id="summary.mitml_+3A_n.rhat">n.Rhat</code></td>
<td>
<p>(optional) An integer denoting the number of segments used for calculating the potential scale reduction factor. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="summary.mitml_+3A_goodness.of.appr">goodness.of.appr</code></td>
<td>
<p>(optional) A logical flag indicating if the goodness of approximation should be printed. Default is <code>FALSE</code> (see 'Details').</p>
</td></tr>
<tr><td><code id="summary.mitml_+3A_autocorrelation">autocorrelation</code></td>
<td>
<p>(optional) A logical flag indicating if the autocorrelation should be printed. Default is <code>FALSE</code> (see 'Details').</p>
</td></tr>
<tr><td><code id="summary.mitml_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>summary</code> method calculates summary statistics for objects of class <code>mitml</code> as produced by <code><a href="#topic+panImpute">panImpute</a></code> or <code><a href="#topic+jomoImpute">jomoImpute</a></code>.
The output includes the potential scale reduction factor (PSRF, or <code class="reqn">\hat{R}</code>) and (optionally) the goodness of approximation and autocorrelation. 
</p>
<p>The PSRF is calculated for each parameter of the imputation model and can be used as a convergence diagnostic (Gelman and Rubin, 1992).
Calculation of the PSRFs can be suppressed by setting <code>n.Rhat = NULL</code>.
The PSRFs are not computed from different chains but by dividing each chain from the imputation phase into a number of segments as denoted by <code>n.Rhat</code>.
This is slightly different from the original method proposed by Gelman and Rubin.
</p>
<p>The goodness of approximation measure indicates what proportion of the posterior standard deviation is due to simulation error.
This is useful for assessing the accuracy of the posterior summaries (e.g., the EAP).
The autocorrelation includes estimates of the autocorrelation in the chains at lag 1 (i.e., for consecutive draws) and for lags <code class="reqn">k</code> and <code class="reqn">2k</code>, where <code class="reqn">k</code> is the number of iterations between imputations.
For lag <code class="reqn">k</code> and <code class="reqn">2k</code>, the autocorrelation is slightly smoothed to reduce the influence of noise on the estimates (see <code><a href="#topic+plot.mitml">plot.mitml</a></code>).
</p>


<h3>Value</h3>

<p>An object of class <code>summary.mitml</code>.
A print method is used for more readable output.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>References</h3>

<p>Gelman, A., and Rubin, D. B. (1992). Inference from iterative simulation using multiple sequences. <em>Statistical Science, 7</em>, 457-472.
</p>
<p>Hoff, P. D. (2009). <em>A first course in Bayesian statistical methods</em>. New York, NY: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panImpute">panImpute</a></code>, <code><a href="#topic+jomoImpute">jomoImpute</a></code>, <code><a href="#topic+plot.mitml">plot.mitml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

# print summary
summary(imp)
</code></pre>

<hr>
<h2 id='testConstraints'>Test functions and constraints of model parameters</h2><span id='topic+testConstraints'></span>

<h3>Description</h3>

<p>Performs hypothesis tests for arbitrary functions of the model parameters using the Delta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
testConstraints(model, qhat, uhat, constraints, method = c("D1", "D2"),
  ariv = c("default", "positive"), df.com = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testConstraints_+3A_model">model</code></td>
<td>
<p>A list of fitted statistical models as produced by <code><a href="#topic+with.mitml.list">with.mitml.list</a></code> or similar.</p>
</td></tr>
<tr><td><code id="testConstraints_+3A_qhat">qhat</code></td>
<td>
<p>A matrix or list containing the point estimates of the parameters for each imputed data set (see 'Details').</p>
</td></tr>
<tr><td><code id="testConstraints_+3A_uhat">uhat</code></td>
<td>
<p>An array or list containing the variance-covariance matrix of the parameters for each imputed data set (see 'Details').</p>
</td></tr>
<tr><td><code id="testConstraints_+3A_constraints">constraints</code></td>
<td>
<p>A character vector specifying constraints or functions of the vector of model parameters to be tested (see 'Details').</p>
</td></tr>
<tr><td><code id="testConstraints_+3A_method">method</code></td>
<td>
<p>A character string denoting the method by which the test is performed. Can be <code>"D1"</code> or <code>"D2"</code> (see 'Details'). Default is <code>"D1"</code>.</p>
</td></tr>
<tr><td><code id="testConstraints_+3A_ariv">ariv</code></td>
<td>
<p>A character string denoting how the ARIV is calculated. Can be <code>"default"</code> or <code>"positive"</code> (see 'Details').</p>
</td></tr>
<tr><td><code id="testConstraints_+3A_df.com">df.com</code></td>
<td>
<p>(optional) A single number or a numeric vector denoting the complete-data degrees of freedom for the hypothesis test (see 'Details'). Only used if <code>method = "D1"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs tests of arbitrary functions (or constraints) of the model parameters using similar methods as <code><a href="#topic+testModels">testModels</a></code>.
The function relies on the Delta method (e.g., Casella &amp; Berger, 2002) for testing functions of the parameters and assumes that their sampling distribution is approximately normal.
The parameters can either be extracted automatically from the fitted statistical models (<code>model</code>) or provided manually as matrices, arrays, or lists (<code>qhat</code> and <code>uhat</code>, see 'Examples').
</p>
<p>Constraints and other functions of the model parameters are specified in the <code>constraints</code> argument.
The constraints must be supplied as a character vector, where each string denotes a function or a constraint to be tested (see 'Examples').
</p>
<p>The Wald-like tests that are carried out by <code>testConstraints</code> are pooled across the imputed data sets with the <code class="reqn">D_1</code> (Li, Raghunathan &amp; Rubin, 1991) or <code class="reqn">D_2</code> (Li, Meng, Raghunathan &amp; Rubin, 1991) method, where <code class="reqn">D_1</code> operates on the constrained point and variance estimates, and <code class="reqn">D_2</code> operates on the Wald-statistics (for additional details, see <code>testModels</code>).
The pooled estimates and standard errors reported in the output are always based on <code class="reqn">D_1</code>.
</p>
<p>For <code class="reqn">D_1</code>, the complete-data degrees of freedom can be adjusted for smaller samples by specifying <code>df.com</code> (see <code>testModels</code>).
</p>
<p>This function supports general statistical models that define <code>coef</code> and <code>vcov</code> methods (e.g., <code>lm</code>, <code>glm</code>, <code>lavaan</code> and others) as well as multilevel models estimated with <code>lme4</code> or <code>nlme</code> and GEEs estimated with <code>geepack</code>.
The arguments <code>qhat</code> and <code>uhat</code> provide a general method for pooling parameter estimates regardless of model type (see 'Examples').
Support for further models may be added in future releases.
</p>
<p>The <code>ariv</code> argument determines how the average relative increase in variance (ARIV) is calculated (see <code>testModels</code>).
If <code>ariv = "default"</code>, the default estimators are used.
If <code>ariv = "positive"</code>, the default estimators are used but constrained to take on strictly positive values.
</p>


<h3>Value</h3>

<p>A list containing the results of the model comparison.
A <code>print</code> method is used for more readable output. 
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>References</h3>

<p>Casella, G., &amp; Berger, R. L. (2002). <em>Statistical inference (2nd. Ed.)</em>. Pacific Grove, CA: Duxbury.
</p>
<p>Li, K.-H., Meng, X.-L., Raghunathan, T. E., &amp; Rubin, D. B. (1991). Significance levels from repeated p-values with multiply-imputed data. <em>Statistica Sinica, 1</em>, 65-92.
</p>
<p>Li, K. H., Raghunathan, T. E., &amp; Rubin, D. B. (1991). Large-sample significance levels from multiply imputed data using moment-based statistics and an F reference distribution. <em>Journal of the American Statistical Association, 86</em>, 1065-1073.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testModels">testModels</a></code>, <code><a href="#topic+with.mitml.list">with.mitml.list</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

fml &lt;- MathDis + ReadDis + SchClimate ~ (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

implist &lt;- mitmlComplete(imp)

# fit simple regression model
fit.lm &lt;- with(implist, lm(SchClimate ~ ReadDis + MathDis))

# apply Rubin's rules
testEstimates(fit.lm)

# * Example 1: test 'identity' function of two parameters (automatic)
# test equivalent to model comparison with a restricted model (without 'ReadDis'
# and 'MathDis')

cons &lt;- c("ReadDis", "MathDis")
testConstraints(fit.lm, constraints = cons)

# ... adjusting for finite samples
testConstraints(fit.lm, constraints = cons, df.com = 749)

# ... using D2
testConstraints(fit.lm, constraints = cons, method = "D2")

# * Example 2: test for equality of two parameters
# tests the hypothesis that the coefficients pertaining to 'ReadDis' and 'MathDis'
# are equal (ReadDis = MathDis)

cons &lt;- c("ReadDis-MathDis")
testConstraints(fit.lm, constraints = cons)

# * Example 3: test against a fixed value
# tests the hypothesis that the coefficient of "ReadDis" is equal to one
# (i.e., 'ReadDis' - 1 == 0)

cons &lt;- c("ReadDis-1")
testConstraints(fit.lm, constraints = cons)

# * Example 4: test 'identity' function of two parameters (qhat, uhat)

fit.lm &lt;- with(implist, lm(SchClimate ~ ReadDis + MathDis))

qhat &lt;- sapply(fit.lm, coef)
uhat &lt;- sapply(fit.lm, function(x) vcov(x), simplify = "array")

cons &lt;- c("ReadDis", "MathDis")
testConstraints(qhat = qhat, uhat = uhat, constraints = cons)
</code></pre>

<hr>
<h2 id='testEstimates'>Compute final estimates and inferences</h2><span id='topic+testEstimates'></span>

<h3>Description</h3>

<p>Computes final parameter estimates and inferences from multiply imputed data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
testEstimates(model, qhat, uhat, extra.pars = FALSE, df.com = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testEstimates_+3A_model">model</code></td>
<td>
<p>A list of fitted statistical models as produced by <code><a href="#topic+with.mitml.list">with.mitml.list</a></code> or similar.</p>
</td></tr>
<tr><td><code id="testEstimates_+3A_qhat">qhat</code></td>
<td>
<p>A matrix or list containing the point estimates of the parameters for each imputed data set (see 'Details').</p>
</td></tr>
<tr><td><code id="testEstimates_+3A_uhat">uhat</code></td>
<td>
<p>(optional) An array, matrix, or list containing the variance estimates (i.e., squared standard errors) of the parameters for each imputed data set (see 'Details').</p>
</td></tr>
<tr><td><code id="testEstimates_+3A_extra.pars">extra.pars</code></td>
<td>
<p>A logical flag indicating if estimates of additional parameters (e.g., variance components) should be calculated. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="testEstimates_+3A_df.com">df.com</code></td>
<td>
<p>(optional) A numeric vector denoting the complete-data degrees of freedom for the hypothesis tests (see 'Details').</p>
</td></tr>
<tr><td><code id="testEstimates_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates pooled parameter estimates and inferences as suggested by Rubin (1987, &quot;Rubin's rules&quot;) for each parameter of the fitted model.
The parameters can either be extracted automatically from the fitted statistical models (<code>model</code>) or provided manually as matrices, arrays, or lists (<code>qhat</code> and <code>uhat</code>, see 'Examples').
</p>
<p>Rubin's original method assumes that the complete-data degrees of freedom are infinite, which is reasonable in larger samples.
Alternatively, the degrees of freedom can be adjusted for smaller samples by specifying <code>df.com</code> (Barnard &amp; Rubin, 1999).
The <code>df.com</code> argument can either be a single number if the degrees of freedom are equal for all parameters being tested, or a numeric vector with one element per parameter.
</p>
<p>Using the <code>extra.pars</code> argument, pooled estimates for additional parameters can be requested (e.g., variance components).
This option is available for a number of models but may not provide estimates for all parameters in all model types.
In such a case, users may extract the estimates of additional parameters by hand and pool them with the <code>qhat</code> argument (see 'Examples').
No inferences are calculated for pooled additional parameters.
</p>
<p>Currently, the procedure supports automatic extraction of model parameters from models that define <code>coef</code> and <code>vcov</code> methods (e.g., <code>lm</code>, <code>glm</code>, <code>lavaan</code> and others) as well as multilevel models estimated with <code>lme4</code> or <code>nlme</code> and GEEs estimated with <code>geepack</code>.
The arguments <code>qhat</code> and <code>uhat</code> provide a general method for pooling parameter estimates regardless of model type (see 'Examples').
Support for further models may be added in future releases.
</p>


<h3>Value</h3>

<p>A list containing the pooled parameter and inferences.
A <code>print</code> method is used for more readable output. 
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>References</h3>

<p>Barnard, J., &amp; Rubin, D. B. (1999). Small-sample degrees of freedom with multiple imputation. <em>Biometrika, 86</em>, 948-955.
</p>
<p>Rubin, D. B. (1987). <em>Multiple imputation for nonresponse in surveys</em>. Hoboken, NJ: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+with.mitml.list">with.mitml.list</a></code>, <code><a href="#topic+confint.mitml.testEstimates">confint.mitml.testEstimates</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

implist &lt;- mitmlComplete(imp)

# fit multilevel model using lme4
require(lme4)
fit.lmer &lt;- with(implist, lmer(SES ~ (1|ID)))

# * Example 1: pool estimates of fitted models (automatic)
# pooled estimates and inferences separately for each parameter (Rubin's rules)
testEstimates(fit.lmer)

# ... adjusted df for finite samples
testEstimates(fit.lmer, df.com = 49)

# ... with additional table for variance components and ICCs
testEstimates(fit.lmer, extra.pars = TRUE)

# * Example 2: pool estimates using matrices or lists (qhat, uhat)
fit.lmer &lt;- with(implist, lmer(SES ~ ReadAchiev + (1|ID)))

qhat &lt;- sapply(fit.lmer, fixef)
uhat &lt;- sapply(fit.lmer, function(x) diag(vcov(x)))

testEstimates(qhat = qhat)
testEstimates(qhat = qhat, uhat = uhat)
</code></pre>

<hr>
<h2 id='testModels'>Test multiple parameters and compare nested models</h2><span id='topic+testModels'></span>

<h3>Description</h3>

<p>Performs multi-parameter hypothesis tests for a vector of statistical parameters and compares nested statistical models obtained from multiply imputed data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
testModels(model, null.model, method = c("D1", "D2", "D3", "D4"), 
  use = c("wald", "likelihood"), ariv = c("default", "positive", "robust"),
  df.com = NULL, data = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testModels_+3A_model">model</code></td>
<td>
<p>A list of fitted statistical models (&ldquo;full&rdquo; model) as produced by <code><a href="#topic+with.mitml.list">with.mitml.list</a></code> or similar.</p>
</td></tr>
<tr><td><code id="testModels_+3A_null.model">null.model</code></td>
<td>
<p>A list of fitted statistical models (&ldquo;restricted&rdquo; model) as produced by <code><a href="#topic+with.mitml.list">with.mitml.list</a></code> or similar.</p>
</td></tr>
<tr><td><code id="testModels_+3A_method">method</code></td>
<td>
<p>A character string denoting the method by which the test is performed. Can be <code>"D1"</code>, <code>"D2"</code>, <code>"D3"</code>, or <code>"D4"</code> (see 'Details'). Default is <code>"D1"</code>.</p>
</td></tr>
<tr><td><code id="testModels_+3A_use">use</code></td>
<td>
<p>A character string denoting Wald- or likelihood-based based tests. Can be either <code>"wald"</code> or <code>"likelihood"</code>. Only used if <code>method = "D2"</code>.</p>
</td></tr>
<tr><td><code id="testModels_+3A_ariv">ariv</code></td>
<td>
<p>A character string denoting how the ARIV is calculated. Can be <code>"default"</code>, <code>"positive"</code>, or <code>"robust"</code> (see 'Details').</p>
</td></tr>
<tr><td><code id="testModels_+3A_df.com">df.com</code></td>
<td>
<p>(optional) A number denoting the complete-data degrees of freedom for the hypothesis test. Only used if <code>method = "D1"</code>.</p>
</td></tr>
<tr><td><code id="testModels_+3A_data">data</code></td>
<td>
<p>(optional) A list of imputed data sets (see 'Details'). Only used if <code>method = "D4"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function compares two nested statistical models fitted to multiply imputed data sets by pooling Wald-like or likelihood-ratio tests.
</p>
<p>Pooling methods for Wald-like tests of multiple parameters were introduced by Rubin (1987) and further developed by Li, Raghunathan and Rubin (1991).
The pooled Wald test is referred to as <code class="reqn">D_1</code> and can be used by setting <code>method = "D1"</code>.
<code class="reqn">D_1</code> is the multi-parameter equivalent of <code><a href="#topic+testEstimates">testEstimates</a></code>, that is, it tests multiple parameters simultaneously.
For <code class="reqn">D_1</code>, the complete-data degrees of freedom are assumed to be infinite, but they can be adjusted for smaller samples by supplying <code>df.com</code> (Reiter, 2007).
</p>
<p>An alternative method for Wald-like hypothesis tests was suggested by Li, Meng, Raghunathan and Rubin (1991).
The procedure is called <code class="reqn">D_2</code> and can be used by setting <code>method = "D2"</code>.
<code class="reqn">D_2</code> calculates the Wald-test directly for each data set and then pools the resulting <code class="reqn">\chi^2</code> values.
The source of these values is specified by the <code>use</code> argument.
If <code>use = "wald"</code> (the default), then a Wald test similar to <code class="reqn">D_1</code> is performed.
If <code>use = "likelihood"</code>, then the two models are compared with a likelihood-ratio test instead.
</p>
<p>Pooling methods for likelihood-ration tests were suggested by Meng and Rubin (1992).
This procedure is referred to as <code class="reqn">D_3</code> and can be used by setting <code>method = "D3"</code>.
<code class="reqn">D_3</code> compares the two models by pooling the likelihood-ratio test across multiply imputed data sets.
</p>
<p>Finally, an improved method for pooling likelihood-ratio tests was recommended by Chan &amp; Meng (2019).
This method is referred to as <code class="reqn">D_4</code> and can be used by setting <code>method = "D4"</code>.
<code class="reqn">D_4</code> also compares models by pooling the likelihood-ratio test but does so in a more general and efficient manner.
</p>
<p>The function supports different classes of statistical models depending on which <code>method</code> is chosen.
<code class="reqn">D_1</code> supports models that define <code>coef</code> and <code>vcov</code> methods (or similar) for extracting the parameter estimates and their estimated covariance matrix. 
<code class="reqn">D_2</code> can be used for the same models (if <code>use = "wald"</code> and models that define a <code>logLik</code> method (if <code>use = "likelihood"</code>).
<code class="reqn">D_3</code> supports linear models, linear mixed-effects models (see Laird, Lange, &amp; Stram, 1987) with an arbitrary cluster structed if estimated with <code>lme4</code> or a single cluster if estimated by <code>nlme</code>, and structural equation models estimated with <code>lavaan</code> (requires ML estimator, see 'Note').
Finally, <code class="reqn">D_4</code> supports models that define a <code>logLik</code> method but can fail if the data to which the model was fitted cannot be found.
In such a case, users can provide the list of imputed data sets directly by specifying the <code>data</code> argument or refit with the <code>include.data</code> argument in <code><a href="#topic+with.mitml.list">with.mitml.list</a></code>.
Support for other statistical models may be added in future releases.
</p>
<p>The <code class="reqn">D_4</code>, <code class="reqn">D_3</code>, and <code class="reqn">D_2</code> methods support different estimators of the relative increase in variance (ARIV), which can be specified with the <code>ariv</code> argument.
If <code>ariv = "default"</code>, the default estimators are used.
If <code>ariv = "positive"</code>, the default estimators are used but constrained to take on strictly positive values.
This is useful if the estimated ARIV is negative.
If <code>ariv = "robust"</code>, which is available only for <code class="reqn">D_4</code>, the &quot;robust&quot; estimator proposed by Chan &amp; Meng (2019) is used.
This method should be used with caution, because it requires much stronger assumptions and may result in liberal inferences if these assumptions are violated.
</p>


<h3>Value</h3>

<p>A list containing the results of the model comparison.
A <code>print</code> method is used for more readable output. 
</p>


<h3>Note</h3>

<p>The methods <code class="reqn">D_4</code>, <code class="reqn">D_3</code>, and the likelihood-based <code class="reqn">D_2</code> assume that models were fit using maximum likelihood (ML).
Models fit using REML are automatically refit using ML.
Models fit in <code>'lavaan'</code> using the MLR estimator or similar techniques that require scaled <code class="reqn">chi^2</code> difference tests are currently not supported.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>References</h3>

<p>Chan, K. W., &amp; Meng, X.-L. (2019). Multiple improvements of multiple imputation likelihood ratio tests. ArXiv:1711.08822 [Math, Stat]. <a href="https://arxiv.org/abs/1711.08822">https://arxiv.org/abs/1711.08822</a>
</p>
<p>Laird, N., Lange, N., &amp; Stram, D. (1987). Maximum likelihood computations with repeated measures: Application of the em algorithm. <em>Journal of the American Statistical Association, 82</em>, 97-105.
</p>
<p>Li, K.-H., Meng, X.-L., Raghunathan, T. E., &amp; Rubin, D. B. (1991). Significance levels from repeated p-values with multiply-imputed data. <em>Statistica Sinica, 1</em>, 65-92.
</p>
<p>Li, K. H., Raghunathan, T. E., &amp; Rubin, D. B. (1991). Large-sample significance levels from multiply imputed data using moment-based statistics and an F reference distribution. <em>Journal of the American Statistical Association, 86</em>, 1065-1073.
</p>
<p>Meng, X.-L., &amp; Rubin, D. B. (1992). Performing likelihood ratio tests with multiply-imputed data sets. <em>Biometrika, 79</em>, 103-111. 
</p>
<p>Reiter, J. P. (2007). Small-sample degrees of freedom for multi-component significance tests with multiple imputation for missing data. <em>Biometrika, 94</em>, 502-508.
</p>
<p>Rubin, D. B. (1987). <em>Multiple imputation for nonresponse in surveys</em>. Hoboken, NJ: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testEstimates">testEstimates</a></code>, <code><a href="#topic+testConstraints">testConstraints</a></code>, <code><a href="#topic+with.mitml.list">with.mitml.list</a></code>, <code><a href="#topic+anova.mitml.result">anova.mitml.result</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

implist &lt;- mitmlComplete(imp)

# * Example 1: multiparameter hypothesis test for 'ReadDis' and 'SES'
# This tests the hypothesis that both effects are zero.

require(lme4)
fit0 &lt;- with(implist, lmer(ReadAchiev ~ (1|ID), REML = FALSE))
fit1 &lt;- with(implist, lmer(ReadAchiev ~ ReadDis + (1|ID), REML = FALSE))

# apply Rubin's rules
testEstimates(fit1)

# multiparameter hypothesis test using D1 (default)
testModels(fit1, fit0)

# ... adjusting for finite samples
testModels(fit1, fit0, df.com = 47)

# ... using D2 ("wald", using estimates and covariance-matrix)
testModels(fit1, fit0, method = "D2")

# ... using D2 ("likelihood", using likelihood-ratio test)
testModels(fit1, fit0, method = "D2", use = "likelihood")

# ... using D3 (likelihood-ratio test, requires ML fit)
testModels(fit1, fit0, method = "D3")

# ... using D4 (likelihood-ratio test, requires ML fit)
testModels(fit1, fit0, method = "D4")
</code></pre>

<hr>
<h2 id='with.mitml.list'>Evaluate an expression in a list of imputed data sets</h2><span id='topic+with.mitml.list'></span><span id='topic+within.mitml.list'></span>

<h3>Description</h3>

<p>The <code>with</code> and <code>within</code> methods evaluate R expressions in a list of multiply imputed data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'mitml.list'
with(data, expr, include.data = FALSE, ...)
## S3 method for class 'mitml.list'
within(data, expr, ignore = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with.mitml.list_+3A_data">data</code></td>
<td>
<p>A list of imputed data sets with class <code>mitml.list</code> as produced by <code>mitmlComplete</code> or <code>as.mitml.list</code>.</p>
</td></tr>
<tr><td><code id="with.mitml.list_+3A_expr">expr</code></td>
<td>
<p>An R expression to be evaluated for each data set.</p>
</td></tr>
<tr><td><code id="with.mitml.list_+3A_include.data">include.data</code></td>
<td>
<p>Either a logical flag or a character string denoting how the data are included when <code>expr</code> is evaluated (see 'Details'). If <code>FALSE</code>, an environment is created from <code>data</code>, and <code>expr</code> is evaluated therein. If <code>TRUE</code>, a call is constructed from <code>expr</code> and evaluated with the imputed data in the <code>"data"</code> slot. If character, a call is constructed from <code>expr</code> and evaluated with the imputed data in the slot named by <code>include.data</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="with.mitml.list_+3A_ignore">ignore</code></td>
<td>
<p>A character vector naming objects that are created but should not be saved (see 'Details').</p>
</td></tr>
<tr><td><code id="with.mitml.list_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two functions provide <code>with</code> and <code>within</code> methods for objects of class <code>mitml.list</code>.
They evaluate an R expression repeatedly for each of the imputed data sets but return different values: <code>with</code> returns the result of the evaluated expression; <code>within</code> returns the resulting data sets.
</p>
<p>The <code>within</code> function is useful for transforming and computing variables in the imputed data (e.g., centering, calculating cluster means, etc.).
The <code>with</code> function is useful, for example, for fitting statistical models.
The list of fitted models can be analyzed using <code><a href="#topic+testEstimates">testEstimates</a></code>, <code><a href="#topic+testModels">testModels</a></code>, <code><a href="#topic+testConstraints">testConstraints</a></code>, or <code><a href="#topic+anova.mitml.result">anova</a></code>.
</p>
<p>The <code>include.data</code> argument can be used to include the imputed data sets in the call to fit statistical models (<code>expr</code>) using <code>with</code>.
This is useful for fitting models that require that the fitting function be called with a proper <code>data</code> argument (e.g., <code>lavaan</code> or <code>nlme</code>; see 'Examples'). 
Setting <code>include.data = TRUE</code> will fit the model with the imputed data sets used as the <code>data</code> argument.
Setting <code>include.data = "df"</code> (or similar) will fit the model with the imputed data sets as the <code>df</code> argument (useful if the function refers to the data by a nonstandard name, such as <code>"df"</code>).
</p>
<p>The <code>ignore</code> argument can be used to declare objects that are not to be saved in the data sets created by <code>within</code>.
</p>


<h3>Value</h3>

<p><code>with</code>: A list of class <code>mitml.results</code> containing the evaluated expression for each data set. 
</p>
<p><code>within</code>: A list of class <code>mitml.list</code> containing the imputed data modified by the evaluated expression.
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>See Also</h3>

<p><code><a href="#topic+mitmlComplete">mitmlComplete</a></code>, <code><a href="#topic+anova.mitml.result">anova.mitml.result</a></code>, <code><a href="#topic+testEstimates">testEstimates</a></code>, <code><a href="#topic+testModels">testModels</a></code>, <code><a href="#topic+testConstraints">testConstraints</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

implist &lt;- mitmlComplete(imp)

# * Example 1: data transformation

# calculate and save cluster means
new1.implist &lt;- within(implist, Means.ReadAchiev &lt;- clusterMeans(ReadAchiev, ID))

# center variables, calculate interaction terms, ignore byproducts
new2.implist &lt;- within(implist, {
  M.SES &lt;- mean(SES)
  M.CognAbility &lt;- mean(CognAbility)
  C.SES &lt;- SES - M.SES
  C.CognAbility &lt;- CognAbility - M.CognAbility
  SES.CognAbility &lt;- C.SES * C.CognAbility
}, ignore = c("M.SES", "M.CognAbility"))

# * Example 2: fitting statistical models

# fit regression model
fit.lm &lt;- with(implist, lm(ReadAchiev ~ ReadDis))

# fit multilevel model with lme4
require(lme4)
fit.lmer &lt;- with(implist, lmer(ReadAchiev ~ ReadDis + (1|ID)))

## Not run: 
# fit structural equation model with lavaan (with include.data = TRUE)
require(lavaan)
mod &lt;- "ReadAchiev ~ ReadDis"
fit.sem &lt;- with(implist,
                sem(model = mod, cluster = "ID", estimator = "MLR"),
                include.data = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='write.mitml'>Write <code>mitml</code> objects to file</h2><span id='topic+write.mitml'></span>

<h3>Description</h3>

<p>Saves objects of class <code>mitml</code> in R binary formats (similar to <code>?save</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
write.mitml(x, filename, drop = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.mitml_+3A_x">x</code></td>
<td>
<p>An object of class <code>mitml</code> as produced by <code>panImpute</code> or <code>jomoImpute</code>.</p>
</td></tr>
<tr><td><code id="write.mitml_+3A_filename">filename</code></td>
<td>
<p>Name of the destination file, specified with file extension (e.g., <code>.R</code>, <code>.Rdata</code>).</p>
</td></tr>
<tr><td><code id="write.mitml_+3A_drop">drop</code></td>
<td>
<p>Logical flag indicating if the parameters of the imputation model should be dropped to reduce file size. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None (invisible <code>NULL</code>).
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>See Also</h3>

<p><code><a href="#topic+panImpute">panImpute</a></code>, <code><a href="#topic+jomoImpute">jomoImpute</a></code>, <code><a href="#topic+read.mitml">read.mitml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

# write full 'mitml' object (default)
write.mitml(imp, filename = "imputation.Rdata")

# drop parameters of the imputation model
write.mitml(imp, filename = "imputation.Rdata", drop = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='write.mitmlMplus'>Write <code>mitml</code> objects to Mplus format</h2><span id='topic+write.mitmlMplus'></span>

<h3>Description</h3>

<p>Saves objects of class <code>mitml</code> as a series of text files which can be processed by the statistical software M<em>plus</em> (Muthen &amp; Muthen, 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
write.mitmlMplus(x, filename, suffix = "list", sep = "\t", dec = ".",
  na.value = -999)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.mitmlMplus_+3A_x">x</code></td>
<td>
<p>An object of class <code>mitml</code> or <code>mitml.list</code> as produced by <code>panImpute</code>, <code>jomoImpute</code>, <code>mitmlComplete</code>, or similar).</p>
</td></tr>
<tr><td><code id="write.mitmlMplus_+3A_filename">filename</code></td>
<td>
<p>File base name for the text files containing the imputed data sets, specified without file extension.</p>
</td></tr>
<tr><td><code id="write.mitmlMplus_+3A_suffix">suffix</code></td>
<td>
<p>File name suffix for the index file.</p>
</td></tr>
<tr><td><code id="write.mitmlMplus_+3A_sep">sep</code></td>
<td>
<p>The field separator.</p>
</td></tr>
<tr><td><code id="write.mitmlMplus_+3A_dec">dec</code></td>
<td>
<p>The decimal separator.</p>
</td></tr>
<tr><td><code id="write.mitmlMplus_+3A_na.value">na.value</code></td>
<td>
<p>A numeric value coding the missing data in the resulting data files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The M<em>plus</em> format for multiply imputed data sets comprises a set of text files, each containing one imputed data set, and an index file containing the names of all data files.
During export, factors and character variables are converted to numeric.
To make this more transparent, <code>write.mitmlMplus</code> produces a log file which contains information about the data set and the factors that have been converted.
</p>
<p>In addition, a basic M<em>plus</em> input file is generated that can be used for setting up subsequent analysis models.
</p>


<h3>Value</h3>

<p>None (invisible <code>NULL</code>).
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>References</h3>

<p>Muthen, L. K., &amp; Muthen, B. O. (2012). <em>Mplus User's Guide. Seventh Edition.</em> Los Angeles, CA: Muthen &amp; Muthen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panImpute">panImpute</a></code>, <code><a href="#topic+jomoImpute">jomoImpute</a></code>, <code><a href="#topic+mitmlComplete">mitmlComplete</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

# write imputation files, index file, and log file
write.mitmlMplus(imp, filename = "imputation", suffix = "list", na.value = -999)

## End(Not run)
</code></pre>

<hr>
<h2 id='write.mitmlSAV'>Write <code>mitml</code> objects to native SPSS format</h2><span id='topic+write.mitmlSAV'></span>

<h3>Description</h3>

<p>Saves objects of class <code>mitml</code> in the <code>.sav</code> format used by the statistical software SPSS (IBM Corp., 2013).
The function serves as a front-end for <code>write_sav</code> from the <code>haven</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
write.mitmlSAV(x, filename)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.mitmlSAV_+3A_x">x</code></td>
<td>
<p>An object of class <code>mitml</code> or <code>mitml.list</code> as produced by <code>panImpute</code>, <code>jomoImpute</code>, <code>mitmlComplete</code>, or similar).</p>
</td></tr>
<tr><td><code id="write.mitmlSAV_+3A_filename">filename</code></td>
<td>
<p>Name of the destination file. The file extension (<code>.sav</code>) is appended if needed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exports multiply imputed data sets to a single <code>.sav</code> file, in which an <code>Imputation_</code> variable separates the original data and the various imputed data sets.
This allows exporting imputed data directly to the native SPSS format.
</p>
<p>Alternatively, <code><a href="#topic+write.mitmlSPSS">write.mitmlSPSS</a></code> may be used for creating separate text and SPSS syntax files, which offers more control over the data format.
</p>


<h3>Value</h3>

<p>None (invisible <code>NULL</code>).
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>References</h3>

<p>IBM Corp. (2013). <em>IBM SPSS Statistics for Windows, Version 22.0</em>. Armonk, NY: IBM Corp
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panImpute">panImpute</a></code>, <code><a href="#topic+jomoImpute">jomoImpute</a></code>, <code><a href="#topic+mitmlComplete">mitmlComplete</a></code>, <code><a href="#topic+write.mitmlSPSS">write.mitmlSPSS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

# write data file and SPSS syntax
write.mitmlSAV(imp, filename = "imputation")

## End(Not run)
</code></pre>

<hr>
<h2 id='write.mitmlSPSS'>Write <code>mitml</code> objects to SPSS compatible format</h2><span id='topic+write.mitmlSPSS'></span>

<h3>Description</h3>

<p>Saves objects of class <code>mitml</code> as a text and a syntax file which can be processed by the statistical software SPSS (IBM Corp., 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
write.mitmlSPSS(x, filename, sep = "\t", dec = ".", na.value = -999, syntax = TRUE,
  locale = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.mitmlSPSS_+3A_x">x</code></td>
<td>
<p>An object of class <code>mitml</code> or <code>mitml.list</code> as produced by <code>panImpute</code>, <code>jomoImpute</code>, <code>mitmlComplete</code>, or similar).</p>
</td></tr>
<tr><td><code id="write.mitmlSPSS_+3A_filename">filename</code></td>
<td>
<p>File base name of the data and syntax files, specified without file extension.</p>
</td></tr>
<tr><td><code id="write.mitmlSPSS_+3A_sep">sep</code></td>
<td>
<p>The field separator.</p>
</td></tr>
<tr><td><code id="write.mitmlSPSS_+3A_dec">dec</code></td>
<td>
<p>The decimal separator.</p>
</td></tr>
<tr><td><code id="write.mitmlSPSS_+3A_na.value">na.value</code></td>
<td>
<p>A numeric value coding the missing data in the resulting data file.</p>
</td></tr>
<tr><td><code id="write.mitmlSPSS_+3A_syntax">syntax</code></td>
<td>
<p>A logical flag indicating if an SPSS syntax file should be generated. This file contains instructions for SPSS for reading in the data file. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="write.mitmlSPSS_+3A_locale">locale</code></td>
<td>
<p>(optional) A character string specifying the localization to be used in SPSS (e.g., <code>"en_US"</code>, <code>"de_DE"</code>; see 'Details').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In SPSS, multiply imputed data are contained in a single file, in which an <code>Imputation_</code> variable separates the original data and the various imputed data sets.
During export, factors are converted to numeric, whereas character variables are left &ldquo;as is&rdquo;.
</p>
<p>By default, <code>write.mitmlSPSS</code> generates a raw text file containing the data, along with a syntax file containing instructions for SPSS.
This syntax file mimics SPSS's functionality to read text files with sensible settings.
In order to read in the data, the syntax file must be opened and executed using SPSS, or open using the GUI.
Manual changes to the syntax file can be required, for example, if the file path of the data file is not correctly represented in the syntax.
The <code>locale</code> argument can be used to ensure that SPSS reads the data in the correct locale.
</p>
<p>Alternatively, <code><a href="#topic+write.mitmlSAV">write.mitmlSAV</a></code> may be used for exporting directly to the SPSS native <code>.sav</code> format.
</p>


<h3>Value</h3>

<p>None (invisible <code>NULL</code>).
</p>


<h3>Author(s)</h3>

<p>Simon Grund</p>


<h3>References</h3>

<p>IBM Corp. <em>IBM SPSS Statistics for Windows</em>. Armonk, NY: IBM Corp
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panImpute">panImpute</a></code>, <code><a href="#topic+jomoImpute">jomoImpute</a></code>, <code><a href="#topic+mitmlComplete">mitmlComplete</a></code>, <code><a href="#topic+write.mitmlSAV">write.mitmlSAV</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(studentratings)

fml &lt;- ReadDis + SES ~ ReadAchiev + (1|ID)
imp &lt;- panImpute(studentratings, formula = fml, n.burn = 1000, n.iter = 100, m = 5)

# write data file and SPSS syntax
write.mitmlSPSS(imp, filename = "imputation", sep = "\t", dec = ".",
                na.value = -999, locale = "en_US")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
