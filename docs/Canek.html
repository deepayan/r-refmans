<!DOCTYPE html><html lang="en"><head><title>Help for package Canek</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Canek}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Canek-package'><p>Canek: Batch Correction of Single Cell Transcriptome Data</p></a></li>
<li><a href='#CheckZeroCV'><p>CheckZeroCV</p></a></li>
<li><a href='#CorrectBatch'><p>CorrectBatch</p></a></li>
<li><a href='#CorrectBatches'><p>CorrectBatches</p></a></li>
<li><a href='#EkfBE'><p>Correction vector estimation</p></a></li>
<li><a href='#Fuzzy'><p>Title Fuzzy</p></a></li>
<li><a href='#MeanBE'><p>MeanBE</p></a></li>
<li><a href='#MedianBE'><p>Correction vector estimation</p></a></li>
<li><a href='#PairsFiltering'><p>Title PairsFiltering</p></a></li>
<li><a href='#RunCanek'><p>RunCanek</p></a></li>
<li><a href='#SimBatches'><p>Dataset with simulated single cell RNA-seq from 2 batches.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Batch Correction of Single Cell Transcriptome Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Non-linear/linear hybrid method for batch-effect correction
    that uses Mutual Nearest Neighbors (MNNs) to identify similar cells between 
    datasets. Reference: Loza M. et al. (NAR Genomics and Bioinformatics, 2020) &lt;<a href="https://doi.org/10.1093%2Fnargab%2Flqac022">doi:10.1093/nargab/lqac022</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>FNN, irlba, numbers, fpc, bluster, igraph, matrixStats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), Seurat, SingleCellExperiment,
SummarizedExperiment, scater, batchelor, scran, knitr,
rmarkdown, patchwork, ggplot2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://martinloza.github.io/Canek/">https://martinloza.github.io/Canek/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MartinLoza/Canek/issues">https://github.com/MartinLoza/Canek/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-08 05:07:41 UTC; martin</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Loza <a href="https://orcid.org/0000-0002-3342-2643"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Diego Diez <a href="https://orcid.org/0000-0002-2325-4893"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Loza &lt;martin.loza.lopez@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Canek-package'>Canek: Batch Correction of Single Cell Transcriptome Data</h2><span id='topic+Canek'></span><span id='topic+Canek-package'></span>

<h3>Description</h3>

<p>Non-linear/linear hybrid method for batch-effect correction that uses Mutual Nearest Neighbors (MNNs) to identify similar cells between datasets. Reference: Loza M. et al. (NAR Genomics and Bioinformatics, 2020) doi: <a href="https://doi.org/10.1093/nargab/lqac022">10.1093/nargab/lqac022</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin Loza <a href="mailto:martin.loza.lopez@gmail.com">martin.loza.lopez@gmail.com</a> (<a href="https://orcid.org/0000-0002-3342-2643">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Diego Diez <a href="mailto:diego10ruiz@gmail.com">diego10ruiz@gmail.com</a> (<a href="https://orcid.org/0000-0002-2325-4893">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://martinloza.github.io/Canek/">https://martinloza.github.io/Canek/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/MartinLoza/Canek/issues">https://github.com/MartinLoza/Canek/issues</a>
</p>
</li></ul>


<hr>
<h2 id='CheckZeroCV'>CheckZeroCV</h2><span id='topic+CheckZeroCV'></span>

<h3>Description</h3>

<p>CheckZeroCV
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckZeroCV(
  MST = NULL,
  cluMem = NULL,
  corGene = NULL,
  fuzzyPCA = fuzzyPCA,
  memCorrData = NULL,
  zeroCorrection = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckZeroCV_+3A_mst">MST</code></td>
<td>
<p>Minimum Spanning Tree</p>
</td></tr>
<tr><td><code id="CheckZeroCV_+3A_clumem">cluMem</code></td>
<td>
<p>Clusters used on MST</p>
</td></tr>
<tr><td><code id="CheckZeroCV_+3A_corgene">corGene</code></td>
<td>
<p>Data to correct</p>
</td></tr>
<tr><td><code id="CheckZeroCV_+3A_fuzzypca">fuzzyPCA</code></td>
<td>
<p>Number of PCs to use in the fuzzy process.</p>
</td></tr>
<tr><td><code id="CheckZeroCV_+3A_memcorrdata">memCorrData</code></td>
<td>
<p>Data to correct</p>
</td></tr>
<tr><td><code id="CheckZeroCV_+3A_zerocorrection">zeroCorrection</code></td>
<td>
<p>Vector indicating which membership has a zero correction vector</p>
</td></tr>
</table>

<hr>
<h2 id='CorrectBatch'>CorrectBatch</h2><span id='topic+CorrectBatch'></span>

<h3>Description</h3>

<p>Batch effect correction on two single-cell batches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CorrectBatch(
  refBatch,
  queBatch,
  cnRef = NULL,
  cnQue = NULL,
  queNumCelltypes = NULL,
  maxMem = 5,
  pairs = NULL,
  kNN = 30,
  sampling = FALSE,
  numSamples = NULL,
  idxQuery = NULL,
  idxRef = NULL,
  pcaDim = 50,
  perCellMNN = 0.08,
  fuzzy = TRUE,
  fuzzyPCA = 10,
  estMethod = "Median",
  clusterMethod = "louvain",
  pairsFilter = FALSE,
  doCosNorm = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CorrectBatch_+3A_refbatch">refBatch</code></td>
<td>
<p>Reference batch.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_quebatch">queBatch</code></td>
<td>
<p>Query batch (batch to correct).</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_cnref">cnRef</code></td>
<td>
<p>Cosine normalization of the reference batch.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_cnque">cnQue</code></td>
<td>
<p>Cosine normalization of the query batch.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_quenumcelltypes">queNumCelltypes</code></td>
<td>
<p>Number of cell types in the query batch. By default Canek searches the number of cell
types using an heuristic algorithm. Change this parameter if you know the number of cell types in advanced.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_maxmem">maxMem</code></td>
<td>
<p>Maximum number of memberships from the query batch. This parameter is used on the
heuristic algorithm to find the number of cell types.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_pairs">pairs</code></td>
<td>
<p>A numerical matrix containing MNNs pairs cell indexes. First column corresponds to query batch cell indexes.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_knn">kNN</code></td>
<td>
<p>Number of k-nearest-neighbors used to define the MNNs pairs.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_sampling">sampling</code></td>
<td>
<p>Use MNNs pairs sampling when using a Kalman filter to estimate the correction vector.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_numsamples">numSamples</code></td>
<td>
<p>If sampling. Number of MNNs pairs samples to use on the estimation process.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_idxquery">idxQuery</code></td>
<td>
<p>Numerical vector indicating the index of the cells from the query batch to use
on the correction vector estimation.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_idxref">idxRef</code></td>
<td>
<p>Numerical vector indicating the index of the cells from the reference batch to use
on the correction vector estimation.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_pcadim">pcaDim</code></td>
<td>
<p>Number of PCA dimensions to use.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_percellmnn">perCellMNN</code></td>
<td>
<p>Threshold value to decide if a membership's correction value is calculated.
As a rough interpretation, this values can be thought as the proportion of cells from a membership
with an associated MNN pair. If the proportion is low, an specific correction vectors is
not calculated for this membership.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_fuzzy">fuzzy</code></td>
<td>
<p>Use fuzzy logic to join the local correction vectors.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_fuzzypca">fuzzyPCA</code></td>
<td>
<p>Number of PCs to use in the fuzzy process.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_estmethod">estMethod</code></td>
<td>
<p>Method to use when estimating the correction vectors:
</p>

<ul>
<li><p>Median. Use the cells median distance.
</p>
</li>
<li><p>EKF. Use an extended Kalman filter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_clustermethod">clusterMethod</code></td>
<td>
<p>Method used to identify memberships.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_pairsfilter">pairsFilter</code></td>
<td>
<p>Filter MNNs pairs before estimating the correction vectors. If TRUE,
the pairs are filtered from outliers using an interquartile range method.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_docosnorm">doCosNorm</code></td>
<td>
<p>Whether to do cosine normalization.</p>
</td></tr>
<tr><td><code id="CorrectBatch_+3A_verbose">verbose</code></td>
<td>
<p>Print output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CorrectBatch is a method to correct batch-effect from two single-cell batches.
Batch-effects observations are defined using mutual nearest neighbors (MNNs) pairs and cell
groups from the query batch are distinguished using clustering. We estimate a correction vector
for each cluster using its MNNs pairs and use these vectors to remove the batch effect from the query batch in two ways:
</p>

<ul>
<li><p>A linear correction is performed by equally correcting the cells from the same cluster.
</p>
</li>
<li><p>A non-linear correction is performed by differently correcting each cell using fuzzy logic.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing the input batches, the corrected query batch, and the correction data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- SimBatches$batches[[1]]
y &lt;- SimBatches$batches[[2]]
z &lt;- CorrectBatch(x, y)
Corrected &lt;- z$`Corrected Query Batch`

Uncorrected_PCA &lt;- prcomp(t(cbind(x,y)))
plot(Uncorrected_PCA$x[,1:2])
Corrected_PCA &lt;- prcomp(t(cbind(x,z$`Corrected Query Batch`)))
plot(Corrected_PCA$x[,1:2])

</code></pre>

<hr>
<h2 id='CorrectBatches'>CorrectBatches</h2><span id='topic+CorrectBatches'></span>

<h3>Description</h3>

<p>Batch-effect correction over a list of single cell batches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CorrectBatches(
  lsBatches,
  hierarchical = TRUE,
  queNumCelltypes = NULL,
  maxMem = 5,
  sampling = FALSE,
  numSamples = NULL,
  kNN = 30,
  pcaDim = 50,
  pairsFilter = FALSE,
  perCellMNN = 0.08,
  fuzzy = TRUE,
  fuzzyPCA = 10,
  estMethod = "Median",
  clusterMethod = "louvain",
  doCosNorm = FALSE,
  fracSampling = NULL,
  debug = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CorrectBatches_+3A_lsbatches">lsBatches</code></td>
<td>
<p>List of batches to integrate. Batches should contain the same number of genes as rows.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_hierarchical">hierarchical</code></td>
<td>
<p>Use hierarchical integration scheme when correcting more than two batches.
If set to FALSE, the input batches are sorted by number of cells and integrated on descending order.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_quenumcelltypes">queNumCelltypes</code></td>
<td>
<p>Number of cell types in the query batch. By default Canek searches the number of
cell types using an heuristic algorithm. Change this parameter if you know the number of cell types in advanced.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_maxmem">maxMem</code></td>
<td>
<p>Maximum number of memberships from the query batch. This parameter is used on the heuristic algorithm to find the number of cell types.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_sampling">sampling</code></td>
<td>
<p>Use MNNs pairs sampling when using a Kalman filter to estimate the correction vector.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_numsamples">numSamples</code></td>
<td>
<p>If sampling. Number of MNNs pairs samples to use on the estimation process.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_knn">kNN</code></td>
<td>
<p>Number of k-nearest-neighbors used to define the MNNs pairs.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_pcadim">pcaDim</code></td>
<td>
<p>Number of PCA dimensions to use.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_pairsfilter">pairsFilter</code></td>
<td>
<p>Filter MNNs pairs before estimating the correction vectors. If TRUE,
the pairs are filtered from outliers using an interquartile range method.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_percellmnn">perCellMNN</code></td>
<td>
<p>Threshold value to decide if a membership's correction value is calculated.
As a rough interpretation, this values can be thought as the proportion of cells from a membership
with an associated MNN pair. If the proportion is low, an specific correction vectors is
not calculated for this membership.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_fuzzy">fuzzy</code></td>
<td>
<p>Use fuzzy logic to join the local correction vectors.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_fuzzypca">fuzzyPCA</code></td>
<td>
<p>Number of PCs to use in the fuzzy process.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_estmethod">estMethod</code></td>
<td>
<p>Method to use when estimating the correction vectors:
</p>

<ul>
<li><p>Median. Use the cells median distance
</p>
</li>
<li><p>EKF. Use an extended Kalman filter
</p>
</li></ul>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_clustermethod">clusterMethod</code></td>
<td>
<p>Method used to identify memberships.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_docosnorm">doCosNorm</code></td>
<td>
<p>Whether to do cosine normalization.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_fracsampling">fracSampling</code></td>
<td>
<p>Fraction of cells to sample in the hierarchical selection (default is NULL, no sampling).</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_debug">debug</code></td>
<td>
<p>Return correction's information</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_verbose">verbose</code></td>
<td>
<p>Print output.</p>
</td></tr>
<tr><td><code id="CorrectBatches_+3A_...">...</code></td>
<td>
<p>Pass down methods from RunCanek().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CorrectBatches is a method to correct batch-effect from two or more single-cell batches.
Batch-effects observations are defined using mutual nearest neighbors (MNNs) pairs and cell
groups from the query batch are distinguished using clustering. We estimate a correction vector
for each cluster using its MNNs pairs and use these vectors to remove the batch effect from the query batch in two ways:
</p>

<ul>
<li><p>A linear correction is performed by equally correcting the cells from the same cluster.
</p>
</li>
<li><p>A non-linear correction is performed by differently correcting each cell using fuzzy logic.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing the integrated datasets as matrix and the correction data .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Batches &lt;- SimBatches$batches
z &lt;- CorrectBatches(Batches)

Uncorrected_PCA &lt;- prcomp(t(cbind(Batches[[1]], Batches[[2]])))
plot(Uncorrected_PCA$x[,1:2])
Corrected_PCA &lt;- prcomp(t(z))
plot(Corrected_PCA$x[,1:2])

</code></pre>

<hr>
<h2 id='EkfBE'>Correction vector estimation</h2><span id='topic+EkfBE'></span>

<h3>Description</h3>

<p>Batch effect estimation using an extended Kalman filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EkfBE(
  refBatch,
  queBatch,
  pairs,
  sampling = FALSE,
  numSamples = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EkfBE_+3A_refbatch">refBatch</code></td>
<td>
<p>Reference batch.</p>
</td></tr>
<tr><td><code id="EkfBE_+3A_quebatch">queBatch</code></td>
<td>
<p>Query batch.</p>
</td></tr>
<tr><td><code id="EkfBE_+3A_pairs">pairs</code></td>
<td>
<p>A numerical matrix containing MNNs pairs cell indexes. First column corresponds to query batch cells.</p>
</td></tr>
<tr><td><code id="EkfBE_+3A_sampling">sampling</code></td>
<td>
<p>Sample MNNs pairs.</p>
</td></tr>
<tr><td><code id="EkfBE_+3A_numsamples">numSamples</code></td>
<td>
<p>If sampling, number of MNNs pairs samples to use on the estimation process.</p>
</td></tr>
<tr><td><code id="EkfBE_+3A_verbose">verbose</code></td>
<td>
<p>Print output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input batches must have the same number of genes. The model used on the estimation has the form of g_ref = g_que + be, where
the batch effect is represented as a value added to the reference gene expression, causing a linear deviation between the reference and
the query batches.
</p>


<h3>Value</h3>

<p>A list containing the estimated correction vector and the estimation data.
The length of the correction vector is equal to the number of genes.
</p>

<hr>
<h2 id='Fuzzy'>Title Fuzzy</h2><span id='topic+Fuzzy'></span>

<h3>Description</h3>

<p>Function to score cell's memberships by fuzzy logic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fuzzy(
  cluMem = NULL,
  pcaQue = NULL,
  corCell = NULL,
  fuzzyPCA = 10,
  MST = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fuzzy_+3A_clumem">cluMem</code></td>
<td>
<p>Memberships' clustering data.</p>
</td></tr>
<tr><td><code id="Fuzzy_+3A_pcaque">pcaQue</code></td>
<td>
<p>PCA representation of the cells.</p>
</td></tr>
<tr><td><code id="Fuzzy_+3A_corcell">corCell</code></td>
<td>
<p>Matrix containing the initial membership assignment.
Matrix dimensions are expected as #Cell x #Memberships, with each row sum equal to 1.</p>
</td></tr>
<tr><td><code id="Fuzzy_+3A_fuzzypca">fuzzyPCA</code></td>
<td>
<p>Number of PCs to use in the fuzzy process.</p>
</td></tr>
<tr><td><code id="Fuzzy_+3A_mst">MST</code></td>
<td>
<p>Minimum spanning tree</p>
</td></tr>
<tr><td><code id="Fuzzy_+3A_verbose">verbose</code></td>
<td>
<p>Print output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function perform the fuzzification for the cells' membership.
A minimum spanning tree (MST) is created among memberships, and the fuzzification is performed
for each of the edges of the MST.#'
</p>

<hr>
<h2 id='MeanBE'>MeanBE</h2><span id='topic+MeanBE'></span>

<h3>Description</h3>

<p>Batch effect estimation using the MNNs pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeanBE(refBatch, queBatch, pairs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MeanBE_+3A_refbatch">refBatch</code></td>
<td>
<p>Reference batch.</p>
</td></tr>
<tr><td><code id="MeanBE_+3A_quebatch">queBatch</code></td>
<td>
<p>Query batch.</p>
</td></tr>
<tr><td><code id="MeanBE_+3A_pairs">pairs</code></td>
<td>
<p>A numerical matrix containing MNNs pairs cell indexes. First column corresponds to query batch cells.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input batches must have the same number of genes. The model used on the estimation has the form of g_ref = g_que + be, where
the batch effect is represented as a value added to the reference gene expression. The batch effect is estimated as
the median of the gene expression difference among the reference and the query batch, e.g. Median(g_ref - g_que).
</p>


<h3>Value</h3>

<p>A list containing the estimated correction vector and the estimation data.
The length of the correction vector is equal to the number of genes.
</p>

<hr>
<h2 id='MedianBE'>Correction vector estimation</h2><span id='topic+MedianBE'></span>

<h3>Description</h3>

<p>Batch effect estimation using the MNNs pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MedianBE(refBatch, queBatch, pairs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MedianBE_+3A_refbatch">refBatch</code></td>
<td>
<p>Reference batch.</p>
</td></tr>
<tr><td><code id="MedianBE_+3A_quebatch">queBatch</code></td>
<td>
<p>Query batch.</p>
</td></tr>
<tr><td><code id="MedianBE_+3A_pairs">pairs</code></td>
<td>
<p>A numerical matrix containing MNNs pairs cell indexes. First column corresponds to query batch cells.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input batches must have the same number of genes. The model used on the estimation has the form of g_ref = g_que + be, where
the batch effect is represented as a value added to the reference gene expression. The batch effect is estimated as
the median of the gene expression difference among the reference and the query batch, e.g. Median(g_ref - g_que).
</p>


<h3>Value</h3>

<p>A list containing the estimated correction vector and the estimation data.
The length of the correction vector is equal to the number of genes.
</p>

<hr>
<h2 id='PairsFiltering'>Title PairsFiltering</h2><span id='topic+PairsFiltering'></span>

<h3>Description</h3>

<p>Function to filter MNNs pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PairsFiltering(refBatch, queBatch, pairs, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PairsFiltering_+3A_refbatch">refBatch</code></td>
<td>
<p>Reference batch single-cell data.</p>
</td></tr>
<tr><td><code id="PairsFiltering_+3A_quebatch">queBatch</code></td>
<td>
<p>Query's batch single-cell data.</p>
</td></tr>
<tr><td><code id="PairsFiltering_+3A_pairs">pairs</code></td>
<td>
<p>A matrix containing MNNs pairs. First column corresponds to query-batch cell indexes.</p>
</td></tr>
<tr><td><code id="PairsFiltering_+3A_verbose">verbose</code></td>
<td>
<p>Print output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Filter MNN pairs by quantiles.
</p>


<h3>Value</h3>

<p>A matrix containing the filtered pairs. First column corresponds to query-batch cell indexes.
</p>

<hr>
<h2 id='RunCanek'>RunCanek</h2><span id='topic+RunCanek'></span><span id='topic+RunCanek.Seurat'></span><span id='topic+RunCanek.SingleCellExperiment'></span><span id='topic+RunCanek.list'></span>

<h3>Description</h3>

<p>Runs Canek integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunCanek(x, ...)

## S3 method for class 'Seurat'
RunCanek(
  x,
  batches = NULL,
  slot = "data",
  assay = NULL,
  features = NULL,
  selection.method = "vst",
  nfeatures = 2000,
  fvf.nfeatures = 2000,
  integration.name = "Canek",
  debug = FALSE,
  ...
)

## S3 method for class 'SingleCellExperiment'
RunCanek(
  x,
  batches = NULL,
  assay = "logcounts",
  integration.name = "Canek",
  debug = FALSE,
  ...
)

## S3 method for class 'list'
RunCanek(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RunCanek_+3A_x">x</code></td>
<td>
<p>object with expression counts or list of matrices.</p>
</td></tr>
<tr><td><code id="RunCanek_+3A_...">...</code></td>
<td>
<p>additional arguments passed down to methods.</p>
</td></tr>
<tr><td><code id="RunCanek_+3A_batches">batches</code></td>
<td>
<p>for S4 objects the column containing batch information.</p>
</td></tr>
<tr><td><code id="RunCanek_+3A_slot">slot</code></td>
<td>
<p>slot used for Seurat objects (default: data).</p>
</td></tr>
<tr><td><code id="RunCanek_+3A_assay">assay</code></td>
<td>
<p>assay used for Seurat objects.</p>
</td></tr>
<tr><td><code id="RunCanek_+3A_features">features</code></td>
<td>
<p>optional vector of features to use for correction.</p>
</td></tr>
<tr><td><code id="RunCanek_+3A_selection.method">selection.method</code></td>
<td>
<p>method used for FindVariableFeatures on Seurat objects when features is NULL.</p>
</td></tr>
<tr><td><code id="RunCanek_+3A_nfeatures">nfeatures</code></td>
<td>
<p>number of features returned by SelectIntegrationFeatures.</p>
</td></tr>
<tr><td><code id="RunCanek_+3A_fvf.nfeatures">fvf.nfeatures</code></td>
<td>
<p>number of features returned by FindVariableFeatures.</p>
</td></tr>
<tr><td><code id="RunCanek_+3A_integration.name">integration.name</code></td>
<td>
<p>name for the integrated assay.</p>
</td></tr>
<tr><td><code id="RunCanek_+3A_debug">debug</code></td>
<td>
<p>whether to store information about correction vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the appropriate type.
</p>

<hr>
<h2 id='SimBatches'>Dataset with simulated single cell RNA-seq from 2 batches.</h2><span id='topic+SimBatches'></span>

<h3>Description</h3>

<p>Dataset with simulated single cell RNA-seq from 2 batches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimBatches
</code></pre>


<h3>Format</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>batches</dt><dd><p>a list with two matrices representing the two batches</p>
</dd>
<dt>pairs</dt><dd><p>matrix of pairs between the two batches.</p>
</dd>
<dt>cell_types</dt><dd><p>a factor with the cell clusters.</p>
</dd>
</dl>
<p>...

</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
