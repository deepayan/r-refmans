<!DOCTYPE html><html><head><title>Help for package phangorn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phangorn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acctran'><p>Parsimony tree.</p></a></li>
<li><a href='#add_ci'><p>Draw Confidences Intervals on Phylogenies</p></a></li>
<li><a href='#add_edge_length'><p>Assign and compute edge lengths from a sample of trees</p></a></li>
<li><a href='#add.tips'><p>Add tips to a tree</p></a></li>
<li><a href='#addConfidences'><p>Compare splits and add support values to an object</p></a></li>
<li><a href='#allSplits'><p>Splits representation of graphs and trees.</p></a></li>
<li><a href='#allTrees'><p>Compute all trees topologies.</p></a></li>
<li><a href='#Ancestors'><p>tree utility function</p></a></li>
<li><a href='#ancestral.pml'><p>Ancestral character reconstruction.</p></a></li>
<li><a href='#as.networx'><p>Conversion among phylogenetic network objects</p></a></li>
<li><a href='#as.pml'><p>Likelihood of a tree.</p></a></li>
<li><a href='#bab'><p>Branch and bound for finding all most parsimonious trees</p></a></li>
<li><a href='#baseFreq'><p>Summaries of alignments</p></a></li>
<li><a href='#bootstrap.pml'><p>Bootstrap</p></a></li>
<li><a href='#chloroplast'><p>Chloroplast alignment</p></a></li>
<li><a href='#CI'><p>Consistency Index and Retention Index</p></a></li>
<li><a href='#cladePar'><p>Utility function to plot.phylo</p></a></li>
<li><a href='#coalSpeciesTree'><p>Species Tree</p></a></li>
<li><a href='#codonTest'><p>codonTest</p></a></li>
<li><a href='#consensusNet'><p>Computes a consensusNetwork from a list of trees Computes a <code>networx</code></p>
object from a collection of splits.</a></li>
<li><a href='#cophenetic.networx'><p>Pairwise Distances from a Phylogenetic Network</p></a></li>
<li><a href='#delta.score'><p>Computes the <code class="reqn">\delta</code> score</p></a></li>
<li><a href='#densiTree'><p>Plots a densiTree.</p></a></li>
<li><a href='#designTree'><p>Compute a design matrix or non-negative LS</p></a></li>
<li><a href='#discrete.gamma'><p>Discrete Gamma and Beta distribution</p></a></li>
<li><a href='#dist.hamming'><p>Pairwise Distances from Sequences</p></a></li>
<li><a href='#dist.p'><p>Pairwise Polymorphism P-Distances from DNA Sequences</p></a></li>
<li><a href='#distanceHadamard'><p>Distance Hadamard</p></a></li>
<li><a href='#dna2codon'><p>Translate nucleic acid sequences into codons</p></a></li>
<li><a href='#getClans'><p>Clans, slices and clips</p></a></li>
<li><a href='#getRoot'><p>Tree manipulation</p></a></li>
<li><a href='#hadamard'><p>Hadamard Matrices and Fast Hadamard Multiplication</p></a></li>
<li><a href='#identify.networx'><p>Identify splits in a network</p></a></li>
<li><a href='#image.phyDat'><p>Plot of a Sequence Alignment</p></a></li>
<li><a href='#Laurasiatherian'><p>Laurasiatherian data (AWCMEE)</p></a></li>
<li><a href='#ldfactorial'><p>Arithmetic Operators</p></a></li>
<li><a href='#lento'><p>Lento plot</p></a></li>
<li><a href='#lli'><p>Internal maximum likelihood functions.</p></a></li>
<li><a href='#mast'><p>Maximum agreement subtree</p></a></li>
<li><a href='#maxCladeCred'><p>Maximum clade credibility tree</p></a></li>
<li><a href='#mites'><p>Morphological characters of Mites (Sch√§ffer et al. 2010)</p></a></li>
<li><a href='#modelTest'><p>ModelTest</p></a></li>
<li><a href='#multiphyDat2pmlPart'><p>Partition model.</p></a></li>
<li><a href='#neighborNet'><p>Computes a neighborNet from a distance matrix</p></a></li>
<li><a href='#NJ'><p>Neighbor-Joining</p></a></li>
<li><a href='#nni'><p>Tree rearrangements.</p></a></li>
<li><a href='#phangorn-package'><p>phangorn: Phylogenetic Reconstruction and Analysis</p></a></li>
<li><a href='#phyDat'><p>Conversion among Sequence Formats</p></a></li>
<li><a href='#plot.networx'><p>plot phylogenetic networks</p></a></li>
<li><a href='#plotBS'><p>Plotting trees with bootstrap values</p></a></li>
<li><a href='#pml_bb'><p>Likelihood of a tree.</p></a></li>
<li><a href='#pml.control'><p>Auxiliary for Controlling Fitting</p></a></li>
<li><a href='#pmlCluster'><p>Stochastic Partitioning</p></a></li>
<li><a href='#pmlMix'><p>Phylogenetic mixture model</p></a></li>
<li><a href='#print.phyDat'><p>Generic functions for class phyDat</p></a></li>
<li><a href='#read.aa'><p>Read Amino Acid Sequences in a File</p></a></li>
<li><a href='#read.nexus.splits'><p>Function to import and export splits and networks</p></a></li>
<li><a href='#read.phyDat'><p>Import and export sequence alignments</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#SH.test'><p>Shimodaira-Hasegawa Test</p></a></li>
<li><a href='#simSeq'><p>Simulate sequences.</p></a></li>
<li><a href='#SOWH.test'><p>Swofford-Olsen-Waddell-Hillis Test</p></a></li>
<li><a href='#splitsNetwork'><p>Phylogenetic Network</p></a></li>
<li><a href='#superTree'><p>Super Tree methods</p></a></li>
<li><a href='#threshStateC'><p>Internal phangorn Functions</p></a></li>
<li><a href='#transferBootstrap'><p>Transfer Bootstrap</p></a></li>
<li><a href='#treedist'><p>Distances between trees</p></a></li>
<li><a href='#upgma'><p>UPGMA and WPGMA</p></a></li>
<li><a href='#writeDist'><p>Writing and reading distances in phylip and nexus format</p></a></li>
<li><a href='#yeast'><p>Yeast alignment (Rokas et al.)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Phylogenetic Reconstruction and Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.11.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows for estimation of phylogenetic trees and networks
    using Maximum Likelihood, Maximum Parsimony, distance methods and
    Hadamard conjugation (Schliep 2011). Offers methods for tree comparison, 
    model selection and visualization of phylogenetic networks as described in
    Schliep et al. (2017).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/KlausVigo/phangorn">https://github.com/KlausVigo/phangorn</a>,
<a href="https://klausvigo.github.io/phangorn/">https://klausvigo.github.io/phangorn/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/KlausVigo/phangorn/issues">https://github.com/KlausVigo/phangorn/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>ape (&ge; 5.6), R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, fastmatch, generics, graphics, grDevices, igraph (&ge;
1.0), Matrix, methods, parallel, quadprog, Rcpp, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Biostrings, knitr, magick, rgl, rmarkdown, seqinr, seqLogo,
tinytest, xtable</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, utils</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Software, Technology, QualityControl</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-22 23:45:05 UTC; klaus</td>
</tr>
<tr>
<td>Author:</td>
<td>Klaus Schliep <a href="https://orcid.org/0000-0003-2941-0161"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Emmanuel Paradis <a href="https://orcid.org/0000-0003-3092-2199"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Leonardo de Oliveira Martins
    <a href="https://orcid.org/0000-0001-5247-1320"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Alastair Potts [aut],
  Iris Bardel-Kahr <a href="https://orcid.org/0000-0002-8950-834X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Tim W. White [ctb],
  Cyrill Stachniss [ctb],
  Michelle Kendall [ctb],
  Keren Halabi [ctb],
  Richel Bilderbeek [ctb],
  Kristin Winchell [ctb],
  Liam Revell [ctb],
  Mike Gilchrist [ctb],
  Jeremy Beaulieu [ctb],
  Brian O'Meara [ctb],
  Long Qu [ctb],
  Joseph Brown <a href="https://orcid.org/0000-0002-3835-8062"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Santiago Claramunt <a href="https://orcid.org/0000-0002-8926-5974"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Klaus Schliep &lt;klaus.schliep@gmail.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-23 10:10:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:51:06 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='acctran'>Parsimony tree.</h2><span id='topic+acctran'></span><span id='topic+fitch'></span><span id='topic+random.addition'></span><span id='topic+parsimony'></span><span id='topic+optim.parsimony'></span><span id='topic+sankoff'></span><span id='topic+pratchet'></span>

<h3>Description</h3>

<p><code>parsimony</code> returns the parsimony score of a tree using either the
sankoff or the fitch algorithm. <code>optim.parsimony</code> tries to find the
maximum parsimony tree using either Nearest Neighbor Interchange (NNI)
rearrangements or sub tree pruning and regrafting (SPR). <code>pratchet</code>
implements the parsimony ratchet (Nixon, 1999) and is the preferred way to
search for the best tree.  <code>random.addition</code> can be used to produce
starting trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acctran(tree, data)

fitch(tree, data, site = "pscore")

random.addition(data, tree = NULL, method = "fitch")

parsimony(tree, data, method = "fitch", cost = NULL, site = "pscore")

optim.parsimony(tree, data, method = "fitch", cost = NULL, trace = 1,
  rearrangements = "SPR", ...)

pratchet(data, start = NULL, method = "fitch", maxit = 1000,
  minit = 100, k = 10, trace = 1, all = FALSE,
  rearrangements = "SPR", perturbation = "ratchet", ...)

sankoff(tree, data, cost = NULL, site = "pscore")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acctran_+3A_tree">tree</code></td>
<td>
<p>tree to start the nni search from.</p>
</td></tr>
<tr><td><code id="acctran_+3A_data">data</code></td>
<td>
<p>A object of class phyDat containing sequences.</p>
</td></tr>
<tr><td><code id="acctran_+3A_site">site</code></td>
<td>
<p>return either 'pscore' or 'site' wise parsimony scores.</p>
</td></tr>
<tr><td><code id="acctran_+3A_method">method</code></td>
<td>
<p>one of 'fitch' or 'sankoff'.</p>
</td></tr>
<tr><td><code id="acctran_+3A_cost">cost</code></td>
<td>
<p>A cost matrix for the transitions between two states.</p>
</td></tr>
<tr><td><code id="acctran_+3A_trace">trace</code></td>
<td>
<p>defines how much information is printed during optimization.</p>
</td></tr>
<tr><td><code id="acctran_+3A_rearrangements">rearrangements</code></td>
<td>
<p>SPR or NNI rearrangements.</p>
</td></tr>
<tr><td><code id="acctran_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods (e.g.
model=&quot;sankoff&quot; and cost matrix).</p>
</td></tr>
<tr><td><code id="acctran_+3A_start">start</code></td>
<td>
<p>a starting tree can be supplied.</p>
</td></tr>
<tr><td><code id="acctran_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations in the ratchet.</p>
</td></tr>
<tr><td><code id="acctran_+3A_minit">minit</code></td>
<td>
<p>minimum number of iterations in the ratchet.</p>
</td></tr>
<tr><td><code id="acctran_+3A_k">k</code></td>
<td>
<p>number of rounds ratchet is stopped, when there is no improvement.</p>
</td></tr>
<tr><td><code id="acctran_+3A_all">all</code></td>
<td>
<p>return all equally good trees or just one of them.</p>
</td></tr>
<tr><td><code id="acctran_+3A_perturbation">perturbation</code></td>
<td>
<p>whether to use &quot;ratchet&quot;, &quot;random_addition&quot; or
&quot;stochastic&quot; (nni) for shuffling the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;SPR&quot; rearrangements are so far only available for the &quot;fitch&quot; method,
&quot;sankoff&quot; only uses &quot;NNI&quot;. The &quot;fitch&quot; algorithm only works correct for
binary trees.
</p>


<h3>Value</h3>

<p><code>parsimony</code> returns the maximum parsimony score (pscore).
<code>optim.parsimony</code> returns a tree after NNI rearrangements.
<code>pratchet</code> returns a tree or list of trees containing the best tree(s)
found during the search.  <code>acctran</code> returns a tree with edge length
according to the ACCTRAN criterion.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Felsenstein, J. (2004). <em>Inferring Phylogenies</em>. Sinauer
Associates, Sunderland.
</p>
<p>Nixon, K. (1999) The Parsimony Ratchet, a New Method for Rapid Parsimony
Analysis. <em>Cladistics</em> <b>15</b>, 407-414
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+bab">bab</a></code>, <code><a href="phangorn.html#topic+CI">CI</a></code>, <code><a href="phangorn.html#topic+RI">RI</a></code>,
<code><a href="phangorn.html#topic+ancestral.pml">ancestral.pml</a></code>, <code><a href="phangorn.html#topic+nni">nni</a></code>, <code><a href="phangorn.html#topic+NJ">NJ</a></code>,
<code><a href="phangorn.html#topic+pml">pml</a></code>, <code><a href="phangorn.html#topic+getClans">getClans</a></code>, <code><a href="phangorn.html#topic+ancestral.pars">ancestral.pars</a></code>,
<code><a href="phangorn.html#topic+bootstrap.pml">bootstrap.pml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(3)
data(Laurasiatherian)
dm &lt;- dist.hamming(Laurasiatherian)
tree &lt;- NJ(dm)
parsimony(tree, Laurasiatherian)
treeRA &lt;- random.addition(Laurasiatherian)
treeSPR &lt;- optim.parsimony(tree, Laurasiatherian)

# lower number of iterations for the example (to run less than 5 seconds),
# keep default values (maxit, minit, k) or increase them for real life
# analyses.
treeRatchet &lt;- pratchet(Laurasiatherian, start=tree, maxit=100,
                        minit=5, k=5, trace=0)
# assign edge length (number of substitutions)
treeRatchet &lt;- acctran(treeRatchet, Laurasiatherian)
# remove edges of length 0
treeRatchet &lt;- di2multi(treeRatchet)

plot(midpoint(treeRatchet))
add.scale.bar(0,0, length=100)

parsimony(c(tree,treeSPR, treeRatchet), Laurasiatherian)

</code></pre>

<hr>
<h2 id='add_ci'>Draw Confidences Intervals on Phylogenies</h2><span id='topic+add_ci'></span><span id='topic+add_boxplot'></span>

<h3>Description</h3>

<p>These are low-level plotting commands to draw the confidence
intervals on the node of a tree as rectangles with coloured backgrounds or
add boxplots to ultrametric or tipdated trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_ci(tree, trees, col95 = "#FF00004D", col50 = "#0000FF4D",
  height = 0.7, legend = TRUE, ...)

add_boxplot(tree, trees, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_ci_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree to which the confidences should be added.</p>
</td></tr>
<tr><td><code id="add_ci_+3A_trees">trees</code></td>
<td>
<p>phylogenetic trees, i.e. an object of class 'multiPhylo'</p>
</td></tr>
<tr><td><code id="add_ci_+3A_col95">col95</code></td>
<td>
<p>colour used for the 95
red.</p>
</td></tr>
<tr><td><code id="add_ci_+3A_col50">col50</code></td>
<td>
<p>colour used for the 50
blue.</p>
</td></tr>
<tr><td><code id="add_ci_+3A_height">height</code></td>
<td>
<p>the height of the boxes.</p>
</td></tr>
<tr><td><code id="add_ci_+3A_legend">legend</code></td>
<td>
<p>a logical value.</p>
</td></tr>
<tr><td><code id="add_ci_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions, <code><a href="graphics.html#topic+legend">legend</a></code> or
<code><a href="graphics.html#topic+bxp">bxp</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All trees should to be rooted, either ultrametric or tip dated.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis, Santiago Claramunt, Joseph Brown, Klaus Schliep
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>, <code><a href="phangorn.html#topic+plotBS">plotBS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Laurasiatherian")
dm &lt;- dist.hamming(Laurasiatherian)
tree &lt;- upgma(dm)
set.seed(123)
trees &lt;- bootstrap.phyDat(Laurasiatherian,
                          FUN=function(x)upgma(dist.hamming(x)), bs=100)
                          tree &lt;- plotBS(tree, trees, "phylogram")
tree &lt;- plotBS(tree, trees, "phylogram")
add_ci(tree, trees)
plot(tree, direction="downwards")
add_boxplot(tree, trees, boxwex=.7)
</code></pre>

<hr>
<h2 id='add_edge_length'>Assign and compute edge lengths from a sample of trees</h2><span id='topic+add_edge_length'></span>

<h3>Description</h3>

<p>This command can infer some average edge lengths and assign
them from a (bootstrap/MCMC) sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_edge_length(tree, trees, fun = function(x) median(na.omit(x)),
  rooted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_edge_length_+3A_tree">tree</code></td>
<td>
<p>tree where edge lengths are assigned to.</p>
</td></tr>
<tr><td><code id="add_edge_length_+3A_trees">trees</code></td>
<td>
<p>an object of class multiPhylo, where the average for the edges
is computed from.</p>
</td></tr>
<tr><td><code id="add_edge_length_+3A_fun">fun</code></td>
<td>
<p>a function to compute the average (default is median).</p>
</td></tr>
<tr><td><code id="add_edge_length_+3A_rooted">rooted</code></td>
<td>
<p>rooted logical, if FALSE edge lengths is a function of the
observed splits, if TRUE edge lengths are estimated from height for the
observed clades.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Schliep
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+node.depth.edgelength">node.depth.edgelength</a></code>, <code><a href="ape.html#topic+consensus">consensus</a></code>,
<code><a href="phangorn.html#topic+maxCladeCred">maxCladeCred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Laurasiatherian")
set.seed(123)
bs &lt;- bootstrap.phyDat(Laurasiatherian,
                FUN=function(x)upgma(dist.ml(x)), bs=100)
tree_compat &lt;- allCompat(bs, rooted=TRUE) |&gt;
              add_edge_length(bs)
plot(tree_compat)
add_boxplot(tree_compat, bs)
</code></pre>

<hr>
<h2 id='add.tips'>Add tips to a tree</h2><span id='topic+add.tips'></span>

<h3>Description</h3>

<p>This function binds tips to nodes of a phylogenetic trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.tips(tree, tips, where, edge.length = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.tips_+3A_tree">tree</code></td>
<td>
<p>an object of class &quot;phylo&quot;.</p>
</td></tr>
<tr><td><code id="add.tips_+3A_tips">tips</code></td>
<td>
<p>a character vector containing the names of the tips.</p>
</td></tr>
<tr><td><code id="add.tips_+3A_where">where</code></td>
<td>
<p>an integer or character vector of the same length as tips giving
the number of the node or tip of the tree where to add the new tips.</p>
</td></tr>
<tr><td><code id="add.tips_+3A_edge.length">edge.length</code></td>
<td>
<p>optional numeric vector with edge length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class phylo
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+bind.tree">bind.tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- rcoal(10)
plot(tree)
nodelabels()
tiplabels()
tree1 &lt;- add.tips(tree, c("A", "B", "C"), c(1,2,15))
plot(tree1)
</code></pre>

<hr>
<h2 id='addConfidences'>Compare splits and add support values to an object</h2><span id='topic+addConfidences'></span><span id='topic+addConfidences.phylo'></span><span id='topic+presenceAbsence'></span><span id='topic+createLabel'></span>

<h3>Description</h3>

<p>Add support values to a <code>splits</code>, <code>phylo</code> or <code>networx</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addConfidences(x, y, ...)

## S3 method for class 'phylo'
addConfidences(x, y, rooted = FALSE, ...)

presenceAbsence(x, y)

createLabel(x, y, label_y, type = "edge", nomatch = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addConfidences_+3A_x">x</code></td>
<td>
<p>an object of class <code>splits</code>, <code>phylo</code> or <code>networx</code></p>
</td></tr>
<tr><td><code id="addConfidences_+3A_y">y</code></td>
<td>
<p>an object of class <code>splits</code>, <code>phylo</code>, <code>multiPhylo</code>
or <code>networx</code></p>
</td></tr>
<tr><td><code id="addConfidences_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="addConfidences_+3A_rooted">rooted</code></td>
<td>
<p>logial, if FALSE bipartitions are considered, if TRUE clades.</p>
</td></tr>
<tr><td><code id="addConfidences_+3A_label_y">label_y</code></td>
<td>
<p>label of y matched on x. Will be usually of
length(as.splits(x)).</p>
</td></tr>
<tr><td><code id="addConfidences_+3A_type">type</code></td>
<td>
<p>should labels returned for edges (in <code>networx</code>) or splits.</p>
</td></tr>
<tr><td><code id="addConfidences_+3A_nomatch">nomatch</code></td>
<td>
<p>default value if no match between x and y is found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object <code>x</code> with added bootstrap / MCMC support values.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Schliep, K., Potts, A. J., Morrison, D. A. and Grimm, G. W.
(2017), Intertwining phylogenetic trees and networks.
<em>Methods Ecol Evol</em>.<b>8</b>, 1212&ndash;1220. doi:10.1111/2041-210X.12760
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+as.splits">as.splits</a></code>, <code><a href="haplotypes.html#topic+as.networx">as.networx</a></code>,
<code><a href="phangorn.html#topic+RF.dist">RF.dist</a></code>, <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(woodmouse)
woodmouse &lt;- phyDat(woodmouse)
tmpfile &lt;- normalizePath(system.file(
             "extdata/trees/RAxML_bootstrap.woodmouse", package="phangorn"))
boot_trees &lt;- read.tree(tmpfile)

dm &lt;- dist.ml(woodmouse)
tree &lt;- upgma(dm)
nnet &lt;- neighborNet(dm)

tree &lt;- addConfidences(tree, boot_trees)
nnet &lt;- addConfidences(nnet, boot_trees)

plot(tree, show.node.label=TRUE)
plot(nnet, show.edge.label=TRUE)

</code></pre>

<hr>
<h2 id='allSplits'>Splits representation of graphs and trees.</h2><span id='topic+allSplits'></span><span id='topic+allCircularSplits'></span><span id='topic+as.splits'></span><span id='topic+splits'></span><span id='topic+as.Matrix'></span><span id='topic+distinct.splits'></span><span id='topic+as.phylo.splits'></span><span id='topic+addTrivialSplits'></span><span id='topic+removeTrivialSplits'></span><span id='topic+matchSplits'></span><span id='topic+as.matrix.splits'></span><span id='topic+as.Matrix.splits'></span><span id='topic+print.splits'></span><span id='topic+c.splits'></span><span id='topic+unique.splits'></span><span id='topic+as.splits.phylo'></span><span id='topic+as.splits.multiPhylo'></span><span id='topic+as.splits.networx'></span><span id='topic+as.prop.part.splits'></span><span id='topic+as.bitsplits.splits'></span><span id='topic+as.splits.bitsplits'></span><span id='topic+compatible'></span>

<h3>Description</h3>

<p><code>as.splits</code> produces a list of splits or bipartitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allSplits(k, labels = NULL)

allCircularSplits(k, labels = NULL)

as.splits(x, ...)

## S3 method for class 'splits'
as.matrix(x, zero.print = 0L, one.print = 1L, ...)

## S3 method for class 'splits'
as.Matrix(x, ...)

## S3 method for class 'splits'
print(x, maxp = getOption("max.print"), zero.print = ".",
  one.print = "|", ...)

## S3 method for class 'splits'
c(..., recursive = FALSE)

## S3 method for class 'splits'
unique(x, incomparables = FALSE, unrooted = TRUE, ...)

## S3 method for class 'phylo'
as.splits(x, ...)

## S3 method for class 'multiPhylo'
as.splits(x, ...)

## S3 method for class 'networx'
as.splits(x, ...)

## S3 method for class 'splits'
as.prop.part(x, ...)

## S3 method for class 'splits'
as.bitsplits(x)

## S3 method for class 'bitsplits'
as.splits(x, ...)

compatible(obj1, obj2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allSplits_+3A_k">k</code></td>
<td>
<p>number of taxa.</p>
</td></tr>
<tr><td><code id="allSplits_+3A_labels">labels</code></td>
<td>
<p>names of taxa.</p>
</td></tr>
<tr><td><code id="allSplits_+3A_x">x</code></td>
<td>
<p>An object of class phylo or multiPhylo.</p>
</td></tr>
<tr><td><code id="allSplits_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="allSplits_+3A_zero.print">zero.print</code></td>
<td>
<p>character which should be printed for zeros.</p>
</td></tr>
<tr><td><code id="allSplits_+3A_one.print">one.print</code></td>
<td>
<p>character which should be printed for ones.</p>
</td></tr>
<tr><td><code id="allSplits_+3A_maxp">maxp</code></td>
<td>
<p>integer, default from <code>options(max.print)</code>, influences how
many entries of large matrices are printed at all.</p>
</td></tr>
<tr><td><code id="allSplits_+3A_recursive">recursive</code></td>
<td>
<p>logical. If recursive = TRUE, the function recursively
descends through lists (and pairlists) combining all their elements into a
vector.</p>
</td></tr>
<tr><td><code id="allSplits_+3A_incomparables">incomparables</code></td>
<td>
<p>only for compatibility so far.</p>
</td></tr>
<tr><td><code id="allSplits_+3A_unrooted">unrooted</code></td>
<td>
<p>todo.</p>
</td></tr>
<tr><td><code id="allSplits_+3A_obj1">obj1</code>, <code id="allSplits_+3A_obj2">obj2</code></td>
<td>
<p>an object of class splits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.splits</code> returns an object of class splits, which is mainly
a list of splits and some attributes. Often a <code>splits</code> object will
contain attributes <code>confidences</code> for bootstrap or Bayesian support
values and <code>weight</code> storing edge weights.
<code>compatible</code> return a lower triangular matrix where an 1 indicates that
two splits are incompatible.
</p>


<h3>Note</h3>

<p>The internal representation is likely to change.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+prop.part">prop.part</a></code>, <code><a href="phangorn.html#topic+lento">lento</a></code>,
<code><a href="haplotypes.html#topic+as.networx">as.networx</a></code>, <code><a href="phangorn.html#topic+distanceHadamard">distanceHadamard</a></code>,
<code><a href="phangorn.html#topic+read.nexus.splits">read.nexus.splits</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(sp &lt;- as.splits(rtree(5)))
write.nexus.splits(sp)
spl &lt;- allCircularSplits(5)
plot(as.networx(spl))

</code></pre>

<hr>
<h2 id='allTrees'>Compute all trees topologies.</h2><span id='topic+allTrees'></span>

<h3>Description</h3>

<p><code>allTrees</code> computes all tree topologies for rooted or unrooted trees
with up to 10 tips. <code>allTrees</code> returns bifurcating trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allTrees(n, rooted = FALSE, tip.label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allTrees_+3A_n">n</code></td>
<td>
<p>Number of tips (&lt;=10).</p>
</td></tr>
<tr><td><code id="allTrees_+3A_rooted">rooted</code></td>
<td>
<p>Rooted or unrooted trees (default: rooted).</p>
</td></tr>
<tr><td><code id="allTrees_+3A_tip.label">tip.label</code></td>
<td>
<p>Tip labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>multiPhylo</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+rtree">rtree</a></code>, <code><a href="phangorn.html#topic+nni">nni</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
trees &lt;- allTrees(5)

old.par &lt;- par(no.readonly = TRUE)
par(mfrow = c(3,5))
for(i in 1:15)plot(trees[[i]])
par(old.par)

</code></pre>

<hr>
<h2 id='Ancestors'>tree utility function</h2><span id='topic+Ancestors'></span><span id='topic+allDescendants'></span><span id='topic+Children'></span><span id='topic+Descendants'></span><span id='topic+Siblings'></span><span id='topic+mrca.phylo'></span>

<h3>Description</h3>

<p>Functions for describing relationships among phylogenetic nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ancestors(x, node, type = c("all", "parent"))

allDescendants(x)

Children(x, node)

Descendants(x, node, type = c("tips", "children", "all"))

Siblings(x, node, include.self = FALSE)

mrca.phylo(x, node = NULL, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ancestors_+3A_x">x</code></td>
<td>
<p>a tree (a phylo object).</p>
</td></tr>
<tr><td><code id="Ancestors_+3A_node">node</code></td>
<td>
<p>an integer or a vector of integers corresponding to a node ID</p>
</td></tr>
<tr><td><code id="Ancestors_+3A_type">type</code></td>
<td>
<p>specify whether to return just direct children / parents or all</p>
</td></tr>
<tr><td><code id="Ancestors_+3A_include.self">include.self</code></td>
<td>
<p>whether to include self in list of siblings</p>
</td></tr>
<tr><td><code id="Ancestors_+3A_full">full</code></td>
<td>
<p>a logical indicating whether to return the MRCAs among all tips
and nodes (if TRUE); the default is to return only the MRCAs among tips.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are inspired by <code>treewalk</code> in phylobase package, but
work on the S3 <code>phylo</code> objects.  The nodes are the indices as given in
edge matrix of an phylo object. From taxon labels these indices can be
easily derived matching against the <code>tip.label</code> argument of an phylo
object, see example below.  All the functions allow <code>node</code> to be either
a scalar or vector.  <code>mrca</code> is a faster version of the mrca in ape, in
phangorn only because of dependencies.
If the argument node is missing the function is evaluated for all nodes.
</p>


<h3>Value</h3>

<p>a vector or a list containing the indices of the nodes.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>allDescendants()</code>: list all the descendant nodes of each node
</p>
</li></ul>


<h3>See Also</h3>

<p><code>treewalk</code>, <code><a href="ape.html#topic+as.phylo">as.phylo</a></code>,
<code><a href="ape.html#topic+nodelabels">nodelabels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tree &lt;- rtree(10)
plot(tree, show.tip.label = FALSE)
nodelabels()
tiplabels()
Ancestors(tree, 1:3, "all")
Children(tree, 11)
Descendants(tree, 11, "tips")
Siblings(tree, 3)
# Siblings of all nodes
Siblings(tree)
mrca.phylo(tree, 1:3)
mrca.phylo(tree, match(c("t1", "t2", "t3"), tree$tip))
mrca.phylo(tree)
# same as mrca(tree), but faster for large trees

</code></pre>

<hr>
<h2 id='ancestral.pml'>Ancestral character reconstruction.</h2><span id='topic+ancestral.pml'></span><span id='topic+ancestral.pars'></span><span id='topic+pace'></span><span id='topic+plotAnc'></span>

<h3>Description</h3>

<p>Marginal reconstruction of the ancestral character states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancestral.pml(object, type = "marginal", return = "prob")

ancestral.pars(tree, data, type = c("MPR", "ACCTRAN", "POSTORDER"),
  cost = NULL, return = "prob")

pace(tree, data, type = c("MPR", "ACCTRAN", "POSTORDER"), cost = NULL,
  return = "prob")

plotAnc(tree, data, i = 1, site.pattern = TRUE, col = NULL,
  cex.pie = par("cex"), pos = "bottomright", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ancestral.pml_+3A_object">object</code></td>
<td>
<p>an object of class pml</p>
</td></tr>
<tr><td><code id="ancestral.pml_+3A_type">type</code></td>
<td>
<p>method used to assign characters to internal nodes, see details.</p>
</td></tr>
<tr><td><code id="ancestral.pml_+3A_return">return</code></td>
<td>
<p>return a <code>phyDat</code> object or matrix of probabilities.</p>
</td></tr>
<tr><td><code id="ancestral.pml_+3A_tree">tree</code></td>
<td>
<p>a tree, i.e. an object of class pml</p>
</td></tr>
<tr><td><code id="ancestral.pml_+3A_data">data</code></td>
<td>
<p>an object of class phyDat</p>
</td></tr>
<tr><td><code id="ancestral.pml_+3A_cost">cost</code></td>
<td>
<p>A cost matrix for the transitions between two states.</p>
</td></tr>
<tr><td><code id="ancestral.pml_+3A_i">i</code></td>
<td>
<p>plots the i-th site pattern of the <code>data</code>.</p>
</td></tr>
<tr><td><code id="ancestral.pml_+3A_site.pattern">site.pattern</code></td>
<td>
<p>logical, plot i-th site pattern or i-th site</p>
</td></tr>
<tr><td><code id="ancestral.pml_+3A_col">col</code></td>
<td>
<p>a vector containing the colors for all possible states.</p>
</td></tr>
<tr><td><code id="ancestral.pml_+3A_cex.pie">cex.pie</code></td>
<td>
<p>a numeric defining the size of the pie graphs</p>
</td></tr>
<tr><td><code id="ancestral.pml_+3A_pos">pos</code></td>
<td>
<p>a character string defining the position of the legend</p>
</td></tr>
<tr><td><code id="ancestral.pml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument &quot;type&quot; defines the criterion to assign the internal nodes. For
<code>ancestral.pml</code> so far &quot;ml&quot; and (empirical) &quot;bayes&quot; and for
<code>ancestral.pars</code> &quot;MPR&quot; and &quot;ACCTRAN&quot; are possible.
</p>
<p>With parsimony reconstruction one has to keep in mind that there will be
often no unique solution.
</p>
<p>For further details see vignette(&quot;Ancestral&quot;).
</p>


<h3>Value</h3>


<p>of class &quot;phyDat&quot;, containing the ancestral states of all nodes.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Felsenstein, J. (2004). <em>Inferring Phylogenies</em>. Sinauer
Associates, Sunderland.
</p>
<p>Swofford, D.L., Maddison, W.P. (1987) Reconstructing ancestral character
states under Wagner parsimony. <em>Math. Biosci.</em> <b>87</b>: 199&ndash;229
</p>
<p>Yang, Z. (2006). <em>Computational Molecular evolution</em>. Oxford University
Press, Oxford.
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+pml">pml</a></code>, <code><a href="phangorn.html#topic+parsimony">parsimony</a></code>, <code><a href="ape.html#topic+ace">ace</a></code>,
<code><a href="ape.html#topic+root">root</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example(NJ)
fit &lt;- pml(tree, Laurasiatherian)
anc.ml &lt;- ancestral.pml(fit, type = "ml")
anc.p &lt;- ancestral.pars(tree, Laurasiatherian)
## Not run: 
require(seqLogo)
seqLogo( t(subset(anc.ml, 48, 1:20)[[1]]), ic.scale=FALSE)
seqLogo( t(subset(anc.p, 48, 1:20)[[1]]), ic.scale=FALSE)

## End(Not run)
# plot the first site pattern
plotAnc(tree, anc.ml, 1)
# plot the third character
plotAnc(tree, anc.ml, attr(anc.ml, "index")[3])

</code></pre>

<hr>
<h2 id='as.networx'>Conversion among phylogenetic network objects</h2><span id='topic+as.networx'></span><span id='topic+networx'></span><span id='topic+as.networx.splits'></span><span id='topic+as.networx.phylo'></span>

<h3>Description</h3>

<p><code>as.networx</code> convert <code>splits</code> objects into a <code>networx</code>
object. And most important there exists a generic <code>plot</code> function to
plot phylogenetic network or split graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.networx(x, ...)

## S3 method for class 'splits'
as.networx(x, planar = FALSE, coord = "none", ...)

## S3 method for class 'phylo'
as.networx(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.networx_+3A_x">x</code></td>
<td>
<p>an object of class <code>"splits"</code> or <code>"phylo"</code></p>
</td></tr>
<tr><td><code id="as.networx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="as.networx_+3A_planar">planar</code></td>
<td>
<p>logical whether to produce a planar graph from only cyclic
splits (may excludes splits).</p>
</td></tr>
<tr><td><code id="as.networx_+3A_coord">coord</code></td>
<td>
<p>add coordinates of the nodes, allows to reproduce the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>networx</code> object hold the information for a phylogenetic
network and extends the <code>phylo</code> object. Therefore some generic function
for <code>phylo</code> objects will also work for <code>networx</code> objects.  The
argument <code>planar = TRUE</code> will create a planar split graph based on a
cyclic ordering. These objects can be nicely plotted in <code>"2D"</code>.
</p>


<h3>Note</h3>

<p>The internal representation is likely to change.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Schliep, K., Potts, A. J., Morrison, D. A. and Grimm, G. W. (2017),
Intertwining phylogenetic trees and networks. <em>Methods Ecol Evol</em>.
<b>8</b>, 1212&ndash;1220. doi:10.1111/2041-210X.12760
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+consensusNet">consensusNet</a></code>, <code><a href="phangorn.html#topic+neighborNet">neighborNet</a></code>,
<code><a href="phangorn.html#topic+splitsNetwork">splitsNetwork</a></code>, <code><a href="phangorn.html#topic+hadamard">hadamard</a></code>,
<code><a href="phangorn.html#topic+distanceHadamard">distanceHadamard</a></code>, <code><a href="phangorn.html#topic+plot.networx">plot.networx</a></code>,
<code><a href="ape.html#topic+evonet">evonet</a></code>, <code><a href="ape.html#topic+as.phylo">as.phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
tree1 &lt;- rtree(20, rooted=FALSE)
sp &lt;- as.splits(rNNI(tree1, n=10))
net &lt;- as.networx(sp)
plot(net)
## Not run: 
# also see example in consensusNet
example(consensusNet)

## End(Not run)

</code></pre>

<hr>
<h2 id='as.pml'>Likelihood of a tree.</h2><span id='topic+as.pml'></span><span id='topic+pml'></span><span id='topic+optim.pml'></span>

<h3>Description</h3>

<p><code>pml</code> computes the likelihood of a phylogenetic tree given a sequence
alignment and a model. <code>optim.pml</code> optimizes the different model
parameters. For a more user-friendly interface see <code><a href="phangorn.html#topic+pml_bb">pml_bb</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.pml(x, ...)

pml(tree, data, bf = NULL, Q = NULL, inv = 0, k = 1, shape = 1,
  rate = 1, model = NULL, site.rate = "gamma", ASC = FALSE, ...)

optim.pml(object, optNni = FALSE, optBf = FALSE, optQ = FALSE,
  optInv = FALSE, optGamma = FALSE, optEdge = TRUE, optRate = FALSE,
  optRooted = FALSE, control = pml.control(), model = NULL,
  rearrangement = ifelse(optNni, "NNI", "none"), subs = NULL,
  ratchet.par = ratchet.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.pml_+3A_x">x</code></td>
<td>
<p>So far only an object of class <code>modelTest</code>.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic <code>tree</code>, object of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_data">data</code></td>
<td>
<p>An alignment, object of class <code>phyDat</code>.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_bf">bf</code></td>
<td>
<p>Base frequencies (see details).</p>
</td></tr>
<tr><td><code id="as.pml_+3A_q">Q</code></td>
<td>
<p>A vector containing the lower triangular part of the rate matrix.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_inv">inv</code></td>
<td>
<p>Proportion of invariable sites.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_k">k</code></td>
<td>
<p>Number of intervals of the discrete gamma distribution.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of the gamma distribution.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_rate">rate</code></td>
<td>
<p>Rate.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_model">model</code></td>
<td>
<p>allows to choose an amino acid models or nucleotide model, see
details.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_site.rate">site.rate</code></td>
<td>
<p>Indicates what type of gamma distribution to use. Options
are &quot;gamma&quot; approach of Yang 1994 (default), &quot;&quot;gamma_quadrature&quot;&quot; after the
Laguerre quadrature approach of Felsenstein 2001 or &quot;freerate&quot;.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_asc">ASC</code></td>
<td>
<p>ascertainment bias correction (ASC), allows to estimate models
like Lewis' Mkv.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_object">object</code></td>
<td>
<p>An object of class <code>pml</code>.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_optnni">optNni</code></td>
<td>
<p>Logical value indicating whether topology gets optimized (NNI).</p>
</td></tr>
<tr><td><code id="as.pml_+3A_optbf">optBf</code></td>
<td>
<p>Logical value indicating whether base frequencies gets
optimized.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_optq">optQ</code></td>
<td>
<p>Logical value indicating whether rate matrix gets optimized.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_optinv">optInv</code></td>
<td>
<p>Logical value indicating whether proportion of variable size
gets optimized.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_optgamma">optGamma</code></td>
<td>
<p>Logical value indicating whether gamma rate parameter gets
optimized.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_optedge">optEdge</code></td>
<td>
<p>Logical value indicating the edge lengths gets optimized.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_optrate">optRate</code></td>
<td>
<p>Logical value indicating the overall rate gets optimized.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_optrooted">optRooted</code></td>
<td>
<p>Logical value indicating if the edge lengths of a rooted
tree get optimized.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_control">control</code></td>
<td>
<p>A list of parameters for controlling the fitting process.</p>
</td></tr>
<tr><td><code id="as.pml_+3A_rearrangement">rearrangement</code></td>
<td>
<p>type of tree tree rearrangements to perform, one of
&quot;none&quot;, &quot;NNI&quot;, &quot;stochastic&quot; or &quot;ratchet&quot;</p>
</td></tr>
<tr><td><code id="as.pml_+3A_subs">subs</code></td>
<td>
<p>A (integer) vector same length as Q to specify the optimization
of Q</p>
</td></tr>
<tr><td><code id="as.pml_+3A_ratchet.par">ratchet.par</code></td>
<td>
<p>search parameter for stochastic search</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Base frequencies in <code>pml</code> can be supplied in different ways.
For amino acid they are usually defined through specifying a model, so the
argument bf does not need to be specified. Otherwise if <code>bf=NULL</code>,
each state is given equal probability. It can be a numeric vector given the
frequencies. Last but not least <code>bf</code> can be string &quot;equal&quot;, &quot;empirical&quot;
and for codon models additionally &quot;F3x4&quot;.
</p>
<p>The topology search uses a nearest neighbor interchange (NNI) and the
implementation is similar to phyML.  The option model in pml is only used
for amino acid models.  The option model defines the nucleotide model which
is getting optimized, all models which are included in modeltest can be
chosen. Setting this option (e.g. &quot;K81&quot; or &quot;GTR&quot;) overrules options optBf
and optQ.  Here is a overview how to estimate different phylogenetic models
with <code>pml</code>: </p>

<table>
<tr>
 <td style="text-align: left;"> model </td><td style="text-align: left;"> optBf </td><td style="text-align: left;"> optQ </td>
</tr>
<tr>
 <td style="text-align: left;"> Jukes-Cantor
</td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> FALSE </td>
</tr>
<tr>
 <td style="text-align: left;"> F81 </td><td style="text-align: left;"> TRUE </td><td style="text-align: left;"> FALSE </td>
</tr>
<tr>
 <td style="text-align: left;"> symmetric </td><td style="text-align: left;"> FALSE
</td><td style="text-align: left;"> TRUE </td>
</tr>
<tr>
 <td style="text-align: left;"> GTR </td><td style="text-align: left;"> TRUE </td><td style="text-align: left;"> TRUE </td>
</tr>

</table>
<p> Via model in optim.pml the following
nucleotide models can be specified: JC, F81, K80, HKY, TrNe, TrN, TPM1, K81,
TPM1u, TPM2, TPM2u, TPM3, TPM3u, TIM1e, TIM1, TIM2e, TIM2, TIM3e, TIM3,
TVMe, TVM, SYM and GTR.  These models are specified as in Posada (2008).
</p>
<p>So far 17 amino acid models are supported (&quot;WAG&quot;, &quot;JTT&quot;, &quot;LG&quot;, &quot;Dayhoff&quot;,
&quot;cpREV&quot;, &quot;mtmam&quot;, &quot;mtArt&quot;, &quot;MtZoa&quot;, &quot;mtREV24&quot;, &quot;VT&quot;,&quot;RtREV&quot;, &quot;HIVw&quot;, &quot;HIVb&quot;,
&quot;FLU&quot;, &quot;Blosum62&quot;, &quot;Dayhoff_DCMut&quot; and &quot;JTT_DCMut&quot;) and additionally rate
matrices and amino acid frequencies can be supplied.
</p>
<p>It is also possible to estimate codon models (e.g. YN98), for details see
also the chapter in vignette(&quot;phangorn-specials&quot;).
</p>
<p>If the option 'optRooted' is set to TRUE than the edge lengths of rooted
tree are optimized. The tree has to be rooted and by now ultrametric!
Optimising rooted trees is generally much slower.
</p>
<p>If <code>rearrangement</code> is set to <code>stochastic</code> a stochastic search
algorithm similar to Nguyen et al. (2015). and for <code>ratchet</code> the
likelihood ratchet as in Vos (2003).  This should helps often to find better
tree topologies, especially for larger trees.
</p>


<h3>Value</h3>

<p><code>pml</code> or <code>optim.pml</code> return a list of class <code>pml</code>,
some are useful for further computations like </p>
<table>
<tr><td><code>tree</code></td>
<td>
<p>the phylogenetic
tree.</p>
</td></tr> <tr><td><code>data</code></td>
<td>
<p>the alignment.</p>
</td></tr> <tr><td><code>logLik</code></td>
<td>
<p>Log-likelihood of the
tree.</p>
</td></tr> <tr><td><code>siteLik</code></td>
<td>
<p>Site log-likelihoods.</p>
</td></tr> <tr><td><code>weight</code></td>
<td>
<p>Weight of the
site patterns.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Felsenstein, J. (1981) Evolutionary trees from DNA sequences: a
maximum likelihood approach. <em>Journal of Molecular Evolution</em>,
<b>17</b>, 368&ndash;376.
</p>
<p>Felsenstein, J. (2004). <em>Inferring Phylogenies</em>. Sinauer Associates,
Sunderland.
</p>
<p>Yang, Z. (2006). <em>Computational Molecular evolution</em>. Oxford University
Press, Oxford.
</p>
<p>Adachi, J., P. J. Waddell, W. Martin, and M. Hasegawa (2000) Plastid genome
phylogeny and a model of amino acid substitution for proteins encoded by
chloroplast DNA.  <em>Journal of Molecular Evolution</em>, <b>50</b>, 348&ndash;358
</p>
<p>Rota-Stabelli, O., Z. Yang, and M. Telford. (2009) MtZoa: a general
mitochondrial amino acid substitutions model for animal evolutionary
studies. <em>Mol. Phyl. Evol</em>, <b>52(1)</b>, 268&ndash;72
</p>
<p>Whelan, S. and Goldman, N. (2001) A general empirical model of protein
evolution derived from multiple protein families using a maximum-likelihood
approach. <em>Molecular Biology and Evolution</em>, <b>18</b>, 691&ndash;699
</p>
<p>Le, S.Q. and Gascuel, O. (2008) LG: An Improved, General Amino-Acid
Replacement Matrix <em>Molecular Biology and Evolution</em>, <b>25(7)</b>,
1307&ndash;1320
</p>
<p>Yang, Z., R. Nielsen, and M. Hasegawa (1998) Models of amino acid
substitution and applications to Mitochondrial protein evolution.
<em>Molecular Biology and Evolution</em>, <b>15</b>, 1600&ndash;1611
</p>
<p>Abascal, F., D. Posada, and R. Zardoya (2007) MtArt: A new Model of amino
acid replacement for Arthropoda. <em>Molecular Biology and Evolution</em>,
<b>24</b>, 1&ndash;5
</p>
<p>Kosiol, C, and Goldman, N (2005) Different versions of the Dayhoff rate
matrix - <em>Molecular Biology and Evolution</em>, <b>22</b>, 193&ndash;199
</p>
<p>L.-T. Nguyen, H.A. Schmidt, A. von Haeseler, and B.Q. Minh (2015) IQ-TREE: A
fast and effective stochastic algorithm for estimating maximum likelihood
phylogenies. <em>Molecular Biology and Evolution</em>, <b>32</b>, 268&ndash;274.
</p>
<p>Vos, R. A. (2003) Accelerated Likelihood Surface Exploration: The Likelihood
Ratchet. <em>Systematic Biology</em>, <b>52(3)</b>, 368&ndash;373
</p>
<p>Yang, Z., and R. Nielsen (1998) Synonymous and nonsynonymous rate variation
in nuclear genes of mammals. <em>Journal of Molecular Evolution</em>,
<b>46</b>, 409-418.
</p>
<p>Lewis, P.O. (2001) A likelihood approach to estimating phylogeny from
discrete morphological character data. <em>Systematic Biology</em> <b>50</b>,
913&ndash;925.
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+pml_bb">pml_bb</a></code>, <code><a href="phangorn.html#topic+bootstrap.pml">bootstrap.pml</a></code>,
<code><a href="phangorn.html#topic+modelTest">modelTest</a></code>, <code><a href="phangorn.html#topic+pmlPart">pmlPart</a></code>, <code><a href="phangorn.html#topic+pmlMix">pmlMix</a></code>,
<code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>, <code><a href="phangorn.html#topic+SH.test">SH.test</a></code>, <code><a href="phangorn.html#topic+ancestral.pml">ancestral.pml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  example(NJ)
# Jukes-Cantor (starting tree from NJ)
  fitJC &lt;- pml(tree, Laurasiatherian)
# optimize edge length parameter
  fitJC &lt;- optim.pml(fitJC)
  fitJC

## Not run: 
# search for a better tree using NNI rearrangements
  fitJC &lt;- optim.pml(fitJC, optNni=TRUE)
  fitJC
  plot(fitJC$tree)

# JC + Gamma + I - model
  fitJC_GI &lt;- update(fitJC, k=4, inv=.2)
# optimize shape parameter + proportion of invariant sites
  fitJC_GI &lt;- optim.pml(fitJC_GI, optGamma=TRUE, optInv=TRUE)
# GTR + Gamma + I - model
  fitGTR &lt;- optim.pml(fitJC_GI, rearrangement = "stochastic",
      optGamma=TRUE, optInv=TRUE, model="GTR")

## End(Not run)


# 2-state data (RY-coded)
  dat &lt;- acgt2ry(Laurasiatherian)
  fit2ST &lt;- pml(tree, dat)
  fit2ST &lt;- optim.pml(fit2ST,optNni=TRUE)
  fit2ST
# show some of the methods available for class pml
  methods(class="pml")

</code></pre>

<hr>
<h2 id='bab'>Branch and bound for finding all most parsimonious trees</h2><span id='topic+bab'></span><span id='topic+BranchAndBound'></span>

<h3>Description</h3>

<p><code>bab</code> finds all most parsimonious trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bab(data, tree = NULL, trace = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bab_+3A_data">data</code></td>
<td>
<p>an object of class phyDat.</p>
</td></tr>
<tr><td><code id="bab_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree an object of class phylo, otherwise a
pratchet search is performed.</p>
</td></tr>
<tr><td><code id="bab_+3A_trace">trace</code></td>
<td>
<p>defines how much information is printed during optimization.</p>
</td></tr>
<tr><td><code id="bab_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is very slow and depending on the data may take very
long time. In the worst case all
<code class="reqn">(2n-5)!! = 1 \times 3 \times 5 \times \ldots \times (2n-5)</code>  possible trees have to be
examined, where n is the number of species / tips. For 10 species there are
already 2027025 tip-labelled unrooted trees. It only uses some basic
strategies to find a lower and upper bounds similar to penny from phylip.
<code>bab</code> uses a very basic heuristic approach of MinMax Squeeze
(Holland et al. 2005) to improve the lower bound.  On the positive side
<code>bab</code> is not like many other implementations restricted to binary or
nucleotide data.
</p>


<h3>Value</h3>

<p><code>bab</code> returns all most parsimonious trees in an object of class
<code>multiPhylo</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a> based on work on Liam
Revell
</p>


<h3>References</h3>

<p>Hendy, M.D. and Penny D. (1982) Branch and bound algorithms to
determine minimal evolutionary trees.  <em>Math. Biosc.</em> <b>59</b>,
277-290
</p>
<p>Holland, B.R., Huber, K.T. Penny, D. and Moulton, V. (2005) The MinMax
Squeeze: Guaranteeing a Minimal Tree for Population Data, <em>Molecular
Biology and Evolution</em>, <b>22</b>, 235&ndash;242
</p>
<p>White, W.T. and Holland, B.R. (2011) Faster exact maximum parsimony search
with XMP. <em>Bioinformatics</em>, <b>27(10)</b>,1359&ndash;1367
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+pratchet">pratchet</a></code>, <code><a href="phangorn.html#topic+dfactorial">dfactorial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(yeast)
dfactorial(11)
# choose only the first two genes
gene12 &lt;- yeast[, 1:3158]
trees &lt;- bab(gene12)

</code></pre>

<hr>
<h2 id='baseFreq'>Summaries of alignments</h2><span id='topic+baseFreq'></span><span id='topic+glance.phyDat'></span>

<h3>Description</h3>

<p><code>baseFreq</code> computes the frequencies (absolute or relative) of the states
from a sample of sequences.
<code>glance</code> computes some useful information about the alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseFreq(obj, freq = FALSE, all = FALSE, drop.unused.levels = FALSE)

## S3 method for class 'phyDat'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseFreq_+3A_obj">obj</code>, <code id="baseFreq_+3A_x">x</code></td>
<td>
<p>as object of class phyDat</p>
</td></tr>
<tr><td><code id="baseFreq_+3A_freq">freq</code></td>
<td>
<p>logical, if 'TRUE', frequencies or counts are returned otherwise
proportions</p>
</td></tr>
<tr><td><code id="baseFreq_+3A_all">all</code></td>
<td>
<p>all a logical; if all = TRUE, all counts of bases, ambiguous
codes, missing data, and alignment gaps are returned as defined in the
contrast.</p>
</td></tr>
<tr><td><code id="baseFreq_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>logical, drop unused levels</p>
</td></tr>
<tr><td><code id="baseFreq_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>baseFreq</code> returns a named vector and <code>glance</code> a one row
<code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+phyDat">phyDat</a>, <a href="ape.html#topic+base.freq">base.freq</a>, <a href="broom.html#topic+glance">glance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
data(chloroplast)
# base frequencies
baseFreq(Laurasiatherian)
baseFreq(Laurasiatherian, all=TRUE)
baseFreq(Laurasiatherian, freq=TRUE)
baseFreq(chloroplast)
glance(Laurasiatherian)
glance(chloroplast)
</code></pre>

<hr>
<h2 id='bootstrap.pml'>Bootstrap</h2><span id='topic+bootstrap.pml'></span><span id='topic+bootstrap.phyDat'></span>

<h3>Description</h3>

<p><code>bootstrap.pml</code> performs (non-parametric) bootstrap analysis and
<code>bootstrap.phyDat</code> produces a list of bootstrapped data sets.
<code>plotBS</code> plots a phylogenetic tree with the bootstrap values assigned
to the (internal) edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap.pml(x, bs = 100, trees = TRUE, multicore = FALSE,
  mc.cores = NULL, tip.dates = NULL, ...)

bootstrap.phyDat(x, FUN, bs = 100, multicore = FALSE, mc.cores = NULL,
  jumble = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap.pml_+3A_x">x</code></td>
<td>
<p>an object of class <code>pml</code> or <code>phyDat</code>.</p>
</td></tr>
<tr><td><code id="bootstrap.pml_+3A_bs">bs</code></td>
<td>
<p>number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="bootstrap.pml_+3A_trees">trees</code></td>
<td>
<p>return trees only (default) or whole <code>pml</code> objects.</p>
</td></tr>
<tr><td><code id="bootstrap.pml_+3A_multicore">multicore</code></td>
<td>
<p>logical, whether models should estimated in parallel.</p>
</td></tr>
<tr><td><code id="bootstrap.pml_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use during bootstrap. Only supported
on UNIX-alike systems.</p>
</td></tr>
<tr><td><code id="bootstrap.pml_+3A_tip.dates">tip.dates</code></td>
<td>
<p>A named vector of sampling times associated to the
tips/sequences. Leave empty if not estimating tip dated phylogenies.</p>
</td></tr>
<tr><td><code id="bootstrap.pml_+3A_...">...</code></td>
<td>
<p>further parameters used by <code>optim.pml</code> or
<code>plot.phylo</code>.</p>
</td></tr>
<tr><td><code id="bootstrap.pml_+3A_fun">FUN</code></td>
<td>
<p>the function to estimate the trees.</p>
</td></tr>
<tr><td><code id="bootstrap.pml_+3A_jumble">jumble</code></td>
<td>
<p>logical, jumble the order of the sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible that the bootstrap is performed in parallel, with help of the
multicore package. Unfortunately the multicore package does not work under
windows or with GUI interfaces (&quot;aqua&quot; on a mac). However it will speed up
nicely from the command line (&quot;X11&quot;).
</p>


<h3>Value</h3>

<p><code>bootstrap.pml</code> returns an object of class <code>multi.phylo</code>
or a list where each element is an object of class <code>pml</code>. <code>plotBS</code>
returns silently a tree, i.e. an object of class <code>phylo</code> with the
bootstrap values as node labels. The argument <code>BStrees</code> is optional and
if not supplied the tree with labels supplied in the <code>node.label</code> slot.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Felsenstein J. (1985) Confidence limits on phylogenies. An
approach using the bootstrap. <em>Evolution</em> <b>39</b>, 783&ndash;791
</p>
<p>Lemoine, F., Entfellner, J. B. D., Wilkinson, E., Correia, D., Felipe, M. D.,
De Oliveira, T., &amp; Gascuel, O. (2018). Renewing Felsenstein‚Äôs phylogenetic
bootstrap in the era of big data. <em>Nature</em>, <b>556(7702)</b>, 452&ndash;456.
</p>
<p>Penny D. and Hendy M.D. (1985) Testing methods evolutionary tree
construction. <em>Cladistics</em> <b>1</b>, 266&ndash;278
</p>
<p>Penny D. and Hendy M.D. (1986) Estimating the reliability of evolutionary
trees. <em>Molecular Biology and Evolution</em> <b>3</b>, 403&ndash;417
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+optim.pml">optim.pml</a></code>, <code><a href="phangorn.html#topic+pml">pml</a></code>,
<code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>, <code><a href="phangorn.html#topic+maxCladeCred">maxCladeCred</a></code>
<code><a href="ape.html#topic+nodelabels">nodelabels</a></code>,<code><a href="phangorn.html#topic+consensusNet">consensusNet</a></code> and
<code><a href="phangorn.html#topic+SOWH.test">SOWH.test</a></code> for parametric bootstrap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(Laurasiatherian)
dm &lt;- dist.hamming(Laurasiatherian)
tree &lt;- NJ(dm)
# NJ
set.seed(123)
NJtrees &lt;- bootstrap.phyDat(Laurasiatherian,
     FUN=function(x)NJ(dist.hamming(x)), bs=100)
treeNJ &lt;- plotBS(tree, NJtrees, "phylogram")

# Maximum likelihood
fit &lt;- pml(tree, Laurasiatherian)
fit &lt;- optim.pml(fit, rearrangement="NNI")
set.seed(123)
bs &lt;- bootstrap.pml(fit, bs=100, optNni=TRUE)
treeBS &lt;- plotBS(fit$tree,bs)

# Maximum parsimony
treeMP &lt;- pratchet(Laurasiatherian)
treeMP &lt;- acctran(treeMP, Laurasiatherian)
set.seed(123)
BStrees &lt;- bootstrap.phyDat(Laurasiatherian, pratchet, bs = 100)
treeMP &lt;- plotBS(treeMP, BStrees, "phylogram")
add.scale.bar()

# export tree with bootstrap values as node labels
# write.tree(treeBS)

## End(Not run)

</code></pre>

<hr>
<h2 id='chloroplast'>Chloroplast alignment</h2><span id='topic+chloroplast'></span>

<h3>Description</h3>

<p>Amino acid alignment of 15 genes of 19 different chloroplast.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(chloroplast)
chloroplast

</code></pre>

<hr>
<h2 id='CI'>Consistency Index and Retention Index</h2><span id='topic+CI'></span><span id='topic+RI'></span>

<h3>Description</h3>

<p><code>CI</code> and <code>RI</code> compute the Consistency Index (CI) and Retention
Index (RI).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CI(tree, data, cost = NULL, sitewise = FALSE)

RI(tree, data, cost = NULL, sitewise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CI_+3A_tree">tree</code></td>
<td>
<p>tree to start the nni search from.</p>
</td></tr>
<tr><td><code id="CI_+3A_data">data</code></td>
<td>
<p>A object of class phyDat containing sequences.</p>
</td></tr>
<tr><td><code id="CI_+3A_cost">cost</code></td>
<td>
<p>A cost matrix for the transitions between two states.</p>
</td></tr>
<tr><td><code id="CI_+3A_sitewise">sitewise</code></td>
<td>
<p>return CI/RI for alignment or sitewise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Consistency Index is defined as minimum number of changes
divided by the number of changes required on the tree (parsimony score). The
Consistency Index is equal to one if there is no homoplasy.
And the Retention Index is defined as
</p>
<p style="text-align: center;"><code class="reqn">RI = \frac{MaxChanges - ObsChanges}{MaxChanges - MinChanges}</code>
</p>



<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+parsimony">parsimony</a></code>, <code><a href="phangorn.html#topic+pratchet">pratchet</a></code>,
<code><a href="phangorn.html#topic+fitch">fitch</a></code>, <code><a href="phangorn.html#topic+sankoff">sankoff</a></code>, <code><a href="phangorn.html#topic+bab">bab</a></code>,
<code><a href="phangorn.html#topic+ancestral.pars">ancestral.pars</a></code>
</p>

<hr>
<h2 id='cladePar'>Utility function to plot.phylo</h2><span id='topic+cladePar'></span>

<h3>Description</h3>

<p>cladePar can help you coloring (choosing edge width/type) of clades.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cladePar(tree, node, edge.color = "red", tip.color = edge.color,
  edge.width = 1, edge.lty = "solid", x = NULL, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cladePar_+3A_tree">tree</code></td>
<td>
<p>an object of class phylo.</p>
</td></tr>
<tr><td><code id="cladePar_+3A_node">node</code></td>
<td>
<p>the node which is the common ancestor of the clade.</p>
</td></tr>
<tr><td><code id="cladePar_+3A_edge.color">edge.color</code></td>
<td>
<p>see plot.phylo.</p>
</td></tr>
<tr><td><code id="cladePar_+3A_tip.color">tip.color</code></td>
<td>
<p>see plot.phylo.</p>
</td></tr>
<tr><td><code id="cladePar_+3A_edge.width">edge.width</code></td>
<td>
<p>see plot.phylo.</p>
</td></tr>
<tr><td><code id="cladePar_+3A_edge.lty">edge.lty</code></td>
<td>
<p>see plot.phylo.</p>
</td></tr>
<tr><td><code id="cladePar_+3A_x">x</code></td>
<td>
<p>the result of a previous call to cladeInfo.</p>
</td></tr>
<tr><td><code id="cladePar_+3A_plot">plot</code></td>
<td>
<p>logical, if TRUE the tree is plotted.</p>
</td></tr>
<tr><td><code id="cladePar_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the information about the edges and tips.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tree &lt;- rtree(10)
plot(tree)
nodelabels()
x &lt;- cladePar(tree, 12)
cladePar(tree, 18, "blue", "blue", x=x, plot=TRUE)

</code></pre>

<hr>
<h2 id='coalSpeciesTree'>Species Tree</h2><span id='topic+coalSpeciesTree'></span>

<h3>Description</h3>

<p><code>coalSpeciesTree</code> estimates species trees and can handle multiple
individuals per species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalSpeciesTree(tree, X = NULL, sTree = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalSpeciesTree_+3A_tree">tree</code></td>
<td>
<p>an object of class <code>multiPhylo</code></p>
</td></tr>
<tr><td><code id="coalSpeciesTree_+3A_x">X</code></td>
<td>
<p>A <code>phyDat</code> object to define which individual belongs to which
species.</p>
</td></tr>
<tr><td><code id="coalSpeciesTree_+3A_stree">sTree</code></td>
<td>
<p>A species tree which fixes the topology.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coalSpeciesTree</code> estimates a single linkage tree as suggested by Liu
et al. (2010) from the element wise minima of the cophenetic matrices of the
gene trees. It extends <code>speciesTree</code> in ape as it allows that have
several individuals per gene tree.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>phylo</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a> Emmanuel Paradies
</p>


<h3>References</h3>

<p>Liu, L., Yu, L. and Pearl, D. K. (2010) Maximum tree: a
consistent estimator of the species tree. <em>Journal of Mathematical
Biology</em>, <b>60</b>, 95&ndash;106.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+speciesTree">speciesTree</a></code>
</p>

<hr>
<h2 id='codonTest'>codonTest</h2><span id='topic+codonTest'></span>

<h3>Description</h3>

<p>Models for detecting positive selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codonTest(tree, object, model = c("M0", "M1a", "M2a"),
  frequencies = "F3x4", opt_freq = FALSE, codonstart = 1,
  control = pml.control(maxit = 20), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codonTest_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree.</p>
</td></tr>
<tr><td><code id="codonTest_+3A_object">object</code></td>
<td>
<p>an object of class phyDat.</p>
</td></tr>
<tr><td><code id="codonTest_+3A_model">model</code></td>
<td>
<p>a vector containing the substitution models to compare with
each other or &quot;all&quot; to test all available models.</p>
</td></tr>
<tr><td><code id="codonTest_+3A_frequencies">frequencies</code></td>
<td>
<p>a character string or vector defining how to compute
the codon frequencies</p>
</td></tr>
<tr><td><code id="codonTest_+3A_opt_freq">opt_freq</code></td>
<td>
<p>optimize frequencies (so far ignored)</p>
</td></tr>
<tr><td><code id="codonTest_+3A_codonstart">codonstart</code></td>
<td>
<p>an integer giving where to start the translation. This
should be 1, 2, or 3, but larger values are accepted and have for effect to
start the translation further within the sequence.</p>
</td></tr>
<tr><td><code id="codonTest_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process.</p>
</td></tr>
<tr><td><code id="codonTest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>codonTest</code> allows to test for positive selection similar to programs
like PAML (Yang ) or HyPhy (Kosakovsky Pond et al. 2005).
</p>
<p>There are several options for deriving the codon frequencies.
Frequencies can be &quot;equal&quot; (1/61), derived from nucleotide frequencies &quot;F1x4&quot;
and &quot;F3x4&quot; or &quot;empirical&quot; codon frequencies. The frequencies taken using
the empirical frequencies or estimated via maximum likelihood.
</p>
<p>So far the M0 model (Goldman and Yang 2002), M1a and M2a are
implemented. The M0 model is always computed the other are optional.
The convergence may be very slow and sometimes fails.
</p>


<h3>Value</h3>

<p>A list with an element called summary containing a data.frame with
the log-likelihood, number of estimated parameters, etc. of all tested
models. An object called posterior which contains the posterior probability
for the rate class for each sites and the estimates of the defined models.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Ziheng Yang (2014). <em>Molecular Evolution: A Statistical
Approach</em>. Oxford University Press, Oxford
</p>
<p>Sergei L. Kosakovsky Pond, Simon D. W. Frost, Spencer V. Muse (2005) HyPhy:
hypothesis testing using phylogenies, <em>Bioinformatics</em>, <b>21(5)</b>:
676&ndash;679, doi:10.1093/bioinformatics/bti079
</p>
<p>Nielsen, R., and Z. Yang. (1998) Likelihood models for detecting positively
selected amino acid sites and applications to the HIV-1 envelope gene.
<em>Genetics</em>, <b>148</b>: 929&ndash;936
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+pml">pml</a></code>, <code><a href="phangorn.html#topic+pmlMix">pmlMix</a></code>, <code><a href="phangorn.html#topic+modelTest">modelTest</a></code>,
<code><a href="stats.html#topic+AIC">AIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# load woodmouse data from ape
data(woodmouse)
dat_codon &lt;- dna2codon(as.phyDat(woodmouse))
tree &lt;- NJ(dist.ml(dat_codon))
# optimize the model the old way
fit &lt;- pml(tree, dat_codon, bf="F3x4")
M0 &lt;- optim.pml(fit, model="codon1")
# Now using the codonTest function
fit_codon &lt;- codonTest(tree, dat_codon)
fit_codon
plot(fit_codon, "M1a")

## End(Not run)

</code></pre>

<hr>
<h2 id='consensusNet'>Computes a consensusNetwork from a list of trees Computes a <code>networx</code>
object from a collection of splits.</h2><span id='topic+consensusNet'></span>

<h3>Description</h3>

<p>Computes a consensusNetwork, i.e. an object of class <code>networx</code> from a
list of trees, i.e. an class of class <code>multiPhylo</code>. Computes a
<code>networx</code> object from a collection of splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensusNet(obj, prob = 0.3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensusNet_+3A_obj">obj</code></td>
<td>
<p>An object of class multiPhylo.</p>
</td></tr>
<tr><td><code id="consensusNet_+3A_prob">prob</code></td>
<td>
<p>the proportion a split has to be present in all trees to be
represented in the network.</p>
</td></tr>
<tr><td><code id="consensusNet_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>consensusNet</code> returns an object of class networx.  This is
just an intermediate to plot phylogenetic networks with igraph.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Holland B.R., Huber K.T., Moulton V., Lockhart P.J. (2004) Using
consensus networks to visualize contradictory evidence for species
phylogeny. <em>Molecular Biology and Evolution</em>, <b>21</b>, 1459&ndash;61
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+splitsNetwork">splitsNetwork</a></code>, <code><a href="phangorn.html#topic+neighborNet">neighborNet</a></code>,
<code><a href="phangorn.html#topic+lento">lento</a></code>, <code><a href="phangorn.html#topic+distanceHadamard">distanceHadamard</a></code>,
<code><a href="phangorn.html#topic+plot.networx">plot.networx</a></code>, <code><a href="phangorn.html#topic+maxCladeCred">maxCladeCred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
set.seed(1)
bs &lt;- bootstrap.phyDat(Laurasiatherian, FUN = function(x)nj(dist.hamming(x)),
    bs=50)
cnet &lt;- consensusNet(bs, .3)
plot(cnet)
## Not run: 
library(rgl)
open3d()
plot(cnet, type = "3D", show.tip.label=FALSE, show.nodes=TRUE)
plot(cnet, type = "equal angle", show.edge.label=TRUE)

tmpfile &lt;- normalizePath(system.file(
              "extdata/trees/RAxML_bootstrap.woodmouse", package="phangorn"))
trees &lt;- read.tree(tmpfile)
cnet_woodmouse &lt;- consensusNet(trees, .3)
plot(cnet_woodmouse, type = "equal angle", show.edge.label=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='cophenetic.networx'>Pairwise Distances from a Phylogenetic Network</h2><span id='topic+cophenetic.networx'></span><span id='topic+cophenetic.splits'></span>

<h3>Description</h3>

<p><code>cophenetic.networx</code> computes the pairwise distances between the pairs
of tips from a phylogenetic network using its branch lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networx'
cophenetic(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cophenetic.networx_+3A_x">x</code></td>
<td>
<p>an object of class <code>networx</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>dist</code>, names are set according to the tip
labels (as given by the element <code>tip.label</code> of the argument <code>x</code>).
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cophenetic">cophenetic</a></code> for the generic function,
<code>neighborNet</code> to construct a network from a distance matrix
</p>

<hr>
<h2 id='delta.score'>Computes the <code class="reqn">\delta</code> score</h2><span id='topic+delta.score'></span>

<h3>Description</h3>

<p>Computes the treelikeness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.score(x, arg = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta.score_+3A_x">x</code></td>
<td>
<p>an object of class <code>phyDat</code></p>
</td></tr>
<tr><td><code id="delta.score_+3A_arg">arg</code></td>
<td>
<p>Specifies the return value, one of &quot;all&quot;, &quot;mean&quot; or &quot;sd&quot;</p>
</td></tr>
<tr><td><code id="delta.score_+3A_...">...</code></td>
<td>
<p>further arguments passed through <code>dist.hamming</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the <code class="reqn">\delta</code> scores.
</p>


<h3>Author(s)</h3>

<p>Alastair Potts and Klaus Schliep
</p>


<h3>References</h3>

<p>BR Holland, KT Huber, A Dress, V Moulton (2002) <code class="reqn">\delta</code>
Plots: a tool for analyzing phylogenetic distance data Russell D. Gray,
David Bryant, Simon J. Greenhill (2010) On the shape and fabric of human
history <em>Molecular Biology and Evolution</em>, <b>19(12)</b> 2051&ndash;2059
</p>
<p>Russell D. Gray, David Bryant, Simon J. Greenhill (2010) On the shape and
fabric of human history <em>Phil. Trans. R. Soc. B</em>, <b>365</b>
3923&ndash;3933; DOI: 10.1098/rstb.2010.0162
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+dist.hamming">dist.hamming</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(yeast)
hist(delta.score(yeast, "all"))

</code></pre>

<hr>
<h2 id='densiTree'>Plots a densiTree.</h2><span id='topic+densiTree'></span>

<h3>Description</h3>

<p>An R function to plot trees similar to those produced by DensiTree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densiTree(x, type = "cladogram", alpha = 1/length(x), consensus = NULL,
  direction = "rightwards", optim = FALSE, scaleX = FALSE, col = 1,
  width = 1, lty = 1, cex = 0.8, font = 3, tip.color = 1, adj = 0,
  srt = 0, underscore = FALSE, label.offset = 0, scale.bar = TRUE,
  jitter = list(amount = 0, random = TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densiTree_+3A_x">x</code></td>
<td>
<p>an object of class <code>multiPhylo</code>.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of phylogeny, so far
&quot;cladogram&quot; (default) or &quot;phylogram&quot; are supported.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_alpha">alpha</code></td>
<td>
<p>parameter for semi-transparent colors.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_consensus">consensus</code></td>
<td>
<p>A tree or character vector which is used to define the order
of the tip labels.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_direction">direction</code></td>
<td>
<p>a character string specifying the direction of the tree.
Four values are possible: &quot;rightwards&quot; (the default), &quot;leftwards&quot;, &quot;upwards&quot;,
and &quot;downwards&quot;.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_optim">optim</code></td>
<td>
<p>not yet used.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_scalex">scaleX</code></td>
<td>
<p>scale trees to have identical heights.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_col">col</code></td>
<td>
<p>a scalar or vector giving the colours used to draw the edges for
each plotted phylogeny. These are taken to be in the same order than input
trees x. If fewer colours are given than the number of trees, then the
colours are recycled.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_width">width</code></td>
<td>
<p>edge width.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_lty">lty</code></td>
<td>
<p>line type.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_cex">cex</code></td>
<td>
<p>a numeric value giving the factor scaling of the tip labels.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_font">font</code></td>
<td>
<p>an integer specifying the type of font for the labels:
1 (plain text), 2 (bold), 3 (italic, the default), or 4 (bold italic).</p>
</td></tr>
<tr><td><code id="densiTree_+3A_tip.color">tip.color</code></td>
<td>
<p>color of the tip labels.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_adj">adj</code></td>
<td>
<p>a numeric specifying the justification of the text strings of the
labels: 0 (left-justification), 0.5 (centering), or 1 (right-justification).</p>
</td></tr>
<tr><td><code id="densiTree_+3A_srt">srt</code></td>
<td>
<p>a numeric giving how much the labels are rotated in degrees.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_underscore">underscore</code></td>
<td>
<p>a logical specifying whether the underscores in tip labels
should be written as spaces (the default) or left as are (if TRUE).</p>
</td></tr>
<tr><td><code id="densiTree_+3A_label.offset">label.offset</code></td>
<td>
<p>a numeric giving the space between the nodes and the tips
of the phylogeny and their corresponding labels.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_scale.bar">scale.bar</code></td>
<td>
<p>a logical specifying whether add scale.bar to the plot.</p>
</td></tr>
<tr><td><code id="densiTree_+3A_jitter">jitter</code></td>
<td>
<p>allows to shift trees. a list with two arguments: the amount of
jitter and random or equally spaced (see details below)</p>
</td></tr>
<tr><td><code id="densiTree_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no consensus tree is provided <code>densiTree</code> computes a consensus tree,
and if the input trees have different labels a mrp.supertree as a backbone.
This should avoid too many unnecessary crossings of edges.
Trees should be rooted, other wise the output may not be visually pleasing.
<code>jitter</code> shifts trees a bit so that they are not exactly on top of each
other.
If <code>amount == 0</code>, it is ignored. If <code>random=TRUE</code> the result of the
permutation is <code>runif(n, -amount, amount)</code>, otherwise
<code>seq(-amount, amount, length=n)</code>, where <code>n &lt;- length(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>densiTree is inspired from the great
<a href="https://www.cs.auckland.ac.nz/~remco/DensiTree/">DensiTree</a> program of
Remco Bouckaert.
</p>
<p>Remco R. Bouckaert (2010) DensiTree: making sense of sets of phylogenetic
trees <em>Bioinformatics</em>, <b>26 (10)</b>, 1372-1373.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>, <code><a href="phangorn.html#topic+plot.networx">plot.networx</a></code>,
<code><a href="base.html#topic+jitter">jitter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
set.seed(1)
bs &lt;- bootstrap.phyDat(Laurasiatherian, FUN =
   function(x) upgma(dist.hamming(x)), bs=25)
# cladogram nice to show topological differences
densiTree(bs, type="cladogram", col="blue")
densiTree(bs, type="phylogram", col="green", direction="downwards", width=2)
# plot five trees slightly shifted, no transparent color
densiTree(bs[1:5], type="phylogram", col=1:5, width=2, jitter=
    list(amount=.3, random=FALSE), alpha=1)
## Not run: 
# phylograms are nice to show different age estimates
require(PhyloOrchard)
data(BinindaEmondsEtAl2007)
BinindaEmondsEtAl2007 &lt;- .compressTipLabel(BinindaEmondsEtAl2007)
densiTree(BinindaEmondsEtAl2007, type="phylogram", col="red")

## End(Not run)

</code></pre>

<hr>
<h2 id='designTree'>Compute a design matrix or non-negative LS</h2><span id='topic+designTree'></span><span id='topic+nnls.tree'></span><span id='topic+nnls.phylo'></span><span id='topic+nnls.splits'></span><span id='topic+nnls.networx'></span><span id='topic+designSplits'></span>

<h3>Description</h3>

<p><code>nnls.tree</code> estimates the branch length using non-negative least
squares given a tree and a distance matrix.  <code>designTree</code> and
<code>designSplits</code> compute design matrices for the estimation of edge
length of (phylogenetic) trees using linear models.  For larger trees a
sparse design matrix can save a lot of memory. 
computes a contrast matrix if the method is &quot;rooted&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designTree(tree, method = "unrooted", sparse = FALSE, tip.dates = NULL,
  ...)

nnls.tree(dm, tree, method = c("unrooted", "ultrametric", "tipdated"),
  rooted = NULL, trace = 1, weight = NULL, balanced = FALSE,
  tip.dates = NULL)

nnls.phylo(x, dm, method = "unrooted", trace = 0, ...)

nnls.splits(x, dm, trace = 0)

nnls.networx(x, dm)

designSplits(x, splits = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designTree_+3A_tree">tree</code></td>
<td>
<p>an object of class <code>phylo</code></p>
</td></tr>
<tr><td><code id="designTree_+3A_method">method</code></td>
<td>
<p>compute an &quot;unrooted&quot;, &quot;ultrametric&quot; or &quot;tipdated&quot; tree.</p>
</td></tr>
<tr><td><code id="designTree_+3A_sparse">sparse</code></td>
<td>
<p>return a sparse design matrix.</p>
</td></tr>
<tr><td><code id="designTree_+3A_tip.dates">tip.dates</code></td>
<td>
<p>a vector of sampling times associated to the tips of tree.</p>
</td></tr>
<tr><td><code id="designTree_+3A_...">...</code></td>
<td>
<p>further arguments, passed to other methods.</p>
</td></tr>
<tr><td><code id="designTree_+3A_dm">dm</code></td>
<td>
<p>a distance matrix.</p>
</td></tr>
<tr><td><code id="designTree_+3A_rooted">rooted</code></td>
<td>
<p>compute a &quot;ultrametric&quot; or &quot;unrooted&quot; tree (better use method).</p>
</td></tr>
<tr><td><code id="designTree_+3A_trace">trace</code></td>
<td>
<p>defines how much information is printed during optimization.</p>
</td></tr>
<tr><td><code id="designTree_+3A_weight">weight</code></td>
<td>
<p>vector of weights to be used in the fitting process.
Weighted least squares is used with weights w, i.e., sum(w * e^2) is
minimized.</p>
</td></tr>
<tr><td><code id="designTree_+3A_balanced">balanced</code></td>
<td>
<p>use weights as in balanced fastME</p>
</td></tr>
<tr><td><code id="designTree_+3A_x">x</code></td>
<td>
<p>number of taxa.</p>
</td></tr>
<tr><td><code id="designTree_+3A_splits">splits</code></td>
<td>
<p>one of &quot;all&quot;, &quot;star&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nnls.tree</code> return a tree, i.e. an object of class
<code>phylo</code>.  <code>designTree</code> and <code>designSplits</code> a matrix, possibly
sparse.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+fastme">fastme</a></code>, <code><a href="ape.html#topic+rtt">rtt</a></code>,
<code><a href="#topic+distanceHadamard">distanceHadamard</a></code>,
<code><a href="#topic+splitsNetwork">splitsNetwork</a></code>, <code><a href="#topic+upgma">upgma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example(NJ)
dm &lt;-  as.matrix(dm)
y &lt;- dm[lower.tri(dm)]
X &lt;- designTree(tree)
lm(y~X-1)
# avoids negative edge weights
tree2 &lt;- nnls.tree(dm, tree)

</code></pre>

<hr>
<h2 id='discrete.gamma'>Discrete Gamma and Beta distribution</h2><span id='topic+discrete.gamma'></span><span id='topic+discrete.beta'></span><span id='topic+plot_gamma_plus_inv'></span><span id='topic+plotRates'></span>

<h3>Description</h3>

<p><code>discrete.gamma</code> internally used for the likelihood computations in
<code>pml</code> or <code>optim.pml</code>. It is useful to understand how it works
for simulation studies or in cases where .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.gamma(alpha, k)

discrete.beta(shape1, shape2, k)

plot_gamma_plus_inv(shape = 1, inv = 0, k = 4, discrete = TRUE,
  cdf = TRUE, append = FALSE, xlab = "x", ylab = ifelse(cdf, "F(x)",
  "f(x)"), xlim = NULL, verticals = FALSE, edge.length = NULL,
  site.rate = "gamma", ...)

plotRates(obj, cdf.color = "blue", main = "cdf", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete.gamma_+3A_alpha">alpha</code></td>
<td>
<p>Shape parameter of the gamma distribution.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_k">k</code></td>
<td>
<p>Number of intervals of the discrete gamma distribution.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_shape1">shape1</code>, <code id="discrete.gamma_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of the gamma distribution.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_inv">inv</code></td>
<td>
<p>Proportion of invariable sites.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_discrete">discrete</code></td>
<td>
<p>logical whether to plot discrete (default) or continuous pdf
or cdf.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_cdf">cdf</code></td>
<td>
<p>logical whether to plot the cumulative distribution function
or density / probability function.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_append">append</code></td>
<td>
<p>logical; if TRUE only add to an existing plot.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis, defaults to a description of x.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis, defaults to a description of y.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_verticals">verticals</code></td>
<td>
<p>logical; if TRUE, draw vertical lines at steps.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_edge.length">edge.length</code></td>
<td>
<p>Total edge length (sum of all edges in a tree).</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_site.rate">site.rate</code></td>
<td>
<p>Indicates what type of gamma distribution to use. Options
are &quot;gamma&quot; (Yang 1994) and &quot;gamma_quadrature&quot; using Laguerre quadrature
approach of Felsenstein (2001)</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_obj">obj</code></td>
<td>
<p>an object of class pml</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_cdf.color">cdf.color</code></td>
<td>
<p>color of the cdf.</p>
</td></tr>
<tr><td><code id="discrete.gamma_+3A_main">main</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are exported to be used in different packages so far only in
the package coalescentMCMC, but are not intended for end user. Most of the
functions call C code and are far less forgiving if the import is not what
they expect than <code>pml</code>.
</p>


<h3>Value</h3>

<p><code>discrete.gamma</code> returns a matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+pml.fit">pml.fit</a>, <a href="stats.html#topic+stepfun">stepfun</a>, link{pgamma}, link{pbeta}</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>discrete.gamma(1, 4)

old.par &lt;- par(no.readonly = TRUE)
par(mfrow = c(2,1))
plot_gamma_plus_inv(shape=2, discrete = FALSE, cdf=FALSE)
plot_gamma_plus_inv(shape=2, append = TRUE, cdf=FALSE)

plot_gamma_plus_inv(shape=2, discrete = FALSE)
plot_gamma_plus_inv(shape=2, append = TRUE)
par(old.par)

</code></pre>

<hr>
<h2 id='dist.hamming'>Pairwise Distances from Sequences</h2><span id='topic+dist.hamming'></span><span id='topic+dist.ml'></span><span id='topic+dist.logDet'></span>

<h3>Description</h3>

<p><code>dist.hamming</code>, <code>dist.ml</code> and <code>dist.logDet</code> compute pairwise
distances for an object of class <code>phyDat</code>.  <code>dist.ml</code> uses DNA /
AA sequences to compute distances under different substitution models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.hamming(x, ratio = TRUE, exclude = "none")

dist.ml(x, model = "JC69", exclude = "none", bf = NULL, Q = NULL,
  k = 1L, shape = 1, ...)

dist.logDet(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.hamming_+3A_x">x</code></td>
<td>
<p>An object of class <code>phyDat</code></p>
</td></tr>
<tr><td><code id="dist.hamming_+3A_ratio">ratio</code></td>
<td>
<p>Compute uncorrected ('p') distance or character difference.</p>
</td></tr>
<tr><td><code id="dist.hamming_+3A_exclude">exclude</code></td>
<td>
<p>One of &quot;none&quot;, &quot;all&quot;, &quot;pairwise&quot; indicating whether to delete
the sites with missing data (or ambiguous states). The default is handle
missing data as in pml.</p>
</td></tr>
<tr><td><code id="dist.hamming_+3A_model">model</code></td>
<td>
<p>One of &quot;JC69&quot;, &quot;F81&quot; or one of 17 amino acid models see
details.</p>
</td></tr>
<tr><td><code id="dist.hamming_+3A_bf">bf</code></td>
<td>
<p>A vector of base frequencies.</p>
</td></tr>
<tr><td><code id="dist.hamming_+3A_q">Q</code></td>
<td>
<p>A vector containing the lower triangular part of the rate matrix.</p>
</td></tr>
<tr><td><code id="dist.hamming_+3A_k">k</code></td>
<td>
<p>Number of intervals of the discrete gamma distribution.</p>
</td></tr>
<tr><td><code id="dist.hamming_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of the gamma distribution.</p>
</td></tr>
<tr><td><code id="dist.hamming_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>So far 17 amino acid models are supported (&quot;WAG&quot;, &quot;JTT&quot;, &quot;LG&quot;, &quot;Dayhoff&quot;,
&quot;cpREV&quot;, &quot;mtmam&quot;, &quot;mtArt&quot;, &quot;MtZoa&quot;, &quot;mtREV24&quot;, &quot;VT&quot;,&quot;RtREV&quot;, &quot;HIVw&quot;, &quot;HIVb&quot;,
&quot;FLU&quot;, &quot;Blosum62&quot;, &quot;Dayhoff_DCMut&quot; and &quot;JTT_DCMut&quot;) and additional rate
matrices and frequencies can be supplied.
</p>
<p>The &quot;F81&quot; model uses empirical base frequencies, the &quot;JC69&quot; equal base
frequencies. This is even the case if the data are not nucleotides.
</p>


<h3>Value</h3>

<p>an object of class <code>dist</code>
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Lockhart, P. J., Steel, M. A., Hendy, M. D. and Penny, D. (1994)
Recovering evolutionary trees under a more realistic model of sequence
evolution. <em>Molecular Biology and Evolution</em>, <b>11</b>, 605&ndash;602.
</p>
<p>Jukes TH and Cantor CR (1969). <em>Evolution of Protein Molecules</em>. New
York: Academic Press. 21&ndash;132.
</p>
<p>McGuire, G., Prentice, M. J. and Wright, F. (1999). Improved error bounds for
genetic distances from DNA sequences. <em>Biometrics</em>, <b>55</b>,
1064‚Äì1070.
</p>


<h3>See Also</h3>

<p>For more distance methods for nucleotide data see
<code><a href="ape.html#topic+dist.dna">dist.dna</a></code> and <code><a href="phangorn.html#topic+dist.p">dist.p</a></code> for pairwise
polymorphism p-distances. <code><a href="phangorn.html#topic+writeDist">writeDist</a></code> for export and import
distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
dm1 &lt;- dist.hamming(Laurasiatherian)
tree1 &lt;- NJ(dm1)
dm2 &lt;- dist.logDet(Laurasiatherian)
tree2 &lt;- NJ(dm2)
treedist(tree1,tree2)
# JC model
dm3 &lt;- dist.ml(Laurasiatherian)
tree3 &lt;- NJ(dm3)
treedist(tree1,tree3)
# F81 + Gamma
dm4 &lt;- dist.ml(Laurasiatherian, model="F81", k=4, shape=.4)
tree4 &lt;- NJ(dm4)
treedist(tree1,tree4)
treedist(tree3,tree4)

</code></pre>

<hr>
<h2 id='dist.p'>Pairwise Polymorphism P-Distances from DNA Sequences</h2><span id='topic+dist.p'></span>

<h3>Description</h3>

<p>This function computes a matrix of pairwise uncorrected polymorphism
p-distances. Polymorphism p-distances include intra-individual site
polymorphisms (2ISPs; e.g. &quot;R&quot;) when calculating genetic distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.p(x, cost = "polymorphism", ignore.indels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.p_+3A_x">x</code></td>
<td>
<p>a matrix containing DNA sequences; this must be of class &quot;phyDat&quot;
(use as.phyDat to convert from DNAbin objects).</p>
</td></tr>
<tr><td><code id="dist.p_+3A_cost">cost</code></td>
<td>
<p>A cost matrix or &quot;polymorphism&quot; for a predefined one.</p>
</td></tr>
<tr><td><code id="dist.p_+3A_ignore.indels">ignore.indels</code></td>
<td>
<p>a logical indicating whether gaps are treated as fifth
state or not. Warning, each gap site is treated as a characters, so an an
indel that spans a number of base positions would be treated as multiple
character states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The polymorphism p-distances (Potts et al. 2014) have been developed to
analyse intra-individual variant polymorphism. For example, the widely used
ribosomal internal transcribed spacer (ITS) region (e.g. Alvarez and Wendel,
2003) consists of 100's to 1000's of units within array across potentially
multiple nucleolus organizing regions (Bailey et al., 2003; Goeker and
Grimm, 2008). This can give rise to intra-individual site polymorphisms
(2ISPs) that can be detected from direct-PCR sequencing or cloning . Clone
consensus sequences (see Goeker and Grimm, 2008) can be analysed with this
function.
</p>


<h3>Value</h3>

<p>an object of class <code>dist</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep and Alastair Potts
</p>


<h3>References</h3>

<p>Alvarez, I., and J. F. Wendel. (2003) Ribosomal ITS sequences
and plant phylogenetic inference. <em> Molecular Phylogenetics and
Evolution</em>, <b>29</b>, 417&ndash;434.
</p>
<p>Bailey, C. D., T. G. Carr, S. A. Harris, and C. E. Hughes. (2003)
Characterization of angiosperm nrDNA polymorphism, paralogy, and
pseudogenes. <em>Molecular Phylogenetics and Evolution</em> <b>29</b>,
435&ndash;455.
</p>
<p>Goeker, M., and G. Grimm. (2008) General functions to transform associate
data to host data, and their use in phylogenetic inference from sequences
with intra-individual variability. <em>BMC Evolutionary Biology</em>,
<b>8</b>:86.
</p>
<p>Potts, A.J., T.A. Hedderson, and G.W. Grimm. (2014) Constructing phylogenies
in the presence of intra-individual site polymorphisms (2ISPs) with a focus
on the nuclear ribosomal cistron. <em>Systematic Biology</em>, <b>63</b>,
1&ndash;16
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+dist.dna">dist.dna</a></code>, <code><a href="#topic+dist.hamming">dist.hamming</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
laura &lt;- as.DNAbin(Laurasiatherian)

dm &lt;- dist.p(Laurasiatherian, "polymorphism")

########################################################
# Dealing with indel 2ISPs
# These can be coded using an "x" in the alignment. Note
# that as.character usage in the read.dna() function.
#########################################################
cat("3 5",
    "No305     ATRA-",
    "No304     ATAYX",
    "No306     ATAGA",
    file = "exdna.txt", sep = "\n")
(ex.dna &lt;- read.dna("exdna.txt", format = "sequential", as.character=TRUE))
dat &lt;- phyDat(ex.dna, "USER", levels=unique(as.vector(ex.dna)))
dist.p(dat)

unlink("exdna.txt")

</code></pre>

<hr>
<h2 id='distanceHadamard'>Distance Hadamard</h2><span id='topic+distanceHadamard'></span>

<h3>Description</h3>

<p>Distance Hadamard produces spectra of splits from a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceHadamard(dm, eps = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceHadamard_+3A_dm">dm</code></td>
<td>
<p>A distance matrix.</p>
</td></tr>
<tr><td><code id="distanceHadamard_+3A_eps">eps</code></td>
<td>
<p>Threshold value for splits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>distanceHadamard</code> returns a matrix. The first column contains
the distance spectra, the second one the edge-spectra. If eps is positive an
object of with all splits greater eps is returned.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>, Tim White
</p>


<h3>References</h3>

<p>Hendy, M. D. and Penny, D. (1993). Spectral Analysis of
Phylogenetic Data. <em>Journal of Classification</em>, <b>10</b>, 5-24.
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+hadamard">hadamard</a></code>, <code><a href="phangorn.html#topic+lento">lento</a></code>,
<code><a href="phangorn.html#topic+plot.networx">plot.networx</a></code>, <code><a href="phangorn.html#topic+neighborNet">neighborNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(yeast)
dm &lt;- dist.hamming(yeast)
dm &lt;- as.matrix(dm)
fit &lt;- distanceHadamard(dm)
lento(fit)
plot(as.networx(fit))

</code></pre>

<hr>
<h2 id='dna2codon'>Translate nucleic acid sequences into codons</h2><span id='topic+dna2codon'></span><span id='topic+codon2dna'></span>

<h3>Description</h3>

<p>The function transforms <code>dna2codon</code> DNA sequences to codon sequences,
<code>codon2dna</code> transform the other way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dna2codon(x, codonstart = 1, code = 1, ambiguity = "---", ...)

codon2dna(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dna2codon_+3A_x">x</code></td>
<td>
<p>An object containing sequences.</p>
</td></tr>
<tr><td><code id="dna2codon_+3A_codonstart">codonstart</code></td>
<td>
<p>an integer giving where to start the translation. This
should be 1, 2, or 3, but larger values are accepted and have for effect to
start the translation further within the sequence.</p>
</td></tr>
<tr><td><code id="dna2codon_+3A_code">code</code></td>
<td>
<p>The ncbi genetic code number for translation (see details).
By default the standard genetic code is used.</p>
</td></tr>
<tr><td><code id="dna2codon_+3A_ambiguity">ambiguity</code></td>
<td>
<p>character for ambiguous character and no contrast is
provided.</p>
</td></tr>
<tr><td><code id="dna2codon_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following genetic codes are described here. The number preceding each
corresponds to the code argument.
</p>

<table>
<tr>
 <td style="text-align: right;">
  1 </td><td style="text-align: left;"> standard   </td>
</tr>
<tr>
 <td style="text-align: right;">
  2 </td><td style="text-align: left;"> vertebrate.mitochondrial </td>
</tr>
<tr>
 <td style="text-align: right;">
  3 </td><td style="text-align: left;"> yeast.mitochondrial </td>
</tr>
<tr>
 <td style="text-align: right;">
  4 </td><td style="text-align: left;"> protozoan.mitochondrial+mycoplasma </td>
</tr>
<tr>
 <td style="text-align: right;">
  5 </td><td style="text-align: left;"> invertebrate.mitochondrial </td>
</tr>
<tr>
 <td style="text-align: right;">
  6 </td><td style="text-align: left;"> ciliate+dasycladaceal </td>
</tr>
<tr>
 <td style="text-align: right;">
  9 </td><td style="text-align: left;"> echinoderm+flatworm.mitochondrial </td>
</tr>
<tr>
 <td style="text-align: right;">
  10 </td><td style="text-align: left;"> euplotid </td>
</tr>
<tr>
 <td style="text-align: right;">
  11 </td><td style="text-align: left;"> bacterial+plantplastid </td>
</tr>
<tr>
 <td style="text-align: right;">
  12 </td><td style="text-align: left;"> alternativeyeast </td>
</tr>
<tr>
 <td style="text-align: right;">
  13 </td><td style="text-align: left;"> ascidian.mitochondrial </td>
</tr>
<tr>
 <td style="text-align: right;">
  14 </td><td style="text-align: left;"> alternativeflatworm.mitochondrial </td>
</tr>
<tr>
 <td style="text-align: right;">
  15 </td><td style="text-align: left;"> blepharism </td>
</tr>
<tr>
 <td style="text-align: right;">
  16 </td><td style="text-align: left;"> chlorophycean.mitochondrial </td>
</tr>
<tr>
 <td style="text-align: right;">
  21 </td><td style="text-align: left;"> trematode.mitochondrial </td>
</tr>
<tr>
 <td style="text-align: right;">
  22 </td><td style="text-align: left;"> scenedesmus.mitochondrial </td>
</tr>
<tr>
 <td style="text-align: right;">
  23 </td><td style="text-align: left;"> thraustochytrium.mitochondria </td>
</tr>
<tr>
 <td style="text-align: right;">
  24 </td><td style="text-align: left;"> Pterobranchia.mitochondrial </td>
</tr>
<tr>
 <td style="text-align: right;">
  25 </td><td style="text-align: left;"> CandidateDivision.SR1+Gracilibacteria </td>
</tr>
<tr>
 <td style="text-align: right;">
  26 </td><td style="text-align: left;"> Pachysolen.tannophilus
</td>
</tr>

</table>

<p>Alignment gaps and ambiguities are currently ignored and sites containing
these are deleted.
</p>


<h3>Value</h3>

<p>The functions return an object of class <code>phyDat</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes">https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+trans">trans</a></code>, <code><a href="phangorn.html#topic+phyDat">phyDat</a></code> and the chapter 4 in the
<code>vignette("phangorn-specials", package="phangorn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
class(Laurasiatherian)
Laurasiatherian
dna2codon(Laurasiatherian)

</code></pre>

<hr>
<h2 id='getClans'>Clans, slices and clips</h2><span id='topic+getClans'></span><span id='topic+getSlices'></span><span id='topic+getClips'></span><span id='topic+getDiversity'></span><span id='topic+summary.clanistics'></span><span id='topic+diversity'></span>

<h3>Description</h3>

<p>Functions for clanistics to compute clans, slices, clips for unrooted trees
and functions to quantify the fragmentation of trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClans(tree)

getSlices(tree)

getClips(tree, all = TRUE)

getDiversity(tree, x, norm = TRUE, var.names = NULL, labels = "new")

## S3 method for class 'clanistics'
summary(object, ...)

diversity(tree, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClans_+3A_tree">tree</code></td>
<td>
<p>An object of class phylo or multiPhylo (getDiversity).</p>
</td></tr>
<tr><td><code id="getClans_+3A_all">all</code></td>
<td>
<p>A logical, return all or just the largest clip.</p>
</td></tr>
<tr><td><code id="getClans_+3A_x">x</code></td>
<td>
<p>An object of class phyDat.</p>
</td></tr>
<tr><td><code id="getClans_+3A_norm">norm</code></td>
<td>
<p>A logical, return Equitability Index (default) or Shannon
Diversity.</p>
</td></tr>
<tr><td><code id="getClans_+3A_var.names">var.names</code></td>
<td>
<p>A vector of variable names.</p>
</td></tr>
<tr><td><code id="getClans_+3A_labels">labels</code></td>
<td>
<p>see details.</p>
</td></tr>
<tr><td><code id="getClans_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="getClans_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="getClans_+3A_x">X</code></td>
<td>
<p>a data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every split in an unrooted tree defines two complementary clans. Thus for an
unrooted binary tree with <code class="reqn">n</code> leaves there are <code class="reqn">2n - 3</code> edges, and
therefore <code class="reqn">4n - 6</code> clans (including <code class="reqn">n</code> trivial clans containing
only one leave).
</p>
<p>Slices are defined by a pair of splits or tripartitions, which are not
clans. The number of distinguishable slices for a binary tree with <code class="reqn">n</code>
tips is <code class="reqn">2n^2 - 10n + 12</code>.
</p>

<p>cophenetic distance and not by the topology. Namely clips are groups of
leaves for which the maximum pairwise distance is smaller than threshold.

distance within a clip is lower than the distance between any member of the
clip and any other tip.
</p>
<p>A clip is a different type of partition, defining groups of leaves that are
related in terms of evolutionary distances and not only topology.  Namely,
clips are groups of leaves for which all pairwise path-length distances are
smaller than a given threshold value (Lapointe et al. 2010). There exists
different numbers of clips for different thresholds, the largest (and
trivial) one being the whole tree.  There is always a clip containing only
the two leaves with the smallest pairwise distance.
</p>
<p>Clans, slices and clips can be used to characterize how well a vector of
categorial characters (natives/intruders) fit on a tree. We will follow the
definitions of Lapointe et al.(2010).  A complete clan is a clan that
contains all leaves of a given state/color, but can also contain leaves of
another state/color. A clan is homogeneous if it only contains leaves of one
state/color.
</p>
<p><code>getDiversity</code> computes either the <br /> Shannon Diversity: <code class="reqn">H =
-\sum_{i=1}^{k}(N_i/N) log(N_i/N), N=\sum_{i=1}^{k} N_i</code> <br /> or the <br /> Equitability Index: <code class="reqn">E = H /
log(N)</code> <br /> where <code class="reqn">N_i</code> are the sizes of the <code class="reqn">k</code> largest homogeneous
clans of intruders.  If the categories of the data can be separated by an
edge of the tree then the E-value will be zero, and maximum equitability
(E=1) is reached if all intruders are in separate clans. getDiversity
computes these Intruder indices for the whole tree, complete clans and
complete slices. Additionally the parsimony scores (p-scores) are reported.
The p-score indicates if the leaves contain only one color (p-score=0), if
the the leaves can be separated by a single split (perfect clan, p-score=1)
or by a pair of splits (perfect slice, p-score=2).
</p>
<p>So far only 2 states are supported (native, intruder), however it is also
possible to recode several states into the native or intruder state using
contrasts, for details see section 2 in vignette(&quot;phangorn-specials&quot;).
Furthermore unknown character states are coded as ambiguous character, which
can act either as native or intruder minimizing the number of clans or
changes (in parsimony analysis) needed to describe a tree for given data.
</p>
<p>Set attribute labels to &quot;old&quot; for analysis as in Schliep et al. (2010) or to
&quot;new&quot; for names which are more intuitive.
</p>
<p><code>diversity</code> returns a data.frame with the parsimony score for each tree
and each levels of the variables in <code>X</code>. <code>X</code> has to be a
<code>data.frame</code> where each column is a factor and the rownames of <code>X</code>
correspond to the tips of the trees.
</p>



<h3>Value</h3>

<p>getClans, getSlices and getClips return a matrix of partitions, a
matrix of ones and zeros where rows correspond to a clan, slice or clip and
columns to tips. A one indicates that a tip belongs to a certain partition.
<br /> getDiversity returns a list with tree object, the first is a data.frame
of the equitability index or Shannon divergence and parsimony scores
(p-score) for all trees and variables. The data.frame has two attributes,
the first is a splits object to identify the taxa of each tree and the
second is a splits object containing all partitions that perfectly fit.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@snv.jussieu.fr">klaus.schliep@snv.jussieu.fr</a>
</p>
<p>Francois-Joseph Lapointe <a href="mailto:francois-joseph.lapointe@umontreal.ca">francois-joseph.lapointe@umontreal.ca</a>
</p>


<h3>References</h3>

<p>Lapointe, F.-J., Lopez, P., Boucher, Y., Koenig, J., Bapteste,
E. (2010) Clanistics: a multi-level perspective for harvesting unrooted gene
trees. <em>Trends in Microbiology</em> 18: 341-347
</p>
<p>Wilkinson, M., McInerney, J.O., Hirt, R.P., Foster, P.G., Embley, T.M.
(2007) Of clades and clans: terms for phylogenetic relationships in unrooted
trees. <em>Trends in Ecology and Evolution</em> 22: 114-115
</p>
<p>Schliep, K., Lopez, P., Lapointe F.-J., Bapteste E. (2011) Harvesting
Evolutionary Signals in a Forest of Prokaryotic Gene Trees, <em>Molecular
Biology and Evolution</em> 28(4): 1393-1405
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+parsimony">parsimony</a></code>, Consistency index <code><a href="phangorn.html#topic+CI">CI</a></code>,
Retention index <code><a href="phangorn.html#topic+RI">RI</a></code>, <code><a href="phangorn.html#topic+phyDat">phyDat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(111)
tree &lt;- rtree(10)
getClans(tree)
getClips(tree, all=TRUE)
getSlices(tree)

set.seed(123)
trees &lt;- rmtree(10, 20)
X &lt;- matrix(sample(c("red", "blue", "violet"), 100, TRUE, c(.5,.4, .1)),
   ncol=5, dimnames=list(paste('t',1:20, sep=""), paste('Var',1:5, sep="_")))
x &lt;- phyDat(X, type = "USER", levels = c("red", "blue"), ambiguity="violet")
plot(trees[[1]], "u", tip.color = X[trees[[1]]$tip,1])  # intruders are blue

(divTab &lt;- getDiversity(trees, x, var.names=colnames(X)))
summary(divTab)

</code></pre>

<hr>
<h2 id='getRoot'>Tree manipulation</h2><span id='topic+getRoot'></span><span id='topic+midpoint'></span><span id='topic+midpoint.phylo'></span><span id='topic+midpoint.multiPhylo'></span><span id='topic+pruneTree'></span>

<h3>Description</h3>

<p><code>midpoint</code> performs midpoint rooting of a tree.  <code>pruneTree</code>
produces a consensus tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRoot(tree)

midpoint(tree, node.labels = "support", ...)

## S3 method for class 'phylo'
midpoint(tree, node.labels = "support", ...)

## S3 method for class 'multiPhylo'
midpoint(tree, node.labels = "support", ...)

pruneTree(tree, ..., FUN = "&gt;=")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRoot_+3A_tree">tree</code></td>
<td>
<p>an object of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="getRoot_+3A_node.labels">node.labels</code></td>
<td>
<p>are node labels 'support' values (edges), 'label' or
should labels get 'deleted'?</p>
</td></tr>
<tr><td><code id="getRoot_+3A_...">...</code></td>
<td>
<p>further arguments, passed to other methods.</p>
</td></tr>
<tr><td><code id="getRoot_+3A_fun">FUN</code></td>
<td>
<p>a function evaluated on the nodelabels, result must be logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pruneTree</code> prunes back a tree and produces a consensus tree, for trees
already containing nodelabels.  It assumes that nodelabels are numerical or
character that allows conversion to numerical, it uses
as.numeric(as.character(tree$node.labels)) to convert them.  <code>midpoint</code>
so far does not transform node.labels properly.
</p>


<h3>Value</h3>

<p><code>pruneTree</code> and <code>midpoint</code> a tree. <code>getRoot</code> returns
the root node.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+consensus">consensus</a></code>, <code><a href="ape.html#topic+root">root</a></code>,
<code><a href="ape.html#topic+multi2di">multi2di</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tree &lt;- rtree(10, rooted = FALSE)
tree$node.label &lt;- c("", round(runif(tree$Nnode-1), digits=3))

tree2 &lt;- midpoint(tree)
tree3 &lt;- pruneTree(tree, .5)

old.par &lt;- par(no.readonly = TRUE)
par(mfrow = c(3,1))
plot(tree, show.node.label=TRUE)
plot(tree2, show.node.label=TRUE)
plot(tree3, show.node.label=TRUE)
par(old.par)

</code></pre>

<hr>
<h2 id='hadamard'>Hadamard Matrices and Fast Hadamard Multiplication</h2><span id='topic+hadamard'></span><span id='topic+fhm'></span><span id='topic+h4st'></span><span id='topic+h2st'></span>

<h3>Description</h3>

<p>A collection of functions to perform Hadamard conjugation.  
Hadamard matrix H with a vector v using fast Hadamard multiplication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hadamard(x)

fhm(v)

h4st(obj, levels = c("a", "c", "g", "t"))

h2st(obj, eps = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hadamard_+3A_x">x</code></td>
<td>
<p>a vector of length <code class="reqn">2^n</code>, where n is an integer.</p>
</td></tr>
<tr><td><code id="hadamard_+3A_v">v</code></td>
<td>
<p>a vector of length <code class="reqn">2^n</code>, where n is an integer.</p>
</td></tr>
<tr><td><code id="hadamard_+3A_obj">obj</code></td>
<td>
<p>a data.frame or character matrix, typical a sequence alignment.</p>
</td></tr>
<tr><td><code id="hadamard_+3A_levels">levels</code></td>
<td>
<p>levels of the sequences.</p>
</td></tr>
<tr><td><code id="hadamard_+3A_eps">eps</code></td>
<td>
<p>Threshold value for splits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>h2st</code> and <code>h4st</code> perform Hadamard conjugation for 2-state
(binary, RY-coded) or 4-state (DNA/RNA) data. <code>write.nexus.splits</code>
writes splits returned from <code>h2st</code> or
<code><a href="#topic+distanceHadamard">distanceHadamard</a></code> to a nexus file, which can be
processed by Spectronet or SplitsTree.
</p>


<h3>Value</h3>

<p><code>hadamard</code> returns a Hadamard matrix. <code>fhm</code> returns the
fast Hadamard multiplication.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Hendy, M.D. (1989). The relationship between simple evolutionary
tree models and observable sequence data. <em>Systematic Zoology</em>,
<b>38</b> 310&ndash;321.
</p>
<p>Hendy, M. D. and Penny, D. (1993). Spectral Analysis of Phylogenetic Data.
<em>Journal of Classification</em>, <b>10</b>, 5&ndash;24.
</p>
<p>Hendy, M. D. (2005). Hadamard conjugation: an analytical tool for
phylogenetics. In O. Gascuel, editor, <em>Mathematics of evolution and
phylogeny</em>, Oxford University Press, Oxford
</p>
<p>Waddell P. J. (1995). Statistical methods of phylogenetic analysis:
Including hadamard conjugation, LogDet transforms, and maximum likelihood.
<em>PhD thesis</em>.
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+distanceHadamard">distanceHadamard</a></code>, <code><a href="phangorn.html#topic+lento">lento</a></code>,
<code><a href="phangorn.html#topic+plot.networx">plot.networx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
H &lt;- hadamard(3)
v &lt;- 1:8
H %*% v
fhm(v)

data(yeast)

# RY-coding
dat_ry &lt;- acgt2ry(yeast)
fit2 &lt;- h2st(dat_ry)
lento(fit2)

# write.nexus.splits(fit2, file = "test.nxs")
# read this file into Spectronet or SplitsTree to show the network

fit4 &lt;- h4st(yeast)
old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(3,1))
lento(fit4[[1]], main="Transversion")
lento(fit4[[2]], main="Transition 1")
lento(fit4[[3]], main="Transition 2")
par(old.par)

</code></pre>

<hr>
<h2 id='identify.networx'>Identify splits in a network</h2><span id='topic+identify.networx'></span>

<h3>Description</h3>

<p><code>identify.networx</code> reads the position of the graphics pointer when the
mouse button is pressed. It then returns the split belonging to the edge
closest to the pointer. The network must be plotted beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networx'
identify(x, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify.networx_+3A_x">x</code></td>
<td>
<p>an object of class <code>networx</code></p>
</td></tr>
<tr><td><code id="identify.networx_+3A_quiet">quiet</code></td>
<td>
<p>a logical controlling whether to print a message inviting the
user to click on the tree.</p>
</td></tr>
<tr><td><code id="identify.networx_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>identify.networx</code> returns a splits object.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.networx">plot.networx</a></code>,
<code><a href="graphics.html#topic+identify">identify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(yeast)
dm &lt;- dist.ml(yeast)
nnet &lt;- neighborNet(dm)
plot(nnet)
identify(nnet) # click close to an edge

## End(Not run)
</code></pre>

<hr>
<h2 id='image.phyDat'>Plot of a Sequence Alignment</h2><span id='topic+image.phyDat'></span>

<h3>Description</h3>

<p>This function plots an image of an alignment of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phyDat'
image(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image.phyDat_+3A_x">x</code></td>
<td>
<p>an object containing sequences, an object of class <code>phyDat</code>.</p>
</td></tr>
<tr><td><code id="image.phyDat_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wrapper for using <code><a href="ape.html#topic+image.DNAbin">image.DNAbin</a></code> and <code><a href="ape.html#topic+image.AAbin">image.AAbin</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+image.DNAbin">image.DNAbin</a></code>, <code><a href="ape.html#topic+image.AAbin">image.AAbin</a></code>
</p>

<hr>
<h2 id='Laurasiatherian'>Laurasiatherian data (AWCMEE)</h2><span id='topic+Laurasiatherian'></span>

<h3>Description</h3>

<p>Laurasiatherian RNA sequence data
</p>


<h3>Source</h3>

<p>Data have been taken from the former repository of the Allan Wilson
Centre and were converted to R format by <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
str(Laurasiatherian)

</code></pre>

<hr>
<h2 id='ldfactorial'>Arithmetic Operators</h2><span id='topic+ldfactorial'></span><span id='topic+dfactorial'></span>

<h3>Description</h3>

<p>double factorial function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldfactorial(x)

dfactorial(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldfactorial_+3A_x">x</code></td>
<td>
<p>a numeric scalar or vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dfactorial(x)</code> returns the double factorial, that is
<code class="reqn">x\!\! = 1 * 3 * 5 * \ldots * x </code> and <code>ldfactorial(x)</code> is the
natural logarithm of it.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Special">factorial</a></code>,
<code><a href="ape.html#topic+howmanytrees">howmanytrees</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dfactorial(1:10)

</code></pre>

<hr>
<h2 id='lento'>Lento plot</h2><span id='topic+lento'></span>

<h3>Description</h3>

<p>The lento plot represents support and conflict of splits/bipartitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lento(obj, xlim = NULL, ylim = NULL, main = "Lento plot", sub = NULL,
  xlab = NULL, ylab = NULL, bipart = TRUE, trivial = FALSE,
  col = rgb(0, 0, 0, 0.5), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lento_+3A_obj">obj</code></td>
<td>
<p>an object of class phylo, multiPhylo or splits</p>
</td></tr>
<tr><td><code id="lento_+3A_xlim">xlim</code></td>
<td>
<p>graphical parameter</p>
</td></tr>
<tr><td><code id="lento_+3A_ylim">ylim</code></td>
<td>
<p>graphical parameter</p>
</td></tr>
<tr><td><code id="lento_+3A_main">main</code></td>
<td>
<p>graphical parameter</p>
</td></tr>
<tr><td><code id="lento_+3A_sub">sub</code></td>
<td>
<p>graphical parameter</p>
</td></tr>
<tr><td><code id="lento_+3A_xlab">xlab</code></td>
<td>
<p>graphical parameter</p>
</td></tr>
<tr><td><code id="lento_+3A_ylab">ylab</code></td>
<td>
<p>graphical parameter</p>
</td></tr>
<tr><td><code id="lento_+3A_bipart">bipart</code></td>
<td>
<p>plot bipartition information.</p>
</td></tr>
<tr><td><code id="lento_+3A_trivial">trivial</code></td>
<td>
<p>logical, whether to present trivial splits (default is
FALSE).</p>
</td></tr>
<tr><td><code id="lento_+3A_col">col</code></td>
<td>
<p>color for the splits / bipartition.</p>
</td></tr>
<tr><td><code id="lento_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lento returns a plot.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Lento, G.M., Hickson, R.E., Chambers G.K., and Penny, D. (1995)
Use of spectral analysis to test hypotheses on the origin of pinninpeds.
<em>Molecular Biology and Evolution</em>, <b>12</b>, 28-52.
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+as.splits">as.splits</a>, <a href="phangorn.html#topic+hadamard">hadamard</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(yeast)
yeast.ry &lt;- acgt2ry(yeast)
splits.h &lt;- h2st(yeast.ry)
lento(splits.h, trivial=TRUE)

</code></pre>

<hr>
<h2 id='lli'>Internal maximum likelihood functions.</h2><span id='topic+lli'></span><span id='topic+edQt'></span><span id='topic+pml.free'></span><span id='topic+pml.init'></span><span id='topic+pml.fit'></span>

<h3>Description</h3>

<p>These functions are internally used for the likelihood computations in
<code>pml</code> or <code>optim.pml</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lli(data, tree = NULL, ...)

edQt(Q = c(1, 1, 1, 1, 1, 1), bf = c(0.25, 0.25, 0.25, 0.25))

pml.free()

pml.init(data, k = 1L)

pml.fit(tree, data, bf = rep(1/length(levels), length(levels)), shape = 1,
  k = 1, Q = rep(1, length(levels) * (length(levels) - 1)/2),
  levels = attr(data, "levels"), inv = 0, rate = 1, g = NULL,
  w = NULL, eig = NULL, INV = NULL, ll.0 = NULL, llMix = NULL,
  wMix = 0, ..., site = FALSE, ASC = FALSE, site.rate = "gamma")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lli_+3A_data">data</code></td>
<td>
<p>An alignment, object of class <code>phyDat</code>.</p>
</td></tr>
<tr><td><code id="lli_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic <code>tree</code>, object of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="lli_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="lli_+3A_q">Q</code></td>
<td>
<p>A vector containing the lower triangular part of the rate matrix.</p>
</td></tr>
<tr><td><code id="lli_+3A_bf">bf</code></td>
<td>
<p>Base frequencies.</p>
</td></tr>
<tr><td><code id="lli_+3A_k">k</code></td>
<td>
<p>Number of intervals of the discrete gamma distribution.</p>
</td></tr>
<tr><td><code id="lli_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of the gamma distribution.</p>
</td></tr>
<tr><td><code id="lli_+3A_levels">levels</code></td>
<td>
<p>The alphabet used e.g. c(&quot;a&quot;, &quot;c&quot;, &quot;g&quot;, &quot;t&quot;) for DNA</p>
</td></tr>
<tr><td><code id="lli_+3A_inv">inv</code></td>
<td>
<p>Proportion of invariable sites.</p>
</td></tr>
<tr><td><code id="lli_+3A_rate">rate</code></td>
<td>
<p>Rate.</p>
</td></tr>
<tr><td><code id="lli_+3A_g">g</code></td>
<td>
<p>vector of quantiles (default is NULL)</p>
</td></tr>
<tr><td><code id="lli_+3A_w">w</code></td>
<td>
<p>vector of probabilities (default is NULL)</p>
</td></tr>
<tr><td><code id="lli_+3A_eig">eig</code></td>
<td>
<p>Eigenvalue decomposition of Q</p>
</td></tr>
<tr><td><code id="lli_+3A_inv">INV</code></td>
<td>
<p>Sparse representation of invariant sites</p>
</td></tr>
<tr><td><code id="lli_+3A_ll.0">ll.0</code></td>
<td>
<p>default is NULL</p>
</td></tr>
<tr><td><code id="lli_+3A_llmix">llMix</code></td>
<td>
<p>default is NULL</p>
</td></tr>
<tr><td><code id="lli_+3A_wmix">wMix</code></td>
<td>
<p>default is NULL</p>
</td></tr>
<tr><td><code id="lli_+3A_site">site</code></td>
<td>
<p>return the log-likelihood or vector of sitewise likelihood
values</p>
</td></tr>
<tr><td><code id="lli_+3A_asc">ASC</code></td>
<td>
<p>ascertainment bias correction (ASC), allows to estimate models
like Lewis' Mkv.</p>
</td></tr>
<tr><td><code id="lli_+3A_site.rate">site.rate</code></td>
<td>
<p>Indicates what type of gamma distribution to use. Options
are &quot;gamma&quot; approach of Yang 1994 (default), &quot;gamma_quadrature&quot; after the
Laguerre quadrature approach of Felsenstein 2001 and &quot;freerate&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are exported to be used in different packages so far only in
the package coalescentMCMC, but are not intended for end user. Most of the
functions call C code and are far less forgiving if the import is not what
they expect than <code>pml</code>.
</p>


<h3>Value</h3>

<p><code>pml.fit</code> returns the log-likelihood.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Felsenstein, J. (1981) Evolutionary trees from DNA sequences: a
maximum likelihood approach. <em>Journal of Molecular Evolution</em>,
<b>17</b>, 368&ndash;376.
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+pml">pml</a>, <a href="phangorn.html#topic+pml_bb">pml_bb</a>, <a href="phangorn.html#topic+pmlPart">pmlPart</a>, <a href="phangorn.html#topic+pmlMix">pmlMix</a></code>
</p>

<hr>
<h2 id='mast'>Maximum agreement subtree</h2><span id='topic+mast'></span>

<h3>Description</h3>

<p><code>mast</code> computes the maximum agreement subtree (MAST).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mast(x, y, tree = TRUE, rooted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mast_+3A_x">x</code></td>
<td>
<p>a tree, i.e. an object of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="mast_+3A_y">y</code></td>
<td>
<p>a tree, i.e. an object of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="mast_+3A_tree">tree</code></td>
<td>
<p>a logical, if TRUE returns a tree other wise the tip labels
of the the maximum agreement subtree.</p>
</td></tr>
<tr><td><code id="mast_+3A_rooted">rooted</code></td>
<td>
<p>logical if TRUE treats trees as rooted otherwise unrooted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code is derived from the code example in Valiente (2009).
The version for the unrooted trees is much slower.
</p>


<h3>Value</h3>

<p><code>mast</code> returns a vector of the tip labels in the MAST.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a> based on code of
Gabriel Valiente
</p>


<h3>References</h3>

<p>G. Valiente (2009). <em>Combinatorial Pattern Matching Algorithms in
Computational Biology using Perl and R</em>. Taylor &amp; Francis/CRC Press
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+SPR.dist">SPR.dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree1 &lt;- rtree(100)
tree2 &lt;- rSPR(tree1, 5)
tips &lt;- mast(tree1, tree2)

</code></pre>

<hr>
<h2 id='maxCladeCred'>Maximum clade credibility tree</h2><span id='topic+maxCladeCred'></span><span id='topic+mcc'></span><span id='topic+allCompat'></span>

<h3>Description</h3>

<p><code>maxCladeCred</code> computes the maximum clade credibility tree from a
sample of trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxCladeCred(x, tree = TRUE, part = NULL, rooted = TRUE)

mcc(x, tree = TRUE, part = NULL, rooted = TRUE)

allCompat(x, rooted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxCladeCred_+3A_x">x</code></td>
<td>
<p><code>x</code> is an object of class <code>multiPhylo</code> or <code>phylo</code></p>
</td></tr>
<tr><td><code id="maxCladeCred_+3A_tree">tree</code></td>
<td>
<p>logical indicating whether return the tree with the clade
credibility (default) or the clade credibility score for all trees.</p>
</td></tr>
<tr><td><code id="maxCladeCred_+3A_part">part</code></td>
<td>
<p>a list of partitions as returned by <code>prop.part</code></p>
</td></tr>
<tr><td><code id="maxCladeCred_+3A_rooted">rooted</code></td>
<td>
<p>logical, if FALSE the tree with highest maximum bipartition
credibility is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>So far just the best tree is returned. No annotations or transformations of
edge length are performed.
</p>
<p>If a list of partition is provided then the clade credibility is computed
for the trees in x.
</p>
<p><code>allCompat</code> returns a 50% majority rule consensus tree with added
compatible splits similar to the option allcompat in MrBayes.
</p>


<h3>Value</h3>

<p>a tree (an object of class <code>phylo</code>) with the highest clade
credibility or a numeric vector of clade credibilities for each tree.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+consensus">consensus</a></code>, <code><a href="phangorn.html#topic+consensusNet">consensusNet</a></code>,
<code><a href="ape.html#topic+prop.part">prop.part</a></code>, <code><a href="phangorn.html#topic+bootstrap.pml">bootstrap.pml</a></code>, <code><a href="phangorn.html#topic+plotBS">plotBS</a></code>,
<code><a href="phangorn.html#topic+transferBootstrap">transferBootstrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(Laurasiatherian)
set.seed(42)
bs &lt;- bootstrap.phyDat(Laurasiatherian,
  FUN = function(x)upgma(dist.hamming(x)), bs=100)

strict_consensus &lt;- consensus(bs)
majority_consensus &lt;- consensus(bs, p=.5)
all_compat &lt;- allCompat(bs)
max_clade_cred &lt;- maxCladeCred(bs)

old.par &lt;- par(no.readonly = TRUE)
par(mfrow = c(2,2), mar = c(1,4,1,1))
plot(strict_consensus, main="Strict consensus tree")
plot(majority_consensus, main="Majority consensus tree")
plot(all_compat, main="Majority consensus tree with compatible splits")
plot(max_clade_cred, main="Maximum clade credibility tree")
par(old.par)

# compute clade credibility for trees given a prop.part object
pp &lt;- prop.part(bs)
tree &lt;- rNNI(bs[[1]], 20)
maxCladeCred(c(tree, bs[[1]]), tree=FALSE, part = pp)
# first value likely be -Inf

</code></pre>

<hr>
<h2 id='mites'>Morphological characters of Mites (Sch√§ffer et al. 2010)</h2><span id='topic+mites'></span>

<h3>Description</h3>

<p>Matrix for morphological characters and character states for 12 species of
mites. See vignette '02_Phylogenetic trees from morphological data' for
examples to import morphological data.
</p>


<h3>References</h3>

<p>Sch√§ffer, S., Pfingstl, T., Koblm√ºller, S., Winkler, K. A.,
Sturmbauer, C., &amp; Krisper, G. (2010). Phylogenetic analysis of European
Scutovertex mites (Acari, Oribatida, Scutoverticidae) reveals paraphyly and
cryptic diversity: a molecular genetic and morphological approach.
<em>Molecular Phylogenetics and Evolution</em>, <b>55(2)</b>, 677&ndash;688.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mites)
mites
# infer all maximum parsimony trees
trees &lt;- bab(mites)
# For larger data sets you might use pratchet instead bab
# trees &lt;- pratchet(mites, minit=200, trace=0, all=TRUE)
# build consensus tree
ctree &lt;- root(consensus(trees, p=.5), outgroup = "C._cymba",
              resolve.root=TRUE, edgelabel=TRUE)
plotBS(ctree, trees)
cnet &lt;- consensusNet(trees)
plot(cnet)
</code></pre>

<hr>
<h2 id='modelTest'>ModelTest</h2><span id='topic+modelTest'></span><span id='topic+AICc'></span>

<h3>Description</h3>

<p>Comparison of different nucleotide or amino acid substitution models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelTest(object, tree = NULL, model = NULL, G = TRUE, I = TRUE,
  FREQ = FALSE, k = 4, control = pml.control(epsilon = 1e-08, maxit = 10,
  trace = 1), multicore = FALSE, mc.cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelTest_+3A_object">object</code></td>
<td>
<p>an object of class phyDat or pml</p>
</td></tr>
<tr><td><code id="modelTest_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree.</p>
</td></tr>
<tr><td><code id="modelTest_+3A_model">model</code></td>
<td>
<p>a vector containing the substitution models to compare with
each other or &quot;all&quot; to test all available models</p>
</td></tr>
<tr><td><code id="modelTest_+3A_g">G</code></td>
<td>
<p>logical, TRUE (default) if (discrete) Gamma model should be tested</p>
</td></tr>
<tr><td><code id="modelTest_+3A_i">I</code></td>
<td>
<p>logical, TRUE (default) if invariant sites should be tested</p>
</td></tr>
<tr><td><code id="modelTest_+3A_freq">FREQ</code></td>
<td>
<p>logical, FALSE (default) if TRUE amino acid frequencies will be
estimated.</p>
</td></tr>
<tr><td><code id="modelTest_+3A_k">k</code></td>
<td>
<p>number of rate classes</p>
</td></tr>
<tr><td><code id="modelTest_+3A_control">control</code></td>
<td>
<p>A list of parameters for controlling the fitting process.</p>
</td></tr>
<tr><td><code id="modelTest_+3A_multicore">multicore</code></td>
<td>
<p>logical, whether models should estimated in parallel.</p>
</td></tr>
<tr><td><code id="modelTest_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child
processes will be run simultaneously. Must be at least one, and
parallelization requires at least two cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modelTest</code> estimates all the specified models for a given tree and
data.  When the mclapply is available, the computations are done in
parallel. <code>modelTest</code> runs each model in one thread.  This is may not
work within a GUI interface and will not work under Windows.
</p>


<h3>Value</h3>

<p>A data.frame containing the log-likelihood, number of estimated
parameters, AIC, AICc and BIC all tested models.  The data.frame has an
attributes &quot;env&quot; which is an environment which contains all the trees, the
data and the calls to allow get the estimated models, e.g. as a starting
point for further analysis (see example).
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Burnham, K. P. and Anderson, D. R (2002) <em>Model selection
and multimodel inference: a practical information-theoretic approach</em>. 2nd
ed. Springer, New York
</p>
<p>Posada, D. and Crandall, K.A. (1998) MODELTEST: testing the model of DNA
substitution. <em>Bioinformatics</em> <b>14(9)</b>: 817-818
</p>
<p>Posada, D. (2008) jModelTest: Phylogenetic Model Averaging. <em>Molecular
Biology and Evolution</em> <b>25</b>: 1253-1256
</p>
<p>Darriba D., Taboada G.L., Doallo R and Posada D. (2011) ProtTest 3: fast
selection of best-fit models of protein evolution. . <em>Bioinformatics</em>
<b>27</b>: 1164-1165
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+pml">pml</a></code>, <code><a href="stats.html#topic+anova">anova</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code>,
<code><a href="phangorn.html#topic+codonTest">codonTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
example(NJ)
(mT &lt;- modelTest(Laurasiatherian, tree, model = c("JC", "F81", "K80", "HKY",
                 "SYM", "GTR")))

# extract best model
(best_model &lt;- as.pml(mT))


data(chloroplast)
(mTAA &lt;- modelTest(chloroplast, model=c("JTT", "WAG", "LG")))

# test all available amino acid models
(mTAA_all &lt;- modelTest(chloroplast, model="all", multicore=TRUE, mc.cores=2))

## End(Not run)

</code></pre>

<hr>
<h2 id='multiphyDat2pmlPart'>Partition model.</h2><span id='topic+multiphyDat2pmlPart'></span><span id='topic+pmlPart2multiPhylo'></span><span id='topic+pmlPart'></span>

<h3>Description</h3>

<p>Model to estimate phylogenies for partitioned data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiphyDat2pmlPart(x, rooted = FALSE, ...)

pmlPart2multiPhylo(x)

pmlPart(formula, object, control = pml.control(epsilon = 1e-08, maxit = 10,
  trace = 1), model = NULL, rooted = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiphyDat2pmlPart_+3A_x">x</code></td>
<td>
<p>an object of class <code>pmlPart</code></p>
</td></tr>
<tr><td><code id="multiphyDat2pmlPart_+3A_rooted">rooted</code></td>
<td>
<p>Are the gene trees rooted (ultrametric) or unrooted.</p>
</td></tr>
<tr><td><code id="multiphyDat2pmlPart_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="multiphyDat2pmlPart_+3A_formula">formula</code></td>
<td>
<p>a formula object (see details).</p>
</td></tr>
<tr><td><code id="multiphyDat2pmlPart_+3A_object">object</code></td>
<td>
<p>an object of class <code>pml</code> or a list of objects of class
<code>pml</code> .</p>
</td></tr>
<tr><td><code id="multiphyDat2pmlPart_+3A_control">control</code></td>
<td>
<p>A list of parameters for controlling the fitting process.</p>
</td></tr>
<tr><td><code id="multiphyDat2pmlPart_+3A_model">model</code></td>
<td>
<p>A vector containing the models containing a model for each
partition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formula</code> object allows to specify which parameter get optimized.
The formula is generally of the form <code>edge + bf + Q ~ rate + shape +
...{}</code>, on the left side are the parameters which get optimized over all
partitions, on the right the parameter which are optimized specific to each
partition. The parameters available are <code>"nni", "bf", "Q", "inv",
"shape", "edge", "rate"</code>.  Each parameters can be used only once in the
formula.  <code>"rate"</code> is only available for the right side of the formula.
</p>
<p>For partitions with different edge weights, but same topology, <code>pmlPen</code>
can try to find more parsimonious models (see example).
</p>
<p><code>pmlPart2multiPhylo</code> is a convenience function to extract the trees out
of a <code>pmlPart</code> object.
</p>


<h3>Value</h3>

<p><code>kcluster</code> returns a list with elements
</p>
<table>
<tr><td><code>logLik</code></td>
<td>
<p>log-likelihood of the fit</p>
</td></tr> <tr><td><code>trees</code></td>
<td>
<p>a list of all trees
during the optimization.</p>
</td></tr> <tr><td><code>object</code></td>
<td>
<p>an object of class <code>"pml"</code> or
<code>"pmlPart"</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+pml">pml</a></code>,<code><a href="phangorn.html#topic+pmlCluster">pmlCluster</a></code>,<code><a href="phangorn.html#topic+pmlMix">pmlMix</a></code>,
<code><a href="phangorn.html#topic+SH.test">SH.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(yeast)
dm &lt;- dist.logDet(yeast)
tree &lt;- NJ(dm)
fit &lt;- pml(tree,yeast)
fits &lt;- optim.pml(fit)

weight=xtabs(~ index+genes,attr(yeast, "index"))[,1:10]

sp &lt;- pmlPart(edge ~ rate + inv, fits, weight=weight)
sp

## Not run: 
sp2 &lt;- pmlPart(~ edge + inv, fits, weight=weight)
sp2
AIC(sp2)

sp3 &lt;- pmlPen(sp2, lambda = 2)
AIC(sp3)

## End(Not run)

</code></pre>

<hr>
<h2 id='neighborNet'>Computes a neighborNet from a distance matrix</h2><span id='topic+neighborNet'></span>

<h3>Description</h3>

<p>Computes a neighborNet, i.e. an object of class <code>networx</code> from a
distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborNet(x, ord = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighborNet_+3A_x">x</code></td>
<td>
<p>a distance matrix.</p>
</td></tr>
<tr><td><code id="neighborNet_+3A_ord">ord</code></td>
<td>
<p>a circular ordering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>neighborNet</code> is still experimental. The cyclic ordering sometimes
differ from the SplitsTree implementation, the <em>ord</em> argument can be
used to enforce a certain circular ordering.
</p>


<h3>Value</h3>

<p><code>neighborNet</code> returns an object of class networx.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Bryant, D. &amp; Moulton, V. (2004) Neighbor-Net: An Agglomerative
Method for the Construction of Phylogenetic Networks. <em>Molecular
Biology and Evolution</em>, 2004, <b>21</b>, 255-265
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+splitsNetwork">splitsNetwork</a></code>, <code><a href="phangorn.html#topic+consensusNet">consensusNet</a></code>,
<code><a href="phangorn.html#topic+plot.networx">plot.networx</a></code>, <code><a href="phangorn.html#topic+lento">lento</a></code>,
<code><a href="phangorn.html#topic+cophenetic.networx">cophenetic.networx</a></code>, <code><a href="phangorn.html#topic+distanceHadamard">distanceHadamard</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(yeast)
dm &lt;- dist.ml(yeast)
nnet &lt;- neighborNet(dm)
plot(nnet)

</code></pre>

<hr>
<h2 id='NJ'>Neighbor-Joining</h2><span id='topic+NJ'></span><span id='topic+UNJ'></span>

<h3>Description</h3>

<p>This function performs the neighbor-joining tree estimation of Saitou and
Nei (1987). UNJ is the unweighted version from Gascuel (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NJ(x)

UNJ(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NJ_+3A_x">x</code></td>
<td>
<p>A distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"phylo"</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus P. Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Saitou, N. and Nei, M. (1987) The neighbor-joining method: a new
method for reconstructing phylogenetic trees. <em>Molecular Biology and
Evolution</em>, <b>4</b>, 406&ndash;425.
</p>
<p>Studier, J. A and Keppler, K. J. (1988) A Note on the Neighbor-Joining
Algorithm of Saitou and Nei. <em>Molecular Biology and Evolution</em>,
<b>6</b>, 729&ndash;731.
</p>
<p>Gascuel, O. (1997) Concerning the NJ algorithm and its unweighted version,
UNJ. in Birkin et. al. <em>Mathematical Hierarchies and Biology</em>,
149&ndash;170.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+nj">nj</a></code>, <code><a href="ape.html#topic+dist.dna">dist.dna</a></code>,
<code><a href="#topic+dist.hamming">dist.hamming</a></code>, <code><a href="#topic+upgma">upgma</a></code>,
<code><a href="ape.html#topic+fastme">fastme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
dm &lt;- dist.ml(Laurasiatherian)
tree &lt;- NJ(dm)
plot(tree)

</code></pre>

<hr>
<h2 id='nni'>Tree rearrangements.</h2><span id='topic+nni'></span><span id='topic+rNNI'></span><span id='topic+rSPR'></span>

<h3>Description</h3>

<p><code>nni</code> returns a list of all trees which are one nearest neighbor
interchange away. <code>rNNI</code> and <code>rSPR</code> are two methods which simulate
random trees which are a specified number of rearrangement apart from the
input tree. Both methods assume that the input tree is bifurcating. These
methods may be useful in simulation studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nni(tree)

rNNI(tree, moves = 1, n = length(moves))

rSPR(tree, moves = 1, n = length(moves), k = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nni_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic <code>tree</code>, object of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="nni_+3A_moves">moves</code></td>
<td>
<p>Number of tree rearrangements to be transformed on a tree.  Can
be a vector</p>
</td></tr>
<tr><td><code id="nni_+3A_n">n</code></td>
<td>
<p>Number of trees to be simulated.</p>
</td></tr>
<tr><td><code id="nni_+3A_k">k</code></td>
<td>
<p>If defined just SPR of distance k are performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class multiPhylo.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+allTrees">allTrees</a></code>, <code><a href="phangorn.html#topic+SPR.dist">SPR.dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tree &lt;- rtree(20, rooted = FALSE)
trees1 &lt;- nni(tree)
trees2 &lt;- rSPR(tree, 2, 10)

</code></pre>

<hr>
<h2 id='phangorn-package'>phangorn: Phylogenetic Reconstruction and Analysis</h2><span id='topic+phangorn'></span><span id='topic+phangorn-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Allows for estimation of phylogenetic trees and networks using Maximum Likelihood, Maximum Parsimony, distance methods and Hadamard conjugation (Schliep 2011). Offers methods for tree comparison, model selection and visualization of phylogenetic networks as described in Schliep et al. (2017).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a> (<a href="https://orcid.org/0000-0003-2941-0161">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Emmanuel Paradis (<a href="https://orcid.org/0000-0003-3092-2199">ORCID</a>)
</p>
</li>
<li><p> Leonardo de Oliveira Martins (<a href="https://orcid.org/0000-0001-5247-1320">ORCID</a>)
</p>
</li>
<li><p> Alastair Potts
</p>
</li>
<li><p> Iris Bardel-Kahr (<a href="https://orcid.org/0000-0002-8950-834X">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Tim W. White [contributor]
</p>
</li>
<li><p> Cyrill Stachniss [contributor]
</p>
</li>
<li><p> Michelle Kendall <a href="mailto:m.kendall@imperial.ac.uk">m.kendall@imperial.ac.uk</a> [contributor]
</p>
</li>
<li><p> Keren Halabi [contributor]
</p>
</li>
<li><p> Richel Bilderbeek [contributor]
</p>
</li>
<li><p> Kristin Winchell [contributor]
</p>
</li>
<li><p> Liam Revell [contributor]
</p>
</li>
<li><p> Mike Gilchrist [contributor]
</p>
</li>
<li><p> Jeremy Beaulieu [contributor]
</p>
</li>
<li><p> Brian O'Meara [contributor]
</p>
</li>
<li><p> Long Qu [contributor]
</p>
</li>
<li><p> Joseph Brown (<a href="https://orcid.org/0000-0002-3835-8062">ORCID</a>) [contributor]
</p>
</li>
<li><p> Santiago Claramunt (<a href="https://orcid.org/0000-0002-8926-5974">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/KlausVigo/phangorn">https://github.com/KlausVigo/phangorn</a>
</p>
</li>
<li> <p><a href="https://klausvigo.github.io/phangorn/">https://klausvigo.github.io/phangorn/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/KlausVigo/phangorn/issues">https://github.com/KlausVigo/phangorn/issues</a>
</p>
</li></ul>


<hr>
<h2 id='phyDat'>Conversion among Sequence Formats</h2><span id='topic+phyDat'></span><span id='topic+as.phyDat.character'></span><span id='topic+as.phyDat.data.frame'></span><span id='topic+as.phyDat.matrix'></span><span id='topic+as.MultipleAlignment'></span><span id='topic+as.MultipleAlignment.phyDat'></span><span id='topic+acgt2ry'></span><span id='topic+phyDat2MultipleAlignment'></span><span id='topic+as.phyDat'></span><span id='topic+as.phyDat.factor'></span><span id='topic+as.phyDat.DNAbin'></span><span id='topic+as.phyDat.alignment'></span><span id='topic+phyDat2alignment'></span><span id='topic+as.phyDat.MultipleAlignment'></span><span id='topic+as.character.phyDat'></span><span id='topic+as.data.frame.phyDat'></span><span id='topic+as.DNAbin.phyDat'></span><span id='topic+as.AAbin.phyDat'></span><span id='topic+genlight2phyDat'></span>

<h3>Description</h3>

<p>These functions transform several DNA formats into the <code>phyDat</code> format.
<code>allSitePattern</code> generates an alignment of all possible site patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyDat(data, type = "DNA", levels = NULL, return.index = TRUE, ...)

as.phyDat(x, ...)

## S3 method for class 'factor'
as.phyDat(x, ...)

## S3 method for class 'DNAbin'
as.phyDat(x, ...)

## S3 method for class 'alignment'
as.phyDat(x, type = "DNA", ...)

phyDat2alignment(x)

## S3 method for class 'MultipleAlignment'
as.phyDat(x, ...)

## S3 method for class 'phyDat'
as.MultipleAlignment(x, ...)

## S3 method for class 'phyDat'
as.character(x, allLevels = TRUE, ...)

## S3 method for class 'phyDat'
as.data.frame(x, ...)

## S3 method for class 'phyDat'
as.DNAbin(x, ...)

## S3 method for class 'phyDat'
as.AAbin(x, ...)

genlight2phyDat(x, ambiguity = NA)

acgt2ry(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyDat_+3A_data">data</code></td>
<td>
<p>An object containing sequences.</p>
</td></tr>
<tr><td><code id="phyDat_+3A_type">type</code></td>
<td>
<p>Type of sequences (&quot;DNA&quot;, &quot;AA&quot;, &quot;CODON&quot; or &quot;USER&quot;).</p>
</td></tr>
<tr><td><code id="phyDat_+3A_levels">levels</code></td>
<td>
<p>Level attributes.</p>
</td></tr>
<tr><td><code id="phyDat_+3A_return.index">return.index</code></td>
<td>
<p>If TRUE returns a index of the site patterns.</p>
</td></tr>
<tr><td><code id="phyDat_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="phyDat_+3A_x">x</code></td>
<td>
<p>An object containing sequences.</p>
</td></tr>
<tr><td><code id="phyDat_+3A_alllevels">allLevels</code></td>
<td>
<p>return original data.</p>
</td></tr>
<tr><td><code id="phyDat_+3A_ambiguity">ambiguity</code></td>
<td>
<p>character for ambiguous character and no contrast is
provided.</p>
</td></tr>
<tr><td><code id="phyDat_+3A_obj">obj</code></td>
<td>
<p>as object of class phyDat</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type</code> &quot;USER&quot; a vector has to be give to <code>levels</code>. For example
c(&quot;a&quot;, &quot;c&quot;, &quot;g&quot;, &quot;t&quot;, &quot;-&quot;) would create a data object that can be used in
phylogenetic analysis with gaps as fifth state.  There is a more detailed
example for specifying &quot;USER&quot; defined data formats in the vignette
&quot;phangorn-specials&quot;.
</p>
<p><code>acgt2ry</code> converts a <code>phyDat</code> object of nucleotides into an binary
ry-coded dataset.
</p>


<h3>Value</h3>

<p>The functions return an object of class <code>phyDat</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p>[DNAbin()], [as.DNAbin()],
<code><a href="phangorn.html#topic+baseFreq">baseFreq</a></code>, <code><a href="phangorn.html#topic+glance.phyDat">glance.phyDat</a></code>,
<code><a href="ape.html#topic+read.dna">read.dna</a></code>, <code><a href="phangorn.html#topic+read.aa">read.aa</a></code>, <code><a href="ape.html#topic+read.nexus.data">read.nexus.data</a></code>
and the chapter 1 in the <code>vignette("phangorn-specials",
package="phangorn")</code> and the example of <code><a href="phangorn.html#topic+pmlMix">pmlMix</a></code> for the use of
<code>allSitePattern</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
class(Laurasiatherian)
Laurasiatherian
# transform as characters
LauraChar &lt;- as.character(Laurasiatherian)
# and back
Laura &lt;- phyDat(LauraChar)
all.equal(Laurasiatherian, Laura)
LauraDNAbin &lt;- as.DNAbin(Laurasiatherian)
all.equal(Laurasiatherian, as.phyDat(LauraDNAbin))

</code></pre>

<hr>
<h2 id='plot.networx'>plot phylogenetic networks</h2><span id='topic+plot.networx'></span>

<h3>Description</h3>

<p>So far not all parameters behave the same on the the <code>rgl</code> <code>"3D"</code>
and basic graphic <code>"2D"</code> device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networx'
plot(x, type = "equal angle", use.edge.length = TRUE,
  show.tip.label = TRUE, show.edge.label = FALSE, edge.label = NULL,
  show.node.label = FALSE, node.label = NULL, show.nodes = FALSE,
  tip.color = "black", edge.color = "black", edge.width = 3,
  edge.lty = 1, split.color = NULL, split.width = NULL,
  split.lty = NULL, font = 3, cex = par("cex"), cex.node.label = cex,
  cex.edge.label = cex, col.node.label = tip.color,
  col.edge.label = tip.color, font.node.label = font,
  font.edge.label = font, underscore = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.networx_+3A_x">x</code></td>
<td>
<p>an object of class <code>"networx"</code></p>
</td></tr>
<tr><td><code id="plot.networx_+3A_type">type</code></td>
<td>
<p>&quot;3D&quot; to plot using rgl or &quot;equal angle&quot; and &quot;2D&quot; in the normal
device.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_use.edge.length">use.edge.length</code></td>
<td>
<p>a logical indicating whether to use the edge weights
of the network to draw the branches (the default) or not.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>a logical indicating whether to show the tip labels on
the graph (defaults to <code>TRUE</code>, i.e. the labels are shown).</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_show.edge.label">show.edge.label</code></td>
<td>
<p>a logical indicating whether to show the tip labels
on the graph.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_edge.label">edge.label</code></td>
<td>
<p>an additional vector of edge labels (normally not needed).</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_show.node.label">show.node.label</code></td>
<td>
<p>a logical indicating whether to show the node labels
(see example).</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_node.label">node.label</code></td>
<td>
<p>an additional vector of node labels (normally not needed).</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_show.nodes">show.nodes</code></td>
<td>
<p>a logical indicating whether to show the nodes (see
example).</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_tip.color">tip.color</code></td>
<td>
<p>the colors used for the tip labels.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_edge.color">edge.color</code></td>
<td>
<p>the colors used to draw edges.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_edge.width">edge.width</code></td>
<td>
<p>the width used to draw edges.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_edge.lty">edge.lty</code></td>
<td>
<p>a vector of line types.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_split.color">split.color</code></td>
<td>
<p>the colors used to draw edges.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_split.width">split.width</code></td>
<td>
<p>the width used to draw edges.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_split.lty">split.lty</code></td>
<td>
<p>a vector of line types.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_font">font</code></td>
<td>
<p>an integer specifying the type of font for the labels: 1 (plain
text), 2 (bold), 3 (italic, the default), or 4 (bold italic).</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_cex">cex</code></td>
<td>
<p>a numeric value giving the factor scaling of the labels.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_cex.node.label">cex.node.label</code></td>
<td>
<p>a numeric value giving the factor scaling of the node
labels.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_cex.edge.label">cex.edge.label</code></td>
<td>
<p>a numeric value giving the factor scaling of the edge
labels.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_col.node.label">col.node.label</code></td>
<td>
<p>the colors used for the node labels.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_col.edge.label">col.edge.label</code></td>
<td>
<p>the colors used for the edge labels.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_font.node.label">font.node.label</code></td>
<td>
<p>the font used for the node labels.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_font.edge.label">font.edge.label</code></td>
<td>
<p>the font used for the edge labels.</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_underscore">underscore</code></td>
<td>
<p>a logical specifying whether the underscores in tip labels
should be written as spaces (the default) or left as are (if TRUE).</p>
</td></tr>
<tr><td><code id="plot.networx_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often it is easier and safer to supply vectors of graphical parameters for
splits (e.g. splits.color) than for edges. These overwrite values edge.color.
</p>


<h3>Note</h3>

<p>The internal representation is likely to change.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Dress, A.W.M. and Huson, D.H. (2004) Constructing Splits Graphs
<em>IEEE/ACM Transactions on Computational Biology and Bioinformatics
(TCBB)</em>, <b>1(3)</b>, 109&ndash;115
</p>
<p>Schliep, K., Potts, A. J., Morrison, D. A. and Grimm, G. W. (2017),
Intertwining phylogenetic trees and networks. <em>Methods Ecol Evol</em>.
<b>8</b>, 1212&ndash;1220. doi:10.1111/2041-210X.12760
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+consensusNet">consensusNet</a></code>, <code><a href="phangorn.html#topic+neighborNet">neighborNet</a></code>,
<code><a href="phangorn.html#topic+splitsNetwork">splitsNetwork</a></code>, <code><a href="phangorn.html#topic+hadamard">hadamard</a></code>,
<code><a href="phangorn.html#topic+distanceHadamard">distanceHadamard</a></code>, <code><a href="haplotypes.html#topic+as.networx">as.networx</a></code>,
<code><a href="ape.html#topic+evonet">evonet</a></code>, <code><a href="ape.html#topic+as.phylo">as.phylo</a></code>,
<code><a href="phangorn.html#topic+densiTree">densiTree</a></code>, <code><a href="ape.html#topic+nodelabels">nodelabels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
tree1 &lt;- rtree(20, rooted=FALSE)
sp &lt;- as.splits(rNNI(tree1, n=10))
net &lt;- as.networx(sp)
plot(net)
## Not run: 
# also see example in consensusNet
example(consensusNet)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotBS'>Plotting trees with bootstrap values</h2><span id='topic+plotBS'></span>

<h3>Description</h3>

<p><code>plotBS</code> plots a phylogenetic tree with the bootstrap values assigned
to the (internal) edges. It can also used to assign bootstrap values to a
phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBS(tree, BStrees, type = "phylogram", method = "FBP",
  bs.col = "black", bs.adj = NULL, digits = 3, p = 0, frame = "none",
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBS_+3A_tree">tree</code></td>
<td>
<p>The tree on which edges the bootstrap values are plotted.</p>
</td></tr>
<tr><td><code id="plotBS_+3A_bstrees">BStrees</code></td>
<td>
<p>a list of trees (object of class &quot;multiPhylo&quot;).</p>
</td></tr>
<tr><td><code id="plotBS_+3A_type">type</code></td>
<td>
<p>the type of tree to plot, one of &quot;phylogram&quot;, &quot;cladogram&quot;, &quot;fan&quot;,
&quot;unrooted&quot;, &quot;radial&quot; or &quot;none&quot;. If type is &quot;none&quot; the tree is returned with
the bootstrap values assigned to the node labels.</p>
</td></tr>
<tr><td><code id="plotBS_+3A_method">method</code></td>
<td>
<p>either &quot;FBP&quot; the classical bootstrap (default) or &quot;TBE&quot;
(transfer bootstrap)</p>
</td></tr>
<tr><td><code id="plotBS_+3A_bs.col">bs.col</code></td>
<td>
<p>color of bootstrap support labels.</p>
</td></tr>
<tr><td><code id="plotBS_+3A_bs.adj">bs.adj</code></td>
<td>
<p>one or two numeric values specifying the horizontal and
vertical justification of the bootstrap labels.</p>
</td></tr>
<tr><td><code id="plotBS_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places.</p>
</td></tr>
<tr><td><code id="plotBS_+3A_p">p</code></td>
<td>
<p>only plot support values higher than this percentage number
(default is 0).</p>
</td></tr>
<tr><td><code id="plotBS_+3A_frame">frame</code></td>
<td>
<p>a character string specifying the kind of frame to be printed
around the bootstrap values. This must be one of &quot;none&quot; (the default),
&quot;rect&quot; or &quot;circle&quot;.</p>
</td></tr>
<tr><td><code id="plotBS_+3A_...">...</code></td>
<td>
<p>further parameters used by <code>plot.phylo</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotBS</code> can either assign the classical Felsenstein‚Äôs bootstrap
proportions (FBP) (Felsenstein (1985), Hendy &amp; Penny (1985))  or the
transfer bootstrap expectation (TBE) of Lemoine et al. (2018). Using the
option <code>type=="n"</code> just assigns the bootstrap values and return the tree
without plotting it.
</p>


<h3>Value</h3>

<p><code>plotBS</code> returns silently a tree, i.e. an object of class
<code>phylo</code> with the bootstrap values as node labels. The argument
<code>BStrees</code> is optional and if not supplied the labels supplied
in the <code>node.label</code> slot will be used.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Felsenstein J. (1985) Confidence limits on phylogenies. An
approach using the bootstrap. <em>Evolution</em> <b>39</b>, 783&ndash;791
</p>
<p>Lemoine, F., Entfellner, J. B. D., Wilkinson, E., Correia, D., Felipe, M. D.,
De Oliveira, T., &amp; Gascuel, O. (2018). Renewing Felsenstein‚Äôs phylogenetic
bootstrap in the era of big data. <em>Nature</em>, <b>556(7702)</b>, 452&ndash;456.
</p>
<p>Penny D. and Hendy M.D. (1985) Testing methods evolutionary tree
construction. <em>Cladistics</em> <b>1</b>, 266&ndash;278
</p>
<p>Penny D. and Hendy M.D. (1986) Estimating the reliability of evolutionary
trees. <em>Molecular Biology and Evolution</em> <b>3</b>, 403&ndash;417
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+transferBootstrap">transferBootstrap</a></code>, <code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>,
<code><a href="phangorn.html#topic+maxCladeCred">maxCladeCred</a></code>, <code><a href="ape.html#topic+nodelabels">nodelabels</a></code>,
<code><a href="ape.html#topic+consensus">consensus</a></code>, <code><a href="phangorn.html#topic+consensusNet">consensusNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdir &lt;- system.file("extdata/trees", package = "phangorn")
# RAxML best-known tree with bipartition support (from previous analysis)
raxml.tree &lt;- read.tree(file.path(fdir,"RAxML_bipartitions.woodmouse"))
# RAxML bootstrap trees (from previous analysis)
raxml.bootstrap &lt;- read.tree(file.path(fdir,"RAxML_bootstrap.woodmouse"))
par(mfrow=c(1,2))
plotBS(raxml.tree,  raxml.bootstrap, "p")
plotBS(raxml.tree,  raxml.bootstrap, "p", "TBE")
</code></pre>

<hr>
<h2 id='pml_bb'>Likelihood of a tree.</h2><span id='topic+pml_bb'></span>

<h3>Description</h3>

<p><code>pml_bb</code> for pml black box infers a phylogentic tree infers a tree using
maximum likelihood (ML).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pml_bb(x, model = NULL, rearrangement = "stochastic",
  method = "unrooted", start = NULL, tip.dates = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pml_bb_+3A_x">x</code></td>
<td>
<p>An alignment of class (either class <code>phyDat</code>, <code>DNAbin</code> or
<code>AAbin</code>) or an object of class <code>modelTest</code>.</p>
</td></tr>
<tr><td><code id="pml_bb_+3A_model">model</code></td>
<td>
<p>A string providing model (e.g. &quot;GTR+G(4)+I&quot;). Not necessary if
a modelTest object is supplied.</p>
</td></tr>
<tr><td><code id="pml_bb_+3A_rearrangement">rearrangement</code></td>
<td>
<p>Type of tree tree rearrangements to perform, one of
&quot;none&quot;, &quot;NNI&quot;, &quot;stochastic&quot; or &quot;ratchet&quot;</p>
</td></tr>
<tr><td><code id="pml_bb_+3A_method">method</code></td>
<td>
<p>One of &quot;unrooted&quot;, &quot;ultrametric&quot; or &quot;tiplabeled&quot;.</p>
</td></tr>
<tr><td><code id="pml_bb_+3A_start">start</code></td>
<td>
<p>A starting tree can be supplied.</p>
</td></tr>
<tr><td><code id="pml_bb_+3A_tip.dates">tip.dates</code></td>
<td>
<p>A named vector of sampling times associated to the tips /
sequences.</p>
</td></tr>
<tr><td><code id="pml_bb_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pml_bb</code> is a convenience function combining <code>pml</code> and
<code>optim.pml</code>. If no tree is supplied, the function will generate a
starting tree. If a modelTest object is supplied the model will be chosen
according to BIC.
</p>
<p>Currently very experimental and likely to change.
</p>
<p><code>tip.dates</code> should be a named vector of sampling times, in any time
unit, with time increasing toward the present. For example, this may be in
units of ‚Äúdays since study start‚Äù or ‚Äúyears since 10,000 BCE‚Äù, but not
‚Äúmillions of yearsago‚Äù.
</p>


<h3>Value</h3>

<p><code>pml_bb</code> returns an object of class pml.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+optim.pml">optim.pml</a></code>, <code><a href="phangorn.html#topic+modelTest">modelTest</a></code>, <code><a href="ape.html#topic+rtt">rtt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(woodmouse)
tmp &lt;- pml_bb(woodmouse)

data(Laurasiatherian)
mt &lt;- modelTest(Laurasiatherian)
fit &lt;- pml_bb(mt)

## End(Not run)
</code></pre>

<hr>
<h2 id='pml.control'>Auxiliary for Controlling Fitting</h2><span id='topic+pml.control'></span><span id='topic+ratchet.control'></span>

<h3>Description</h3>

<p>Auxiliary functions for <code><a href="phangorn.html#topic+optim.pml">optim.pml</a></code> fitting. Use it to construct
a <code>control</code> or <code>ratchet.par</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pml.control(epsilon = 1e-08, maxit = 10, trace = 1, tau = 1e-08)

ratchet.control(iter = 20L, maxit = 200L, minit = 50L, prop = 1/2,
  rell = TRUE, bs = 1000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pml.control_+3A_epsilon">epsilon</code></td>
<td>
<p>Stop criterion for optimization (see details).</p>
</td></tr>
<tr><td><code id="pml.control_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (see details).</p>
</td></tr>
<tr><td><code id="pml.control_+3A_trace">trace</code></td>
<td>
<p>Show output during optimization (see details).</p>
</td></tr>
<tr><td><code id="pml.control_+3A_tau">tau</code></td>
<td>
<p>minimal edge length.</p>
</td></tr>
<tr><td><code id="pml.control_+3A_iter">iter</code></td>
<td>
<p>Number of iterations to stop if there is no change.</p>
</td></tr>
<tr><td><code id="pml.control_+3A_minit">minit</code></td>
<td>
<p>Minimum number of iterations.</p>
</td></tr>
<tr><td><code id="pml.control_+3A_prop">prop</code></td>
<td>
<p>Only used if <code>rearrangement=stochstic</code>. How many NNI moves
should be added to the tree in proportion of the number of taxa.¬¥</p>
</td></tr>
<tr><td><code id="pml.control_+3A_rell">rell</code></td>
<td>
<p>logical, if TRUE approximate bootstraping similar Minh et al.
(2013) is performed.</p>
</td></tr>
<tr><td><code id="pml.control_+3A_bs">bs</code></td>
<td>
<p>number of approximate bootstrap samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pml.control</code> controls the fitting process. <code>epsilon</code> and
<code>maxit</code> are only defined for the most outer loop, this affects
<code>pmlCluster</code>, <code>pmlPart</code> and <code>pmlMix</code>.  <code>epsilon</code> is
defined as (logLik(k)-logLik(k+1))/logLik(k+1), this seems to be a good
heuristics which works reasonably for small and large trees or alignments.
If <code>trace</code> is set to zero than no out put is shown, if functions are
called internally than the trace is decreased by one, so a higher of trace
produces more feedback.
</p>


<h3>Value</h3>

<p>A list with components named as the arguments for controlling the
fitting process.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Minh, B. Q., Nguyen, M. A. T., &amp; von Haeseler, A. (2013).
Ultrafast approximation for phylogenetic bootstrap. <em>Molecular biology
and evolution</em>, <b>30(5)</b>, 1188-1195.
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+optim.pml">optim.pml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pml.control()
pml.control(maxit=25)
</code></pre>

<hr>
<h2 id='pmlCluster'>Stochastic Partitioning</h2><span id='topic+pmlCluster'></span>

<h3>Description</h3>

<p>Stochastic Partitioning of genes into p cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmlCluster(formula, fit, weight, p = 1:5, part = NULL, nrep = 10,
  control = pml.control(epsilon = 1e-08, maxit = 10, trace = 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmlCluster_+3A_formula">formula</code></td>
<td>
<p>a formula object (see details).</p>
</td></tr>
<tr><td><code id="pmlCluster_+3A_fit">fit</code></td>
<td>
<p>an object of class <code>pml</code>.</p>
</td></tr>
<tr><td><code id="pmlCluster_+3A_weight">weight</code></td>
<td>
<p><code>weight</code> is matrix of frequency of site patterns for all
genes.</p>
</td></tr>
<tr><td><code id="pmlCluster_+3A_p">p</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="pmlCluster_+3A_part">part</code></td>
<td>
<p>starting partition, otherwise a random partition is generated.</p>
</td></tr>
<tr><td><code id="pmlCluster_+3A_nrep">nrep</code></td>
<td>
<p>number of replicates for each p.</p>
</td></tr>
<tr><td><code id="pmlCluster_+3A_control">control</code></td>
<td>
<p>A list of parameters for controlling the fitting process.</p>
</td></tr>
<tr><td><code id="pmlCluster_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formula</code> object allows to specify which parameter get optimized.
The formula is generally of the form <code>edge + bf + Q ~ rate + shape +
...{}</code>, on the left side are the parameters which get optimized over all
cluster, on the right the parameter which are optimized specific to each
cluster. The parameters available are <code>"nni", "bf", "Q", "inv",
"shape", "edge", "rate"</code>.  Each parameter can be used only once in the
formula.  There are also some restriction on the combinations how parameters
can get used. <code>"rate"</code> is only available for the right side.  When
<code>"rate"</code> is specified on the left hand side <code>"edge"</code> has to be
specified (on either side), if <code>"rate"</code> is specified on the right hand
side it follows directly that <code>edge</code> is too.
</p>


<h3>Value</h3>

<p><code>pmlCluster</code> returns a list with elements
</p>
<table>
<tr><td><code>logLik</code></td>
<td>
<p>log-likelihood of the fit</p>
</td></tr> <tr><td><code>trees</code></td>
<td>
<p>a list of all trees
during the optimization.</p>
</td></tr> <tr><td><code>fits</code></td>
<td>
<p>fits for the final partitions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>K. P. Schliep (2009). Some Applications of statistical
phylogenetics (PhD Thesis)
</p>
<p>Lanfear, R., Calcott, B., Ho, S.Y.W. and Guindon, S. (2012) PartitionFinder:
Combined Selection of Partitioning Schemes and Substitution Models for
Phylogenetic Analyses. <em>Molecular Biology and Evolution</em>, <b>29(6)</b>,
1695-1701
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+pml">pml</a></code>,<code><a href="phangorn.html#topic+pmlPart">pmlPart</a></code>,<code><a href="phangorn.html#topic+pmlMix">pmlMix</a></code>,
<code><a href="phangorn.html#topic+SH.test">SH.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(yeast)
dm &lt;- dist.logDet(yeast)
tree &lt;- NJ(dm)
fit &lt;- pml(tree,yeast)
fit &lt;- optim.pml(fit)

weight &lt;- xtabs(~ index+genes,attr(yeast, "index"))
set.seed(1)

sp &lt;- pmlCluster(edge~rate, fit, weight, p=1:4)
sp
SH.test(sp)

## End(Not run)

</code></pre>

<hr>
<h2 id='pmlMix'>Phylogenetic mixture model</h2><span id='topic+pmlMix'></span>

<h3>Description</h3>

<p>Phylogenetic mixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmlMix(formula, fit, m = 2, omega = rep(1/m, m),
  control = pml.control(epsilon = 1e-08, maxit = 20, trace = 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmlMix_+3A_formula">formula</code></td>
<td>
<p>a formula object (see details).</p>
</td></tr>
<tr><td><code id="pmlMix_+3A_fit">fit</code></td>
<td>
<p>an object of class <code>pml</code>.</p>
</td></tr>
<tr><td><code id="pmlMix_+3A_m">m</code></td>
<td>
<p>number of mixtures.</p>
</td></tr>
<tr><td><code id="pmlMix_+3A_omega">omega</code></td>
<td>
<p>mixing weights.</p>
</td></tr>
<tr><td><code id="pmlMix_+3A_control">control</code></td>
<td>
<p>A list of parameters for controlling the fitting process.</p>
</td></tr>
<tr><td><code id="pmlMix_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formula</code> object allows to specify which parameter get optimized.
The formula is generally of the form <code>edge + bf + Q ~ rate + shape +
...{}</code>, on the left side are the parameters which get optimized over all
mixtures, on the right the parameter which are optimized specific to each
mixture. The parameters available are <code>"nni", "bf", "Q", "inv",
"shape", "edge", "rate"</code>.  Each parameters can be used only once in the
formula.  <code>"rate"</code> and <code>"nni"</code> are only available for the right
side of the formula. On the other hand parameters for invariable sites are
only allowed on the left-hand side.  The convergence of the algorithm is
very slow and is likely that the algorithm can get stuck in local optima.
</p>


<h3>Value</h3>

<p><code>pmlMix</code> returns a list with elements
</p>
<table>
<tr><td><code>logLik</code></td>
<td>
<p>log-likelihood of the fit</p>
</td></tr> <tr><td><code>omega</code></td>
<td>
<p>mixing weights.</p>
</td></tr>
<tr><td><code>fits</code></td>
<td>
<p>fits for the final mixtures.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+pml">pml</a></code>,<code><a href="phangorn.html#topic+pmlPart">pmlPart</a></code>,<code><a href="phangorn.html#topic+pmlCluster">pmlCluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
X &lt;- allSitePattern(5)
tree &lt;- read.tree(text = "((t1:0.3,t2:0.3):0.1,(t3:0.3,t4:0.3):0.1,t5:0.5);")
fit &lt;- pml(tree,X, k=4)
weights &lt;- 1000*exp(fit$siteLik)
attr(X, "weight") &lt;- weights
fit1 &lt;- update(fit, data=X, k=1)
fit2 &lt;- update(fit, data=X)

(fitMixture &lt;- pmlMix(edge~rate, fit1 , m=4))
(fit2 &lt;- optim.pml(fit2, optGamma=TRUE))


data(Laurasiatherian)
dm &lt;- dist.logDet(Laurasiatherian)
tree &lt;- NJ(dm)
fit &lt;- pml(tree, Laurasiatherian)
fit &lt;- optim.pml(fit)

fit2 &lt;- update(fit, k=4)
fit2 &lt;- optim.pml(fit2, optGamma=TRUE)

fitMix &lt;- pmlMix(edge ~ rate, fit, m=4)
fitMix


#
# simulation of mixture models
#
X &lt;- allSitePattern(5)
tree1 &lt;- read.tree(text = "((t1:0.1,t2:0.5):0.1,(t3:0.1,t4:0.5):0.1,t5:0.5);")
tree2 &lt;- read.tree(text = "((t1:0.5,t2:0.1):0.1,(t3:0.5,t4:0.1):0.1,t5:0.5);")
tree1 &lt;- unroot(tree1)
tree2 &lt;- unroot(tree2)
fit1 &lt;- pml(tree1,X)
fit2 &lt;- pml(tree2,X)

weights &lt;- 2000*exp(fit1$siteLik) + 1000*exp(fit2$siteLik)
attr(X, "weight") &lt;- weights

fit1 &lt;- pml(tree1, X)
fit2 &lt;- optim.pml(fit1)
logLik(fit2)
AIC(fit2, k=log(3000))

fitMixEdge &lt;- pmlMix( ~ edge, fit1, m=2)
logLik(fitMixEdge)
AIC(fitMixEdge, k=log(3000))

fit.p &lt;- pmlPen(fitMixEdge, .25)
logLik(fit.p)
AIC(fit.p, k=log(3000))

## End(Not run)

</code></pre>

<hr>
<h2 id='print.phyDat'>Generic functions for class phyDat</h2><span id='topic+print.phyDat'></span><span id='topic+cbind.phyDat'></span><span id='topic+c.phyDat'></span><span id='topic+removeUndeterminedSites'></span><span id='topic+subset.phyDat'></span><span id='topic++5B.phyDat'></span><span id='topic+unique.phyDat'></span><span id='topic+removeAmbiguousSites'></span><span id='topic+allSitePattern'></span>

<h3>Description</h3>

<p>These functions help to manipulate alignments of class phyDat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phyDat'
print(x, ...)

## S3 method for class 'phyDat'
subset(x, subset, select, site.pattern = TRUE, ...)

## S3 method for class 'phyDat'
x[i, j, ..., drop = FALSE]

## S3 method for class 'phyDat'
unique(x, incomparables = FALSE, identical = TRUE, ...)

removeUndeterminedSites(x, ...)

removeAmbiguousSites(x)

allSitePattern(n, levels = NULL, names = NULL, type = "DNA", code = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.phyDat_+3A_x">x</code></td>
<td>
<p>An object containing sequences.</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_subset">subset</code></td>
<td>
<p>a subset of taxa.</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_select">select</code></td>
<td>
<p>a subset of characters.</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_site.pattern">site.pattern</code></td>
<td>
<p>select site pattern or sites (see details).</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_i">i</code>, <code id="print.phyDat_+3A_j">j</code></td>
<td>
<p>indices of the rows and/or columns to select or to drop. They
may be numeric, logical, or character (in the same way than for standard R
objects).</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_drop">drop</code></td>
<td>
<p>for compatibility with the generic (unused).</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_incomparables">incomparables</code></td>
<td>
<p>for compatibility with unique.</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_identical">identical</code></td>
<td>
<p>if TRUE (default) sequences have to be identical, if FALSE
sequences are considered duplicates if distance between sequences is zero
(happens frequently with ambiguous sites).</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_n">n</code></td>
<td>
<p>Number of sequences.</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_levels">levels</code></td>
<td>
<p>Level attributes.</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_names">names</code></td>
<td>
<p>Names of sequences.</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_type">type</code></td>
<td>
<p>Type of sequences (&quot;DNA&quot;, &quot;AA&quot; or &quot;USER&quot;).</p>
</td></tr>
<tr><td><code id="print.phyDat_+3A_code">code</code></td>
<td>
<p>The ncbi genetic code number for translation.
By default the standard genetic code is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>allSitePattern</code> generates all possible site patterns and can be useful
in simulation studies. For further details see the vignette
AdvancedFeatures.
</p>
<p>The generic function <code>c</code> can be used to to combine sequences and
<code>unique</code> to get all unique sequences or unique haplotypes.
</p>
<p><code>phyDat</code> stores identical columns of an alignment only once and keeps an
index of the original positions. This saves memory and especially
computations as these are usually need to be done only once for each site
pattern.
In the example below the matrix x in the example has 8 columns, but column 1
and 2 and also 3 and 5 are identical. The <code>phyDat</code> object y has only 6
site pattern. If argument <code>site.pattern=FALSE</code> the indexing behaves like
on the original matrix x. <code>site.pattern=TRUE</code> can be useful inside
functions.
</p>


<h3>Value</h3>

<p>The functions return an object of class <code>phyDat</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+DNAbin">DNAbin</a></code>, <code><a href="ape.html#topic+as.DNAbin">as.DNAbin</a></code>,
<code><a href="phangorn.html#topic+baseFreq">baseFreq</a></code>, <code><a href="phangorn.html#topic+glance.phyDat">glance.phyDat</a></code>, <code><a href="phangorn.html#topic+dna2codon">dna2codon</a></code>,
<code><a href="ape.html#topic+read.dna">read.dna</a></code>, <code><a href="phangorn.html#topic+read.aa">read.aa</a></code>, <code><a href="ape.html#topic+read.nexus.data">read.nexus.data</a></code>
and the chapter 1 in the <code>vignette("AdvancedFeatures",
package="phangorn")</code> and the example of <code><a href="phangorn.html#topic+pmlMix">pmlMix</a></code> for the use of
<code><a href="phangorn.html#topic+allSitePattern">allSitePattern</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
class(Laurasiatherian)
Laurasiatherian
# base frequencies
baseFreq(Laurasiatherian)
# subsetting phyDat objects
# the first 5 sequences
subset(Laurasiatherian, subset=1:5)
# the first 5 characters
subset(Laurasiatherian, select=1:5, site.pattern = FALSE)
# subsetting with []
Laurasiatherian[1:5, 1:20]
# short for
subset(Laurasiatherian, subset=1:5, select=1:20, site.pattern = FALSE)
# the first 5 site patterns (often more than 5 characters)
subset(Laurasiatherian, select=1:5, site.pattern = TRUE)

x &lt;- matrix(c("a", "a", "c", "g", "c", "t", "a", "g",
              "a", "a", "c", "g", "c", "t", "a", "g",
              "a", "a", "c", "c", "c", "t", "t", "g"), nrow=3, byrow = TRUE,
            dimnames = list(c("t1", "t2", "t3"), 1:8))
(y &lt;- phyDat(x))

subset(y, 1:2)
subset(y, 1:2, compress=TRUE)

subset(y, select=1:3, site.pattern = FALSE) |&gt; as.character()
subset(y, select=1:3, site.pattern = TRUE) |&gt; as.character()
y[,1:3] # same as subset(y, select=1:3, site.pattern = FALSE)

# Compute all possible site patterns
# for nucleotides there $4 ^ (number of tips)$ patterns
allSitePattern(5)

</code></pre>

<hr>
<h2 id='read.aa'>Read Amino Acid Sequences in a File</h2><span id='topic+read.aa'></span>

<h3>Description</h3>

<p>This function reads amino acid sequences in a file, and returns a matrix
list of DNA sequences with the names of the taxa read in the file as row
names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.aa(file, format = "interleaved", skip = 0, nlines = 0,
  comment.char = "#", seq.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.aa_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character, or
a double-quoted string.</p>
</td></tr>
<tr><td><code id="read.aa_+3A_format">format</code></td>
<td>
<p>a character string specifying the format of the DNA sequences.
Three choices are possible: <code>"interleaved"</code>, <code>"sequential"</code>, or
<code>"fasta"</code>, or any unambiguous abbreviation of these.</p>
</td></tr>
<tr><td><code id="read.aa_+3A_skip">skip</code></td>
<td>
<p>the number of lines of the input file to skip before beginning
to read data.</p>
</td></tr>
<tr><td><code id="read.aa_+3A_nlines">nlines</code></td>
<td>
<p>the number of lines to be read (by default the file is read
until its end).</p>
</td></tr>
<tr><td><code id="read.aa_+3A_comment.char">comment.char</code></td>
<td>
<p>a single character, the remaining of the line after this
character is ignored.</p>
</td></tr>
<tr><td><code id="read.aa_+3A_seq.names">seq.names</code></td>
<td>
<p>the names to give to each sequence; by default the names
read in the file are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of amino acid sequences.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>


<p><a href="https://en.wikipedia.org/wiki/FASTA_format">https://en.wikipedia.org/wiki/FASTA_format</a>
</p>
<p>Felsenstein, J. (1993) Phylip (Phylogeny Inference Package) version 3.5c.
Department of Genetics, University of Washington.
<a href="https://evolution.genetics.washington.edu/phylip/phylip.html">https://evolution.genetics.washington.edu/phylip/phylip.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+read.dna">read.dna</a></code>, <code><a href="ape.html#topic+read.GenBank">read.GenBank</a></code>,
<code><a href="#topic+phyDat">phyDat</a></code>, <code><a href="seqinr.html#topic+read.alignment">read.alignment</a></code>
</p>

<hr>
<h2 id='read.nexus.splits'>Function to import and export splits and networks</h2><span id='topic+read.nexus.splits'></span><span id='topic+write.nexus.splits'></span><span id='topic+write.nexus.networx'></span><span id='topic+read.nexus.networx'></span><span id='topic+write.splits'></span>

<h3>Description</h3>

<p><code>read.nexus.splits</code>, <code>write.nexus.splits</code>,
<code>read.nexus.networx</code>, <code>write.nexus.networx</code>
can be used to import and export splits and networks with nexus format
and allow to exchange these object with other software like SplitsTree.
<code>write.splits</code> returns a human readable output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.nexus.splits(file)

write.nexus.splits(obj, file = "", weights = NULL, taxa = TRUE,
  append = FALSE)

write.nexus.networx(obj, file = "", taxa = TRUE, splits = TRUE,
  append = FALSE)

read.nexus.networx(file, splits = TRUE)

write.splits(x, file = "", zero.print = ".", one.print = "|",
  print.labels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.nexus.splits_+3A_file">file</code></td>
<td>
<p>a file name.</p>
</td></tr>
<tr><td><code id="read.nexus.splits_+3A_obj">obj</code></td>
<td>
<p>An object of class splits.</p>
</td></tr>
<tr><td><code id="read.nexus.splits_+3A_weights">weights</code></td>
<td>
<p>Edge weights.</p>
</td></tr>
<tr><td><code id="read.nexus.splits_+3A_taxa">taxa</code></td>
<td>
<p>logical. If TRUE a taxa block is added</p>
</td></tr>
<tr><td><code id="read.nexus.splits_+3A_append">append</code></td>
<td>
<p>logical. If TRUE the nexus blocks will be added to a file.</p>
</td></tr>
<tr><td><code id="read.nexus.splits_+3A_splits">splits</code></td>
<td>
<p>logical. If TRUE the nexus blocks will be added to a file.</p>
</td></tr>
<tr><td><code id="read.nexus.splits_+3A_x">x</code></td>
<td>
<p>An object of class splits.</p>
</td></tr>
<tr><td><code id="read.nexus.splits_+3A_zero.print">zero.print</code></td>
<td>
<p>character which should be printed for zeros.</p>
</td></tr>
<tr><td><code id="read.nexus.splits_+3A_one.print">one.print</code></td>
<td>
<p>character which should be printed for ones.</p>
</td></tr>
<tr><td><code id="read.nexus.splits_+3A_print.labels">print.labels</code></td>
<td>
<p>logical. If TRUE labels are printed.</p>
</td></tr>
<tr><td><code id="read.nexus.splits_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="read.nexus.splits_+3A_labels">labels</code></td>
<td>
<p>names of taxa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>write.nexus.splits</code> and <code>write.nexus.networx</code> write out
the <code>splits</code> and <code>networx</code> object to read with
other software like SplitsTree.
<code>read.nexus.splits</code> and <code>read.nexus.networx</code> return an
<code>splits</code> and <code>networx</code> object.
</p>


<h3>Note</h3>

<p><code>read.nexus.splits</code> reads in the splits block of a nexus file. It
assumes that different co-variables are tab delimited and the bipartition
are separated with white-space. Comments in square brackets are ignored.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+prop.part">prop.part</a></code>, <code><a href="phangorn.html#topic+lento">lento</a></code>,
<code><a href="phangorn.html#topic+as.splits">as.splits</a></code>, <code><a href="haplotypes.html#topic+as.networx">as.networx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(sp &lt;- as.splits(rtree(5)))
write.nexus.splits(sp)
spl &lt;- allCircularSplits(5)
plot(as.networx(spl))
write.splits(spl, print.labels = FALSE)

</code></pre>

<hr>
<h2 id='read.phyDat'>Import and export sequence alignments</h2><span id='topic+read.phyDat'></span><span id='topic+write.phyDat'></span>

<h3>Description</h3>

<p>These functions read and write sequence alignments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.phyDat(file, format = "phylip", type = "DNA", ...)

write.phyDat(x, file, format = "phylip", colsep = "", nbcol = -1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.phyDat_+3A_file">file</code></td>
<td>
<p>a file name specified by either a variable of mode character, or
a double-quoted string.</p>
</td></tr>
<tr><td><code id="read.phyDat_+3A_format">format</code></td>
<td>
<p>File format of the sequence alignment (see details).  Several
popular formats are supported: &quot;phylip&quot;, &quot;interleaved&quot;, &quot;sequential&quot;,
&quot;clustal&quot;, &quot;fasta&quot; or &quot;nexus&quot;, or any unambiguous abbreviation of these.</p>
</td></tr>
<tr><td><code id="read.phyDat_+3A_type">type</code></td>
<td>
<p>Type of sequences (&quot;DNA&quot;, &quot;AA&quot;, &quot;CODON&quot; or &quot;USER&quot;).</p>
</td></tr>
<tr><td><code id="read.phyDat_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="read.phyDat_+3A_x">x</code></td>
<td>
<p>An object of class <code>phyDat</code>.</p>
</td></tr>
<tr><td><code id="read.phyDat_+3A_colsep">colsep</code></td>
<td>
<p>a character used to separate the columns (a single space by
default).</p>
</td></tr>
<tr><td><code id="read.phyDat_+3A_nbcol">nbcol</code></td>
<td>
<p>a numeric specifying the number of columns per row (-1 by
default); may be negative implying that the nucleotides are printed on a
single line.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>write.phyDat</code> calls the function <code><a href="ape.html#topic+write.dna">write.dna</a></code> or
<code><a href="ape.html#topic+write.nexus.data">write.nexus.data</a></code> and <code>read.phyDat</code> calls the function
<code><a href="ape.html#topic+read.dna">read.dna</a></code>, <code>read.aa</code> or <code>read.nexus.data</code>, so see
for more details over there.
</p>
<p>You may import data directly with <code><a href="ape.html#topic+read.dna">read.dna</a></code> or
<code><a href="ape.html#topic+read.nexus.data">read.nexus.data</a></code> and convert the data to class phyDat.
</p>


<h3>Value</h3>

<p><code>read.phyDat</code> returns an object of class phyDat,
<code>write.phyDat</code> write an alignment to a file.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>


<p><a href="https://www.ncbi.nlm.nih.gov/blast/fasta.shtml">https://www.ncbi.nlm.nih.gov/blast/fasta.shtml</a> Felsenstein, J. (1993)
Phylip (Phylogeny Inference Package) version 3.5c. Department of Genetics,
University of Washington.
<a href="https://evolution.genetics.washington.edu/phylip/phylip.html">https://evolution.genetics.washington.edu/phylip/phylip.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+read.dna">read.dna</a></code>, <code><a href="ape.html#topic+read.GenBank">read.GenBank</a></code>,
<code><a href="#topic+phyDat">phyDat</a></code>, <code><a href="seqinr.html#topic+read.alignment">read.alignment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdir &lt;- system.file("extdata/trees", package = "phangorn")
primates &lt;- read.phyDat(file.path(fdir, "primates.dna"),
                        format = "interleaved")
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+glance'></span><span id='topic+tidy'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='SH.test'>Shimodaira-Hasegawa Test</h2><span id='topic+SH.test'></span>

<h3>Description</h3>

<p>This function computes the Shimodaira&ndash;Hasegawa test for a set of trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SH.test(..., B = 10000, data = NULL, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SH.test_+3A_...">...</code></td>
<td>
<p>either a series of objects of class <code>"pml"</code> separated by
commas, a list containing such objects or an object of class <code>"pmlPart"</code>
or a matrix containing the site-wise likelihoods in columns.</p>
</td></tr>
<tr><td><code id="SH.test_+3A_b">B</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="SH.test_+3A_data">data</code></td>
<td>
<p>an object of class <code>"phyDat"</code>.</p>
</td></tr>
<tr><td><code id="SH.test_+3A_weight">weight</code></td>
<td>
<p>if a matrix with site (log-)likelihoods is is supplied an
optional vector containing the number of occurrences of each site pattern.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with the P-value associated with each tree given in
<code>...</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Shimodaira, H. and Hasegawa, M. (1999) Multiple comparisons of
log-likelihoods with applications to phylogenetic inference. <em>Molecular
Biology and Evolution</em>, <b>16</b>, 1114&ndash;1116.
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+pml">pml</a></code>, <code><a href="phangorn.html#topic+pmlPart">pmlPart</a></code>, <code><a href="phangorn.html#topic+pmlCluster">pmlCluster</a></code>,
<code><a href="phangorn.html#topic+SOWH.test">SOWH.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
dm &lt;- dist.logDet(Laurasiatherian)
tree1 &lt;- NJ(dm)
tree2 &lt;- unroot(upgma(dm))
fit1 &lt;- pml(tree1, Laurasiatherian)
fit2 &lt;- pml(tree2, Laurasiatherian)
fit1 &lt;- optim.pml(fit1) # optimize edge weights
fit2 &lt;- optim.pml(fit2)
# with pml objects as input
SH.test(fit1, fit2, B=1000)
# in real analysis use larger B, e.g. 10000

# with matrix as input
X &lt;- matrix(c(fit1$siteLik, fit2$siteLik), ncol=2)
SH.test(X, weight=attr(Laurasiatherian, "weight"), B=1000)
## Not run: 
example(pmlPart)
SH.test(sp, B=1000)

## End(Not run)
</code></pre>

<hr>
<h2 id='simSeq'>Simulate sequences.</h2><span id='topic+simSeq'></span><span id='topic+simSeq.phylo'></span><span id='topic+simSeq.pml'></span>

<h3>Description</h3>

<p>Simulate sequences from a given evolutionary tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simSeq(x, ...)

## S3 method for class 'phylo'
simSeq(x, l = 1000, Q = NULL, bf = NULL,
  rootseq = NULL, type = "DNA", model = NULL, levels = NULL,
  rate = 1, ancestral = FALSE, code = 1, ...)

## S3 method for class 'pml'
simSeq(x, ancestral = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simSeq_+3A_x">x</code></td>
<td>
<p>a phylogenetic tree <code>tree</code>, i.e. an object of class
<code>phylo</code> or and object of class <code>pml</code>.</p>
</td></tr>
<tr><td><code id="simSeq_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="simSeq_+3A_l">l</code></td>
<td>
<p>The length of the sequence to simulate.</p>
</td></tr>
<tr><td><code id="simSeq_+3A_q">Q</code></td>
<td>
<p>The rate matrix.</p>
</td></tr>
<tr><td><code id="simSeq_+3A_bf">bf</code></td>
<td>
<p>Base frequencies.</p>
</td></tr>
<tr><td><code id="simSeq_+3A_rootseq">rootseq</code></td>
<td>
<p>A vector of length <code>l</code> containing the root sequence.
If not provided, the root sequence is randomly generated.</p>
</td></tr>
<tr><td><code id="simSeq_+3A_type">type</code></td>
<td>
<p>Type of sequences (&quot;DNA&quot;, &quot;AA&quot;, &quot;CODON&quot; or &quot;USER&quot;).</p>
</td></tr>
<tr><td><code id="simSeq_+3A_model">model</code></td>
<td>
<p>Amino acid model of evolution to employ, for example &quot;WAG&quot;,
&quot;JTT&quot;, &quot;Dayhoff&quot; or &quot;LG&quot;. For a full list of supported models, type
<code>phangorn:::.aamodels</code>. Ignored if type is not equal to &quot;AA&quot;.</p>
</td></tr>
<tr><td><code id="simSeq_+3A_levels">levels</code></td>
<td>
<p>A character vector of the different character tokens.
Ignored unless type = &quot;USER&quot;.</p>
</td></tr>
<tr><td><code id="simSeq_+3A_rate">rate</code></td>
<td>
<p>A numerical value greater than zero giving the mutation rate
or scaler for edge lengths.</p>
</td></tr>
<tr><td><code id="simSeq_+3A_ancestral">ancestral</code></td>
<td>
<p>Logical specifying whether to return ancestral sequences.</p>
</td></tr>
<tr><td><code id="simSeq_+3A_code">code</code></td>
<td>
<p>The ncbi genetic code number for translation (see details). By
default the standard genetic code is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simSeq</code> is a generic function to simulate sequence alignments
along a phylogeny. It is quite flexible and can generate DNA, RNA,
amino acids, codon, morphological or binary sequences.
simSeq can take as input a phylogenetic tree of class <code>phylo</code>,
or a <code>pml</code> object; it will return an object of class <code>phyDat</code>.
There is also a more low level
version, which lacks rate variation, but one can combine different
alignments with their own rates (see example). The rate parameter acts like
a scaler for the edge lengths.
</p>
<p>For codon models <code>type="CODON"</code>, two additional arguments <code>dnds</code>
for the dN/dS ratio and <code>tstv</code> for the transition transversion ratio
can be supplied.
</p>
<p><strong>Defaults:</strong>
</p>
<p>If <code>x</code> is a tree of class <code>phylo</code>, then sequences will be generated
with the default Jukes-Cantor DNA model (<code>"JC"</code>).
</p>
<p>If <code>bf</code> is not specified, then all states will be treated as equally
probable.
</p>
<p>If <code>Q</code> is not specified, then a uniform rate matrix will be employed.
</p>


<h3>Value</h3>

<p><code>simSeq</code> returns an object of class phyDat.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+phyDat">phyDat</a></code>, <code><a href="phangorn.html#topic+pml">pml</a></code>, <code><a href="phangorn.html#topic+SOWH.test">SOWH.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(Laurasiatherian)
tree &lt;- nj(dist.ml(Laurasiatherian))
fit &lt;- pml(tree, Laurasiatherian, k=4)
fit &lt;- optim.pml(fit, optNni=TRUE, model="GTR", optGamma=TRUE)
data &lt;- simSeq(fit)

## End(Not run)


tree &lt;- rtree(5)
plot(tree)
nodelabels()

# Example for simple DNA alignment
data &lt;- simSeq(tree, l = 10, type="DNA", bf=c(.1,.2,.3,.4), Q=1:6,
               ancestral=TRUE)
as.character(data)


# Example to simulate discrete Gamma rate variation
rates &lt;- discrete.gamma(1,4)
data1 &lt;- simSeq(tree, l = 100, type="AA", model="WAG", rate=rates[1])
data2 &lt;- simSeq(tree, l = 100, type="AA", model="WAG", rate=rates[2])
data3 &lt;- simSeq(tree, l = 100, type="AA", model="WAG", rate=rates[3])
data4 &lt;- simSeq(tree, l = 100, type="AA", model="WAG", rate=rates[4])
data &lt;- c(data1,data2, data3, data4)

write.phyDat(data, file="temp.dat", format="sequential", nbcol = -1,
  colsep = "")
unlink("temp.dat")

</code></pre>

<hr>
<h2 id='SOWH.test'>Swofford-Olsen-Waddell-Hillis Test</h2><span id='topic+SOWH.test'></span>

<h3>Description</h3>

<p>This function computes the Swofford&ndash;Olsen&ndash;Waddell&ndash;Hillis (SOWH) test, a
parametric bootstrap test. The function is computational very demanding and
likely to be very slow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SOWH.test(x, n = 100, restricted = list(optNni = FALSE), optNni = TRUE,
  trace = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SOWH.test_+3A_x">x</code></td>
<td>
<p>an object of class <code>"pml"</code>.</p>
</td></tr>
<tr><td><code id="SOWH.test_+3A_n">n</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="SOWH.test_+3A_restricted">restricted</code></td>
<td>
<p>list of restricted parameter settings.</p>
</td></tr>
<tr><td><code id="SOWH.test_+3A_optnni">optNni</code></td>
<td>
<p>Logical value indicating whether topology gets optimized
(NNI).</p>
</td></tr>
<tr><td><code id="SOWH.test_+3A_trace">trace</code></td>
<td>
<p>Show output during computations.</p>
</td></tr>
<tr><td><code id="SOWH.test_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>"optim.pml"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SOWH.test</code> performs a parametric bootstrap test to compare two trees.
It makes extensive use <code>simSeq</code> and <code>optim.pml</code> and can take quite
long.
</p>


<h3>Value</h3>

<p>an object of class SOWH. That is a list with three elements, one is
a matrix containing for each bootstrap replicate the (log-) likelihood of
the restricted and unrestricted estimate and two pml objects of the
restricted and unrestricted model.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Goldman, N., Anderson, J. P., and Rodrigo, A. G. (2000)
Likelihood -based tests of topologies in phylogenetics. <em>Systematic
Biology</em> <b>49</b> 652-670.
</p>
<p>Swofford, D.L., Olsen, G.J., Waddell, P.J. and Hillis, D.M. (1996)
Phylogenetic Inference in Hillis, D.M., Moritz, C. and Mable, B.K. (Eds.)
<em>Molecular Systematics</em> (2nd ed.) 407-514, Sunderland, MA: Sinauer
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+pml">pml</a></code>, <code><a href="phangorn.html#topic+pmlPart">pmlPart</a></code>, <code><a href="phangorn.html#topic+pmlCluster">pmlCluster</a></code>,
<code><a href="phangorn.html#topic+simSeq">simSeq</a></code>, <code><a href="phangorn.html#topic+SH.test">SH.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# in real analysis use larger n, e.g. 500 preferably more
## Not run: 
data(Laurasiatherian)
dm &lt;- dist.logDet(Laurasiatherian)
tree &lt;- NJ(dm)
fit &lt;- pml(tree, Laurasiatherian)
fit &lt;- optim.pml(fit, TRUE)
set.seed(6)
tree &lt;- rNNI(fit$tree, 1)
fit &lt;- update(fit, tree = tree)
(res &lt;- SOWH.test(fit, n=100))
summary(res)

## End(Not run)

</code></pre>

<hr>
<h2 id='splitsNetwork'>Phylogenetic Network</h2><span id='topic+splitsNetwork'></span>

<h3>Description</h3>

<p><code>splitsNetwork</code> estimates weights for a splits graph from a distance
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitsNetwork(dm, splits = NULL, gamma = 0.1, lambda = 1e-06,
  weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitsNetwork_+3A_dm">dm</code></td>
<td>
<p>A distance matrix.</p>
</td></tr>
<tr><td><code id="splitsNetwork_+3A_splits">splits</code></td>
<td>
<p>a splits object, containing all splits to consider, otherwise
all possible splits are used</p>
</td></tr>
<tr><td><code id="splitsNetwork_+3A_gamma">gamma</code></td>
<td>
<p>penalty value for the L1 constraint.</p>
</td></tr>
<tr><td><code id="splitsNetwork_+3A_lambda">lambda</code></td>
<td>
<p>penalty value for the L2 constraint.</p>
</td></tr>
<tr><td><code id="splitsNetwork_+3A_weight">weight</code></td>
<td>
<p>a vector of weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>splitsNetwork</code> fits non-negative least-squares phylogenetic networks
using L1 (LASSO), L2(ridge regression) constraints.  The function minimizes
the penalized least squares
</p>
<p style="text-align: center;"><code class="reqn">\beta = min \sum(dm - X\beta)^2 + \lambda \|\beta \|^2_2 </code>
</p>

<p>with respect to </p>
<p style="text-align: center;"><code class="reqn">\|\beta \|_1 &lt;= \gamma, \beta &gt;= 0</code>
</p>

<p>where <code class="reqn">X</code> is a design matrix constructed with <code>designSplits</code>.
External edges are fitted without L1 or L2 constraints.
</p>


<h3>Value</h3>

<p><code>splitsNetwork</code> returns a splits object with a matrix added.
The first column contains the indices of the splits, the second column an
unconstrained fit without penalty terms and the third column the constrained
fit.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Efron, Hastie, Johnstone and Tibshirani (2004) Least Angle
Regression (with discussion) <em>Annals of Statistics</em> <b>32(2)</b>,
407&ndash;499
</p>
<p>K. P. Schliep (2009). Some Applications of statistical phylogenetics (PhD
Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distanceHadamard">distanceHadamard</a></code>,
<code><a href="#topic+designTree">designTree</a></code> <code><a href="#topic+consensusNet">consensusNet</a></code>,
<code><a href="#topic+plot.networx">plot.networx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(yeast)
dm &lt;- dist.ml(yeast)
fit &lt;- splitsNetwork(dm)
net &lt;- as.networx(fit)
plot(net)
write.nexus.splits(fit)

</code></pre>

<hr>
<h2 id='superTree'>Super Tree methods</h2><span id='topic+superTree'></span>

<h3>Description</h3>

<p>These function <code>superTree</code> allows the estimation of a supertree from a
set of trees using either Matrix representation parsimony, Robinson-Foulds
or SPR as criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superTree(tree, method = "MRP", rooted = FALSE, trace = 0,
  start = NULL, multicore = FALSE, mc.cores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superTree_+3A_tree">tree</code></td>
<td>
<p>an object of class <code>multiPhylo</code></p>
</td></tr>
<tr><td><code id="superTree_+3A_method">method</code></td>
<td>
<p>An argument defining which algorithm is used to optimize the
tree.  Possible are &quot;MRP&quot;, &quot;RF&quot;, and &quot;SPR&quot;.</p>
</td></tr>
<tr><td><code id="superTree_+3A_rooted">rooted</code></td>
<td>
<p>should the resulting supertrees be rooted.</p>
</td></tr>
<tr><td><code id="superTree_+3A_trace">trace</code></td>
<td>
<p>defines how much information is printed during optimization.</p>
</td></tr>
<tr><td><code id="superTree_+3A_start">start</code></td>
<td>
<p>a starting tree can be supplied.</p>
</td></tr>
<tr><td><code id="superTree_+3A_multicore">multicore</code></td>
<td>
<p>logical, whether models should estimated in parallel.</p>
</td></tr>
<tr><td><code id="superTree_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child
processes will be run simultaneously.</p>
</td></tr>
<tr><td><code id="superTree_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>superTree</code> extends the function mrp.supertree from Liam
Revells, with artificial adding an outgroup on the root of the trees.  This
allows to root the supertree afterwards. The functions is internally used in
DensiTree. The implementation for the RF- and SPR-supertree are very basic
so far and assume that all trees share the same set of taxa.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>phylo</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a> Liam Revell
</p>


<h3>References</h3>

<p>Baum, B. R., (1992) Combining trees as a way of combining data
sets for phylogenetic inference, and the desirability of combining gene
trees. <em>Taxon</em>, <b>41</b>, 3-10.
</p>
<p>Ragan, M. A. (1992) Phylogenetic inference based on matrix representation of
trees. <em>Molecular Phylogenetics and Evolution</em>, <b>1</b>, 53-58.
</p>


<h3>See Also</h3>

<p><code>mrp.supertree</code>, <code><a href="phangorn.html#topic+densiTree">densiTree</a></code>,
<code><a href="phangorn.html#topic+RF.dist">RF.dist</a></code>, <code><a href="phangorn.html#topic+SPR.dist">SPR.dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
set.seed(1)
bs &lt;- bootstrap.phyDat(Laurasiatherian,
                       FUN = function(x) upgma(dist.hamming(x)), bs=50)

mrp_st &lt;- superTree(bs)
plot(mrp_st)
## Not run: 
rf_st &lt;- superTree(bs, method = "RF")
spr_st &lt;- superTree(bs, method = "SPR")

## End(Not run)

</code></pre>

<hr>
<h2 id='threshStateC'>Internal phangorn Functions</h2><span id='topic+threshStateC'></span><span id='topic+candidate_tree'></span><span id='topic+hash_phylo'></span><span id='topic+coords'></span><span id='topic+phangorn-internal'></span><span id='topic+map_duplicates'></span><span id='topic+pmlPen'></span>

<h3>Description</h3>

<p>Internal <span class="pkg">phangorn</span> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshStateC(x, thresholds)

candidate_tree(x, method = c("unrooted", "ultrametric", "tipdated"),
  eps = 1e-08, tip.dates = NULL, ...)

hash_phylo(x, ...)

coords(obj, dim = "3D")

map_duplicates(x, dist = length(x) &lt; 500, ...)

pmlPen(object, lambda, ...)
</code></pre>

<hr>
<h2 id='transferBootstrap'>Transfer Bootstrap</h2><span id='topic+transferBootstrap'></span>

<h3>Description</h3>

<p><code>transferBootstrap</code> assignes transfer bootstrap (Lemoine et al. 2018)
values to the (internal) edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transferBootstrap(tree, BStrees)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transferBootstrap_+3A_tree">tree</code></td>
<td>
<p>The tree on which edges the bootstrap values are plotted.</p>
</td></tr>
<tr><td><code id="transferBootstrap_+3A_bstrees">BStrees</code></td>
<td>
<p>a list of trees (object of class &quot;multiPhylo&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plotBS</code> returns silently a tree, i.e. an object of class
<code>phylo</code> with the bootstrap values as node labels. The argument
<code>BSTrees</code> is optional and if not supplied the labels supplied
in the <code>node.label</code> slot will be used.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Lemoine, F., Entfellner, J. B. D., Wilkinson, E., Correia, D.,
Felipe, M. D., De Oliveira, T., &amp; Gascuel, O. (2018). Renewing Felsenstein‚Äôs
phylogenetic bootstrap in the era of big data. <em>Nature</em>,
<b>556(7702)</b>, 452&ndash;456.
</p>


<h3>See Also</h3>

<p><code><a href="phangorn.html#topic+plotBS">plotBS</a></code>, <code><a href="phangorn.html#topic+maxCladeCred">maxCladeCred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdir &lt;- system.file("extdata/trees", package = "phangorn")
# RAxML best-known tree with bipartition support (from previous analysis)
raxml.tree &lt;- read.tree(file.path(fdir,"RAxML_bipartitions.woodmouse"))
# RAxML bootstrap trees (from previous analysis)
raxml.bootstrap &lt;- read.tree(file.path(fdir,"RAxML_bootstrap.woodmouse"))

tree_tbe &lt;- transferBootstrap(raxml.tree,  raxml.bootstrap)
par(mfrow=c(1,2))
plotBS(tree_tbe)
# same as
plotBS(raxml.tree,  raxml.bootstrap, "p", "TBE")
</code></pre>

<hr>
<h2 id='treedist'>Distances between trees</h2><span id='topic+treedist'></span><span id='topic+sprdist'></span><span id='topic+SPR.dist'></span><span id='topic+RF.dist'></span><span id='topic+wRF.dist'></span><span id='topic+KF.dist'></span><span id='topic+path.dist'></span>

<h3>Description</h3>

<p><code>treedist</code> computes different tree distance methods and <code>RF.dist</code>
the Robinson-Foulds or symmetric distance. The Robinson-Foulds distance only
depends on the topology of the trees. If edge weights should be considered
<code>wRF.dist</code> calculates the weighted RF distance (Robinson &amp; Foulds
1981). and <code>KF.dist</code> calculates the branch score distance (Kuhner &amp;
Felsenstein 1994).  <code>path.dist</code> computes the path difference metric as
described in Steel and Penny 1993).
<code>sprdist</code> computes the approximate SPR distance (Oliveira Martins et
al. 2008, de Oliveira Martins 2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treedist(tree1, tree2, check.labels = TRUE)

sprdist(tree1, tree2)

SPR.dist(tree1, tree2 = NULL)

RF.dist(tree1, tree2 = NULL, normalize = FALSE, check.labels = TRUE,
  rooted = FALSE)

wRF.dist(tree1, tree2 = NULL, normalize = FALSE, check.labels = TRUE,
  rooted = FALSE)

KF.dist(tree1, tree2 = NULL, check.labels = TRUE, rooted = FALSE)

path.dist(tree1, tree2 = NULL, check.labels = TRUE, use.weight = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treedist_+3A_tree1">tree1</code></td>
<td>
<p>A phylogenetic tree (class <code>phylo</code>) or vector of trees (an
object of class <code>multiPhylo</code>). See details</p>
</td></tr>
<tr><td><code id="treedist_+3A_tree2">tree2</code></td>
<td>
<p>A phylogenetic tree.</p>
</td></tr>
<tr><td><code id="treedist_+3A_check.labels">check.labels</code></td>
<td>
<p>compares labels of the trees.</p>
</td></tr>
<tr><td><code id="treedist_+3A_normalize">normalize</code></td>
<td>
<p>compute normalized RF-distance, see details.</p>
</td></tr>
<tr><td><code id="treedist_+3A_rooted">rooted</code></td>
<td>
<p>take bipartitions for rooted trees into account, default is
unrooting the trees.</p>
</td></tr>
<tr><td><code id="treedist_+3A_use.weight">use.weight</code></td>
<td>
<p>use edge.length argument or just count number of edges on
the path (default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Robinson-Foulds distance between two trees <code class="reqn">T_1</code> and
<code class="reqn">T_2</code> with <code class="reqn">n</code> tips is defined as (following the notation Steel and
Penny 1993):
</p>
<p style="text-align: center;"><code class="reqn">d(T_1, T_2) = i(T_1) + i(T_2) - 2v_s(T_1, T_2)</code>
</p>
<p> where <code class="reqn">i(T_1)</code>
denotes the number of internal edges and <code class="reqn">v_s(T_1, T_2)</code> denotes the
number of internal splits shared by the two trees. The normalized
Robinson-Foulds distance is derived by dividing <code class="reqn">d(T_1, T_2)</code> by the
maximal possible distance <code class="reqn">i(T_1) + i(T_2)</code>. If both trees are unrooted
and binary this value is <code class="reqn">2n-6</code>.
</p>
<p>Functions like <code>RF.dist</code> returns the Robinson-Foulds distance (Robinson
and Foulds 1981) between either 2 trees or computes a matrix of all pairwise
distances if a <code>multiPhylo</code> object is given.
</p>
<p>For large number of trees the distance functions can use a lot of memory!
</p>


<h3>Value</h3>

<p><code>treedist</code> returns a vector containing the following tree
distance methods </p>
<table>
<tr><td><code>symmetric.difference</code></td>
<td>
<p>symmetric.difference or
Robinson-Foulds distance</p>
</td></tr>
<tr><td><code>branch.score.difference</code></td>
<td>
<p>branch.score.difference</p>
</td></tr>
<tr><td><code>path.difference</code></td>
<td>
<p>path.difference</p>
</td></tr>
<tr><td><code>weighted.path.difference</code></td>
<td>
<p>weighted.path.difference</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus P. Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>,
Leonardo de Oliveira Martins
</p>


<h3>References</h3>

<p>de Oliveira Martins L., Leal E., Kishino H. (2008)
<em>Phylogenetic Detection of Recombination with a Bayesian Prior on the
Distance between Trees</em>. PLoS ONE <b>3(7)</b>. e2651. doi:
10.1371/journal.pone.0002651
</p>
<p>de Oliveira Martins L., Mallo D., Posada D. (2016) <em>A Bayesian
Supertree Model for Genome-Wide Species Tree Reconstruction</em>. Syst. Biol.
<b>65(3)</b>: 397-416, doi:10.1093/sysbio/syu082
</p>
<p>Steel M. A. and Penny P. (1993) <em>Distributions of tree comparison
metrics - some new results</em>, Syst. Biol., <b>42(2)</b>, 126&ndash;141
</p>
<p>Kuhner, M. K. and Felsenstein, J. (1994) <em>A simulation comparison of
phylogeny algorithms under equal and unequal evolutionary rates</em>, Molecular
Biology and Evolution, <b>11(3)</b>, 459&ndash;468
</p>
<p>D.F. Robinson and L.R. Foulds (1981) <em>Comparison of phylogenetic
trees</em>, Mathematical Biosciences, <b>53(1)</b>, 131&ndash;147
</p>
<p>D.F. Robinson and L.R. Foulds (1979) Comparison of weighted labelled trees.
In Horadam, A. F. and Wallis, W. D. (Eds.), <em>Combinatorial Mathematics
VI: Proceedings of the Sixth Australian Conference on Combinatorial
Mathematics, Armidale, Australia</em>, 119&ndash;126
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+dist.topo">dist.topo</a></code>, <code><a href="phangorn.html#topic+nni">nni</a></code>,
<code><a href="phangorn.html#topic+superTree">superTree</a></code>, <code><a href="phangorn.html#topic+mast">mast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tree1 &lt;- rtree(100, rooted=FALSE)
tree2 &lt;- rSPR(tree1, 3)
RF.dist(tree1, tree2)
treedist(tree1, tree2)
sprdist(tree1, tree2)
trees &lt;- rSPR(tree1, 1:5)
SPR.dist(tree1, trees)

</code></pre>

<hr>
<h2 id='upgma'>UPGMA and WPGMA</h2><span id='topic+upgma'></span><span id='topic+wpgma'></span>

<h3>Description</h3>

<p>UPGMA and WPGMA clustering. Just a wrapper function around
<code><a href="stats.html#topic+hclust">hclust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upgma(D, method = "average", ...)

wpgma(D, method = "mcquitty", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upgma_+3A_d">D</code></td>
<td>
<p>A distance matrix.</p>
</td></tr>
<tr><td><code id="upgma_+3A_method">method</code></td>
<td>
<p>The agglomeration method to be used. This should be (an
unambiguous abbreviation of) one of &quot;ward&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;,
&quot;mcquitty&quot;, &quot;median&quot; or &quot;centroid&quot;. The default is &quot;average&quot;.</p>
</td></tr>
<tr><td><code id="upgma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A phylogenetic tree of class <code>phylo</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="phangorn.html#topic+dist.hamming">dist.hamming</a></code>, <code><a href="phangorn.html#topic+NJ">NJ</a></code>,
<code><a href="ape.html#topic+as.phylo">as.phylo</a></code>, <code><a href="ape.html#topic+fastme">fastme</a></code>, <code><a href="phangorn.html#topic+nnls.tree">nnls.tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Laurasiatherian)
dm &lt;- dist.ml(Laurasiatherian)
tree &lt;- upgma(dm)
plot(tree)

</code></pre>

<hr>
<h2 id='writeDist'>Writing and reading distances in phylip and nexus format</h2><span id='topic+writeDist'></span><span id='topic+write.nexus.dist'></span><span id='topic+readDist'></span><span id='topic+read.nexus.dist'></span><span id='topic+unique.dist'></span>

<h3>Description</h3>

<p><code>readDist</code>, <code>writeDist</code> and <code>write.nexus.dist</code> are useful to
exchange distance matrices with other phylogenetic programs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeDist(x, file = "", format = "phylip", ...)

write.nexus.dist(x, file = "", append = FALSE, upper = FALSE,
  diag = TRUE, digits = getOption("digits"), taxa = !append)

readDist(file, format = "phylip")

read.nexus.dist(file)

## S3 method for class 'dist'
unique(x, incomparables, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeDist_+3A_x">x</code></td>
<td>
<p>A <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="writeDist_+3A_file">file</code></td>
<td>
<p>A file name.</p>
</td></tr>
<tr><td><code id="writeDist_+3A_format">format</code></td>
<td>
<p>file format, default is &quot;phylip&quot;, only other option so far is
&quot;nexus&quot;.</p>
</td></tr>
<tr><td><code id="writeDist_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="writeDist_+3A_append">append</code></td>
<td>
<p>logical. If TRUE the nexus blocks will be added to a file.</p>
</td></tr>
<tr><td><code id="writeDist_+3A_upper">upper</code></td>
<td>
<p>logical value indicating whether the upper triangle of the
distance matrix should be printed.</p>
</td></tr>
<tr><td><code id="writeDist_+3A_diag">diag</code></td>
<td>
<p>logical value indicating whether the diagonal of the distance
matrix should be printed.</p>
</td></tr>
<tr><td><code id="writeDist_+3A_digits">digits</code></td>
<td>
<p>passed to format inside of <code>write.nexus.dist</code>.</p>
</td></tr>
<tr><td><code id="writeDist_+3A_taxa">taxa</code></td>
<td>
<p>logical. If TRUE a taxa block is added.</p>
</td></tr>
<tr><td><code id="writeDist_+3A_incomparables">incomparables</code></td>
<td>
<p>Not used so far.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>dist</code>
</p>


<h3>Author(s)</h3>

<p>Klaus Schliep <a href="mailto:klaus.schliep@gmail.com">klaus.schliep@gmail.com</a>
</p>


<h3>References</h3>

<p>Maddison, D. R., Swofford, D. L. and Maddison, W. P. (1997)
NEXUS: an extensible file format for systematic information.
<em>Systematic Biology</em>, <b>46</b>, 590&ndash;621.
</p>


<h3>See Also</h3>

<p>To compute distance matrices see <code><a href="phangorn.html#topic+dist.ml">dist.ml</a></code>
<code><a href="ape.html#topic+dist.dna">dist.dna</a></code> and <code><a href="phangorn.html#topic+dist.p">dist.p</a></code> for pairwise
polymorphism p-distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(yeast)
dm &lt;- dist.ml(yeast)
writeDist(dm)
write.nexus.dist(dm)

</code></pre>

<hr>
<h2 id='yeast'>Yeast alignment (Rokas et al.)</h2><span id='topic+yeast'></span>

<h3>Description</h3>

<p>Alignment of 106 genes of 8 different species of yeast.
</p>


<h3>References</h3>

<p>Rokas, A., Williams, B. L., King, N., and Carroll, S. B. (2003)
Genome-scale approaches to resolving incongruence in molecular phylogenies.
<em>Nature</em>, <b>425</b>(6960): 798&ndash;804
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(yeast)
str(yeast)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
