<!DOCTYPE html><html><head><title>Help for package triggerstrategy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {triggerstrategy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alpha2boundary'><p>Convert cumulative alpha levels to normal critical boundaries</p></a></li>
<li><a href='#boundary2alpha'><p>Convert normal critical boundaries to cumulative alpha levels.</p></a></li>
<li><a href='#corrMatGenerator'><p>Correlation matrix generator</p></a></li>
<li><a href='#gbounds'><p>Critical boundary in group sequential trials</p></a></li>
<li><a href='#marginalPwR'><p>Marginal Power Rate</p></a></li>
<li><a href='#psPwRbhmb'><p>Powers of testing the primary and secondary hypotheses</p></a></li>
<li><a href='#psPwRtrigger'><p>Powers of testing the primary and secondary hypotheses using trigger strategy</p></a></li>
<li><a href='#sBoundsPh2'><p>Critical boundaries for the secondary endpoint in the partially hierarchical group sequential design</p></a></li>
<li><a href='#sErrRphInt2'><p>Type I error rate of the overall null hypothesis using the partial hierarchical design</p></a></li>
<li><a href='#solveAlphaXsampleSize'><p>Sample size calculation</p></a></li>
<li><a href='#solveAlphaXsampleSizeGA'><p>Sample size calculation using Genetic Algorithms</p></a></li>
<li><a href='#sPwRholm'><p>Power of testing the secondary hypothesis using Holm</p></a></li>
<li><a href='#sPwRholmye'><p>Power of testing the secondary hypothesis using Holm-Ye</p></a></li>
<li><a href='#sPwRnaiveBonf'><p>Power of testing the secondary hypothesis using Bonferroni</p></a></li>
<li><a href='#sPwRph2'><p>Power of testing the secondary hypothesis in partially hierarchical design</p></a></li>
<li><a href='#sPwRtrigger'><p>Power of testing the secondary hypothesis using Trigger strategy</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Trigger Strategy in Clinical Trials</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-02</td>
</tr>
<tr>
<td>Description:</td>
<td>The trigger strategy is a general framework for a multistage statistical design with multiple hypotheses, allowing an adaptive selection of interim analyses. The selection of interim stages can be associated with some prespecified endpoints which serve as the trigger. This selection allows us to refine the critical boundaries in hypotheses testing procedures, and potentially increase the statistical power. This package includes several trial designs using the trigger strategy. 
    See Gou, J. (2023), "Trigger strategy in repeated tests on multiple hypotheses", Statistics in Biopharmaceutical Research, 15(1), 133-140, and Gou, J. (2022), "Sample size optimization and initial allocation of the significance levels in group sequential trials with multiple endpoints", Biometrical Journal, 64(2), 301-311.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>GA (&ge; 3.0.0), ldbounds (&ge; 2.0.0), mvtnorm (&ge; 1.1.0),
nleqslv (&ge; 3.0.0), stats (&ge; 4.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-02 17:40:34 UTC; psystat</td>
</tr>
<tr>
<td>Author:</td>
<td>Jiangtao Gou [aut, cre],
  Fengqing (Zoe) Zhang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jiangtao Gou &lt;gouRpackage@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-04 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alpha2boundary'>Convert cumulative alpha levels to normal critical boundaries</h2><span id='topic+alpha2boundary'></span>

<h3>Description</h3>

<p>This function converts cumulative alpha levels into normal critical boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha2boundary(
  alphas,
  t,
  initIntvl = c(1, 2 * stats::qnorm(p = alphas[1], lower.tail = FALSE))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha2boundary_+3A_alphas">alphas</code></td>
<td>
<p>a list of cumulative errors from some error spending functions</p>
</td></tr>
<tr><td><code id="alpha2boundary_+3A_t">t</code></td>
<td>
<p>a vector of information times</p>
</td></tr>
<tr><td><code id="alpha2boundary_+3A_initintvl">initIntvl</code></td>
<td>
<p>a pair of numbers as the lower and upper bounds of critical boundaries, used for <code>stats::uniroot</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current version of <code>ldbounds::ldBounds</code> may not work for Hwang-Shih-DeCani boundaries.
</p>


<h3>Value</h3>

<p>a vector of critical boundaries
</p>


<h3>Author(s)</h3>

<p>Jiangtao Gou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ldbounds)
tvec &lt;- c(0.5,1)
result &lt;- ldbounds::ldBounds(t=tvec, iuse=1, alpha=0.05, sides=1)
print(result$upper.bounds)
bd &lt;- alpha2boundary(alphas = result$exit.pr, t=tvec)
print(bd)
</code></pre>

<hr>
<h2 id='boundary2alpha'>Convert normal critical boundaries to cumulative alpha levels.</h2><span id='topic+boundary2alpha'></span>

<h3>Description</h3>

<p>This function converts normal critical boundaries to cumulative alpha levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundary2alpha(cvec, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundary2alpha_+3A_cvec">cvec</code></td>
<td>
<p>a vector of critical boundaries</p>
</td></tr>
<tr><td><code id="boundary2alpha_+3A_t">t</code></td>
<td>
<p>a vector of information times</p>
</td></tr>
</table>


<h3>Value</h3>

<p>alphas, a vector of cumulative errors
</p>


<h3>Author(s)</h3>

<p>Jiangtao Gou
</p>
<p>Fengqing Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- c(0.5,0.8,1)
iuse &lt;- 4
result &lt;- gbounds(t=t, iuse=iuse)
print(result)
boundary2alpha(cvec=result$bd, t=t)
</code></pre>

<hr>
<h2 id='corrMatGenerator'>Correlation matrix generator</h2><span id='topic+corrMatGenerator'></span>

<h3>Description</h3>

<p>This function generate the correlation matrix for group sequential trials with two endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrMatGenerator(tp, ts, rhops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrMatGenerator_+3A_tp">tp</code></td>
<td>
<p>an information fraction vector of Hp</p>
</td></tr>
<tr><td><code id="corrMatGenerator_+3A_ts">ts</code></td>
<td>
<p>an information fraction vector of Hs</p>
</td></tr>
<tr><td><code id="corrMatGenerator_+3A_rhops">rhops</code></td>
<td>
<p>a number that shows the correlation coefficient between the test statistics of the primary endpoint and that of the secondary endpoint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the correlation matrix, Hp goes first, and Hs goes second.
</p>


<h3>Author(s)</h3>

<p>Jiangtao Gou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corrMatGenerator(tp=c(0.64,1),
    ts=c(0.25,0.49,1),
    rhops=1)
</code></pre>

<hr>
<h2 id='gbounds'>Critical boundary in group sequential trials</h2><span id='topic+gbounds'></span>

<h3>Description</h3>

<p>This function computes the critical boundaries and the error spent until each stage in group sequential trials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbounds(t, iuse = 1, alpha = 0.05, phi = rep(1, length(alpha)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbounds_+3A_t">t</code></td>
<td>
<p>a vector of information times</p>
</td></tr>
<tr><td><code id="gbounds_+3A_iuse">iuse</code></td>
<td>
<p>a number of the type of the error spending function, from -2, -1, 1, 2, 3, 4</p>
</td></tr>
<tr><td><code id="gbounds_+3A_alpha">alpha</code></td>
<td>
<p>a number of type I error rate</p>
</td></tr>
<tr><td><code id="gbounds_+3A_phi">phi</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the original Pocock is implemented, we specify <code>iuse=-2</code>. If the original OBrien-Flemming is implemented, we specify <code>iuse=-1</code>.
</p>


<h3>Value</h3>

<p>a list of two vectors: <code>bd</code> critical boundaries, <code>er</code> error spent until each stage
</p>


<h3>Author(s)</h3>

<p>Jiangtao Gou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t&lt;-c(0.5,0.8,1)
iuse &lt;- 4
gbounds(t=t, iuse=iuse)
gbounds(t=(1:5)/5, iuse=4, alpha=0.01, phi=-4)
gbounds(t=(1:5)/5, iuse=-2, alpha=0.01)
</code></pre>

<hr>
<h2 id='marginalPwR'>Marginal Power Rate</h2><span id='topic+marginalPwR'></span>

<h3>Description</h3>

<p>This function computes the marginal powers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalPwR(cvec, t, delta = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalPwR_+3A_cvec">cvec</code></td>
<td>
<p>a vector of critical boundaries</p>
</td></tr>
<tr><td><code id="marginalPwR_+3A_t">t</code></td>
<td>
<p>a vector of information times</p>
</td></tr>
<tr><td><code id="marginalPwR_+3A_delta">delta</code></td>
<td>
<p>a number shows the drift paramter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number shows the marginal power (delta isn't equal to zero) or type I error (delta is zero)
</p>


<h3>Author(s)</h3>

<p>Jiangtao Gou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>marginalPwR(c(2.218,2.218),c(0.1,0.5,1),delta=3)
marginalPwR(1.96,t=1,delta=3)
</code></pre>

<hr>
<h2 id='psPwRbhmb'>Powers of testing the primary and secondary hypotheses</h2><span id='topic+psPwRbhmb'></span>

<h3>Description</h3>

<p>This function computes the powers of testing the primary and secondary hypotheses using the <code>holm</code>, <code>maurer-bretz</code>, <code>bonferroni</code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psPwRbhmb(
  alpha,
  alpha0,
  t0,
  t1,
  tc0 = t0,
  tc1 = t1,
  rho = 0,
  iuse0 = 1,
  iuse1 = 1,
  phi0 = rep(1, length(alpha)),
  phi1 = rep(1, length(alpha)),
  usingRhoForBoundary = FALSE,
  groupsize,
  szratio = 1,
  effsz0,
  effsz1,
  method = "bonferroni"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psPwRbhmb_+3A_alpha">alpha</code></td>
<td>
<p>a number shows the overall error rate</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_alpha0">alpha0</code></td>
<td>
<p>a number shows the error rate assigned to the primary endpoint initially</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_t0">t0</code></td>
<td>
<p>a vector shows the information times of the primary endpoint</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_t1">t1</code></td>
<td>
<p>a vector shows the information times of the secondary endpoint</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_tc0">tc0</code></td>
<td>
<p>a vector shows the calendar times of the primary endpoint</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_tc1">tc1</code></td>
<td>
<p>a vector shows the calendar times of the secondary endpoint</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_rho">rho</code></td>
<td>
<p>a number shows the correlation between the primary and secondary endpoints</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_iuse0">iuse0</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the primary endpoint</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_iuse1">iuse1</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the secondary endpoint</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_phi0">phi0</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the primary endpoint</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_phi1">phi1</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the secondary endpoint</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_usingrhoforboundary">usingRhoForBoundary</code></td>
<td>
<p>an indicator whether using the informaiton of rho to calculate the boundary, default is FALSE (not using)</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_groupsize">groupsize</code></td>
<td>
<p>a value of sample size in group 1</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_szratio">szratio</code></td>
<td>
<p>a value of the sample size ratio, n2/n1</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_effsz0">effsz0</code></td>
<td>
<p>a value of effect size for hypothesis H0</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_effsz1">effsz1</code></td>
<td>
<p>a value of effect size for hypothesis H1</p>
</td></tr>
<tr><td><code id="psPwRbhmb_+3A_method">method</code></td>
<td>
<p>a text of method, including <code>holm</code>, <code>maurer-bretz</code>, <code>bonferroni</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods include <code>holm</code>, <code>maurer-bretz</code>, and <code>bonferroni</code>. Users can decide whether the correlation information is used or not.
</p>


<h3>Value</h3>

<p>a vector of two values of the probability that H0 is rejected,  the probability that H1 is rejected, the power, using <code>holm</code>, <code>maurer-bretz</code>, or <code>bonferroni</code>.
</p>


<h3>Author(s)</h3>

<p>Jiangtao Gou
</p>


<h3>References</h3>

<p>Gou, J. (2023). Trigger strategy in repeated tests on multiple hypotheses. <em>Statistics in Biopharmaceutical Research</em>, 15(1), 133-140.
Gou, J. (2022). Sample size optimization and initial allocation of the significance levels in group sequential trials with multiple endpoints. <em>Biometrical Journal</em>, 64(2), 301-311.
Tamhane, A. C., Gou, J., Jennison, C., Mehta, C. R., and Curto, T. (2018). A gatekeeping procedure to test a primary and a secondary endpoint in a group sequential design with multiple interim looks. <em>Biometrics</em>, 74(1), 40-48.
Tamhane, A. C., &amp; Gou, J. (2022). Chapter 2 - Multiple test procedures based on p-values. In X. Cui, T. Dickhaus, Y. Ding, &amp; J. C. Hsu (Eds.), <em>Handbook of multiple comparisons</em> (Vol. 45, pp. 11–34).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;-  0.025
alpha0 &lt;- 0.0136
iuse0 &lt;- 1
iuse1 &lt;- 2
phi0 &lt;- -4
phi1 &lt;- 1
tc0 &lt;- c(1,2)
tc1 &lt;- c(1,2,3)
t0 &lt;- c(0.6,1)
t1 &lt;- c(0.5,0.9,1)
rho &lt;- 0
effsz0 &lt;- 0.33
effsz1 &lt;- 0.30
groupsize=226
szratio=1
method="bonferroni"
method = "holm"
method="maurer-bretz"
psPwRbhmb(alpha=alpha, alpha0=alpha0,
    t0=t0, t1=t1, tc0=tc0, tc1=tc1,
    rho=rho, iuse0=1, iuse1=iuse1,
    phi0=phi0, phi1=phi1,
    usingRhoForBoundary=usingRhoForBoundary,
    groupsize=groupsize, szratio=szratio,
    effsz0=effsz0, effsz1=effsz1,
    method=method)
</code></pre>

<hr>
<h2 id='psPwRtrigger'>Powers of testing the primary and secondary hypotheses using trigger strategy</h2><span id='topic+psPwRtrigger'></span>

<h3>Description</h3>

<p>This function computes the powers of testing the primary and secondary hypotheses using trigger strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psPwRtrigger(
  alpha,
  alpha0,
  t0,
  t1,
  tc0 = t0,
  tc1 = t1,
  rho = 0,
  iuse0 = 1,
  iuse1 = 1,
  phi0 = rep(1, length(alpha)),
  phi1 = rep(1, length(alpha)),
  usingRhoForBoundary = FALSE,
  groupsize,
  szratio = 1,
  effsz0,
  effsz1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psPwRtrigger_+3A_alpha">alpha</code></td>
<td>
<p>a number shows the overall error rate</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_alpha0">alpha0</code></td>
<td>
<p>a number shows the error rate assigned to the primary endpoint initially</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_t0">t0</code></td>
<td>
<p>a vector shows the information times of the primary endpoint</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_t1">t1</code></td>
<td>
<p>a vector shows the information times of the secondary endpoint</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_tc0">tc0</code></td>
<td>
<p>a vector shows the calendar times of the primary endpoint</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_tc1">tc1</code></td>
<td>
<p>a vector shows the calendar times of the secondary endpoint</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_rho">rho</code></td>
<td>
<p>a number shows the correlation between the primary and secondary endpoints</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_iuse0">iuse0</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the primary endpoint</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_iuse1">iuse1</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the secondary endpoint</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_phi0">phi0</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the primary endpoint</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_phi1">phi1</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the secondary endpoint</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_usingrhoforboundary">usingRhoForBoundary</code></td>
<td>
<p>an indicator whether using the informaiton of rho to calculate the boundary, default is FALSE (not using)</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_groupsize">groupsize</code></td>
<td>
<p>a value of sample size in group 1</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_szratio">szratio</code></td>
<td>
<p>a value of the sample size ratio, n2/n1</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_effsz0">effsz0</code></td>
<td>
<p>a value of effect size for hypothesis H0</p>
</td></tr>
<tr><td><code id="psPwRtrigger_+3A_effsz1">effsz1</code></td>
<td>
<p>a value of effect size for hypothesis H1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of two values of the probability that H0 is rejected, and the probability that H1 is rejected, using the trigger strategy
</p>


<h3>References</h3>

<p>Gou, J. (2023). Trigger strategy in repeated tests on multiple hypotheses. <em>Statistics in Biopharmaceutical Research</em>, 15(1), 133-140.
Gou, J. (2022). Sample size optimization and initial allocation of the significance levels in group sequential trials with multiple endpoints. <em>Biometrical Journal</em>, 64(2), 301-311.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;-  0.0250
alpha0 &lt;- 0.0136
iuse0 &lt;- 1
iuse1 &lt;- 2
phi0 &lt;- -4
phi1 &lt;- 1
tc0 &lt;- c(1,2)
tc1 &lt;- c(1,2,3)
t0 &lt;- c(0.6,1)
t1 &lt;- c(0.5,0.9,1)
rho &lt;- 0
effsz0 &lt;- 0.33
effsz1 &lt;- 0.30
groupsize=226
szratio=1
psPwRtrigger(alpha=alpha, alpha0=alpha0,
    t0=t0, t1=t1, tc0=tc0, tc1=tc1,
    rho=rho, iuse0=1, iuse1=iuse1,
    phi0=phi0, phi1=phi1,
    usingRhoForBoundary=FALSE,
    groupsize=groupsize, szratio=szratio,
    effsz0=effsz0, effsz1=effsz1)
</code></pre>

<hr>
<h2 id='sBoundsPh2'>Critical boundaries for the secondary endpoint in the partially hierarchical group sequential design</h2><span id='topic+sBoundsPh2'></span>

<h3>Description</h3>

<p>This function computes the critical boundaries for the secondary endpoint in the partially hierarchical group sequential design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sBoundsPh2(
  alpha,
  alpha0,
  t0,
  t1,
  tc0 = t0,
  tc1 = t1,
  rho = 0,
  iuse0 = 1,
  iuse1h = 1,
  iuse1t = 1,
  phi0 = rep(1, length(alpha)),
  phi1h = rep(1, length(alpha)),
  phi1t = rep(1, length(alpha))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sBoundsPh2_+3A_alpha">alpha</code></td>
<td>
<p>a value of overall type I error rate</p>
</td></tr>
<tr><td><code id="sBoundsPh2_+3A_alpha0">alpha0</code></td>
<td>
<p>a value of the type I error rate for testing H0</p>
</td></tr>
<tr><td><code id="sBoundsPh2_+3A_t0">t0</code></td>
<td>
<p>a vector of information times for H0</p>
</td></tr>
<tr><td><code id="sBoundsPh2_+3A_t1">t1</code></td>
<td>
<p>a vector of information times for H1</p>
</td></tr>
<tr><td><code id="sBoundsPh2_+3A_tc0">tc0</code></td>
<td>
<p>a vector of calendar times for H0</p>
</td></tr>
<tr><td><code id="sBoundsPh2_+3A_tc1">tc1</code></td>
<td>
<p>a vector of calendar times for H1</p>
</td></tr>
<tr><td><code id="sBoundsPh2_+3A_rho">rho</code></td>
<td>
<p>a value of the correlation between the test statistics for H0 and H1.</p>
</td></tr>
<tr><td><code id="sBoundsPh2_+3A_iuse0">iuse0</code></td>
<td>
<p>a value of the type of error spending function for H0, ranging from 1 to 4</p>
</td></tr>
<tr><td><code id="sBoundsPh2_+3A_iuse1h">iuse1h</code></td>
<td>
<p>a value of the type of error spending function for H1 first half, ranging from 1 to 4</p>
</td></tr>
<tr><td><code id="sBoundsPh2_+3A_iuse1t">iuse1t</code></td>
<td>
<p>a value of the type of error spending function for H1 second half, ranging from 1 to 4</p>
</td></tr>
<tr><td><code id="sBoundsPh2_+3A_phi0">phi0</code></td>
<td>
<p>a value of the parameter of error spending function for H0</p>
</td></tr>
<tr><td><code id="sBoundsPh2_+3A_phi1h">phi1h</code></td>
<td>
<p>a value of the parameter of error spending function for H1 first half</p>
</td></tr>
<tr><td><code id="sBoundsPh2_+3A_phi1t">phi1t</code></td>
<td>
<p>a value of the parameter of error spending function for H1 second half</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two vectors: <code>bd</code> critical boundaries, <code>er</code> error spent until each stage
</p>


<h3>Author(s)</h3>

<p>Jiangtao Gou
</p>


<h3>References</h3>

<p>Gou, J. (2023). Trigger strategy in repeated tests on multiple hypotheses. <em>Statistics in Biopharmaceutical Research</em>, 15(1), 133-140.
Gou, J. (2022). Sample size optimization and initial allocation of the significance levels in group sequential trials with multiple endpoints. <em>Biometrical Journal</em>, 64(2), 301-311.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 0.05
alpha0 &lt;- 0.03
iuse0 &lt;- 4
iuse1h &lt;- 4
iuse1t &lt;- 4
phi0 &lt;- -4
phi1h &lt;- 1
phi1t &lt;- 1
tc0 &lt;- c(3,6,9,12)
tc1 &lt;- c(6,12,18,24)
t0 &lt;- c(0.3,0.6,0.9,1)
t1 &lt;- (1:4)/4
rho &lt;- 0
sBoundsPh2(alpha, alpha0,
    t0, t1, tc0, tc1,
    rho, iuse0, iuse1h, iuse1t,
    phi0, phi1h, phi1t)
alpha &lt;-  0.025
alpha0 &lt;- 0.01
iuse0 &lt;- 4
iuse1 &lt;- 4
phi0 &lt;- -4
phi1 &lt;- -4
tc0 &lt;- c(3,6,9,12,18)
tc1 &lt;- c(6,12,18,36)
t0 &lt;- (1:5)/5
t1 &lt;- (1:4)/4
rho &lt;- 0.0;
sBoundsPh2(alpha, alpha0,
    t0, t1, tc0, tc1,
    rho, iuse0, iuse1h=iuse1, iuse1t=iuse1,
    phi0, phi1h=phi1, phi1t=phi1)
</code></pre>

<hr>
<h2 id='sErrRphInt2'>Type I error rate of the overall null hypothesis using the partial hierarchical design</h2><span id='topic+sErrRphInt2'></span>

<h3>Description</h3>

<p>This function computes the type I error rate of the overall null hypothesis using the partial hierarchical group sequential design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sErrRphInt2(cvec0, cvec1, t0, t1, tc0 = t0, tc1 = t1, rho = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sErrRphInt2_+3A_cvec0">cvec0</code></td>
<td>
<p>a vector of critical boundaries for testing H0</p>
</td></tr>
<tr><td><code id="sErrRphInt2_+3A_cvec1">cvec1</code></td>
<td>
<p>a vector of critical boundaries for testing H1</p>
</td></tr>
<tr><td><code id="sErrRphInt2_+3A_t0">t0</code></td>
<td>
<p>a vector of information times for H0</p>
</td></tr>
<tr><td><code id="sErrRphInt2_+3A_t1">t1</code></td>
<td>
<p>a vector of information times for H1</p>
</td></tr>
<tr><td><code id="sErrRphInt2_+3A_tc0">tc0</code></td>
<td>
<p>a vector of calendar times for H0</p>
</td></tr>
<tr><td><code id="sErrRphInt2_+3A_tc1">tc1</code></td>
<td>
<p>a vector of calendar times for H1</p>
</td></tr>
<tr><td><code id="sErrRphInt2_+3A_rho">rho</code></td>
<td>
<p>a value of the correlation between the test statistics for H0 and H1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number shows the type I error rate of testing H0 intersect H1
</p>


<h3>Author(s)</h3>

<p>Jiangtao Gou
</p>


<h3>References</h3>

<p>Gou, J. (2023). Trigger strategy in repeated tests on multiple hypotheses. <em>Statistics in Biopharmaceutical Research</em>, 15(1), 133-140.
Gou, J. (2022). Sample size optimization and initial allocation of the significance levels in group sequential trials with multiple endpoints. <em>Biometrical Journal</em>, 64(2), 301-311.
Tamhane, A. C., Gou, J., Jennison, C., Mehta, C. R., and Curto, T. (2018). A gatekeeping procedure to test a primary and a secondary endpoint in a group sequential design with multiple interim looks. <em>Biometrics</em>, 74(1), 40-48.
Tamhane, A. C., &amp; Gou, J. (2022). Chapter 2 - Multiple test procedures based on p-values. In X. Cui, T. Dickhaus, Y. Ding, &amp; J. C. Hsu (Eds.), <em>Handbook of multiple comparisons</em> (Vol. 45, pp. 11–34).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha0 &lt;- 0.03
alpha1 &lt;- 0.02
iuse0 &lt;- 4
iuse1 &lt;- 4
phi0 &lt;- -4
phi1 &lt;- 1
tc0 &lt;- c(3,6,9,12)
tc1 &lt;- c(6,12,18,24)
t0 &lt;- c(0.3,0.6,0.9,1)
t1 &lt;- (1:4)/4
rho &lt;- 0
cvecList0 &lt;- gbounds(t=t0,iuse=iuse0,
    alpha=alpha0,phi=phi0)
cvec0 &lt;- cvecList0$bd
cvecList1 &lt;- gbounds(t=t1,iuse=iuse1,
    alpha=alpha1,phi=phi1)
cvec1 &lt;- cvecList1$bd
result &lt;- sErrRphInt2(cvec0, cvec1,
    t0, t1, tc0, tc1, rho)
print(result)
</code></pre>

<hr>
<h2 id='solveAlphaXsampleSize'>Sample size calculation</h2><span id='topic+solveAlphaXsampleSize'></span>

<h3>Description</h3>

<p>This function computes the sample size and the error rate pre-assigned to the primary endpoint using methods of <code>trigger</code>, <code>holm</code>, <code>maurer-bretz</code>, <code>bonferroni</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveAlphaXsampleSize(
  alpha,
  beta0,
  beta1,
  effsz0,
  effsz1,
  szratio = 1,
  t0 = 1,
  t1 = 1,
  tc0 = t0,
  tc1 = t1,
  rho = 0,
  iuse0 = 1,
  iuse1 = 1,
  phi0 = rep(1, length(alpha)),
  phi1 = rep(1, length(alpha)),
  usingRhoForBoundary = FALSE,
  method = "trigger",
  myinit
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveAlphaXsampleSize_+3A_alpha">alpha</code></td>
<td>
<p>a number of overall type I error rate</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_beta0">beta0</code></td>
<td>
<p>a number of type II error rate for H0</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_beta1">beta1</code></td>
<td>
<p>a number of type II error rate for H1</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_effsz0">effsz0</code></td>
<td>
<p>a number of the effect size of testing H0</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_effsz1">effsz1</code></td>
<td>
<p>a number of the effect size of testing H1</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_szratio">szratio</code></td>
<td>
<p>a number of the ratio of sample size of testing H0 to that of testing H1</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_t0">t0</code></td>
<td>
<p>a vector of information times for H0</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_t1">t1</code></td>
<td>
<p>a vector of information times for H1</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_tc0">tc0</code></td>
<td>
<p>a vector of calendar times for H0</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_tc1">tc1</code></td>
<td>
<p>a vector of calendar times for H1</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_rho">rho</code></td>
<td>
<p>a value of correlation coefficient between H0 and H1</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_iuse0">iuse0</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the primary endpoint</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_iuse1">iuse1</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the secondary endpoint</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_phi0">phi0</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the primary endpoint</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_phi1">phi1</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the secondary endpoint</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_usingrhoforboundary">usingRhoForBoundary</code></td>
<td>
<p>an indicator whether using the informaiton of rho to calculate the boundary, default is FALSE (not using)</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_method">method</code></td>
<td>
<p>a text of method, including <code>trigger</code>, <code>holm</code>, <code>maurer-bretz</code>, <code>bonferroni</code></p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSize_+3A_myinit">myinit</code></td>
<td>
<p>a vector of two starting points for alpha0 and sample size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two values, <code>alpha0</code> and <code>groupsize</code>
</p>


<h3>References</h3>

<p>Gou, J. (2023). Trigger strategy in repeated tests on multiple hypotheses. <em>Statistics in Biopharmaceutical Research</em>, 15(1), 133-140.
Gou, J. (2022). Sample size optimization and initial allocation of the significance levels in group sequential trials with multiple endpoints. <em>Biometrical Journal</em>, 64(2), 301-311.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Single Stage Example
alpha &lt;- 0.025
effsz0 &lt;- 0.4
effsz1 &lt;- 0.30
szratio &lt;- 1
beta0 &lt;- 0.10
beta1 &lt;- 0.20
solveAlphaXsampleSize(alpha, beta0, beta1,
    effsz0, effsz1, szratio)
# Multi-stage example
alpha &lt;- 0.025
beta0 &lt;- 0.10
beta1 &lt;- 0.20
effsz0 &lt;- 0.33
effsz1 &lt;- 0.30
szratio &lt;- 1
t0 &lt;- c(0.5,0.9,1)
t1 &lt;- c(0.6,1)
tc0 &lt;- c(1,2)
tc1 &lt;- c(1,2,3)
rho &lt;- 0
iuse0 &lt;- 1
iuse1 &lt;- 2
phi0 &lt;- -4
phi1 &lt;- 1
usingRhoForBoundary &lt;- FALSE
myinit &lt;- c(300,alpha/2)
myinit &lt;- c(200,alpha/10)
method="trigger"
method="bonferroni"
method="holm"
method="maurer-bretz"
solveAlphaXsampleSize(alpha=alpha,
    beta0=beta0, beta1=beta1,
    effsz0=effsz0, effsz1=effsz1,
    szratio=szratio,
    t0=t0, t1=t1, tc0=tc0, tc1=tc1,
    rho=rho, iuse0=iuse0, iuse1=iuse1,
    phi0=phi0, phi1=phi1,
    usingRhoForBoundary=usingRhoForBoundary,
    method=method,
    myinit=myinit)
</code></pre>

<hr>
<h2 id='solveAlphaXsampleSizeGA'>Sample size calculation using Genetic Algorithms</h2><span id='topic+solveAlphaXsampleSizeGA'></span>

<h3>Description</h3>

<p>This function computes the sample size and the error rate pre-assigned to the primary endpoint using methods of <code>trigger</code>, <code>holm</code>, <code>maurer-bretz</code>, <code>bonferroni</code>, with Genetic Algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveAlphaXsampleSizeGA(
  alpha,
  beta0,
  beta1,
  effsz0,
  effsz1,
  szratio = 1,
  t0 = 1,
  t1 = 1,
  tc0 = t0,
  tc1 = t1,
  rho = 0,
  iuse0 = 1,
  iuse1 = 1,
  phi0 = rep(1, length(alpha)),
  phi1 = rep(1, length(alpha)),
  usingRhoForBoundary = FALSE,
  method = "trigger",
  lower = c(1, 1e-04),
  upper = c(10000, alpha - 1e-04),
  maxiter = 20,
  run = 200,
  seed = 1949
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_alpha">alpha</code></td>
<td>
<p>a number of overall type I error rate</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_beta0">beta0</code></td>
<td>
<p>a number of type II error rate for H0</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_beta1">beta1</code></td>
<td>
<p>a number of type II error rate for H1</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_effsz0">effsz0</code></td>
<td>
<p>a number of the effect size of testing H0</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_effsz1">effsz1</code></td>
<td>
<p>a number of the effect size of testing H1</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_szratio">szratio</code></td>
<td>
<p>a number of the ratio of sample size of testing H0 to that of testing H1</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_t0">t0</code></td>
<td>
<p>a vector of information times for H0</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_t1">t1</code></td>
<td>
<p>a vector of information times for H1</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_tc0">tc0</code></td>
<td>
<p>a vector of calendar times for H0</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_tc1">tc1</code></td>
<td>
<p>a vector of calendar times for H1</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_rho">rho</code></td>
<td>
<p>a value of correlation coefficient between H0 and H1</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_iuse0">iuse0</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the primary endpoint</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_iuse1">iuse1</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the secondary endpoint</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_phi0">phi0</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the primary endpoint</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_phi1">phi1</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the secondary endpoint</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_usingrhoforboundary">usingRhoForBoundary</code></td>
<td>
<p>an indicator whether using the informaiton of rho to calculate the boundary, default is FALSE (not using)</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_method">method</code></td>
<td>
<p>a text of method, including <code>trigger</code>, <code>holm</code>, <code>maurer-bretz</code>, <code>bonferroni</code></p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_lower">lower</code></td>
<td>
<p>a vector of two lower limits for alpha0 and sample size</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_upper">upper</code></td>
<td>
<p>a vector of two upper limits for alpha0 and sample size.</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_maxiter">maxiter</code></td>
<td>
<p>a number of maximum number of iterations</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_run">run</code></td>
<td>
<p>a number of maximum number of consecutive generations without any improvement in the best fitness value before the GA is stopped</p>
</td></tr>
<tr><td><code id="solveAlphaXsampleSizeGA_+3A_seed">seed</code></td>
<td>
<p>a number of seed of random number generator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R package <code>GA</code> is used for Genetic Algorithms.
</p>


<h3>Value</h3>

<p>a list of two values, <code>alpha0</code> and <code>groupsize</code>
</p>


<h3>References</h3>

<p>Gou, J. (2023). Trigger strategy in repeated tests on multiple hypotheses. <em>Statistics in Biopharmaceutical Research</em>, 15(1), 133-140.
Gou, J. (2022). Sample size optimization and initial allocation of the significance levels in group sequential trials with multiple endpoints. <em>Biometrical Journal</em>, 64(2), 301-311.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha=0.025
beta0=0.10
beta1=0.20
effsz0=0.33
effsz1=0.30
szratio=1
t0=c(0.5,0.9,1)
t1=c(0.6,1)
tc0=c(1,2)
tc1=c(1,2,3)
rho=0
iuse0=1
iuse1=2
phi0=-4
phi1=1
usingRhoForBoundary=FALSE
method="trigger"
method="bonferroni"
method="holm"
method="maurer-bretz"
lower = c(180,0.005)
upper = c(240, alpha-0.005)
maxiter = 1 # Increase this number for more precise results
run = 1 # Increase this number for more precise results
seed = 123
result &lt;- solveAlphaXsampleSizeGA(alpha=alpha,
    beta0=beta0, beta1=beta1,
    effsz0=effsz0, effsz1=effsz1,
    szratio=szratio,
    t0=t0, t1=t1, tc0=tc0, tc1=tc1,
    rho=rho, iuse0=iuse0, iuse1=iuse1,
    phi0=phi0, phi1=phi1,
    usingRhoForBoundary=usingRhoForBoundary,
    method=method,
    lower = lower, upper = upper,
    maxiter = maxiter,
    run = run,
    seed = seed)
print(result)
</code></pre>

<hr>
<h2 id='sPwRholm'>Power of testing the secondary hypothesis using Holm</h2><span id='topic+sPwRholm'></span>

<h3>Description</h3>

<p>This function computes the power of testing the secondary hypothesis using Holm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sPwRholm(
  alpha,
  alpha0,
  t0,
  t1,
  delta0,
  delta1,
  rho = 0,
  iuse0 = 1,
  iuse1 = 1,
  phi0 = rep(1, length(alpha)),
  phi1 = rep(1, length(alpha))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sPwRholm_+3A_alpha">alpha</code></td>
<td>
<p>a number shows the overall error rate</p>
</td></tr>
<tr><td><code id="sPwRholm_+3A_alpha0">alpha0</code></td>
<td>
<p>a number shows the error rate assigned to the primary endpoint initially</p>
</td></tr>
<tr><td><code id="sPwRholm_+3A_t0">t0</code></td>
<td>
<p>a vector shows the information times of the primary endpoint</p>
</td></tr>
<tr><td><code id="sPwRholm_+3A_t1">t1</code></td>
<td>
<p>a vector shows the information times of the secondary endpoint</p>
</td></tr>
<tr><td><code id="sPwRholm_+3A_delta0">delta0</code></td>
<td>
<p>a value of delta for hypothesis H0</p>
</td></tr>
<tr><td><code id="sPwRholm_+3A_delta1">delta1</code></td>
<td>
<p>a value of delta for hypothesis H1</p>
</td></tr>
<tr><td><code id="sPwRholm_+3A_rho">rho</code></td>
<td>
<p>a number shows the correlation between the primary and secondary endpoints</p>
</td></tr>
<tr><td><code id="sPwRholm_+3A_iuse0">iuse0</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the primary endpoint</p>
</td></tr>
<tr><td><code id="sPwRholm_+3A_iuse1">iuse1</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the secondary endpoint</p>
</td></tr>
<tr><td><code id="sPwRholm_+3A_phi0">phi0</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the primary endpoint</p>
</td></tr>
<tr><td><code id="sPwRholm_+3A_phi1">phi1</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the secondary endpoint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number shows the statistical power of rejecting H1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;-  0.025
alpha0 &lt;- 0.01
iuse0 &lt;- 4
iuse1 &lt;- 4
phi0 &lt;- -4
phi1 &lt;- -4
t0 &lt;- (1:5)/5
t1 &lt;- (1:4)/4
rho &lt;- 0.5
delta0 &lt;- 1
delta1 &lt;- 3
sPwRholm(alpha=alpha, alpha0=alpha0, 
    t0=t0, t1=t1, 
    delta0=delta0, delta1=delta1, 
    rho=rho, iuse0=iuse0, iuse1=iuse1, 
    phi0=phi0, phi1=phi1)
</code></pre>

<hr>
<h2 id='sPwRholmye'>Power of testing the secondary hypothesis using Holm-Ye</h2><span id='topic+sPwRholmye'></span>

<h3>Description</h3>

<p>This function computes the power of testing the secondary hypothesis using Holm-Ye
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sPwRholmye(
  alpha,
  alpha0,
  t0,
  t1,
  tc0 = t0,
  tc1 = t1,
  delta0,
  delta1,
  rho = 0,
  iuse0 = 1,
  iuse1 = 1,
  phi0 = rep(1, length(alpha)),
  phi1 = rep(1, length(alpha))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sPwRholmye_+3A_alpha">alpha</code></td>
<td>
<p>a number shows the overall error rate</p>
</td></tr>
<tr><td><code id="sPwRholmye_+3A_alpha0">alpha0</code></td>
<td>
<p>a number shows the error rate assigned to the primary endpoint initially</p>
</td></tr>
<tr><td><code id="sPwRholmye_+3A_t0">t0</code></td>
<td>
<p>a vector shows the information times of the primary endpoint</p>
</td></tr>
<tr><td><code id="sPwRholmye_+3A_t1">t1</code></td>
<td>
<p>a vector shows the information times of the secondary endpoint</p>
</td></tr>
<tr><td><code id="sPwRholmye_+3A_tc0">tc0</code></td>
<td>
<p>a vector shows the calendar times of the primary endpoint</p>
</td></tr>
<tr><td><code id="sPwRholmye_+3A_tc1">tc1</code></td>
<td>
<p>a vector shows the calendar times of the secondary endpoint</p>
</td></tr>
<tr><td><code id="sPwRholmye_+3A_delta0">delta0</code></td>
<td>
<p>a value of delta for hypothesis H0</p>
</td></tr>
<tr><td><code id="sPwRholmye_+3A_delta1">delta1</code></td>
<td>
<p>a value of delta for hypothesis H1</p>
</td></tr>
<tr><td><code id="sPwRholmye_+3A_rho">rho</code></td>
<td>
<p>a number shows the correlation between the primary and secondary endpoints</p>
</td></tr>
<tr><td><code id="sPwRholmye_+3A_iuse0">iuse0</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the primary endpoint</p>
</td></tr>
<tr><td><code id="sPwRholmye_+3A_iuse1">iuse1</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the secondary endpoint</p>
</td></tr>
<tr><td><code id="sPwRholmye_+3A_phi0">phi0</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the primary endpoint</p>
</td></tr>
<tr><td><code id="sPwRholmye_+3A_phi1">phi1</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the secondary endpoint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number shows the statistical power of rejecting H1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;-  0.025
alpha0 &lt;- 0.01
iuse0 &lt;- 4
iuse1 &lt;- 4
phi0 &lt;- -4
phi1 &lt;- -4
tc0 &lt;- c(3,6,9,12,18)
tc1 &lt;- c(6,12,18,36)
t0 &lt;- (1:5)/5
t1 &lt;- (1:4)/4
rho &lt;- 0.5
delta0 &lt;- 1
delta1 &lt;- 3
sPwRholmye(alpha=alpha, alpha0=alpha0, 
    t0=t0, t1=t1, tc0=tc0, tc1=tc1, 
    delta0=delta0, delta1=delta1, 
    rho=rho, iuse0=iuse0, iuse1=iuse1, 
    phi0=phi0, phi1=phi1) 
</code></pre>

<hr>
<h2 id='sPwRnaiveBonf'>Power of testing the secondary hypothesis using Bonferroni</h2><span id='topic+sPwRnaiveBonf'></span>

<h3>Description</h3>

<p>This function computes the power of testing the secondary hypothesis using Bonferroni
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sPwRnaiveBonf(
  alpha,
  alpha0 = alpha/2,
  t1,
  delta1,
  iuse1,
  phi1 = rep(1, length(alpha))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sPwRnaiveBonf_+3A_alpha">alpha</code></td>
<td>
<p>a number shows the overall error rate</p>
</td></tr>
<tr><td><code id="sPwRnaiveBonf_+3A_alpha0">alpha0</code></td>
<td>
<p>a number shows the error rate assigned to the primary endpoint initially</p>
</td></tr>
<tr><td><code id="sPwRnaiveBonf_+3A_t1">t1</code></td>
<td>
<p>a vector shows the information times of the secondary endpoint</p>
</td></tr>
<tr><td><code id="sPwRnaiveBonf_+3A_delta1">delta1</code></td>
<td>
<p>a value of delta for hypothesis H1</p>
</td></tr>
<tr><td><code id="sPwRnaiveBonf_+3A_iuse1">iuse1</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the secondary endpoint</p>
</td></tr>
<tr><td><code id="sPwRnaiveBonf_+3A_phi1">phi1</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the secondary endpoint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value of the probability that H1 is rejected, the power, using the naive Bonferroni method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;-  0.025
alpha0 &lt;- 0.01
iuse0 &lt;- 4
iuse1 &lt;- 4
phi0 &lt;- -4
phi1 &lt;- -4
tc0 &lt;- c(3,6,9,12,18)
tc1 &lt;- c(6,12,18,36)
t0 &lt;- (1:5)/5
t1 &lt;- (1:4)/4
rho &lt;- 0.5
delta0 &lt;- 1
delta1 &lt;- 3
sPwRnaiveBonf(alpha=alpha, 
    alpha0=alpha0, 
    t1=t1, 
    delta1=delta1, 
    iuse1=iuse1, 
    phi1=phi1)
</code></pre>

<hr>
<h2 id='sPwRph2'>Power of testing the secondary hypothesis in partially hierarchical design</h2><span id='topic+sPwRph2'></span>

<h3>Description</h3>

<p>This function computes the power of testing the secondary hypothesis in partially hierarchical design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sPwRph2(cvec0, cvec1, delta0, delta1, t0, t1, tc0 = t0, tc1 = t1, rho = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sPwRph2_+3A_cvec0">cvec0</code></td>
<td>
<p>a vector of critical boundaries for testing H0</p>
</td></tr>
<tr><td><code id="sPwRph2_+3A_cvec1">cvec1</code></td>
<td>
<p>a vector of critical boundaries for testing H1</p>
</td></tr>
<tr><td><code id="sPwRph2_+3A_delta0">delta0</code></td>
<td>
<p>a value of drift parameter for testing H0</p>
</td></tr>
<tr><td><code id="sPwRph2_+3A_delta1">delta1</code></td>
<td>
<p>a value of drift parameter for testing H1</p>
</td></tr>
<tr><td><code id="sPwRph2_+3A_t0">t0</code></td>
<td>
<p>a vector of information times for H0</p>
</td></tr>
<tr><td><code id="sPwRph2_+3A_t1">t1</code></td>
<td>
<p>a vector of information times for H1</p>
</td></tr>
<tr><td><code id="sPwRph2_+3A_tc0">tc0</code></td>
<td>
<p>a vector of calendar times for H0</p>
</td></tr>
<tr><td><code id="sPwRph2_+3A_tc1">tc1</code></td>
<td>
<p>a vector of calendar times for H1</p>
</td></tr>
<tr><td><code id="sPwRph2_+3A_rho">rho</code></td>
<td>
<p>a value of correlation coefficient between H0 and H1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value of the probability that H1 is rejected, the power
</p>


<h3>References</h3>

<p>Gou, J. (2023). Trigger strategy in repeated tests on multiple hypotheses. <em>Statistics in Biopharmaceutical Research</em>, 15(1), 133-140.
Gou, J. (2022). Sample size optimization and initial allocation of the significance levels in group sequential trials with multiple endpoints. <em>Biometrical Journal</em>, 64(2), 301-311.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 0.05
alpha0 &lt;- 0.03
iuse0 &lt;- 4
iuse1h &lt;- 4
iuse1t &lt;- 4
phi0 &lt;- -4
phi1h &lt;- 1
phi1t &lt;- 1
tc0 &lt;- c(3,6,9,12)
tc1 &lt;- c(6,12,18,24)
t0 &lt;- c(0.3,0.6,0.9,1)
t1 &lt;- (1:4)/4
rho &lt;- 0
cvecList0 &lt;- gbounds(t=t0, iuse=iuse0,
    alpha=alpha0, phi=phi0)
cvec0 &lt;- cvecList0$bd
cvecList1 &lt;- sBoundsPh2(alpha, alpha0,
    t0, t1, tc0, tc1,
    rho, iuse0, iuse1h, iuse1t,
    phi0, phi1h, phi1t)
cvec1 &lt;- cvecList1$bd
sPwRph2(cvec0, cvec1,
    delta0=2, delta1=3,
    t0, t1, tc0, tc1,
    rho=0)
</code></pre>

<hr>
<h2 id='sPwRtrigger'>Power of testing the secondary hypothesis using Trigger strategy</h2><span id='topic+sPwRtrigger'></span>

<h3>Description</h3>

<p>This function computes the power of testing the secondary hypothesis using  Trigger strategy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sPwRtrigger(
  alpha,
  alpha0,
  t0,
  t1,
  tc0 = t0,
  tc1 = t1,
  delta0,
  delta1,
  rho = 0,
  iuse0 = 1,
  iuse1 = 1,
  phi0 = rep(1, length(alpha)),
  phi1 = rep(1, length(alpha)),
  usingRhoForBoundary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sPwRtrigger_+3A_alpha">alpha</code></td>
<td>
<p>a number shows the overall error rate</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_alpha0">alpha0</code></td>
<td>
<p>a number shows the error rate assigned to the primary endpoint initially</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_t0">t0</code></td>
<td>
<p>a vector shows the information times of the primary endpoint</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_t1">t1</code></td>
<td>
<p>a vector shows the information times of the secondary endpoint</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_tc0">tc0</code></td>
<td>
<p>a vector shows the calendar times of the primary endpoint</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_tc1">tc1</code></td>
<td>
<p>a vector shows the calendar times of the secondary endpoint</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_delta0">delta0</code></td>
<td>
<p>a value of delta for hypothesis H0</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_delta1">delta1</code></td>
<td>
<p>a value of delta for hypothesis H1</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_rho">rho</code></td>
<td>
<p>a number shows the correlation between the primary and secondary endpoints</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_iuse0">iuse0</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the primary endpoint</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_iuse1">iuse1</code></td>
<td>
<p>an integer shows the type of group sequential boundaries used for the secondary endpoint</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_phi0">phi0</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the primary endpoint</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_phi1">phi1</code></td>
<td>
<p>a parameter for the power family or the HSD gamma family for the secondary endpoint</p>
</td></tr>
<tr><td><code id="sPwRtrigger_+3A_usingrhoforboundary">usingRhoForBoundary</code></td>
<td>
<p>an indicator whether using the informaiton of rho to calculate the boundary, default is FALSE (not using)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value of the probability that H1 is rejected, the power, using the trigger strategy
</p>


<h3>References</h3>

<p>Gou, J. (2023). Trigger strategy in repeated tests on multiple hypotheses. <em>Statistics in Biopharmaceutical Research</em>, 15(1), 133-140.
Gou, J. (2022). Sample size optimization and initial allocation of the significance levels in group sequential trials with multiple endpoints. <em>Biometrical Journal</em>, 64(2), 301-311.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;-  0.025
alpha0 &lt;- 0.01
iuse0 &lt;- 4
iuse1 &lt;- 4
phi0 &lt;- -4
phi1 &lt;- -4
tc0 &lt;- c(3,6,9,12,18)
tc1 &lt;- c(6,12,18,36)
t0 &lt;- (1:5)/5
t1 &lt;- (1:4)/4
rho &lt;- 0.5
delta0 &lt;- 1
delta1 &lt;- 3
sPwRtrigger(alpha=alpha, alpha0=alpha0,
    t0=t0, t1=t1, tc0=tc0, tc1=tc1,
    delta0=delta0, delta1=delta1,
    rho=rho, iuse0=1, iuse1=iuse1,
    phi0=phi0, phi1=phi1,
    usingRhoForBoundary=FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
