<!DOCTYPE html><html><head><title>Help for package funprog</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {funprog}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#funprog-package'><p>Implementation of pure functional programming languages functions</p></a></li>
<li><a href='#+25on+25'><p>Transform a binary function with a unary function</p></a></li>
<li><a href='#descending'><p>Reverse a sorting function</p></a></li>
<li><a href='#group_if'><p>Group vector values</p></a></li>
<li><a href='#iterate'><p>Apply a function repeatedly</p></a></li>
<li><a href='#partition'><p>Partition a vector in two</p></a></li>
<li><a href='#sort_by'><p>Sort with auxiliary function</p></a></li>
<li><a href='#unique_by'><p>Unique with auxiliary function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functional Programming</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>
    High-order functions for data manipulation : sort or group data, given one
    or more auxiliary functions. Functions are inspired by other pure
    functional programming languages ('Haskell' mainly). The package also 
    provides built-in function operators for creating compact anonymous
    functions, as well as the possibility to use the 'purrr' package syntax.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://py_b.gitlab.io/funprog">https://py_b.gitlab.io/funprog</a>, <a href="https://gitlab.com/py_b/funprog">https://gitlab.com/py_b/funprog</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/py_b/funprog/-/issues">https://gitlab.com/py_b/funprog/-/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>purrr (&ge; 0.2.3), testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-07 11:10:44 UTC; CPY_2</td>
</tr>
<tr>
<td>Author:</td>
<td>Pierre-Yves Berrard [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierre-Yves Berrard &lt;pyb@gmx.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-07 11:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='funprog-package'>Implementation of pure functional programming languages functions</h2><span id='topic+funprog-package'></span>

<h3>Description</h3>

<p>The <strong>funprog</strong> package implements in R some functions existing in other
pure functional programming languages.
</p>


<h3>Main functions</h3>

<p>The package provides high-order functions, for example :
</p>

<ul>
<li><p><code><a href="#topic+group_if">group_if</a></code>, inspired by Haskell's <code>groupBy</code>
</p>
</li>
<li><p><code><a href="#topic+sort_by">sort_by</a></code>, inspired by Haskell's <code>sortBy</code>
</p>
</li></ul>



<h3>Helper functions</h3>

<p>Helper functions can be used in conjunction with the main functions :
</p>

<ul>
<li><p><code>%on%</code> combines two functions into one and serves to create a
predicate function to <code>group_if</code>
</p>
</li>
<li><p><code>descending</code> is used to reverse the output of a sorting
function used with <code>sort_by</code>
</p>
</li></ul>



<h3><code>purrr</code> syntax</h3>

<p>If the <a href="https://purrr.tidyverse.org">purrr</a> package is installed, you
can use its special syntax to create very compact anonymous functions, for
example <code>~ abs(.x - .y) &gt; 1</code> instead of <code>function(x, y) abs(x - y)
&gt; 1</code>.
</p>

<hr>
<h2 id='+25on+25'>Transform a binary function with a unary function</h2><span id='topic++25on+25'></span><span id='topic+on'></span>

<h3>Description</h3>

<p>Execute the binary function f on the results of applying unary function g to
two arguments x and y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f %on% g
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25on+2B25_+3A_f">f</code></td>
<td>
<p>a binary function.</p>
</td></tr>
<tr><td><code id="+2B25on+2B25_+3A_g">g</code></td>
<td>
<p>a unary function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formally, <code>%on%</code> is defined this way :
<code>function(f, g) function(x, y) f(g(x), g(y))</code>.
</p>
<p>f can be a function taking two arguments but also a variadic function (i.e.
whose first argument is <code>...</code>), which will be fed with exactly two
arguments.
</p>
<p>A typical usage of this function is in combination with function like
<code><a href="#topic+group_if">group_if</a></code>.
</p>


<h3>Value</h3>

<p>A binary function. This function transforms 2 inputs (with g) and
combines the outputs (with f).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h &lt;- max %on% abs
h(-2, 1)
</code></pre>

<hr>
<h2 id='descending'>Reverse a sorting function</h2><span id='topic+descending'></span>

<h3>Description</h3>

<p>Transform a function (typically used in <code><a href="#topic+sort_by">sort_by</a></code>), so that its
ouput can be sorted in descending order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descending(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="descending_+3A_f">f</code></td>
<td>
<p>a function to modify.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function returning a numeric vector which, if passed to
<code><a href="base.html#topic+order">order</a></code>, will be used to sort some data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>desc_abs &lt;- descending(abs)

x &lt;- -2:1
order(abs(x))
order(desc_abs(x))
</code></pre>

<hr>
<h2 id='group_if'>Group vector values</h2><span id='topic+group_if'></span><span id='topic+group_eq'></span>

<h3>Description</h3>

<p>Split a vector or a list into groups, given a predicate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_if(x, predicate, na.rm = FALSE)

group_eq(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_if_+3A_x">x</code></td>
<td>
<p>a vector or a list to split into groups.</p>
</td></tr>
<tr><td><code id="group_if_+3A_predicate">predicate</code></td>
<td>
<p>a binary function returning a boolean value.</p>
</td></tr>
<tr><td><code id="group_if_+3A_na.rm">na.rm</code></td>
<td>
<p>if x is atomic, delete missing values before grouping.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predicate</code> will be applied to 2 adjacent elements. If it evaluates to
<code>TRUE</code>, those elements belong to the same group, otherwise they belong
to different groups.
</p>
<p>Grouping on equality is the most natural approach, therefore <code>group_eq</code>
is a convenient shortcut defined as </p>

<ul>
<li><p><code>group_if(x, predicate = `==`)</code> for an atomic vector;
</p>
</li>
<li><p><code>group_if(x, predicate = identical)</code> for a list.
</p>
</li></ul>

<p><code>group_if</code> (resp. <code>group_eq</code>) is inspired by <code>groupBy</code> (resp.
<code>group</code>) in Haskell.
<em>Note that <code>group_if</code> behaves a little differently : while in
Haskell, the comparison is made with the first element in the group, in this
R-version the comparison is made with the adjacent element.</em>
</p>
<p>The operator <a href="#topic++25on+25">%on%</a> may be helpful to create a predicate with readable
syntax.
</p>


<h3>Value</h3>

<p>A list where each element is a group (flattening this list should
give back the same values in the same order). Element names are kept.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c(3, 4, 2, 2, 1, 1, 1, 3)
group_eq(x1)
group_if(x1, `&lt;=`)
group_if(x1, function(x, y) abs(x - y) &gt; 1)

x2 &lt;- c(3, 4, 2, -2, -1, 1, 1, 3)
group_if(x2, `==` %on% abs)

x3 &lt;- list(1:3, 1:3, 3:5, 1, 2)
group_if(x3, `==` %on% length)
</code></pre>

<hr>
<h2 id='iterate'>Apply a function repeatedly</h2><span id='topic+iterate'></span>

<h3>Description</h3>

<p>Apply a function to a value, then reapply the same function to the result and
so on... until a condition on the result is met (or a certain number of
iterations reached).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate(x, f, stop_fun = NULL, stop_n = Inf, accumulate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterate_+3A_x">x</code></td>
<td>
<p>initial value.</p>
</td></tr>
<tr><td><code id="iterate_+3A_f">f</code></td>
<td>
<p>the function to apply.</p>
</td></tr>
<tr><td><code id="iterate_+3A_stop_fun">stop_fun</code></td>
<td>
<p>a predicate (function) evaluated on the current result, which
will stop the process if its result is <code>TRUE</code>. If not provided, the
process will stop after <code>stop_n</code> iteration (see below).</p>
</td></tr>
<tr><td><code id="iterate_+3A_stop_n">stop_n</code></td>
<td>
<p>maximal number of times the function will be applied (mandatory
if <code>stop_fun</code> is not defined).</p>
</td></tr>
<tr><td><code id="iterate_+3A_accumulate">accumulate</code></td>
<td>
<p>by default, the function returns only the last element. To
get the list of all intermediate results, turn this parameter to
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As it is a very generic function (<code>x</code> can be any type of object) and the
number of computations cannot be known in advance, <code>iterate</code> can be
quite inefficient (particularly if you use <code>accumulate = TRUE</code>).
</p>


<h3>Value</h3>

<p>The last result, or the list of all results if
<code>accumulate = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># https://en.wikipedia.org/wiki/Collatz_conjecture
syracuse &lt;- function(x) if (x %% 2) 3 * x + 1 else x / 2
iterate(
  10,
  syracuse,
  stop_fun = function(n) n == 1,
  accumulate = TRUE
)

# https://en.wikipedia.org/wiki/H%C3%A9non_map
henon_attractor &lt;-
  iterate(
    c(-1, 0.1),
    function(x) c(1 - 1.4 * x[1]^2 + x[2], 0.3 * x[1]),
    stop_n = 5000,
    accumulate = TRUE
  )
plot(
  sapply(henon_attractor, function(.) .[1]),
  sapply(henon_attractor, function(.) .[2]),
  pch = "."
)
</code></pre>

<hr>
<h2 id='partition'>Partition a vector in two</h2><span id='topic+partition'></span>

<h3>Description</h3>

<p>Split a vector or a list in 2 groups, given a predicate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(x, predicate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_+3A_x">x</code></td>
<td>
<p>vector or list to partition.</p>
</td></tr>
<tr><td><code id="partition_+3A_predicate">predicate</code></td>
<td>
<p>a function returning a boolean value, to apply to each
element of x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements. The first element contains elements of x
satisfying the predicate, the second the rest of x. Missing values will be
discarded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>partition(c(2, 1, 3, 4, 1, 5), function(x) x &lt; 3)
partition(list(1:3, NA, c(1, NA, 3)), anyNA)
</code></pre>

<hr>
<h2 id='sort_by'>Sort with auxiliary function</h2><span id='topic+sort_by'></span>

<h3>Description</h3>

<p>Sort a vector or a list, given one or more auxiliary functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_by(x, ..., method = c("auto", "shell", "radix"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_by_+3A_x">x</code></td>
<td>
<p>vector or list to sort.</p>
</td></tr>
<tr><td><code id="sort_by_+3A_...">...</code></td>
<td>
<p>one or several functions to apply to <code>x</code>. Use
<code><a href="#topic+descending">descending</a></code> for reversed order.</p>
</td></tr>
<tr><td><code id="sort_by_+3A_method">method</code></td>
<td>
<p>the method for ties (see <code><a href="base.html#topic+order">order</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of the first function will be used as first key for sorting,
the output of the second function as second key, and so on...
Therefore, these outputs should be sortable (i.e. atomic vectors).
</p>
<p><code>sort_by</code> is inspired by <code>sortBy</code> in Haskell.
</p>


<h3>Value</h3>

<p>A vector or list containing rearranged elements of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+order">order</a></code> which is used for rearranging elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sort_by(-3:2, abs)
sort_by(-3:2, abs, function(x) -x)
sort_by(list(5:7, 0, 1:4), length)
sort_by(list(1:2, 3:4, 5), length, descending(sum))
</code></pre>

<hr>
<h2 id='unique_by'>Unique with auxiliary function</h2><span id='topic+unique_by'></span>

<h3>Description</h3>

<p>Remove duplicate elements, given a transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_by(x, f, first = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_by_+3A_x">x</code></td>
<td>
<p>a vector or a list.</p>
</td></tr>
<tr><td><code id="unique_by_+3A_f">f</code></td>
<td>
<p>a function to apply to each element of <code>x</code>. This function must
produce comparable results.</p>
</td></tr>
<tr><td><code id="unique_by_+3A_first">first</code></td>
<td>
<p>if several elements are identical after being transformed by
<code>f</code>, keep the first. Otherwise, keep the last.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as x. Only elements that are unique after
being transformed by <code>f</code> are kept.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unique_by(-3:2, abs)
unique_by(-3:2, abs, first = FALSE)
unique_by(c(1, 2, 4, 5, 6), function(x) x %% 3)
unique_by(list(1:2, 2:3, 2:4), length)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
