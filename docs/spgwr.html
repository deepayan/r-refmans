<!DOCTYPE html><html><head><title>Help for package spgwr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spgwr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#georgia'><p>Georgia census data set (SpatialDataFramePolygons)</p></a></li>
<li><a href='#ggwr'><p>Generalised geographically weighted regression</p></a></li>
<li><a href='#ggwr.sel'><p>Crossvalidation of bandwidth for generalised GWR</p></a></li>
<li><a href='#gw.adapt'><p>Adaptive kernel for GWR</p></a></li>
<li><a href='#gw.cov'><p>Geographically weighted local statistics</p></a></li>
<li><a href='#gwr'><p>Geographically weighted regression</p></a></li>
<li><a href='#gwr.bisquare'><p>GWR bisquare weights function</p></a></li>
<li><a href='#gwr.gauss'><p>GWR Gaussian weights function</p></a></li>
<li><a href='#gwr.morantest'><p>Moran's I for gwr objects</p></a></li>
<li><a href='#gwr.sel'><p>Crossvalidation of bandwidth for geographically weighted regression</p></a></li>
<li><a href='#gwr.tricube'><p>GWR tricube weights function</p></a></li>
<li><a href='#LMZ.F3GWR.test'><p>Global tests of geographical weighted regressions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.6-36</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-21</td>
</tr>
<tr>
<td>Title:</td>
<td>Geographically Weighted Regression</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14), sp (&ge; 0.8-3), spData (&ge; 0.2.6.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spdep, parallel, sf, knitr, rmarkdown, tinytest</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for computing geographically weighted
  regressions are provided, based on work by Chris
  Brunsdon, Martin Charlton and Stewart Fotheringham. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rsbivand/spgwr/issues">https://github.com/rsbivand/spgwr/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rsbivand/spgwr/">https://github.com/rsbivand/spgwr/</a>,
<a href="https://rsbivand.github.io/spgwr/">https://rsbivand.github.io/spgwr/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-13 18:25:31 UTC; rsb</td>
</tr>
<tr>
<td>Author:</td>
<td>Roger Bivand <a href="https://orcid.org/0000-0003-2392-6140"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Danlin Yu <a href="https://orcid.org/0000-0002-4470-7011"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Tomoki Nakaya [ctb],
  Miquel-Angel Garcia-Lopez [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roger Bivand &lt;Roger.Bivand@nhh.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-14 03:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='georgia'>Georgia census data set (SpatialDataFramePolygons)</h2><span id='topic+georgia'></span><span id='topic+gSRDF'></span><span id='topic+gSRouter'></span>

<h3>Description</h3>

<p>The Georgia census data set from Fotheringham et al. (2002) in shapefile format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(georgia)</code></pre>


<h3>Format</h3>

<p>A SpatialPolygonsDataFrame object (proj4string set to &quot;+proj=longlat +datum=NAD27&quot;).
</p>
<p>The &quot;data&quot; slot is a data frame with 159 observations on the following 13 variables.
</p>

<dl>
<dt>AreaKey</dt><dd><p>a numeric vector</p>
</dd>
<dt>Latitude</dt><dd><p>a numeric vector</p>
</dd>
<dt>Longitud</dt><dd><p>a numeric vector</p>
</dd>
<dt>TotPop90</dt><dd><p>a numeric vector</p>
</dd>
<dt>PctRural</dt><dd><p>a numeric vector</p>
</dd>
<dt>PctBach</dt><dd><p>a numeric vector</p>
</dd>
<dt>PctEld</dt><dd><p>a numeric vector</p>
</dd>
<dt>PctFB</dt><dd><p>a numeric vector</p>
</dd>
<dt>PctPov</dt><dd><p>a numeric vector</p>
</dd>
<dt>PctBlack</dt><dd><p>a numeric vector</p>
</dd>
<dt>ID</dt><dd><p>a numeric vector</p>
</dd>
<dt>X</dt><dd><p>a numeric vector</p>
</dd>
<dt>Y</dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Variables are from GWR3 file GeorgiaData.csv.
</p>


<h3>Source</h3>

<p>Originally: http://www.census.gov/geo/cob/bdy/co/co90shp/co13_d90_shp.zip, currently behind: <a href="https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.1990.html">https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.1990.html</a> choosing 1990 Census and Georgia; <a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a>
</p>


<h3>References</h3>

<p>Fotheringham, A.S., Brunsdon, C., and Charlton, M.E., 2002, Geographically Weighted Regression: The Analysis of Spatially Varying Relationships, Chichester: Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(georgia)
plot(gSRDF)
data(gSRouter)
</code></pre>

<hr>
<h2 id='ggwr'>Generalised geographically weighted regression</h2><span id='topic+ggwr'></span>

<h3>Description</h3>

<p>The function implements generalised geographically weighted regression approach
to exploring spatial non-stationarity for given global bandwidth and chosen
weighting scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggwr(formula, data = list(), coords, bandwidth, gweight = gwr.Gauss,
 adapt = NULL, fit.points, family = gaussian, longlat = NULL, type = 
c("working", "deviance", "pearson", "response"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggwr_+3A_formula">formula</code></td>
<td>
<p>regression model formula as in <code>glm</code></p>
</td></tr>
<tr><td><code id="ggwr_+3A_data">data</code></td>
<td>
<p>model data frame as in <code>glm</code>, or may be a SpatialPointsDataFrame or SpatialPolygonsDataFrame object as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="ggwr_+3A_coords">coords</code></td>
<td>
<p>matrix of coordinates of points representing the spatial
positions of the observations</p>
</td></tr>
<tr><td><code id="ggwr_+3A_bandwidth">bandwidth</code></td>
<td>
<p>bandwidth used in the weighting function, possibly
calculated by <code>ggwr.sel</code></p>
</td></tr>
<tr><td><code id="ggwr_+3A_gweight">gweight</code></td>
<td>
<p>geographical weighting function, at present 
<code>gwr.Gauss()</code> default, or <code>gwr.gauss()</code>, the previous default or <code>gwr.bisquare()</code></p>
</td></tr>
<tr><td><code id="ggwr_+3A_adapt">adapt</code></td>
<td>
<p>either NULL (default) or a proportion between 0 and 1 of observations to include in weighting scheme (k-nearest neighbours)</p>
</td></tr>
<tr><td><code id="ggwr_+3A_fit.points">fit.points</code></td>
<td>
<p>an object containing the coordinates of fit points; often an object from package <span class="pkg">sp</span>; if missing, the coordinates given through the data argument object, or the coords argument are used</p>
</td></tr>
<tr><td><code id="ggwr_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model, see <code>glm</code></p>
</td></tr>
<tr><td><code id="ggwr_+3A_longlat">longlat</code></td>
<td>
<p>TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in kilometers; if x is a SpatialPoints object, the value is taken from the object itself</p>
</td></tr>
<tr><td><code id="ggwr_+3A_type">type</code></td>
<td>
<p>the type of residuals which should be returned. The alternatives are: &quot;working&quot; (default), &quot;pearson&quot;, &quot;deviance&quot; and &quot;response&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &ldquo;gwr&rdquo;:
</p>
<table>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or SpatialPolygonsDataFrame object (see package &quot;sp&quot;) with fit.points, weights, GWR coefficient estimates, dispersion if a &quot;quasi&quot;-family is used, and the residuals of type &quot;type&quot; in its &quot;data&quot; slot.</p>
</td></tr>
<tr><td><code>lhat</code></td>
<td>
<p>Leung et al. L matrix, here set to NA</p>
</td></tr>
<tr><td><code>lm</code></td>
<td>
<p>GLM global regression on the same model formula.</p>
</td></tr>  <tr><td><code>bandwidth</code></td>
<td>
<p>the bandwidth used.</p>
</td></tr>
<tr><td><code>this.call</code></td>
<td>
<p>the function call used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The use of GWR on GLM is only at the initial proof of concept stage, nothing should be treated as an accepted method at this stage.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Fotheringham, A.S., Brunsdon, C., and Charlton, M.E., 2002,
Geographically Weighted Regression, Chichester: Wiley;
<a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ggwr.sel">ggwr.sel</a></code>, <code><a href="#topic+gwr">gwr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(sf)) {
xx &lt;- as(st_read(system.file("shapes/sids.shp", package="spData")[1]), "Spatial")
bw &lt;- 144.4813
## Not run: 
bw &lt;- ggwr.sel(SID74 ~ I(NWBIR74/BIR74) + offset(log(BIR74)), data=xx,
  family=poisson(), longlat=TRUE)

## End(Not run)
nc &lt;- ggwr(SID74 ~ I(NWBIR74/BIR74) + offset(log(BIR74)), data=xx,
  family=poisson(), longlat=TRUE, bandwidth=bw)
nc
## Not run: 
nc &lt;- ggwr(SID74 ~ I(NWBIR74/10000) + offset(log(BIR74)), data=xx,
  family=poisson(), longlat=TRUE, bandwidth=bw)
nc
nc &lt;- ggwr(SID74 ~ I(NWBIR74/10000) + offset(log(BIR74)), data=xx,
  family=quasipoisson(), longlat=TRUE, bandwidth=bw)
nc

## End(Not run)
}
</code></pre>

<hr>
<h2 id='ggwr.sel'>Crossvalidation of bandwidth for generalised GWR</h2><span id='topic+ggwr.sel'></span><span id='topic+ggwr.cv.adapt.f'></span><span id='topic+ggwr.cv.f'></span>

<h3>Description</h3>

<p>The function finds a bandwidth for a given generalised geographically weighted regression
by optimzing a selected function. For cross-validation, this scores the root mean square
prediction error for the generalised geographically weighted regressions, choosing the
bandwidth minimizing this quantity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggwr.sel(formula, data = list(), coords, adapt = FALSE, gweight = gwr.Gauss,
 family = gaussian, verbose = TRUE, longlat = NULL, RMSE=FALSE,
 tol=.Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggwr.sel_+3A_formula">formula</code></td>
<td>
<p>regression model formula as in <code>glm</code></p>
</td></tr>
<tr><td><code id="ggwr.sel_+3A_data">data</code></td>
<td>
<p>model data frame as in <code>glm</code>, or may be a SpatialPointsDataFrame or SpatialPolygonsDataFrame object as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="ggwr.sel_+3A_coords">coords</code></td>
<td>
<p>matrix of coordinates of points representing the spatial
positions of the observations</p>
</td></tr>
<tr><td><code id="ggwr.sel_+3A_adapt">adapt</code></td>
<td>
<p>either TRUE: find the proportion between 0 and 1 of observations to include in weighting scheme (k-nearest neighbours), or FALSE &mdash; find global bandwidth</p>
</td></tr>
<tr><td><code id="ggwr.sel_+3A_gweight">gweight</code></td>
<td>
<p>geographical weighting function, at present 
<code>gwr.Gauss()</code> default, or <code>gwr.gauss()</code>, the previous default or <code>gwr.bisquare()</code></p>
</td></tr>
<tr><td><code id="ggwr.sel_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model, see <code>glm</code></p>
</td></tr>
<tr><td><code id="ggwr.sel_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE (default), reports the progress of search for bandwidth</p>
</td></tr>
<tr><td><code id="ggwr.sel_+3A_longlat">longlat</code></td>
<td>
<p>TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in kilometers; if x is a SpatialPoints object, the value is taken from the object itself</p>
</td></tr>
<tr><td><code id="ggwr.sel_+3A_rmse">RMSE</code></td>
<td>
<p>default FALSE to correspond with CV scores in newer references (sum of squared CV errors), if TRUE the previous behaviour of scoring by LOO CV RMSE</p>
</td></tr>
<tr><td><code id="ggwr.sel_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy to be passed to <code>optimize</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the cross-validation bandwidth.
</p>


<h3>Note</h3>

<p>The use of GWR on GLM is only at the initial proof of concept stage, nothing should be treated as an accepted method at this stage.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Fotheringham, A.S., Brunsdon, C., and Charlton, M.E., 2002,
Geographically Weighted Regression, Chichester: Wiley;
<a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gwr.sel">gwr.sel</a></code>, <code><a href="#topic+ggwr">ggwr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(sf)) {
xx &lt;- as(st_read(system.file("shapes/sids.shp", package="spData")[1]), "Spatial")
bw &lt;- ggwr.sel(SID74 ~ I(NWBIR74/BIR74) + offset(log(BIR74)), data=xx,
  family=poisson(), longlat=TRUE)
bw
}

</code></pre>

<hr>
<h2 id='gw.adapt'>Adaptive kernel for GWR</h2><span id='topic+gw.adapt'></span>

<h3>Description</h3>

<p>The function constructs weights using an adaptive kernal for geographically weighted regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gw.adapt(dp, fp, quant, longlat=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gw.adapt_+3A_dp">dp</code></td>
<td>
<p>data points coordinates</p>
</td></tr>
<tr><td><code id="gw.adapt_+3A_fp">fp</code></td>
<td>
<p>fit points coordinates</p>
</td></tr>
<tr><td><code id="gw.adapt_+3A_quant">quant</code></td>
<td>
<p>proportion of data points to include in the weights</p>
</td></tr>
<tr><td><code id="gw.adapt_+3A_longlat">longlat</code></td>
<td>
<p>if TRUE, use distances on an ellipse with WGS84 parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of weights
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>

<hr>
<h2 id='gw.cov'>Geographically weighted local statistics</h2><span id='topic+gw.cov'></span>

<h3>Description</h3>

<p>The function provides an implementation of geographically weighted local statistics based on Chapter 7 of the GWR book - see references. Local means, local standard deviations, local standard errors of the mean, standardised differences of the global and local means, and local covariances and if requested correlations, are reported for the chosed fixed or adaptive bandwidth and weighting function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gw.cov(x, vars, fp, adapt = NULL, bw, gweight = gwr.bisquare,
 cor = TRUE, var.term = FALSE, longlat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gw.cov_+3A_x">x</code></td>
<td>
 <p><code>x</code> should be a SpatialPolygonsDataFrame object or a SpatialPointsDataFrame object </p>
</td></tr>
<tr><td><code id="gw.cov_+3A_vars">vars</code></td>
<td>
 <p><code>vars</code> is a vector of column names of the data frame in the data slot of x </p>
</td></tr>
<tr><td><code id="gw.cov_+3A_fp">fp</code></td>
<td>
 <p><code>fp</code> if given an object inheriting from &ldquo;Spatial&rdquo; that contains the fit points to be used, for example a SpatialPixels object describing the grid of points to be used </p>
</td></tr>
<tr><td><code id="gw.cov_+3A_adapt">adapt</code></td>
<td>
 <p><code>adapt</code> if given should lie between 0 and 1, and indicates the proportion of observations to be included in the weighted window - it cannot be selected automatically</p>
</td></tr>
<tr><td><code id="gw.cov_+3A_bw">bw</code></td>
<td>
 <p><code>bw</code> when adapt is not given, the bandwidth chosen to suit the data set - it cannot be selected automatically</p>
</td></tr>
<tr><td><code id="gw.cov_+3A_gweight">gweight</code></td>
<td>
 <p><code>gweight</code> default gwr.bisquare - the weighting function to use </p>
</td></tr>
<tr><td><code id="gw.cov_+3A_cor">cor</code></td>
<td>
 <p><code>cor</code> default TRUE, report correlations in addition to covariances </p>
</td></tr>
<tr><td><code id="gw.cov_+3A_var.term">var.term</code></td>
<td>
 <p><code>var.term</code> default FALSE, if TRUE apply a correction to the variance term </p>
</td></tr>
<tr><td><code id="gw.cov_+3A_longlat">longlat</code></td>
<td>
<p>TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in kilometers; if x is a SpatialPoints object, the value is taken from the object itself</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If argument fp is given, and it is a SpatialPixels object, a SpatialPixelsDataFrame is returned, if it is any other coordinate object, a SpatialPointsDataFrame is returned. If argument fp is not given, the object returned will be the class of object x. The data slot will contain a data frame with local means, local standard deviations, local standard errors of the mean, standardised differences of the global and local means, and local covariances and if requested correlations.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Fotheringham, A.S., Brunsdon, C., and Charlton, M.E., 2002,
Geographically Weighted Regression, Chichester: Wiley (chapter 7);
<a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gwr">gwr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(georgia)
SRgwls &lt;- gw.cov(gSRDF, vars=6:11, bw=2, longlat=FALSE)
names(SRgwls$SDF)
spplot(SRgwls$SDF, "mean.PctPov")
spplot(SRgwls$SDF, "sd.PctPov")
spplot(SRgwls$SDF, "sem.PctPov")
spplot(SRgwls$SDF, "diff.PctPov")
spplot(SRgwls$SDF, "cor.PctPov.PctBlack.")
SRgwls &lt;- gw.cov(gSRDF, vars=6:11, bw=150, longlat=TRUE)
names(SRgwls$SDF)
spplot(SRgwls$SDF, "mean.PctPov")
spplot(SRgwls$SDF, "sd.PctPov")
spplot(SRgwls$SDF, "sem.PctPov")
spplot(SRgwls$SDF, "diff.PctPov")
spplot(SRgwls$SDF, "cor.PctPov.PctBlack.")
data(gSRouter)
#gGrid &lt;- sample.Polygons(slot(gSRouter, "polygons")[[1]], 5000,
gGrid &lt;- spsample(slot(gSRouter, "polygons")[[1]], 5000,
  type="regular")
gridded(gGrid) &lt;- TRUE
SGgwls &lt;- gw.cov(gSRDF, vars=6:11, fp=gGrid, bw=150, longlat=TRUE)
names(SGgwls$SDF)
spplot(SGgwls$SDF, "mean.PctPov")
spplot(SGgwls$SDF, "sd.PctPov")
spplot(SGgwls$SDF, "sem.PctPov")
spplot(SGgwls$SDF, "diff.PctPov")
spplot(SGgwls$SDF, "cor.PctPov.PctBlack.")

set.seed(1)
pts &lt;- data.frame(x=runif(100, 0, 5), y=runif(100, 0, 5), z=rnorm(100))
coordinates(pts) &lt;- c("x", "y")
proj4string(pts) &lt;- CRS("+proj=longlat +ellps=WGS84")
fps &lt;- SpatialPoints(cbind(x=runif(100, 0, 5), y=runif(100, 0, 5)),
 proj4string=CRS("+proj=longlat +ellps=WGS84"))
t0 &lt;- gw.cov(pts, "z", fp=fps, adapt=0.2, longlat=TRUE)
</code></pre>

<hr>
<h2 id='gwr'>Geographically weighted regression</h2><span id='topic+gwr'></span><span id='topic+print.gwr'></span>

<h3>Description</h3>

<p>The function implements the basic geographically weighted regression approach
to exploring spatial non-stationarity for given global bandwidth and chosen
weighting scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr(formula, data=list(), coords, bandwidth, gweight=gwr.Gauss, 
	adapt=NULL, hatmatrix = FALSE, fit.points, longlat=NULL, 
	se.fit=FALSE, weights, cl=NULL, predictions = FALSE, 
        fittedGWRobject = NULL, se.fit.CCT = TRUE)
## S3 method for class 'gwr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr_+3A_formula">formula</code></td>
<td>
<p>regression model formula as in <code>lm</code></p>
</td></tr>
<tr><td><code id="gwr_+3A_data">data</code></td>
<td>
<p>model data frame, or SpatialPointsDataFrame or SpatialPolygonsDataFrame as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr_+3A_coords">coords</code></td>
<td>
<p>matrix of coordinates of points representing the spatial
positions of the observations; may be omitted if the object passed through the data argument is from package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr_+3A_bandwidth">bandwidth</code></td>
<td>
<p>bandwidth used in the weighting function, possibly
calculated by <code>gwr.sel</code></p>
</td></tr>
<tr><td><code id="gwr_+3A_gweight">gweight</code></td>
<td>
<p>geographical weighting function, at present 
<code>gwr.Gauss()</code> default, or <code>gwr.gauss()</code>, the previous default or <code>gwr.bisquare()</code></p>
</td></tr>
<tr><td><code id="gwr_+3A_adapt">adapt</code></td>
<td>
<p>either NULL (default) or a proportion between 0 and 1 of observations to include in weighting scheme (k-nearest neighbours)</p>
</td></tr>
<tr><td><code id="gwr_+3A_hatmatrix">hatmatrix</code></td>
<td>
<p>if TRUE, return the hatmatrix as a component of the result, ignored if <code>fit.points</code> given</p>
</td></tr>
<tr><td><code id="gwr_+3A_fit.points">fit.points</code></td>
<td>
<p>an object containing the coordinates of fit points; often an object from package <span class="pkg">sp</span>; if missing, the coordinates given through the data argument object, or the coords argument are used</p>
</td></tr>
<tr><td><code id="gwr_+3A_longlat">longlat</code></td>
<td>
<p>TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in kilometers; if x is a SpatialPoints object, the value is taken from the object itself</p>
</td></tr>
<tr><td><code id="gwr_+3A_se.fit">se.fit</code></td>
<td>
<p>if TRUE, return local coefficient standard errors - if <code>hatmatrix</code> is TRUE and no fit.points are given, two effective degrees of freedom sigmas will be used to generate alternative coefficient standard errors</p>
</td></tr>
<tr><td><code id="gwr_+3A_weights">weights</code></td>
<td>
<p>case weights used as in weighted least squares, beware of scaling issues, probably unsafe</p>
</td></tr>
<tr><td><code id="gwr_+3A_cl">cl</code></td>
<td>
<p>if NULL, ignored, otherwise <code>cl</code> must be an object describing a &ldquo;cluster&rdquo; created using <code>makeCluster</code> in the <span class="pkg">parallel</span> package. The cluster will then be used to hand off the calculation of local coefficients to cluster nodes, if fit points have been given as an argument, and <code>hatmatrix=FALSE</code></p>
</td></tr>
<tr><td><code id="gwr_+3A_predictions">predictions</code></td>
<td>
<p>default FALSE; if TRUE and no fit points given, return GW fitted values at data points, if fit points given and are a Spatial*DataFrame object containing the RHS variables in the formula, return GW predictions at the fit points</p>
</td></tr>
<tr><td><code id="gwr_+3A_fittedgwrobject">fittedGWRobject</code></td>
<td>
<p>a fitted <code>gwr</code> object with a hatmatrix (optional), if given, and if fit.points are given and if <code>se.fit</code> is TRUE, two effective degrees of freedom sigmas will be used to generate alternative coefficient standard errors</p>
</td></tr>
<tr><td><code id="gwr_+3A_se.fit.cct">se.fit.CCT</code></td>
<td>
<p>default TRUE, compute local coefficient standard errors using formula (2.14), p. 55, in the GWR book</p>
</td></tr>
<tr><td><code id="gwr_+3A_x">x</code></td>
<td>
<p>an object of class &quot;gwr&quot; returned by the <code>gwr</code> function</p>
</td></tr>
<tr><td><code id="gwr_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function applies the weighting function in turn to each of the 
observations, or fit points if given, calculating a weighted regression 
for each point. The results may be explored to see if coefficient values vary over space. The local coefficient estimates may be made on a multi-node cluster using the <code>cl</code> argument to pass through a <span class="pkg">parallel</span> cluster. The function will then divide the fit points (which must be given separately) between the clusters for fitting. Note that each node will need to have the &ldquo;spgwr&rdquo; package present, so initiating by <code>clusterEvalQ(cl, library(spgwr))</code> may save a little time per node. The function clears the global environment on the node of objects sent. Using two nodes reduces timings to a little over half the time for a single node.
</p>
<p>The section of the examples code now includes two simulation scenarios, showing how important it is to check that mapped pattern in local coefficients is actually there, rather than being an artefact.
</p>


<h3>Value</h3>

<p>A list of class &ldquo;gwr&rdquo;:
</p>
<table>
<tr><td><code>SDF</code></td>
<td>
<p>a SpatialPointsDataFrame (may be gridded) or SpatialPolygonsDataFrame object (see package &quot;sp&quot;) with fit.points, weights, GWR coefficient estimates, R-squared, and coefficient standard errors in its &quot;data&quot; slot.</p>
</td></tr>
<tr><td><code>lhat</code></td>
<td>
<p>Leung et al. L matrix</p>
</td></tr>
<tr><td><code>lm</code></td>
<td>
<p>Ordinary least squares global regression on the same model formula, as returned by lm.wfit().</p>
</td></tr>
<tr><td><code>bandwidth</code></td>
<td>
<p>the bandwidth used.</p>
</td></tr>
<tr><td><code>this.call</code></td>
<td>
<p>the function call used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Fotheringham, A.S., Brunsdon, C., and Charlton, M.E., 2002,
Geographically Weighted Regression, Chichester: Wiley; Paez A, Farber S, Wheeler D, 2011, &quot;A simulation-based study of geographically weighted regression as a method for investigating spatially varying relationships&quot;, Environment and
Planning A 43(12) 2992-3010;
<a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gwr.sel">gwr.sel</a></code>, <code><a href="#topic+gwr.gauss">gwr.gauss</a></code>,
<code><a href="#topic+gwr.bisquare">gwr.bisquare</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(columbus, package="spData")
col.lm &lt;- lm(CRIME ~ INC + HOVAL, data=columbus)
summary(col.lm)
col.bw &lt;- gwr.sel(CRIME ~ INC + HOVAL, data=columbus,
  coords=cbind(columbus$X, columbus$Y))
col.gauss &lt;- gwr(CRIME ~ INC + HOVAL, data=columbus,
  coords=cbind(columbus$X, columbus$Y), bandwidth=col.bw, hatmatrix=TRUE)
col.gauss
col.d &lt;- gwr.sel(CRIME ~ INC + HOVAL, data=columbus,
  coords=cbind(columbus$X, columbus$Y), gweight=gwr.bisquare)
col.bisq &lt;- gwr(CRIME ~ INC + HOVAL, data=columbus,
  coords=cbind(columbus$X, columbus$Y), bandwidth=col.d, 
  gweight=gwr.bisquare, hatmatrix=TRUE)
col.bisq
data(georgia)
g.adapt.gauss &lt;- gwr.sel(PctBach ~ TotPop90 + PctRural + PctEld + PctFB + 
 PctPov + PctBlack, data=gSRDF, adapt=TRUE)
res.adpt &lt;- gwr(PctBach ~ TotPop90 + PctRural + PctEld + PctFB + PctPov + 
 PctBlack, data=gSRDF, adapt=g.adapt.gauss)
res.adpt
pairs(as(res.adpt$SDF, "data.frame")[,2:8], pch=".")
brks &lt;- c(-0.25, 0, 0.01, 0.025, 0.075)
cols &lt;- grey(5:2/6)
plot(res.adpt$SDF, col=cols[findInterval(res.adpt$SDF$PctBlack, brks,
 all.inside=TRUE)])

# simulation scenario with patterned dependent variable
set.seed(1)
X0 &lt;- runif(nrow(gSRDF)*3)
X1 &lt;- matrix(sample(X0), ncol=3)
X1 &lt;- prcomp(X1, center=FALSE, scale.=FALSE)$x
gSRDF$X1 &lt;- X1[,1]
gSRDF$X2 &lt;- X1[,2]
gSRDF$X3 &lt;- X1[,3]
bw &lt;- gwr.sel(PctBach ~ X1 + X2 + X3, data=gSRDF, verbose=FALSE)
out &lt;- gwr(PctBach ~ X1 + X2 + X3, data=gSRDF, bandwidth=bw, hatmatrix=TRUE)
out
spplot(gSRDF, "PctBach", col.regions=grey.colors(20))
spplot(gSRDF, c("X1", "X2", "X3"), col.regions=grey.colors(20))
# pattern in the local coefficients
spplot(out$SDF, c("X1", "X2", "X3"), col.regions=grey.colors(20))
# but no "significant" pattern
spplot(out$SDF, c("X1_se", "X2_se", "X3_se"), col.regions=grey.colors(20))
out$SDF$X1_t &lt;- out$SDF$X1/out$SDF$X1_se
out$SDF$X2_t &lt;- out$SDF$X2/out$SDF$X2_se
out$SDF$X3_t &lt;- out$SDF$X3/out$SDF$X3_se
spplot(out$SDF, c("X1_t", "X2_t", "X3_t"), col.regions=grey.colors(20))
# simulation scenario with random dependent variable
yrn &lt;- rnorm(nrow(gSRDF))
gSRDF$yrn &lt;- sample(yrn)
bw &lt;- gwr.sel(yrn ~ X1 + X2 + X3, data=gSRDF, verbose=FALSE)
# bandwidth selection maxes out at 620 km, equal to upper bound
# of line search
out &lt;- gwr(yrn ~ X1 + X2 + X3, data=gSRDF, bandwidth=bw, hatmatrix=TRUE)
out
spplot(gSRDF, "yrn", col.regions=grey.colors(20))
spplot(gSRDF, c("X1", "X2", "X3"), col.regions=grey.colors(20))
# pattern in the local coefficients
spplot(out$SDF, c("X1", "X2", "X3"), col.regions=grey.colors(20))
# but no "significant" pattern
spplot(out$SDF, c("X1_se", "X2_se", "X3_se"), col.regions=grey.colors(20))
out$SDF$X1_t &lt;- out$SDF$X1/out$SDF$X1_se
out$SDF$X2_t &lt;- out$SDF$X2/out$SDF$X2_se
out$SDF$X3_t &lt;- out$SDF$X3/out$SDF$X3_se
spplot(out$SDF, c("X1_t", "X2_t", "X3_t"), col.regions=grey.colors(20))
# end of simulations


data(meuse)
coordinates(meuse) &lt;- c("x", "y")
meuse$ffreq &lt;- factor(meuse$ffreq)
data(meuse.grid)
coordinates(meuse.grid) &lt;- c("x", "y")
meuse.grid$ffreq &lt;- factor(meuse.grid$ffreq)
gridded(meuse.grid) &lt;- TRUE
xx &lt;- gwr(cadmium ~ dist, meuse, bandwidth = 228, hatmatrix=TRUE)
xx
x &lt;- gwr(cadmium ~ dist, meuse, bandwidth = 228, fit.points = meuse.grid,
 predict=TRUE, se.fit=TRUE, fittedGWRobject=xx)
x
spplot(x$SDF, "pred")
spplot(x$SDF, "pred.se")

## Not run: 
  g.bw.gauss &lt;- gwr.sel(PctBach ~ TotPop90 + PctRural + PctEld + PctFB +
    PctPov + PctBlack, data=gSRDF)
  res.bw &lt;- gwr(PctBach ~ TotPop90 + PctRural + PctEld + PctFB + PctPov +
    PctBlack, data=gSRDF, bandwidth=g.bw.gauss)
  res.bw
  pairs(as(res.bw$SDF, "data.frame")[,2:8], pch=".")
  plot(res.bw$SDF, col=cols[findInterval(res.bw$SDF$PctBlack, brks,
    all.inside=TRUE)])
  g.bw.gauss &lt;- gwr.sel(PctBach ~ TotPop90 + PctRural + PctEld + PctFB +
    PctPov + PctBlack, data=gSRDF, longlat=TRUE)
  data(gSRouter)
#  require(maptools)
#  SG &lt;- GE_SpatialGrid(gSRouter, maxPixels = 100)
  if (require(sf, quietly=TRUE) &amp;&amp; require(stars, quietly=TRUE)) {
    SG_0 &lt;- st_as_stars(st_bbox(st_as_sf(gSRouter)), nx=87, ny=100)
    SG &lt;- as(SG_0, "Spatial")
    SPxMASK0 &lt;- over(SG, gSRouter)
    SGDF &lt;- SpatialGridDataFrame(slot(SG, "grid"),
      data=data.frame(SPxMASK0=SPxMASK0),
      proj4string=CRS(proj4string(gSRouter)))
    SPxDF &lt;- as(SGDF, "SpatialPixelsDataFrame")
    res.bw &lt;- gwr(PctBach ~ TotPop90 + PctRural + PctEld + PctFB + PctPov +
      PctBlack, data=gSRDF, bandwidth=g.bw.gauss, fit.points=SPxDF,
      longlat=TRUE)
    res.bw
    res.bw$timings
    spplot(res.bw$SDF, "PctBlack")
    require(parallel)
    cl &lt;- makeCluster(detectCores())
    res.bwc &lt;- gwr(PctBach ~ TotPop90 + PctRural + PctEld + PctFB + PctPov +
      PctBlack, data=gSRDF, bandwidth=g.bw.gauss, fit.points=SPxDF,
      longlat=TRUE, cl=cl)
    res.bwc
    res.bwc$timings
    stopCluster(cl)
  }

## End(Not run)
</code></pre>

<hr>
<h2 id='gwr.bisquare'>GWR bisquare weights function</h2><span id='topic+gwr.bisquare'></span>

<h3>Description</h3>

<p>The function returns a vector of weights using
the bisquare scheme:
</p>
<p style="text-align: center;"><code class="reqn">w_{ij}(g) = (1 - (d_{ij}^2/d^2))^2 </code>
</p>

<p>if <code class="reqn">d_{ij} &lt;= d</code> else <code class="reqn">w_{ij}(g) = 0</code>, where <code class="reqn">d_{ij}</code> 
are the distances between the observations
and <code class="reqn">d</code> is the distance at which weights are set to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.bisquare(dist2, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.bisquare_+3A_dist2">dist2</code></td>
<td>
<p>vector of squared distances between observations</p>
</td></tr>
<tr><td><code id="gwr.bisquare_+3A_d">d</code></td>
<td>
<p>distance at which weights are set to zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of weights.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Fotheringham, A.S., Brunsdon, C., and Charlton, M.E., 2000,
Quantitative Geography, London: Sage; C. Brunsdon, A.Stewart Fotheringham
and M.E. Charlton, 1996, &quot;Geographically Weighted Regression: A Method for
Exploring Spatial Nonstationarity&quot;, Geographical Analysis, 28(4), 281-298;
<a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gwr.sel">gwr.sel</a></code>, <code><a href="#topic+gwr">gwr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(seq(-10,10,0.1), gwr.bisquare(seq(-10,10,0.1)^2, 6.0), type="l")
</code></pre>

<hr>
<h2 id='gwr.gauss'>GWR Gaussian weights function</h2><span id='topic+gwr.gauss'></span><span id='topic+gwr.Gauss'></span>

<h3>Description</h3>

<p>The gwr.gauss function returns a vector of weights using
the Gaussian scheme:
</p>
<p style="text-align: center;"><code class="reqn">w(g) = e^{{-(d/h)}^2}</code>
</p>

<p>where <code class="reqn">d</code> are the distances between the observations
and <code class="reqn">h</code> is the bandwidth.
</p>
<p>The default (from release 0.5) gwr.Gauss function returns a vector of 
weights using the Gaussian scheme:
</p>
<p style="text-align: center;"><code class="reqn">w(g) = e^{-(1/2) {{(d/h)}^2}}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>gwr.gauss(dist2, bandwidth)
gwr.Gauss(dist2, bandwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.gauss_+3A_dist2">dist2</code></td>
<td>
<p>vector of squared distances between observations and fit point</p>
</td></tr>
<tr><td><code id="gwr.gauss_+3A_bandwidth">bandwidth</code></td>
<td>
<p>bandwidth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of weights.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Fotheringham, A.S., Brunsdon, C., and Charlton, M.E., 2000,
Quantitative Geography, London: Sage; C. Brunsdon, A.Stewart Fotheringham
and M.E. Charlton, 1996, &quot;Geographically Weighted Regression: A Method for
Exploring Spatial Nonstationarity&quot;, Geographical Analysis, 28(4), 281-298;
<a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gwr.sel">gwr.sel</a></code>, <code><a href="#topic+gwr">gwr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(seq(-10,10,0.1), gwr.Gauss(seq(-10,10,0.1)^2, 3.5), type="l")
</code></pre>

<hr>
<h2 id='gwr.morantest'>Moran's I for gwr objects</h2><span id='topic+gwr.morantest'></span>

<h3>Description</h3>

<p>The function returns Leung et al. (2000) three moment approximation for Moran's I, for a gwr object calculated with argument hatmatrix=TRUE. This implementation should not be regarded as authoritative, as it involves assumptions about implied methods and about estimated degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.morantest(x, lw, zero.policy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.morantest_+3A_x">x</code></td>
<td>
<p>a <code>gwr</code> object returned by <code>gwr()</code> with argument hatmatrix=TRUE</p>
</td></tr>
<tr><td><code id="gwr.morantest_+3A_lw">lw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code> in the spdep package</p>
</td></tr>
<tr><td><code id="gwr.morantest_+3A_zero.policy">zero.policy</code></td>
<td>
<p>if TRUE assign zero to the lagged value of zones without 
neighbours, if FALSE (default) assign NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &ldquo;htest&rdquo; object with the results of testing the GWR residuals
</p>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>References</h3>

<p>Leung Y, Mei C-L, Zhang W-X 2000 Testing for spatial autocorrelation among the residuals of the geographically weighted regression, Environment and Planning A, 32, 871-890.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (suppressWarnings(require(spData)) &amp;&amp; suppressWarnings(require(spdep))) {
  data(columbus, package="spData")
  bw &lt;- gwr.sel(CRIME ~ INC + HOVAL, data=columbus, coords=coords)
  col0 &lt;- gwr(CRIME ~ INC + HOVAL, data=columbus, coords=coords,
    bandwidth=bw, hatmatrix=TRUE)
  gwr.morantest(col0, nb2listw(col.gal.nb))
}
</code></pre>

<hr>
<h2 id='gwr.sel'>Crossvalidation of bandwidth for geographically weighted regression</h2><span id='topic+gwr.sel'></span><span id='topic+gwr.cv.f'></span><span id='topic+gwr.cv.adapt.f'></span><span id='topic+gwr.aic.f'></span><span id='topic+gwr.aic.adapt.f'></span>

<h3>Description</h3>

<p>The function finds a bandwidth for a given geographically weighted regression
by optimzing a selected function. For cross-validation, this scores the root mean square
prediction error for the geographically weighted regressions, choosing the
bandwidth minimizing this quantity. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.sel(formula, data=list(), coords, adapt=FALSE, gweight=gwr.Gauss,
 method = "cv", verbose = TRUE, longlat=NULL, RMSE=FALSE, weights,
 tol=.Machine$double.eps^0.25, show.error.messages = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.sel_+3A_formula">formula</code></td>
<td>
<p>regression model formula as in <code>lm</code></p>
</td></tr>
<tr><td><code id="gwr.sel_+3A_data">data</code></td>
<td>
<p>model data frame as in <code>lm</code>, or may be a SpatialPointsDataFrame or SpatialPolygonsDataFrame object as defined in package <span class="pkg">sp</span></p>
</td></tr>
<tr><td><code id="gwr.sel_+3A_coords">coords</code></td>
<td>
<p>matrix of coordinates of points representing the spatial
positions of the observations</p>
</td></tr>
<tr><td><code id="gwr.sel_+3A_adapt">adapt</code></td>
<td>
<p>either TRUE: find the proportion between 0 and 1 of observations to include in weighting scheme (k-nearest neighbours), or FALSE &mdash; find global bandwidth</p>
</td></tr>
<tr><td><code id="gwr.sel_+3A_gweight">gweight</code></td>
<td>
<p>geographical weighting function, at present 
<code>gwr.Gauss()</code> default, or <code>gwr.gauss()</code>, the previous default or <code>gwr.bisquare()</code></p>
</td></tr>
<tr><td><code id="gwr.sel_+3A_method">method</code></td>
<td>
<p>default &quot;cv&quot; for drop-1 cross-validation, or &quot;aic&quot; for AIC optimisation (depends on assumptions about AIC degrees of freedom)</p>
</td></tr>
<tr><td><code id="gwr.sel_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE (default), reports the progress of search for bandwidth</p>
</td></tr>
<tr><td><code id="gwr.sel_+3A_longlat">longlat</code></td>
<td>
<p>TRUE if point coordinates are longitude-latitude decimal degrees, in which case distances are measured in kilometers; if x is a SpatialPoints object, the value is taken from the object itself</p>
</td></tr>
<tr><td><code id="gwr.sel_+3A_rmse">RMSE</code></td>
<td>
<p>default FALSE to correspond with CV scores in newer references (sum of squared CV errors), if TRUE the previous behaviour of scoring by LOO CV RMSE</p>
</td></tr>
<tr><td><code id="gwr.sel_+3A_weights">weights</code></td>
<td>
<p>case weights used as in weighted least squares, beware of scaling issues &mdash; only used with the cross-validation method, probably unsafe</p>
</td></tr>
<tr><td><code id="gwr.sel_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy to be passed to <code>optimize</code></p>
</td></tr>
<tr><td><code id="gwr.sel_+3A_show.error.messages">show.error.messages</code></td>
<td>
<p>default FALSE; may be set to TRUE to see error messages if <code>gwr.sel</code> returns without a value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the regression contains little pattern, the bandwidth will converge to the upper bound of the line search, which is the diagonal of the bounding box of the data point coordinates for &ldquo;adapt=FALSE&rdquo;, and 1 for &ldquo;adapt=TRUE&rdquo;; see the simulation block in the examples below.</p>


<h3>Value</h3>

<p>returns the cross-validation bandwidth.
</p>


<h3>Note</h3>

<p>Use of method=&quot;aic&quot; results in the creation of an n by n matrix, and should not be chosen when n is large.</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Fotheringham, A.S., Brunsdon, C., and Charlton, M.E., 2002,
Geographically Weighted Regression, Chichester: Wiley; Paez A, Farber S, Wheeler D, 2011, &quot;A simulation-based study of geographically weighted regression as a method for investigating spatially varying relationships&quot;, Environment and
Planning A 43(12) 2992-3010;
<a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gwr.bisquare">gwr.bisquare</a></code>, <code><a href="#topic+gwr.gauss">gwr.gauss</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(columbus, package="spData")
gwr.sel(CRIME ~ INC + HOVAL, data=columbus,
  coords=cbind(columbus$X, columbus$Y))
gwr.sel(CRIME ~ INC + HOVAL, data=columbus,
  coords=cbind(columbus$X, columbus$Y), gweight=gwr.bisquare)
## Not run: 
data(georgia)
set.seed(1)
X0 &lt;- runif(nrow(gSRDF)*3)
X1 &lt;- matrix(sample(X0), ncol=3)
X1 &lt;- prcomp(X1, center=FALSE, scale.=FALSE)$x
gSRDF$X1 &lt;- X1[,1]
gSRDF$X2 &lt;- X1[,2]
gSRDF$X3 &lt;- X1[,3]
yrn &lt;- rnorm(nrow(gSRDF))
gSRDF$yrn &lt;- sample(yrn)
bw &lt;- gwr.sel(yrn ~ X1 + X2 + X3, data=gSRDF, method="cv", adapt=FALSE, verbose=FALSE)
bw
bw &lt;- gwr.sel(yrn ~ X1 + X2 + X3, data=gSRDF, method="aic", adapt=FALSE, verbose=FALSE)
bw
bw &lt;- gwr.sel(yrn ~ X1 + X2 + X3, data=gSRDF, method="cv", adapt=TRUE, verbose=FALSE)
bw
bw &lt;- gwr.sel(yrn ~ X1 + X2 + X3, data=gSRDF, method="aic", adapt=TRUE, verbose=FALSE)
bw

## End(Not run)
</code></pre>

<hr>
<h2 id='gwr.tricube'>GWR tricube weights function</h2><span id='topic+gwr.tricube'></span>

<h3>Description</h3>

<p>The function returns a vector of weights using
the tricube scheme:
</p>
<p style="text-align: center;"><code class="reqn">w_{ij}(g) = (1 - (d_{ij}/d)^3)^3 </code>
</p>

<p>if <code class="reqn">d_{ij} &lt;= d</code> else <code class="reqn">w_{ij}(g) = 0</code>, where <code class="reqn">d_{ij}</code> 
are the distances between the observations
and <code class="reqn">d</code> is the distance at which weights are set to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr.tricube(dist2, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwr.tricube_+3A_dist2">dist2</code></td>
<td>
<p>vector of squared distances between observations</p>
</td></tr>
<tr><td><code id="gwr.tricube_+3A_d">d</code></td>
<td>
<p>distance at which weights are set to zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of weights.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a></p>


<h3>References</h3>

<p>Fotheringham, A.S., Brunsdon, C., and Charlton, M.E., 2000,
Quantitative Geography, London: Sage; C. Brunsdon, A.Stewart Fotheringham
and M.E. Charlton, 1996, &quot;Geographically Weighted Regression: A Method for
Exploring Spatial Nonstationarity&quot;, Geographical Analysis, 28(4), 281-298;
<a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gwr.sel">gwr.sel</a></code>, <code><a href="#topic+gwr">gwr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(seq(-10,10,0.1), gwr.tricube(seq(-10,10,0.1)^2, 6.0), type="l")
</code></pre>

<hr>
<h2 id='LMZ.F3GWR.test'>Global tests of geographical weighted regressions</h2><span id='topic+LMZ.F3GWR.test'></span><span id='topic+LMZ.F2GWR.test'></span><span id='topic+LMZ.F1GWR.test'></span><span id='topic+BFC99.gwr.test'></span><span id='topic+BFC02.gwr.test'></span><span id='topic+anova.gwr'></span>

<h3>Description</h3>

<p>Four related test statistics for comparing OLS and GWR models based on bapers by Brunsdon, Fotheringham and Charlton (1999) and Leung et al (2000), and a development from the GWR book (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMZ.F3GWR.test(go)
LMZ.F2GWR.test(x)
LMZ.F1GWR.test(x)
BFC99.gwr.test(x)
BFC02.gwr.test(x, approx=FALSE)
## S3 method for class 'gwr'
anova(object, ..., approx=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LMZ.F3GWR.test_+3A_go">go</code>, <code id="LMZ.F3GWR.test_+3A_x">x</code>, <code id="LMZ.F3GWR.test_+3A_object">object</code></td>
<td>
<p>a <code>gwr</code> object returned by <code>gwr()</code></p>
</td></tr>
<tr><td><code id="LMZ.F3GWR.test_+3A_...">...</code></td>
<td>
<p>arguments passed through (unused)</p>
</td></tr>
<tr><td><code id="LMZ.F3GWR.test_+3A_approx">approx</code></td>
<td>
<p>default FALSE, if TRUE, use only (n - tr(S)) instead of (n - 2*tr(S) - tr(S'S)) as the GWR degrees of freedom</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The papers in the references give the background for the analyses of variance presented.
</p>


<h3>Value</h3>

<p>BFC99.GWR.test, BFC02.gwr.test, LMZ.F1GWR.test and LMZ.F2GWR.test return &quot;htest&quot; objects, 
LMZ.F3GWR.test a matrix of test results.
</p>


<h3>Author(s)</h3>

<p>Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a> and Danlin Yu</p>


<h3>References</h3>

<p>Fotheringham, A.S., Brunsdon, C., and Charlton, M.E., 2002,
Geographically Weighted Regression, Chichester: Wiley;
<a href="http://gwr.nuim.ie/">http://gwr.nuim.ie/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gwr">gwr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(columbus, package="spData")
col.bw &lt;- gwr.sel(CRIME ~ INC + HOVAL, data=columbus,
  coords=cbind(columbus$X, columbus$Y))
col.gauss &lt;- gwr(CRIME ~ INC + HOVAL, data=columbus,
  coords=cbind(columbus$X, columbus$Y), bandwidth=col.bw, hatmatrix=TRUE)
BFC99.gwr.test(col.gauss)
BFC02.gwr.test(col.gauss)
BFC02.gwr.test(col.gauss, approx=TRUE)
anova(col.gauss)
anova(col.gauss, approx=TRUE)
## Not run: 
col.d &lt;- gwr.sel(CRIME ~ INC + HOVAL, data=columbus,
  coords=cbind(columbus$X, columbus$Y), gweight=gwr.bisquare)
col.bisq &lt;- gwr(CRIME ~ INC + HOVAL, data=columbus,
  coords=cbind(columbus$X, columbus$Y), bandwidth=col.d, 
  gweight=gwr.bisquare, hatmatrix=TRUE)
BFC99.gwr.test(col.bisq)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
