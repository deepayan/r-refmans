<!DOCTYPE html><html><head><title>Help for package optimalThreshold</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {optimalThreshold}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#optimalThreshold-package'><p>optimalThreshold: Bayesian Methods for Optimal Threshold Estimation</p></a></li>
<li><a href='#allowedDist-class'><p>An S4 union class to represent allowed dist object.</p></a></li>
<li><a href='#allowedFitDist-class'><p>An S4 union class to represent allowed fitDist objects.</p></a></li>
<li><a href='#cdf'><p>Cumulative distribution function of a specified distribution</p></a></li>
<li><a href='#compoundEvtInnovDist-class'><p>An S4 class to represent a compound distribution.</p></a></li>
<li><a href='#compoundEvtRefDist-class'><p>An S4 class to represent a compound distribution.</p></a></li>
<li><a href='#compoundNoEvtInnovDist-class'><p>An S4 class to represent a compound distribution.</p></a></li>
<li><a href='#compoundNoEvtRefDist-class'><p>An S4 class to represent a compound distribution.</p></a></li>
<li><a href='#credibleIntervals'><p>Credible intervals estimation</p></a></li>
<li><a href='#decisionCurve'><p>Decision curve plot</p></a></li>
<li><a href='#densCurves'><p>Density curves plot</p></a></li>
<li><a href='#diagOptThresh-class'><p>An S4 class to describe the optimal threshold of a diagnostic marker.</p></a></li>
<li><a href='#diagRelUtility-class'><p>An S4 class to sum up the results from the decisionCurve methods.</p></a></li>
<li><a href='#diagThresh'><p>Estimation of the optimal threshold of a diagnostic marker</p></a></li>
<li><a href='#estimates'><p>Indicator estimates</p></a></li>
<li><a href='#fit'><p>Specify which distribution to fit on the marker values</p></a></li>
<li><a href='#fitGammaDist-class'><p>An S4 class to fit a gamma distribution on a vector of marker values.</p></a></li>
<li><a href='#fitLogisticDist-class'><p>An S4 class to fit a logistic distribution on a vector of marker values.</p></a></li>
<li><a href='#fitLogNormalDist-class'><p>An S4 class to fit a log-normal distribution on a vector of marker values.</p></a></li>
<li><a href='#fitNormalDist-class'><p>An S4 class to fit a normal distribution on a vector of marker values.</p></a></li>
<li><a href='#fitStudentDist-class'><p>An S4 class to fit a Student distribution on a vector of marker values.</p></a></li>
<li><a href='#fitUserDefinedDist-class'><p>An S4 class to fit a user-defined distribution on a vector of marker values.</p></a></li>
<li><a href='#gammaDist-class'><p>An S4 class to represent a gamma distribution.</p></a></li>
<li><a href='#gradient'><p>Probability density function of a specified distribution</p></a></li>
<li><a href='#hessian'><p>Second derivative of the cumulative distribution function of a specified distribution</p></a></li>
<li><a href='#logisticDist-class'><p>An S4 class to represent a logistic distribution.</p></a></li>
<li><a href='#logNormalDist-class'><p>An S4 class to represent a log-normal distribution.</p></a></li>
<li><a href='#mcmc.listOrNull-class'><p>An S4 union class to merge mcmc.list and NULL types of object.</p></a></li>
<li><a href='#normalDist-class'><p>An S4 class to represent a normal distribution.</p></a></li>
<li><a href='#plot-methods'><p>Plot method</p></a></li>
<li><a href='#plot.diagRelUtility'><p>Plot the decision curves of a diagnostic marker</p></a></li>
<li><a href='#plot.trtSelRelUtility'><p>Plot the decision curves of a treatment selection marker</p></a></li>
<li><a href='#riskCurves'><p>Marker-by-treatment predictiveness curves plot</p></a></li>
<li><a href='#samplePosteriorDist'><p>Sample in the posterior distribution of the parameters of a given theoretical distribution.</p></a></li>
<li><a href='#show-methods'><p>Show method</p></a></li>
<li><a href='#studentDist-class'><p>An S4 class to represent a scaled Student distribution.</p></a></li>
<li><a href='#summary-methods'><p>An S4 method that summarizes the results of a <code>trtSelOpthThresh</code> or a <code>diagOpthThresh</code> object.</p></a></li>
<li><a href='#trtSelOptThresh-class'><p>An S4 class to describe the optimal threshold of a treatment selection marker.</p></a></li>
<li><a href='#trtSelRelUtility-class'><p>An S4 class to the results from the decisionCurve methods.</p></a></li>
<li><a href='#trtSelThresh'><p>Estimation of the optimal threshold of a treatment selection marker</p></a></li>
<li><a href='#undefined-class'><p>An S4 class to represent an 'undefined' distribution.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Methods for Optimal Threshold Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>JAGS 4.x.y</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-01-09</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to estimate the optimal threshold of diagnostic markers or treatment selection markers. The optimal threshold is the marker value that maximizes the utility of the marker based-strategy (for diagnostic or treatment selection) in a given population. The utility function depends on the type of marker (diagnostic or treatment selection), but always takes into account the preferences of the patients or the physician in the decision process. For estimating the optimal threshold, ones must specify the distributions of the marker in different groups (defined according to the type of marker, diagnostic or treatment selection) and provides data to estimate the parameters of these distributions. Ones must also provide some features of the target populations (disease prevalence or treatment efficacies) as well as the preferences of patients or physicians. The functions rely on Bayesian inference which helps producing several indicators derived from the optimal threshold. See Blangero, Y, Rabilloud, M, Ecochard, R, and Subtil, F (2019) &lt;<a href="https://doi.org/10.1177%2F0962280218821394">doi:10.1177/0962280218821394</a>&gt; for the original article that describes the estimation method for treatment selection markers and Subtil, F, and Rabilloud, M (2019) &lt;<a href="https://doi.org/10.1002%2Fbimj.200900242">doi:10.1002/bimj.200900242</a>&gt; for diagnostic markers.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>Collate:</td>
<td>Package.R import_package.R scaledT.R ClassUnions.R
ClassFitNormalDist.R ClassFitLogNormalDist.R
ClassFitGammaDist.R ClassFitStudentDist.R
ClassFitLogisticDist.R ClassFitUserDefinedDist.R
ClassUndefined.R ClassNormalDist.R ClassLogNormalDist.R
ClassGammaDist.R ClassStudentDist.R ClassLogisticDist.R
ClassUnionsDist.R ClassCompoundDist.R ClassTrtSelOptThresh.R
ClassTrtSelRelUtility.R ClassDiagOptThresh.R
ClassDiagRelUtility.R cdf.R gradient.R hessian.R ARS.R
samplePosteriorDist.R global.R</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>ars, rjags, HDInterval, mgcv, utils, coda, grDevices, methods,
stats, graphics</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-09 21:51:17 UTC; yblan</td>
</tr>
<tr>
<td>Author:</td>
<td>Yoann Blangero [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yoann Blangero &lt;yblangero@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-13 16:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='optimalThreshold-package'>optimalThreshold: Bayesian Methods for Optimal Threshold Estimation</h2><span id='topic+optimalThreshold'></span><span id='topic+optimalThreshold-package'></span>

<h3>Description</h3>

<p><code>optimalThreshold</code> provides functions to estimate the optimal threshold of diagnostic markers or treatment selection markers. The optimal threshold is the marker value that maximizes the utility of the marker based-strategy (for diagnostic or treatment selection) in a given population. The utility function depends on the type of marker (diagnostic or treatment selection), but always takes into account the preferences of the patients or the physician in the decision process. For estimating the optimal threshold, ones must specify the distributions of the marker in different groups (defined according to the type of marker, diagnostic or treatment selection) and provides data to estimate the parameters of these distributions. Ones must also provide some features of the target populations (disease prevalence or treatment efficacies) as well as the preferences of patients or physicians. The functions rely on Bayesian inference which helps producing several indicators derived from the optimal threshold. 
Whatever the type of marker (diagnostic or treatment selection), <code>optimalThreshold</code> also provides decision curves to help defining the range of patients preferences for which the marker-based strategy is useful.
</p>


<h3>Details</h3>

<p>Package: optimalThreshold
</p>
<p>Type:    Package
</p>
<p>Version: 1.0
</p>
<p>Date:    2019-07-19
</p>
<p>License: GPL (&gt;=2.0)
</p>


<h3>References</h3>

<p>Blangero, Y, Rabilloud, M, Ecochard, R, and Subtil, F. A Bayesian method to estimate the optimal threshold of a marker used to select patients' treatment. <em>Statistical Methods in Medical Research</em>. 2019.
Subtil, F, and Rabilloud, M. A Bayesian method to estimate the optimal threshold of a longitudinal marker. <em>Biometrical Journal</em>. 2010.
</p>


<h3>Author(s)</h3>

<p>Yoann Blangero (yblangero@gmail.com)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for fitting a distribution on marker values, <code><a href="#topic+trtSelThresh">trtSelThresh</a></code> for estimating the optimal threshold of a treatment selection marker, <code><a href="#topic+diagThresh">diagThresh</a></code> for estimating the optimal threshold of a diagnostic marker, <code><a href="#topic+densCurves">densCurves</a></code> for plotting density curves, <code><a href="#topic+riskCurves">riskCurves</a></code> for plotting marker-by-treatment predictiveness curves, and <code><a href="#topic+decisionCurve">decisionCurve</a></code> for plotting decision curves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See individual function man pages for examples.
?fit
?trtSelThresh
?diagThresh
?densCurves
?riskCurves
?decisionCurve
</code></pre>

<hr>
<h2 id='allowedDist-class'>An S4 union class to represent allowed dist object.</h2><span id='topic+allowedDist-class'></span><span id='topic+allowedDist'></span>

<h3>Description</h3>

<p>This S4 union class describes what types of distribution are supported by the <code>optimalThreshold</code> package.
</p>


<h3>Details</h3>

<p>Five theoretical univariate and continuous distributions are supported by the package internally (normal, log-normal, gamma, scaled t, and logistic). However, it is possible for the user to define its own distribution type using the <code>fit</code> function, and passing the result to one of the two main functions: <code>trtSelThresh</code>, and <code>diagThresh</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code>, <code><a href="#topic+trtSelThresh">trtSelThresh</a></code>, and <code><a href="#topic+diagThresh">diagThresh</a></code>.
</p>

<hr>
<h2 id='allowedFitDist-class'>An S4 union class to represent allowed fitDist objects.</h2><span id='topic+allowedFitDist-class'></span><span id='topic+allowedFitDist'></span>

<h3>Description</h3>

<p>This S4 union class describes what types of distribution may be fitted by the user in the <code>optimalThreshold</code> package.
</p>


<h3>Details</h3>

<p>Five theoretical types of distribution fit are supported by the package internally (normal, log-normal, gamma, scaled t, and logistic). However, it is possible for the user to fit a personalized distribution using the <code>fit</code> function, and passing the result to one of the two main functions: <code>trtSelThresh</code>, and <code>diagThresh</code>. The 'undefined' type is used to indicate which distribution must be expressed as a function of the three others when estimating the optimal threshold of a treatment selection marker (see References for more details).
</p>


<h3>References </h3>

<p>Blangero, Y, Rabilloud, M, Ecochard, R, and Subtil, F. A Bayesian method to estimate the optimal threshold of a marker used to select patients' treatment. <em>Statistical Methods in Medical Research</em>. 2019.
Subtil, F, and Rabilloud, M. A Bayesian method to estimate the optimal threshold of a longitudinal marker. <em>Biometrical Journal</em>. 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code>, <code><a href="#topic+trtSelThresh">trtSelThresh</a></code>, and <code><a href="#topic+diagThresh">diagThresh</a></code>.
</p>

<hr>
<h2 id='cdf'>Cumulative distribution function of a specified distribution</h2><span id='topic+cdf'></span><span id='topic+cdf+2CnormalDist-method'></span><span id='topic+cdf.normalDist'></span><span id='topic+cdf+2ClogNormalDist-method'></span><span id='topic+cdf.logNormalDist'></span><span id='topic+cdf+2CgammaDist-method'></span><span id='topic+cdf.gammaDist'></span><span id='topic+cdf+2CstudentDist-method'></span><span id='topic+cdf.studentDist'></span><span id='topic+cdf+2ClogisticDist-method'></span><span id='topic+cdf.logisticDist'></span><span id='topic+cdf+2CcompoundEvtRefDist-method'></span><span id='topic+cdf.compoundEvtRefDist'></span><span id='topic+cdf+2CcompoundNoEvtRefDist-method'></span><span id='topic+cdf.compoundNoEvtRefDist'></span><span id='topic+cdf+2CcompoundEvtInnovDist-method'></span><span id='topic+cdf.compoundEvtInnovDist'></span><span id='topic+cdf+2CcompoundNoEvtInnovDist-method'></span><span id='topic+cdf.compoundNoEvtInnovDist'></span>

<h3>Description</h3>

<p>The <code>cdf</code> function returns the cumulative distribution function relative to the S4 object passed in its argument. See details to know on what kind of S4 objects this function could be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf(object)

## S4 method for signature 'normalDist'
cdf(object)

## S4 method for signature 'logNormalDist'
cdf(object)

## S4 method for signature 'gammaDist'
cdf(object)

## S4 method for signature 'studentDist'
cdf(object)

## S4 method for signature 'logisticDist'
cdf(object)

## S4 method for signature 'compoundEvtRefDist'
cdf(object)

## S4 method for signature 'compoundNoEvtRefDist'
cdf(object)

## S4 method for signature 'compoundEvtInnovDist'
cdf(object)

## S4 method for signature 'compoundNoEvtInnovDist'
cdf(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf_+3A_object">object</code></td>
<td>
<p>Any S4 object for which a <code>cdf</code> method is defined. Should match with the definition of an S4 distribution object as defined in the <code>optimalThreshold</code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method can be applied to the S4 distribution objects that are supported in the <code>optimalThreshold</code> package: <code>normalDist</code>, <code>logNormalDist</code>, <code>gammaDist</code>, <code>studentDist</code>, <code>logisticDist</code>, and <code>userDefinedDist</code>. These methods are applied internally, and you have no need to use it outside of the main functions <code>trtSelThresh</code> and <code>diagThresh</code>. 
</p>

<ul>
<li><p> Normal distribution: the <code>cdf</code> method applied to a <code>normalDist</code> object is simply the <code>pnorm</code> function (see help on this function to have more details).
</p>
</li>
<li><p> Log-normal distribution: the <code>cdf</code> method applied to a <code>logNormalDist</code> object is simply the <code>plnorm</code> function (see help on this function to have more details).
</p>
</li>
<li><p> Gamma distribution: the <code>cdf</code> method applied to a <code>gammaDist</code> object is simply the <code>pgamma</code> function (see help on this function to have more details).
</p>
</li>
<li><p> Scaled t distribution: the scaled t distribution with <code>df</code> = n, <code>mu</code> = <code class="reqn">\mu</code>, and <code>sd</code> = <code class="reqn">\sigma</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x)=(\Gamma((n+1)/2)/(\sqrt{n\pi}\Gamma(n/2))(1+((x-\mu)/\sigma)^2/n)^-((n+1)/2))/\sigma</code>
</p>

</li>
<li><p> Logistic distribution: the <code>cdf</code> method applied to a <code>logisticDist</code> object is simply the <code>plogis</code> function (see help on this function to have more details).
</p>
</li>
<li><p> User-defined distribution: the <code>cdf</code> method applied to a <code>userDefinedDist</code> object is simply the cumulative distribution function provided by the user when fitting a user-defined distribution with the <code>fit</code> function.
</p>
</li></ul>

<p>The S4 objects <code>compoundEvtRefDist</code>, <code>compoundNoEvtRefDist</code>, <code>compoundEvtInnovDist</code>, and <code>compoundNoEvtInnovDist</code> are created internally. The <code>cdf</code> function applied to these objects is defined dynamically depending on what types of distribution are fitted. The definition of the <code>cdf</code> function relies on the expression of the randomization constraint of a clinical trial that enforces the distribution of the marker in each treatment arm to be identical (see References for more details).
</p>


<h3>Value</h3>

<p>Returns the cumulative distribution function of the specified distribution.
</p>


<h3>References</h3>

<p>Blangero, Y, Rabilloud, M, Ecochard, R, and Subtil, F. A Bayesian method to estimate the optimal threshold of a marker used to select patients' treatment. <em>Statistical Methods in Medical Research</em>. 2019.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trtSelThresh">trtSelThresh</a></code>, <code><a href="#topic+diagThresh">diagThresh</a></code>, <code><a href="stats.html#topic+pnorm">pnorm</a></code>, <code><a href="stats.html#topic+plnorm">plnorm</a></code>, <code><a href="stats.html#topic+pgamma">pgamma</a></code>, <code><a href="stats.html#topic+plogis">plogis</a></code>, <code><a href="#topic+fit">fit</a></code>.
</p>

<hr>
<h2 id='compoundEvtInnovDist-class'>An S4 class to represent a compound distribution.</h2><span id='topic+compoundEvtInnovDist-class'></span><span id='topic+compoundEvtInnovDist'></span>

<h3>Description</h3>

<p>This S4 class describes the 'compound' distribution that is fitted to the marker values of patients that developed the event of interest in the innovative treatment arm when the type of distribution is set to 'undefined' in the <code>fit</code> function.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when an undefined distribution is fitted on the marker values.
</p>


<h3>Slots</h3>


<dl>
<dt><code>EvtRefDist</code></dt><dd><p>This slot is an object that describes the distribution of the marker for patients that developed the event in the reference arm. This object must be an &quot;allowedDist&quot; class object.</p>
</dd>
<dt><code>NoEvtRefDist</code></dt><dd><p>This slot is an object that describes the distribution of the marker for patients that did not develop the event in the reference arm. This object must be an &quot;allowedDist&quot; class object.</p>
</dd>
<dt><code>NoEvtInnovDist</code></dt><dd><p>This slot is an object that describes the distribution of the marker for patients that did not develop the event in the innovative arm. This object must be an &quot;allowedDist&quot; class object.</p>
</dd>
<dt><code>r0</code></dt><dd><p>Mean risk of event occurrence in the reference arm. Numeric argument.</p>
</dd>
<dt><code>r1</code></dt><dd><p>Mean risk of event occurrence in the innovative arm. Numeric argument.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit an undefined distribution.
</p>

<hr>
<h2 id='compoundEvtRefDist-class'>An S4 class to represent a compound distribution.</h2><span id='topic+compoundEvtRefDist-class'></span><span id='topic+compoundEvtRefDist'></span>

<h3>Description</h3>

<p>This S4 class describes the 'compound' distribution that is fitted to the marker values of patients that developed the event of interest in the reference treatment arm when the type of distribution is set to 'undefined' in the <code>fit</code> function.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when an undefined distribution is fitted on the marker values.
</p>


<h3>Slots</h3>


<dl>
<dt><code>NoEvtRefDist</code></dt><dd><p>This slot is an object that describes the distribution of the marker for patients that did not develop the event in the reference arm. This object must be an &quot;allowedDist&quot; class object.</p>
</dd>
<dt><code>EvtInnovDist</code></dt><dd><p>This slot is an object that describes the distribution of the marker for patients that developed the event in the innovative arm. This object must be an &quot;allowedDist&quot; class object.</p>
</dd>
<dt><code>NoEvtInnovDist</code></dt><dd><p>This slot is an object that describes the distribution of the marker for patients that did not develop the event in the innovative arm. This object must be an &quot;allowedDist&quot; class object.</p>
</dd>
<dt><code>r0</code></dt><dd><p>Mean risk of event occurrence in the reference arm. Numeric argument.</p>
</dd>
<dt><code>r1</code></dt><dd><p>Mean risk of event occurrence in the innovative arm. Numeric argument.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit an undefined distribution.
</p>

<hr>
<h2 id='compoundNoEvtInnovDist-class'>An S4 class to represent a compound distribution.</h2><span id='topic+compoundNoEvtInnovDist-class'></span><span id='topic+compoundNoEvtInnovDist'></span>

<h3>Description</h3>

<p>This S4 class describes the 'compound' distribution that is fitted to the marker values of patients that did not develop the event of interest in the innovative treatment arm when the type of distribution is set to 'undefined' in the <code>fit</code> function.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when an undefined distribution is fitted on the marker values.
</p>


<h3>Slots</h3>


<dl>
<dt><code>EvtRefDist</code></dt><dd><p>This slot is an object that describes the distribution of the marker for patients that developed the event in the reference arm. This object must be an &quot;allowedDist&quot; class object.</p>
</dd>
<dt><code>NoEvtRefDist</code></dt><dd><p>This slot is an object that describes the distribution of the marker for patients that did not develop the event in the reference arm. This object must be an &quot;allowedDist&quot; class object.</p>
</dd>
<dt><code>EvtInnovDist</code></dt><dd><p>This slot is an object that describes the distribution of the marker for patients that developed the event in the innovative arm. This object must be an &quot;allowedDist&quot; class object.</p>
</dd>
<dt><code>r0</code></dt><dd><p>Mean risk of event occurrence in the reference arm. Numeric argument.</p>
</dd>
<dt><code>r1</code></dt><dd><p>Mean risk of event occurrence in the innovative arm. Numeric argument.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit an undefined distribution.
</p>

<hr>
<h2 id='compoundNoEvtRefDist-class'>An S4 class to represent a compound distribution.</h2><span id='topic+compoundNoEvtRefDist-class'></span><span id='topic+compoundNoEvtRefDist'></span>

<h3>Description</h3>

<p>This S4 class describes the 'compound' distribution that is fitted to the marker values of patients that did not develop the event of interest in the reference treatment arm when the type of distribution is set to 'undefined' in the <code>fit</code> function.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when an undefined distribution is fitted on the marker values.
</p>


<h3>Slots</h3>


<dl>
<dt><code>EvtRefDist</code></dt><dd><p>This slot is an object that describes the distribution of the marker for patients that developed the event in the reference arm. This object must be an &quot;allowedDist&quot; class object.</p>
</dd>
<dt><code>EvtInnovDist</code></dt><dd><p>This slot is an object that describes the distribution of the marker for patients that developed the event in the innovative arm. This object must be an &quot;allowedDist&quot; class object.</p>
</dd>
<dt><code>NoEvtInnovDist</code></dt><dd><p>This slot is an object that describes the distribution of the marker for patients that did not develop the event in the innovative arm. This object must be an &quot;allowedDist&quot; class object.</p>
</dd>
<dt><code>r0</code></dt><dd><p>Mean risk of event occurrence in the reference arm. Numeric argument.</p>
</dd>
<dt><code>r1</code></dt><dd><p>Mean risk of event occurrence in the innovative arm. Numeric argument.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit an undefined distribution.
</p>

<hr>
<h2 id='credibleIntervals'>Credible intervals estimation</h2><span id='topic+credibleIntervals'></span><span id='topic+credibleIntervals+2CtrtSelOptThresh-method'></span><span id='topic+credibleIntervals.trtSelOptThresh'></span><span id='topic+credibleIntervals+2CdiagOptThresh-method'></span><span id='topic+credibleIntervals.diagOptThresh'></span>

<h3>Description</h3>

<p>Credible intervals estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credibleIntervals(object, ...)

## S4 method for signature 'trtSelOptThresh'
credibleIntervals(object, alpha = 0.05,
  hpd = FALSE)

## S4 method for signature 'diagOptThresh'
credibleIntervals(object, alpha = 0.05,
  hpd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="credibleIntervals_+3A_object">object</code></td>
<td>
<p>a <code>trtSelOptThresh</code> or a <code>diagOptThresh</code> S4 class object from which the credible intervals of several indicators (including the optimal threshold) must be calculated.</p>
</td></tr>
<tr><td><code id="credibleIntervals_+3A_...">...</code></td>
<td>
<p>other arguments passed to the method.</p>
</td></tr>
<tr><td><code id="credibleIntervals_+3A_alpha">alpha</code></td>
<td>
<p>alpha parameter for the confidence level required.</p>
</td></tr>
<tr><td><code id="credibleIntervals_+3A_hpd">hpd</code></td>
<td>
<p>logical value to specify whether the function has to return Highest Posterior Density interval or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the credible intervals of several indicators depending on the type of marker under study (treatment selection or diagnostic marker). The user may specify the alpha risk for the confidence level (default is 5
</p>


<h3>Value</h3>

<p>Returns a matrix with the credible intervals of several indicators.
</p>
<p>Returns the credible intervals of several indicators.
</p>


<h3>References</h3>

<p>Gelman, A, et al. 2014. <em>Bayesian Data Analysis</em>. 3rd edition, CRC Press, Boca Raton, section 2.3.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trtSelThresh">trtSelThresh</a></code>, <code><a href="#topic+diagThresh">diagThresh</a></code>, and <code><a href="HDInterval.html#topic+hdi">hdi</a></code>.
</p>

<hr>
<h2 id='decisionCurve'>Decision curve plot</h2><span id='topic+decisionCurve'></span><span id='topic+decisionCurve+2CtrtSelOptThresh-method'></span><span id='topic+decisionCurve.trtSelOptThresh'></span><span id='topic+decisionCurve+2CdiagOptThresh-method'></span><span id='topic+decisionCurve.diagOptThresh'></span>

<h3>Description</h3>

<p>This S4 method allows to plot the decision curve associated with a treatment selection marker for several treatment/event cost ratios, or with a diagnostic marker for several risk thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decisionCurve(object, r, ...)

## S4 method for signature 'trtSelOptThresh'
decisionCurve(object, r, alpha = 0.05)

## S4 method for signature 'diagOptThresh'
decisionCurve(object, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decisionCurve_+3A_object">object</code></td>
<td>
<p>a <code>trtSelOptThresh</code> or a <code>diagOptThresh</code> S4 class object from which the decision curve must be plotted.</p>
</td></tr>
<tr><td><code id="decisionCurve_+3A_r">r</code></td>
<td>
<p>Ratio of treatment/event costs (for treatment selection markers), or risk preference (for diagnostic marker). Numeric argument.</p>
</td></tr>
<tr><td><code id="decisionCurve_+3A_...">...</code></td>
<td>
<p>other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="decisionCurve_+3A_alpha">alpha</code></td>
<td>
<p>alpha parameter for the confidence level required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the decision curves according to the type of marker under study (treatment selection or diagnostic) and the <code>r</code> argument. For treatment selection markers, it plots two graphs: the first one is a classical decision curves graph comparing the utilities of: the marker under study, the perfect marker, the strategy 'Treat everyone with the reference treatment', and the strategy 'Treat everyone with the innovative treatment'; the second one is the relative decision curve that plots the relative utility of the marker under study (0 meaning that using the marker to guide treatment decisions is not better than treating everyone with the overall best treatment, and 1 meaning that the marker under study has the same utility as the perfect marker). The decision curves are calculated using the mean risk of event in each treatment arm provided in the <code>trtSelOptThresh</code> object.
For diagnostic markers it calculates the expected benefit of the marker and compares it with the strategies &quot;Treat everyone&quot; and &quot;Do not treat anyone&quot;. The decision curve is calculated for a population with a disease prevalence provided in the <code>diagOptThresh</code> object.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>trtSelRelUtility</code> if applied to a <code>trtSelOptThresh</code> object, and an object of class <code>diagRelUtility</code> if applied to a <code>diagOptThresh</code> object.
</p>


<h3>References</h3>

<p>Blangero, Y, Rabilloud, M, Ecochard, R, and Subtil, F. A Bayesian method to estimate the optimal threshold of a marker used to select patients' treatment. <em>Statistical Methods in Medical Research</em>. 2019.
Huang, Y, Laber, EB, and Janes H. Characterizing expected benefits of biomarkers in treatment selection. <em>Biostatistics</em>. 2015; 16(2): 383-399.
Vickers, AJ, and Elkin, EB. Decision curve analysis: a novel method for evaluating prediction models. <em>Medical Decision Making</em>. 2006; 26(6): 565-574.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trtSelThresh">trtSelThresh</a></code> and <code><a href="#topic+diagThresh">diagThresh</a></code> for some examples on how to use this function.
</p>

<hr>
<h2 id='densCurves'>Density curves plot</h2><span id='topic+densCurves'></span>

<h3>Description</h3>

<p>This function plots the density curves of the marker values in each treatment arm (treatment selection marker), or for diseased and non-diseased patients (diagnostic marker).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densCurves(x0, x1, type, ylab = "Density", xlab = "Marker values",
  main = "Density curves", col0 = "blue", col1 = "green", lty0 = 1,
  lty1 = 1, pos.legend = "topright", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densCurves_+3A_x0">x0</code></td>
<td>
<p>a numeric vector containing the marker values of patients in the reference arm (treatment selection marker), or non-diseased patients (diagnostic marker).</p>
</td></tr>
<tr><td><code id="densCurves_+3A_x1">x1</code></td>
<td>
<p>a numeric vector containing the marker values of patients in the innovative arm (treatment selection marker), or diseased patients (diagnostic marker).</p>
</td></tr>
<tr><td><code id="densCurves_+3A_type">type</code></td>
<td>
<p>a character argument that specifies the type of the marker (&quot;treatment selection&quot; for treatment selection marker or &quot;diagnostic&quot; for diagnostic marker).</p>
</td></tr>
<tr><td><code id="densCurves_+3A_ylab">ylab</code></td>
<td>
<p>label of the Y-axis.</p>
</td></tr>
<tr><td><code id="densCurves_+3A_xlab">xlab</code></td>
<td>
<p>label of the X-axis.</p>
</td></tr>
<tr><td><code id="densCurves_+3A_main">main</code></td>
<td>
<p>title of the graph.</p>
</td></tr>
<tr><td><code id="densCurves_+3A_col0">col0</code></td>
<td>
<p>color of the density curve in the reference arm (treatment selection marker), or for non-diseased patients (diagnostic marker).</p>
</td></tr>
<tr><td><code id="densCurves_+3A_col1">col1</code></td>
<td>
<p>color of the density curve in the innovative arm (treatment selection marker), or for diseased patients (diagnostic marker).</p>
</td></tr>
<tr><td><code id="densCurves_+3A_lty0">lty0</code></td>
<td>
<p>type of the line for the density curve in the reference arm (treatment selection marker), or for non-diseased patients (diagnostic marker).</p>
</td></tr>
<tr><td><code id="densCurves_+3A_lty1">lty1</code></td>
<td>
<p>type of the line for the density curve in the innovative arm (treatment selection marker), or for diseased patients (diagnostic marker).</p>
</td></tr>
<tr><td><code id="densCurves_+3A_pos.legend">pos.legend</code></td>
<td>
<p>the x and y co-ordinates to be used to position the legend. They can be specified by keyword or in any way which is accepted by xy.coords.</p>
</td></tr>
<tr><td><code id="densCurves_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When assessing treatment selection markers and estimating their optimal threshold, it is necessary that the randomization constraint be respected. If the density curves of the marker are different when comparing the two treatment arms, then it is likely that the <code>trtSelThresh</code> function will provide a threshold that do not correspond to the true optimal threshold. 
When assessing diagnostic markers, it is necessary to define the decision rule (classically high values of the marker are associated with a worst outcome). This decision rule may be checked with the density curves of the marker for diseased and non-diseased patients.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Plotting density curves for a treatment selection marker
# Data generation
x0E &lt;- rnorm(100, 2, 1)
x0Eb &lt;- rnorm(200, 4, 1)
x1E &lt;- rnorm(100, 4, 1)
x1Eb &lt;- rnorm(200, 2, 1)
densCurves(x0 = c(x0E, x0Eb), x1 = c(x1E, x1Eb), type = "treatment selection")

### Plotting density curves for a diagnostic marker
# Data generation
xE &lt;- rnorm(30, 3, 1)
xEb &lt;- rnorm(90, 1, 1)
densCurves(x0 = xEb, x1 = xE, type = "diagnostic")
</code></pre>

<hr>
<h2 id='diagOptThresh-class'>An S4 class to describe the optimal threshold of a diagnostic marker.</h2><span id='topic+diagOptThresh-class'></span><span id='topic+diagOptThresh'></span>

<h3>Description</h3>

<p>An S4 class to describe the optimal threshold of a diagnostic marker.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when the <code>diagThresh</code> function is used.
</p>


<h3>Slots</h3>


<dl>
<dt><code>optThresh</code></dt><dd><p>This slot is an object that takes in argument the sampled optimal threshold values. Numeric argument.</p>
</dd>
<dt><code>p</code></dt><dd><p>Prevalence specified by the user. Numeric argument.</p>
</dd>
<dt><code>r</code></dt><dd><p>Risk threshold preference. Numeric argument.</p>
</dd>
<dt><code>N</code></dt><dd><p>Sample size.</p>
</dd>
<dt><code>xEvt</code></dt><dd><p>This slot is an object that takes in argument the marker values in the subgroup of patients that developed the event. Numeric argument.</p>
</dd>
<dt><code>xNoEvt</code></dt><dd><p>This slot is an object that takes in argument the marker values in the subgroup of patients that did not develop the event. Numeric argument.</p>
</dd>
<dt><code>lowEvt</code></dt><dd><p>This slot is a logical argument that specifies whether the low values of the marker are associated with the presence of the disease or not.</p>
</dd>
<dt><code>mcmcChainEvt</code></dt><dd><p>This slot is an object that takes in argument the sampled distribution objects in the subgroup of patients that developed the event. list argument.</p>
</dd>
<dt><code>mcmcChainNoEvt</code></dt><dd><p>This slot is an object that takes in argument the sampled distribution objects in the subgroup of patients that did not develop the event. list argument.</p>
</dd>
<dt><code>tabMCMCChain</code></dt><dd><p>This slot is an object that takes in argument all the distribution parameters that were sampled using the MCMC algorithm. mcmc.listOrNull argument.</p>
</dd>
<dt><code>paraNamesUserDefined</code></dt><dd><p>This slot is an object that takes in argument the list of the distribution parameter names defined by the user in a 'fitUserDefinedDist' object. list argument.</p>
</dd>
<dt><code>cdfUserDefined</code></dt><dd><p>This slot is an object that takes in argument the list of cumulative distribution functions defined by the user in 'fitUserDefinedDist' objects. list argument.</p>
</dd>
<dt><code>gradientUserDefined</code></dt><dd><p>This slot is an object that takes in argument the list of gradient functions defined by the user in 'fitUserDefinedDist' objects. list argument.</p>
</dd>
<dt><code>hessianUserDefined</code></dt><dd><p>This slot is an object that takes in argument the list of hessian functions defined by the user in 'fitUserDefinedDist' objects. list argument.</p>
</dd>
<dt><code>percentNA</code></dt><dd><p>This slot is a numeric object that indicates the percentage of NA values contained in the 'optThresh' slot.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+diagThresh">diagThresh</a></code> for more details on how to estimate the optimal threshold of a diagnostic marker.
</p>

<hr>
<h2 id='diagRelUtility-class'>An S4 class to sum up the results from the decisionCurve methods.</h2><span id='topic+diagRelUtility-class'></span><span id='topic+diagRelUtility'></span>

<h3>Description</h3>

<p>An S4 class to sum up the results from the decisionCurve methods.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when the <code>decisionCurve</code> method is applied to a 'diagOptThresh' object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>U</code></dt><dd><p>This slot is a matrix of the marker-based utility according to <code>r</code>.</p>
</dd>
<dt><code>UNoTreat</code></dt><dd><p>This slot is a matrix of the utility of the 'No Treat' strategy according to <code>r</code>.</p>
</dd>
<dt><code>UTreatAll</code></dt><dd><p>This slot is a matrix of the utility of the 'Treat All' strategy according to <code>r</code>.</p>
</dd>
<dt><code>r</code></dt><dd><p>Risk threshold preference. Numeric argument.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+decisionCurve">decisionCurve</a></code> for more details on how to plot the decision curves.
</p>

<hr>
<h2 id='diagThresh'>Estimation of the optimal threshold of a diagnostic marker</h2><span id='topic+diagThresh'></span>

<h3>Description</h3>

<p>This function produces a sample of the posterior distribution of the optimal threshold of a diagnostic marker. The optimal threshold is defined as the marker value that maximized the utility of using the marker to make the diagnosis and treat the patient (treat or not the patient). The utility function takes into account the proportions of patients well classified and miss-classified (through the sensitivity and specificity), the prevalence of the disease in the target population, and the cost and benefits of treating wrongly or rightly the subject.
To calculate the utility function, the user needs to specify:
</p>

<ul>
<li><p> the distribution of the marker in the subject with and without the disease (see the <code><a href="#topic+fit">fit</a></code> function)
</p>
</li>
<li><p> the prevalence of the disease in the target population
</p>
</li>
<li><p> the cost of treating subject without the disease and the benefit of treating a patient with the disease (see Details). 
</p>
</li></ul>

<p>The optimal threshold and its credible interval are calculated using a Monte Carlo approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagThresh(EvtDist = NULL, NoEvtDist = NULL, p, r, lowEvt = FALSE,
  le.MCMC = 1000, hessTol = 10^(-6), plot = FALSE,
  progress.bar = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagThresh_+3A_evtdist">EvtDist</code></td>
<td>
<p>an object of class allowedFitDist that summarizes the distribution fitted to the marker values of patients with the disease of interest. This class of objects is obtained using the <code><a href="#topic+fit">fit</a></code> function.</p>
</td></tr>
<tr><td><code id="diagThresh_+3A_noevtdist">NoEvtDist</code></td>
<td>
<p>an object of class allowedFitDist that summarizes the distribution fitted to the marker values of patients without the disease of interest. This class of objects is obtained using the <code><a href="#topic+fit">fit</a></code> function.</p>
</td></tr>
<tr><td><code id="diagThresh_+3A_p">p</code></td>
<td>
<p>the prevalence of the disease in the target population.</p>
</td></tr>
<tr><td><code id="diagThresh_+3A_r">r</code></td>
<td>
<p>the risk threshold preference (see Details).</p>
</td></tr>
<tr><td><code id="diagThresh_+3A_lowevt">lowEvt</code></td>
<td>
<p>logical argument that specifies whether low values of the marker are associated with the presence of the disease or not.</p>
</td></tr>
<tr><td><code id="diagThresh_+3A_le.mcmc">le.MCMC</code></td>
<td>
<p>length of the desired MCMC chain.</p>
</td></tr>
<tr><td><code id="diagThresh_+3A_hesstol">hessTol</code></td>
<td>
<p>a numeric value used in the optimization algorithm to control the tolerance threshold of the hessian value at the optimal threshold estimate.</p>
</td></tr>
<tr><td><code id="diagThresh_+3A_plot">plot</code></td>
<td>
<p>a logical value indicating whether routine graphics must be produced.</p>
</td></tr>
<tr><td><code id="diagThresh_+3A_progress.bar">progress.bar</code></td>
<td>
<p>a character string indicating whether the user wishes to print a progress bar during the function process.</p>
</td></tr>
<tr><td><code id="diagThresh_+3A_seed">seed</code></td>
<td>
<p>a numerical value used to fix the random seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The r value can be defined as the probability of disease above which a patient or a physician would accept the treatment. The value (1-r)/r can be interpreted as the NB/NC ratio, i.e. the number of subjects without the disease a physician would accept to treat wrongly to be able to detect and treat one diseased patient.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>diagOptThresh</code>.
</p>


<h3>References </h3>

<p>Subtil, F, and Rabilloud. A Bayesian method to estimate the optimal threshold of a longitudinal marker. <em>Biometrical Journal</em>. 2010; 52(3): 333-347.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulating data from two gaussian distributions:
xE &lt;- rnorm(100) # distribution of the marker in diseased patients
xEb &lt;- rnorm(400, 2) # distribution of the marker in the subjects without the disease

#When working with real data. You can check the decision rule (whether low or high 
#value of the marker are associated with the disease) using the densCurves function:
densCurves(x0 = xEb, x1 = xE, type = "diagnostic")

#Fit normal distributions on the two groups:
fitE &lt;- fit(xE, "norm")
fitEb &lt;- fit(xEb, "norm")

#Apply the main function to estimate the optimal threshold:

res &lt;- diagThresh(fitE, fitEb, p = 0.2, r = 0.3, lowEvt = TRUE, le.MCMC = 5000, 
                  plot = TRUE, progress.bar = "text")

#You can summarize the results using the summary() function:
summary(res,method = "median")

#You can extract the estimates and CI bounds of each indicator presented in the summary:
estimates(res, method = "median")
credibleIntervals(res)

#Plot the decision curves (this function is time-consuming):
dCres &lt;- decisionCurve(res, r = seq(0, 0.5, length.out = 10))

#You can plot again the decision curves by applying the plot method to dCres, 
#this function is a lot faster than the previous one. It also has more options
#to customize the plot:
plot(dCres)

</code></pre>

<hr>
<h2 id='estimates'>Indicator estimates</h2><span id='topic+estimates'></span><span id='topic+estimates+2CtrtSelOptThresh-method'></span><span id='topic+estimates.trtSelOptThresh'></span><span id='topic+estimates+2CdiagOptThresh-method'></span><span id='topic+estimates.diagOptThresh'></span>

<h3>Description</h3>

<p>This function calculates the punctual estimates of several indicators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimates(object, ...)

## S4 method for signature 'trtSelOptThresh'
estimates(object, method = "median")

## S4 method for signature 'diagOptThresh'
estimates(object, method = "median")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimates_+3A_object">object</code></td>
<td>
<p>a <code>trtSelOptThresh</code> S4 class object from which the decision curve must be plotted.</p>
</td></tr>
<tr><td><code id="estimates_+3A_...">...</code></td>
<td>
<p>other arguments to pass to estimates method.</p>
</td></tr>
<tr><td><code id="estimates_+3A_method">method</code></td>
<td>
<p>which method to use: median, mean or mode (median is the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the punctual estimates of several indicators (median, mean, or mode) depending on the type of marker under study (treatment selection or diagnostic marker).
</p>


<h3>Value</h3>

<p>Returns a list of several indicator estimates.
</p>
<p>Returns the estimates of several indicators.
</p>

<hr>
<h2 id='fit'>Specify which distribution to fit on the marker values</h2><span id='topic+fit'></span>

<h3>Description</h3>

<p>This function is a wrapper to create an S4 object to specify a distribution to fit the marker values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit(x, distr, ini = NULL, thin = NULL, burnin = NULL, model = NULL,
  paraNames = NULL, mcmcList = NULL, cdf = NULL, gradient = NULL,
  hessian = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_+3A_x">x</code></td>
<td>
<p>a vector of marker values (NA values allowed, see Details).</p>
</td></tr>
<tr><td><code id="fit_+3A_distr">distr</code></td>
<td>
<p>a character that specifies the distribution to fit (normal, log-normal, scaled t, gamma, logistic, user-defined or undefined, see Details).</p>
</td></tr>
<tr><td><code id="fit_+3A_ini">ini</code></td>
<td>
<p>specification of initial values for the parameters of the marker distribution in the form of a list. Each list must be named. A list should be provided for each MCMC chain. NULL for &quot;norm&quot; and &quot;lnorm&quot;.</p>
</td></tr>
<tr><td><code id="fit_+3A_thin">thin</code></td>
<td>
<p>the thinning interval between consecutive observations. NULL for &quot;norm&quot; and &quot;lnorm&quot;.</p>
</td></tr>
<tr><td><code id="fit_+3A_burnin">burnin</code></td>
<td>
<p>a positive integer that defines the length of the burn-in iterations when performing the MCMC algorithm. NULL for &quot;norm&quot; and &quot;lnorm&quot;.</p>
</td></tr>
<tr><td><code id="fit_+3A_model">model</code></td>
<td>
<p>a character string used to define the model. Must match with the definition of a model compatible with JAGS. Necessary only for the t and logistic distributions (see Details).</p>
</td></tr>
<tr><td><code id="fit_+3A_paranames">paraNames</code></td>
<td>
<p>a string vector containing the names of the parameters of the submitted distribution. Should be provided only for &quot;user&quot; defined distribution.</p>
</td></tr>
<tr><td><code id="fit_+3A_mcmclist">mcmcList</code></td>
<td>
<p>an object of class mcmc.list where each list contains an MCMC chain. To be provided only for &quot;user&quot; defined distribution.</p>
</td></tr>
<tr><td><code id="fit_+3A_cdf">cdf</code></td>
<td>
<p>a function that characterizes the cumulative distribution. To be provided only for &quot;user&quot; defined distribution (see Details).</p>
</td></tr>
<tr><td><code id="fit_+3A_gradient">gradient</code></td>
<td>
<p>a function that characterizes the density distribution. To be provided only for &quot;user&quot; defined distribution (see Details).</p>
</td></tr>
<tr><td><code id="fit_+3A_hessian">hessian</code></td>
<td>
<p>a function that characterizes the first derivative of the probability density function. To be provided only for &quot;user&quot; defined distribution (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the user to specify which distribution should be fitted to the marker values. If NA values are present in the <code>x</code> argument passed to the function, a warning is produced. However, the user should not discard the NA values from the original data because the length of the <code>x</code> argument is calculated internally to to estimate the mean risk of event occurrence in each treatment arm. So NA values are managed internally by the function.
Five theoretical distributions are implemented by the package: normal, log-normal, gamma, scaled t, and logistic. This is here that the user must specify which of the four distributions must be of type 'undefined' (or in other words which distribution must be expressed as a function of the three other distributions and mean risks of event). The user may also define its own theoretical distribution. The details for each theoretical distribution are provided hereafter:
</p>

<ul>
<li><p> Fit a normal distribution: when specifying <code>distr="norm"</code> you fit a normal distribution to the marker values passed to the <code>x</code> argument of the function. Non-informative priors are used (<code class="reqn">p(\mu,\sigma^2) \propto (\sigma^2)^(-1)</code>). Posterior values of the normal distribution parameters are sampled directly from the exact posterior distributions. If you don't want to use non-informative priors, see the explanation on how to fit a user-defined distribution.
</p>
</li>
<li><p> Fit a log-normal distribution: when specifying <code>distr="lnorm"</code> you fit a log-normal distribution to the marker values passed to the <code>x</code> argument of the function. Non-informative priors are used (<code class="reqn">p(\mu,\sigma^2) \propto (\sigma^2)^(-1)</code>). Posterior values of the log-normal distribution parameters are sampled directly from the exact posterior distributions. If you don't want to use non-informative priors, see the explanation on how to fit a user-defined distribution.
</p>
</li>
<li><p> Fit a gamma distribution: when specifying <code>distr="gamma"</code> you fit a gamma distribution to the marker values passed to the <code>x</code> argument of the function. Non-informative priors are used (<code class="reqn">p(shape,scale) \propto 1/scale</code>). Posterior values of the gamma distribution parameters are sampled using the ARS method. This method requires that the user specifies a list of initial values passed to the <code>ini</code> argument of the function. Each element of this list must be a list with one element named 'shape'. It also requires the <code>thin</code> of the MCMC chain, and the length of the burnin phase passed to the <code>burnin</code> argument. If you don't want to use non-informative priors, see the explanation on how to fit a user-defined distribution.
</p>
</li>
<li><p> Fit a scaled t distribution: when specifying <code>distr="t"</code> you fit a scaled t distribution to the marker values passed to the <code>x</code> argument of the function. Posterior values of the scaled t distribution parameters are sampled using an MCMC algorithm through the JAGS software, so the function requires the user to provide the JAGS model as a character string through the <code>model</code> argument of the function. If <code>NULL</code>, a model with vague priors is provided to the function automatically:
</p>
<p style="text-align: center;"><code class="reqn">mu ~ U(min(x),max(x))</code>
</p>

<p style="text-align: center;"><code class="reqn">log(sd) ~ U(-10,10)</code>
</p>

<p style="text-align: center;"><code class="reqn">1/df ~ U(0,1)</code>
</p>

<p>This method requires that the user specifies a list of initial values passed to the <code>ini</code> argument of the function. Each element of this list must be a list with three elements named 'mu', 'sd', and 'df'. It also requires the <code>thin</code> of the MCMC chain, and the length of the burnin phase passed to the <code>burnin</code> argument. 
</p>
</li>
<li><p> Fit a logistic distribution: when specifying <code>distr="logis"</code> you fit a logistic distribution to the marker values passed to the <code>x</code> argument of the function. Posterior values of the logistic distribution parameters are sampled using a MCMC algorithm through the JAGS software, so the function requires the user to provide the JAGS model as a character string through the <code>model</code> argument of the function. If <code>NULL</code>, a model with vague priors is provided to the function automatically:
</p>
<p style="text-align: center;"><code class="reqn">location ~ U(min(x),max(x))</code>
</p>

<p style="text-align: center;"><code class="reqn">log(scale) ~ U(-10,10)</code>
</p>

<p>This method requires that the user specifies a list of initial values passed to the <code>ini</code> argument of the function. Each element of this list must be a list with two elements named 'location', and 'scale'. It also requires the <code>thin</code> of the MCMC chain, and the length of the burnin phase passed to the <code>burnin</code> argument. 
</p>
</li>
<li><p> Fit a user-defined distribution: when specifying <code>distr="user"</code> you fit a user-defined distribution to the marker values passed to the <code>x</code> argument of the function. First of all, the user must give the parameters name in the argument <code>paraNames</code> of the function using a character vector. Then, the user provides a posterior sample of the parameters of the distribution obtained using JAGS or another software through an object of class <code>mcmc.list</code> to the argument <code>mcmcList</code> of the function (this implies that the user performed the Bayesian inference himself). Note that the names passed to the <code>mcmc.list</code> object must match with the names given in the <code>paraNames</code> argument. Then, the user must specify the <code>cdf</code>, <code>gradient</code>, and <code>hessian</code> functions associated with the fitted distribution. The <code>cdf</code> function is the cumulative distribution function that is fitted to the marker values, the <code>gradient</code> function is its first derivative which corresponds to the probability density function fitted to the marker values, and the <code>hessian</code> function is the second derivative of <code>cdf</code>. When the fitted distribution is a supported distribution (e.g. a normal distribution with informative priors), the user may use the <code>getMethod(cdf,"normalDist")</code> function to use the standard method for normal distribution used in the package. When the fitted distribution is not supported, the user must specify directly the <code>cdf</code> as <code>function(x,mu,sd) pnorm(x,mu,sd)</code> (if we keep the example of the normal distribution). The same idea may be used for the <code>gradient</code> and <code>hessian</code> functions (see the examples to have more details).
</p>
</li>
<li><p> Specify which marker distribution is expressed as a function of the three others and the mean risks of event using <code>distr="undefined"</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an object to be passed to the <code>trtSelThresh</code> and <code>diagThresh</code> functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trtSelThresh">trtSelThresh</a></code> and <code><a href="#topic+diagThresh">diagThresh</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fit a normal distribution
x &lt;- rnorm(250)
fitX &lt;- fit(x, "norm")

#Fit a log-normal distribution
x &lt;- rlnorm(250)
fitX &lt;- fit(x, "lnorm")

#Fit a gamma distribution
x &lt;- rgamma(250, shape = 2, scale = 1.2)
fitX &lt;- fit(x, "gamma", 
            ini = list(list(shape = 1), 
                       list(shape = 2), 
                       list(shape = 3)),
            thin = 1, burnin = 1000)

#Fit a scaled t distribution
x &lt;- optimalThreshold:::rt.scaled(250, df = 4, mean = 2.5, sd = 2)
fitX &lt;- fit(x, "t",
            ini = list(list(mu = 1, sd = 1, df = 2), 
                       list(mu = 2, sd = 2, df = 4), 
                       list(mu = 3, sd = 3, df = 6)),
            thin = 1, burnin = 1000, model = NULL)

#Fit a logistic distribution
x &lt;- rlogis(250)
fitX &lt;- fit(x, "logis", 
            ini = list(list(location = 0.3, scale = 0.5), 
                       list(location = 1, scale = 1), 
                       list(location = 2, scale = 2)), 
            thin = 1, burnin = 1000, model = NULL)

#Specify which distribution is 'undefined'
x &lt;- rnorm(250)
fitX &lt;- fit(x, "undefined")

#Fit a user-defined normal distribution with informative priors
library(rjags)
x &lt;- rnorm(250, mean = 2, sd = 1)
model &lt;- "model
		{
			mu ~ dunif(0, 4)
			log_sd ~ dunif(-1, 1)
			sd &lt;- exp(log_sd)
			tau &lt;- 1 / (sd^2)
			for (i in 1:N)
			{
				x[i] ~ dnorm(mu, tau)
			}
		}
		"
modelJAGS &lt;- jags.model(file = textConnection(model), data = list(x = x, N = length(x)), 
                        inits = list(list(mu = 1, log_sd = -0.5),list(mu = 3.5, log_sd = 0.5)),
                        n.chains = 2, quiet = TRUE)
update(modelJAGS, 1000, progress.bar = "text")
mcmcpara &lt;- coda.samples(modelJAGS, c("mu", "log_sd"), n.iter = 2000, thin = 1)
varnames(mcmcpara) &lt;- c("mu", "sd")
mcmcpara[[1]][, "sd"] &lt;- exp(mcmcpara[[1]][, "sd"])
mcmcpara[[2]][, "sd"] &lt;- exp(mcmcpara[[2]][, "sd"])
fitX &lt;- fit(x, "user", paraNames = varnames(mcmcpara), mcmcList = mcmcpara, 
            cdf = function(x, mu, sd) pnorm(x, mu, sd), 
            gradient = getMethod(gradient, "normalDist"), 
            hessian = function(x, mu, sd) ((mu - x) / sd^2) * dnorm(x, mu, sd))

</code></pre>

<hr>
<h2 id='fitGammaDist-class'>An S4 class to fit a gamma distribution on a vector of marker values.</h2><span id='topic+fitGammaDist-class'></span><span id='topic+fitGammaDist'></span>

<h3>Description</h3>

<p>This class allows to fit a gamma distribution on the marker values <code>x</code>.
</p>


<h3>Details</h3>

<p>This class is automatically created when the user applies the <code>fit</code> function with the argument <code>distr="gamma"</code>. You never have to create manually this class, it is created internally.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>This slot takes in argument the marker values. Numeric argument.</p>
</dd>
<dt><code>n</code></dt><dd><p>Length of x vector (including NA values). Numeric argument.</p>
</dd>
<dt><code>ini</code></dt><dd><p>This slot is a list of initial values passed to the MCMC algorithm. List argument.</p>
</dd>
<dt><code>thin</code></dt><dd><p>This slot is a strictly positive integer value that specifies the 'thin' applied to the MCMC algorithm.</p>
</dd>
<dt><code>burnin</code></dt><dd><p>This slot is a positive integer value that specifies the length of the burnin period in the MCMC algorithm.</p>
</dd>
<dt><code>mcmc</code></dt><dd><p>This slot allows the main function to k,now whether an MCMC algorithm must be performed to sample the distribution parameters from their posterior distribution.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit a gamma distribution.
</p>

<hr>
<h2 id='fitLogisticDist-class'>An S4 class to fit a logistic distribution on a vector of marker values.</h2><span id='topic+fitLogisticDist-class'></span><span id='topic+fitLogisticDist'></span>

<h3>Description</h3>

<p>This class allows to fit a logistic distribution on the marker values <code>x</code>.
</p>


<h3>Details</h3>

<p>This class is automatically created when the user applies the <code>fit</code> function with the argument <code>distr="logis"</code>. You never have to create manually this class, it is created internally.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>This slot takes in argument the marker values. Numeric argument.</p>
</dd>
<dt><code>n</code></dt><dd><p>Length of x vector (including NA values). Numeric argument.</p>
</dd>
<dt><code>ini</code></dt><dd><p>This slot is a list of initial values passed to the MCMC algorithm. List argument.</p>
</dd>
<dt><code>thin</code></dt><dd><p>This slot is a strictly positive integer value that specifies the 'thin' applied to the MCMC algorithm.</p>
</dd>
<dt><code>burnin</code></dt><dd><p>This slot is a positive integer value that specifies the length of the burnin period in the MCMC algorithm.</p>
</dd>
<dt><code>model</code></dt><dd><p>This slot is a character string that specifies the model passed to the JAGS software to perform the MCMC algorithm.</p>
</dd>
<dt><code>mcmc</code></dt><dd><p>This slot allows the main function to k,now whether an MCMC algorithm must be performed to sample the distribution parameters from their posterior distribution.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit a logistic distribution.
</p>

<hr>
<h2 id='fitLogNormalDist-class'>An S4 class to fit a log-normal distribution on a vector of marker values.</h2><span id='topic+fitLogNormalDist-class'></span><span id='topic+fitLogNormalDist'></span>

<h3>Description</h3>

<p>This class allows to fit a log-normal distribution on the marker values <code>x</code>.
</p>


<h3>Details</h3>

<p>This class is automatically created when the user applies the <code>fit</code> function with the argument <code>distr="lnorm"</code>. You never have to create manually this class, it is created internally.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>This slot takes in argument the marker values. Numeric argument.</p>
</dd>
<dt><code>n</code></dt><dd><p>Length of x vector (including NA values). Numeric argument.</p>
</dd>
<dt><code>mcmc</code></dt><dd><p>This slot allows the main function to k,now whether an MCMC algorithm must be performed to sample the distribution parameters from their posterior distribution.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit a log-normal distribution.
</p>

<hr>
<h2 id='fitNormalDist-class'>An S4 class to fit a normal distribution on a vector of marker values.</h2><span id='topic+fitNormalDist-class'></span><span id='topic+fitNormalDist'></span>

<h3>Description</h3>

<p>This class allows to fit a normal distribution on the marker values <code>x</code>.
</p>


<h3>Details</h3>

<p>This class is automatically created when the user applies the <code>fit</code> function with the argument <code>distr="norm"</code>. You never have to create manually this class, it is created internally.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>This slot takes in argument the marker values. Numeric argument.</p>
</dd>
<dt><code>n</code></dt><dd><p>Length of x vector (including NA values). Numeric argument.</p>
</dd>
<dt><code>mcmc</code></dt><dd><p>This slot allows the main function to k,now whether an MCMC algorithm must be performed to sample the distribution parameters from their posterior distribution.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit a normal distribution.
</p>

<hr>
<h2 id='fitStudentDist-class'>An S4 class to fit a Student distribution on a vector of marker values.</h2><span id='topic+fitStudentDist-class'></span><span id='topic+fitStudentDist'></span>

<h3>Description</h3>

<p>This class allows to fit a t distribution on the marker values <code>x</code>.
</p>


<h3>Details</h3>

<p>This class is automatically created when the user applies the <code>fit</code> function with the argument <code>distr="t"</code>. You never have to create manually this class, it is created internally.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>This slot takes in argument the marker values. Numeric argument.</p>
</dd>
<dt><code>n</code></dt><dd><p>Length of x vector (including NA values). Numeric argument.</p>
</dd>
<dt><code>ini</code></dt><dd><p>This slot is a list of initial values passed to the MCMC algorithm. List argument.</p>
</dd>
<dt><code>thin</code></dt><dd><p>This slot is a strictly positive integer value that specifies the 'thin' applied to the MCMC algorithm.</p>
</dd>
<dt><code>burnin</code></dt><dd><p>This slot is a positive integer value that specifies the length of the burnin period in the MCMC algorithm.</p>
</dd>
<dt><code>model</code></dt><dd><p>This slot is a character string that specifies the model passed to the JAGS software to perform the MCMC algorithm.</p>
</dd>
<dt><code>mcmc</code></dt><dd><p>This slot allows the main function to know whether an MCMC algorithm must be performed to sample the distribution parameters from their posterior distribution.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit a t distribution.
</p>

<hr>
<h2 id='fitUserDefinedDist-class'>An S4 class to fit a user-defined distribution on a vector of marker values.</h2><span id='topic+fitUserDefinedDist-class'></span><span id='topic+fitUserDefinedDist'></span>

<h3>Description</h3>

<p>This class allows to fit a user-defined distribution on the marker values <code>x</code>.
</p>


<h3>Details</h3>

<p>This class is automatically created when the user applies the <code>fit</code> function with the argument <code>distr="user"</code>. You never have to create manually this class, it is created internally.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>This slot takes in argument the marker values. Numeric argument.</p>
</dd>
<dt><code>n</code></dt><dd><p>Length of x vector (including NA values). Numeric argument.</p>
</dd>
<dt><code>paraNames</code></dt><dd><p>This slot is a character vector of distribution parameter names.</p>
</dd>
<dt><code>mcmcList</code></dt><dd><p>This slot is an mcmc.list object summing up all the sampled parameters of the user-defined distribution.</p>
</dd>
<dt><code>cdf</code></dt><dd><p>This slot is a function that describes the cumulative distribution function of the user-defined distribution.</p>
</dd>
<dt><code>gradient</code></dt><dd><p>This slot is a function that describes the probability density function of the user-defined distribution.</p>
</dd>
<dt><code>hessian</code></dt><dd><p>This slot is a function that describes the fisrt derivative of the probability density function of the user-defined distribution.</p>
</dd>
<dt><code>mcmc</code></dt><dd><p>This slot allows the main function to k,now whether an MCMC algorithm must be performed to sample the distribution parameters from their posterior distribution.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit a user-defined distribution.
</p>

<hr>
<h2 id='gammaDist-class'>An S4 class to represent a gamma distribution.</h2><span id='topic+gammaDist-class'></span><span id='topic+gammaDist'></span>

<h3>Description</h3>

<p>This S4 class describes the gamma distribution that is fitted to the marker values. The gamma distribution is characterized by the <code>shape</code> and the <code>scale</code> parameters.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when a gamma distribution is fitted on the marker values.
</p>


<h3>Slots</h3>


<dl>
<dt><code>shape</code></dt><dd><p>shape parameter. Must be positive.</p>
</dd>
<dt><code>scale</code></dt><dd><p>scale parameter. Must be strictly positive.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit a gamma distribution.
</p>

<hr>
<h2 id='gradient'>Probability density function of a specified distribution</h2><span id='topic+gradient'></span><span id='topic+gradient+2CnormalDist-method'></span><span id='topic+gradient.normalDist'></span><span id='topic+gradient+2ClogNormalDist-method'></span><span id='topic+gradient.logNormalDist'></span><span id='topic+gradient+2CgammaDist-method'></span><span id='topic+gradient.gammaDist'></span><span id='topic+gradient+2CstudentDist-method'></span><span id='topic+gradient.studentDist'></span><span id='topic+gradient+2ClogisticDist-method'></span><span id='topic+gradient.logisticDist'></span><span id='topic+gradient+2CcompoundEvtRefDist-method'></span><span id='topic+gradient.compoundEvtRefDist'></span><span id='topic+gradient+2CcompoundNoEvtRefDist-method'></span><span id='topic+gradient.compoundNoEvtRefDist'></span><span id='topic+gradient+2CcompoundEvtInnovDist-method'></span><span id='topic+gradient.compoundEvtInnovDist'></span><span id='topic+gradient+2CcompoundNoEvtInnovDist-method'></span><span id='topic+gradient.compoundNoEvtInnovDist'></span>

<h3>Description</h3>

<p>The <code>gradient</code> function returns the probability density function relative to the S4 object passed in its argument. See details to know on what kind of S4 objects this function could be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient(object)

## S4 method for signature 'normalDist'
gradient(object)

## S4 method for signature 'logNormalDist'
gradient(object)

## S4 method for signature 'gammaDist'
gradient(object)

## S4 method for signature 'studentDist'
gradient(object)

## S4 method for signature 'logisticDist'
gradient(object)

## S4 method for signature 'compoundEvtRefDist'
gradient(object)

## S4 method for signature 'compoundNoEvtRefDist'
gradient(object)

## S4 method for signature 'compoundEvtInnovDist'
gradient(object)

## S4 method for signature 'compoundNoEvtInnovDist'
gradient(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradient_+3A_object">object</code></td>
<td>
<p>Any S4 object for which a <code>gradient</code> method is defined. Should match with the definition of an S4 distribution object as defined in the <code>optimalThreshold</code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method can be applied to the S4 distribution objects that are supported in the <code>optimalThreshold</code> package: <code>normalDist</code>, <code>logNormalDist</code>, <code>gammaDist</code>, <code>studentDist</code>, <code>logisticDist</code>, and <code>userDefinedDist</code>. These methods are applied internally, and you have no need to use it outside of the main functions <code>trtSelThresh</code> and <code>diagThresh</code>. 
</p>

<ul>
<li><p> Normal distribution: the <code>gradient</code> method applied to a <code>normalDist</code> object is simply the <code>dnorm</code> function (see help on this function to have more details).
</p>
</li>
<li><p> Log-normal distribution: the <code>gradient</code> method applied to a <code>logNormalDist</code> object is simply the <code>dlnorm</code> function (see help on this function to have more details).
</p>
</li>
<li><p> Gamma distribution: the <code>gradient</code> method applied to a <code>gammaDist</code> object is simply the <code>dgamma</code> function (see help on this function to have more details).
</p>
</li>
<li><p> Scaled t distribution: the scaled t distribution with <code>df</code> = n, <code>mu</code> = <code class="reqn">\mu</code>, and <code>sd</code> = <code class="reqn">\sigma</code> has density:
</p>
<p style="text-align: center;"><code class="reqn">f(x)=(\Gamma((n+1)/2)/(\sqrt{n\pi}\Gamma(n/2))(1+((x-\mu)/\sigma)^2/n)^-((n+1)/2))/\sigma</code>
</p>

</li>
<li><p> Logistic distribution: the <code>gradient</code> method applied to a <code>logisticDist</code> object is simply the <code>dlogis</code> function (see help on this function to have more details).
</p>
</li>
<li><p> User-defined distribution: the <code>gradient</code> method applied to a <code>userDefinedDist</code> object is simply the gradient function provided by the user when fitting a user-defined distribution with the <code>fit</code> function.
</p>
</li></ul>

<p>The S4 objects <code>compoundEvtRefDist</code>, <code>compoundNoEvtRefDist</code>, <code>compoundEvtInnovDist</code>, and <code>compoundNoEvtInnovDist</code> are created internally. The <code>gradient</code> function applied to these objects is defined dynamically depending on what types of distribution are fitted. The definition of the <code>gradient</code> function relies on the expression of the randomization constraint of a clinical trial that enforces the distribution of the marker in each treatment arm to be identical (see References for more details).
</p>


<h3>Value</h3>

<p>Returns the probability density function of the specified distribution.
</p>


<h3>References</h3>

<p>Blangero, Y, Rabilloud, M, Ecochard, R, and Subtil, F. A Bayesian method to estimate the optimal threshold of a marker used to select patients' treatment. <em>Statistical Methods in Medical Research</em>. 2019.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trtSelThresh">trtSelThresh</a></code>, <code><a href="stats.html#topic+dnorm">dnorm</a></code>, <code><a href="stats.html#topic+dlnorm">dlnorm</a></code>, <code><a href="stats.html#topic+dgamma">dgamma</a></code>, <code><a href="stats.html#topic+dlogis">dlogis</a></code>, <code><a href="#topic+fit">fit</a></code>
</p>

<hr>
<h2 id='hessian'>Second derivative of the cumulative distribution function of a specified distribution</h2><span id='topic+hessian'></span><span id='topic+hessian+2CnormalDist-method'></span><span id='topic+hessian.normalDist'></span><span id='topic+hessian+2ClogNormalDist-method'></span><span id='topic+hessian.logNormalDist'></span><span id='topic+hessian+2CgammaDist-method'></span><span id='topic+hessian.gammaDist'></span><span id='topic+hessian+2CstudentDist-method'></span><span id='topic+hessian.studentDist'></span><span id='topic+hessian+2ClogisticDist-method'></span><span id='topic+hessian.logisticDist'></span><span id='topic+hessian+2CcompoundEvtRefDist-method'></span><span id='topic+hessian.compoundEvtRefDist'></span><span id='topic+hessian+2CcompoundNoEvtRefDist-method'></span><span id='topic+hessian.compoundNoEvtRefDist'></span><span id='topic+hessian+2CcompoundEvtInnovDist-method'></span><span id='topic+hessian.compoundEvtInnovDist'></span><span id='topic+hessian+2CcompoundNoEvtInnovDist-method'></span><span id='topic+hessian.compoundNoEvtInnovDist'></span>

<h3>Description</h3>

<p>The <code>hessian</code> function returns the second derivative of the cumulative distribution function relative to the S4 object passed in its argument. See details to know on what kind of S4 objects this function could be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hessian(object)

## S4 method for signature 'normalDist'
hessian(object)

## S4 method for signature 'logNormalDist'
hessian(object)

## S4 method for signature 'gammaDist'
hessian(object)

## S4 method for signature 'studentDist'
hessian(object)

## S4 method for signature 'logisticDist'
hessian(object)

## S4 method for signature 'compoundEvtRefDist'
hessian(object)

## S4 method for signature 'compoundNoEvtRefDist'
hessian(object)

## S4 method for signature 'compoundEvtInnovDist'
hessian(object)

## S4 method for signature 'compoundNoEvtInnovDist'
hessian(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hessian_+3A_object">object</code></td>
<td>
<p>A distribution object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method can be applied to the S4 distribution objects that are supported in the <code>optimalThreshold</code> package: <code>normalDist</code>, <code>logNormalDist</code>, <code>gammaDist</code>, <code>studentDist</code>, <code>logisticDist</code>, and <code>userDefinedDist</code>. These methods are applied internally, and you have no need to use it outside of the main functions <code>trtSelThresh</code> and <code>diagThresh</code>. 
</p>

<ul>
<li><p> Normal distribution: the <code>hessian</code> method applied to a <code>normalDist</code> object is simply the second derivative of the cumulative distribution function of a normal distribution, with <code>mu</code>=<code class="reqn">\mu</code> and <code>sd</code>=<code class="reqn">\sigma</code>, and expressed as: 
</p>
<p style="text-align: center;"><code class="reqn">f'(x)=((\mu-x)/\sigma^2)*f(x)</code>
</p>

</li>
<li><p> Log-normal distribution: the <code>hessian</code> method applied to a <code>logNormalDist</code> object is simply the second derivative of the cumulative distribution function of a log-normal distribution, with <code>mu</code>=<code class="reqn">\mu</code> and <code>sd</code>=<code class="reqn">\sigma</code>, and expressed as:
</p>
<p style="text-align: center;"><code class="reqn">f'(x)=(((\mu-\log(x))/(x*\sigma^2))-1/x)*f(x)</code>
</p>

</li>
<li><p> Gamma distribution: the <code>hessian</code> method applied to a <code>gammaDist</code> object is simply the second derivative of the cumulative distribution function of a gamma distribution, with <code>shape</code>=<code class="reqn">\alpha</code> and <code>scale</code>=<code class="reqn">\beta</code>, and expressed as:
</p>
<p style="text-align: center;"><code class="reqn">f'(x)=((\alpha-1)/x-1/\beta)*f(x)</code>
</p>

</li>
<li><p> Scaled t distribution: the <code>hessian</code> method applied to a <code>studentDist</code> object is simply the second derivative of the cumulative distribution function of a t scaled distribution, with <code>df</code>=n, <code>mu</code>=<code class="reqn">\mu</code> and <code>sd</code>=<code class="reqn">\sigma</code>, and expressed as:
</p>
<p style="text-align: center;"><code class="reqn">f'(x)=(-(n+1))*((x-\mu)/(\sigma^2*(n+((x-\mu)/\sigma)^2)))*f(x)</code>
</p>

</li>
<li><p> Logistic distribution: the <code>hessian</code> method applied to a <code>logisticDist</code> object is simply the second derivative of the cumulative distribution function of a logistic distribution, with <code>location</code>=<code class="reqn">\mu</code>, and <code>scale</code>=<code class="reqn">\sigma</code>, and expressed as:
</p>
<p style="text-align: center;"><code class="reqn">f'(x)=((\exp(-(x-\mu)/\sigma)^2-1)/(\sigma*(1+\exp(-(x-\mu)/\sigma))^2))*f(x)</code>
</p>

</li>
<li><p> User-defined distribution: the <code>hessin</code> method applied to a <code>userDefinedDist</code> object is simply the hessian function provided by the user when fitting a user-defined distribution with the <code>fit</code> function.
</p>
</li></ul>

<p>The S4 objects <code>compoundEvtRefDist</code>, <code>compoundNoEvtRefDist</code>, <code>compoundEvtInnovDist</code>, and <code>compoundNoEvtInnovDist</code> are created internally. The <code>hessian</code> function applied to these objects is defined dynamically depending on what types of distribution are fitted. The definition of the <code>hessian</code> function relies on the expression of the randomization constraint of a clinical trial that enforces the distribution of the marker in each treatment arm to be identical (see References for more details).
</p>


<h3>Value</h3>

<p>Returns the second derivative of the cumulative distribution function of the specified distribution.
</p>


<h3>References</h3>

<p>Blangero, Y, Rabilloud, M, Ecochard, R, and Subtil, F. A Bayesian method to estimate the optimal threshold of a marker used to select patients' treatment. <em>Statistical Methods in Medical Research</em>. 2019.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trtSelThresh">trtSelThresh</a></code>, <code><a href="#topic+fit">fit</a></code>
</p>

<hr>
<h2 id='logisticDist-class'>An S4 class to represent a logistic distribution.</h2><span id='topic+logisticDist-class'></span><span id='topic+logisticDist'></span>

<h3>Description</h3>

<p>This S4 class describes the logistic distribution that is fitted to the marker values. The logistic distribution is characterized by the <code>location</code> and the <code>scale</code> parameters.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when a logistic distribution is fitted on the marker values.
</p>


<h3>Slots</h3>


<dl>
<dt><code>location</code></dt><dd><p>location parameter.</p>
</dd>
<dt><code>scale</code></dt><dd><p>scale parameter. Must be strictly positive.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit a logistic distribution.
</p>

<hr>
<h2 id='logNormalDist-class'>An S4 class to represent a log-normal distribution.</h2><span id='topic+logNormalDist-class'></span><span id='topic+logNormalDist'></span>

<h3>Description</h3>

<p>This S4 class describes the log-normal distribution that is fitted to the marker values. The log-normal distribution is characterized by the <code>mu</code> and the <code>sd</code> parameters.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when a log-normal distribution is fitted on the marker values.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mu</code></dt><dd><p>mu parameter.</p>
</dd>
<dt><code>sd</code></dt><dd><p>standard deviation parameter. Must be strictly positive.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit a log-normal distribution.
</p>

<hr>
<h2 id='mcmc.listOrNull-class'>An S4 union class to merge mcmc.list and NULL types of object.</h2><span id='topic+mcmc.listOrNull-class'></span><span id='topic+mcmc.listOrNull'></span>

<h3>Description</h3>

<p>An S4 union class to merge mcmc.list and NULL types of object.
</p>

<hr>
<h2 id='normalDist-class'>An S4 class to represent a normal distribution.</h2><span id='topic+normalDist-class'></span><span id='topic+normalDist'></span>

<h3>Description</h3>

<p>This S4 class describes the normal distribution that is fitted to the marker values. The normal distribution is characterized by the <code>mu</code> and the <code>sd</code> parameters.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when a normal distribution is fitted on the marker values.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mu</code></dt><dd><p>mu parameter.</p>
</dd>
<dt><code>sd</code></dt><dd><p>standard deviation parameter. Must be strictly positive.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit a normal distribution.
</p>

<hr>
<h2 id='plot-methods'>Plot method</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CtrtSelOptThresh-method'></span><span id='topic+plot.trtSelOptThresh'></span><span id='topic+plot+2CdiagOptThresh-method'></span><span id='topic+plot.diagOptThresh'></span>

<h3>Description</h3>

<p>Plot method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'trtSelOptThresh'
plot(x, y,
  main = "MCMC sample distribution of optimal threshold",
  col = "gray85", border.col = "darkgrey",
  xlab = "Optimal threshold estimate", yaxs = "i", freq = FALSE,
  breaks = seq(min(x@optThresh, na.rm = TRUE), max(x@optThresh, na.rm =
  TRUE), length.out = 20), ...)

## S4 method for signature 'diagOptThresh'
plot(x, y,
  main = "MCMC sample distribution of optimal threshold",
  col = "gray85", border.col = "darkgrey",
  xlab = "Optimal threshold estimate", yaxs = "i", freq = FALSE,
  breaks = seq(min(x@optThresh, na.rm = TRUE), max(x@optThresh, na.rm =
  TRUE), length.out = 20), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>a <code>trtSelOptThresh</code> or a <code>diagOptThresh</code> object.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p>unused parameter.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_col">col</code></td>
<td>
<p>the color of the histogram.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_border.col">border.col</code></td>
<td>
<p>the color of the histogram border.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis of the plot.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_yaxs">yaxs</code></td>
<td>
<p>The style of axis interval calculation to be used for the y-axis.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_freq">freq</code></td>
<td>
<p>logical; if TRUE, the histogram graphic is a representation of frequencies; if FALSE, probability densities are plotted (so that the histogram has a total area of one).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_breaks">breaks</code></td>
<td>
<p>one of: 
</p>

<ul>
<li><p> a vector giving the breakpoints between histogram cells, 
</p>
</li>
<li><p> a function to compute the vector of breakpoints, 
</p>
</li>
<li><p> a single number giving the number of cells for the histogram, 
</p>
</li>
<li><p> a character string naming an algorithm to compute the number of cells, 
</p>
</li>
<li><p> a function to compute the number of cells. 
</p>
</li></ul>

<p>In the last three cases the number is a suggestion only; as the breakpoints will be set to pretty values, the number is limited to 1e6 (with a warning if it was larger). If breaks is a function, the x vector is supplied to it as the only argument (and the number of breaks is only limited by the amount of available memory).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>other graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plot.diagRelUtility'>Plot the decision curves of a diagnostic marker</h2><span id='topic+plot.diagRelUtility'></span><span id='topic+plot+2CdiagRelUtility-method'></span>

<h3>Description</h3>

<p>Plot the decision curves of a diagnostic marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'diagRelUtility'
plot(x, y, main = "Decision curves",
  lty = 1, lwd = 1, xlim = range(x@r), ylim = c(min(x@U,
  x@UNoTreat, x@UTreatAll), max(x@U, x@UNoTreat, x@UTreatAll)),
  ylab = "Expected benefit", xlab = "r", col.U = "black",
  col.UNoTreat = "blue", col.UTreatAll = "green", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.diagRelUtility_+3A_x">x</code></td>
<td>
<p>a <code>diagRelUtility</code> object.</p>
</td></tr>
<tr><td><code id="plot.diagRelUtility_+3A_y">y</code></td>
<td>
<p>unused parameter.</p>
</td></tr>
<tr><td><code id="plot.diagRelUtility_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.diagRelUtility_+3A_lty">lty</code></td>
<td>
<p>the line type. Line types can either be specified as an integer (0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings &quot;blank&quot;, &quot;solid&quot;, &quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, or &quot;twodash&quot;, where &quot;blank&quot; uses 'invisible lines' (i.e., does not draw them).</p>
</td></tr>
<tr><td><code id="plot.diagRelUtility_+3A_lwd">lwd</code></td>
<td>
<p>the line width, a <em>positive</em> number, defaulting to 1. The interpretation is device-specific, and some devices do not implement line widths less than one. (See the help on the device for details of the interpretation).</p>
</td></tr>
<tr><td><code id="plot.diagRelUtility_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.diagRelUtility_+3A_ylim">ylim</code></td>
<td>
<p>the x limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.diagRelUtility_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis.</p>
</td></tr>
<tr><td><code id="plot.diagRelUtility_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis</p>
</td></tr>
<tr><td><code id="plot.diagRelUtility_+3A_col.u">col.U</code></td>
<td>
<p>color of the utility curve for the marker-based strategy.</p>
</td></tr>
<tr><td><code id="plot.diagRelUtility_+3A_col.unotreat">col.UNoTreat</code></td>
<td>
<p>color of the utility curve for the &quot;No Treat&quot; strategy.</p>
</td></tr>
<tr><td><code id="plot.diagRelUtility_+3A_col.utreatall">col.UTreatAll</code></td>
<td>
<p>color of the utility curve for the &quot;Treat All&quot; strategy.</p>
</td></tr>
<tr><td><code id="plot.diagRelUtility_+3A_...">...</code></td>
<td>
<p>other graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plot.trtSelRelUtility'>Plot the decision curves of a treatment selection marker</h2><span id='topic+plot.trtSelRelUtility'></span><span id='topic+plot+2CtrtSelRelUtility-method'></span>

<h3>Description</h3>

<p>Plot the decision curves of a treatment selection marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'trtSelRelUtility'
plot(x, y, which = c(1, 2), alpha = 0.05,
  conf.int = TRUE, main1 = "Decision curves (unscaled)",
  main2 = "Decision curve (scaled)", lty = 1, lwd = 1,
  xlim = range(x@r), ylim1 = c(min(x@U, x@UT0, x@UT1, x@Up), max(x@U,
  x@UT0, x@UT1, x@Up)), ylim2 = c(0, 1), ylab1 = "Utility",
  ylab2 = "Relative utility", xlab = "r ratio", col.U = "black",
  col.Up = "red", col.UT0 = "blue", col.UT1 = "green",
  col.RU = "black", col.conf.int = "black", add = FALSE,
  legend1 = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.trtSelRelUtility_+3A_x">x</code></td>
<td>
<p>a <code>trtSelRelUtility</code> object.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_y">y</code></td>
<td>
<p>unused parameter.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_which">which</code></td>
<td>
<p>indicates which graph should be plotted. Default is both graphs.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_alpha">alpha</code></td>
<td>
<p>alpha risk for the confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_conf.int">conf.int</code></td>
<td>
<p>a logical value indicating whether the confidence intervals should be plotted for the relative utility curve.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_main1">main1</code></td>
<td>
<p>an overall title for the first plot.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_main2">main2</code></td>
<td>
<p>an overall title for the second plot.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_lty">lty</code></td>
<td>
<p>the line type. Line types can either be specified as an integer (0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings &quot;blank&quot;, &quot;solid&quot;, &quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, or &quot;twodash&quot;, where &quot;blank&quot; uses 'invisible lines' (i.e., does not draw them).</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_lwd">lwd</code></td>
<td>
<p>the line width, a <em>positive</em> number, defaulting to 1. The interpretation is device-specific, and some devices do not implement line widths less than one. (See the help on the device for details of the interpretation).</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plots.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_ylim1">ylim1</code></td>
<td>
<p>the y limits of the first plot.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_ylim2">ylim2</code></td>
<td>
<p>the y limits of the second plot.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_ylab1">ylab1</code></td>
<td>
<p>a label for the y axis of the first plot.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_ylab2">ylab2</code></td>
<td>
<p>a label for the y axis of the second plot.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis of the plots.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_col.u">col.U</code></td>
<td>
<p>color of the utility curve for the marker-based strategy.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_col.up">col.Up</code></td>
<td>
<p>color of the utility curve for the perfect marker-based strategy.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_col.ut0">col.UT0</code></td>
<td>
<p>color of the utility curve for the &quot;Treat All with the reference treatment&quot; strategy.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_col.ut1">col.UT1</code></td>
<td>
<p>color of the utility curve for the &quot;Treat All with the innovative treatment&quot; strategy.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_col.ru">col.RU</code></td>
<td>
<p>color of the relative utility curve.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_col.conf.int">col.conf.int</code></td>
<td>
<p>color of the confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_add">add</code></td>
<td>
<p>a logical value indicating whether the relative utility curve should superimpose with an existing graph. Only works when <code>which</code> = 2.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_legend1">legend1</code></td>
<td>
<p>a logical value indicating whether a legend should be added to the first plot.</p>
</td></tr>
<tr><td><code id="plot.trtSelRelUtility_+3A_...">...</code></td>
<td>
<p>other graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='riskCurves'>Marker-by-treatment predictiveness curves plot</h2><span id='topic+riskCurves'></span>

<h3>Description</h3>

<p>This function plots the marker-by-treatment predictiveness curves for treatment selection markers, corresponding to the risk of event in each treatment arm in function of the cumulative distribution of the marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riskCurves(x0E, x0Eb, x1E, x1Eb, ylab = "Predicted risk of event",
  xlab = "Empirical cumulative distribution function of the marker",
  main = "Marker-by-treatment predictiveness curves")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riskCurves_+3A_x0e">x0E</code></td>
<td>
<p>a numeric vector of the marker values for patients in the reference arm that developed the event.</p>
</td></tr>
<tr><td><code id="riskCurves_+3A_x0eb">x0Eb</code></td>
<td>
<p>a numeric vector of the marker values for patients in the reference arm that did not develop the event.</p>
</td></tr>
<tr><td><code id="riskCurves_+3A_x1e">x1E</code></td>
<td>
<p>a numeric vector of the marker values for patients in the innovative arm that developed the event.</p>
</td></tr>
<tr><td><code id="riskCurves_+3A_x1eb">x1Eb</code></td>
<td>
<p>a numeric vector of the marker values for patients in the innovative arm that did not develop the event.</p>
</td></tr>
<tr><td><code id="riskCurves_+3A_ylab">ylab</code></td>
<td>
<p>label of the Y-axis.</p>
</td></tr>
<tr><td><code id="riskCurves_+3A_xlab">xlab</code></td>
<td>
<p>label of the X-axis.</p>
</td></tr>
<tr><td><code id="riskCurves_+3A_main">main</code></td>
<td>
<p>title of the graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses regression splines to plot the marker-by-treatment predictiveness curves. This graph may be used to check graphically the strength of the marker-by-treatment interaction, and to know whether low values of the marker are associated with a better response of the reference treatment (this information is needed in the <code>trtSelThresh</code> function).
</p>


<h3>Value</h3>

<p>None
</p>


<h3>References</h3>

<p>Janes, H, Pepe, MS, Bossuyt, PM, and Barlow, WE. Measuring the performance of markers for guiding treatment decisions. <em>Annals of Internal Medicine</em>. 2011; 154(4): 253-259.
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+gam">gam</a></code> for more details about regression splines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x0E &lt;- rnorm(100, 2, 1)
x0Eb &lt;- rnorm(100, 4, 1)
x1E &lt;- rnorm(100, 4, 1)
x1Eb &lt;- rnorm(100, 2, 1)
riskCurves(x0E, x0Eb, x1E, x1Eb)
</code></pre>

<hr>
<h2 id='samplePosteriorDist'>Sample in the posterior distribution of the parameters of a given theoretical distribution.</h2><span id='topic+samplePosteriorDist'></span><span id='topic+samplePosteriorDist+2CfitNormalDist-method'></span><span id='topic+samplePosteriorDist.fitNormalDist'></span><span id='topic+samplePosteriorDist+2CfitLogNormalDist-method'></span><span id='topic+samplePosteriorDist.fitLogNormalDist'></span><span id='topic+samplePosteriorDist+2CfitGammaDist-method'></span><span id='topic+samplePosteriorDist.fitGammaDist'></span><span id='topic+samplePosteriorDist+2CfitStudentDist-method'></span><span id='topic+samplePosteriorDist.fitStudentDist'></span><span id='topic+samplePosteriorDist+2CfitLogisticDist-method'></span><span id='topic+samplePosteriorDist.fitLogisticDist'></span>

<h3>Description</h3>

<p>The <code>samplePosteriorDist</code> function samples the parameters of a given theoretical distribution using explicit posterior distribution (if it exists), or a Markov Chain Monte Carlo (MCMC) algorithm when the posterior distribution is unknown. See details to know on what kind of S4 objects this function could be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samplePosteriorDist(object, K, ...)

## S4 method for signature 'fitNormalDist'
samplePosteriorDist(object, K, n)

## S4 method for signature 'fitLogNormalDist'
samplePosteriorDist(object, K, n)

## S4 method for signature 'fitGammaDist'
samplePosteriorDist(object, K, do.pb, seed)

## S4 method for signature 'fitStudentDist'
samplePosteriorDist(object, K, do.pb, seed)

## S4 method for signature 'fitLogisticDist'
samplePosteriorDist(object, K, do.pb, seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samplePosteriorDist_+3A_object">object</code></td>
<td>
<p>A distribution object.</p>
</td></tr>
<tr><td><code id="samplePosteriorDist_+3A_k">K</code></td>
<td>
<p>A numerical value indicating the length of the sample.</p>
</td></tr>
<tr><td><code id="samplePosteriorDist_+3A_...">...</code></td>
<td>
<p>other parameters passed to methods.</p>
</td></tr>
<tr><td><code id="samplePosteriorDist_+3A_n">n</code></td>
<td>
<p>number of MCMC chains.</p>
</td></tr>
<tr><td><code id="samplePosteriorDist_+3A_do.pb">do.pb</code></td>
<td>
<p>Indicates whther progressing bar or not</p>
</td></tr>
<tr><td><code id="samplePosteriorDist_+3A_seed">seed</code></td>
<td>
<p>seed for the random number generator. Integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method can be applied to the S4 distribution objects that are supported in the <code>optimalThreshold</code> package: <code>fitNormalDist</code>, <code>fitLogNormalDist</code>, <code>fitGammaDist</code>, <code>fitStudentDist</code>, and <code>fitLogisticDist</code>. These methods are applied internally, and you have no need to use it outside of the main function <code>optThresEst</code>. See below to have details on the expression of the <code>samplePosteriorDist</code> function according to the type of distribution.
</p>

<ul>
<li><p> Normal distribution: a noninformative prior is used for the parameters of the normal distribution (<code>mu</code>=<code class="reqn">\mu</code>, and <code>sd</code>=<code class="reqn">\sigma</code>). The <code class="reqn">\sigma^2</code> parameter is sampled from an inverse Chi-squared distribution, and the <code class="reqn">\mu</code> parameter is sampled from a normal distribution with known variance. So, sampling in the posterior distribution of <code class="reqn">\mu</code> and <code class="reqn">\sigma</code> does not involve an MCMC algorithm (see References for more details and justification).
</p>
</li>
<li><p> Log-normal distribution: a noninformative prior is used for the parameters of the log-normal distribution (<code>mu</code>=<code class="reqn">\mu</code>, and <code>sd</code>=<code class="reqn">\sigma</code>). The <code class="reqn">\sigma^2</code> parameter is sampled from an inverse Chi-squared distribution, and the <code class="reqn">\mu</code> parameter is sampled from a normal distribution with known variance. So, sampling in the posterior distribution of <code class="reqn">\mu</code> and <code class="reqn">\sigma</code> does not involve an MCMC algorithm (see References for more details and justification).
</p>
</li>
<li><p> Gamma distribution: a noninformative prior is used for the parameters of the gamma distribution (<code>shape</code>=<code class="reqn">\alpha</code>, and <code>scale</code>=<code class="reqn">\beta</code>). The parameters are sampled using an adaptive rejection sampling (ARS) algorithm. The <code class="reqn">\beta</code> parameter is sampled at the first iteration from an inverse gamma distribution using the initial value of the <code class="reqn">\alpha</code> parameter provided by the user. Then the ARS algorithm is performed to sample <code class="reqn">\alpha</code> from its posterior distribution (see References for more details and justification).
</p>
</li>
<li><p> Scaled t distribution: a vague prior is used for the parameters of the scaled t distribution as a default. However, the user can write its own JAGS model to use different priors (see the <code>fit</code> function for more details). Sampling from the posterior distribution of the parameters of a scaled t distribution requires JAGS to be installed.
</p>
</li>
<li><p> Logistic distribution: a vague prior is used for the parameters of the logistic distribution as a default. However, the user can write its own JAGS model to use different priors (see the <code>fit</code> function for more details). Sampling from the posterior distribution of the parameters of a logistic distribution requires JAGS to be installed.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an object of class list.
</p>


<h3>References</h3>

<p>Gelman, A, et al. 2014. <em>Bayesian Data Analysis</em>. 3rd edition, CRC Press, Boca Raton, section 2.8.
Sook, Y, and Oh, M. Bayesian estimation of the two-parameter Gamma distribution. <em>Communications in Statistics - Simulation and Computation</em>. 2006; 35: 285-293.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trtSelThresh">trtSelThresh</a></code>
</p>

<hr>
<h2 id='show-methods'>Show method</h2><span id='topic+show-methods'></span><span id='topic+show+2CtrtSelOptThresh-method'></span><span id='topic+show.trtSelOptThresh'></span><span id='topic+show+2CdiagOptThresh-method'></span><span id='topic+show.diagOptThresh'></span>

<h3>Description</h3>

<p>Show some of the slots of a <code>trtSelOptThresh</code> or a <code>diagOptThresh</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'trtSelOptThresh'
show(object)

## S4 method for signature 'diagOptThresh'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show-methods_+3A_object">object</code></td>
<td>
<p>a <code>trtSelOptThresh</code> or a <code>diagOptThresh</code> S4 object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='studentDist-class'>An S4 class to represent a scaled Student distribution.</h2><span id='topic+studentDist-class'></span><span id='topic+studentDist'></span>

<h3>Description</h3>

<p>This S4 class describes the scaled t distribution that is fitted to the marker values. The scaled t distribution is characterized by the <code>df</code> (degrees of freedom), the <code>mu</code>, and the <code>sd</code> parameters.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when a scaled t distribution is fitted on the marker values.
</p>


<h3>Slots</h3>


<dl>
<dt><code>df</code></dt><dd><p>degrees of freedom (&gt; 0, maybe non-integer).</p>
</dd>
<dt><code>mu</code></dt><dd><p>mu parameter.</p>
</dd>
<dt><code>sd</code></dt><dd><p>standard deviation parameter. Must be strictly positive.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit a t distribution.
</p>

<hr>
<h2 id='summary-methods'>An S4 method that summarizes the results of a <code>trtSelOpthThresh</code> or a <code>diagOpthThresh</code> object.</h2><span id='topic+summary-methods'></span><span id='topic+summary.trtSelOptThresh'></span><span id='topic+summary+2CtrtSelOptThresh-method'></span><span id='topic+summary.diagOptThresh'></span><span id='topic+summary+2CdiagOptThresh-method'></span>

<h3>Description</h3>

<p>An S4 method that summarizes the results of a <code>trtSelOpthThresh</code> or a <code>diagOpthThresh</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'trtSelOptThresh'
summary(object, alpha = 0.05,
  method = "median")

## S4 method for signature 'diagOptThresh'
summary(object, alpha = 0.05,
  method = "median")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>
<p>a <code>trtSelOptThresh</code> S4 class object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_alpha">alpha</code></td>
<td>
<p>alpha parameter for the confidence level required.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_method">method</code></td>
<td>
<p>which method to use: median, mean or mode (median is the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function presents the results stocked in a <code>trtSelOpthThresh</code> object, or in a <code>diagOpthThresh</code> object. For a <code>trtSelOpthThresh</code> object it prints:
</p>

<ul>
<li><p> The decision rule: is the reference treatment recommended for low values of the marker?
</p>
</li>
<li><p> The median (default), mean, or mode risk of event occurrence in each treatment arm, and their credible interval.
</p>
</li>
<li><p> Some summary statistics of the marker under study (min, max, quartiles and mean)
</p>
</li>
<li><p> The optimal threshold estimate and its credible interval (percentile and highest posterior density).
</p>
</li>
<li><p> The median (default), mean, or mode risk in each arm under the marker-based strategy.
</p>
</li>
<li><p> The median (default), mean, or mode benefit estimate under each treatment arm.
</p>
</li>
<li><p> The percentage of NA values returned during the optimal threshold estimation process.
</p>
</li></ul>

<p>For a <code>diagOpthThresh</code> object, it prints:
</p>

<ul>
<li><p> The decision rule: is the reference treatment recommended for low values of the marker?
</p>
</li>
<li><p> The median (default), mean, or mode risk of event occurrence in each treatment arm, and their credible interval.
</p>
</li>
<li><p> Some summary statistics of the marker under study (min, max, quartiles and mean)
</p>
</li>
<li><p> The optimal threshold estimate and its credible interval (percentile and highest posterior density).
</p>
</li>
<li><p> The median (default), mean, or mode risk in each arm under the marker-based strategy.
</p>
</li>
<li><p> The median (default), mean, or mode benefit estimate under each treatment arm.
</p>
</li>
<li><p> The percentage of NA values returned during the optimal threshold estimation process.
</p>
</li></ul>



<h3>Value</h3>

<p>This function returns an object of class 'summaryTrtSelOptThresh'.
</p>
<p>This function returns an object of class 'summaryDiagOptThresh'.
</p>


<h3>References </h3>

<p>Blangero, Y, Rabilloud, M, Ecochard, R, and Subtil, F. A Bayesian method to estimate the optimal threshold of a marker used to select patients' treatment. <em>Statistical Methods in Medical Research</em>. 2019.
</p>
<p>Subtil, F, and Rabilloud. A Bayesian method to estimate the optimal threshold of a longitudinal biomarker. <em>Biometrical Journal</em>. 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trtSelThresh">trtSelThresh</a></code> for more details on how to estimate the optimal threshold of a treatment selection marker.
</p>
<p><code><a href="#topic+diagThresh">diagThresh</a></code> for more details on how to estimate the optimal threshold of a diagnostic marker.
</p>

<hr>
<h2 id='trtSelOptThresh-class'>An S4 class to describe the optimal threshold of a treatment selection marker.</h2><span id='topic+trtSelOptThresh-class'></span><span id='topic+trtSelOptThresh'></span>

<h3>Description</h3>

<p>An S4 class to describe the optimal threshold of a treatment selection marker.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when the <code>trtSelThresh</code> function is used.
</p>


<h3>Slots</h3>


<dl>
<dt><code>optThresh</code></dt><dd><p>This slot is an object that takes in argument the sampled optimal threshold values. Numeric argument.</p>
</dd>
<dt><code>r0</code></dt><dd><p>This slot is an object that takes in argument the sampled mean risks of event occurrence in the reference arm. Numeric argument.</p>
</dd>
<dt><code>r1</code></dt><dd><p>This slot is an object that takes in argument the sampled mean risks of event occurrence in the innovative arm. Numeric argument.</p>
</dd>
<dt><code>xEvtRef</code></dt><dd><p>This slot is an object that takes in argument the marker values in the subgroup of patients that developed the event in the reference arm. Numeric argument.</p>
</dd>
<dt><code>xNoEvtRef</code></dt><dd><p>This slot is an object that takes in argument the marker values in the subgroup of patients that did not develop the event in the reference arm. Numeric argument.</p>
</dd>
<dt><code>xEvtInnov</code></dt><dd><p>This slot is an object that takes in argument the marker values in the subgroup of patients that developed the event in the innovative arm. Numeric argument.</p>
</dd>
<dt><code>xNoEvtInnov</code></dt><dd><p>This slot is an object that takes in argument the marker values in the subgroup of patients that did not develop the event in the innovative arm. Numeric argument.</p>
</dd>
<dt><code>lowRef</code></dt><dd><p>This slot is a logical argument that specifies whether the reference treatment is recommended for low values of the marker.</p>
</dd>
<dt><code>toxRef</code></dt><dd><p>This slot is a logical argument that specifies whether the reference treatment is the most toxic treatment option at equal efficacy with the innovative treatment.</p>
</dd>
<dt><code>markerBasedRiskRef</code></dt><dd><p>This slot is an object that takes in argument the sampled mean risks of event occurrence in the reference treatment under the marker-based allocation rule. Numeric argument.</p>
</dd>
<dt><code>markerBasedRiskInnov</code></dt><dd><p>This slot is an object that takes in argument the sampled mean risks of event occurrence in the innovative treatment under the marker-based allocation rule. Numeric argument.</p>
</dd>
<dt><code>mcmcChainEvtRef</code></dt><dd><p>This slot is an object that takes in argument the sampled distribution objects in the subgroup of patients that developed the event in the reference arm. list argument.</p>
</dd>
<dt><code>mcmcChainNoEvtRef</code></dt><dd><p>This slot is an object that takes in argument the sampled distribution objects in the subgroup of patients that did not develop the event in the reference arm. list argument.</p>
</dd>
<dt><code>mcmcChainEvtInnov</code></dt><dd><p>This slot is an object that takes in argument the sampled distribution objects in the subgroup of patients that developed the event in the innovative arm. list argument.</p>
</dd>
<dt><code>mcmcChainNoEvtInnov</code></dt><dd><p>This slot is an object that takes in argument the sampled distribution objects in the subgroup of patients that did not develop the event in the innovative arm. list argument.</p>
</dd>
<dt><code>tabMCMCChain</code></dt><dd><p>This slot is an object that takes in argument all the distribution parameters that were sampled using the MCMC algorithm. mcmc.listOrNull argument.</p>
</dd>
<dt><code>paraNamesUserDefined</code></dt><dd><p>This slot is an object that takes in argument the list of the distribution parameter names defined by the user in a 'fitUserDefinedDist' object. list argument.</p>
</dd>
<dt><code>cdfUserDefined</code></dt><dd><p>This slot is an object that takes in argument the list of cumulative distribution functions defined by the user in 'fitUserDefinedDist' objects. list argument.</p>
</dd>
<dt><code>gradientUserDefined</code></dt><dd><p>This slot is an object that takes in argument the list of gradient functions defined by the user in 'fitUserDefinedDist' objects. list argument.</p>
</dd>
<dt><code>hessianUserDefined</code></dt><dd><p>This slot is an object that takes in argument the list of hessian functions defined by the user in 'fitUserDefinedDist' objects. list argument.</p>
</dd>
<dt><code>percentNA</code></dt><dd><p>This slot is a numeric object that indicates the percentage of NA values contained in the 'optThresh' slot.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+trtSelThresh">trtSelThresh</a></code> for more details on how to estimate the optimal threshold of a treatment selection marker.
</p>

<hr>
<h2 id='trtSelRelUtility-class'>An S4 class to the results from the decisionCurve methods.</h2><span id='topic+trtSelRelUtility-class'></span><span id='topic+trtSelRelUtility'></span>

<h3>Description</h3>

<p>An S4 class to the results from the decisionCurve methods.
</p>


<h3>Details</h3>

<p>You never have to create this class manually. This class is created internally when the <code>decisionCurve</code> method is applied to an 'optThresh' object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>RU</code></dt><dd><p>This slot is a matrix of the relative utility according to the r ratios.</p>
</dd>
<dt><code>U</code></dt><dd><p>This slot is a matrix of the marker-based utility according to the r ratios.</p>
</dd>
<dt><code>UT0</code></dt><dd><p>This slot is a matrix of the reference treatment utility according to the r ratios.</p>
</dd>
<dt><code>UT1</code></dt><dd><p>This slot is a matrix of the innovative treatment utility according to the r ratios.</p>
</dd>
<dt><code>Up</code></dt><dd><p>This slot is a matrix of perfect marker utility according to the r ratios.</p>
</dd>
<dt><code>r</code></dt><dd><p>Ratio of treatment/event costs. Numeric argument.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+decisionCurve">decisionCurve</a></code> for more details on how to plot the decision curves.
</p>

<hr>
<h2 id='trtSelThresh'>Estimation of the optimal threshold of a treatment selection marker</h2><span id='topic+trtSelThresh'></span>

<h3>Description</h3>

<p>This function produces a sample of the posterior distribution of the optimal threshold of a treatment selection marker. The optimal threshold is defined as the marker value that maximized the utility of using the marker to decide between two treatment options (innovative and reference one). The utility function takes into account the efficacy of the treatment options as well as treatment induced toxicities.
The estimation of the utility function needs data from a clinical trial about the two treatment options, in which the success of a treatment is defined by the absence of an event of interest in a given post-treatment interval (binary data). For the time being, the package cannot estimate the optimal threshold in case of censored data about the occurrence of the event in the given post-treatment interval.
To calculate the utility function, the user needs to specify: 
</p>

<ul>
<li><p> the distribution of the marker in the four groups defined by the treatment option and the outcome; in fact only three distributions need to be specified, the fourth one being derived from the three others and the mean risks of event in the two treatment arms through the randomization constraint (the distribution of the marker being the same in both treatment arms; see the <code><a href="#topic+fit">fit</a></code> function for more details),
</p>
</li>
<li><p> and the mean risks of the event in the two treatment arms. The user must also specify: the cost of the innovative treatment relative to the cost of the event (see Details). 
</p>
</li></ul>

<p>The optimal threshold and its credible interval are calculated using a Monte Carlo approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trtSelThresh(EvtRefDist = NULL, NoEvtRefDist = NULL,
  EvtInnovDist = NULL, NoEvtInnovDist = NULL, mRiskRef = NULL,
  mRiskInnov = NULL, lowRef = TRUE, toxRef = TRUE, r = 0,
  le.MCMC = 1000, hessTol = 10^(-6), plot = FALSE,
  progress.bar = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trtSelThresh_+3A_evtrefdist">EvtRefDist</code></td>
<td>
<p>an object of class allowedFitDist that summarizes the distribution fitted to the marker values of patients that developed the event of interest in the reference arm. This class of objects is obtained using the <code><a href="#topic+fit">fit</a></code> function.</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_noevtrefdist">NoEvtRefDist</code></td>
<td>
<p>an object of class allowedFitDist that summarizes the distribution fitted to the marker values of patients that did not develop the event of interest in the reference arm. This class of objects is obtained using the <code><a href="#topic+fit">fit</a></code> function.</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_evtinnovdist">EvtInnovDist</code></td>
<td>
<p>an object of class allowedFitDist that summarizes the distribution fitted to the marker values of patients that developed the event of interest in the innovative arm. This class of objects is obtained using the <code><a href="#topic+fit">fit</a></code> function.</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_noevtinnovdist">NoEvtInnovDist</code></td>
<td>
<p>an object of class allowedFitDist that summarizes the distribution fitted to the marker values of patients that did not develop the event of interest in the innovative arm. This class of objects is obtained using the <code><a href="#topic+fit">fit</a></code> function.</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_mriskref">mRiskRef</code></td>
<td>
<p>an object of class mcmc.list provided by the user. It must be a sample of the posterior distribution of the mean risk of event in the reference treatment arm. If NULL, the function samples values in the posterior distribution of the mean risk of event in the reference arm assuming Jeffrey's prior (Beta(0.5,0.5)), and estimating the mean risk using the number of marker values specified in each treatment arm.</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_mriskinnov">mRiskInnov</code></td>
<td>
<p>an object of class mcmc.list provided by the user. It must be a sample of the posterior distribution of the mean risk of event in the innovative treatment arm. If NULL, the function samples values in the posterior distribution of the mean risk of event in the innovative arm assuming Jeffrey's prior (Beta(0.5,0.5)), and estimating the mean risk using the number of marker values specified in each treatment arm..</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_lowref">lowRef</code></td>
<td>
<p>a logical value indicating whether low values of the marker are associated with low (TRUE) or high (FALSE) risk under the reference treatment arm.</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_toxref">toxRef</code></td>
<td>
<p>a logical value indicating whether the reference treatment arm (TRUE) or the innovative treatment arm (FALSE) must be preferred at equal efficacy taking into account toxicity.</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_r">r</code></td>
<td>
<p>a numeric value indicating the cost ratio between the most harmful treatment and the event (see Details).</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_le.mcmc">le.MCMC</code></td>
<td>
<p>length of the desired MCMC chain.</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_hesstol">hessTol</code></td>
<td>
<p>tolerance for the hessian value of the utility function at the optimal threshold.</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_plot">plot</code></td>
<td>
<p>a logical value indicating whether routine graphics must be produced.</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_progress.bar">progress.bar</code></td>
<td>
<p>a character string indicating whether the user wishes to print a progress bar during the function process.</p>
</td></tr>
<tr><td><code id="trtSelThresh_+3A_seed">seed</code></td>
<td>
<p>a numerical value used to fix the random seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>toxRef==FALSE</code> then Janes et al. (2014) defined the costs of event and treatment as:
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;"> Y=0 </td><td style="text-align: center;"> Y=1 </td>
</tr>
<tr>
 <td style="text-align: left;">
Z=0 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> <code class="reqn">C_Y</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Z=1 </td><td style="text-align: center;"> <code class="reqn">C_Z</code> </td><td style="text-align: center;"> <code class="reqn">C_Z+C_Y</code> 
</td>
</tr>

</table>

<p>When <code>toxRef==TRUE</code> it is defined as :
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;"> Y=0 </td><td style="text-align: center;"> Y=1 </td>
</tr>
<tr>
 <td style="text-align: left;">
Z=0 </td><td style="text-align: center;"> <code class="reqn">C_Z</code> </td><td style="text-align: center;"> <code class="reqn">C_Z+C_Y</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Z=1 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> <code class="reqn">C_Y</code> 
</td>
</tr>

</table>

<p>According to the value of <code>toxRef</code>, the r ratio is simply <code class="reqn">r=C_Z/C_Y</code>. The r ratio can also be indirectly specified by the absolute difference in risk of event between the two treatments above which a physician would recommend the use of the most harmful treatment. The inverse of the r ratio can also be interpreted as the number of patients for whom the physician is ready to give the most harmful treatment to prevent one additional case compared with the less harmful treatment.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>trtSelOptThresh</code>.
</p>


<h3>References </h3>

<p>Blangero, Y, Rabilloud, M, Ecochard, R, and Subtil, F. A Bayesian method to estimate the optimal threshold of a marker used to select patients' treatment. <em>Statistical Methods in Medical Research</em>. 2019.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulating data from four gaussian distributions, 
#with mean risks equal to 0.5 in each arm:
x0E &lt;- rnorm(250) # reference arm, event
x0Eb &lt;- rnorm(250, 2) # reference arm, no event
x1E &lt;- rnorm(250, 2) # innovative arm, event
x1Eb &lt;- rnorm(250) # innovative arm, no event

#When working with real data. You can check the randomization constraint using the 
#densCurves function:
densCurves(x0 = c(x0E, x0Eb), x1 = c(x1E, x1Eb), type = "treatment selection")

#You can also use the riskCurves function to know if low values of the marker are associated
#with a better response under the reference treatment or not:
library(mgcv)
riskCurves(x0E, x0Eb, x1E, x1Eb)

#Fit normal distributions on three groups. And let the last one (1E) be undefined (derived 
#indirectly using the randomization constraint):
fit0E &lt;- fit(x0E, "norm")
fit0Eb &lt;- fit(x0Eb, "norm")
fit1E &lt;- fit(x1E, "undefined")
fit1Eb &lt;- fit(x1Eb, "norm")

#Apply the main function to estimate the optimal threshold:
# first case: the mean risks of event in the two treatment arms are left unspecified (are 
# determined by the number of marker measurements in the fit0E, fi0Eb, fit1E, fit1Eb) 

res &lt;- trtSelThresh(fit0E, fit0Eb, fit1E, fit1Eb, 
                    lowRef = FALSE, toxRef = FALSE, r = 0.02, le.MCMC = 5000, plot = TRUE, 
                    progress.bar = "text")

# second case: the mean risks of event in the two treatment arms are given through mcmc.lists 
# that correspond to their posterior distributions (see the fit man page for examples on how
# to generate posterior distributions manually)

#You can summarize the results using the summary() function:
summary(res, method = "median")

#You can extract the estimates and CI bounds of each indicator presented in the summary:
estimates(res, method = "median")
credibleIntervals(res)

#Plot the decision curves (this function is time-consuming):
dCres &lt;- decisionCurve(res, r = seq(0, 0.2, length.out = 6))

#You can plot again the decision curves by applying the plot method to dCres, 
#this function is a lot faster than the previous one. It also has more options
#to customize the plot:
plot(dCres)
plot(dCres, which = 1)
plot(dCres, which = 2)

</code></pre>

<hr>
<h2 id='undefined-class'>An S4 class to represent an 'undefined' distribution.</h2><span id='topic+undefined-class'></span><span id='topic+undefined'></span>

<h3>Description</h3>

<p>This class allows to fit an undefined distribution on the marker values <code>x</code>.
</p>


<h3>Details</h3>

<p>This class is automatically created when the user applies the <code>fit</code> function with the argument <code>distr="undefined"</code>. You never have to create manually this class, it is created internally.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>a vector of marker values.</p>
</dd>
<dt><code>n</code></dt><dd><p>Length of x vector (including NA values). Numeric argument.</p>
</dd>
<dt><code>mcmc</code></dt><dd><p>This slot allows the main function to k,now whether an MCMC algorithm must be performed to sample the distribution parameters from their posterior distribution.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit</a></code> for more details on how to fit an undefined distribution.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
