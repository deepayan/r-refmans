<!DOCTYPE html><html><head><title>Help for package biplotEZ</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {biplotEZ}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alpha.bags'><p>Create alpha bags</p></a></li>
<li><a href='#AoD'><p>Use the Analysis of Distance (AoD) method to construct the biplot</p></a></li>
<li><a href='#AoD.biplot'><p>Calculate elements for the Analysis of Distance (AoD) biplot</p></a></li>
<li><a href='#axes'><p>Aesthetics for biplot axes</p></a></li>
<li><a href='#biplot'><p>First step to create a new biplot with <span class="pkg">biplotEZ</span></p></a></li>
<li><a href='#biplotEZ'><p>biplotEZ: EZ-to-Use Biplots</p></a></li>
<li><a href='#CA'><p>Correspondence Analysis (CA) method</p></a></li>
<li><a href='#CA.biplot'><p>CA biplot</p></a></li>
<li><a href='#CATPCA'><p>Categorical Principal Component Analysis</p></a></li>
<li><a href='#classification'><p>Classification biplot method</p></a></li>
<li><a href='#classification.biplot'><p>classification biplot</p></a></li>
<li><a href='#classify'><p>Classify samples into classes</p></a></li>
<li><a href='#CVA'><p>Perform Canonical Variate Analysis (CVA)</p></a></li>
<li><a href='#CVA.biplot'><p>Calculate elements for the CVA biplot</p></a></li>
<li><a href='#CVAlowdim'><p>Construct additional dimensions when the dimension of the canonical space is smaller than the dimension of the biplot</p></a></li>
<li><a href='#density1D'><p>Creates a kernel density in 1-dimension</p></a></li>
<li><a href='#density2D'><p>Create a density in 2-dimensions</p></a></li>
<li><a href='#ellipses'><p>Concentration ellipses (<code class="reqn">\kappa</code>-ellipses)</p></a></li>
<li><a href='#extended.matching.coefficient'><p>Extended matching coefficient</p></a></li>
<li><a href='#fit.measures'><p>Compute measures of fit for the biplot.</p></a></li>
<li><a href='#interpolate'><p>Interpolate supplementary points and variables to add to the biplot</p></a></li>
<li><a href='#legend.type'><p>Format the legend for the biplot</p></a></li>
<li><a href='#means'><p>Aesthetics for biplot class / group means</p></a></li>
<li><a href='#newaxes'><p>Aesthetics for supplementary (new) biplot axes</p></a></li>
<li><a href='#newsamples'><p>Aesthetics for supplementary (new) biplot samples</p></a></li>
<li><a href='#PCA'><p>Perform Principal Components Analysis (PCA)</p></a></li>
<li><a href='#PCA.biplot'><p>Calculate elements for the PCA biplot</p></a></li>
<li><a href='#PCO'><p>Principal Coordinate Analysis (PCO) biplot method</p></a></li>
<li><a href='#PCO.biplot'><p>PCO biplot</p></a></li>
<li><a href='#plot.biplot'><p>Generic Plotting function of objects of class biplot</p></a></li>
<li><a href='#plot3D'><p>Generic Plotting function of objects of class biplot in three dimensions</p></a></li>
<li><a href='#prediction'><p>Predict samples to display on the biplot</p></a></li>
<li><a href='#print.biplot'><p>Generic print function for objects of class biplot</p></a></li>
<li><a href='#print.CA'><p>Generic print function of objects of class CA</p></a></li>
<li><a href='#reflect'><p>Reflect the biplot about a chosen axis</p></a></li>
<li><a href='#regress'><p>Regression biplot method</p></a></li>
<li><a href='#regress.biplot'><p>Regression biplot</p></a></li>
<li><a href='#rotate'><p>Rotate the biplot a chosen amount of degrees</p></a></li>
<li><a href='#samples'><p>Aesthetics for biplot samples</p></a></li>
<li><a href='#sqrtManhattan'><p>Computes the square root of the Manhattan distance</p>
An example of a Euclidean embeddable distance metric</a></li>
<li><a href='#summary.biplot'><p>Generic summary function for objects of class biplot</p></a></li>
<li><a href='#translate_axes'><p>Translate biplot axes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>EZ-to-Use Biplots</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides users with an EZ-to-use platform for representing data
             with biplots. Currently principal component analysis (PCA) and canonical variate
             analysis (CVA) biplots are included. This is accompanied by various formatting
             options for the samples and axes. Alpha-bags and concentration ellipses
             are included for visual enhancements and interpretation. For an extensive
             discussion on the topic, see Gower, J.C., Lubbe, S. and le Roux, N.J.
             (2011, ISBN: 978-0-470-01255-0) Understanding Biplots. Wiley: Chichester.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>caret, cluster, geometry, ggplot2, ggrepel, grid, knitr,
MASS, rgl, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, plotrix, splines, stats, withr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-08 09:35:24 UTC; Sugnet</td>
</tr>
<tr>
<td>Author:</td>
<td>Sugnet Lubbe <a href="https://orcid.org/0000-0003-2762-9944"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Niël le Roux <a href="https://orcid.org/0000-0002-1791-746X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Johané Nienkemper-Swanepoel
    <a href="https://orcid.org/0000-0001-6086-8272"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Raeesa Ganey <a href="https://orcid.org/0009-0008-6973-0999"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Ruan Buys <a href="https://orcid.org/0000-0001-8527-8631"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Zoë-Mae Adams <a href="https://orcid.org/0000-0003-3730-4887"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Peter Manefeldt <a href="https://orcid.org/0000-0002-8604-843X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sugnet Lubbe &lt;muvisu@sun.ac.za&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-08 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alpha.bags'>Create alpha bags</h2><span id='topic+alpha.bags'></span>

<h3>Description</h3>

<p>This function produces <code class="reqn">\alpha</code>-bags, which is a useful graphical summary of the
scatter plot. The alpha-bag refers to a contour which contains <code class="reqn">\alpha</code>% of the observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha.bags(bp, alpha = 0.95, which = NULL, col = ez.col[which], lty = 1,
lwd = 1, max = 2500, trace = TRUE, opacity = 0.25, outlying=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha.bags_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code>.</p>
</td></tr>
<tr><td><code id="alpha.bags_+3A_alpha">alpha</code></td>
<td>
<p>numeric vector between 0 and 1 to determine coverage of the bag (<code class="reqn">\alpha</code>), with default <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="alpha.bags_+3A_which">which</code></td>
<td>
<p>numeric vector indicating the selection of groups or classes to be fitted with <code class="reqn">\alpha</code>-bags.</p>
</td></tr>
<tr><td><code id="alpha.bags_+3A_col">col</code></td>
<td>
<p>vector of colours for the <code class="reqn">\alpha</code>-bags. Multiple <code class="reqn">\alpha</code> bags for one group will be displayed in the same colour.</p>
</td></tr>
<tr><td><code id="alpha.bags_+3A_lty">lty</code></td>
<td>
<p>vector of line types for the <code class="reqn">\alpha</code>-bags. The same line type will be used per value of <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="alpha.bags_+3A_lwd">lwd</code></td>
<td>
<p>vector of line widths for the <code class="reqn">\alpha</code>-bags. The same line width will be used per value of <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="alpha.bags_+3A_max">max</code></td>
<td>
<p>maximum number of samples to include in <code class="reqn">\alpha</code>-bag calculations, with default 2500. If
more samples are in the group, a random sample of size max is taken for the computations.</p>
</td></tr>
<tr><td><code id="alpha.bags_+3A_trace">trace</code></td>
<td>
<p>logical, indicating progress of computation.</p>
</td></tr>
<tr><td><code id="alpha.bags_+3A_opacity">opacity</code></td>
<td>
<p>level of opacity, with default <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="alpha.bags_+3A_outlying">outlying</code></td>
<td>
<p>logical indicating whether only outlying points should be plotted. Note the <code>which</code> argument may be overwritten when <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components is available:
</p>
<table>
<tr><td><code>alpha.bags</code></td>
<td>
<p>list of coordinates for the <code class="reqn">\alpha</code>-bags for each group.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>vector of colours for the <code class="reqn">\alpha</code>-bags.</p>
</td></tr>
<tr><td><code>lty</code></td>
<td>
<p>vector of line types for the <code class="reqn">\alpha</code>-bags.</p>
</td></tr>
<tr><td><code>lwd</code></td>
<td>
<p>vector of line widths for the <code class="reqn">\alpha</code>-bags.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gower, J., Gardner-Lubbe, S. &amp; Le Roux, N. (2011, ISBN: 978-0-470-01255-0) <em>Understanding Biplots.</em> Chichester, England: John Wiley &amp; Sons Ltd.<br><br>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot (iris[,1:4]) |&gt; PCA(group.aes=iris[,5]) |&gt; alpha.bags(alpha=0.95) |&gt; plot()
biplot (iris[,1:4],group.aes=iris[,5]) |&gt; PCA() |&gt; alpha.bags(alpha=0.95) |&gt; plot()

</code></pre>

<hr>
<h2 id='AoD'>Use the Analysis of Distance (AoD) method to construct the biplot</h2><span id='topic+AoD'></span>

<h3>Description</h3>

<p>This function appends the <code>biplot</code> object with elements resulting from using the AoD method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AoD(bp, classes=bp$classes, Dmat=NULL, dist.func=NULL,
dim.biplot = c(2,1,3), e.vects = 1:ncol(bp$X), 
weighted = c("unweighted","weighted"), show.class.means = TRUE, 
axes = c("regression","splines"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AoD_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="AoD_+3A_classes">classes</code></td>
<td>
<p>a vector of the same length as the number of rows in the data matrix with the class indicator for the samples.</p>
</td></tr>
<tr><td><code id="AoD_+3A_dmat">Dmat</code></td>
<td>
<p>the matrix of Euclidean embeddable distances between samples.</p>
</td></tr>
<tr><td><code id="AoD_+3A_dist.func">dist.func</code></td>
<td>
<p>a character string indicating which distance function is used to compute the Euclidean embeddable distances between samples. One of <code>NULL</code> (default) which computes the Euclidean distance or other functions that can be used for the <code>dist()</code> function.</p>
</td></tr>
<tr><td><code id="AoD_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>the dimension of the biplot. Only values <code>1</code>, <code>2</code> and <code>3</code> are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="AoD_+3A_e.vects">e.vects</code></td>
<td>
<p>the vector indicating which eigenvectors (canonical variates) should be plotted in the biplot, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="AoD_+3A_weighted">weighted</code></td>
<td>
<p>a character string indicating the weighting of the classes. One of &quot;<code>unweighted</code>&quot; for each class to receive equal weighting or &quot;<code>weighted</code>&quot; for each class to receive their class sizes as weights.</p>
</td></tr>
<tr><td><code id="AoD_+3A_show.class.means">show.class.means</code></td>
<td>
<p>a logical value indicating whether to plot the class means on the biplot.</p>
</td></tr>
<tr><td><code id="AoD_+3A_axes">axes</code></td>
<td>
<p>a character string indicating the type of biplot axes to be used in the biplot. One of <code>"regression"</code> or <code>"splines"</code>.</p>
</td></tr>
<tr><td><code id="AoD_+3A_...">...</code></td>
<td>
<p>more arguments to <code>dist.func</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>biplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4]) |&gt; AoD(classes=iris[,5])
# create a CVA biplot
biplot(iris[,1:4]) |&gt; AoD(classes=iris[,5]) |&gt; plot()

</code></pre>

<hr>
<h2 id='AoD.biplot'>Calculate elements for the Analysis of Distance (AoD) biplot</h2><span id='topic+AoD.biplot'></span>

<h3>Description</h3>

<p>This function is used to construct the AoD biplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biplot'
AoD(
  bp,
  classes = bp$classes,
  Dmat = NULL,
  dist.func = NULL,
  dim.biplot = c(2, 1, 3),
  e.vects = 1:ncol(bp$X),
  weighted = c("unweighted", "weighted"),
  show.class.means = TRUE,
  axes = c("regression", "splines"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AoD.biplot_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="AoD.biplot_+3A_classes">classes</code></td>
<td>
<p>a vector of the same length as the number of rows in the data matrix with the class indicator for the samples.</p>
</td></tr>
<tr><td><code id="AoD.biplot_+3A_dmat">Dmat</code></td>
<td>
<p>the matrix of Euclidean embeddable distances between samples.</p>
</td></tr>
<tr><td><code id="AoD.biplot_+3A_dist.func">dist.func</code></td>
<td>
<p>a character string indicating which distance function is used to compute the Euclidean embeddable distances between samples. One of <code>NULL</code> (default) which computes the Euclidean distance or other functions that can be used for the <code>dist()</code> function.</p>
</td></tr>
<tr><td><code id="AoD.biplot_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>the dimension of the biplot. Only values <code>1</code>, <code>2</code> and <code>3</code> are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="AoD.biplot_+3A_e.vects">e.vects</code></td>
<td>
<p>the vector indicating which eigenvectors (canonical variates) should be plotted in the biplot, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="AoD.biplot_+3A_weighted">weighted</code></td>
<td>
<p>a character string indicating the weighting of the classes. One of &quot;<code>unweighted</code>&quot; for each class to receive equal weighting or &quot;<code>weighted</code>&quot; for each class to receive their class sizes as weights.</p>
</td></tr>
<tr><td><code id="AoD.biplot_+3A_show.class.means">show.class.means</code></td>
<td>
<p>a logical value indicating whether to plot the class means on the biplot.</p>
</td></tr>
<tr><td><code id="AoD.biplot_+3A_axes">axes</code></td>
<td>
<p>a character string indicating the type of biplot axes to be used in the biplot. One of <code>"regression"</code> or <code>"splines"</code>.</p>
</td></tr>
<tr><td><code id="AoD.biplot_+3A_...">...</code></td>
<td>
<p>more arguments to <code>dist.func</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>biplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris) |&gt; AoD(classes = iris[,5]) |&gt; plot()

</code></pre>

<hr>
<h2 id='axes'>Aesthetics for biplot axes</h2><span id='topic+axes'></span>

<h3>Description</h3>

<p>This function allows formatting changes to axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axes(bp, X.names=colnames(bp$X), which = 1:bp$p, col = grey(0.7), lwd = 1, lty = 1,
label.dir = "Orthog", label.col = col, label.cex = 0.75, label.line = 0.1, 
label.offset=rep(0,4), ticks = 5, tick.col = col, tick.size = 1, tick.label = TRUE, 
tick.label.side = "below", tick.label.col = tick.col, tick.label.cex = 0.6,
predict.col = col, predict.lwd = lwd, predict.lty = lty, ax.names = X.names,
orthogx = 0, orthogy = 0, vectors = FALSE, unit.circle=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axes_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_x.names">X.names</code></td>
<td>
<p>refers to the column names of <code>bp</code> to specify which axes to label.</p>
</td></tr>
<tr><td><code id="axes_+3A_which">which</code></td>
<td>
<p>integer-valued vector specifying which biplot axes are shown
in a biplot. By default all p biplot axes are shown.</p>
</td></tr>
<tr><td><code id="axes_+3A_col">col</code></td>
<td>
<p>vector of size p specifying colours of labels of biplot axes. The default is <code>grey(0.7)</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_lwd">lwd</code></td>
<td>
<p>axis line width, with default <code>1</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_lty">lty</code></td>
<td>
<p>axis line type, with default <code>1</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_label.dir">label.dir</code></td>
<td>
<p>One of &quot;Orthog&quot; (default), &quot;Hor&quot; or &quot;Paral&quot; specifying titles of
axes to appear orthogonal to the side of the figure; always
horizontally or always parallel to the side of the figure.</p>
</td></tr>
<tr><td><code id="axes_+3A_label.col">label.col</code></td>
<td>
<p>axis label colour, with default, <code>col</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_label.cex">label.cex</code></td>
<td>
<p>axis label expansion, with default <code>0.75</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_label.line">label.line</code></td>
<td>
<p>axis label written on which margin line, with default <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_label.offset">label.offset</code></td>
<td>
<p>A four-component numeric vector controlling the distance a
biplot axis title is printed from the side of the figure. Sides are
numbered 1 to 4 according to R conventions clockwise starting
from the bottom horizontal side. Default is rep(0,4)</p>
</td></tr>
<tr><td><code id="axes_+3A_ticks">ticks</code></td>
<td>
<p>integer-valued vector of size equal to the number of biplot axes
to control the number of tickmarks on each individual biplot
axis. Default is 5 for each axis.</p>
</td></tr>
<tr><td><code id="axes_+3A_tick.col">tick.col</code></td>
<td>
<p>tick mark colour, with default <code>col</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_tick.size">tick.size</code></td>
<td>
<p>positive integer-valued vector with specifying tick mark sizes, with default <code>1</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_tick.label">tick.label</code></td>
<td>
<p>logical, whether axes should be labelled or not, with default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_tick.label.side">tick.label.side</code></td>
<td>
<p>character vector specifying position of the tick label &quot;below&quot; or &quot;above&quot; the axis.</p>
</td></tr>
<tr><td><code id="axes_+3A_tick.label.col">tick.label.col</code></td>
<td>
<p>tick mark label colour, with default <code>tick.col</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_tick.label.cex">tick.label.cex</code></td>
<td>
<p>tick mark label expansion, with default <code>0.6</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_predict.col">predict.col</code></td>
<td>
<p>predicted samples colour, with default <code>col</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_predict.lwd">predict.lwd</code></td>
<td>
<p>predicted samples line width, with default <code>lwd</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_predict.lty">predict.lty</code></td>
<td>
<p>predicted samples line type, with default <code>lty</code>.</p>
</td></tr>
<tr><td><code id="axes_+3A_ax.names">ax.names</code></td>
<td>
<p>vector of size <code>p</code> containing user defined names for the variables.</p>
</td></tr>
<tr><td><code id="axes_+3A_orthogx">orthogx</code></td>
<td>
<p>numeric vector of size p specifying the x-coordinate of the parallel transformation of each axis.
Defaults to zero for each axis. Only used when the dimension of the biplot is two.</p>
</td></tr>
<tr><td><code id="axes_+3A_orthogy">orthogy</code></td>
<td>
<p>numeric vector of size p specifying the y-coordinate of the parallel transformation of each axis.
Defaults to zero for each axis. Only used when the dimension of the biplot is two.</p>
</td></tr>
<tr><td><code id="axes_+3A_vectors">vectors</code></td>
<td>
<p>logical, whether calibrated axes should be displayed on the biplot</p>
</td></tr>
<tr><td><code id="axes_+3A_unit.circle">unit.circle</code></td>
<td>
<p>logical, whether a unit circle should be displayed on the biplot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components is available:
</p>
<table>
<tr><td><code>which</code></td>
<td>
<p>vector of the columns displayed as axes.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>vector of axis colours.</p>
</td></tr>
<tr><td><code>lwd</code></td>
<td>
<p>vector of axis line widths.</p>
</td></tr>
<tr><td><code>lty</code></td>
<td>
<p>vector of axis line types.</p>
</td></tr>
<tr><td><code>label.dir</code></td>
<td>
<p>direction of the axis labels.</p>
</td></tr>
<tr><td><code>label.col</code></td>
<td>
<p>vector of axis label colours.</p>
</td></tr>
<tr><td><code>label.cex</code></td>
<td>
<p>vector of axis labels expansions.</p>
</td></tr>
<tr><td><code>label.line</code></td>
<td>
<p>vector of axis label margin lines from axes.</p>
</td></tr>
<tr><td><code>ticks</code></td>
<td>
<p>vector representing the number of tick marks per axis.</p>
</td></tr>
<tr><td><code>tick.col</code></td>
<td>
<p>vector of tick mark colours.</p>
</td></tr>
<tr><td><code>tick.size</code></td>
<td>
<p>vector of tick mark sizes.</p>
</td></tr>
<tr><td><code>tick.label</code></td>
<td>
<p>vector of logical values indicating whether axes are labelled.</p>
</td></tr>
<tr><td><code>tick.label.side</code></td>
<td>
<p>vector specifying position of the tick label &quot;below&quot; or &quot;above&quot; the axis.</p>
</td></tr>
<tr><td><code>tick.label.col</code></td>
<td>
<p>vector of tick mark label colours.</p>
</td></tr>
<tr><td><code>tick.label.cex</code></td>
<td>
<p>vector of tick mark label expansions.</p>
</td></tr>
<tr><td><code>predict.col</code></td>
<td>
<p>vector of colours for the predicted samples.</p>
</td></tr>
<tr><td><code>predict.lty</code></td>
<td>
<p>vector of line types for the predicted samples.</p>
</td></tr>
<tr><td><code>predict.lwd</code></td>
<td>
<p>vector of line widths for the predicted samples.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>vector of variable names defined by the user.</p>
</td></tr>
<tr><td><code>orthogx</code></td>
<td>
<p>vector of the horisontal translations for each axis.</p>
</td></tr>
<tr><td><code>orthogy</code></td>
<td>
<p>vector of the vertical translations for each axis.</p>
</td></tr>
<tr><td><code>calibrated.axis</code></td>
<td>
<p>whether to plot calibrated axis</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4]) |&gt; PCA() |&gt; axes(col="purple") |&gt; plot()
biplot(iris[,1:4]) |&gt; PCA() |&gt; samples(col="purple",pch=15) |&gt; axes() |&gt; plot()

</code></pre>

<hr>
<h2 id='biplot'>First step to create a new biplot with <span class="pkg">biplotEZ</span></h2><span id='topic+biplot'></span>

<h3>Description</h3>

<p>This function produces a list of elements to be used when producing a biplot,
which provides a useful data analysis tool and allows the visual appraisal
of the structure of large data matrices. Biplots are the
multivariate analogue of scatter plots. They approximate the multivariate
distribution of a sample in a few dimensions and they superimpose on this
display representations of the variables on which the samples are measured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biplot(data, classes = NULL, group.aes = NULL, center = TRUE, scaled = FALSE,
Title = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biplot_+3A_data">data</code></td>
<td>
<p>a data frame or numeric matrix containing all variables the user wants to analyse.</p>
</td></tr>
<tr><td><code id="biplot_+3A_classes">classes</code></td>
<td>
<p>a vector identifying class membership.</p>
</td></tr>
<tr><td><code id="biplot_+3A_group.aes">group.aes</code></td>
<td>
<p>a vector identifying groups for aesthetic formatting.</p>
</td></tr>
<tr><td><code id="biplot_+3A_center">center</code></td>
<td>
<p>a logical value indicating whether <code>data</code> should be column centered, with default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="biplot_+3A_scaled">scaled</code></td>
<td>
<p>a logical value indicating whether <code>data</code> should be standardised to unit column variances, with default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="biplot_+3A_title">Title</code></td>
<td>
<p>the title of the biplot to be rendered, enter text in &quot;  &quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the entry-level function in <code>biplotEZ</code> to construct a biplot display.
It initialises an object of class <code>biplot</code> which can then be piped to various other functions
to build up the biplot display.
</p>


<h3>Value</h3>

<p>A list with the following components is available:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>the matrix of the centered and scaled numeric variables.</p>
</td></tr>
<tr><td><code>Xcat</code></td>
<td>
<p>the data frame of the categorical variables.</p>
</td></tr>
<tr><td><code>raw.X</code></td>
<td>
<p>the original data.</p>
</td></tr>
<tr><td><code>classes</code></td>
<td>
<p>the vector of category levels for the class variable. This is to be used for <code>colour</code>, <code>pch</code> and <code>cex</code> specifications.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>the vector of observations that have been removed.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>a logical value indicating whether <code class="reqn">\mathbf{X}</code> is centered.</p>
</td></tr>
<tr><td><code>scaled</code></td>
<td>
<p>a logical value indicating whether <code class="reqn">\mathbf{X}</code> is scaled.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>the vector of means for each numeric variable.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the vector of standard deviations for each numeric variable.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the number of variables.</p>
</td></tr>
<tr><td><code>group.aes</code></td>
<td>
<p>the vector of category levels for the grouping variable. This is to be used for <code>colour</code>, <code>pch</code> and <code>cex</code> specifications.</p>
</td></tr>
<tr><td><code>g.names</code></td>
<td>
<p>the descriptive names to be used for group labels.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>the number of groups.</p>
</td></tr>
<tr><td><code>Title</code></td>
<td>
<p>the title of the biplot rendered</p>
</td></tr>
</table>


<h3>Useful links</h3>

<p>The biplot display can be built up in four broad steps depending on the needs for the display.
Firstly, choose an appropriate method to construct the display;
Secondly, change the aesthetics of the display;
Thirdly, append the display with supplementary features such as axes, samples and means;
Finally, superimpose shapes, characters or elements onto the display.
</p>
<p><strong>1. Different types of biplots:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+PCA">PCA()</a></code>: Principal Component Analysis biplot of various dimensions
</p>
</li>
<li> <p><code><a href="#topic+CVA">CVA()</a></code>: Canonical Variate Analysis biplot
</p>
</li>
<li> <p><code><a href="#topic+PCO">PCO()</a></code>: Principal Coordinate Analysis biplot
</p>
</li>
<li> <p><code><a href="#topic+CA">CA()</a></code>: Correspondence Analysis biplot
</p>
</li>
<li> <p><code><a href="#topic+regress">regress()</a></code>: Regression biplot method
</p>
</li></ul>

<p><strong>2. Customise the biplot display with aesthetic functions:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+samples">samples()</a></code>: Change the formatting of sample points on the biplot display
</p>
</li>
<li> <p><code><a href="#topic+axes">axes()</a></code>: Change the formatting of the biplot axes
</p>
</li></ul>

<p><strong>3. Supplement the existing biplot with additional axes, samples and group means:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+newsamples">newsamples()</a></code>: Add and change formatting of additional samples
</p>
</li>
<li> <p><code><a href="#topic+newaxes">newaxes()</a></code>: Add and change formatting of additional axes
</p>
</li>
<li> <p><code><a href="#topic+means">means()</a></code>: Insert class means to the display, and format appropriately
</p>
</li></ul>

<p><strong>4. Append the biplot display:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+alpha.bags">alpha.bags()</a></code>: Add <code class="reqn">\alpha</code>-bags
</p>
</li>
<li> <p><code><a href="#topic+ellipses">ellipses()</a></code>: Add ellipses
</p>
</li>
<li> <p><code><a href="#topic+density2D">density2D()</a></code>: Add 2D density regions
</p>
</li></ul>

<p><strong>Other useful links:</strong>
</p>

<ul>
<li> <p><code><a href="base.html#topic+plot">plot()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+fit.measures">fit.measures()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+legend.type">legend.type()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+interpolate">interpolate()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+prediction">prediction()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+classify">classify()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+reflect">reflect()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+rotate">rotate()</a></code>
</p>
</li></ul>



<h3>References</h3>

<p>Gabriel, K.R. (1971) The biplot graphic display of matrices with application to principal component analysis. <em>Biometrika.</em> 58(3):453–467.<br><br>
Gower, J., Gardner-Lubbe, S. &amp; Le Roux, N. (2011, ISBN: 978-0-470-01255-0) <em>Understanding Biplots.</em> Chichester, England: John Wiley &amp; Sons Ltd.<br><br>
Gower, J.C. &amp; Hand, D.J.(1996, ISBN: 0-412-71630-5) <em>Biplots.</em> London: Chapman &amp; Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(data = iris)
# create a PCA biplot
biplot(data = iris) |&gt; PCA() |&gt; plot()

</code></pre>

<hr>
<h2 id='biplotEZ'>biplotEZ: EZ-to-Use Biplots</h2><span id='topic+biplotEZ'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>


<h3>Details</h3>

<p>The goal of biplotEZ is to provide users an EZ-to-use platform for visually representing
their data with biplots. Currently, this package includes principal component analysis
(PCA) and canonical variate analysis (CVA) biplots. This is accompanied by various
formatting options for the samples and axes. Alpha-bags and concentration ellipses are
included for visual enhancements and interpretation.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> biplotEZ </td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 05-04-2024</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> MIT </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>


<ul>
<li><p>Sugnet Lubbe (Maintainer, muvisu@sun.ac.za)
</p>
</li>
<li><p>Niël le Roux
</p>
</li>
<li><p>Johané Nienkemper-Swanepoel
</p>
</li>
<li><p>Raeesa Ganey
</p>
</li>
<li><p>Ruan Buys
</p>
</li>
<li><p>Zoë-Mae Adams
</p>
</li>
<li><p>Peter Manefeldt
</p>
</li></ul>



<h3>Core Functions</h3>


<ul>
<li><p><a href="#topic+biplot">biplot</a>
</p>
</li>
<li><p><a href="#topic+PCA">PCA</a>
</p>
</li>
<li><p><a href="#topic+CVA">CVA</a>
</p>
</li>
<li><p><a href="#topic+CA">CA</a>
</p>
</li></ul>



<h3>Code Availability</h3>

<p>The newest version of the package can be obtained on
GitHub: <a href="https://github.com/MuViSU/biplotEZ">https://github.com/MuViSU/biplotEZ</a>
</p>

<hr>
<h2 id='CA'>Correspondence Analysis (CA) method</h2><span id='topic+CA'></span>

<h3>Description</h3>

<p>This function produces a list of elements to be used for CA biplot construction by approximation of the Pearson residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CA(bp, dim.biplot = c(2,1,3), e.vects = 1:ncol(bp$X), variant = "Princ", 
lambda.scal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CA_+3A_bp">bp</code></td>
<td>
<p>object of class <code>biplot</code> obtained from preceding function <code>biplot(center = FALSE)</code>. In order to maintain the frequency table, the input should not be centered or scaled. For <code>CA</code>, <code>bp</code> should be a contingency table.</p>
</td></tr>
<tr><td><code id="CA_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>dimension of the biplot. Only values 1, 2 and 3 are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="CA_+3A_e.vects">e.vects</code></td>
<td>
<p>which eigenvectors (canonical variates) to extract, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="CA_+3A_variant">variant</code></td>
<td>
<p>which correspondence analysis variant, with default &quot;Princ&quot;, presents a biplot with rows in principal coordinates
and columns in standard coordinates. <code>variant = "Stand"</code>, presents a biplot with rows in standard coordinates and columns in
principal coordinates. <code>variant = "symmetric"</code>, presents a symmetric biplot with row and column standard coordinates scaled
equally by the singular values.</p>
</td></tr>
<tr><td><code id="CA_+3A_lambda.scal">lambda.scal</code></td>
<td>
<p>logical value to request lambda-scaling, default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components is available:
</p>
<table>
<tr><td><code>Z</code></td>
<td>
<p>Combined data frame of the row and column coordinates.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Numer of levels in the row factor.</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>Numer of levels in the column factor.</p>
</td></tr>
<tr><td><code>rowcoor</code></td>
<td>
<p>Row coordinates based on the selected <code>variant</code>.</p>
</td></tr>
<tr><td><code>colcoor</code></td>
<td>
<p>Column coordinates based on the selected <code>variant</code>.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>Correspondence Matrix</p>
</td></tr>
<tr><td><code>Smat</code></td>
<td>
<p>Standardised Pearson residuals.</p>
</td></tr>
<tr><td><code>SVD</code></td>
<td>
<p>Singular value decomposition solution: <code>d, u, v</code>.</p>
</td></tr>
<tr><td><code>qual</code></td>
<td>
<p>Quality of the approximation.</p>
</td></tr>
<tr><td><code>lambda.val</code></td>
<td>
<p>The computed lambda value if lambda-scaling is requested.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a CA biplot with rows in principal coordinates:
biplot(HairEyeColor[,,2], center = FALSE) |&gt; CA() |&gt; plot()
# Creating a CA biplot with rows in standard coordinates:
biplot(HairEyeColor[,,2], center = FALSE) |&gt; CA(variant = "Stand") |&gt; 
samples(col=c("magenta","purple"), pch=c(15,17), label.col="black") |&gt; plot()
# Creating a CA biplot with rows and columns scaled equally:
biplot(HairEyeColor[,,2], center = FALSE) |&gt; CA(variant = "Symmetric") |&gt; 
samples(col=c("magenta","purple"), pch=c(15,17), label.col="black") |&gt; plot()
</code></pre>

<hr>
<h2 id='CA.biplot'>CA biplot</h2><span id='topic+CA.biplot'></span>

<h3>Description</h3>

<p>Performs calculations for a CA biplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biplot'
CA(
  bp,
  dim.biplot = c(2, 1, 3),
  e.vects = 1:ncol(bp$X),
  variant = "Princ",
  lambda.scal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CA.biplot_+3A_bp">bp</code></td>
<td>
<p>object of class <code>biplot</code> obtained from preceding function <code>biplot(center = FALSE)</code>. In order to maintain the frequency table, the input should not be centered or scaled. For <code>CA</code>, <code>bp</code> should be a contingency table.</p>
</td></tr>
<tr><td><code id="CA.biplot_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>dimension of the biplot. Only values 1, 2 and 3 are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="CA.biplot_+3A_e.vects">e.vects</code></td>
<td>
<p>which eigenvectors (canonical variates) to extract, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="CA.biplot_+3A_variant">variant</code></td>
<td>
<p>which correspondence analysis variant, with default &quot;Princ&quot;, presents a biplot with rows in principal coordinates
and columns in standard coordinates. <code>variant = "Stand"</code>, presents a biplot with rows in standard coordinates and columns in
principal coordinates. <code>variant = "symmetric"</code>, presents a symmetric biplot with row and column standard coordinates scaled
equally by the singular values.</p>
</td></tr>
<tr><td><code id="CA.biplot_+3A_lambda.scal">lambda.scal</code></td>
<td>
<p>logical value to request lambda-scaling, default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class CA, inherits from class biplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(HairEyeColor[,,2], center = FALSE) |&gt; CA() |&gt; plot()

</code></pre>

<hr>
<h2 id='CATPCA'>Categorical Principal Component Analysis</h2><span id='topic+CATPCA'></span>

<h3>Description</h3>

<p>Categorical Principal Component Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CATPCA(bp, dim.biplot = c(2, 1, 3), e.vects = 1:ncol(bp$X),
group.aes = NULL, show.class.means = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CATPCA_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="CATPCA_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>dimension of the biplot. Only values 1, 2 and 3 are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="CATPCA_+3A_e.vects">e.vects</code></td>
<td>
<p>which eigenvectors (principal components) to extract, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="CATPCA_+3A_group.aes">group.aes</code></td>
<td>
<p>vector of the same length as the number of rows in the data matrix
for differentiated aesthetics for samples.</p>
</td></tr>
<tr><td><code id="CATPCA_+3A_show.class.means">show.class.means</code></td>
<td>
<p>logical, indicating whether group means should be plotted in the biplot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>biplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CATPCA (iris)
</code></pre>

<hr>
<h2 id='classification'>Classification biplot method</h2><span id='topic+classification'></span>

<h3>Description</h3>

<p>This function produces a list of elements to be used for constructing a classification biplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classification(bp, Pmat, dim.biplot = c(2, 1, 3), e.vects = 1:ncol(bp$X),
group.aes=NULL, axes = "regression", col=ez.col, opacity=0.4, borders = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classification_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="classification_+3A_pmat">Pmat</code></td>
<td>
<p>a matrix containing the posterior probability for the classes</p>
</td></tr>
<tr><td><code id="classification_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>dimension of the biplot. Only values 1, 2 and 3 are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="classification_+3A_e.vects">e.vects</code></td>
<td>
<p>which eigenvectors (principal components) to extract, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="classification_+3A_group.aes">group.aes</code></td>
<td>
<p>vector of the same length as the number of rows in the data matrix
for differentiated aesthetics for samples.</p>
</td></tr>
<tr><td><code id="classification_+3A_axes">axes</code></td>
<td>
<p>type of axes, defaults to &quot;regression&quot;</p>
</td></tr>
<tr><td><code id="classification_+3A_col">col</code></td>
<td>
<p>colour of the classification regions</p>
</td></tr>
<tr><td><code id="classification_+3A_opacity">opacity</code></td>
<td>
<p>opacity of classification regions</p>
</td></tr>
<tr><td><code id="classification_+3A_borders">borders</code></td>
<td>
<p>logical, indicating whether borders should be added to classification regions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class biplot with the following elements:
</p>


<h3>References</h3>

<p>Gardner-Lubbe, S., 2016. A triplot for multiclass classification visualisation. <em>Computational Statistics &amp; Data Analysis</em>, 94, pp.20-32.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4]) |&gt; 
classification(predict(MASS::lda(Species ~ ., data = iris))$posterior)
# create a classification biplot
biplot(iris[,1:4]) |&gt; 
classification(predict(MASS::lda(Species ~ ., data = iris))$posterior) |&gt; 
plot()
</code></pre>

<hr>
<h2 id='classification.biplot'>classification biplot</h2><span id='topic+classification.biplot'></span>

<h3>Description</h3>

<p>Performs calculations for a classification biplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biplot'
classification(
  bp,
  Pmat,
  dim.biplot = c(2, 1, 3),
  e.vects = 1:ncol(bp$X),
  group.aes = NULL,
  axes = "regression",
  col = ez.col,
  opacity = 0.4,
  borders = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classification.biplot_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="classification.biplot_+3A_pmat">Pmat</code></td>
<td>
<p>a matrix containing the posterior probability for the classes</p>
</td></tr>
<tr><td><code id="classification.biplot_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>dimension of the biplot. Only values 1, 2 and 3 are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="classification.biplot_+3A_e.vects">e.vects</code></td>
<td>
<p>which eigenvectors (principal components) to extract, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="classification.biplot_+3A_group.aes">group.aes</code></td>
<td>
<p>vector of the same length as the number of rows in the data matrix
for differentiated aesthetics for samples.</p>
</td></tr>
<tr><td><code id="classification.biplot_+3A_axes">axes</code></td>
<td>
<p>type of axes, defaults to &quot;regression&quot;</p>
</td></tr>
<tr><td><code id="classification.biplot_+3A_col">col</code></td>
<td>
<p>colour of the classification regions</p>
</td></tr>
<tr><td><code id="classification.biplot_+3A_opacity">opacity</code></td>
<td>
<p>opacity of classification regions</p>
</td></tr>
<tr><td><code id="classification.biplot_+3A_borders">borders</code></td>
<td>
<p>logical, indicating whether borders should be added to classification regions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class biplot.
</p>

<hr>
<h2 id='classify'>Classify samples into classes</h2><span id='topic+classify'></span>

<h3>Description</h3>

<p>Classify samples into classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify(
  bp,
  classify.regions = TRUE,
  col = ez.col,
  opacity = 0.4,
  borders = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code></p>
</td></tr>
<tr><td><code id="classify_+3A_classify.regions">classify.regions</code></td>
<td>
<p>a logical value indicating whether classifications regions should be
shown in the biplot, with default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="classify_+3A_col">col</code></td>
<td>
<p>the colours of the classification regions</p>
</td></tr>
<tr><td><code id="classify_+3A_opacity">opacity</code></td>
<td>
<p>the opacity levels of the classification regions</p>
</td></tr>
<tr><td><code id="classify_+3A_borders">borders</code></td>
<td>
<p>the border colours of the classification regions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object called <code>classify</code> appended to the object of class <code>biplot</code> with the following elements:
</p>
<table>
<tr><td><code>table</code></td>
<td>
<p>the confusion matrix resulting from the classification into classes.</p>
</td></tr>
<tr><td><code>rate</code></td>
<td>
<p>the classification accuracy rate.</p>
</td></tr>
<tr><td><code>classify.regions</code></td>
<td>
<p>a logical value indicating whether classification regions are shown in the biplot.</p>
</td></tr>
<tr><td><code>aes</code></td>
<td>
<p>a list of chosen aesthetics for the colours, opacity levels and border colours of the classification regions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4],classes = iris[,5]) |&gt; CVA() |&gt; axes(col="black") |&gt; 
  classify(col=c("red","blue","orange"),opacity=0.1) |&gt; plot()
</code></pre>

<hr>
<h2 id='CVA'>Perform Canonical Variate Analysis (CVA)</h2><span id='topic+CVA'></span>

<h3>Description</h3>

<p>This function appends the <code>biplot</code> object with elements resulting from performing CVA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CVA(bp, classes=bp$classes, dim.biplot = c(2, 1, 3), e.vects = 1:ncol(bp$X),
           weightedCVA = "weighted", show.class.means = TRUE,
           low.dim = "sample.opt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CVA_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="CVA_+3A_classes">classes</code></td>
<td>
<p>a vector of the same length as the number of rows in the data matrix with the class indicator for the samples.</p>
</td></tr>
<tr><td><code id="CVA_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>the dimension of the biplot. Only values <code>1</code>, <code>2</code> and <code>3</code> are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="CVA_+3A_e.vects">e.vects</code></td>
<td>
<p>the vector indicating which eigenvectors (canonical variates) should be plotted in the biplot, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="CVA_+3A_weightedcva">weightedCVA</code></td>
<td>
<p>a character string indicating which type of CVA to perform. One of &quot;<code>weighted</code>&quot; (default) for a weighted CVA to be performed (The centring matrix will be a diagonal matrix with the class sizes (<code class="reqn">\mathbf{C} = \mathbf{N}</code>), &quot;<code>unweightedCent</code>&quot; for unweighted CVA to be performed (The centring matrix is the usual centring matrix (<code class="reqn">\mathbf{C} = \mathbf{I}_{G} - G^{-1}\mathbf{1}_{G}\mathbf{1}_{G}'</code>)) or &quot;<code>unweightedI</code>&quot; for unweighted CVA to be performed while retaining the weighted centroid (The centring matrix is an indicator matrix (<code class="reqn">\mathbf{C} = \mathbf{I}_{G}</code>)).</p>
</td></tr>
<tr><td><code id="CVA_+3A_show.class.means">show.class.means</code></td>
<td>
<p>a logical value indicating whether to plot the class means on the biplot.</p>
</td></tr>
<tr><td><code id="CVA_+3A_low.dim">low.dim</code></td>
<td>
<p>a character string indicating which method to use to construct additional dimension(s) if the dimension of the canonical space is smaller than <code>dim.biplot</code>. One of &quot;<code>sample.opt</code>&quot; (default) for maximising the sample predictivity of the individual samples in the biplot or &quot;<code>Bhattacharyya.dist</code>&quot; which is based on the decomposition of the Bhattacharyya distance into a component for the sample means and a component for the dissimilarity between the sample covariance matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class CVA with the following elements:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>the matrix of the centered and scaled numeric variables.</p>
</td></tr>
<tr><td><code>Xcat</code></td>
<td>
<p>the data frame of the categorical variables.</p>
</td></tr>
<tr><td><code>raw.X</code></td>
<td>
<p>the original data.</p>
</td></tr>
<tr><td><code>classes</code></td>
<td>
<p>the vector of category levels for the class variable. This is to be used for <code>colour</code>, <code>pch</code> and <code>cex</code> specifications.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>the vector of observations that have been removed.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>a logical value indicating whether <code class="reqn">\mathbf{X}</code> is centered.</p>
</td></tr>
<tr><td><code>scaled</code></td>
<td>
<p>a logical value indicating whether <code class="reqn">\mathbf{X}</code> is scaled.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>the vector of means for each numerical variable.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the vector of standard deviations for each numerical variable.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the number of variables.</p>
</td></tr>
<tr><td><code>group.aes</code></td>
<td>
<p>the vector of category levels for the grouping variable. This is to be used for <code>colour</code>, <code>pch</code> and <code>cex</code> specifications. </p>
</td></tr>
<tr><td><code>g.names</code></td>
<td>
<p>the descriptive names to be used for group labels.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>the number of groups.</p>
</td></tr>
<tr><td><code>Title</code></td>
<td>
<p>the title of the biplot rendered.</p>
</td></tr>
<tr><td><code>Lmat</code></td>
<td>
<p>the matrix for transformation to the canonical space.</p>
</td></tr>
<tr><td><code>Linv</code></td>
<td>
<p>the inverse of <code class="reqn">\mathbf{L}</code>.</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>the vector of eigenvalues of the two-sided eigenvalue problem.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>the matrix with each row containing the details of the points to be plotted (i.e. coordinates).</p>
</td></tr>
<tr><td><code>ax.one.unit</code></td>
<td>
<p>one unit in the positive direction of each biplot axis.</p>
</td></tr>
<tr><td><code>Gmat</code></td>
<td>
<p>the indicator matrix defining membership of the classes.</p>
</td></tr>
<tr><td><code>Xmeans</code></td>
<td>
<p>the matrix of the class means.</p>
</td></tr>
<tr><td><code>Zmeans</code></td>
<td>
<p>the matrix of the class mean coordinates that are plotted in the biplot.</p>
</td></tr>
<tr><td><code>e.vects</code></td>
<td>
<p>the vector indicating which canonical variates are plotted in the biplot.</p>
</td></tr>
<tr><td><code>Cmat</code></td>
<td>
<p>the centring matrix based on different choices of weighting described in arguments.</p>
</td></tr>
<tr><td><code>Bmat</code></td>
<td>
<p>the between class sums of squares and cross products matrix.</p>
</td></tr>
<tr><td><code>Wmat</code></td>
<td>
<p>the within class sums of squares and cross products matrix.</p>
</td></tr>
<tr><td><code>Mrr</code></td>
<td>
<p>the matrix used for prediction from the canonical space (the inverse of <code class="reqn">\mathbf{M}=\mathbf{LV})</code>.</p>
</td></tr>
<tr><td><code>Mr</code></td>
<td>
<p>the first r dimensions of the solution to be plotted.</p>
</td></tr>
<tr><td><code>Nmat</code></td>
<td>
<p>the matrix with the class sizes on the diagonal.</p>
</td></tr>
<tr><td><code>lambda.mat</code></td>
<td>
<p>the matrix with the eigenvalues of <code class="reqn">\mathbf{W}^{-1/2}\mathbf{BW}^{-1/2}</code> on the diagonal.</p>
</td></tr>
<tr><td><code>class.means</code></td>
<td>
<p>a logical value indicating whether the class means should be plotted in the biplot.</p>
</td></tr>
<tr><td><code>dim.biplot</code></td>
<td>
<p>the dimension of the biplot.</p>
</td></tr>
<tr><td><code>low.dim</code></td>
<td>
<p>the method used to construct additional dimension(s).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4]) |&gt; CVA(classes=iris[,5])
# create a CVA biplot
biplot(iris[,1:4]) |&gt; CVA(classes=iris[,5]) |&gt; plot()

</code></pre>

<hr>
<h2 id='CVA.biplot'>Calculate elements for the CVA biplot</h2><span id='topic+CVA.biplot'></span>

<h3>Description</h3>

<p>This function performs calculations for the construction of a CVA biplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biplot'
CVA(
  bp,
  classes = bp$classes,
  dim.biplot = c(2, 1, 3),
  e.vects = 1:ncol(bp$X),
  weightedCVA = "weighted",
  show.class.means = TRUE,
  low.dim = "sample.opt"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CVA.biplot_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="CVA.biplot_+3A_classes">classes</code></td>
<td>
<p>a vector of the same length as the number of rows in the data matrix with the class indicator for the samples.</p>
</td></tr>
<tr><td><code id="CVA.biplot_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>the dimension of the biplot. Only values <code>1</code>, <code>2</code> and <code>3</code> are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="CVA.biplot_+3A_e.vects">e.vects</code></td>
<td>
<p>the vector indicating which eigenvectors (canonical variates) should be plotted in the biplot, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="CVA.biplot_+3A_weightedcva">weightedCVA</code></td>
<td>
<p>a character string indicating which type of CVA to perform. One of &quot;<code>weighted</code>&quot; (default) for a weighted CVA to be performed (The centring matrix will be a diagonal matrix with the class sizes (<code class="reqn">\mathbf{C} = \mathbf{N}</code>), &quot;<code>unweightedCent</code>&quot; for unweighted CVA to be performed (The centring matrix is the usual centring matrix (<code class="reqn">\mathbf{C} = \mathbf{I}_{G} - G^{-1}\mathbf{1}_{G}\mathbf{1}_{G}'</code>)) or &quot;<code>unweightedI</code>&quot; for unweighted CVA to be performed while retaining the weighted centroid (The centring matrix is an indicator matrix (<code class="reqn">\mathbf{C} = \mathbf{I}_{G}</code>)).</p>
</td></tr>
<tr><td><code id="CVA.biplot_+3A_show.class.means">show.class.means</code></td>
<td>
<p>a logical value indicating whether to plot the class means on the biplot.</p>
</td></tr>
<tr><td><code id="CVA.biplot_+3A_low.dim">low.dim</code></td>
<td>
<p>a character string indicating which method to use to construct additional dimension(s) if the dimension of the canonical space is smaller than <code>dim.biplot</code>. One of &quot;<code>sample.opt</code>&quot; (default) for maximising the sample predictivity of the individual samples in the biplot or &quot;<code>Bhattacharyya.dist</code>&quot; which is based on the decomposition of the Bhattacharyya distance into a component for the sample means and a component for the dissimilarity between the sample covariance matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>CVA</code>, inherits from class <code>biplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4]) |&gt; CVA(classes=iris[,5])

</code></pre>

<hr>
<h2 id='CVAlowdim'>Construct additional dimensions when the dimension of the canonical space is smaller than the dimension of the biplot</h2><span id='topic+CVAlowdim'></span>

<h3>Description</h3>

<p>This function is used to add dimensions to the CVA biplot when the dimension of the canonical space <code class="reqn">K</code> is smaller than the dimension of the biplot (<code>dim.biplot</code>). This function is already used in the CVA calculations, and will therefore not have to be used in isolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CVAlowdim(bp, G, W, Mmat, low.dim, K, e.vects)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CVAlowdim_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code>.</p>
</td></tr>
<tr><td><code id="CVAlowdim_+3A_g">G</code></td>
<td>
<p>the indicator matrix defining membership of the classes.</p>
</td></tr>
<tr><td><code id="CVAlowdim_+3A_w">W</code></td>
<td>
<p>the within class sums of squares and cross products matrix.</p>
</td></tr>
<tr><td><code id="CVAlowdim_+3A_mmat">Mmat</code></td>
<td>
<p>the eigenvector matrix from CVA.</p>
</td></tr>
<tr><td><code id="CVAlowdim_+3A_low.dim">low.dim</code></td>
<td>
<p>a character string indicating which method to use to construct additional dimension(s) if the dimension of the canonical space is smaller than <code>dim.biplot</code>. One of &quot;<code>sample.opt</code>&quot; (default) for maximising the sample predictivity of the individual samples in the biplot or <code>Bhattacharyya.dist</code> which is based on the decomposition of the Bhattacharyya distance into a component for the sample means and a component for the dissimilarity between the sample covariance matrices.</p>
</td></tr>
<tr><td><code id="CVAlowdim_+3A_k">K</code></td>
<td>
<p>the dimension of the canonical space.</p>
</td></tr>
<tr><td><code id="CVAlowdim_+3A_e.vects">e.vects</code></td>
<td>
<p>the vector indicating which canonical variates are plotted in the biplot, with default <code>1:dim.biplot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three components:
</p>
<table>
<tr><td><code>Mr</code></td>
<td>
<p>the first r dimensions of the solution to be plotted.</p>
</td></tr>
<tr><td><code>Mrr</code></td>
<td>
<p>the matrix used for prediction from the canonical space.</p>
</td></tr>
<tr><td><code>Lmat</code></td>
<td>
<p>the matrix for transformation to the canonical space.</p>
</td></tr>
</table>

<hr>
<h2 id='density1D'>Creates a kernel density in 1-dimension</h2><span id='topic+density1D'></span>

<h3>Description</h3>

<p>Creates a kernel density in 1-dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density1D(
  bp,
  which = NULL,
  h = "nrd0",
  kernel = "gaussian",
  col = ez.col,
  lwd = 1.5,
  legend.mar = c(2, 5, 0, 5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density1D_+3A_bp">bp</code></td>
<td>
<p>object of class <code>biplot</code></p>
</td></tr>
<tr><td><code id="density1D_+3A_which">which</code></td>
<td>
<p>which group.</p>
</td></tr>
<tr><td><code id="density1D_+3A_h">h</code></td>
<td>
<p>bandwidth.</p>
</td></tr>
<tr><td><code id="density1D_+3A_kernel">kernel</code></td>
<td>
<p>character string giving the smoothing kernel to be used.</p>
</td></tr>
<tr><td><code id="density1D_+3A_col">col</code></td>
<td>
<p>colours to be used for each of the density curves.</p>
</td></tr>
<tr><td><code id="density1D_+3A_lwd">lwd</code></td>
<td>
<p>linewidth of density curve.</p>
</td></tr>
<tr><td><code id="density1D_+3A_legend.mar">legend.mar</code></td>
<td>
<p>The margin line of the legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>biplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot (iris,classes=iris[,5]) |&gt; CVA(dim=1) |&gt; density1D() |&gt; plot()
</code></pre>

<hr>
<h2 id='density2D'>Create a density in 2-dimensions</h2><span id='topic+density2D'></span>

<h3>Description</h3>

<p>Create a density in 2-dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density2D(
  bp,
  which = NULL,
  contours = F,
  h = NULL,
  n = 100,
  col = c("green", "yellow", "red"),
  contour.col = "black",
  cuts = 50,
  cex = 0.6,
  tcl = -0.2,
  mgp = c(0, -0.25, 0),
  layout.heights = c(100, 10),
  legend.mar = c(2, 5, 0, 5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density2D_+3A_bp">bp</code></td>
<td>
<p>object of class <code>biplot</code></p>
</td></tr>
<tr><td><code id="density2D_+3A_which">which</code></td>
<td>
<p>which group.</p>
</td></tr>
<tr><td><code id="density2D_+3A_contours">contours</code></td>
<td>
<p>logical indicating whether contours are added to the density plot</p>
</td></tr>
<tr><td><code id="density2D_+3A_h">h</code></td>
<td>
<p>vector of bandwidths for x and y directions, see <code><a href="MASS.html#topic+kde2d">kde2d</a></code>.</p>
</td></tr>
<tr><td><code id="density2D_+3A_n">n</code></td>
<td>
<p>number of grid points in each direction. Can be scalar or a length-2 integer
vector.</p>
</td></tr>
<tr><td><code id="density2D_+3A_col">col</code></td>
<td>
<p>vector of colours to use to form a 'continuous' sequence of colours.</p>
</td></tr>
<tr><td><code id="density2D_+3A_contour.col">contour.col</code></td>
<td>
<p>colour of the contours.</p>
</td></tr>
<tr><td><code id="density2D_+3A_cuts">cuts</code></td>
<td>
<p>number of colours in <code>col</code>.</p>
</td></tr>
<tr><td><code id="density2D_+3A_cex">cex</code></td>
<td>
<p>character expansion.</p>
</td></tr>
<tr><td><code id="density2D_+3A_tcl">tcl</code></td>
<td>
<p>The length of tick marks as a fraction of the height of a line of text.</p>
</td></tr>
<tr><td><code id="density2D_+3A_mgp">mgp</code></td>
<td>
<p>The margin line.</p>
</td></tr>
<tr><td><code id="density2D_+3A_layout.heights">layout.heights</code></td>
<td>
<p>A vector of values for the heights of rows.</p>
</td></tr>
<tr><td><code id="density2D_+3A_legend.mar">legend.mar</code></td>
<td>
<p>The margin line of the legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>biplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4],group.aes = iris[,5]) |&gt; PCA() |&gt; 
  density2D(which=3,col=c("white","purple","cyan","blue")) |&gt; plot()
biplot(iris[,1:4],group.aes = iris[,5]) |&gt; PCA() |&gt; 
  density2D(which=3,col=c("white","purple","cyan","blue"),contours = TRUE,
  contour.col = "grey") |&gt; plot()
</code></pre>

<hr>
<h2 id='ellipses'>Concentration ellipses (<code class="reqn">\kappa</code>-ellipses)</h2><span id='topic+ellipses'></span>

<h3>Description</h3>

<p>This function produces <code class="reqn">\kappa</code>-ellipses, which is a useful geometrical description of the
data points about the sample mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipses(bp, df=2, kappa = NULL, which = NULL,
alpha = 0.95, col = bp$sample$col[which], lty = 1, lwd = 1,
opacity = 0.25, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipses_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code>.</p>
</td></tr>
<tr><td><code id="ellipses_+3A_df">df</code></td>
<td>
<p>degrees of freedom, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="ellipses_+3A_kappa">kappa</code></td>
<td>
<p>value to construct <code class="reqn">\kappa</code>-ellipse (the value of <code class="reqn">\kappa</code>).</p>
</td></tr>
<tr><td><code id="ellipses_+3A_which">which</code></td>
<td>
<p>the selection of the group for ellipse construction.</p>
</td></tr>
<tr><td><code id="ellipses_+3A_alpha">alpha</code></td>
<td>
<p>size of <code class="reqn">\alpha</code>-bag, with default <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="ellipses_+3A_col">col</code></td>
<td>
<p>colour of ellipse. Multiple <code class="reqn">\kappa</code>-ellipse for one group will be displayed in the same colour.</p>
</td></tr>
<tr><td><code id="ellipses_+3A_lty">lty</code></td>
<td>
<p>line type of ellipse. The same line type will be used per value of <code class="reqn">\kappa</code>.</p>
</td></tr>
<tr><td><code id="ellipses_+3A_lwd">lwd</code></td>
<td>
<p>line width of ellipse. The same line width will be used per value of <code class="reqn">\kappa</code>.</p>
</td></tr>
<tr><td><code id="ellipses_+3A_opacity">opacity</code></td>
<td>
<p>level of opacity, with default <code>0.25</code>.</p>
</td></tr>
<tr><td><code id="ellipses_+3A_trace">trace</code></td>
<td>
<p>logical, indicating progress of computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components is available:
</p>
<table>
<tr><td><code>conc.ellipses</code></td>
<td>
<p>list of coordinates for the <code class="reqn">\kappa</code>-ellipses for each group.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>vector of colours for the <code class="reqn">\kappa</code>-ellipses.</p>
</td></tr>
<tr><td><code>lty</code></td>
<td>
<p>vector of line types for the <code class="reqn">\kappa</code>-ellipses.</p>
</td></tr>
<tr><td><code>lwd</code></td>
<td>
<p>vector of line widths for the <code class="reqn">\kappa</code>-ellipses.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>vector of <code class="reqn">\alpha</code> values.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gower, J., Gardner-Lubbe, S. &amp; Le Roux, N. (2011, ISBN: 978-0-470-01255-0) <em>Understanding Biplots.</em> Chichester, England: John Wiley &amp; Sons Ltd.<br><br>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot (iris[,1:4]) |&gt; PCA(group.aes=iris[,5]) |&gt; ellipses(kappa=2) |&gt; plot()

</code></pre>

<hr>
<h2 id='extended.matching.coefficient'>Extended matching coefficient</h2><span id='topic+extended.matching.coefficient'></span>

<h3>Description</h3>

<p>Extended matching coefficient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extended.matching.coefficient(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extended.matching.coefficient_+3A_x">X</code></td>
<td>
<p>a data frame containing the categorical variables used for computing the EMC distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dist object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtdf &lt;- as.data.frame(mtcars)
mtdf$cyl &lt;- factor(mtdf$cyl)
mtdf$vs &lt;- factor(mtdf$vs)
mtdf$am &lt;- factor(mtdf$am)
mtdf$gear &lt;- factor(mtdf$gear)
mtdf$carb &lt;- factor(mtdf$carb)
extended.matching.coefficient(mtdf[,8:11])

</code></pre>

<hr>
<h2 id='fit.measures'>Compute measures of fit for the biplot.</h2><span id='topic+fit.measures'></span>

<h3>Description</h3>

<p>This function computes the measures of fit for the biplot. The biplot object is augmented with additional items, which can differ depending on the type of biplot. The measures provide information on the overall quality of fit and the adequacy of representation of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.measures(bp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.measures_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>biplot</code>. The object is augmented with
additional items, depending on the type of biplot object.
</p>
<table>
<tr><td><code>quality</code></td>
<td>
<p>the overall quality of fit.</p>
</td></tr>
<tr><td><code>adequacy</code></td>
<td>
<p>the adequacy of representation of variables.</p>
</td></tr>
</table>
<p>For an object of class <code>PCA</code>:
</p>
<table>
<tr><td><code>axis.predictivity</code></td>
<td>
<p>the fit measure of each individual axis.</p>
</td></tr>
<tr><td><code>sample.predictivity</code></td>
<td>
<p>the fit measure for each individual sample.</p>
</td></tr>
</table>
<p>For an object of class <code>CVA</code>:
</p>
<table>
<tr><td><code>axis.predictivity</code></td>
<td>
<p>the fit measure of each individual axis.</p>
</td></tr>
<tr><td><code>class.predictivity</code></td>
<td>
<p>the fit measure for each class mean.</p>
</td></tr>
<tr><td><code>within.class.axis.predictivity</code></td>
<td>
<p>the fit measure for each axis based on values
expressed as deviations from their class means.</p>
</td></tr>
<tr><td><code>within.class.sample.predictivity</code></td>
<td>
<p>the fit measure for each sample expressed as
deviation from its class mean.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- biplot (iris[,1:4]) |&gt; PCA() |&gt; fit.measures()
summary(out)

</code></pre>

<hr>
<h2 id='interpolate'>Interpolate supplementary points and variables to add to the biplot</h2><span id='topic+interpolate'></span>

<h3>Description</h3>

<p>This function adds supplementary points and variables to the plot from a new data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate(bp, newdata = NULL, newvariable = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_newdata">newdata</code></td>
<td>
<p>a new data set, similar in structure to the data set supplied to <code>biplot()</code>
containing supplementary data points to be added onto the biplot.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_newvariable">newvariable</code></td>
<td>
<p>a new data set, similar in structure to the data set supplied to <code>biplot()</code>
containing supplementary variables to be added onto the biplot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object of class <code>biplot</code> will be appended with the following elements:
</p>
<table>
<tr><td><code>Xnew.raw</code></td>
<td>
<p>the new data.</p>
</td></tr>
<tr><td><code>Xnew</code></td>
<td>
<p>the matrix of the centered and scaled new numeric variables of new data.</p>
</td></tr>
<tr><td><code>Xnew.cat</code></td>
<td>
<p>the matrix of the categorical variables of new data.</p>
</td></tr>
<tr><td><code>Znew</code></td>
<td>
<p>the matrix of the coordinates of the new data in the biplot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(data = iris[1:145,]) |&gt; PCA() |&gt; interpolate(newdata = iris[146:150,]) |&gt; plot()

</code></pre>

<hr>
<h2 id='legend.type'>Format the legend for the biplot</h2><span id='topic+legend.type'></span>

<h3>Description</h3>

<p>This function enables the user to format the legend and make a required selection to display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legend.type(bp, samples = FALSE, means = FALSE, bags = FALSE,
                   ellipses=FALSE,regions=FALSE, new=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legend.type_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code>.</p>
</td></tr>
<tr><td><code id="legend.type_+3A_samples">samples</code></td>
<td>
<p>a logical value indicating whether a legend should be printed for samples, with default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="legend.type_+3A_means">means</code></td>
<td>
<p>a logical value indicating whether a legend should be printed for means, with default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="legend.type_+3A_bags">bags</code></td>
<td>
<p>a logical value indicating whether a legend should be printed for bags, with default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="legend.type_+3A_ellipses">ellipses</code></td>
<td>
<p>a logical value indicating whether a legend should be printed for concentration ellipses, with default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="legend.type_+3A_regions">regions</code></td>
<td>
<p>a logical value indicating whether a legend should be printed for classification regions, with default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="legend.type_+3A_new">new</code></td>
<td>
<p>a logical value indicating whether the legend should appear in a new window, with default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="legend.type_+3A_...">...</code></td>
<td>
<p>additional arguments to be sent to <code>legend()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components is available:
</p>
<table>
<tr><td><code>samples</code></td>
<td>
<p>a logical value indicating whether a legend for samples are provided.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>a logical value indicating whether a legend for class means are provided.</p>
</td></tr>
<tr><td><code>bags</code></td>
<td>
<p>a logical value indicating whether a legend for <code class="reqn">\alpha</code>-bags are provided.</p>
</td></tr>
<tr><td><code>ellipses</code></td>
<td>
<p>a logical value indicating whether a legend for <code class="reqn">\kappa</code>-ellipses are provided.</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>a logical value indicating whether a legend for classification regions are provided.</p>
</td></tr>
<tr><td><code>new</code></td>
<td>
<p>a logical value indicating whether the legend appears on new plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>biplot (iris[,1:4], Title="Test biplot") |&gt; PCA(group.aes = iris[,5]) |&gt;
    legend.type(samples=TRUE) |&gt; plot()
    
</code></pre>

<hr>
<h2 id='means'>Aesthetics for biplot class / group means</h2><span id='topic+means'></span>

<h3>Description</h3>

<p>This function allows formatting changes to class means or group means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>means (bp,  which = NULL, col = NULL, pch = 15, cex = 1, label = FALSE,
label.col = NULL,label.cex = 0.75, label.side = "bottom", label.offset = 0.5,
opacity = 1, shade.darker = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="means_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code>.</p>
</td></tr>
<tr><td><code id="means_+3A_which">which</code></td>
<td>
<p>vector of which means to display, with default <code>bp$g</code>.</p>
</td></tr>
<tr><td><code id="means_+3A_col">col</code></td>
<td>
<p>mean colour, with default to sample colour.</p>
</td></tr>
<tr><td><code id="means_+3A_pch">pch</code></td>
<td>
<p>mean plotting character, with default <code>o</code>.</p>
</td></tr>
<tr><td><code id="means_+3A_cex">cex</code></td>
<td>
<p>mean character expansion, with default <code>1</code>.</p>
</td></tr>
<tr><td><code id="means_+3A_label">label</code></td>
<td>
<p>logical, whether means should be labelled or not, with default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="means_+3A_label.col">label.col</code></td>
<td>
<p>vector of length g with the colour of the labels, defaulting to the
colour of the means.</p>
</td></tr>
<tr><td><code id="means_+3A_label.cex">label.cex</code></td>
<td>
<p>label text expansion, with default <code>0.75</code>.</p>
</td></tr>
<tr><td><code id="means_+3A_label.side">label.side</code></td>
<td>
<p>side of the plotting character where label appears, with default <code>bottom</code>. Note that unlike
the argument <code>pos</code> in <code>text()</code>, options are &quot;bottom&quot;, &quot;left&quot;, &quot;top&quot;, &quot;right&quot; and not 1, 2, 3, 4.</p>
</td></tr>
<tr><td><code id="means_+3A_label.offset">label.offset</code></td>
<td>
<p>offset of the label from the mean point. See ?text for a detailed explanation of the
argument <code>offset</code>.</p>
</td></tr>
<tr><td><code id="means_+3A_opacity">opacity</code></td>
<td>
<p>transparency of means.</p>
</td></tr>
<tr><td><code id="means_+3A_shade.darker">shade.darker</code></td>
<td>
<p>automatically makes the colour of the means a darker shade than the default (or specified) colour</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of classes or groups (defined by group.aes) is indicated as <code>g</code>. If an argument is not of length <code>g</code>,
recycling is used.
</p>


<h3>Value</h3>

<p>A list with the following components is available:
</p>
<table>
<tr><td><code>which</code></td>
<td>
<p>which means to display.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>colour of the means.</p>
</td></tr>
<tr><td><code>pch</code></td>
<td>
<p>plotting character of the means.</p>
</td></tr>
<tr><td><code>cex</code></td>
<td>
<p>expansion of the plotting character of the means.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>logical, whether means should be labelled.</p>
</td></tr>
<tr><td><code>label.col</code></td>
<td>
<p>colour of the label.</p>
</td></tr>
<tr><td><code>label.cex</code></td>
<td>
<p>expansion of the label.</p>
</td></tr>
<tr><td><code>label.side</code></td>
<td>
<p>side at which to plot the label of means.</p>
</td></tr>
<tr><td><code>label.offset</code></td>
<td>
<p>offset of the label from the mean point.</p>
</td></tr>
<tr><td><code>opacity</code></td>
<td>
<p>transparency of means</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4]) |&gt; PCA() |&gt;
          means(col = "purple", pch = 15, cex = 2) |&gt; plot()
</code></pre>

<hr>
<h2 id='newaxes'>Aesthetics for supplementary (new) biplot axes</h2><span id='topic+newaxes'></span>

<h3>Description</h3>

<p>Aesthetics for supplementary (new) biplot axes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newaxes(bp, X.new.names=bp$var.names, which = 1:bp$num.vars, col = "orange", lwd = 1, 
lty = 1, label.dir = "Orthog", label.col = col, label.cex = 0.75, label.line = 0.1, 
ticks = 5, tick.col = col, tick.size = 1, tick.label = TRUE, tick.label.col = tick.col, 
tick.label.cex = 0.6, tick.label.side = "below", predict.col = col, predict.lwd = lwd, 
predict.lty = lty, ax.names = X.new.names, orthogx = 0, orthogy = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newaxes_+3A_bp">bp</code></td>
<td>
<p>object of class <code>biplot</code></p>
</td></tr>
<tr><td><code id="newaxes_+3A_x.new.names">X.new.names</code></td>
<td>
<p>refers to the new column names of <code>bp</code> to specify which axes to label.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_which">which</code></td>
<td>
<p>vector of new columns to be displayed in the biplot.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_col">col</code></td>
<td>
<p>vector of size p specifying colours of labels of biplot axes. The default is <code>grey(0.7)</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_lwd">lwd</code></td>
<td>
<p>axis line width, with default <code>1</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_lty">lty</code></td>
<td>
<p>axis line type, with default <code>1</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_label.dir">label.dir</code></td>
<td>
<p>One of &quot;Orthog&quot; (default), &quot;Hor&quot; or &quot;Paral&quot; specifying titles of
axes to appear orthogonal to the side of the figure; always
horizontally or always parallel to the side of the figure.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_label.col">label.col</code></td>
<td>
<p>axis label colour, with default, <code>col</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_label.cex">label.cex</code></td>
<td>
<p>axis label expansion, with default <code>0.75</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_label.line">label.line</code></td>
<td>
<p>axis label written on which margin line, with default <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_ticks">ticks</code></td>
<td>
<p>integer-valued vector of size equal to the number of biplot axes
to control the number of tickmarks on each individual biplot
axis. Default is 5 for each axis.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_tick.col">tick.col</code></td>
<td>
<p>tick mark colour, with default <code>col</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_tick.size">tick.size</code></td>
<td>
<p>positive integer-valued vector with specifying tick mark sizes, with default <code>1</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_tick.label">tick.label</code></td>
<td>
<p>logical, whether axes should be labelled or not, with default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_tick.label.col">tick.label.col</code></td>
<td>
<p>tick mark label colour, with default <code>tick.col</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_tick.label.cex">tick.label.cex</code></td>
<td>
<p>tick mark label expansion, with default <code>0.6</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_tick.label.side">tick.label.side</code></td>
<td>
<p>character vector specifying position of the tick label &quot;below&quot; or &quot;above&quot; the axis.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_predict.col">predict.col</code></td>
<td>
<p>predicted samples colour, with default <code>col</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_predict.lwd">predict.lwd</code></td>
<td>
<p>predicted samples line width, with default <code>lwd</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_predict.lty">predict.lty</code></td>
<td>
<p>predicted samples line type, with default <code>lty</code>.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_ax.names">ax.names</code></td>
<td>
<p>vector of size <code>p</code> containing user defined names for the variables.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_orthogx">orthogx</code></td>
<td>
<p>numeric vector of size p specifying the x-coordinate of the parallel transformation of each axis.
Defaults to zero for each axis. Only used when the dimension of the biplot is two.</p>
</td></tr>
<tr><td><code id="newaxes_+3A_orthogy">orthogy</code></td>
<td>
<p>numeric vector of size p specifying the y-coordinate of the parallel transformation of each axis.
Defaults to zero for each axis. Only used when the dimension of the biplot is two.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>biplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(data = iris[,1:2]) |&gt; PCA() |&gt; interpolate(newvariable = iris[3:4]) |&gt; 
  newaxes(col="gold") |&gt; plot()
</code></pre>

<hr>
<h2 id='newsamples'>Aesthetics for supplementary (new) biplot samples</h2><span id='topic+newsamples'></span>

<h3>Description</h3>

<p>This function allows formatting changes to new samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newsamples (bp,  col = "darkorange1", pch = 1, cex = 1, label = FALSE,
label.name = NULL, label.col = NULL,label.cex = 0.75, label.side = "bottom", 
label.offset = 0.5, connected = FALSE, connect.col = "black", connect.lty=1, 
connect.lwd=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newsamples_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code>.</p>
</td></tr>
<tr><td><code id="newsamples_+3A_col">col</code></td>
<td>
<p>new sample colour, with default <code>darkorange1</code>.</p>
</td></tr>
<tr><td><code id="newsamples_+3A_pch">pch</code></td>
<td>
<p>new sample plotting character, with default <code>o</code>.</p>
</td></tr>
<tr><td><code id="newsamples_+3A_cex">cex</code></td>
<td>
<p>new sample character expansion, with default <code>1</code>.</p>
</td></tr>
<tr><td><code id="newsamples_+3A_label">label</code></td>
<td>
<p>logical, whether samples should be labelled or not, with default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="newsamples_+3A_label.name">label.name</code></td>
<td>
<p>names for the new samples</p>
</td></tr>
<tr><td><code id="newsamples_+3A_label.col">label.col</code></td>
<td>
<p>vector of length number of new samples with the colour of the labels, defaulting to the
colour of the sample points.</p>
</td></tr>
<tr><td><code id="newsamples_+3A_label.cex">label.cex</code></td>
<td>
<p>label text expansion, with default <code>0.75</code>.</p>
</td></tr>
<tr><td><code id="newsamples_+3A_label.side">label.side</code></td>
<td>
<p>side of the plotting character where label appears, with default <code>bottom</code>. Note that unlike
the argument <code>pos</code> in <code>text()</code>, options are &quot;bottom&quot;, &quot;left&quot;, &quot;top&quot;, &quot;right&quot; and not 1, 2, 3, 4.</p>
</td></tr>
<tr><td><code id="newsamples_+3A_label.offset">label.offset</code></td>
<td>
<p>offset of the label from the data point. See ?text for a detailed explanation of the
argument <code>offset</code>.</p>
</td></tr>
<tr><td><code id="newsamples_+3A_connected">connected</code></td>
<td>
<p>logical, whether samples are connected in order of rows of data matrix, with default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="newsamples_+3A_connect.col">connect.col</code></td>
<td>
<p>colour of the connecting line, with default <code>black</code>.</p>
</td></tr>
<tr><td><code id="newsamples_+3A_connect.lty">connect.lty</code></td>
<td>
<p>line type of the connecting line, with default <code>1</code>.</p>
</td></tr>
<tr><td><code id="newsamples_+3A_connect.lwd">connect.lwd</code></td>
<td>
<p>line width of the connecting line, with default <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components is available:
</p>
<table>
<tr><td><code>col</code></td>
<td>
<p>colour of the samples.</p>
</td></tr>
<tr><td><code>pch</code></td>
<td>
<p>plotting character of the samples.</p>
</td></tr>
<tr><td><code>cex</code></td>
<td>
<p>expansion of the plotting character of the samples.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>TRUE or FALSE, whether samples should be labelled.</p>
</td></tr>
<tr><td><code>label.col</code></td>
<td>
<p>colour of the label.</p>
</td></tr>
<tr><td><code>label.cex</code></td>
<td>
<p>expansion of the label.</p>
</td></tr>
<tr><td><code>label.side</code></td>
<td>
<p>side at which to plot the label of samples.</p>
</td></tr>
<tr><td><code>label.offset</code></td>
<td>
<p>offset of the label from the data point.</p>
</td></tr>
<tr><td><code>connected</code></td>
<td>
<p>TRUE or FALSE, whether samples should be connected in row order of X.</p>
</td></tr>
<tr><td><code>connect.col</code></td>
<td>
<p>colour of the connecting line.</p>
</td></tr>
<tr><td><code>connect.lty</code></td>
<td>
<p>line type of the connecting line.</p>
</td></tr>
<tr><td><code>connect.lwd</code></td>
<td>
<p>line width of the connecting line.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(data = iris[1:145,]) |&gt; PCA() |&gt; samples(col = "grey") |&gt;
interpolate(newdata = iris[146:150,]) |&gt; newsamples(col = rainbow(6), pch=15) |&gt; plot()

</code></pre>

<hr>
<h2 id='PCA'>Perform Principal Components Analysis (PCA)</h2><span id='topic+PCA'></span>

<h3>Description</h3>

<p>This function appends the <code>biplot</code> object with elements resulting from performing PCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCA(bp, dim.biplot = c(2, 1, 3), e.vects = 1:ncol(bp$X),
group.aes = NULL, show.class.means = FALSE, correlation.biplot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCA_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="PCA_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>the dimension of the biplot. Only values <code>1</code>, <code>2</code> and <code>3</code> are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="PCA_+3A_e.vects">e.vects</code></td>
<td>
<p>the vector indicating which eigenvectors (principal components) should be plotted in the biplot, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="PCA_+3A_group.aes">group.aes</code></td>
<td>
<p>a vector of the same length as the number of rows in the data matrix
for differentiated aesthetics for samples.</p>
</td></tr>
<tr><td><code id="PCA_+3A_show.class.means">show.class.means</code></td>
<td>
<p>a logical value indicating whether group means should be plotted in the biplot.</p>
</td></tr>
<tr><td><code id="PCA_+3A_correlation.biplot">correlation.biplot</code></td>
<td>
<p>a logical value. If <code>FALSE</code>, the distances between sample points are
optimally approximated in the biplot. If <code>TRUE</code>, the correlations between
variables are optimally approximated by the cosine of the angles between
axes. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class PCA with the following elements:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>the matrix of the centered and scaled numeric variables.</p>
</td></tr>
<tr><td><code>Xcat</code></td>
<td>
<p>the data frame of the categorical variables.</p>
</td></tr>
<tr><td><code>raw.X</code></td>
<td>
<p>the original data.</p>
</td></tr>
<tr><td><code>classes</code></td>
<td>
<p>the vector of category levels for the class variable. This is to be used for <code>colour</code>, <code>pch</code> and <code>cex</code> specifications.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>the vector of observations that have been removed.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>a logical value indicating whether <code class="reqn">\mathbf{X}</code> is centered.</p>
</td></tr>
<tr><td><code>scaled</code></td>
<td>
<p>a logical value indicating whether <code class="reqn">\mathbf{X}</code> is scaled.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>the vector of means for each numerical variable.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the vector of standard deviations for each numerical variable.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the number of variables.</p>
</td></tr>
<tr><td><code>group.aes</code></td>
<td>
<p>the vector of category levels for the grouping variable. This is to be used for <code>colour</code>, <code>pch</code> and <code>cex</code> specification.</p>
</td></tr>
<tr><td><code>g.names</code></td>
<td>
<p>the descriptive names to be used for group labels.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>the number of groups.</p>
</td></tr>
<tr><td><code>Title</code></td>
<td>
<p>the title of the biplot rendered.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>the matrix with each row containing the details of the points that are plotted (i.e. coordinates).</p>
</td></tr>
<tr><td><code>Lmat</code></td>
<td>
<p>the matrix for transformation to the principal components.</p>
</td></tr>
<tr><td><code>Linv</code></td>
<td>
<p>the inverse of <code class="reqn">\mathbf{L}</code>.</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>the vector of eigenvalues of the covariance matrix of <code class="reqn">\mathbf{X}</code>.</p>
</td></tr>
<tr><td><code>ax.one.unit</code></td>
<td>
<p>one unit in the positive direction of each biplot axis.</p>
</td></tr>
<tr><td><code>e.vects</code></td>
<td>
<p>the vector indicating which principal components are plotted in the biplot.</p>
</td></tr>
<tr><td><code>Vr</code></td>
<td>
<p>the <code>1:dim.biplot</code> columns of <code class="reqn">\mathbf{V}</code>.</p>
</td></tr>
<tr><td><code>dim.biplot</code></td>
<td>
<p>the dimension of the biplot.</p>
</td></tr>
<tr><td><code>V.mat</code></td>
<td>
<p>the matrix containing the right singular vectors of <code class="reqn">\mathbf{X}</code>.</p>
</td></tr>
<tr><td><code>Sigma.mat</code></td>
<td>
<p>the matrix with the singular values of <code class="reqn">\mathbf{X}</code> on the diagonal.</p>
</td></tr>
<tr><td><code>U.mat</code></td>
<td>
<p>the matrix containing the left singular vectors of <code class="reqn">\mathbf{X}</code>.</p>
</td></tr>
<tr><td><code>class.means</code></td>
<td>
<p>a logical value indicating whether group means are plotted in the biplot.</p>
</td></tr>
<tr><td><code>Zmeans</code></td>
<td>
<p>the matrix of class mean coordinates that are plotted in the biplot.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gabriel, K.R. (1971) The biplot graphic display of matrices with application to principal component analysis. <em>Biometrika.</em> 58(3):453–467.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4]) |&gt; PCA()
# create a PCA biplot
biplot(data = iris) |&gt; PCA() |&gt; plot()

</code></pre>

<hr>
<h2 id='PCA.biplot'>Calculate elements for the PCA biplot</h2><span id='topic+PCA.biplot'></span>

<h3>Description</h3>

<p>This function performs calculations for the construction of a PCA biplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biplot'
PCA(
  bp,
  dim.biplot = c(2, 1, 3),
  e.vects = 1:ncol(bp$X),
  group.aes = NULL,
  show.class.means = FALSE,
  correlation.biplot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCA.biplot_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="PCA.biplot_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>the dimension of the biplot. Only values <code>1</code>, <code>2</code> and <code>3</code> are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="PCA.biplot_+3A_e.vects">e.vects</code></td>
<td>
<p>the vector indicating which eigenvectors (principal components) should be plotted in the biplot, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="PCA.biplot_+3A_group.aes">group.aes</code></td>
<td>
<p>a vector of the same length as the number of rows in the data matrix
for differentiated aesthetics for samples.</p>
</td></tr>
<tr><td><code id="PCA.biplot_+3A_show.class.means">show.class.means</code></td>
<td>
<p>a logical value indicating whether group means should be plotted in the biplot.</p>
</td></tr>
<tr><td><code id="PCA.biplot_+3A_correlation.biplot">correlation.biplot</code></td>
<td>
<p>a logical value. If <code>FALSE</code>, the distances between sample points are
optimally approximated in the biplot. If <code>TRUE</code>, the correlations between
variables are optimally approximated by the cosine of the angles between
axes. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>PCA</code>, inherits from class <code>biplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4]) |&gt; PCA()
# create a PCA biplot
biplot(data = iris) |&gt; PCA() |&gt; plot()

</code></pre>

<hr>
<h2 id='PCO'>Principal Coordinate Analysis (PCO) biplot method</h2><span id='topic+PCO'></span>

<h3>Description</h3>

<p>Principal Coordinate Analysis (PCO) biplot method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCO(bp, Dmat=NULL, dist.func=NULL, dist.func.cat=NULL,
           dim.biplot = c(2,1,3), e.vects = NULL, group.aes=NULL,
           show.class.means = FALSE, axes = c("regression","splines"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCO_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="PCO_+3A_dmat">Dmat</code></td>
<td>
<p>nxn matrix of Euclidean embeddable distances between samples</p>
</td></tr>
<tr><td><code id="PCO_+3A_dist.func">dist.func</code></td>
<td>
<p>function to compute Euclidean embeddable distances between samples. The
default NULL computes Euclidean distance.</p>
</td></tr>
<tr><td><code id="PCO_+3A_dist.func.cat">dist.func.cat</code></td>
<td>
<p>function to compute Euclidean embeddable distance between categorical
variables for the samples. The default NULL computes the extended
matching coefficient.</p>
</td></tr>
<tr><td><code id="PCO_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>dimension of the biplot. Only values 1, 2 and 3 are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="PCO_+3A_e.vects">e.vects</code></td>
<td>
<p>e.vects which eigenvectors (canonical variates) to extract, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="PCO_+3A_group.aes">group.aes</code></td>
<td>
<p>vector of the same length as the number of rows in the data matrix
for differentiated aesthetics for samples.</p>
</td></tr>
<tr><td><code id="PCO_+3A_show.class.means">show.class.means</code></td>
<td>
<p>logical, indicating whether to plot the class means on the biplot.</p>
</td></tr>
<tr><td><code id="PCO_+3A_axes">axes</code></td>
<td>
<p>type of biplot axes, currently only regression axes are implemented</p>
</td></tr>
<tr><td><code id="PCO_+3A_...">...</code></td>
<td>
<p>more arguments to <code>dist.func</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class biplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4]) |&gt; PCO(dist.func = sqrtManhattan)
# create a CVA biplot
biplot(iris[,1:4]) |&gt; PCO(dist.func = sqrtManhattan) |&gt; plot()
</code></pre>

<hr>
<h2 id='PCO.biplot'>PCO biplot</h2><span id='topic+PCO.biplot'></span>

<h3>Description</h3>

<p>Computes Principal Coordinate Analysis biplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biplot'
PCO(
  bp,
  Dmat = NULL,
  dist.func = NULL,
  dist.func.cat = NULL,
  dim.biplot = c(2, 1, 3),
  e.vects = NULL,
  group.aes = NULL,
  show.class.means = FALSE,
  axes = c("regression", "splines"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCO.biplot_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="PCO.biplot_+3A_dmat">Dmat</code></td>
<td>
<p>nxn matrix of Euclidean embeddable distances between samples</p>
</td></tr>
<tr><td><code id="PCO.biplot_+3A_dist.func">dist.func</code></td>
<td>
<p>function to compute Euclidean embeddable distances between samples. The
default NULL computes Euclidean distance.</p>
</td></tr>
<tr><td><code id="PCO.biplot_+3A_dist.func.cat">dist.func.cat</code></td>
<td>
<p>function to compute Euclidean embeddable distance between categorical
variables for the samples. The default NULL computes the extended
matching coefficient.</p>
</td></tr>
<tr><td><code id="PCO.biplot_+3A_dim.biplot">dim.biplot</code></td>
<td>
<p>dimension of the biplot. Only values 1, 2 and 3 are accepted, with default <code>2</code>.</p>
</td></tr>
<tr><td><code id="PCO.biplot_+3A_e.vects">e.vects</code></td>
<td>
<p>e.vects which eigenvectors (canonical variates) to extract, with default <code>1:dim.biplot</code>.</p>
</td></tr>
<tr><td><code id="PCO.biplot_+3A_group.aes">group.aes</code></td>
<td>
<p>vector of the same length as the number of rows in the data matrix
for differentiated aesthetics for samples.</p>
</td></tr>
<tr><td><code id="PCO.biplot_+3A_show.class.means">show.class.means</code></td>
<td>
<p>logical, indicating whether to plot the class means on the biplot.</p>
</td></tr>
<tr><td><code id="PCO.biplot_+3A_axes">axes</code></td>
<td>
<p>type of biplot axes, currently only regression axes are implemented</p>
</td></tr>
<tr><td><code id="PCO.biplot_+3A_...">...</code></td>
<td>
<p>more arguments to <code>dist.func</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class biplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris) |&gt; PCO(dist.func=sqrtManhattan) |&gt; plot()

</code></pre>

<hr>
<h2 id='plot.biplot'>Generic Plotting function of objects of class biplot</h2><span id='topic+plot.biplot'></span>

<h3>Description</h3>

<p>Generic Plotting function of objects of class biplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biplot'
plot(
  x,
  exp.factor = 1.2,
  axis.predictivity = NULL,
  sample.predictivity = NULL,
  zoom = FALSE,
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.biplot_+3A_x">x</code></td>
<td>
<p>An object of class <code>biplot</code>.</p>
</td></tr>
<tr><td><code id="plot.biplot_+3A_exp.factor">exp.factor</code></td>
<td>
<p>numeric value with default axes of the biplot. Larger values for zooming out and
smaller values for zooming in with respect to sample points
in the biplot display.</p>
</td></tr>
<tr><td><code id="plot.biplot_+3A_axis.predictivity">axis.predictivity</code></td>
<td>
<p>either logical or a numeric value between 0 and 1.
If it is a numeric value, this value is used as threshold so that
only axes with axis predictivity larger than the threshold is displayed.
If <code>axis.predictivity = TRUE</code>, the axis color is 'diluted' in
proportion with the axis predictivity.</p>
</td></tr>
<tr><td><code id="plot.biplot_+3A_sample.predictivity">sample.predictivity</code></td>
<td>
<p>either a logical or a numeric value between 0 and 1.
If it is a numeric value, this value is used as threshold so that
only samples with sample predictivity larger than the threshold is displayed.
if <code>sample.predictivity = TRUE</code>, the sample size is shrinked in
proportion with the sample predictivity.</p>
</td></tr>
<tr><td><code id="plot.biplot_+3A_zoom">zoom</code></td>
<td>
<p>logical, allowing the user to select an area to zoom into</p>
</td></tr>
<tr><td><code id="plot.biplot_+3A_xlim">xlim</code></td>
<td>
<p>horisontal limits of the plot</p>
</td></tr>
<tr><td><code id="plot.biplot_+3A_ylim">ylim</code></td>
<td>
<p>vertical limits of the plot</p>
</td></tr>
<tr><td><code id="plot.biplot_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>biplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot (iris[,1:4]) |&gt; PCA() |&gt; plot()
</code></pre>

<hr>
<h2 id='plot3D'>Generic Plotting function of objects of class biplot in three dimensions</h2><span id='topic+plot3D'></span>

<h3>Description</h3>

<p>Generic Plotting function of objects of class biplot in three dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3D(bp, exp.factor = 1.2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3D_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code></p>
</td></tr>
<tr><td><code id="plot3D_+3A_exp.factor">exp.factor</code></td>
<td>
<p>factor to expand plotting area beyond samples.</p>
</td></tr>
<tr><td><code id="plot3D_+3A_...">...</code></td>
<td>
<p>more arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>biplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(data = iris) |&gt; PCA(dim.biplot = 3) |&gt; plot3D()
</code></pre>

<hr>
<h2 id='prediction'>Predict samples to display on the biplot</h2><span id='topic+prediction'></span>

<h3>Description</h3>

<p>This function makes predictions of sample points, variables and means and displays them on the biplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prediction(bp, predict.samples = NULL, predict.means = NULL, which = 1:bp$p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prediction_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="prediction_+3A_predict.samples">predict.samples</code></td>
<td>
<p>a vector specifying which samples to predict.</p>
</td></tr>
<tr><td><code id="prediction_+3A_predict.means">predict.means</code></td>
<td>
<p>a vector specifying which group means to predict.</p>
</td></tr>
<tr><td><code id="prediction_+3A_which">which</code></td>
<td>
<p>a vector specifying which variable to do the prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object called <code>predict</code> appended to the object of class <code>biplot</code> with the following elements:
</p>
<table>
<tr><td><code>samples</code></td>
<td>
<p>a vector of indices of samples which are being predicted.</p>
</td></tr>
<tr><td><code>predict.means</code></td>
<td>
<p>a vector of group names of groups for which the means are being predicted.</p>
</td></tr>
<tr><td><code>which</code></td>
<td>
<p>the vector of indices variables which are being predicted.</p>
</td></tr>
<tr><td><code>predict.mat</code></td>
<td>
<p>the matrix of predicted samples.</p>
</td></tr>
<tr><td><code>predict.means.mat</code></td>
<td>
<p>the matrix of predicted group means.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(data = iris[,1:4]) |&gt; PCA(group.aes=iris[,5], show.class.means = TRUE) |&gt; 
prediction(141:145,1:3) |&gt; plot()

</code></pre>

<hr>
<h2 id='print.biplot'>Generic print function for objects of class biplot</h2><span id='topic+print.biplot'></span>

<h3>Description</h3>

<p>This function is used to print output when the biplot object is created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biplot'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.biplot_+3A_x">x</code></td>
<td>
<p>an object of class <code>biplot</code>.</p>
</td></tr>
<tr><td><code id="print.biplot_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will not produce a return value, it is called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- biplot (iris[,1:4]) |&gt; PCA()
out

</code></pre>

<hr>
<h2 id='print.CA'>Generic print function of objects of class CA</h2><span id='topic+print.CA'></span>

<h3>Description</h3>

<p>Generic print function of objects of class CA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CA'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.CA_+3A_x">x</code></td>
<td>
<p>an object of class <code>CA</code></p>
</td></tr>
<tr><td><code id="print.CA_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- biplot(HairEyeColor[,,1], center=FALSE) |&gt; CA()
out

</code></pre>

<hr>
<h2 id='reflect'>Reflect the biplot about a chosen axis</h2><span id='topic+reflect'></span>

<h3>Description</h3>

<p>This function provides the user with an option to reflect the biplot horizontally, vertically or diagonally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reflect(bp, reflect.axis = c("FALSE", "x", "y", "xy"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reflect_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code></p>
</td></tr>
<tr><td><code id="reflect_+3A_reflect.axis">reflect.axis</code></td>
<td>
<p>a character string indicating which axis about to reflect. One of <code>FALSE</code> (default), &quot;<code>x</code>&quot; for reflection about the x-axis, &quot;<code>y</code>&quot; for reflection about the y-axis and &quot;<code>xy</code>&quot; for reflection about both axes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>biplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4],group.aes = iris[,5]) |&gt; PCA() |&gt; reflect("x") |&gt; plot()
biplot(iris[,1:4],group.aes = iris[,5]) |&gt; PCA() |&gt; reflect("y") |&gt; plot()
biplot(iris[,1:4],group.aes = iris[,5]) |&gt; PCA() |&gt; reflect("xy") |&gt; plot()

</code></pre>

<hr>
<h2 id='regress'>Regression biplot method</h2><span id='topic+regress'></span>

<h3>Description</h3>

<p>Regression biplot method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regress(bp, Z, group.aes=NULL, show.group.means = TRUE, 
               axes = c("regression", "splines"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regress_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="regress_+3A_z">Z</code></td>
<td>
<p>the matrix of coordinates of the samples</p>
</td></tr>
<tr><td><code id="regress_+3A_group.aes">group.aes</code></td>
<td>
<p>vector of the same length as the number of rows in the data matrix
for differentiated aesthetics for samples.</p>
</td></tr>
<tr><td><code id="regress_+3A_show.group.means">show.group.means</code></td>
<td>
<p>logical, indicating whether group means should be plotted in the biplot.</p>
</td></tr>
<tr><td><code id="regress_+3A_axes">axes</code></td>
<td>
<p>the type of axes to be fitted to the biplot. Options are 'regression' for linear
regression axes (default) and 'splines' for B-spline axes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class biplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4]) |&gt; regress(Z=cmdscale(dist(iris[,1:4]))) |&gt; plot()
</code></pre>

<hr>
<h2 id='regress.biplot'>Regression biplot</h2><span id='topic+regress.biplot'></span>

<h3>Description</h3>

<p>Computes regression biplot axes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biplot'
regress(
  bp,
  Z,
  group.aes = NULL,
  show.group.means = TRUE,
  axes = c("regression", "splines")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regress.biplot_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code> obtained from preceding function <code>biplot()</code>.</p>
</td></tr>
<tr><td><code id="regress.biplot_+3A_z">Z</code></td>
<td>
<p>the matrix of coordinates of the samples</p>
</td></tr>
<tr><td><code id="regress.biplot_+3A_group.aes">group.aes</code></td>
<td>
<p>vector of the same length as the number of rows in the data matrix
for differentiated aesthetics for samples.</p>
</td></tr>
<tr><td><code id="regress.biplot_+3A_show.group.means">show.group.means</code></td>
<td>
<p>logical, indicating whether group means should be plotted in the biplot.</p>
</td></tr>
<tr><td><code id="regress.biplot_+3A_axes">axes</code></td>
<td>
<p>the type of axes to be fitted to the biplot. Options are 'regression' for linear
regression axes (default) and 'splines' for B-spline axes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class biplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris) |&gt; regress(Z = cmdscale(dist(iris[,1:4]))) |&gt; plot()

</code></pre>

<hr>
<h2 id='rotate'>Rotate the biplot a chosen amount of degrees</h2><span id='topic+rotate'></span>

<h3>Description</h3>

<p>This function provides the user with an option to rotate the biplot anti-clockwise or clockwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate(bp, rotate.degrees = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code></p>
</td></tr>
<tr><td><code id="rotate_+3A_rotate.degrees">rotate.degrees</code></td>
<td>
<p>a value specifying the degrees the biplot should be rotated, with default <code>0</code>. A positive value results in anti-clockwise rotation and a negative value in clockwise rotation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>biplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4],group.aes = iris[,5]) |&gt; PCA() |&gt; rotate(200) |&gt; plot()

</code></pre>

<hr>
<h2 id='samples'>Aesthetics for biplot samples</h2><span id='topic+samples'></span>

<h3>Description</h3>

<p>This function allows formatting changes to samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samples (bp,  which = 1:bp$g, col = ez.col, pch = 16, cex = 1,
label = FALSE, label.name = NULL, label.col=NULL, label.cex = 0.75, 
label.side = "bottom", label.offset = 0.5,
connected=FALSE, connect.col = "black", connect.lty = 1, 
connect.lwd = 1, opacity = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samples_+3A_bp">bp</code></td>
<td>
<p>an object of class <code>biplot</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_which">which</code></td>
<td>
<p>vector of which groups of samples to display, with default <code>bp$g</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_col">col</code></td>
<td>
<p>sample colour, with default <code>blue</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_pch">pch</code></td>
<td>
<p>sample plotting character, with default <code>+</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_cex">cex</code></td>
<td>
<p>sample character expansion, with default <code>1</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_label">label</code></td>
<td>
<p>logical (<code>TRUE</code>, <code>FALSE</code>), whether samples should be labelled, with default <code>FALSE</code>. Alternatively, specify <code>"ggrepel"</code> for non-overlapping placement of labels.</p>
</td></tr>
<tr><td><code id="samples_+3A_label.name">label.name</code></td>
<td>
<p>vector of length number of samples, with default
<code>NULL</code>, <code>rownames(bp)</code> are used.</p>
</td></tr>
<tr><td><code id="samples_+3A_label.col">label.col</code></td>
<td>
<p>vector of length number of samples with the colour of the labels, defaulting to the
colour of the sample points.</p>
</td></tr>
<tr><td><code id="samples_+3A_label.cex">label.cex</code></td>
<td>
<p>label text expansion, with default <code>0.75</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_label.side">label.side</code></td>
<td>
<p>side of the plotting character where label appears, with default <code>bottom</code>. Note that unlike
the argument <code>pos</code> in <code>text()</code>, options are &quot;bottom&quot;, &quot;left&quot;, &quot;top&quot;, &quot;right&quot; and not 1, 2, 3, 4.</p>
</td></tr>
<tr><td><code id="samples_+3A_label.offset">label.offset</code></td>
<td>
<p>offset of the label from the data point. See ?text for a detailed explanation of the
argument <code>offset</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_connected">connected</code></td>
<td>
<p>logical, whether samples are connected in order of rows of data matrix, with default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_connect.col">connect.col</code></td>
<td>
<p>colour of the connecting line, with default <code>black</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_connect.lty">connect.lty</code></td>
<td>
<p>line type of the connecting line, with default <code>1</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_connect.lwd">connect.lwd</code></td>
<td>
<p>line width of the connecting line, with default <code>1</code>.</p>
</td></tr>
<tr><td><code id="samples_+3A_opacity">opacity</code></td>
<td>
<p>opacity of sample points, with default 1 (opaque).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>which</code>, <code>col</code>, <code>pch</code> and <code>cex</code> are based on the specification of <code>group.aes</code> or <code>classes</code>. If no groups
are specified, a single colour, plotting character and / or character expansion is expected. If g groups are
specified, vectors of length g is expected, or values are recycled to length g.
</p>
<p>The arguments <code>label</code>, <code>label.cex</code>, <code>label.side</code> and <code>label.offset</code> are based on the sample size n. A single value
will be recycled n times or a vector of length n is expected.
</p>


<h3>Value</h3>

<p>A list with the following components is available:
</p>
<table>
<tr><td><code>which</code></td>
<td>
<p>which means to display.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>colour of the samples.</p>
</td></tr>
<tr><td><code>pch</code></td>
<td>
<p>plotting character of the samples.</p>
</td></tr>
<tr><td><code>cex</code></td>
<td>
<p>expansion of the plotting character of the samples.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>TRUE or FALSE, whether samples should be labelled, with default
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code>label.name</code></td>
<td>
<p>If <code>NULL</code>, the row names will be used, with default <code>NULL</code>. Alternatively, a vector of length <code>n</code> should be used.</p>
</td></tr>
<tr><td><code>label.col</code></td>
<td>
<p>colour of the label.</p>
</td></tr>
<tr><td><code>label.cex</code></td>
<td>
<p>expansion of the label.</p>
</td></tr>
<tr><td><code>label.side</code></td>
<td>
<p>side at which to plot the label of samples.</p>
</td></tr>
<tr><td><code>label.offset</code></td>
<td>
<p>offset of the label from the data point.</p>
</td></tr>
<tr><td><code>connected</code></td>
<td>
<p>TRUE or FALSE, whether samples should be connected in row order of X.</p>
</td></tr>
<tr><td><code>connect.col</code></td>
<td>
<p>colour of the connecting line.</p>
</td></tr>
<tr><td><code>connect.lty</code></td>
<td>
<p>line type of the connecting line.</p>
</td></tr>
<tr><td><code>connect.lwd</code></td>
<td>
<p>line width of the connecting line.</p>
</td></tr>
<tr><td><code>opacity</code></td>
<td>
<p>opacity of sample points, with default 1 (opaque).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>biplot(iris[,1:4]) |&gt; PCA() |&gt; samples(col="purple",pch=15, opacity=0.5) |&gt; plot()
biplot(iris[,1:4]) |&gt; PCA() |&gt; 
  samples(col="purple",pch=NA, opacity=0.5, label = TRUE) |&gt; plot()
biplot(iris[,1:4]) |&gt; PCA() |&gt; 
  samples(col="purple",pch=NA, opacity=0.5, label = TRUE, 
          label.name = paste("s:",1:150, sep="")) |&gt; 
  plot()
biplot(iris[,1:4]) |&gt; PCA() |&gt; 
  samples(col="purple",pch=NA, opacity=0.5, label = "ggrepel") |&gt; plot()

</code></pre>

<hr>
<h2 id='sqrtManhattan'>Computes the square root of the Manhattan distance
An example of a Euclidean embeddable distance metric</h2><span id='topic+sqrtManhattan'></span>

<h3>Description</h3>

<p>Computes the square root of the Manhattan distance
An example of a Euclidean embeddable distance metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrtManhattan(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqrtManhattan_+3A_x">X</code></td>
<td>
<p>matrix of samples x variables for computation of samples x samples distance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dist object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sqrtManhattan(iris[,1:4])
</code></pre>

<hr>
<h2 id='summary.biplot'>Generic summary function for objects of class biplot</h2><span id='topic+summary.biplot'></span>

<h3>Description</h3>

<p>This function is used to print summary output of the biplot. These summary outputs are related to measures of fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biplot'
summary(
  object,
  adequacy = TRUE,
  axis.predictivity = TRUE,
  sample.predictivity = TRUE,
  class.predictivity = TRUE,
  within.class.axis.predictivity = TRUE,
  within.class.sample.predictivity = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.biplot_+3A_object">object</code></td>
<td>
<p>an object of class <code>biplot</code>.</p>
</td></tr>
<tr><td><code id="summary.biplot_+3A_adequacy">adequacy</code></td>
<td>
<p>a logical value indicating whether variable adequacies should be reported, with default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.biplot_+3A_axis.predictivity">axis.predictivity</code></td>
<td>
<p>a logical value indicating whether axis predictivities should be reported, with default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.biplot_+3A_sample.predictivity">sample.predictivity</code></td>
<td>
<p>a logical value indicating whether sample predictivities should be reported, with default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.biplot_+3A_class.predictivity">class.predictivity</code></td>
<td>
<p>a logical value indicating whether class predictivities should be reported, with default <code>TRUE</code>
(only applicable to objects of class <code>CVA</code>).</p>
</td></tr>
<tr><td><code id="summary.biplot_+3A_within.class.axis.predictivity">within.class.axis.predictivity</code></td>
<td>
<p>a logical value indicating whether within class axis predictivity
should be reported, with default <code>TRUE</code> (only applicable to objects
of class <code>CVA</code>).</p>
</td></tr>
<tr><td><code id="summary.biplot_+3A_within.class.sample.predictivity">within.class.sample.predictivity</code></td>
<td>
<p>a logical value indicating whether within class sample predictivity
should be reported, with default <code>TRUE</code> (only applicable to objects
of class <code>CVA</code>).</p>
</td></tr>
<tr><td><code id="summary.biplot_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will not produce a return value, it is called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- biplot (iris[,1:4]) |&gt; PCA() |&gt; fit.measures()
summary(out)

</code></pre>

<hr>
<h2 id='translate_axes'>Translate biplot axes</h2><span id='topic+translate_axes'></span>

<h3>Description</h3>

<p>Automatically or manually translate the axes away from the center of the plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_axes(bp, delta = 0, swop = FALSE, distances = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_axes_+3A_bp">bp</code></td>
<td>
<p>An object of class <code>biplot</code></p>
</td></tr>
<tr><td><code id="translate_axes_+3A_delta">delta</code></td>
<td>
<p>numeric value indicating distance between axes</p>
</td></tr>
<tr><td><code id="translate_axes_+3A_swop">swop</code></td>
<td>
<p>logical. Change the direction in which axes are translated</p>
</td></tr>
<tr><td><code id="translate_axes_+3A_distances">distances</code></td>
<td>
<p>numeric vector of distances. Used to manually parallel translate the axes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the same algorithm implemented in <code><a href="bipl5.html#topic+TDAbiplot">TDAbiplot</a></code>
in the <code>bipl5</code> package. It translates the axes out of the center of the plot.
Correlated axes generally gets translated in the same direction.
</p>
<p>This function calculates the <code>orthogx</code> and <code>orthogy</code> paramaters in <code><a href="#topic+axes">axes()</a></code>
</p>


<h3>Value</h3>

<p>An object of class <code>biplot</code> with the translated distances appended under bp$axes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Translate the axes out of the plot center

bp &lt;- biplot(state.x77,scaled = TRUE)|&gt; 
      CVA(state.region) |&gt; 
      translate_axes(swop=TRUE,delta =0.2)|&gt;
      plot(exp.factor=3)

#adjust the distance of an axis

dist &lt;- bp$axes$translate_distance
dist[7] &lt;- 0.4
bp |&gt; translate_axes(delta = 0.2, distances=dist) |&gt; plot()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
