<!DOCTYPE html><html lang="en"><head><title>Help for package vcd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vcd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#agreementplot'><p>Bangdiwala's Observer Agreement Chart</p></a></li>
<li><a href='#Arthritis'><p>Arthritis Treatment Data</p></a></li>
<li><a href='#assoc'><p>Extended Association Plots</p></a></li>
<li><a href='#assocstats'><p>Association Statistics</p></a></li>
<li><a href='#Baseball'><p>Baseball Data</p></a></li>
<li><a href='#binreg_plot'><p>Binary Regression Plot</p></a></li>
<li><a href='#BrokenMarriage'><p>Broken Marriage Data</p></a></li>
<li><a href='#Bundesliga'><p>Ergebnisse der Fussball-Bundesliga</p></a></li>
<li><a href='#Bundestag2005'><p>Votes in German Bundestag Election 2005</p></a></li>
<li><a href='#Butterfly'><p>Butterfly Species in Malaya</p></a></li>
<li><a href='#cd_plot'><p>Conditional Density Plots</p></a></li>
<li><a href='#co_table'><p>Compute Conditional Tables</p></a></li>
<li><a href='#CoalMiners'><p>Breathlessness and Wheeze in Coal Miners</p></a></li>
<li><a href='#coindep_test'><p>Test for (Conditional) Independence</p></a></li>
<li><a href='#cotab_panel'><p>Panel-generating Functions for Contingency Table Coplots</p></a></li>
<li><a href='#cotabplot'><p>Coplot for Contingency Tables</p></a></li>
<li><a href='#DanishWelfare'><p>Danish Welfare Study Data</p></a></li>
<li><a href='#distplot'><p>Diagnostic Distribution Plots</p></a></li>
<li><a href='#doubledecker'><p>Doubledecker Plot</p></a></li>
<li><a href='#Employment'><p>Employment Status</p></a></li>
<li><a href='#Federalist'><p>&lsquo;May&rsquo; in Federalist Papers</p></a></li>
<li><a href='#fourfold'><p>Fourfold Plots</p></a></li>
<li><a href='#goodfit'><p>Goodness-of-fit Tests for Discrete Data</p></a></li>
<li><a href='#grid_barplot'><p>Barplot</p></a></li>
<li><a href='#grid_legend'><p>Legend Function for grid Graphics</p></a></li>
<li><a href='#Hitters'><p>Hitters Data</p></a></li>
<li><a href='#hls'><p>HLS Color Specification</p></a></li>
<li><a href='#HorseKicks'><p>Death by Horse Kicks</p></a></li>
<li><a href='#Hospital'><p>Hospital data</p></a></li>
<li><a href='#independence_table'><p>Independence Table</p></a></li>
<li><a href='#JobSatisfaction'><p>Job Satisfaction Data</p></a></li>
<li><a href='#JointSports'><p>Opinions About Joint Sports</p></a></li>
<li><a href='#Kappa'><p>Cohen's Kappa and Weighted Kappa</p></a></li>
<li><a href='#labeling_border'><p>Labeling Functions for Strucplots</p></a></li>
<li><a href='#labeling_cells_list'><p>Labeling Functions for Strucplots</p></a></li>
<li><a href='#legends'><p>Legend Functions for Strucplots</p></a></li>
<li><a href='#Lifeboats'><p>Lifeboats on the Titanic</p></a></li>
<li><a href='#lodds'>
<p>Calculate Generalized Log Odds for Frequency Tables</p></a></li>
<li><a href='#loddsratio'>
<p>Calculate Generalized Log Odds Ratios for Frequency Tables</p></a></li>
<li><a href='#mar_table'><p>Table with Marginal Sums</p></a></li>
<li><a href='#mosaic'><p>Extended Mosaic Plots</p></a></li>
<li><a href='#mplot'><p>Multiple Grid plots</p></a></li>
<li><a href='#MSPatients'><p>Diagnosis of Multiple Sclerosis</p></a></li>
<li><a href='#NonResponse'><p>Non-Response Survey Data</p></a></li>
<li><a href='#Ord_plot'><p>Ord Plots</p></a></li>
<li><a href='#OvaryCancer'><p>Ovary Cancer Data</p></a></li>
<li><a href='#Pairs+20plot+20panel+20functions+20for+20diagonal+20cells'><p>Diagonal Panel Functions for Table Pairs Plot</p></a></li>
<li><a href='#Pairs+20plot+20panel+20functions+20for+20off-diagonal+20cells'><p>Off-diagonal Panel Functions for Table Pairs Plot</p></a></li>
<li><a href='#pairs.table'><p>Pairs Plot for Contingency Tables</p></a></li>
<li><a href='#plot.loddsratio'><p>Plotting (Log) Odds Ratios</p></a></li>
<li><a href='#plot.loglm'><p>Visualize Fitted Log-linear Models</p></a></li>
<li><a href='#PreSex'><p>Pre-marital Sex and Divorce</p></a></li>
<li><a href='#Punishment'><p>Corporal Punishment Data</p></a></li>
<li><a href='#RepVict'><p>Repeat Victimization Data</p></a></li>
<li><a href='#Rochdale'><p>Rochdale Data</p></a></li>
<li><a href='#rootogram'><p>Rootograms</p></a></li>
<li><a href='#Saxony'><p>Families in Saxony</p></a></li>
<li><a href='#SexualFun'><p>Sex is Fun</p></a></li>
<li><a href='#shadings'><p>Shading-generating Functions for Residual-based Shadings</p></a></li>
<li><a href='#sieve'><p>Extended Sieve Plots</p></a></li>
<li><a href='#SpaceShuttle'><p>Space Shuttle O-ring Failures</p></a></li>
<li><a href='#spacings'><p>Spacing-generating Functions</p></a></li>
<li><a href='#spine'><p>Spine Plots and Spinograms</p></a></li>
<li><a href='#struc_assoc'><p>Core-generating Function for Association Plots</p></a></li>
<li><a href='#struc_mosaic'><p>Core-generating Function for Mosaic Plots</p></a></li>
<li><a href='#struc_sieve'><p>Core-generating Function for Sieve Plots</p></a></li>
<li><a href='#strucplot'><p>Structured Displays of Contingency Tables</p></a></li>
<li><a href='#structable'><p>Structured Contingency Tables</p></a></li>
<li><a href='#Suicide'><p>Suicide Rates in Germany</p></a></li>
<li><a href='#table2d_summary'><p>Summary of a 2-way Table</p></a></li>
<li><a href='#ternaryplot'><p>Ternary Diagram</p></a></li>
<li><a href='#tile'><p>Tile Plot</p></a></li>
<li><a href='#Trucks'><p>Truck Accidents Data</p></a></li>
<li><a href='#UKSoccer'><p>UK Soccer Scores</p></a></li>
<li><a href='#VisualAcuity'><p>Visual Acuity in Left and Right Eyes</p></a></li>
<li><a href='#VonBort'><p>Von Bortkiewicz Horse Kicks Data</p></a></li>
<li><a href='#WeldonDice'><p>Weldon's Dice Data</p></a></li>
<li><a href='#WomenQueue'><p>Women in Queues</p></a></li>
<li><a href='#woolf_test'><p>Woolf Test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.4-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Visualizing Categorical Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Visualization techniques, data sets, summary and inference
        procedures aimed particularly at categorical data. Special
        emphasis is given to highly extensible grid graphics. The
        package was package was originally inspired by the book 
	"Visualizing Categorical Data" by Michael Friendly and is 
	now the main support package for a new book, 
	"Discrete Data Analysis with R" by Michael Friendly and 
	David Meyer (2015).</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.4.0), grid</td>
</tr>
<tr>
<td>Suggests:</td>
<td>KernSmooth, mvtnorm, kernlab, HSAUR3, coin</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, MASS, grDevices, colorspace, lmtest</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-16 09:01:34 UTC; meyer</td>
</tr>
<tr>
<td>Author:</td>
<td>David Meyer <a href="https://orcid.org/0000-0002-5196-3048"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Florian Gerber [ctb],
  Michael Friendly <a href="https://orcid.org/0000-0002-3237-0941"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Meyer &lt;David.Meyer@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-16 10:13:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='agreementplot'>Bangdiwala's Observer Agreement Chart</h2><span id='topic+agreementplot'></span><span id='topic+agreementplot.default'></span><span id='topic+agreementplot.formula'></span>

<h3>Description</h3>

<p>Representation of a <code class="reqn">k \times k</code> confusion matrix,
where the observed and expected diagonal elements are represented by
superposed black and white rectangles, respectively.  The function
also computes a statistic measuring the strength of agreement
(relation of respective area sums).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
agreementplot(x, reverse_y = TRUE, main = NULL,
              weights = c(1, 1 - 1/(ncol(x) - 1)^2), margins = par("mar"),
              newpage = TRUE, pop = TRUE, 
              xlab = names(dimnames(x))[2],
              ylab = names(dimnames(x))[1],
              xlab_rot = 0, xlab_just = "center",
              ylab_rot = 90, ylab_just = "center",
              fill_col = function(j) gray((1 - (weights[j]) ^ 2) ^ 0.5),
              line_col = "red", xscale = TRUE, yscale = TRUE,
              return_grob = FALSE,
              prefix = "", ...)
## S3 method for class 'formula'
agreementplot(formula, data = NULL, ..., subset)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agreementplot_+3A_x">x</code></td>
<td>
<p>a confusion matrix, i.e., a table with equal-sized dimensions.</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_reverse_y">reverse_y</code></td>
<td>
<p>if <code>TRUE</code>, the y axis is reversed (i.e., the
rectangles' positions correspond to the contingency table).</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_main">main</code></td>
<td>
<p>user-specified main title.</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_weights">weights</code></td>
<td>
<p>vector of weights for successive larger observed areas,
used in the agreement strength statistic, and also for the
shading.  The first element should be 1.</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_margins">margins</code></td>
<td>
<p>vector of margins (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_newpage">newpage</code></td>
<td>
<p>logical; if <code>TRUE</code>, the plot is drawn on a new page.</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_pop">pop</code></td>
<td>
<p>logical; if <code>TRUE</code>, all newly generated viewports are popped after plotting.</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_return_grob">return_grob</code></td>
<td>
<p>logical. Should a snapshot of the display be
returned as a grid grob?</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_xlab">xlab</code>, <code id="agreementplot_+3A_ylab">ylab</code></td>
<td>
<p>labels of x- and y-axis.</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_xlab_rot">xlab_rot</code>, <code id="agreementplot_+3A_ylab_rot">ylab_rot</code></td>
<td>
<p>rotation angle for the category labels.</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_xlab_just">xlab_just</code>, <code id="agreementplot_+3A_ylab_just">ylab_just</code></td>
<td>
<p>justification for the category labels.</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_fill_col">fill_col</code></td>
<td>
<p>a function, giving the fill colors used for exact and partial agreement</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_line_col">line_col</code></td>
<td>
<p>color used for the diagonal reference line</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_formula">formula</code></td>
<td>
<p>a formula, such as <code>y ~ x</code>.
For details, see <code><a href="stats.html#topic+xtabs">xtabs</a></code>.</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_data">data</code></td>
<td>
<p>a data frame (or list), or a contingency table from which
the variables in <code>formula</code> should be taken.</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of the rows in
the data frame to be used for plotting.</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_xscale">xscale</code>, <code id="agreementplot_+3A_yscale">yscale</code></td>
<td>
<p>logicals indicating whether the marginals should
be added on the x-axis/y-axis, respectively.</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_prefix">prefix</code></td>
<td>
<p>character string used as prefix for the viewport name</p>
</td></tr>
<tr><td><code id="agreementplot_+3A_...">...</code></td>
<td>
<p>further graphics parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weights can be specified to allow for partial agreement, taking into
account contributions from off-diagonal cells.  Partial agreement
is typically represented in the display by lighter shading, as given by
<code>fill_col(j)</code>, corresponding to <code>weights[j]</code>.
</p>
<p>A weight vector of
length 1 means strict agreement only, each additional element
increases the maximum number of disagreement steps.
</p>
<p><code><a href="#topic+cotabplot">cotabplot</a></code> can be used for stratified analyses (see examples).
</p>


<h3>Value</h3>

<p>Invisibly returned, a list with components
</p>
<table role = "presentation">
<tr><td><code>Bangdiwala</code></td>
<td>
<p>the unweighted agreement strength statistic.</p>
</td></tr>
<tr><td><code>Bangdiwala_Weighted</code></td>
<td>
<p>the weighted statistic.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the weight vector used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Bangdiwala, S. I. (1988). The Agreement Chart.  Department of Biostatistics,
University of North Carolina at Chapel Hill,
Institute of Statistics Mimeo Series No. 1859,
<a href="https://repository.lib.ncsu.edu/bitstreams/fea554e9-8750-4f1a-8419-ee126ce1a790/download">https://repository.lib.ncsu.edu/bitstreams/fea554e9-8750-4f1a-8419-ee126ce1a790/download</a>
</p>
<p>Bangdiwala, S. I.,  Ana S. Haedo, Marcela L. Natal, and Andres
Villaveces. The agreement chart as an alternative to the
receiver-operating characteristic curve for diagnostic tests. 
<em>Journal of Clinical Epidemiology</em>, 61 (9), 866-874.
</p>
<p>Michael Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SexualFun")
agreementplot(t(SexualFun))

data("MSPatients")
## Not run: 
## best visualized using a resized device, e.g. using:
## get(getOption("device"))(width = 12)
pushViewport(viewport(layout = grid.layout(ncol = 2)))
pushViewport(viewport(layout.pos.col = 1))
agreementplot(t(MSPatients[,,1]), main = "Winnipeg Patients",
              newpage = FALSE)
popViewport()
pushViewport(viewport(layout.pos.col = 2))
agreementplot(t(MSPatients[,,2]), main = "New Orleans Patients",
              newpage = FALSE)
popViewport(2)
dev.off()

## End(Not run)

## alternatively, use cotabplot:
cotabplot(MSPatients, panel = cotab_agreementplot)
</code></pre>

<hr>
<h2 id='Arthritis'>Arthritis Treatment Data</h2><span id='topic+Arthritis'></span>

<h3>Description</h3>

<p>Data from Koch &amp; Edwards (1988) from a double-blind clinical trial
investigating a new treatment for rheumatoid arthritis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Arthritis")</code></pre>


<h3>Format</h3>

<p>A data frame with 84 observations and 5 variables.
</p>

<dl>
<dt>ID</dt><dd><p>patient ID.</p>
</dd>
<dt>Treatment</dt><dd><p>factor indicating treatment (Placebo, Treated).</p>
</dd>
<dt>Sex</dt><dd><p>factor indicating sex (Female, Male).</p>
</dd>
<dt>Age</dt><dd><p>age of patient.</p>
</dd>
<dt>Improved</dt><dd><p>ordered factor indicating treatment outcome (None,
Some, Marked).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Michael Friendly (2000),
Visualizing Categorical Data:
<a href="http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/arthrit.sas">http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/arthrit.sas</a>
</p>


<h3>References</h3>

<p>G. Koch &amp; S. Edwards (1988),
Clinical efficiency trials with categorical data.
In K. E. Peace (ed.), <em>Biopharmaceutical Statistics for Drug
Development</em>, 403&ndash;451.
Marcel Dekker, New York.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Arthritis")
art &lt;- xtabs(~ Treatment + Improved, data = Arthritis, subset = Sex == "Female")
art

mosaic(art, gp = shading_Friendly)
mosaic(art, gp = shading_max)
</code></pre>

<hr>
<h2 id='assoc'>Extended Association Plots</h2><span id='topic+assoc'></span><span id='topic+assoc.default'></span><span id='topic+assoc.formula'></span>

<h3>Description</h3>

<p>Produce an association plot indicating deviations from a
specified independence model in a possibly high-dimensional
contingency table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
assoc(x, row_vars = NULL, col_vars = NULL, compress = TRUE,
  xlim = NULL, ylim = NULL,
  spacing = spacing_conditional(sp = 0), spacing_args = list(),
  split_vertical = NULL, keep_aspect_ratio = FALSE, 
  xscale = 0.9, yspace = unit(0.5, "lines"), main = NULL, sub = NULL,
  ..., residuals_type = "Pearson", gp_axis = gpar(lty = 3))
## S3 method for class 'formula'
assoc(formula, data = NULL, ..., subset = NULL, na.action = NULL, main = NULL, sub = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assoc_+3A_x">x</code></td>
<td>
<p>a contingency table in array form with optional category
labels specified in the <code>dimnames(x)</code> attribute, or an object
inheriting from the <code>"ftable"</code> class (such as
<code>"structable"</code> objects).</p>
</td></tr>
<tr><td><code id="assoc_+3A_row_vars">row_vars</code></td>
<td>
<p>a vector of integers giving the indices, or a
character vector giving the names of the variables to be used for
the rows of the association plot.</p>
</td></tr>
<tr><td><code id="assoc_+3A_col_vars">col_vars</code></td>
<td>
<p>a vector of integers giving the indices, or a
character vector giving the names of the variables to be used for
the columns of the association plot.</p>
</td></tr>
<tr><td><code id="assoc_+3A_compress">compress</code></td>
<td>
<p>logical; if <code>FALSE</code>, the space between the rows
(columns) are chosen such that the <em>total</em> heights (widths) of
the rows (columns) are all equal.  If <code>TRUE</code>, the space between
rows and columns is fixed and hence the plot is more
&ldquo;compressed&rdquo;.</p>
</td></tr>
<tr><td><code id="assoc_+3A_xlim">xlim</code></td>
<td>
<p>a <code class="reqn">2 \times k</code> matrix of doubles, <code class="reqn">k</code>
number of total columns of the plot.  The columns of <code>xlim</code>
correspond to the columns of the association plot, the rows describe
the column ranges (minimums in the first row, maximums in the second
row).  If <code>xlim</code> is <code>NULL</code>, the ranges are determined from
the residuals according to <code>compress</code> (if <code>TRUE</code>: widest
range from each column, if <code>FALSE</code>: from the whole association
plot matrix).</p>
</td></tr>
<tr><td><code id="assoc_+3A_ylim">ylim</code></td>
<td>
<p>a <code class="reqn">2 \times k</code> matrix of doubles, <code class="reqn">k</code>
number of total rows of the plot.  The columns of <code>ylim</code>
correspond to the rows of the association plot, the rows describe
the column ranges (minimums in the first row, maximums in the second
row).  If <code>ylim</code> is <code>NULL</code>, the ranges are determined from
the residuals according to <code>compress</code> (if <code>TRUE</code>: widest
range from each row, if <code>FALSE</code>: from the whole association
plot matrix).</p>
</td></tr>
<tr><td><code id="assoc_+3A_spacing">spacing</code></td>
<td>
<p>a spacing object, a spacing function, or a
corresponding generating function (see <code><a href="#topic+strucplot">strucplot</a></code> for
more information).  The default is the spacing-generating function
<code><a href="#topic+spacing_conditional">spacing_conditional</a></code> that is (by default) called with the
argument list <code>spacing_args</code> (see <code>spacings</code> for more details).</p>
</td></tr>
<tr><td><code id="assoc_+3A_spacing_args">spacing_args</code></td>
<td>
<p>list of arguments for the spacing-generating function, if
specified (see <code><a href="#topic+strucplot">strucplot</a></code> for more information).</p>
</td></tr>
<tr><td><code id="assoc_+3A_split_vertical">split_vertical</code></td>
<td>
<p>vector of logicals of length <code class="reqn">k</code>, where <code class="reqn">k</code>
is the number of margins of <code>x</code> (default: <code>FALSE</code>).
Values are recycled as needed.
A <code>TRUE</code> component indicates that the corresponding dimension
is folded into the columns, <code>FALSE</code> folds the dimension into the
rows.</p>
</td></tr>
<tr><td><code id="assoc_+3A_keep_aspect_ratio">keep_aspect_ratio</code></td>
<td>
<p>logical indicating whether the aspect ratio should be
fixed or not.</p>
</td></tr>
<tr><td><code id="assoc_+3A_residuals_type">residuals_type</code></td>
<td>
<p>a character string indicating the type of
residuals to be computed. Currently, only Pearson residuals are
supported.</p>
</td></tr>
<tr><td><code id="assoc_+3A_xscale">xscale</code></td>
<td>
<p>scale factor resizing the tile's width, thus adding
additional space between the tiles. </p>
</td></tr>
<tr><td><code id="assoc_+3A_yspace">yspace</code></td>
<td>
<p>object of class <code>"unit"</code> specifying additional
space separating the rows.</p>
</td></tr>
<tr><td><code id="assoc_+3A_gp_axis">gp_axis</code></td>
<td>
<p>object of class <code>"gpar"</code> specifying the visual
aspects of the tiles' baseline.</p>
</td></tr>
<tr><td><code id="assoc_+3A_formula">formula</code></td>
<td>
<p>a formula object with possibly both left and right hand
sides specifying the column and row variables of the flat table.</p>
</td></tr>
<tr><td><code id="assoc_+3A_data">data</code></td>
<td>
<p>a data frame, list or environment containing the variables
to be cross-tabulated, or an object inheriting from class <code>table</code>.</p>
</td></tr>
<tr><td><code id="assoc_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used. Ignored if <code>data</code> is a contingency table.</p>
</td></tr>
<tr><td><code id="assoc_+3A_na.action">na.action</code></td>
<td>
<p>an optional function which indicates what should happen when
the data contain <code>NA</code>s. Ignored if <code>data</code> is a contingency table.</p>
</td></tr>
<tr><td><code id="assoc_+3A_main">main</code>, <code id="assoc_+3A_sub">sub</code></td>
<td>
<p>either a logical, or a character string used for plotting
the main (sub) title.  If logical and <code>TRUE</code>, the
name of the <code>data</code> object is used.</p>
</td></tr>
<tr><td><code id="assoc_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code><a href="#topic+strucplot">strucplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Association plots have been suggested by Cohen (1980) and extended
by Friendly (1992) and provide a means for visualizing the residuals
of an independence model for a contingency table.
</p>
<p><code>assoc</code> is a generic function and currently has a default method and a
formula interface.  Both are high-level interfaces to the
<code><a href="#topic+strucplot">strucplot</a></code> function, and produce (extended) association
plots.  Most of the functionality is described there, such as
specification of the independence model, labeling, legend, spacing,
shading, and other graphical parameters.
</p>
<p>For a contingency table, the signed contribution
to Pearson's <code class="reqn">\chi^2</code> for cell <code class="reqn">\{ij\ldots k\}</code> is
</p>
<p style="text-align: center;"><code class="reqn">d_{ij\ldots k} = \frac{(f_{ij\ldots k} - e_{ij\ldots k})}{
      \sqrt{e_{ij\ldots k}}}</code>
</p>

<p>where <code class="reqn">f_{ij\ldots k}</code> and <code class="reqn">e_{ij\ldots
      k}</code> 
are the observed and  expected counts corresponding to the cell.  In
the association plot, each cell is represented by a
rectangle that has (signed) height proportional to <code class="reqn">d_{ij\ldots
      k}</code> 
and width proportional to
<code class="reqn">\sqrt{e_{ij\ldots k}}</code>,
so that the area of the box is proportional to the difference in
observed and expected frequencies.  The rectangles in each row are
positioned relative to a baseline indicating independence
(<code class="reqn">d_{ij\ldots k} = 0</code>). 
If the observed frequency of a cell is greater than the expected one,
the box rises above the baseline, and falls below otherwise.
</p>
<p>Additionally, the residuals can be colored depending on a specified
shading scheme (see Meyer et al., 2003).  Package <span class="pkg">vcd</span> offers a range of
<em>residual-based</em> shadings (see the shadings help page). Some of
them allow, e.g., the visualization of test statistics.
</p>
<p>Unlike the <code><a href="graphics.html#topic+assocplot">assocplot</a></code> function in the
<span class="pkg">graphics</span> package, this function allows the visualization of
contingency tables with more than two dimensions. Similar to the
construction of &lsquo;flat&rsquo; tables (like objects of class <code>"ftable"</code> or
<code>"structable"</code>), the dimensions are folded into rows and columns.
</p>
<p>The layout is very flexible: the specification of shading, labeling,
spacing, and legend is modularized (see <code><a href="#topic+strucplot">strucplot</a></code> for
details).
</p>


<h3>Value</h3>

<p>The <code>"structable"</code> visualized is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Cohen, A. (1980),
On the graphical display of the significant components in a two-way
contingency table.
<em>Communications in Statistics&mdash;Theory and Methods</em>, <b>A9</b>,
1025&ndash;1041.
</p>
<p>Friendly, M. (1992),
Graphical methods for categorical data.
<em>SAS User Group International Conference Proceedings</em>, <b>17</b>,
190&ndash;200.
<a href="http://datavis.ca/papers/sugi/sugi17.pdf">http://datavis.ca/papers/sugi/sugi17.pdf</a>
</p>
<p>Meyer, D., Zeileis, A., Hornik, K. (2003), Visualizing independence using
extended association plots. <em>Proceedings of the 3rd International
Workshop on Distributed Statistical Computing</em>, K. Hornik, F. Leisch,
A. Zeileis (eds.), ISSN 1609-395X.
<a href="https://www.R-project.org/conferences/DSC-2003/Proceedings/">https://www.R-project.org/conferences/DSC-2003/Proceedings/</a>
</p>
<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as <code>vignette ("strucplot", package = "vcd")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mosaic">mosaic</a></code>,
<code><a href="#topic+strucplot">strucplot</a></code>,
<code><a href="#topic+structable">structable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HairEyeColor")
## Aggregate over sex:
(x &lt;- margin.table(HairEyeColor, c(1, 2)))

## Ordinary assocplot:
assoc(x)
## and with residual-based shading (of independence)
assoc(x, main = "Relation between hair and eye color", shade = TRUE)

## Aggregate over Eye color:
(x &lt;- margin.table(HairEyeColor, c(1, 3)))
chisq.test(x)
assoc(x, main = "Relation between hair color and sex", shade = TRUE)

# Visualize multi-way table
assoc(aperm(HairEyeColor), expected = ~ (Hair + Eye) * Sex,
      labeling_args = list(just_labels = c(Eye = "left"),
                           offset_labels = c(right = -0.5),
                           offset_varnames = c(right = 1.2),
                           rot_labels = c(right = 0),
                           tl_varnames = c(Eye = TRUE))
)

assoc(aperm(UCBAdmissions), expected = ~ (Admit + Gender) * Dept, compress = FALSE,
      labeling_args = list(abbreviate_labs = c(Gender = TRUE), rot_labels = 0)
)
</code></pre>

<hr>
<h2 id='assocstats'>Association Statistics</h2><span id='topic+assocstats'></span><span id='topic+summary.assocstats'></span><span id='topic+print.assocstats'></span><span id='topic+print.summary.assocstats'></span>

<h3>Description</h3>

<p>Computes the Pearson chi-Squared test, the Likelihood Ratio chi-Squared test,
the phi coefficient, the contingency coefficient and Cramer's V for
possibly stratified contingency tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assocstats(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assocstats_+3A_x">x</code></td>
<td>
<p>a contingency table, with possibly more than 2 dimensions. In
this case, all dimensions except the first two ones are considered as strata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of a 2-dimensional table, a list with components:
</p>
<table role = "presentation">
<tr><td><code>chisq_tests</code></td>
<td>
<p>a <code class="reqn">2 \times 3</code> table with the
chi-squared statistics.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>The <em>absolute value</em> of the phi coefficient (only
defined for <code class="reqn">2 \times 2</code> tables).</p>
</td></tr>
<tr><td><code>cont</code></td>
<td>
<p>The contingency coefficient.</p>
</td></tr>
<tr><td><code>cramer</code></td>
<td>
<p>Cramer's V.</p>
</td></tr>
</table>
<p>In case of higher-dimensional tables, a list of the above mentioned
structure, each list component representing one stratum defined by the
combinations of all levels of the stratum dimensions.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Michael Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>
<p>Fleiss, J. L. (1981).
<em>Statistical methods for rates and proportions</em>
(2nd ed). New York: Wiley 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Arthritis")
tab &lt;- xtabs(~Improved + Treatment, data = Arthritis)
summary(assocstats(tab))

assocstats(UCBAdmissions)
</code></pre>

<hr>
<h2 id='Baseball'>Baseball Data</h2><span id='topic+Baseball'></span>

<h3>Description</h3>

<p>Baseball data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Baseball")
</code></pre>


<h3>Format</h3>

<p>A data frame with 322 observations and 25 variables.
</p>

<dl>
<dt>name1</dt><dd><p>player's first name.</p>
</dd>
<dt>name2</dt><dd><p>player's last name.</p>
</dd>
<dt>atbat86</dt><dd><p>times at Bat: number of official plate appearances by
a hitter.  It counts as an official at-bat as long as the batter
does not walk, sacrifice, get hit by a pitch or reach base due to
catcher's interference.</p>
</dd>
<dt>hits86</dt><dd><p>hits.</p>
</dd>
<dt>homer86</dt><dd><p>home runs.</p>
</dd>
<dt>runs86</dt><dd><p>the number of runs scored by a player.  A run is
scored by an offensive player who advances from batter to runner
and touches first, second, third and home base in that order
without being put out.</p>
</dd> 
<dt>rbi86</dt><dd><p>Runs Batted In: A hitter earns a run batted in when he
drives in a run via a hit, walk, sacrifice (bunt or fly) fielder's
choice, hit-batsman or on an error (when the official scorer rules
that the run would have scored anyway).</p>
</dd>
<dt>walks86</dt><dd><p>A &ldquo;walk&rdquo; (or &ldquo;base on balls&rdquo;) is an
award of first base granted to a batter who receives four pitches
outside the strike zone.</p>
</dd>
<dt>years</dt><dd><p>Years in the Major Leagues.  Seems to count all years a
player has actually played in the Major Leagues, not necessarily
consecutive.</p>
</dd>
<dt>atbat</dt><dd><p>career times at bat.</p>
</dd>
<dt>hits</dt><dd><p>career hits.</p>
</dd>
<dt>homeruns</dt><dd><p>career home runs.</p>
</dd>
<dt>runs</dt><dd><p>career runs.</p>
</dd>
<dt>rbi</dt><dd><p>career runs batted in.</p>
</dd>
<dt>walks</dt><dd><p>career walks.</p>
</dd>
<dt>league86</dt><dd><p>player's league.</p>
</dd>
<dt>div86</dt><dd><p>player's division.</p>
</dd>
<dt>team86</dt><dd><p>player's team.</p>
</dd>
<dt>posit86</dt><dd><p>player's position (see <code><a href="#topic+Hitters">Hitters</a></code>).</p>
</dd>
<dt>outs86</dt><dd><p>number of putouts (see <code><a href="#topic+Hitters">Hitters</a></code>)</p>
</dd>
<dt>assist86</dt><dd><p>number of assists (see <code><a href="#topic+Hitters">Hitters</a></code>)</p>
</dd>
<dt>error86</dt><dd><p>number of assists (see <code><a href="#topic+Hitters">Hitters</a></code>)</p>
</dd>
<dt>sal87</dt><dd><p>annual salary on opening day (in USD 1000).</p>
</dd>
<dt>league87</dt><dd><p>league in 1987.</p>
</dd>
<dt>team87</dt><dd><p>team in 1987.</p>
</dd>
</dl>



<h3>Source</h3>

<p>SAS System for Statistical Graphics, First Edition, page A2.3
</p>


<h3>References</h3>

<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hitters">Hitters</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Baseball")
</code></pre>

<hr>
<h2 id='binreg_plot'>Binary Regression Plot</h2><span id='topic+binreg_plot'></span><span id='topic+grid_abline'></span>

<h3>Description</h3>

<p>Creates a display of observed and fitted values for a binary regression
model with one numeric predictor, conditioned by zero or many co-factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binreg_plot(model, main = NULL, xlab = NULL, ylab = NULL,
            xlim = NULL, ylim = NULL,
            pred_var = NULL, pred_range = c("data", "xlim"),
            group_vars = NULL, base_level = NULL, subset,
            type = c("response", "link"), conf_level = 0.95, delta = FALSE,
            pch = NULL, cex = 0.6, jitter_factor = 0.1,
            lwd = 5, lty = 1, point_size = 0, col_lines = NULL, col_bands = NULL, 
            legend = TRUE, legend_pos = NULL, legend_inset = c(0, 0.1),
            legend_vgap = unit(0.5, "lines"),
            labels = FALSE, labels_pos = c("right", "left"),
            labels_just = c("left","center"), labels_offset = c(0.01, 0),
            gp_main = gpar(fontface = "bold", fontsize = 14),
            gp_legend_frame = gpar(lwd = 1, col = "black"),
            gp_legend_title = gpar(fontface = "bold"),
            newpage = TRUE, pop = FALSE, return_grob = FALSE)
grid_abline(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binreg_plot_+3A_model">model</code></td>
<td>
<p>a binary regression model fitted with <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_main">main</code></td>
<td>
<p>user-specified main title.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label. Defaults to the name of the (first) numeric predictor.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label. Defaults to the name of the response -
within either 'P(...)' or 'logit(...)', depending on the response
type.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_xlim">xlim</code></td>
<td>
<p>Range of the x-axis. Defaults to the range of the numeric
predictor.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_ylim">ylim</code></td>
<td>
<p>Range of the y-axis. Defaults to the unit interval on
probability scale or the fitted values range on the link scale,
depending on <code>type</code>.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_pred_var">pred_var</code></td>
<td>
<p>character string of length 1 giving the name of
the numeric predictor. Defaults to the first one found in the data
set.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_pred_range">pred_range</code></td>
<td>
<p><code>"data"</code>, <code>"xlim"</code>, or a numeric vector.
If <code>"data"</code>, the numeric predictor corresponds to the observed values. If
<code>"xlim"</code>, 100 values are taken from the <code>"xlim"</code>
range. A numeric vector will be interpreted as the values to be predicted.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_group_vars">group_vars</code></td>
<td>
<p>optional character string of conditioning
variables. Defaults to all factors found in the data set, response
excluded. If <code>FALSE</code>, no variables are used for conditioning.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_base_level">base_level</code></td>
<td>
<p>vector of length one. If the response is a vector,
this specifies the base ('no effect') value of the
response variable
(e.g., &quot;Placebo&quot;, 0, FALSE, etc.) and defaults
to the first level for
factor responses, or 0 for numeric/binary variables. This controls
which observations will be plotted on the top or the bottom of the
display. If the response is a matrix with success and failure
column, this specifies the one to be interpreted as failure
(default: 2), either as an integer, or as a
string (<code>"success"</code>  or <code>"failure"</code>). The proportions of
<em>successes</em> will be plotted as observed values.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of the data
rows. The value is evaluated in the data environment, so expressions
can be used to select the data (see examples).</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_type">type</code></td>
<td>
<p>either &quot;response&quot; or &quot;link&quot; to select the scale of the
fitted values. The y-axis will be adapted accordingly.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_conf_level">conf_level</code></td>
<td>
<p>confidence level used for calculating 
confidence bands.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_delta">delta</code></td>
<td>
<p>logical; indicates whether the delta method should be
employed for calculating the limits of the confidence band or not
(see details).</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_pch">pch</code></td>
<td>
<p>character or numeric vector of symbols used for plotting
the (possibly conditioned) observed values, recycled as needed.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_cex">cex</code></td>
<td>
<p>size of the plot symbols (in lines).</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_jitter_factor">jitter_factor</code></td>
<td>
<p>argument passed to <code><a href="base.html#topic+jitter">jitter</a></code>
used for the points representing the observed values.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_lwd">lwd</code></td>
<td>
<p>Line width for the fitted values.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_lty">lty</code></td>
<td>
<p>Line type for the fitted values.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_point_size">point_size</code></td>
<td>
<p>size of points for the fitted values in char units (default: 0, so
no points are plotted).</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_col_lines">col_lines</code>, <code id="binreg_plot_+3A_col_bands">col_bands</code></td>
<td>
<p>character vector specifying the colors of the fitted
lines and confidence bands,
by default chosen with <code><a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a></code>. The
confidence bands are using alpha blending with alpha = 0.2.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_legend">legend</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), a legend is drawn.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_legend_pos">legend_pos</code></td>
<td>
<p>numeric vector of length 2, specifying x and y
coordinates of the legend, or a character string (e.g., <code>"topleft"</code>,
<code>"center"</code> etc.). Defaults to <code>"topleft"</code> if the fitted curve's slope is
positive, and <code>"topright"</code> else.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_legend_inset">legend_inset</code></td>
<td>
<p>numeric vector or length 2 specifying the inset
from the legend's x and y coordinates in npc units.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_legend_vgap">legend_vgap</code></td>
<td>
<p>vertical space between the legend's line entries.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_labels">labels</code></td>
<td>
<p>logical; if <code>TRUE</code>, labels corresponding to the
factor levels are plotted next to the fitted lines.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_labels_pos">labels_pos</code></td>
<td>
<p>either <code>"right"</code> or <code>"left"</code>, determining on which side
of the fitted lines (start or end) the labels should be placed.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_labels_just">labels_just</code></td>
<td>
<p>character vector of length 2, specifying the
relative justification of the labels to their coordinates. See the
documentation of the <code>just</code> parameter of
<code><a href="grid.html#topic+grid.text">grid.text</a></code> for more details.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_labels_offset">labels_offset</code></td>
<td>
<p>numeric vector of length 2, specifying the offset    
of the labels' coordinates in npc units.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_gp_main">gp_main</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the main title.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_gp_legend_frame">gp_legend_frame</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the
legend frame.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_gp_legend_title">gp_legend_title</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the
legend title.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_newpage">newpage</code></td>
<td>
<p>logical; if <code>TRUE</code>, the plot is drawn on a new page.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_pop">pop</code></td>
<td>
<p>logical; if <code>TRUE</code>, all newly generated viewports are
popped after plotting.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_return_grob">return_grob</code></td>
<td>
<p>logical. Should a snapshot of the display be
returned as a grid grob?</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_a">a</code></td>
<td>
<p>intercept; alternatively, a regression model from which
coefficients can be extracted via <code><a href="stats.html#topic+coef">coef</a></code>.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_b">b</code></td>
<td>
<p>slope.</p>
</td></tr>
<tr><td><code id="binreg_plot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="grid.html#topic+grid.abline">grid.abline</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The primary purpose of <code>binreg_plot()</code> is to visualize observed and
fitted values for binary regression models (like the logistic or probit
regression model) with one numeric predictor. If one or more
categorical predictors are used in the model, the <em>fitted</em> values are
conditioned on them, i.e. separate curves are drawn corresponding to
the factor level combinations. Thus, it shows a <em>full-model plot</em>, not a
conditional plot where several models would be fit to data subsets.
</p>
<p>The implementation relies on objects returned by
<code><a href="stats.html#topic+glm">glm</a></code>, as it uses its <code>"terms"</code> and
<code>"model"</code> components. 
</p>
<p>The function tries to determine suitable values for the legend and/or
labels, but depending on the data, this might require some tweaking.
</p>
<p>By default, the limits of the confidence band are determined for the
linear predictor (i.e., on the link scale) and transformed to response
scale (if this is the chosen plot type) using the inverse link
function. If <code>delta</code> is <code>TRUE</code>, the limits
are determined on the response scale. Note that the resulting band using the
delta method is symmetric around the fitted mean,
but may exceed the unit interval (on the response scale) and 
will be cut off.
</p>
<p><code>grid_abline()</code> is a simple convenience wrapper for
<code><a href="grid.html#topic+grid.abline">grid.abline</a></code> with similar behavior than
<code><a href="graphics.html#topic+abline">abline</a></code> in that it extracts coefficients from
a regression model, if given instead of the intercept <code>a</code>.
</p>


<h3>Value</h3>

<p>if <code>return_grob</code> is <code>TRUE</code>, a grob object corresponding to
the plot. <code>NULL</code> (invisibly) else.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Michael Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple model with no conditioning variables
art.mod0 &lt;- glm(Improved &gt; "None" ~ Age, data = Arthritis, family = binomial)

binreg_plot(art.mod0, "Arthritis Data")
binreg_plot(art.mod0, type = "link") ## logit scale

## one conditioning factor
art.mod1 &lt;- update(art.mod0, . ~ . + Sex)
binreg_plot(art.mod1)
binreg_plot(art.mod1, legend = FALSE, labels = TRUE, xlim = c(20, 80))

## two conditioning factors
art.mod2 &lt;- update(art.mod1, . ~ . + Treatment)
binreg_plot(art.mod2)
binreg_plot(art.mod2, subset = Sex == "Male") ## subsetting

## some tweaking
binreg_plot(art.mod2, gp_legend_frame = gpar(col = NA, fill = "white"), col_bands = NA)
binreg_plot(art.mod2, legend = FALSE, labels = TRUE,
            labels_pos = "left", labels_just = c("left", "top"))

## model with grouped response data
shuttle.mod &lt;- glm(cbind(nFailures, 6 - nFailures) ~ Temperature,
                   data = SpaceShuttle, na.action = na.exclude, family = binomial)
binreg_plot(shuttle.mod, xlim = c(30, 81), pred_range = "xlim",
            ylab = "O-Ring Failure Probability", xlab = "Temperature (F)")
</code></pre>

<hr>
<h2 id='BrokenMarriage'>Broken Marriage Data</h2><span id='topic+BrokenMarriage'></span>

<h3>Description</h3>

<p>Data from the Danish Welfare Study about broken marriages or permanent
relationships depending on gender and social rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("BrokenMarriage")
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations and 4 variables.
</p>

<dl>
<dt>Freq</dt><dd><p>frequency.</p>
</dd>
<dt>gender</dt><dd><p>factor indicating gender (male, female).</p>
</dd>
<dt>rank</dt><dd><p>factor indicating social rank (I, II, III, IV, V).</p>
</dd>
<dt>broken</dt><dd><p>factor indicating whether the marriage or permanent
relationship was broken (yes, no).</p>
</dd>
</dl>



<h3>Source</h3>

<p>E. B. Andersen (1991),
The Statistical Analysis of Categorical Data, page 177.
</p>


<h3>References</h3>

<p>E. B. Andersen (1991),
<em>The Statistical Analysis of Categorical Data</em>.
2nd edition.
Springer-Verlag, Berlin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("BrokenMarriage")
structable(~ ., data = BrokenMarriage)
</code></pre>

<hr>
<h2 id='Bundesliga'>Ergebnisse der Fussball-Bundesliga</h2><span id='topic+Bundesliga'></span>

<h3>Description</h3>

<p>Results from the first German soccer league (1963-2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Bundesliga")
</code></pre>


<h3>Format</h3>

<p>A data frame with 14018 observations and 7 variables.
</p>

<dl>
<dt>HomeTeam</dt><dd><p>factor. Name of the home team.</p>
</dd>
<dt>AwayTeam</dt><dd><p>factor. Name of the away team.</p>
</dd>
<dt>HomeGoals</dt><dd><p>number of goals scored by the home team.</p>
</dd>
<dt>AwayGoals</dt><dd><p>number of goals scored by the away team.</p>
</dd>
<dt>Round</dt><dd><p>round of the game.</p>
</dd>
<dt>Year</dt><dd><p>year in which the season started.</p>
</dd>
<dt>Date</dt><dd><p>starting time of the game (in <code>"POSIXct"</code> format).</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data comprises all games in the first German soccer league since
its foundation in 1963. The data have been queried online from the 
official Web page of the DFB and prepared as a data frame in R by
Daniel Dekic, Torsten Hothorn, and Achim Zeileis (replacing earlier versions of the
data in the package containing only subsets of years).
</p>
<p>Each year/season comprises 34 rounds (except 1963, 1964, 1991) so that
all 18 teams play twice against each other (switching home court advantage).
In 1963/64, there were only 16 teams, hence only 30 rounds.
In 1991, after the German unification, there was one season with 20 teams
and 38 rounds.
</p>


<h3>Source</h3>

<p>Homepage of the Deutscher Fussball-Bund (DFB, German Football Association):
<a href="https://www.dfb.de/index/">https://www.dfb.de/index/</a>
</p>


<h3>References</h3>

<p>Leonhard Knorr-Held (1999), Dynamic rating of sports teams.
SFB 386 &ldquo;Statistical Analysis of Discrete Structures&rdquo;,
Discussion paper <b>98</b>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UKSoccer">UKSoccer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Bundesliga")

## number of goals per game poisson distributed?
ngoals1 &lt;- xtabs(~ HomeGoals, data = Bundesliga, subset = Year == 1995)
ngoals2 &lt;- xtabs(~ AwayGoals, data = Bundesliga, subset = Year == 1995)
ngoals3 &lt;- table(apply(subset(Bundesliga, Year == 1995)[,3:4], 1, sum))

gf1 &lt;- goodfit(ngoals1)
gf2 &lt;- goodfit(ngoals2)
gf3 &lt;- goodfit(ngoals3)

summary(gf1)
summary(gf2)
summary(gf3)
plot(gf1)
plot(gf2)
plot(gf3)

Ord_plot(ngoals1)
distplot(ngoals1)
</code></pre>

<hr>
<h2 id='Bundestag2005'>Votes in German Bundestag Election 2005</h2><span id='topic+Bundestag2005'></span>

<h3>Description</h3>

<p>Number of votes by province in the German Bundestag election
2005 (for the parties that eventually entered the parliament).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Bundestag2005")
</code></pre>


<h3>Format</h3>

<p>A 2-way <code>"table"</code> giving the number of votes for each
party (<code>Fraktion</code>) in each of the 16 German provinces
(<code>Bundesland</code>):
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> Bundesland </td><td style="text-align: left;"> Schleswig-Holstein, Mecklenburg-Vorpommern, ... </td>
</tr>
<tr>
 <td style="text-align: right;">
    2 </td><td style="text-align: left;"> Fraktion </td><td style="text-align: left;"> SPD, CDU/CSU, Gruene, FDP, Linke
  </td>
</tr>

</table>



<h3>Details</h3>

<p>In the election for the German parliament &ldquo;Bundestag&rdquo;, 
five parties obtained enough votes to enter the parliament:
the social democrats SPD, the conservative CDU/CSU, the liberal FDP,
the green party &ldquo;Die Gruenen&rdquo; and the leftist party 
&ldquo;Die Linke&rdquo;. The table <code>Bundestag2005</code> gives the
number of votes for each party (<code>Fraktion</code>) in each of the
16 German provinces (<code>Bundesland</code>). The provinces are ordered
from North to South.
</p>
<p>The data have been obtained from the German statistical office (Statistisches
Bundesamt) from the Web page given below.
</p>
<p>Note that the number of seats in the parliament cannot be computed from
the number of votes alone. The examples below show the distribution of seats
that resulted from the election.
</p>


<h3>Source</h3>

<p>Die Bundeswahlleiterin, Statistisches Bundesamt.  
<a href="https://www.bundeswahlleiterin.de/bundestagswahlen/2005.html">https://www.bundeswahlleiterin.de/bundestagswahlen/2005.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(colorspace)
## The outcome of the election in terms of seats in the
## parliament was:
seats &lt;- structure(c(226, 61, 54, 51, 222),
  .Names = c("CDU/CSU", "FDP",  "Linke", "Gruene", "SPD"))

## Hues are chosen as metaphors for the political parties
## CDU/CSU: blue, FDP: yellow, Linke: purple, Gruene: green, SPD: red
## using the respective hues from a color wheel with
## chroma = 60 and luminance = 75
parties &lt;- rainbow_hcl(6, c = 60, l = 75)[c(5, 2, 6, 3, 1)]
names(parties) &lt;- names(seats)
parties

## The pie chart shows that neither the SPD+Gruene coalition nor
## the opposition of CDU/CSU+FDP could assemble a majority.
## No party would enter a coalition with the leftists, leading to a
## big coalition.
pie(seats, clockwise = TRUE, col = parties)

## The regional distribution of the votes, stratified by province,
## is shown in a mosaic display: first for the 10 Western then the
## 6 Eastern provinces.
data("Bundestag2005")
votes &lt;- Bundestag2005[c(1, 3:5, 9, 11, 13:16, 2, 6:8, 10, 12),
                       c("CDU/CSU", "FDP", "SPD", "Gruene", "Linke")]
mosaic(votes, gp = gpar(fill = parties[colnames(votes)]),
  spacing = spacing_highlighting, labeling = labeling_left,
  labeling_args = list(rot_labels = c(0, 90, 0, 0), pos_labels = "center",
  just_labels = c("center","center","center","right"), varnames = FALSE),
  margins = unit(c(2.5, 1, 1, 12), "lines"),
  keep_aspect_ratio = FALSE)
</code></pre>

<hr>
<h2 id='Butterfly'>Butterfly Species in Malaya</h2><span id='topic+Butterfly'></span>

<h3>Description</h3>

<p>Data from Fisher et al. (1943) giving the number of tokens found for
each of 501 species of butterflies collected in Malaya.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Butterfly")
</code></pre>


<h3>Format</h3>

<p>A 1-way table giving the number of tokens for 501 species of
butterflies. The variable and its levels are
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> nTokens </td><td style="text-align: left;"> 0, 1, ..., 24 </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Michael Friendly (2000),
Visualizing Categorical Data, pages 21&ndash;22.
</p>


<h3>References</h3>

<p>R. A. Fisher, A. S. Corbet, C. B. Williams (1943),
The relation between the number of species and the number of
individuals,
<em>Journal of Animal Ecology</em>, <b>12</b>, 42&ndash;58.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Butterfly")
Ord_plot(Butterfly)
</code></pre>

<hr>
<h2 id='cd_plot'>Conditional Density Plots</h2><span id='topic+cd_plot'></span><span id='topic+cd_plot.default'></span><span id='topic+cd_plot.formula'></span>

<h3>Description</h3>

<p>Computes and plots conditional densities describing how the
distribution of a categorical variable <code>y</code> changes over a
numerical variable <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cd_plot(x, ...)
## Default S3 method:
cd_plot(x, y,
  plot = TRUE, ylab_tol = 0.05,
  bw = "nrd0", n = 512, from = NULL, to = NULL,
  main = "", xlab = NULL, ylab = NULL, margins = c(5.1, 4.1, 4.1, 3.1),
  gp = gpar(), name = "cd_plot", newpage = TRUE, pop = TRUE, return_grob = FALSE, ...)
## S3 method for class 'formula'
cd_plot(formula, data = list(),
  plot = TRUE, ylab_tol = 0.05,
  bw = "nrd0", n = 512, from = NULL, to = NULL,
  main = "", xlab = NULL, ylab = NULL, margins = c(5.1, 4.1, 4.1, 3.1),
  gp = gpar(), name = "cd_plot", newpage = TRUE, pop = TRUE, return_grob = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cd_plot_+3A_x">x</code></td>
<td>
<p>an object, the default method expects either a single numerical variable.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_y">y</code></td>
<td>
<p>a <code>"factor"</code> interpreted to be the dependent variable</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_formula">formula</code></td>
<td>
<p>a <code>"formula"</code> of type <code>y ~ x</code> with a single dependent <code>"factor"</code>
and a single numerical explanatory variable.</p>
</td></tr>    
<tr><td><code id="cd_plot_+3A_data">data</code></td>
<td>
<p>an optional data frame.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_plot">plot</code></td>
<td>
<p>logical. Should the computed conditional densities be plotted?</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_ylab_tol">ylab_tol</code></td>
<td>
<p>convenience tolerance parameter for y-axis annotation.
If the distance between two labels drops under this threshold, they are
plotted equidistantly.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_bw">bw</code>, <code id="cd_plot_+3A_n">n</code>, <code id="cd_plot_+3A_from">from</code>, <code id="cd_plot_+3A_to">to</code>, <code id="cd_plot_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="stats.html#topic+density">density</a></code></p>
</td></tr>
<tr><td><code id="cd_plot_+3A_main">main</code>, <code id="cd_plot_+3A_xlab">xlab</code>, <code id="cd_plot_+3A_ylab">ylab</code></td>
<td>
<p>character strings for annotation</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_margins">margins</code></td>
<td>
<p>margins when calling <code><a href="grid.html#topic+plotViewport">plotViewport</a></code></p>
</td></tr>
<tr><td><code id="cd_plot_+3A_gp">gp</code></td>
<td>
<p>a <code>"gpar"</code> object controlling the grid graphical
parameters of the rectangles. It should specify in particular a vector of
<code>fill</code> colors of the same length as <code>levels(y)</code>. The default is
to call <code><a href="grDevices.html#topic+gray.colors">gray.colors</a></code>.</p>
</td></tr>  
<tr><td><code id="cd_plot_+3A_name">name</code></td>
<td>
<p>name of the plotting viewport.</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_newpage">newpage</code></td>
<td>
<p>logical. Should <code><a href="grid.html#topic+grid.newpage">grid.newpage</a></code> be called 
before plotting?</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_return_grob">return_grob</code></td>
<td>
<p>logical. Should a snapshot of the display be
returned as a grid grob?</p>
</td></tr>
<tr><td><code id="cd_plot_+3A_pop">pop</code></td>
<td>
<p>logical. Should the viewport created be popped?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cd_plot</code> computes the conditional densities of <code>x</code> given
the levels of <code>y</code> weighted by the marginal distribution of <code>y</code>.
The densities are derived cumulatively over the levels of <code>y</code>.
</p>
<p>This visualization technique is similar to spinograms (see <code><a href="#topic+spine">spine</a></code>)
but they do not discretize the explanatory variable, but rather use a smoothing
approach. Furthermore, the original x axis and not a distorted x axis (as for
spinograms) is used. This typically results in conditional densities that
are based on very few observations in the margins: hence, the estimates are less
reliable there.
</p>


<h3>Value</h3>

<p>The conditional density functions (cumulative over the levels of <code>y</code>)
are returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>References</h3>

<p>Hofmann, H., Theus, M. (2005), <em>Interactive graphics for visualizing
conditional distributions</em>, Unpublished Manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spine">spine</a></code>, <code><a href="stats.html#topic+density">density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Arthritis data
data("Arthritis")
cd_plot(Improved ~ Age, data = Arthritis)
cd_plot(Improved ~ Age, data = Arthritis, bw = 3)
cd_plot(Improved ~ Age, data = Arthritis, bw = "SJ")
## compare with spinogram
spine(Improved ~ Age, data = Arthritis, breaks = 3)

## Space shuttle data
data("SpaceShuttle")
cd_plot(Fail ~ Temperature, data = SpaceShuttle, bw = 2)

## scatter plot with conditional density
cdens &lt;- cd_plot(Fail ~ Temperature, data = SpaceShuttle, bw = 2, plot = FALSE)
plot(I(-1 * (as.numeric(Fail) - 2)) ~ jitter(Temperature, factor = 2), data = SpaceShuttle,
  xlab = "Temperature", ylab = "Failure")
lines(53:81, cdens[[1]](53:81), col = 2)
</code></pre>

<hr>
<h2 id='co_table'>Compute Conditional Tables</h2><span id='topic+co_table'></span>

<h3>Description</h3>

<p>For a contingency table in array form, compute a list of conditional
tables given some margins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>co_table(x, margin, collapse = ".")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="co_table_+3A_x">x</code></td>
<td>
<p>a contingency table in array form.</p>
</td></tr>
<tr><td><code id="co_table_+3A_margin">margin</code></td>
<td>
<p>margin index(es) or corresponding name(s) of the
conditioning variables.</p>
</td></tr>
<tr><td><code id="co_table_+3A_collapse">collapse</code></td>
<td>
<p>character used when collapsing level names
(if more than 1 <code>margin</code> is specified).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is essentially an interface to <code><a href="base.html#topic++5B">[</a></code>
which is more convenient for arrays of arbitrary dimension.   
</p>


<h3>Value</h3>

<p>A list of the resulting conditional tables.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HairEyeColor")
co_table(HairEyeColor, 1)
co_table(HairEyeColor, c("Hair", "Eye"))
co_table(HairEyeColor, 1:2, collapse = "")
</code></pre>

<hr>
<h2 id='CoalMiners'>Breathlessness and Wheeze in Coal Miners</h2><span id='topic+CoalMiners'></span>

<h3>Description</h3>

<p>Data from Ashford &amp; Sowden (1970) given by Agresti (1990) on the
association between two pulmonary conditions, breathlessness and
wheeze, in a large sample of coal miners who were smokers with no
radiological evidence of pneumoconlosis, aged between 20&ndash;64
when examined.
This data is frequently used as an example of fitting models for
bivariate, binary responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("CoalMiners")
</code></pre>


<h3>Format</h3>

<p>A 3-dimensional table of size 2 x 2 x 9
resulting from cross-tabulating variables for
18,282 coal miners.  The variables and their levels are as follows:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> Breathlessness </td><td style="text-align: left;"> B, NoB </td>
</tr>
<tr>
 <td style="text-align: right;">
    2 </td><td style="text-align: left;"> Wheeze </td><td style="text-align: left;"> W, NoW </td>
</tr>
<tr>
 <td style="text-align: right;">
    3 </td><td style="text-align: left;"> Age </td><td style="text-align: left;"> 20-24, 25-29, 30-34, ..., 60-64
  </td>
</tr>

</table>



<h3>Details</h3>

<p>In an earlier version of this data set, the first group, aged 20-24, was
inadvertently omitted from this data table and the breathlessness variable
was called wheeze and vice versa.
</p>


<h3>Source</h3>

<p>Michael Friendly (2000),
Visualizing Categorical Data, pages 82&ndash;83, 319&ndash;322.
</p>


<h3>References</h3>

<p>A. Agresti (1990),
<em>Categorical Data Analysis</em>.
Wiley-Interscience, New York, Table 7.11, p. 237
</p>
<p>J. R. Ashford and R. D. Sowdon (1970),
Multivariate probit analysis,
<em>Biometrics</em>, <b>26</b>, 535&ndash;546.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CoalMiners")

ftable(CoalMiners, row.vars = 3)

## Fourfold display, both margins equated
fourfold(CoalMiners[,,2:9], mfcol = c(2,4))

## Fourfold display, strata equated
fourfold(CoalMiners[,,2:9], std = "ind.max", mfcol = c(2,4))


## Log Odds Ratio Plot
lor_CM &lt;- loddsratio(CoalMiners)
summary(lor_CM)
plot(lor_CM)
lor_CM_df &lt;- as.data.frame(lor_CM)

# fit linear models using WLS
age &lt;- seq(20, 60, by = 5)
lmod &lt;- lm(LOR ~ age, weights = 1 / ASE^2, data = lor_CM_df)
grid.lines(age, fitted(lmod), gp = gpar(col = "blue"))
qmod &lt;- lm(LOR ~ poly(age, 2), weights = 1 / ASE^2, data = lor_CM_df)
grid.lines(age, fitted(qmod), gp = gpar(col = "red"))
</code></pre>

<hr>
<h2 id='coindep_test'>Test for (Conditional) Independence</h2><span id='topic+coindep_test'></span><span id='topic+fitted.coindep_test'></span>

<h3>Description</h3>

<p>Performs a test of (conditional) independence of 2 margins
in a contingency table by simulation from the marginal
distribution of the input table under (conditional)
independence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coindep_test(x, margin = NULL, n = 1000, 
  indepfun = function(x) max(abs(x)), aggfun = max,
  alternative = c("greater", "less"),
  pearson = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coindep_test_+3A_x">x</code></td>
<td>
<p>a contingency table.</p>
</td></tr>
<tr><td><code id="coindep_test_+3A_margin">margin</code></td>
<td>
<p>margin index(es) or corresponding name(s) of the
conditioning variables. Each resulting conditional table has to
be a 2-way table.</p>
</td></tr>
<tr><td><code id="coindep_test_+3A_n">n</code></td>
<td>
<p>number of (conditional) independence tables to be drawn.</p>
</td></tr>
<tr><td><code id="coindep_test_+3A_indepfun">indepfun</code></td>
<td>
<p>aggregation function capturing independence in
(each conditional) 2-way table.</p>
</td></tr>
<tr><td><code id="coindep_test_+3A_aggfun">aggfun</code></td>
<td>
<p>aggregation function aggregating the test statistics
computed by <code>indepfun</code>.</p>
</td></tr>
<tr><td><code id="coindep_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis; must be either <code>"greater"</code> (default) or
<code>"less"</code> (and may be abbreviated.)</p>
</td></tr>
<tr><td><code id="coindep_test_+3A_pearson">pearson</code></td>
<td>
<p>logical. Should the table of Pearson residuals under
independence be computed and passed to <code>indepfun</code> (default)
or the raw table of observed frequencies?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>margin</code> is <code>NULL</code> this computes a simple independence
statistic in a 2-way table. Alternatively, <code>margin</code> can give 
several conditioning variables and then conditional independence in
the resulting conditional table is tested.
</p>
<p>By default, this uses a (double) maximum statistic of Pearson residuals.
By changing <code>indepfun</code> or <code>aggfun</code> a (maximum of) Pearson Chi-squared
statistic(s) can be computed or just the usual Pearson Chi-squared statistics
and so on. Other statistics can be computed by changing <code>pearson</code>
to <code>FALSE</code>.
</p>
<p>The function uses <code><a href="stats.html#topic+r2dtable">r2dtable</a></code> to simulate the distribution
of the test statistic under the null.
</p>


<h3>Value</h3>

<p>A list of class <code>"coindep_test"</code> inheriting from <code>"htest"</code>
with following components: 
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the <code class="reqn">p</code> value for the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the type of the test.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>observed</code></td>
<td>
<p>observed table of frequencies</p>
</td></tr>
<tr><td><code>expctd</code></td>
<td>
<p>expected table of frequencies</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>corresponding Pearson residuals</p>
</td></tr>
<tr><td><code>margin</code></td>
<td>
<p>the <code>margin</code> used</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>a vector of size <code>n</code> with simulated values of the
distribution of the statistic under the null.</p>
</td></tr>
<tr><td><code>qdist</code></td>
<td>
<p>the corresponding quantile function (for computing 
critical values).</p>
</td></tr>
<tr><td><code>pdist</code></td>
<td>
<p>the corresponding distribution function (for computing
<code class="reqn">p</code> values).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+chisq.test">chisq.test</a></code>,
<code><a href="stats.html#topic+fisher.test">fisher.test</a></code>,
<code><a href="stats.html#topic+r2dtable">r2dtable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
TeaTasting &lt;- matrix(c(3, 1, 1, 3), nrow = 2,
                     dimnames = list(Guess = c("Milk", "Tea"),
                                     Truth = c("Milk", "Tea"))
)
## compute maximum statistic
coindep_test(TeaTasting)
## compute Chi-squared statistic
coindep_test(TeaTasting, indepfun = function(x) sum(x^2))
## use unconditional asymptotic distribution
chisq.test(TeaTasting, correct = FALSE)
chisq.test(TeaTasting)


data("UCBAdmissions")
## double maximum statistic
coindep_test(UCBAdmissions, margin = "Dept")
## maximum of Chi-squared statistics
coindep_test(UCBAdmissions, margin = "Dept", indepfun = function(x) sum(x^2))
## Pearson Chi-squared statistic
coindep_test(UCBAdmissions, margin = "Dept", indepfun = function(x) sum(x^2), aggfun = sum)
## use unconditional asymptotic distribution
loglm(~ Dept * (Gender + Admit), data = UCBAdmissions)
</code></pre>

<hr>
<h2 id='cotab_panel'>Panel-generating Functions for Contingency Table Coplots</h2><span id='topic+cotab_mosaic'></span><span id='topic+cotab_assoc'></span><span id='topic+cotab_sieve'></span><span id='topic+cotab_loddsratio'></span><span id='topic+cotab_agreementplot'></span><span id='topic+cotab_coindep'></span><span id='topic+cotab_fourfold'></span>

<h3>Description</h3>

<p>Panel-generating functions visualizing contingency tables that
can be passed to <code>cotabplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cotab_mosaic(x = NULL, condvars = NULL, ...)
cotab_assoc(x = NULL, condvars = NULL, ylim = NULL, ...)
cotab_sieve(x = NULL, condvars = NULL, ...)
cotab_loddsratio(x = NULL, condvars = NULL, ...)
cotab_agreementplot(x = NULL, condvars = NULL, ...)
cotab_fourfold(x = NULL, condvars = NULL, ...)
cotab_coindep(x, condvars,
  test = c("doublemax", "maxchisq", "sumchisq"),
  level = NULL, n = 1000, interpolate = c(2, 4),
  h = NULL, c = NULL, l = NULL, lty = 1,
  type = c("mosaic", "assoc"), legend = FALSE, ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cotab_panel_+3A_x">x</code></td>
<td>
<p>a contingency tables in array form.</p>
</td></tr>
<tr><td><code id="cotab_panel_+3A_condvars">condvars</code></td>
<td>
<p>margin name(s) of the conditioning variables.</p>
</td></tr>
<tr><td><code id="cotab_panel_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits for <code>assoc</code> plot. By default this
is computed from <code>x</code>.</p>
</td></tr>
<tr><td><code id="cotab_panel_+3A_test">test</code></td>
<td>
<p>character indicating which type of statistic
should be used for assessing conditional independence.</p>
</td></tr>
<tr><td><code id="cotab_panel_+3A_level">level</code>, <code id="cotab_panel_+3A_n">n</code>, <code id="cotab_panel_+3A_h">h</code>, <code id="cotab_panel_+3A_c">c</code>, <code id="cotab_panel_+3A_l">l</code>, <code id="cotab_panel_+3A_lty">lty</code>, <code id="cotab_panel_+3A_interpolate">interpolate</code></td>
<td>
<p>variables controlling the HCL shading of the
residuals, see <code><a href="#topic+shadings">shadings</a></code> for more details.</p>
</td></tr>
<tr><td><code id="cotab_panel_+3A_type">type</code></td>
<td>
<p>character indicating which type of plot should be produced.</p>
</td></tr>
<tr><td><code id="cotab_panel_+3A_legend">legend</code></td>
<td>
<p>logical. Should a legend be produced in each panel?</p>
</td></tr>
<tr><td><code id="cotab_panel_+3A_...">...</code></td>
<td>
<p>further arguments passed to the plotting function (such as
<code><a href="#topic+mosaic">mosaic</a></code> or <code><a href="#topic+assoc">assoc</a></code> or <code><a href="#topic+sieve">sieve</a></code>
respectively).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions of class <code>"panel_generator"</code> are panel-generating
functions for use with <code><a href="#topic+cotabplot">cotabplot</a></code>, i.e., they return functions
with the interface
</p>
<p><code>panel(x, condlevels)</code>
</p>
<p>required for <code>cotabplot</code>. The functions produced by <code>cotab_mosaic</code>,
<code>cotab_assoc</code> and <code>cotab_sieve</code> essentially only call <code>co_table</code>
to produce the conditioned table and then call <code><a href="#topic+mosaic">mosaic</a></code>, <code><a href="#topic+assoc">assoc</a></code>
or <code><a href="#topic+sieve">sieve</a></code> respectively with the arguments specified.
</p>
<p>The function <code>cotab_coindep</code> is similar but additionally chooses an appropriate
residual-based shading visualizing the associated conditional independence
model. The conditional independence test is carried out via <code><a href="#topic+coindep_test">coindep_test</a></code>
and the shading is set up via <code><a href="#topic+shading_hcl">shading_hcl</a></code>.
</p>
<p>A description of the underlying ideas is given in Zeileis, Meyer, Hornik
(2005).
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>References</h3>

<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>
<p>Zeileis, A., Meyer, D., Hornik K. (2007), <em>Residual-based shadings for visualizing
(conditional) independence</em>, <em>Journal of Computational and Graphical Statistics</em>, <b>16</b>,
507&ndash;525.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cotabplot">cotabplot</a></code>,
<code><a href="#topic+mosaic">mosaic</a></code>,
<code><a href="#topic+assoc">assoc</a></code>,
<code><a href="#topic+sieve">sieve</a></code>,
<code><a href="#topic+co_table">co_table</a></code>,
<code><a href="#topic+coindep_test">coindep_test</a></code>,
<code><a href="#topic+shading_hcl">shading_hcl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("UCBAdmissions")

cotabplot(~ Admit + Gender | Dept, data = UCBAdmissions)
cotabplot(~ Admit + Gender | Dept, data = UCBAdmissions, panel = cotab_assoc)
cotabplot(~ Admit + Gender | Dept, data = UCBAdmissions, panel = cotab_fourfold)

ucb &lt;- cotab_coindep(UCBAdmissions, condvars = "Dept", type = "assoc",
                     n = 5000, margins = c(3, 1, 1, 3))
cotabplot(~ Admit + Gender | Dept, data = UCBAdmissions, panel = ucb)
</code></pre>

<hr>
<h2 id='cotabplot'>Coplot for Contingency Tables</h2><span id='topic+cotabplot'></span><span id='topic+cotabplot.default'></span><span id='topic+cotabplot.formula'></span>

<h3>Description</h3>

<p><code>cotabplot</code> is a generic function for creating trellis-like
coplots (conditional plots) for contingency tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cotabplot(x, ...)
## Default S3 method:
cotabplot(x, cond = NULL,
  panel = cotab_mosaic, panel_args = list(),
  margins = rep(1, 4), layout = NULL,
  text_gp = gpar(fontsize = 12), rect_gp = gpar(fill = grey(0.9)),
  pop = TRUE, newpage = TRUE, return_grob = FALSE,
  ...)
## S3 method for class 'formula'
cotabplot(formula, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cotabplot_+3A_x">x</code></td>
<td>
<p>an object. The default method can deal with contingency tables
in array form.</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_cond">cond</code></td>
<td>
<p>margin index(es) or corresponding name(s) of the
conditioning variables.</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_panel">panel</code></td>
<td>
<p>panel function applied for each conditioned plot,
see details.</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_panel_args">panel_args</code></td>
<td>
<p>list of arguments passed to <code>panel</code> if this is
a panel-generating function inheriting from class <code>"grapcon_generator"</code>.</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_margins">margins</code></td>
<td>
<p>either an object of class <code>"unit"</code> of length 4, or
a numeric vector of length 4. The elements are recycled as needed.
giving the margins around the whole plot.</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_layout">layout</code></td>
<td>
<p>integer vector (of length two), giving the number of
rows and columns for the panel.</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_text_gp">text_gp</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the text in the panel titles.</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_rect_gp">rect_gp</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the rectangles with the panel titles.</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_pop">pop</code></td>
<td>
<p>logical indicating whether the generated viewport tree
should be removed at the end of the drawing or not.</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_newpage">newpage</code></td>
<td>
<p>logical controlling whether a new grid page should be
created.</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_return_grob">return_grob</code></td>
<td>
<p>logical. Should a snapshot of the display be
returned as a grid grob?</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to the panel-generating function.</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the variables used to create a 
contingency table from <code>data</code>. It has to be of type <code>~ x + y | z</code>
where <code>z</code> is/are the conditioning variable(s) used.</p>
</td></tr>
<tr><td><code id="cotabplot_+3A_data">data</code></td>
<td>
<p>either a data frame, or an object of class <code>"table"</code>
or <code>"ftable"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cotabplot</code> is a generic function designed to create coplots or
conditional plots (see Cleveland, 1993, and Becker, Cleveland, Shyu, 1996)
similar to <code><a href="graphics.html#topic+coplot">coplot</a></code> but for contingency tables.
</p>
<p><code>cotabplot</code> takes on computing the conditioning information 
and setting up the trellis display, and then relies on a panel function
to create plots from the full table and the conditioning information.
A simple example would be a contingency table <code>tab</code> with margin
names <code>"x"</code>, <code>"y"</code> and <code>"z"</code>. To produce this plot
either the default interface can be used or the formula interface via
</p>
<p><code>cotabplot(tab, "z")</code>
<code>cotabplot(~ x + y | z, data = tab)</code>
</p>
<p>The panel function needs to be of the form
</p>
<p><code>panel(x, condlevels)</code>
</p>
<p>where <code>x</code> is the <em>full</em> table (<code>tab</code> in the example above)
and <code>condlevels</code> is a named vector with the levels (e.g., 
<code>c(z = "z1")</code> in the example above). 
</p>
<p>Alternatively, <code>panel</code> can also be a panel-generating function
of class <code>"grapcon_generator"</code> which creates a function with the
interface described above. The panel-generating function is called
with the interface
</p>
<p><code>panel(x, condvars, ...)</code>
</p>
<p>where again <code>x</code> is the full table, <code>condvars</code> is now only
a vector with the names of the conditioning variables (and not their
levels, e.g., <code>"z"</code> in the example above). Further arguments
can be passed to the panel-generating function via <code>...</code> which
also includes the arguments set in <code>panel_args</code>.
</p>
<p>Suitable panel-generating functions for mosaic, association and sieve
plots can be found at <code><a href="#topic+cotab_mosaic">cotab_mosaic</a></code>.
</p>
<p>A description of the underlying ideas is given in Zeileis, Meyer, Hornik
(2005).
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>References</h3>

<p>Becker, R.A., Cleveland, W.S., Shyu, M.-J. (1996),
The visual design and control of trellis display.
<em>Journal of Computational and Graphical Statistics</em>, <b>5</b>,
123&ndash;155.
</p>
<p>Cleveland, W.S. (1993), <em>Visualizing Data</em>, Summit, New Jersey: Hobart Press.
</p>
<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>
<p>Zeileis, A., Meyer, D., Hornik K. (2007), <em>Residual-based shadings for visualizing
(conditional) independence</em>, <em>Journal of Computational and Graphical Statistics</em>, <b>16</b>,
507&ndash;525.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cotab_mosaic">cotab_mosaic</a></code>,
<code><a href="#topic+cotab_coindep">cotab_coindep</a></code>,
<code><a href="#topic+co_table">co_table</a></code>,
<code><a href="#topic+coindep_test">coindep_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("UCBAdmissions")

cotabplot(~ Admit + Gender | Dept, data = UCBAdmissions)
cotabplot(~ Admit + Gender | Dept, data = UCBAdmissions, panel = cotab_assoc)

ucb &lt;- cotab_coindep(UCBAdmissions, condvars = "Dept", type = "assoc",
                     n = 5000, margins = c(3, 1, 1, 3))
cotabplot(~ Admit + Gender | Dept, data = UCBAdmissions, panel = ucb)
</code></pre>

<hr>
<h2 id='DanishWelfare'>Danish Welfare Study Data</h2><span id='topic+DanishWelfare'></span>

<h3>Description</h3>

<p>Data from the Danish Welfare Study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DanishWelfare")</code></pre>


<h3>Format</h3>

<p>A data frame with 180 observations and 5 variables.
</p>

<dl>
<dt>Freq</dt><dd><p>frequency.</p>
</dd>
<dt>Alcohol</dt><dd><p>factor indicating daily alcohol consumption: less
than 1 unit (&lt;1), 1-2 units (1-2) or more than 2 units (&gt;2).
1 unit is approximately 1 bottle of beer or 4cl 40% alcohol.</p>
</dd>
<dt>Income</dt><dd><p>factor indicating income group in 1000 DKK (0-50,
50-100, 100-150, &gt;150).</p>
</dd> 
<dt>Status</dt><dd><p>factor indicating marriage status (Widow, Married,
Unmarried).</p>
</dd>
<dt>Urban</dt><dd><p>factor indicating urbanization: Copenhagen
(Copenhagen), Suburbian Copenhagen (SubCopenhagen), three largest
cities (LargeCity), other cities (City), countryside (Country).</p>
</dd>
</dl>



<h3>Source</h3>

<p>E. B. Andersen (1991),
The Statistical Analysis of Categorical Data, page 205.
</p>


<h3>References</h3>

<p>E. B. Andersen (1991),
<em>The Statistical Analysis of Categorical Data</em>.
2nd edition.
Springer-Verlag, Berlin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("DanishWelfare")
ftable(xtabs(Freq ~ ., data = DanishWelfare))
</code></pre>

<hr>
<h2 id='distplot'>Diagnostic Distribution Plots</h2><span id='topic+distplot'></span>

<h3>Description</h3>

<p>Diagnostic distribution plots: poissonness, binomialness and
negative binomialness plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distplot(x, type = c("poisson", "binomial", "nbinomial"),
  size = NULL, lambda = NULL, legend = TRUE, xlim = NULL, ylim = NULL,
  conf_int = TRUE, conf_level = 0.95, main = NULL,
  xlab = "Number of occurrences", ylab = "Distribution metameter",
  gp = gpar(cex = 0.8), lwd=2, gp_conf_int = gpar(lty = 2),
  name = "distplot", newpage = TRUE,
  pop =TRUE, return_grob = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distplot_+3A_x">x</code></td>
<td>
<p>either a vector of counts, a 1-way table of frequencies of
counts or a data frame or matrix with frequencies in the first
column and the corresponding counts in the second column.</p>
</td></tr>
<tr><td><code id="distplot_+3A_type">type</code></td>
<td>
<p>a character string indicating the distribution.</p>
</td></tr>
<tr><td><code id="distplot_+3A_size">size</code></td>
<td>
<p>the size argument for the binomial and negative binomial
distribution.
If set to <code>NULL</code> and <code>type</code> is <code>"binomial"</code>, then
<code>size</code> is taken to be the maximum count. 
If set to <code>NULL</code> and <code>type</code> is <code>"nbinomial"</code>, then
<code>size</code> is estimated from the data.</p>
</td></tr>
<tr><td><code id="distplot_+3A_lambda">lambda</code></td>
<td>
<p>parameter of the poisson distribution.
If type is <code>"poisson"</code> and <code>lambda</code> is specified a leveled
poissonness plot is produced.</p>
</td></tr>
<tr><td><code id="distplot_+3A_legend">legend</code></td>
<td>
<p>logical.  Should a legend be plotted?</p>
</td></tr>
<tr><td><code id="distplot_+3A_xlim">xlim</code></td>
<td>
<p>limits for the x axis.</p>
</td></tr>
<tr><td><code id="distplot_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y axis.</p>
</td></tr>
<tr><td><code id="distplot_+3A_conf_int">conf_int</code></td>
<td>
<p>logical.  Should confidence intervals be plotted?</p>
</td></tr>
<tr><td><code id="distplot_+3A_conf_level">conf_level</code></td>
<td>
<p>confidence level for confidence intervals.</p>
</td></tr>
<tr><td><code id="distplot_+3A_main">main</code></td>
<td>
<p>a title for the plot.</p>
</td></tr>
<tr><td><code id="distplot_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="distplot_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis.</p>
</td></tr>
<tr><td><code id="distplot_+3A_gp">gp</code></td>
<td>
<p>a <code>"gpar"</code> object controlling the grid graphical
parameters of the points.</p>
</td></tr>  
<tr><td><code id="distplot_+3A_gp_conf_int">gp_conf_int</code></td>
<td>
<p>a <code>"gpar"</code> object controlling the grid graphical
parameters of the confidence intervals.</p>
</td></tr>  
<tr><td><code id="distplot_+3A_lwd">lwd</code></td>
<td>
<p>line width for the fitted line</p>
</td></tr>
<tr><td><code id="distplot_+3A_name">name</code></td>
<td>
<p>name of the plotting viewport.</p>
</td></tr>
<tr><td><code id="distplot_+3A_newpage">newpage</code></td>
<td>
<p>logical. Should <code><a href="grid.html#topic+grid.newpage">grid.newpage</a></code> be called 
before plotting?</p>
</td></tr>
<tr><td><code id="distplot_+3A_pop">pop</code></td>
<td>
<p>logical. Should the viewport created be popped?</p>
</td></tr>
<tr><td><code id="distplot_+3A_return_grob">return_grob</code></td>
<td>
<p>logical. Should a snapshot of the display be
returned as a grid grob?</p>
</td></tr>
<tr><td><code id="distplot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="grid.html#topic+grid.points">grid.points</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>distplot</code> plots the number of occurrences (counts) against the
distribution metameter of the specified distribution.  If the
distribution fits the data, the plot should show a straight line.
See Friendly (2000) for details.
</p>
<p>In these plots, the open points show the observed count metameters;
the filled points show the confidence interval centers, and the
dashed lines show the <code>conf_level</code> confidence intervals for
each point.
</p>


<h3>Value</h3>

<p>Returns invisibly a data frame containing the counts (<code>Counts</code>), 
frequencies (<code>Freq</code>) and other details of the computations used
to construct the plot.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>References</h3>

<p>D. C. Hoaglin (1980),
A poissonness plot,
<em>The American Statistican</em>, <b>34</b>, 146&ndash;149.
</p>
<p>D. C. Hoaglin &amp; J. W. Tukey (1985),
Checking the shape of discrete distributions.
In D. C. Hoaglin, F. Mosteller, J. W. Tukey (eds.),
<em>Exploring Data Tables, Trends and Shapes</em>, chapter 9.
John Wiley &amp; Sons, New York.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulated data examples:
dummy &lt;- rnbinom(1000, size = 1.5, prob = 0.8)
distplot(dummy, type = "nbinomial")

## Real data examples:
data("HorseKicks")
data("Federalist")
data("Saxony")
distplot(HorseKicks, type = "poisson")
distplot(HorseKicks, type = "poisson", lambda = 0.61)
distplot(Federalist, type = "poisson")
distplot(Federalist, type = "nbinomial", size = 1)
distplot(Federalist, type = "nbinomial")
distplot(Saxony, type = "binomial", size = 12)
</code></pre>

<hr>
<h2 id='doubledecker'>Doubledecker Plot</h2><span id='topic+doubledecker.default'></span><span id='topic+doubledecker.formula'></span><span id='topic+doubledecker'></span>

<h3>Description</h3>

<p>This function creates a doubledecker plot visualizing a classification
rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
doubledecker(formula, data = NULL, ..., main = NULL)
## Default S3 method:
doubledecker(x, depvar = length(dim(x)),
  margins = c(1,4, length(dim(x)) + 1, 1),
  gp = gpar(fill = rev(gray.colors(tail(dim(x), 1)))),
  labeling = labeling_doubledecker,
  spacing = spacing_highlighting,
  main = NULL, keep_aspect_ratio = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doubledecker_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the variables used to create a 
contingency table from <code>data</code>. The dependent variable is used
last for splitting.</p>
</td></tr>
<tr><td><code id="doubledecker_+3A_data">data</code></td>
<td>
<p>either a data frame, or an object of class <code>"table"</code>
or <code>"ftable"</code>.</p>
</td></tr>
<tr><td><code id="doubledecker_+3A_x">x</code></td>
<td>
<p>a contingency table in array form, with optional category
labels specified in the <code>dimnames(x)</code> attribute.</p>
</td></tr>
<tr><td><code id="doubledecker_+3A_depvar">depvar</code></td>
<td>
<p>dimension index or character string specifying the
dependent variable.  That will be sorted last in the table.</p>
</td></tr>
<tr><td><code id="doubledecker_+3A_margins">margins</code></td>
<td>
<p>margins of the plot.  Note that by default, all factor
names (except the last one) and their levels are visualized <em>as
a block</em> under the plot.</p>
</td></tr>
<tr><td><code id="doubledecker_+3A_gp">gp</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the tiles of the last variable.</p>
</td></tr>
<tr><td><code id="doubledecker_+3A_labeling">labeling</code></td>
<td>
<p>labeling function or corresponding generating
generating function (see <code><a href="#topic+strucplot">strucplot</a></code> for details).</p>
</td></tr>
<tr><td><code id="doubledecker_+3A_spacing">spacing</code></td>
<td>
<p>spacing object, spacing function or corresponding
generating function (see <code><a href="#topic+strucplot">strucplot</a></code> for details).</p>
</td></tr>
<tr><td><code id="doubledecker_+3A_main">main</code></td>
<td>
<p>either a logical, or a character string used for plotting
the main title.  If <code>main</code> is <code>TRUE</code>, the
name of the <code>data</code> object is used.</p>
</td></tr>
<tr><td><code id="doubledecker_+3A_keep_aspect_ratio">keep_aspect_ratio</code></td>
<td>
<p>logical indicating whether the aspect ratio should be
maintained or not.</p>
</td></tr>
<tr><td><code id="doubledecker_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code>mosaic</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Doubledecker plots visualize the the dependence of one
categorical (typically binary) variable on further categorical
variables.  Formally, they are mosaic plots with vertical splits for
all dimensions (antecedents) except the last one, which represents the
dependent variable (consequent).  The last variable is visualized by
horizontal splits, no space between the tiles, and separate colors for
the levels.
</p>


<h3>Value</h3>

<p>The <code>"structable"</code> visualized is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>H. Hoffmann (2001),
Generalized odds ratios for visual modeling.
<em>Journal of Computational and Graphical Statistics</em>,
<b>10</b>, 4, 628&ndash;640.
</p>
<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strucplot">strucplot</a></code>,
<code><a href="#topic+mosaic">mosaic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Titanic")
doubledecker(Titanic)
doubledecker(Titanic, depvar = "Survived")
doubledecker(Survived ~ ., data = Titanic)
</code></pre>

<hr>
<h2 id='Employment'>Employment Status</h2><span id='topic+Employment'></span>

<h3>Description</h3>

<p>Data from a 1974 Danish study given by Andersen (1991) on the
employees who had been laid off.  The workers are classified by 
their employment status on 1975-01-01, the cause of their layoff
and the length of employment before they were laid off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Employment")
</code></pre>


<h3>Format</h3>

<p>A 3-dimensional array resulting from cross-tabulating variables for
1314 employees.  The variables and their levels are as follows:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> EmploymentStatus </td><td style="text-align: left;"> NewJob, Unemployed </td>
</tr>
<tr>
 <td style="text-align: right;">
    2 </td><td style="text-align: left;"> EmploymentLength </td><td style="text-align: left;"> &lt;1Mo, 1-3Mo, 3-12Mo, 1-2Yr, 2-5Yr, &gt;5Yr </td>
</tr>
<tr>
 <td style="text-align: right;">
    3 </td><td style="text-align: left;"> LayoffCause </td><td style="text-align: left;"> Closure, Replaced
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Michael Friendly (2000),
Visualizing Categorical Data, pages 126&ndash;129.
</p>


<h3>References</h3>

<p>E. B. Andersen (1991),
<em>The Statistical Analysis of Categorical Data</em>.
Springer-Verlag, Berlin.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Employment")

## Employment Status
mosaic(Employment,
       expected = ~ LayoffCause * EmploymentLength + EmploymentStatus,
       main = "Layoff*EmployLength + EmployStatus")

mosaic(Employment,
       expected = ~ LayoffCause * EmploymentLength + LayoffCause * EmploymentStatus,
       main = "Layoff*EmployLength + Layoff*EmployStatus")

## Stratified view

grid.newpage()
pushViewport(viewport(layout = grid.layout(ncol = 2)))
pushViewport(viewport(layout.pos.col = 1))

## Closure
mosaic(Employment[,,1], main = "Layoff: Closure", newpage = FALSE)

popViewport(1)
pushViewport(viewport(layout.pos.col = 2))

## Replaced
mosaic(Employment[,,2], main = "Layoff: Replaced", newpage = FALSE)
popViewport(2)
</code></pre>

<hr>
<h2 id='Federalist'>&lsquo;May&rsquo; in Federalist Papers</h2><span id='topic+Federalist'></span>

<h3>Description</h3>

<p>Data from Mosteller &amp; Wallace (1984) investigating the use of certain
keywords (&lsquo;may&rsquo; in this data set) to identify the author of 12
disputed &lsquo;Federalist Papers&rsquo; by Alexander Hamilton, John Jay
and James Madison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Federalist")
</code></pre>


<h3>Format</h3>

<p>A 1-way table giving the number of occurrences of &lsquo;may&rsquo; in 262
blocks of text.  The variable and its levels are
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> nMay </td><td style="text-align: left;"> 0, 1, ..., 6 </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Michael Friendly (2000),
Visualizing Categorical Data, page 19.
</p>


<h3>References</h3>

<p>F. Mosteller &amp; D. L. Wallace (1984),
<em>Applied Bayesian and Classical Inference: The Case of the
Federalist Papers</em>.
Springer-Verlag, New York, NY. 
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Federalist")
gf &lt;- goodfit(Federalist, type = "nbinomial")
summary(gf)
plot(gf)
</code></pre>

<hr>
<h2 id='fourfold'>Fourfold Plots</h2><span id='topic+fourfold'></span>

<h3>Description</h3>

<p>Creates an (extended) fourfold display of a <code class="reqn">2 \times 2 \times k</code>
contingency table, allowing for the visual inspection of the association
between two dichotomous variables in one or several populations (strata).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourfold(x,
  color = c("#99CCFF", "#6699CC", "#FFA0A0", "#A0A0FF", "#FF0000", "#000080"),
  conf_level = 0.95, std = c("margins", "ind.max", "all.max"),
  margin = c(1, 2), space = 0.2, main = NULL, sub = NULL,
  mfrow = NULL, mfcol = NULL, extended = TRUE, ticks = 0.15,
  p_adjust_method = p.adjust.methods, newpage = TRUE,
  fontsize = 12, default_prefix = c("Row", "Col", "Strata"),
  sep = ": ", varnames = TRUE, return_grob = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fourfold_+3A_x">x</code></td>
<td>
<p>a <code class="reqn">2 \times 2 \times k</code> contingency table in array form, or a
<code class="reqn">2 \times 2</code> matrix if <code class="reqn">k</code> is 1.  If <code>length(dim(x)&gt;3</code>, 
dimensions <code>3:length(dim(x)</code> are silently raveled into a combined strata dimension
with <code>k=prod(dim(x)[-(1:2)]))</code>.</p>
</td></tr> 
<tr><td><code id="fourfold_+3A_color">color</code></td>
<td>
<p>a vector of length 6 specifying the colors to use for the
smaller and larger diagonals of each <code class="reqn">2 \times 2</code> table. The first pair
is used for the standard (non-extended) plots, the other two
for the extended version: the second/third pair is used for tables with
non-significant/significant log-odds ratios, respectively, the latter
being visualized in brighter colors.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_conf_level">conf_level</code></td>
<td>
<p>confidence level used for the confidence rings on
the odds ratios.  Must be a single non-negative number less than 1;
if set to 0, confidence rings are suppressed.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_std">std</code></td>
<td>
<p>a character string specifying how to standardize the table.
Must be one of <code>"margins"</code>, <code>"ind.max"</code>, or
<code>"all.max"</code>, and can be abbreviated by the initial letter.
If set to <code>"margins"</code>, each <code class="reqn">2 \times 2</code> table is standardized to
equate the margins specified by <code>margin</code> while preserving the
odds ratio.  If <code>"ind.max"</code> or <code>"all.max"</code>, the tables are
either individually or simultaneously standardized to a maximal cell
frequency of 1.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_margin">margin</code></td>
<td>
<p>a numeric vector with the margins to equate.  Must be
one of <code>1</code>, <code>2</code>, or <code>c(1, 2)</code> (the default), which
corresponds to standardizing only the row, only column, or both row and column in
each <code class="reqn">2 \times 2</code> table.
Only used if <code>std</code> equals <code>"margins"</code>.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_space">space</code></td>
<td>
<p>the amount of space (as a fraction of the maximal radius
of the quarter circles) used for the row and column labels.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_main">main</code>, <code id="fourfold_+3A_sub">sub</code></td>
<td>
<p>character string for the fourfold plot title/subtitle.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_mfrow">mfrow</code>, <code id="fourfold_+3A_mfcol">mfcol</code></td>
<td>
<p>a numeric vector with two components:
<var>nr</var> and <var>nc</var>, indicating that the displays for the <code class="reqn">2 \times 2</code>
tables should be arranged in an <var>nr</var> by <var>nc</var> layout, filled
by rows/columns. The defaults are calculated to give a collection of plots in
landscape orientation when <var>k</var> is not a perfect square.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_extended">extended</code></td>
<td>
<p>logical; if <code>TRUE</code>, extended plots are plotted,
i.e., colors are brighter for significant log-odds ratios, and ticks
are plotted showing the direction of association for positive log-odds.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_ticks">ticks</code></td>
<td>
<p>the length of the ticks. If set to 0, no ticks are
plotted.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_p_adjust_method">p_adjust_method</code></td>
<td>
<p>method to be used for p-value adjustments for
multi-stratum plots, as provided by <code>link[stats]{p.adjust}</code>.
Use <code>p_adjust_method="none"</code> to disable this adjustment.
The p-values are used for the &lsquo;visual&rsquo;
significance tests of the odds ratios.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_newpage">newpage</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code>grid.newpage()</code> is
called before plotting.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_fontsize">fontsize</code></td>
<td>
<p>fontsize of main title.  Other labels are scaled
relative to this.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_default_prefix">default_prefix</code></td>
<td>
<p>character vector of length 3 with default labels
for possibly missing row/column/strata variable names.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_sep">sep</code></td>
<td>
<p>default separator between variable names and levels for
labels.</p>
</td></tr>
<tr><td><code id="fourfold_+3A_varnames">varnames</code></td>
<td>
<p>Logical; should the variable names
be printed in the labeling of stratifed plots?</p>
</td></tr>
<tr><td><code id="fourfold_+3A_return_grob">return_grob</code></td>
<td>
<p>Logical; shall a snapshot of the display be
returned as a grob object?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fourfold display is designed for the display of <code class="reqn">2 \times 2 \times k</code>
tables.
</p>
<p>Following suitable standardization, the cell frequencies
<code class="reqn">f_{ij}</code> of each <code class="reqn">2 \times 2</code> table are shown as a quarter
circle whose radius is proportional to
<code class="reqn">\sqrt{f_{ij}}</code> so that its area is proportional to
the cell frequency.  An association (odds ratio different from 1)
between the binary row and column variables is indicated by the
tendency of diagonally opposite cells in one direction to differ in
size from those in the other direction; color is used to show this
direction.  Confidence rings for the odds ratio allow a visual test of
the null of no association; the rings for adjacent quadrants overlap
iff the observed counts are consistent with the null hypothesis.
</p>
<p>Typically, the number <code class="reqn">k</code> corresponds to the number of levels of a
stratifying variable, and it is of interest to see whether the
association is homogeneous across strata.  The fourfold display
visualizes the pattern of association.  Note that the confidence rings
for the individual odds ratios are not adjusted for multiple testing.
</p>


<h3>References</h3>

<p>Friendly, M. (1994),
<em>A fourfold display for 2 by 2 by <code class="reqn">k</code> tables</em>.
Technical Report 217, York University, Psychology Department,
<a href="http://datavis.ca/papers/4fold/4fold.pdf">http://datavis.ca/papers/4fold/4fold.pdf</a>.
</p>
<p>Friendly, M. (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mosaic">mosaic</a></code>,
<code><a href="#topic+assoc">assoc</a></code>
</p>
<p><code>link[stats]{p.adjust}</code> for methods of p value adjustment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("UCBAdmissions")
## Use the Berkeley admission data as in Friendly (1995).
x &lt;- aperm(UCBAdmissions, c(2, 1, 3))
dimnames(x)[[2]] &lt;- c("Yes", "No")
names(dimnames(x)) &lt;- c("Sex", "Admit?", "Department")
ftable(x)

## Fourfold display of data aggregated over departments, with
## frequencies standardized to equate the margins for admission
## and sex.
## Figure 1 in Friendly (1994).
fourfold(margin.table(x, c(1, 2)))

## Fourfold display of x, with frequencies in each table
## standardized to equate the margins for admission and sex.
## Figure 2 in Friendly (1994).
fourfold(x)
cotabplot(x, panel = cotab_fourfold)

## Fourfold display of x, with frequencies in each table
## standardized to equate the margins for admission. but not
## for sex.
## Figure 3 in Friendly (1994).
fourfold(x, margin = 2)
</code></pre>

<hr>
<h2 id='goodfit'>Goodness-of-fit Tests for Discrete Data</h2><span id='topic+goodfit'></span><span id='topic+summary.goodfit'></span><span id='topic+plot.goodfit'></span><span id='topic+predict.goodfit'></span><span id='topic+fitted.goodfit'></span><span id='topic+residuals.goodfit'></span><span id='topic+print.goodfit'></span>

<h3>Description</h3>

<p>Fits a discrete (count data) distribution for goodness-of-fit tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goodfit(x, type = c("poisson", "binomial", "nbinomial"),
  method = c("ML", "MinChisq"), par = NULL)
## S3 method for class 'goodfit'
predict(object, newcount = NULL, type = c("response", "prob"), ...)
## S3 method for class 'goodfit'
residuals(object, type = c("pearson", "deviance",
"raw"), ...)
## S3 method for class 'goodfit'
print(x, residuals_type = c("pearson", "deviance",
"raw"), ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="goodfit_+3A_x">x</code></td>
<td>
<p>either a vector of counts, a 1-way table of frequencies of
counts or a data frame or matrix with frequencies in the first
column and the corresponding counts in the second column.</p>
</td></tr>
<tr><td><code id="goodfit_+3A_type">type</code></td>
<td>
<p>character string indicating: for <code>goodfit</code>, which
distribution should be fit; for <code>predict</code>, the
type of prediction (fitted response or probabilities); for
<code>residuals</code>, either <code>"pearson"</code>, <code>"deviance"</code> or
<code>"raw"</code>.</p>
</td></tr>
<tr><td><code id="goodfit_+3A_residuals_type">residuals_type</code></td>
<td>
<p>character string indicating the type of
residuals: either <code>"pearson"</code>, <code>"deviance"</code> or
<code>"raw"</code>.</p>
</td></tr>
<tr><td><code id="goodfit_+3A_method">method</code></td>
<td>
<p>a character string indicating whether the distribution
should be fit via ML (Maximum Likelihood) or Minimum Chi-squared.</p>
</td></tr>
<tr><td><code id="goodfit_+3A_par">par</code></td>
<td>
<p>a named list giving the distribution parameters (named as
in the corresponding density function), if set to <code>NULL</code>, the
default, the parameters are estimated.  If the parameter <code>size</code>
is not specified if <code>type</code> is <code>"binomial"</code> it is taken to
be the maximum count. If <code>type</code> is <code>"nbinomial"</code>, then
parameter <code>size</code> can be specified to fix it so that only the
parameter <code>prob</code> will be estimated (see the examples below).</p>
</td></tr>
<tr><td><code id="goodfit_+3A_object">object</code></td>
<td>
<p>an object of class <code>"goodfit"</code>.</p>
</td></tr>
<tr><td><code id="goodfit_+3A_newcount">newcount</code></td>
<td>
<p>a vector of counts.  By default the counts stored in
<code>object</code> are used, i.e., the fitted values are computed.  These
can also be extracted by <code>fitted(object)</code>.</p>
</td></tr>
<tr><td><code id="goodfit_+3A_...">...</code></td>
<td>
<p><em>currently not used</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>goodfit</code> essentially computes the fitted values of a discrete
distribution (either Poisson, binomial or negative binomial) to the
count data given in <code>x</code>.  If the parameters are not specified
they are estimated either by ML or Minimum Chi-squared. 
</p>
<p>To fix parameters,
<code>par</code> should be a named list specifying the parameters <code>lambda</code>
for <code>"poisson"</code> and <code>prob</code> and <code>size</code> for
<code>"binomial"</code> or <code>"nbinomial"</code>, respectively.
If for <code>"binomial"</code>, <code>size</code> is not specified it is not
estimated but taken as the maximum count.
</p>
<p>The corresponding Pearson Chi-squared or likelihood ratio statistic,
respectively, is computed and given with their <code class="reqn">p</code> values by the
<code>summary</code> method. The <code>summary</code> method always prints this
information and returns a matrix  with the printed information
invisibly. The <code>plot</code> method produces a
<code><a href="#topic+rootogram">rootogram</a></code> of the observed and fitted values.
</p>
<p>In case of count distribtions (Poisson and negative binomial), the
minimum Chi-squared approach is somewhat ad hoc. Strictly speaking,
the Chi-squared asymptotics would only hold if the number of cells
were fixed or did not increase too quickly with the sample size. However,
in <code>goodfit</code> the number of cells is data-driven: Each count is
a cell of its own. All counts larger than the maximal count are merged
into the cell with the last count for computing the test statistic.
</p>


<h3>Value</h3>

<p>A list of class <code>"goodfit"</code> with elements:
</p>
<table role = "presentation">
<tr><td><code>observed</code></td>
<td>
<p>observed frequencies.</p>
</td></tr>
<tr><td><code>count</code></td>
<td>
<p>corresponding counts.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>expected frequencies (fitted by ML).</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a character string indicating the distribution fitted.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the fitting method (can
be either <code>"ML"</code>, <code>"MinChisq"</code> or <code>"fixed"</code> if the
parameters were specified).</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>a named list of the (estimated) distribution parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>References</h3>

<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rootogram">rootogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulated data examples:
dummy &lt;- rnbinom(200, size = 1.5, prob = 0.8)
gf &lt;- goodfit(dummy, type = "nbinomial", method = "MinChisq")
summary(gf)
plot(gf)

dummy &lt;- rbinom(100, size = 6, prob = 0.5)
gf1 &lt;- goodfit(dummy, type = "binomial", par = list(size = 6))
gf2 &lt;- goodfit(dummy, type = "binomial", par = list(prob = 0.6, size = 6))
summary(gf1)
plot(gf1)
summary(gf2)
plot(gf2)

## Real data examples:
data("HorseKicks")
HK.fit &lt;- goodfit(HorseKicks)
summary(HK.fit)
plot(HK.fit)

data("Federalist")
## try geometric and full negative binomial distribution
F.fit &lt;- goodfit(Federalist, type = "nbinomial", par = list(size = 1))
F.fit2 &lt;- goodfit(Federalist, type = "nbinomial")
summary(F.fit)
summary(F.fit2)
plot(F.fit)
plot(F.fit2)
</code></pre>

<hr>
<h2 id='grid_barplot'>Barplot</h2><span id='topic+grid_barplot'></span>

<h3>Description</h3>

<p>Bar plots of 1-way tables in grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_barplot(height, width = 0.8, offset = 0,
  names = NULL, xlim = NULL, ylim = NULL, xlab = "", ylab = "", main = "",
  gp = gpar(fill = "lightgray"), name = "grid_barplot",
  newpage = TRUE, pop = FALSE, return_grob = FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid_barplot_+3A_height">height</code></td>
<td>
<p>either a vector or a 1-way table of frequencies.</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_width">width</code></td>
<td>
<p>width of the bars (recycled if needed to the number of bars).</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_offset">offset</code></td>
<td>
<p>offset of the bars (recycled if needed to the number of bars).</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_names">names</code></td>
<td>
<p>a vector of names for the bars, if set
to <code>NULL</code> the names of <code>height</code> are used.</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_xlim">xlim</code></td>
<td>
<p>limits for the x axis.</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y axis.</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis.</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_main">main</code></td>
<td>
<p>a title for the plot.</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_gp">gp</code></td>
<td>
<p>a <code>"gpar"</code> object controlling the grid graphical
parameters of the rectangles.</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_name">name</code></td>
<td>
<p>name of the plotting viewport.</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_newpage">newpage</code></td>
<td>
<p>logical. Should <code><a href="grid.html#topic+grid.newpage">grid.newpage</a></code> be called 
before plotting?</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_pop">pop</code></td>
<td>
<p>logical. Should the viewport created be popped?</p>
</td></tr>
<tr><td><code id="grid_barplot_+3A_return_grob">return_grob</code></td>
<td>
<p>logical. Shall the plot be returned as a grob object?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>grid_barplot</code> mimics (some of) the features of <code><a href="graphics.html#topic+barplot">barplot</a></code>,
but currently it only supports 1-way tables.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid_barplot(sample(1:6), names = letters[1:6])
</code></pre>

<hr>
<h2 id='grid_legend'>Legend Function for grid Graphics</h2><span id='topic+grid_legend'></span>

<h3>Description</h3>

<p>This function can be used to add legends to <em>grid-based</em> plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_legend(x, y, pch = NA, col = par('col'), labels, frame = TRUE,
            hgap = unit(0.8, "lines"), vgap = unit(0.8, "lines"),
            default_units = "lines", gp = gpar(), draw = TRUE,
            title = NULL, just = 'center', lwd = NA, lty = NA,
            size = 1,
            gp_title = NULL, gp_labels = NULL,
            gp_frame = gpar(fill = "transparent"),
            inset = c(0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid_legend_+3A_x">x</code></td>
<td>
<p>character string <code>"topright"</code>, <code>"topleft"</code>, <code>"bottomright"</code>,
<code>"bottomleft"</code>, <code>"top"</code>, <code>"bottom"</code>, <code>"left"</code>, <code>"right"</code>, <code>"center"</code> or x coordinate of the legend.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_y">y</code></td>
<td>
<p>y coordinates of the legend.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_pch">pch</code></td>
<td>
<p>integer vector of plotting symbols, if any.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_col">col</code></td>
<td>
<p>character vector of colors for the symbols.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_labels">labels</code></td>
<td>
<p>character vector of labels corresponding to the symbols.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_frame">frame</code></td>
<td>
<p>logical indicating whether the legend should have a
border or not.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_hgap">hgap</code></td>
<td>
<p>object of class <code>"unit"</code> specifying the space between
symbols and labels.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_vgap">vgap</code></td>
<td>
<p>object of class <code>"unit"</code> specifying the space between
the lines.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_default_units">default_units</code></td>
<td>
<p>character string indicating the default unit.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_gp">gp</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the legend.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_draw">draw</code></td>
<td>
<p>logical indicating whether the legend be drawn or not.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_title">title</code></td>
<td>
<p>character string indicating the plot's title.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_just">just</code></td>
<td>
<p>justification of the legend relative to its (x, y)
location. see ?viewport for more details.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_lwd">lwd</code></td>
<td>
<p>positive number to set the line width. if specified lines are drawn.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_lty">lty</code></td>
<td>
<p>line type. if specified lines are drawn.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_size">size</code></td>
<td>
<p>size of the group symbols (in char units).</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_gp_title">gp_title</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the title.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_gp_labels">gp_labels</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the labels.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_gp_frame">gp_frame</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the frame.</p>
</td></tr>
<tr><td><code id="grid_legend_+3A_inset">inset</code></td>
<td>
<p>numeric vector of length 2 specifying the inset of the
legend in npc units, relative to the specified x and y coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the legend as a <code>"grob"</code> object.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
Florian Gerber <a href="mailto:florian.gerber@math.uzh.ch">florian.gerber@math.uzh.ch</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+legend">legend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lifeboats")
attach(Lifeboats)
ternaryplot(Lifeboats[,4:6],
  pch = ifelse(side == "Port", 1, 19),
  col = ifelse(side == "Port", "red", "blue"),
  id  = ifelse(men / total &gt; 0.1, as.character(boat), NA),
  prop_size = 2,
  dimnames_position = "edge",
  main = "Lifeboats on Titanic")
grid_legend(0.8, 0.9, c(1, 19), c("red", "blue"),
  c("Port", "Starboard"), title = "SIDE")


grid.newpage()
pushViewport(viewport(height = .9, width = .9 ))
grid.rect(gp = gpar(lwd = 2, lty = 2))

grid_legend(x = unit(.05,'npc'),
            y = unit(.05,'npc'),
            just = c(0,0),
            pch = c(1,2,3),
            col = c(1,2,3),
            lwd=NA, 
            lty=NA,
            labels = c("b",'r','g'),
            title = NULL,
            gp=gpar(lwd=2, cex=1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))

grid_legend(x = unit(1,'npc'),
            y = unit(1,'npc'),
            just = c(1,1),
            pch = NA,
            col = c(1,2,3,4),
            lwd=c(1,1,1,3), 
            lty=c(1,2,1,3),
            labels = c("black",'red','green','blue'),
            gp_labels = list(gpar(col = 1), gpar(col = 2), gpar(col = 3), gpar(col = 4)),
            title = NULL,
            gp=gpar(lwd=2, cex=1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))

grid_legend(x = 'topleft',
            pch = c(1,NA,2,NA),
            col = c(1,2,3,4),
            lwd=NA, 
            lty=c(NA,2,NA,3),
            labels = c("black",'red','green','blue'),
            title = 'Some LONG Title',
            gp_title = gpar(col = 3),
            gp_frame = gpar(col = 4, lty = 2, fill = "transparent"),
            gp_labels = gpar(col = 6),
            gp=gpar(lwd=2, cex=2, col = 1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))

grid_legend(x = .7,
            y = .7,
            pch = c(1,NA,2,NA),
            col = c(1,2,3,4),
            lwd=1, 
            lty=c(NA,2,NA,3),
            labels = c("black",'red','green','blue'),
            title = 'short T',
            gp=gpar(lwd=1, cex=.7,col = 1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))

grid_legend(x = 'bottomright',
            pch = c(1,NA,2,NA),
            col = c(2),
            lwd=NA, 
            lty=c(NA,2,NA,3),
            labels = c("black",'red','green','blue'),
            title = NULL,
            gp=gpar(lwd=2, cex=1,col = 1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))
</code></pre>

<hr>
<h2 id='Hitters'>Hitters Data</h2><span id='topic+Hitters'></span>

<h3>Description</h3>

<p>This data set is deduced from the <code><a href="#topic+Baseball">Baseball</a></code> fielding data
set: fielding performance basically includes the numbers of Errors,
Putouts and Assists made by each player.  In order to reduce the
number of observations, the was compressed by calculating the mean
number of errors, putouts and assists for each team and for only 6
positions (1B, 2B, 3B, C, OF, SS and UT).  In addition, each of these
three variables was scaled to a common range by dividing each variable
by the maximum of the variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Hitters")</code></pre>


<h3>Format</h3>

<p>A data frame with 154 observations and 4 variables.
</p>

<dl>
<dt>Positions</dt><dd><p>factor indicating the field position (1B=first
baseman, 2B=second baseman, 3B=third baseman, C=catcher,
OF=outfielder, SS=Short Stop, UT=Utility Players).</p>
</dd>
<dt>Putouts</dt><dd><p>occur when a fielder causes an opposing player to be
tagged or forced out.</p>
</dd>
<dt>Assists</dt><dd><p>are credited to other fielders involved in making
that putout.</p>
</dd>
<dt>Errors</dt><dd><p>count the errors made by a player.</p>
</dd>
</dl>



<h3>Source</h3>

<p>SAS System for Statistical Graphics, First Edition, Page A2.3
</p>


<h3>References</h3>

<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Hitters")
attach(Hitters)

colors &lt;- c("black","red","green","blue","red","black","blue")
pch &lt;- substr(levels(Positions), 1, 1)
ternaryplot(Hitters[,2:4],
  pch = as.character(Positions),
  col = colors[as.numeric(Positions)],
  main = "Baseball Hitters Data")
grid_legend(0.8, 0.9, pch, colors, levels(Positions),
  title = "POSITION(S)")

detach(Hitters)
</code></pre>

<hr>
<h2 id='hls'>HLS Color Specification</h2><span id='topic+hls'></span>

<h3>Description</h3>

<p>Create a HLS color from specifying hue, luminance and saturation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hls(h = 1, l = 0.5, s = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hls_+3A_h">h</code></td>
<td>
<p>hue value in [0, 1].</p>
</td></tr>
<tr><td><code id="hls_+3A_l">l</code></td>
<td>
<p>luminance value in [0, 1].</p>
</td></tr>
<tr><td><code id="hls_+3A_s">s</code></td>
<td>
<p>saturation value in [0, 1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>HLS colors are a similar specification of colors as HSV
colors, but using hue/luminance/saturation rather that
hue/saturation/value.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+hsv">hsv</a></code>,
<code><a href="#topic+hcl2hex">hcl2hex</a></code>,
<code><a href="colorspace.html#topic+polarLUV">polarLUV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## an HLS color wheel
pie(rep(1, 12), col = sapply(1:12/12, function(x) hls(x)))
</code></pre>

<hr>
<h2 id='HorseKicks'>Death by Horse Kicks</h2><span id='topic+HorseKicks'></span>

<h3>Description</h3>

<p>Data from von Bortkiewicz (1898), given by Andrews &amp; Herzberg (1985),
on number of deaths by horse or mule kicks in 10 (of 14 reported)
corps of the Prussian army.  4 corps were not considered by Fisher
(1925) as they had a different organization. This data set is a
popular subset of the <code><a href="#topic+VonBort">VonBort</a></code> data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HorseKicks")
</code></pre>


<h3>Format</h3>

<p>A 1-way table giving the number of deaths in 200 corps-years.  The
variable and its levels are
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> nDeaths </td><td style="text-align: left;"> 0, 1, ..., 4 </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Michael Friendly (2000),
Visualizing Categorical Data, page 18.
</p>


<h3>References</h3>

<p>D. F. Andrews &amp; A. M. Herzberg (1985),
<em>Data: A Collection of Problems from Many Fields for the Student
and Research Worker</em>.
Springer-Verlag, New York, NY.
</p>
<p>R. A. Fisher (1925),
<em>Statistical Methods for Research Workers</em>.
Oliver &amp; Boyd, London.
</p>
<p>L. von Bortkiewicz (1898),
<em>Das Gesetz der kleinen Zahlen</em>.
Teubner, Leipzig.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VonBort">VonBort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HorseKicks")
gf &lt;- goodfit(HorseKicks)
summary(gf)
plot(gf)
</code></pre>

<hr>
<h2 id='Hospital'>Hospital data</h2><span id='topic+Hospital'></span>

<h3>Description</h3>

<p>The table relates the length of stay (in years) of 132
long-term schizophrenic patients in two London mental hospitals with
the frequency of visits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Hospital")
</code></pre>


<h3>Format</h3>

<p>A 2-dimensional array resulting from cross-tabulating 
132 patients.  The variables and their levels are as follows:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> Visit Frequency </td><td style="text-align: left;"> Regular, Less than monthly, Never </td>
</tr>
<tr>
 <td style="text-align: right;">
    2 </td><td style="text-align: left;"> Length of Stay </td><td style="text-align: left;"> 2--9 years, 10--19 years, 20+ years
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Wing (1962) who collected this data concludes 
that the longer the length of stay in hospital, the less frequent the
visits.
</p>
<p>Haberman (1974) notes that this pattern does not increase from the &quot;Less
than monthly&quot; to the &quot;Never&quot; group, which are homogeneous.
</p>


<h3>Source</h3>

<p>S.J Haberman (1974): Log-linear models for frequency tables with ordered
classifications. Biometrics, 30:689&ndash;700.
</p>


<h3>References</h3>

<p>J.K. Wing (1962): Institutionalism in mental hospitals.
British Journal of Social Clinical Psychology, 1:38&ndash;51.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Hospital")

mosaic(t(Hospital), shade = TRUE)
mosaic(Hospital, shade = TRUE)
sieve(Hospital, shade = TRUE)
assoc(Hospital, shade = TRUE)
</code></pre>

<hr>
<h2 id='independence_table'>Independence Table</h2><span id='topic+independence_table'></span>

<h3>Description</h3>

<p>Computes table of expected frequencies (under the null hypotheses of
independence) from an <code class="reqn">n</code>-way table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>independence_table(x, frequency = c("absolute", "relative"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="independence_table_+3A_x">x</code></td>
<td>
<p>a table.</p>
</td></tr>
<tr><td><code id="independence_table_+3A_frequency">frequency</code></td>
<td>
<p>indicates whether absolute or relative frequencies
should be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with either absolute or relative frequencies.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("MSPatients")
independence_table(MSPatients)
independence_table(MSPatients, frequency = "relative")
</code></pre>

<hr>
<h2 id='JobSatisfaction'>Job Satisfaction Data</h2><span id='topic+JobSatisfaction'></span>

<h3>Description</h3>

<p>Data from Petersen (1968) about the job satisfaction of 715 blue
collar workers, selected from Danish Industry in 1968.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("JobSatisfaction")
</code></pre>


<h3>Format</h3>

<p>A data frame with 8 observations and 4 variables.
</p>

<dl>
<dt>Freq</dt><dd><p>frequency.</p>
</dd>
<dt>management</dt><dd><p>factor indicating quality of management (bad,
good).</p>
</dd> 
<dt>supervisor</dt><dd><p>factor indicating supervisor's job satisfaction
(low, high).</p>
</dd>
<dt>own</dt><dd><p>factor indicating worker's own job satisfaction (low,
high).</p>
</dd>
</dl>



<h3>Source</h3>

<p>E. B. Andersen (1991),
The Statistical Analysis of Categorical Data, Table 5.4.
</p>


<h3>References</h3>

<p>E. B. Andersen (1991),
<em>The Statistical Analysis of Categorical Data</em>.
2nd edition.
Springer-Verlag, Berlin.
</p>
<p>E. Petersen (1968),
<em>Job Satisfaction in Denmark</em>.
(In Danish).
Mentalhygiejnisk Forlag, Copenhagen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("JobSatisfaction")
structable(~ ., data = JobSatisfaction)

mantelhaen.test(xtabs(Freq ~ own + supervisor + management,
                      data = JobSatisfaction))

</code></pre>

<hr>
<h2 id='JointSports'>Opinions About Joint Sports</h2><span id='topic+JointSports'></span>

<h3>Description</h3>

<p>Data from a Danish study in 1983 and 1985 about sports activities and
the opinion about joint sports with the other gender among 16&ndash;19 year
old high school students.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("JointSports")
</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations and 5 variables.
</p>

<dl>
<dt>Freq</dt><dd><p>frequency.</p>
</dd>
<dt>opinion</dt><dd><p>factor indicating opinion about sports joint with the
other gender (very good, good, indifferent, bad, very bad).</p>
</dd>
<dt>year</dt><dd><p>factor indicating year of study (1983, 1985).</p>
</dd>
<dt>grade</dt><dd><p>factor indicating school grade (1st, 3rd).</p>
</dd>
<dt>gender</dt><dd><p>factor indicating gender (Boy, Girl).</p>
</dd>
</dl>



<h3>Source</h3>

<p>E. B. Andersen (1991),
The Statistical Analysis of Categorical Data, page 210.
</p>


<h3>References</h3>

<p>E. B. Andersen (1991),
<em>The Statistical Analysis of Categorical Data</em>.
2nd edition.
Springer-Verlag, Berlin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
data("JointSports")
tab &lt;- xtabs(Freq ~ gender + opinion + grade + year, data = JointSports)
doubledecker(opinion ~ gender + year + grade, data = tab)
loglm(~ opinion* (gender + grade+ year) + gender*year*grade, data = tab)
</code></pre>

<hr>
<h2 id='Kappa'>Cohen's Kappa and Weighted Kappa</h2><span id='topic+Kappa'></span><span id='topic+print.Kappa'></span><span id='topic+confint.Kappa'></span><span id='topic+summary.Kappa'></span><span id='topic+print.summary.Kappa'></span>

<h3>Description</h3>

<p>Computes two agreement rates: Cohen's kappa and weighted kappa, and
confidence bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kappa(x, weights = c("Equal-Spacing", "Fleiss-Cohen"))
## S3 method for class 'Kappa'
print(x, digits=max(getOption("digits") - 3, 3),
CI=FALSE, level=0.95, ...)
## S3 method for class 'Kappa'
confint(object, parm, level = 0.95, ...)
## S3 method for class 'Kappa'
summary(object, ...)
## S3 method for class 'summary.Kappa'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kappa_+3A_x">x</code></td>
<td>
<p>For <code>Kappa</code>: a confusion matrix. For the print methods:
object of class <code>"Kappa"</code> or <code>"summary.Kappa"</code></p>
</td></tr>
<tr><td><code id="Kappa_+3A_weights">weights</code></td>
<td>
<p>either one of the character strings given in the
default value, or a user-specified matrix with same dimensions as
<code>x</code>.</p>
</td></tr>
<tr><td><code id="Kappa_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits.</p>
</td></tr>
<tr><td><code id="Kappa_+3A_ci">CI</code></td>
<td>
<p>logical; shall confidence limits be added to the output?</p>
</td></tr>
<tr><td><code id="Kappa_+3A_level">level</code></td>
<td>
<p>confidence level between 0 and 1 used for the confidence
interval.</p>
</td></tr>
<tr><td><code id="Kappa_+3A_object">object</code></td>
<td>
<p>object of class <code>"Kappa"</code>.</p>
</td></tr>
<tr><td><code id="Kappa_+3A_parm">parm</code></td>
<td>
<p>Currently, ignored.</p>
</td></tr>
<tr><td><code id="Kappa_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the default print method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cohen's kappa is the diagonal sum of the (possibly weighted) relative
frequencies, corrected for expected values and standardized by its
maximum value.
The equal-spacing weights are defined by <code class="reqn">1 - |i - j| / (r -
    1)</code>, <code class="reqn">r</code> number of columns/rows, and
the Fleiss-Cohen weights by <code class="reqn">1 - |i - j|^2 / (r - 1)^2</code>.
The latter one attaches greater importance to near disagreements.
</p>


<h3>Value</h3>

<p>An object of class <code>"Kappa"</code> with three components:
</p>
<table role = "presentation">
<tr><td><code>Unweighted</code></td>
<td>
<p>numeric vector of length 2 with the kappa statistic
(<code>value</code> component), along with Approximate Standard Error
(<code>ASE</code> component)</p>
</td></tr>
<tr><td><code>Weighted</code></td>
<td>
<p>idem for the weighted kappa.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>numeric matrix with weights used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>summary</code> method also prints the weights.
</p>
<p>There is a <code>confint</code> method for computing approximate confidence
intervals.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Cohen, J. (1960),
A coefficient of agreement for nominal scales.
<em>Educational and Psychological Measurement</em>,
<b>20</b>, 37&ndash;46.
</p>
<p>Everitt, B.S. (1968),
Moments of statistics kappa and weighted kappa.
<em>The British Journal of Mathematical and Statistical Psychology</em>,
<b>21</b>, 97&ndash;103.
</p>
<p>Fleiss, J.L., Cohen, J., and Everitt, B.S. (1969),
Large sample standard errors of kappa and weighted kappa.
<em>Psychological Bulletin</em>,
<b>72</b>, 332&ndash;327.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+agreementplot">agreementplot</a></code>,
<code><a href="stats.html#topic+confint">confint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SexualFun")
K &lt;- Kappa(SexualFun)
K
confint(K)
summary(K)
print(K, CI = TRUE)

</code></pre>

<hr>
<h2 id='labeling_border'>Labeling Functions for Strucplots</h2><span id='topic+labeling_border'></span><span id='topic+labeling_conditional'></span><span id='topic+labeling_left'></span><span id='topic+labeling_left2'></span><span id='topic+labeling_cboxed'></span><span id='topic+labeling_lboxed'></span><span id='topic+labeling_doubledecker'></span><span id='topic+labeling_values'></span><span id='topic+labeling_residuals'></span><span id='topic+labelings'></span>

<h3>Description</h3>

<p>These functions generate labeling functions used for strucplots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labeling_border(labels = TRUE, varnames = labels,
  set_labels = NULL, set_varnames = NULL, 
  tl_labels = NULL, alternate_labels = FALSE, tl_varnames = NULL, 
  gp_labels = gpar(fontsize = 12),
  gp_varnames = gpar(fontsize = 12, fontface = 2),
  rot_labels = c(0, 90, 0, 90), rot_varnames = c(0, 90, 0, 90),
  pos_labels = "center", pos_varnames = "center",
  just_labels = "center", just_varnames = pos_varnames,
  boxes = FALSE, fill_boxes = FALSE,
  offset_labels = c(0, 0, 0, 0), offset_varnames = offset_labels,
  labbl_varnames = NULL, labels_varnames = FALSE, sep = ": ",
  abbreviate_labs = FALSE, rep = TRUE, clip = FALSE, ...)
labeling_values(value_type = c("observed", "expected", "residuals"),
                suppress = NULL, digits = 1, clip_cells = FALSE, ...)
labeling_residuals(suppress = NULL, digits = 1, clip_cells = FALSE, ...)
labeling_conditional(...)
labeling_left(rep = FALSE, pos_varnames = "left",
  pos_labels = "left", just_labels = "left", ...)
labeling_left2(tl_labels = TRUE, clip = TRUE, pos_varnames = "left",
  pos_labels = "left", just_labels = "left", ...)
labeling_cboxed(tl_labels = TRUE, boxes = TRUE, clip = TRUE,
  pos_labels = "center", ...)
labeling_lboxed(tl_labels = FALSE, boxes = TRUE, clip = TRUE,
  pos_labels = "left", just_labels = "left",
  labbl_varnames = FALSE, ...)
labeling_doubledecker(lab_pos = c("bottom", "top"), dep_varname = TRUE,
  boxes = NULL, clip = NULL, labbl_varnames = FALSE,
  rot_labels = rep.int(0, 4),
  pos_labels = c("left", "center", "left", "center"),
  just_labels = c("left", "left", "left", "center"),
  varnames = NULL, gp_varnames = gpar(fontsize = 12, fontface = 2),
  offset_varnames = c(0, -0.6, 0, 0), tl_labels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labeling_border_+3A_labels">labels</code></td>
<td>
<p>vector of logicals indicating whether labels should be
drawn for a particular dimension.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_varnames">varnames</code></td>
<td>
<p>vector of logicals indicating whether variable names
should be drawn for a particular dimension.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_set_labels">set_labels</code></td>
<td>
<p>An optional character vector with named components
replacing the so-specified variable names. The component names must
exactly match the variable names to be replaced.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_set_varnames">set_varnames</code></td>
<td>
<p>An optional list with named components of
character vectors replacing the labels of the so-specified
variables. The component names must
exactly match the variable names whose labels should be replaced.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_tl_labels">tl_labels</code></td>
<td>
<p>vector of logicals indicating whether labels should
be positioned on top (column labels) / left (row labels) for a
particular dimension.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_alternate_labels">alternate_labels</code></td>
<td>
<p>vector of logicals indicating whether labels should
be alternated on the top/bottom (left/right) side of the plot for a
particular dimension.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_tl_varnames">tl_varnames</code></td>
<td>
<p>vector of logicals indicating whether variable
names should be positioned on top (column labels) / on left (row
labels) for a particular dimension.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_gp_labels">gp_labels</code></td>
<td>
<p>list of objects of class <code>"gpar"</code> used for
drawing the labels.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_gp_varnames">gp_varnames</code></td>
<td>
<p>list of objects of class <code>"gpar"</code> used for
drawing the variable names.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_rot_labels">rot_labels</code></td>
<td>
<p>vector of rotation angles for the labels for each of
the four sides of the plot.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_rot_varnames">rot_varnames</code></td>
<td>
<p>vector of rotation angles for the variable names
for each of the four sides of the plot.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_pos_labels">pos_labels</code></td>
<td>
<p>character string of label positions (<code>"left"</code>,
<code>"center"</code>, <code>"right"</code>) for each of the variables.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_pos_varnames">pos_varnames</code></td>
<td>
<p>character string of variable names positions
(<code>"left"</code>, <code>"center"</code>, <code>"right"</code>) for each of the
four sides of the plot.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_just_labels">just_labels</code></td>
<td>
<p>character string of label justifications
(<code>"left"</code>, <code>"center"</code>, <code>"right"</code>) for each of the
variables.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_just_varnames">just_varnames</code></td>
<td>
<p>character string of variable names justifications
(<code>"left"</code>, <code>"center"</code>, <code>"right"</code>) for each of the
four sides of the plot.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_boxes">boxes</code></td>
<td>
<p>vector of logicals indicating whether boxes should be
drawn around the labels for a particular dimension.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_fill_boxes">fill_boxes</code></td>
<td>
<p>Either a vector of logicals, or a vector of characters,
or a list of such vectors, specifying the fill colors for the
boxes. <code>"TRUE"</code> and <code>"FALSE"</code> values are
transformed into <code>"grey"</code> and <code>"white"</code>, respectively. If
<code>fill_boxes</code> is atomic, each component
specifies a basic color for the corresponding dimension. This color
is transformed into its HSV representation, and the value is varied
from 50% to 100% to give a sequential color palette for the
levels. For <code>NA</code> components, no palette is produced (no fill
color). If <code>fill_boxes</code> is a list of vectors,
each vector specifies the level colors of the corresponding
dimension.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_offset_labels">offset_labels</code>, <code id="labeling_border_+3A_offset_varnames">offset_varnames</code></td>
<td>
<p>numeric vector of length 4
indicating the offset of the
labels (variable names) for each of the four sides of the plot.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_labbl_varnames">labbl_varnames</code></td>
<td>
<p>vector of logicals indicating whether variable
names should be drawn on the left (column variables) / on top (row
variables) of the corresponding labels.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_labels_varnames">labels_varnames</code></td>
<td>
<p>vector of logicals indicating, for each
dimension, whether the variable name should be added to the
corresponding labels or not.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_sep">sep</code></td>
<td>
<p>separator used if any component of <code>"labels_varnames"</code>
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_abbreviate_labs">abbreviate_labs</code></td>
<td>
<p>vector of integers or logicals indicating, for each
dimension, the number of characters the labels should be abbreviated
to.
<code>TRUE</code> means 1 character, <code>FALSE</code> causes no abbreviation.
Values are recycled as needed.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_rep">rep</code></td>
<td>
<p>vector of logicals indicating, for each dimension, whether
labels should be repeated for all conditioning strata, or appear
only once.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_clip">clip</code></td>
<td>
<p>vector of integers indicating, for each dimension, whether
labels should be clipped to not overlap.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_lab_pos">lab_pos</code></td>
<td>
<p>character string switching between <code>"top"</code> or
<code>"bottom"</code> position of the labels (only used for
<code>labeling_doubledecker</code>).</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_dep_varname">dep_varname</code></td>
<td>
<p>logical or character string. If logical, this is
indicating whether the name of the dependent variable should be
printed or not. A character string will be printed instead of the
variable name taken from the dimnames.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_value_type">value_type</code></td>
<td>
<p>character string specifying which values should be
displayed in the cells.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_suppress">suppress</code></td>
<td>
<p>numeric vector of length 2 specifying an interval of
values that are not displayed. 0 values are never displayed.
A single number, <var>k</var>, is treated as <code>c(-<var>k</var>,
      <var>k</var>)</code>. The default for labeling residuals is
<code>c(-2,2)</code>. Use <code>suppress = 0</code> to show all non-zero values.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_digits">digits</code></td>
<td>
<p>integer specifying the number of digits used for rounding.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_clip_cells">clip_cells</code></td>
<td>
<p>logical indicating whether the values should be clipped at
the cell borders.</p>
</td></tr>
<tr><td><code id="labeling_border_+3A_...">...</code></td>
<td>
<p>only used for <code>labeling_conditional</code> and
<code>labeling_doubledecker</code>: parameters
passed to <code>labeling_cells</code> and <code>labeling_border</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions generate labeling functions called by
<code><a href="#topic+strucplot">strucplot</a></code> for their side-effect of adding labels to the
plot. They suppose that a strucplot has been drawn and the
corresponding viewport structure is pushed, since the positions of the
viewports are used for the label positioning.
Note that the functions can also be used &lsquo;stand-alone&rsquo; as
shown in the examples.
</p>
<p>All values supplied to vectorized arguments can be
&lsquo;abbreviated&rsquo; by using named components which override the
default component values.  In addition, these defaults can be
overloaded by the sequence of non-named components which are recycled
as needed (see examples).
</p>
<p>This help page only documents <code>labeling_border</code> and
derived functions, more functions are described on the help page
for <code><a href="#topic+labeling_cells">labeling_cells</a></code> and <code><a href="#topic+labeling_list">labeling_list</a></code>.
</p>
<p><code>labeling_left</code>, <code>labeling_left2</code>, <code>labeling_cboxed</code>,
and <code>labeling_lboxed</code>
are really just wrappers to <code>labeling_border</code>, and good examples for
the parameter usage.
</p>
<p><code>labeling_residuals</code> is a trivial wrapper for
<code>labeling_values</code>, which in turn calls <code>labeling_border</code> by
additionally adding the observed or expected frequencies or residuals
to the cells.
</p>


<h3>Value</h3>

<p>A function with arguments:
</p>
<table role = "presentation">
<tr><td><code>d</code></td>
<td>
<p><code>"dimnames"</code> attribute from the visualized contingency
table, or the visualized table itself from which the
<code>"dimnames"</code> attributes will then be extracted.</p>
</td></tr>
<tr><td><code>split_vertical</code></td>
<td>
<p>vector of logicals indicating the split
directions.</p>
</td></tr>
<tr><td><code>condvars</code></td>
<td>
<p>integer vector of conditioning dimensions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+labeling_cells">labeling_cells</a></code>, 
<code><a href="#topic+labeling_list">labeling_list</a></code>, 
<code><a href="#topic+structable">structable</a></code>, 
<code><a href="grid.html#topic+grid.text">grid.text</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Titanic")

mosaic(Titanic)

mosaic(Titanic, labeling = labeling_left)
labeling_left

mosaic(Titanic, labeling = labeling_cboxed)
labeling_cboxed

mosaic(Titanic, labeling = labeling_lboxed)
labeling_lboxed

data("PreSex")
mosaic(~ PremaritalSex + ExtramaritalSex | Gender + MaritalStatus,
  data = PreSex, labeling = labeling_conditional)

## specification of vectorized arguments 
mosaic(Titanic, labeling_args = list(abbreviate_labs = c(Survived = TRUE)))

mosaic(Titanic, labeling_args = list(clip = TRUE, boxes = TRUE,
  fill_boxes = c(Survived = "green", "red")))

mosaic(Titanic, labeling_args = list(clip = TRUE, boxes = TRUE,
  fill_boxes = list(Sex = "red", "green")))

mosaic(Titanic, labeling_args = list(clip = TRUE, boxes = TRUE,
  fill_boxes = list(Sex = c(Male = "red", "blue"), "green")))

## change variable names
mosaic(Titanic, labeling_args = list(set_varnames = c(Sex = "Gender")))

## change labels
mosaic(Titanic, labeling_args = list(set_varnames = c(Survived = "Status"),
  set_labels = list(Survived = c("Survived", "Not Survived")), rep = FALSE))

## show frequencies
mosaic(Titanic, labeling = labeling_values)
</code></pre>

<hr>
<h2 id='labeling_cells_list'>Labeling Functions for Strucplots</h2><span id='topic+labeling_list'></span><span id='topic+labeling_cells'></span>

<h3>Description</h3>

<p>These functions generate labeling functions that produce labels for
strucplots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labeling_cells(labels = TRUE, varnames = TRUE,
  abbreviate_labels = FALSE, abbreviate_varnames = FALSE,
  gp_text = gpar(), lsep = ": ", lcollapse = "\n",
  just = "center", pos = "center", rot = 0,
  margin = unit(0.5, "lines"), clip_cells = TRUE,
  text = NULL, ...)
labeling_list(gp_text = gpar(), just = "left", pos = "left", lsep = ": ",
  sep = " ", offset = unit(c(2, 2), "lines"),
  varnames = TRUE, cols = 2, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labeling_cells_list_+3A_labels">labels</code></td>
<td>
<p>vector of logicals indicating, for each dimension,
whether labels for the factor levels should be drawn or not.
Values are recycled as needed.</p>
</td></tr> 
<tr><td><code id="labeling_cells_list_+3A_varnames">varnames</code></td>
<td>
<p>vector of logicals indicating, for each dimension,
whether variable names should be drawn.
Values are recycled as needed.</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_abbreviate_labels">abbreviate_labels</code></td>
<td>
<p>vector of integers or logicals indicating,
for each dimension, the number of characters the labels should be
abbreviated to.
<code>TRUE</code> means 1 character, <code>FALSE</code> causes no abbreviation.
Values are recycled as needed.</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_abbreviate_varnames">abbreviate_varnames</code></td>
<td>
<p>vector of integers or logicals indicating,
for each dimension, the number of characters the variable
(i.e., dimension) names should be abbreviated to.
<code>TRUE</code> means 1 character, <code>FALSE</code> causes no abbreviation.
Values are recycled as needed.</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_gp_text">gp_text</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the text drawn.</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_lsep">lsep</code></td>
<td>
<p>character that separates variable names from the factor
levels.</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_sep">sep</code></td>
<td>
<p>character that separates the factor levels (only used for
<code>labeling_list</code>).</p>
</td></tr> 
<tr><td><code id="labeling_cells_list_+3A_offset">offset</code></td>
<td>
<p>object of class <code>"unit"</code> of length 2 specifying the
offset in x- and y-direction of the text block drawn under the
strucplot (only used for <code>labeling_list</code>).</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_cols">cols</code></td>
<td>
<p>number of text columns (only used for
<code>labeling_list</code>).</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_lcollapse">lcollapse</code></td>
<td>
<p>character that separates several variable name/factor
level-combinations.  Typically a line break.
(Only used for <code>labeling_cells</code>.)</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_just">just</code>, <code id="labeling_cells_list_+3A_pos">pos</code></td>
<td>
<p>character string of length 1 (<code>labeling_list</code>)
or at most 2 (<code>labeling_cells</code>) specifying the labels'
horizontal position and justification (horizontal and vertical for
<code>labeling_cells</code>).</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_rot">rot</code></td>
<td>
<p>rotation angle in degrees, used for all labels (only used
for <code>labeling_cells</code>).</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_margin">margin</code></td>
<td>
<p>object of class <code>"unit"</code> (a numeric value is
converted to <code>"lines"</code>) specifying an offset from the cell
borders (only used for <code>labeling_cells</code>).</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_clip_cells">clip_cells</code></td>
<td>
<p>logical indicating whether text should be clipped at
the cell borders (only used for <code>labeling_cells</code>).</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_text">text</code></td>
<td>
<p>Optionally, a character table of the same dimensions than
the contingency table whose entries will then be used instead of
the labels.  <code>NA</code> entries are not drawn.
This allows custom cell annotations (see examples).
Only used for <code>labeling_cells</code>.</p>
</td></tr>
<tr><td><code id="labeling_cells_list_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions generate labeling functions that can add different
kinds of labels to an existing plot. Typically they are 
supplied to <code><a href="#topic+strucplot">strucplot</a></code> which then generates and calls
the labeling function. They assume that a strucplot has been drawn
and the corresponding viewport structure is pushed, so that by 
navigating through the viewport tree the labels can be positioned
appropriately.
</p>
<p>This help page only documents <code>labeling_list</code> and
<code>labeling_cells</code>; more functions are described on the help page
for <code><a href="#topic+labeling_border">labeling_border</a></code>.
</p>
<p>The functions can also be used &lsquo;stand-alone&rsquo; as shown in the
examples.
</p>
<p>Using <code>labeling_list</code> will typically necessitate a bottom margin
adjustment.
</p>


<h3>Value</h3>

<p>A function with arguments:
</p>
<table role = "presentation">
<tr><td><code>d</code></td>
<td>
<p><code>"dimnames"</code> attribute from the visualized contingency
table, or the visualized table itself from which the
<code>"dimnames"</code> attributes will then be extracted.</p>
</td></tr>
<tr><td><code>split_vertical</code></td>
<td>
<p>vector of logicals indicating the split
directions.</p>
</td></tr>
<tr><td><code>condvars</code></td>
<td>
<p>integer vector of conditioning dimensions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+labeling_border">labeling_border</a></code>, 
<code><a href="#topic+structable">structable</a></code>, 
<code><a href="grid.html#topic+grid.text">grid.text</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Titanic")

mosaic(Titanic, labeling = labeling_cells)
mosaic(Titanic, labeling = labeling_list)

## A more complex example, adding the observed frequencies
## to a mosaic plot:
tab &lt;- ifelse(Titanic &lt; 6, NA, Titanic)
mosaic(Titanic, pop = FALSE)
labeling_cells(text = tab, margin = 0)(Titanic)
</code></pre>

<hr>
<h2 id='legends'>Legend Functions for Strucplots</h2><span id='topic+legends'></span><span id='topic+legend_resbased'></span><span id='topic+legend_fixed'></span>

<h3>Description</h3>

<p>These functions generate legend functions for residual-based shadings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legend_resbased(fontsize = 12, fontfamily = "",
  x = unit(1, "lines"), y = unit(0.1,"npc"),
  height = unit(0.8, "npc"),
  width = unit(0.7, "lines"),
  digits = 2, pdigits = max(1, getOption("digits") - 2),
  check_overlap = TRUE, text = NULL,
  steps = 200, ticks = 10, pvalue = TRUE,  range = NULL)
legend_fixed(fontsize = 12, fontfamily = "", x = unit(1, "lines"), y = NULL,
  height = NULL, width = unit(1.5, "lines"), steps = 200,
  digits = 1, space = 0.05, text = NULL, range = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="legends_+3A_fontsize">fontsize</code></td>
<td>
<p>fontsize of title and p-value text.</p>
</td></tr>
<tr><td><code id="legends_+3A_fontfamily">fontfamily</code></td>
<td>
<p>fontfamily of all text.</p>
</td></tr>
<tr><td><code id="legends_+3A_x">x</code>, <code id="legends_+3A_y">y</code></td>
<td>
<p>objects of class <code>"unit"</code> indicating the coordinates
of the title. For <code>legend_fixed</code>, the default for <code>y</code> is
computed as to leave enough space for the specified <code>text</code>.</p>
</td></tr>
<tr><td><code id="legends_+3A_height">height</code>, <code id="legends_+3A_width">width</code></td>
<td>
<p>object of class <code>"unit"</code> indicating the
height/width of the legend. For <code>legend_fixed</code>, the default for
<code>y</code> is computed as to align upper margins of legend and actual plot.</p>
</td></tr> 
<tr><td><code id="legends_+3A_digits">digits</code></td>
<td>
<p>number of digits for the scale labels.</p>
</td></tr>
<tr><td><code id="legends_+3A_pdigits">pdigits</code></td>
<td>
<p>number of digits for the p-value.</p>
</td></tr>
<tr><td><code id="legends_+3A_check_overlap">check_overlap</code></td>
<td>
<p>logical indicating whether overlap of scale
labels should be inhibited or not.</p>
</td></tr>
<tr><td><code id="legends_+3A_space">space</code></td>
<td>
<p>For <code>legend_fixed</code> only: proportion of space
between the tiles.</p>
</td></tr>
<tr><td><code id="legends_+3A_text">text</code></td>
<td>
<p>character string indicating the title of the legend.</p>
</td></tr>
<tr><td><code id="legends_+3A_steps">steps</code></td>
<td>
<p>granularity of the color gradient.</p>
</td></tr>
<tr><td><code id="legends_+3A_ticks">ticks</code></td>
<td>
<p>number of scale ticks.</p>
</td></tr>
<tr><td><code id="legends_+3A_pvalue">pvalue</code></td>
<td>
<p>logical indicating whether the <code class="reqn">p</code>-value should be
visualized under the scale or not.</p>
</td></tr>
<tr><td><code id="legends_+3A_range">range</code></td>
<td>
<p>Numeric vector of length 2 for setting the legend
range. Computed from the residuals if omitted. <code>NA</code> values are
replaced by the corresponding minimum / maximum of the residuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions generate legend functions for residual-based shadings,
visualizing deviations from expected values of an hypothesized
independence model.  Therefore, the legend uses a supplied shading
function to visualize the color gradient for the residuals range.
<code>legend_fixed</code> is inspired by the legend used in
<code><a href="graphics.html#topic+mosaicplot">mosaicplot</a></code>. For
more details on the shading functions and their return values, see
<code><a href="#topic+shadings">shadings</a></code>.
</p>


<h3>Value</h3>

<p>A function with arguments:
</p>
<table role = "presentation">
<tr><td><code>residuals</code></td>
<td>
<p>residuals from the fitted independence model to be
visualized.</p>
</td></tr>
<tr><td><code>shading</code></td>
<td>
<p>shading function computing colors from residuals (see
details).</p>
</td></tr>
<tr><td><code>autotext</code></td>
<td>
<p>character vector indicating the title to be used when
no <code>text</code> argument is specified. Allows strucplot to generate
sensible defaults depending on the residuals type.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>
<p>Meyer, D., Zeileis, A., Hornik, K. (2003), Visualizing independence using
extended association plots. <em>Proceedings of the 3rd International
Workshop on Distributed Statistical Computing</em>, K. Hornik, F. Leisch,
A. Zeileis (eds.), ISSN 1609-395X.
<a href="https://www.R-project.org/conferences/DSC-2003/Proceedings/">https://www.R-project.org/conferences/DSC-2003/Proceedings/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+structable">structable</a></code>,
<code><a href="#topic+shadings">shadings</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Titanic")

mosaic(Titanic, shade = TRUE, legend = legend_resbased)
mosaic(Titanic, shade = TRUE, legend = legend_fixed, gp = shading_Friendly)
</code></pre>

<hr>
<h2 id='Lifeboats'>Lifeboats on the Titanic</h2><span id='topic+Lifeboats'></span>

<h3>Description</h3>

<p>Data from Mersey (1912) about the 18 (out of 20) lifeboats launched
before the sinking of the S. S. Titanic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Lifeboats")</code></pre>


<h3>Format</h3>

<p>A data frame with 18 observations and 8 variables.
</p>

<dl>
<dt>launch</dt><dd><p>launch time in <code>"<a href="base.html#topic+POSIXt">POSIXt</a>"</code> format.</p>
</dd>
<dt>side</dt><dd><p>factor.  Side of the boat.</p>
</dd>
<dt>boat</dt><dd><p>factor indicating the boat.</p>
</dd>
<dt>crew</dt><dd><p>number of male crew members on board.</p>
</dd>
<dt>men</dt><dd><p>number of men on board.</p>
</dd>
<dt>women</dt><dd><p>number of women (including female crew) on board.</p>
</dd>
<dt>total</dt><dd><p>total number of passengers.</p>
</dd>
<dt>cap</dt><dd><p>capacity of the boat.</p>
</dd>
</dl>



<h3>Source</h3>

<p>M. Friendly (2000),
Visualizing Categorical Data:
<a href="http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/lifeboat.sas">http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/lifeboat.sas</a>
</p>


<h3>References</h3>

<p>L. Mersey (1912),
Report on the loss of the &ldquo;Titanic&rdquo; (S. S.).
Parliamentary command paper 6452.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Lifeboats")
attach(Lifeboats)
ternaryplot(
  Lifeboats[,4:6],
  pch = ifelse(side == "Port", 1, 19),
  col = ifelse(side == "Port", "red", "blue"),
  id  = ifelse(men / total &gt; 0.1, as.character(boat), NA),
  prop_size = 2,
  dimnames_position = "edge",
  main = "Lifeboats on the Titanic"
)
grid_legend(0.8, 0.9, c(1, 19), c("red", "blue"),
  c("Port", "Starboard"), title = "SIDE")
detach(Lifeboats)
</code></pre>

<hr>
<h2 id='lodds'>
Calculate Generalized Log Odds for Frequency Tables
</h2><span id='topic+lodds'></span><span id='topic+odds'></span><span id='topic+lodds.default'></span><span id='topic+lodds.formula'></span><span id='topic+coef.lodds'></span><span id='topic+confint.lodds'></span><span id='topic+dim.lodds'></span><span id='topic+dimnames.lodds'></span><span id='topic+print.lodds'></span><span id='topic+vcov.lodds'></span><span id='topic+as.matrix.lodds'></span><span id='topic+as.array.lodds'></span><span id='topic+aperm.lodds'></span><span id='topic+t.lodds'></span><span id='topic+as.data.frame.lodds'></span>

<h3>Description</h3>

<p>Computes (log) odds and their asymptotic variance covariance
matrix for R  (by strata) tables.
Odds are calculated for pairs of levels of one array dimension 
(typically a response or focal variable)
separately for each level of
all stratifying dimensions. See Friendly et al. (2011) for a sketch of a
general theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
lodds(x, ...)
## Default S3 method:
lodds(x, response = NULL, strata = NULL, log = TRUE, 
  ref = NULL, correct = any(x == 0), ...)

## S3 method for class 'formula'
lodds(formula, data = NULL, ...,
subset = NULL, na.action = NULL)

odds(x, log = FALSE, ...)

## S3 method for class 'lodds'
coef(object, log = object$log, ...)
## S3 method for class 'lodds'
vcov(object, log = object$log, ...)
## S3 method for class 'lodds'
print(x, log = x$log, ...)
## S3 method for class 'lodds'
confint(object, parm, level = 0.95, log = object$log, ...)

## S3 method for class 'lodds'
dim(x, ...)
## S3 method for class 'lodds'
dimnames(x, ...)
## S3 method for class 'lodds'
as.array(x, log=x$log, ...)
## S3 method for class 'lodds'
t(x)
## S3 method for class 'lodds'
aperm(a, perm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lodds_+3A_x">x</code></td>
<td>
<p>an object. For the default method a k-way matrix/table/array
of frequencies. The number of margins has to be at least 2.</p>
</td></tr>
<tr><td><code id="lodds_+3A_response">response</code></td>
<td>
<p>Numeric or character indicating the margin of a
$k$-way table <code>x</code> (with $k$ greater than 2) that should be employed
as the response variable. By default the first dimension is used.</p>
</td></tr>
<tr><td><code id="lodds_+3A_strata">strata</code></td>
<td>
<p>Numeric or character indicating the margins of a
$k$-way table <code>x</code> (with $k$ greater than 2) that should be employed
as strata. Ignored if <code>response</code> is specified.
By default all dimensions except the first are used as strata.</p>
</td></tr>
<tr><td><code id="lodds_+3A_ref">ref</code></td>
<td>
<p>numeric or character. Reference categories for the (non-stratum)
row and column dimensions that should be employed for computing the
odds. By default, odds for profile contrasts (or sequential
contrasts, i.e., successive differences of adjacent categories) are
used. See details below.</p>
</td></tr>
<tr><td><code id="lodds_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the variables used to create a 
contingency table from <code>data</code>. A conditioning
formula can be specified; the conditioning variables will then be
used as strata variables.</p>
</td></tr>
<tr><td><code id="lodds_+3A_data">data</code></td>
<td>
<p>either a data frame, or an object of class <code>"table"</code>
or <code>"ftable"</code>.</p>
</td></tr>
<tr><td><code id="lodds_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="lodds_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s. Ignored if <code>data</code> is a contingency table.</p>
</td></tr>
<tr><td><code id="lodds_+3A_log">log</code></td>
<td>
<p>logical. Should the results be displayed on a log scale
or not? All internal computations are always on the log-scale but the
results are transformed by default if <code>log = TRUE</code>.</p>
</td></tr>
<tr><td><code id="lodds_+3A_correct">correct</code></td>
<td>
<p>logical or numeric. Should a continuity correction
be applied before computing odds?
If <code>TRUE</code>, 0.5 is  added to  all cells; if numeric (or an
array conforming to the data) that value is added to all cells.  By default,
this not  employed unless there are any zero cells in  the table, but this
correction is often recommended to reduce bias when some frequencies are small
(Fleiss, 1981).</p>
</td></tr>
<tr><td><code id="lodds_+3A_a">a</code>, <code id="lodds_+3A_object">object</code></td>
<td>
<p>an object of class <code>lodds</code> as computed by
<code>lodds</code>.</p>
</td></tr>
<tr><td><code id="lodds_+3A_perm">perm</code></td>
<td>
<p>numeric or character vector specifying a permutation of strata.</p>
</td></tr>
<tr><td><code id="lodds_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
<tr><td><code id="lodds_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, 
either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="lodds_+3A_level">level</code></td>
<td>
<p>the confidence level required for the <code>confint</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an n-way table with the <code>response</code> variable containing R levels, 
(log) odds are formed (by default) for the set of (R-1) 
contrasts among the response levels.
The <code>ref</code> argument allows these to be specified in a general
way.
</p>
<p><code>ref = NULL</code> (default) corresponds to &ldquo;profile contrasts&rdquo; 
(or sequential contrasts or successive differences) for ordered categories,
i.e., R1&ndash;R2, R2&ndash;R3, R3&ndash;R4, etc., and similarly for the column categories.
These are sometimes called &ldquo;local odds&rdquo; or &ldquo;adjacent odds&rdquo;.
</p>
<p><code>ref = 1</code> gives contrasts with the first category; <code>ref = dim(x)</code>
gives contrasts with the last category.
</p>
<p>Note that all such parameterizations are equivalent, in that one can derive all
other possible odds from any non-redundant set, but the interpretation
of these values depends on the parameterization.
</p>
<p>See the help page of <code><a href="#topic+plot.loddsratio">plot.loddsratio</a></code> for related visualization methods.
There is as yet no plot method for <code>lodds</code> objects.
</p>


<h3>Value</h3>

<p>An object of class <code>lodds</code>, with the following components: 
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>A named vector, of length (R-1) x (C-1) x <code>prod(dim(x)[strata])</code>
containing the log odds. Use the <code>coef</code> method to 
extract these from the object, and the <code>confint</code> method for confidence intervals.
For a two-way table, the names for the log oddsare constructed in the form
Ri:Rj using the table names for rows and columns. For a stratified table,
the names are constructed in the form Ri:Rj|Lk.
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>Variance covariance matrix of the log odds.</p>
</td></tr>
<tr><td><code>dimnames</code></td>
<td>
<p>Dimension names for the log odds, considered as a table of
size (R-1, C-1, <code>dim(x)[strata]</code>). Use the <code>dim</code> and <code>dimnames</code> methods
to extract these and manipulate the log odds in relation to the original table.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>Corresponding dimension vector.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>A matrix C, such that <code>C %*% as.vector(log(x))</code> gives the log odds
ratios. Each row corresponds to one log odds, and is all zero, except for 2 elements
of <code>c(1, -1)</code> for a given 2 x 1 subtable.</p>
</td></tr>
<tr><td><code>log</code></td>
<td>
<p>A logical, indicating the value of <code>log</code> in the original call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The method of calculation is an example of the use of the delta method
described by Agresti (2013), Section 16.1.6, giving estimates of
log odds ratios and their asymptotic covariance matrix.
</p>
<p>The <code>coef</code> method returns the <code>coefficients</code> component as a vector
of length (R-1) x  <code>prod(dim(x)[strata])</code>.
The <code>dim</code> and <code>dimnames</code> methods provide the proper attributes for
treating the <code>coefficients</code> vector as an (R-1) x  strata array.
<code>as.matrix</code> and <code>as.array</code> methods are also provided for this purpose.
</p>
<p>The <code>confint</code> method computes confidence intervals for the log odds
(or for odds, with <code>log = FALSE</code>).
The <code><a href="lmtest.html#topic+coeftest">coeftest</a></code> method (<code>summary</code> is an alias)
prints the asymptotic standard errors, z tests (standardized log odds), and the corresponding p values.
</p>
<p><em>Structural zeros</em>: In addition to the options for zero cells provided by <code>correct</code>,
the function allows for structural zeros to be represented as <code>NA</code> in the data argument.
<code>NA</code> in the data yields <code>NA</code> as the <code>LOR</code> estimate, but does not affect other
cells.
</p>
<p><code>odds</code> is just an alias to <code>lodds</code> with the default <code>log=FALSE</code> for
convenience.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis, Michael Friendly and David Meyer.
</p>


<h3>References</h3>

<p>A. Agresti (2013), <em>Categorical Data Analysis</em>, 3rd Ed. New York: Wiley.
</p>
<p>Fleiss, J. L. (1981). <em>Statistical Methods for Rates and Proportions</em>.
2nd Edition. New York: Wiley.
</p>
<p>M. Friendly (2000), <em>Visualizing Categorical Data</em>. SAS Institute, Cary, NC.
</p>
<p>Friendly, M., Turner, H,, Firth, D., Zeileis, A. (2011).
<em>Advances in Visualizing Categorical Data Using the vcd, gnm and vcdExtra Packages in R</em>.
Correspondence Analysis and Related Methods (CARME 2011).
<a href="http://www.datavis.ca/papers/adv-vcd-4up.pdf">http://www.datavis.ca/papers/adv-vcd-4up.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loddsratio">loddsratio</a></code> for log odds <em>ratios</em>;
<code><a href="stats.html#topic+confint">confint</a></code> for confidence intervals;
<code><a href="lmtest.html#topic+coeftest">coeftest</a></code> for z-tests of significance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## artificial example
set.seed(1)
x &lt;- matrix(rpois(5 * 3, 7), ncol = 5, nrow = 3)
dimnames(x) &lt;- list(Row = head(letters, 3), Col = tail(letters, 5))

x_lodds &lt;- lodds(x)
coef(x_lodds)
x_lodds
confint(x_lodds)
summary(x_lodds)

### 2 x 2 x k cases
##data(CoalMiners, package = "vcd")
#lor_CM &lt;- loddsratio(CoalMiners)
#lor_CM
#coef(lor_CM)
#confint(lor_CM)
#confint(lor_CM, log = FALSE)
#
### 2 x k x 2
#lor_Emp &lt;-loddsratio(Employment)
#lor_Emp
#confint(lor_Emp)
#
### 4 way tables 
#data(Punishment, package = "vcd")
#lor_pun &lt;- loddsratio(Freq ~ memory + attitude | age + education, data = Punishment)
#lor_pun
#confint(lor_pun)
#summary(lor_pun)
#
## fit linear model using WLS
#lor_pun_df &lt;- as.data.frame(lor_pun)
#pun_mod1 &lt;- lm(LOR ~ as.numeric(age) * as.numeric(education),
#               data = lor_pun_df, weights = 1 / ASE^2)
#anova(pun_mod1)
#
### illustrate ref levels
#VA.fem &lt;- xtabs(Freq ~ left + right, subset=gender=="female", data=VisualAcuity)
#VA.fem
#loddsratio(VA.fem)                  # profile contrasts
#loddsratio(VA.fem, ref=1)           # contrasts against level 1
#loddsratio(VA.fem, ref=dim(VA.fem)) # contrasts against level 4
#

</code></pre>

<hr>
<h2 id='loddsratio'>
Calculate Generalized Log Odds Ratios for Frequency Tables
</h2><span id='topic+loddsratio'></span><span id='topic+oddsratio'></span><span id='topic+loddsratio.default'></span><span id='topic+loddsratio.formula'></span><span id='topic+coef.loddsratio'></span><span id='topic+confint.loddsratio'></span><span id='topic+dim.loddsratio'></span><span id='topic+dimnames.loddsratio'></span><span id='topic+print.loddsratio'></span><span id='topic+vcov.loddsratio'></span><span id='topic+as.matrix.loddsratio'></span><span id='topic+as.array.loddsratio'></span><span id='topic+aperm.loddsratio'></span><span id='topic+t.loddsratio'></span><span id='topic+as.data.frame.loddsratio'></span>

<h3>Description</h3>

<p>Computes (log) odds ratios and their asymptotic variance covariance
matrix for R x C (x strata) tables.
Odds ratios are calculated for two array dimensions, separately for each level of
all stratifying dimensions. See Friendly et al. (2011) for a sketch of a
general theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
loddsratio(x, ...)
## Default S3 method:
loddsratio(x, strata = NULL, log = TRUE, 
  ref = NULL, correct = any(x == 0L), ...)

## S3 method for class 'formula'
loddsratio(formula, data = NULL, ...,
subset = NULL, na.action = NULL)

oddsratio(x, stratum = NULL, log = TRUE)

## S3 method for class 'loddsratio'
coef(object, log = object$log, ...)
## S3 method for class 'loddsratio'
vcov(object, log = object$log, ...)
## S3 method for class 'loddsratio'
print(x, log = x$log, ...)
## S3 method for class 'loddsratio'
confint(object, parm, level = 0.95, log = object$log, ...)

## S3 method for class 'loddsratio'
as.array(x, log=x$log, ...)
## S3 method for class 'loddsratio'
t(x)
## S3 method for class 'loddsratio'
aperm(a, perm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loddsratio_+3A_x">x</code></td>
<td>
<p>an object. For the default method a k-way matrix/table/array
of frequencies. The number of margins has to be at least 2.</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_strata">strata</code>, <code id="loddsratio_+3A_stratum">stratum</code></td>
<td>
<p>Numeric or character indicating the margins of a
$k$-way table <code>x</code> (with $k$ greater than 2) that should be employed
as strata. By default all dimensions except the first two are used.</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_ref">ref</code></td>
<td>
<p>numeric or character. Reference categories for the (non-stratum)
row and column dimensions that should be employed for computing the
odds ratios. By default, odds ratios for profile contrasts (or sequential
contrasts, i.e., successive differences of adjacent categories) are
used. See details below.</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the variables used to create a 
contingency table from <code>data</code>. A conditioning
formula can be specified; the conditioning variables will then be
used as strata variables.</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_data">data</code></td>
<td>
<p>either a data frame, or an object of class <code>"table"</code>
or <code>"ftable"</code>.</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s. Ignored if <code>data</code> is a contingency table.</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_log">log</code></td>
<td>
<p>logical. Should the results be displayed on a log scale
or not? All internal computations are always on the log-scale but the
results are transformed by default if <code>log = TRUE</code>.</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_correct">correct</code></td>
<td>
<p>logical or numeric. Should a continuity correction
be applied before computing odds ratios?
If <code>TRUE</code>, 0.5 is  added to  all cells; if numeric (or an
array conforming to the data) that value is added to all cells.  By default,
this not  employed unless there are any zero cells in  the table, but this
correction is often recommended to reduce bias when some frequencies are small
(Fleiss, 1981).</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_a">a</code>, <code id="loddsratio_+3A_object">object</code></td>
<td>
<p>an object of class <code>loddsratio</code> as computed by
<code>loddsratio</code>.</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_perm">perm</code></td>
<td>
<p>numeric or character vector specifying a permutation of strata.</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, 
either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="loddsratio_+3A_level">level</code></td>
<td>
<p>the confidence level required for the <code>confint</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an R x C table, (log) odds ratios are formed for the set of (R-1) x (C-1)
2 x 2 tables, corresponding to some set of contrasts among the row and column
variables.  The <code>ref</code> argument allows these to be specified in a general
way.
</p>
<p><code>ref = NULL</code> (default) corresponds to &ldquo;profile contrasts&rdquo; 
(or sequential contrasts or successive differences) for ordered categories,
i.e., R1&ndash;R2, R2&ndash;R3, R3&ndash;R4, etc., and similarly for the column categories.
These are sometimes called &ldquo;local odds ratios&rdquo;.
</p>
<p><code>ref = 1</code> gives contrasts with the first category; <code>ref = dim(x)</code>
gives contrasts with the last category; <code>ref = c(2, 4)</code> or <code>ref = list(2, 4)</code>
corresponds to the reference being the second category in rows and
the fourth in columns.
</p>
<p>Combinations like <code>ref = list(NULL, 3)</code> are also possible, as are character
vectors, e.g., <code>ref = c("foo", "bar")</code> also works (&quot;foo&quot; pertaining again to the
row reference and &quot;bar&quot; to column reference).
</p>
<p>Note that all such parameterizations are equivalent, in that one can derive all
other possible odds ratios from any non-redundant set, but the interpretation
of these values depends on the parameterization.
</p>
<p>Note also that these reference level parameterizations only have meaning when the
primary (non-strata) table dimensions are larger than 2x2.  In the 2x2 case,
the odds ratios are defined by the order of levels of those variables in the table,
so you can achieve a desired interpretation by manipulating the table.
</p>
<p>See the help page of <code><a href="#topic+plot.loddsratio">plot.loddsratio</a></code> for visualization methods.
</p>


<h3>Value</h3>

<p>An object of class <code>loddsratio</code>, with the following components: 
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>A named vector, of length (R-1) x (C-1) x <code>prod(dim(x)[strata])</code>
containing the log odds ratios. Use the <code>coef</code> method to 
extract these from the object, and the <code>confint</code> method for confidence intervals.
For a two-way table, the names for the log odds ratios are constructed in the form
Ri:Rj/Ci:Cj using the table names for rows and columns. For a stratified table,
the names are constructed in the form Ri:Rj/Ci:Cj|Lk.
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>Variance covariance matrix of the log odds ratios.</p>
</td></tr>
<tr><td><code>dimnames</code></td>
<td>
<p>Dimension names for the log odds ratios, considered as a table of
size (R-1, C-1, <code>dim(x)[strata]</code>). Use the <code>dim</code> and <code>dimnames</code> methods
to extract these and manipulate the log odds ratios in relation to the original table.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>Corresponding dimension vector.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>A matrix C, such that <code>C %*% as.vector(log(x))</code> gives the log odds
ratios. Each row corresponds to one log odds ratio, and is all zero, except for 4 elements
of <code>c(1, -1, -1, 1)</code> for a given 2 x 2 subtable.</p>
</td></tr>
<tr><td><code>log</code></td>
<td>
<p>A logical, indicating the value of <code>log</code> in the original call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The method of calculation is an example of the use of the delta method
described by Agresti (2013), Section 16.1.6, giving estimates of
log odds ratios and their asymptotic covariance matrix.
</p>
<p>The <code>coef</code> method returns the <code>coefficients</code> component as a vector
of length (R-1) x (C-1) x <code>prod(dim(x)[strata])</code>.
The <code>dim</code> and <code>dimnames</code> methods provide the proper attributes for
treating the <code>coefficients</code> vector as an (R-1) x (C-1) x strata array.
<code>as.matrix</code> and <code>as.array</code> methods are also provided for this purpose.
</p>
<p>The <code>confint</code> method computes confidence intervals for the log odds ratios
(or for odds ratios, with <code>log = FALSE</code>).
The <code><a href="lmtest.html#topic+coeftest">coeftest</a></code> method (<code>summary</code> is an alias)
prints the asymptotic standard errors, z tests (standardized log odds
ratios), and the corresponding p values.
</p>
<p><em>Structural zeros</em>: In addition to the options for zero cells provided by <code>correct</code>,
the function allows for structural zeros to be represented as <code>NA</code> in the data argument.
<code>NA</code> in the data yields <code>NA</code> as the <code>LOR</code> estimate, but does not affect other
cells.
</p>
<p><code>oddsratio</code> is just an alias to <code>loddsratio</code> for backward
compatibility.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis, Michael Friendly and David Meyer.
</p>


<h3>References</h3>

<p>A. Agresti (2013), <em>Categorical Data Analysis</em>, 3rd Ed. New York: Wiley.
</p>
<p>Fleiss, J. L. (1981). <em>Statistical Methods for Rates and Proportions</em>.
2nd Edition. New York: Wiley.
</p>
<p>M. Friendly (2000), <em>Visualizing Categorical Data</em>. SAS Institute, Cary, NC.
</p>
<p>Friendly, M., Turner, H,, Firth, D., Zeileis, A. (2011).
<em>Advances in Visualizing Categorical Data Using the vcd, gnm and vcdExtra Packages in R</em>.
Correspondence Analysis and Related Methods (CARME 2011).
<a href="http://www.datavis.ca/papers/adv-vcd-4up.pdf">http://www.datavis.ca/papers/adv-vcd-4up.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.loddsratio">plot.loddsratio</a></code> for some plotting methods;
<code><a href="stats.html#topic+confint">confint</a></code> for confidence intervals;
<code><a href="lmtest.html#topic+coeftest">coeftest</a></code> for z-tests of significance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## artificial example
set.seed(1)
x &lt;- matrix(rpois(5 * 3, 7), ncol = 5, nrow = 3)
dimnames(x) &lt;- list(Row = head(letters, 3), Col = tail(letters, 5))

x_lor &lt;- loddsratio(x)
coef(x_lor)
x_lor
confint(x_lor)
summary(x_lor)

## 2 x 2 x k cases
#data(CoalMiners, package = "vcd")
lor_CM &lt;- loddsratio(CoalMiners)
lor_CM
coef(lor_CM)
confint(lor_CM)
confint(lor_CM, log = FALSE)

## 2 x k x 2
lor_Emp &lt;-loddsratio(Employment)
lor_Emp
confint(lor_Emp)

## 4 way tables 
data(Punishment, package = "vcd")
lor_pun &lt;- loddsratio(Freq ~ memory + attitude | age + education, data = Punishment)
lor_pun
confint(lor_pun)
summary(lor_pun)

# fit linear model using WLS
lor_pun_df &lt;- as.data.frame(lor_pun)
pun_mod1 &lt;- lm(LOR ~ as.numeric(age) * as.numeric(education),
               data = lor_pun_df, weights = 1 / ASE^2)
anova(pun_mod1)

## illustrate ref levels
VA.fem &lt;- xtabs(Freq ~ left + right, subset=gender=="female", data=VisualAcuity)
VA.fem
loddsratio(VA.fem)                  # profile contrasts
loddsratio(VA.fem, ref=1)           # contrasts against level 1
loddsratio(VA.fem, ref=dim(VA.fem)) # contrasts against level 4


</code></pre>

<hr>
<h2 id='mar_table'>Table with Marginal Sums</h2><span id='topic+mar_table'></span>

<h3>Description</h3>

<p>Adds row and column sums to a two-way table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mar_table(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mar_table_+3A_x">x</code></td>
<td>
<p>a two-way table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with row and column totals added.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SexualFun")
mar_table(SexualFun)
</code></pre>

<hr>
<h2 id='mosaic'>Extended Mosaic Plots</h2><span id='topic+mosaic'></span><span id='topic+mosaic.default'></span><span id='topic+mosaic.formula'></span>

<h3>Description</h3>

<p>Plots (extended) mosaic displays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
mosaic(x, condvars = NULL,
  split_vertical = NULL, direction = NULL, spacing = NULL,
  spacing_args = list(), gp = NULL, expected = NULL, shade = NULL,
  highlighting = NULL, highlighting_fill = rev(gray.colors(tail(dim(x), 1))),
  highlighting_direction = NULL,
  zero_size = 0.5, zero_split = FALSE, zero_shade = NULL,
  zero_gp = gpar(col = 0), panel = NULL, main = NULL, sub = NULL, ...)
## S3 method for class 'formula'
mosaic(formula, data, highlighting = NULL,
  ..., main = NULL, sub = NULL, subset = NULL, na.action = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosaic_+3A_x">x</code></td>
<td>
<p>a contingency table in array form, with optional category
labels specified in the <code>dimnames(x)</code> attribute, or an object
of class <code>"structable"</code>.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_condvars">condvars</code></td>
<td>
<p>vector of integers or character strings indicating
conditioning variables, if any. The table will be permuted to order
them first.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the variables used to create a 
contingency table from <code>data</code>.  For convenience, conditioning
formulas can be specified; the conditioning variables will then be
used first for splitting. If any, a specified response variable will be
highlighted in the cells.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_data">data</code></td>
<td>
<p>either a data frame, or an object of class <code>"table"</code>
or <code>"ftable"</code>.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s. Ignored if <code>data</code> is a contingency table.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_zero_size">zero_size</code></td>
<td>
<p>size of the bullets used for zero entries (if 0, no
bullets are drawn).</p>
</td></tr>
<tr><td><code id="mosaic_+3A_zero_split">zero_split</code></td>
<td>
<p>logical controlling whether zero cells should be
further split. If <code>FALSE</code> and <code>zero_shade</code> is
<code>FALSE</code>, only one bullet is drawn (centered) for unsplit
zero cells. If <code>FALSE</code> and <code>zero_shade</code> is
<code>TRUE</code>, a bullet for each zero cell is drawn to allow, e.g.,
residual-based shadings to be effective also for zero cells.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_zero_shade">zero_shade</code></td>
<td>
<p>logical controlling whether zero bullets should be
shaded. The default is <code>TRUE</code> if <code>shade</code> is <code>TRUE</code>
or <code>expected</code> is not null or <code>gp</code> is not null, and
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_zero_gp">zero_gp</code></td>
<td>
<p>object of class <code>"gpar"</code> used
for zero bullets in case they are <em>not</em> shaded.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_split_vertical">split_vertical</code></td>
<td>
<p>vector of logicals of length <code class="reqn">k</code>, where <code class="reqn">k</code>
is the number of margins of <code>x</code> (default: <code>FALSE</code>).
Values are recycled as needed. 
A <code>TRUE</code> component indicates that the tile(s) of the
corresponding dimension should be split vertically, <code>FALSE</code>
means horizontal splits. Ignored if <code>direction</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_direction">direction</code></td>
<td>
<p>character vector of length <code class="reqn">k</code>, where <code class="reqn">k</code> is the
number of margins of <code>x</code> (values are recycled as needed).
For each component, a value of <code>"h"</code> indicates that the tile(s)
of the corresponding dimension should be split horizontally, whereas
<code>"v"</code> indicates vertical split(s).</p>
</td></tr>
<tr><td><code id="mosaic_+3A_spacing">spacing</code></td>
<td>
<p>spacing object, spacing function, or corresponding
generating function (see <code><a href="#topic+strucplot">strucplot</a></code> for more
information).
The default is <code>spacing_equal</code> if <code>x</code> has two dimensions,
<code>spacing_increase</code> for more dimensions, and
<code>spacing_conditional</code> if conditioning variables are specified
using <code>condvars</code> or the formula interface.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_spacing_args">spacing_args</code></td>
<td>
<p>list of arguments for the generating function, if
specified (see <code><a href="#topic+strucplot">strucplot</a></code> for more information).</p>
</td></tr>
<tr><td><code id="mosaic_+3A_gp">gp</code></td>
<td>
<p>object of class <code>"gpar"</code>, shading function or a
corresponding generating function (see details and
<code><a href="#topic+shadings">shadings</a></code>). Components of <code>"gpar"</code>
objects are recycled as needed along the last splitting dimension.
Ignored if <code>shade = FALSE</code>.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_shade">shade</code></td>
<td>
<p>logical specifying whether <code>gp</code> should be used or not
(see <code>gp</code>). If <code>TRUE</code> and <code>expected</code> is unspecified,
a default model is fitted: if <code>condvars</code> (see
<code><a href="#topic+strucplot">strucplot</a></code>) is specified, a
corresponding conditional independence model, and else the total
independence model.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_expected">expected</code></td>
<td>
<p>optionally, an array of expected values of the same dimension
as <code>x</code>, or alternatively the corresponding independence model specification
as used by <code><a href="stats.html#topic+loglin">loglin</a></code> or <code><a href="MASS.html#topic+loglm">loglm</a></code>
(see <code><a href="#topic+strucplot">strucplot</a></code>).</p>
</td></tr>
<tr><td><code id="mosaic_+3A_highlighting">highlighting</code></td>
<td>
<p>character vector or integer specifying a variable
to be highlighted in the cells.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_highlighting_fill">highlighting_fill</code></td>
<td>
<p>color vector or palette function
used for a highlighted variable, if any.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_highlighting_direction">highlighting_direction</code></td>
<td>
<p>Either <code>"left"</code>, <code>"right"</code>,
<code>"top"</code>, or <code>"bottom"</code> specifying the direction of
highlighting in the cells.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_panel">panel</code></td>
<td>
<p>Optional function with arguments: <code>residuals</code>,
<code>observed</code>, <code>expected</code>, <code>index</code>, <code>gp</code>, and
<code>name</code> called by the
<code>struc_mosaic</code> workhorse for each tile that is drawn in the
mosaic. <code>index</code> is an integer vector with the tile's
coordinates in the contingency table, <code>gp</code> a <code>gpar</code> object
for the tile, and <code>name</code> a label to be assigned to the drawn
grid object.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_main">main</code>, <code id="mosaic_+3A_sub">sub</code></td>
<td>
<p>either a logical, or a character string used for plotting
the main (sub) title.  If logical and <code>TRUE</code>, the
name of the <code>data</code> object is used.</p>
</td></tr>
<tr><td><code id="mosaic_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+strucplot">strucplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mosaic displays have been suggested in the statistical literature
by Hartigan and Kleiner (1984) and have been extended by Friendly
(1994). <code><a href="graphics.html#topic+mosaicplot">mosaicplot</a></code> is a base graphics
implementation and <code>mosaic</code> is a much more flexible and extensible
grid implementation.
</p>
<p><code>mosaic</code> is a generic function which currently has a default method and a
formula interface.  Both are high-level interfaces to the
<code><a href="#topic+strucplot">strucplot</a></code> function, and produce (extended) mosaic
displays.  Most of the functionality is described there, such as
specification of the independence model, labeling, legend, spacing,
shading, and other graphical parameters.
</p>
<p>A mosaic plot is an area proportional visualization of a (possibly
higher-dimensional) table of expected frequencies.  It is composed of
tiles (corresponding to the cells) created by recursive vertical and
horizontal splits of a square.  The area of each tile is proportional
to the corresponding cell entry, <em>given</em> the dimensions of
previous splits.
</p>
<p>An <em>extended</em> mosaic plot, in addition, visualizes the fit of a
particular log-linear model. Typically, this is done by residual-based
shadings where color and/or outline of the tiles visualize sign, size
and possibly significance of the corresponding residual.
</p>
<p>The layout is very flexible: the specification of shading, labeling,
spacing, and legend is modularized (see <code><a href="#topic+strucplot">strucplot</a></code> for
details).
</p>
<p>In contrast to the <code><a href="graphics.html#topic+mosaicplot">mosaicplot</a></code> function in
<span class="pkg">graphics</span>, the splits start with the <em>horizontal</em> direction
by default to match the printed output of <code><a href="#topic+structable">structable</a></code>.
</p>


<h3>Value</h3>

<p>The <code>"structable"</code> visualized is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Hartigan, J.A., and Kleiner, B. (1984),
A mosaic of television ratings.
<em>The American Statistician</em>,
<b>38</b>, 32&ndash;35.
</p>
<p>Emerson, J. W. (1998),
Mosaic displays in S-PLUS: A general implementation and a case study.
<em>Statistical Computing and Graphics Newsletter (ASA)</em>,
<b>9</b>, 1, 17&ndash;23.
</p>
<p>Friendly, M. (1994),
Mosaic displays for multi-way contingency tables.
<em>Journal of the American Statistical Association</em>, <b>89</b>,
190&ndash;200.
</p>
<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot", package = "vcd")</code>.
</p>
<p>The home page of Michael Friendly
(<a href="http://datavis.ca">http://datavis.ca</a>) provides
information on various aspects of graphical methods for analyzing
categorical data, including mosaic plots. In particular, there are
many materials for his course &ldquo;Visualizing Categorical Data with SAS and R&rdquo;
at <a href="http://datavis.ca/courses/VCD/">http://datavis.ca/courses/VCD/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assoc">assoc</a></code>,
<code><a href="#topic+strucplot">strucplot</a></code>,
<code><a href="graphics.html#topic+mosaicplot">mosaicplot</a></code>,
<code><a href="#topic+structable">structable</a></code>,
<code><a href="#topic+doubledecker">doubledecker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
data("Titanic")
mosaic(Titanic)

## Formula interface for tabulated data plus shading and legend:
mosaic(~ Sex + Age + Survived, data = Titanic,
  main = "Survival on the Titanic", shade = TRUE, legend = TRUE)

data("HairEyeColor")
mosaic(HairEyeColor, shade = TRUE)
## Independence model of hair and eye color and sex.  Indicates that
## there are significantly more blue eyed blond females than expected
## in the case of independence (and too few brown eyed blond females).

mosaic(HairEyeColor, shade = TRUE, expected = list(c(1,2), 3))
## Model of joint independence of sex from hair and eye color.  Males
## are underrepresented among people with brown hair and eyes, and are
## overrepresented among people with brown hair and blue eyes, but not
## "significantly".

## Formula interface for raw data: visualize crosstabulation of numbers
## of gears and carburettors in Motor Trend car data.
data("mtcars")
mosaic(~ gear + carb, data = mtcars, shade = TRUE)

data("PreSex")
mosaic(PreSex, condvars = c(1,4))
mosaic(~ ExtramaritalSex + PremaritalSex | MaritalStatus + Gender,
       data = PreSex)

## Highlighting:
mosaic(Survived ~ ., data = Titanic)

data("Arthritis")
mosaic(Improved ~ Treatment | Sex, data = Arthritis, zero_size = 0)
mosaic(Improved ~ Treatment | Sex, data = Arthritis, zero_size = 0,
       highlighting_direction = "right")
</code></pre>

<hr>
<h2 id='mplot'>Multiple Grid plots</h2><span id='topic+mplot'></span>

<h3>Description</h3>

<p>combines severals grid-based plots in a multi-panel-layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mplot(..., .list = list(),
      layout = NULL, cex = NULL,
      main = NULL, gp_main = gpar(fontsize = 20),
      sub = NULL, gp_sub = gpar(fontsize = 15),
      keep_aspect_ratio = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mplot_+3A_...">...</code>, <code id="mplot_+3A_.list">.list</code></td>
<td>
<p>A list of objects inheriting from class <code>"grob"</code>,
or having a <code>"grob"</code> attribute containing such an object.</p>
</td></tr>
<tr><td><code id="mplot_+3A_layout">layout</code></td>
<td>
<p>integer vector of length 2 giving the number of rows and
columns. If <code>NULL</code>, the values will be
guessed using some heuristics from the number of objects supplied in
....</p>
</td></tr>
<tr><td><code id="mplot_+3A_cex">cex</code></td>
<td>
<p>Scaling factor for the fonts in the subplots. If
<code>NULL</code>, the value is calculated as the inverse square root of
the row number.</p>
</td></tr>
<tr><td><code id="mplot_+3A_main">main</code>, <code id="mplot_+3A_sub">sub</code></td>
<td>
<p>Optional main and sub title, respectively.</p>
</td></tr>
<tr><td><code id="mplot_+3A_gp_main">gp_main</code>, <code id="mplot_+3A_gp_sub">gp_sub</code></td>
<td>
<p>Optional objects of class <code>"gpar"</code> specifying
the graphical parameters for the main and sub title, respectively.</p>
</td></tr>
<tr><td><code id="mplot_+3A_keep_aspect_ratio">keep_aspect_ratio</code></td>
<td>
<p>logical; should the aspect ratio of the plots
be fixed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function for producing multi-panel plots from
grid-based displays, especially those produced by the vcd methods. The
layout (number of rows and columns) is guessed from the amount of
supplied objects, if not supplied. Currently, the vcd plotting
functions do not return grob objects by default&mdash;this might change in
the future. Also, some of them will return the grob object as a
<code>"grob"</code> attribute, attached to the currently returned object.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mplot(mosaic(Titanic, return_grob = TRUE),
      assoc(Titanic), return_grob = TRUE)

A = mosaic(Titanic, return_grob = TRUE)
B = mosaic(Titanic, type = "expected", return_grob = TRUE)
mplot(A, B)

mplot(sieve(SexualFun, return_grob = TRUE),
      agreementplot(SexualFun, return_grob = TRUE),
      main = "Sexual Fun")

mplot(A, grid.circle())
</code></pre>

<hr>
<h2 id='MSPatients'>Diagnosis of Multiple Sclerosis</h2><span id='topic+MSPatients'></span>

<h3>Description</h3>

<p>Data from Westlund &amp; Kurland (1953) on the diagnosis of multiple
sclerosis (MS): two samples of patients, one from Winnipeg and one
from New Orleans, were each rated by two neurologists (one from each
city) in four diagnostic categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("MSPatients")
</code></pre>


<h3>Format</h3>

<p>A 3-dimensional array resulting from cross-tabulating 218 observations
on 3 variables.  The variables and their levels are as follows:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> New Orleans Neurologist </td><td style="text-align: left;"> Certain, Probable, Possible, Doubtful </td>
</tr>
<tr>
 <td style="text-align: right;">
    2 </td><td style="text-align: left;"> Winnipeg Neurologist </td><td style="text-align: left;"> Certain, Probable, Possible, Doubtful </td>
</tr>
<tr>
 <td style="text-align: right;">
    3 </td><td style="text-align: left;"> Patients </td><td style="text-align: left;"> Winnipeg, New Orleans
  </td>
</tr>

</table>



<h3>Source</h3>

<p>M. Friendly (2000),
Visualizing Categorical Data:
<a href="http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/msdiag.sas">http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/msdiag.sas</a>
</p>


<h3>References</h3>

<p>K. B. Westlund &amp; L. T. Kurland (1953),
Studies on multiple sclerosis in Winnipeg, Manitoba and New Orleans,
Louisiana,
<em>American Journal of Hygiene</em>, <b>57</b>, 380&ndash;396.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("MSPatients")
## Not run: 
## best visualized using a resized device, e.g. using:
## get(getOption("device"))(width = 12)
pushViewport(viewport(layout = grid.layout(ncol = 2)))
pushViewport(viewport(layout.pos.col = 1))
popViewport()
pushViewport(viewport(layout.pos.col = 2))
popViewport(2)
dev.off()

## End(Not run)

## alternative, more convenient way
mplot(
  agreementplot(t(MSPatients[,,1]), return_grob = TRUE,
    main = "Winnipeg Patients"),
  agreementplot(t(MSPatients[,,2]), return_grob = TRUE,
    main = "New Orleans Patients")
)

## alternatively, use cotabplot:
cotabplot(MSPatients, panel = cotab_agreementplot)
</code></pre>

<hr>
<h2 id='NonResponse'>Non-Response Survey Data</h2><span id='topic+NonResponse'></span>

<h3>Description</h3>

<p>Data about non-response for a Danish survey in 1965.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("NonResponse")
</code></pre>


<h3>Format</h3>

<p>A data frame with 12 observations and 4 variables.
</p>

<dl>
<dt>Freq</dt><dd><p>frequency.</p>
</dd>
<dt>residence</dt><dd><p>factor indicating whether residence was in
Copenhagen, in a city outside Copenhagen or at the countryside
(Copenhagen, City, Country).</p>
</dd>
<dt>response</dt><dd><p>factor indicating whether a response was given (yes,
no).</p>
</dd>
<dt>gender</dt><dd><p>factor indicating gender (male, female).</p>
</dd>
</dl>



<h3>Source</h3>

<p>E. B. Andersen (1991),
The Statistical Analysis of Categorical Data, Table 5.17.
</p>


<h3>References</h3>

<p>E. B. Andersen (1991),
<em>The Statistical Analysis of Categorical Data</em>.
2nd edition.
Springer-Verlag, Berlin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("NonResponse")
structable(~ ., data = NonResponse)
</code></pre>

<hr>
<h2 id='Ord_plot'>Ord Plots</h2><span id='topic+Ord_plot'></span><span id='topic+Ord_estimate'></span>

<h3>Description</h3>

<p>Ord plots for diagnosing discrete distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ord_plot(obj, legend = TRUE, estimate = TRUE, tol = 0.1, type = NULL,
  xlim = NULL, ylim = NULL, xlab = "Number of occurrences",
  ylab = "Frequency ratio", main = "Ord plot", gp = gpar(cex = 0.5),
  lwd = c(2,2), lty=c(2,1), col=c("black", "red"),
  name = "Ord_plot", newpage = TRUE, pop = TRUE,
  return_grob = FALSE, ...)
Ord_estimate(x, type = NULL, tol = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ord_plot_+3A_obj">obj</code></td>
<td>
<p>either a vector of counts, a 1-way table of frequencies
of counts or a data frame or matrix with frequencies
in the first column and the corresponding counts in the
second column.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_legend">legend</code></td>
<td>
<p>logical. Should a legend be plotted?.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_estimate">estimate</code></td>
<td>
<p>logical. Should the distribution and its parameters
be estimated from the data? See details.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_tol">tol</code></td>
<td>
<p>tolerance for estimating the distribution. See details.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_type">type</code></td>
<td>
<p>a character string indicating the distribution, must be
one of <code>"poisson"</code>, <code>"binomial"</code>, <code>"nbinomial"</code>
or <code>"log-series"</code> or <code>NULL</code>. In the latter case the
distribution is estimated from the data. See details.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_xlim">xlim</code></td>
<td>
<p>limits for the x axis.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y axis.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_main">main</code></td>
<td>
<p>a title for the plot.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_gp">gp</code></td>
<td>
<p>a <code>"gpar"</code> object controlling the grid graphical
parameters of the points.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_lwd">lwd</code>, <code id="Ord_plot_+3A_lty">lty</code></td>
<td>
<p>vectors of length 2, giving the line width and line type
used for drawing the OLS line and the WLS lines.</p>
</td></tr> 
<tr><td><code id="Ord_plot_+3A_col">col</code></td>
<td>
<p>vector of length 2 giving the colors used for drawing the OLS
and WLS lines.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_name">name</code></td>
<td>
<p>name of the plotting viewport.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_newpage">newpage</code></td>
<td>
<p>logical. Should <code><a href="grid.html#topic+grid.newpage">grid.newpage</a></code> be called 
before plotting?</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_pop">pop</code></td>
<td>
<p>logical. Should the viewport created be popped?</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_return_grob">return_grob</code></td>
<td>
<p>logical. Should a snapshot of the display be
returned as a grid grob?</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="grid.html#topic+grid.points">grid.points</a></code>.</p>
</td></tr>
<tr><td><code id="Ord_plot_+3A_x">x</code></td>
<td>
<p>a vector giving intercept and slope for the (fitted)
line in the Ord plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Ord plot plots the number of occurrences against a certain
frequency ratio (see Friendly (2000) for details) and should give a
straight line if the data comes from a poisson, binomial, negative
binomial or log-series distribution.  The intercept and slope of this
straight line conveys information about the underlying distribution.
</p>
<p><code>Ord_plot</code> fits a usual OLS line (black) and a weighted OLS line
(red).  From the coefficients of the latter the distribution is
estimated by <code>Ord_estimate</code> as described in Table 2.10 in
Friendly (2000).  To judge whether a coefficient is positive or
negative a tolerance given by <code>tol</code> is used.  If none of the
distributions fits well, no parameters are estimated.  Be careful with
the conclusions from <code>Ord_estimate</code> as it implements just some
simple heuristics!
</p>


<h3>Value</h3>

<p>A vector giving the intercept and slope of the weighted OLS line.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>References</h3>

<p>J. K. Ord (1967),
Graphical methods for a class of discrete distributions,
<em>Journal of the Royal Statistical Society</em>, <b>A 130</b>,
232&ndash;238.
</p>
<p>Michael Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulated data examples:
dummy &lt;- rnbinom(1000, size = 1.5, prob = 0.8)
Ord_plot(dummy)

## Real data examples:
data("HorseKicks")
data("Federalist")
data("Butterfly")
data("WomenQueue")

## Not run: 
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))

pushViewport(viewport(layout.pos.col=1, layout.pos.row=1))
Ord_plot(HorseKicks, main = "Death by horse kicks", newpage = FALSE)
popViewport()

pushViewport(viewport(layout.pos.col=1, layout.pos.row=2))
Ord_plot(Federalist, main = "Instances of 'may' in Federalist papers", newpage = FALSE)
popViewport()

pushViewport(viewport(layout.pos.col=2, layout.pos.row=1))
Ord_plot(Butterfly, main = "Butterfly species collected in Malaya", newpage = FALSE)
popViewport()

pushViewport(viewport(layout.pos.col=2, layout.pos.row=2))
Ord_plot(WomenQueue, main = "Women in queues of length 10", newpage = FALSE)
popViewport(2)

## End(Not run)

## same
mplot(
  Ord_plot(HorseKicks, return_grob = TRUE, main = "Death by horse kicks"),
  Ord_plot(Federalist, return_grob = TRUE, main = "Instances of 'may' in Federalist papers"),
  Ord_plot(Butterfly, return_grob = TRUE, main = "Butterfly species collected in Malaya"),
  Ord_plot(WomenQueue, return_grob = TRUE, main = "Women in queues of length 10")
)
</code></pre>

<hr>
<h2 id='OvaryCancer'>Ovary Cancer Data</h2><span id='topic+OvaryCancer'></span>

<h3>Description</h3>

<p>Data from Obel (1975) about a retrospective study of ovary cancer
carried out in 1973.  Information was obtained from 299 women, who
were operated for ovary cancer 10 years before.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("OvaryCancer")
</code></pre>


<h3>Format</h3>

<p>A data frame with 16 observations and 5 variables.
</p>

<dl>
<dt>Freq</dt><dd><p>frequency.</p>
</dd>
<dt>stage</dt><dd><p>factor indicating the stage of the cancer at the
time of operation (early, advanced).</p>
</dd>
<dt>operation</dt><dd><p>factor indicating type of operation (radical,
limited).</p>
</dd>
<dt>survival</dt><dd><p>factor indicating survival status after 10 years
(yes, no).</p>
</dd>
<dt>xray</dt><dd><p>factor indicating whether X-ray treatment was received
(yes, no).</p>
</dd>
</dl>



<h3>Source</h3>

<p>E. B. Andersen (1991),
The Statistical Analysis of Categorical Data, Table 6.4.
</p>


<h3>References</h3>

<p>E. B. Obel (1975),
A Comparative Study of Patients with Cancer of the Ovary Who Have
Survived More or Less Than 10 Years.
<em>Acta Obstetricia et Gynecologica Scandinavica</em>, 
<b>55</b>, 429-439.
</p>
<p>E. B. Andersen (1991),
<em>The Statistical Analysis of Categorical Data</em>.
2nd edition.
Springer-Verlag, Berlin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("OvaryCancer")
tab &lt;- xtabs(Freq ~ xray + survival + stage + operation, data = OvaryCancer)
ftable(tab, col.vars = "survival", row.vars = c("stage", "operation", "xray"))

## model: ~ xray * operation * stage + survival * stage
## interpretation: treat xray, operation, stage as fixed margins,
##   the survival depends on stage, but not xray and operation.
doubledecker(survival ~ stage + operation + xray, data = tab)
mosaic(~ stage + operation + xray + survival,
  split_vertical = c(FALSE, TRUE, TRUE, FALSE), data = tab, keep_aspect_ratio = FALSE,
  gp = gpar(fill = rev(grey.colors(2))))
mosaic(~ stage + operation + xray + survival,
  split_vertical = c(FALSE, TRUE, TRUE, FALSE), data = tab, keep_aspect_ratio = FALSE,
  expected = ~ xray * operation * stage + survival*stage)
</code></pre>

<hr>
<h2 id='Pairs+20plot+20panel+20functions+20for+20diagonal+20cells'>Diagonal Panel Functions for Table Pairs Plot</h2><span id='topic+pairs_barplot'></span><span id='topic+pairs_text'></span><span id='topic+pairs_diagonal_text'></span><span id='topic+pairs_diagonal_mosaic'></span>

<h3>Description</h3>

<p>Diagonal panel functions for <code><a href="#topic+pairs.table">pairs.table</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_barplot(gp_bars = NULL,
  gp_vartext = gpar(fontsize = 17),
  gp_leveltext = gpar(),
  gp_axis = gpar(),
  just_leveltext = c("center", "bottom"),
  just_vartext = c("center", "top"),
  rot = 0, abbreviate = FALSE, check_overlap = TRUE, fill = "grey",
  var_offset = unit(1, "npc"), ...)
pairs_text(dimnames = TRUE, gp_vartext = gpar(fontsize = 17), 
  gp_leveltext = gpar(), gp_border = gpar(), ...) 
pairs_diagonal_text(varnames = TRUE, gp_vartext = gpar(fontsize = 17, fontface = "bold"),
  gp_leveltext = gpar(), gp_border = gpar(), pos = c("right","top"),
  distribute = c("equal","margin"), rot = 0, ...)
pairs_diagonal_mosaic(split_vertical = TRUE, margins = unit(0, "lines"),
  offset_labels = -0.4, offset_varnames = 0,
  gp = NULL, fill = "grey", labeling = labeling_values, alternate_labels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_dimnames">dimnames</code></td>
<td>
<p>vector of logicals indicating whether the factor
levels should be displayed (only used for <code>pairs_text</code>).</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_varnames">varnames</code></td>
<td>
<p>vector of logicals indicating whether the variable
names should be displayed (only used for <code>pairs_text_diagonal</code>).</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_gp_bars">gp_bars</code></td>
<td>
<p>object of class <code>"gpar"</code> used for bars (only used
for <code>pairs_barplot</code>). If unspecified, the default is to set the <code>fill</code>
component of this object to the <code>fill</code> argument.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_gp_vartext">gp_vartext</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the factor
names.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_gp_leveltext">gp_leveltext</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the factor
levels.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_gp_axis">gp_axis</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the y axis.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_gp_border">gp_border</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the border
(only used for <code>pairs_text</code>).</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_gp">gp</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the tiles (only used
for <code>pairs_diagonal_mosaic</code>).
If unspecified, the default is to set the <code>fill</code>
component of this object to the <code>fill</code> argument.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_fill">fill</code></td>
<td>
<p>color vector or palette function used for the fill colors
of bars (for <code>pairs_barplot</code>) or tiles (for
<code>pairs_diagonal_mosaic</code>).</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_labeling">labeling</code></td>
<td>
<p>labeling function, passed to <code>mosaic()</code></p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_alternate_labels">alternate_labels</code></td>
<td>
<p>should labels alternate top/bottom?</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_just_leveltext">just_leveltext</code>, <code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_just_vartext">just_vartext</code></td>
<td>
<p>character string indicating the
justification for variable names and levels.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_pos">pos</code></td>
<td>
<p>character string of length 2 controlling the
horizontal and vertical position of the variable names
(only used for <code>pairs_text_diagonal</code>).</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_rot">rot</code></td>
<td>
<p>rotation angle for the variable levels.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_distribute">distribute</code></td>
<td>
<p>character string indicating whether levels should be
distributed equally or according to the margins
(only used for <code>pairs_text_diagonal</code>).</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_abbreviate">abbreviate</code></td>
<td>
<p>integer or logical indicating
the number of characters the labels should be abbreviated
to. <code>TRUE</code> means 1 character, <code>FALSE</code> causes no
abbreviation.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, some levels will suppressed to
avoid overlapping, if any.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_split_vertical">split_vertical</code></td>
<td>
<p>vector of logicals of length <code class="reqn">k</code>, where
<code class="reqn">k</code> is the number of margins of <code>x</code> (values are recycled as needed).
A <code>TRUE</code> component indicates that the tile(s) of the
corresponding dimension should be split vertically, <code>FALSE</code>
means horizontal splits. Default is <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_margins">margins</code></td>
<td>
<p>either an object of class <code>"unit"</code> of length 4, or
a numeric vector of length 4. The elements are recycled as needed.
The four components specify the top, right,
bottom, and left margin of the plot, respectively.
When a numeric vector is supplied, the numbers are interpreted as
<code>"lines"</code> units.  In addition, the unit or numeric vector
may have named arguments
(&lsquo;<span class="samp">&#8288;top&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;right&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;bottom&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;left&#8288;</span>&rsquo;), in which
case the non-named arguments specify the default values (recycled as
needed), overloaded by the named arguments.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_offset_labels">offset_labels</code>, <code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_offset_varnames">offset_varnames</code></td>
<td>
<p>numeric vector of length 4
indicating the offset of the
labels (variable names) for each of the four sides of the plot.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_var_offset">var_offset</code></td>
<td>
<p>object of class <code>"unit"</code> specifying the
offset of variable names from the bottom of the bar plots
created by <code>pairs_barplot</code>. If numeric, the unit defaults to &quot;npc&quot;.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20diagonal+2B20cells_+3A_...">...</code></td>
<td>
<p>other parameters passed to the underlying graphics
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the diagonal cells, the pairsplot visualizes statistics or
information for each dimension (that is: the single factors) alone.
<code><a href="#topic+pairs_text">pairs_text</a></code> displays the factor's name, and optionally
also the factor levels. <code><a href="#topic+pairs_barplot">pairs_barplot</a></code> produces a bar plot
of the corresponding factor, along with the factor's name.
</p>


<h3>Value</h3>

<p>A function with one argument: the marginal table for the corresponding
dimension.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairs.table">pairs.table</a></code>,
<code><a href="#topic+pairs_assoc">pairs_assoc</a></code>,
<code><a href="#topic+pairs_mosaic">pairs_mosaic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("UCBAdmissions")

pairs(UCBAdmissions) # pairs_barplot is default
pairs(UCBAdmissions, diag_panel = pairs_text)

pairs(UCBAdmissions, diag_panel = pairs_diagonal_text)
pairs(Titanic, diag_panel = pairs_diagonal_text)
pairs(Titanic, diag_panel = pairs_diagonal_text(distribute = "margin"))
pairs(Titanic,
      diag_panel = pairs_diagonal_text(distribute = "margin", rot = 45))
</code></pre>

<hr>
<h2 id='Pairs+20plot+20panel+20functions+20for+20off-diagonal+20cells'>Off-diagonal Panel Functions for Table Pairs Plot</h2><span id='topic+pairs_strucplot'></span><span id='topic+pairs_mosaic'></span><span id='topic+pairs_assoc'></span><span id='topic+pairs_sieve'></span>

<h3>Description</h3>

<p>Off-diagonal panel functions for <code><a href="#topic+pairs.table">pairs.table</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_strucplot(panel = mosaic, 
  type = c("pairwise", "total", "conditional", "joint"),
  legend = FALSE, margins = c(0, 0, 0, 0), labeling = NULL, ...)
pairs_assoc(...)
pairs_mosaic(...)
pairs_sieve(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20off-diagonal+2B20cells_+3A_panel">panel</code></td>
<td>
<p>function to be used for the plots in each
cell, such as <code><a href="#topic+pairs_assoc">pairs_assoc</a></code>, <code><a href="#topic+pairs_mosaic">pairs_mosaic</a></code>,
and <code><a href="#topic+pairs_sieve">pairs_sieve</a></code>.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20off-diagonal+2B20cells_+3A_type">type</code></td>
<td>
<p>character string specifying the type of independence model
visualized in the cells.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20off-diagonal+2B20cells_+3A_legend">legend</code></td>
<td>
<p>logical specifying whether a legend should be displayed
in the cells or not.</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20off-diagonal+2B20cells_+3A_margins">margins</code></td>
<td>
<p>margins inside each cell (see <code><a href="#topic+strucplot">strucplot</a></code>).</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20off-diagonal+2B20cells_+3A_labeling">labeling</code></td>
<td>
<p>labeling function or labeling-generating function (see
<code><a href="#topic+strucplot">strucplot</a></code>).</p>
</td></tr>
<tr><td><code id="Pairs+2B20plot+2B20panel+2B20functions+2B20for+2B20off-diagonal+2B20cells_+3A_...">...</code></td>
<td>
<p><code>pairs_mosaic</code>, <code><a href="#topic+pairs_assoc">pairs_assoc</a></code>, and
<code>pairs_sieve</code>: parameters
passed to <code>pairs_strucplot</code>. <code>pairs_strucplot</code>:
other parameters passed to panel function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions really just wrap <code><a href="#topic+assoc">assoc</a></code>, <code><a href="#topic+sieve">sieve</a></code>, and
<code><a href="#topic+mosaic">mosaic</a></code> by basically inhibiting labeling and
legend-drawing and setting the margins to 0.
</p>


<h3>Value</h3>

<p>A function with arguments:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>contingency table.</p>
</td></tr>
<tr><td><code>i</code>, <code>j</code></td>
<td>
<p>cell coordinates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Cohen, A. (1980),
On the graphical display of the significant components in a two-way
contingency table.
<em>Communications in Statistics&mdash;Theory and Methods</em>, <b>A9</b>,
1025&ndash;1041.
</p>
<p>Friendly, M. (1992),
Graphical methods for categorical data.
<em>SAS User Group International Conference Proceedings</em>, <b>17</b>,
190&ndash;200.
<a href="http://datavis.ca/papers/sugi/sugi17.pdf">http://datavis.ca/papers/sugi/sugi17.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairs.table">pairs.table</a></code>,
<code><a href="#topic+pairs_text">pairs_text</a></code>,
<code><a href="#topic+pairs_barplot">pairs_barplot</a></code>,
<code><a href="#topic+assoc">assoc</a></code>,
<code><a href="#topic+mosaic">mosaic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("UCBAdmissions")
data("PreSex")

pairs(PreSex)
pairs(UCBAdmissions)
pairs(UCBAdmissions, upper_panel_args = list(shade = FALSE))
pairs(UCBAdmissions, lower_panel = pairs_mosaic(type = "conditional"))
pairs(UCBAdmissions, upper_panel = pairs_assoc)
</code></pre>

<hr>
<h2 id='pairs.table'>Pairs Plot for Contingency Tables</h2><span id='topic+pairs.table'></span><span id='topic+pairs.structable'></span>

<h3>Description</h3>

<p>Produces a matrix of strucplot displays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'table'
pairs(x, upper_panel = pairs_mosaic, upper_panel_args = list(),
  lower_panel = pairs_mosaic, lower_panel_args = list(),
  diag_panel = pairs_diagonal_mosaic, diag_panel_args = list(),
  main = NULL, sub = NULL, main_gp = gpar(fontsize = 20),
  sub_gp = gpar(fontsize = 15), space = 0.3,
  newpage = TRUE, pop = TRUE, return_grob = FALSE,
  margins = unit(1, "lines"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairs.table_+3A_x">x</code></td>
<td>
<p>a contingency table in array form, with optional category
labels specified in the <code>dimnames(x)</code> attribute.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_upper_panel">upper_panel</code></td>
<td>
<p>function for the upper triangle of the matrix, or
corresponding generating function. If <code>NULL</code>, no panel is drawn.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_upper_panel_args">upper_panel_args</code></td>
<td>
<p>list of arguments for the generating
function, if specified.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_lower_panel">lower_panel</code></td>
<td>
<p>function for the lower triangle of the matrix, or
corresponding generating function. If <code>NULL</code>, no panel is drawn.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_lower_panel_args">lower_panel_args</code></td>
<td>
<p>list of arguments for the panel-generating
function, if specified.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_diag_panel">diag_panel</code></td>
<td>
<p>function for the diagonal of the matrix, or
corresponding generating function. If <code>NULL</code>, no panel is drawn.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_diag_panel_args">diag_panel_args</code></td>
<td>
<p>list of arguments for the generating
function, if specified.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_main">main</code></td>
<td>
<p>either a logical, or a character string used for plotting
the main title.  If <code>main</code> is a logical and <code>TRUE</code>, the
name of the object supplied as <code>x</code> is used.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_sub">sub</code></td>
<td>
<p>a character string used for plotting the subtitle.
If <code>sub</code> is a logical and <code>TRUE</code> and <code>main</code> is unspecified, the
name of the object supplied as <code>x</code> is used.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_main_gp">main_gp</code>, <code id="pairs.table_+3A_sub_gp">sub_gp</code></td>
<td>
<p>object of class <code>"gpar"</code> containing the graphical
parameters used for the main (sub) title, if specified.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_space">space</code></td>
<td>
<p>double specifying the distance between the cells.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_newpage">newpage</code></td>
<td>
<p>logical controlling whether a new grid page should be
created.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_pop">pop</code></td>
<td>
<p>logical indicating whether all viewports should be popped
after the plot has been drawn.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_return_grob">return_grob</code></td>
<td>
<p>logical. Should a snapshot of the display be
returned as a grid grob?</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_margins">margins</code></td>
<td>
<p>either an object of class <code>"unit"</code> of length 4, or
a numeric vector of length 4. The elements are recycled as needed.
The four components specify the top, right,
bottom, and left margin of the plot, respectively.
When a numeric vector is supplied, the numbers are interpreted as
<code>"lines"</code> units.  In addition, the unit or numeric vector
may have named arguments
(&lsquo;<span class="samp">&#8288;top&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;right&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;bottom&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;left&#8288;</span>&rsquo;), in which
case the non-named arguments specify the default values (recycled as
needed), overloaded by the named arguments.</p>
</td></tr>
<tr><td><code id="pairs.table_+3A_...">...</code></td>
<td>
<p>For convenience,
list of arguments for the panel-generating
functions of upper and lower panels, if specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a <code><a href="graphics.html#topic+pairs">pairs</a></code> method for objects inheriting
from class <code>"table"</code> or <code>"structable"</code>.
It plots a matrix of pairwise mosaic plots.
</p>
<p>Four independence types are distinguished: <code>"pairwise"</code>,
<code>"total"</code>, <code>"conditional"</code> and <code>"joint"</code>.
The pairwise mosaic matrix shows bivariate marginal relations,
collapsed over all other variables.
The total independence mosaic matrix shows mosaic plots for mutual
independence, i.e., for marginal and conditional independence among
all pairs of variables.
The conditional independence mosaic matrix shows mosaic plots for
conditional independence for each pair of variables, given all other variables.
The joint independence mosaic matrix shows mosaic plots for joint
independence of all pairs of variables from the others.
</p>
<p>This method uses panel functions called for each cell of the
matrix which can be different for upper matrix, lower matrix, and
diagonal cells.  Correspondingly, for each panel parameter <var>foo</var>
(= &lsquo;<span class="samp">&#8288;upper&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;lower&#8288;</span>&rsquo;, or &lsquo;<span class="samp">&#8288;diag&#8288;</span>&rsquo;), <code>pairs.table</code> takes
two arguments: <var>foo_panel</var> and <var>foo_panel_args</var>, which can
be used to specify the parameters as follows:
</p>

<ol>
<li><p> Passing a suitable panel function to <var>foo_panel</var> which
subsequently is called for each cell with the corresponding
coordinates.
</p>
</li>
<li><p> Passing a corresponding <em>generating function</em> (of class
<code>"panel_generator"</code>) to <var>foo_panel</var>, along with parameters passed to
<var>foo_panel_args</var>, that generates such a function. 
</p>
</li></ol>

<p>Hence, the second approach is equivalent to the first if
<var>foo_panel(foo_panel_args)</var> is passed to
<var>foo_panel</var>.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Cohen, A. (1980),
On the graphical display of the significant components in a two-way
contingency table.
<em>Communications in Statistics&mdash;Theory and Methods</em>, <b>A9</b>,
1025&ndash;1041.
</p>
<p>Friendly, M. (1992),
Graphical methods for categorical data.
<em>SAS User Group International Conference Proceedings</em>, <b>17</b>,
190&ndash;200.
<a href="http://datavis.ca/papers/sugi/sugi17.pdf">http://datavis.ca/papers/sugi/sugi17.pdf</a>
</p>
<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairs_mosaic">pairs_mosaic</a></code>,
<code><a href="#topic+pairs_assoc">pairs_assoc</a></code>,
<code><a href="#topic+pairs_sieve">pairs_sieve</a></code>,
<code><a href="#topic+pairs_diagonal_text">pairs_diagonal_text</a></code>,
<code><a href="#topic+pairs_diagonal_mosaic">pairs_diagonal_mosaic</a></code>,
<code><a href="#topic+pairs_text">pairs_text</a></code>,
<code><a href="#topic+pairs_barplot">pairs_barplot</a></code>,
<code><a href="#topic+assoc">assoc</a></code>,
<code><a href="#topic+sieve">sieve</a></code>,
<code><a href="#topic+mosaic">mosaic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("UCBAdmissions")
data("PreSex")
data(HairEyeColor)
hec = structable(Eye ~ Sex + Hair, data = HairEyeColor)

pairs(PreSex)
pairs(UCBAdmissions)
pairs(UCBAdmissions, upper_panel_args = list(shade = TRUE))
pairs(UCBAdmissions, lower_panel = pairs_mosaic(type = "conditional"))
pairs(UCBAdmissions, diag_panel = pairs_text)
pairs(UCBAdmissions, upper_panel = pairs_assoc, shade = TRUE)
pairs(hec, highlighting = 2, diag_panel_args = list(fill = grey.colors))
pairs(hec, highlighting = 2, diag_panel = pairs_diagonal_mosaic,
           diag_panel_args = list(fill = grey.colors, alternate_labels =TRUE))

</code></pre>

<hr>
<h2 id='plot.loddsratio'>Plotting (Log) Odds Ratios</h2><span id='topic+plot.loddsratio'></span><span id='topic+lines.loddsratio'></span>

<h3>Description</h3>

<p>Produces a (conditional) line plot of extended (log) odds ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loddsratio'
plot(x, baseline = TRUE, gp_baseline = gpar(lty = 2),
     lines = TRUE, lwd_lines = 3,
     confidence = TRUE, conf_level = 0.95, lwd_confidence = 2,
     whiskers = 0, transpose = FALSE,
     col = NULL, cex = 0.8, pch = NULL,
     bars = NULL, gp_bars = gpar(fill = "lightgray", alpha = 0.5),
     bar_width = unit(0.05, "npc"),
             
     legend = TRUE, legend_pos = "topright", legend_inset = c(0, 0),
     legend_vgap = unit(0.5, "lines"),
     gp_legend_frame = gpar(lwd = 1, col = "black"),
     gp_legend_title = gpar(fontface = "bold"),
     gp_legend = gpar(), legend_lwd = 1, legend_size = 1,
             
     xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL,
     main = NULL, gp_main = gpar(fontsize = 12, fontface = "bold"),
     newpage = TRUE, pop = FALSE, return_grob = FALSE,
     add = FALSE, prefix = "", ...)
## S3 method for class 'loddsratio'
lines(x, legend = FALSE, confidence = FALSE, cex = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.loddsratio_+3A_x">x</code></td>
<td>
<p>an object of class <code>loddsratio</code>.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_baseline">baseline</code></td>
<td>
<p>if <code>TRUE</code>, a dashed line is plotted at a
value of 1 (in case of odds) or 0 (in case of log-odds).</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_gp_baseline">gp_baseline</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the baseline.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_lines">lines</code></td>
<td>
<p>if <code>TRUE</code>, the points are connected by lines (only
sensible if the variable represented by the x-axis is ordinal).</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_lwd_lines">lwd_lines</code></td>
<td>
<p>Width of the connecting lines (in <code>char</code> units).</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_confidence">confidence</code></td>
<td>
<p>logical; shall confindence intervals be plotted?</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_conf_level">conf_level</code></td>
<td>
<p>confidence level used for confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_lwd_confidence">lwd_confidence</code></td>
<td>
<p>Line width of the confidence interval bars (in <code>char</code> units).</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_whiskers">whiskers</code></td>
<td>
<p>width of the confidence interval whiskers.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_transpose">transpose</code></td>
<td>
<p>if <code>TRUE</code>, the plot is transposed.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_col">col</code></td>
<td>
<p>character vector specifying the colors of the fitted
lines, by default chosen with <code><a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a></code>.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_cex">cex</code></td>
<td>
<p>size of the plot symbols (in lines).</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_pch">pch</code></td>
<td>
<p>character or numeric vector of symbols used for plotting
the (possibly conditioned) observed values, recycled as needed.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_bars">bars</code></td>
<td>
<p>logical; shall bars be plotted additionally to the points?
Defaults to <code>TRUE</code> in case of only one conditioning variable.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_gp_bars">gp_bars</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the bars.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_bar_width">bar_width</code></td>
<td>
<p>Width of the bars, if drawn.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_legend">legend</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), a legend is drawn.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_legend_pos">legend_pos</code></td>
<td>
<p>numeric vector of length 2, specifying x and y
coordinates of the legend, or a character string (e.g., <code>"topleft"</code>,
<code>"center"</code> etc.). Defaults to <code>"topleft"</code>
if the fitted curve's slope is
positive, and <code>"topright"</code> else.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_legend_inset">legend_inset</code></td>
<td>
<p>numeric vector or length 2 specifying the inset
from the legend's x and y coordinates in npc units.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_legend_vgap">legend_vgap</code></td>
<td>
<p>vertical space between the legend's line entries.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_gp_legend_frame">gp_legend_frame</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the
legend frame.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_gp_legend_title">gp_legend_title</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the
legend title.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_gp_legend">gp_legend</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the
legend defaults.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_legend_lwd">legend_lwd</code></td>
<td>
<p>line width used in the legend for the different
groups.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_legend_size">legend_size</code></td>
<td>
<p>size used for the group symbols (in char units).</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis. Defaults to <code>"Strata"</code> if
<code>transpose</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis. Defaults to <code>"Strata"</code> if
<code>transpose</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_xlim">xlim</code></td>
<td>
<p>x-axis limits. Ignored if <code>transpose</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits. Ignored if <code>transpose</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_main">main</code></td>
<td>
<p>user-specified main title.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_gp_main">gp_main</code></td>
<td>
<p>object of class <code>"gpar"</code> used for the main title.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_newpage">newpage</code></td>
<td>
<p>logical; if <code>TRUE</code>, the plot is drawn on a new page.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_pop">pop</code></td>
<td>
<p>logical; if <code>TRUE</code>, all newly generated viewports are
popped after plotting.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_return_grob">return_grob</code></td>
<td>
<p>logical. Should a snapshot of the display be
returned as a grid grob?</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_add">add</code></td>
<td>
<p>logical; should the plot added to an existing log odds
ratio plot?</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_prefix">prefix</code></td>
<td>
<p>character string used as prefix for the viewport name.</p>
</td></tr>
<tr><td><code id="plot.loddsratio_+3A_...">...</code></td>
<td>
<p>other graphics parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function basically produces conditioned line plots of the (log)
odds ratios structure provided in <code>x</code>.
</p>
<p>The <code>lines</code> method can be used to overlay different plots (for
example, observed and expected values).
</p>
<p><code><a href="#topic+cotabplot">cotabplot</a></code> can be used for stratified analyses (see examples).
</p>


<h3>Value</h3>

<p>if <code>return_grob</code> is <code>TRUE</code>, a grob object corresponding to
the plot. <code>NULL</code> (invisibly) else.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loddsratio">loddsratio</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 2 x 2 x k cases
data(CoalMiners, package = "vcd")
lor_CM &lt;- loddsratio(CoalMiners)
plot(lor_CM)
lor_CM_df &lt;- as.data.frame(lor_CM)

# fit linear models using WLS
age &lt;- seq(20, 60, by = 5)
lmod &lt;- lm(LOR ~ age, weights = 1 / ASE^2, data = lor_CM_df)
grid.lines(seq_along(age), fitted(lmod), gp = gpar(col = "blue", lwd = 2), default.units = "native")
qmod &lt;- lm(LOR ~ poly(age, 2), weights = 1 / ASE^2, data = lor_CM_df)
grid.lines(seq_along(age), fitted(qmod), gp = gpar(col = "red", lwd = 2), default.units = "native")

## 2 x k x 2
lor_Emp &lt;-loddsratio(Employment)
plot(lor_Emp)

## 4 way tables 
data(Punishment, package = "vcd")
mosaic(attitude ~ age + education + memory, data = Punishment,
highlighting_direction="left", rep = c(attitude = FALSE))

# visualize the log odds ratios, by education
plot(loddsratio(~ attitude + memory | education, data = Punishment))

# visualize the log odds ratios, by age
plot(loddsratio(~ attitude + memory | age, data = Punishment))

# visualize the log odds ratios, by age and education
plot(loddsratio(~ attitude + memory | age + education, data = Punishment))

# same, transposed
plot(loddsratio(~ attitude + memory | age + education, data = Punishment), transpose = TRUE)

# alternative visualization methods
image(loddsratio(Freq ~ ., data = Punishment))
tile(loddsratio(Freq ~ ., data = Punishment))

## cotabplots for more complex tables
cotabplot(Titanic, cond = c("Age","Sex"), panel = cotab_loddsratio)

cotabplot(Freq ~ opinion + grade + year | gender, data = JointSports, panel = cotab_loddsratio)
cotabplot(Freq ~ opinion + grade | year + gender, data = JointSports, panel = cotab_loddsratio)
</code></pre>

<hr>
<h2 id='plot.loglm'>Visualize Fitted Log-linear Models</h2><span id='topic+plot.loglm'></span><span id='topic+assoc.loglm'></span><span id='topic+mosaic.loglm'></span>

<h3>Description</h3>

<p>Visualize fitted <code>"loglm"</code> objects by mosaic or 
association plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loglm'
plot(x, panel = mosaic, type = c("observed", "expected"),
  residuals_type = c("pearson", "deviance"), gp = shading_hcl, gp_args = list(),
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.loglm_+3A_x">x</code></td>
<td>
<p>a fitted <code>"loglm"</code> object, see <code><a href="MASS.html#topic+loglm">loglm</a></code>.</p>
</td></tr>
<tr><td><code id="plot.loglm_+3A_panel">panel</code></td>
<td>
<p>a panel function for visualizing the observed values,
residuals and expected values. Currently, <code><a href="#topic+mosaic">mosaic</a></code> and
<code><a href="#topic+assoc">assoc</a></code> in <span class="pkg">vcd</span>.</p>
</td></tr>
<tr><td><code id="plot.loglm_+3A_type">type</code></td>
<td>
<p>a character string indicating whether the observed or the
expected values of the table should be visualized.</p>
</td></tr>
<tr><td><code id="plot.loglm_+3A_residuals_type">residuals_type</code></td>
<td>
<p>a character string indicating the type of
residuals to be computed.</p>
</td></tr>
<tr><td><code id="plot.loglm_+3A_gp">gp</code></td>
<td>
<p>object of class <code>"gpar"</code>, shading function or a
corresponding generating function (see details and
<code><a href="#topic+shadings">shadings</a></code>).
Ignored if <code>shade = FALSE</code>.</p>
</td></tr> 
<tr><td><code id="plot.loglm_+3A_gp_args">gp_args</code></td>
<td>
<p>list of arguments for the shading-generating function,
if specified.</p>
</td></tr>
<tr><td><code id="plot.loglm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the <code>panel</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> method for <code>"loglm"</code> objects by default visualizes 
the model using a mosaic plot (can be changed to an association plot
by setting <code>panel = assoc</code>) with a shading based on the residuals
of this model. The legend also reports the corresponding p value of the
associated goodness-of-fit test. The <code>mosaic</code> and <code>assoc</code> methods
are simple convenience interfaces to this <code>plot</code> method, setting 
the <code>panel</code> argument accordingly.
</p>


<h3>Value</h3>

<p>The <code>"structable"</code> visualized is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+loglm">loglm</a></code>,
<code><a href="#topic+assoc">assoc</a></code>,
<code><a href="#topic+mosaic">mosaic</a></code>,
<code><a href="#topic+strucplot">strucplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
## mosaic display for PreSex model
data("PreSex")
fm &lt;- loglm(~ PremaritalSex * ExtramaritalSex * (Gender + MaritalStatus),
  data = aperm(PreSex, c(3, 2, 4, 1)))
fm
## visualize Pearson statistic
plot(fm, split_vertical = TRUE)
## visualize LR statistic
plot(fm, split_vertical = TRUE, residuals_type = "deviance")

## conditional independence in UCB admissions data
data("UCBAdmissions")
fm &lt;- loglm(~ Dept * (Gender + Admit), data = aperm(UCBAdmissions))

## use mosaic display
plot(fm, labeling_args = list(abbreviate_labs = c(Admit = 3)))

## and association plot
plot(fm, panel = assoc)
assoc(fm)
</code></pre>

<hr>
<h2 id='PreSex'>Pre-marital Sex and Divorce</h2><span id='topic+PreSex'></span>

<h3>Description</h3>

<p>Data from Thornes &amp; Collard (1979), reported in Gilbert (1981), on
pre- and extra-marital sex and divorce.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("PreSex")
</code></pre>


<h3>Format</h3>

<p>A 4-dimensional array resulting from cross-tabulating 1036
observations on 4 variables.  The variables and their levels are as
follows:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> MaritalStatus </td><td style="text-align: left;"> Divorced, Married </td>
</tr>
<tr>
 <td style="text-align: right;">
    2 </td><td style="text-align: left;"> ExtramaritalSex </td><td style="text-align: left;"> Yes, No </td>
</tr>
<tr>
 <td style="text-align: right;">
    3 </td><td style="text-align: left;"> PremaritalSex </td><td style="text-align: left;"> Yes, No </td>
</tr>
<tr>
 <td style="text-align: right;">
    4 </td><td style="text-align: left;"> Gender </td><td style="text-align: left;"> Women, Men
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Michael Friendly (2000),
Visualizing Categorical Data:
<a href="http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/marital.sas">http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/marital.sas</a>
</p>


<h3>References</h3>

<p>G. N. Gilbert (1981),
<em>Modelling Society: An Introduction to Loglinear Analysis for
Social Researchers</em>.
Allen and Unwin, London.
</p>
<p>B. Thornes &amp; J. Collard (1979),
<em>Who Divorces?</em>.
Routledge &amp; Kegan, London.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("PreSex")

## Mosaic display for Gender and Premarital Sexual Experience
## (Gender Pre)
mosaic(margin.table(PreSex, c(3,4)), 
                main = "Gender and Premarital Sex")

## (Gender Pre)(Extra)
mosaic(margin.table(PreSex, c(2,3,4)), 
       expected = ~Gender * PremaritalSex + ExtramaritalSex ,
	   main = "PreMaritalSex*Gender +Sex")

## (Gender Pre Extra)(Marital)
mosaic(PreSex,
       expected = ~Gender*PremaritalSex*ExtramaritalSex + MaritalStatus,
       main = "PreMarital*ExtraMarital + MaritalStatus")

## (GPE)(PEM)
mosaic(PreSex, 
       expected = ~ Gender * PremaritalSex * ExtramaritalSex
                    + MaritalStatus * PremaritalSex * ExtramaritalSex,
       main = "G*P*E + P*E*M")
</code></pre>

<hr>
<h2 id='Punishment'>Corporal Punishment Data</h2><span id='topic+Punishment'></span>

<h3>Description</h3>

<p>Data from a study of the Gallup Institute in Denmark in 1979 about the
attitude of a random sample of 1,456 persons towards corporal punishment
of children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Punishment")
</code></pre>


<h3>Format</h3>

<p>A data frame with 36 observations and 5 variables.
</p>

<dl>
<dt>Freq</dt><dd><p>frequency.</p>
</dd>
<dt>attitude</dt><dd><p>factor indicating attitude: (no, moderate)
punishment of children.</p>
</dd>
<dt>memory</dt><dd><p>factor indicating whether the person had memories of
corporal punishment as a child (yes, no).</p>
</dd>
<dt>education</dt><dd><p>factor indicating highest level of education
(elementary, secondary, high).</p>
</dd>
<dt>age</dt><dd><p>factor indicating age group in years (15-24, 25-39, 40-).</p>
</dd>
</dl>



<h3>Note</h3>

<p>Anderson (1991) erroneously indicates the total sum of respondents to be 783.</p>


<h3>Source</h3>

<p>E. B. Andersen (1991),
The Statistical Analysis of Categorical Data, pages 207&ndash;208.
</p>


<h3>References</h3>

<p>E. B. Andersen (1991),
<em>The Statistical Analysis of Categorical Data</em>.
2nd edition.
Springer-Verlag, Berlin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Punishment", package = "vcd")
pun &lt;- xtabs(Freq ~ memory + attitude + age + education, data = Punishment)

## model: ~ (memory + attitude) * age * education
## use maximum sum-of-squares test/shading

cotabplot(~ memory + attitude | age + education, data = pun,
          panel = cotab_coindep, panel_args = list( 
  n = 5000, type = "assoc", test = "maxchisq", interpolate = 1:2))
</code></pre>

<hr>
<h2 id='RepVict'>Repeat Victimization Data</h2><span id='topic+RepVict'></span>

<h3>Description</h3>

<p>Data from Reiss (1980) given by Fienberg (1980) about instances of
repeat victimization for households in the U.S. National Crime
Survey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("RepVict")
</code></pre>


<h3>Format</h3>

<p>A 2-dimensional array resulting from cross-tabulating victimization.
The variables and their levels are as follows:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> First Victimization </td><td style="text-align: left;"> Rape, Assault, Robbery, Pickpocket,
    Personal Larceny, </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: left;"> </td><td style="text-align: left;"> Burglary, Household Larceny, Auto Theft </td>
</tr>
<tr>
 <td style="text-align: right;">
    2 </td><td style="text-align: left;"> Second Victimization </td><td style="text-align: left;"> Rape, Assault, Robbery, Pickpocket,
    Personal Larceny,</td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: left;"> </td><td style="text-align: left;"> Burglary, Household Larceny, Auto Theft
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Michael Friendly (2000),
Visualizing Categorical Data, page 113.
</p>


<h3>References</h3>

<p>S. E. Fienberg (1980),
<em>The Analysis of Cross-Classified Categorical Data</em>,
MIT Press, Cambridge, 2nd edition.
</p>
<p>A. J. J. Reiss (1980),
Victim proneness by type of crime in repeat victimization.
In S. E. Fienberg &amp; A. J. J. Reiss (eds.),
<em>Indicators of Crime and Criminal Justice</em>.
U.S. Government Printing Office, Washington, DC.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("RepVict")

mosaic(RepVict[-c(4,7),-c(4,7)], gp = shading_max,
       main = "Repeat Victimization Data")
</code></pre>

<hr>
<h2 id='Rochdale'>Rochdale Data</h2><span id='topic+Rochdale'></span>

<h3>Description</h3>

<p>Information on 665 households of Rochdale, Lancashire, UK.
The study was conducted to identify influence factors on economical
activity of wives. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Rochdale")
</code></pre>


<h3>Format</h3>

<p>A 8-dimensional array resulting from cross-tabulating 665 observations
on 8 variables.  The variables and their levels are as follows:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> EconActive </td><td style="text-align: left;"> yes, no </td>
</tr>
<tr>
 <td style="text-align: right;">
    2 </td><td style="text-align: left;"> Age </td><td style="text-align: left;"> &lt;38, &gt;38 </td>
</tr>
<tr>
 <td style="text-align: right;">
    3 </td><td style="text-align: left;"> HusbandEmployed </td><td style="text-align: left;"> yes, no </td>
</tr>
<tr>
 <td style="text-align: right;">
    4 </td><td style="text-align: left;"> Child </td><td style="text-align: left;"> yes, no </td>
</tr>
<tr>
 <td style="text-align: right;">
    5 </td><td style="text-align: left;"> Education </td><td style="text-align: left;"> yes, no </td>
</tr>
<tr>
 <td style="text-align: right;">
    6 </td><td style="text-align: left;"> HusbandEducation </td><td style="text-align: left;"> yes, no </td>
</tr>
<tr>
 <td style="text-align: right;">
    7 </td><td style="text-align: left;"> Asian </td><td style="text-align: left;"> yes, no </td>
</tr>
<tr>
 <td style="text-align: right;">
    8 </td><td style="text-align: left;"> HouseholdWorking </td><td style="text-align: left;"> yes, no </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Note</h3>

<p>Many observations are missing: only 91 out of all 256 combinations
contain information.
</p>


<h3>Source</h3>

<p>Whittaker (1990).
</p>


<h3>References</h3>

<p>H. Hofmann (2003).
Constructing and reading mosaicplots.
<em>Computational Statistics &amp; Data Analysis</em>,
<b>43</b>, 4, 565&ndash;580.
</p>
<p>J. Whittaker (1990),
<em>Graphical Models on Applied Multivariate Statistics</em>,
Wiley, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Rochdale")
mosaic(Rochdale)
</code></pre>

<hr>
<h2 id='rootogram'>Rootograms</h2><span id='topic+rootogram'></span><span id='topic+rootogram.default'></span><span id='topic+rootogram.goodfit'></span>

<h3>Description</h3>

<p>Rootograms of observed and fitted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
rootogram(x, fitted, names = NULL, scale = c("sqrt", "raw"),
  type = c("hanging", "standing", "deviation"),
  shade = FALSE, legend = TRUE,
  legend_args = list(x = 0, y = 0.2, height = 0.6), df = NULL,
  rect_gp = NULL, rect_gp_args = list(),
  lines_gp = gpar(col = "red", lwd = 2),
  points_gp = gpar(col = "red"), pch = 19,
  xlab = NULL, ylab = NULL, ylim = NULL,
  main = NULL, sub = NULL,
  margins = unit(0, "lines"),
  title_margins = NULL, legend_width = NULL,
  main_gp = gpar(fontsize = 20),
  sub_gp = gpar(fontsize = 15),
  name = "rootogram", prefix = "",
  keep_aspect_ratio = FALSE,
  newpage = TRUE, pop = TRUE,
  return_grob = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rootogram_+3A_x">x</code></td>
<td>
<p>either a vector or a 1-way table of frequencies.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_fitted">fitted</code></td>
<td>
<p>a vector of fitted frequencies.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_names">names</code></td>
<td>
<p>a vector of names passed to <code><a href="#topic+grid_barplot">grid_barplot</a></code>, if set
to <code>NULL</code> the names of <code>x</code> are used.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_scale">scale</code></td>
<td>
<p>a character string indicating whether the values should be
plotted on the raw or square root scale.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_type">type</code></td>
<td>
<p>a character string indicating if the bars for the observed
frequencies should be <code>hanging</code> or <code>standing</code> or indicate the <code>deviation</code>
between observed and fitted frequencies.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_shade">shade</code></td>
<td>
<p>logical specifying whether <code>rect_gp</code> should be set
to colors corresponding to the pearson residuals, i.e., if a
residual-based shading should be applied to the bars.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_legend">legend</code></td>
<td>
<p>either a legend-generating function, or a legend
function (see details and <code><a href="#topic+legends">legends</a></code>), or a logical.
If <code>legend</code> is <code>NULL</code> or <code>TRUE</code> and <code>gp</code> is a
function, legend defaults to <code><a href="#topic+legend_resbased">legend_resbased</a></code>.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_legend_args">legend_args</code></td>
<td>
<p>list of arguments for the legend-generating
function, if specified.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_df">df</code></td>
<td>
<p>degrees of freedom passed to the shading functions
used for inference.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_rect_gp">rect_gp</code></td>
<td>
<p>a <code>"gpar"</code> object controlling the grid graphical
parameters of the rectangles, shading function or a
corresponding generating function (see <code><a href="#topic+shadings">shadings</a></code>). If
unspecified and no shading is applied, defaults to light grey fill color for the bars.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_rect_gp_args">rect_gp_args</code></td>
<td>
<p>list of arguments for the shading-generating
function, if specified for <code>rect_gp</code>.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_lines_gp">lines_gp</code></td>
<td>
<p>a <code>"gpar"</code> object controlling the grid graphical
parameters of the lines.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_points_gp">points_gp</code></td>
<td>
<p>a <code>"gpar"</code> object controlling the grid graphical
parameters of the points.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_pch">pch</code></td>
<td>
<p>plotting character for the points.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y axis.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_main">main</code></td>
<td>
<p>either a logical, or a character string used for plotting
the main title.  If <code>main</code> is a logical and <code>TRUE</code>, the
name of the object supplied as <code>x</code> is used.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_sub">sub</code></td>
<td>
<p>a character string used for plotting the subtitle.
If <code>sub</code> is a logical and <code>TRUE</code> and <code>main</code> is unspecified, the
name of the object supplied as <code>x</code> is used.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_margins">margins</code></td>
<td>
<p>either an object of class <code>"unit"</code> of length 4, or
a numeric vector of length 4. The elements are recycled as needed.
The four components specify the top, right,
bottom, and left margin of the plot, respectively.
When a numeric vector is supplied, the numbers are interpreted as
<code>"lines"</code> units.  In addition, the unit or numeric vector
may have named arguments
(&lsquo;<span class="samp">&#8288;top&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;right&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;bottom&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;left&#8288;</span>&rsquo;), in which
case the non-named arguments specify the default values (recycled as
needed), overloaded by the named arguments.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_title_margins">title_margins</code></td>
<td>
<p>either an object of class <code>"unit"</code> of length 2, or
a numeric vector of length 2. The elements are recycled as needed.
The two components specify the top and bottom <em>title</em> margin
of the plot, respectively. The default for each
<em>specified</em> title are 2 lines (and 0 else), except when a
legend is plotted and <code>keep_aspect_ratio</code> is <code>TRUE</code>: in
this case, the default values of both margins are set as to align
the heights of legend and actual plot.
When a numeric vector is supplied, the numbers are interpreted as
<code>"lines"</code> units.  In addition, the unit or numeric vector
may have named arguments (&lsquo;<span class="samp">&#8288;top&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;bottom&#8288;</span>&rsquo;), in which
case the non-named argument specify the default value (recycled as
needed), overloaded by the named arguments.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_legend_width">legend_width</code></td>
<td>
<p>An object of class <code>"unit"</code> of length
1 specifying the width of the legend (if any). Default: 5 lines.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_main_gp">main_gp</code>, <code id="rootogram_+3A_sub_gp">sub_gp</code></td>
<td>
<p>object of class <code>"gpar"</code> containing the graphical parameters used for the main (sub) title, if specified.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_name">name</code></td>
<td>
<p>name of the plotting viewport.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_keep_aspect_ratio">keep_aspect_ratio</code></td>
<td>
<p>logical indicating whether the aspect ratio should be fixed or not.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_prefix">prefix</code></td>
<td>
<p>optional character string used as a prefix for the
generated viewport and grob names.</p>
</td></tr>
<tr><td><code id="rootogram_+3A_newpage">newpage</code></td>
<td>
<p>logical. Should <code><a href="grid.html#topic+grid.newpage">grid.newpage</a></code> be called 
before plotting?</p>
</td></tr>
<tr><td><code id="rootogram_+3A_pop">pop</code></td>
<td>
<p>logical. Should the viewport created be popped?</p>
</td></tr>
<tr><td><code id="rootogram_+3A_return_grob">return_grob</code></td>
<td>
<p>logical. Should a snapshot of the display be
returned as a grid grob?</p>
</td></tr>
<tr><td><code id="rootogram_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+grid_barplot">grid_barplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The observed frequencies are displayed as bars and the fitted
frequencies as a line.  By default a sqrt scale is used to make the
smaller frequencies more visible.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>,
David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>J. W. Tukey (1977),
<em>Exploratory Data Analysis</em>.
Addison Wesley, Reading, MA.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid_barplot">grid_barplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulated data examples:
dummy &lt;- rnbinom(200, size = 1.5, prob = 0.8)
observed &lt;- table(dummy)
fitted1 &lt;- dnbinom(as.numeric(names(observed)),
                   size = 1.5, prob = 0.8) * sum(observed)
fitted2 &lt;- dnbinom(as.numeric(names(observed)),
                   size = 2, prob = 0.6) * sum(observed)
rootogram(observed, fitted1)
rootogram(observed, fitted2)

## Real data examples:
data("HorseKicks")
HK.fit &lt;- goodfit(HorseKicks)
summary(HK.fit)
plot(HK.fit)
## or equivalently
rootogram(HK.fit)

data("Federalist")
F.fit &lt;- goodfit(Federalist, type = "nbinomial")
summary(F.fit)
plot(F.fit)

## (Pearson) residual-based shading
data("Federalist")
Fed_fit0 &lt;- goodfit(Federalist, type = "poisson")
plot(Fed_fit0, shade = TRUE)
</code></pre>

<hr>
<h2 id='Saxony'>Families in Saxony</h2><span id='topic+Saxony'></span>

<h3>Description</h3>

<p>Data from Geissler, cited in Sokal &amp; Rohlf (1969) and Lindsey (1995)
on gender distributions in families in Saxony in the 19th century.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Saxony")
</code></pre>


<h3>Format</h3>

<p>A 1-way table giving the number of male children in 6115 families of
size 12.  The variable and its levels are
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> nMales </td><td style="text-align: left;"> 0, 1, ..., 12 </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>M. Friendly (2000),
Visualizing Categorical Data, pages 40&ndash;42.
</p>


<h3>References</h3>

<p>J. K. Lindsey (1995),
<em>Analysis of Frequency and Count Data</em>.
Oxford University Press, Oxford, UK.
</p>
<p>R. R. Sokal &amp; F. J. Rohlf (1969),
<em>Biometry. The Principles and Practice of Statistics</em>.
W. H. Freeman, San Francisco, CA.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Saxony")
gf &lt;- goodfit(Saxony, type = "binomial")
summary(gf)
plot(gf)
</code></pre>

<hr>
<h2 id='SexualFun'>Sex is Fun</h2><span id='topic+SexualFun'></span>

<h3>Description</h3>

<p>Data from Hout et al. (1987) given by Agresti (1990) summarizing the
responses of married couples to the questionnaire item: Sex is fun for
me and my partner: (a) never or occasionally, (b) fairly often, (c)
very often, (d) almost always.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("SexualFun")
</code></pre>


<h3>Format</h3>

<p>A 2-dimensional array resulting from cross-tabulating the ratings of
91 married couples.  The variables and their levels are as follows:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> Husband </td><td style="text-align: left;"> Never Fun, Fairly Often, Very Often, Always Fun </td>
</tr>
<tr>
 <td style="text-align: right;">
    2 </td><td style="text-align: left;"> Wife </td><td style="text-align: left;"> Never Fun, Fairly Often, Very Often, Always Fun
  </td>
</tr>

</table>



<h3>Source</h3>

<p>M. Friendly (2000),
Visualizing Categorical Data, page 91.
</p>


<h3>References</h3>

<p>A. Agresti (1990),
<em>Categorical Data Analysis</em>.
Wiley-Interscience, New York.
</p>
<p>M. Hout, O. D. Duncan, M. E. Sobel (1987),
Association and heterogeneity: Structural models of similarities and
differences,
<em>Sociological Methodology</em>, <b>17</b>, 145-184.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SexualFun")

## Kappa statistics
Kappa(SexualFun)

## Agreement Chart
agreementplot(t(SexualFun), weights = 1)
## Partial Agreement Chart and B-Statistics
agreementplot(t(SexualFun),
              xlab = "Husband's Rating",
              ylab = "Wife's Rating",
              main = "Husband's and Wife's Sexual Fun")
</code></pre>

<hr>
<h2 id='shadings'>Shading-generating Functions for Residual-based Shadings</h2><span id='topic+shadings'></span><span id='topic+shading_hsv'></span><span id='topic+shading_hcl'></span><span id='topic+shading_max'></span><span id='topic+shading_Friendly'></span><span id='topic+shading_Friendly2'></span><span id='topic+shading_Marimekko'></span><span id='topic+shading_diagonal'></span><span id='topic+shading_sieve'></span><span id='topic+shading_binary'></span><span id='topic+hcl2hex'></span>

<h3>Description</h3>

<p>Shading-generating functions for computing residual-based shadings 
for mosaic and association plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shading_hcl(observed, residuals = NULL, expected = NULL, df = NULL,
  h = NULL, c = NULL, l = NULL, interpolate = c(2, 4), lty = 1,
  eps = NULL, line_col = "black", p.value = NULL, level = 0.95, ...)

shading_hsv(observed, residuals = NULL, expected = NULL, df = NULL,
  h = c(2/3, 0), s = c(1, 0), v = c(1, 0.5),
  interpolate = c(2, 4), lty = 1, eps = NULL, line_col = "black",
  p.value = NULL, level = 0.95, ...)

shading_max(observed = NULL, residuals = NULL, expected = NULL, df = NULL,
  h = NULL, c = NULL, l = NULL, lty = 1, eps = NULL, line_col = "black",
  level = c(0.9, 0.99), n = 1000, ...)

shading_Friendly(observed = NULL, residuals = NULL, expected = NULL, df = NULL,
  h = c(2/3, 0), lty = 1:2, interpolate = c(2, 4),
  eps = 0.01, line_col = "black", ...)

shading_Friendly2(observed = NULL, residuals = NULL,
  expected = NULL, df = NULL, lty = 1:2, interpolate = c(2, 4), eps =
  0.01, line_col = "black", ...)

shading_sieve(observed = NULL, residuals = NULL, expected = NULL, df = NULL,
  h = c(260, 0), lty = 1:2, interpolate = c(2, 4),
  eps = 0.01, line_col = "black", ...)

shading_binary(observed = NULL, residuals = NULL, expected = NULL, df = NULL,
  col = NULL)

shading_Marimekko(x, fill = NULL, byrow = FALSE)

shading_diagonal(x, fill = NULL)

hcl2hex(h = 0, c = 35, l = 85, fixup = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shadings_+3A_observed">observed</code></td>
<td>
<p>contingency table of observed values</p>
</td></tr>
<tr><td><code id="shadings_+3A_residuals">residuals</code></td>
<td>
<p>contingency table of residuals</p>
</td></tr>
<tr><td><code id="shadings_+3A_expected">expected</code></td>
<td>
<p>contingency table of expected values</p>
</td></tr>
<tr><td><code id="shadings_+3A_df">df</code></td>
<td>
<p>degrees of freedom of the associated independence model.</p>
</td></tr>  
<tr><td><code id="shadings_+3A_h">h</code></td>
<td>
<p>hue value in the HCL or HSV color description, has to be
in [0, 360] for HCL and in [0, 1] for HSV colors. The default is
to use blue and red for positive and negative residuals respectively.
In the HCL specification it is <code>c(260, 0)</code> by default and for HSV
<code>c(2/3, 0)</code>.</p>
</td></tr>
<tr><td><code id="shadings_+3A_c">c</code></td>
<td>
<p>chroma value in the HCL color description. This controls the maximum
chroma for significant and non-significant results respectively and defaults 
to <code>c(100, 20)</code>.</p>
</td></tr>
<tr><td><code id="shadings_+3A_l">l</code></td>
<td>
<p>luminance value in the HCL color description. Defaults to <code>c(90, 50)</code>
for small and large residuals respectively.</p>
</td></tr>
<tr><td><code id="shadings_+3A_s">s</code></td>
<td>
<p>saturation value in the HSV color description. Defaults to <code>c(1, 0)</code>
for large and small residuals respectively.</p>
</td></tr>
<tr><td><code id="shadings_+3A_v">v</code></td>
<td>
<p>saturation value in the HSV color description. Defaults to <code>c(1, 0.5)</code>
for significant and non-significant results respectively.</p>
</td></tr>
<tr><td><code id="shadings_+3A_interpolate">interpolate</code></td>
<td>
<p>a specification for mapping the absolute size of the residuals to
a value in [0, 1]. This can be either a function or a numeric vector. In the latter
case, a step function with steps of equal size going from 0 to 1 is used.</p>
</td></tr>
<tr><td><code id="shadings_+3A_lty">lty</code></td>
<td>
<p>a vector of two line types for positive and negative residuals respectively.
Recycled if necessary.</p>
</td></tr>
<tr><td><code id="shadings_+3A_eps">eps</code></td>
<td>
<p>numeric tolerance value below which absolute residuals are considered to be
zero, which is used for coding the border color and line type. If set to <code>NULL</code> (default),
all borders have the default color specified by <code>line\_col</code>.
If set to a numeric value, all border colors corresponding
to residuals with a larger absolute value are set to the full positive or negative
color, respectively;  borders corresponding to smaller residuals are are drawn with
<code>line\_col</code> and <code>lty[1]</code></p>
</td></tr></table>
<p>.  This is used principally in <code>shading\_Friendly</code>.
</p>
<table role = "presentation">
<tr><td><code id="shadings_+3A_line_col">line_col</code></td>
<td>
<p>default border color (for <code>shading_sieve</code>: default sieve color).</p>
</td></tr>
<tr><td><code id="shadings_+3A_p.value">p.value</code></td>
<td>
<p>the <code class="reqn">p</code> value associated with the independence model. By default,
this is computed from a Chi-squared distribution with <code>df</code> degrees of freedom.
<code>p.value</code> can be either a scalar or a <code>function(observed, residuals, expected, df)</code>
that computes the <code class="reqn">p</code> value from the data. If set to <code>NA</code> no inference
is performed.</p>
</td></tr>
<tr><td><code id="shadings_+3A_level">level</code></td>
<td>
<p>confidence level of the test used. If <code>p.value</code> is smaller than
<code>1 - level</code>, bright colors are used, otherwise dark colors are employed. For
<code>shading_max</code> a vector of levels can be supplied. The corresponding critical
values are then used as <code>interpolate</code> cut-offs.</p>
</td></tr>
<tr><td><code id="shadings_+3A_n">n</code></td>
<td>
<p>number of permutations used in the call to <code>coindep_test</code>.</p>
</td></tr>
<tr><td><code id="shadings_+3A_col">col</code></td>
<td>
<p>a vector of two colors for positive and negative residuals respectively.</p>
</td></tr>
<tr><td><code id="shadings_+3A_fixup">fixup</code></td>
<td>
<p>logical. Should the color be corrected to a valid RGB
value before correction?</p>
</td></tr>
<tr><td><code id="shadings_+3A_x">x</code></td>
<td>
<p>object of class <code>table</code> used to determine the
dimension.</p>
</td></tr>
<tr><td><code id="shadings_+3A_fill">fill</code></td>
<td>
<p>Either a character vector of color codes, or a palette
function that generates such a vector. Defaults to
<code><a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a></code></p>
</td></tr>
<tr><td><code id="shadings_+3A_byrow">byrow</code></td>
<td>
<p>logical; shall tiles be filled by row or by column?</p>
</td></tr>
<tr><td><code id="shadings_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+hcl2hex">hcl2hex</a></code>
or <code><a href="grDevices.html#topic+hsv">hsv</a></code>, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These shading-generating functions can be passed to <code>strucplot</code> to generate
residual-based shadings for contingency tables. <code>strucplot</code> calls these
functions with the arguments <code>observed</code>, <code>residuals</code>, <code>expected</code>,
<code>df</code> which give the observed values, residuals, expected values and associated
degrees of freedom for a particular contingency table and associated independence 
model.
</p>
<p>The shadings <code>shading_hcl</code> and <code>shading_hsv</code> do the same thing conceptually,
but use HCL or HSV colors respectively. The former is usually preferred because they
are perceptually based. Both shadings visualize the <em>sign</em> of the residuals of
an independence model using two hues (by default: blue and red). The <em>absolute size</em> of 
the residuals is visualized by the colorfulness and the amount of grey, by default in three categories:
very colorful for large residuals (&gt; 4), less colorful for medium sized residuals (&lt; 4 and &gt; 2),
grey/white for small residuals (&lt; 2). More categories or a continuous scale can
be specified by setting <code>interpolate</code>. Furthermore, the result of a significance
test can be visualized by the amount of grey in the colors. If significant, a colorful
palette is used, if not, the amount of color is reduced.
See Zeileis, Meyer, and Hornik (2007) and <code><a href="colorspace.html#topic+diverge_hcl">diverge_hcl</a></code> for more details.
</p>
<p>The shading <code>shading_max</code> is applicable in 2-way contingency tables and uses
a similar strategy as <code>shading_hcl</code>. But instead of using the cut-offs 2 and 4,
it employs the critical values for the maximum statistic (by default at 90% and 99%).
Consequently, color in the plot signals a significant result at 90% or 99% significance
level, respectively. The test is carried out by calling <code><a href="#topic+coindep_test">coindep_test</a></code>.
</p>
<p>The shading <code>shading_Friendly</code> is very similar to <code>shading_hsv</code>, but additionally
codes the sign of the residuals by different line types. See Friendly
(1994) for more details. <code>shading_Friendly2</code> and
<code>shading_sieve</code> are similar, but use HCL colors.
</p>
<p>The shading <code>shading_binary</code> just visualizes the sign of the residuals by using
two different colors (default: blue HCL(260, 50, 70) and red HCL(0, 50, 70)).
</p>
<p><code>shading_Marimekko</code> is a simple generating function for
producing, in conjunction with <code><a href="#topic+mosaic">mosaic</a></code>, so-called
<em>Marimekko-charts</em>, which paint the tiles of each columns of a
mosaic display in the same color to better display departures from
independence.
</p>
<p><code>shading_diagonal</code> generates a color shading for basically square
matrices (or arrays having the first two dimensons of same length)
visualizing the diagonal cells, and the off-diagonal cells 1, 2, ...
steps removed.
</p>
<p>The color implementations employed are <code><a href="grDevices.html#topic+hsv">hsv</a></code>
from base R and <code><a href="colorspace.html#topic+polarLUV">polarLUV</a></code> from the <span class="pkg">colorspace</span>
package, respectively. To transform the HCL coordinates to
a hexadecimal color string (as returned by <code>hsv</code>), the function
<code><a href="colorspace.html#topic+hex">hex</a></code> is employed. A convenience wrapper <code>hcl2hex</code>
is provided.
</p>


<h3>Value</h3>

<p>A shading function which takes only a single argument, interpreted as a
vector/table of residuals, and returns a <code>"gpar"</code> object with the
corresponding vector(s)/table(s) of graphical parameter(s).
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>References</h3>

<p>Friendly M. (1994),
Mosaic Displays for Multi-Way Contingency Tables.
<em>Journal of the American Statistical Association</em>,
<b>89</b>, 190&ndash;200.
</p>
<p>Meyer D., Zeileis A., and Hornik K. (2006),
The Strucplot Framework: Visualizing Multi-Way Contingency Tables with <span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17</b>(3), 1&ndash;48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a>. See also <code>vignette("strucplot", package = "vcd")</code>.
</p>
<p>Zeileis A., Meyer D., Hornik K. (2007), Residual-Based Shadings for Visualizing
(Conditional) Independence. <em>Journal of Computational and Graphical Statistics</em>,
<b>16</b>, 507&ndash;525.
</p>
<p>Zeileis A., Hornik K. and Murrell P. (2008),
Escaping RGBland: Selecting Colors for Statistical Graphics.
<em>Computational Statistics &amp; Data Analysis</em>, <b>53</b>, 3259&ndash;3270.
Preprint available from <a href="https://www.zeileis.org/papers/Zeileis+Hornik+Murrell-2009.pdf">https://www.zeileis.org/papers/Zeileis+Hornik+Murrell-2009.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="colorspace.html#topic+hex">hex</a></code>,
<code><a href="colorspace.html#topic+polarLUV">polarLUV</a></code>,
<code><a href="grDevices.html#topic+hsv">hsv</a></code>,
<code><a href="#topic+mosaic">mosaic</a></code>,
<code><a href="#topic+assoc">assoc</a></code>,
<code><a href="#topic+strucplot">strucplot</a></code>,
<code><a href="colorspace.html#topic+diverge_hcl">diverge_hcl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load Arthritis data
data("Arthritis")
art &lt;- xtabs(~Treatment + Improved, data = Arthritis)

## plain mosaic display without shading
mosaic(art)

## with shading for independence model
mosaic(art, shade = TRUE)
## which uses the HCL shading
mosaic(art, gp = shading_hcl)
## the residuals are too small to have color,
## hence the cut-offs can be modified
mosaic(art, gp = shading_hcl, gp_args = list(interpolate = c(1, 1.8)))
## the same with the Friendly palette 
## (without significance testing)
mosaic(art, gp = shading_Friendly, gp_args = list(interpolate = c(1, 1.8)))

## assess independence using the maximum statistic
## cut-offs are now critical values for the test statistic
mosaic(art, gp = shading_max)

## association plot with shading as in base R
assoc(art, gp = shading_binary(col = c(1, 2)))

## Marimekko Chart
hec &lt;- margin.table(HairEyeColor, 1:2)
mosaic(hec, gp = shading_Marimekko(hec))
mosaic(HairEyeColor, gp = shading_Marimekko(HairEyeColor))

## Diagonal cells shading
ac &lt;- xtabs(VisualAcuity)
mosaic(ac, gp = shading_diagonal(ac))

</code></pre>

<hr>
<h2 id='sieve'>Extended Sieve Plots</h2><span id='topic+sieve'></span><span id='topic+sieve.default'></span><span id='topic+sieve.formula'></span>

<h3>Description</h3>

<p>(Extended) sieve displays for n-way contingency tables: plots rectangles with
areas proportional to the expected cell frequencies and filled with a
number of squares equal to the observed frequencies.  Thus, the
densities visualize the deviations of the observed from the expected
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
sieve(x, condvars = NULL, gp = NULL, shade = NULL,
  legend = FALSE, split_vertical = NULL, direction = NULL, spacing = NULL,
  spacing_args = list(), sievetype = c("observed","expected"),
  gp_tile = gpar(), scale = 1, main = NULL, sub = NULL, ...)
## S3 method for class 'formula'
sieve(formula, data, ..., main = NULL, sub = NULL, subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sieve_+3A_x">x</code></td>
<td>
<p>a contingency table in array form, with optional category
labels specified in the <code>dimnames(x)</code> attribute.</p>
</td></tr>
<tr><td><code id="sieve_+3A_condvars">condvars</code></td>
<td>
<p>vector of integers or character strings indicating
conditioning variables, if any. The table will be permuted to order
them first.</p>
</td></tr>
<tr><td><code id="sieve_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the variables used to create a 
contingency table from <code>data</code>.  For convenience, conditioning
formulas can be specified; the conditioning variables will then be
used first for splitting.  Formulas for sieve displays (unlike
those for doubledecker plots) have no response variable.</p>
</td></tr>
<tr><td><code id="sieve_+3A_data">data</code></td>
<td>
<p>either a data frame, or an object of class <code>"table"</code>
or <code>"ftable"</code>.</p>
</td></tr>
<tr><td><code id="sieve_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="sieve_+3A_shade">shade</code></td>
<td>
<p>logical specifying whether <code>gp</code> should be used or not
(see <code>gp</code>). If <code>TRUE</code> and <code>expected</code> is unspecified,
a default model is fitted: if <code>condvars</code> is specified, a
corresponding conditional independence model, and else the total
independence model. If <code>shade</code> is <code>NULL</code> (default),
<code>gp</code> is used if specified.</p>
</td></tr>
<tr><td><code id="sieve_+3A_sievetype">sievetype</code></td>
<td>
<p>logical indicating whether rectangles should be filled
according to <code>observed</code> or <code>expected</code> frequencies.</p>
</td></tr>
<tr><td><code id="sieve_+3A_gp">gp</code></td>
<td>
<p>object of class <code>"gpar"</code>, shading function or a
corresponding generating function (see details of <code><a href="#topic+strucplot">strucplot</a></code> and
<code><a href="#topic+shadings">shadings</a></code>). Components of <code>"gpar"</code>
objects are recycled as needed along the last splitting
dimension. The default is a modified version of
<code><a href="#topic+shading_Friendly">shading_Friendly</a></code>:
if <code>sievetype</code> is <code>"observed"</code>, cells with positive
residuals are painted with a red sieve, and cells with negative residuals
with a blue one.
If <code>sievetype</code> is <code>"expected"</code>, the sieves' color is
gray. Ignored if <code>shade = FALSE</code>.</p>
</td></tr>
<tr><td><code id="sieve_+3A_gp_tile">gp_tile</code></td>
<td>
<p>object of class <code>"gpar"</code>, controlling the
appearance of all <em>static</em>
elements of the cells (e.g., border and fill color).</p>
</td></tr>
<tr><td><code id="sieve_+3A_scale">scale</code></td>
<td>
<p>scaling factor for the sieve.</p>
</td></tr>
<tr><td><code id="sieve_+3A_legend">legend</code></td>
<td>
<p>either a legend-generating function, a legend
function (see details of <code><a href="#topic+strucplot">strucplot</a></code> and
<code><a href="#topic+legends">legends</a></code>), or a logical value.
If <code>legend</code> is <code>NULL</code> or <code>TRUE</code> and <code>gp</code> is a
function, legend defaults to <code><a href="#topic+legend_resbased">legend_resbased</a></code>.</p>
</td></tr>
<tr><td><code id="sieve_+3A_split_vertical">split_vertical</code></td>
<td>
<p>vector of logicals of length <code class="reqn">k</code>, where <code class="reqn">k</code>
is the number of margins of <code>x</code> (default: <code>FALSE</code>).
Values are recycled as needed. 
A <code>TRUE</code> component indicates that the tile(s) of the
corresponding dimension should be split vertically, <code>FALSE</code>
means horizontal splits.
Ignored if <code>direction</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sieve_+3A_direction">direction</code></td>
<td>
<p>character vector of length <code class="reqn">k</code>, where <code class="reqn">k</code> is the
number of margins of <code>x</code> (values are recycled as needed).
For each component, a value of <code>"h"</code> indicates that the tile(s)
of the corresponding dimension should be split horizontally, whereas
<code>"v"</code> indicates vertical split(s).</p>
</td></tr>
<tr><td><code id="sieve_+3A_spacing">spacing</code></td>
<td>
<p>spacing object, spacing function, or corresponding
generating function (see <code><a href="#topic+strucplot">strucplot</a></code> for more
information).
The default is no spacing at all if <code>x</code> has two dimensions,
and  <code>spacing_increase</code> for more dimensions.</p>
</td></tr>
<tr><td><code id="sieve_+3A_spacing_args">spacing_args</code></td>
<td>
<p>list of arguments for the generating function, if
specified (see <code><a href="#topic+strucplot">strucplot</a></code> for more information).</p>
</td></tr>
<tr><td><code id="sieve_+3A_main">main</code>, <code id="sieve_+3A_sub">sub</code></td>
<td>
<p>either a logical, or a character string used for plotting
the main (sub) title.  If logical and <code>TRUE</code>, the
name of the <code>data</code> object is used.</p>
</td></tr>
<tr><td><code id="sieve_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+strucplot">strucplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sieve</code> is a generic function which currently has a default method and a
formula interface.  Both are high-level interfaces to the
<code><a href="#topic+strucplot">strucplot</a></code> function, and produce (extended) sieve
displays.  Most of the functionality is described there, such as
specification of the independence model, labeling, legend, spacing,
shading, and other graphical parameters.
</p>
<p>The layout is very flexible: the specification of shading, labeling,
spacing, and legend is modularized (see <code><a href="#topic+strucplot">strucplot</a></code> for
details).
</p>


<h3>Value</h3>

<p>The <code>"structable"</code> visualized is returned invisibly.
</p>


<h3>Note</h3>

<p>To be faithful to the original definition by Riedwyl &amp; Schüpbach,
the default is to have no spacing between the tiles for two-way tables.</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>H. Riedwyl &amp; M. Schüpbach (1994),
Parquet diagram to plot contingency tables.
In F. Faulbaum (ed.),
<em>Softstat '93: Advances in Statistical Software</em>, 293&ndash;299.
Gustav Fischer, New York.
</p>
<p>M. Friendly (2000),
Visualizing Categorical Data,
SAS Institute, Cary, NC.
</p>
<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assoc">assoc</a></code>,
<code><a href="#topic+strucplot">strucplot</a></code>,
<code><a href="#topic+mosaic">mosaic</a></code>,
<code><a href="#topic+structable">structable</a></code>,
<code><a href="#topic+doubledecker">doubledecker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HairEyeColor")

## aggregate over 'sex':
(haireye &lt;- margin.table(HairEyeColor, c(2,1)))

## plot expected values:
sieve(haireye, sievetype = "expected", shade = TRUE)

## plot observed table:
sieve(haireye, shade = TRUE)

## plot complete diagram:
sieve(HairEyeColor, shade = TRUE)

## example with observed values in the cells:
sieve(haireye, shade = TRUE, labeling = labeling_values,
               gp_text = gpar(fontface = 2))

## example with expected values in the cells:
sieve(haireye, shade = TRUE, labeling = labeling_values,
               value_type = "expected", gp_text = gpar(fontface = 2))

## an example for the formula interface:
data("VisualAcuity")
sieve(Freq ~ right + left,  data = VisualAcuity)

</code></pre>

<hr>
<h2 id='SpaceShuttle'>Space Shuttle O-ring Failures</h2><span id='topic+SpaceShuttle'></span>

<h3>Description</h3>

<p>Data from Dalal et al. (1989) about O-ring failures in the NASA space
shuttle program.  The damage index comes from a discussion of the data
by Tufte (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("SpaceShuttle")
</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations and 6 variables.
</p>

<dl>
<dt>FlightNumber</dt><dd><p>Number of space shuttle flight.</p>
</dd>
<dt>Temperature</dt><dd><p>temperature during start (in degrees F).</p>
</dd>
<dt>Pressure</dt><dd><p>pressure.</p>
</dd>
<dt>Fail</dt><dd><p>did any O-ring failures occur? (no, yes).</p>
</dd>
<dt>nFailures</dt><dd><p>how many (of six) 0-rings failed?.</p>
</dd>
<dt>Damage</dt><dd><p>damage index.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Michael Friendly (2000),
Visualizing Categorical Data:
<a href="http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/orings.sas">http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/orings.sas</a>
</p>


<h3>References</h3>

<p>S. Dalal, E. B. Fowlkes, B. Hoadly (1989),
Risk analysis of the space shuttle: Pre-Challenger prediction of
failure,
<em>Journal of the American Statistical Association</em>,
<b>84</b>, 945&ndash;957.
</p>
<p>E. R. Tufte (1997),
<em>Visual Explanations: Images and Quantities, Evidence and
Narrative</em>.
Graphics Press, Cheshire, CT. 
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SpaceShuttle")
plot(nFailures/6 ~ Temperature, data = SpaceShuttle,
     xlim = c(30, 81), ylim = c(0,1),
     main = "NASA Space Shuttle O-Ring Failures",
     ylab = "Estimated failure probability",
     pch = 19, col = 4)
fm &lt;- glm(cbind(nFailures, 6 - nFailures) ~ Temperature,
          data = SpaceShuttle,
          family = binomial)
lines(30 : 81,
      predict(fm, data.frame(Temperature = 30 : 81), type = "re"),
      lwd = 2)
abline(v = 31, lty = 3)
</code></pre>

<hr>
<h2 id='spacings'>Spacing-generating Functions</h2><span id='topic+spacings'></span><span id='topic+spacing_highlighting'></span><span id='topic+spacing_equal'></span><span id='topic+spacing_dimequal'></span><span id='topic+spacing_increase'></span><span id='topic+spacing_conditional'></span>

<h3>Description</h3>

<p>These functions generate spacing functions to be used with
<code><a href="#topic+strucplot">strucplot</a></code> to obtain customized spaces between the
elements of a strucplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spacing_equal(sp = unit(0.3, "lines"))
spacing_dimequal(sp)
spacing_increase(start = unit(0.3, "lines"), rate = 1.5)
spacing_conditional(sp = unit(0.3, "lines"), start = unit(2, "lines"), rate = 1.8)
spacing_highlighting(start = unit(0.2, "lines"), rate = 1.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spacings_+3A_start">start</code></td>
<td>
<p>object of class <code>"unit"</code> indicating the start value
for increasing spacings.</p>
</td></tr>
<tr><td><code id="spacings_+3A_rate">rate</code></td>
<td>
<p>increase rate for spacings.</p>
</td></tr>
<tr><td><code id="spacings_+3A_sp">sp</code></td>
<td>
<p>object of class <code>"unit"</code> specifying a fixed spacing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These generating functions return a function used by
<code><a href="#topic+strucplot">strucplot</a></code> to generate appropriate spaces between tiles of
a strucplot, using the <code>dimnames</code> information of the visualized
table.
</p>
<p><code>spacing_equal</code> allows to specify one fixed space for <em>all</em>
dimensions.
</p>
<p><code>spacing_dimequal</code> allows to specify a fixed space for
<em>each</em> dimension.
</p>
<p><code>spacing_increase</code> creates increasing spaces for all dimensions,
based on a starting value and an increase rate.
</p>
<p><code>spacing_conditional</code> combines <code>spacing_equal</code> and
<code>spacing_increase</code> to create fixed spaces for conditioned
dimensions, and increasing spaces for conditioning dimensions.
</p>
<p><code>spacing_highlighting</code> is essentially <code>spacing_conditional</code> but with
the space of the last dimension set to 0. With a corresponding color
scheme, this gives the impression of the last class being
&lsquo;highlighted&rsquo; in the penultimate class (as, e.g., in
<code><a href="#topic+doubledecker">doubledecker</a></code> plots).
</p>


<h3>Value</h3>

<p>A spacing function with arguments:
</p>
<table role = "presentation">
<tr><td><code>d</code></td>
<td>
<p><code>"dim"</code> attribute of a contingency table.</p>
</td></tr>
<tr><td><code>condvars</code></td>
<td>
<p>index vector of conditioning dimensions (currently only used by
<code>spacing_conditional</code>).</p>
</td></tr>
</table>
<p>This function computes a list of objects of class <code>"unit"</code>.
Each list element contains the spacing information for the
corresponding dimension of the table.  The length of the
<code>"unit"</code> objects is <code class="reqn">k-1</code>, <code class="reqn">k</code> number of levels of the
corresponding factor.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strucplot">strucplot</a></code>,
<code><a href="#topic+doubledecker">doubledecker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Titanic")
strucplot(Titanic, spacing = spacing_increase(start = 0.5, rate = 1.5))
strucplot(Titanic, spacing = spacing_equal(1))
strucplot(Titanic, spacing = spacing_dimequal(1:4 / 4))
strucplot(Titanic, spacing = spacing_highlighting,
                   gp = gpar(fill = c("light gray","dark gray")))
data("PreSex")
strucplot(aperm(PreSex, c(1,4,2,3)), spacing = spacing_conditional,
          condvars = 2)  
</code></pre>

<hr>
<h2 id='spine'>Spine Plots and Spinograms</h2><span id='topic+spine'></span><span id='topic+spine.default'></span><span id='topic+spine.formula'></span>

<h3>Description</h3>

<p>Spine plots are a special cases of mosaic plots, and can be seen as
a generalization of stacked (or highlighted) bar plots. Analogously,
spinograms are an extension of histograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spine(x, ...)
## Default S3 method:
spine(x, y = NULL,
  breaks = NULL, ylab_tol = 0.05, off = NULL,
  main = "", xlab = NULL, ylab = NULL, ylim = c(0, 1), margins = c(5.1, 4.1, 4.1, 3.1),
  gp = gpar(), name = "spineplot", newpage = TRUE, pop = TRUE,
  ...)
## S3 method for class 'formula'
spine(formula, data = list(),
  breaks = NULL, ylab_tol = 0.05, off = NULL,
  main = "", xlab = NULL, ylab = NULL, ylim = c(0, 1), margins = c(5.1, 4.1, 4.1, 3.1),
  gp = gpar(), name = "spineplot", newpage = TRUE, pop = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spine_+3A_x">x</code></td>
<td>
<p>an object, the default method expects either a single variable
(interpreted to be the explanatory variable) or a 2-way table. See details.</p>
</td></tr>
<tr><td><code id="spine_+3A_y">y</code></td>
<td>
<p>a <code>"factor"</code> interpreted to be the dependent variable</p>
</td></tr>
<tr><td><code id="spine_+3A_formula">formula</code></td>
<td>
<p>a <code>"formula"</code> of type <code>y ~ x</code> with a single dependent <code>"factor"</code>
and a single explanatory variable.</p>
</td></tr>    
<tr><td><code id="spine_+3A_data">data</code></td>
<td>
<p>an optional data frame.</p>
</td></tr>
<tr><td><code id="spine_+3A_breaks">breaks</code></td>
<td>
<p>if the explanatory variable is numeric, this controls how
it is discretized. <code>breaks</code> is passed to <code><a href="graphics.html#topic+hist">hist</a></code> and can
be a list of arguments.</p>
</td></tr>
<tr><td><code id="spine_+3A_ylab_tol">ylab_tol</code></td>
<td>
<p>convenience tolerance parameter for y-axis annotation.
If the distance between two labels drops under this threshold, they are
plotted equidistantly.</p>
</td></tr>
<tr><td><code id="spine_+3A_off">off</code></td>
<td>
<p>vertical offset between the bars (in per cent). It is fixed to
<code>0</code> for spinograms and defaults to <code>2</code> for spine plots.</p>
</td></tr>
<tr><td><code id="spine_+3A_main">main</code>, <code id="spine_+3A_xlab">xlab</code>, <code id="spine_+3A_ylab">ylab</code></td>
<td>
<p>character strings for annotation</p>
</td></tr>
<tr><td><code id="spine_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y axis</p>
</td></tr>
<tr><td><code id="spine_+3A_margins">margins</code></td>
<td>
<p>margins when calling <code><a href="grid.html#topic+plotViewport">plotViewport</a></code></p>
</td></tr>
<tr><td><code id="spine_+3A_gp">gp</code></td>
<td>
<p>a <code>"gpar"</code> object controlling the grid graphical
parameters of the rectangles. It should specify in particular a vector of
<code>fill</code> colors of the same length as <code>levels(y)</code>. The default is
to call <code><a href="grDevices.html#topic+gray.colors">gray.colors</a></code>.</p>
</td></tr>  
<tr><td><code id="spine_+3A_name">name</code></td>
<td>
<p>name of the plotting viewport.</p>
</td></tr>
<tr><td><code id="spine_+3A_newpage">newpage</code></td>
<td>
<p>logical. Should <code><a href="grid.html#topic+grid.newpage">grid.newpage</a></code> be called 
before plotting?</p>
</td></tr>
<tr><td><code id="spine_+3A_pop">pop</code></td>
<td>
<p>logical. Should the viewport created be popped?</p>
</td></tr>
<tr><td><code id="spine_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="grid.html#topic+plotViewport">plotViewport</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spine</code> creates either a spinogram or a spine plot. It can be called
via <code>spine(x, y)</code> or <code>spine(y ~ x)</code> where <code>y</code> is interpreted
to be the dependent variable (and has to be categorical) and <code>x</code>
the explanatory variable. <code>x</code> can be either categorical (then a spine
plot is created) or numerical (then a spinogram is plotted).
Additionally, <code>spine</code> can also be called with only a single argument
which then has to be a 2-way table, interpreted to correspond to <code>table(x, y)</code>.
</p>
<p>Spine plots are a generalization of stacked bar plots where not the heights
but the widths of the bars corresponds to the relative frequencies of <code>x</code>.
The heights of the bars then correspond to the conditional relative frequencies
of <code>y</code> in every <code>x</code> group. This is a special case of a mosaic plot
with specific spacing and shading.
</p>
<p>Analogously, spinograms extend stacked histograms. As for the histogram,
<code>x</code> is first discretized (using <code><a href="graphics.html#topic+hist">hist</a></code>) and then for the
discretized data a spine plot is created.
</p>


<h3>Value</h3>

<p>The table visualized is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis <a href="mailto:Achim.Zeileis@R-project.org">Achim.Zeileis@R-project.org</a>
</p>


<h3>References</h3>

<p>Hummel, J. (1996), Linked bar charts: Analysing categorical data graphically.
<em>Computational Statistics</em>, <b>11</b>, 23&ndash;33.
</p>
<p>Hofmann, H., Theus, M. (2005), <em>Interactive graphics for visualizing
conditional distributions</em>, Unpublished Manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cd_plot">cd_plot</a></code>, <code><a href="#topic+mosaic">mosaic</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Arthritis data (dependence on a categorical variable)
data("Arthritis")
(spine(Improved ~ Treatment, data = Arthritis))

## Arthritis data (dependence on a numerical variable)
(spine(Improved ~ Age, data = Arthritis, breaks = 5))
(spine(Improved ~ Age, data = Arthritis, breaks = quantile(Arthritis$Age)))
(spine(Improved ~ Age, data = Arthritis, breaks = "Scott"))

## Space shuttle data (dependence on a numerical variable)
data("SpaceShuttle")
(spine(Fail ~ Temperature, data = SpaceShuttle, breaks = 3))
</code></pre>

<hr>
<h2 id='struc_assoc'>Core-generating Function for Association Plots</h2><span id='topic+struc_assoc'></span>

<h3>Description</h3>

<p>Core-generating function for <code>strucplot</code> returning a function
producing association plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struc_assoc(compress = TRUE, xlim = NULL, ylim = NULL,
  yspace = unit(0.5, "lines"), xscale = 0.9, gp_axis = gpar(lty = 3))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="struc_assoc_+3A_compress">compress</code></td>
<td>
<p>logical; if <code>FALSE</code>, the space between the rows
(columns) are chosen such that the <em>total</em> heights (widths) of
the rows (column) are all equal.  If <code>TRUE</code>, the space between
the rows and columns is fixed and hence the plot is more
&ldquo;compressed&rdquo;.</p>
</td></tr> 
<tr><td><code id="struc_assoc_+3A_xlim">xlim</code></td>
<td>
<p>either a <code class="reqn">2 \times k</code> matrix of doubles,
<code class="reqn">k</code> the number of total columns of the plot, or a recycled
vector from which such a matrix will be constructed.
The columns of <code>xlim</code> correspond to the columns of the
association plot, the rows describe the column ranges (minimums in
the first row, maximums in the second row).
If <code>xlim</code> is <code>NULL</code>, the ranges are determined from the
residuals according to <code>compress</code> (if <code>TRUE</code>: widest range
from each column, if <code>FALSE</code>: from the whole association plot
matrix).</p>
</td></tr>
<tr><td><code id="struc_assoc_+3A_ylim">ylim</code></td>
<td>
<p>either a <code class="reqn">2 \times k</code> matrix of doubles,
<code class="reqn">k</code> the number of total rows of the plot, or a recycled vector
from which such a matrix will be constructed.
The columns of <code>ylim</code> correspond to the rows of the association
plot, the rows describe the column ranges (minimums in the first
row, maximums in the second row).
If <code>ylim</code> is <code>NULL</code>, the ranges are determined from the
residuals according to <code>compress</code> (if <code>TRUE</code>: widest range
from each row, if <code>FALSE</code>: from the whole association plot
matrix).</p>
</td></tr>
<tr><td><code id="struc_assoc_+3A_xscale">xscale</code></td>
<td>
<p>scale factor resizing the tile's width, thus adding
additional space between the tiles. </p>
</td></tr>
<tr><td><code id="struc_assoc_+3A_yspace">yspace</code></td>
<td>
<p>object of class <code>"unit"</code> specifying additional
space separating the rows.</p>
</td></tr>
<tr><td><code id="struc_assoc_+3A_gp_axis">gp_axis</code></td>
<td>
<p>object of class <code>"gpar"</code> specifying the visual
aspects of the tiles' baseline.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually called by <code>strucplot</code> (typically when
called by <code>assoc</code>) and returns a function used by
<code>strucplot</code> to produce association plots. 
</p>


<h3>Value</h3>

<p>A function with arguments:
</p>
<table role = "presentation">
<tr><td><code>residuals</code></td>
<td>
<p>table of residuals.</p>
</td></tr>
<tr><td><code>observed</code></td>
<td>
<p>not used by <code>struc_assoc</code>.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>table of expected frequencies.</p>
</td></tr>
<tr><td><code>spacing</code></td>
<td>
<p>object of class <code>"unit"</code> specifying the space
between the tiles.</p>
</td></tr>
<tr><td><code>gp</code></td>
<td>
<p>list of <code>gpar</code> objects used for the drawing the tiles.</p>
</td></tr>
<tr><td><code>split_vertical</code></td>
<td>
<p>vector of logicals indicating, for each
dimension of the table, the split direction.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Cohen, A. (1980),
On the graphical display of the significant components in a two-way
contingency table.
<em>Communications in Statistics&mdash;Theory and Methods</em>, <b>A9</b>,
1025&ndash;1041.
</p>
<p>Friendly, M. (1992),
Graphical methods for categorical data.
<em>SAS User Group International Conference Proceedings</em>, <b>17</b>,
190&ndash;200.
<a href="http://datavis.ca/papers/sugi/sugi17.pdf">http://datavis.ca/papers/sugi/sugi17.pdf</a>
</p>
<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assoc">assoc</a></code>,
<code><a href="#topic+strucplot">strucplot</a></code>,
<code><a href="#topic+structable">structable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## UCB Admissions
data("UCBAdmissions")
ucb &lt;- aperm(UCBAdmissions)

## association plot for conditional independence
strucplot(ucb, expected = ~ Dept * (Admit + Gender),
  core = struc_assoc(ylim = c(-4, 4)), labeling_args = list(abbreviate_labs = c(Admit = 3)))
</code></pre>

<hr>
<h2 id='struc_mosaic'>Core-generating Function for Mosaic Plots</h2><span id='topic+struc_mosaic'></span>

<h3>Description</h3>

<p>Core-generating function for <code>strucplot</code> returning a function
producing mosaic plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struc_mosaic(zero_size = 0.5, zero_split = FALSE, zero_shade = TRUE,
             zero_gp = gpar(col = 0), panel = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="struc_mosaic_+3A_zero_size">zero_size</code></td>
<td>
<p>size of the bullets used for zero-entries in the
contingency table (if 0, no bullets are drawn).</p>
</td></tr> 
<tr><td><code id="struc_mosaic_+3A_zero_split">zero_split</code></td>
<td>
<p>logical controlling whether zero cells should be
further split. If <code>FALSE</code> and <code>zero_shade</code> is
<code>FALSE</code>, only one bullet is drawn (centered) for unsplit
zero cells. If <code>FALSE</code> and <code>zero_shade</code> is
<code>TRUE</code>, a bullet for each zero cell is drawn to allow, e.g.,
residual-based shadings to be effective also for zero cells.</p>
</td></tr>
<tr><td><code id="struc_mosaic_+3A_zero_shade">zero_shade</code></td>
<td>
<p>logical controlling whether zero bullets should be
shaded.</p>
</td></tr>
<tr><td><code id="struc_mosaic_+3A_zero_gp">zero_gp</code></td>
<td>
<p>object of class <code>"gpar"</code> used
for zero bullets in case they are <em>not</em> shaded.</p>
</td></tr>
<tr><td><code id="struc_mosaic_+3A_panel">panel</code></td>
<td>
<p>Optional function with arguments: <code>residuals</code>,
<code>observed</code>, <code>expected</code>, <code>index</code>, <code>gp</code>, and
<code>name</code> called by the
<code>struc_mosaic</code> workhorse for each tile that is drawn in the
mosaic. <code>index</code> is an integer vector with the tile's
coordinates in the contingency table, <code>gp</code> a <code>gpar</code> object
for the tile, and <code>name</code> a label to be assigned to the drawn
grid object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually called by <code><a href="#topic+strucplot">strucplot</a></code> (typically
when called by <code><a href="#topic+mosaic">mosaic</a></code>) and returns a function used by
<code><a href="#topic+strucplot">strucplot</a></code> to produce mosaic plots. 
</p>


<h3>Value</h3>

<p>A function with arguments:
</p>
<table role = "presentation">
<tr><td><code>residuals</code></td>
<td>
<p>table of residuals.</p>
</td></tr>
<tr><td><code>observed</code></td>
<td>
<p>table of observed values.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>not used by <code>struc_mosaic</code>.</p>
</td></tr>
<tr><td><code>spacing</code></td>
<td>
<p>object of class <code>"unit"</code> specifying the space
between the tiles.</p>
</td></tr>
<tr><td><code>gp</code></td>
<td>
<p>list of <code>gpar</code> objects used for the drawing the tiles.</p>
</td></tr>
<tr><td><code>split_vertical</code></td>
<td>
<p>vector of logicals indicating, for each
dimension of the table, the split direction.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Cohen, A. (1980),
On the graphical display of the significant components in a two-way
contingency table.
<em>Communications in Statistics&mdash;Theory and Methods</em>, <b>A9</b>,
1025&ndash;1041.
</p>
<p>Friendly, M. (1992),
Graphical methods for categorical data.
<em>SAS User Group International Conference Proceedings</em>, <b>17</b>,
190&ndash;200.
<a href="http://datavis.ca/papers/sugi/sugi17.pdf">http://datavis.ca/papers/sugi/sugi17.pdf</a>
</p>
<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mosaic">mosaic</a></code>,
<code><a href="#topic+strucplot">strucplot</a></code>,
<code><a href="#topic+structable">structable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Titanic data
data("Titanic")
## mosaic plot with large zeros
strucplot(Titanic, core = struc_mosaic(zero_size = 1))
</code></pre>

<hr>
<h2 id='struc_sieve'>Core-generating Function for Sieve Plots</h2><span id='topic+struc_sieve'></span>

<h3>Description</h3>

<p>Core-generating function for <code>strucplot</code> returning a function
producing sieve plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struc_sieve(sievetype = c("observed","expected"), gp_tile = gpar(),
scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="struc_sieve_+3A_sievetype">sievetype</code></td>
<td>
<p>logical indicating whether rectangles should be filled
according to <code>observed</code> or <code>expected</code> frequencies.</p>
</td></tr>
<tr><td><code id="struc_sieve_+3A_gp_tile">gp_tile</code></td>
<td>
<p>object of class <code>"gpar"</code>, controlling the
appearance of all <em>static</em>
elements of the cells (e.g., border and fill color).</p>
</td></tr>
<tr><td><code id="struc_sieve_+3A_scale">scale</code></td>
<td>
<p>Scaling factor for the sieve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually called by <code><a href="#topic+strucplot">strucplot</a></code> (typically
when called by <code><a href="#topic+sieve">sieve</a></code>) and returns a function used by
<code><a href="#topic+strucplot">strucplot</a></code> to produce sieve plots. 
</p>


<h3>Value</h3>

<p>A function with arguments:
</p>
<table role = "presentation">
<tr><td><code>residuals</code></td>
<td>
<p>table of residuals.</p>
</td></tr>
<tr><td><code>observed</code></td>
<td>
<p>table of observed values.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>not used by <code>struc_sieve</code>.</p>
</td></tr>
<tr><td><code>spacing</code></td>
<td>
<p>object of class <code>"unit"</code> specifying the space
between the tiles.</p>
</td></tr>
<tr><td><code>gp</code></td>
<td>
<p>list of <code>gpar</code> objects used for the drawing the tiles.</p>
</td></tr>
<tr><td><code>split_vertical</code></td>
<td>
<p>vector of logicals indicating, for each
dimension of the table, the split direction.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Riedwyl, H., and Schüpbach, M. (1994),
Parquet diagram to plot contingency tables.
In F. Faulbaum (ed.),
<em>Softstat '93: Advances in Statistical Software</em>, 293&ndash;299.
Gustav Fischer, New York.
</p>
<p>Friendly, M. (2000),
Visualizing Categorical Data,
SAS Institute, Cary, NC.
</p>
<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sieve">sieve</a></code>,
<code><a href="#topic+strucplot">strucplot</a></code>,
<code><a href="#topic+structable">structable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Titanic data
data("Titanic")
strucplot(Titanic, core = struc_sieve)
</code></pre>

<hr>
<h2 id='strucplot'>Structured Displays of Contingency Tables</h2><span id='topic+strucplot'></span>

<h3>Description</h3>

<p>This modular function visualizes certain aspects of high-dimensional
contingency tables in a hierarchical way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strucplot(x, residuals = NULL, expected = NULL,
  condvars = NULL, shade = NULL, type = c("observed", "expected"),
  residuals_type = NULL, df = NULL, split_vertical = NULL, 
  spacing = spacing_equal, spacing_args = list(),
  gp = NULL, gp_args = list(),
  labeling = labeling_border, labeling_args = list(),
  core = struc_mosaic, core_args = list(),
  legend = NULL, legend_args = list(),
  main = NULL, sub = NULL, margins = unit(3, "lines"),
  title_margins = NULL, legend_width = NULL,
  main_gp = gpar(fontsize = 20), sub_gp = gpar(fontsize = 15),
  newpage = TRUE, pop = TRUE, return_grob = FALSE,
  keep_aspect_ratio = NULL, prefix = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strucplot_+3A_x">x</code></td>
<td>
<p>a contingency table in array form, with optional category
labels specified in the <code>dimnames</code> attribute.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_residuals">residuals</code></td>
<td>
<p>optionally, an array of residuals of the same dimension
as <code>x</code> (see details).</p>
</td></tr>
<tr><td><code id="strucplot_+3A_expected">expected</code></td>
<td>
<p>optionally, an array of expected values of the same dimension
as <code>x</code>, or alternatively the corresponding independence model specification
as used by <code><a href="stats.html#topic+loglin">loglin</a></code> or <code><a href="MASS.html#topic+loglm">loglm</a></code>
(see details).</p>
</td></tr>
<tr><td><code id="strucplot_+3A_df">df</code></td>
<td>
<p>degrees of freedom passed to the shading functions
used for inference. Will be calculated (and overwritten if
specified) if both <code>expected</code> and
<code>residuals</code> are <code>NULL</code>, or if <code>expected</code> is given a formula.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_condvars">condvars</code></td>
<td>
<p>number of conditioning variables, if any; those are
expected to be ordered first in the table.
This information is used for computing the expected values, and is
also passed to the spacing functions (see <code><a href="#topic+spacings">spacings</a></code>).</p>
</td></tr>
<tr><td><code id="strucplot_+3A_shade">shade</code></td>
<td>
<p>logical specifying whether <code>gp</code> should be used or not
(see <code>gp</code>). If <code>TRUE</code> and <code>expected</code> is unspecified,
a default model is fitted: if <code>condvars</code> is specified, a
corresponding conditional independence model, and else the total
independence model.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_residuals_type">residuals_type</code></td>
<td>
<p>a character string indicating the type of
residuals to be computed when none are supplied.
If <code>residuals</code> is <code>NULL</code>, <code>residuals_type</code> must
be one of <code>"pearson"</code> (default; giving components of Pearson's
chi-squared), <code>"deviance"</code> (giving components of the likelihood
ratio chi-squared), or <code>"FT"</code> for the Freeman-Tukey residuals.
The value of this argument can be abbreviated. If <code>residuals</code>
are specified, the value of <code>residuals_type</code> is just passed
&ldquo;as is&rdquo; to the legend function.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_type">type</code></td>
<td>
<p>a character string indicating whether the observed or the
expected values of the table should be visualized.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_split_vertical">split_vertical</code></td>
<td>
<p>vector of logicals of length <code class="reqn">k</code>, where
<code class="reqn">k</code> is the number of margins of <code>x</code> (values are recycled as needed).
A <code>TRUE</code> component indicates that the tile(s) of the
corresponding dimension should be split vertically, <code>FALSE</code>
means horizontal splits. Default is <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="strucplot_+3A_spacing">spacing</code></td>
<td>
<p>spacing object, spacing function, or a corresponding
generating function (see details and <code><a href="#topic+spacings">spacings</a></code>).</p>
</td></tr>
<tr><td><code id="strucplot_+3A_spacing_args">spacing_args</code></td>
<td>
<p>list of arguments for the spacing-generating
function, if specified.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_gp">gp</code></td>
<td>
<p>object of class <code>"gpar"</code>, shading function or a
corresponding generating function (see details and
<code><a href="#topic+shadings">shadings</a></code>). Components of <code>"gpar"</code>
objects are recycled as needed along the last splitting dimension.
Ignored if <code>shade = FALSE</code>.</p>
</td></tr> 
<tr><td><code id="strucplot_+3A_gp_args">gp_args</code></td>
<td>
<p>list of arguments for the shading-generating function,
if specified.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_labeling">labeling</code></td>
<td>
<p>either a logical, or a labeling function, or a corresponding
generating function (see details and <code><a href="#topic+labelings">labelings</a></code>. If
<code>FALSE</code> or <code>NULL</code>, no labeling is produced.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_labeling_args">labeling_args</code></td>
<td>
<p>list of arguments for the labeling-generating
function, if specified.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_core">core</code></td>
<td>
<p>either a core function, or a corresponding generating
function (see details).  Currently, generating functions for
mosaic plots (<code><a href="#topic+struc_mosaic">struc_mosaic</a></code>), association plots
(<code><a href="#topic+struc_assoc">struc_assoc</a></code>), and sieve plots
(<code><a href="#topic+struc_sieve">struc_sieve</a></code>) are provided.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_core_args">core_args</code></td>
<td>
<p>list of arguments for the core-generating function,
if specified.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_legend">legend</code></td>
<td>
<p>either a legend-generating function, or a legend
function (see details and <code><a href="#topic+legends">legends</a></code>), or a logical.
If <code>legend</code> is <code>NULL</code> or <code>TRUE</code> and <code>gp</code> is a
function, legend defaults to <code><a href="#topic+legend_resbased">legend_resbased</a></code>.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_legend_args">legend_args</code></td>
<td>
<p>list of arguments for the legend-generating
function, if specified.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_main">main</code></td>
<td>
<p>either a logical, or a character string used for plotting
the main title.  If <code>main</code> is a logical and <code>TRUE</code>, the
name of the object supplied as <code>x</code> is used.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_sub">sub</code></td>
<td>
<p>a character string used for plotting the subtitle.
If <code>sub</code> is a logical and <code>TRUE</code> and <code>main</code> is unspecified, the
name of the object supplied as <code>x</code> is used.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_margins">margins</code></td>
<td>
<p>either an object of class <code>"unit"</code> of length 4, or
a numeric vector of length 4. The elements are recycled as needed.
The four components specify the top, right,
bottom, and left margin of the plot, respectively.
When a numeric vector is supplied, the numbers are interpreted as
<code>"lines"</code> units.  In addition, the unit or numeric vector
may have named arguments
(&lsquo;<span class="samp">&#8288;top&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;right&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;bottom&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;left&#8288;</span>&rsquo;), in which
case the non-named arguments specify the default values (recycled as
needed), overloaded by the named arguments.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_title_margins">title_margins</code></td>
<td>
<p>either an object of class <code>"unit"</code> of length 2, or
a numeric vector of length 2. The elements are recycled as needed.
The two components specify the top and bottom <em>title</em> margin
of the plot, respectively. The default for each
<em>specified</em> title are 2 lines (and 0 else), except when a
legend is plotted and <code>keep_aspect_ratio</code> is <code>TRUE</code>: in
this case, the default values of both margins are set as to align
the heights of legend and actual plot.
When a numeric vector is supplied, the numbers are interpreted as
<code>"lines"</code> units.  In addition, the unit or numeric vector
may have named arguments (&lsquo;<span class="samp">&#8288;top&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;bottom&#8288;</span>&rsquo;), in which
case the non-named argument specify the default value (recycled as
needed), overloaded by the named arguments.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_legend_width">legend_width</code></td>
<td>
<p>An object of class <code>"unit"</code> of length
1 specifying the width of the legend (if any). Default: 5 lines.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_pop">pop</code></td>
<td>
<p>logical indicating whether the generated viewport tree
should be removed at the end of the drawing or not.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_main_gp">main_gp</code>, <code id="strucplot_+3A_sub_gp">sub_gp</code></td>
<td>
<p>object of class <code>"gpar"</code> containing the graphical
parameters used for the main (sub) title, if specified.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_newpage">newpage</code></td>
<td>
<p>logical indicating whether a new page should be created
for the plot or not.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_return_grob">return_grob</code></td>
<td>
<p>logical. Should a snapshot of the display be
returned as a grid grob?</p>
</td></tr>
<tr><td><code id="strucplot_+3A_keep_aspect_ratio">keep_aspect_ratio</code></td>
<td>
<p>logical indicating whether the aspect ratio should be
fixed or not. If unspecified, the default is <code>TRUE</code> for
two-dimensional tables and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_prefix">prefix</code></td>
<td>
<p>optional character string used as a prefix for the
generated viewport and grob names.</p>
</td></tr>
<tr><td><code id="strucplot_+3A_...">...</code></td>
<td>
<p>For convenience, list of arguments passed to the
labeling-generating function used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function&mdash;usually called by higher-level functions such as
<code><a href="#topic+assoc">assoc</a></code> and <code><a href="#topic+mosaic">mosaic</a></code>&mdash;generates conditioning
plots of contingency tables. First, it sets up a set of viewports for
main- and subtitles, legend, and the actual plot region.  Then,
residuals are computed as needed from observed and expected
frequencies, where the expected frequencies are optionally computed
for a specified independence model.  Finally, the specified functions
for spacing, gp, main plot, legend, and labeling are called to produce
the plot.  The function invisibly returns the <code>"structable"</code> object
visualized.
</p>
<p>Most elements of the plot, such as the core function, the spacing
between the tiles, the shading of the tiles, the labeling, and the
legend, are modularized in graphical appearance control (&ldquo;grapcon&rdquo;)
functions and specified as parameters.  For
each element <em>foo</em> (= <code>spacing</code>, <code>labeling</code>, <code>core</code>,
or <code>legend</code>), <code>strucplot</code> takes two arguments:
<var>foo</var> and <var>foo_args</var>, which can be used to specify the
parameters in the following alternative ways:
</p>

<ol>
<li><p> Passing a suitable function to <var>foo</var> which subsequently
will be called from <code>strucplot</code> to compute shadings, labelings,
etc.
</p>
</li>
<li><p> Passing a corresponding <em>generating</em> function to <var>foo</var>,
along with parameters passed to <var>foo_args</var>, that generates such a
function. Generating functions must inherit from classes
<code>"grapcon_generator"</code> and <code>"<var>foo</var>"</code>.
</p>
</li>
<li><p> Except for the shading functions (<var>shading_bar</var>),
passing <var>foo(foo_args)</var> to the <var>foo</var> argument.
</p>
</li>
<li><p> For shadings and spacings, passing the final parameter object
itself; see the corresponding help pages for more details on the
data structures.
</p>
</li></ol>

<p>If legends are drawn, a &lsquo;cinemascope&rsquo;-like layout is used for
the plot to preserve the 1:1 aspect ratio.
</p>
<p>If <code>type = "expected"</code>, the expected values are passed to the
<code>observed</code> argument of the core function, and the observed
values to the <code>expected</code> argument.
</p>
<p>Although the <code>gp</code> argument is typically used for shading, it can
be used for arbitrary modifications of the tiles' graphics parameters
(e.g., for highlighting particular cells, etc.).
</p>


<h3>Value</h3>

<p>Invisibly, an object of class <code>"structable"</code> corresponding to the
plot. If <code>return_grob</code> is <code>TRUE</code>, additionally, the plot as
a grob object is returned in a <code>grob</code> attribute.
</p>


<h3>Note</h3>

<p>The created viewports, as well as the tiles and bullets, are named and
thus can conveniently be modified after a plot has been drawn (and
<code>pop = FALSE</code>).
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assoc">assoc</a></code>,
<code><a href="#topic+mosaic">mosaic</a></code>,
<code><a href="#topic+sieve">sieve</a></code>,
<code><a href="#topic+struc_assoc">struc_assoc</a></code>,
<code><a href="#topic+struc_sieve">struc_sieve</a></code>,
<code><a href="#topic+struc_mosaic">struc_mosaic</a></code>,
<code><a href="#topic+structable">structable</a></code>,
<code><a href="#topic+doubledecker">doubledecker</a></code>,
<code><a href="#topic+labelings">labelings</a></code>,
<code><a href="#topic+shadings">shadings</a></code>,
<code><a href="#topic+legends">legends</a></code>,
<code><a href="#topic+spacings">spacings</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Titanic")

strucplot(Titanic)
strucplot(Titanic, core = struc_assoc)
strucplot(Titanic, spacing = spacing_increase,
                   spacing_args = list(start = 0.5, rate = 1.5))
strucplot(Titanic, spacing = spacing_increase(start = 0.5, rate = 1.5))

## modify a tile's color
strucplot(Titanic, pop = FALSE)
grid.edit("rect:Class=1st,Sex=Male,Age=Adult,Survived=Yes",
          gp = gpar(fill = "red"))
</code></pre>

<hr>
<h2 id='structable'>Structured Contingency Tables</h2><span id='topic+structable.default'></span><span id='topic+structable.formula'></span><span id='topic+structable'></span><span id='topic+Extract.structable'></span><span id='topic+aperm.structable'></span><span id='topic+t.structable'></span><span id='topic+is.structable'></span><span id='topic+cbind.structable'></span><span id='topic+rbind.structable'></span><span id='topic+length.structable'></span><span id='topic+is.na.structable'></span><span id='topic+as.matrix.structable'></span><span id='topic+as.vector.structable'></span><span id='topic+dim.structable'></span><span id='topic+dimnames.structable'></span><span id='topic+as.table.structable'></span>

<h3>Description</h3>

<p>This function produces a &lsquo;flat&rsquo; representation of a
high-dimensional contingency table constructed by recursive
splits (similar to the construction of mosaic displays).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
structable(formula, data,
direction = NULL, split_vertical = NULL, ..., subset, na.action)
## Default S3 method:
structable(..., direction = NULL, split_vertical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="structable_+3A_formula">formula</code></td>
<td>
<p>a formula object with possibly both left and right hand
sides specifying the column and row variables of the flat table.</p>
</td></tr>
<tr><td><code id="structable_+3A_data">data</code></td>
<td>
<p>a data frame, list or environment containing the variables
to be cross-tabulated, or an object inheriting from class <code>table</code>.</p>
</td></tr>
<tr><td><code id="structable_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.
Ignored if <code>data</code> is a contingency table.</p>
</td></tr>
<tr><td><code id="structable_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.
Ignored if <code>data</code> is a contingency table</p>
</td></tr>
<tr><td><code id="structable_+3A_...">...</code></td>
<td>
<p><span class="rlang"><b>R</b></span> objects which can be interpreted as factors (including
character strings), or a list (or data frame) whose components can
be so interpreted, or a contingency table object of class
<code>"table"</code> or <code>"ftable"</code>.</p>
</td></tr>
<tr><td><code id="structable_+3A_split_vertical">split_vertical</code></td>
<td>
<p>logical vector indicating, for each dimension,
whether it should be split vertically or not (default:
<code>FALSE</code>). Values are recycled as needed.
If the argument is of length 1, the value is alternated
for all dimensions. Ignored if <code>direction</code> is provided.</p>
</td></tr>
<tr><td><code id="structable_+3A_direction">direction</code></td>
<td>
<p>character vector alternatively specifying the
splitting direction (<code>"h"</code> for horizontal and <code>"v"</code> for
vertical splits).  Values are recycled as needed.  If the argument
is of length 1, the value is alternated for all dimensions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces textual representations of mosaic displays, and
thus &lsquo;flat&rsquo; contingency tables. The formula interface is quite
similar to the one of <code><a href="stats.html#topic+ftable">ftable</a></code>, but also accepts the
<code><a href="#topic+mosaic">mosaic</a></code>-like formula interface (empty left-hand
side).  Note that even if the <code><a href="stats.html#topic+ftable">ftable</a></code> interface is used,
the <code>split_vertical</code> or <code>direction</code> argument is needed to
specify the <em>order</em> of the horizontal and vertical splits.
If pretabulated data with a <code>Freq</code> column is used, than the
left-hand side should be left empty&mdash;the <code>Freq</code> column will be
handled correctly.
</p>
<p><code>"structable"</code> objects can be subset using the <code>[</code> and <code>[[</code>
operators, using either level indices or names (see
examples). The corresponding replacement functions are available as well. In
addition, appropriate <code><a href="base.html#topic+aperm">aperm</a></code>, <code><a href="base.html#topic+cbind">cbind</a></code>,
<code><a href="base.html#topic+rbind">rbind</a></code>, <code><a href="base.html#topic+length">length</a></code>, <code><a href="base.html#topic+dim">dim</a></code>, and
<code><a href="base.html#topic+is.na">is.na</a></code> methods do exist. 
</p>


<h3>Value</h3>

<p>An object of class <code>"structable"</code>,
inheriting from class <code>"ftable"</code>, with the splitting
information (<code>"split_vertical"</code>) as additional attribute.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>Meyer, D., Zeileis, A., and Hornik, K. (2006),
The strucplot framework: Visualizing multi-way contingency tables with
<span class="pkg">vcd</span>.
<em>Journal of Statistical Software</em>, <b>17(3)</b>, 1-48.
<a href="https://doi.org/10.18637/jss.v017.i03">doi:10.18637/jss.v017.i03</a> and available as 
<code>vignette("strucplot")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strucplot">strucplot</a></code>,
<code><a href="#topic+mosaic">mosaic</a></code>,
<code><a href="stats.html#topic+ftable">ftable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>structable(Titanic)
structable(Titanic, split_vertical = c(TRUE, TRUE, FALSE, FALSE))
structable(Titanic, direction = c("h","h","v","v"))
structable(Sex + Class ~ Survived + Age, data = Titanic)

## subsetting of structable objects
(hec &lt;- structable(aperm(HairEyeColor)))

## The "[" operator treats structables as a block-matrix and selects parts of the matrix:
hec[1]
hec[2]
hec[1,c(2,4)]
hec["Male",c("Blue","Green")]

## replacement funcion:
tmp &lt;- hec
(tmp[1,2:3] &lt;- tmp[2,c(1,4)])

## In contrast, the "[[" operator treats structables as two-dimensional
## lists. Indexing conditions on specified levels and thus reduces the dimensionality:

## seek subtables conditioning on levels of the first dimension:
hec[[1]]
hec[[2]]

## Seek subtable from the first two dimensions, given the level "Male"
## of the first variable, and "Brown" from the second
## (the following two commands are equivalent):
hec[["Male"]][["Brown"]]
hec[[c("Male","Brown")]]

## Seeking subtables by conditioning on row and/or column variables:
hec[["Male","Hazel"]]
hec[[c("Male","Brown"),]]
hec[[c("Male","Brown"),"Hazel"]]

## a few other operations
t(hec)
dim(hec)
dimnames(hec)
as.matrix(hec)
length(hec)
cbind(hec[,1],hec[,3])

as.vector(hec) ## computed on the _multiway_ table
as.vector(unclass(hec))
</code></pre>

<hr>
<h2 id='Suicide'>Suicide Rates in Germany</h2><span id='topic+Suicide'></span>

<h3>Description</h3>

<p>Data from Heuer (1979) on suicide rates in West Germany classified by
age, sex, and method of suicide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Suicide")
</code></pre>


<h3>Format</h3>

<p>A data frame with 306 observations and 6 variables.
</p>

<dl>
<dt>Freq</dt><dd><p>frequency of suicides.</p>
</dd>
<dt>sex</dt><dd><p>factor indicating sex (male, female).</p>
</dd>
<dt>method</dt><dd><p>factor indicating method used.</p>
</dd>
<dt>age</dt><dd><p>age (rounded).</p>
</dd>
<dt>age.group</dt><dd><p>factor.  Age classified into 5 groups.</p>
</dd>
<dt>method2</dt><dd><p>factor indicating method used (same as <code>method</code>
but some levels are merged).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Michael Friendly (2000),
Visualizing Categorical Data:
<a href="http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/suicide.sas">http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/suicide.sas</a>
</p>


<h3>References</h3>

<p>J. Heuer (1979),
<em>Selbstmord bei Kindern und Jugendlichen</em>.
Ernst Klett Verlag, Stuttgart.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Suicide")
structable(~ sex + method2 + age.group, data = Suicide)
</code></pre>

<hr>
<h2 id='table2d_summary'>Summary of a 2-way Table</h2><span id='topic+table2d_summary'></span><span id='topic+print.table2d_summary'></span>

<h3>Description</h3>

<p>Prints a 2-way contingency table along with percentages, marginal,
and conditional distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table2d_summary(object, margins = TRUE, percentages = FALSE,
  conditionals = c("none", "row", "column"), chisq.test = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table2d_summary_+3A_object">object</code></td>
<td>
<p>a <code class="reqn">r \times c</code>-contingency table</p>
</td></tr>
<tr><td><code id="table2d_summary_+3A_margins">margins</code></td>
<td>
<p>if <code>TRUE</code>, marginal distributions are computed.</p>
</td></tr>
<tr><td><code id="table2d_summary_+3A_percentages">percentages</code></td>
<td>
<p>if <code>TRUE</code>, relative frequencies are computed.</p>
</td></tr>
<tr><td><code id="table2d_summary_+3A_conditionals">conditionals</code></td>
<td>
<p>if not <code>"none"</code>, the conditional
distributions, given the row/column factor, are computed.</p>
</td></tr>
<tr><td><code id="table2d_summary_+3A_chisq.test">chisq.test</code></td>
<td>
<p>if <code>TRUE</code>, a chi-squared test of independence
is carried out.</p>
</td></tr>
<tr><td><code id="table2d_summary_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly a <code class="reqn">r \times c \times k</code>
table, <code class="reqn">k</code> depending on the amount of choices (at most 3).
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mar_table">mar_table</a></code>,
<code><a href="base.html#topic+prop.table">prop.table</a></code>,
<code><a href="#topic+independence_table">independence_table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("UCBAdmissions")
table2d_summary(margin.table(UCBAdmissions, 1:2))
</code></pre>

<hr>
<h2 id='ternaryplot'>Ternary Diagram</h2><span id='topic+ternaryplot'></span>

<h3>Description</h3>

<p>Visualizes compositional, 3-dimensional data in an equilateral
triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ternaryplot(x, scale = 1, dimnames = NULL,
  dimnames_position = c("corner","edge","none"),
  dimnames_color = "black", dimnames_rot = c(-60, 60, 0),
  id = NULL, id_color = "black",
  id_just = c("center", "center"),
  coordinates = FALSE, grid = TRUE, grid_color = "gray",
  labels = c("inside", "outside", "none"),
  labels_color = "darkgray", labels_rot = c(120, -120, 0),
  border = "black", bg = "white",
  pch = 19, cex = 1, prop_size = FALSE, col = "red",
  main = "ternary plot", newpage = TRUE, pop = TRUE,
  return_grob = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ternaryplot_+3A_x">x</code></td>
<td>
<p>a matrix with three columns.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_scale">scale</code></td>
<td>
<p>row sums scale to be used.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_dimnames">dimnames</code></td>
<td>
<p>dimension labels (defaults to the column names of
<code>x</code>).</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_dimnames_position">dimnames_position</code>, <code id="ternaryplot_+3A_dimnames_color">dimnames_color</code></td>
<td>
<p>position and color of
dimension labels.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_dimnames_rot">dimnames_rot</code></td>
<td>
<p>Numeric vector of length 3, specifying the angle
of the dimension labels.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_id">id</code></td>
<td>
<p>optional labels to be plotted below the plot
symbols. <code>coordinates</code> and <code>id</code> are mutual exclusive.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_id_color">id_color</code></td>
<td>
<p>color of these labels.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_id_just">id_just</code></td>
<td>
<p>character vector of length 1 or 2 indicating the
justification of these labels.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_coordinates">coordinates</code></td>
<td>
<p>if <code>TRUE</code>, the coordinates of the points are
plotted below them. <code>coordinates</code> and <code>id</code> are mutual
exclusive.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_grid">grid</code></td>
<td>
<p>if <code>TRUE</code>, a grid is plotted. May optionally
be a string indicating the line type (default: <code>"dotted"</code>).</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_grid_color">grid_color</code></td>
<td>
<p>grid color.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_labels">labels</code>, <code id="ternaryplot_+3A_labels_color">labels_color</code></td>
<td>
<p>position and color of the grid labels.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_labels_rot">labels_rot</code></td>
<td>
<p>Numeric vector of length 3, specifying the angle
of the grid labels.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_border">border</code></td>
<td>
<p>color of the triangle border.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_bg">bg</code></td>
<td>
<p>triangle background.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_pch">pch</code></td>
<td>
<p>plotting character. Defaults to filled dots.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_cex">cex</code></td>
<td>
<p>a numerical value giving the amount by which plotting text
and symbols should be scaled relative to the default.  Ignored for
the symbol size if <code>prop_size</code> is not <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_prop_size">prop_size</code></td>
<td>
<p>if <code>TRUE</code>, the symbol size is plotted
proportional to the row sum of the three variables, i.e., represents
the weight of the observation.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_col">col</code></td>
<td>
<p>plotting color.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_main">main</code></td>
<td>
<p>main title.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_newpage">newpage</code></td>
<td>
<p>if <code>TRUE</code>, the plot will appear on a new graphics
page.</p>
</td></tr> 
<tr><td><code id="ternaryplot_+3A_pop">pop</code></td>
<td>
<p>logical; if <code>TRUE</code>, all newly generated viewports are popped after plotting.</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_return_grob">return_grob</code></td>
<td>
<p>logical. Should a snapshot of the display be
returned as a grid grob?</p>
</td></tr>
<tr><td><code id="ternaryplot_+3A_...">...</code></td>
<td>
<p>additional graphics parameters (see <code>par</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A points' coordinates are found by computing the gravity center of
mass points using the data entries as weights.  Thus, the coordinates
of a point <code class="reqn">P(a,b,c)</code>, <code class="reqn">a + b + c = 1</code>, are: <code class="reqn">P(b + c/2, c
    \sqrt{3}/2)</code>.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>References</h3>

<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Arthritis")

## Build table by crossing Treatment and Sex
tab &lt;- as.table(xtabs(~ I(Sex:Treatment) + Improved, data = Arthritis))

## Mark groups
col &lt;- c("red", "red", "blue", "blue")
pch &lt;- c(1, 19, 1, 19)

## plot
ternaryplot(
            tab,
            col = col,
            pch = pch,
            prop_size = TRUE,
            bg = "lightgray",
            grid_color = "white",
            labels_color = "white",
            main = "Arthritis Treatment Data"
           )
## legend
grid_legend(0.8, 0.7, pch, col, rownames(tab), title = "GROUP")

## Titanic
data("Lifeboats")
attach(Lifeboats)
ternaryplot(
  Lifeboats[,4:6],
  pch = ifelse(side == "Port", 1, 19),
  col = ifelse(side == "Port", "red", "blue"),
  id  = ifelse(men / total &gt; 0.1, as.character(boat), NA),
  prop_size = 2,
  dimnames_position = "edge",
  main = "Lifeboats on Titanic"
)
grid_legend(0.8, 0.9, c(1, 19),
  c("red", "blue"), c("Port", "Starboard"),
  title = "SIDE")


## Hitters
data("Hitters")
attach(Hitters)
colors &lt;- c("black","red","green","blue","red","black","blue")
pch &lt;- substr(levels(Positions), 1, 1)
ternaryplot(
  Hitters[,2:4],
  pch = as.character(Positions),
  col = colors[as.numeric(Positions)],
  main = "Baseball Hitters Data"
)
grid_legend(0.8, 0.9, pch, colors, levels(Positions),
  title = "POSITION(S)")

</code></pre>

<hr>
<h2 id='tile'>Tile Plot</h2><span id='topic+tile'></span><span id='topic+tile.default'></span><span id='topic+tile.formula'></span>

<h3>Description</h3>

<p>Plots a tile display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
tile(x,
         tile_type = c("area", "squaredarea", "height", "width"),
         halign = c("left", "center", "right"),
         valign = c("bottom", "center", "top"),
         split_vertical = NULL,
         shade = FALSE,
         spacing = spacing_equal(unit(1, "lines")),
         set_labels = NULL,
         margins = unit(3, "lines"),
         keep_aspect_ratio = FALSE,
         legend = NULL,
         legend_width = NULL,
         squared_tiles = TRUE,
         main = NULL, sub = NULL, ...)
## S3 method for class 'formula'
tile(formula, data,
  ..., main = NULL, sub = NULL, subset = NULL, na.action = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tile_+3A_x">x</code></td>
<td>
<p>a contingency table, or an object coercible to one.</p>
</td></tr>
<tr><td><code id="tile_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the variables used to create a 
contingency table from <code>data</code></p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code id="tile_+3A_data">data</code></td>
<td>
<p>either a data frame, or an object of class <code>"table"</code>
or <code>"ftable"</code>.</p>
</td></tr>
<tr><td><code id="tile_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="tile_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s. Ignored if <code>data</code> is a contingency
table.</p>
</td></tr>
<tr><td><code id="tile_+3A_tile_type">tile_type</code></td>
<td>
<p>character string indicating how the tiles should reflect
the table frequencies (see details).</p>
</td></tr>
<tr><td><code id="tile_+3A_halign">halign</code>, <code id="tile_+3A_valign">valign</code></td>
<td>
<p>character string specifying the horizontal and
vertical alignment of the tiles.</p>
</td></tr>
<tr><td><code id="tile_+3A_split_vertical">split_vertical</code></td>
<td>
<p>vector of logicals of length <code class="reqn">k</code>, where
<code class="reqn">k</code> is the number of margins of <code>x</code> (values are recycled as needed).
A <code>TRUE</code> component indicates that the tile(s) of the
corresponding dimension should be split vertically, <code>FALSE</code>
means horizontal splits. Default is <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="tile_+3A_spacing">spacing</code></td>
<td>
<p>spacing object, spacing function, or corresponding
generating function (see <code><a href="#topic+strucplot">strucplot</a></code> for more
information).</p>
</td></tr>
<tr><td><code id="tile_+3A_set_labels">set_labels</code></td>
<td>
<p>An optional character vector with named components
replacing the so-specified variable names. The component names must
exactly match the variable names to be replaced.</p>
</td></tr>
<tr><td><code id="tile_+3A_shade">shade</code></td>
<td>
<p>logical specifying whether shading should be enabled or
not (see <code><a href="#topic+strucplot">strucplot</a></code>).</p>
</td></tr>
<tr><td><code id="tile_+3A_margins">margins</code></td>
<td>
<p>either an object of class <code>"unit"</code> of length 4, or
a numeric vector of length 4. The elements are recycled as needed.
The four components specify the top, right,
bottom, and left margin of the plot, respectively.
When a numeric vector is supplied, the numbers are interpreted as
<code>"lines"</code> units.  In addition, the unit or numeric vector
may have named arguments
(&lsquo;<span class="samp">&#8288;top&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;right&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;bottom&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;left&#8288;</span>&rsquo;), in which
case the non-named arguments specify the default values (recycled as
needed), overloaded by the named arguments.</p>
</td></tr>
<tr><td><code id="tile_+3A_legend">legend</code></td>
<td>
<p>either a legend-generating function, or a legend
function (see details and <code><a href="#topic+legends">legends</a></code>), or a logical.
If <code>legend</code> is <code>NULL</code> or <code>TRUE</code> and <code>gp</code> is a
function or missing, legend defaults to <code><a href="#topic+legend_resbased">legend_resbased</a></code>.
</p>
</td></tr>
<tr><td><code id="tile_+3A_legend_width">legend_width</code></td>
<td>
<p>An object of class <code>"unit"</code> of length
1 specifying the width of the legend (if any). Default: 5 lines.</p>
</td></tr>
<tr><td><code id="tile_+3A_keep_aspect_ratio">keep_aspect_ratio</code></td>
<td>
<p>logical indicating whether the aspect ratio should be
fixed or not. The default is <code>FALSE</code> to enable the creation of
squared tiles.</p>
</td></tr>
<tr><td><code id="tile_+3A_squared_tiles">squared_tiles</code></td>
<td>
<p>logical indicating whether white space should be
added as needed to rows or columns to obtain squared tiles in case of an
unequal number of row and column labels.</p>
</td></tr>
<tr><td><code id="tile_+3A_main">main</code>, <code id="tile_+3A_sub">sub</code></td>
<td>
<p>either a logical, or a character string used for plotting
the main (sub) title.  If logical and <code>TRUE</code>, the
name of the <code>data</code> object is used.</p>
</td></tr>
<tr><td><code id="tile_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+strucplot">strucplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tile plot is a matrix of tiles. For each tile, either the <code>"width"</code>,
<code>"height"</code>, <code>"area"</code>, or squared area is proportional to the
corresponding entry. The first three options allow
column-wise, row-wise and overall comparisons, respectively. The last
variant allows to compare the tiles both column-wise and row-wise,
considering either the width or the height, respectively.
</p>
<p>In contrast to other high-level strucplot functions, <code>tile</code>
also accepts a table with duplicated levels (see examples). In this
case, artificial dimnames will be created, and the actual ones are
drawn using <code>set_labels</code>.
</p>
<p>Note that multiway-tables are first &ldquo;flattened&rdquo; using
<code>structable</code>.
</p>


<h3>Value</h3>

<p>The <code>"structable"</code> visualized is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>David Meyer <a href="mailto:David.Meyer@R-project.org">David.Meyer@R-project.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assoc">assoc</a></code>,
<code><a href="#topic+strucplot">strucplot</a></code>,
<code><a href="#topic+mosaic">mosaic</a></code>,
<code><a href="#topic+structable">structable</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Titanic")

## default plot
tile(Titanic)
tile(Titanic, type = "expected")
tile(Titanic, shade = TRUE)

## some variations
tile(Titanic, tile_type = "squaredarea")
tile(Titanic, tile_type = "width", squared_tiles = FALSE)
tile(Titanic, tile_type = "height", squared_tiles = FALSE)
tile(Titanic, tile_type = "area", halign = "center", valign = "center")

## repeat levels
tile(Titanic[,,,c(1,2,1,2)])
</code></pre>

<hr>
<h2 id='Trucks'>Truck Accidents Data</h2><span id='topic+Trucks'></span>

<h3>Description</h3>

<p>Data from a study in England in two periods from November 1969 to
October 1971 and November 1971 to October 1973.  A new compulsory
safety measure for trucks was introduced in October 1971.  Therefore,
the question is whether the safety measure had an effect on the number
of accidents and on the point of collision on the truck.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Trucks")
</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on 5 variables.
</p>

<dl>
<dt>Freq</dt><dd><p>frequency of accidents involving trucks.</p>
</dd>
<dt>period</dt><dd><p>factor indicating time period (before, after)
1971-11-01.</p>
</dd> 
<dt>collision</dt><dd><p>factor indicating whether the collision was in the
back or forward (including the front and the sides) of the truck
(back, forward).</p>
</dd>
<dt>parked</dt><dd><p>factor indicating whether the truck was parked (yes,
no).</p>
</dd>
<dt>light</dt><dd><p>factor indicating light conditions: day light (daylight),
night on an illuminated road (night, illuminate), night on a dark
road (night, dark).</p>
</dd>
</dl>



<h3>Source</h3>

<p>E. B. Andersen (1991),
The Statistical Analysis of Categorical Data, Table 6.8.
</p>


<h3>References</h3>

<p>E. B. Andersen (1991),
<em>The Statistical Analysis of Categorical Data</em>.
2nd edition.
Springer-Verlag, Berlin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
data("Trucks")
tab &lt;- xtabs(Freq ~ period + collision + light + parked, data = Trucks)
loglm(~ (collision + period) * parked * light, data = tab)
doubledecker(collision ~ parked + light + period, data = tab)
cotabplot(tab, panel = cotab_coindep)
</code></pre>

<hr>
<h2 id='UKSoccer'>UK Soccer Scores</h2><span id='topic+UKSoccer'></span>

<h3>Description</h3>

<p>Data from Lee (1997), on the goals scored by Home and Away teams in
the Premier Football League, 1995/6 season.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("UKSoccer")
</code></pre>


<h3>Format</h3>

<p>A 2-dimensional array resulting from cross-tabulating the number of
goals scored in 380 games.  The variables and their levels are as
follows:
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> Home </td><td style="text-align: left;"> 0, 1, ..., 4 </td>
</tr>
<tr>
 <td style="text-align: right;">
    2 </td><td style="text-align: left;"> Away </td><td style="text-align: left;"> 0, 1, ..., 4
  </td>
</tr>

</table>



<h3>Source</h3>

<p>M. Friendly (2000),
Visualizing Categorical Data, page 27.
</p>


<h3>References</h3>

<p>A. J. Lee (1997),
Modelling scores in the Premier League: Is Manchester United really
the best?,
<em>Chance</em>, <b>10</b>(1), 15&ndash;19.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bundesliga">Bundesliga</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("UKSoccer")
mosaic(UKSoccer, gp = shading_max, main = "UK Soccer Scores")
</code></pre>

<hr>
<h2 id='VisualAcuity'>Visual Acuity in Left and Right Eyes</h2><span id='topic+VisualAcuity'></span>

<h3>Description</h3>

<p>Data from Kendall &amp; Stuart (1961) on unaided vision among 3,242 men
and 7,477 women, all aged 30-39 and employed in the U.K. Royal
Ordnance factories 1943-1946.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("VisualAcuity")
</code></pre>


<h3>Format</h3>

<p>A data frame with 32 observations and 4 variables.
</p>

<dl>
<dt>Freq</dt><dd><p>frequency of visual acuity measurements.</p>
</dd>
<dt>right</dt><dd><p>visual acuity on right eye.</p>
</dd>
<dt>left</dt><dd><p>visual acuity on left eye.</p>
</dd>
<dt>gender</dt><dd><p>factor indicating gender of patient.</p>
</dd>
</dl>



<h3>Source</h3>

<p>M. Friendly (2000),
Visualizing Categorical Data:
<a href="http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/vision.sas">http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/vision.sas</a>
</p>


<h3>References</h3>

<p>M. G. Kendall &amp; A. Stuart (1961),
<em>The Advanced Theory of Statistics</em>, Vol. 2.
Griffin, London.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("VisualAcuity")
structable(~ gender + left + right, data = VisualAcuity)
sieve(Freq ~ left + right | gender, data = VisualAcuity, shade = TRUE)
cotabplot(Freq ~ left + right | gender, data = VisualAcuity,
          panel = cotab_agreementplot)
</code></pre>

<hr>
<h2 id='VonBort'>Von Bortkiewicz Horse Kicks Data</h2><span id='topic+VonBort'></span>

<h3>Description</h3>

<p>Data from von Bortkiewicz (1898), given by Andrews &amp; Herzberg (1985),
on number of deaths by horse or mule kicks in 14 corps of the Prussian
army.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("VonBort")
</code></pre>


<h3>Format</h3>

<p>A data frame with 280 observations and 4 variables.
</p>

<dl>
<dt>deaths</dt><dd><p>number of deaths.</p>
</dd>
<dt>year</dt><dd><p>year of the deaths.</p>
</dd>
<dt>corps</dt><dd><p>factor indicating the corps.</p>
</dd>
<dt>fisher</dt><dd><p>factor indicating whether the corresponding corps was
considered by Fisher (1925) or not.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Michael Friendly (2000),
Visualizing Categorical Data:
<a href="http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/vonbort.sas">http://euclid.psych.yorku.ca/ftp/sas/vcd/catdata/vonbort.sas</a>
</p>


<h3>References</h3>

<p>D. F. Andrews &amp; A. M. Herzberg (1985),
<em>Data: A Collection of Problems from Many Fields for the Student
and Research Worker</em>.
Springer-Verlag, New York, NY.
</p>
<p>R. A. Fisher (1925),
<em>Statistical Methods for Research Workers</em>.
Oliver &amp; Boyd, London.
</p>
<p>L. von Bortkiewicz (1898),
<em>Das Gesetz der kleinen Zahlen</em>.
Teubner, Leipzig.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HorseKicks">HorseKicks</a></code> for a popular subsample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("VonBort")
## HorseKicks data
xtabs(~ deaths, data = VonBort, subset = fisher == "yes")
</code></pre>

<hr>
<h2 id='WeldonDice'>Weldon's Dice Data</h2><span id='topic+WeldonDice'></span>

<h3>Description</h3>

<p>Data from Pearson (1900) about the frequency of 5s and 6s in throws of
12 dice.  Weldon tossed the dice 26,306 times and reported his results
in a letter to Francis Galton on 1894-02-02.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("WeldonDice")
</code></pre>


<h3>Format</h3>

<p>A 1-way table giving the frequency of a 5 or a 6 in 26,306 throws of
12 dice where 10 indicates &lsquo;10 or more&rsquo; 5s or 6s.  The variable
and its levels are
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> n56 </td><td style="text-align: left;"> 0, 1, ..., 10 </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>M. Friendly (2000),
Visualizing Categorical Data,
pages 20&ndash;21.
</p>


<h3>References</h3>

<p>K. Pearson (1900),
On the criterion that a given system of deviations from the probable
in the case of a correlated system of variables is such that it can be
reasonably supposed to have arisen by random sampling,
<em>Philosophical Magazine</em>, <b>50</b> (5th series), 157&ndash;175.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("WeldonDice")
gf &lt;- goodfit(WeldonDice, type = "binomial")
summary(gf)
plot(gf)
</code></pre>

<hr>
<h2 id='WomenQueue'>Women in Queues</h2><span id='topic+WomenQueue'></span>

<h3>Description</h3>

<p>Data from Jinkinson &amp; Slater (1981) and Hoaglin &amp; Tukey (1985)
reporting the frequency distribution of females in 100 queues of
length 10 in a London Underground station.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("WomenQueue")
</code></pre>


<h3>Format</h3>

<p>A 1-way table giving the number of women in 100 queues of length
10.  The variable and its levels are 
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels </td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> nWomen </td><td style="text-align: left;"> 0, 1, ..., 10 </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>M. Friendly (2000),
Visualizing Categorical Data,
pages 19&ndash;20.
</p>


<h3>References</h3>

<p>D. C. Hoaglin &amp; J. W. Tukey (1985),
Checking the shape of discrete distributions.
In D. C. Hoaglin, F. Mosteller, J. W. Tukey (eds.),
<em>Exploring Data Tables, Trends and Shapes</em>, chapter 9.
John Wiley &amp; Sons, New York.
</p>
<p>R. A. Jinkinson &amp; M. Slater (1981),
Critical discussion of a graphical method for identifying discrete
distributions,
<em>The Statistician</em>, <b>30</b>, 239&ndash;248.
</p>
<p>M. Friendly (2000),
<em>Visualizing Categorical Data</em>.
SAS Institute, Cary, NC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("WomenQueue")
gf &lt;- goodfit(WomenQueue, type = "binomial")
summary(gf)
plot(gf)
</code></pre>

<hr>
<h2 id='woolf_test'>Woolf Test</h2><span id='topic+woolf_test'></span>

<h3>Description</h3>

<p>Test for homogeneity on <code class="reqn">2 \times 2 \times k</code> tables
over strata (i.e., whether the log odds ratios are the same in all
strata).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>woolf_test(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="woolf_test_+3A_x">x</code></td>
<td>
<p>A <code class="reqn">2 \times 2 \times k</code> table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"htest"</code> containing the following
components: 
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the chi-squared test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>degrees of freedom of the approximate chi-squared
distribution of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p><code class="reqn">p</code>-value for the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the type of test
performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>observed</code></td>
<td>
<p>the observed counts.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>the expected counts under the null hypothesis.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Woolf, B. 1955. On estimating the relation between blood group and 
disease. <em>Ann. Human Genet.</em> (London) <b>19</b>, 251-253.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+mantelhaen.test">mantelhaen.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CoalMiners")
woolf_test(CoalMiners)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
