<!DOCTYPE html><html lang="en"><head><title>Help for package purgeR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {purgeR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#purgeR'><p>purgeR: Estimation of inbreeding-purging genetic parameters in pedigreed populations</p></a></li>
<li><a href='#ancestors'><p>Individuals to be evaluated in purging analyses</p></a></li>
<li><a href='#arrui'><p>Arrui pedigree</p></a></li>
<li><a href='#atlas'><p>Cuvier's gazelle pedigree</p></a></li>
<li><a href='#check_ancestors'><p>Check ancestor individuals</p></a></li>
<li><a href='#check_basic'><p>Check basic</p></a></li>
<li><a href='#check_bool'><p>Check if a variable is boolean or not</p></a></li>
<li><a href='#check_col'><p>Check that optional column is included</p></a></li>
<li><a href='#check_d'><p>Check purging coefficient</p></a></li>
<li><a href='#check_df'><p>Check pedigree class</p></a></li>
<li><a href='#check_Fcol'><p>Check columns with inbreeding values</p></a></li>
<li><a href='#check_index'><p>Check individual index</p></a></li>
<li><a href='#check_int'><p>Check if a variable is a positive integer or not</p></a></li>
<li><a href='#check_length'><p>Check if a variable has length &gt;1</p></a></li>
<li><a href='#check_na'><p>Check if a vector contains NA values</p></a></li>
<li><a href='#check_names'><p>Check that mandatory column names are included</p></a></li>
<li><a href='#check_Ne'><p>Check Ne</p></a></li>
<li><a href='#check_not_col'><p>Check if optional column is included</p></a></li>
<li><a href='#check_nrows'><p>Check observed and expected number of rows</p></a></li>
<li><a href='#check_order'><p>Check individual order</p></a></li>
<li><a href='#check_reference'><p>Check columns with reference individuals</p></a></li>
<li><a href='#check_repeat_id'><p>Check repeated ids</p></a></li>
<li><a href='#check_tcol'><p>Check columns with generation numbers</p></a></li>
<li><a href='#check_types'><p>Check that mandatory column names are of type int</p></a></li>
<li><a href='#check_zero_id'><p>Check individuals named zero</p></a></li>
<li><a href='#dama'><p>Dama gazelle pedigree</p></a></li>
<li><a href='#darwin'><p>Darwin/Wedgwood pedigree</p></a></li>
<li><a href='#delta_Fi'><p>Individual inbreeding variation</p></a></li>
<li><a href='#dorcas'><p>Dorcas gazelle pedigree</p></a></li>
<li><a href='#exp_F'><p>Expected inbreeding coefficient</p></a></li>
<li><a href='#exp_Fa'><p>Expected ancestral inbreeding coefficient</p></a></li>
<li><a href='#exp_g'><p>Expected purged inbreeding coefficient</p></a></li>
<li><a href='#F'><p>Inbreeding coefficient</p></a></li>
<li><a href='#Fa'><p>Ancestral inbreeding coefficient</p></a></li>
<li><a href='#Fij_core'><p>Partial inbreeding coefficient (core function)</p></a></li>
<li><a href='#Fij_core_i_cpp'><p>Partial inbreeding coefficient (core function)</p></a></li>
<li><a href='#g'><p>Purged inbreeding coefficient</p></a></li>
<li><a href='#hwd'><p>Deviation from Hardy-Weinberg equilibrium</p></a></li>
<li><a href='#idx_ancestors'><p>Index ancestors</p></a></li>
<li><a href='#ip_F'><p>Inbreeding coefficient</p></a></li>
<li><a href='#ip_Fa'><p>Ancestral inbreeding coefficient</p></a></li>
<li><a href='#ip_Fij'><p>Partial inbreeding coefficient</p></a></li>
<li><a href='#ip_g'><p>Purged inbreeding coefficient</p></a></li>
<li><a href='#ip_op'><p>Opportunity of purging</p></a></li>
<li><a href='#map_ancestors'><p>Map ancestors</p></a></li>
<li><a href='#Ne_delta'><p>Realized effective population size (mean)</p></a></li>
<li><a href='#op'><p>Opportunity of purging</p></a></li>
<li><a href='#ped_clean'><p>Remove individuals not used for purging analyses</p></a></li>
<li><a href='#ped_graph'><p>Input for igraph</p></a></li>
<li><a href='#ped_maternal'><p>Maternal effects</p></a></li>
<li><a href='#ped_rename'><p>Rename individuals in a pedigree from 1 to N</p></a></li>
<li><a href='#ped_sort'><p>Sort individuals (with ancestors on top of descendants)</p></a></li>
<li><a href='#ped_sort_i'><p>Sorting steps</p></a></li>
<li><a href='#pop_hwd'><p>Deviation from Hardy-Weinberg equilibrium</p></a></li>
<li><a href='#pop_Nancestors'><p>Population founders and ancestors</p></a></li>
<li><a href='#pop_Ne'><p>Effective population size</p></a></li>
<li><a href='#pop_t'><p>Number of equivalent complete generations</p></a></li>
<li><a href='#reproductive_value'><p>Reproductive value</p></a></li>
<li><a href='#sample_allele'><p>Sample dam or sire inherited allele</p></a></li>
<li><a href='#search_ancestors'><p>Search and individuals' ancestors</p></a></li>
<li><a href='#w_grandoffspring'><p>Grandoffspring</p></a></li>
<li><a href='#w_offspring'><p>Offspring</p></a></li>
<li><a href='#w_reproductive_value'><p>Reproductive value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inbreeding-Purging Estimation in Pedigreed Populations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Inbreeding-purging analysis of pedigreed populations, including the computation of the inbreeding coefficient, partial, ancestral and purged inbreeding coefficients, and measures of the opportunity of purging related to the individual reduction of inbreeding load.
    In addition, functions to calculate the effective population size and other parameters relevant to population genetics are included.
    See López-Cortegano E. (2021) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtab599">doi:10.1093/bioinformatics/btab599</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/elcortegano/purgeR/">https://gitlab.com/elcortegano/purgeR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/elcortegano/purgeR/-/issues/">https://gitlab.com/elcortegano/purgeR/-/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>doSNOW (&ge; 1.0.19), foreach (&ge; 1.5.1), parallel, progress (&ge;
1.2.2), Rcpp (&ge; 1.0.5), RcppProgress (&ge; 0.4.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>Suggests:</td>
<td>caret (&ge; 6.0-86), coda (&ge; 0.19-4), dplyr (&ge; 1.0.0), e1071
(&ge; 1.7-4), ggplot2 (&ge; 3.3.1), ggraph (&ge; 2.1.0), glmnet (&ge;
4.0-2), gtable (&ge; 0.3.0), igraph (&ge; 1.5.0.1), knitr (&ge;
1.28), magrittr (&ge; 1.5), pander (&ge; 0.6.3), plyr (&ge; 1.8.6),
purrr (&ge; 0.3.4), rmarkdown (&ge; 2.2), scales (&ge; 1.1.1),
stringr (&ge; 1.4.0), testthat (&ge; 2.3.2), tibble (&ge; 3.0.1),
tidyr (&ge; 1.1.0), tidyselect (&ge; 1.1.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 21:57:01 UTC; elcortegano</td>
</tr>
<tr>
<td>Author:</td>
<td>Eugenio López-Cortegano
    <a href="https://orcid.org/0000-0001-6914-6305"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eugenio López-Cortegano &lt;elcortegano@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='purgeR'>purgeR: Estimation of inbreeding-purging genetic parameters in pedigreed populations</h2><span id='topic+purgeR'></span><span id='topic+purgeR-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">purgeR</span> package includes functions for the computation of parameters related to inbreeding and genetic purging in pedigreed populations, including standard, ancestral and purged inbreeding coefficients, among other measures of inbreeding and purging. In addition, functions to compute the effective population size and other parameters relevant to population genetics and structure are included.
</p>


<h3>Details</h3>

<p>A complete user's guide with examples is provided as vignettes, introducing functions in this package and providing examples of use. Navigate these vignettes from R with:
</p>
<p><code>browseVignettes("purgeR")</code>
</p>
<p>There are currently two vignettes available:
</p>

<ul>
<li><p><strong>purgeR-tutorial</strong>: A complete overview of all functions in the package, including easy to follow examples.
</p>
</li>
<li><p><strong>ip</strong>: A more advanced guide showing examples of inbreeding purging analyses.
</p>
</li></ul>



<h3>Functions</h3>

<p>Preprocessing
</p>

<ul>
<li> <p><code><a href="#topic+ped_rename">ped_rename</a></code>: Rename individuals in a pedigree from 1 to N
</p>
</li>
<li> <p><code><a href="#topic+ped_sort">ped_sort</a></code>: Sort individuals (with ancestors on top of descendants)
</p>
</li>
<li> <p><code><a href="#topic+ped_clean">ped_clean</a></code>: Remove individuals not used for purging analyses
</p>
</li>
<li> <p><code><a href="#topic+ped_maternal">ped_maternal</a></code>: Maternal effects
</p>
</li>
<li> <p><code><a href="#topic+ped_graph">ped_graph</a></code>: Input for igraph
</p>
</li></ul>

<p>Inbreeding and purging
</p>

<ul>
<li> <p><code><a href="#topic+ip_F">ip_F</a></code>: Inbreeding coefficient
</p>
</li>
<li> <p><code><a href="#topic+ip_Fa">ip_Fa</a></code>: Ancestral inbreeding coefficient
</p>
</li>
<li> <p><code><a href="#topic+ip_Fij">ip_Fij</a></code>: Partial inbreeding coefficient
</p>
</li>
<li> <p><code><a href="#topic+ip_g">ip_g</a></code>: Purged inbreeding coefficient
</p>
</li>
<li> <p><code><a href="#topic+ip_op">ip_op</a></code>: Opportunity of purging
</p>
</li>
<li> <p><code><a href="#topic+exp_F">exp_F</a></code>: Expected inbreeding coefficient
</p>
</li>
<li> <p><code><a href="#topic+exp_Fa">exp_Fa</a></code>: Expected ancestral inbreeding coefficient
</p>
</li>
<li> <p><code><a href="#topic+exp_g">exp_g</a></code>: Expected purged inbreeding coefficient
</p>
</li></ul>

<p>Population parameters
</p>

<ul>
<li> <p><code><a href="#topic+pop_hwd">pop_hwd</a></code>: Deviation from Hardy-Weinberg equilibrium
</p>
</li>
<li> <p><code><a href="#topic+pop_t">pop_t</a></code>: Number of equivalent complete generations
</p>
</li>
<li> <p><code><a href="#topic+pop_Ne">pop_Ne</a></code>: Effective population size
</p>
</li>
<li> <p><code><a href="#topic+pop_Nancestors">pop_Nancestors</a></code>: Population founders and ancestors
</p>
</li>
<li> <p><code><a href="#topic+pop_Na">pop_Na</a></code>: Total number of ancestors
</p>
</li>
<li> <p><code><a href="#topic+pop_Nae">pop_Nae</a></code>: Effective number of ancestors
</p>
</li>
<li> <p><code><a href="#topic+pop_Nf">pop_Nf</a></code>: Total number of founders
</p>
</li>
<li> <p><code><a href="#topic+pop_Nfe">pop_Nfe</a></code>: Effective number of founders
</p>
</li>
<li> <p><code><a href="#topic+pop_Ng">pop_Ng</a></code>: Number of founder genome equivalents
</p>
</li></ul>

<p>Fitness
</p>

<ul>
<li> <p><code><a href="#topic+w_grandoffspring">w_grandoffspring</a></code>: Grandoffspring
</p>
</li>
<li> <p><code><a href="#topic+w_offspring">w_offspring</a></code>: Offspring
</p>
</li>
<li> <p><code><a href="#topic+w_reproductive_value">w_reproductive_value</a></code>: Reproductive value
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eugenio López-Cortegano &lt;elcortegano@gmail.com&gt; (<a href="https://orcid.org/0000-0001-6914-6305">ORCID</a>)
</p>


<h3>References</h3>


<ul>
<li><p>López-Cortegano E. 2022. purgeR: Inbreeding and purging in pedigreed populations. <em>Bioinformatics</em>, https://doi.org/10.1093/bioinformatics/btab599.
</p>
</li></ul>



<h3>See Also</h3>

<p>Source code is available via the GitLab repository at <a href="https://gitlab.com/elcortegano/purgeR/">https://gitlab.com/elcortegano/purgeR/</a>. Users are encouraged to report bugs, request features, and contribute code to this project.
</p>
<p>Some users might find useful the C++ software PURGd, which computes inbreeding-purging parameters and follow-up statistical analyses: <a href="https://gitlab.com/elcortegano/PURGd/">https://gitlab.com/elcortegano/PURGd/</a>.
</p>

<hr>
<h2 id='ancestors'>Individuals to be evaluated in purging analyses</h2><span id='topic+ancestors'></span>

<h3>Description</h3>

<p>Returns a boolean vector indicating what individuals are suitable for purging analyses, given a measure of fitness.
Individuals with NA values of fitness, and that do not have descendants with non-NA fitness values, are excluded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancestors(ped, reference, rp_idx, nboot = 10000L, seed = NULL, skip_Ng = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ancestors_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="ancestors_+3A_reference">reference</code></td>
<td>
<p>A string naming a column indicating whether individuals belong to the reference population or not. Column must be boolean or coercible to boolean type.</p>
</td></tr>
<tr><td><code id="ancestors_+3A_rp_idx">rp_idx</code></td>
<td>
<p>Vector containing the indexes of individuals of the RP</p>
</td></tr>
<tr><td><code id="ancestors_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap iterations (for computing Ng).</p>
</td></tr>
<tr><td><code id="ancestors_+3A_seed">seed</code></td>
<td>
<p>Sets a seed for the random number generator.</p>
</td></tr>
<tr><td><code id="ancestors_+3A_skip_ng">skip_Ng</code></td>
<td>
<p>Skip Ng computation or not (FALSE by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean vector indicating what individuals will be evaluated.
</p>

<hr>
<h2 id='arrui'>Arrui pedigree</h2><span id='topic+arrui'></span>

<h3>Description</h3>

<p>This data set contains the pedigree of the arrui (<em>Ammotragus lervia</em>),
also known as barbary sheep.
A total of 380 individuals is included, as well as measurements of biological fitness
and other factors (see reference below for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrui
</code></pre>


<h3>Format</h3>

<p>A data frame with with records from 380 individuals (in rows), and 10 variables:
</p>

<ul>
<li><p><em>id</em> -  Individual identity.
</p>
</li>
<li><p><em>dam</em> -  Maternal identity.
</p>
</li>
<li><p><em>sire</em> -  Paternal identity.
</p>
</li>
<li><p><em>survival15</em> -  15-days survival.
</p>
</li>
<li><p><em>prod</em> -  Female productivity.
</p>
</li>
<li><p><em>sex</em> -  Individual sex.
</p>
</li>
<li><p><em>yob</em> -  Year of birth.
</p>
</li>
<li><p><em>pom</em> -  Period of management.
</p>
</li>
<li><p><em>target</em> -  Individual in the target population.
</p>
</li>
<li><p><em>eeza_id</em> -  Individual identity (as recorded in the original studbook)
</p>
</li></ul>



<h3>Source</h3>

<p>The original studbook containing the complete and updated pedigree can be found at: <a href="http://www.eeza.csic.es/en/programadecria.aspx">http://www.eeza.csic.es/en/programadecria.aspx</a>.
</p>


<h3>References</h3>


<ul>
<li><p>López-Cortegano E et al. 2021. Genetic purging in captive endangered ungulates with extremely low effective population sizes.*Heredity*, https://www.nature.com/articles/s41437-021-00473-2.
</p>
</li></ul>


<hr>
<h2 id='atlas'>Cuvier's gazelle pedigree</h2><span id='topic+atlas'></span>

<h3>Description</h3>

<p>This data set contains the pedigree of Cuvier's gazelle (<em>Gazella atlas</em>).
A total of 948 individuals is included, as well as measurements of biological fitness
and other factors (see reference below for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atlas
</code></pre>


<h3>Format</h3>

<p>A data frame with with records from 948 individuals (in rows), and 10 variables:
</p>

<ul>
<li><p><em>id</em> -  Individual identity.
</p>
</li>
<li><p><em>dam</em> -  Maternal identity.
</p>
</li>
<li><p><em>sire</em> -  Paternal identity.
</p>
</li>
<li><p><em>survival15</em> -  15-days survival.
</p>
</li>
<li><p><em>prod</em> -  Female productivity.
</p>
</li>
<li><p><em>sex</em> -  Individual sex.
</p>
</li>
<li><p><em>yob</em> -  Year of birth.
</p>
</li>
<li><p><em>pom</em> -  Period of management.
</p>
</li>
<li><p><em>target</em> -  Individual in the target population.
</p>
</li>
<li><p><em>eeza_id</em> -  Individual identity (as recorded in the original studbook)
</p>
</li></ul>



<h3>Source</h3>

<p>The original studbook containing the complete and updated pedigree can be found at: <a href="http://www.eeza.csic.es/en/programadecria.aspx">http://www.eeza.csic.es/en/programadecria.aspx</a>.
</p>


<h3>References</h3>


<ul>
<li><p>López-Cortegano E et al. 2021. Genetic purging in captive endangered ungulates with extremely low effective population sizes. *Heredity*, https://www.nature.com/articles/s41437-021-00473-2.
</p>
</li></ul>


<hr>
<h2 id='check_ancestors'>Check ancestor individuals</h2><span id='topic+check_ancestors'></span>

<h3>Description</h3>

<p>Takes a column name, and checks its use as target.
It should name a boolean vector (or coercible to it),
with at least one TRUE value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ancestors(id, ancestors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_ancestors_+3A_id">id</code></td>
<td>
<p>Vector of individual ids.</p>
</td></tr>
<tr><td><code id="check_ancestors_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of ancestor ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_basic'>Check basic</h2><span id='topic+check_basic'></span>

<h3>Description</h3>

<p>This function will group some other checking functions, that should be run everytime when using
functions in this package, to avoid unexpected errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_basic(
  ped,
  id_name = "id",
  dam_name = "dam",
  sire_name = "sire",
  when_rename = FALSE,
  when_sort = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_basic_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="check_basic_+3A_id_name">id_name</code></td>
<td>
<p>Column name for individual id.</p>
</td></tr>
<tr><td><code id="check_basic_+3A_dam_name">dam_name</code></td>
<td>
<p>Column name for dam.</p>
</td></tr>
<tr><td><code id="check_basic_+3A_sire_name">sire_name</code></td>
<td>
<p>Column name for sire.</p>
</td></tr>
<tr><td><code id="check_basic_+3A_when_rename">when_rename</code></td>
<td>
<p>True when called from ped_rename function. It softs checks on individual ID column name and types</p>
</td></tr>
<tr><td><code id="check_basic_+3A_when_sort">when_sort</code></td>
<td>
<p>True when called from ped_sort function. It softs checks on pedigree sorting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_bool'>Check if a variable is boolean or not</h2><span id='topic+check_bool'></span>

<h3>Description</h3>

<p>Can be used to test arguments that need to be of logical (boolean) type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_bool(variable)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_bool_+3A_variable">variable</code></td>
<td>
<p>Variable to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_col'>Check that optional column is included</h2><span id='topic+check_col'></span>

<h3>Description</h3>

<p>Some functions require additional columns. Check that they are named in the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_col(names, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_col_+3A_names">names</code></td>
<td>
<p>Column names (all)</p>
</td></tr>
<tr><td><code id="check_col_+3A_name">name</code></td>
<td>
<p>Column name to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_d'>Check purging coefficient</h2><span id='topic+check_d'></span>

<h3>Description</h3>

<p>The purging coefficient must be a number between 0 and 0.5
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_d(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_d_+3A_d">d</code></td>
<td>
<p>Purging coefficient (taking values between 0.0 and 0.5).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_df'>Check pedigree class</h2><span id='topic+check_df'></span>

<h3>Description</h3>

<p>The pedigree must be of object class 'data.frame'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_df(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_df_+3A_obj">obj</code></td>
<td>
<p>Object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_Fcol'>Check columns with inbreeding values</h2><span id='topic+check_Fcol'></span>

<h3>Description</h3>

<p>Takes a column name, and checks its use as inbreeding coefficient.
It should name a numeric vector, with values in the range [0,1]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_Fcol(ped, Fcol, compute = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_Fcol_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="check_Fcol_+3A_fcol">Fcol</code></td>
<td>
<p>Name of column with inbreeding coefficient values. If none is used, inbreeding will be computed.</p>
</td></tr>
<tr><td><code id="check_Fcol_+3A_compute">compute</code></td>
<td>
<p>Compute inbreeding if Fcol is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of inbreeding values (if checks are successful)
</p>

<hr>
<h2 id='check_index'>Check individual index</h2><span id='topic+check_index'></span>

<h3>Description</h3>

<p>Renamed individuals must be named by their index (from 1 to N)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_index(id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_index_+3A_id">id</code></td>
<td>
<p>Column of individual ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_int'>Check if a variable is a positive integer or not</h2><span id='topic+check_int'></span>

<h3>Description</h3>

<p>Can be used to test arguments that need to be integers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_int(variable)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_int_+3A_variable">variable</code></td>
<td>
<p>Variable to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_length'>Check if a variable has length &gt;1</h2><span id='topic+check_length'></span>

<h3>Description</h3>

<p>Used to test arguments that need to be of length 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_length(variable, message = "Expected value of length 1")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_length_+3A_variable">variable</code></td>
<td>
<p>Variable to test</p>
</td></tr>
<tr><td><code id="check_length_+3A_message">message</code></td>
<td>
<p>Error message to display</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_na'>Check if a vector contains NA values</h2><span id='topic+check_na'></span>

<h3>Description</h3>

<p>Return warning when NA values are present
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_na(variable)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_na_+3A_variable">variable</code></td>
<td>
<p>Variable to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_names'>Check that mandatory column names are included</h2><span id='topic+check_names'></span>

<h3>Description</h3>

<p>Columns for id, dam and sire are mandatory. This function checks that they are named in the pedigree.
The function works with arbitrary column names (not 'id', 'dam' and 'sire') to work with ped_rename()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_names(ped, id_name = "id", dam_name = "dam", sire_name = "sire")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_names_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="check_names_+3A_id_name">id_name</code></td>
<td>
<p>Column name for individual id.</p>
</td></tr>
<tr><td><code id="check_names_+3A_dam_name">dam_name</code></td>
<td>
<p>Column name for dam.</p>
</td></tr>
<tr><td><code id="check_names_+3A_sire_name">sire_name</code></td>
<td>
<p>Column name for sire.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_Ne'>Check Ne</h2><span id='topic+check_Ne'></span>

<h3>Description</h3>

<p>The effective population size (Ne) must be a number higher than 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_Ne(Ne)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_Ne_+3A_ne">Ne</code></td>
<td>
<p>Effective population size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_not_col'>Check if optional column is included</h2><span id='topic+check_not_col'></span>

<h3>Description</h3>

<p>Some functions require additional columns. Check if they are already named in the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_not_col(names, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_not_col_+3A_names">names</code></td>
<td>
<p>Column names (all)</p>
</td></tr>
<tr><td><code id="check_not_col_+3A_name">name</code></td>
<td>
<p>Column name to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_nrows'>Check observed and expected number of rows</h2><span id='topic+check_nrows'></span>

<h3>Description</h3>

<p>Expected and observed number of rows must be equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_nrows(df, exp, message = "Expected value of length 1")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_nrows_+3A_df">df</code></td>
<td>
<p>Dataframe to test</p>
</td></tr>
<tr><td><code id="check_nrows_+3A_exp">exp</code></td>
<td>
<p>Expected number of rows</p>
</td></tr>
<tr><td><code id="check_nrows_+3A_message">message</code></td>
<td>
<p>Error message to display</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_order'>Check individual order</h2><span id='topic+check_order'></span>

<h3>Description</h3>

<p>Individuals must be sorted from older to younger
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_order(id, dam, sire, soft_sorting = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_order_+3A_id">id</code></td>
<td>
<p>Vector of individual ids.</p>
</td></tr>
<tr><td><code id="check_order_+3A_dam">dam</code></td>
<td>
<p>Vector of dam ids.</p>
</td></tr>
<tr><td><code id="check_order_+3A_sire">sire</code></td>
<td>
<p>Vector of sire ids.</p>
</td></tr>
<tr><td><code id="check_order_+3A_soft_sorting">soft_sorting</code></td>
<td>
<p>If TRUE checking is relaxed, allowing descendants to be declared before ancestors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_reference'>Check columns with reference individuals</h2><span id='topic+check_reference'></span><span id='topic+check_target'></span>

<h3>Description</h3>

<p>Takes a column name, and checks its use as reference.
It should name a boolean vector (or coercible to it),
with at least one TRUE value.
</p>
<p>Takes a column name, and checks its use as target.
It should name a boolean vector (or coercible to it),
with at least one TRUE value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_reference(ped, reference)

check_target(ped, reference, target, variable)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_reference_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="check_reference_+3A_reference">reference</code></td>
<td>
<p>A string naming a column indicating whether individuals belong to the reference population or not. Column must be boolean or coercible to boolean type.</p>
</td></tr>
<tr><td><code id="check_reference_+3A_target">target</code></td>
<td>
<p>Target column</p>
</td></tr>
<tr><td><code id="check_reference_+3A_variable">variable</code></td>
<td>
<p>To be used in printed messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of reference numbers (if checks are successful)
</p>
<p>Vector of target numbers (if checks are successful)
</p>

<hr>
<h2 id='check_repeat_id'>Check repeated ids</h2><span id='topic+check_repeat_id'></span>

<h3>Description</h3>

<p>Individual id are unique and cannot be repeated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_repeat_id(id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_repeat_id_+3A_id">id</code></td>
<td>
<p>Vector of individual ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_tcol'>Check columns with generation numbers</h2><span id='topic+check_tcol'></span>

<h3>Description</h3>

<p>Takes a column name, and checks its use as generation numbers.
It should name a numeric vector, with values &gt;= 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_tcol(ped, tcol, compute = TRUE, force_int = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_tcol_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="check_tcol_+3A_tcol">tcol</code></td>
<td>
<p>Name of column with individual generation times. If none is used, the number of equivalent complete generations is computed.</p>
</td></tr>
<tr><td><code id="check_tcol_+3A_compute">compute</code></td>
<td>
<p>Compute generation numbers if tcol is NULL</p>
</td></tr>
<tr><td><code id="check_tcol_+3A_force_int">force_int</code></td>
<td>
<p>Generation numbers must be integers (disabled by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of generation numbers (if checks are successful)
</p>

<hr>
<h2 id='check_types'>Check that mandatory column names are of type int</h2><span id='topic+check_types'></span>

<h3>Description</h3>

<p>Columns for id, dam and sire are mandatory, and required to be of type integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_types(id, dam, sire)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_types_+3A_id">id</code></td>
<td>
<p>Vector of individual ids.</p>
</td></tr>
<tr><td><code id="check_types_+3A_dam">dam</code></td>
<td>
<p>Vector of dam ids.</p>
</td></tr>
<tr><td><code id="check_types_+3A_sire">sire</code></td>
<td>
<p>Vector of sire ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='check_zero_id'>Check individuals named zero</h2><span id='topic+check_zero_id'></span>

<h3>Description</h3>

<p>Individual id cannot equal zero (0). This is reserved to dams and sires.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_zero_id(id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_zero_id_+3A_id">id</code></td>
<td>
<p>Vector of individual ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>

<hr>
<h2 id='dama'>Dama gazelle pedigree</h2><span id='topic+dama'></span>

<h3>Description</h3>

<p>This data set contains the pedigree of the dama gazelle (<em>Nanger dama</em>).
A total of 1316 individuals is included, as well as measurements of biological fitness
and other factors (see reference below for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dama
</code></pre>


<h3>Format</h3>

<p>A data frame with with records from 1316 individuals (in rows), and 10 variables:
</p>

<ul>
<li><p><em>id</em> -  Individual identity.
</p>
</li>
<li><p><em>dam</em> -  Maternal identity.
</p>
</li>
<li><p><em>sire</em> -  Paternal identity.
</p>
</li>
<li><p><em>survival15</em> -  15-days survival.
</p>
</li>
<li><p><em>prod</em> -  Female productivity.
</p>
</li>
<li><p><em>sex</em> -  Individual sex.
</p>
</li>
<li><p><em>yob</em> -  Year of birth.
</p>
</li>
<li><p><em>pom</em> -  Period of management.
</p>
</li>
<li><p><em>target</em> -  Individual in the target population.
</p>
</li>
<li><p><em>eeza_id</em> -  Individual identity (as recorded in the original studbook)
</p>
</li></ul>



<h3>Source</h3>

<p>The original studbook containing the complete and updated pedigree can be found at: <a href="http://www.eeza.csic.es/en/programadecria.aspx">http://www.eeza.csic.es/en/programadecria.aspx</a>.
</p>


<h3>References</h3>


<ul>
<li><p>López-Cortegano E et al. 2021. Genetic purging in captive endangered ungulates with extremely low effective population sizes. *Heredity*, https://www.nature.com/articles/s41437-021-00473-2.
</p>
</li></ul>


<hr>
<h2 id='darwin'>Darwin/Wedgwood pedigree</h2><span id='topic+darwin'></span>

<h3>Description</h3>

<p>This data set contains the pedigree of the Darwin/Wedgwood dynasty.
It is composed by a total of 63 individuals,
including Charles R. Darwin and Francis Galton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>darwin
</code></pre>


<h3>Format</h3>

<p>A data frame with with records from 63 individuals (in rows), and 3 variables:
</p>

<ul>
<li><p><em>Individual</em> -  Individual identity.
</p>
</li>
<li><p><em>Mother</em> -  Mother's identity.
</p>
</li>
<li><p><em>Father</em> -  Father's identity.
</p>
</li></ul>



<h3>Source</h3>

<p>The pedigree is adapted from Berra et al. (2010)
</p>


<h3>References</h3>


<ul>
<li><p>Berra TM et al. 2010. Was the Darwin/Wedgwood dynasty adversely affected by consanguinity?. BioScience 60(5): 376-383.
</p>
</li></ul>


<hr>
<h2 id='delta_Fi'>Individual inbreeding variation</h2><span id='topic+delta_Fi'></span>

<h3>Description</h3>

<p>Computes the increase in inbreeding coefficient for a given individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_Fi(Fi, t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delta_Fi_+3A_fi">Fi</code></td>
<td>
<p>Individual inbreeding coefficient.</p>
</td></tr>
<tr><td><code id="delta_Fi_+3A_t">t</code></td>
<td>
<p>Individual generation number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Individual variation in inbreeding.
</p>

<hr>
<h2 id='dorcas'>Dorcas gazelle pedigree</h2><span id='topic+dorcas'></span>

<h3>Description</h3>

<p>This data set contains the pedigree of dorcas gazelle (<em>Gazella dorcas</em>).
A total of 1279 individuals is included, as well as measurements of biological fitness
and other factors (see reference below for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dorcas
</code></pre>


<h3>Format</h3>

<p>A data frame with with records from 1279 individuals (in rows), and 10 variables:
</p>

<ul>
<li><p><em>id</em> -  Individual identity.
</p>
</li>
<li><p><em>dam</em> -  Maternal identity.
</p>
</li>
<li><p><em>sire</em> -  Paternal identity.
</p>
</li>
<li><p><em>survival15</em> -  15-days survival.
</p>
</li>
<li><p><em>prod</em> -  Female productivity.
</p>
</li>
<li><p><em>sex</em> -  Individual sex.
</p>
</li>
<li><p><em>yob</em> -  Year of birth.
</p>
</li>
<li><p><em>pom</em> -  Period of management.
</p>
</li>
<li><p><em>target</em> -  Individual in the target population.
</p>
</li>
<li><p><em>eeza_id</em> -  Individual identity (as recorded in the original studbook)
</p>
</li></ul>



<h3>Source</h3>

<p>The original studbook containing the complete and updated pedigree can be found at: <a href="http://www.eeza.csic.es/en/programadecria.aspx">http://www.eeza.csic.es/en/programadecria.aspx</a>.
</p>


<h3>References</h3>


<ul>
<li><p>López-Cortegano E et al. 2021. Genetic purging in captive endangered ungulates with extremely low effective population sizes. *Heredity*, https://www.nature.com/articles/s41437-021-00473-2.
</p>
</li></ul>


<hr>
<h2 id='exp_F'>Expected inbreeding coefficient</h2><span id='topic+exp_F'></span>

<h3>Description</h3>

<p>Estimates the expected inbreeding coefficient (F) as a function of the effective population size and generation number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp_F(Ne, t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp_F_+3A_ne">Ne</code></td>
<td>
<p>Effective population size</p>
</td></tr>
<tr><td><code id="exp_F_+3A_t">t</code></td>
<td>
<p>Generation number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of the inbreeding coefficient uses the classical formula:
</p>
<p>F(t) = 1 - (1 - 1/2N) ^ t
</p>


<h3>Value</h3>

<p>The inbreeding coefficient
</p>


<h3>References</h3>


<ul>
<li><p>Falconer DS, Mackay TFC. 1996. Introduction to Quantitative Genetics. 4th edition. Longman, Essex, U.K.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ip_F">ip_F</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp_F(Ne = 50, t = 0)
exp_F(Ne = 50, t = 50)
exp_F(Ne = 10, t = 50)
</code></pre>

<hr>
<h2 id='exp_Fa'>Expected ancestral inbreeding coefficient</h2><span id='topic+exp_Fa'></span>

<h3>Description</h3>

<p>Estimates the expected ancestral inbreeding coefficient (Fa) as a function of the effective population size and generation number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp_Fa(Ne, t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp_Fa_+3A_ne">Ne</code></td>
<td>
<p>Effective population size</p>
</td></tr>
<tr><td><code id="exp_Fa_+3A_t">t</code></td>
<td>
<p>Generation number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of the ancestral inbreeding coefficient uses the adaptation from Ballou's (1997) formula, as in López-Cortegano et al. (2018):
</p>
<p>Fa(t) = 1 - (1 - 1/2N) ^ (1/2 (t-1)t)
</p>


<h3>Value</h3>

<p>The ancestral inbreeding coefficient
</p>


<h3>References</h3>


<ul>
<li><p>Ballou JD. 1997. Ancestral inbreeding only minimally affects inbreeding depression in mammalian populations. J Hered. 88:169–178.
</p>
</li>
<li><p>López-Cortegano E et al. 2018. Detection of genetic purging and predictive value of purging parameters estimated in pedigreed populations. Heredity 121(1): 38-51.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ip_Fa">ip_Fa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp_Fa(Ne = 50, t = 0)
exp_Fa(Ne = 50, t = 50)
exp_Fa(Ne = 10, t = 50)
</code></pre>

<hr>
<h2 id='exp_g'>Expected purged inbreeding coefficient</h2><span id='topic+exp_g'></span>

<h3>Description</h3>

<p>Estimates the expected purged inbreeding coefficient (g) as a function of the effective population size, generation number, and purging coefficient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp_g(Ne, t, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp_g_+3A_ne">Ne</code></td>
<td>
<p>Effective population size</p>
</td></tr>
<tr><td><code id="exp_g_+3A_t">t</code></td>
<td>
<p>Generation number</p>
</td></tr>
<tr><td><code id="exp_g_+3A_d">d</code></td>
<td>
<p>Purging coefficient (taking values between 0.0 and 0.5).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of the purged inbreeding coefficient is calculated as in García-Dorado (2012):
</p>
<p>g(t) = [ (1 - 1/2N) g(t-1)  + 1/2N] * [1 - 2d F(t-1)]
</p>
<p>When convergence is reached, the asymptotic value g(a) is returned:
</p>
<p>g(a) = (1 - 2d) / (1 + 2d (2N-1))
</p>


<h3>Value</h3>

<p>The purged inbreeding coefficient
</p>


<h3>References</h3>


<ul>
<li><p>García-Dorado. 2012. Understanding and predicting the fitness decline of shrunk populations: Inbreeding, purging, mutation, and standard selection. Genetics 190: 1-16.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ip_g">ip_g</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp_g(Ne = 50, t = 0, d = 0.15)
exp_g(Ne = 50, t = 50, d = 0.15)
exp_g(Ne = 10, t = 50, d = 0.15)
</code></pre>

<hr>
<h2 id='F'>Inbreeding coefficient</h2><span id='topic+F'></span>

<h3>Description</h3>

<p>Computes the standard inbreeding coefficient (<em>F</em>).
This is the probability that two alleles on a locus are identical by descent (Falconer and Mackay 1996, Wright 1922), calculated from the genealogical coancestry matrix (Malécot 1948).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F(ped, name_to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="F_+3A_name_to">name_to</code></td>
<td>
<p>A string naming the new output column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe, plus an additional column named &quot;F&quot; with individual inbreeding coefficient values.
</p>


<h3>References</h3>


<ul>
<li><p>Falconer DS, Mackay TFC. 1996. Introduction to Quantitative Genetics. 4th edition. Longman, Essex, U.K.
</p>
</li>
<li><p>Malécot G, 1948. Les Mathématiques de l’hérédité. Masson &amp; Cie., Paris.
</p>
</li>
<li><p>Wright S. 1922. Coefficients of inbreeding and relationship. The American Naturalist 56: 330-338.
</p>
</li></ul>


<hr>
<h2 id='Fa'>Ancestral inbreeding coefficient</h2><span id='topic+Fa'></span>

<h3>Description</h3>

<p>Computes the ancestral inbreeding coefficient (<em>Fa</em>).
This is the probability that an allele has been in homozygosity in at least one ancestor (Ballou 1997).
A genedrop approach is included to compute unbiased estimates of <em>Fa</em> (Baumung et al. 2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fa(ped, Fi, name_to, genedrop = 0L, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fa_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="Fa_+3A_fi">Fi</code></td>
<td>
<p>Vector of inbreeding coefficient values</p>
</td></tr>
<tr><td><code id="Fa_+3A_name_to">name_to</code></td>
<td>
<p>A string naming the new output column.</p>
</td></tr>
<tr><td><code id="Fa_+3A_genedrop">genedrop</code></td>
<td>
<p>Number of genedrop iterations to run. If set to zero (as default), Ballou's Fa is computed.</p>
</td></tr>
<tr><td><code id="Fa_+3A_seed">seed</code></td>
<td>
<p>Sets a seed for the random number generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe, plus an additional column named &quot;Fa&quot; with individual ancestral inbreeding coefficient values.
</p>


<h3>References</h3>


<ul>
<li><p>Ballou JD. 1997. Ancestral inbreeding only minimally affects inbreeding depression in mammalian populations. J Hered. 88:169–178.
</p>
</li>
<li><p>Baumung et al. 2015. GRAIN: A computer program to calculate ancestral and partial inbreeding coefficients using a gene dropping approach. Journal of Animal Breeding and Genetics 132: 100-108.
</p>
</li></ul>


<hr>
<h2 id='Fij_core'>Partial inbreeding coefficient (core function)</h2><span id='topic+Fij_core'></span>

<h3>Description</h3>

<p>Computes partial inbreeding coefficients, Fi(j).
A coefficient Fi(j) can be read as the probability of individual i being
homozygous for alleles derived from ancestor j
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fij_core(ped, ancestors, ancestors_idx, Fi, mapa, ncores = 1, genedrop, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fij_core_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="Fij_core_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of the identities to be assumed as founder ancestors.</p>
</td></tr>
<tr><td><code id="Fij_core_+3A_ancestors_idx">ancestors_idx</code></td>
<td>
<p>Index of ancestors.</p>
</td></tr>
<tr><td><code id="Fij_core_+3A_fi">Fi</code></td>
<td>
<p>Vector of inbreeding coefficients.</p>
</td></tr>
<tr><td><code id="Fij_core_+3A_mapa">mapa</code></td>
<td>
<p>Map of ancestors</p>
</td></tr>
<tr><td><code id="Fij_core_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="Fij_core_+3A_genedrop">genedrop</code></td>
<td>
<p>Enable genedrop simulation</p>
</td></tr>
<tr><td><code id="Fij_core_+3A_seed">seed</code></td>
<td>
<p>Sets a seed for the random number generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of partial inbreeding coefficients. Fi(j) values can thus be read from row i and column j.
</p>

<hr>
<h2 id='Fij_core_i_cpp'>Partial inbreeding coefficient (core function)</h2><span id='topic+Fij_core_i_cpp'></span>

<h3>Description</h3>

<p>Computes partial inbreeding coefficients, Fi(j).
A coefficient Fi(j) can be read as the probability of individual i being
homozygous for alleles derived from ancestor j
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fij_core_i_cpp(dam, sire, anc_idx, mapa, Fi, genedrop = 0L, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fij_core_i_cpp_+3A_dam">dam</code></td>
<td>
<p>Vector of dam ids.</p>
</td></tr>
<tr><td><code id="Fij_core_i_cpp_+3A_sire">sire</code></td>
<td>
<p>Vector of sire ids.</p>
</td></tr>
<tr><td><code id="Fij_core_i_cpp_+3A_anc_idx">anc_idx</code></td>
<td>
<p>Index of ancestors.</p>
</td></tr>
<tr><td><code id="Fij_core_i_cpp_+3A_mapa">mapa</code></td>
<td>
<p>Map of ancestors</p>
</td></tr>
<tr><td><code id="Fij_core_i_cpp_+3A_fi">Fi</code></td>
<td>
<p>Vector of inbreeding coefficients.</p>
</td></tr>
<tr><td><code id="Fij_core_i_cpp_+3A_genedrop">genedrop</code></td>
<td>
<p>Enable genedrop simulation</p>
</td></tr>
<tr><td><code id="Fij_core_i_cpp_+3A_seed">seed</code></td>
<td>
<p>Sets a seed for the random number generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of partial inbreeding coefficients. Fi(j) values can thus be read from row i and column j.
</p>

<hr>
<h2 id='g'>Purged inbreeding coefficient</h2><span id='topic+g'></span>

<h3>Description</h3>

<p>Computes the purged inbreeding coefficient (<em>g</em>).
This is the probability that two alleles on a locus are identical by descent,
but relative to deleterious recessive alleles (García-Dorado 2012). The reduction
in <em>g</em> relative to standard inbreeding (<em>F</em>) is given by an effective purging
coefficient (<em>d</em>), that measures the strength of the deleterious recessive
component in the genome. The coefficient <em>g</em> is computed following the methods
for pedigrees in García-Dorado (2012) and García-Dorado et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g(ped, d, Fi, name_to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="g_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="g_+3A_d">d</code></td>
<td>
<p>Purging coefficient (taking values between 0.0 and 0.5).</p>
</td></tr>
<tr><td><code id="g_+3A_fi">Fi</code></td>
<td>
<p>Vector of inbreeding coefficient values</p>
</td></tr>
<tr><td><code id="g_+3A_name_to">name_to</code></td>
<td>
<p>A string naming the new output column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe, plus an additional column named &quot;g&quot; followed by the purging coefficient, containing purged inbreeding coefficient values.
</p>


<h3>References</h3>


<ul>
<li><p>García-Dorado. 2012. Understanding and predicting the fitness decline of shrunk populations: Inbreeding, purging, mutation, and standard selection. Genetics 190: 1-16.
</p>
</li>
<li><p>García-Dorado et al. 2016. Predictive model and software for inbreeding-purging analysis of pedigreed populations. G3 6: 3593-3601.
</p>
</li></ul>


<hr>
<h2 id='hwd'>Deviation from Hardy-Weinberg equilibrium</h2><span id='topic+hwd'></span>

<h3>Description</h3>

<p>Computes the deviation from Hardy-Weinberg equilibrium following Caballero and Toro (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwd(ped, reference = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hwd_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="hwd_+3A_reference">reference</code></td>
<td>
<p>A string naming a column indicating whether individuals belong to the reference population or not. Column must be boolean or coercible to boolean type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value indicating the deviation from Hardy-Weinberg equilibrium.
</p>


<h3>References</h3>


<ul>
<li><p>Caballero A, Toro M. 2000. Interrelations between effective population size and other pedigree tools for the management of conserved populations. Genet. Res. 75: 331-343.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+pop_Ne">pop_Ne</a></code>
</p>

<hr>
<h2 id='idx_ancestors'>Index ancestors</h2><span id='topic+idx_ancestors'></span>

<h3>Description</h3>

<p>Creates a vector of length N (the number of individuals)
Only coordinates for valid ancestors will be given
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idx_ancestors(ids, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idx_ancestors_+3A_ids">ids</code></td>
<td>
<p>Ancestor identities</p>
</td></tr>
<tr><td><code id="idx_ancestors_+3A_n">N</code></td>
<td>
<p>Total number of individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical matrix.
</p>

<hr>
<h2 id='ip_F'>Inbreeding coefficient</h2><span id='topic+ip_F'></span>

<h3>Description</h3>

<p>Computes the standard inbreeding coefficient (<em>F</em>).
This is the probability that two alleles on a locus are identical by descent (Falconer and Mackay 1996, Wright 1922), calculated from the genealogical coancestry matrix (Malécot 1948).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_F(ped, name_to = "Fi")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ip_F_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="ip_F_+3A_name_to">name_to</code></td>
<td>
<p>A string naming the new output column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe, plus an additional column with individual inbreeding coefficient values (named &quot;Fi&quot; by default).
</p>


<h3>References</h3>


<ul>
<li><p>Falconer DS, Mackay TFC. 1996. Introduction to Quantitative Genetics. 4th edition. Longman, Essex, U.K.
</p>
</li>
<li><p>Malécot G, 1948. Les Mathématiques de l’hérédité. Masson &amp; Cie., Paris.
</p>
</li>
<li><p>Wright S. 1922. Coefficients of inbreeding and relationship. The American Naturalist 56: 330-338.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+exp_F">exp_F</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dama)
dama &lt;- ip_F(dama)
tail(dama)
</code></pre>

<hr>
<h2 id='ip_Fa'>Ancestral inbreeding coefficient</h2><span id='topic+ip_Fa'></span>

<h3>Description</h3>

<p>Computes the ancestral inbreeding coefficient (<em>Fa</em>).
This is the probability that an allele has been in homozygosity in at least one ancestor (Ballou 1997).
A genedrop approach is included to compute unbiased estimates of <em>Fa</em> (Baumung et al. 2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_Fa(ped, name_to = "Fa", genedrop = 0, seed = NULL, Fcol = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ip_Fa_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="ip_Fa_+3A_name_to">name_to</code></td>
<td>
<p>A string naming the new output column.</p>
</td></tr>
<tr><td><code id="ip_Fa_+3A_genedrop">genedrop</code></td>
<td>
<p>Number of genedrop iterations to run. If set to zero (as default), Ballou's Fa is computed.</p>
</td></tr>
<tr><td><code id="ip_Fa_+3A_seed">seed</code></td>
<td>
<p>Sets a seed for the random number generator.</p>
</td></tr>
<tr><td><code id="ip_Fa_+3A_fcol">Fcol</code></td>
<td>
<p>Name of column with inbreeding coefficient values. If none is used, inbreeding will be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe, plus an additional column with individual ancestral inbreeding coefficient values (named &quot;Fa&quot; by default).
</p>


<h3>References</h3>


<ul>
<li><p>Ballou JD. 1997. Ancestral inbreeding only minimally affects inbreeding depression in mammalian populations. J Hered. 88:169–178.
</p>
</li>
<li><p>Baumung et al. 2015. GRAIN: A computer program to calculate ancestral and partial inbreeding coefficients using a gene dropping approach. Journal of Animal Breeding and Genetics 132: 100-108.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ip_F">ip_F</a></code>, <code><a href="#topic+exp_Fa">exp_Fa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dama)
# dama &lt;- ip_Fa(dama) # Compute F on the go (won't be kept in the pedigree).
dama &lt;- ip_F(dama)
dama &lt;- ip_Fa(dama, Fcol = 'Fi') # If F is computed in advance.
tail(dama)
</code></pre>

<hr>
<h2 id='ip_Fij'>Partial inbreeding coefficient</h2><span id='topic+ip_Fij'></span>

<h3>Description</h3>

<p>Computes partial inbreeding coefficients, <em>Fi(j)</em>.
A coefficient <em>Fi(j)</em> can be read as the probability of individual <em>i</em> being
homozygous for alleles derived from ancestor <em>j</em>.
It is calculated following the tabular method described by Gulisija &amp; Crow (2007).
Optionally, it can be estimated via genedrop simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_Fij(
  ped,
  mode = "founders",
  ancestors = NULL,
  Fcol = NULL,
  genedrop = 0,
  seed = NULL,
  ncores = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ip_Fij_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="ip_Fij_+3A_mode">mode</code></td>
<td>
<p>Defines the set of ancestors considered when computing partial inbreeding. It can be set as:
&quot;founder&quot; for inbreeding conditional to founders only (default),
&quot;all&quot; for all individuals in the pedigree (it may take long to compute in large pedigrees),
and &quot;custom&quot; for individuals identities given in a integer vector (see 'ancestors' argument).</p>
</td></tr>
<tr><td><code id="ip_Fij_+3A_ancestors">ancestors</code></td>
<td>
<p>Under the &quot;custom&quot; run mode, it defines a vector of ancestors that will be considered
when computing partial inbreeding values.</p>
</td></tr>
<tr><td><code id="ip_Fij_+3A_fcol">Fcol</code></td>
<td>
<p>Name of column with inbreeding coefficient values. If none is used, inbreeding will be computed.</p>
</td></tr>
<tr><td><code id="ip_Fij_+3A_genedrop">genedrop</code></td>
<td>
<p>Number of genedrop iterations to run. If set to zero (as default), exact coefficients are computed.</p>
</td></tr>
<tr><td><code id="ip_Fij_+3A_seed">seed</code></td>
<td>
<p>Sets a seed for the random number generator (only if genedrop is enabled).</p>
</td></tr>
<tr><td><code id="ip_Fij_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel computing (default = 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of partial inbreeding coefficients. <em>Fi(j)</em> values can thus be read from row i and column j.
In the resultant matrix, there are as many rows as individuals in the pedigree, and as many columns as ancestors used.
Columns will be named and sorted by ancestor identity.
</p>


<h3>References</h3>


<ul>
<li><p>Gulisija D, Crow JF. 2007. Inferring purging from pedigree data. Evolution 61(5): 1043-1051.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ip_F">ip_F</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Original pedigree file in Gulisija &amp; Crow (2007)
pedigree &lt;- tibble::tibble(
  id = c("M", "K", "J", "a", "c", "b", "e", "d", "I"),
  dam = c("0", "0", "0", "K", "M", "a", "c", "c", "e"),
  sire = c("0", "0", "0", "J", "a", "J", "b", "b", "d")
)
pedigree &lt;- purgeR::ped_rename(pedigree, keep_names = TRUE)

# Partial inbreeding relative to founder ancestors
m &lt;- ip_Fij(pedigree)
# Note that in the example above, the sum of the values in
# rows will equal the vector of inbreeding coefficients
# i.e. base::rowSums(m) equals purgeR::ip_F(pedigree)$Fi

# Compute partial inbreeding relative to an arbitrary ancestor
# with id = 3 (i.e. individual named "J")
anc &lt;- as.integer(c(3))
m &lt;- ip_Fij(pedigree, mode = "custom", ancestors = anc)
</code></pre>

<hr>
<h2 id='ip_g'>Purged inbreeding coefficient</h2><span id='topic+ip_g'></span>

<h3>Description</h3>

<p>Computes the purged inbreeding coefficient (<em>g</em>).
This is the probability that two alleles on a locus are identical by descent,
but relative to deleterious recessive alleles (García-Dorado 2012). The reduction
in <em>g</em> relative to standard inbreeding (<em>F</em>) is given by an effective purging
coefficient (<em>d</em>), that measures the strength of the deleterious recessive
component in the genome. The coefficient <em>g</em> is computed following the methods
for pedigrees in García-Dorado (2012) and García-Dorado et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_g(ped, d, name_to = "g&lt;d&gt;", Fcol = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ip_g_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="ip_g_+3A_d">d</code></td>
<td>
<p>Purging coefficient (taking values between 0.0 and 0.5).</p>
</td></tr>
<tr><td><code id="ip_g_+3A_name_to">name_to</code></td>
<td>
<p>A string naming the new output column.</p>
</td></tr>
<tr><td><code id="ip_g_+3A_fcol">Fcol</code></td>
<td>
<p>Name of column with inbreeding coefficient values. If none is used, inbreeding will be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe, plus an additional column containing purged inbreeding coefficient values (named &quot;g&quot; and followed by the purging coefficient value by default).
</p>


<h3>References</h3>


<ul>
<li><p>García-Dorado. 2012. Understanding and predicting the fitness decline of shrunk populations: Inbreeding, purging, mutation, and standard selection. Genetics 190: 1-16.
</p>
</li>
<li><p>García-Dorado et al. 2016. Predictive model and software for inbreeding-purging analysis of pedigreed populations. G3 6: 3593-3601.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ip_F">ip_F</a></code> <code><a href="#topic+exp_g">exp_g</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dama)
dama &lt;- ip_g(dama, d = 0.23)
tail(dama)
</code></pre>

<hr>
<h2 id='ip_op'>Opportunity of purging</h2><span id='topic+ip_op'></span>

<h3>Description</h3>

<p>The potential reduction in individual inbreeding load can be
estimated by means of the opportunity of purging (<em>O</em>) and expressed
opportunity of purging (<em>Oe</em>) parameters described by Gulisija
and Crow (2007). Whereas <em>O</em> relates to the total potential reduction
of the inbreeding load in an individual, as a consequence of it having
inbred ancestors, <em>Oe</em> relates to the expressed potential reduction of the
inbreeding load. Only <em>Oe</em> is computed by default. Estimates of <em>O</em>
and <em>Oe</em> need to be corrected in complex pedigrees (see Details below).
Both corrected (named &quot;O&quot; and &quot;Oe&quot; by default), and non-corrected (suffixed
with &quot;_raw&quot;) are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ip_op(
  ped,
  name_Oe = "Oe",
  compute_O = FALSE,
  name_O = "O",
  Fcol = NULL,
  ncores = 1L,
  genedrop = 0,
  seed = NULL,
  complex = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ip_op_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="ip_op_+3A_name_oe">name_Oe</code></td>
<td>
<p>A string naming the new output column for the expressed opportunity of purging (defaults to &quot;Oe&quot;)</p>
</td></tr>
<tr><td><code id="ip_op_+3A_compute_o">compute_O</code></td>
<td>
<p>Enable computation of total opportunity of purging (disabled by default)</p>
</td></tr>
<tr><td><code id="ip_op_+3A_name_o">name_O</code></td>
<td>
<p>A string naming the new output column for total opportunity of purging (defaults to &quot;O&quot;)</p>
</td></tr>
<tr><td><code id="ip_op_+3A_fcol">Fcol</code></td>
<td>
<p>Name of column with inbreeding coefficient values. If none is used, inbreeding will be computed.</p>
</td></tr>
<tr><td><code id="ip_op_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="ip_op_+3A_genedrop">genedrop</code></td>
<td>
<p>Number of genedrop iterations run to compute partial inbreedng. If set to zero (as default), exact coefficients are computed.</p>
</td></tr>
<tr><td><code id="ip_op_+3A_seed">seed</code></td>
<td>
<p>Sets a seed for the random number generator (only if genedrop is enabled).</p>
</td></tr>
<tr><td><code id="ip_op_+3A_complex">complex</code></td>
<td>
<p>Enable correction for complex pedigrees (deprecated in v1.3, both raw and corrected measures of &quot;Oe&quot; are returned now).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model used here assume fully recessive, high effect size alleles (Gulisija and Crow, 2007).
</p>
<p>In simple pedigrees, the opportunity of purging (<em>O</em>) and the expressed
opportunity of purging (<em>Oe</em>) are estimated as in Gulisija and Crow (2007).
For complex pedigrees involving more than one autozygous individual per
path from an individual to an ancestor, <em>O</em> and <em>Oe</em> in the closer ancestors
need to be discounted for what was already accounted for in their predecessors.
To solve this problem, Gulisija and Crow (2007) provide expression to 
correct <em>O</em> and <em>Oe</em> (see equations 21 and 22 in the manuscript). 
</p>
<p>Here, an heuristic approach is used to prevent the inflation of <em>O</em> and <em>Oe</em>,
and avoid the use of additional looped expressions that may result in an
excessive computational cost. To do so, only the contribution of the most recent
ancestors in a path will be considered. Specifically, the method skips contributions
from &quot;far&quot; ancestors <em>k</em>, such that <em>Fj(k) &gt; 0</em>, where <em>j</em> is an intermediate ancestor,
both referred to an individual <em>i</em> of interest. <em>Fj(k)</em> refers to the partial
inbreeding of <em>j</em> for alleles derived from <em>k</em> (see <code><a href="#topic+ip_Fij">ip_Fij</a></code>).
This may not provide exact values of <em>O</em> and <em>Oe</em>, but we expect little bias, since
more distant ancestors also contribute lesser to <em>O</em> and <em>Oe</em>.
</p>
<p>Both types of estimates (corrected and non-corrected) are returned (non-corrected
estimates, prefixed with &quot;_raw&quot;).
</p>


<h3>Value</h3>

<p>The input dataframe, plus an additional column containing <em>Oe</em> and <em>Oe_raw</em> estimates (additional columns for <em>O</em> can appended by enabling <code>compute_O = TRUE</code>).
</p>


<h3>References</h3>


<ul>
<li><p>Gulisija D, Crow JF. 2007. Inferring purging from pedigree data. Evolution 61(5): 1043-1051.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ip_Fij">ip_Fij</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Original pedigree file in Gulisija &amp; Crow (2007)
pedigree &lt;- tibble::tibble(
  id = c("M", "K", "J", "a", "c", "b", "e", "d", "I"),
  dam = c("0", "0", "0", "K", "M", "a", "c", "c", "e"),
  sire = c("0", "0", "0", "J", "a", "J", "b", "b", "d")
)
pedigree &lt;- purgeR::ped_rename(pedigree, keep_names = TRUE)
ip_op(pedigree, compute_O = TRUE)
</code></pre>

<hr>
<h2 id='map_ancestors'>Map ancestors</h2><span id='topic+map_ancestors'></span>

<h3>Description</h3>

<p>Creates a logical matrix that indicates whether an individual i (in columns) is ancestor of other j (in rows)
For example, matrix[, 1] will indicate descendants of id = 1
And matrix[1, ] indicates ancestors of id = 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_ancestors(ped, idx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_ancestors_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="map_ancestors_+3A_idx">idx</code></td>
<td>
<p>Index of ancestors to map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical matrix.
</p>

<hr>
<h2 id='Ne_delta'>Realized effective population size (mean)</h2><span id='topic+Ne_delta'></span><span id='topic+se_Ne_delta'></span>

<h3>Description</h3>

<p>Computes the mean realized effective population size.
Note this function expected a mean delta_F value for all individuals in the reference population
</p>
<p>Computes the standard error of the realized effective population size.
Note this function expects the mean and standard deviation of delta F, as well as the total number of individuals in the reference population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ne_delta(delta)

se_Ne_delta(delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ne_delta_+3A_delta">delta</code></td>
<td>
<p>Vector of individual variations in inbreeding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean effective population size.
</p>
<p>Standard error of the effective population size.
</p>

<hr>
<h2 id='op'>Opportunity of purging</h2><span id='topic+op'></span>

<h3>Description</h3>

<p>The potential reduction in individual inbreeding load can be
estimated by means of the opportunity of purging (<em>O</em>) and expressed
opportunity of purging (<em>Oe</em>) parameters described by Gulisija
and Crow (2007). Whereas <em>O</em> relates to the total potential reduction
of the inbreeding load in an individual, as a consequence of it having
inbred ancestors, <em>Oe</em> relates to the expressed potential reduction of the
inbreeding load. In both cases, these measures are referred to fully recessive,
high effect size alleles (e.g. lethals). For complex pedigrees, involving more than one
autozygous individual per path from a reference individual to an
ancestor, these estimates are estimated following an heuristic approach
(see details below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>op(ped, pi, Fi, name_O, name_Oe, sufix, compute_O = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="op_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="op_+3A_pi">pi</code></td>
<td>
<p>Partial inbreeding matrix</p>
</td></tr>
<tr><td><code id="op_+3A_fi">Fi</code></td>
<td>
<p>Vector of inbreeding coefficient values</p>
</td></tr>
<tr><td><code id="op_+3A_name_o">name_O</code></td>
<td>
<p>A string naming the new output column for total opportunity of purging (defaults to &quot;O&quot;)</p>
</td></tr>
<tr><td><code id="op_+3A_name_oe">name_Oe</code></td>
<td>
<p>A string naming the new output column for the expressed opportunity of purging (defaults to &quot;Oe&quot;)</p>
</td></tr>
<tr><td><code id="op_+3A_sufix">sufix</code></td>
<td>
<p>A string naming the sufix for non-corrected O and Oe measures</p>
</td></tr>
<tr><td><code id="op_+3A_compute_o">compute_O</code></td>
<td>
<p>Enable computation of total opportunity of purging (false by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In simple pedigrees, the opportunity of purging (<em>O</em>) and the expressed
opportunity of purging (<em>Oe</em>) are estimated as in Gulisija and Crow (2007).
For complex pedigrees involving more than one autozygous individual per
path from an individual to an ancestor, <em>O</em> and <em>Oe</em> in the closer ancestors
need to be discounted for what was already accounted for in their predecessors.
To solve this problem, Gulisija and Crow (2007) provide expression to 
correct <em>O</em> and <em>Oe</em> (see equations 21 and 22 in the manuscript).
</p>
<p>Here, an heuristic approach is used to prevent the inflation of <em>O</em> and <em>Oe</em>,
and avoid the use of additional looped expressions that may result in an
excessive computational cost. To do so, when using <code>ip_op(complex = TRUE)</code>
only the contribution of the most recent ancestors in a path will be considered.
This may not provide exact values of <em>O</em> and <em>Oe</em>, but we expect little bias, since
more distant ancestors also contribute lesser to <em>O</em> and <em>Oe</em>.
</p>


<h3>Value</h3>

<p>The input dataframe, plus two additional column named &quot;O&quot; and &quot;Oe&quot;, containing total and expressed opportunity of purging measures.
</p>


<h3>References</h3>


<ul>
<li><p>Gulisija D, Crow JF. 2007. Inferring purging from pedigree data. Evolution 61(5): 1043-1051.
</p>
</li></ul>


<hr>
<h2 id='ped_clean'>Remove individuals not used for purging analyses</h2><span id='topic+ped_clean'></span>

<h3>Description</h3>

<p>Remove individuals that are not necessary for purging analyses involving fitness.
This will reduce the size of the pedigree, and speed up the computation of inbreeding
parameters.
Individuals removed include those with unknown (NA)
values of a given parameter, as long as they do not have any descendant in the
pedigree with known values of that parameter.
Cleaned pedigrees will automatically have individual identities
renamed (see <code><a href="#topic+ped_rename">ped_rename</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped_clean(ped, value_from)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped_clean_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="ped_clean_+3A_value_from">value_from</code></td>
<td>
<p>Name of the column of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the pedigree cleaned for the specificed parameter (column) provided.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ped_rename">ped_rename</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arrui)
nrow(arrui)
arrui &lt;- ped_clean(arrui, "survival15")
nrow(arrui)
</code></pre>

<hr>
<h2 id='ped_graph'>Input for igraph</h2><span id='topic+ped_graph'></span>

<h3>Description</h3>

<p>Processes a pedigree into a list with two objects, one dataframe of edges,
and a dataframe of vertices, which can be used as input for functions of the
igraph package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped_graph(ped)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped_graph_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one dataframe 'edges' and another 'vertices', each following igraph format.
</p>
<p>The 'edges' dataframe will contain two columns in addition to the defaults &quot;from&quot; and &quot;to&quot;:
1) 'from_parent' indicates whether the vertex from which the edge originates represents a mother (&quot;dam&quot;) or a father (&quot;sire&quot;).
2) 'to_parent' indicates whether the vertex to which the edge is directed represents a mother (&quot;dam&quot;), father (&quot;sire&quot;) or none (&quot;NA&quot;).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ped_rename">ped_rename</a></code>, <code><a href="igraph.html#topic+graph_from_data_frame">graph_from_data_frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(atlas)
atlas_graph &lt;- ped_graph(atlas)
G &lt;- igraph::graph_from_data_frame(d = atlas_graph$edges,
                                   vertices = atlas_graph$vertices,
                                   directed = TRUE)
</code></pre>

<hr>
<h2 id='ped_maternal'>Maternal effects</h2><span id='topic+ped_maternal'></span>

<h3>Description</h3>

<p>For every individual in the pedigree, it will assign them their maternal (or
paternal) value for an observed variable of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped_maternal(ped, value_from, name_to, use_dam = TRUE, set_na = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped_maternal_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="ped_maternal_+3A_value_from">value_from</code></td>
<td>
<p>Name of the column of interest.</p>
</td></tr>
<tr><td><code id="ped_maternal_+3A_name_to">name_to</code></td>
<td>
<p>A string naming the new output column.</p>
</td></tr>
<tr><td><code id="ped_maternal_+3A_use_dam">use_dam</code></td>
<td>
<p>Extract maternal values. If false, parental values are returned.</p>
</td></tr>
<tr><td><code id="ped_maternal_+3A_set_na">set_na</code></td>
<td>
<p>When maternal values are unknown, NA values are generated by default. This option allows to set a different value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe, plus an additional column with maternal (or paternal) values of a variable of interest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To assign maternal inbreeding as a new variable, we can do as follows:
data(dama)
dama &lt;- ip_F(dama)
dama &lt;- ped_maternal(dama, value_from = "Fi", name_to = "Fdam")
tail(dama)
</code></pre>

<hr>
<h2 id='ped_rename'>Rename individuals in a pedigree from 1 to N</h2><span id='topic+ped_rename'></span>

<h3>Description</h3>

<p>Functions in <b>purgeR</b> require individuals to be named with integers from 1 to N.
This takes a dataframe containing a pedigree, and rename individuals having
names in any format to that required by other functions in <span class="pkg">purgeR</span>. The
process will also check that the pedigree format is suitable for other functions
in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped_rename(ped, id = "id", dam = "dam", sire = "sire", keep_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped_rename_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="ped_rename_+3A_id">id</code></td>
<td>
<p>A string naming the column with individual identities. It will be renamed to its default value 'id'.</p>
</td></tr>
<tr><td><code id="ped_rename_+3A_dam">dam</code></td>
<td>
<p>A string naming the column with maternal identities. It will be renamed to its default value 'dam'.</p>
</td></tr>
<tr><td><code id="ped_rename_+3A_sire">sire</code></td>
<td>
<p>A string naming the column with paternal identities. It will be renamed to its default value 'sire'.</p>
</td></tr>
<tr><td><code id="ped_rename_+3A_keep_names">keep_names</code></td>
<td>
<p>A boolean value indicating whether the original identity values should be kept on a separate column (named 'names'), or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the pedigree's identities renamed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ped_clean">ped_clean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(darwin)
darwin &lt;- ped_rename(darwin, id = "Individual", dam = "Mother", sire = "Father", keep_names = TRUE)
head(darwin)
</code></pre>

<hr>
<h2 id='ped_sort'>Sort individuals (with ancestors on top of descendants)</h2><span id='topic+ped_sort'></span>

<h3>Description</h3>

<p>Individuals can be sorted according to the pedigree structure, without need of birth dates.
In the sorted pedigree, descendants will always be placed in rows with higher index number
than that of their ancestors. This way, individuals born first will tend to be in the top
of the pedigree. Younger individuals, and individuals with no descendants will tend to be
placed at the bottom.
This function uses the sorting algorithm developed by Zhang et al (2009).
After sorting, individuals will be renamed from 1 to N using <code><a href="#topic+ped_rename">ped_rename</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped_sort(ped, id = "id", dam = "dam", sire = "sire", keep_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped_sort_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="ped_sort_+3A_id">id</code></td>
<td>
<p>A string naming the column with individual identities. It will be renamed to its default value 'id'.</p>
</td></tr>
<tr><td><code id="ped_sort_+3A_dam">dam</code></td>
<td>
<p>A string naming the column with maternal identities. It will be renamed to its default value 'dam'.</p>
</td></tr>
<tr><td><code id="ped_sort_+3A_sire">sire</code></td>
<td>
<p>A string naming the column with paternal identities. It will be renamed to its default value 'sire'.</p>
</td></tr>
<tr><td><code id="ped_sort_+3A_keep_names">keep_names</code></td>
<td>
<p>A boolean value indicating whether the original identity values should be kept on a separate column (named 'names'), or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sorted pedigree dataframe (with ancestors on top of descendants).
</p>


<h3>References</h3>


<ul>
<li><p>Zhang Z, Li C, Todhunter RJ, Lust G, Goonewardene L, Wang Z. 2009. An algorithm to sort complex pedigrees chronologically without birthdates. J Anim Vet Adv. 8 (1): 177-182.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ped_rename">ped_rename</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(darwin)
# Here we reshuffle rows in the pedigree. It won't be usable for other functions in the package
darwin &lt;- darwin[sample(1:nrow(darwin)), ]
# Below, we sort the pedigree again. The order might not be the same as before.
# But ancestors will always be placed on top of descendants,
# making the pedigree usable for other functions in the package.
darwin &lt;- ped_sort(darwin, id = "Individual", dam = "Mother", sire = "Father", keep_names = TRUE)
</code></pre>

<hr>
<h2 id='ped_sort_i'>Sorting steps</h2><span id='topic+ped_sort_i'></span><span id='topic+sort_step'></span>

<h3>Description</h3>

<p>Recursive function that computes steps for sorting algorithm described by Zhang et al (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_step(p, id, dam, sire, t, S, G, t_G)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped_sort_i_+3A_p">p</code></td>
<td>
<p>Pedigree to sort (used as template)</p>
</td></tr>
<tr><td><code id="ped_sort_i_+3A_id">id</code></td>
<td>
<p>A string naming the column with individual identities. It will be renamed to its default value 'id'.</p>
</td></tr>
<tr><td><code id="ped_sort_i_+3A_dam">dam</code></td>
<td>
<p>A string naming the column with maternal identities. It will be renamed to its default value 'dam'.</p>
</td></tr>
<tr><td><code id="ped_sort_i_+3A_sire">sire</code></td>
<td>
<p>A string naming the column with paternal identities. It will be renamed to its default value 'sire'.</p>
</td></tr>
<tr><td><code id="ped_sort_i_+3A_t">t</code></td>
<td>
<p>Template for the new sorted pedigree</p>
</td></tr>
<tr><td><code id="ped_sort_i_+3A_s">S</code></td>
<td>
<p>Vector of assumed parent individuals</p>
</td></tr>
<tr><td><code id="ped_sort_i_+3A_g">G</code></td>
<td>
<p>Vector of generation numbers (0 identifies the youngest)</p>
</td></tr>
<tr><td><code id="ped_sort_i_+3A_t_g">t_G</code></td>
<td>
<p>Vector G for the new sorted pedigree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Will print an error message if checking fail.
</p>
<p>Filled template for the sorted pedigree. Once recursion ends, it returns the sorted pedigree
</p>


<h3>References</h3>


<ul>
<li><p>Zhang Z, Li C, Todhunter RJ, Lust G, Goonewardene L, Wang Z. 2009. An algorithm to sort complex pedigrees chronologically without birthdates. J Anim Vet Adv. 8 (1): 177-182.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ped_sort">ped_sort</a></code>
</p>

<hr>
<h2 id='pop_hwd'>Deviation from Hardy-Weinberg equilibrium</h2><span id='topic+pop_hwd'></span>

<h3>Description</h3>

<p>Computes the deviation from Hardy-Weinberg equilibrium following Caballero and Toro (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_hwd(ped, reference = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pop_hwd_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="pop_hwd_+3A_reference">reference</code></td>
<td>
<p>A string naming a column indicating whether individuals belong to the reference population or not. Column must be boolean or coercible to boolean type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value indicating the deviation from Hardy-Weinberg equilibrium.
</p>


<h3>References</h3>


<ul>
<li><p>Caballero A, Toro M. 2000. Interrelations between effective population size and other pedigree tools for the management of conserved populations. Genet. Res. 75: 331-343.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+pop_Ne">pop_Ne</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(atlas)
pop_hwd(dama)
</code></pre>

<hr>
<h2 id='pop_Nancestors'>Population founders and ancestors</h2><span id='topic+pop_Nancestors'></span><span id='topic+pop_Nf'></span><span id='topic+pop_Nfe'></span><span id='topic+pop_Na'></span><span id='topic+pop_Nae'></span><span id='topic+pop_Ng'></span>

<h3>Description</h3>

<p>Estimate the total and effective number of founders and ancestors
in a pedigree, as well as the number of founder genome equivalents
(see details on these parameters below).
Note that a reference population (RP) must be defined, so that founders
and ancestors are referred to the set of individuals belonging to
that RP. This is set by means of a boolean vector passed as argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_Nancestors(ped, reference, nboot = 10000L, seed = NULL, skip_Ng = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pop_Nancestors_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="pop_Nancestors_+3A_reference">reference</code></td>
<td>
<p>A string naming a column indicating whether individuals belong to the reference population or not. Column must be boolean or coercible to boolean type.</p>
</td></tr>
<tr><td><code id="pop_Nancestors_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap iterations (for computing <em>Ng</em>).</p>
</td></tr>
<tr><td><code id="pop_Nancestors_+3A_seed">seed</code></td>
<td>
<p>Sets a seed for the random number generator.</p>
</td></tr>
<tr><td><code id="pop_Nancestors_+3A_skip_ng">skip_Ng</code></td>
<td>
<p>Skip <em>Ng</em> computation or not (FALSE by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total number of founders (<em>Nf</em>) and ancestors (<em>Na</em>)
are calculated simply as the count of founders and ancestors of
individuals belonging to the reference population (RP).
Founders here are defined as individuals with both parentals unknown.
</p>
<p>The effective number of founders (<em>Nfe</em>) is the number of equally
contributing founders, that would account for observed genetic diversity
in the RP, while the effective number of ancestors (<em>Nae</em>)
is defined as the minimum number of ancestors, founders or not, required
to account for the genetic diversity observed in the RP.
These parameters are computed from the probability of gene origin,
following methods in Tahmoorespur and Sheikhloo (2011).
</p>
<p>While the previous parameters account for diversity loss due to bottlenecks
at the level of founders or ancestors, other sources of random loss of
alleles (such as drift) can be accounted by means of the number of
founder genome equivalents (<em>Ng</em>, Caballero and Toro 2000).
This parameter is estimated via Monte Carlo simulation of allele segregation,
following Boichard et al. (1997).
</p>


<h3>Value</h3>

<p>A dataframe containing population size estimates for founders and ancestors:
</p>

<ul>
<li><p><em>Nr</em> -  Total number of individuals in the RP
</p>
</li>
<li><p><em>Nf</em> -  Total number of founders
</p>
</li>
<li><p><em>Nfe</em> -  Effective number of founders
</p>
</li>
<li><p><em>Na</em> -  Total number of ancestors
</p>
</li>
<li><p><em>Nae</em> -  Effective number of ancestors
</p>
</li>
<li><p><em>Ng</em> -  Number of founder genome equivalents
</p>
</li>
<li><p><em>se_Ng</em> -  Standard error of Ng
</p>
</li></ul>

<p>If some of the auxiliary functions is used (e.g. <em>pop_Nr</em>), only the corresponding numerical estimate will be returned.
In the case of <em>pop_Ng</em>, a list object is returned, with the number of founder genome equivalents (Ng) and its standard error (se_Ng).
</p>


<h3>References</h3>


<ul>
<li><p>Boichard D, Maignel L, Verrier E. 1997. The value of using probabilities of gene origin to measure genetic variability in a population. Genet. Sel. Evol. 29: 5-23.
</p>
</li>
<li><p>Caballero A, Toro M. 2000. Interrelations between effective population size and other pedigree tools for the management of conserved populations. Genet. Res. 75: 331-343.
</p>
</li>
<li><p>Tahmoorespur M, Sheikhloo M. 2011. Pedigree analysis of the closed nucleus of Iranian Baluchi sheep. Small Rumin. Res. 99: 1-6.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(arrui)
pop_Nancestors(arrui, reference = "target", skip_Ng = TRUE)
</code></pre>

<hr>
<h2 id='pop_Ne'>Effective population size</h2><span id='topic+pop_Ne'></span>

<h3>Description</h3>

<p>Estimate the effective population size (<em>Ne</em>). This is computed from the increase in individual inbreeding, following the method described by Gutiérrez et al (2008, 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_Ne(ped, Fcol, tcol)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pop_Ne_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="pop_Ne_+3A_fcol">Fcol</code></td>
<td>
<p>Name of column with inbreeding coefficient values.</p>
</td></tr>
<tr><td><code id="pop_Ne_+3A_tcol">tcol</code></td>
<td>
<p>Name of column with generation numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the effective population size (Ne) and its standard error (se_Ne).
</p>


<h3>References</h3>


<ul>
<li><p>Gutiérrez JP, Cervantes I, Molina A, Valera M, Goyache F. 2008. Individual increase in inbreeding allows estimating effective sizes from pedigrees. Genet. Sel. Evol. 40: 359-378.
</p>
</li>
<li><p>Gutiérrez JP, Cervantes I, Goyache F. 2009. Improving the estimation of realized effective population sizes in farm animals. J. Anim. Breed. Genet. 126: 327-332.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ip_F">ip_F</a></code>, <code><a href="#topic+pop_t">pop_t</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(atlas)
atlas &lt;- ip_F(atlas) # compute inbreeding, appending column "F"
atlas &lt;- pop_t(atlas) # compute generations, appending column "t"
pop_Ne(atlas, Fcol = "Fi", tcol = "t")
</code></pre>

<hr>
<h2 id='pop_t'>Number of equivalent complete generations</h2><span id='topic+pop_t'></span>

<h3>Description</h3>

<p>Computes the number of equivalent complete generations (<em>t</em>), as defined by Boichard et al (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_t(ped, name_to = "t")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pop_t_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="pop_t_+3A_name_to">name_to</code></td>
<td>
<p>A string naming the new output column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe, plus an additional column corresponding to the number of equivalent complete generations of every individual (named &quot;t&quot; by default).
</p>


<h3>References</h3>


<ul>
<li><p>Boichard D, Maignel L, Verrier E. 1997. The value of using probabilities of gene origin to measure genetic variability in a population. Genet. Sel. Evol., 29: 5-23.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+pop_Ne">pop_Ne</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dama)
dama &lt;- pop_t(dama)
tail(dama)
</code></pre>

<hr>
<h2 id='reproductive_value'>Reproductive value</h2><span id='topic+reproductive_value'></span>

<h3>Description</h3>

<p>Computes the reproductive value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reproductive_value(
  ped,
  reference,
  name_to,
  target = NULL,
  enable_correction = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reproductive_value_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="reproductive_value_+3A_reference">reference</code></td>
<td>
<p>A string naming a column indicating whether individuals belong to the reference population or not. Column must be boolean or coercible to boolean type.</p>
</td></tr>
<tr><td><code id="reproductive_value_+3A_name_to">name_to</code></td>
<td>
<p>A string naming the new output column.</p>
</td></tr>
<tr><td><code id="reproductive_value_+3A_target">target</code></td>
<td>
<p>A string naming a column indicating whether individuals belong to the target population or not. Column must be boolean or coercible to boolean type. By default, all descendants of the reference population are used.</p>
</td></tr>
<tr><td><code id="reproductive_value_+3A_enable_correction">enable_correction</code></td>
<td>
<p>Correct reproductive values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe, plus an additional column with reproductive values for the reference and target populations assumed.
</p>


<h3>References</h3>

<p>Hunter DC et al. 2019. Pedigree-based estimation of reproductive value. Journal of Heredity 110 (4): 433-444
</p>

<hr>
<h2 id='sample_allele'>Sample dam or sire inherited allele</h2><span id='topic+sample_allele'></span>

<h3>Description</h3>

<p>Given two alleles (one from dam, the other from sire), it samples one at random.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_allele_+3A_dam_al">dam_al</code></td>
<td>
<p>Dam allele.</p>
</td></tr>
<tr><td><code id="sample_allele_+3A_sire_al">sire_al</code></td>
<td>
<p>Sire allele.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sampled allele.
</p>

<hr>
<h2 id='search_ancestors'>Search and individuals' ancestors</h2><span id='topic+search_ancestors'></span>

<h3>Description</h3>

<p>Recursive function that gathers all founders and ancestors for a given individual
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_ancestors_+3A_dam">dam</code></td>
<td>
<p>Vector of dams.</p>
</td></tr>
<tr><td><code id="search_ancestors_+3A_sire">sire</code></td>
<td>
<p>Vector of sires.</p>
</td></tr>
<tr><td><code id="search_ancestors_+3A_i">i</code></td>
<td>
<p>Reference individual (its index, not id).</p>
</td></tr>
<tr><td><code id="search_ancestors_+3A_fnd">fnd</code></td>
<td>
<p>Vector of founders (to be returned as reference).</p>
</td></tr>
<tr><td><code id="search_ancestors_+3A_anc">anc</code></td>
<td>
<p>Vector of ancestors (to be returned as reference).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sampled allele.
</p>

<hr>
<h2 id='w_grandoffspring'>Grandoffspring</h2><span id='topic+w_grandoffspring'></span>

<h3>Description</h3>

<p>Counts the number of grandoffspring for individuals in the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w_grandoffspring(ped, name_to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="w_grandoffspring_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="w_grandoffspring_+3A_name_to">name_to</code></td>
<td>
<p>A string naming the new output column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe, plus an additional column indicating the total number of grandoffspring.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arrui)
dama &lt;- w_grandoffspring(arrui, name_to = "G")
head(arrui)
</code></pre>

<hr>
<h2 id='w_offspring'>Offspring</h2><span id='topic+w_offspring'></span>

<h3>Description</h3>

<p>Counts the number of offspring for individuals in the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w_offspring(ped, name_to, dam_offspring = TRUE, sire_offspring = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="w_offspring_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="w_offspring_+3A_name_to">name_to</code></td>
<td>
<p>A string naming the new output column.</p>
</td></tr>
<tr><td><code id="w_offspring_+3A_dam_offspring">dam_offspring</code></td>
<td>
<p>Compute dam offspring (TRUE by default).</p>
</td></tr>
<tr><td><code id="w_offspring_+3A_sire_offspring">sire_offspring</code></td>
<td>
<p>Compute sire offspring (TRUE by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe, plus an additional column indicating the total number of offspring.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arrui)
dama &lt;- w_offspring(arrui, name_to = "P")
head(arrui)
</code></pre>

<hr>
<h2 id='w_reproductive_value'>Reproductive value</h2><span id='topic+w_reproductive_value'></span>

<h3>Description</h3>

<p>Computes the reproductive value following the method by Hunter et al. (2019).
This is a measure of how well a gene originated in a set of 'reference' individuals
is represented in a different set of 'target' individuals. By default, fitness is
computed for individuals in the reference population, using all of their descendants
as target. A generation-wise mode can also be enabled, to compute fitness
contributions consecutively from one generation to the next.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w_reproductive_value(
  ped,
  reference,
  name_to,
  target = NULL,
  enable_correction = TRUE,
  generation_wise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="w_reproductive_value_+3A_ped">ped</code></td>
<td>
<p>A dataframe containing the pedigree. Individual (id), maternal (dam), and paternal (sire) identities are mandatory columns.</p>
</td></tr>
<tr><td><code id="w_reproductive_value_+3A_reference">reference</code></td>
<td>
<p>A string naming a column indicating whether individuals belong to the reference population or not. Column must be boolean or coercible to boolean type.</p>
</td></tr>
<tr><td><code id="w_reproductive_value_+3A_name_to">name_to</code></td>
<td>
<p>A string naming the new output column.</p>
</td></tr>
<tr><td><code id="w_reproductive_value_+3A_target">target</code></td>
<td>
<p>A string naming a column indicating whether individuals belong to the target population or not. Column must be boolean or coercible to boolean type. By default, all descendants of the reference population are used.</p>
</td></tr>
<tr><td><code id="w_reproductive_value_+3A_enable_correction">enable_correction</code></td>
<td>
<p>Correct reproductive values (enabled by default).</p>
</td></tr>
<tr><td><code id="w_reproductive_value_+3A_generation_wise">generation_wise</code></td>
<td>
<p>Assume that the reference population is a vector of integers indicating generation numbers. Reproductive values will be computed generation by generation independently (except for the last one).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A reference population must be defined, which represents a set of individuals
whose reproductive value is to be calculated.
By default, genetic contributions to the rest of individuals in the pedigree
is assumed, but a target population can also be defined, restricting the set
of individuals accounted when computing the reproductive value. 
This could represent for example a cohort of alive individuals.
</p>


<h3>Value</h3>

<p>The input dataframe, plus an additional column with reproductive values for the reference and target populations assumed.
</p>


<h3>References</h3>


<ul>
<li><p>Hunter DC et al. 2019. Pedigree-based estimation of reproductive value. Journal of Heredity 10(4): 433-444.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(magrittr)
# Pedigree used in Hunter et al. (2019)
id &lt;- c("A1", "A2", "A3", "A4", "A5", "A6",
        "B1", "B2", "B3", "B4",
        "C1", "C2", "C3", "C4")
dam &lt;- c("0", "0", "0", "0", "0", "0",
         "A2", "A2", "A2", "A4",
         "B2", "B2", "A4", "A6")
sire &lt;- c("0", "0", "0", "0", "0", "0",
          "A1", "A1", "A1", "A5",
          "B1", "B3", "B3", "A5")
t &lt;- c(0, 0, 0, 0, 0, 0,
       1, 1, 1, 1,
       2, 2, 2, 2)
ped &lt;- tibble::tibble(id, dam, sire, t)
ped &lt;- purgeR::ped_rename(ped, keep_names = TRUE) %&gt;%
 dplyr::mutate(reference = ifelse(t == 1, TRUE, FALSE))
purgeR::w_reproductive_value(ped, reference = "reference", name_to = "R")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
