<!DOCTYPE html><html><head><title>Help for package BeviMed</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BeviMed}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BeviMed-package'>
<p>Bayesian Evaluation of Variant Involvement in Mendelian Disease</p></a></li>
<li><a href='#bevimed'><p>Bayesian Evaluation of Variant Involvement in Mendelian Disease</p></a></li>
<li><a href='#bevimed_m'><p>Perform inference under model gamma = 1 conditional on mode of inheritance</p></a></li>
<li><a href='#bevimed_polytomous'><p>Model selection for multiple association models</p></a></li>
<li><a href='#call_cpp'><p>R interface to BeviMed c++ MCMC procedure</p></a></li>
<li><a href='#CI_gamma1_evidence'><p>Estimate confidence interval for estimated marginal likelihood</p></a></li>
<li><a href='#conditional_prob_pathogenic'><p>Calculate probability of pathogencity for variants conditional on mode of inheritance.</p></a></li>
<li><a href='#expected_explained'><p>Calculate expected number of explained cases</p></a></li>
<li><a href='#explaining_variants'><p>Calculate expected number of pathogenic variants in cases</p></a></li>
<li><a href='#extract_conditional_prob_pathogenic'><p>Extract probability of pathogenicity for variant conditional on a given association model</p></a></li>
<li><a href='#extract_expected_explained'><p>Extract expected number of explained cases</p></a></li>
<li><a href='#extract_explaining_variants'><p>Extract expected number of pathogenic variants in cases</p></a></li>
<li><a href='#extract_gamma1_evidence'><p>Extract evidence for model gamma = 1</p></a></li>
<li><a href='#extract_prob_association'><p>Extract the posterior probability of association</p></a></li>
<li><a href='#extract_prob_pathogenic'><p>Extract variant marginal probabilities of pathogenicity</p></a></li>
<li><a href='#gamma0_evidence'><p>Calculate marginal probability of observed case-control status y under model gamma = 0</p></a></li>
<li><a href='#gamma1_evidence'><p>Calculate evidence under model gamma = 1</p></a></li>
<li><a href='#log_BF'><p>Calculate log Bayes factor between an association model with a given mode of inheritance and model gamma = 0</p></a></li>
<li><a href='#print.BeviMed'><p>Print readable summary of <code>BeviMed</code> object</p></a></li>
<li><a href='#print.BeviMed_m'><p>Print <code>BeviMed_m</code> object</p></a></li>
<li><a href='#print.BeviMed_summary'><p>Print readable summary of <code>BeviMed_summary</code> object.</p></a></li>
<li><a href='#prob_association'><p>Calculate probability of association</p></a></li>
<li><a href='#prob_association_m'><p>Calculate probability of association for one mode of inheritance</p></a></li>
<li><a href='#prob_pathogenic'><p>Calculate variant marginal probabilities of pathogencity</p></a></li>
<li><a href='#stack_BeviMeds'><p>Concatenate objects of class <code>BeviMed_raw</code></p></a></li>
<li><a href='#stop_chain'><p>Apply the MCMC algorithm in blocks until conditions are met</p></a></li>
<li><a href='#subset_variants'><p>Remove variants with no data for pathogenicity</p></a></li>
<li><a href='#sum_ML_over_PP'><p>Calculate marginal likelihood from power posteriors output</p></a></li>
<li><a href='#summary.BeviMed'><p>Summarise a <code>BeviMed</code> object</p></a></li>
<li><a href='#summary.BeviMed_m'><p>Summarise a <code>BeviMed_m</code> object</p></a></li>
<li><a href='#tune_proposal_sds'><p>Tune proposal standard deviation for MH sampled parameters</p></a></li>
<li><a href='#tune_temperatures'><p>Tune temperatures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Evaluation of Variant Involvement in Mendelian Disease</td>
</tr>
<tr>
<td>Version:</td>
<td>5.10</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Greene, Sylvia Richardson and Ernest Turro</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Greene &lt;dg333@cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A fast integrative genetic association test for rare diseases based on a model for disease status given allele counts at rare variant sites. Probability of association, mode of inheritance and probability of pathogenicity for individual variants are all inferred in a Bayesian framework - 'A Fast Association Test for Identifying Pathogenic Variants Involved in Rare Diseases', Greene et al 2017 &lt;<a href="https://doi.org/10.1016%2Fj.ajhg.2017.05.015">doi:10.1016/j.ajhg.2017.05.015</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.3), Matrix, methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-29 17:25:27 UTC; dg</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-29 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BeviMed-package'>
Bayesian Evaluation of Variant Involvement in Mendelian Disease 
</h2><span id='topic+BeviMed-package'></span><span id='topic+BeviMed'></span>

<h3>Description</h3>

<p>A fast integrative genetic association test for rare diseases.
</p>


<h3>Details</h3>

<p>BeviMed estimates a probability of association between a case/control label and allele counts at rare variant sites in a genomic locus and also, given that there is an association, the probabilities that each variant is involved in the disease. It does so by estimating the evidence for a model where the case/control label is independent of the allele configurations, and a model in which the probability of the case/control label depends on the corresponding allele configuration and a latent partition of variants into pathogenic and non-pathogenic groups.
</p>


<h3>Author(s)</h3>

<p>Daniel Greene.
</p>
<p>Maintainer: Daniel Greene &lt;dg333@cam.ac.uk&gt;
</p>


<h3>References</h3>

<p>Greene et al., A Fast Association Test for Identifying Pathogenic Variants Involved in Rare Diseases, The American Journal of Human Genetics (2017), http://dx.doi.org/10.1016/j.ajhg.2017.05.015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bevimed">bevimed</a></code>
</p>

<hr>
<h2 id='bevimed'>Bayesian Evaluation of Variant Involvement in Mendelian Disease</h2><span id='topic+bevimed'></span>

<h3>Description</h3>

<p>Infer probabilities of association between disease label and locus and posterior parameter values under BeviMed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bevimed(
  y,
  G,
  ploidy = rep(2L, length(y)),
  prior_prob_association = 0.01,
  prior_prob_dominant = 0.5,
  dominant_args = NULL,
  recessive_args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bevimed_+3A_y">y</code></td>
<td>
<p>Logical vector of case (<code>TRUE</code>) control (<code>FALSE</code>) status.</p>
</td></tr>
<tr><td><code id="bevimed_+3A_g">G</code></td>
<td>
<p>Integer matrix of variant counts per individual, one row per individual and one column per variant.</p>
</td></tr>
<tr><td><code id="bevimed_+3A_ploidy">ploidy</code></td>
<td>
<p>Integer vector giving ploidy of samples.</p>
</td></tr>
<tr><td><code id="bevimed_+3A_prior_prob_association">prior_prob_association</code></td>
<td>
<p>The prior probability of association.</p>
</td></tr>
<tr><td><code id="bevimed_+3A_prior_prob_dominant">prior_prob_dominant</code></td>
<td>
<p>The prior probability of dominant inheritance given that there is an association.</p>
</td></tr>
<tr><td><code id="bevimed_+3A_dominant_args">dominant_args</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+bevimed_m">bevimed_m</a></code> conditioning on dominant inheritance.</p>
</td></tr>
<tr><td><code id="bevimed_+3A_recessive_args">recessive_args</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+bevimed_m">bevimed_m</a></code> conditioning on recessive inheritance.</p>
</td></tr>
<tr><td><code id="bevimed_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+bevimed_m">bevimed_m</a></code> for both modes of inheritance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>BeviMed</code> object containing results of inference.
</p>


<h3>References</h3>

<p>Greene et al., A Fast Association Test for Identifying Pathogenic Variants Involved in Rare Diseases, The American Journal of Human Genetics (2017), http://dx.doi.org/10.1016/j.ajhg.2017.05.015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prob_association">prob_association</a></code>, <code><a href="#topic+bevimed_m">bevimed_m</a></code>, <code><a href="#topic+summary.BeviMed">summary.BeviMed</a></code>, <code><a href="#topic+bevimed_polytomous">bevimed_polytomous</a></code>
</p>

<hr>
<h2 id='bevimed_m'>Perform inference under model gamma = 1 conditional on mode of inheritance</h2><span id='topic+bevimed_m'></span>

<h3>Description</h3>

<p>Sample from posterior distribution of parameters under model gamma = 1 and conditional on mode of inheritance, set via the <code>min_ac</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bevimed_m(
  y,
  G,
  min_ac = 1L,
  tau_shape = c(1, 1),
  pi_shape = c(6, 1),
  omega_shape = if (max(min_ac) == 1L) c(2, 8) else c(2, 2),
  samples_per_chain = 1000,
  stop_early = FALSE,
  blocks = 5,
  burn = as.integer(samples_per_chain/10),
  temperatures = (0:6/6)^2,
  tune_temps = 0,
  vec_sums = FALSE,
  return_z_trace = TRUE,
  return_x_trace = TRUE,
  raw_only = FALSE,
  swaps = as.integer(length(temperatures)/2),
  optimise_z0 = FALSE,
  tune_omega_and_phi_proposal_sd = FALSE,
  tune_block_size = 100,
  variant_weights = NULL,
  standardise_weights = TRUE,
  log_phi_mean = -0.15,
  log_phi_sd = sqrt(0.3),
  tandem_variant_updates = if (max(min_ac) == 1) 0 else min(sum(y), ncol(G)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bevimed_m_+3A_y">y</code></td>
<td>
<p>Logical vector of case (<code>TRUE</code>) control (<code>FALSE</code>) status.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_g">G</code></td>
<td>
<p>Integer matrix of variant counts per individual, one row per individual and one column per variant.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_min_ac">min_ac</code></td>
<td>
<p>Integer vector with a length equalling the number of individuals or length <code>1</code> (in which case the given value is used for all individuals) giving the minimum number of alleles at pathogenic variant sites each individual requires in order to classify as having a &lsquo;pathogenic allele configuration&rsquo;. Thus, this parameter encodes the mode of inheritance. For instance, setting this parameter to <code>1</code> corresponds to dominant inheritance. If there are differences in ploidy between individuals in the locus, it is necessary to set it on an sample level basis - e.g. to ensure sex is accounted for if the locus lies on the X chromosome.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_tau_shape">tau_shape</code></td>
<td>
<p>Beta shape hyper-priors for prior on rate of affection (i.e. being a case) amongst individuals with non-pathogenic variant combinations (i.e. they have less than <code>min_ac</code> variants.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_pi_shape">pi_shape</code></td>
<td>
<p>Beta shape hyper-priors for prior on rate of affection (i.e. being a case) amongst individuals with pathogenic variant combinations (i.e. they have at least <code>min_ac</code> variants.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_omega_shape">omega_shape</code></td>
<td>
<p>Beta shape hyper-priors for prior on rate of pathogenicity amongst variants.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_samples_per_chain">samples_per_chain</code></td>
<td>
<p>Number of samples to draw from each chain.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_stop_early">stop_early</code></td>
<td>
<p>Logical value determining whether to attempt to stop the sampling as soon as certain conditions are met (i.e. either the estimated marginal log likelihood lies within a certain confidence interval, or we are sufficiently confidence that the log Bayes factor against of model gamma = 1 over model gamma = 0 is sufficiently low).</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_blocks">blocks</code></td>
<td>
<p>Maximum number of blocks of <code>samples_per_chain</code> samples to draw before either the confidence interval for the marginal likelihood under the model gamma = 1 is sufficiently small or terminating the sampling. This parameter is ignored if unless <code>stop_early==TRUE</code>.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_burn">burn</code></td>
<td>
<p>Number of samples to drop from the start of the chain.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_temperatures">temperatures</code></td>
<td>
<p>Numeric vector of temperatures of power posteriors. One chain will be created for each element of the vector at the corresponding temperature.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_tune_temps">tune_temps</code></td>
<td>
<p>Integer value - if greater than 0, the <code>temperatures</code> argument is ignored, and instead <code>tune_temps</code> tuned temperatures are used instead.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_vec_sums">vec_sums</code></td>
<td>
<p>Logical value determining whether to calculate vector summary statistics.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_return_z_trace">return_z_trace</code></td>
<td>
<p>Logical value determining whether to store the z-vectors for each chain, which uses alot of memory, particularly if <code>samples_per_chain</code>, k and <code>length(temperatures)</code> are large.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_return_x_trace">return_x_trace</code></td>
<td>
<p>Logical value determining whether to store the x variable determined by success samples of z. Potentially uses alot of memory, particularly if <code>samples_per_chain</code>, k and <code>length(temperatures)</code> are large.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_raw_only">raw_only</code></td>
<td>
<p>Logical value determining whether to return raw output of MCMC routine only.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_swaps">swaps</code></td>
<td>
<p>Number of swaps between adjacent tempered chains to perform per update cycle.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_optimise_z0">optimise_z0</code></td>
<td>
<p>Logical value determining whether to use a simulated annealing optimisation run to tune the initial values of <code>z</code>.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_tune_omega_and_phi_proposal_sd">tune_omega_and_phi_proposal_sd</code></td>
<td>
<p>Logical value determining whether the proposal SDs of the Metropolis-Hastings estimated parameters should be tuned for a target acceptance range.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_tune_block_size">tune_block_size</code></td>
<td>
<p>Integer value giving number of samples to draw when estimatating the acceptance rate of the omega/phi proposals.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_variant_weights">variant_weights</code></td>
<td>
<p>Vector of log-odds off-sets for rates of pathogenicity of individual variants relative to the global rate, omega.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_standardise_weights">standardise_weights</code></td>
<td>
<p>Boolean value determining whether weights should be standardised by subtracting their mean and dividing by their sample standard deviation. If <code>FALSE</code>, weights are untransformed.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_log_phi_mean">log_phi_mean</code></td>
<td>
<p>Mean for normal prior on scaling factor phi.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_log_phi_sd">log_phi_sd</code></td>
<td>
<p>SD for normal prior on scaling factor phi. Setting to 0 causes the weights to be fixed and not estimated.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_tandem_variant_updates">tandem_variant_updates</code></td>
<td>
<p>Number of tandem variant updates to make per update cycle.</p>
</td></tr>
<tr><td><code id="bevimed_m_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+stop_chain">stop_chain</a></code> and/or <code><a href="#topic+tune_proposal_sds">tune_proposal_sds</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>BeviMed_m</code> object is a list containing elements:
</p>

<ul>
<li><p> &lsquo;parameters&rsquo;: a list containing arguments used in the function call, including the adjusted weights used in the inference in the &lsquo;c_weights&rsquo; slot,
</p>
</li>
<li><p> &lsquo;traces&rsquo;: a list of traces of model parameters from all MCMC chains for each parameter. Parameters sampled are z, omega, phi and x (the indicator of having a pathogenic configuration of alleles). The list of traces is named by parameter name, and each is a matrix where the rows correspond to samples. $z has k columns for each temperature, with the samples from the true posterior (i.e. with temperature equal to 1) of z corresponding to the final k columns. Likewise, the true posterior is given by the final column for the traces of phi and omega. The trace of x is only given for temperature equal to 1 to reduce memory usage.
</p>
</li>
<li><p> &lsquo;final&rsquo;: a list named by model parameter giving the final sample of each,
</p>
</li>
<li><p> &lsquo;swaps&rsquo;: a list with an element named &lsquo;accept&rsquo; which is a logical vector whose ith element indicates whether the ith swap between adjacent tempered chains was accepted or not, and an element named 'at_temperature', an integer vector whose ith element indicates which pair of consecutive temperatures was the ith to be proposed for swapping (giving the lowest one). 
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>BeviMed_m</code>.
</p>


<h3>References</h3>

<p>Greene et al., A Fast Association Test for Identifying Pathogenic Variants Involved in Rare Diseases, The American Journal of Human Genetics (2017), http://dx.doi.org/10.1016/j.ajhg.2017.05.015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bevimed_m">bevimed_m</a></code>, <code><a href="#topic+prob_association_m">prob_association_m</a></code>
</p>

<hr>
<h2 id='bevimed_polytomous'>Model selection for multiple association models</h2><span id='topic+bevimed_polytomous'></span>

<h3>Description</h3>

<p>Apply bevimed to the no association model (gamma = 0) and multiple association models for different sets of variants, for instance, corresponding to different functional consequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bevimed_polytomous(
  y,
  G,
  ploidy = rep(2L, length(y)),
  variant_sets,
  prior_prob_association = rep(0.01/length(variant_sets), length(variant_sets)),
  tau0_shape = c(1, 1),
  moi = rep("dominant", length(variant_sets)),
  model_specific_args = vector(mode = "list", length = length(variant_sets)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bevimed_polytomous_+3A_y">y</code></td>
<td>
<p>Logical vector of case (<code>TRUE</code>) control (<code>FALSE</code>) status.</p>
</td></tr>
<tr><td><code id="bevimed_polytomous_+3A_g">G</code></td>
<td>
<p>Integer matrix of variant counts per individual, one row per individual and one column per variant.</p>
</td></tr>
<tr><td><code id="bevimed_polytomous_+3A_ploidy">ploidy</code></td>
<td>
<p>Integer vector giving ploidy of samples.</p>
</td></tr>
<tr><td><code id="bevimed_polytomous_+3A_variant_sets">variant_sets</code></td>
<td>
<p>List of integer vectors corresponding to sets of indices of <code>G</code>, each of which is to be considered in a model explaining the phenotype, <code>y</code>.</p>
</td></tr>
<tr><td><code id="bevimed_polytomous_+3A_prior_prob_association">prior_prob_association</code></td>
<td>
<p>The prior probability of association.</p>
</td></tr>
<tr><td><code id="bevimed_polytomous_+3A_tau0_shape">tau0_shape</code></td>
<td>
<p>Beta shape hyper-priors for prior on rate of case labels.</p>
</td></tr>
<tr><td><code id="bevimed_polytomous_+3A_moi">moi</code></td>
<td>
<p>Character vector giving mode of inheritance for each model.</p>
</td></tr>
<tr><td><code id="bevimed_polytomous_+3A_model_specific_args">model_specific_args</code></td>
<td>
<p>List of named lists of parameters to use in <code><a href="#topic+bevimed_m">bevimed_m</a></code> applications for specific models.</p>
</td></tr>
<tr><td><code id="bevimed_polytomous_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+bevimed_m">bevimed_m</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Greene et al., A Fast Association Test for Identifying Pathogenic Variants Involved in Rare Diseases, The American Journal of Human Genetics (2017), http://dx.doi.org/10.1016/j.ajhg.2017.05.015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bevimed_m">bevimed_m</a></code>, <code><a href="#topic+bevimed">bevimed</a></code>
</p>

<hr>
<h2 id='call_cpp'>R interface to BeviMed c++ MCMC procedure</h2><span id='topic+call_cpp'></span>

<h3>Description</h3>

<p>Allows other functions in the package to call the c++ function passing arguments more succinctly and by name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_cpp(
  samples_per_chain,
  y,
  block_starts,
  block_ends,
  cases,
  counts,
  min_ac,
  tau_shape,
  pi_shape,
  omega_shape,
  temperatures,
  z0_matrix,
  estimate_omega,
  logit_omegas,
  logit_omega_proposal_sds,
  variant_weights,
  estimate_phi,
  log_phis,
  log_phi_mean,
  log_phi_sd,
  log_phi_proposal_sds,
  chain_swaps_per_cycle,
  annealing,
  tandem_variant_updates,
  comphet_variant_block_starts,
  comphet_variant_block_ends,
  comphet_variants,
  return_z_trace,
  return_x_trace,
  vec_sums = FALSE,
  burn = 0,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_cpp_+3A_samples_per_chain">samples_per_chain</code></td>
<td>
<p>Number of samples to draw from each chain.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_y">y</code></td>
<td>
<p>Logical vector of subject affectedness status.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_block_starts">block_starts</code></td>
<td>
<p>Integer vector of k 0-indexed start positions (with respect to <code>cases</code> and <code>counts</code>) for contiguous blocks relating to the k variants.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_block_ends">block_ends</code></td>
<td>
<p>Integer vector of (exclusive) k 0-indexed end positions.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_cases">cases</code></td>
<td>
<p>0 based vector of case indices with respect to y.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_counts">counts</code></td>
<td>
<p>Vector of variant counts.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_min_ac">min_ac</code></td>
<td>
<p>Integer vector with a length equalling the number of individuals or length <code>1</code> (in which case the given value is used for all individuals) giving the minimum number of alleles at pathogenic variant sites each individual requires in order to classify as having a &lsquo;pathogenic allele configuration&rsquo;. Thus, this parameter encodes the mode of inheritance. For instance, setting this parameter to <code>1</code> corresponds to dominant inheritance. If there are differences in ploidy between individuals in the locus, it is necessary to set it on an sample level basis - e.g. to ensure sex is accounted for if the locus lies on the X chromosome.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_tau_shape">tau_shape</code></td>
<td>
<p>Beta distribution parameterisation of benign variant configuration rate of affection, q.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_pi_shape">pi_shape</code></td>
<td>
<p>Beta distribution parameterisation of pathogenic variant configuration rate of affection, p.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_omega_shape">omega_shape</code></td>
<td>
<p>Beta distribution of global rate of pathogenicty of variants in gene given pathogenicity of gene, omega.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_temperatures">temperatures</code></td>
<td>
<p>Numeric vector of temperatures of power posteriors. One chain will be created for each element of the vector at the corresponding temperature.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_z0_matrix">z0_matrix</code></td>
<td>
<p>Matrix of logicals, where the rows are used as an initial zs for the chains.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_estimate_omega">estimate_omega</code></td>
<td>
<p>Logical value determining whether to estimate the parameter omega.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_logit_omegas">logit_omegas</code></td>
<td>
<p>Numeric vector of logit omega values, one value per chain.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_logit_omega_proposal_sds">logit_omega_proposal_sds</code></td>
<td>
<p>Numeric vector of proposal standard deviations for Metropolis-Hastings sampling of logit omega parameter, one value per chain.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_variant_weights">variant_weights</code></td>
<td>
<p>Vector of log-odds off-sets for rates of pathogenicity of individual variants relative to the global rate, omega.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_estimate_phi">estimate_phi</code></td>
<td>
<p>Logical value determining whether to estimate a scaling factor of <code>variant_weights</code>.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_log_phis">log_phis</code></td>
<td>
<p>Numeric vector of log phi values, one value per chain.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_log_phi_mean">log_phi_mean</code></td>
<td>
<p>Mean for normal prior on scaling factor phi.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_log_phi_sd">log_phi_sd</code></td>
<td>
<p>SD for normal prior on scaling factor phi.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_log_phi_proposal_sds">log_phi_proposal_sds</code></td>
<td>
<p>Numeric vector of proposal standard deviations for Metropolis-Hastings sampling of log phi parameter, one value per chain.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_chain_swaps_per_cycle">chain_swaps_per_cycle</code></td>
<td>
<p>Number of chain swaps to propose per update cycle.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_annealing">annealing</code></td>
<td>
<p>Logical value determining whether to anneal the chains, e.g. for optimisation.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_tandem_variant_updates">tandem_variant_updates</code></td>
<td>
<p>Number of tandem variant updates to make per update cycle.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_comphet_variant_block_starts">comphet_variant_block_starts</code></td>
<td>
<p>0-indexed start positions for contiguous blocks of variants in <code>comphet_variants</code>.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_comphet_variant_block_ends">comphet_variant_block_ends</code></td>
<td>
<p>As <code>comphet_variant_block_starts</code> for (exclusive) stop positions.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_comphet_variants">comphet_variants</code></td>
<td>
<p>Integer vector giving variant numbers (0-based, i.e. between 0 and k-1). Used to pick pairs of variants for tandem updates from.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_return_z_trace">return_z_trace</code></td>
<td>
<p>Logical value determining whether to store the z-vectors for each chain, which uses alot of memory, particularly if <code>samples_per_chain</code>, k and <code>length(temperatures)</code> are large.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_return_x_trace">return_x_trace</code></td>
<td>
<p>Logical value determining whether to store the x variable determined by success samples of z. Potentially uses alot of memory, particularly if <code>samples_per_chain</code>, k and <code>length(temperatures)</code> are large.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_vec_sums">vec_sums</code></td>
<td>
<p>Logical value determining whether to calculate vector summary statistics.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_burn">burn</code></td>
<td>
<p>Number of samples to drop from the start of the chain.</p>
</td></tr>
<tr><td><code id="call_cpp_+3A_check">check</code></td>
<td>
<p>Logical value indicating whether to perform validation on the arguments before calling the c++ function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>BeviMed_raw</code>, containing the output of the MCMC sampling.
</p>

<hr>
<h2 id='CI_gamma1_evidence'>Estimate confidence interval for estimated marginal likelihood</h2><span id='topic+CI_gamma1_evidence'></span>

<h3>Description</h3>

<p>Central limit theorem not applicable so use simulation to estimate confidence interval for evidence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CI_gamma1_evidence(
  temperatures,
  y_log_lik_t_equals_1_traces,
  confidence = 0.95,
  simulations = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CI_gamma1_evidence_+3A_temperatures">temperatures</code></td>
<td>
<p>Numeric vector of temperatures of power posteriors. One chain will be created for each element of the vector at the corresponding temperature.</p>
</td></tr>
<tr><td><code id="CI_gamma1_evidence_+3A_y_log_lik_t_equals_1_traces">y_log_lik_t_equals_1_traces</code></td>
<td>
<p>Numeric matrix of log probabilities of <code>y</code> at different temperatures (columns) in different iterations (rows).</p>
</td></tr>
<tr><td><code id="CI_gamma1_evidence_+3A_confidence">confidence</code></td>
<td>
<p>Numeric value of statistical confidence with which returning interval should contain the true value.</p>
</td></tr>
<tr><td><code id="CI_gamma1_evidence_+3A_simulations">simulations</code></td>
<td>
<p>Integer value of number of simulations to use in estimation of the confidence interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Confidence interval as numeric vector of length 2.
</p>

<hr>
<h2 id='conditional_prob_pathogenic'>Calculate probability of pathogencity for variants conditional on mode of inheritance.</h2><span id='topic+conditional_prob_pathogenic'></span>

<h3>Description</h3>

<p>Calls <code><a href="#topic+bevimed_m">bevimed_m</a></code> and <code><a href="#topic+extract_conditional_prob_pathogenic">extract_conditional_prob_pathogenic</a></code> to obtain probabilities of pathogenicity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_prob_pathogenic(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditional_prob_pathogenic_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+bevimed_m">bevimed_m</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probabilities of pathogenicity.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_conditional_prob_pathogenic">extract_conditional_prob_pathogenic</a></code>, <code><a href="#topic+bevimed_m">bevimed_m</a></code>
</p>

<hr>
<h2 id='expected_explained'>Calculate expected number of explained cases</h2><span id='topic+expected_explained'></span>

<h3>Description</h3>

<p>Use <code><a href="#topic+bevimed_m">bevimed_m</a></code> to perform inference under model gamma = 1 and return only the expected number of cases explained by pathogenic allele configurations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_explained(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected_explained_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+bevimed_m">bevimed_m</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bevimed_m">bevimed_m</a></code>, <code><a href="#topic+extract_expected_explained">extract_expected_explained</a></code>
</p>

<hr>
<h2 id='explaining_variants'>Calculate expected number of pathogenic variants in cases</h2><span id='topic+explaining_variants'></span>

<h3>Description</h3>

<p>Use <code><a href="#topic+bevimed_m">bevimed_m</a></code> to perform inference under model gamma = 1 and return only the expected number of pathogenic variants in cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explaining_variants(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explaining_variants_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+bevimed_m">bevimed_m</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_explaining_variants">extract_explaining_variants</a></code>, <code><a href="#topic+bevimed_m">bevimed_m</a></code>
</p>

<hr>
<h2 id='extract_conditional_prob_pathogenic'>Extract probability of pathogenicity for variant conditional on a given association model</h2><span id='topic+extract_conditional_prob_pathogenic'></span>

<h3>Description</h3>

<p>Extract the probability of pathogenicity for individual variants from a <code>BeviMed_m</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_conditional_prob_pathogenic(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_conditional_prob_pathogenic_+3A_x">x</code></td>
<td>
<p>Object of class <code>x_BeviMed_m</code>. See function <code><a href="#topic+bevimed_m">bevimed_m</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of probabilities of pathogenicity for individual variants.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conditional_prob_pathogenic">conditional_prob_pathogenic</a></code>, <code><a href="#topic+bevimed_m">bevimed_m</a></code>
</p>

<hr>
<h2 id='extract_expected_explained'>Extract expected number of explained cases</h2><span id='topic+extract_expected_explained'></span>

<h3>Description</h3>

<p>Extract expected number of cases explained by pathogenic configurations of alleles from <code>BeviMed_m</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_expected_explained(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_expected_explained_+3A_x">x</code></td>
<td>
<p>Object of class <code>x_BeviMed_m</code>. See function <code><a href="#topic+bevimed_m">bevimed_m</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expected_explained">expected_explained</a></code>, <code><a href="#topic+bevimed_m">bevimed_m</a></code>
</p>

<hr>
<h2 id='extract_explaining_variants'>Extract expected number of pathogenic variants in cases</h2><span id='topic+extract_explaining_variants'></span>

<h3>Description</h3>

<p>Extract expected number of variants involved in cases explained by pathogenic conigurations of alleles from <code>BeviMed_m</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_explaining_variants(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_explaining_variants_+3A_x">x</code></td>
<td>
<p>Object of class <code>x_BeviMed_m</code>. See function <code><a href="#topic+bevimed_m">bevimed_m</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+explaining_variants">explaining_variants</a></code>, <code><a href="#topic+bevimed_m">bevimed_m</a></code>
</p>

<hr>
<h2 id='extract_gamma1_evidence'>Extract evidence for model gamma = 1</h2><span id='topic+extract_gamma1_evidence'></span>

<h3>Description</h3>

<p>Extract evidence from <code>BeviMed_m</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_gamma1_evidence(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_gamma1_evidence_+3A_x">x</code></td>
<td>
<p>Object of class <code>x_BeviMed_m</code>. See function <code><a href="#topic+bevimed_m">bevimed_m</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log marginal likelihood.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamma1_evidence">gamma1_evidence</a></code>, <code><a href="#topic+bevimed_m">bevimed_m</a></code>
</p>

<hr>
<h2 id='extract_prob_association'>Extract the posterior probability of association</h2><span id='topic+extract_prob_association'></span>

<h3>Description</h3>

<p>Get posterior probability of association as numeric value, or optionally as numeric vector of length two with probabilities broken down by mode of inheritance (by passing <code>by_model=TRUE</code>), from a <code>BeviMed</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_prob_association(x, by_model = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_prob_association_+3A_x">x</code></td>
<td>
<p>Object of class <code>BeviMed</code>.</p>
</td></tr>
<tr><td><code id="extract_prob_association_+3A_by_model">by_model</code></td>
<td>
<p>Logical value determining whether to return probabilities broken down by mode of inheritance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prob_association">prob_association</a></code>, <code><a href="#topic+bevimed">bevimed</a></code>
</p>

<hr>
<h2 id='extract_prob_pathogenic'>Extract variant marginal probabilities of pathogenicity</h2><span id='topic+extract_prob_pathogenic'></span>

<h3>Description</h3>

<p>Extract the marginal probability of pathogenicity for individual variants from <code>BeviMed</code> object, optionally broken down by mode of inheritance/model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_prob_pathogenic(x, by_model = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_prob_pathogenic_+3A_x">x</code></td>
<td>
<p>Object of class <code>BeviMed</code>.</p>
</td></tr>
<tr><td><code id="extract_prob_pathogenic_+3A_by_model">by_model</code></td>
<td>
<p>Logical value determining whether to return probabilities broken down by mode of inheritance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of probabilities of pathogenicity for individual variants, or if <code>by_model</code> is <code>TRUE</code>, then a matrix of probabilities, with rows corresponding to modes of inheritance and columns to variants.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prob_pathogenic">prob_pathogenic</a></code>, <code><a href="#topic+bevimed">bevimed</a></code>
</p>

<hr>
<h2 id='gamma0_evidence'>Calculate marginal probability of observed case-control status y under model gamma = 0</h2><span id='topic+gamma0_evidence'></span>

<h3>Description</h3>

<p>Marginal probability calculated exactly by integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma0_evidence(y, tau0_shape = c(1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma0_evidence_+3A_y">y</code></td>
<td>
<p>Logical vector of case (<code>TRUE</code>) control (<code>FALSE</code>) status.</p>
</td></tr>
<tr><td><code id="gamma0_evidence_+3A_tau0_shape">tau0_shape</code></td>
<td>
<p>Beta shape hyper-priors for prior on rate of case labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log marginal likelihood.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bevimed">bevimed</a></code>, <code><a href="#topic+gamma1_evidence">gamma1_evidence</a></code>
</p>

<hr>
<h2 id='gamma1_evidence'>Calculate evidence under model gamma = 1</h2><span id='topic+gamma1_evidence'></span>

<h3>Description</h3>

<p>Use <code><a href="#topic+bevimed_m">bevimed_m</a></code> to perform inference under model gamma = 1 and return only the log evidence/integrated likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma1_evidence(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma1_evidence_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+bevimed_m">bevimed_m</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log marginal likelihood.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bevimed_m">bevimed_m</a></code>, <code><a href="#topic+extract_gamma1_evidence">extract_gamma1_evidence</a></code>
</p>

<hr>
<h2 id='log_BF'>Calculate log Bayes factor between an association model with a given mode of inheritance and model gamma = 0</h2><span id='topic+log_BF'></span>

<h3>Description</h3>

<p>Compute log Bayes factor of an association model and model gamma = 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_BF(y, tau0_shape = c(1, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_BF_+3A_y">y</code></td>
<td>
<p>Logical vector of case (<code>TRUE</code>) control (<code>FALSE</code>) status.</p>
</td></tr>
<tr><td><code id="log_BF_+3A_tau0_shape">tau0_shape</code></td>
<td>
<p>Beta shape hyper-priors for prior on rate of case labels.</p>
</td></tr>
<tr><td><code id="log_BF_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+bevimed_m">bevimed_m</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log Bayes factor.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bevimed_m">bevimed_m</a></code>, <code><a href="#topic+prob_association_m">prob_association_m</a></code>
</p>

<hr>
<h2 id='print.BeviMed'>Print readable summary of <code>BeviMed</code> object</h2><span id='topic+print.BeviMed'></span>

<h3>Description</h3>

<p>Print summary statistics of BeviMed inference, including probability of association, probability of dominant inheritance given association and probability of pathogenicity of each variant under dominant and recessive inheritance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BeviMed'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.BeviMed_+3A_x">x</code></td>
<td>
<p><code>BeviMed</code> object.</p>
</td></tr>
<tr><td><code id="print.BeviMed_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+summary.BeviMed">summary.BeviMed</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.BeviMed">summary.BeviMed</a></code>
</p>

<hr>
<h2 id='print.BeviMed_m'>Print <code>BeviMed_m</code> object</h2><span id='topic+print.BeviMed_m'></span>

<h3>Description</h3>

<p>Print summary statistics for <code>BeviMed_m</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BeviMed_m'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.BeviMed_m_+3A_x">x</code></td>
<td>
<p>Object of class <code>x_BeviMed_m</code>. See function <code><a href="#topic+bevimed_m">bevimed_m</a></code>.</p>
</td></tr>
<tr><td><code id="print.BeviMed_m_+3A_...">...</code></td>
<td>
<p>Unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.BeviMed_m">summary.BeviMed_m</a></code>
</p>

<hr>
<h2 id='print.BeviMed_summary'>Print readable summary of <code>BeviMed_summary</code> object.</h2><span id='topic+print.BeviMed_summary'></span>

<h3>Description</h3>

<p>Print summary statistics of BeviMed inference, including probability of association, probability of dominant inheritance given association and probability of pathogenicity of each variant under dominant and recessive inheritance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BeviMed_summary'
print(x, print_prob_pathogenic = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.BeviMed_summary_+3A_x">x</code></td>
<td>
<p><code>BeviMed_summary</code> object.</p>
</td></tr>
<tr><td><code id="print.BeviMed_summary_+3A_print_prob_pathogenic">print_prob_pathogenic</code></td>
<td>
<p>Logical value indicating whether to print list of marginal probabilities of <code>z_j = 1</code> for all variants <code>j</code> under each mode of inheritance.</p>
</td></tr>
<tr><td><code id="print.BeviMed_summary_+3A_...">...</code></td>
<td>
<p>Unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary
</p>

<hr>
<h2 id='prob_association'>Calculate probability of association</h2><span id='topic+prob_association'></span>

<h3>Description</h3>

<p>Calculate probability of an association between case/control label and allele configuration, optionally broken down by mode of inheritance/model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_association(by_model = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_association_+3A_by_model">by_model</code></td>
<td>
<p>Logical value determining whether to return probabilities broken down by mode of inheritance.</p>
</td></tr>
<tr><td><code id="prob_association_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+bevimed">bevimed</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability of association.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bevimed">bevimed</a></code>, <code><a href="#topic+extract_prob_association">extract_prob_association</a></code>
</p>

<hr>
<h2 id='prob_association_m'>Calculate probability of association for one mode of inheritance</h2><span id='topic+prob_association_m'></span>

<h3>Description</h3>

<p>Equivalent to <code><a href="#topic+prob_association">prob_association</a></code> where the prior probability of one mode of inheritance is 1. This function is faster, as it only calls <code><a href="#topic+bevimed_m">bevimed_m</a></code> once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_association_m(y, min_ac = 1L, prior_prob_association = 0.01, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_association_m_+3A_y">y</code></td>
<td>
<p>Logical vector of case (<code>TRUE</code>) control (<code>FALSE</code>) status.</p>
</td></tr>
<tr><td><code id="prob_association_m_+3A_min_ac">min_ac</code></td>
<td>
<p>Integer vector with a length equalling the number of individuals or length <code>1</code> (in which case the given value is used for all individuals) giving the minimum number of alleles at pathogenic variant sites each individual requires in order to classify as having a &lsquo;pathogenic allele configuration&rsquo;. Thus, this parameter encodes the mode of inheritance. For instance, setting this parameter to <code>1</code> corresponds to dominant inheritance. If there are differences in ploidy between individuals in the locus, it is necessary to set it on an sample level basis - e.g. to ensure sex is accounted for if the locus lies on the X chromosome.</p>
</td></tr>
<tr><td><code id="prob_association_m_+3A_prior_prob_association">prior_prob_association</code></td>
<td>
<p>The prior probability of association.</p>
</td></tr>
<tr><td><code id="prob_association_m_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+log_BF">log_BF</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+log_BF">log_BF</a></code>, <code><a href="#topic+prob_association">prob_association</a></code>, <code><a href="#topic+bevimed_m">bevimed_m</a></code>
</p>

<hr>
<h2 id='prob_pathogenic'>Calculate variant marginal probabilities of pathogencity</h2><span id='topic+prob_pathogenic'></span>

<h3>Description</h3>

<p>Calls <code><a href="#topic+bevimed">bevimed</a></code> and <code><a href="#topic+extract_prob_pathogenic">extract_prob_pathogenic</a></code> to obtain marginal probabilities of pathogenicity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_pathogenic(by_model = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_pathogenic_+3A_by_model">by_model</code></td>
<td>
<p>Logical value determining whether to return probabilities broken down by mode of inheritance.</p>
</td></tr>
<tr><td><code id="prob_pathogenic_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+bevimed">bevimed</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>by_model</code> is <code>FALSE</code>, a vector of probabilities of pathogenicity for each variant, otherwise a list of vectors of probabilities of pathogenicity conditional on each compared association model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_prob_pathogenic">extract_prob_pathogenic</a></code>, <code><a href="#topic+bevimed">bevimed</a></code>
</p>

<hr>
<h2 id='stack_BeviMeds'>Concatenate objects of class <code>BeviMed_raw</code></h2><span id='topic+stack_BeviMeds'></span>

<h3>Description</h3>

<p>This function could be used to stitch together consecutive chains to create one larger sampled set of states from the MCMC procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack_BeviMeds(objects)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_BeviMeds_+3A_objects">objects</code></td>
<td>
<p><code>list</code> of <code>BeviMed_raw</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>BeviMed</code> object.
</p>

<hr>
<h2 id='stop_chain'>Apply the MCMC algorithm in blocks until conditions are met</h2><span id='topic+stop_chain'></span>

<h3>Description</h3>

<p>Sample blocks of a given size until either the estimated log marginal likelihood falls within a given confidence interval, there is sufficient confidence that the evidence model gamma = 1 is at most a certain quantity, or a certain number of blocks have been sampled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_chain(
  y,
  blocks_remaining,
  start_zs,
  start_logit_omegas,
  start_log_phis,
  temperatures,
  tolerance = 1,
  confidence = 0.95,
  simulations = 1000,
  log_evidence_threshold = -Inf,
  y_log_lik_t_equals_1_traces = matrix(ncol = length(temperatures), nrow = 0),
  full_block_traces = list(),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_chain_+3A_y">y</code></td>
<td>
<p>Logical vector of case (<code>TRUE</code>) control (<code>FALSE</code>) status.</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_blocks_remaining">blocks_remaining</code></td>
<td>
<p>Maximum number of blocks left before termination.</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_start_zs">start_zs</code></td>
<td>
<p>Initial (logical) z-matrix.</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_start_logit_omegas">start_logit_omegas</code></td>
<td>
<p>Initial values of logit_omega (numeric vector - one value per chain).</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_start_log_phis">start_log_phis</code></td>
<td>
<p>Initial values of log_phi (numeric vector - one value per chain).</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_temperatures">temperatures</code></td>
<td>
<p>Numeric vector of temperatures of power posteriors. One chain will be created for each element of the vector at the corresponding temperature.</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_tolerance">tolerance</code></td>
<td>
<p>Maximum width for confidence_interval of log marginal likelihood to allow before stopping the chain.</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_confidence">confidence</code></td>
<td>
<p>Numeric value of statistical confidence with which returning interval should contain the true value.</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_simulations">simulations</code></td>
<td>
<p>Integer value of number of simulations to use in estimation of the confidence interval.</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_log_evidence_threshold">log_evidence_threshold</code></td>
<td>
<p>Numeric value used to determine whether to stop the sampling procedure after successive blocks. If we are confident (to the level of <code>confidence</code>) that the evidence for model gamma = 1 is under this value, sampling is halted.</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_y_log_lik_t_equals_1_traces">y_log_lik_t_equals_1_traces</code></td>
<td>
<p>Numeric matrix of log probabilities of <code>y</code> at different temperatures (columns) in different iterations (rows).</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_full_block_traces">full_block_traces</code></td>
<td>
<p>List of outputs of calls to MCMC routine.</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_verbose">verbose</code></td>
<td>
<p>To print execution progress or not.</p>
</td></tr>
<tr><td><code id="stop_chain_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+call_cpp">call_cpp</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>BeviMed</code>.
</p>

<hr>
<h2 id='subset_variants'>Remove variants with no data for pathogenicity</h2><span id='topic+subset_variants'></span>

<h3>Description</h3>

<p>Subset an allele count matrix given a minimum allele count threshold for pathogenicity per individual so that only variants for which data relevant to pathogencity are retained. This is useful to apply before running <code><a href="#topic+bevimed">bevimed</a></code> as it reduces the size of the parameter space used in the inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_variants(G, min_ac = 1L, return_variants = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_variants_+3A_g">G</code></td>
<td>
<p>Integer matrix of variant counts per individual, one row per individual and one column per variant.</p>
</td></tr>
<tr><td><code id="subset_variants_+3A_min_ac">min_ac</code></td>
<td>
<p>Integer vector with a length equalling the number of individuals or length <code>1</code> (in which case the given value is used for all individuals) giving the minimum number of alleles at pathogenic variant sites each individual requires in order to classify as having a &lsquo;pathogenic allele configuration&rsquo;. Thus, this parameter encodes the mode of inheritance. For instance, setting this parameter to <code>1</code> corresponds to dominant inheritance. If there are differences in ploidy between individuals in the locus, it is necessary to set it on an sample level basis - e.g. to ensure sex is accounted for if the locus lies on the X chromosome.</p>
</td></tr>
<tr><td><code id="subset_variants_+3A_return_variants">return_variants</code></td>
<td>
<p>Logical value determining whether to return an integer vector of indices of retained variants or the subsetted allele count matrix</p>
</td></tr>
</table>

<hr>
<h2 id='sum_ML_over_PP'>Calculate marginal likelihood from power posteriors output</h2><span id='topic+sum_ML_over_PP'></span>

<h3>Description</h3>

<p>Calculate the Marginal Likelihood by summation over power posterior likelihood exptectances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_ML_over_PP(y_log_lik_t_equals_1_traces, temperatures)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_ML_over_PP_+3A_y_log_lik_t_equals_1_traces">y_log_lik_t_equals_1_traces</code></td>
<td>
<p>Numeric matrix of log probabilities of <code>y</code> at different temperatures (columns) in different iterations (rows).</p>
</td></tr>
<tr><td><code id="sum_ML_over_PP_+3A_temperatures">temperatures</code></td>
<td>
<p>Numeric vector of temperatures used to produce <code>y_log_lik_t_equals_1_traces</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value of estimated log marginal likelihood.
</p>

<hr>
<h2 id='summary.BeviMed'>Summarise a <code>BeviMed</code> object</h2><span id='topic+summary.BeviMed'></span>

<h3>Description</h3>

<p>Create a summary of inference over model gamma = 0 and association models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BeviMed'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BeviMed_+3A_object">object</code></td>
<td>
<p>Object of class <code>BeviMed</code>.</p>
</td></tr>
<tr><td><code id="summary.BeviMed_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>summary.BeviMed_m</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a <code>BeviMed_summary</code> object, which is a list containing elements:
</p>

<ul>
<li><p> 'prob_association': the probability of association under each association model,
</p>
</li>
<li><p> 'prior_prob_association': the prior probability of association for each association model,
</p>
</li>
<li><p> &lsquo;gamma0_evidence&rsquo;: the log evidence under model gamma = 0,
</p>
</li>
<li><p> &lsquo;models&rsquo;: a list of summaries of model conditional inferences, i.e. objects of class <code>BeviMed_m_summary</code>. See <code><a href="#topic+summary.BeviMed_m">summary.BeviMed_m</a></code> for more details.
</p>
</li></ul>



<h3>Value</h3>

<p>Object of class <code>BeviMed_summary</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.BeviMed_m">summary.BeviMed_m</a></code>
</p>

<hr>
<h2 id='summary.BeviMed_m'>Summarise a <code>BeviMed_m</code> object</h2><span id='topic+summary.BeviMed_m'></span>

<h3>Description</h3>

<p>Create a summary of inference conditional on mode of inheritance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BeviMed_m'
summary(object, confidence = 0.95, simulations = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BeviMed_m_+3A_object">object</code></td>
<td>
<p>Object of class <code>BeviMed_m</code>. See function <code><a href="#topic+bevimed_m">bevimed_m</a></code>.</p>
</td></tr>
<tr><td><code id="summary.BeviMed_m_+3A_confidence">confidence</code></td>
<td>
<p>Numeric value of statistical confidence with which returning interval should contain the true value.</p>
</td></tr>
<tr><td><code id="summary.BeviMed_m_+3A_simulations">simulations</code></td>
<td>
<p>Integer value of number of simulations to use in estimation of the confidence interval.</p>
</td></tr>
<tr><td><code id="summary.BeviMed_m_+3A_...">...</code></td>
<td>
<p>Unused arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a <code>BeviMed_m_summary</code> object, which is a list containing elements:
</p>

<ul>
<li><p> &lsquo;gamma1_evidence&rsquo;: the log evidence under model gamma = 1,
</p>
</li>
<li><p> &lsquo;gamma1_evidence_confidence_interval&rsquo;: a confidence interval for the log evidence under model gamma = 1,
</p>
</li>
<li><p> &lsquo;conditional_prob_pathogenic&rsquo;: vector of marginal probabilities of pathogenicity for individual variants,
</p>
</li>
<li><p> &lsquo;expected_explained&rsquo;: the expected number of cases with a pathogenic configuration of alleles,
</p>
</li>
<li><p> &lsquo;explaining_variants&rsquo;: the expected number of variants present for which cases harbour a rare allele,
</p>
</li>
<li><p> &lsquo;number_of_posterior_samples&rsquo;: the number of samples from the posterior distribution of the model parameters which upon which the summary is based,
</p>
</li>
<li><p> &lsquo;omega_estimated&rsquo;: logical value indicating whether the parameter omega was estimated,
</p>
</li>
<li><p> &lsquo;omega&rsquo;: the posterior mean of omega,
</p>
</li>
<li><p> &lsquo;omega_acceptance_rate&rsquo;: if omega was estimated, the rate of acceptance of proposed omega values in the Metropolis-Hastings sampling routine,  
</p>
</li>
<li><p> &lsquo;phi_estimated&rsquo;: logical value indicating whether the parameter phi was estimated,
</p>
</li>
<li><p> &lsquo;phi&rsquo;: the posterior mean of phi,
</p>
</li>
<li><p> &lsquo;phi_acceptance_rate&rsquo;: if phi was estimated, the rate of acceptance of proposed phi values in the Metropolis-Hastings sampling routine, 
</p>
</li>
<li><p> 'N': number of samples in the analysis,
</p>
</li>
<li><p> 'k': number of variants in the analysis,
</p>
</li>
<li><p> &lsquo;variant_counts&rsquo;: list of counts of each variant for cases and controls,
</p>
</li>
<li><p> &lsquo;temperatures&rsquo;: numeric vector of temperatures used as temperatures for tempered MCMC chains 
</p>
</li></ul>



<h3>Value</h3>

<p>Object of class <code>BeviMed_m_summary</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.BeviMed">summary.BeviMed</a></code>
</p>

<hr>
<h2 id='tune_proposal_sds'>Tune proposal standard deviation for MH sampled parameters</h2><span id='topic+tune_proposal_sds'></span>

<h3>Description</h3>

<p>Tune the proposal standard deviations for the Metropolis-Hastings updates of either phi or omega
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune_proposal_sds(
  tune_for = c("logit_omega"),
  initial_proposal_sds,
  target_acceptance_range = c(0.3, 0.7),
  other_param_proposal_sd = 0.7,
  max_tuning_cycles = 10,
  initial_rate = 1,
  rate_decay = 1.2,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune_proposal_sds_+3A_tune_for">tune_for</code></td>
<td>
<p>Character vector of length one, naming which variable to tune the proposal SDs for: either <code>"logit_omega"</code> or <code>"log_phi"</code>.</p>
</td></tr>
<tr><td><code id="tune_proposal_sds_+3A_initial_proposal_sds">initial_proposal_sds</code></td>
<td>
<p>Numeric vector with the initial values of the proposal SDs.</p>
</td></tr>
<tr><td><code id="tune_proposal_sds_+3A_target_acceptance_range">target_acceptance_range</code></td>
<td>
<p>Numeric vector of length 2 where the first element is the lower bound for the acceptance interval and the second is the upper bound.</p>
</td></tr>
<tr><td><code id="tune_proposal_sds_+3A_other_param_proposal_sd">other_param_proposal_sd</code></td>
<td>
<p>The proposal SD to use for <code>log_phi</code> when tuning <code>logit_omega</code> or vice versa.</p>
</td></tr>
<tr><td><code id="tune_proposal_sds_+3A_max_tuning_cycles">max_tuning_cycles</code></td>
<td>
<p>Maximum number of tuning cycles to perform before returning the proposal SDs as they are.</p>
</td></tr>
<tr><td><code id="tune_proposal_sds_+3A_initial_rate">initial_rate</code></td>
<td>
<p>Initial rate at which to mutate the proposal SDs.</p>
</td></tr>
<tr><td><code id="tune_proposal_sds_+3A_rate_decay">rate_decay</code></td>
<td>
<p>Geometric rate of decay for size of proposal SD mutation with each successive tuning cycle.</p>
</td></tr>
<tr><td><code id="tune_proposal_sds_+3A_verbose">verbose</code></td>
<td>
<p>To print execution progress or not.</p>
</td></tr>
<tr><td><code id="tune_proposal_sds_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+call_cpp">call_cpp</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of proposal SDs for the different temperature chains.
</p>

<hr>
<h2 id='tune_temperatures'>Tune temperatures</h2><span id='topic+tune_temperatures'></span>

<h3>Description</h3>

<p>Tune temperatures using interval bisection to minimimise Kullback-Liebler divergence between adjacent power posteriors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune_temperatures(number_of_temperatures, return_temperatures = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune_temperatures_+3A_number_of_temperatures">number_of_temperatures</code></td>
<td>
<p>Integer value giving number of tuned temperatures (including 0 and 1) to obtain.</p>
</td></tr>
<tr><td><code id="tune_temperatures_+3A_return_temperatures">return_temperatures</code></td>
<td>
<p>Logical value determining whether to return just the numeric vector of tuned temperatures or to return the <code>BeviMed_m</code>-classed object containing the output of the MCMC sampling.</p>
</td></tr>
<tr><td><code id="tune_temperatures_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code>call_cpp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return_temperatures == TRUE</code>, a numeric vector of tuned temperatures, otherwise an object of class <code>BeviMed_m</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
