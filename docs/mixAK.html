<!DOCTYPE html><html><head><title>Help for package mixAK</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mixAK}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Acidity'><p>Acidity index of lakes in North-Central Wisconsin</p></a></li>
<li><a href='#autolayout'>
<p>Automatic layout for several plots in one figure</p></a></li>
<li><a href='#BLA'>
<p>Best linear approximation with respect to the mean square error</p>
(theoretical linear regression).</a></li>
<li><a href='#BsBasis'><p>B-spline basis</p></a></li>
<li><a href='#cbplot'>
<p>Plot a function together with its confidence/credible bands</p></a></li>
<li><a href='#Dirichlet'>
<p>Dirichlet distribution</p></a></li>
<li><a href='#Enzyme'><p>Enzymatic activity in the blood</p></a></li>
<li><a href='#Faithful'><p>Old Faithful Geyser Data</p></a></li>
<li><a href='#fitted.GLMM_MCMC'><p>Fitted profiles in the GLMM model</p></a></li>
<li><a href='#Galaxy'><p>Velocities of distant galaxies</p></a></li>
<li><a href='#generatePermutations'>
<p>Generate all permutations of (1, ..., K)</p></a></li>
<li><a href='#getProfiles'><p>Individual longitudinal profiles of a given variable</p></a></li>
<li><a href='#GLMM_longitDA'>
<p>Discriminant analysis for longitudinal profiles based on fitted GLMM's</p></a></li>
<li><a href='#GLMM_longitDA2'>
<p>Discriminant analysis for longitudinal profiles based on fitted GLMM's</p></a></li>
<li><a href='#GLMM_MCMC'>
<p>MCMC estimation of a (multivariate) generalized linear mixed model</p>
with a normal mixture in the distribution of random effects</a></li>
<li><a href='#GLMM_MCMCdata'>
<p>Data manipulation for the GLMM_MCMC function</p></a></li>
<li><a href='#GLMM_MCMCifit'>
<p>Initial (RE)ML fits for the GLMM_MCMC function</p></a></li>
<li><a href='#GLMM_MCMCinit.alpha'>
<p>Handle init.alpha or init2.alpha argument of GLMM_MCMC function</p></a></li>
<li><a href='#GLMM_MCMCinit.b'>
<p>Handle init.b or init2.b argument of GLMM_MCMC function</p></a></li>
<li><a href='#GLMM_MCMCinit.eps'>
<p>Handle init.eps or init2.eps argument of GLMM_MCMC function</p></a></li>
<li><a href='#GLMM_MCMCprior.alpha'>
<p>Handle prior.alpha argument of GLMM_MCMC function</p></a></li>
<li><a href='#GLMM_MCMCprior.b'>
<p>Handle prior.eps argument of GLMM_MCMC function</p></a></li>
<li><a href='#GLMM_MCMCprior.eps'>
<p>Handle prior.eps argument of GLMM_MCMC function</p></a></li>
<li><a href='#GLMM_MCMCscale.b'>
<p>Handle scale.b argument of GLMM_MCMC function</p></a></li>
<li><a href='#GLMM_MCMCwrapper'>
<p>Wrapper to the GLMM_MCMC main simulation.</p></a></li>
<li><a href='#MatMPpinv'>
<p>Moore-Penrose pseudoinverse of a squared matrix</p></a></li>
<li><a href='#MatSqrt'>
<p>Square root of a matrix</p></a></li>
<li><a href='#MVN'>
<p>Multivariate normal distribution</p></a></li>
<li><a href='#MVNmixture'>
<p>Mixture of (multivariate) normal distributions</p></a></li>
<li><a href='#MVT'>
<p>Multivariate Student t distribution</p></a></li>
<li><a href='#NMixChainComp'>
<p>Chains for mixture parameters</p></a></li>
<li><a href='#NMixChainsDerived'>
<p>Create MCMC chains derived from previously sampled values</p></a></li>
<li><a href='#NMixCluster'>
<p>Clustering based on the MCMC output of the mixture model</p></a></li>
<li><a href='#NMixEM'>
<p>EM algorithm for a homoscedastic normal mixture</p></a></li>
<li><a href='#NMixMCMC'>
<p>MCMC estimation of (multivariate) normal mixtures with possibly</p>
censored data.</a></li>
<li><a href='#NMixMCMCdata'>
<p>Data manipulation for the NMixMCMC function</p></a></li>
<li><a href='#NMixMCMCinitr'>
<p>Initial component allocations for the NMixMCMC function</p></a></li>
<li><a href='#NMixMCMCinity'>
<p>Initial values of censored observations for the NMixMCMC function</p></a></li>
<li><a href='#NMixMCMCwrapper'>
<p>Wrapper to the NMixMCMC main simulation.</p></a></li>
<li><a href='#NMixPlugCondDensJoint2'>
<p>Pairwise bivariate conditional densities: plug-in estimate</p></a></li>
<li><a href='#NMixPlugCondDensMarg'>
<p>Univariate conditional densities: plug-in estimate</p></a></li>
<li><a href='#NMixPlugDA'>
<p>Discriminant analysis based on plug-in estimates from the mixture model</p></a></li>
<li><a href='#NMixPlugDensJoint2'>
<p>Pairwise bivariate densities: plug-in estimate</p></a></li>
<li><a href='#NMixPlugDensMarg'>
<p>Marginal (univariate) densities: plug-in estimate</p></a></li>
<li><a href='#NMixPredCDFMarg'>
<p>Marginal (univariate) predictive cumulative distribution function</p></a></li>
<li><a href='#NMixPredCondCDFMarg'>
<p>Univariate conditional predictive cumulative distribution function</p></a></li>
<li><a href='#NMixPredCondDensJoint2'>
<p>Pairwise bivariate conditional predictive densities</p></a></li>
<li><a href='#NMixPredCondDensMarg'>
<p>Univariate conditional predictive density</p></a></li>
<li><a href='#NMixPredDA'>
<p>Discriminant analysis based on MCMC output from the mixture model</p></a></li>
<li><a href='#NMixPredDensJoint2'>
<p>Pairwise bivariate predictive density</p></a></li>
<li><a href='#NMixPredDensMarg'>
<p>Marginal (univariate) predictive density</p></a></li>
<li><a href='#NMixPseudoGOF'>
<p>Pseudo goodness-of-fit test for a normal mixture model</p></a></li>
<li><a href='#NMixRelabel'>
<p>Re-labeling the MCMC output of the mixture model</p></a></li>
<li><a href='#NMixRelabelAlgorithm'>
<p>Argument manipulation for the NMixRelabel functions</p></a></li>
<li><a href='#NMixSummComp'>
<p>Summary for the mixture components</p></a></li>
<li><a href='#PBC910'><p>Subset of Mayo Clinic Primary Biliary Cholangitis (Cirrhosis) data</p></a></li>
<li><a href='#PBCseq'><p>Mayo Clinic Primary Biliary Cholangitis (Cirrhosis), sequential data</p></a></li>
<li><a href='#plot.NMixPlugCondDensJoint2'>
<p>Plot computed pairwise bivariate conditional densities</p>
(plug-in estimate)</a></li>
<li><a href='#plot.NMixPlugCondDensMarg'>
<p>Plot computed univariate conditional densities (plug-in estimate)</p></a></li>
<li><a href='#plot.NMixPlugDensJoint2'>
<p>Plot computed marginal pairwise bivariate densities (plug-in estimate)</p></a></li>
<li><a href='#plot.NMixPlugDensMarg'>
<p>Plot computed marginal predictive densities</p></a></li>
<li><a href='#plot.NMixPredCDFMarg'>
<p>Plot computed marginal predictive cumulative distribution functions</p></a></li>
<li><a href='#plot.NMixPredCondCDFMarg'>
<p>Plot computed univariate conditional predictive cumulative</p>
distribution functions</a></li>
<li><a href='#plot.NMixPredCondDensJoint2'>
<p>Plot computed predictive pairwise bivariate conditional densities</p></a></li>
<li><a href='#plot.NMixPredCondDensMarg'>
<p>Plot computed univariate conditional predictive densities</p></a></li>
<li><a href='#plot.NMixPredDensJoint2'>
<p>Plot computed marginal pairwise bivariate predictive densities</p></a></li>
<li><a href='#plot.NMixPredDensMarg'>
<p>Plot computed marginal predictive densities</p></a></li>
<li><a href='#plotProfiles'><p>Plot individual longitudinal profiles</p></a></li>
<li><a href='#rRotationMatrix'>
<p>Random rotation matrix</p></a></li>
<li><a href='#rSamplePair'>
<p>Sample a pair (with replacement)</p></a></li>
<li><a href='#SimData'><p>Simulated dataset</p></a></li>
<li><a href='#SP2Rect'>
<p>Conversion of a symmetric matrix stored in a packed format (lower triangle only) into a matrix</p></a></li>
<li><a href='#summaryDiff'>
<p>Posterior summary statistics for a difference of two quantities</p></a></li>
<li><a href='#Tandmob'><p>Signal Tandmobiel data</p></a></li>
<li><a href='#TandmobEmer'><p>Signal Tandmobiel data - emergence times</p></a></li>
<li><a href='#TMVN'>
<p>Truncated multivariate normal distribution</p></a></li>
<li><a href='#TNorm'>
<p>Truncated normal distribution</p></a></li>
<li><a href='#tracePlots'>
<p>Traceplots for selected parameters</p></a></li>
<li><a href='#Wishart'>
<p>Wishart distribution</p></a></li>
<li><a href='#Y2T'>
<p>Transform fitted distribution of Y=trans(T) into distribution of T</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>5.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Normal Mixture Models and Mixtures of Generalized
Linear Mixed Models Including Model Based Clustering</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), colorspace, lme4 (&ge; 1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, methods, splines, fastGHQuad, mnormt,
parallel, coda</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains a mixture of statistical methods including the MCMC methods to analyze normal mixtures. Additionally, model based clustering methods are implemented to perform classification based on (multivariate) longitudinal (or otherwise correlated) data. The basis for such clustering is a mixture of multivariate generalized linear mixed models.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://msekce.karlin.mff.cuni.cz/~komarek/">https://msekce.karlin.mff.cuni.cz/~komarek/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-14 13:41:12 UTC; komarek</td>
</tr>
<tr>
<td>Author:</td>
<td>Arnošt Komárek <a href="https://orcid.org/0000-0001-8778-3762"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arnošt Komárek &lt;arnost.komarek@mff.cuni.cz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-14 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Acidity'>Acidity index of lakes in North-Central Wisconsin</h2><span id='topic+Acidity'></span>

<h3>Description</h3>

<p>Acidity index measured in a sample of 155 lakes in North-Central
Wisconsin.
</p>
<p>Crawford et al. (1992) and Crawford (1994) analyzed these data as a
mixture of normal distributions on the log-scale. Richardson and Green
(1997) used a normal mixture estimated using reversible jump MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Acidity)</code></pre>


<h3>Format</h3>

<p>A numeric vector with observed values.
</p>


<h3>Source</h3>

<p>Originally from http://www.stats.bris.ac.uk/~peter/mixdata/
</p>


<h3>References</h3>

<p>Crawford, S. L. (1994).
An application of the Laplace method to finite mixture distribution.
<em>Journal of the American Statistical Association</em>, <b>89</b>, 259&ndash;267.
</p>
<p>Crawford, S. L., DeGroot, M. H., Kadane, J. B., and Small, M. J. (1994).
Modeling lake chemistry distributions: Approximate Bayesian methods for estimating a finite mixture model.
<em>Technometrics</em>, <b>34</b>, 441&ndash;453.
</p>
<p>Richardson, S. and Green, P. J. (1997).
On Bayesian analysis of mixtures with unknown number of components (with Discussion).
<em>Journal of the Royal Statistical Society, Series B</em>, <b>59</b>, 731&ndash;792.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Acidity)
summary(Acidity)
</code></pre>

<hr>
<h2 id='autolayout'>
Automatic layout for several plots in one figure
</h2><span id='topic+autolayout'></span>

<h3>Description</h3>

<p>Returns a matrix which can be used in <code><a href="graphics.html#topic+layout">layout</a></code>
function as its <code>mat</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autolayout(np)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autolayout_+3A_np">np</code></td>
<td>
<p>number of plots that are to be produced on 1 figure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>autolayout(10)
</code></pre>

<hr>
<h2 id='BLA'>
Best linear approximation with respect to the mean square error
(theoretical linear regression).
</h2><span id='topic+BLA'></span><span id='topic+C_BLA'></span>

<h3>Description</h3>

<p>For a random vector <code class="reqn">\boldsymbol{X} = (X_1,\dots,X_p)'</code>
for which a mean and a covariance matrix are given
computes coefficients of the best linear approximations with respect
to the mean square error of each component of <code class="reqn">\boldsymbol{X}</code>
given the remaining components of <code class="reqn">\boldsymbol{X}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BLA(mean=c(0, 0),  Sigma=diag(2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BLA_+3A_mean">mean</code></td>
<td>
<p>a numeric vector of means.</p>
</td></tr>
<tr><td><code id="BLA_+3A_sigma">Sigma</code></td>
<td>
<p>a covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>computed regression coefficients</p>
</td></tr>
<tr><td><code>sigmaR2</code></td>
<td>
<p>residual variances</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Anděl, J. (2007, odd. 2.5).
<em>Základy matematické statistiky</em>.
Praha: MATFYZPRESS.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### X = (U(1), U(2), U(3))'
##### * U(1) &lt;= U(2) &lt;= U(3)
##### * ordered uniform Unif(0, 1) variates
EX &lt;- (1:3)/4
varX &lt;- matrix(c(3,2,1, 2,4,2, 1,2,3), ncol=3)/80
BLA(EX, Sigma=varX)


##### Uroda sena
##### * Y1 = uroda sena [cent/akr]
##### * Y2 = jarni srazky [palce]
##### * Y3 = kumulovana teplota nad 42 F
EY &lt;- c(28.02, 4.91, 28.7)
varY &lt;- matrix(c(19.54, 3.89, -3.76,  3.89, 1.21, -1.31,  -3.76, -1.31, 4.52), ncol=3)
BLA(EY, Sigma=varY)


##### Z=(X, Y) ~ uniform distribution on a triangle
##### M = {(x,y): x&gt;=0, y&gt;=0, x+y&lt;=3}
EZ &lt;- c(1, 1)
varZ &lt;- matrix(c(2, -1,  -1, 2), nrow=2)/4
BLA(EZ, Sigma=varZ)


##### W=(X, Y) ~ uniform distribution on
##### M = {(x,y): x&gt;=0, 0&lt;=y&lt;=1, y&lt;=x&lt;=y+1}
EW &lt;- c(1, 1/2)
varW &lt;- matrix(c(2, 1,  1, 1), nrow=2)/12
BLA(EW, Sigma=varW)
</code></pre>

<hr>
<h2 id='BsBasis'>B-spline basis</h2><span id='topic+BsBasis'></span>

<h3>Description</h3>

<p>It creates a B-spline basis based on a specific
dataset. B-splines are assumed to have common boundary knots and
equidistant inner knots.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BsBasis(degree, ninner, knotsBound, knots, intercept=FALSE,
        x, tgrid, Bname="B", plot=FALSE, lwd=1,
        col="blue", xlab="Time", ylab="B(t)",
        pch=16, cex.pch=1, knotcol="red")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BsBasis_+3A_degree">degree</code></td>
<td>
<p>degree of the B-spline.</p>
</td></tr>
<tr><td><code id="BsBasis_+3A_ninner">ninner</code></td>
<td>
<p>number of inner knots.</p>
</td></tr>
<tr><td><code id="BsBasis_+3A_knotsbound">knotsBound</code></td>
<td>
<p>2-component vector with boundary knots.</p>
</td></tr>
<tr><td><code id="BsBasis_+3A_knots">knots</code></td>
<td>
<p>knots of the B-spline (including boundary ones). If
<code>knots</code> is given <code>ninner</code> and <code>knotsBound</code> are ignored.</p>
</td></tr>
<tr><td><code id="BsBasis_+3A_intercept">intercept</code></td>
<td>
<p>logical, if <code>FALSE</code>, the first basis B-spline is
removed from the B-spline basis and it is assumed that intercept is
added to the statistical models used afterwards.</p>
</td></tr>
<tr><td><code id="BsBasis_+3A_x">x</code></td>
<td>
<p>a numeric vector to be used to create the B-spline basis.</p>
</td></tr>
<tr><td><code id="BsBasis_+3A_tgrid">tgrid</code></td>
<td>
<p>if given then it is used to plot the basis.</p>
</td></tr>  
<tr><td><code id="BsBasis_+3A_bname">Bname</code></td>
<td>
<p>label for the created columns with the B-spline basis.</p>
</td></tr>
<tr><td><code id="BsBasis_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the B-spline basis is plotted.</p>
</td></tr>
<tr><td><code id="BsBasis_+3A_lwd">lwd</code>, <code id="BsBasis_+3A_col">col</code>, <code id="BsBasis_+3A_xlab">xlab</code>, <code id="BsBasis_+3A_ylab">ylab</code></td>
<td>
<p>arguments passed to the plotting
function.</p>
</td></tr>
<tr><td><code id="BsBasis_+3A_pch">pch</code>, <code id="BsBasis_+3A_cex.pch">cex.pch</code></td>
<td>
<p>plotting character and cex used to plot knots</p>
</td></tr>
<tr><td><code id="BsBasis_+3A_knotcol">knotcol</code></td>
<td>
<p>color for knots on the plot with the B-spline basis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the B-spline basis. Number of rows is equal to the
length of <code>x</code>.
</p>
<p>Additionally, the resulting matrix has attributes:
</p>
<table>
<tr><td><code>degree</code></td>
<td>
<p>B-spline degree</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>logical indicating the presence of the intercept B-spline</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>a numeric vector of knots</p>
</td></tr>
<tr><td><code>knotsInner</code></td>
<td>
<p>a numeric vector of innner knots</p>
</td></tr>
<tr><td><code>knotsBound</code></td>
<td>
<p>a numeric vector of boundary knots</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the length of the B-spline basis (number of columns of the
resulting object).</p>
</td></tr>
<tr><td><code>tgrid</code></td>
<td>
<p>a numeric vector which can be used on <code>x</code>-axis to
plot the basis.</p>
</td></tr>
<tr><td><code>Xgrid</code></td>
<td>
<p>a matrix with <code>length(tgrid)</code> rows and <code>df</code>
columns which can be used to plot the basis.</p>
</td></tr>    
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="splines.html#topic+bs">bs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20101126)
t &lt;- runif(20, 0, 100)

oldPar &lt;- par(mfrow=c(1, 2), bty="n")
Bs &lt;- BsBasis(degree=3, ninner=3, knotsBound=c(0, 100), intercept=FALSE,
              x=t, tgrid=0:100, plot=TRUE)
print(Bs)

Bs2 &lt;- BsBasis(degree=3, ninner=3, knotsBound=c(0, 100), intercept=TRUE,
               x=t, tgrid=0:100, plot=TRUE)
print(Bs2)
par(oldPar)

print(Bs)
print(Bs2)
</code></pre>

<hr>
<h2 id='cbplot'>
Plot a function together with its confidence/credible bands
</h2><span id='topic+cbplot'></span>

<h3>Description</h3>

<p>This routine typically plots a function together with its confidence
or credible bands. The credible band can be indicated either by
additional lines or by a shaded region or by both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbplot(x, y, low, upp, type=c("l", "s"), band.type=c("ls", "s", "l"), add=FALSE,
       col="darkblue", lty=1, lwd=2,
       cbcol=col, cblty=4, cblwd=lwd,
       scol=rainbow_hcl(1, start=180, end=180), slwd=5,
       xlim, ylim, xlab, ylab, main="", sub="", cex.lab=1, cex.axis=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbplot_+3A_x">x</code></td>
<td>
<p>a numeric vector with <code>x</code> coordinates corresponding to
<code>y</code>, <code>low</code>, <code>upp</code>.
</p>
</td></tr>
<tr><td><code id="cbplot_+3A_y">y</code></td>
<td>
<p>a numeric vector with <code>y</code> coordinates of the function to
plot.
</p>
</td></tr>
<tr><td><code id="cbplot_+3A_low">low</code></td>
<td>
<p>a numeric vector with <code>y</code> coordinates of the lower
limit of the credible band.
</p>
</td></tr>
<tr><td><code id="cbplot_+3A_upp">upp</code></td>
<td>
<p>a numeric vector with <code>y</code> coordinates of the upper
limit of the credible band.
</p>
</td></tr>
<tr><td><code id="cbplot_+3A_type">type</code></td>
<td>
<p>argument with the same meaning as <code>type</code> in <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="cbplot_+3A_band.type">band.type</code></td>
<td>
<p>a character which specifies the graphical way to show
the credible band, &ldquo;ls&rdquo; stands for line and shaded region,
&ldquo;s&rdquo; stands for shaded region only and &ldquo;l&rdquo; stands for
line only.
</p>
</td></tr>
<tr><td><code id="cbplot_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code> then everything is added to the current
plot.
</p>
</td></tr>
<tr><td><code id="cbplot_+3A_col">col</code>, <code id="cbplot_+3A_lty">lty</code>, <code id="cbplot_+3A_lwd">lwd</code></td>
<td>
<p>graphical paramters to draw the x-y line.
</p>
</td></tr>
<tr><td><code id="cbplot_+3A_cbcol">cbcol</code>, <code id="cbplot_+3A_cblty">cblty</code>, <code id="cbplot_+3A_cblwd">cblwd</code></td>
<td>
<p>graphical parameters to draw the x-low and
x-upp lines.
</p>
</td></tr>
<tr><td><code id="cbplot_+3A_scol">scol</code>, <code id="cbplot_+3A_slwd">slwd</code></td>
<td>
<p>graphical parameters for the shaded region between
the credible/confidence bounds.
</p>
</td></tr>
<tr><td><code id="cbplot_+3A_xlim">xlim</code>, <code id="cbplot_+3A_ylim">ylim</code>, <code id="cbplot_+3A_xlab">xlab</code>, <code id="cbplot_+3A_ylab">ylab</code>, <code id="cbplot_+3A_main">main</code>, <code id="cbplot_+3A_sub">sub</code>, <code id="cbplot_+3A_cex.lab">cex.lab</code>, <code id="cbplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>other graphical parameters.
</p>
</td></tr>
<tr><td><code id="cbplot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> function.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Artificial credible bands around the CDF's of N(100, 15*15)
### and N(80, 10*10)
iq &lt;- seq(55, 145, length=100)
Fiq &lt;- pnorm(iq, 100, 15)
low &lt;- Fiq - 0.1
upp &lt;- Fiq + 0.1

iq2 &lt;- seq(35, 125, length=100)
Fiq2 &lt;- pnorm(iq, 80, 10)
low2 &lt;- Fiq2 - 0.1
upp2 &lt;- Fiq2 + 0.1

cbplot(iq, Fiq, low, upp, xlim=c(35, 145))
cbplot(iq2, Fiq2, low2, upp2, add=TRUE, col="red4",
       scol=rainbow_hcl(1, start=20, end=20))
</code></pre>

<hr>
<h2 id='Dirichlet'>
Dirichlet distribution
</h2><span id='topic+Dirichlet'></span><span id='topic+rDirichlet'></span><span id='topic+C_rDirichlet_R'></span>

<h3>Description</h3>

<p>Random number generation for the Dirichlet distribution
<code class="reqn">D(\alpha_1,\dots,\alpha_K).</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rDirichlet(n, alpha=c(1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dirichlet_+3A_n">n</code></td>
<td>
<p>number of observations to be sampled.</p>
</td></tr>  
<tr><td><code id="Dirichlet_+3A_alpha">alpha</code></td>
<td>
<p>parameters of the Dirichlet distribution (&lsquo;prior sample sizes&rsquo;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Some objects.
</p>


<h3>Value for rDirichlet</h3>

<p>A matrix with sampled values.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Devroye, L. (1986).
<em>Non-Uniform Random Variate Generation</em>.
New York: Springer-Verlag, Chap. XI.
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., and Rubin, D. B. (2004).
<em>Bayesian Data Analysis. Second Edition</em>.
Boca Raton: Chapman and Hall/CRC, pp. 576, 582.  
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rbeta">rbeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1977)

alpha &lt;- c(1, 2, 3)
Mean &lt;- alpha/sum(alpha)
Var &lt;- -(alpha %*% t(alpha))
diag(Var) &lt;- diag(Var) + alpha*sum(alpha)
Var &lt;- Var/(sum(alpha)^2*(1+sum(alpha)))
x &lt;- rDirichlet(1000, alpha=alpha)
x[1:5,]

apply(x, 1, sum)[1:5]           ### should be all ones
rbind(Mean, apply(x, 2, mean))

var(x)
print(Var)
</code></pre>

<hr>
<h2 id='Enzyme'>Enzymatic activity in the blood</h2><span id='topic+Enzyme'></span>

<h3>Description</h3>

<p>Enzymatic activity in the blood, for an enzyme involved in the
metabolism of carcinogenic substances, among a group of 245 unrelated individuals.
</p>
<p>Bechtel et al. (1993) identified a mixture of two skewed distributions
by using maximum-likelihood estimation.
Richardson and Green (1997) used a normal mixture estimated using
reversible jump MCMC to estimate the distribution of the enzymatic activity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Enzyme)</code></pre>


<h3>Format</h3>

<p>A numeric vector with observed values.
</p>


<h3>Source</h3>

<p>Originally from http://www.stats.bris.ac.uk/~peter/mixdata/
</p>


<h3>References</h3>

<p><code class="reqn">\mbox{Bechtel, Y. C., Bona\"{\i}ti-Pelli\'e, C., Poisson, N., Magnette, J., and Bechtel, P. R.}</code>(1993).  
A population and family study of N-acetyltransferase using caffeine urinary metabolites.
<em>Clinical Pharmacology and Therapeutics</em>, <b>54</b>, 134&ndash;141.
</p>
<p>Richardson, S. and Green, P. J. (1997).
On Bayesian analysis of mixtures with unknown number of components (with Discussion).
<em>Journal of the Royal Statistical Society, Series B</em>, <b>59</b>, 731&ndash;792.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Enzyme)
summary(Enzyme)
</code></pre>

<hr>
<h2 id='Faithful'>Old Faithful Geyser Data</h2><span id='topic+Faithful'></span>

<h3>Description</h3>

<p>Waiting time between eruptions and the duration of the eruption
for the Old Faithful geyser in Yellowstone National Park, Wyoming,
USA, version used in <code class="reqn">\mbox{H\"ardle, W.}</code> (1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Faithful)</code></pre>


<h3>Format</h3>

<p>A data frame with 272 observations on 2 variables.
</p>

<dl>
<dt><code>eruptions</code></dt><dd><p>eruption time in minutes</p>
</dd>
<dt><code>waiting</code></dt><dd><p>waiting time to the next eruption in minutes</p>
</dd>    
</dl>
  


<h3>Details</h3>

<p>There are many versions of this dataset around. Azzalini and Bowman
(1990) use a more complete version.  
</p>


<h3>Source</h3>

<p>R package MASS
</p>


<h3>References</h3>

<p><code class="reqn">\mbox{H\"ardle, W.}</code> (1991).
<em>Smoothing Techniques with Implementation in S</em>.
New York: Springer.
</p>
<p>Azzalini, A. and Bowman, A. W. (1990).
A look at some data on the Old Faithful geyser.
<em>Applied Statistics</em>, <b>39</b>, 357-365.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+geyser">geyser</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Faithful)
summary(Faithful)
</code></pre>

<hr>
<h2 id='fitted.GLMM_MCMC'>Fitted profiles in the GLMM model</h2><span id='topic+fitted.GLMM_MCMC'></span>

<h3>Description</h3>

<p>It calculates fitted profiles in the (multivariate) GLMM
with a normal mixture in the random effects distribution based on
selected posterior summary statistic of the model parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GLMM_MCMC'
fitted(object, x, z,
  statistic=c("median", "mean", "Q1", "Q3", "2.5%", "97.5%"),
  overall=FALSE, glmer=TRUE, nAGQ=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.GLMM_MCMC_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.GLMM_MCMC_+3A_x">x</code></td>
<td>
<p>matrix or list of matrices (in the case of multiple
responses) for &ldquo;fixed effects&rdquo; part of the model used in the
calculation of fitted values.</p>
</td></tr>
<tr><td><code id="fitted.GLMM_MCMC_+3A_z">z</code></td>
<td>
<p>matrix or list of matrices (in the case of multiple
responses) for &ldquo;random effects&rdquo; part of the model used in the
calculation of fitted values.</p>
</td></tr>
<tr><td><code id="fitted.GLMM_MCMC_+3A_statistic">statistic</code></td>
<td>
<p>character which specifies the posterior summary
statistic to be used to calculate fitted profiles. Default is the
posterior median. It applies only to the overall fit.</p>
</td></tr>
<tr><td><code id="fitted.GLMM_MCMC_+3A_overall">overall</code></td>
<td>
<p>logical. If <code>TRUE</code>, fitted profiles based on posterior
mean/median/Q1/Q3/2.5%/97.5% of the model parameters are computed.
</p>
<p>If <code>FALSE</code>, fitted profiles based on posterior means
given mixture component are calculated. Note that this depends on
used re-labelling of the mixture components and hence might be
misleading if re-labelling is not succesfull!</p>
</td></tr>
<tr><td><code id="fitted.GLMM_MCMC_+3A_glmer">glmer</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the real marginal means
are calculated using Gaussian quadrature.</p>
</td></tr>
<tr><td><code id="fitted.GLMM_MCMC_+3A_nagq">nAGQ</code></td>
<td>
<p>number of quadrature points used when <code>glmer</code> is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted.GLMM_MCMC_+3A_...">...</code></td>
<td>
<p>possibly extra arguments. Nothing useful at this moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (one component for each of multivariate responses from the
model) with fitted values calculated using the <code>x</code> and <code>z</code>
matrices. If <code>overall</code> is <code>FALSE</code>, these are then matrices
with one column for each mixture component.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### WILL BE ADDED.
</code></pre>

<hr>
<h2 id='Galaxy'>Velocities of distant galaxies</h2><span id='topic+Galaxy'></span>

<h3>Description</h3>

<p>Velocities (in km/sec) of 82 distant galaxies, diverging from our own galaxy.
</p>
<p>The dataset was first described by Roeder (1990) and subsequently
analysed under different mixture models by several researchers
including Escobar and West (1995) and Phillips and Smith (1996).
Richardson and Green (1997) used a normal mixture estimated using
reversible jump MCMC to estimate the distribution of the velocities.
</p>
<p><b>REMARK:</b> 78th observation is here 26.96 whereas it should be
26.69 (see <code><a href="MASS.html#topic+galaxies">galaxies</a></code>). A value of 26.96 used in
Richardson and Green (1997) is kept here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Galaxy)</code></pre>


<h3>Format</h3>

<p>A numeric vector with observed values.
</p>


<h3>Source</h3>

<p>Originally from http://www.stats.bris.ac.uk/~peter/mixdata/
</p>


<h3>References</h3>

<p>Escobar, M. D. and West, M. (1995).
Bayesian density estimation and inference using mixtures.
<em>Journal of the American Statistical Association</em>, <b>90</b>, 577&ndash;588.
</p>
<p>Phillips, D. B. and Smith, A. F. M. (1996).
Bayesian model comparison via jump diffusions.
In <em>Practical Markov Chain Monte Carlo</em>,
eds: W. R. Gilks, S. Richardson, and D. J. Spiegelhalter, ch. 13, pp. 215-239.
London: Chapman and Hall.
</p>
<p>Richardson, S. and Green, P. J. (1997).
On Bayesian analysis of mixtures with unknown number of components (with Discussion).
<em>Journal of the Royal Statistical Society, Series B</em>, <b>59</b>, 731&ndash;792.
</p>
<p>Roeder, K. (1990).
Density estimation with confidence sets exemplified by superclusters and voids in the galaxies.
<em>Journal of the American Statistical Association</em>, <b>85</b>, 617&ndash;624.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+galaxies">galaxies</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Galaxy)
summary(Galaxy)
</code></pre>

<hr>
<h2 id='generatePermutations'>
Generate all permutations of (1, ..., K) 
</h2><span id='topic+generatePermutations'></span><span id='topic+C_generatePermutations'></span>

<h3>Description</h3>

<p>It generates a matrix containing all permutations of (1, ..., K).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatePermutations(K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatePermutations_+3A_k">K</code></td>
<td>
<p>integer value of <code class="reqn">K</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension <code class="reqn">K! \times K</code> with generated
permutations in rows.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generatePermutations(1)
generatePermutations(2)
generatePermutations(3)
generatePermutations(4)
</code></pre>

<hr>
<h2 id='getProfiles'>Individual longitudinal profiles of a given variable</h2><span id='topic+getProfiles'></span>

<h3>Description</h3>

<p>It creates a list with individual longitudinal profiles of a given variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getProfiles(t, y, id, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getProfiles_+3A_t">t</code></td>
<td>
<p>a character string giving the name of the variable with &ldquo;time&rdquo;.</p>
</td></tr>
<tr><td><code id="getProfiles_+3A_y">y</code></td>
<td>
<p>a character string giving the names of the responses variables
to keep in the resulting object.</p>
</td></tr>
<tr><td><code id="getProfiles_+3A_id">id</code></td>
<td>
<p>a character string giving the name of the variable which
identifies subjects.</p>
</td></tr>
<tr><td><code id="getProfiles_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> with all the variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>data.frame</code>s, one for each subject identified by
<code>id</code> in the original <code>data</code>.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotProfiles">plotProfiles</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PBCseq, package="mixAK")
ip &lt;- getProfiles(t="day", y=c("age", "lbili", "platelet", "spiders"),
                  id="id", data=PBCseq)
print(ip[[2]])
print(ip[[34]])

XLIM &lt;- c(0, 910)
lcol1 &lt;- rainbow_hcl(1, start=40, end=40)

oldPar &lt;- par(mfrow=c(1, 3), bty="n")
plotProfiles(ip=ip, data=PBCseq, xlim=XLIM, var="lbili", tvar="day",
             xlab="Time (days)", col=lcol1, auto.layout=FALSE, main="Log(bilirubin)")
plotProfiles(ip=ip, data=PBCseq, xlim=XLIM, var="platelet", tvar="day",
             xlab="Time (days)", col=lcol1, auto.layout=FALSE, main="Platelet count")
plotProfiles(ip=ip, data=PBCseq, xlim=XLIM, var="spiders",  tvar="day",
             xlab="Time (days)", col=lcol1, auto.layout=FALSE)
par(oldPar)
</code></pre>

<hr>
<h2 id='GLMM_longitDA'>
Discriminant analysis for longitudinal profiles based on fitted GLMM's
</h2><span id='topic+GLMM_longitDA'></span><span id='topic+C_GLMM_longitDA'></span>

<h3>Description</h3>

<p>The idea is that we fit (possibly different) GLMM's for data in training 
groups using the function <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> and then use the fitted 
models for discrimination of new observations. For more details we 
refer to Komárek et al. (2010).
</p>
<p>Currently, only continuous responses for which linear mixed models are
assumed are allowed.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_longitDA(mod, w.prior, y, id, time, x, z, xz.common=TRUE, info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_longitDA_+3A_mod">mod</code></td>
<td>
<p>a list containing models fitted with the
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function. Each component of the list is the
GLMM fitted in the training dataset of each cluster.
</p>
</td></tr>
<tr><td><code id="GLMM_longitDA_+3A_w.prior">w.prior</code></td>
<td>
<p>a vector with prior cluster weights. The length of this
argument must be the same as the length of argument <code>mod</code>.
Can also be given relatively, e.g., as <code>c(1, 1)</code> which means
that both prior weights are equal to 1/2.
</p>
</td></tr>
<tr><td><code id="GLMM_longitDA_+3A_y">y</code></td>
<td>
<p>vector, matrix or data frame (see argument <code>y</code> of
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function) with responses of objects that are
to be clustered.
</p>
</td></tr>
<tr><td><code id="GLMM_longitDA_+3A_id">id</code></td>
<td>
<p>vector which determines clustered observations (see also
argument <code>y</code> of <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function).
</p>
</td></tr>
<tr><td><code id="GLMM_longitDA_+3A_time">time</code></td>
<td>
<p>vector which gives indeces of observations within
clusters. It appears (together with <code>id</code>) in the output as
identifier of observations</p>
</td></tr>  
<tr><td><code id="GLMM_longitDA_+3A_x">x</code></td>
<td>
<p>see <code>xz.common</code> below.</p>
</td></tr>
<tr><td><code id="GLMM_longitDA_+3A_z">z</code></td>
<td>
<p>see <code>xz.common</code> below.</p>
</td></tr>
<tr><td><code id="GLMM_longitDA_+3A_xz.common">xz.common</code></td>
<td>
<p>a logical value.
</p>
<p>If <code>TRUE</code> then it is assumed
that the X and Z matrices are the same for GLMM in each cluster. In
that case, arguments <code>x</code> and <code>z</code> have the same structure
as arguments <code>x</code> and <code>z</code> of <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>
function.
</p>
<p>If <code>FALSE</code> then X and Z matrices for the GLMM may differ across
clusters. In that case, arguments <code>x</code> and <code>z</code> are both
lists of length equal to the number of clusters and each component
of lists <code>x</code> and <code>z</code> has the same structure as arguments
<code>x</code> and <code>z</code> of <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
</p>
</td></tr>
<tr><td><code id="GLMM_longitDA_+3A_info">info</code></td>
<td>
<p>interval in which the function prints the progress of computation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function complements a paper Komárek et al. (2010).
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>ident</code></td>
<td>
<p>ADD DESCRIPTION</p>
</td></tr>
<tr><td><code>marg</code></td>
<td>
<p>ADD DESCRIPTION</p>
</td></tr>
<tr><td><code>cond</code></td>
<td>
<p>ADD DESCRIPTION</p>
</td></tr>
<tr><td><code>ranef</code></td>
<td>
<p>ADD DESCRIPTION</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A., Hansen, B. E., Kuiper,
E. M. M., van Buuren, H. R., and Lesaffre, E. (2010).
Discriminant analysis using a multivariate linear mixed model with a
normal mixture in the random effects distribution.
<em>Statistics in Medicine</em>, <b>29</b>(30), 3267&ndash;3283.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>, <code><a href="#topic+GLMM_longitDA2">GLMM_longitDA2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### WILL BE ADDED.
</code></pre>

<hr>
<h2 id='GLMM_longitDA2'>
Discriminant analysis for longitudinal profiles based on fitted GLMM's
</h2><span id='topic+GLMM_longitDA2'></span><span id='topic+C_GLMM_longitDA2'></span>

<h3>Description</h3>

<p>WILL BE ADDED.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_longitDA2(mod, w.prior, y, id, x, z, xz.common = TRUE,
               keep.comp.prob = FALSE, level = 0.95,
               info, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_longitDA2_+3A_mod">mod</code></td>
<td>
<p>a list containing models fitted with the
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function. Each component of the list is the
GLMM fitted in the training dataset of each cluster.
</p>
</td></tr>
<tr><td><code id="GLMM_longitDA2_+3A_w.prior">w.prior</code></td>
<td>
<p>a vector with prior cluster weights. The length of this
argument must be the same as the length of argument <code>mod</code>.
Can also be given relatively, e.g., as <code>c(1, 1)</code> which means
that both prior weights are equal to 1/2.
</p>
</td></tr>
<tr><td><code id="GLMM_longitDA2_+3A_y">y</code></td>
<td>
<p>vector, matrix or data frame (see argument <code>y</code> of
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function) with responses of objects that are
to be clustered.
</p>
</td></tr>
<tr><td><code id="GLMM_longitDA2_+3A_id">id</code></td>
<td>
<p>vector which determines clustered observations (see also
argument <code>y</code> of <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function).
</p>
</td></tr>
<tr><td><code id="GLMM_longitDA2_+3A_x">x</code></td>
<td>
<p>see <code>xz.common</code> below.</p>
</td></tr>
<tr><td><code id="GLMM_longitDA2_+3A_z">z</code></td>
<td>
<p>see <code>xz.common</code> below.</p>
</td></tr>
<tr><td><code id="GLMM_longitDA2_+3A_xz.common">xz.common</code></td>
<td>
<p>a logical value.
</p>
<p>If <code>TRUE</code> then it is assumed
that the X and Z matrices are the same for GLMM in each cluster. In
that case, arguments <code>x</code> and <code>z</code> have the same structure
as arguments <code>x</code> and <code>z</code> of <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>
function.
</p>
<p>If <code>FALSE</code> then X and Z matrices for the GLMM may differ across
clusters. In that case, arguments <code>x</code> and <code>z</code> are both
lists of length equal to the number of clusters and each component
of lists <code>x</code> and <code>z</code> has the same structure as arguments
<code>x</code> and <code>z</code> of <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
</p>
</td></tr>
<tr><td><code id="GLMM_longitDA2_+3A_keep.comp.prob">keep.comp.prob</code></td>
<td>
<p>a logical value indicating whether the
allocation probabilities should be kept for all MCMC
iterations. This may ask for quite some memory but it is necessary
if credible intervals etc. should be calculated for the component
probabilities.</p>
</td></tr>
<tr><td><code id="GLMM_longitDA2_+3A_level">level</code></td>
<td>
<p>level of HPD credible intervals that are calculated for
the component probabilities if <code>keep.comp.prob</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GLMM_longitDA2_+3A_info">info</code></td>
<td>
<p>interval in which the function prints the progress of
computation (unless <code>silent</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="GLMM_longitDA2_+3A_silent">silent</code></td>
<td>
<p>logical value indicating whether to switch-off printing
the information during calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function complements a paper being currently in preparation.
</p>
<p><code>GLMM_longitDA2</code> differs in many aspects from <code><a href="#topic+GLMM_longitDA2">GLMM_longitDA2</a></code>!
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>ADD</code></td>
<td>
<p>ADD DESCRIPTION</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>, <code><a href="#topic+GLMM_longitDA">GLMM_longitDA</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### WILL BE ADDED.
</code></pre>

<hr>
<h2 id='GLMM_MCMC'>
MCMC estimation of a (multivariate) generalized linear mixed model
with a normal mixture in the distribution of random effects
</h2><span id='topic+GLMM_MCMC'></span><span id='topic+print.GLMM_MCMC'></span><span id='topic+print.GLMM_MCMClist'></span><span id='topic+C_GLMM_MCMC'></span><span id='topic+C_GLMM_PED'></span>

<h3>Description</h3>

<p>This function runs MCMC for a generalized linear mixed model
with possibly several response variables and possibly normal
mixtures in the distributions of random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_MCMC(y, dist = "gaussian", id, x, z, random.intercept,
     prior.alpha, init.alpha, init2.alpha,                      
     scale.b,     prior.b,    init.b,      init2.b,
     prior.eps,   init.eps,   init2.eps,
     nMCMC = c(burn = 10, keep = 10, thin = 1, info = 10),
     tuneMCMC = list(alpha = 1, b = 1),
     store = c(b = FALSE), PED = TRUE, keep.chains = TRUE,
     dens.zero = 1e-300, parallel = FALSE, cltype, silent = FALSE)

## S3 method for class 'GLMM_MCMC'
print(x, ...)

## S3 method for class 'GLMM_MCMClist'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_MCMC_+3A_y">y</code></td>
<td>
<p>vector, matrix or data frame with responses. If <code>y</code> is vector then
there is only one response in the model. If <code>y</code> is matrix or data frame then
each column gives values of one response. Missing values are allowed.
</p>
<p>If there are several responses specified then 
continuous responses must be put in the first columns and
discrete responses in the subsequent columns.
</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_dist">dist</code></td>
<td>
<p>character (vector) which determines distribution (and a link function)
for each response variable. Possible values are:
&ldquo;gaussian&rdquo; for gaussian (normal) distribution (with identity link),
&ldquo;binomial(logit)&rdquo; for binomial (0/1) distribution with a logit link.
&ldquo;poisson(log)&rdquo; for Poisson distribution with a log link.     
Single value is recycled if necessary.
</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_id">id</code></td>
<td>
<p>vector which determines longitudinally or otherwise dependent observations. If not given then it is assumed
that there are no clusters and all observations of one response are
independent.
</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_x">x</code></td>
<td>
<p>matrix or a list of matrices with covariates (intercept not included) for fixed effects.
If there is more than one response, this must always be a list. Note that intercept in included
in all models. Use a character value &ldquo;empty&rdquo; as a component of the list <code>x</code>
if there are no covariates for a particular response.
</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_z">z</code></td>
<td>
<p>matrix or a list of matrices with covariates (intercept not included) for random effects.
If there is more than one response, this must always be a list. Note that random intercept
is specified using the argument <code>random.intercept</code>.
</p>
<p>REMARK: For a particular response, matrices <code>x</code> and <code>z</code>
may not have the same columns. That is, matrix <code>x</code> includes
covariates which are not involved among random effects and matrix
<code>z</code> includes covariates which are involved among random effects
(and implicitely among fixed effects as well).
</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_random.intercept">random.intercept</code></td>
<td>
<p>logical (vector) which determines for which responses random intercept
should be included.
</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_prior.alpha">prior.alpha</code></td>
<td>
<p>a list which specifies prior distribution for fixed
effects (not the means of random effects). The prior distribution is
normal and the user can specify the mean and variances.
The list <code>prior.alpha</code> can have the components listed below.
</p>

<dl>
<dt>mean</dt><dd><p>a vector with prior means, defaults to zeros.</p>
</dd>
<dt>var</dt><dd><p>a vector with prior variances, defaults to 10000 for
all components.</p>
</dd>      
</dl>
      
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_init.alpha">init.alpha</code></td>
<td>
<p>a numeric vector with initial values of fixed effects
(not the means of random effects) for the first chain. A sensible value is determined using the
maximum-likelihood fits (using <code><a href="lme4.html#topic+lmer">lmer</a></code> functions)
and does not have to be given by the user.
</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_init2.alpha">init2.alpha</code></td>
<td>
<p>a numeric vector with initial values of fixed
effects for the second chain.
</p>
</td></tr>  
<tr><td><code id="GLMM_MCMC_+3A_scale.b">scale.b</code></td>
<td>
<p>a list specifying how to scale the random effects during
the MCMC. A sensible value is determined using the
maximum-likelihood fits (using <code><a href="lme4.html#topic+lmer">lmer</a></code> functions)
and does not have to be given by the user.
</p>
<p>If the user wishes to influence the shift and scale constants, these
are given as components of the list <code>scale.b</code>. The components
are named:
</p>

<dl>
<dt>shift</dt><dd><p>see vignette <a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>
<dt>scale</dt><dd><p>see vignette <a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>
</dl>
          
</td></tr>  
<tr><td><code id="GLMM_MCMC_+3A_prior.b">prior.b</code></td>
<td>
<p>a list which specifies prior distribution for (shifted
and scaled) random effects. The prior is in principle a normal
mixture (being a simple normal distribution if we restrict the
number of mixture components to be equal to one).
</p>
<p>The list <code>prior.b</code> can have the components listed below. Their
meaning is analogous to the components of the same name of the
argument <code>prior</code> of function <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> (see
therein for details).
</p>

<dl>
<dt>distribution</dt><dd><p>a character string which specifies the assumed
prior distribution for random effects. It can be either
&ldquo;normal&rdquo; (multivaruate normal - default) or &ldquo;MVT&rdquo;
(multivariate Student t distribution).</p>
</dd>
<dt>priorK</dt><dd><p>a character string which specifies the type of the
prior for <code class="reqn">K</code> (the number of mixture components).
</p>
</dd>
<dt>priormuQ</dt><dd><p>a character string which specifies the type of the
prior for mixture means and mixture variances.
</p>
</dd>
<dt>Kmax</dt><dd><p>maximal number of mixture components.</p>
</dd>
<dt>lambda</dt><dd><p>see vignette
<a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>
<dt>delta</dt><dd><p>see vignette
<a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>
<dt>xi</dt><dd><p>see vignette
<a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>
<dt>ce</dt><dd><p>see vignette
<a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>
<dt>D</dt><dd><p>see vignette
<a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>
<dt>zeta</dt><dd><p>see vignette
<a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>
<dt>gD</dt><dd><p>see vignette
<a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>
<dt>hD</dt><dd><p>see vignette
<a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>
<dt>gdf</dt><dd><p>shape parameter of the prior distribution for the
degrees of freedom if the random effects are assumed to follow
the MVT distribution</p>
</dd>
<dt>hdf</dt><dd><p>rate parameter of the prior distribution for the
degrees of freedom if the random effects are assumed to follow
the MVT distribution</p>
</dd>
</dl>
  
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_init.b">init.b</code></td>
<td>
<p>a list with initial values of the first chain for parameters related to the
distribution of random effects and random effects
themselves. Sensible initial values are determined by the function
itself and do not have to be given by the user.
</p>

<dl>
<dt>b</dt><dd></dd>
<dt>K</dt><dd></dd>
<dt>w</dt><dd></dd>
<dt>mu</dt><dd></dd>
<dt>Sigma</dt><dd></dd>
<dt>Li</dt><dd></dd>
<dt>gammaInv</dt><dd></dd>
<dt>df</dt><dd></dd>
<dt>r</dt><dd></dd>                  
</dl>
  
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_init2.b">init2.b</code></td>
<td>
<p>a list with initial values of the second chain for parameters related to the
distribution of random effects and random effects
themselves.</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_prior.eps">prior.eps</code></td>
<td>
<p>a list specifying prior distributions for
error terms for continuous responses. The list <code>prior.eps</code> can
have the components listed below. For all components, a sensible
value leading to weakly informative prior distribution can be
determined by the function.
</p>

<dl>
<dt>zeta</dt><dd><p>see vignette
<a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>
<dt>g</dt><dd><p>see vignette
<a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>
<dt>h</dt><dd><p>see vignette
<a href="http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf">PBCseq.pdf</a> for details</p>
</dd>       
</dl>
  
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_init.eps">init.eps</code></td>
<td>
<p>a list with initial values of the first chain for parameters related to the
distribution of error terms of continuous responses. The list
<code>init.eps</code> can have the components listed below. For all
components, a sensible value can be determined by the function.
</p>

<dl>
<dt>sigma</dt><dd><p>a numeric vector with the initial values for residual
standard deviations for each continuous response.</p>
</dd>
<dt>gammaInv</dt><dd><p>a numeric vector with the initial values for the
inverted components of the hyperparameter gamma for each
continuous response.</p>
</dd>
</dl>
  
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_init2.eps">init2.eps</code></td>
<td>
<p>a list with initial values of the second chain for parameters related to the
distribution of error terms of continuous responses.</p>
</td></tr>  
<tr><td><code id="GLMM_MCMC_+3A_nmcmc">nMCMC</code></td>
<td>
<p>numeric vector of length 4 giving parameters of the MCMC
simulation. Its components may be named (ordering is then unimportant) as:
</p>

<dl>
<dt>burn</dt><dd><p>length of the burn-in (after discarding the thinned
values), can be equal to zero as well.</p>
</dd>
<dt>keep</dt><dd><p>length of the kept chains (after discarding the
thinned values), must be positive.</p>
</dd>
<dt>thin</dt><dd><p>thinning interval, must be positive.</p>
</dd>
<dt>info</dt><dd><p>interval in which the progress information is printed
on the screen.</p>
</dd>      
</dl>

<p>In total <code class="reqn">(M_{burn} + M_{keep}) \cdot M_{thin}</code> MCMC scans are performed.
</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_tunemcmc">tuneMCMC</code></td>
<td>
<p>a list with tuning scale parameters for proposal
distribution of fixed and random effects. It is used only when there
are some discrete response profiles. The components of the list have
the following meaning:
</p>

<dl>
<dt>alpha</dt><dd><p>scale parameters by which we multiply the proposal
covariance matrix when updating the fixed effects pertaining to
the discrete response profiles. There is one scale parameter for
each DISCRETE profile. A single value is recycled if necessary.</p>
</dd>
<dt>b</dt><dd><p>a scale parameter by which we multiply the proposal
covariance matrix when updating the random effects. It is used
only when there are some discrete response profiles in the model.</p>
</dd>
</dl>
           
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_store">store</code></td>
<td>
<p>logical vector indicating whether the chains of
parameters should be stored. Its components may be named (ordering
is then unimportant) as:
</p>

<dl>
<dt>b</dt><dd><p>if <code>TRUE</code> then the sampled values of random effects
are stored. Defaults to <code>FALSE</code>.</p>
</dd>
</dl>
  
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_ped">PED</code></td>
<td>
<p>a logical value which indicates whether the penalized
expected deviance (see Plummer, 2008 for more details)
is to be computed (which requires two parallel
chains).
</p>
</td></tr>  
<tr><td><code id="GLMM_MCMC_+3A_keep.chains">keep.chains</code></td>
<td>
<p>logical. If <code>FALSE</code>, only summary statistics
are returned in the resulting object. This might be useful in the
model searching step to save some memory.
</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_dens.zero">dens.zero</code></td>
<td>
<p>a small value used instead of zero when computing
deviance related quantities.
</p>
</td></tr>  
<tr><td><code id="GLMM_MCMC_+3A_parallel">parallel</code></td>
<td>
<p>a logical value which indicates whether parallel
computation (based on a package <code>parallel</code>)
should be used when running two chains for the purpose of <code>PED</code>
calculation.</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_cltype">cltype</code></td>
<td>
<p>optional argument applicable if <code>parallel</code> is
<code>TRUE</code>. If <code>cltype</code> is given, it is passed as the
<code>type</code> argument into the call to <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_silent">silent</code></td>
<td>
<p>a logical value indicating whether the information on
the MCMC progress is to be supressed.</p>
</td></tr>
<tr><td><code id="GLMM_MCMC_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the default <code>print</code> method.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>See accompanying papers (Komárek et al., 2010, Komárek and Komárková, 2013).  
</p>


<h3>Value</h3>

<p>An object of class <code>GLMM_MCMClist</code> (if <code>PED</code> argument is
<code>TRUE</code>) or <code>GLMM_MCMC</code> (if <code>PED</code> argument is
<code>FALSE</code>).
</p>


<h3>Object of class GLMM_MCMC</h3>

<p>Object of class <code>GLMM_MCMC</code> can have the following
components (some of them may be missing according to the context
of the model):
</p>
  
<dl>
<dt>iter</dt><dd><p>index of the last iteration performed.</p>
</dd>
<dt>nMCMC</dt><dd><p>used value of the argument <code>nMCMC</code>.</p>
</dd>
<dt>dist</dt><dd><p>a character vector of length R corresponding to the
<code>dist</code> argument.</p>
</dd>  
<dt>R</dt><dd><p>a two component vector giving the number of continuous
responses and the number of discrete responses.</p>
</dd>
<dt>p</dt><dd><p>a numeric vector of length R giving the number of
non-intercept alpha parameters for each response.</p>
</dd>
<dt>q</dt><dd><p>a numeric vector of length R giving the number of
non-intercept random effects for each response.</p>
</dd>
<dt>fixed.intercept</dt><dd><p>a logical vector of length R which indicates
inclusion of fixed intercept for each response.</p>
</dd>
<dt>random.intercept</dt><dd><p>a logical vector of length R which indicates
inclusion of random intercept for each response.</p>
</dd>  
<dt>lalpha</dt><dd><p>length of the vector of fixed effects.</p>
</dd>
<dt>dimb</dt><dd><p>dimension of the distribution of random effects.</p>
</dd>
<dt>prior.alpha</dt><dd><p>a list containing the used value of the
argument <code>prior.alpha</code>.</p>
</dd>
<dt>prior.b</dt><dd><p>a list containing the used value of the
argument <code>prior.b</code>.</p>
</dd>
<dt>prior.eps</dt><dd><p>a list containing the used value of the
argument <code>prior.eps</code>.</p>
</dd>
<dt>init.alpha</dt><dd><p>a numeric vector with the used value of the
argument <code>init.alpha</code>.</p>
</dd>
<dt>init.b</dt><dd><p>a list containing the used value of the
argument <code>init.b</code>.</p>
</dd>
<dt>init.eps</dt><dd><p>a list containing the used value of the
argument <code>init.eps</code>.</p>
</dd>
<dt>state.first.alpha</dt><dd><p>a numeric vector with the first stored (after burn-in) value
of fixed effects <code class="reqn">\alpha</code>.</p>
</dd>
<dt>state.last.alpha</dt><dd><p>a numeric vector with the last sampled value
of fixed effects <code class="reqn">\alpha</code>. It can be used as argument
<code>init.alpha</code> to restart MCMC.</p>
</dd>
<dt>state.first.b</dt><dd><p>a list with the first stored (after burn-in) values of parameters
related to the distribution of random effects. It has components
named <code>b</code>, <code>K</code>, <code>w</code>, <code>mu</code>, <code>Sigma</code>, <code>Li</code>, <code>Q</code>,
<code>gammaInv</code>, <code>r</code>.</p>
</dd>
<dt>state.last.b</dt><dd><p>a list with the last sampled values of parameters
related to the distribution of random effects. It has components
named <code>b</code>, <code>K</code>, <code>w</code>, <code>mu</code>, <code>Sigma</code>, <code>Li</code>, <code>Q</code>,
<code>gammaInv</code>, <code>r</code>. It can be used as argument
<code>init.b</code> to restart MCMC.</p>
</dd>
<dt>state.first.eps</dt><dd><p>a list with the first stored (after burn-in) values of parameters
related to the distribution of residuals of continuous responses. It
has components named <code>sigma</code>, <code>gammaInv</code>.</p>
</dd>
<dt>state.last.eps</dt><dd><p>a list with the last sampled values of parameters
related to the distribution of residuals of continuous responses. It
has components named <code>sigma</code>, <code>gammaInv</code>. It can be used as argument
<code>init.eps</code> to restart MCMC.</p>
</dd>
<dt>prop.accept.alpha</dt><dd><p>acceptance proportion from the
Metropolis-Hastings algorithm for fixed effects
(separately for each response type). Note that the acceptance
proportion is equal to one for continuous responses since the Gibbs
algorithm is used there.</p>
</dd>
<dt>prop.accept.b</dt><dd><p>acceptance proportion from the
Metropolis-Hastings algorithm for random effects
(separately for each cluster). Note that the acceptance
proportion is equal to one for models with continuous responses only
since the Gibbs algorithm is used there.</p>
</dd>  
<dt>scale.b</dt><dd><p>a list containing the used value of the argument
<code>scale.b</code>.</p>
</dd>
<dt>summ.Deviance</dt><dd><p>a <code>data.frame</code> with posterior summary
statistics for the deviance (approximated using the Laplacian
approximation) and conditional (given random effects) devience.</p>
</dd>
<dt>summ.alpha</dt><dd><p>a <code>data.frame</code> with posterior summary statistics for fixed effects.</p>
</dd>
<dt>summ.b.Mean</dt><dd><p>a matrix with posterior summary statistics for
means of random effects.</p>
</dd>
<dt>summ.b.SDCorr</dt><dd><p>a matrix with posterior summary statistics for
standard deviations of random effects and correlations of each pair
of random effects.</p>
</dd>
<dt>summ.sigma_eps</dt><dd><p>a matrix with posterior summary statistics for
standard deviations of the error terms in the (mixed) models of
continuous responses.</p>
</dd>
<dt>poster.comp.prob_u</dt><dd><p>a matrix which is present in the output object
if the number of mixture components in the distribution of random
effects is fixed and equal to <code class="reqn">K</code>. In that case,
<code>poster.comp.prob_u</code> is a matrix with <code class="reqn">K</code> columns and <code class="reqn">I</code>
rows (<code class="reqn">I</code> is the number of subjects defining the longitudinal
profiles or correlated observations) with estimated posterior component probabilities
&ndash; posterior means of the components of the underlying 0/1
allocation vector.
</p>
<p><b>WARNING:</b> By default, the labels of components are based on artificial
identifiability constraints based on ordering of the mixture means
in the first margin. Very often, such identifiability constraint is
not satisfactory!
</p>


</dd>
<dt>poster.comp.prob_b</dt><dd><p>a matrix which is present in the output object
if the number of mixture components in the distribution of random
effects is fixed and equal to <code class="reqn">K</code>. In that case,
<code>poster.comp.prob_b</code> is a matrix with <code class="reqn">K</code> columns and <code class="reqn">I</code>
rows (<code class="reqn">I</code> is the number of subjects defining the longitudinal
profiles or correlated observations)
with estimated posterior component probabilities
&ndash; posterior mean over model parameters including random effects.
</p>
<p><b>WARNING:</b> By default, the labels of components are based on artificial
identifiability constraints based on ordering of the mixture means
in the first margin. Very often, such identifiability constraint is
not satisfactory!
</p>


</dd>    
<dt>freqK_b</dt><dd><p>frequency table for the MCMC sample of the number of
mixture components in the distribution of the random effects.</p>
</dd>
<dt>propK_b</dt><dd><p>posterior probabilities for the numbers of mixture
components in the distribution of random effects.</p>
</dd>
<dt>poster.mean.y</dt><dd><p>a list with <code>data.frame</code>s, one
<code>data.frame</code> per response profile. Each <code>data.frame</code>
with columns labeled <code>id</code>, <code>observed</code>,
<code>fitted</code>, <code>stres</code>,
<code>eta.fixed</code> and <code>eta.random</code> holding
identifier for clusters of grouped observations,
observed values and
posterior means for fitted values (response expectation given fixed and random effects),
standardized residuals (derived from fitted values),
fixed effect part of the linear predictor and the random effect part of
the linear predictor. In each column, there are first all values for
the first response, then all values for the second response etc.</p>
</dd>
<dt>poster.mean.profile</dt><dd><p>a <code>data.frame</code> with columns labeled
<code>b1</code>, ..., <code>bq</code>, <code>Logpb</code>, <code>Cond.Deviance</code>, <code>Deviance</code> with
posterior means of random effects for each cluster, posterior
means of <code class="reqn">\log\bigl\{p(\boldsymbol{b})\bigr\}</code>,
conditional deviances, i.e., minus twice the conditional (given
random effects) log-likelihood for each cluster
and GLMM deviances, i.e., minus twice the marginal (random effects
integrated out) log-likelihoods for each cluster. The value of the
marginal (random effects integrated out) log-likelihood at each MCMC
iteration is obtained using the Laplacian approximation.</p>
</dd>
<dt>poster.mean.w_b</dt><dd><p>a numeric vector with posterior means of mixture
weights after re-labeling. It is computed only if <code class="reqn">K_b</code> is fixed
and even then I am not convinced that these are useful posterior
summary statistics (see label switching problem mentioned above).
In any case, they should be used with care.</p>
</dd>
<dt>poster.mean.mu_b</dt><dd><p>a matrix with posterior means of mixture
means after re-labeling. It is computed only if <code class="reqn">K_b</code> is fixed
and even then I am not convinced that these are useful posterior
summary statistics (see label switching problem mentioned above).
In any case, they should be used with care.</p>
</dd>
<dt>poster.mean.Q_b</dt><dd><p>a list with posterior means of mixture inverse
variances after re-labeling. It is computed only if <code class="reqn">K_b</code> is fixed
and even then I am not convinced that these are useful posterior
summary statistics (see label switching problem mentioned above).
In any case, they should be used with care.</p>
</dd>
<dt>poster.mean.Sigma_b</dt><dd><p>a list with posterior means of mixture
variances after re-labeling. It is computed only if <code class="reqn">K_b</code> is fixed
and even then I am not convinced that these are useful posterior
summary statistics (see label switching problem mentioned above).
In any case, they should be used with care.</p>
</dd>
<dt>poster.mean.Li_b</dt><dd><p>a list with posterior means of Cholesky
decompositions of mixture inverse
variances after re-labeling. It is computed only if <code class="reqn">K_b</code> is fixed
and even then I am not convinced that these are useful posterior
summary statistics (see label switching problem mentioned above).
In any case, they should be used with care.</p>
</dd>
<dt>Deviance</dt><dd><p>numeric vector with a chain for the GLMM deviances,
i.e., twice the marginal (random effects integrated out)
log-likelihoods of the GLMM. The marginal log-likelihood is obtained
using the Laplacian approximation at each iteration of MCMC.
</p>
</dd>
<dt>Cond.Deviance</dt><dd><p>numeric vector with a chain for the conditional deviances,
i.e., twice the conditional (given random effects)
log-likelihoods.
</p>
</dd>  
<dt>K_b</dt><dd><p>numeric vector with a chain for <code class="reqn">K_b</code> (number of
mixture components in the distribution of random effects).</p>
</dd>
<dt>w_b</dt><dd><p>numeric vector or matrix with a chain for <code class="reqn">w_b</code> (mixture
weights for the distribution of random effects). It is a matrix with
<code class="reqn">K_b</code> columns when <code class="reqn">K_b</code> is fixed.
Otherwise, it is a vector with weights put sequentially after each other.</p>
</dd>
<dt>mu_b</dt><dd><p>numeric vector or matrix with a chain for <code class="reqn">\mu_b</code> (mixture
means for the distribution of random effects). It is a matrix with
<code class="reqn">dimb\cdot K_b</code> columns when <code class="reqn">K_b</code> is
fixed. Otherwise, it is a vector with means put sequentially after
each other.</p>
</dd>
<dt>Q_b</dt><dd><p>numeric vector or matrix with a chain for lower triangles of <code class="reqn">\boldsymbol{Q}_b</code> (mixture
inverse variances for the distribution of random effects). It is a matrix with <code class="reqn">\frac{dimb(dimb+1)}{2}\cdot K_b</code>
columns when <code class="reqn">K_b</code> is fixed. Otherwise, it is a vector with lower
triangles of <code class="reqn">\boldsymbol{Q}_b</code> matrices put sequentially after each other.</p>
</dd>
<dt>Sigma_b</dt><dd><p>numeric vector or matrix with a chain for lower triangles of <code class="reqn">\Sigma_b</code> (mixture
variances for the distribution of random effects). It is a matrix with <code class="reqn">\frac{dimb(dimb+1)}{2}\cdot K_b</code>
columns when <code class="reqn">K_b</code> is fixed. Otherwise, it is a vector with lower
triangles of <code class="reqn">\Sigma_b</code> matrices put sequentially after each other.</p>
</dd>
<dt>Li_b</dt><dd><p>numeric vector or matrix with a chain for lower triangles of
Cholesky decompositions of <code class="reqn">\boldsymbol{Q}_b</code> matrices.
It is a matrix with <code class="reqn">\frac{dimb(dimb+1)}{2}\cdot K_b</code>
columns when <code class="reqn">K_b</code> is fixed. Otherwise, it is a vector with lower
triangles put sequentially after each other.</p>
</dd>  
<dt>gammaInv_b</dt><dd><p>matrix with <code class="reqn">dimb</code> columns with a chain for inverses
of the hyperparameter <code class="reqn">\boldsymbol{\gamma}_b</code>.</p>
</dd>
<dt>order_b</dt><dd><p>numeric vector or matrix with order indeces of mixture
components in the distribution of random effects related to artificial identifiability constraint
defined by ordering of the first component of the mixture means.
</p>
<p>It is a matrix with <code class="reqn">K_b</code> columns when <code class="reqn">K_b</code> is
fixed. Otherwise it is a vector with orders put sequentially after
each other.</p>
</dd>
<dt>rank_b</dt><dd><p>numeric vector or matrix with rank indeces of mixture
components in the distribution of random effects related to artificial identifiability constraint
defined by ordering of the first component of the mixture means.
</p>
<p>It is a matrix with <code class="reqn">K_b</code> columns when <code class="reqn">K_b</code> is
fixed. Otherwise it is a vector with ranks put sequentially after
each other.</p>
</dd>
<dt>mixture_b</dt><dd><p><code>data.frame</code> with columns labeled
<code>b.Mean.*</code>, <code>b.SD.*</code>, <code>b.Corr.*.*</code>
containing the chains for the means, standard deviations and correlations of the
distribution of the random effects based on a normal mixture at each
iteration.</p>
</dd>
<dt>b</dt><dd><p>a matrix with the MCMC chains for random effects. It is
included only if <code>store[b]</code> is <code>TRUE</code>.</p>
</dd>
<dt>alpha</dt><dd><p>numeric vector or matrix with the MCMC chain(s) for fixed effects.</p>
</dd>
<dt>sigma_eps</dt><dd><p>numeric vector or matrix with the MCMC chain(s) for
standard deviations of the error terms in the (mixed) models for
continuous responses.</p>
</dd>
<dt>gammaInv_eps</dt><dd><p>matrix with <code class="reqn">dimb</code> columns with MCMC chain(s) for inverses
of the hyperparameter <code class="reqn">\boldsymbol{\gamma}_b</code>.</p>
</dd>
<dt>relabel_b</dt><dd><p>a list which specifies the algorithm used to re-label
the MCMC output to compute <code>order_b</code>, <code>rank_b</code>, <code>poster.comp.prob_u</code>,
<code>poster.comp.prob_b</code>, <code>poster.mean.w_b</code>,
<code>poster.mean.mu_b</code>, <code>poster.mean.Q_b</code>,
<code>poster.mean.Sigma_b</code>, <code>poster.mean.Li_b</code>. 
</p>
</dd>
<dt>Cpar</dt><dd><p>a list with components useful to call underlying C++ functions (not
interesting for ordinary users).</p>
</dd>
</dl>



<h3>Object of class GLMM_MCMClist</h3>

<p>Object of class <code>NMixMCMClist</code> is the list having two components
of class <code>NMixMCMC</code> representing two parallel chains and
additionally the following components:
</p>

<dl>
<dt>PED</dt><dd><p>values of penalized expected deviance and related
quantities. It is a vector with five components: <code>D.expect</code> <code class="reqn">=</code>
estimated expected deviance, where the estimate is based on two
parallel chains; <code>popt</code> <code class="reqn">=</code> estimated penalty, where the
estimate is based on simple MCMC average based on two parallel
chains; <code>PED</code> <code class="reqn">=</code> estimated penalized expected deviance
<code class="reqn">=</code> <code>D.expect</code> <code class="reqn">+</code> <code>popt</code>; <code>wpopt</code> <code class="reqn">=</code>
estimated penalty, where the estimate is based on weighted MCMC average
(through importance sampling) based on two parallel chains;
<code>wPED</code> <code class="reqn">=</code> estimated penalized expected deviance <code class="reqn">=</code>
<code>D.expect</code> <code class="reqn">+</code> <code>wpopt</code>.</p>
</dd>
<dt>D</dt><dd><p>posterior mean of the deviance for each subject.</p>
</dd>
<dt>popt</dt><dd><p>contributions to the unweighted penalty from each subject.</p>
</dd>
<dt>wpopt</dt><dd><p>contributions to the weighted penalty from each subject.</p>
</dd>
<dt>inv.D</dt><dd><p>for each subject, number of iterations (in both chains), where the
deviance was in fact equal to infinity (when the corresponding
density was lower than <code>dens.zero</code>) and was not taken into account when
computing <code>D.expect</code>.</p>
</dd>
<dt>inv.popt</dt><dd><p>for each subject, number of iterations, where the
penalty was in fact equal to infinity and was not taken into account
when computing <code>popt</code>.
</p>
</dd>
<dt>inv.wpopt</dt><dd><p>for each subject, number of iterations, where the
importance sampling weight was in fact equal to infinity and was not taken into account
when computing <code>wpopt</code>.</p>
</dd>
<dt>sumISw</dt><dd><p>for each subject, sum of importance sampling
weights.</p>
</dd>
<dt>Deviance1</dt><dd><p>sampled value of the observed data deviance from
chain 1</p>
</dd>
<dt>Deviance2</dt><dd><p>sampled values of the obserbed data deviance from
chain 2</p>
</dd>
<dt>Deviance_repl1_ch1</dt><dd><p>sampled values of the deviance of data
replicated according to the chain 1 evaluated under the parameters
from chain 1</p>
</dd>
<dt>Deviance_repl1_ch2</dt><dd><p>sampled values of the deviance of data
replicated according to the chain 1 evaluated under the parameters
from chain 2</p>
</dd>
<dt>Deviance_repl2_ch1</dt><dd><p>sampled values of the deviance of data
replicated according to the chain 2 evaluated under the parameters
from chain 1</p>
</dd>
<dt>Deviance_repl2_ch2</dt><dd><p>sampled values of the deviance of data
replicated according to the chain 2 evaluated under the parameters
from chain 2</p>
</dd>  
</dl>



<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. and Komárková, L. (2013).
Clustering for multivariate continuous and discrete longitudinal data.
<em>The Annals of Applied Statistics</em>, <b>7</b>(1), 177&ndash;200.
</p>
<p>Komárek, A. and Komárková, L. (2014).
Capabilities of R package mixAK for clustering based on multivariate continuous and discrete longitudinal data.
<em>Journal of Statistical Software</em>, <b>59</b>(12), 1&ndash;38.
<a href="https://doi.org/10.18637/jss.v059.i12">doi:10.18637/jss.v059.i12</a>.
</p>
<p>Komárek, A., Hansen, B. E., Kuiper, E. M. M., van Buuren, H. R., and Lesaffre, E. (2010).
Discriminant analysis using a multivariate linear mixed model with a normal mixture in the random effects distribution.
<em>Statistics in Medicine</em>, <b>29</b>(30), 3267&ndash;3283.
</p>
<p>Plummer, M. (2008).
Penalized loss functions for Bayesian model comparison.
<em>Biostatistics</em>, <b>9</b>(3), 523&ndash;539.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See also additional material available in 
## YOUR_R_DIR/library/mixAK/doc/
## or YOUR_R_DIR/site-library/mixAK/doc/
## - files http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf,
##         PBCseq.R
## ==============================================
</code></pre>

<hr>
<h2 id='GLMM_MCMCdata'>
Data manipulation for the GLMM_MCMC function 
</h2><span id='topic+GLMM_MCMCdata'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_MCMCdata(y, dist, id, time, x, z, random.intercept)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_MCMCdata_+3A_y">y</code></td>
<td>
<p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.</p>
</td></tr>
<tr><td><code id="GLMM_MCMCdata_+3A_dist">dist</code></td>
<td>
<p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.</p>
</td></tr>
<tr><td><code id="GLMM_MCMCdata_+3A_id">id</code></td>
<td>
<p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.</p>
</td></tr>
<tr><td><code id="GLMM_MCMCdata_+3A_time">time</code></td>
<td>
<p>see <code><a href="#topic+GLMM_longitDA">GLMM_longitDA</a></code> function.</p>
</td></tr>  
<tr><td><code id="GLMM_MCMCdata_+3A_x">x</code></td>
<td>
<p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.</p>
</td></tr>
<tr><td><code id="GLMM_MCMCdata_+3A_z">z</code></td>
<td>
<p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.</p>
</td></tr>
<tr><td><code id="GLMM_MCMCdata_+3A_random.intercept">random.intercept</code></td>
<td>
<p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>worked out value of <code>y</code></p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>worked out value of <code>dist</code></p>
</td></tr>  
<tr><td><code>id</code></td>
<td>
<p>worked out value of <code>id</code></p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>worked out value of <code>time</code></p>
</td></tr>  
<tr><td><code>x</code></td>
<td>
<p>worked out value of <code>x</code></p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>worked out value of <code>z</code></p>
</td></tr>
<tr><td><code>random.intercept</code></td>
<td>
<p>worked out value of <code>random.intercept</code></p>
</td></tr>  
<tr><td><code>R</code></td>
<td>
<p>number of response variables</p>
</td></tr>
<tr><td><code>Rc</code></td>
<td>
<p>number of continuous response variables</p>
</td></tr>
<tr><td><code>Rd</code></td>
<td>
<p>number of discrete response variables</p>
</td></tr>  
<tr><td><code>ndist</code></td>
<td>
<p>numerical counterpart of 'dist' argument</p>
</td></tr>
<tr><td><code>xempty</code></td>
<td>
<p>logical vector of length R</p>
</td></tr>
<tr><td><code>zempty</code></td>
<td>
<p>logical vector of length R</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>numeric vector of length R</p>
</td></tr>  
<tr><td><code>q</code></td>
<td>
<p>numeric vector of length R</p>
</td></tr>
<tr><td><code>fixed.intercept</code></td>
<td>
<p>logical vector of length R</p>
</td></tr>
<tr><td><code>CrandomIntcpt</code></td>
<td>
<p>numerical counterpart of random.intercept</p>
</td></tr>
<tr><td><code>CfixedIntcpt</code></td>
<td>
<p>numerical counterpart of fixed.intercept</p>
</td></tr>
<tr><td><code>dimb</code></td>
<td>
<p>dimension of random effects (random intercepts included)</p>
</td></tr>
<tr><td><code>LTb</code></td>
<td>
<p>length of lower triangle of matrix dimb x dimb</p>
</td></tr>
<tr><td><code>naamLTb</code></td>
<td>
<p>names (indices) for elements of a lower triangle of matrix dimb x dimb</p>
</td></tr>  
<tr><td><code>lalpha</code></td>
<td>
<p>length of alpha vector (fixed intercepts included)</p>
</td></tr>
<tr><td><code>p_fi</code></td>
<td>
<p>numeric vector of length R</p>
</td></tr>
<tr><td><code>q_ri</code></td>
<td>
<p>numeric vector of length R</p>
</td></tr>
<tr><td><code>name.response</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='GLMM_MCMCifit'>
Initial (RE)ML fits for the GLMM_MCMC function
</h2><span id='topic+GLMM_MCMCifit'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
Besides initial (RE)ML fits, the function created variables
derived from the design matrices.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_MCMCifit(do.init, na.complete,
    y, dist, id, time, x, z, random.intercept,
    xempty, zempty, Rc, Rd, p, p_fi, q, q_ri, lalpha, dimb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_MCMCifit_+3A_do.init">do.init</code></td>
<td>
<p>logical value indicating whether initial (RE)ML fits
should be done</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_na.complete">na.complete</code></td>
<td>
<p>logical value. If <code>TRUE</code> then
the function removes rows containing NA's from <code>y</code>, <code>id</code>, <code>x</code>,
<code>z</code> whenever there is at least one missing value for arbitrary
response. If <code>FALSE</code> then the missing values are removed
response by response, i.e., different response variables may have
different numbers of observations.</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_y">y</code></td>
<td>
<p>see output element <code>y</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_dist">dist</code></td>
<td>
<p>see argument<code>dist</code> of <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_id">id</code></td>
<td>
<p>see output element <code>id</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_time">time</code></td>
<td>
<p>see argument <code>time</code> of <code>GLMM_longitClust</code></p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_x">x</code></td>
<td>
<p>see output element <code>x</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_z">z</code></td>
<td>
<p>see output element <code>z</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_random.intercept">random.intercept</code></td>
<td>
<p>see output element <code>random.intercept</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_xempty">xempty</code></td>
<td>
<p>see output element <code>xempty</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_zempty">zempty</code></td>
<td>
<p>see output element <code>zempty</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_rc">Rc</code></td>
<td>
<p>see output element <code>Rc</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_rd">Rd</code></td>
<td>
<p>see output element <code>Rd</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_p">p</code></td>
<td>
<p>see output element <code>p</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_p_fi">p_fi</code></td>
<td>
<p>see output element <code>p_fi</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_q">q</code></td>
<td>
<p>see output element <code>q</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_q_ri">q_ri</code></td>
<td>
<p>see output element <code>q_ri</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_lalpha">lalpha</code></td>
<td>
<p>see output element <code>lalpha</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCifit_+3A_dimb">dimb</code></td>
<td>
<p>see output element <code>dimb</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list with the following components (some of them not included if
<code>do.init</code> is <code>FALSE</code>):
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>a list of length R with observations really used in fitting process
(after removal of missing values)</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p>a list of length R with id's corresponding to Y</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>a vector <code>time</code> upon removal of missing values</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>a list resulting from the original argument x after removal of
observations with some missing information
additionaly, intercept column is added if fixed intercept included in the model</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>a list resulting from the original argument z after removal of
observations with some missing information
additionaly, intercept column is added if random intercept included in the model</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>number of subjects (grouped observations) in the original data (before removing NA's)</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a list of length R, each component is a vector or length I (may contain zeros
if some cluster disappears for particular response due to NA's)</p>
</td></tr>
<tr><td><code>Cn</code></td>
<td>
<p>vectorized n</p>
</td></tr>
<tr><td><code>sumCn</code></td>
<td>
<p>sum(Cn) = total number of observations</p>
</td></tr>
<tr><td><code>Cy_c</code></td>
<td>
<p>vector with continuous response to be passed to C++, equal to 0 if there is no continuous response</p>
</td></tr>
<tr><td><code>Cy_d</code></td>
<td>
<p>vector with discrete response to be passed to C++, equal to 0 if there is no discrete response</p>
</td></tr>
<tr><td><code>CX</code></td>
<td>
<p>vector containing X matrices (without ones for possible intercept)
to be passed to C++, equal to 0 if there are no X matrices</p>
</td></tr>
<tr><td><code>CZ</code></td>
<td>
<p>vector containing Z matrices (without ones for possible intercept)
to be passed to C++, equal to 0 if there are no Z matrices</p>
</td></tr>










<tr><td><code>iintcpt</code></td>
<td>
<p>data.frame(Est, SE) with estimated intercepts and their SE, R rows,
row equal to (0, 0) if there is no fixed intercept for particular response</p>
</td></tr>
<tr><td><code>ifixef</code></td>
<td>
<p>a list of length R, each component is equal to 0 if there are no fixed effects for particular response,
and is equal to data.frame(Est, SE) if there are fixed effects</p>
</td></tr>
<tr><td><code>isigma</code></td>
<td>
<p>vector of length R, equal to 0 for discrete response, equal to estimated residual
standard deviation for continuous response</p>
</td></tr>
<tr><td><code>iEranef</code></td>
<td>
<p>a list of length R, each component is equal to 0 if there are no random effects for particular response,
and is equal to data.frame(Est, SE) with estimated means of the random effects
and their std. errors if there are random effects</p>
</td></tr>
<tr><td><code>iSDranef</code></td>
<td>
<p>a list of length R, each component is equal to 0 if there are no random effects for particular response,
and is equal to a vector with estimated standard deviations of the random effects if there are random effects</p>
</td></tr>
<tr><td><code>ib</code></td>
<td>
<p>a list of length R, each component is equal to 0 if there are no random effects for particular response,
and a matrix with EB estimates of random effects shifted by their estimated mean if there are random effects</p>
</td></tr>
<tr><td><code>is.intcpt</code></td>
<td>
<p>logical vector of length R</p>
</td></tr>
<tr><td><code>is.fixef</code></td>
<td>
<p>logical vector of length R</p>
</td></tr>
<tr><td><code>is.ranef</code></td>
<td>
<p>logical vector of length R</p>
</td></tr>  
<tr><td><code>is.sigma</code></td>
<td>
<p>logical vector of length R</p>
</td></tr>
<tr><td><code>ibMat</code></td>
<td>
<p>matrix with initial values of random effects (EB
estimates from (RE)ML fits)</p>
</td></tr>
<tr><td><code>ibMat2</code></td>
<td>
<p>matrix with alternative initial values of random effects</p>
</td></tr>  
<tr><td><code>iEranefVec</code></td>
<td>
<p>vector with estimated means of random effects</p>
</td></tr>
<tr><td><code>iSDranefVec</code></td>
<td>
<p>vector with estimated standard deviations of random
effects</p>
</td></tr>
<tr><td><code>iSEranefVec</code></td>
<td>
<p>vector with standard errors of estimated means of
random effects</p>
</td></tr>  
<tr><td><code>ialpha</code></td>
<td>
<p>vector with initial values of alpha's (including fixed
intercepts)</p>
</td></tr>
<tr><td><code>ialpha2</code></td>
<td>
<p>vector with alternative initial values of alpha's (including fixed
intercepts)</p>
</td></tr>  
<tr><td><code>iSEalpha</code></td>
<td>
<p>vector with standard errors of estimated values of
fixed effects</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='GLMM_MCMCinit.alpha'>
Handle init.alpha or init2.alpha argument of GLMM_MCMC function
</h2><span id='topic+GLMM_MCMCinit.alpha'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_MCMCinit.alpha(init.alpha, lalpha, ialpha, number="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_MCMCinit.alpha_+3A_init.alpha">init.alpha</code></td>
<td>
<p>see argument <code>init.alpha</code> or <code>init2.alpha</code> of
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.alpha_+3A_lalpha">lalpha</code></td>
<td>
<p>see output element <code>lalpha</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.alpha_+3A_ialpha">ialpha</code></td>
<td>
<p>a numeric vector of initial values of fixed effects.
See output element <code>ialpha</code> of <code><a href="#topic+GLMM_MCMCifit">GLMM_MCMCifit</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.alpha_+3A_number">number</code></td>
<td>
<p>label of the initial values (used only in error messages)</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list with the same structure as complete <code>init.alpha</code> argument
of the <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='GLMM_MCMCinit.b'>
Handle init.b or init2.b argument of GLMM_MCMC function
</h2><span id='topic+GLMM_MCMCinit.b'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_MCMCinit.b(init.b, prior.b, scale.b,
                id, dimb, LTb, naamLTb,
                I, ibMat, iEranefVec, iSDranefVec, number="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_MCMCinit.b_+3A_init.b">init.b</code></td>
<td>
<p>see argument <code>init.b</code> or <code>init2.b</code> of
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.b_+3A_prior.b">prior.b</code></td>
<td>
<p>see argument <code>prior.b</code> of <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.b_+3A_scale.b">scale.b</code></td>
<td>
<p>see argument <code>scale.b</code> of <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.b_+3A_id">id</code></td>
<td>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.b_+3A_dimb">dimb</code></td>
<td>
<p>dimension of random effects (random intercepts included)</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.b_+3A_ltb">LTb</code></td>
<td>
<p>length of lower triangle of matrix dimb x dimb</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.b_+3A_naamltb">naamLTb</code></td>
<td>
<p>names (indices) for elements of a lower triangle of matrix dimb x dimb</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.b_+3A_i">I</code></td>
<td>
<p>number of subjects (grouped observations) in the original data (before removing NA's)</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.b_+3A_ibmat">ibMat</code></td>
<td>
<p>matrix with initial values of random effects</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.b_+3A_ieranefvec">iEranefVec</code></td>
<td>
<p>vector with initial values of overall means of
random effects</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.b_+3A_isdranefvec">iSDranefVec</code></td>
<td>
<p>vector with initial values of overall standard
deviations of random effects</p>
</td></tr>  
<tr><td><code id="GLMM_MCMCinit.b_+3A_number">number</code></td>
<td>
<p>label of the initial values (used only in error messages)</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list with the same structure as complete <code>init.b</code> argument
of the <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='GLMM_MCMCinit.eps'>
Handle init.eps or init2.eps argument of GLMM_MCMC function
</h2><span id='topic+GLMM_MCMCinit.eps'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_MCMCinit.eps(init.eps, prior.eps, Rc, isigma, number="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_MCMCinit.eps_+3A_init.eps">init.eps</code></td>
<td>
<p>see argument <code>init.eps</code> or <code>init2.eps</code> of <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.eps_+3A_prior.eps">prior.eps</code></td>
<td>
<p>see argument <code>prior.eps</code> of <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function</p>
</td></tr>  
<tr><td><code id="GLMM_MCMCinit.eps_+3A_rc">Rc</code></td>
<td>
<p>see output element <code>Rc</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code> function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.eps_+3A_isigma">isigma</code></td>
<td>
<p>a numeric vector of length <code>Rc</code> with initial values of residual standard deviations.</p>
</td></tr>
<tr><td><code id="GLMM_MCMCinit.eps_+3A_number">number</code></td>
<td>
<p>label of the initial values (used only in error messages)</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list with the same structure as complete <code>init.eps</code> argument
of the <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='GLMM_MCMCprior.alpha'>
Handle prior.alpha argument of GLMM_MCMC function
</h2><span id='topic+GLMM_MCMCprior.alpha'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_MCMCprior.alpha(prior.alpha, lalpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_MCMCprior.alpha_+3A_prior.alpha">prior.alpha</code></td>
<td>
<p>see argument <code>prior.alpha</code> of
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCprior.alpha_+3A_lalpha">lalpha</code></td>
<td>
<p>see output element <code>lalpha</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>prior.alpha</code></td>
<td>
<p>value of <code>prior.alpha</code> with added default values
where necessary</p>
</td></tr>
<tr><td><code>CpriorDouble_alpha</code></td>
<td>
<p>a numeric vector to be passed to C++</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='GLMM_MCMCprior.b'>
Handle prior.eps argument of GLMM_MCMC function
</h2><span id='topic+GLMM_MCMCprior.b'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_MCMCprior.b(prior.b, scale.b, dimb, iEranefVec, iSDranefVec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_MCMCprior.b_+3A_prior.b">prior.b</code></td>
<td>
<p>see argument<code>prior.b</code> of
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCprior.b_+3A_scale.b">scale.b</code></td>
<td>
<p>see argument<code>scale.b</code> of
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCprior.b_+3A_dimb">dimb</code></td>
<td>
<p>see output element <code>dimb</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCprior.b_+3A_ieranefvec">iEranefVec</code></td>
<td>
<p>see output element <code>iEranefVec</code> of <code><a href="#topic+GLMM_MCMCifit">GLMM_MCMCifit</a></code>
function. Defaults to a vector of zeros if missing</p>
</td></tr>
<tr><td><code id="GLMM_MCMCprior.b_+3A_isdranefvec">iSDranefVec</code></td>
<td>
<p>see output element <code>iSDranefVec</code> of <code><a href="#topic+GLMM_MCMCifit">GLMM_MCMCifit</a></code>
function. Defaults to a vector of ones if missing</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>prior.b</code></td>
<td>
<p>value of <code>prior.b</code> with added default values
where necessary</p>
</td></tr>
<tr><td><code>CpriorInt_b</code></td>
<td>
<p>a numeric vector to be passed to C++</p>
</td></tr>  
<tr><td><code>CpriorDouble_b</code></td>
<td>
<p>a numeric vector to be passed to C++</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='GLMM_MCMCprior.eps'>
Handle prior.eps argument of GLMM_MCMC function
</h2><span id='topic+GLMM_MCMCprior.eps'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_MCMCprior.eps(prior.eps, Rc, isigma, is.sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_MCMCprior.eps_+3A_prior.eps">prior.eps</code></td>
<td>
<p>see argument<code>prior.eps</code> of
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCprior.eps_+3A_rc">Rc</code></td>
<td>
<p>see output element <code>Rc</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCprior.eps_+3A_isigma">isigma</code></td>
<td>
<p>see output element <code>isigma</code> of <code><a href="#topic+GLMM_MCMCifit">GLMM_MCMCifit</a></code>
function. It is used to determine a default value of <code>prior.eps$h</code>.
Defaults to a vector of ones if missing</p>
</td></tr>
<tr><td><code id="GLMM_MCMCprior.eps_+3A_is.sigma">is.sigma</code></td>
<td>
<p>see output element <code>is.sigma</code> of <code><a href="#topic+GLMM_MCMCifit">GLMM_MCMCifit</a></code>
function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>prior.eps</code></td>
<td>
<p>value of <code>prior.eps</code> with added default values
where necessary</p>
</td></tr>
<tr><td><code>CpriorDouble_eps</code></td>
<td>
<p>a numeric vector to be passed to C++</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='GLMM_MCMCscale.b'>
Handle scale.b argument of GLMM_MCMC function
</h2><span id='topic+GLMM_MCMCscale.b'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_MCMCscale.b(scale.b, dimb, iEranefVec, iSDranefVec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_MCMCscale.b_+3A_scale.b">scale.b</code></td>
<td>
<p>see argument<code>prior.eps</code> of
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCscale.b_+3A_dimb">dimb</code></td>
<td>
<p>see output element <code>dimb</code> of <code><a href="#topic+GLMM_MCMCdata">GLMM_MCMCdata</a></code>
function</p>
</td></tr>
<tr><td><code id="GLMM_MCMCscale.b_+3A_ieranefvec">iEranefVec</code></td>
<td>
<p>see output element <code>iEranefVec</code> of <code><a href="#topic+GLMM_MCMCifit">GLMM_MCMCifit</a></code>
function. It is used to determine a default value of <code>scale.b$shift</code>.
Defaults to a vector of zeros if missing</p>
</td></tr>
<tr><td><code id="GLMM_MCMCscale.b_+3A_isdranefvec">iSDranefVec</code></td>
<td>
<p>see output element <code>iSDranefVec</code> of <code><a href="#topic+GLMM_MCMCifit">GLMM_MCMCifit</a></code>
function. It is used to determine a default value of <code>scale.b$scale</code>.
Defaults to a vector of ones if missing</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Value of <code>scale.b</code> with added default values where necessary.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='GLMM_MCMCwrapper'>
Wrapper to the GLMM_MCMC main simulation.
</h2><span id='topic+GLMM_MCMCwrapper'></span>

<h3>Description</h3>

<p>This is wrapper to the GLMM_MCMC main simulation which allows
vectorized evaluation and possibly parallel computation.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLMM_MCMCwrapper(chain = 1, data,
     prior.alpha, init.alpha,
     scale.b, prior.b, init.b,
     prior.eps, init.eps,
     Cpar, nMCMC, store, keep.chains,
     silent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLMM_MCMCwrapper_+3A_chain">chain</code></td>
<td>
<p>identification of the chain sampled in a particular call
of this function, usually number like 1, 2, ...</p>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_data">data</code></td>
<td>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_prior.alpha">prior.alpha</code></td>
<td>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_init.alpha">init.alpha</code></td>
<td>
<p>a list of <code>init.alpha</code> objects for all chains</p>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_scale.b">scale.b</code></td>
<td>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_prior.b">prior.b</code></td>
<td>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_init.b">init.b</code></td>
<td>
<p>a list of <code>init.b</code> objects for all chains</p>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_prior.eps">prior.eps</code></td>
<td>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_init.eps">init.eps</code></td>
<td>
<p>a list of <code>init.eps</code> objects for all chains</p>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_cpar">Cpar</code></td>
<td>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_nmcmc">nMCMC</code></td>
<td>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_store">store</code></td>
<td>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_keep.chains">keep.chains</code></td>
<td>
</td></tr>
<tr><td><code id="GLMM_MCMCwrapper_+3A_silent">silent</code></td>
<td>
</td></tr>        
</table>


<h3>Value</h3>

<p>A list having almost the same components as object returned by
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='MatMPpinv'>
Moore-Penrose pseudoinverse of a squared matrix
</h2><span id='topic+MatMPpinv'></span><span id='topic+C_MPpinvSP'></span>

<h3>Description</h3>

<p>For a matrix <code class="reqn">\boldsymbol{A}</code> its Moore-Penrose pseudoinverse is such a matrix
<code class="reqn">\boldsymbol{A}^+</code> which satisfies
</p>

<table>
<tr>
 <td style="text-align: left;">
    (i) <code class="reqn">\boldsymbol{A}\boldsymbol{A}^+\boldsymbol{A} = \boldsymbol{A}</code>,  </td>
</tr>
<tr>
 <td style="text-align: left;">
    (ii) <code class="reqn">\boldsymbol{A}^+\boldsymbol{A}\boldsymbol{A}^+ = \boldsymbol{A}^+</code>,  </td>
</tr>
<tr>
 <td style="text-align: left;">
    (iii) <code class="reqn">(\boldsymbol{A}\boldsymbol{A}^+)' = \boldsymbol{A}\boldsymbol{A}^+</code>,  </td>
</tr>
<tr>
 <td style="text-align: left;">
    (iv) <code class="reqn">(\boldsymbol{A}^+\boldsymbol{A}) = \boldsymbol{A}^+\boldsymbol{A}</code>.  </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>
  
<p>Computation is done using spectral decomposition. At this moment, it
is implemented for symmetric matrices only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  MatMPpinv(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatMPpinv_+3A_a">A</code></td>
<td>
<p>either a numeric vector in which case inverse of each
element of A is returned or a squared matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a numeric vector or a matrix.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Golub, G. H. and Van Loan, C. F. (1996, Sec. 5.5).
<em>Matrix Computations. Third Edition</em>.
Baltimore: The Johns Hopkins University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(770328)
A &lt;- rWISHART(1, 5, diag(4))
Ainv &lt;- MatMPpinv(A)

### Check the conditions
prec &lt;- 13
round(A - A %*% Ainv %*% A, prec)
round(Ainv - Ainv %*% A %*% Ainv, prec)
round(A %*% Ainv - t(A %*% Ainv), prec)
round(Ainv %*% A - t(Ainv %*% A), prec)
</code></pre>

<hr>
<h2 id='MatSqrt'>
Square root of a matrix
</h2><span id='topic+MatSqrt'></span><span id='topic+C_sqrtGE'></span>

<h3>Description</h3>

<p>For a matrix <code class="reqn">\boldsymbol{A}</code> its square root is such a matrix
<code class="reqn">\boldsymbol{B}</code> which satisfies <code class="reqn">\boldsymbol{A} =
    \boldsymbol{B}\boldsymbol{B}</code>.
</p>
<p>Computation is done using spectral decomposition. When calculating the
square roots of eigenvalues, always a root with positive real part
and a sign of the imaginary part the same as the sign of the imaginary
eigenvalue part is taken.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  MatSqrt(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatSqrt_+3A_a">A</code></td>
<td>
<p>either a numeric vector in which case square roots of each
element of A is returned or a squared matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a numeric vector or a matrix.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MatSqrt(0:4)
MatSqrt((-4):0)
MatSqrt(c(-1, 1, -2, 2))

A &lt;- (1:4) %*% t(1:4)
sqrtA &lt;- MatSqrt(A)
sqrtA
round(sqrtA %*% sqrtA - A, 13)

### The following example crashes on r-devel Windows x64 x86_64,
### on r-patched Linux x86_64 
### due to failure of LAPACK zgesv routine
###
### Commented on 16/01/2010
###
# B &lt;- -A
# sqrtB &lt;- MatSqrt(B)
# sqrtB
# round(Re(sqrtB %*% sqrtB - B), 13)
# round(Im(sqrtB %*% sqrtB - B), 13)

V &lt;- eigen(A)$vectors
sqrtV &lt;- MatSqrt(V)
sqrtV
round(sqrtV %*% sqrtV - V, 14)

Sigma &lt;- matrix(c(1, 1, 1.5,  1, 4, 4.2,  1.5, 4.2, 9), nrow=3)
sqrtSigma &lt;- MatSqrt(Sigma)
sqrtSigma
round(sqrtSigma %*% sqrtSigma - Sigma, 13)

D4 &lt;- matrix(c(5, -4,  1,  0,  0,
              -4,  6, -4,  1,  0,
               1, -4,  6, -4,  1,
               0,  1, -4,  6, -4,
               0,  0,  1, -4,  5), nrow=5)
sqrtD4 &lt;- MatSqrt(D4)
sqrtD4[abs(sqrtD4) &lt; 1e-15] &lt;- 0
sqrtD4
round(sqrtD4 %*% sqrtD4 - D4, 14)

X &lt;- matrix(c(7, 15, 10, 22), nrow=2)
sqrtX &lt;- MatSqrt(X)
sqrtX %*% sqrtX - X
</code></pre>

<hr>
<h2 id='MVN'>
Multivariate normal distribution
</h2><span id='topic+MVN'></span><span id='topic+dMVN'></span><span id='topic+rMVN'></span><span id='topic+rcMVN'></span><span id='topic+C_dMVN1_R'></span><span id='topic+C_rMVN1_R'></span><span id='topic+C_rMVN2_R'></span>

<h3>Description</h3>

<p>Density and random generation for the multivariate normal distribution
with mean equal to <code>mean</code>, precision matrix equal to <code>Q</code> (or covariance
matrix equal to <code>Sigma</code>).
</p>
<p>Function <code>rcMVN</code> samples from the multivariate normal
distribution with a canonical mean <code class="reqn">b</code>, i.e., the mean is
<code class="reqn">\mu = Q^{-1}\,b.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dMVN(x, mean=0, Q=1, Sigma, log=FALSE)

rMVN(n, mean=0, Q=1, Sigma)

rcMVN(n, b=0, Q=1, Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVN_+3A_mean">mean</code></td>
<td>
<p>vector of mean.</p>
</td></tr>
<tr><td><code id="MVN_+3A_b">b</code></td>
<td>
<p>vector of a canonical mean.</p>
</td></tr>
<tr><td><code id="MVN_+3A_q">Q</code></td>
<td>
<p>precision matrix of the multivariate normal
distribution. Ignored if <code>Sigma</code> is given.</p>
</td></tr>
<tr><td><code id="MVN_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of the multivariate normal
distribution. If <code>Sigma</code> is supplied, precision
is computed from <code class="reqn">\Sigma</code> as
<code class="reqn">Q = \Sigma^{-1}</code>.</p>
</td></tr>
<tr><td><code id="MVN_+3A_n">n</code></td>
<td>
<p>number of observations to be sampled.</p>
</td></tr>
<tr><td><code id="MVN_+3A_x">x</code></td>
<td>
<p>vector or matrix of the points where the density should be
evaluated.</p>
</td></tr>
<tr><td><code id="MVN_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, log-density is computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Some objects.
</p>


<h3>Value for dMVN</h3>

<p>A vector with evaluated values of the (log-)density
</p>


<h3>Value for rMVN</h3>

<p>A list with the components:
</p>

<dl>
<dt>x</dt><dd><p>vector or matrix with sampled values</p>
</dd>
<dt>log.dens</dt><dd><p>vector with the values of the log-density evaluated
in the sampled values</p>
</dd>
</dl>



<h3>Value for rcMVN</h3>

<p>A list with the components:
</p>

<dl>
<dt>x</dt><dd><p>vector or matrix with sampled values</p>
</dd>
<dt>mean</dt><dd><p>vector or the mean of the normal distribution</p>
</dd>    
<dt>log.dens</dt><dd><p>vector with the values of the log-density evaluated
in the sampled values</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Rue, H. and Held, L. (2005).
<em>Gaussian Markov Random Fields: Theory and Applications</em>.
Boca Raton: Chapman and Hall/CRC.  
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnorm">dnorm</a></code>, <code><a href="mvtnorm.html#topic+Mvnorm">Mvnorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1977)

### Univariate normal distribution
### ==============================
c(dMVN(0), dnorm(0))
c(dMVN(0, log=TRUE), dnorm(0, log=TRUE))

rbind(dMVN(c(-1, 0, 1)), dnorm(c(-1, 0, 1)))
rbind(dMVN(c(-1, 0, 1), log=TRUE), dnorm(c(-1, 0, 1), log=TRUE))

c(dMVN(1, mean=1.2, Q=0.5), dnorm(1, mean=1.2, sd=sqrt(2)))
c(dMVN(1, mean=1.2, Q=0.5, log=TRUE), dnorm(1, mean=1.2, sd=sqrt(2), log=TRUE))

rbind(dMVN(0:2, mean=1.2, Q=0.5), dnorm(0:2, mean=1.2, sd=sqrt(2)))
rbind(dMVN(0:2, mean=1.2, Q=0.5, log=TRUE), dnorm(0:2, mean=1.2, sd=sqrt(2), log=TRUE))

### Multivariate normal distribution
### ================================
mu &lt;- c(0, 6, 8)
L &lt;- matrix(1:9, nrow=3)
L[upper.tri(L, diag=FALSE)] &lt;- 0
Sigma &lt;- L %*% t(L)
Q &lt;- chol2inv(chol(Sigma))
b &lt;- solve(Sigma, mu)

dMVN(mu, mean=mu, Q=Q)
dMVN(mu, mean=mu, Sigma=Sigma)
dMVN(mu, mean=mu, Q=Q, log=TRUE)
dMVN(mu, mean=mu, Sigma=Sigma, log=TRUE)

xx &lt;- matrix(c(0,6,8, 1,5,7, -0.5,5.5,8.5, 0.5,6.5,7.5), ncol=3, byrow=TRUE)
dMVN(xx, mean=mu, Q=Q)
dMVN(xx, mean=mu, Sigma=Sigma)
dMVN(xx, mean=mu, Q=Q, log=TRUE)
dMVN(xx, mean=mu, Sigma=Sigma, log=TRUE)

zz &lt;- rMVN(1000, mean=mu, Sigma=Sigma)
rbind(apply(zz$x, 2, mean), mu)
var(zz$x)
Sigma
cbind(dMVN(zz$x, mean=mu, Sigma=Sigma, log=TRUE), zz$log.dens)[1:10,]

zz &lt;- rcMVN(1000, b=b, Sigma=Sigma)
rbind(apply(zz$x, 2, mean), mu)
var(zz$x)
Sigma
cbind(dMVN(zz$x, mean=mu, Sigma=Sigma, log=TRUE), zz$log.dens)[1:10,]

zz &lt;- rMVN(1000, mean=rep(0, 3), Sigma=Sigma)
rbind(apply(zz$x, 2, mean), rep(0, 3))
var(zz$x)
Sigma
cbind(dMVN(zz$x, mean=rep(0, 3), Sigma=Sigma, log=TRUE), zz$log.dens)[1:10,]


### The same using the package mvtnorm
### ==================================
# require(mvtnorm)
# c(dMVN(mu, mean=mu, Sigma=Sigma), dmvnorm(mu, mean=mu, sigma=Sigma))
# c(dMVN(mu, mean=mu, Sigma=Sigma, log=TRUE), dmvnorm(mu, mean=mu, sigma=Sigma, log=TRUE))
#
# rbind(dMVN(xx, mean=mu, Sigma=Sigma), dmvnorm(xx, mean=mu, sigma=Sigma))
# rbind(dMVN(xx, mean=mu, Sigma=Sigma, log=TRUE), dmvnorm(xx, mean=mu, sigma=Sigma, log=TRUE))
</code></pre>

<hr>
<h2 id='MVNmixture'>
Mixture of (multivariate) normal distributions
</h2><span id='topic+MVNmixture'></span><span id='topic+dMVNmixture'></span><span id='topic+dMVNmixture2'></span><span id='topic+rMVNmixture'></span><span id='topic+rMVNmixture2'></span><span id='topic+C_dmixMVN_R'></span><span id='topic+C_dmixNorm_R'></span><span id='topic+C_rmixMVN_R'></span><span id='topic+C_rmixNorm_R'></span>

<h3>Description</h3>

<p>Density and random generation for the mixture of the <code class="reqn">p</code>-variate normal distributions
with means given by <code>mean</code>, precision matrix given by <code>Q</code> (or covariance
matrices given by<code>Sigma</code>).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dMVNmixture(x, weight, mean, Q, Sigma, log=FALSE)

dMVNmixture2(x, weight, mean, Q, Sigma, log=FALSE)

rMVNmixture(n, weight, mean, Q, Sigma)

rMVNmixture2(n, weight, mean, Q, Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVNmixture_+3A_weight">weight</code></td>
<td>
<p>vector of length <code class="reqn">K</code> with the mixture weights or
values which are proportional to the weights.</p>
</td></tr>
<tr><td><code id="MVNmixture_+3A_mean">mean</code></td>
<td>
<p>vector or matrix of mixture means.
</p>
<p>For <code class="reqn">p=1</code> this
should be a vector of length <code class="reqn">K</code>, for <code class="reqn">p&gt;1</code> this should be a
<code class="reqn">K\times p</code> matrix with mixture means in rows.
</p>
</td></tr>
<tr><td><code id="MVNmixture_+3A_q">Q</code></td>
<td>
<p>precision matrices of the multivariate normal
distribution. Ignored if <code>Sigma</code> is given.
</p>
<p>For <code class="reqn">p=1</code> this should be a vector of length <code class="reqn">K</code>, for <code class="reqn">p
      &gt; 1</code> this should be a list of length <code class="reqn">K</code> with the mixture
precision matrices as components of the list.
</p>
</td></tr>
<tr><td><code id="MVNmixture_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of the multivariate normal
distribution. If <code>Sigma</code> is supplied, precisions
are computed from <code class="reqn">\Sigma</code> as
<code class="reqn">Q = \Sigma^{-1}</code>.
</p>
<p>For <code class="reqn">p=1</code> this should be a vector of length <code class="reqn">K</code>, for <code class="reqn">p
      &gt; 1</code> this should be a list of length <code class="reqn">K</code> with the mixture
covariance matrices as components of the list.
</p>
</td></tr>
<tr><td><code id="MVNmixture_+3A_n">n</code></td>
<td>
<p>number of observations to be sampled.</p>
</td></tr>
<tr><td><code id="MVNmixture_+3A_x">x</code></td>
<td>
<p>vector or matrix of the points where the density should be
evaluated.</p>
</td></tr>
<tr><td><code id="MVNmixture_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, log-density is computed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>dMVNmixture</code> and <code>dMVNmixture2</code> differ only
internally in the way they compute the mixture density. In
<code>dMVNmixture</code>, only multivariate normal densities are evaluated
in compiled C++ code and mixing is done directly in R. In
<code>dMVNmixture2</code>, everything is evaluated in compiled C++
code. Normally, both <code>dMVNmixture</code> and <code>dMVNmixture2</code> should
return the same results.
</p>
<p>Similarly for <code>rMVNmixture</code> and <code>rMVNmixture2</code>. Another
difference is that <code>rMVNmixture</code> returns only random generated
points and <code>rMVNmixture2</code> also values of the density evaluated in
the generated points.
</p>


<h3>Value</h3>

<p>Some objects.
</p>


<h3>Value for dMVNmixture</h3>

<p>A vector with evaluated values of the (log-)density.
</p>


<h3>Value for dMVNmixture2</h3>

<p>A vector with evaluated values of the (log-)density.
</p>


<h3>Value for rMVNmixture</h3>

<p>A vector (for <code>n=1</code> or for univariate mixture)
or matrix with sampled values (in rows of the matrix).
</p>


<h3>Value for rMVNmixture2</h3>

<p>A list with components named <code>x</code> which is 
a vector (for <code>n=1</code> or for univariate mixture)
or matrix with sampled values (in rows of the matrix)
and <code>dens</code> which are the values of the density evaluated in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnorm">dnorm</a></code>, <code><a href="#topic+MVN">MVN</a></code>, <code><a href="mvtnorm.html#topic+Mvnorm">Mvnorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1977)

##### Univariate normal mixture
##### =========================
mu &lt;- c(-1, 1)
Sigma &lt;- c(0.25^2, 0.4^2)
Q &lt;- 1/Sigma
w &lt;- c(0.3, 0.7)

xx &lt;- seq(-2, 2.5, length=100)
yyA &lt;- dMVNmixture(xx, weight=w, mean=mu, Sigma=Sigma)
yyB &lt;- dMVNmixture(xx, weight=w, mean=mu, Q=Q)
yyC &lt;- dMVNmixture2(xx, weight=w, mean=mu, Sigma=Sigma)
yyD &lt;- dMVNmixture2(xx, weight=w, mean=mu, Q=Q)

xxSample &lt;- rMVNmixture(1000, weight=w, mean=mu, Sigma=Sigma)
xxSample2 &lt;- rMVNmixture2(1000, weight=w, mean=mu, Sigma=Sigma)

sum(abs(xxSample2$dens - dMVNmixture(xxSample2$x, weight=w, mean=mu, Sigma=Sigma)) &gt; 1e-15)
xxSample2 &lt;- xxSample2$x

par(mfrow=c(2, 2), bty="n")
plot(xx, yyA, type="l", col="red", xlab="x", ylab="f(x)")
points(xx, yyB, col="darkblue")
hist(xxSample, col="lightblue", prob=TRUE, xlab="x", xlim=range(xx), ylim=c(0, max(yyA)),
     main="Sampled values")
lines(xx, yyA, col="red")
plot(xx, yyC, type="l", col="red", xlab="x", ylab="f(x)")
points(xx, yyD, col="darkblue")
hist(xxSample2, col="sandybrown", prob=TRUE, xlab="x", xlim=range(xx), ylim=c(0, max(yyA)),
     main="Sampled values")
lines(xx, yyC, col="red")


##### Bivariate normal mixture
##### ========================
### Choice 1
sd11 &lt;- sd12 &lt;- 1.1
sd21 &lt;- 0.5
sd22 &lt;- 1.5
rho2 &lt;- 0.7
Xlim &lt;- c(-3, 4)
Ylim &lt;- c(-6, 4)

### Choice 2
sd11 &lt;- sd12 &lt;- 0.3
sd21 &lt;- 0.5
sd22 &lt;- 0.3
rho2 &lt;- 0.8
Xlim &lt;- c(-3, 2.5)
Ylim &lt;- c(-2.5, 2.5)

mu &lt;- matrix(c(1,1, -1,-1), nrow=2, byrow=TRUE)
Sigma &lt;- list(diag(c(sd11^2, sd12^2)),
              matrix(c(sd21^2, rho2*sd21*sd22, rho2*sd21*sd22, sd22^2), nrow=2))
Q &lt;- list(chol2inv(chol(Sigma[[1]])), chol2inv(chol(Sigma[[2]])))
w &lt;- c(0.3, 0.7)

xx1 &lt;- seq(mu[2,1]-3*sd21, mu[1,1]+3*sd11, length=100)
xx2 &lt;- seq(mu[2,2]-3*sd22, mu[1,2]+3*sd12, length=90)
XX &lt;- cbind(rep(xx1, length(xx2)), rep(xx2, each=length(xx1)))
yyA &lt;- matrix(dMVNmixture(XX, weight=w, mean=mu, Sigma=Sigma), nrow=length(xx1), ncol=length(xx2))
yyB &lt;- matrix(dMVNmixture(XX, weight=w, mean=mu, Q=Q), nrow=length(xx1), ncol=length(xx2))
yyC &lt;- matrix(dMVNmixture2(XX, weight=w, mean=mu, Sigma=Sigma), nrow=length(xx1), ncol=length(xx2))
yyD &lt;- matrix(dMVNmixture2(XX, weight=w, mean=mu, Q=Q), nrow=length(xx1), ncol=length(xx2))

#xxSample &lt;- rMVNmixture(1000, weight=w, mean=mu, Sigma=Sigma)
### Starting from version 3.6, the above command led to SegFault
### on CRAN r-patched-solaris-sparc check.
### Commented here on 20140806 (version 3.6-1).
xxSample2 &lt;- rMVNmixture2(1000, weight=w, mean=mu, Sigma=Sigma)

sum(abs(xxSample2$dens - dMVNmixture(xxSample2$x, weight=w, mean=mu, Sigma=Sigma)) &gt; 1e-15)
xxSample2 &lt;- xxSample2$x

par(mfrow=c(1, 2), bty="n")
plot(xxSample, col="darkblue", xlab="x1", ylab="x2", xlim=Xlim, ylim=Ylim)
contour(xx1, xx2, yyA, col="red", add=TRUE)
plot(xxSample2, col="darkblue", xlab="x1", ylab="x2", xlim=Xlim, ylim=Ylim)
contour(xx1, xx2, yyC, col="red", add=TRUE)

par(mfrow=c(2, 2), bty="n")
contour(xx1, xx2, yyA, col="red", xlab="x1", ylab="x2")
points(mu[,1], mu[,2], col="darkgreen")
persp(xx1, xx2, yyA, col="lightblue", xlab="x1", ylab="x2", zlab="f(x1, x2)")
contour(xx1, xx2, yyB, col="red", xlab="x1", ylab="x2")
points(mu[,1], mu[,2], col="darkgreen")
persp(xx1, xx2, yyB, col="lightblue", xlab="x1", ylab="x2", zlab="f(x1, x2)", phi=30, theta=30)

par(mfrow=c(2, 2), bty="n")
contour(xx1, xx2, yyC, col="red", xlab="x1", ylab="x2")
points(mu[,1], mu[,2], col="darkgreen")
persp(xx1, xx2, yyC, col="lightblue", xlab="x1", ylab="x2", zlab="f(x1, x2)")
contour(xx1, xx2, yyD, col="red", xlab="x1", ylab="x2")
points(mu[,1], mu[,2], col="darkgreen")
persp(xx1, xx2, yyD, col="lightblue", xlab="x1", ylab="x2", zlab="f(x1, x2)", phi=30, theta=30)
</code></pre>

<hr>
<h2 id='MVT'>
Multivariate Student t distribution
</h2><span id='topic+MVT'></span><span id='topic+dMVT'></span><span id='topic+rMVT'></span><span id='topic+C_rMVT1_R'></span><span id='topic+C_dMVT1_R'></span><span id='topic+C_deriv_ldMVT_x'></span>

<h3>Description</h3>

<p>Density and random generation for the multivariate Student t distribution
with location equal to <code>mu</code>, precision matrix equal to <code>Q</code> (or scale
matrix equal to <code>Sigma</code>).
</p>
<p>Mentioned functions implement the multivariate Student t distribution
with a density given by
</p>
<p style="text-align: center;"><code class="reqn">%
    p(\boldsymbol{z}) = 
      \frac{\Gamma\bigl(\frac{\nu+p}{2}\bigr)}{\Gamma\bigl(\frac{\nu}{2}\bigr)\,\nu^{\frac{p}{2}}\,\pi^{\frac{p}{2}}}\,
      \bigl|\Sigma\bigr|^{-\frac{1}{2}}\,
      \Bigl\{1 + \frac{(\boldsymbol{z} -
	\boldsymbol{\mu})'\Sigma^{-1}(\boldsymbol{z} -
	\boldsymbol{\mu})}{\nu}\Bigr\}^{-\frac{\nu+p}{2}},        
  </code>
</p>
  
<p>where <code class="reqn">p</code> is the dimension, <code class="reqn">\nu &gt; 0</code> degrees of
freedom, <code class="reqn">\boldsymbol{\mu}</code> the location parameter and
<code class="reqn">\Sigma</code> the scale matrix.
</p>
<p>For <code class="reqn">\nu &gt; 1</code>, the mean in equal to
<code class="reqn">\boldsymbol{\mu}</code>,
for <code class="reqn">\nu &gt; 2</code>, the covariance matrix is equal to
<code class="reqn">\frac{\nu}{\nu - 2}\Sigma</code>.        
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dMVT(x, df, mu=0, Q=1, Sigma, log=FALSE)

rMVT(n, df, mu=0, Q=1, Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVT_+3A_df">df</code></td>
<td>
<p>degrees of freedom of the multivariate Student t distribution.</p>
</td></tr>
<tr><td><code id="MVT_+3A_mu">mu</code></td>
<td>
<p>vector of the location parameter.</p>
</td></tr>
<tr><td><code id="MVT_+3A_q">Q</code></td>
<td>
<p>precision (inverted scale) matrix of the multivariate Student
t distribution. Ignored if <code>Sigma</code> is given.</p>
</td></tr>
<tr><td><code id="MVT_+3A_sigma">Sigma</code></td>
<td>
<p>scale matrix of the multivariate Student t
distribution. If <code>Sigma</code> is supplied, precision
is computed from <code class="reqn">\Sigma</code> as
<code class="reqn">Q = \Sigma^{-1}</code>.</p>
</td></tr>
<tr><td><code id="MVT_+3A_n">n</code></td>
<td>
<p>number of observations to be sampled.</p>
</td></tr>
<tr><td><code id="MVT_+3A_x">x</code></td>
<td>
<p>vector or matrix of the points where the density should be
evaluated.</p>
</td></tr>
<tr><td><code id="MVT_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, log-density is computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Some objects.
</p>


<h3>Value for dMVT</h3>

<p>A vector with evaluated values of the (log-)density
</p>


<h3>Value for rMVT</h3>

<p>A list with the components:
</p>

<dl>
<dt>x</dt><dd><p>vector or matrix with sampled values</p>
</dd>
<dt>log.dens</dt><dd><p>vector with the values of the log-density evaluated
in the sampled values</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dt">dt</a></code>, <code><a href="mvtnorm.html#topic+Mvt">Mvt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1977)

### Univariate central t distribution
z &lt;- rMVT(10, df=1, mu=0, Q=1)
ldz &lt;- dMVT(z$x, df=1, log=TRUE)
boxplot(as.numeric(z$x))
cbind(z$log.dens, ldz, dt(as.numeric(z$x), df=1, log=TRUE))

### Multivariate t distribution
mu &lt;- c(1, 2, 3)
Sigma &lt;- matrix(c(1, 1, -1.5,  1, 4, 1.8,  -1.5, 1.8, 9), nrow=3)
Q &lt;- chol2inv(chol(Sigma))

nu &lt;- 3
z &lt;- rMVT(1000, df=nu, mu=mu, Sigma=Sigma)
apply(z$x, 2, mean)              ## should be close to mu
((nu - 2) / nu) * var(z$x)       ## should be close to Sigma            

dz &lt;- dMVT(z$x, df=nu, mu=mu, Sigma=Sigma)
ldz &lt;- dMVT(z$x, df=nu, mu=mu, Sigma=Sigma, log=TRUE)

### Compare with mvtnorm package
#require(mvtnorm)
#ldz2 &lt;- dmvt(z$x, sigma=Sigma, df=nu, delta=mu, log=TRUE)
#plot(z$log.dens, ldz2, pch=21, col="red3", bg="orange", xlab="mixAK", ylab="mvtnorm")
#plot(ldz, ldz2, pch=21, col="red3", bg="orange", xlab="mixAK", ylab="mvtnorm")
</code></pre>

<hr>
<h2 id='NMixChainComp'>
Chains for mixture parameters
</h2><span id='topic+NMixChainComp'></span><span id='topic+NMixChainComp.default'></span><span id='topic+NMixChainComp.NMixMCMC'></span><span id='topic+NMixChainComp.GLMM_MCMC'></span>

<h3>Description</h3>

<p>This function returns chains for parameters derived from the
(re-labeled) mixture weights, means, covariance matrices.
</p>
<p>First, mixture means and shifted-scaled to the original (data) scale, mixture
covariance matrices are scaled to the original (data) scale
(see argument <code>scale</code> in <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> function
or argument <code>scale.b</code> in <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>).
Possible derived parameters are standard deviations and correlation coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixChainComp(x, relabel = TRUE, param)

## Default S3 method:
NMixChainComp(x, relabel = TRUE, param)

## S3 method for class 'NMixMCMC'
NMixChainComp(x, relabel = TRUE,
   param = c("w", "mu", "var", "sd", "cor", "Sigma", "Q", "Li"))

## S3 method for class 'GLMM_MCMC'
NMixChainComp(x, relabel = TRUE,
   param = c("w_b", "mu_b", "var_b", "sd_b", "cor_b", "Sigma_b", "Q_b", "Li_b"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixChainComp_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> or <code>GLMM_MCMC</code>.</p>
</td></tr>
<tr><td><code id="NMixChainComp_+3A_relabel">relabel</code></td>
<td>
<p>a logical argument indicating whether the chains are to
be returned with components being re-labeled (see
<code><a href="#topic+NMixRelabel">NMixRelabel</a></code>) or whether the chains are to be returned as
originally sampled.</p>
</td></tr>
<tr><td><code id="NMixChainComp_+3A_param">param</code></td>
<td>
<p>a character string indicating which sample is to be
returned:
</p>

<dl>
<dt>w, w_b</dt><dd><p>mixture weights;</p>
</dd>
<dt>mu, mu_b</dt><dd><p>mixture means;</p>
</dd>
<dt>var, var_b</dt><dd><p>mixture variances;</p>
</dd>
<dt>sd, sd_b</dt><dd><p>mixture standard deviations;</p>
</dd>
<dt>cor, cor_b</dt><dd><p>correlations derived from the mixture covariance
matrices;</p>
</dd>
<dt>Sigma, Sigma_b</dt><dd><p>mixture covariance matrices (their lower triangles);</p>
</dd>
<dt>Q, Q_b</dt><dd><p>mixture inverted covariance matrices (their lower triangles);</p>
</dd>
<dt>Li, Li_b</dt><dd><p>Cholesky factors (their lower triangles) of the
mixture inverted covariance matrices.</p>
</dd>      
</dl>
  
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with sampled values in rows, parameters in columns.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='NMixChainsDerived'>
Create MCMC chains derived from previously sampled values
</h2><span id='topic+NMixChainsDerived'></span><span id='topic+C_NMix_ChainsDerived'></span>

<h3>Description</h3>

<p>Currently, this function creates chains for marginal means
of exp(data) from previously sampled values (see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>).
This is useful in survival context when a density
of <code class="reqn">Y=\log(T)</code> is modelled using the function
<code><a href="#topic+NMixMCMC">NMixMCMC</a></code> and we are interested in inference
on <code class="reqn">\mbox{E}T = \mbox{E}\exp(Y)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixChainsDerived(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixChainsDerived_+3A_object">object</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> or <code>NMixMCMClist</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as argument <code>object</code>. When
<code>object</code> was of class <code>NMixMCMC</code>, the resulting object
contains additionally the following components:
</p>
<table>
<tr><td><code>chains.derived</code></td>
<td>
<p>a <code>data.frame</code> with columns labeled
<code>expy.Mean.1</code>, ..., <code>expy.Mean.p</code> containing the
sampled values of <code class="reqn">\mbox{E}\exp(Y_1)</code>, ...,
<code class="reqn">\mbox{E}\exp(Y_p)</code>.</p>
</td></tr>
<tr><td><code>summ.expy.Mean</code></td>
<td>
<p>posterior summary statistics for <code class="reqn">\mbox{E}\exp(Y_1)</code>, ...,
<code class="reqn">\mbox{E}\exp(Y_p)</code>.</p>
</td></tr>
</table>
<p>When <code>object</code> was of the class <code>NMixMCMClist</code> then each of
its components (chains) is augmented by new components
<code>chains.derived</code> and <code>summ.expy.Mean</code>.   
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='NMixCluster'>
Clustering based on the MCMC output of the mixture model
</h2><span id='topic+NMixCluster'></span><span id='topic+NMixCluster.default'></span><span id='topic+NMixCluster.GLMM_MCMC'></span>

<h3>Description</h3>

<p>TO BE ADDED.
</p>
<p>This function only works for models with a fixed number of mixture components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixCluster(object, ...)

## Default S3 method:
NMixCluster(object, ...)

## S3 method for class 'GLMM_MCMC'
NMixCluster(object,
   prob = c("poster.comp.prob", "quant.comp.prob", "poster.comp.prob_b",
            "quant.comp.prob_b", "poster.comp.prob_u"),
   pquant = 0.5, HPD = FALSE, pHPD = 0.95, pthresh = -1, unclass.na = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixCluster_+3A_object">object</code></td>
<td>
<p>an object of apropriate class.</p>
</td></tr>
<tr><td><code id="NMixCluster_+3A_prob">prob</code></td>
<td>
<p>character string which identifies estimates of the
component probabilities to be used for clustering.</p>
</td></tr>
<tr><td><code id="NMixCluster_+3A_pquant">pquant</code></td>
<td>
<p>when <code>prob</code> is either &ldquo;quant.comp.prob&rdquo; or
&ldquo;quant.comp.prob_b&rdquo;, argument <code>pquant</code> is the
probability of the quantile of the component probabilities to be
used for clustering.</p>
</td></tr>
<tr><td><code id="NMixCluster_+3A_hpd">HPD</code></td>
<td>
<p>logical value. If <code>TRUE</code> then only those subjects are
classified for which the lower limit of the <code>pHPD</code>*100% HPD
credible interval of the component probability exceeds the value of <code>ptrash</code>.</p>
</td></tr>
<tr><td><code id="NMixCluster_+3A_phpd">pHPD</code></td>
<td>
<p>credible level of the HPD credible interval, see argument <code>HPD</code>.</p>
</td></tr>
<tr><td><code id="NMixCluster_+3A_pthresh">pthresh</code></td>
<td>
<p>an optional threshold for the estimated component
probability (when <code>HPD</code> is <code>FALSE</code>) or for the lower limit
of the HPD credible interval (when <code>HPD</code> is <code>TRUE</code>) to
classify a subject. No effect when <code>pthresh</code> is negative.</p>
</td></tr>
<tr><td><code id="NMixCluster_+3A_unclass.na">unclass.na</code></td>
<td>
<p>logical value taken into account when <code>pthresh</code>
is positive. If <code>unclass.na</code> is <code>TRUE</code>, unclassified subjects get classification
<code>NA</code>. If <code>unclass.na</code> is <code>FALSE</code>, unclassified
subjects create a separate (last) group.</p>
</td></tr>
<tr><td><code id="NMixCluster_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with three (when <code>HPD</code> is <code>FALSE</code>) or five
(when <code>HPD</code> is <code>TRUE</code>) columns.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## TO BE ADDED.
</code></pre>

<hr>
<h2 id='NMixEM'>
EM algorithm for a homoscedastic normal mixture
</h2><span id='topic+NMixEM'></span><span id='topic+print.NMixEM'></span>

<h3>Description</h3>

<p>This function computes ML estimates of the parameters
of the <code class="reqn">p</code>-dimensional <code class="reqn">K</code>-component normal mixture using the EM algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixEM(y, K, weight, mean, Sigma, toler=1e-5, maxiter=500)

## S3 method for class 'NMixEM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixEM_+3A_y">y</code></td>
<td>
<p>vector (if <code class="reqn">p=1</code>) matrix or data frame (if <code class="reqn">p &gt; 1</code>) with data. Rows correspond to
observations, columns correspond to margins.</p>
</td></tr>
<tr><td><code id="NMixEM_+3A_k">K</code></td>
<td>
<p>required number of mixture components.</p>
</td></tr>
<tr><td><code id="NMixEM_+3A_weight">weight</code></td>
<td>
<p>a numeric vector with initial mixture weights.
</p>
<p>If not given, initial weights are all equal to <code class="reqn">1/K</code>.
</p>
</td></tr>
<tr><td><code id="NMixEM_+3A_mean">mean</code></td>
<td>
<p>vector or matrix of initial mixture means.
</p>
<p>For <code class="reqn">p=1</code> this
should be a vector of length <code class="reqn">K</code>, for <code class="reqn">p&gt;1</code> this should be a
<code class="reqn">K\times p</code> matrix with mixture means in rows.
</p>
</td></tr>
<tr><td><code id="NMixEM_+3A_sigma">Sigma</code></td>
<td>
<p>number or <code class="reqn">p\times p</code> matrix giving the
initial variance/covariance matrix.
</p>
</td></tr>
<tr><td><code id="NMixEM_+3A_toler">toler</code></td>
<td>
<p>tolerance to determine convergence.</p>
</td></tr>
<tr><td><code id="NMixEM_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations of the EM algorithm.</p>
</td></tr>
<tr><td><code id="NMixEM_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixEM</code>.</p>
</td></tr>
<tr><td><code id="NMixEM_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the default <code>print</code> method.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>An object of class <code>NMixEM</code> which has the following components:
</p>
<table>
<tr><td><code>K</code></td>
<td>
<p>number of mixture components</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>estimated mixture weights</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>estimated mixture means</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>estimated covariance matrix</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood value at fitted values</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>Akaike information criterion
(<code class="reqn">-2\hat{\ell} + 2\nu</code>), where
<code class="reqn">\hat{\ell}</code> stands for the log-likelihood value at
fitted values and <code class="reqn">\nu</code> for the number of free model parameters
</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>Bayesian (Schwarz) information criterion
(<code class="reqn">-2\hat{\ell} + \log(n)\,\nu</code>), where
<code class="reqn">\hat{\ell}</code> stands for the log-likelihood value at
fitted values and <code class="reqn">\nu</code> for the number of free model
parameters, and <code class="reqn">n</code> for the sample size    
</p>
</td></tr>  
<tr><td><code>iter</code></td>
<td>
<p>number of iterations of the EM algorithm used to get the solution</p>
</td></tr>
<tr><td><code>iter.loglik</code></td>
<td>
<p>values of the log-likelihood at iterations of the
EM algorithm</p>
</td></tr>
<tr><td><code>iter.Qfun</code></td>
<td>
<p>values of the EM objective function at iterations of
the EM algorithm</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>dimension <code class="reqn">p</code></p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations <code class="reqn">n</code></p>
</td></tr>       
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Dempster, A. P., Laird, N. M., Rubin, D. B. (1977).
Maximum likelihood from incomplete data via the EM algorithm.
<em>Journal of the Royal Statistical Society, Series B</em>, <b>39</b>, 1-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Estimates for 3-component mixture in  Anderson's iris data
## ==========================================================
data(iris, package="datasets")
summary(iris)

VARS &lt;- names(iris)[1:4]
fit &lt;- NMixEM(iris[, VARS], K = 3)
print(fit)

apply(subset(iris, Species == "versicolor")[, VARS], 2, mean)
apply(subset(iris, Species == "setosa")[, VARS], 2, mean)
apply(subset(iris, Species == "virginica")[, VARS], 2, mean)

## Estimates of 6-component mixture in Galaxy data
## ==================================================
data(Galaxy, package="mixAK")
summary(Galaxy)

fit2 &lt;- NMixEM(Galaxy, K = 6)
y &lt;- seq(5, 40, length=300)
fy &lt;- dMVNmixture(y, weight=fit2$weight, mean=fit2$mean,
                     Sigma=rep(fit2$Sigma, fit2$K))
hist(Galaxy, prob=TRUE, breaks=seq(5, 40, by=0.5),
     main="", xlab="Velocity (km/sec)", col="sandybrown")
lines(y, fy, col="darkblue", lwd=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='NMixMCMC'>
MCMC estimation of (multivariate) normal mixtures with possibly
censored data.
</h2><span id='topic+NMixMCMC'></span><span id='topic+print.NMixMCMC'></span><span id='topic+print.NMixMCMClist'></span><span id='topic+C_NMix_MCMC'></span><span id='topic+C_NMix_PED'></span>

<h3>Description</h3>

<p>This function runs MCMC for a model in which unknown density is
specified as a normal mixture with either known or unknown number of
components. With a prespecified number of components, MCMC is
implemented through Gibbs sampling (see Diebolt and Robert, 1994) and
dimension of the data can be arbitrary.
With unknown number of components, currently only univariate case is
implemented using the reversible jump MCMC (Richardson and Green,
1997).



</p>
<p>Further, the data are allowed to be censored in which case additional
Gibbs step is used within the MCMC algorithm 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixMCMC(y0, y1, censor, x_w, scale, prior,
         init, init2, RJMCMC,
         nMCMC = c(burn = 10, keep = 10, thin = 1, info = 10),
         PED, keep.chains = TRUE, onlyInit = FALSE, dens.zero = 1e-300,
         parallel = FALSE, cltype)

## S3 method for class 'NMixMCMC'
print(x, dic, ...)

## S3 method for class 'NMixMCMClist'
print(x, ped, dic, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixMCMC_+3A_y0">y0</code></td>
<td>
<p>numeric vector of length <code class="reqn">n</code> or <code class="reqn">n\times p</code>
matrix with observed data. It contains exactly observed,
right-censored, left-censored data and lower limits for
interval-censored data.</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_y1">y1</code></td>
<td>
<p>numeric vector of length <code class="reqn">n</code> or <code class="reqn">n\times p</code>
matrix with upper limits for interval-censored data. Elements
corresponding to exactly observed, right-censored or left-censored
data are ignored and can be filled arbitrarily (by
<code>NA</code>'s) as well.
</p>
<p>It does not have to be supplied if there are no interval-censored data.
</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_censor">censor</code></td>
<td>
<p>numeric vector of length <code class="reqn">n</code> or <code class="reqn">n\times p</code>
matrix with censoring indicators. The following values indicate:
</p>

<dl>
<dt>0</dt><dd><p>right-censored observation,</p>
</dd>
<dt>1</dt><dd><p>exactly observed value,</p>
</dd>
<dt>2</dt><dd><p>left-censored observation,</p>
</dd>
<dt>3</dt><dd><p>interval-censored observation.</p>
</dd>      
</dl>

<p>If it is not supplied then it is assumed that all values are exactly
observed.
</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_x_w">x_w</code></td>
<td>
<p>optional vector providing a categorical covariate that may
influence the mixture weights. Internally, it is converted into a
<code>factor</code>.
</p>
<p>Added in version 4.0 (03/2015).
</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_scale">scale</code></td>
<td>
<p>a list specifying how to scale the data before running
MCMC. It should have two components:
</p>

<dl>
<dt>shift</dt><dd><p>a vector of length 1 or <code class="reqn">p</code> specifying shift
vector <code class="reqn">\boldsymbol{m}</code>,</p>
</dd>
<dt>scale</dt><dd><p>a vector of length 1 or <code class="reqn">p</code> specifying diagonal of the
scaling matrix <code class="reqn">\boldsymbol{S}</code>.</p>
</dd>
</dl>
  
<p>If there is no censoring, and argument <code>scale</code> is missing
then the data are scaled to have zero mean and unit variances, i.e.,
<code>scale(y0)</code> is used for MCMC. In the case there is censoring
and <code>scale</code> is missing,
<code>scale$shift</code> is taken to be a sample mean of <code>init$y</code> and
<code>scale$scale</code> are sample standard deviations of columns of <code>init$y</code>.
</p>
<p>If you do not wish to scale the data before running MCMC, specify
<code>scale=list(shift=0, scale=1)</code>.
</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_prior">prior</code></td>
<td>
<p>a list with the parameters of the prior distribution. It
should have the following components (for some of them,
the program can assign default values and the user does not have to
specify them if he/she wishes to use the defaults):
</p>

<dl>
<dt>priorK</dt><dd><p>a character string which specifies the type of the
prior for <code class="reqn">K</code> (the number of mixture components). It should
have one of the following values:
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>
&ldquo;<code>fixed</code>&rdquo;<code class="reqn">\mbox{\hspace{6in}}</code>
Number of mixture components is assumed to be fixed to
<code class="reqn">K_{max}</code>. This is a <b>default</b> value.
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>
&ldquo;<code>uniform</code>&rdquo;<code class="reqn">\mbox{\hspace{6in}}</code>
A priori <code class="reqn">K \sim \mbox{Unif}\{1,\dots,K_{max}\}.</code>
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>
&ldquo;<code>tpoisson</code>&rdquo;<code class="reqn">\mbox{\hspace{6in}}</code>
A priori <code class="reqn">K \sim
	  \mbox{truncated-Poiss}(\lambda,\,K_{max}).</code>
</p>
</dd>
<dt>priormuQ</dt><dd><p>a character string which specifies the type of the
prior for <code class="reqn">\boldsymbol{\mu}_1,\dots,\boldsymbol{\mu}_{K_{max}}</code> (mixture means) and
<code class="reqn">\boldsymbol{Q}_1,\dots,\boldsymbol{Q}_{K_{max}}</code> (inverted mixture covariance matrices). It should
have one of the following values:
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>
&ldquo;<code>independentC</code>&rdquo;<code class="reqn">\mbox{\hspace{6in}}</code>
<code class="reqn">\equiv</code> independent conjugate prior (this is a
<b>default</b> value).
That is, a priori
</p>
<p style="text-align: center;"><code class="reqn">
          (\boldsymbol{\mu}_j,\, \boldsymbol{Q}_j) \sim
	  \mbox{N}(\boldsymbol{\xi}_j,\,\boldsymbol{D}_j)
	  \times
	  \mbox{Wishart}(\zeta,\,\boldsymbol{\Xi})
	</code>
</p>
  
<p>independently for <code class="reqn">j=1,\ldots,K</code>, where
normal means
<code class="reqn">\boldsymbol{\xi}_1,\dots,\boldsymbol{\xi}_K</code>,
normal variances
<code class="reqn">\boldsymbol{D}_1,\dots,\boldsymbol{D}_K</code>,
and Wishart degrees of freedom <code class="reqn">\zeta</code> are specified
further as <code>xi</code>, <code>D</code>, <code>zeta</code> components of the
list <code>prior</code>.
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>
&ldquo;<code>naturalC</code>&rdquo;<code class="reqn">\mbox{\hspace{6in}}</code>
<code class="reqn">\equiv</code> natural conjugate prior. That is, a priori
</p>
<p style="text-align: center;"><code class="reqn">
          (\boldsymbol{\mu}_j,\, \boldsymbol{Q}_j) \sim
	  \mbox{N}(\boldsymbol{\xi}_j,\,c_j^{-1}\boldsymbol{Q}_j^{-1})
	  \times
	  \mbox{Wishart}(\zeta,\,\boldsymbol{\Xi})
	</code>
</p>
  
<p>independently for <code class="reqn">j=1,\ldots,K</code>, where
normal means
<code class="reqn">\boldsymbol{\xi}_1,\dots,\boldsymbol{\xi}_K</code>,
precisions
<code class="reqn">c_1,\dots,c_K</code>,
and Wishart degrees of freedom <code class="reqn">\zeta</code> are specified
further as <code>xi</code>, <code>ce</code>, <code>zeta</code> components of the
list <code>prior</code>.
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>
For both, independent conjugate and natural conjugate prior, the
Wishart scale matrix <code class="reqn">\boldsymbol{\Xi}</code> is assumed to be
diagonal with
<code class="reqn">\gamma_1,\dots,\gamma_p</code> on a
diagonal. For <code class="reqn">\gamma_j^{-1}</code> <code class="reqn">(j=1,\ldots,K)</code> additional
gamma hyperprior <code class="reqn">\mbox{G}(g_j,\,h_j)</code> is assumed.
Values of <code class="reqn">g_1,\dots,g_p</code> and
<code class="reqn">h_1,\dots,h_p</code> are further specified as
<code>g</code> and <code>h</code> components of the <code>prior</code> list.
</p>
</dd>
<dt>Kmax</dt><dd><p>maximal number of mixture components
<code class="reqn">K_{max}</code>. It must <b>always be specified</b> by the user.</p>
</dd>
<dt>lambda</dt><dd><p>parameter <code class="reqn">\lambda</code> for the truncated
Poisson prior on <code class="reqn">K</code>. It must be positive and must <b>always be specified</b> if
<code>priorK</code> is &ldquo;<code>tpoisson</code>&rdquo;.</p>
</dd>
<dt>delta</dt><dd><p>parameter <code class="reqn">\delta</code> for the Dirichlet prior
on the mixture weights <code class="reqn">w_1,\dots,w_K.</code>
It must be positive. Its <b>default</b> value is 1.</p>
</dd>
<dt>xi</dt><dd><p>a numeric value, vector or matrix which specifies
<code class="reqn">\boldsymbol{\xi}_1, \dots, \boldsymbol{\xi}_{K_{max}}</code> (prior means for the mixture means
<code class="reqn">\boldsymbol{\mu}_1,\dots,\boldsymbol{\mu}_{K_{max}}</code>). <b>Default</b> value is a matrix
<code class="reqn">K_{max}\times p</code> with midpoints of columns
of <code>init$y</code> in rows which follows Richardson and Green (1997).
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>	  
If <code class="reqn">p=1</code> and <code>xi</code><code class="reqn">=\xi</code> is a single value
then <code class="reqn">\xi_1=\cdots=\xi_{K_{max}} =
	    \xi.</code>
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>
If <code class="reqn">p=1</code> and <code>xi</code><code class="reqn">=\boldsymbol{\xi}</code> is a vector of length
<code class="reqn">K_{max}</code> then the <code class="reqn">j</code>-th element of <code>xi</code>
gives <code class="reqn">\xi_j</code> <code class="reqn">(j=1,\dots,K_{max}).</code>
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>	  
If <code class="reqn">p&gt;1</code> and <code>xi</code><code class="reqn">=\boldsymbol{\xi}</code> is a vector of length <code class="reqn">p</code>
then <code class="reqn">\boldsymbol{\xi}_1=\cdots=\boldsymbol{\xi}_{K_{max}} =
	    \boldsymbol{\xi}.</code>
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>
If <code class="reqn">p&gt;1</code> and <code>xi</code> is a <code class="reqn">K_{max} \times p</code> matrix then the <code class="reqn">j</code>-th row of <code>xi</code>
gives <code class="reqn">\boldsymbol{xi}_j</code> <code class="reqn">(j=1,\dots,K_{max}).</code>	  
</p>
</dd> 
<dt>ce</dt><dd><p>a numeric value or vector which specifies prior
precision parameters
<code class="reqn">c_1,\dots,c_{K_{max}}</code> for the
mixture means <code class="reqn">\boldsymbol{\mu}_1,\dots,\boldsymbol{\mu}_{K_{max}}</code> when <code>priormuQ</code> is &ldquo;<code>naturalC</code>&rdquo;.
Its <b>default</b> value is a vector of ones which follows
Cappe, Robert and Ryden (2003).
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>
If <code>ce</code><code class="reqn">=c</code> is a single value then
<code class="reqn">c_1=\cdots=c_{K_{max}}=c.</code>
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>
If <code>ce</code><code class="reqn">=\boldsymbol{c}</code> is a vector of length
<code class="reqn">K_{max}</code> then the <code class="reqn">j</code>-th element of <code>ce</code>
gives <code class="reqn">c_j</code> <code class="reqn">(j=1,\dots,K_{max}).</code>      
</p>
</dd>
<dt>D</dt><dd><p>a numeric vector or matrix which specifies
<code class="reqn">\boldsymbol{D}_1, \dots, \boldsymbol{D}_{K_{max}}</code> (prior variances or covariance matrices
of the mixture means
<code class="reqn">\boldsymbol{\mu}_1,\dots,\boldsymbol{\mu}_{K_{max}}</code> when <code>priormuQ</code> is
&ldquo;<code>independentC</code>&rdquo;.)
Its <b>default</b> value is a diagonal matrix with squared ranges
of each column of <code>init$y</code> on a diagonal.
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>	  
If <code class="reqn">p=1</code> and <code>D</code><code class="reqn">=d</code> is a single value
then <code class="reqn">d_1=\cdots=d_{K_{max}} =
	d.</code>
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>
If <code class="reqn">p=1</code> and <code>D</code><code class="reqn">=\boldsymbol{d}</code> is a vector of length
<code class="reqn">K_{max}</code> then the <code class="reqn">j</code>-th element of <code>D</code>
gives <code class="reqn">d_j</code> <code class="reqn">(j=1,\dots,K_{max}).</code>
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>	  
If <code class="reqn">p&gt;1</code> and <code>D</code><code class="reqn">=\boldsymbol{D}</code> is a
<code class="reqn">p\times p</code> matrix
then <code class="reqn">\boldsymbol{D}_1=\cdots=\boldsymbol{D}_{K_{max}} =
	  \boldsymbol{D}.</code>
</p>
<p><code class="reqn">\mbox{\hspace{6in}}</code>
If <code class="reqn">p&gt;1</code> and <code>D</code> is a <code class="reqn">(K_{max}\cdot p) \times p</code> matrix then the the first <code class="reqn">p</code> rows of <code>D</code>
give <code class="reqn">\boldsymbol{D}_1</code>, rows <code class="reqn">p+1,\ldots,2p</code> of
<code>D</code> give <code class="reqn">\boldsymbol{D}_2</code> etc.
</p>
</dd>
<dt>zeta</dt><dd><p>degrees of freedom <code class="reqn">\zeta</code> for the Wishart
prior on the inverted mixture variances
<code class="reqn">\boldsymbol{Q}_1,\dots,\boldsymbol{Q}_{K_{max}}.</code>.
It must be higher then <code class="reqn">p-1</code>. Its <b>default</b> value is
<code class="reqn">p + 1</code>.	
</p>
</dd>
<dt>g</dt><dd><p>a value or a vector of length <code class="reqn">p</code> with the shape
parameters <code class="reqn">g_1,\dots,g_p</code> for the Gamma hyperpriors on
<code class="reqn">\gamma_1,\dots,\gamma_p</code>.	
It must be positive. Its <b>default</b> value is a vector
<code class="reqn">(0.2,\dots,0.2)'</code>.
</p>
</dd>
<dt>h</dt><dd><p>a value or a vector of length <code class="reqn">p</code> with the rate
parameters <code class="reqn">h_1,\dots,h_p</code>
for the Gamma hyperpriors on <code class="reqn">\gamma_1,\dots,\gamma_p</code>.
It must be positive. Its <b>default</b> value is a vector containing
<code class="reqn">10/R_l^2</code>, where
<code class="reqn">R_l</code> is a range of the <code class="reqn">l</code>-th column of <code>init$y</code>.
</p>
</dd>	
</dl>
  
</td></tr>
<tr><td><code id="NMixMCMC_+3A_init">init</code></td>
<td>
<p>a list with the initial values for the MCMC. All initials
can be determined by the program if they are not specified. The list
may have the following components:
</p>

<dl>
<dt>y</dt><dd><p>a numeric vector or matrix with the initial values for the latent censored observations.</p>
</dd>
<dt>K</dt><dd><p>a numeric value with the initial value for the number of mixture components.</p>
</dd>
<dt>w</dt><dd><p>a numeric vector with the initial values for the mixture
weights.</p>
</dd>
<dt>mu</dt><dd><p>a numeric vector or matrix with the initial values for
the mixture means.</p>
</dd>
<dt>Sigma</dt><dd><p>a numeric vector or matrix with the initial values
for the mixture variances.</p>
</dd>
<dt>Li</dt><dd><p>a numeric vector with the initial values for the Colesky
decomposition of the mixture inverse variances.</p>
</dd>
<dt>gammaInv</dt><dd><p>a numeric vector with the initial values for the
inverted components of the hyperparameter <code class="reqn">\boldsymbol{\gamma}</code>.</p>
</dd>
<dt>r</dt><dd><p>a numeric vector with the initial values for the mixture
allocations.</p>
</dd>      
</dl>
      
</td></tr>
<tr><td><code id="NMixMCMC_+3A_init2">init2</code></td>
<td>
<p>a list with the initial values for the second chain
needed to estimate the penalized expected deviance of Plummer
(2008). The list <code>init2</code> has the same structure as the list
<code>init</code>. All initials in <code>init2</code> can be determined by the
program (differently than the values in <code>init</code>) if they are not
specified.
</p>
<p>Ignored when <code>PED</code> is <code>FALSE</code>.
</p>
</td></tr>  
<tr><td><code id="NMixMCMC_+3A_rjmcmc">RJMCMC</code></td>
<td>
<p>a list with the parameters needed to run reversible jump
MCMC for mixtures with varying number of components. It does not
have to be specified if the number of components is fixed. Most of
the parameters can be determined by the program if they are not
specified. The list may have the following components:
</p>

<dl>
<dt>Paction</dt><dd><p>probabilities (or proportionalit constants) which
are used to choose an action of the sampler within each
iteration of MCMC to update the mixture related parameters. Let
<code>Paction</code> = <code class="reqn">(p_1,\,p_2,\,p_3)'</code>. Then with probability <code class="reqn">p_1</code> only steps
assuming fixed <code class="reqn">k</code> (number of mixture components) are
performed, with probability <code class="reqn">p_2</code> split-combine move
is proposed and with probability <code class="reqn">p_3</code> birth-death
move is proposed.
</p>
<p>If not specified (default) then in each iteration of MCMC, all
sampler actions are performed.






</p>
</dd>
<dt>Psplit</dt><dd><p>a numeric vector of length <code>prior$Kmax</code> giving
conditional probabilities of the split move given <code class="reqn">k</code> as
opposite to the combine move.
</p>
<p>Default value is
<code class="reqn">(1,\,0.5,\ldots,0.5,\,0)'</code>.
</p>
</dd>
<dt>Pbirth</dt><dd><p>a numeric vector of length <code>prior$Kmax</code> giving
conditional probabilities of the birth move given <code class="reqn">k</code> as
opposite to the death move.
</p>
<p>Default value is
<code class="reqn">(1,\,0.5,\ldots,0.5,\,0)'</code>.
</p>
</dd>
<dt>par.u1</dt><dd><p>a two component vector with parameters of the beta
distribution used to generate an auxiliary value
<code class="reqn">u_1</code>.
</p>
<p>A default value is <code>par.u1</code> = <code class="reqn">(2,\,2)'</code>,
i.e., <code class="reqn">u_1 \sim \mbox{Beta}(2,\,2).</code>	
</p>
</dd>
<dt>par.u2</dt><dd><p>a two component vector (for <code class="reqn">p=1</code>) or a matrix
(for <code class="reqn">p &gt; 1</code>)
with two columns with parameters of the distributions of the
auxiliary values
<code class="reqn">u_{2,1},\ldots,u_{2,p}</code> in rows.
</p>
<p>A default value leads to
<code class="reqn">u_{2,d} \sim \mbox{Unif}(-1,\,1)\; (d=1,\ldots,p-1),</code>
<code class="reqn">u_{2,p} \sim \mbox{Beta}(1,\,2p).</code>
</p>
</dd>
<dt>par.u3</dt><dd><p>a two component vector (for <code class="reqn">p=1</code>) or a matrix
(for <code class="reqn">p &gt; 1</code>)
with two columns with parameters of the distributions of the
auxiliary values
<code class="reqn">u_{3,1},\ldots,u_{3,p}</code> in rows.
</p>
<p>A default value leads to
<code class="reqn">u_{3,d} \sim \mbox{Unif}(0,\,1)\; (d=1,\ldots,p-1),</code>
<code class="reqn">u_{3,p} \sim \mbox{Beta}(1,\,p),</code>	
</p>
</dd>      
</dl>
    
</td></tr>  
<tr><td><code id="NMixMCMC_+3A_nmcmc">nMCMC</code></td>
<td>
<p>numeric vector of length 4 giving parameters of the MCMC
simulation. Its components may be named (ordering is then unimportant) as:
</p>

<dl>
<dt>burn</dt><dd><p>length of the burn-in (after discarding the thinned
values), can be equal to zero as well.</p>
</dd>
<dt>keep</dt><dd><p>length of the kept chains (after discarding the
thinned values), must be positive.</p>
</dd>
<dt>thin</dt><dd><p>thinning interval, must be positive.</p>
</dd>
<dt>info</dt><dd><p>interval in which the progress information is printed
on the screen.</p>
</dd>      
</dl>

<p>In total <code class="reqn">(M_{burn} + M_{keep}) \cdot M_{thin}</code> MCMC scans are performed.
</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_ped">PED</code></td>
<td>
<p>a logical value which indicates whether the penalized
expected deviance (see Plummer, 2008 for more details)
is to be computed (which requires two parallel
chains). If not specified, <code>PED</code> is set to <code>TRUE</code>
for models with fixed number of components and is set to
<code>FALSE</code> for models with numbers of components estimated using RJ-MCMC.
</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_keep.chains">keep.chains</code></td>
<td>
<p>logical. If <code>FALSE</code>, only summary statistics
are returned in the resulting object. This might be useful in the
model searching step to save some memory.</p>
</td></tr>  
<tr><td><code id="NMixMCMC_+3A_onlyinit">onlyInit</code></td>
<td>
<p>logical. If <code>TRUE</code> then the function only
determines parameters of the prior distribution, initial values,
values of <code>scale</code> and
parameters for the reversible jump MCMC.</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_dens.zero">dens.zero</code></td>
<td>
<p>a small value used instead of zero when computing
deviance related quantities.</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> or <code>NMixMCMClist</code> to
be printed.</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_dic">dic</code></td>
<td>
<p>logical which indicates whether DIC should be printed. By
default, DIC is printed only for models with a fixed number of
mixture components.
</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_ped">ped</code></td>
<td>
<p>logical which indicates whether PED should be printed. By
default, PED is printed only for models with a fixed number of
mixture components.
</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_parallel">parallel</code></td>
<td>
<p>a logical value which indicates whether parallel
computation (based on a package <code>parallel</code>) should be used when
running two chains for the purpose of <code>PED</code> calculation</p>
</td></tr>
<tr><td><code id="NMixMCMC_+3A_cltype">cltype</code></td>
<td>
<p>optional argument applicable if <code>parallel</code> is
<code>TRUE</code>. If <code>cltype</code> is given, it is passed as the
<code>type</code> argument into the call to <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.</p>
</td></tr>  
<tr><td><code id="NMixMCMC_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the default <code>print</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See accompanying paper (Komárek, 2009).
In the rest of the helpfile,
the same notation is used as in the paper, namely, <code class="reqn">n</code> denotes the number of
observations, <code class="reqn">p</code> is dimension of the data, <code class="reqn">K</code> is the number
of mixture components,
<code class="reqn">w_1,\dots,w_K</code> are mixture weights, 
<code class="reqn">\boldsymbol{\mu}_1,\dots,\boldsymbol{\mu}_K</code>
are mixture means,
<code class="reqn">\boldsymbol{\Sigma}_1,\dots,\boldsymbol{\Sigma}_K</code>
are mixture variance-covariance matrices,
<code class="reqn">\boldsymbol{Q}_1,\dots,\boldsymbol{Q}_K</code> are
their inverses.
</p>
<p>For the data
<code class="reqn">\boldsymbol{y}_1,\dots,\boldsymbol{y}_n</code> the
following <code class="reqn">g_y(\boldsymbol{y})</code> density is assumed
</p>
<p style="text-align: center;"><code class="reqn">
    g_y(\boldsymbol{y}) = |\boldsymbol{S}|^{-1} \sum_{j=1}^K w_j
    \varphi\bigl(\boldsymbol{S}^{-1}(\boldsymbol{y} - \boldsymbol{m}\,|\,\boldsymbol{\mu}_j,\,\boldsymbol{\Sigma}_j)\bigr),
  </code>
</p>

<p>where
<code class="reqn">\varphi(\cdot\,|\,\boldsymbol{\mu},\,\boldsymbol{\Sigma})</code> denotes a density
of the (multivariate) normal distribution
with mean <code class="reqn">\boldsymbol{\mu}</code> and a~variance-covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code>.
Finally, <code class="reqn">\boldsymbol{S}</code> is a pre-specified diagonal scale matrix and
<code class="reqn">\boldsymbol{m}</code> is a pre-specified shift vector. Sometimes, by
setting <code class="reqn">\boldsymbol{m}</code> to sample means of components of
<code class="reqn">\boldsymbol{y}</code> and diagonal of <code class="reqn">\boldsymbol{S}</code> to
sample standard deviations of <code class="reqn">\boldsymbol{y}</code> (considerable)
improvement of the MCMC algorithm is achieved.   
</p>


<h3>Value</h3>

<p>An object of class <code>NMixMCMC</code> or class <code>NMixMCMClist</code>.
Object of class <code>NMixMCMC</code> is returned if <code>PED</code> is
<code>FALSE</code>. Object of class <code>NMixMCMClist</code> is returned if
<code>PED</code> is <code>TRUE</code>. 
</p>


<h3>Object of class NMixMCMC</h3>

<p>Objects of class <code>NMixMCMC</code> have the following components:
</p>
  
<dl>
<dt>iter</dt><dd><p>index of the last iteration performed.</p>
</dd>
<dt>nMCMC</dt><dd><p>used value of the argument <code>nMCMC</code>.</p>
</dd>
<dt>dim</dt><dd><p>dimension <code class="reqn">p</code> of the distribution of data</p>
</dd>
<dt>nx_w</dt><dd><p>number of levels of a factor covariate on mixture weights
(equal to 1 if there were no covariates on mixture weights)</p>
</dd>



<dt>prior</dt><dd><p>a list containing the used value of the argument <code>prior</code>.</p>
</dd>
<dt>init</dt><dd><p>a list containing the used initial values for the MCMC
(the first iteration of the burn-in).
</p>
</dd>
<dt>state.first</dt><dd><p>a list having the components labeled
<code>y</code>, <code>K</code>, <code>w</code>, <code>mu</code>, <code>Li</code>, <code>Q</code>, <code>Sigma</code>,
<code>gammaInv</code>, <code>r</code> containing the values of
generic parameters at the first stored (after burn-in) iteration of the MCMC.
</p>
</dd>  
<dt>state.last</dt><dd><p>a list having the components labeled
<code>y</code>, <code>K</code>, <code>w</code>, <code>mu</code>, <code>Li</code>, <code>Q</code>, <code>Sigma</code>,
<code>gammaInv</code>, <code>r</code> containing the last sampled values of
generic parameters.
</p>
</dd>  
<dt>RJMCMC</dt><dd><p>a list containing the used value of the argument <code>RJMCMC</code>.</p>
</dd>  
<dt>scale</dt><dd><p>a list containing the used value of the argument <code>scale</code>.</p>
</dd>
<dt>freqK</dt><dd><p>frequency table of <code class="reqn">K</code> based on the sampled chain.</p>
</dd>
<dt>propK</dt><dd><p>posterior distribution of <code class="reqn">K</code> based on the sampled chain.</p>
</dd>
<dt>DIC</dt><dd><p>a <code>data.frame</code> having columns labeled
<code>DIC</code>, <code>pD</code>, <code>D.bar</code>, <code>D.in.bar</code> containing
values used to compute deviance information criterion
(DIC). Currently only <code class="reqn">DIC_3</code> of Celeux et al. (2006) is
implemented.
</p>
</dd>
<dt>moves</dt><dd><p>a <code>data.frame</code> which summarizes the acceptance
probabilities of different move types of the sampler.</p>
</dd>
<dt>K</dt><dd><p>numeric vector with a chain for <code class="reqn">K</code> (number of mixture components).</p>
</dd>
<dt>w</dt><dd><p>numeric vector or matrix with a chain for <code class="reqn">w</code> (mixture
weights). It is a matrix with <code class="reqn">K</code> columns when <code class="reqn">K</code> is
fixed. Otherwise, it is a vector with weights put sequentially after
each other.</p>
</dd>
<dt>mu</dt><dd><p>numeric vector or matrix with a chain for <code class="reqn">\mu</code> (mixture
means). It is a matrix with <code class="reqn">p\cdot K</code> columns when <code class="reqn">K</code> is
fixed. Otherwise, it is a vector with means put sequentially after
each other.</p>
</dd>
<dt>Q</dt><dd><p>numeric vector or matrix with a chain for lower triangles of <code class="reqn">\boldsymbol{Q}</code> (mixture
inverse variances). It is a matrix with <code class="reqn">\frac{p(p+1)}{2}\cdot K</code>
columns when <code class="reqn">K</code> is fixed. Otherwise, it is a vector with lower
triangles of <code class="reqn">\boldsymbol{Q}</code> matrices put sequentially after each other.</p>
</dd>
<dt>Sigma</dt><dd><p>numeric vector or matrix with a chain for lower triangles of <code class="reqn">\Sigma</code> (mixture
variances). It is a matrix with <code class="reqn">\frac{p(p+1)}{2}\cdot K</code>
columns when <code class="reqn">K</code> is fixed. Otherwise, it is a vector with lower
triangles of <code class="reqn">\Sigma</code> matrices put sequentially after each other.</p>
</dd>
<dt>Li</dt><dd><p>numeric vector or matrix with a chain for lower triangles of
Cholesky decompositions of <code class="reqn">\boldsymbol{Q}</code> matrices.
It is a matrix with <code class="reqn">\frac{p(p+1)}{2}\cdot K</code>
columns when <code class="reqn">K</code> is fixed. Otherwise, it is a vector with lower
triangles put sequentially after each other.</p>
</dd>
<dt>gammaInv</dt><dd><p>matrix with <code class="reqn">p</code> columns with a chain for inverses
of the hyperparameter <code class="reqn">\boldsymbol{\gamma}</code>.
</p>
</dd>
<dt>order</dt><dd><p>numeric vector or matrix with order indeces of mixture
components related to artificial identifiability constraint
defined by a suitable re-labeling algorithm
(by default, simple ordering of the first component of the mixture
means is used).
</p>
<p>It is a matrix with <code class="reqn">K</code> columns when <code class="reqn">K</code> is
fixed. Otherwise it is a vector with orders put sequentially after
each other.</p>
</dd>
<dt>rank</dt><dd><p>numeric vector or matrix with rank indeces of mixture
components. related to artificial identifiability constraint
defined by a suitable re-labeling algorithm
(by default, simple ordering of the first component of the mixture
means is used).
</p>
<p>It is a matrix with <code class="reqn">K</code> columns when <code class="reqn">K</code> is
fixed. Otherwise it is a vector with ranks put sequentially after
each other.</p>
</dd>  
<dt>mixture</dt><dd><p><code>data.frame</code> with columns labeled
<code>y.Mean.*</code>, <code>y.SD.*</code>, <code>y.Corr.*.*</code>,
<code>z.Mean.*</code>, <code>z.SD.*</code>, <code>z.Corr.*.*</code> containing the
chains for the means, standard deviations and correlations of the
distribution of the original (<code>y</code>) and scaled (<code>z</code>) data
based on a normal mixture at each iteration.
</p>
</dd>
<dt>deviance</dt><dd><p><code>data.frame</code> with columns labeles
<code>LogL0</code>, <code>LogL1</code>, <code>dev.complete</code>, <code>dev.observed</code>
containing the chains of quantities needed to compute DIC.
</p>
</dd>  
<dt>pm.y</dt><dd><p>a <code>data.frame</code> with <code class="reqn">p</code> columns with posterior
means for (latent) values of observed data (useful when there is
censoring).</p>
</dd>
<dt>pm.z</dt><dd><p>a <code>data.frame</code> with <code class="reqn">p</code> columns with posterior
means for (latent) values of scaled observed data (useful when there is censoring).</p>
</dd>  
<dt>pm.indDev</dt><dd><p>a <code>data.frame</code> with columns labeled
<code>LogL0</code>, <code>LogL1</code>, <code>dev.complete</code>,
<code>dev.observed</code>, <code>pred.dens</code> containing posterior means of
individual contributions to the deviance.
</p>
</dd>
<dt>pred.dens</dt><dd><p>a numeric vector with the predictive density of the
data based on the MCMC sample evaluated at data points.
</p>
<p>Note that when there is censoring, this is not exactly the
predictive density as it is computed as the average of densities at
each iteration evaluated at sampled values of latent observations at
iterations.
</p>
</dd>
<dt>poster.comp.prob_u</dt><dd><p>a matrix which is present in the output object
if the number of mixture components in the distribution of random
effects is fixed and equal to <code class="reqn">K</code>. In that case,
<code>poster.comp.prob_u</code> is a matrix with <code class="reqn">K</code> columns and <code class="reqn">n</code>
rows with estimated posterior component probabilities
&ndash; posterior means of the components of the underlying 0/1
allocation vector.
</p>
<p><b>WARNING:</b> By default,
the labels of components are based on artificial
identifiability constraints based on ordering of the mixture means
in the first margin. Very often, such identifiability constraint is
not satisfactory!
</p>

</dd>
<dt>poster.comp.prob_b</dt><dd><p>a matrix which is present in the output object
if the number of mixture components in the distribution of random
effects is fixed and equal to <code class="reqn">K</code>. In that case,
<code>poster.comp.prob_b</code> is a matrix with <code class="reqn">K</code> columns and <code class="reqn">n</code>
rows  with estimated posterior component probabilities
&ndash; posterior mean over model parameters.
</p>
<p><b>WARNING:</b> By default, the labels of components are based on artificial
identifiability constraints based on ordering of the mixture means
in the first margin. Very often, such identifiability constraint is
not satisfactory!
</p>

</dd>    
<dt>summ.y.Mean</dt><dd><p>Posterior summary statistics based on chains stored
in <code>y.Mean.*</code> columns of the <code>data.frame</code> <code>mixture</code>.</p>
</dd>
<dt>summ.y.SDCorr</dt><dd><p>Posterior summary statistics based on chains
stored in <code>y.SD.*</code> and <code>y.Corr.*.*</code> columns of the
<code>data.frame</code> <code>mixture</code>.</p>
</dd>
<dt>summ.z.Mean</dt><dd><p>Posterior summary statistics based on chains stored
in <code>z.Mean.*</code> columns of the <code>data.frame</code> <code>mixture</code>.</p>
</dd>
<dt>summ.z.SDCorr</dt><dd><p>Posterior summary statistics based on chains
stored in <code>z.SD.*</code> and <code>z.Corr.*.*</code> columns of the <code>data.frame</code> <code>mixture</code>.</p>
</dd>  
<dt>poster.mean.w</dt><dd><p>a numeric vector with posterior means of mixture
weights after re-labeling. It is computed only if <code class="reqn">K</code> is fixed
and even then I am not convinced that these are useful posterior
summary statistics (see label switching problem mentioned above).
In any case, they should be used with care.</p>
</dd>  
<dt>poster.mean.mu</dt><dd><p>a matrix with posterior means of mixture
means after re-labeling. It is computed only if <code class="reqn">K</code> is fixed
and even then I am not convinced that these are useful posterior
summary statistics (see label switching problem mentioned above).
In any case, they should be used with care.</p>
</dd>
<dt>poster.mean.Q</dt><dd><p>a list with posterior means of mixture inverse
variances after re-labeling. It is computed only if <code class="reqn">K</code> is fixed
and even then I am not convinced that these are useful posterior
summary statistics (see label switching problem mentioned above).
In any case, they should be used with care.</p>
</dd>
<dt>poster.mean.Sigma</dt><dd><p>a list with posterior means of mixture
variances after re-labeling. It is computed only if <code class="reqn">K</code> is fixed
and even then I am not convinced that these are useful posterior
summary statistics (see label switching problem mentioned above).
In any case, they should be used with care.</p>
</dd>
<dt>poster.mean.Li</dt><dd><p>a list with posterior means of Cholesky
decompositions of mixture inverse variances after re-labeling.
It is computed only if <code class="reqn">K</code> is fixed
and even then I am not convinced that these are useful posterior
summary statistics (see label switching problem mentioned above).
In any case, they should be used with care.</p>
</dd>
<dt>relabel</dt><dd><p>a list which specifies the algorithm used to re-label
the MCMC output to compute <code>order</code>, <code>rank</code>, <code>poster.comp.prob_u</code>,
<code>poster.comp.prob_b</code>, <code>poster.mean.w</code>,
<code>poster.mean.mu</code>, <code>poster.mean.Q</code>,
<code>poster.mean.Sigma</code>, <code>poster.mean.Li</code>. 
</p>
</dd>
<dt>Cpar</dt><dd><p>a list with components useful to call underlying C++ functions (not
interesting for ordinary users).</p>
</dd>
</dl>



<h3>Object of class NMixMCMClist</h3>

<p>Object of class <code>NMixMCMClist</code> is the list having two components
of class <code>NMixMCMC</code> representing two parallel chains and
additionally the following components:
</p>

<dl>
<dt>PED</dt><dd><p>values of penalized expected deviance and related
quantities. It is a vector with five components: <code>D.expect</code> <code class="reqn">=</code>
estimated expected deviance, where the estimate is based on two
parallel chains; <code>popt</code> <code class="reqn">=</code> estimated penalty, where the
estimate is based on simple MCMC average based on two parallel
chains; <code>PED</code> <code class="reqn">=</code> estimated penalized expected deviance
<code class="reqn">=</code> <code>D.expect</code> <code class="reqn">+</code> <code>popt</code>; <code>wpopt</code> <code class="reqn">=</code>
estimated penalty, where the estimate is based on weighted MCMC average
(through importance sampling) based on two parallel chains;
<code>wPED</code> <code class="reqn">=</code> estimated penalized expected deviance <code class="reqn">=</code>
<code>D.expect</code> <code class="reqn">+</code> <code>wpopt</code>.</p>
</dd>
<dt>popt</dt><dd><p>contributions to the unweighted penalty from each observation.</p>
</dd>
<dt>wpopt</dt><dd><p>contributions to the weighted penalty from each observation.</p>
</dd>
<dt>inv.D</dt><dd><p>for each observation, number of iterations (in both chains), where the
deviance was in fact equal to infinity (when the corresponding
density was lower than <code>dens.zero</code>) and was not taken into account when
computing <code>D.expect</code>.</p>
</dd>
<dt>inv.popt</dt><dd><p>for each observation, number of iterations, where the
penalty was in fact equal to infinity and was not taken into account
when computing <code>popt</code>.
</p>
</dd>
<dt>inv.wpopt</dt><dd><p>for each observation, number of iterations, where the
importance sampling weight was in fact equal to infinity and was not taken into account
when computing <code>wpopt</code>.</p>
</dd>
<dt>sumISw</dt><dd><p>for each observation, sum of importance sampling
weights.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Celeux, G., Forbes, F., Robert, C. P., and Titterington, D. M. (2006).
Deviance information criteria for missing data models.
<em>Bayesian Analysis</em>, <b>1</b>(4), 651&ndash;674.
</p>
<p>Cappé, Robert and Rydén (2003).
Reversible jump, birth-and-death and more general continuous time Markov chain Monte Carlo samplers.
<em>Journal of the Royal Statistical Society, Series B</em>, <b>65</b>(3), 679&ndash;700.
</p>



<p>Diebolt, J. and Robert, C. P. (1994).
Estimation of finite mixture distributions through Bayesian sampling.
<em>Journal of the Royal Statistical Society, Series B</em>, <b>56</b>(2), 363&ndash;375.
</p>
<p>Jasra, A., Holmes, C. C., and Stephens, D. A. (2005).
Markov chain Monte Carlo methods and the label switching problem in
Bayesian mixture modelling.
<em>Statistical Science</em>, <b>20</b>(1), 50&ndash;67.
</p>
<p>Komárek, A. (2009).
A new R package for Bayesian estimation of multivariate normal mixtures allowing for selection 
of the number of components and interval-censored data.
<em>Computational Statistics and Data Analysis</em>, <b>53</b>(12), 3932&ndash;3947.
</p>
<p>Plummer, M. (2008).
Penalized loss functions for Bayesian model comparison.
<em>Biostatistics</em>, <b>9</b>(3), 523&ndash;539.
</p>
<p>Richardson, S. and Green, P. J. (1997).
On Bayesian analysis of mixtures with unknown number of components
(with Discussion).
<em>Journal of the Royal Statistical Society, Series B</em>, <b>59</b>(4), 731&ndash;792.
</p>
<p>Spiegelhalter, D. J.,Best, N. G., Carlin, B. P., and van der Linde, A. (2002).
Bayesian measures of model complexity and fit (with Discussion).
<em>Journal of the Royal Statistical Society, Series B</em>, <b>64</b>(4), 583&ndash;639.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixPredDensMarg">NMixPredDensMarg</a></code>, <code><a href="#topic+NMixPredDensJoint2">NMixPredDensJoint2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## See also additional material available in 
## YOUR_R_DIR/library/mixAK/doc/
## or YOUR_R_DIR/site-library/mixAK/doc/
## - files Galaxy.R, Faithful.R, Tandmob.R and
## https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/Galaxy.pdf
## https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/Faithful.pdf
## https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/Tandmob.pdf
##

## ==============================================

## Simple analysis of Anderson's iris data
## ==============================================
library("colorspace")

data(iris, package="datasets")
summary(iris)
VARS &lt;- names(iris)[1:4]
#COLS &lt;- rainbow_hcl(3, start = 60, end = 240)
COLS &lt;- c("red", "darkblue", "darkgreen")
names(COLS) &lt;- levels(iris[, "Species"])

### Prior distribution and the length of MCMC
Prior &lt;- list(priorK = "fixed", Kmax = 3)
nMCMC &lt;- c(burn=5000, keep=10000, thin=5, info=1000)

### Run MCMC
set.seed(20091230)
fit &lt;- NMixMCMC(y0 = iris[, VARS], prior = Prior, nMCMC = nMCMC)

### Basic posterior summary
print(fit)

### Univariate marginal posterior predictive densities
### based on chain #1
pdens1 &lt;- NMixPredDensMarg(fit[[1]], lgrid=150)
plot(pdens1)
plot(pdens1, main=VARS, xlab=VARS)

### Bivariate (for each pair of margins) predictive densities
### based on chain #1
pdens2a &lt;- NMixPredDensJoint2(fit[[1]])
plot(pdens2a)

plot(pdens2a, xylab=VARS)
plot(pdens2a, xylab=VARS, contour=TRUE)

### Determine the grid to compute bivariate densities
grid &lt;- list(Sepal.Length=seq(3.5, 8.5, length=75),
             Sepal.Width=seq(1.8, 4.5, length=75),
             Petal.Length=seq(0, 7, length=75),
             Petal.Width=seq(-0.2, 3, length=75))
pdens2b &lt;- NMixPredDensJoint2(fit[[1]], grid=grid)
plot(pdens2b, xylab=VARS)

### Plot with contours
ICOL &lt;- rev(heat_hcl(20, c=c(80, 30), l=c(30, 90), power=c(1/5, 2)))
oldPar &lt;- par(mfrow=c(2, 3), bty="n")
for (i in 1:3){
  for (j in (i+1):4){
    NAME &lt;- paste(i, "-", j, sep="")
    MAIN &lt;- paste(VARS[i], "x", VARS[j])
    image(pdens2b$x[[i]], pdens2b$x[[j]], pdens2b$dens[[NAME]], col=ICOL,
          xlab=VARS[i], ylab=VARS[j], main=MAIN)
    contour(pdens2b$x[[i]], pdens2b$x[[j]], pdens2b$dens[[NAME]], add=TRUE, col="brown4")
  }  
}  

### Plot with data
for (i in 1:3){
  for (j in (i+1):4){
    NAME &lt;- paste(i, "-", j, sep="")
    MAIN &lt;- paste(VARS[i], "x", VARS[j])
    image(pdens2b$x[[i]], pdens2b$x[[j]], pdens2b$dens[[NAME]], col=ICOL,
          xlab=VARS[i], ylab=VARS[j], main=MAIN)
    for (spec in levels(iris[, "Species"])){
      Data &lt;- subset(iris, Species==spec)
      points(Data[,i], Data[,j], pch=16, col=COLS[spec])
    }  
  }  
}  

### Set the graphical parameters back to their original values
par(oldPar)

### Clustering based on posterior summary statistics of component allocations
### or on the posterior distribution of component allocations
### (these are two equivalent estimators of probabilities of belonging
###  to each mixture components for each observation)
p1 &lt;- fit[[1]]$poster.comp.prob_u
p2 &lt;- fit[[1]]$poster.comp.prob_b

### Clustering based on posterior summary statistics of mixture weight, means, variances
p3 &lt;- NMixPlugDA(fit[[1]], iris[, VARS])
p3 &lt;- p3[, paste("prob", 1:3, sep="")]

  ### Observations from "setosa" species (all would be allocated in component 1)
apply(p1[1:50,], 2, quantile, prob=seq(0, 1, by=0.1))
apply(p2[1:50,], 2, quantile, prob=seq(0, 1, by=0.1))
apply(p3[1:50,], 2, quantile, prob=seq(0, 1, by=0.1))

  ### Observations from "versicolor" species (almost all would be allocated in component 2)
apply(p1[51:100,], 2, quantile, prob=seq(0, 1, by=0.1))
apply(p2[51:100,], 2, quantile, prob=seq(0, 1, by=0.1))
apply(p3[51:100,], 2, quantile, prob=seq(0, 1, by=0.1))

  ### Observations from "virginica" species (all would be allocated in component 3)
apply(p1[101:150,], 2, quantile, prob=seq(0, 1, by=0.1))
apply(p2[101:150,], 2, quantile, prob=seq(0, 1, by=0.1))
apply(p3[101:150,], 2, quantile, prob=seq(0, 1, by=0.1))

## End(Not run)
</code></pre>

<hr>
<h2 id='NMixMCMCdata'>
Data manipulation for the NMixMCMC function 
</h2><span id='topic+NMixMCMCdata'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> function.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixMCMCdata(y0, y1, censor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixMCMCdata_+3A_y0">y0</code></td>
<td>
<p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> function.</p>
</td></tr>
<tr><td><code id="NMixMCMCdata_+3A_y1">y1</code></td>
<td>
<p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> function.</p>
</td></tr>
<tr><td><code id="NMixMCMCdata_+3A_censor">censor</code></td>
<td>
<p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> function.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>y0</code></td>
<td>
<p>worked out value of <code>y0</code></p>
</td></tr>
<tr><td><code>y1</code></td>
<td>
<p>worked out value of <code>y1</code></p>
</td></tr>
<tr><td><code>censor</code></td>
<td>
<p>worked out value of <code>censor</code></p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>dimension of the response</p>
</td></tr>
<tr><td><code>LTp</code></td>
<td>
<p>length of the lower triangle of the <code class="reqn">p\times p</code> matrix</p>
</td></tr>
<tr><td><code>naamLTp</code></td>
<td>
<p>a character vector of length <code>LTp</code> with names
(indices) for elements of a lower triangle of the <code class="reqn">p\times p</code> matrix</p>
</td></tr>
<tr><td><code>are.Censored</code></td>
<td>
<p>logical value which indicates whether there are
censored observations in the data</p>
</td></tr>
<tr><td><code>are.Right</code></td>
<td>
<p>logical value which indicates whether there are
right-censored observations in the data</p>
</td></tr>
<tr><td><code>are.Exact</code></td>
<td>
<p>logical value which indicates whether there are
exact observations in the data</p>
</td></tr>
<tr><td><code>are.Left</code></td>
<td>
<p>logical value which indicates whether there are
left-censored observations in the data</p>
</td></tr>  
<tr><td><code>are.Interval</code></td>
<td>
<p>logical value which indicates whether there are
interval-censored observations in the data</p>
</td></tr>
<tr><td><code>is.Interval</code></td>
<td>
<p>a logical vector of length <code class="reqn">n</code> which indicates
whether a specific observation is interval-censored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='NMixMCMCinitr'>
Initial component allocations for the NMixMCMC function 
</h2><span id='topic+NMixMCMCinitr'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> function. If
<code>initr</code> is not given, it calculates reasonable initial values for
component allocations. If <code>initr</code> argument is given then it is
checked for consistency and formatted on output.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixMCMCinitr(z, K, w, mu, Sigma, p, n, initr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixMCMCinitr_+3A_z">z</code></td>
<td>
<p>a vector (if <code class="reqn">p=1</code>) or a <code class="reqn">n\times p</code> matrix
with initial values of scaled observations</p>
</td></tr>
<tr><td><code id="NMixMCMCinitr_+3A_k">K</code></td>
<td>
<p>a number of mixture components</p>
</td></tr>
<tr><td><code id="NMixMCMCinitr_+3A_w">w</code></td>
<td>
<p>a vector with (initial) mixture weights</p>
</td></tr>
<tr><td><code id="NMixMCMCinitr_+3A_mu">mu</code></td>
<td>
<p>a vector of (initial) mixture means (if <code class="reqn">p=1</code>) or a
<code class="reqn">K\times p</code> matrix with (initial) mixture means in rows
(if <code class="reqn">p&gt;1</code>)</p>
</td></tr>
<tr><td><code id="NMixMCMCinitr_+3A_sigma">Sigma</code></td>
<td>
<p>a vector of (initial) mixture variances (if <code class="reqn">p=1</code>) or
a <code class="reqn">K\,p\times p</code> matrix with (initial) mixture
covariance matrices put below each other</p>
</td></tr>
<tr><td><code id="NMixMCMCinitr_+3A_p">p</code></td>
<td>
<p>dimension of the data</p>
</td></tr>  
<tr><td><code id="NMixMCMCinitr_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="NMixMCMCinitr_+3A_initr">initr</code></td>
<td>
<p>a vector of initial component allocations to be checked
for consistency. If not given then reasonable initials are generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with reasonable initial component allocations.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='NMixMCMCinity'>
Initial values of censored observations for the NMixMCMC function 
</h2><span id='topic+NMixMCMCinity'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> function. If
<code>inity</code> is not given, it calculates reasonable initial values for
censored observations. If <code>inity</code> argument is given then it is
checked for consistency and formatted on output.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixMCMCinity(y0, y1, censor, sd.init,
   are.Censored, are.Right, are.Exact, are.Left, are.Interval,
   p, n, inity, random=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixMCMCinity_+3A_y0">y0</code></td>
<td>
<p>see output from <code><a href="#topic+NMixMCMCdata">NMixMCMCdata</a></code></p>
</td></tr>
<tr><td><code id="NMixMCMCinity_+3A_y1">y1</code></td>
<td>
<p>see output from <code><a href="#topic+NMixMCMCdata">NMixMCMCdata</a></code></p>
</td></tr>
<tr><td><code id="NMixMCMCinity_+3A_censor">censor</code></td>
<td>
<p>see output from <code><a href="#topic+NMixMCMCdata">NMixMCMCdata</a></code></p>
</td></tr>  
<tr><td><code id="NMixMCMCinity_+3A_sd.init">sd.init</code></td>
<td>
<p>a vector of length <code class="reqn">p</code> with initial values for
overall standard deviations in each margin</p>
</td></tr>
<tr><td><code id="NMixMCMCinity_+3A_are.censored">are.Censored</code></td>
<td>
<p>see output from <code><a href="#topic+NMixMCMCdata">NMixMCMCdata</a></code></p>
</td></tr>
<tr><td><code id="NMixMCMCinity_+3A_are.right">are.Right</code></td>
<td>
<p>see output from <code><a href="#topic+NMixMCMCdata">NMixMCMCdata</a></code></p>
</td></tr> 
<tr><td><code id="NMixMCMCinity_+3A_are.exact">are.Exact</code></td>
<td>
<p>see output from <code><a href="#topic+NMixMCMCdata">NMixMCMCdata</a></code></p>
</td></tr>
<tr><td><code id="NMixMCMCinity_+3A_are.left">are.Left</code></td>
<td>
<p>see output from <code><a href="#topic+NMixMCMCdata">NMixMCMCdata</a></code></p>
</td></tr>
<tr><td><code id="NMixMCMCinity_+3A_are.interval">are.Interval</code></td>
<td>
<p>see output from <code><a href="#topic+NMixMCMCdata">NMixMCMCdata</a></code></p>
</td></tr>      
<tr><td><code id="NMixMCMCinity_+3A_p">p</code></td>
<td>
<p>dimension of the data</p>
</td></tr>  
<tr><td><code id="NMixMCMCinity_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="NMixMCMCinity_+3A_inity">inity</code></td>
<td>
<p>a vector (if <code class="reqn">p=1</code>) or a <code class="reqn">n\times p</code> matrix
(if <code class="reqn">p \geq 1</code>) of initial values of censored observations to be checked
for consistency. If not given then reasonable initials are
generated.</p>
</td></tr>
<tr><td><code id="NMixMCMCinity_+3A_random">random</code></td>
<td>
<p>logical value. If <code>TRUE</code> then some randomness is
used when generating initial values.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A <code class="reqn">n\times p</code> matrix with reasonable initial values for
censored observations.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='NMixMCMCwrapper'>
Wrapper to the NMixMCMC main simulation.
</h2><span id='topic+NMixMCMCwrapper'></span>

<h3>Description</h3>

<p>This is wrapper to the NMixMCMC main simulation which allows
vectorized evaluation and possibly parallel computation.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixMCMCwrapper(chain = 1,
                scale, prior, inits, Cpar, RJMCMC, CRJMCMC,
                actionAll, nMCMC, keep.chains, PED,
                dens.zero, lx_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixMCMCwrapper_+3A_chain">chain</code></td>
<td>
<p>identification of the chain sampled in a particular call
of this function, usually number like 1, 2, ...</p>
</td></tr>
<tr><td><code id="NMixMCMCwrapper_+3A_cpar">Cpar</code></td>
<td>
<p>a list with the following components
</p>

<dl>
<dt>z0</dt><dd><p><code class="reqn">n\times p</code> matrix with shifted and scaled main limits
of observed intervals.</p>
</dd>
<dt>z0</dt><dd><p><code class="reqn">n\times p</code> matrix with shifted and scaled upper
limits of observed intervals.</p>
</dd>
<dt>censor</dt><dd><p><code class="reqn">n\times p</code> matrix with censoring indicators.</p>
</dd>
<dt>p</dt><dd><p>dimension of the response.</p>
</dd>
<dt>n</dt><dd><p>number of observations.</p>
</dd>
<dt>Cinteger</dt><dd><p>a numeric vector with integer prior parameters.</p>
</dd>
<dt>Cdouble</dt><dd><p>a numeric vector with double precission prior
parameters.</p>
</dd> 
<dt>lx_w</dt><dd><p>a character vector with levels of an optional factor
covariate on the mixture weights.</p>
</dd>
</dl>
  
</td></tr>  
<tr><td><code id="NMixMCMCwrapper_+3A_scale">scale</code></td>
<td>
<p>a list specifying how to scale the data before running
MCMC. See argument <code>scale</code> in <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>
</p>
</td></tr>
<tr><td><code id="NMixMCMCwrapper_+3A_prior">prior</code></td>
<td>
<p>a list specifying prior hyperparameters. See argument
<code>prior</code> in <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>
</td></tr>
<tr><td><code id="NMixMCMCwrapper_+3A_inits">inits</code></td>
<td>
<p>a list of length at least <code>chain</code>. Its
<code>chain</code>-th component is used. Each component of the list should
have the structure of <code>init</code> argument of function
<code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>
</td></tr>
<tr><td><code id="NMixMCMCwrapper_+3A_rjmcmc">RJMCMC</code></td>
<td>
<p>a list specifying parameters for RJ-MCMC.
See argument <code>RJMCMC</code> in <code><a href="#topic+NMixMCMC">NMixMCMC</a></code></p>
</td></tr>
<tr><td><code id="NMixMCMCwrapper_+3A_crjmcmc">CRJMCMC</code></td>
<td>
<p>a numeric vector with parameters for RJ-MCMC.</p>
</td></tr>
<tr><td><code id="NMixMCMCwrapper_+3A_actionall">actionAll</code></td>
<td>
<p>argument for underlying C++ function.</p>
</td></tr>
<tr><td><code id="NMixMCMCwrapper_+3A_nmcmc">nMCMC</code></td>
<td>
<p>vector giving the length of MCMC etc.</p>
</td></tr>
<tr><td><code id="NMixMCMCwrapper_+3A_keep.chains">keep.chains</code></td>
<td>
<p>logical. If <code>FALSE</code>, only summary statistics
are returned in the resulting object. This might be useful in the
model searching step to save some memory.</p>
</td></tr>
<tr><td><code id="NMixMCMCwrapper_+3A_ped">PED</code></td>
<td>
<p>a logical value which indicates whether the penalized
expected deviance (see Plummer, 2008 for more details)
will be computed (which requires two parallel
chains). Even if <code>keep.chains</code> is <code>FALSE</code>, it is necessary
to keep (for a while) at least some chains to compute PED.
</p>
</td></tr>
<tr><td><code id="NMixMCMCwrapper_+3A_dens.zero">dens.zero</code></td>
<td>
<p>small number (1e-300) to determine whether the
contribution to the deviance (<code class="reqn">-\log</code> density) is equal to
infinity. Such values are trimmed when computing expected deviance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list having almost the same components as object returned by
<code><a href="#topic+NMixMCMC">NMixMCMC</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='NMixPlugCondDensJoint2'>
Pairwise bivariate conditional densities: plug-in estimate
</h2><span id='topic+NMixPlugCondDensJoint2'></span><span id='topic+NMixPlugCondDensJoint2.default'></span><span id='topic+NMixPlugCondDensJoint2.NMixMCMC'></span><span id='topic+NMixPlugCondDensJoint2.GLMM_MCMC'></span>

<h3>Description</h3>

<p>This function serves as an inference tool for the MCMC output
obtained using the function <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>. It computes
estimates of pairwise bivariate conditional densities (given one margin)
obtained by using posterior summary statistics (e.g., posterior means)
of mixture weights, means and variances (plug-in estimate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPlugCondDensJoint2(x, ...)

## Default S3 method:
NMixPlugCondDensJoint2(x, icond, scale, w, mu, Sigma, ...)

## S3 method for class 'NMixMCMC'
NMixPlugCondDensJoint2(x, icond, grid, lgrid=50, scaled=FALSE, ...)

## S3 method for class 'GLMM_MCMC'
NMixPlugCondDensJoint2(x, icond, grid, lgrid=50, scaled=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPlugCondDensJoint2_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> for
<code>NMixPlugCondDensJoint2.NMixMCMC</code> function.
</p>
<p>An object of class <code>GLMM_MCMC</code> for
<code>NMixPlugCondDensJoint2.GLMM_MCMC</code> function.
</p>
<p>A list with the grid values (see below) for
<code>NMixPlugCondDensJoint2.default</code> function.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensJoint2_+3A_icond">icond</code></td>
<td>
<p>index of the margin by which we want to condition
</p>
</td></tr> 
<tr><td><code id="NMixPlugCondDensJoint2_+3A_scale">scale</code></td>
<td>
<p>a two component list giving the <code>shift</code> and the
<code>scale</code>. If not given, shift is equal to zero and scale is
equal to one.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensJoint2_+3A_w">w</code></td>
<td>
<p>a numeric vector with posterior summary statistics for the
mixture weights. The length of this vector determines the number of
mixture components.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensJoint2_+3A_mu">mu</code></td>
<td>
<p>a matrix with posterior summary statistics for
mixture means in rows. That is, <code>mu</code> has
<code class="reqn">K</code> rows and <code class="reqn">p</code> columns, where <code class="reqn">K</code> denotes the number
of mixture components and <code class="reqn">p</code> is dimension of the mixture
distribution.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensJoint2_+3A_sigma">Sigma</code></td>
<td>
<p>a list with posterior summary statistics for mixture covariance matrices.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensJoint2_+3A_grid">grid</code></td>
<td>
<p>a list with the grid values for each margin in which
the density should be evaluated. The value of <code>grid[[icond]]</code>
determines the values by which we condition.
</p>
<p>If <code>grid</code> is not specified, it is created automatically using
the information from the posterior summary statistics stored in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensJoint2_+3A_lgrid">lgrid</code></td>
<td>
<p>a length of the grid used to create the <code>grid</code> if
that is not specified.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensJoint2_+3A_scaled">scaled</code></td>
<td>
<p>if <code>TRUE</code>, the density of shifted and scaled data is
summarized. The shift and scale vector are taken from the
<code>scale</code> component of the object <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensJoint2_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>      
</table>


<h3>Value</h3>

<p>An object of class <code>NMixPlugCondDensJoint2</code> which has the
following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a list with the grid values for each margin. The components
of the list are named <code>x1</code>, ... or take names from
<code>grid</code> argument.</p>
</td></tr>
<tr><td><code>icond</code></td>
<td>
<p>index of the margin by which we condition.</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>a list with the computed conditional densities for each
value of <code>x[[icond]]</code>. Each <code>dens[[j]]</code> is again a list
with conditional densities for each pair of margins given margin
<code>icond</code> equal to <code>x[[icond]][j]</code>.
The value of <code>dens[[j]][[i-k]]</code> gives values
of conditional density of the (i,k)-th margins given margin
<code>icond</code> equal to <code>x[[icond]][j]</code>.
</p>
</td></tr>    
</table>
<p>There is also a <code>plot</code> method implemented for the resulting object.  
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.NMixPlugCondDensJoint2">plot.NMixPlugCondDensJoint2</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>, <code><a href="#topic+NMixPredCondDensJoint2">NMixPredCondDensJoint2</a></code>.
</p>

<hr>
<h2 id='NMixPlugCondDensMarg'>
Univariate conditional densities: plug-in estimate
</h2><span id='topic+NMixPlugCondDensMarg'></span><span id='topic+NMixPlugCondDensMarg.default'></span><span id='topic+NMixPlugCondDensMarg.NMixMCMC'></span><span id='topic+NMixPlugCondDensMarg.GLMM_MCMC'></span>

<h3>Description</h3>

<p>This function serves as an inference tool for the MCMC output
obtained using the function <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>. It computes
estimates of univariate conditional densities obtained by using posterior
summary statistics (e.g., posterior means) of mixture weights, means
and variances (plug-in estimate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPlugCondDensMarg(x, ...)

## Default S3 method:
NMixPlugCondDensMarg(x, icond, scale, w, mu, Sigma, ...)

## S3 method for class 'NMixMCMC'
NMixPlugCondDensMarg(x, icond, grid, lgrid=50, scaled=FALSE, ...)

## S3 method for class 'GLMM_MCMC'
NMixPlugCondDensMarg(x, icond, grid, lgrid=50, scaled=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPlugCondDensMarg_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> for
<code>NMixPlugCondDensMarg.NMixMCMC</code> function.
</p>
<p>An object of class <code>GLMM_MCMC</code> for
<code>NMixPlugCondDensMarg.GLMM_MCMC</code> function.
</p>
<p>A list with the grid values (see below) for
<code>NMixPlugCondDensMarg.default</code> function.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensMarg_+3A_icond">icond</code></td>
<td>
<p>index of the margin by which we want to condition
</p>
</td></tr> 
<tr><td><code id="NMixPlugCondDensMarg_+3A_scale">scale</code></td>
<td>
<p>a two component list giving the <code>shift</code> and the
<code>scale</code>. If not given, shift is equal to zero and scale is
equal to one.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensMarg_+3A_w">w</code></td>
<td>
<p>a numeric vector with posterior summary statistics for the
mixture weights. The length of this vector determines the number of
mixture components.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensMarg_+3A_mu">mu</code></td>
<td>
<p>a matrix with posterior summary statistics for
mixture means in rows. That is, <code>mu</code> has
<code class="reqn">K</code> rows and <code class="reqn">p</code> columns, where <code class="reqn">K</code> denotes the number
of mixture components and <code class="reqn">p</code> is dimension of the mixture
distribution.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensMarg_+3A_sigma">Sigma</code></td>
<td>
<p>a list with posterior summary statistics for mixture covariance matrices.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensMarg_+3A_grid">grid</code></td>
<td>
<p>a list with the grid values for each margin in which
the density should be evaluated. The value of <code>grid[[icond]]</code>
determines the values by which we condition.
</p>
<p>If <code>grid</code> is not specified, it is created automatically using
the information from the posterior summary statistics stored in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensMarg_+3A_lgrid">lgrid</code></td>
<td>
<p>a length of the grid used to create the <code>grid</code> if
that is not specified.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensMarg_+3A_scaled">scaled</code></td>
<td>
<p>if <code>TRUE</code>, the density of shifted and scaled data is
summarized. The shift and scale vector are taken from the
<code>scale</code> component of the object <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPlugCondDensMarg_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>An object of class <code>NMixPlugCondDensMarg</code> which has the following components:  
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a list with the grid values for each margin. The components
of the list are named <code>x1</code>, ... or take names from
<code>grid</code> argument.</p>
</td></tr>
<tr><td><code>icond</code></td>
<td>
<p>index of the margin by which we condition.</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>a list with the computed conditional densities for each
value of <code>x[[icond]]</code>. Each <code>dens[[j]]</code> is again a list
with conditional densities for each margin given margin
<code>icond</code> equal to <code>x[[icond]][j]</code>.
The value of <code>dens[[j]][[imargin]]</code> gives a value
of a marginal density of the <code>imargin</code>-th margin at <code>x[[icond]][j]</code>.
</p>
</td></tr>    
</table>
<p>There is also a <code>plot</code> method implemented for the resulting object.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.NMixPlugCondDensMarg">plot.NMixPlugCondDensMarg</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>, <code><a href="#topic+NMixPredCondDensMarg">NMixPredCondDensMarg</a></code>.
</p>

<hr>
<h2 id='NMixPlugDA'>
Discriminant analysis based on plug-in estimates from the mixture model
</h2><span id='topic+NMixPlugDA'></span>

<h3>Description</h3>

<p>It performs discriminant analysis based on 
posterior summary for (re-labeled) mixture
components in a model with fixed number of components fitted with
<code><a href="#topic+NMixMCMC">NMixMCMC</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPlugDA(object, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPlugDA_+3A_object">object</code></td>
<td>
<p>an object of class <code>NMixMCMC</code></p>
</td></tr>
<tr><td><code id="NMixPlugDA_+3A_y">y</code></td>
<td>
<p>vector, matrix or data frame with observations to be clustered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with 
columns labeled <code>prob1</code>,..., <code>probp</code> giving
plug-in estimates of probabilities of belonging to each component and a column
labeled <code>component</code> giving the index of the component with the
highest component probability.  
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+NMixPredDA">NMixPredDA</a></code>.
</p>

<hr>
<h2 id='NMixPlugDensJoint2'>
Pairwise bivariate densities: plug-in estimate
</h2><span id='topic+NMixPlugDensJoint2'></span><span id='topic+NMixPlugDensJoint2.default'></span><span id='topic+NMixPlugDensJoint2.NMixMCMC'></span><span id='topic+NMixPlugDensJoint2.GLMM_MCMC'></span>

<h3>Description</h3>

<p>This function serves as an inference tool for the MCMC output
obtained using the function <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>. It computes
marginal (pairwise bivariate) plug-in densities obtained by using posterior
summary statistics (e.g., posterior means) of mixture weights, means
and variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPlugDensJoint2(x, ...)

## Default S3 method:
NMixPlugDensJoint2(x, scale, w, mu, Sigma, ...)

## S3 method for class 'NMixMCMC'
NMixPlugDensJoint2(x, grid, lgrid=50, scaled=FALSE, ...)

## S3 method for class 'GLMM_MCMC'
NMixPlugDensJoint2(x, grid, lgrid=50, scaled=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPlugDensJoint2_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> for
<code>NMixPlugDensJoint2.NMixMCMC</code> function.
</p>
<p>An object of class <code>GLMM_MCMC</code> for
<code>NMixPlugDensJoint2.GLMM_MCMC</code> function.
</p>
<p>A list with the grid values (see below) for
<code>NMixPlugDensJoint2.default</code> function.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensJoint2_+3A_scale">scale</code></td>
<td>
<p>a two component list giving the <code>shift</code> and the
<code>scale</code>. If not given, shift is equal to zero and scale is
equal to one.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensJoint2_+3A_w">w</code></td>
<td>
<p>a numeric vector with posterior summary statistics for the
mixture weights. The length of this vector determines the number of
mixture components.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensJoint2_+3A_mu">mu</code></td>
<td>
<p>a matrix with posterior summary statistics for
mixture means in rows. That is, <code>mu</code> has
<code class="reqn">K</code> rows and <code class="reqn">p</code> columns, where <code class="reqn">K</code> denotes the number
of mixture components and <code class="reqn">p</code> is dimension of the mixture
distribution.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensJoint2_+3A_sigma">Sigma</code></td>
<td>
<p>a list with posterior summary statistics for for mixture covariance matrices.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensJoint2_+3A_grid">grid</code></td>
<td>
<p>a list with the grid values for each margin in which
the density should be evaluated.
</p>
<p>If <code>grid</code> is not specified, it is created automatically using
the information from the posterior summary statistics stored in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensJoint2_+3A_lgrid">lgrid</code></td>
<td>
<p>a length of the grid used to create the <code>grid</code> if
that is not specified.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensJoint2_+3A_scaled">scaled</code></td>
<td>
<p>if <code>TRUE</code>, the density of shifted and scaled data is
summarized. The shift and scale vector are taken from the
<code>scale</code> component of the object <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensJoint2_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>An object of class <code>NMixPlugDensJoint2</code> which has the following components:  
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a list with the grid values for each margin. The components
of the list are named <code>x1</code>, ... or take names from
<code>grid</code> argument.</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>a list with the computed densities for each
pair of margins. The components of the list are named <code>1-2</code>,
<code>1-3</code>, ..., i.e.,
<code>dens[[1]]</code><code class="reqn">=</code><code>dens[["1-2"]]</code> is the pairwise predictive
density for margins 1 and 2, etc. Each component of the <code>list</code>
is a matrix in such a form that it can be directly passed together
with the proper components of <code>x</code> to the plotting functions
like <code><a href="graphics.html#topic+contour">contour</a></code> or <code><a href="graphics.html#topic+image">image</a></code>.
</p>
</td></tr>
</table>
<p>There is also a <code>plot</code> method implemented for the resulting object.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.NMixPlugDensJoint2">plot.NMixPlugDensJoint2</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>, <code><a href="#topic+NMixPredDensJoint2">NMixPredDensJoint2</a></code>.
</p>

<hr>
<h2 id='NMixPlugDensMarg'>
Marginal (univariate) densities: plug-in estimate
</h2><span id='topic+NMixPlugDensMarg'></span><span id='topic+NMixPlugDensMarg.default'></span><span id='topic+NMixPlugDensMarg.NMixMCMC'></span><span id='topic+NMixPlugDensMarg.GLMM_MCMC'></span>

<h3>Description</h3>

<p>This function serves as an inference tool for the MCMC output
obtained using the function <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>. It computes
marginal (univariate) plug-in densities obtained by using posterior
summary statistics (e.g., posterior means) of mixture weights, means
and variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPlugDensMarg(x, ...)

## Default S3 method:
NMixPlugDensMarg(x, scale, w, mu, Sigma, ...)

## S3 method for class 'NMixMCMC'
NMixPlugDensMarg(x, grid, lgrid=500, scaled=FALSE, ...)

## S3 method for class 'GLMM_MCMC'
NMixPlugDensMarg(x, grid, lgrid=500, scaled=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPlugDensMarg_+3A_x">x</code></td>
<td>
<p>a list with the grid values (see below) for
<code>NMixPlugDensMarg.default</code> function.
</p>
<p>An object of class <code>NMixMCMC</code> for
<code>NMixPlugDensMarg.NMixMCMC</code> function.
</p>
<p>An object of class <code>GLMM_MCMC</code> for
<code>NMixPlugDensMarg.GLMM_MCMC</code> function.    
</p>
</td></tr>
<tr><td><code id="NMixPlugDensMarg_+3A_scale">scale</code></td>
<td>
<p>a two component list giving the <code>shift</code> and the
<code>scale</code>. If not given, shift is equal to zero and scale is
equal to one.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensMarg_+3A_w">w</code></td>
<td>
<p>a numeric vector with posterior summary statistics for the
mixture weights. The length of this vector determines the number of
mixture components.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensMarg_+3A_mu">mu</code></td>
<td>
<p>a matrix with posterior summary statistics for
mixture means in rows. That is, <code>mu</code> has
<code class="reqn">K</code> rows and <code class="reqn">p</code> columns, where <code class="reqn">K</code> denotes the number
of mixture components and <code class="reqn">p</code> is dimension of the mixture
distribution.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensMarg_+3A_sigma">Sigma</code></td>
<td>
<p>a list with posterior summary statistics for mixture covariance matrices.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensMarg_+3A_grid">grid</code></td>
<td>
<p>a list with the grid values for each margin in which
the density should be evaluated.
</p>
<p>If <code>grid</code> is not specified, it is created automatically using
the information from the posterior summary statistics stored in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensMarg_+3A_lgrid">lgrid</code></td>
<td>
<p>a length of the grid used to create the <code>grid</code> if
that is not specified.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensMarg_+3A_scaled">scaled</code></td>
<td>
<p>if <code>TRUE</code>, the density of shifted and scaled data is
summarized. The shift and scale vector are taken from the
<code>scale</code> component of the object <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPlugDensMarg_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>An object of class <code>NMixPlugDensMarg</code> which has the following components:  
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a list with the grid values for each margin. The components
of the list are named <code>x1</code>, ... or take names from
<code>grid</code> argument.</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>a list with the computed densities for each
margin. The components of the list are named <code>1</code>, ..., i.e.,
<code>dens[[1]]</code><code class="reqn">=</code><code>dens[["1"]]</code> is the predictive
density for margin 1 etc.</p>
</td></tr>
</table>
<p>There is also a <code>plot</code> method implemented for the resulting object.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.NMixPlugDensMarg">plot.NMixPlugDensMarg</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>,
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>, <code><a href="#topic+NMixPredDensMarg">NMixPredDensMarg</a></code>.
</p>

<hr>
<h2 id='NMixPredCDFMarg'>
Marginal (univariate) predictive cumulative distribution function
</h2><span id='topic+NMixPredCDFMarg'></span><span id='topic+NMixPredCDFMarg.default'></span><span id='topic+NMixPredCDFMarg.NMixMCMC'></span><span id='topic+NMixPredCDFMarg.GLMM_MCMC'></span><span id='topic+C_NMix_PredCDFMarg'></span>

<h3>Description</h3>

<p>This function serves as an inference tool for the MCMC output
obtained using the function <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>. It computes
estimated posterior predictive cumulative distribution function for each margin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPredCDFMarg(x, ...)

## Default S3 method:
NMixPredCDFMarg(x, scale, K, w, mu, Li, Krandom=TRUE, ...)

## S3 method for class 'NMixMCMC'
NMixPredCDFMarg(x, grid, lgrid=500, scaled=FALSE, ...)

## S3 method for class 'GLMM_MCMC'
NMixPredCDFMarg(x, grid, lgrid=500, scaled=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPredCDFMarg_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> for
<code>NMixPredCDFMarg.NMixMCMC</code> function.
</p>
<p>An object of class <code>GLMM_MCMC</code> for
<code>NMixPredCDFMarg.GLMM_MCMC</code> function.
</p>
<p>A list with the grid values (see below) for
<code>NMixPredCDFMarg.default</code> function.
</p>
</td></tr>
<tr><td><code id="NMixPredCDFMarg_+3A_scale">scale</code></td>
<td>
<p>a two component list giving the <code>shift</code> and the <code>scale</code>.</p>
</td></tr>
<tr><td><code id="NMixPredCDFMarg_+3A_k">K</code></td>
<td>
<p>either a number (when <code>Krandom</code><code class="reqn">=</code><code>FALSE</code>) or a
numeric vector with the chain for the number of mixture components.</p>
</td></tr>
<tr><td><code id="NMixPredCDFMarg_+3A_w">w</code></td>
<td>
<p>a numeric vector with the chain for the mixture weights.</p>
</td></tr>
<tr><td><code id="NMixPredCDFMarg_+3A_mu">mu</code></td>
<td>
<p>a numeric vector with the chain for the mixture means.</p>
</td></tr>
<tr><td><code id="NMixPredCDFMarg_+3A_li">Li</code></td>
<td>
<p>a numeric vector with the chain for the mixture inverse
variances (lower triangles only).</p>
</td></tr>
<tr><td><code id="NMixPredCDFMarg_+3A_krandom">Krandom</code></td>
<td>
<p>a logical value which indicates whether the number of
mixture components changes from one iteration to another.</p>
</td></tr>
<tr><td><code id="NMixPredCDFMarg_+3A_grid">grid</code></td>
<td>
<p>a numeric vector or a list with the grid values in which
the predictive CDF should be evaluated.
</p>
<p>If <code>x$dim</code> is 1 then <code>grid</code> may be a numeric vector. If
<code>x$dim</code> is higher than then <code>grid</code> must be a list with
numeric vectors as components giving the grids for each margin.
</p>
<p>If <code>grid</code> is not specified, it is created automatically using
the information from the posterior summary statistics stored in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPredCDFMarg_+3A_lgrid">lgrid</code></td>
<td>
<p>a length of the grid used to create the <code>grid</code> if
that is not specified.</p>
</td></tr>
<tr><td><code id="NMixPredCDFMarg_+3A_scaled">scaled</code></td>
<td>
<p>if <code>TRUE</code>, the CDF of shifted and scaled data is
summarized. The shift and scale vector are taken from the
<code>scale</code> component of the object <code>x</code>.</p>
</td></tr>
<tr><td><code id="NMixPredCDFMarg_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>NMixPredCDFMarg</code> which has the following components:  
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a list with the grid values for each margin. The components
of the list are named <code>x1</code>, ... or take names from
<code>grid</code> argument.</p>
</td></tr>
<tr><td><code>freqK</code></td>
<td>
<p>frequency table for the values of <code class="reqn">K</code> (numbers of
mixture components) in the MCMC chain.</p>
</td></tr>
<tr><td><code>propK</code></td>
<td>
<p>proportions derived from <code>freqK</code>.</p>
</td></tr>
<tr><td><code>MCMC.length</code></td>
<td>
<p>the length of the MCMC used to compute the
predictive cdf's.</p>
</td></tr>
<tr><td><code>cdf</code></td>
<td>
<p>a list with the computed predictive CDF's for each
margin. The components of the list are named <code>1</code>, ..., i.e.,
<code>cdf[[1]]</code><code class="reqn">=</code><code>cdf[["1"]]</code> is the predictive
cdf for margin 1 etc.</p>
</td></tr>
<tr><td><code>cdfK</code></td>
<td>
<p>a list with the computed predictive CDF's for each
margin, conditioned further by <code class="reqn">K</code>. The components of the list
are named <code>1</code>, .... That is,
<code>cdf[[1]][[1]]</code> <code class="reqn">=</code> <code>cdf[["1"]][[1]]</code> is the predictive
CDF for margin 1 conditioned by <code class="reqn">K=1</code>,
<code>cdf[[1]][[2]]</code> <code class="reqn">=</code> <code>cdf[["1"]][[2]]</code> is the predictive
CDF for margin 1 conditioned by <code class="reqn">K=2</code> etc.
</p>
<p>Note that <code>cdfK</code> provides some additional information only
when <code>Krandom</code> <code class="reqn">=</code> <code>TRUE</code> or when <code>x</code> results from
the <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> call to the reversible jump MCMC.
</p>
</td></tr>
</table>
<p>There is also a <code>plot</code> method implemented for the resulting object.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2009).  
A new R package for Bayesian estimation of multivariate normal mixtures allowing for selection 
of the number of components and interval-censored data.
<em>Computational Statistics and Data Analysis</em>, <b>53</b>(12), 3932&ndash;3947.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.NMixPredCDFMarg">plot.NMixPredCDFMarg</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='NMixPredCondCDFMarg'>
Univariate conditional predictive cumulative distribution function
</h2><span id='topic+NMixPredCondCDFMarg'></span><span id='topic+NMixPredCondCDFMarg.default'></span><span id='topic+NMixPredCondCDFMarg.NMixMCMC'></span><span id='topic+NMixPredCondCDFMarg.GLMM_MCMC'></span>

<h3>Description</h3>

<p>This function serves as an inference tool for the MCMC output
obtained using the function <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>. It computes
(posterior predictive) estimates of univariate conditional cumulative distribution functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPredCondCDFMarg(x, ...)

## Default S3 method:
NMixPredCondCDFMarg(x, icond, prob, scale, K, w, mu, Li, Krandom=FALSE, ...)

## S3 method for class 'NMixMCMC'
NMixPredCondCDFMarg(x, icond, prob, grid, lgrid=50, scaled=FALSE, ...)

## S3 method for class 'GLMM_MCMC'
NMixPredCondCDFMarg(x, icond, prob, grid, lgrid=50, scaled=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPredCondCDFMarg_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> for
<code>NMixPredCondCDFMarg.NMixMCMC</code> function.
</p>
<p>An object of class <code>GLMM_MCMC</code> for
<code>NMixPredCondCDFMarg.GLMM_MCMC</code> function.
</p>
<p>A list with the grid values (see below) for
<code>NMixPredCondCDFMarg.default</code> function.
</p>
</td></tr>
<tr><td><code id="NMixPredCondCDFMarg_+3A_icond">icond</code></td>
<td>
<p>index of the margin by which we want to condition
</p>
</td></tr>
<tr><td><code id="NMixPredCondCDFMarg_+3A_prob">prob</code></td>
<td>
<p>a numeric vector. If given then also the posterior
pointwise quantiles of the conditional cdf's are computed for
probabilities given by <code>prob</code>. These can be used to draw
pointwise credible intervals.
</p>
</td></tr>    
<tr><td><code id="NMixPredCondCDFMarg_+3A_scale">scale</code></td>
<td>
<p>a two component list giving the <code>shift</code> and the
<code>scale</code>. If not given, shift is equal to zero and scale is
equal to one.
</p>
</td></tr>
<tr><td><code id="NMixPredCondCDFMarg_+3A_k">K</code></td>
<td>
<p>either a number (when <code>Krandom</code><code class="reqn">=</code><code>FALSE</code>) or a
numeric vector with the chain for the number of mixture components.
</p>
</td></tr>
<tr><td><code id="NMixPredCondCDFMarg_+3A_w">w</code></td>
<td>
<p>a numeric vector with the chain for the mixture weights.
</p>
</td></tr>
<tr><td><code id="NMixPredCondCDFMarg_+3A_mu">mu</code></td>
<td>
<p>a numeric vector with the chain for the mixture means.
</p>
</td></tr>
<tr><td><code id="NMixPredCondCDFMarg_+3A_li">Li</code></td>
<td>
<p>a numeric vector with the chain for the mixture inverse
variances (lower triangles only).
</p>
</td></tr>
<tr><td><code id="NMixPredCondCDFMarg_+3A_krandom">Krandom</code></td>
<td>
<p>a logical value which indicates whether the number of
mixture components changes from one iteration to another.
</p>
</td></tr>  
<tr><td><code id="NMixPredCondCDFMarg_+3A_grid">grid</code></td>
<td>
<p>a list with the grid values for each margin in which
the cdf should be evaluated. The value of <code>grid[[icond]]</code>
determines the values by which we condition.
</p>
<p>If <code>grid</code> is not specified, it is created automatically using
the information from the posterior summary statistics stored in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPredCondCDFMarg_+3A_lgrid">lgrid</code></td>
<td>
<p>a length of the grid used to create the <code>grid</code> if
that is not specified.
</p>
</td></tr>
<tr><td><code id="NMixPredCondCDFMarg_+3A_scaled">scaled</code></td>
<td>
<p>if <code>TRUE</code>, the cdf of shifted and scaled data is
summarized. The shift and scale vector are taken from the
<code>scale</code> component of the object <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPredCondCDFMarg_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>An object of class <code>NMixPredCondCDFMarg</code> which has the following components:  
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a list with the grid values for each margin. The components
of the list are named <code>x1</code>, ... or take names from
<code>grid</code> argument.</p>
</td></tr>
<tr><td><code>icond</code></td>
<td>
<p>index of the margin by which we condition.</p>
</td></tr>
<tr><td><code>cdf</code></td>
<td>
<p>a list with the computed conditional cdf's for each
value of <code>x[[icond]]</code>. Each <code>cdf[[j]]</code> is again a list
with conditional cdf's for each margin given margin
<code>icond</code> equal to <code>x[[icond]][j]</code>.
The value of <code>cdf[[j]][[imargin]]</code> gives a value
of a marginal cdf of the <code>imargin</code>-th margin at <code>x[[icond]][j]</code>.
</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>a value of the argument <code>prob</code>.
</p>
</td></tr>
<tr><td><code>qXX%</code></td>
<td>
<p>if <code>prob</code> is given then there is one
additional component named qXX%, e.g., q50% for
each value of <code>prob</code> which has the same structure as the
component <code>cdf</code> and keeps computed posterior pointwise
quantiles.
</p>
</td></tr>
</table>
<p>There is also a <code>plot</code> method implemented for the resulting object.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.NMixPredCondCDFMarg">plot.NMixPredCondCDFMarg</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='NMixPredCondDensJoint2'>
Pairwise bivariate conditional predictive densities
</h2><span id='topic+NMixPredCondDensJoint2'></span><span id='topic+NMixPredCondDensJoint2.default'></span><span id='topic+NMixPredCondDensJoint2.NMixMCMC'></span><span id='topic+NMixPredCondDensJoint2.GLMM_MCMC'></span><span id='topic+C_NMix_PredCondDensJoint2'></span>

<h3>Description</h3>

<p>This function serves as an inference tool for the MCMC output
obtained using the function <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>. It computes
(posterior predictive) estimates of pairwise bivariate conditional
densities (given one margin).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPredCondDensJoint2(x, ...)

## Default S3 method:
NMixPredCondDensJoint2(x, icond, scale, K, w, mu, Li, Krandom=FALSE, ...)

## S3 method for class 'NMixMCMC'
NMixPredCondDensJoint2(x, icond, grid, lgrid=50, scaled=FALSE, ...)

## S3 method for class 'GLMM_MCMC'
NMixPredCondDensJoint2(x, icond, grid, lgrid=50, scaled=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPredCondDensJoint2_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> for
<code>NMixPredCondDensJoint2.NMixMCMC</code> function.
</p>
<p>An object of class <code>GLMM_MCMC</code> for
<code>NMixPredCondDensJoint2.GLMM_MCMC</code> function.
</p>
<p>A list with the grid values (see below) for
<code>NMixPredCondDensJoint2.default</code> function.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensJoint2_+3A_icond">icond</code></td>
<td>
<p>index of the margin by which we want to condition
</p>
</td></tr> 
<tr><td><code id="NMixPredCondDensJoint2_+3A_scale">scale</code></td>
<td>
<p>a two component list giving the <code>shift</code> and the
<code>scale</code>. If not given, shift is equal to zero and scale is
equal to one.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensJoint2_+3A_k">K</code></td>
<td>
<p>either a number (when <code>Krandom</code><code class="reqn">=</code><code>FALSE</code>) or a
numeric vector with the chain for the number of mixture components.</p>
</td></tr>
<tr><td><code id="NMixPredCondDensJoint2_+3A_w">w</code></td>
<td>
<p>a numeric vector with the chain for the mixture weights.</p>
</td></tr>
<tr><td><code id="NMixPredCondDensJoint2_+3A_mu">mu</code></td>
<td>
<p>a numeric vector with the chain for the mixture means.</p>
</td></tr>
<tr><td><code id="NMixPredCondDensJoint2_+3A_li">Li</code></td>
<td>
<p>a numeric vector with the chain for the mixture inverse
variances (lower triangles only).</p>
</td></tr>
<tr><td><code id="NMixPredCondDensJoint2_+3A_krandom">Krandom</code></td>
<td>
<p>a logical value which indicates whether the number of
mixture components changes from one iteration to another.
</p>
</td></tr>  
<tr><td><code id="NMixPredCondDensJoint2_+3A_grid">grid</code></td>
<td>
<p>a list with the grid values for each margin in which
the density should be evaluated. The value of <code>grid[[icond]]</code>
determines the values by which we condition.
</p>
<p>If <code>grid</code> is not specified, it is created automatically using
the information from the posterior summary statistics stored in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensJoint2_+3A_lgrid">lgrid</code></td>
<td>
<p>a length of the grid used to create the <code>grid</code> if
that is not specified.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensJoint2_+3A_scaled">scaled</code></td>
<td>
<p>if <code>TRUE</code>, the density of shifted and scaled data is
summarized. The shift and scale vector are taken from the
<code>scale</code> component of the object <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensJoint2_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>      
</table>


<h3>Value</h3>

<p>An object of class <code>NMixPredCondDensJoint2</code> which has the
following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a list with the grid values for each margin. The components
of the list are named <code>x1</code>, ... or take names from
<code>grid</code> argument.</p>
</td></tr>
<tr><td><code>icond</code></td>
<td>
<p>index of the margin by which we condition.</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>a list with the computed conditional densities for each
value of <code>x[[icond]]</code>. Each <code>dens[[j]]</code> is again a list
with conditional densities for each pair of margins given margin
<code>icond</code> equal to <code>x[[icond]][j]</code>.
The value of <code>dens[[j]][[i-k]]</code> gives values
of conditional density of the (i,k)-th margins given margin
<code>icond</code> equal to <code>x[[icond]][j]</code>.
</p>
</td></tr>    
</table>
<p>There is also a <code>plot</code> method implemented for the resulting object.  
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.NMixPredCondDensJoint2">plot.NMixPredCondDensJoint2</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='NMixPredCondDensMarg'>
Univariate conditional predictive density
</h2><span id='topic+NMixPredCondDensMarg'></span><span id='topic+NMixPredCondDensMarg.default'></span><span id='topic+NMixPredCondDensMarg.NMixMCMC'></span><span id='topic+NMixPredCondDensMarg.GLMM_MCMC'></span><span id='topic+C_NMix_PredCondDensCDFMarg'></span>

<h3>Description</h3>

<p>This function serves as an inference tool for the MCMC output
obtained using the function <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>. It computes
(posterior predictive) estimates of univariate conditional densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPredCondDensMarg(x, ...)

## Default S3 method:
NMixPredCondDensMarg(x, icond, prob, scale, K, w, mu, Li, Krandom=FALSE, ...)

## S3 method for class 'NMixMCMC'
NMixPredCondDensMarg(x, icond, prob, grid, lgrid=50, scaled=FALSE, ...)

## S3 method for class 'GLMM_MCMC'
NMixPredCondDensMarg(x, icond, prob, grid, lgrid=50, scaled=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPredCondDensMarg_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> for
<code>NMixPredCondDensMarg.NMixMCMC</code> function.
</p>
<p>An object of class <code>GLMM_MCMC</code> for
<code>NMixPredCondDensMarg.GLMM_MCMC</code> function.
</p>
<p>A list with the grid values (see below) for
<code>NMixPredCondDensMarg.default</code> function.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensMarg_+3A_icond">icond</code></td>
<td>
<p>index of the margin by which we want to condition
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensMarg_+3A_prob">prob</code></td>
<td>
<p>a numeric vector. If given then also the posterior
pointwise quantiles of the conditional densities are computed for
probabilities given by <code>prob</code>. These can be used to draw
pointwise credible intervals.
</p>
</td></tr>  
<tr><td><code id="NMixPredCondDensMarg_+3A_scale">scale</code></td>
<td>
<p>a two component list giving the <code>shift</code> and the
<code>scale</code>. If not given, shift is equal to zero and scale is
equal to one.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensMarg_+3A_k">K</code></td>
<td>
<p>either a number (when <code>Krandom</code><code class="reqn">=</code><code>FALSE</code>) or a
numeric vector with the chain for the number of mixture components.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensMarg_+3A_w">w</code></td>
<td>
<p>a numeric vector with the chain for the mixture weights.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensMarg_+3A_mu">mu</code></td>
<td>
<p>a numeric vector with the chain for the mixture means.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensMarg_+3A_li">Li</code></td>
<td>
<p>a numeric vector with the chain for the mixture inverse
variances (lower triangles only).
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensMarg_+3A_krandom">Krandom</code></td>
<td>
<p>a logical value which indicates whether the number of
mixture components changes from one iteration to another.
</p>
</td></tr>  
<tr><td><code id="NMixPredCondDensMarg_+3A_grid">grid</code></td>
<td>
<p>a list with the grid values for each margin in which
the density should be evaluated. The value of <code>grid[[icond]]</code>
determines the values by which we condition.
</p>
<p>If <code>grid</code> is not specified, it is created automatically using
the information from the posterior summary statistics stored in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensMarg_+3A_lgrid">lgrid</code></td>
<td>
<p>a length of the grid used to create the <code>grid</code> if
that is not specified.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensMarg_+3A_scaled">scaled</code></td>
<td>
<p>if <code>TRUE</code>, the density of shifted and scaled data is
summarized. The shift and scale vector are taken from the
<code>scale</code> component of the object <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPredCondDensMarg_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>An object of class <code>NMixPredCondDensMarg</code> which has the following components:  
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a list with the grid values for each margin. The components
of the list are named <code>x1</code>, ... or take names from
<code>grid</code> argument.</p>
</td></tr>
<tr><td><code>icond</code></td>
<td>
<p>index of the margin by which we condition.</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>a list with the computed conditional densities for each
value of <code>x[[icond]]</code>. Each <code>dens[[j]]</code> is again a list
with conditional densities for each margin given margin
<code>icond</code> equal to <code>x[[icond]][j]</code>.
The value of <code>dens[[j]][[imargin]]</code> gives a value
of a marginal density of the <code>imargin</code>-th margin at <code>x[[icond]][j]</code>.
</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>a value of the argument <code>prob</code>.
</p>
</td></tr>
<tr><td><code>qXX%</code></td>
<td>
<p>if <code>prob</code> is given then there is one
additional component named qXX%, e.g., q50% for
each value of <code>prob</code> which has the same structure as the
component <code>dens</code> and keeps computed posterior pointwise
quantiles.
</p>
</td></tr>  
</table>
<p>There is also a <code>plot</code> method implemented for the resulting object.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.NMixPredCondDensMarg">plot.NMixPredCondDensMarg</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='NMixPredDA'>
Discriminant analysis based on MCMC output from the mixture model
</h2><span id='topic+NMixPredDA'></span><span id='topic+C_NMix_PredDA'></span>

<h3>Description</h3>

<p>It performs discriminant analysis based on sampled (re-labeled) MCMC
chains from the mixture model fitted with
<code><a href="#topic+NMixMCMC">NMixMCMC</a></code> function. Observations to be discriminated may
be censored.
</p>
<p>Discrimination is based on posterior predictive probabilities of
belonging to (re-labeled) mixture components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPredDA(object, y0, y1, censor, inity, info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPredDA_+3A_object">object</code></td>
<td>
<p>an object of class <code>NMixMCMC</code></p>
</td></tr>
<tr><td><code id="NMixPredDA_+3A_y0">y0</code></td>
<td>
<p>vector, matrix or data frame with observations (or limits of
censored-observations) to be clustered. See <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> for details.
</p>
<p>If <code>y0</code> is not given then the function discriminates original
observations used to generate MCMC sample stored in <code>object</code>.
</p>
</td></tr>
<tr><td><code id="NMixPredDA_+3A_y1">y1</code></td>
<td>
<p>vector, matrix or data frame with upper limits of
interval-censored observations (if there are any). See
<code><a href="#topic+NMixMCMC">NMixMCMC</a></code> for details.
</p>
</td></tr>
<tr><td><code id="NMixPredDA_+3A_censor">censor</code></td>
<td>
<p>vector, matrix or data frame with censoring indicators
(if there are any censored observations). See
<code><a href="#topic+NMixMCMC">NMixMCMC</a></code> for details.
</p>
</td></tr>
<tr><td><code id="NMixPredDA_+3A_inity">inity</code></td>
<td>
<p>optional vector, matrix or data frame with initial values
of censored observations (if there are any censored observations)
</p>
</td></tr>
<tr><td><code id="NMixPredDA_+3A_info">info</code></td>
<td>
<p>number which specifies frequency used to re-display the
iteration counter during the computation.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with 
columns labeled <code>prob1</code>,..., <code>probp</code> giving
posterior predictive probabilities of belonging to each component and a column
labeled <code>component</code> giving the index of the component with the
highest component probability.  
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+NMixPlugDA">NMixPlugDA</a></code>.
</p>

<hr>
<h2 id='NMixPredDensJoint2'>
Pairwise bivariate predictive density
</h2><span id='topic+NMixPredDensJoint2'></span><span id='topic+NMixPredDensJoint2.default'></span><span id='topic+NMixPredDensJoint2.NMixMCMC'></span><span id='topic+NMixPredDensJoint2.GLMM_MCMC'></span><span id='topic+C_NMix_PredDensJoint2'></span>

<h3>Description</h3>

<p>This function serves as an inference tool for the MCMC output
obtained using the function <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>. It computes
estimated posterior predictive densities for each pair of margins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPredDensJoint2(x, ...)

## Default S3 method:
NMixPredDensJoint2(x, scale, K, w, mu, Li, Krandom=TRUE, ...)

## S3 method for class 'NMixMCMC'
NMixPredDensJoint2(x, grid, lgrid=50, scaled=FALSE, ...)

## S3 method for class 'GLMM_MCMC'
NMixPredDensJoint2(x, grid, lgrid=50, scaled=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPredDensJoint2_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> for
<code>NMixPredDensJoint2.NMixMCMC</code> function.
</p>
<p>an object of class <code>GLMM_MCMC</code> for
<code>NMixPredDensJoint2.GLMM_MCMC</code> function.
</p>
<p>A list with the grid values (see below) for
<code>NMixPredDensJoint2.default</code> function.
</p>
</td></tr>
<tr><td><code id="NMixPredDensJoint2_+3A_scale">scale</code></td>
<td>
<p>a two component list giving the <code>shift</code> and the
<code>scale</code>. If not given, shift is equal to zero and scale is
equal to one.</p>
</td></tr>
<tr><td><code id="NMixPredDensJoint2_+3A_k">K</code></td>
<td>
<p>either a number (when <code>Krandom</code><code class="reqn">=</code><code>FALSE</code>) or a
numeric vector with the chain for the number of mixture components.</p>
</td></tr>
<tr><td><code id="NMixPredDensJoint2_+3A_w">w</code></td>
<td>
<p>a numeric vector with the chain for the mixture weights.</p>
</td></tr>
<tr><td><code id="NMixPredDensJoint2_+3A_mu">mu</code></td>
<td>
<p>a numeric vector with the chain for the mixture means.</p>
</td></tr>
<tr><td><code id="NMixPredDensJoint2_+3A_li">Li</code></td>
<td>
<p>a numeric vector with the chain for the mixture inverse
variances (lower triangles only).</p>
</td></tr>
<tr><td><code id="NMixPredDensJoint2_+3A_krandom">Krandom</code></td>
<td>
<p>a logical value which indicates whether the number of
mixture components changes from one iteration to another.</p>
</td></tr>
<tr><td><code id="NMixPredDensJoint2_+3A_grid">grid</code></td>
<td>
<p>a list with the grid values for each margin in which
the predictive density should be evaluated.
</p>
<p>If <code>grid</code> is not specified, it is created automatically using
the information from the posterior summary statistics stored in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPredDensJoint2_+3A_lgrid">lgrid</code></td>
<td>
<p>a length of the grid used to create the <code>grid</code> if
that is not specified.</p>
</td></tr>
<tr><td><code id="NMixPredDensJoint2_+3A_scaled">scaled</code></td>
<td>
<p>if <code>TRUE</code>, the density of shifted and scaled data is
summarized. The shift and scale vector are taken from the
<code>scale</code> component of the object <code>x</code>.</p>
</td></tr>
<tr><td><code id="NMixPredDensJoint2_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>An object of class <code>NMixPredDensJoint2</code> which has the following components:  
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a list with the grid values for each margin. The components
of the list are named <code>x1</code>, ... or take names from
<code>grid</code> argument.</p>
</td></tr>
<tr><td><code>freqK</code></td>
<td>
<p>frequency table for the values of <code class="reqn">K</code> (numbers of
mixture components) in the MCMC chain.</p>
</td></tr>
<tr><td><code>propK</code></td>
<td>
<p>proportions derived from <code>freqK</code>.</p>
</td></tr>
<tr><td><code>MCMC.length</code></td>
<td>
<p>the length of the MCMC used to compute the
predictive densities.</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>a list with the computed predictive densities for each
pair of margins. The components of the list are named <code>1-2</code>,
<code>1-3</code>, ..., i.e.,
<code>dens[[1]]</code><code class="reqn">=</code><code>dens[["1-2"]]</code> is the pairwise predictive
density for margins 1 and 2, etc. Each component of the <code>list</code>
is a matrix in such a form that it can be directly passed together
with the proper components of <code>x</code> to the plotting functions
like <code><a href="graphics.html#topic+contour">contour</a></code> or <code><a href="graphics.html#topic+image">image</a></code>.
</p>
</td></tr>
<tr><td><code>densK</code></td>
<td>
<p>a list with the computed predictive densities for each
margin, conditioned further by <code class="reqn">K</code>. The components of the list
are named <code>1-2</code>, <code>1-3</code>, .... That is,
<code>dens[[1]][[1]]</code> <code class="reqn">=</code> <code>dens[["1-2"]][[1]]</code> is the
pairwise predictive  density for margins 1 and 2 conditioned by <code class="reqn">K=1</code>,
<code>dens[[1]][[2]]</code> <code class="reqn">=</code> <code>dens[["1-2"]][[2]]</code> is the
pairwise predictive density for margins 1 and 2 conditioned by <code class="reqn">K=2</code> etc.
</p>
<p>Note that <code>densK</code> provides some additional information only
when <code>Krandom</code> <code class="reqn">=</code> <code>TRUE</code> or when <code>x</code> results from
the <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> call to the reversible jump MCMC.
</p>
</td></tr>
</table>
<p>There is also a <code>plot</code> method implemented for the resulting object.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2009).    
A new R package for Bayesian estimation of multivariate normal mixtures allowing for selection 
of the number of components and interval-censored data.
<em>Computational Statistics and Data Analysis</em>, <b>53</b>(12), 3932&ndash;3947.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.NMixPredDensJoint2">plot.NMixPredDensJoint2</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>,
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>, <code><a href="#topic+NMixPredDensMarg">NMixPredDensMarg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See additional material available in 
## YOUR_R_DIR/library/mixAK/doc/
## or YOUR_R_DIR/site-library/mixAK/doc/
## https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/Galaxy.pdf
## https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/Faithful.pdf
## https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/Tandmob.pdf
##
</code></pre>

<hr>
<h2 id='NMixPredDensMarg'>
Marginal (univariate) predictive density
</h2><span id='topic+NMixPredDensMarg'></span><span id='topic+NMixPredDensMarg.default'></span><span id='topic+NMixPredDensMarg.NMixMCMC'></span><span id='topic+NMixPredDensMarg.GLMM_MCMC'></span><span id='topic+C_NMix_PredDensMarg'></span>

<h3>Description</h3>

<p>This function serves as an inference tool for the MCMC output
obtained using the function <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>. It computes
estimated posterior predictive densities for each margin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPredDensMarg(x, ...)

## Default S3 method:
NMixPredDensMarg(x, scale, K, w, mu, Li, Krandom=TRUE, ...)

## S3 method for class 'NMixMCMC'
NMixPredDensMarg(x, grid, lgrid=500, scaled=FALSE, ...)

## S3 method for class 'GLMM_MCMC'
NMixPredDensMarg(x, grid, lgrid=500, scaled=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPredDensMarg_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> for
<code>NMixPredDensMarg.NMixMCMC</code> function.
</p>
<p>An object of class <code>GLMM_MCMC</code> for
<code>NMixPredDensMarg.GLMM_MCMC</code> function.
</p>
<p>A list with the grid values (see below) for
<code>NMixPredDensMarg.default</code> function.
</p>
</td></tr>
<tr><td><code id="NMixPredDensMarg_+3A_scale">scale</code></td>
<td>
<p>a two component list giving the <code>shift</code> and the <code>scale</code>.</p>
</td></tr>
<tr><td><code id="NMixPredDensMarg_+3A_k">K</code></td>
<td>
<p>either a number (when <code>Krandom</code><code class="reqn">=</code><code>FALSE</code>) or a
numeric vector with the chain for the number of mixture components.</p>
</td></tr>
<tr><td><code id="NMixPredDensMarg_+3A_w">w</code></td>
<td>
<p>a numeric vector with the chain for the mixture weights.</p>
</td></tr>
<tr><td><code id="NMixPredDensMarg_+3A_mu">mu</code></td>
<td>
<p>a numeric vector with the chain for the mixture means.</p>
</td></tr>
<tr><td><code id="NMixPredDensMarg_+3A_li">Li</code></td>
<td>
<p>a numeric vector with the chain for the mixture inverse
variances (lower triangles only).</p>
</td></tr>
<tr><td><code id="NMixPredDensMarg_+3A_krandom">Krandom</code></td>
<td>
<p>a logical value which indicates whether the number of
mixture components changes from one iteration to another.</p>
</td></tr>
<tr><td><code id="NMixPredDensMarg_+3A_grid">grid</code></td>
<td>
<p>a numeric vector or a list with the grid values in which
the predictive density should be evaluated.
</p>
<p>If <code>x$dim</code> is 1 then <code>grid</code> may be a numeric vector. If
<code>x$dim</code> is higher than then <code>grid</code> must be a list with
numeric vectors as components giving the grids for each margin.
</p>
<p>If <code>grid</code> is not specified, it is created automatically using
the information from the posterior summary statistics stored in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="NMixPredDensMarg_+3A_lgrid">lgrid</code></td>
<td>
<p>a length of the grid used to create the <code>grid</code> if
that is not specified.</p>
</td></tr>
<tr><td><code id="NMixPredDensMarg_+3A_scaled">scaled</code></td>
<td>
<p>if <code>TRUE</code>, the density of shifted and scaled data is
summarized. The shift and scale vector are taken from the
<code>scale</code> component of the object <code>x</code>.</p>
</td></tr>
<tr><td><code id="NMixPredDensMarg_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>NMixPredDensMarg</code> which has the following components:  
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a list with the grid values for each margin. The components
of the list are named <code>x1</code>, ... or take names from
<code>grid</code> argument.</p>
</td></tr>
<tr><td><code>freqK</code></td>
<td>
<p>frequency table for the values of <code class="reqn">K</code> (numbers of
mixture components) in the MCMC chain.</p>
</td></tr>
<tr><td><code>propK</code></td>
<td>
<p>proportions derived from <code>freqK</code>.</p>
</td></tr>
<tr><td><code>MCMC.length</code></td>
<td>
<p>the length of the MCMC used to compute the
predictive densities.</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>a list with the computed predictive densities for each
margin. The components of the list are named <code>1</code>, ..., i.e.,
<code>dens[[1]]</code><code class="reqn">=</code><code>dens[["1"]]</code> is the predictive
density for margin 1 etc.</p>
</td></tr>
<tr><td><code>densK</code></td>
<td>
<p>a list with the computed predictive densities for each
margin, conditioned further by <code class="reqn">K</code>. The components of the list
are named <code>1</code>, .... That is,
<code>dens[[1]][[1]]</code> <code class="reqn">=</code> <code>dens[["1"]][[1]]</code> is the predictive
density for margin 1 conditioned by <code class="reqn">K=1</code>,
<code>dens[[1]][[2]]</code> <code class="reqn">=</code> <code>dens[["1"]][[2]]</code> is the predictive
density for margin 1 conditioned by <code class="reqn">K=2</code> etc.
</p>
<p>Note that <code>densK</code> provides some additional information only
when <code>Krandom</code> <code class="reqn">=</code> <code>TRUE</code> or when <code>x</code> results from
the <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> call to the reversible jump MCMC.
</p>
</td></tr>
</table>
<p>There is also a <code>plot</code> method implemented for the resulting object.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2009).  
A new R package for Bayesian estimation of multivariate normal mixtures allowing for selection 
of the number of components and interval-censored data.
<em>Computational Statistics and Data Analysis</em>, <b>53</b>(12), 3932&ndash;3947.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.NMixPredDensMarg">plot.NMixPredDensMarg</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>, <code><a href="#topic+NMixPredDensJoint2">NMixPredDensJoint2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See additional material available in 
## YOUR_R_DIR/library/mixAK/doc/
## or YOUR_R_DIR/site-library/mixAK/doc/
## https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/Galaxy.pdf
## https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/Faithful.pdf
## https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/Tandmob.pdf
##
</code></pre>

<hr>
<h2 id='NMixPseudoGOF'>
Pseudo goodness-of-fit test for a normal mixture model
</h2><span id='topic+NMixPseudoGOF'></span><span id='topic+NMixPseudoGOF.default'></span><span id='topic+NMixPseudoGOF.NMixMCMC'></span>

<h3>Description</h3>

<p>It takes a (fitted) normal mixture, creates hyperrectangles according to a specified grid,
computes probability masses in each hyperrectangle derived from the (fitted) normal mixture.
From computed probability masses expected frequencies (using the sample size of supplied data) are
computed and compared to frequencies observed in supplied data. From expected and observed
frequencies, a Pearson chi-squared like statistic is computed and returned together with
residuals derived from that statistic.
</p>
<p>Also pseudo degrees of freedom are returned which are equal
to a number of hyperrectangles minus number of free parameters of the normal mixture.
For a <code class="reqn">K</code>-component mixture of dimension <code class="reqn">p</code>, the number of free parameters
is computed as
</p>
<p style="text-align: center;"><code class="reqn">q = K-1 + K\cdot p + K\cdot p(p+1)/2</code>
</p>

<p>Note that computation of <code class="reqn">q</code> does not take into account the positive (semi-)definiteness
restriction on covariance matrices.
</p>
<p>WARNING: There is no statistical theory developed that would guarantee that
computed chi-squared like statistics follows a chi-squared distribution
with computed pseudo degrees of freedom under the null hypothesis that
the distribution that generated the data is a normal mixture. This function serves purely
for descriptive purposes!  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixPseudoGOF(x, ...)

## Default S3 method:
NMixPseudoGOF(x, scale, w, mu, Sigma, breaks, nbreaks=10, digits=3, ...)

## S3 method for class 'NMixMCMC'
NMixPseudoGOF(x, y, breaks, nbreaks=10, digits=3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixPseudoGOF_+3A_x">x</code></td>
<td>
<p>data object (see argument <code>y</code> below) for
<code>NMixPseudoGOF.default</code> function.
</p>
<p>An object of class <code>NMixMCMC</code> for
<code>NMixPseudoGOF.NMixMCMC</code> function.
</p>
</td></tr>
<tr><td><code id="NMixPseudoGOF_+3A_y">y</code></td>
<td>
<p>a numeric vector, matrix or data frame with the data. It is a
numeric vector if <code class="reqn">p</code> is one. It is a matrix or data frame with
<code class="reqn">p</code> columns if <code class="reqn">p &gt; 1</code>.
</p>
</td></tr>
<tr><td><code id="NMixPseudoGOF_+3A_scale">scale</code></td>
<td>
<p>a two component list giving the <code>shift</code> and the
<code>scale</code>. If not given, shift is equal to zero and scale is
equal to one.
</p>
</td></tr>
<tr><td><code id="NMixPseudoGOF_+3A_w">w</code></td>
<td>
<p>a numeric vector with mixture weights.
The length of this vector determines the number of
mixture components.
</p>
</td></tr>
<tr><td><code id="NMixPseudoGOF_+3A_mu">mu</code></td>
<td>
<p>a matrix with mixture means in rows. That is, <code>mu</code> has
<code class="reqn">K</code> rows and <code class="reqn">p</code> columns, where <code class="reqn">K</code> denotes the number
of mixture components and <code class="reqn">p</code> is dimension of the mixture
distribution.
</p>
</td></tr>
<tr><td><code id="NMixPseudoGOF_+3A_sigma">Sigma</code></td>
<td>
<p>a list with mixture covariance matrices.
</p>
</td></tr>
<tr><td><code id="NMixPseudoGOF_+3A_breaks">breaks</code></td>
<td>
<p>a numeric vector or a list with the breaks defining the
hyperrectangles. It is a numeric vector if <code class="reqn">p</code> is equal to
one. It is a list of length <code class="reqn">p</code> of numeric vectors. Each
component of the list determines the breaks for each margin.     
</p>
</td></tr>
<tr><td><code id="NMixPseudoGOF_+3A_nbreaks">nbreaks</code></td>
<td>
<p>a number or a numeric vector with the number of breaks
for each margin. It is only used if the argument <code>breaks</code> is
not given to determine sensible break values.
</p>
</td></tr>
<tr><td><code id="NMixPseudoGOF_+3A_digits">digits</code></td>
<td>
<p>a number or a numeric vector with the number of digits
to which the breaks should be rounded in the case they are created
by the function. If it is a vector then different rounding may be
used for each margin.
</p>
</td></tr>
<tr><td><code id="NMixPseudoGOF_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>ADD DESCRIPTION
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.    
</p>

<hr>
<h2 id='NMixRelabel'>
Re-labeling the MCMC output of the mixture model
</h2><span id='topic+NMixRelabel'></span><span id='topic+NMixRelabel.default'></span><span id='topic+NMixRelabel.NMixMCMC'></span><span id='topic+NMixRelabel.NMixMCMClist'></span><span id='topic+NMixRelabel.GLMM_MCMC'></span><span id='topic+NMixRelabel.GLMM_MCMClist'></span><span id='topic+C_NMix_NMixRelabel'></span><span id='topic+C_GLMM_NMixRelabel'></span>

<h3>Description</h3>

<p>This function takes an object generated by the <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>
or <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function and internally re-labels the mixture
components using selected re-labeling algorithm. It also computes
posterior summary statistics for mixture means, weights, variances
which correspond to newly labeled MCMC sample. Further, posterior
component probabilities (<code>poster.comp.prob_u</code> and
<code>poster.comp.prob_b</code> components of the object <code>object</code>) are
updated according to the newly labeled MCMC sample.
</p>
<p>This function only works for models with a fixed number of mixture components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixRelabel(object, type=c("mean", "weight", "stephens"), par, ...)

## Default S3 method:
NMixRelabel(object, type = c("mean", "weight", "stephens"), par, ...)

## S3 method for class 'NMixMCMC'
NMixRelabel(object, type = c("mean", "weight","stephens"), par,
   prob=c(0.025, 0.5, 0.975), keep.comp.prob = FALSE, info, ...)

## S3 method for class 'NMixMCMClist'
NMixRelabel(object, type = c("mean", "weight","stephens"), par,
   prob=c(0.025, 0.5, 0.975), keep.comp.prob = FALSE, info,
   silent = FALSE, parallel = FALSE, ...)

## S3 method for class 'GLMM_MCMC'
NMixRelabel(object, type = c("mean", "weight", "stephens"), par,
   prob = c(0.025, 0.5, 0.975), keep.comp.prob = FALSE, info,
   silent = FALSE, ...)

## S3 method for class 'GLMM_MCMClist'
NMixRelabel(object, type = c("mean", "weight", "stephens"), par,
   prob = c(0.025, 0.5, 0.975), keep.comp.prob = FALSE, jointly = FALSE,
   info, silent = FALSE, parallel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixRelabel_+3A_object">object</code></td>
<td>
<p>an object of apropriate class.</p>
</td></tr>
<tr><td><code id="NMixRelabel_+3A_type">type</code></td>
<td>
<p>character string which specifies the type of the
re-labeling algorithm.</p>
</td></tr>
<tr><td><code id="NMixRelabel_+3A_par">par</code></td>
<td>
<p>additional parameters for particular re-labeling
algorithms.
</p>

<dl>
<dt>mean</dt><dd><p><code>par</code> specifies margin which is used to order the
components. It is set to 1 if not given.</p>
</dd>
<dt>weight</dt><dd><p><code>par</code> is empty.</p>
</dd>
<dt>stephens</dt><dd><p><code>par</code> is a list with components
<code>type.init</code>, <code>par</code>, <code>maxiter</code>.
</p>
<p>Component <code>type.init</code> is a character string being equal to
either of &ldquo;identity&rdquo;, &ldquo;mean&rdquo;, &ldquo;weight&rdquo;. It
determines the way which is used to obtain initial re-labeling.
</p>
<p>Component <code>par</code> determines the margin in the case that
<code>type.init</code> is equal to &ldquo;mean&rdquo;.
</p>
<p>Component <code>maxiter</code> determines maximum number of iterations
of the re-labeling algorithm.		
</p>
</dd>
</dl>
  
</td></tr>
<tr><td><code id="NMixRelabel_+3A_prob">prob</code></td>
<td>
<p>probabilities for which the posterior quantiles
of component allocation probabilities are computed.
</p>
</td></tr>
<tr><td><code id="NMixRelabel_+3A_keep.comp.prob">keep.comp.prob</code></td>
<td>
<p>logical. If <code>TRUE</code>, posterior sample of
component allocation probabilities (for each subject) is kept in the
resulting object.</p>
</td></tr>
<tr><td><code id="NMixRelabel_+3A_jointly">jointly</code></td>
<td>
<p>a logical value. If it is <code>TRUE</code> then both chains
are processed together. In the output, all posterior summary
statistics are then also related to both chains as if it is one long
chain. If it is <code>FALSE</code> then both chains are processed independently.
</p>
</td></tr>
<tr><td><code id="NMixRelabel_+3A_info">info</code></td>
<td>
<p>number which specifies frequency used to re-display the
iteration counter during the computation.
</p>
</td></tr>
<tr><td><code id="NMixRelabel_+3A_silent">silent</code></td>
<td>
<p>a logical value indicating whether the information on
the MCMC progress is to be supressed.</p>
</td></tr>
<tr><td><code id="NMixRelabel_+3A_parallel">parallel</code></td>
<td>
<p>a logical value indicating whether parallel
computation (based on a package <code>parallel</code>) should be used (if
possible) for re-labelling of the two chains.</p>
</td></tr>
<tr><td><code id="NMixRelabel_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object being equal to the value of the <code>object</code> argument in
which the following components are updated according to new labeling
of the mixture components.
</p>


<h3>Value for NMixMCMC object</h3>

<p>When the argument <code>object</code> is of class <code>NMixMCMC</code>, the
resulting object is equal to <code>object</code> with the following
components being modified:
</p>

<dl>
<dt>relabel</dt><dd><p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code></p>
</dd>
<dt>order</dt><dd><p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code></p>
</dd>
<dt>rank</dt><dd><p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code></p>
</dd>
<dt>poster.mean.w</dt><dd><p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code></p>
</dd>
<dt>poster.mean.mu</dt><dd><p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code></p>
</dd>
<dt>poster.mean.Q</dt><dd><p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code></p>
</dd>
<dt>poster.mean.Sigma</dt><dd><p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code></p>
</dd>
<dt>poster.mean.Li</dt><dd><p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code></p>
</dd>
<dt>poster.comp.prob_u</dt><dd><p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code></p>
</dd>
<dt>poster.comp.prob_b</dt><dd><p>see <code><a href="#topic+NMixMCMC">NMixMCMC</a></code></p>
</dd>
</dl>

<p>Additionally, new components are added, namely
</p>

<dl>
<dt>quant.comp.prob_b</dt><dd><p>a list with the posterior quantiles of
component probabilities. One <code>list</code> component for each
quantile specified by <code>prob</code> argument.</p>
</dd>
<dt>comp.prob_b</dt><dd><p>posterior sample of individual component
probabilities (also given random effects). It is an <code class="reqn">M \times
	n\cdot K</code> matrix where <code class="reqn">M</code> is the length of the
posterior sample, <code class="reqn">n</code> is the number of subjects, and <code class="reqn">K</code>
is the number of mixture components. Component labels correspond
to the re-labelled sample. It is included in the
resulting object only if <code>keep.comp.prob</code> argument is
<code>TRUE</code>.</p>
</dd>
</dl>
      


<h3>Value for GLMM_MCMC object</h3>

<p>When the argument <code>object</code> is of class <code>GLMM_MCMC</code>, the
resulting object is equal to <code>object</code> with the following
components being modified:
</p>

<dl>
<dt>relabel_b</dt><dd><p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code></p>
</dd>
<dt>order_b</dt><dd><p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code></p>
</dd>
<dt>rank_b</dt><dd><p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code></p>
</dd>
<dt>poster.mean.w_b</dt><dd><p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code></p>
</dd>
<dt>poster.mean.mu_b</dt><dd><p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code></p>
</dd>
<dt>poster.mean.Q_b</dt><dd><p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code></p>
</dd>
<dt>poster.mean.Sigma_b</dt><dd><p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code></p>
</dd>
<dt>poster.mean.Li_b</dt><dd><p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code></p>
</dd>
<dt>poster.comp.prob_u</dt><dd><p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code></p>
</dd>
<dt>poster.comp.prob_b</dt><dd><p>see <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code></p>
</dd>
</dl>

<p>Additionally, new components are added, namely
</p>

<dl>
<dt>quant.comp.prob_b</dt><dd><p>a list with the posterior quantiles of
component probabilities. One <code>list</code> component for each
quantile specified by <code>prob</code> argument.</p>
</dd>
<dt>comp.prob_b</dt><dd><p>posterior sample of individual component
probabilities (also given random effects). It is an <code class="reqn">M \times
	I\cdot K</code> matrix where <code class="reqn">M</code> is the length of the
posterior sample, <code class="reqn">I</code> is the number of subjects, and <code class="reqn">K</code>
is the number of mixture components. Component labels correspond
to the re-labelled sample. It is included in the
resulting object only if <code>keep.comp.prob</code> argument is
<code>TRUE</code>.</p>
</dd>
<dt>poster.comp.prob</dt><dd><p>a matrix with the posterior means of
component probabilities which are calculated with random effects
integrated out.</p>
</dd>
<dt>quant.comp.prob</dt><dd><p>a list with the posterior quantiles of
component probabilities. One <code>list</code> component for each
quantile specified by <code>prob</code> argument.</p>
</dd>
<dt>comp.prob</dt><dd><p>posterior sample of individual component
probabilities (with random effects integrated out). It is an <code class="reqn">M \times
	I\cdot K</code> matrix where <code class="reqn">M</code> is the length of the
posterior sample, <code class="reqn">I</code> is the number of subjects, and <code class="reqn">K</code>
is the number of mixture components. Component labels correspond
to the re-labelled sample. It is included in the
resulting object only if <code>keep.comp.prob</code> argument is
<code>TRUE</code>.
</p>
<p><b>Remark.</b> These are the component probabilities which should
normally be used for clustering purposes.
</p>
</dd>    
</dl>
    


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Celeux, G. (1998).
Bayesian inference for mixtures: The label-switching problem.
In: <em>COMPSTAT 98</em> (eds. R. Payne and P. Green),
pp. 227-232. Heidelberg: Physica-Verlag.
</p>
<p>Jasra, A., Holmes, C. C., and Stephens, D. A. (2005).
Markov chain Monte Carlo methods and the label switching problem in
Bayesian mixture modeling.
<em>Statistical Science</em>, <b>20</b>, 50-67.
</p>
<p>Stephens, M. (1997).
<em>Bayesian methods for mixtures of normal distributions. DPhil Thesis.</em>
Oxford: University of Oxford.
(Available from:
<a href="http://stephenslab.uchicago.edu/publications.html">http://stephenslab.uchicago.edu/publications.html</a>
(accessed on 05/02/2014)).
</p>
<p>Stephens, M. (2000).
Dealing with label switching in mixture models.
<em>Journal of the Royal Statistical Society, Series B</em>, <b>62</b>, 795-809.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See also additional material available in 
## YOUR_R_DIR/library/mixAK/doc/
## or YOUR_R_DIR/site-library/mixAK/doc/
## - file PBCseq.R and
##   https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/PBCseq.pdf
##
## ==============================================
</code></pre>

<hr>
<h2 id='NMixRelabelAlgorithm'>
Argument manipulation for the NMixRelabel functions 
</h2><span id='topic+NMixRelabelAlgorithm'></span>

<h3>Description</h3>

<p>This is a help function for <code><a href="#topic+NMixRelabel">NMixRelabel</a></code> functions.
</p>
<p>THIS FUNCTION IS NOT TO BE CALLED BY ORDINARY USERS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixRelabelAlgorithm(type=c("mean", "weight", "stephens"), par, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixRelabelAlgorithm_+3A_type">type</code></td>
<td>
<p>see <code><a href="#topic+NMixRelabel">NMixRelabel</a></code> function.</p>
</td></tr>
<tr><td><code id="NMixRelabelAlgorithm_+3A_par">par</code></td>
<td>
<p>see <code><a href="#topic+NMixRelabel">NMixRelabel</a></code> function.</p>
</td></tr>  
<tr><td><code id="NMixRelabelAlgorithm_+3A_dim">dim</code></td>
<td>
<p>dimension of the data</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>relabel</code></td>
<td>
<p>a list with the same structure as <code>relabel</code>
component of objects of class <code>NMixMCMC</code> or <code>GLMM_MCMC</code>.</p>
</td></tr>
<tr><td><code>Ctype</code></td>
<td>
<p>integer to be passed to C++ re-labelling functions.</p>
</td></tr>
<tr><td><code>iparam</code></td>
<td>
<p>integer vector to be passed to C++ re-labelling functions.</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixRelabel">NMixRelabel</a></code>.
</p>

<hr>
<h2 id='NMixSummComp'>
Summary for the mixture components
</h2><span id='topic+NMixSummComp'></span><span id='topic+NMixSummComp.default'></span><span id='topic+NMixSummComp.NMixMCMC'></span><span id='topic+NMixSummComp.GLMM_MCMC'></span>

<h3>Description</h3>

<p>This function returns basic posterior summary for (re-labeled) mixture
components in a model with fixed number of components fitted with
<code><a href="#topic+NMixMCMC">NMixMCMC</a></code> or <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> function.
The summary also takes into account
possible scaling and shifting of the data (see argument <code>scale</code>
in <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> function
or argument <code>scale.b</code> in <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>).
</p>
<p>Note that even though the mixture components are re-labeled before the
summary is computed to achieve some identifiability, posterior summaries of
individual mixture means and variances are not always the quantity we
would like to see. For density estimation, posterior
predictive density (<code><a href="#topic+NMixPredDensMarg">NMixPredDensMarg</a></code>,
<code><a href="#topic+NMixPredDensJoint2">NMixPredDensJoint2</a></code>) is usually the right stuff one
should be interested in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMixSummComp(x)

## Default S3 method:
NMixSummComp(x)

## S3 method for class 'NMixMCMC'
NMixSummComp(x)

## S3 method for class 'GLMM_MCMC'
NMixSummComp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMixSummComp_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixMCMC</code> or <code>GLMM_MCMC</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>x</code>. The rest is printed on output device.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>.
</p>

<hr>
<h2 id='PBC910'>Subset of Mayo Clinic Primary Biliary Cholangitis (Cirrhosis) data</h2><span id='topic+PBC910'></span>

<h3>Description</h3>

<p>This is a subset of <code><a href="#topic+PBCseq">PBCseq</a></code> data which contains only data from
260 patients known to be alive and without liver transplantation at 910 days of follow-up. Furthermore,
only a selection of longitudinal measurements is included and only those
measurements that were obtained by 910 days. The <code>PBC910</code> dataset was used in
papers Komárek and Komárková (2013, 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PBCseq)</code></pre>


<h3>Format</h3>

<p>a data frame with 918 rows and the following
variables
</p>

<dl>
<dt>id</dt><dd><p>identification number of a patient</p>
</dd>
<dt>day</dt><dd><p>number of days between enrollment and this visit date
(all measurements below refer to this date)</p>
</dd>
<dt>month</dt><dd><p>number of months between enrollment and this visit
date</p>
</dd>
<dt>fu.days</dt><dd><p>total number of follow up days</p>
</dd>
<dt>delta.ltx.death</dt><dd><p>0/1 censoring indicator for event = death or
liver transplantation related to <code>fu.days</code></p>
</dd>
<dt>lbili</dt><dd><p>natural logarithm of above</p>
</dd>
<dt>platelet</dt><dd><p>platelet count</p>
</dd>    
<dt>spiders</dt><dd><p>0/1 presence of blood vessel malformations in the skin</p>
</dd>
<dt>jspiders</dt><dd><p>jittered version of a variable <code>spiders</code></p>
</dd>
</dl>
  


<h3>Source</h3>

<p><code>URL:</code> <code>http://lib.stat.cmu.edu/datasets/</code>
</p>


<h3>References</h3>

<p>Komárek, A. and Komárková, L. (2013).
Clustering for multivariate continuous and discrete longitudinal data.
<em>The Annals of Applied Statistics</em>, <b>7</b>(1), 177&ndash;200.
</p>
<p>Komárek, A. and Komárková, L. (2014).
Capabilities of R package mixAK for clustering based on multivariate continuous and discrete longitudinal data.
<em>Journal of Statistical Software</em>, <b>59</b>(12), 1&ndash;38.
<a href="https://doi.org/10.18637/jss.v059.i12">doi:10.18637/jss.v059.i12</a>.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PBC910">PBC910</a></code>, <code><a href="survival.html#topic+pbc">pbc</a></code>, <code><a href="survival.html#topic+pbcseq">pbcseq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PBC910)
summary(PBC910)
</code></pre>

<hr>
<h2 id='PBCseq'>Mayo Clinic Primary Biliary Cholangitis (Cirrhosis), sequential data</h2><span id='topic+PBCseq'></span>

<h3>Description</h3>

<p>This data is a continuation of the PBC data set (<code><a href="survival.html#topic+pbc">pbc</a></code>),
and contains the follow-up laboratory data for each study patient.
An analysis based on the data can be found in Murtagh et al. (1994).
</p>
<p>The primary PBC data set contains only baseline measurements 
of the laboratory 
paramters.  This data set contains multiple laboratory results, but
only on the 312 randomized patients.  Some baseline data values in this file
differ from the original PBC file, for instance, the data errors in
prothrombin time and age which were discovered after the orignal analysis
(see Fleming and Harrington, 1991, figure 4.6.7).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PBCseq)</code></pre>


<h3>Format</h3>

<p>a data frame with 1 945 rows and the following
variables
</p>

<dl>
<dt>id</dt><dd><p>identification number of a patient</p>
</dd>
<dt>sex</dt><dd><p>0/1 for male and female</p>
</dd>
<dt>fsex</dt><dd><p><code>factor</code> of above</p>
</dd>
<dt>drug</dt><dd><p>0/1 for placebo and D-penicillamine</p>
</dd>
<dt>fdrug</dt><dd><p><code>factor</code> of above</p>
</dd>
<dt>age</dt><dd><p>age at entry in years</p>
</dd>
<dt>fu.days</dt><dd><p>total number of follow up days</p>
</dd>
<dt>alive</dt><dd><p>number of days when the patient is known to be alive
and without liver transplantation</p>
</dd>
<dt>status</dt><dd><p>status at endpoint, 0/1/2 for censored, liver transplant, dead</p>
</dd>
<dt>fstatus</dt><dd><p><code>factor</code> of above</p>
</dd>
<dt>delta.death</dt><dd><p>0/1 censoring indicator for event = death (i.e.,
liver transplantation means censoring)</p>
</dd>    
<dt>delta.ltx.death</dt><dd><p>0/1 censoring indicator for event = death or
liver transplantation</p>
</dd>
<dt>day</dt><dd><p>number of days between enrollment and this visit date
(all measurements below refer to this date)</p>
</dd>
<dt>month</dt><dd><p>number of months between enrollment and this visit date</p>
</dd>
<dt>ascites</dt><dd><p>0/1 presence of ascites</p>
</dd>
<dt>fascites</dt><dd><p><code>factor</code> of above</p>
</dd>
<dt>hepatom</dt><dd><p>0/1 presence of hepatomegaly or enlarged liver</p>
</dd>
<dt>fhepatom</dt><dd><p><code>factor</code> of above</p>
</dd>
<dt>spiders</dt><dd><p>0/1 presence of blood vessel malformations in the skin</p>
</dd>
<dt>fspiders</dt><dd><p><code>factor</code> of above</p>
</dd>
<dt>edema</dt><dd><p>presence and status of edema, 0 for no edema, 0.5 for
untreated or successfully treated edema, 1 for edema despite diuretic therapy</p>
</dd>    
<dt>fedema</dt><dd><p><code>factor</code> of above</p>
</dd>
<dt>stage</dt><dd><p>histologic stage of disease (needs biopsy)</p>
</dd>
<dt>fstage</dt><dd><p><code>factor</code> of above</p>
</dd>
<dt>bili</dt><dd><p>serum bilirubin (mg/dl)</p>
</dd>
<dt>lbili</dt><dd><p>natural logarithm of above</p>
</dd>
<dt>albumin</dt><dd><p>serum albumin (mg/dl)</p>
</dd>
<dt>lalbumin</dt><dd><p>natural logarithm of above</p>
</dd>
<dt>alk.phos</dt><dd><p>alkaline phosphotase (U/liter)</p>
</dd>
<dt>lalk.phos</dt><dd><p>natural logarithm of above</p>
</dd>
<dt>chol</dt><dd><p>serum cholesterol (mg/dl)</p>
</dd>    
<dt>lchol</dt><dd><p>natural logarithm of above</p>
</dd>
<dt>sgot</dt><dd><p>serum glutamic-oxaloacetic transaminase (the enzyme name
has subsequently changed to &ldquo;ALT&rdquo; in the medical literature) (U/ml)</p>
</dd>
<dt>lsgot</dt><dd><p>natural logarithm of above</p>
</dd>
<dt>platelet</dt><dd><p>platelet count</p>
</dd>
<dt>lplatelet</dt><dd><p>natural logarithm of above</p>
</dd>
<dt>protime</dt><dd><p>standardised blood clotting time</p>
</dd>
<dt>lprotime</dt><dd><p>natural logarithm of above</p>
</dd>
</dl>
  


<h3>Source</h3>

<p><code>URL:</code> <code>http://lib.stat.cmu.edu/datasets/</code>
</p>


<h3>References</h3>

<p>Dickson, E. R., Grambsch,  P. M., Fleming, T. R., Fisher, L. D., and Langworthy, A. (1989).
Prognosis in primary biliary-cirrhosis &ndash; Model for decision-making.
<em>Hepatology,</em> <b>10</b>, 1&ndash;7.
</p>
<p>Fleming, T. R. and Harrington, D. P. (1991).
<em>Counting Processes and Survival Analysis.</em>
New York: John Wiley and Sons.
</p>
<p>Markus, B. H., Dickson, E. R., Grambsch, P. M., Fleming, T. R.,
Mazzaferro, V., Klintmalm, G. B. G., Wiesner, R. H., Vanthiel, D. H.,
and Starzl, T. E. (1989).
Efficacy of liver-transplantation in patients with primary biliary-cirrhosis.
<em>New England Journal of Medicine,</em> <b>320</b>, 1709&ndash;1713.
</p>
<p>Murtaugh, P. A., Dickson, E. R., Van Dam, G. M., Malinchoc, M.,
Grambsch, P. M., Langworthy, A. L., and Gips, C. H. (1994).
Primary biliary cirrhosis: Prediction of short-term survival based on repeated patient visits.
<em>Hepatology,</em> <b>20</b>, 126-134.
</p>
<p>Therneau, T. M. and Grambsch, P. M. (2000).
<em>Modeling Survival Data: Extending the Cox Model.</em>
New York: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+pbc">pbc</a></code>, <code><a href="survival.html#topic+pbcseq">pbcseq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PBCseq)
summary(PBCseq)
</code></pre>

<hr>
<h2 id='plot.NMixPlugCondDensJoint2'>
Plot computed pairwise bivariate conditional densities
(plug-in estimate)
</h2><span id='topic+plot.NMixPlugCondDensJoint2'></span>

<h3>Description</h3>

<p>This is a basic plotting tool to visualize computed plug-in estimates
of pairwise bivariate conditional densities using the
<code><a href="graphics.html#topic+image">image</a></code> or <code><a href="graphics.html#topic+contour">contour</a></code> plot.
See also <code><a href="#topic+NMixPlugCondDensJoint2">NMixPlugCondDensJoint2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMixPlugCondDensJoint2'
plot(x, ixcond, imargin,
    contour=FALSE,
    add.contour=TRUE, col.add.contour="brown",
    auto.layout=TRUE,
    col, lwd=1, main, xylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NMixPlugCondDensJoint2_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixPlugCondDensJoint2</code>.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensJoint2_+3A_ixcond">ixcond</code></td>
<td>
<p>if given then conditional densities of all pairs of margins given <code>x[[icond]][ixcond]</code> are plotted where
<code>icond</code> is taken from <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensJoint2_+3A_imargin">imargin</code></td>
<td>
<p>vector of length 2.
if given then conditional densities of the (<code>imargin[1]</code>,
<code>imargin[2]</code>) pair of margins given all values of <code>x[[icond]]</code>
are plotted.
</p>
</td></tr>  
<tr><td><code id="plot.NMixPlugCondDensJoint2_+3A_contour">contour</code></td>
<td>
<p>logical. If <code>TRUE</code> then contours are drawn,
otherwise image plot is created.
</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensJoint2_+3A_add.contour">add.contour</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>contour</code> is
<code>FALSE</code> (i.e., image plot is drawn) then contours are added to
the image plots.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensJoint2_+3A_col.add.contour">col.add.contour</code></td>
<td>
<p>color of contours which are added to the image plot.</p>
</td></tr>  
<tr><td><code id="plot.NMixPlugCondDensJoint2_+3A_auto.layout">auto.layout</code></td>
<td>
<p>if <code>TRUE</code> then the function determines itself
how to divide the plotting region to draw densities for all margins.
</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensJoint2_+3A_col">col</code></td>
<td>
<p>color used to draw the contours or images.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensJoint2_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensJoint2_+3A_main">main</code></td>
<td>
<p>main title of the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensJoint2_+3A_xylab">xylab</code></td>
<td>
<p>optional character vector of the length equal to
the number of margins with labels used for x and y axes on the plots.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensJoint2_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixPlugCondDensJoint2">NMixPlugCondDensJoint2</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='plot.NMixPlugCondDensMarg'>
Plot computed univariate conditional densities (plug-in estimate)
</h2><span id='topic+plot.NMixPlugCondDensMarg'></span>

<h3>Description</h3>

<p>This is a basic plotting tool to visualize computed plug-in estimates
of univariate conditional densities, see <code><a href="#topic+NMixPlugCondDensMarg">NMixPlugCondDensMarg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMixPlugCondDensMarg'
plot(x, ixcond, imargin, over=FALSE,
    auto.layout=TRUE, type="l", lwd=1, lty, col, main, xlab, ylab, ylim,
    annot=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixPlugCondDensMarg</code>.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_ixcond">ixcond</code></td>
<td>
<p>if given then conditional densities of all margins given <code>x[[icond]][ixcond]</code> are plotted where
<code>icond</code> is taken from <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_imargin">imargin</code></td>
<td>
<p>if given then conditional densities of the <code>imargin</code>-th margin given all values of <code>x[[icond]]</code>
are plotted - either separately or all in one plot.
</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_over">over</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>imargin</code> is given then
all conditional densities are drawn in one plot.
</p>
</td></tr>  
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_auto.layout">auto.layout</code></td>
<td>
<p>if <code>TRUE</code> then the function determines itself
how to divide the plotting region to draw the computed densities.
</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_type">type</code></td>
<td>
<p>type of the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>  
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_col">col</code></td>
<td>
<p>color used to draw the lines. It can be a vector in which
case different lines are drawn in different colors.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_lty">lty</code></td>
<td>
<p>type of the line. It can be a vector in which
case different lines are drawn in different types.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_main">main</code></td>
<td>
<p>main title of the plot. Either character which is
replicated or a vector of characters.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis. Either character which is
replicated or a vector of characters.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis. Either character which is
replicated or a vector of characters.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y-axis.</p>
</td></tr>  
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_annot">annot</code></td>
<td>
<p>if <code>TRUE</code> and <code>imargin</code> is given and
<code>over</code> is <code>TRUE</code> then a legend is added to the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugCondDensMarg_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixPlugCondDensMarg">NMixPlugCondDensMarg</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='plot.NMixPlugDensJoint2'>
Plot computed marginal pairwise bivariate densities (plug-in estimate)
</h2><span id='topic+plot.NMixPlugDensJoint2'></span>

<h3>Description</h3>

<p>This is a basic plotting tool to visualize computed marginal pairwise
bivariate densities (plug-in version) using the
<code><a href="graphics.html#topic+contour">contour</a></code> plot. See also <code><a href="#topic+NMixPlugDensJoint2">NMixPlugDensJoint2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMixPlugDensJoint2'
plot(x, contour=FALSE,
    add.contour=TRUE, col.add.contour="brown",
    auto.layout=TRUE,
    col, lwd=1, main, xylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NMixPlugDensJoint2_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixPlugDensJoint2</code>.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensJoint2_+3A_contour">contour</code></td>
<td>
<p>logical. If <code>TRUE</code> then contours are drawn,
otherwise image plot is created.
</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensJoint2_+3A_add.contour">add.contour</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>contour</code> is
<code>FALSE</code> (i.e., image plot is drawn) then contours are added to
the image plots.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensJoint2_+3A_col.add.contour">col.add.contour</code></td>
<td>
<p>color of contours which are added to the image plot.</p>
</td></tr>  
<tr><td><code id="plot.NMixPlugDensJoint2_+3A_auto.layout">auto.layout</code></td>
<td>
<p>if <code>TRUE</code> then the function determines itself
how to divide the plotting region to draw densities for all margins.
</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensJoint2_+3A_col">col</code></td>
<td>
<p>color used to draw the contours or images.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensJoint2_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensJoint2_+3A_main">main</code></td>
<td>
<p>main title of the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensJoint2_+3A_xylab">xylab</code></td>
<td>
<p>optional character vector of the length equal to
the number of margins with labels used for x and y axes on the
plots.
</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensJoint2_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixPlugDensJoint2">NMixPlugDensJoint2</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='plot.NMixPlugDensMarg'>
Plot computed marginal predictive densities
</h2><span id='topic+plot.NMixPlugDensMarg'></span>

<h3>Description</h3>

<p>This is a basic plotting tool to visualize computed marginal
plug-in estimates of densities, see <code><a href="#topic+NMixPlugDensMarg">NMixPlugDensMarg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMixPlugDensMarg'
plot(x, auto.layout=TRUE,
    type="l", col="darkblue", lty=1, lwd=1, main, xlab, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NMixPlugDensMarg_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixPlugDensMarg</code>.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensMarg_+3A_auto.layout">auto.layout</code></td>
<td>
<p>if <code>TRUE</code> then the function determines itself
how to divide the plotting region to draw densities for all margins.
</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensMarg_+3A_type">type</code></td>
<td>
<p>type of the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensMarg_+3A_col">col</code></td>
<td>
<p>color used to draw the lines.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensMarg_+3A_lty">lty</code></td>
<td>
<p>type of the line.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensMarg_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensMarg_+3A_main">main</code></td>
<td>
<p>main title of the plot. Either character which is
replicated or a vector of characters of the length equal to the number of margins.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensMarg_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis. Either character which is
replicated or a vector of characters of the length equal to the number of margins.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensMarg_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis. Either character which is
replicated or a vector of characters of the length equal to the number of margins.</p>
</td></tr>
<tr><td><code id="plot.NMixPlugDensMarg_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixPlugDensMarg">NMixPlugDensMarg</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='plot.NMixPredCDFMarg'>
Plot computed marginal predictive cumulative distribution functions
</h2><span id='topic+plot.NMixPredCDFMarg'></span>

<h3>Description</h3>

<p>This is a basic plotting tool to visualize computed marginal
cumulative distribution functions, see <code><a href="#topic+NMixPredCDFMarg">NMixPredCDFMarg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMixPredCDFMarg'
plot(x, K=0, auto.layout=TRUE,
    type="l", col="darkblue", lty=1, lwd=1, main, xlab, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NMixPredCDFMarg_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixPredCDFMarg</code>.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCDFMarg_+3A_k">K</code></td>
<td>
<p>if equal to <code>0</code> then the overall predictive CDF's
are plotted taken from the <code>dens</code> part of the object <code>x</code>.
</p>
<p>If higher than <code>0</code> then the predictive CDF conditioned by
the value of <code>K</code> is plotted (taken from the <code>densK</code> part
of the object <code>x</code>).
</p>
</td></tr>
<tr><td><code id="plot.NMixPredCDFMarg_+3A_auto.layout">auto.layout</code></td>
<td>
<p>if <code>TRUE</code> then the function determines itself
how to divide the plotting region to draw densities for all margins.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredCDFMarg_+3A_type">type</code></td>
<td>
<p>type of the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCDFMarg_+3A_col">col</code></td>
<td>
<p>color used to draw the lines.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCDFMarg_+3A_lty">lty</code></td>
<td>
<p>type of the line.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCDFMarg_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCDFMarg_+3A_main">main</code></td>
<td>
<p>main title of the plot. Either character which is
replicated or a vector of characters of the length equal to the number of margins.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCDFMarg_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis. Either character which is
replicated or a vector of characters of the length equal to the number of margins.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCDFMarg_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis. Either character which is
replicated or a vector of characters of the length equal to the number of margins.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCDFMarg_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2009).
A new R package for Bayesian estimation of multivariate normal mixtures allowing for selection 
of the number of components and interval-censored data.
<em>Computational Statistics and Data Analysis</em>, <b>53</b>(12), 3932&ndash;3947.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixPredCDFMarg">NMixPredCDFMarg</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='plot.NMixPredCondCDFMarg'>
Plot computed univariate conditional predictive cumulative
distribution functions
</h2><span id='topic+plot.NMixPredCondCDFMarg'></span>

<h3>Description</h3>

<p>This is a basic plotting tool to visualize computed posterior
predictive estimates
of univariate conditional cdf's, see <code><a href="#topic+NMixPredCondCDFMarg">NMixPredCondCDFMarg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMixPredCondCDFMarg'
plot(x, ixcond, imargin, prob, over=FALSE,
    auto.layout=TRUE, type="l", lwd=1, lty, col, qlwd=1, qlty, qcol,
    main, xlab, ylab, ylim,
    annot=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixPredCondCDFMarg</code>.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_ixcond">ixcond</code></td>
<td>
<p>if given then conditional cdf's of all margins given <code>x[[icond]][ixcond]</code> are plotted where
<code>icond</code> is taken from <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_imargin">imargin</code></td>
<td>
<p>if given then conditional cdf's of the <code>imargin</code>-th margin given all values of <code>x[[icond]]</code>
are plotted - either separately or all in one plot.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_prob">prob</code></td>
<td>
<p>probabilities of pointwise posterior quantiles which
should be added to the plot. Computed values of requested posterior
quantiles must be present in the object <code>x</code> (see argument
<code>prob</code> of <code><a href="#topic+NMixPredCondCDFMarg">NMixPredCondCDFMarg</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_over">over</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>imargin</code> is given then
all conditional cdf's are drawn in one plot.
</p>
</td></tr>  
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_auto.layout">auto.layout</code></td>
<td>
<p>if <code>TRUE</code> then the function determines itself
how to divide the plotting region to draw the computed cdf's.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_type">type</code></td>
<td>
<p>type of the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>  
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_lty">lty</code></td>
<td>
<p>type of the line. It can be a vector in which
case different lines are drawn in different types.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_col">col</code></td>
<td>
<p>color used to draw the lines. It can be a vector in which
case different lines are drawn in different colors.</p>
</td></tr>  
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_qlwd">qlwd</code></td>
<td>
<p>line width for pointwise posterior quantiles.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_qlty">qlty</code></td>
<td>
<p>type of the line for pointwise posterior quantiles.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_qcol">qcol</code></td>
<td>
<p>color used to draw pointwise posterior quantiles.</p>
</td></tr>    
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_main">main</code></td>
<td>
<p>main title of the plot. Either character which is
replicated or a vector of characters.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis. Either character which is
replicated or a vector of characters.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis. Either character which is
replicated or a vector of characters.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_annot">annot</code></td>
<td>
<p>if <code>TRUE</code> and <code>imargin</code> is given and
<code>over</code> is <code>TRUE</code> then a legend is added to the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondCDFMarg_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixPredCondCDFMarg">NMixPredCondCDFMarg</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='plot.NMixPredCondDensJoint2'>
Plot computed predictive pairwise bivariate conditional densities
</h2><span id='topic+plot.NMixPredCondDensJoint2'></span>

<h3>Description</h3>

<p>This is a basic plotting tool to visualize computed 
predictive pairwise bivariate conditional densities using the
<code><a href="graphics.html#topic+image">image</a></code> or <code><a href="graphics.html#topic+contour">contour</a></code> plot.
See also <code><a href="#topic+NMixPredCondDensJoint2">NMixPredCondDensJoint2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMixPredCondDensJoint2'
plot(x, ixcond, imargin,
    contour=FALSE,
    add.contour=TRUE, col.add.contour="brown",
    auto.layout=TRUE,
    col, lwd=1, main, xylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NMixPredCondDensJoint2_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixPredCondDensJoint2</code>.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensJoint2_+3A_ixcond">ixcond</code></td>
<td>
<p>if given then conditional densities of all pairs of margins given <code>x[[icond]][ixcond]</code> are plotted where
<code>icond</code> is taken from <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensJoint2_+3A_imargin">imargin</code></td>
<td>
<p>vector of length 2.
if given then conditional densities of the (<code>imargin[1]</code>,
<code>imargin[2]</code>) pair of margins given all values of <code>x[[icond]]</code>
are plotted.
</p>
</td></tr>  
<tr><td><code id="plot.NMixPredCondDensJoint2_+3A_contour">contour</code></td>
<td>
<p>logical. If <code>TRUE</code> then contours are drawn,
otherwise image plot is created.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensJoint2_+3A_add.contour">add.contour</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>contour</code> is
<code>FALSE</code> (i.e., image plot is drawn) then contours are added to
the image plots.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensJoint2_+3A_col.add.contour">col.add.contour</code></td>
<td>
<p>color of contours which are added to the image plot.</p>
</td></tr>  
<tr><td><code id="plot.NMixPredCondDensJoint2_+3A_auto.layout">auto.layout</code></td>
<td>
<p>if <code>TRUE</code> then the function determines itself
how to divide the plotting region to draw densities for all margins.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensJoint2_+3A_col">col</code></td>
<td>
<p>color used to draw the contours or images.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensJoint2_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensJoint2_+3A_main">main</code></td>
<td>
<p>main title of the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensJoint2_+3A_xylab">xylab</code></td>
<td>
<p>optional character vector of the length equal to
the number of margins with labels used for x and y axes on the plots.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensJoint2_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixPredCondDensJoint2">NMixPredCondDensJoint2</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='plot.NMixPredCondDensMarg'>
Plot computed univariate conditional predictive densities
</h2><span id='topic+plot.NMixPredCondDensMarg'></span>

<h3>Description</h3>

<p>This is a basic plotting tool to visualize computed posterior predictive estimates
of univariate conditional densities, see <code><a href="#topic+NMixPredCondDensMarg">NMixPredCondDensMarg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMixPredCondDensMarg'
plot(x, ixcond, imargin, prob, over=FALSE,
    auto.layout=TRUE, type="l", lwd=1, lty, col, qlwd=1, qlty, qcol,
    main, xlab, ylab, ylim,
    annot=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixPredCondDensMarg</code>.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_ixcond">ixcond</code></td>
<td>
<p>if given then conditional densities of all margins given <code>x[[icond]][ixcond]</code> are plotted where
<code>icond</code> is taken from <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_imargin">imargin</code></td>
<td>
<p>if given then conditional densities of the <code>imargin</code>-th margin given all values of <code>x[[icond]]</code>
are plotted - either separately or all in one plot.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_prob">prob</code></td>
<td>
<p>probabilities of pointwise posterior quantiles which
should be added to the plot. Computed values of requested posterior
quantiles must be present in the object <code>x</code> (see argument
<code>prob</code> of <code><a href="#topic+NMixPredCondDensMarg">NMixPredCondDensMarg</a></code>).
</p>
</td></tr>  
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_over">over</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>imargin</code> is given then
all conditional densities are drawn in one plot.
</p>
</td></tr>  
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_auto.layout">auto.layout</code></td>
<td>
<p>if <code>TRUE</code> then the function determines itself
how to divide the plotting region to draw the computed densities.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_type">type</code></td>
<td>
<p>type of the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_lty">lty</code></td>
<td>
<p>type of the line. It can be a vector in which
case different lines are drawn in different types.</p>
</td></tr>  
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_col">col</code></td>
<td>
<p>color used to draw the lines. It can be a vector in which
case different lines are drawn in different colors.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_qlwd">qlwd</code></td>
<td>
<p>line width for pointwise posterior quantiles.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_qlty">qlty</code></td>
<td>
<p>type of the line for pointwise posterior quantiles.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_qcol">qcol</code></td>
<td>
<p>color used to draw pointwise posterior quantiles.</p>
</td></tr>  
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_main">main</code></td>
<td>
<p>main title of the plot. Either character which is
replicated or a vector of characters.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis. Either character which is
replicated or a vector of characters.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis. Either character which is
replicated or a vector of characters.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_annot">annot</code></td>
<td>
<p>if <code>TRUE</code> and <code>imargin</code> is given and
<code>over</code> is <code>TRUE</code> then a legend is added to the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPredCondDensMarg_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixPredCondDensMarg">NMixPredCondDensMarg</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>

<hr>
<h2 id='plot.NMixPredDensJoint2'>
Plot computed marginal pairwise bivariate predictive densities
</h2><span id='topic+plot.NMixPredDensJoint2'></span>

<h3>Description</h3>

<p>This is a basic plotting tool to visualize computed marginal pairwise
bivariate predictive densities using the
<code><a href="graphics.html#topic+image">image</a></code> plot or <code><a href="graphics.html#topic+contour">contour</a></code>
plot.
See also <code><a href="#topic+NMixPredDensJoint2">NMixPredDensJoint2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMixPredDensJoint2'
plot(x, K=0, contour=FALSE,
    add.contour=TRUE, col.add.contour="brown",
    auto.layout=TRUE,
    col, lwd=1, main, xylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NMixPredDensJoint2_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixPredDensJoint2</code>.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensJoint2_+3A_k">K</code></td>
<td>
<p>if equal to <code>0</code> then the overall predictive densities
are plotted taken from the <code>dens</code> part of the object <code>x</code>.
</p>
<p>If higher than <code>0</code> then the predictive density conditioned by
the value of <code>K</code> is plotted (taken from the <code>densK</code> part
of the object <code>x</code>).
</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensJoint2_+3A_contour">contour</code></td>
<td>
<p>logical. If <code>TRUE</code> then contours are drawn,
otherwise image plot is created.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensJoint2_+3A_add.contour">add.contour</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>contour</code> is
<code>FALSE</code> (i.e., image plot is drawn) then contours are added to
the image plots.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensJoint2_+3A_col.add.contour">col.add.contour</code></td>
<td>
<p>color of contours which are added to the image plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensJoint2_+3A_auto.layout">auto.layout</code></td>
<td>
<p>if <code>TRUE</code> then the function determines itself
how to divide the plotting region to draw densities for all margins.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensJoint2_+3A_col">col</code></td>
<td>
<p>color used to draw the contours or images.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensJoint2_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensJoint2_+3A_main">main</code></td>
<td>
<p>main title of the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensJoint2_+3A_xylab">xylab</code></td>
<td>
<p>optional character vector of the length equal to
the number of margins with labels used for x and y axes on the plots.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensJoint2_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2009).
A new R package for Bayesian estimation of multivariate normal mixtures allowing for selection 
of the number of components and interval-censored data.
<em>Computational Statistics and Data Analysis</em>, <b>53</b>(12), 3932&ndash;3947.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixPredDensJoint2">NMixPredDensJoint2</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See additional material available in 
## YOUR_R_DIR/library/mixAK/doc/
## or YOUR_R_DIR/site-library/mixAK/doc/
## - files Galaxy.R, Faithful.R, Tandmob.R and
## http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/Galaxy.pdf
## http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/Faithful.pdf
## http://www.karlin.mff.cuni.cz/~komarek/software/mixAK/Tandmob.pdf
</code></pre>

<hr>
<h2 id='plot.NMixPredDensMarg'>
Plot computed marginal predictive densities
</h2><span id='topic+plot.NMixPredDensMarg'></span>

<h3>Description</h3>

<p>This is a basic plotting tool to visualize computed marginal
predictive densities, see <code><a href="#topic+NMixPredDensMarg">NMixPredDensMarg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMixPredDensMarg'
plot(x, K=0, auto.layout=TRUE,
    type="l", col="darkblue", lty=1, lwd=1, main, xlab, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NMixPredDensMarg_+3A_x">x</code></td>
<td>
<p>an object of class <code>NMixPredDensMarg</code>.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensMarg_+3A_k">K</code></td>
<td>
<p>if equal to <code>0</code> then the overall predictive densities
are plotted taken from the <code>dens</code> part of the object <code>x</code>.
</p>
<p>If higher than <code>0</code> then the predictive density conditioned by
the value of <code>K</code> is plotted (taken from the <code>densK</code> part
of the object <code>x</code>).
</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensMarg_+3A_auto.layout">auto.layout</code></td>
<td>
<p>if <code>TRUE</code> then the function determines itself
how to divide the plotting region to draw densities for all margins.
</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensMarg_+3A_type">type</code></td>
<td>
<p>type of the plot.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensMarg_+3A_col">col</code></td>
<td>
<p>color used to draw the lines.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensMarg_+3A_lty">lty</code></td>
<td>
<p>type of the line.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensMarg_+3A_lwd">lwd</code></td>
<td>
<p>line width.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensMarg_+3A_main">main</code></td>
<td>
<p>main title of the plot. Either character which is
replicated or a vector of characters of the length equal to the number of margins.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensMarg_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis. Either character which is
replicated or a vector of characters of the length equal to the number of margins.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensMarg_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis. Either character which is
replicated or a vector of characters of the length equal to the number of margins.</p>
</td></tr>
<tr><td><code id="plot.NMixPredDensMarg_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code>plot</code> function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A. (2009).
A new R package for Bayesian estimation of multivariate normal mixtures allowing for selection 
of the number of components and interval-censored data.
<em>Computational Statistics and Data Analysis</em>, <b>53</b>(12), 3932&ndash;3947.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixPredDensMarg">NMixPredDensMarg</a></code>, <code><a href="#topic+NMixMCMC">NMixMCMC</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See additional material available in 
## YOUR_R_DIR/library/mixAK/doc/
## or YOUR_R_DIR/site-library/mixAK/doc/
## https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/Galaxy.pdf
## https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/Faithful.pdf
## https://www2.karlin.mff.cuni.cz/~komarek/software/mixAK/Tandmob.pdf
##
</code></pre>

<hr>
<h2 id='plotProfiles'>Plot individual longitudinal profiles</h2><span id='topic+plotProfiles'></span>

<h3>Description</h3>

<p>It creates a plot of individual longitudinal profiles. It
is based on the output from <code>getProfiles</code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotProfiles(ip, data, var, trans, tvar, gvar,
             auto.layout=TRUE, lines=TRUE, points=FALSE, add=FALSE,
             xlab="Time", ylab, xaxt="s", yaxt="s", xlim, ylim, main,
             lcol, col, bg, lty=1, lwd=1, pch=21, cex.points=1,
             highlight, lines.highlight=TRUE, points.highlight=TRUE,
             lcol.highlight="red3", col.highlight="red3", bg.highlight="orange",
             lty.highlight=1, lwd.highlight=2,
             pch.highlight=23, cex.highlight=1)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotProfiles_+3A_ip">ip</code></td>
<td>
<p>output from <code><a href="#topic+getProfiles">getProfiles</a></code> function containing
extracted individual longitudinal profiles of each subject.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> used to produce <code>ip</code>. It is used to
detect ranges for some variables.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_var">var</code></td>
<td>
<p>character string identifying the response variable to plot.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_trans">trans</code></td>
<td>
<p>possible transformation of the response variable.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_tvar">tvar</code></td>
<td>
<p>character string identifying the time variable.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_gvar">gvar</code></td>
<td>
<p>character string identifying the group variable for which
different colors are used.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_auto.layout">auto.layout</code></td>
<td>
<p>logical. If <code>TRUE</code>, the layout of the plotting
region is determined automatically.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_lines">lines</code></td>
<td>
<p>logical. If <code>TRUE</code>, lines are drawn in the plot
connecting observations within individuals.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_points">points</code></td>
<td>
<p>logical. If <code>TRUE</code>, points are added to the plot.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_add">add</code></td>
<td>
<p>logical. If <code>TRUE</code>, the new plot overlays the old
one.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_lcol">lcol</code></td>
<td>
<p>color for lines.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_col">col</code></td>
<td>
<p>color for points.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_xlab">xlab</code>, <code id="plotProfiles_+3A_ylab">ylab</code>, <code id="plotProfiles_+3A_xaxt">xaxt</code>, <code id="plotProfiles_+3A_yaxt">yaxt</code>, <code id="plotProfiles_+3A_xlim">xlim</code>, <code id="plotProfiles_+3A_ylim">ylim</code>, <code id="plotProfiles_+3A_main">main</code>, <code id="plotProfiles_+3A_bg">bg</code>, <code id="plotProfiles_+3A_lty">lty</code>, <code id="plotProfiles_+3A_lwd">lwd</code>, <code id="plotProfiles_+3A_pch">pch</code></td>
<td>
<p>arguments passed to
standard plotting functions. <code>col</code> might also be a vector in
which case different colors are used for profiles from different
groups identified by the <code>gvar</code> variable.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_cex.points">cex.points</code></td>
<td>
<p>passed as a <code>cex</code> argument to
<code><a href="graphics.html#topic+points">points</a></code> function used when <code>points = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_highlight">highlight</code></td>
<td>
<p>an optional numeric vector giving the indeces of
<code>ip</code> for which the longitudinal profiles should be highlighted.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_lines.highlight">lines.highlight</code></td>
<td>
<p>logical. If <code>TRUE</code>, highlighting is done
using lines.</p>
</td></tr>
<tr><td><code id="plotProfiles_+3A_points.highlight">points.highlight</code></td>
<td>
<p>logical. If <code>TRUE</code>, highlighting is done
using points.</p>
</td></tr>  
<tr><td><code id="plotProfiles_+3A_lcol.highlight">lcol.highlight</code>, <code id="plotProfiles_+3A_col.highlight">col.highlight</code>, <code id="plotProfiles_+3A_bg.highlight">bg.highlight</code>, <code id="plotProfiles_+3A_lty.highlight">lty.highlight</code>, <code id="plotProfiles_+3A_lwd.highlight">lwd.highlight</code>, <code id="plotProfiles_+3A_pch.highlight">pch.highlight</code>, <code id="plotProfiles_+3A_cex.highlight">cex.highlight</code></td>
<td>
<p>arguments <code>col</code>, <code>bg</code>, <code>lty</code>,
<code>lwd</code>, <code>pch</code>, <code>cex</code> passed to <code><a href="graphics.html#topic+lines">lines</a></code> and/or <code><a href="graphics.html#topic+points">points</a></code>
functions which provide highlighting of selected profiles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>ip</code>.</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getProfiles">getProfiles</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PBCseq, package="mixAK")
ip &lt;- getProfiles(t="day", y=c("age", "fdrug", "bili", "platelet", "spiders"),
                  id="id", data=PBCseq)

XLIM &lt;- c(0, 910)
lcol2 &lt;- c("darkgreen", "red")

oldPar &lt;- par(mfrow=c(1, 3), bty="n")
plotProfiles(ip=ip, data=PBCseq, xlim=XLIM, var="bili", trans=log, tvar="day", gvar="fdrug",
             xlab="Time (days)", col=lcol2, auto.layout=FALSE, main="Log(bilirubin)",
             highlight=c(2, 4), col.highlight="darkblue")
plotProfiles(ip=ip, data=PBCseq, xlim=XLIM, var="platelet", tvar="day", gvar="fdrug",
             xlab="Time (days)", col=lcol2, auto.layout=FALSE, main="Platelet count",
             highlight=c(2, 4), col.highlight="darkblue")
plotProfiles(ip=ip, data=PBCseq, xlim=XLIM, var="spiders",  tvar="day", gvar="fdrug",
             xlab="Time (days)", col=lcol2, auto.layout=FALSE,
             lines=FALSE, points=TRUE,
             highlight=c(2, 4), col.highlight="darkblue", bg.highlight="skyblue") 
par(oldPar)
</code></pre>

<hr>
<h2 id='rRotationMatrix'>
Random rotation matrix
</h2><span id='topic+rRotationMatrix'></span><span id='topic+C_RotationMatrix_R'></span>

<h3>Description</h3>

<p>Generate a random rotation matrix, i.e., a matrix
<code class="reqn">\boldsymbol{P} = (p_{i,j})_{i=1,\dots,p, j=1,\dots,p},</code>
which satisfies
</p>
<p>a) <code class="reqn">\boldsymbol{P}\boldsymbol{P}' = \boldsymbol{I}</code>,
</p>
<p>b) <code class="reqn">\boldsymbol{P}'\boldsymbol{P} = \boldsymbol{I}</code>,
</p>
<p>c) <code class="reqn">\mbox{det}(\boldsymbol{P}) = 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rRotationMatrix(n, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rRotationMatrix_+3A_n">n</code></td>
<td>
<p>number of matrices to generate.</p>
</td></tr>
<tr><td><code id="rRotationMatrix_+3A_dim">dim</code></td>
<td>
<p>dimension of a generated matrix/matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>dim</code> = 2, <code class="reqn">p_{2,1}</code>
(<code class="reqn">\sin(\theta)</code>)
is generated from Unif(0, 1) and the rest computed as follows:
<code class="reqn">p_{1,1} = p_{2,2} = \sqrt{1 - p_{2,1}^2}</code>
(<code class="reqn">\cos(\theta)</code>) and
<code class="reqn">p_{1,2} = -p_{2,1}</code>
(<code class="reqn">-\sin(\theta)</code>).
</p>
<p>For <code>dim</code> <code class="reqn">&gt;</code> 2, the matrix <code class="reqn">\boldsymbol{P}</code> is generated
in the following steps:
</p>
<p>1) Generate a <code class="reqn">p\times p</code> matrix <code class="reqn">\boldsymbol{A}</code> with
independent Unif(0, 1) elements and check whether <code class="reqn">\boldsymbol{A}</code>
is of full rank <code class="reqn">p</code>.
</p>
<p>2) Computes a QR decomposition of <code class="reqn">\boldsymbol{A}</code>, i.e.,
<code class="reqn">\boldsymbol{A} = \boldsymbol{Q}\boldsymbol{R}</code> where
<code class="reqn">\boldsymbol{Q}</code> satisfies
<code class="reqn">\boldsymbol{Q}\boldsymbol{Q}' = \boldsymbol{I}</code>,
<code class="reqn">\boldsymbol{Q}'\boldsymbol{Q} = \boldsymbol{I}</code>,
<code class="reqn">\mbox{det}(\boldsymbol{Q}) = (-1)^{p+1}</code>,
and columns of <code class="reqn">\boldsymbol{Q}</code> spans the linear space generated by
the columns of <code class="reqn">\boldsymbol{A}</code>.
</p>
<p>3) For odd <code>dim</code>, return matrix <code class="reqn">\boldsymbol{Q}</code>. For even
<code>dim</code>, return corrected matrix <code class="reqn">\boldsymbol{Q}</code> to satisfy the
determinant condition.
</p>


<h3>Value</h3>

<p>For <code>n</code>=1, a matrix is returned.
</p>
<p>For <code>n</code>&gt;1, a list of matrices is returned.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Golub, G. H. and Van Loan, C. F. (1996, Sec. 5.1).
<em>Matrix Computations. Third Edition</em>.
Baltimore: The Johns Hopkins University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- rRotationMatrix(n=1, dim=5)
print(P)
round(P %*% t(P), 10)
round(t(P) %*% P, 10)
det(P)

n &lt;- 10
P &lt;- rRotationMatrix(n=n, dim=5)
for (i in 1:3){
  cat(paste("*** i=", i, "\n", sep=""))
  print(P[[i]])
  print(round(P[[i]] %*% t(P[[i]]), 10))
  print(round(t(P[[i]]) %*% P[[i]], 10))
  print(det(P[[i]]))
}
</code></pre>

<hr>
<h2 id='rSamplePair'>
Sample a pair (with replacement)
</h2><span id='topic+rSamplePair'></span><span id='topic+C_SamplePair_R'></span>

<h3>Description</h3>

<p>For given <code class="reqn">K</code>, the function samples with replacement from a
uniform distribution on a set of pairs
<code class="reqn">(1,2), (1,3), \ldots, (1,K), (2,3), \ldots, (2,K), \ldots, (K-1,K).</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rSamplePair(n, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSamplePair_+3A_n">n</code></td>
<td>
<p>number of pairs to sample.</p>
</td></tr>
<tr><td><code id="rSamplePair_+3A_k">K</code></td>
<td>
<p>a numeric value which determines <code class="reqn">K</code> (see above).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-component numeric vector for <code>n</code><code class="reqn">=2</code> or a matrix with 2
columns with sampled pairs in rows for <code>n</code><code class="reqn">&gt;2.</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rSamplePair(n=1, K=2)
rSamplePair(n=10, K=2)

rSamplePair(n=1, K=3)
rSamplePair(n=10, K=3)

rSamplePair(n=1, K=4)
rSamplePair(n=10, K=4)
</code></pre>

<hr>
<h2 id='SimData'>Simulated dataset</h2><span id='topic+SimData'></span>

<h3>Description</h3>

<p>A simulated dataset used as an example dataset in Komárek and
Komárková (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SimData)</code></pre>


<h3>Format</h3>

<p>a data frame with 1 157 rows
and the following variables
</p>

<dl>
<dt>id</dt><dd><p>identification number of a subject.</p>
</dd>
<dt>tday</dt><dd><p>visit time in days.</p>
</dd>
<dt>tmonth</dt><dd><p>visit time in months.</p>
</dd>
<dt>yN</dt><dd><p>response variable generated according to a linear mixed
model with normal errors. It intentionally contains 50 <code>NA</code>'s.</p>
</dd>
<dt>yP</dt><dd><p>response variable generated according to a Poisson
generalized linear mixed model. It intentionally contains 50 <code>NA</code>'s.</p>
</dd>
<dt>yB</dt><dd><p>response variable generated according to a Bernoulli
generalized linear mixed model. It intentionally contains 50
<code>NA</code>'s.</p>
</dd>
<dt>yBjit</dt><dd><p>a jittered version of <code>yB</code>.</p>
</dd>







</dl>
  


<h3>References</h3>

<p>Komárek, A. and Komárková, L. (2014).
Capabilities of R package mixAK for clustering based on multivariate continuous and discrete longitudinal data.
<em>Journal of Statistical Software</em>, <b>59</b>(12), 1&ndash;38.
<a href="https://doi.org/10.18637/jss.v059.i12">doi:10.18637/jss.v059.i12</a>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SimData)
summary(SimData)
</code></pre>

<hr>
<h2 id='SP2Rect'>
Conversion of a symmetric matrix stored in a packed format (lower triangle only) into a matrix
</h2><span id='topic+SP2Rect'></span>

<h3>Description</h3>

<p>It creates a symmetric matrix from its lower triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  SP2Rect(LT, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SP2Rect_+3A_lt">LT</code></td>
<td>
<p>a numeric vector with the lower triangle (stored columnwise)
of the matrix we want to reconstruct.</p>
</td></tr>
<tr><td><code id="SP2Rect_+3A_dim">dim</code></td>
<td>
<p>number of rows and columns of a resulting matrix.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SP2Rect(3, dim=1)
SP2Rect(c(1, 0.5, 2), dim=2)
SP2Rect(c(1, 0.5, 0.25, 2, -0.5, 3), dim=3)
</code></pre>

<hr>
<h2 id='summaryDiff'>
Posterior summary statistics for a difference of two quantities
</h2><span id='topic+summaryDiff'></span>

<h3>Description</h3>

<p>It calculates (posterior) summary statistics for a difference of two quantities supplied as (MCMC) samples
Within <code>mixAK</code> package it is primarily used to calculate posterior summary for the difference of the
deviances of two competing models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryDiff(x, y, prob=c(0.025, 0.5, 0.975), cut=c(-2*log(9), 0), na.rm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryDiff_+3A_x">x</code></td>
<td>
<p>a numeric vector with the sample of the first quantity.</p>
</td></tr>
<tr><td><code id="summaryDiff_+3A_y">y</code></td>
<td>
<p>a numeric vector with the sample of the second quantity to be subtracted from <code>x</code>.</p>
</td></tr>
<tr><td><code id="summaryDiff_+3A_prob">prob</code></td>
<td>
<p>a numeric vector of probabilities for quantiles to be calculated from the sample of differences.</p>
</td></tr>
<tr><td><code id="summaryDiff_+3A_cut">cut</code></td>
<td>
<p>numeric value(s) which specify the cutoff(s) we are interested in estimating
<code class="reqn">\mbox{P}(x - y &lt; \mbox{cut})</code> from the sample. The default values are motivated by
the arguments given in Section 4 of Aitkin, Liu and Chadwick (2009)
and in Section 7.5 of Aitkin (2010).
</p>
</td></tr>
<tr><td><code id="summaryDiff_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating on how to handle <code>NA</code>'s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>
<table>
<tr><td><code>summary</code></td>
<td>
<p>a named vector with the (posterior) summary statistics
based on the differences.</p>
</td></tr>
<tr><td><code>Pcut</code></td>
<td>
<p>estimated (posterior) probabilities that the difference
lies below the <code>cut</code> values.</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Aitkin, M. (2010).
<em>Statistical Inference: An Integrated Bayesian/Likelihood Approach.</em>
Boca Raton: CRC Press.
</p>
<p>Aitkin, M., Liu, C. C., and Chadwick, T. (2009).
Bayesian model comparison and model averaging for small-area
estimation.
<em>Annals of Applied Statistics</em>, <b>3</b>, 199-221.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(16336886)
x &lt;- runif(100, 0, 100)
y &lt;- runif(100, 0, 100)
sdiff &lt;- summaryDiff(x, y)
</code></pre>

<hr>
<h2 id='Tandmob'>Signal Tandmobiel data</h2><span id='topic+Tandmob'></span>

<h3>Description</h3>

<p>This is the dataset resulting from a longitudinal prospective dental
study performed in Flanders (North of Belgium) in 1996 &ndash; 2001. The
cohort of 4 468 randomly sampled children who attended the first year
of the basic school at the beginning of the study was annualy dental
examined by one of 16 trained dentists.
The original dataset consists thus of at most 6 dental observations
for each child.
</p>
<p>The dataset presented here contains mainly the
information on the emergence and caries times summarized in the
interval-censored observations. Some baseline covariates are also
included here.
This is a copy of <code>tandmob2</code> data in the package <code>bayesSurv</code>.  

</p>
<p>For more detail on the design of the study see Vanobbergen et
al. (2000).
</p>
<p>This data set was used in the analyses presented in
Komárek et al. (2005), in
Lesaffre, Komárek, and Declerck (2005) and in
Komárek and Lesaffre (2007).
</p>
<p><b>IMPORTANT NOTICE:</b> It is possible to use these data for your
research work under the condition that each manuscript is first
approved by <br />
Prof. Emmanuel Lesaffre <br />
Leuven Biostatistics and statistical Bioinformatics Centre (L-BioStat) <br />
Katholieke Universiteit Leuven <br />
Kapucijnenvoer 35 <br />
B-3000 Leuven <br />
Belgium <br />
&lt;<code>emmanuel.lesaffre@kuleuven.be</code>&gt;  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Tandmob)</code></pre>


<h3>Format</h3>

<p>a data frame with 4 430 rows (38 sampled children did not come
to any of the designed dental examinations) and the following
variables
</p>

<dl>
<dt>IDNR</dt><dd><p>identification number of a child</p>
</dd>
<dt>GENDER</dt><dd><p>character <em>boy</em> or <em>girl</em></p>
</dd>
<dt>GENDERNum</dt><dd><p>numeric, 0 = <em>boy</em>, 1 = <em>girl</em></p>
</dd>
<dt>DOB</dt><dd><p>character, date of birth in the format DDmmmYY</p>
</dd>
<dt>PROVINCE</dt><dd><p>factor, code of the province with
</p>

<dl>
<dt>0 = </dt><dd><p>Antwerpen</p>
</dd>
<dt>1 = </dt><dd><p>Vlaams Brabant</p>
</dd>
<dt>2 = </dt><dd><p>Limburg</p>
</dd>
<dt>3 = </dt><dd><p>Oost Vlaanderen</p>
</dd>
<dt>4 = </dt><dd><p>West Vlaanderen</p>
</dd>
</dl>
  
</dd>
<dt>EDUC</dt><dd><p>factor, code of the educational system with
</p>

<dl>
<dt>0 = </dt><dd><p>Free</p>
</dd>
<dt>1 = </dt><dd><p>Community school</p>
</dd>
<dt>2 = </dt><dd><p>Province/council school</p>
</dd>
</dl>
  
</dd>
<dt>STARTBR</dt><dd><p>factor, code indicating the starting age of brushing
the teeth (as reported by parents) with
</p>

<dl>
<dt>1 = </dt><dd><p>[0, 1] years</p>
</dd>
<dt>2 = </dt><dd><p>(1, 2] years</p>
</dd>
<dt>3 = </dt><dd><p>(2, 3] years</p>
</dd>
<dt>4 = </dt><dd><p>(3, 4] years</p>
</dd>
<dt>5 = </dt><dd><p>(4, 5] years</p>
</dd>      
<dt>6 = </dt><dd><p>later than at the age of 5</p>
</dd>      
</dl>
  
</dd>
<dt>FLUOR</dt><dd><p>binary covariate, 0 = no, 1 = yes. This is the covariate
<em>fluorosis</em> used in the paper Komárek et al. (2005).
</p>
</dd>
<dt>BAD.xx</dt><dd><p>binary, indicator whether a deciduous tooth xx was
removed becaues of orthodontical reasons or not.
</p>
<p>xx takes values 53, 63, 73, 83 (deciduous lateral canines),
54, 64, 74, 84 (deciduous first molars),
55, 65, 75, 85 (deciduous second molars).
</p>
</dd>
<dt>EBEG.xx</dt><dd><p>lower limit of the emergence (in years of age) of the
permanent tooth xx. <code>NA</code> if the emergence was left-censored.
</p>
<p>xx takes values 11, 21, 31, 41 (permanent incisors),
12, 22, 32, 42 (permanent central canines),
13, 23, 33, 43 (permanent lateral canines),
14, 24, 34, 44 (permanent first premolars),
15, 25, 35, 45 (permanent second premolars),
16, 26, 36, 46 (permanent first molars),
17, 27, 37, 47 (permanent second molars).
</p>
</dd>
<dt>EEND.xx</dt><dd><p>upper limit of the emergence (in years of age) of the
permanent tooth xx. <code>NA</code> if the emergence was right-censored.
</p>
<p>xx takes values as for the variable <code>EBEG.xx</code>.
</p>
</dd>
<dt>FBEG.xx</dt><dd><p>lower limit for the caries time (in years of age, &lsquo;F&rsquo;
stands for &lsquo;failure&rsquo;) of the permanent tooth xx. <code>NA</code> if the
caries time was left-censored.
</p>
<p>xx takes values as for the variable <code>EBEG.xx</code>.    
</p>
</dd>
<dt>FEND.xx</dt><dd><p>upper limit for the caries time (in years of age, &lsquo;F&rsquo;
stands for &lsquo;failure&rsquo;) of the permanent tooth xx. <code>NA</code> if the
caries time was right-censored.
</p>
<p>xx takes values as for the variable <code>EBEG.xx</code>.
</p>
<p>Unfortunately, for all teeth except 16, 26, 36 and 46 almost all
the caries times are right-censored. For teeth 16, 26, 36, 46, the
amount of right-censoring is only about 25%.
</p>
</dd>
<dt>Txx.DMF</dt><dd><p>indicator whether a deciduous tooth xx was
<em><b>d</b>ecayed</em> or <em><b>m</b>issing due to caries</em>
or <em><b>f</b>illed</em> on at most the last examination
before the first examination when the emergence of the permanent
successor was recorded.
</p>
<p>xx takes values 53, 63, 73, 83 (deciduous lateral incisors),
54, 64, 74, 84 (deciduous first molars),
55, 65, 75, 85 (deciduous second molars).
</p>
</dd>
<dt>Txx.CAR</dt><dd><p>indicator whether a~deciduous tooth xx was
removed due to the orthodontical reasons or decayed
on at most the last examination before the first examination when  
the emergence of the permanent successor was recorded.
</p>
</dd>  
</dl>
  


<h3>Source</h3>

<p>Leuven Biostatistics and statistical Bioinformatics Centre (L-BioStat), Katholieke Universiteit Leuven,
Kapucijnenvoer 35, 3000 Leuven, Belgium
</p>
<p><code>URL:</code> <code>https://gbiomed.kuleuven.be/english/research/50000687/50000696/</code>
</p>
<p>Data collection was supported by Unilever, Belgium.
The Signal Tandmobiel project comprises the following partners:
D. Declerck (Dental School, Catholic University Leuven),
L. Martens (Dental School, University Ghent),
J. Vanobbergen (Oral Health Promotion and Prevention, Flemish Dental Association),
P. Bottenberg (Dental School, University Brussels),
E. Lesaffre (Biostatistical Centre, Catholic University Leuven),
K. Hoppenbrouwers (Youth Health Department, Catholic University Leuven; Flemish Association for Youth Health Care).  
</p>


<h3>References</h3>

<p>Komárek, A., Lesaffre, E.,
<code class="reqn">\mbox{H\"{a}rk\"{a}nen,}</code> T., Declerck, D., and
Virtanen, J. I. (2005).
A Bayesian analysis of multivariate doubly-interval-censored dental data.
<em>Biostatistics,</em> <b>6</b>, 145&ndash;155.
</p>
<p>Komárek, A. and Lesaffre, E. (2007).
Bayesian accelerated failure time model for correlated interval-censored data
with a normal mixture as an error distribution.
<em>Statistica Sinica,</em> <b>17</b>, 549&ndash;569. 
</p>
<p>Lesaffre, E., Komárek, A., and Declerck, D. (2005).
An overview of methods for interval-censored data with an emphasis on
applications in dentistry.
<em>Statistical Methods in Medical Research</em>, <b>14</b>, 539&ndash;552.
</p>
<p>Vanobbergen, J., Martens, L., Lesaffre, E., and Declerck, D. (2000).
The Signal-Tandmobiel project &ndash; a longitudinal intervention health promotion
study in Flanders (Belgium): baseline and first year results.
<em>European Journal of Paediatric Dentistry</em>, <b>2</b>, 87&ndash;96.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Tandmob)
summary(Tandmob)
</code></pre>

<hr>
<h2 id='TandmobEmer'>Signal Tandmobiel data - emergence times</h2><span id='topic+TandmobEmer'></span>

<h3>Description</h3>

<p>This is a part of the <code><a href="#topic+Tandmob">Tandmob</a></code> data containing only
emergence times and some baseline covariates. Here, all left-censored
emergence times have been changed into interval-censored with the
lower limit of the intervals equal to 5 years of age (clinically
minimal time before which the permanent teeth hardly emerge). Also
censoring indicators are added to be able to use the data directly
with the <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> function.  
</p>
<p><b>IMPORTANT NOTICE:</b> It is possible to use these data for your
research work under the condition that each manuscript is first
approved by <br />
Prof. Emmanuel Lesaffre <br />
Leuven Biostatistics and statistical Bioinformatics Centre (L-BioStat) <br />
Katholieke Universiteit Leuven <br />
Kapucijnenvoer 35 <br />
B-3000 Leuven <br />
Belgium <br />
&lt;<code>emmanuel.lesaffre@kuleuven.be</code>&gt;  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TandmobEmer)</code></pre>


<h3>Format</h3>

<p>a data frame with 4 430 rows and the following
variables
</p>

<dl>
<dt>IDNR</dt><dd><p>identification number of a child</p>
</dd>
<dt>GENDER</dt><dd><p>character <em>boy</em> or <em>girl</em></p>
</dd>
<dt>GENDERNum</dt><dd><p>numeric, 0 = <em>boy</em>, 1 = <em>girl</em></p>
</dd>
<dt>DOB</dt><dd><p>character, date of birth in the format DDmmmYY</p>
</dd>
<dt>PROVINCE</dt><dd><p>factor, code of the province with
</p>

<dl>
<dt>0 = </dt><dd><p>Antwerpen</p>
</dd>
<dt>1 = </dt><dd><p>Vlaams Brabant</p>
</dd>
<dt>2 = </dt><dd><p>Limburg</p>
</dd>
<dt>3 = </dt><dd><p>Oost Vlaanderen</p>
</dd>
<dt>4 = </dt><dd><p>West Vlaanderen</p>
</dd>
</dl>
  
</dd>
<dt>EDUC</dt><dd><p>factor, code of the educational system with
</p>

<dl>
<dt>0 = </dt><dd><p>Free</p>
</dd>
<dt>1 = </dt><dd><p>Community school</p>
</dd>
<dt>2 = </dt><dd><p>Province/council school</p>
</dd>
</dl>
  
</dd>
<dt>STARTBR</dt><dd><p>factor, code indicating the starting age of brushing
the teeth (as reported by parents) with
</p>

<dl>
<dt>1 = </dt><dd><p>[0, 1] years</p>
</dd>
<dt>2 = </dt><dd><p>(1, 2] years</p>
</dd>
<dt>3 = </dt><dd><p>(2, 3] years</p>
</dd>
<dt>4 = </dt><dd><p>(3, 4] years</p>
</dd>
<dt>5 = </dt><dd><p>(4, 5] years</p>
</dd>      
<dt>6 = </dt><dd><p>later than at the age of 5</p>
</dd>      
</dl>
  
</dd>
<dt>EBEG.xx</dt><dd><p>lower limit of the emergence (in years of age) of the
permanent tooth xx. It is equal to 5 if the emergence was originally
left-censored.
</p>
<p>xx takes values 11, 21, 31, 41 (permanent incisors),
12, 22, 32, 42 (permanent central canines),
13, 23, 33, 43 (permanent lateral canines),
14, 24, 34, 44 (permanent first premolars),
15, 25, 35, 45 (permanent second premolars),
16, 26, 36, 46 (permanent first molars),
17, 27, 37, 47 (permanent second molars).
</p>
</dd>
<dt>EEND.xx</dt><dd><p>upper limit of the emergence (in years of age) of the
permanent tooth xx. <code>NA</code> if the emergence was right-censored.
</p>
<p>xx takes values as for the variable <code>EBEG.xx</code>.
</p>
</dd>
<dt>CENSOR.xx</dt><dd><p>censoring indicator for the emergence. It is equal to
3 for interval-censored times and equal to 0 for right-censored
times.
</p>
<p>xx takes values as for the variable <code>EBEG.xx</code>.    
</p>
</dd>  
</dl>
  


<h3>Source</h3>

<p>Leuven Biostatistics and statistical Bioinformatics Centre (L-BioStat), Katholieke Universiteit Leuven,
Kapucijnenvoer 35, 3000 Leuven, Belgium
</p>
<p><code>URL:</code> <code>https://gbiomed.kuleuven.be/english/research/50000687/50000696/</code>
</p>
<p>Data collection was supported by Unilever, Belgium.
The Signal Tandmobiel project comprises the following partners:
D. Declerck (Dental School, Catholic University Leuven),
L. Martens (Dental School, University Ghent),
J. Vanobbergen (Oral Health Promotion and Prevention, Flemish Dental Association),
P. Bottenberg (Dental School, University Brussels),
E. Lesaffre (Biostatistical Centre, Catholic University Leuven),
K. Hoppenbrouwers (Youth Health Department, Catholic University Leuven; Flemish Association for Youth Health Care).  
</p>


<h3>References</h3>

<p>Komárek, A. (2009).
A new R package for Bayesian estimation of multivariate normal mixtures allowing for selection 
of the number of components and interval-censored data.
<em>Computational Statistics and Data Analysis</em>, <b>53</b>(12), 3932&ndash;3947.
</p>
<p>Vanobbergen, J., Martens, L., Lesaffre, E., and Declerck, D. (2000).
The Signal-Tandmobiel project &ndash; a longitudinal intervention health promotion
study in Flanders (Belgium): baseline and first year results.
<em>European Journal of Paediatric Dentistry</em>, <b>2</b>, 87-96.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Tandmob">Tandmob</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TandmobEmer)
summary(TandmobEmer)
</code></pre>

<hr>
<h2 id='TMVN'>
Truncated multivariate normal distribution
</h2><span id='topic+TMVN'></span><span id='topic+rTMVN'></span><span id='topic+C_rTMVN1_R'></span>

<h3>Description</h3>

<p>Random generation for the truncated multivariate normal distribution.
The mean and covariance matrix of the original multivariate normal distribution
are <code>mean</code> and <code>Sigma</code>. Truncation limits are given by
<code>a</code>, <code>b</code>, type of truncation is given by <code>trunc</code>.
</p>
<p>This function uses a Gibbs algorithm to produce a Markov chain whose
stationary distribution is the targeted truncated multivariate normal
distribution, see Geweke (1991) for more details. Be aware that the
sampled values are not i.i.d.!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTMVN(n, mean=c(0, 0), Sigma=diag(2), a, b, trunc, xinit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TMVN_+3A_mean">mean</code></td>
<td>
<p>a numeric vector of the mean of the original multivariate
normal distribution.</p>
</td></tr>
<tr><td><code id="TMVN_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of the original multivariate normal
distribution.</p>
</td></tr>
<tr><td><code id="TMVN_+3A_a">a</code></td>
<td>
<p>a numeric vector of the same length as <code>mean</code> of
truncation limits 1.</p>
</td></tr>
<tr><td><code id="TMVN_+3A_b">b</code></td>
<td>
<p>a numeric vector of the same length as <code>mean</code> of
truncation limits 2.</p>
</td></tr>
<tr><td><code id="TMVN_+3A_trunc">trunc</code></td>
<td>
<p>a numeric vector of the same length as <code>mean</code>
describing the type of truncation in each margin.
</p>

<dl>
<dt><code>trunc</code>=0</dt><dd><p>normal distribution is truncated on the
interval <code class="reqn">(a,\,\infty).</code>. Value of <code class="reqn">b</code> is
ignored.</p>
</dd>
<dt><code>trunc</code>=1</dt><dd><p>degenerated normal distribution, all values
are with probability 1 equal to <code class="reqn">a</code>, <code class="reqn">b</code> is ignored.</p>
</dd>
<dt><code>trunc</code>=2</dt><dd><p>normal distribution is truncated on the
interval <code class="reqn">(-\infty,\,a).</code> Value of <code class="reqn">b</code> is ignored.</p>
</dd>
<dt><code>trunc</code>=3</dt><dd><p>normal distribution is truncated on the
interval <code class="reqn">(a,\,b).</code></p>
</dd>
<dt><code>trunc</code>=4</dt><dd><p>there is no truncation, values of <code class="reqn">a</code>
and <code class="reqn">b</code> are ignored.</p>
</dd>      
</dl>

<p>If <code>trunc</code> is not given, it is assumed that it is equal to
4. Note that <code>a</code>, <code>b</code> and <code>trunc</code>
must have the same length, with exception that 
<code>b</code> does not have to be supplied if all <code>trunc</code> values 0,
1, 2 or 4.
</p>
</td></tr>
<tr><td><code id="TMVN_+3A_xinit">xinit</code></td>
<td>
<p>a numeric vector of the same length as <code>mean</code> with
the initial value for the Gibbs sampler. If it is not supplied, the
function determines itself the initial value.</p>
</td></tr>
<tr><td><code id="TMVN_+3A_n">n</code></td>
<td>
<p>number of observations to be sampled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the sampled values (Markov chain) in rows.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Geweke, J. (1991).
Efficient simulation from the multivariate normal and
Student-t distributions subject to linear constraints 
and the evaluation of constraint probabilities.
<em>Computer Sciences and Statistics</em>, <b>23</b>, 571&ndash;578.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rTNorm">rTNorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1977)

exam2 &lt;- function(n, mu, sigma, rho, a, b, trunc)
{
  Sigma &lt;- matrix(c(sigma[1]^2, rho*sigma[1]*sigma[2], rho*sigma[1]*sigma[2], sigma[2]^2), nrow=2)
  x &lt;- rTMVN(n, mean=mu, Sigma=Sigma, a=a, b=b, trunc=trunc)
  x1.gr &lt;- seq(mu[1]-3.5*sigma[1], mu[1]+3.5*sigma[1], length=100)
  x2.gr &lt;- seq(mu[2]-3.5*sigma[2], mu[2]+3.5*sigma[2], length=100)    
  z &lt;- cbind(rep(x1.gr, 100), rep(x2.gr, each=100))
  dens.z &lt;- matrix(dMVN(z, mean=mu, Sigma=Sigma), ncol=100)

  MEAN &lt;- round(apply(x, 2, mean), 3)
  SIGMA &lt;- var(x)
  SD &lt;- sqrt(diag(SIGMA))
  RHO &lt;- round(SIGMA[1,2]/(SD[1]*SD[2]), 3)
  SD &lt;- round(SD, 3)
  
  layout(matrix(c(0,1,1,0, 2,2,3,3), nrow=2, byrow=TRUE))
  contour(x1.gr, x2.gr, dens.z, col="darkblue", xlab="x[1]", ylab="x[2]")
  points(x[,1], x[,2], col="red")
  title(sub=paste("Sample mean = ", MEAN[1], ", ", MEAN[2], ",  Sample SD = ", SD[1], ", ", SD[2],
                  ",  Sample rho = ", RHO, sep=""))
  plot(1:n, x[,1], type="l", xlab="Iteration", ylab="x[1]", col="darkgreen")
  plot(1:n, x[,2], type="l", xlab="Iteration", ylab="x[2]", col="darkgreen")

  return(x)  
}  

x1 &lt;- exam2(1000, mu=c(-1, 1), sigma=c(1, sqrt(2)), rho=0, a=c(-6, -9), b=c(4, 11), trunc=c(3, 3))
x2 &lt;- exam2(1000, mu=c(-1, 1), sigma=c(1, sqrt(2)), rho=0.7, a=c(-6, -9), b=c(4, 11), trunc=c(3, 3))
x3 &lt;- exam2(1000, mu=c(-1, 1), sigma=c(1, sqrt(2)), rho=0.7, a=c(-100, -100), b=c(100, 100),
            trunc=c(3, 3))
x4 &lt;- exam2(1000, mu=c(-1, 1), sigma=c(1, sqrt(2)), rho=-0.7, a=c(-6, -9), b=c(4, 11),
            trunc=c(3, 3))
x5 &lt;- exam2(1000, mu=c(-1, 1), sigma=c(1, sqrt(2)), rho=-0.9, a=c(-6, -9), b=c(4, 11),
            trunc=c(3, 3))

x6 &lt;- exam2(1000, mu=c(-1, 1), sigma=c(1, sqrt(2)), rho=0.7, a=c(0, 0), trunc=c(0, 2))
x7 &lt;- exam2(1000, mu=c(-1, 1), sigma=c(1, sqrt(2)), rho=0.7, a=c(-1, 1), trunc=c(0, 2))
x8 &lt;- exam2(1000, mu=c(-1, 1), sigma=c(1, sqrt(2)), rho=0.7, a=c(-1, 1), trunc=c(1, 2))
x9 &lt;- exam2(1000, mu=c(-1, 1), sigma=c(1, sqrt(2)), rho=0.7, a=c(-1.5, 0.5), b=c(-0.5, 1.5),
            trunc=c(3, 3))
x10 &lt;- exam2(1000, mu=c(-1, 1), sigma=c(1, sqrt(2)), rho=0.7, a=c(-1.5, 0.5), b=c(-0.5, 1.5),
             trunc=c(4, 3))

## End(Not run)
</code></pre>

<hr>
<h2 id='TNorm'>
Truncated normal distribution
</h2><span id='topic+TNorm'></span><span id='topic+rTNorm'></span><span id='topic+C_rTNorm1_R'></span>

<h3>Description</h3>

<p>Random generation for the truncated normal distribution.
The mean and standard deviation of the original normal distribution
are <code>mean</code> and <code>sd</code>. Truncation limits are given by
<code>a</code>, <code>b</code>, type of truncation is given by <code>trunc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTNorm(n, mean=0, sd=1, a, b, trunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TNorm_+3A_mean">mean</code></td>
<td>
<p>mean (if common for all observations) or a vector of
length <code>n</code> of means.</p>
</td></tr>
<tr><td><code id="TNorm_+3A_sd">sd</code></td>
<td>
<p>standard deviation (if common for all observations) or a vector of
length <code>n</code> of standard deviations.
</p>
<p>Note that <code>mean</code> and <code>sd</code>
must have the same length, either 1 or <code>n</code>.</p>
</td></tr>
<tr><td><code id="TNorm_+3A_a">a</code></td>
<td>
<p>truncation limit 1 (if common for all observations) or a
vector of length <code>n</code> of truncation limits 1.</p>
</td></tr>
<tr><td><code id="TNorm_+3A_b">b</code></td>
<td>
<p>truncation limit 2 (if common for all observations) or a
vector of length <code>n</code> of truncation limits 2.</p>
</td></tr>
<tr><td><code id="TNorm_+3A_trunc">trunc</code></td>
<td>
<p>type of truncation (if common for all observations) or a
vector of length <code>n</code> of types of truncation
</p>

<dl>
<dt><code>trunc</code>=0</dt><dd><p>normal distribution is truncated on the
interval <code class="reqn">(a,\,\infty).</code>. Value of <code class="reqn">b</code> is
ignored.</p>
</dd>
<dt><code>trunc</code>=1</dt><dd><p>degenerated normal distribution, all values
are with probability 1 equal to <code class="reqn">a</code>, <code class="reqn">b</code> is ignored.</p>
</dd>
<dt><code>trunc</code>=2</dt><dd><p>normal distribution is truncated on the
interval <code class="reqn">(-\infty,\,a).</code> Value of <code class="reqn">b</code> is ignored.</p>
</dd>
<dt><code>trunc</code>=3</dt><dd><p>normal distribution is truncated on the
interval <code class="reqn">(a,\,b).</code></p>
</dd>
<dt><code>trunc</code>=4</dt><dd><p>there is no truncation, values of <code class="reqn">a</code>
and <code class="reqn">b</code> are ignored.</p>
</dd>      
</dl>

<p>If <code>trunc</code> is not given, it is assumed that it is equal to
4. Note that <code>a</code>, <code>b</code> and <code>trunc</code>
must have the same length, either 1 or <code>n</code> with exception that
<code>b</code> does not have to be supplied if <code>trunc</code> is 0, 1, 2 or 4.    
</p>
</td></tr>    
<tr><td><code id="TNorm_+3A_n">n</code></td>
<td>
<p>number of observations to be sampled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with sampled values.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Geweke, J. (1991).
Efficient simulation from the multivariate normal and
Student-t distributions subject to linear constraints 
and the evaluation of constraint probabilities.
<em>Computer Sciences and Statistics</em>, <b>23</b>, 571&ndash;578.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rnorm">rnorm</a></code>, <code><a href="#topic+rTMVN">rTMVN</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1977)

### Not truncated normal distribution
x1 &lt;- rTNorm(1000, mean=10, sd=3)
c(mean(x1), sd(x1), range(x1))

### Truncation from left only
x2 &lt;- rTNorm(1000, mean=10, sd=3, a=7, trunc=0)
c(mean(x2), sd(x2), range(x2))

### Degenerated normal distribution
x6 &lt;- rTNorm(1000, mean=10, sd=3, a=13, trunc=1)
c(mean(x6), sd(x6), range(x6))

### Truncation from right only
x3 &lt;- rTNorm(1000, mean=10, sd=3, a=13, trunc=2)
c(mean(x3), sd(x3), range(x3))

### Truncation from both sides
x4 &lt;- rTNorm(1000, mean=10, sd=3, a=7, b=13, trunc=3)
c(mean(x4), sd(x4), range(x4))

x5 &lt;- rTNorm(1000, mean=10, sd=3, a=5.5, b=14.5, trunc=3)
c(mean(x5), sd(x5), range(x5))

oldPar &lt;- par(mfrow=c(2, 3))
hist(x1, main="N(10, 3^2)")
hist(x2, main="TN(10, 3^2, 7, Infty)")
hist(x6, main="TN(10, 3^2, 13, 13)")
hist(x3, main="TN(10, 3^2, -Infty, 13)")
hist(x4, main="TN(10, 3^2, 7, 13)")
hist(x5, main="TN(10, 3^2, 5.5, 14.5)")
par(oldPar)

### Different truncation limits
n &lt;- 1000
a &lt;- rnorm(n, -2, 1)
b &lt;- a + rgamma(n, 1, 1)
trunc &lt;- rep(c(0, 1, 2, 3, 4), each=n/5)
x7 &lt;- rTNorm(n, mean=1, sd=2, a=a, b=b, trunc=trunc)
cbind(trunc, a, x7)[1:10,]
sum(x7[1:(n/5)] &gt; a[1:(n/5)])      ## must be equal to n/5

cbind(trunc, a, x7)[201:210,]
sum(x7[(n/5+1):(2*n/5)] == a[(n/5+1):(2*n/5)])         ## must be equal to n/5

cbind(trunc, x7, a)[401:410,]
sum(x7[(2*n/5+1):(3*n/5)] &lt; a[(2*n/5+1):(3*n/5)])      ## must be equal to n/5

cbind(trunc, a, x7, b)[601:610,]
sum(x7[(3*n/5+1):(4*n/5)] &gt; a[(3*n/5+1):(4*n/5)])      ## must be equal to n/5
sum(x7[(3*n/5+1):(4*n/5)] &lt; b[(3*n/5+1):(4*n/5)])      ## must be equal to n/5

cbind(trunc, x7)[801:810,]

### Different moments and truncation limits
n &lt;- 1000
mu &lt;- rnorm(n, 1, 0.2)
sigma &lt;- 0.5 + rgamma(n, 1, 1)
a &lt;- rnorm(n, -2, 1)
b &lt;- a + rgamma(n, 1, 1)
trunc &lt;- rep(c(0, 1, 2, 3, 4), each=n/5)
x8 &lt;- rTNorm(n, mean=1, sd=2, a=a, b=b, trunc=trunc)

### Truncation from left only
### (extreme cases when we truncate to the area
###  where the original normal distribution has
###  almost zero probability)
x2b &lt;- rTNorm(1000, mean=0, sd=1, a=7.9, trunc=0)
c(mean(x2b), sd(x2b), range(x2b))

x2c &lt;- rTNorm(1000, mean=1, sd=2, a=16, trunc=0)
c(mean(x2c), sd(x2c), range(x2c))

### Truncation from right only (extreme cases)
x3b &lt;- rTNorm(1000, mean=0, sd=1, a=-7.9, trunc=2)
c(mean(x3b), sd(x3b), range(x3b))

x3c &lt;- rTNorm(1000, mean=1, sd=2, a=-13, trunc=2)
c(mean(x3c), sd(x3c), range(x3c))

### Truncation from both sides (extreme cases)
x4b &lt;- rTNorm(1000, mean=0, sd=1, a=-9, b=-7.9, trunc=3)
c(mean(x4b), sd(x4b), range(x4b))

x4c &lt;- rTNorm(1000, mean=0, sd=1, a=7.9, b=9, trunc=3)
c(mean(x4c), sd(x4c), range(x4c))
</code></pre>

<hr>
<h2 id='tracePlots'>
Traceplots for selected parameters
</h2><span id='topic+tracePlots'></span><span id='topic+tracePlots.default'></span><span id='topic+tracePlots.NMixMCMC'></span><span id='topic+tracePlots.NMixMCMClist'></span><span id='topic+tracePlots.GLMM_MCMC'></span><span id='topic+tracePlots.GLMM_MCMClist'></span>

<h3>Description</h3>

<p>This function draws traceplots of selected parameters from the MCMC
simulations ran using <code><a href="#topic+NMixMCMC">NMixMCMC</a></code> or
<code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tracePlots(x, ...)

  ## Default S3 method:
tracePlots(x, ...)

  ## S3 method for class 'NMixMCMC'
tracePlots(x, param=c("Emix", "SDmix", "Cormix", "K", "w", "mu", "sd", "gammaInv"),
    relabel=FALSE, order,
    auto.layout=TRUE, xlab="Iteration", ylab, col="slateblue", main="", ...)

  ## S3 method for class 'NMixMCMClist'
tracePlots(x, param=c("Emix", "SDmix", "Cormix", "K", "w", "mu", "sd", "gammaInv"),
    relabel=FALSE,
    auto.layout=TRUE, xlab="Iteration", ylab, col=c("blue3", "red3"), main="", ...)

  ## S3 method for class 'GLMM_MCMC'
tracePlots(x, param=c("Deviance", "Cond.Deviance",
    "alpha", "Eb", "SDb", "Corb", "sigma_eps",
    "w_b", "mu_b", "sd_b", "gammaInv_b", "gammaInv_eps"),
    relabel=FALSE, order,
    auto.layout=TRUE, xlab="Iteration", ylab, col="slateblue", main="", ...)

  ## S3 method for class 'GLMM_MCMClist'
tracePlots(x, param=c("Deviance", "Cond.Deviance",
    "alpha", "Eb", "SDb", "Corb", "sigma_eps",
    "w_b", "mu_b", "sd_b", "gammaInv_b", "gammaInv_eps"),
    relabel=FALSE,                             
    auto.layout=TRUE, xlab="Iteration", ylab, col=c("blue3", "red3"), main="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tracePlots_+3A_x">x</code></td>
<td>
<p>an object of appropriate class.</p>
</td></tr>
<tr><td><code id="tracePlots_+3A_param">param</code></td>
<td>
<p>a character string which specifies which sort of
parameters is to be plotted.
</p>

<dl>
<dt>Emix</dt><dd><p>overall means (for each margin) of the normal mixture;</p>
</dd>
<dt>SDmix</dt><dd><p>overall standard deviations (for each margin) of the
normal mixture;</p>
</dd>
<dt>Cormix</dt><dd><p>overall correlations (each pair) of the normal
mixture;</p>
</dd>
<dt>K</dt><dd><p>number of mixture components;</p>
</dd>
<dt>w, w_b</dt><dd><p>weights of each of mixture components.
If <code>relabel</code> is <code>FALSE</code>, weights are not re-labeled before plotting;</p>
</dd>
<dt>mu, mu_b</dt><dd><p>component means (each margin, each mixture component) of the
normal mixture. The mixture means are shifted and scaled using
<code>x$scale$shift</code> and <code>x$scale$scale</code> before plotting.
If <code>relabel</code> is <code>FALSE</code>, means are not re-labeled before plotting;</p>
</dd>
<dt>sd, sd_b</dt><dd><p>component standard deviations (each margin, each mixture
component) of the normal mixture. The mixture standard deviations are scaled using
<code>x$scale$scale</code> before plotting.
If <code>relabel</code> is <code>FALSE</code>, standard deviations are
not re-labeled before plotting;</p>
</dd>
<dt>gammaInv, gammaInv_b, gammaInv_eps</dt><dd><p>variance
hyperparameters;</p>
</dd>
<dt>Deviance</dt><dd><p>deviance (marginal, with random effects integrated
out) of the GLMM;</p>
</dd>
<dt>Cond.Deviance</dt><dd><p>conditional deviance (given random effects)
of the GLMM;</p>
</dd>
<dt>alpha</dt><dd><p>fixed effects of the fitted GLMM;</p>
</dd>
<dt>Eb</dt><dd><p>overall means (for each margin) of the random effects of
the fitted GLMM;</p>
</dd>
<dt>SDb</dt><dd><p>overall standard deviations (for each margin) of the random effects of
the fitted GLMM;</p>
</dd>
<dt>Corb</dt><dd><p>overall correlations (each pair) of the distribution
of the random effects of the fitted GLMM.</p>
</dd>
<dt>sigma_eps</dt><dd><p>standard deviations of the error terms in the
(mixed) models for continuous responses.</p>
</dd>
</dl>
  
</td></tr>
<tr><td><code id="tracePlots_+3A_relabel">relabel</code></td>
<td>
<p>logical value. It indicates whether the chains with
<code>param</code> being <code>w</code>, <code>mu</code>, <code>sd</code>, <code>w_b</code>,
<code>mu_b</code>, <code>sd_b</code> should be re-labeled before
plotting. Re-labelling is given by argument <code>order</code>. If
<code>order</code> is missing then <code>x$order</code> or <code>x$order_b</code>
determines re-labelling.
</p>
</td></tr>
<tr><td><code id="tracePlots_+3A_order">order</code></td>
<td>
<p>a matrix with <code class="reqn">K</code> columns and <code class="reqn">M</code> rows where
<code class="reqn">M</code> is the length of MCMC. Each row of <code>order</code> must be a
permutation of <code class="reqn">(1, \ldots, K)</code>.
</p>
</td></tr>
<tr><td><code id="tracePlots_+3A_auto.layout">auto.layout</code></td>
<td>
<p>logical value. If <code>TRUE</code>, the plotting region
is automatically divided to produce traceplots of all
parameters. Note that layout must be set up automatically if there
are more than 28 parameters to be plotted (often the case for
correlations with <code>param</code> being <code>Corb</code> or for mixture
means with <code>param</code> being <code>mu_b</code>).</p>
</td></tr>
<tr><td><code id="tracePlots_+3A_xlab">xlab</code>, <code id="tracePlots_+3A_ylab">ylab</code>, <code id="tracePlots_+3A_col">col</code>, <code id="tracePlots_+3A_main">main</code></td>
<td>
<p>arguments passed to <code>plot</code>
function. They all can be of length one (the value is used on all
plots) or of length equal to the number of parameters to be
plotted.</p>
</td></tr>
<tr><td><code id="tracePlots_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(x)</code>
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixMCMC">NMixMCMC</a></code>, <code><a href="#topic+GLMM_MCMC">GLMM_MCMC</a></code>, <code><a href="#topic+NMixRelabel">NMixRelabel</a></code>, <code><a href="coda.html#topic+traceplot">traceplot</a></code>.
</p>

<hr>
<h2 id='Wishart'>
Wishart distribution
</h2><span id='topic+Wishart'></span><span id='topic+dWISHART'></span><span id='topic+rWISHART'></span><span id='topic+C_rWishart_R'></span><span id='topic+C_ldWishart_R'></span>

<h3>Description</h3>

<p>Wishart distribution
</p>
<p style="text-align: center;"><code class="reqn">\mbox{Wishart}(\nu, \boldsymbol{S}),</code>
</p>

<p>where <code class="reqn">\nu</code> are degrees of freedom of the Wishart distribution
and <code class="reqn">\boldsymbol{S}</code> is its scale matrix. The same parametrization as in
Gelman (2004) is assumed, that is, if
<code class="reqn">\boldsymbol{W}\sim\mbox{Wishart}(\nu,\,\boldsymbol{S})</code> then
</p>
<p style="text-align: center;"><code class="reqn">\mbox{E}(\boldsymbol{W}) = \nu \boldsymbol{S}.</code>
</p>

<p>Prior to version 3.4-1 of this package, functions <code>dWISHART</code> and
<code>rWISHART</code> were called as <code>dWishart</code> and <code>rWishart</code>,
respectively. The names were changed in order to avoid conflicts with
<code><a href="stats.html#topic+rWishart">rWishart</a></code> from a standard package <code>stats</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dWISHART(W, df, S, log=FALSE)

rWISHART(n, df, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wishart_+3A_w">W</code></td>
<td>
<p>Either a matrix with the same number of rows and columns as
<code>S</code> (1 point sampled from the Wishart distribution) or a matrix
with <code>ncol</code> equal to <code>ncol</code>*<code>(ncol+1)</code>/2 and <code>n</code>
rows (<code>n</code> points sampled from the Wishart distribution for
which only lower triangles are given in rows of the matrix <code>W</code>).</p>
</td></tr>
<tr><td><code id="Wishart_+3A_n">n</code></td>
<td>
<p>number of observations to be sampled.</p>
</td></tr>  
<tr><td><code id="Wishart_+3A_df">df</code></td>
<td>
<p>degrees of freedom of the Wishart distribution.</p>
</td></tr>
<tr><td><code id="Wishart_+3A_s">S</code></td>
<td>
<p>scale matrix of the Wishart distribution.</p>
</td></tr>
<tr><td><code id="Wishart_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, log-density is computed</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The density of the Wishart distribution is the following
</p>
<p style="text-align: center;"><code class="reqn">
    f(\boldsymbol{W}) = \Bigl(2^{\nu\,p/2}\,\pi^{p(p-1)/4}\,\prod_{i=1}^p
    \Gamma\bigl(\frac{\nu + 1 - i}{2}\bigr)\Bigr)^{-1}\,
    |\boldsymbol{S}|^{-\nu/2}\,|\boldsymbol{W}|^{(\nu - p - 1)/2}\,
    \exp\Bigl(-\frac{1}{2}\mbox{tr}(\boldsymbol{S}^{-1}\boldsymbol{W})\Bigr),    
  </code>
</p>
  
<p>where <code class="reqn">p</code> is number of rows and columns of the matrix <code class="reqn">\boldsymbol{W}</code>.
</p>
<p>In the univariate case, <code class="reqn">\mbox{Wishart}(\nu,\,S)</code> is the
same as <code class="reqn">\mbox{Gamma}(\nu/2, 1/(2S)).</code>  
</p>
<p>Generation of random numbers is performed by the algorithm described
in Ripley (1987, pp. 99).
</p>


<h3>Value</h3>

<p>Some objects.
</p>


<h3>Value for dWISHART</h3>

<p>A numeric vector with evaluated (log-)density.
</p>


<h3>Value for rWISHART</h3>

<p>If <code>n</code> equals 1 then a sampled symmetric matrix W is returned.
</p>
<p>If <code>n</code> &gt; 1 then a matrix with sampled points (lower triangles of
<code class="reqn">\boldsymbol{W}</code>) in rows is returned.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S., and Rubin, D. B. (2004).
<em>Bayesian Data Analysis, Second edition</em>. 
Boca Raton: Chapman and Hall/CRC.
</p>
<p>Ripley, B. D. (1987).
<em>Stochastic Simulation</em>.
New York: John Wiley and Sons.  
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rWishart">rWishart</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1977)
### The same as gamma(shape=df/2, rate=1/(2*S))
df &lt;- 1
S  &lt;- 3

w &lt;- rWISHART(n=1000, df=df, S=S)
mean(w)    ## should be close to df*S
var(w)     ## should be close to 2*df*S^2

dWISHART(w[1], df=df, S=S)
dWISHART(w[1], df=df, S=S, log=TRUE)

dens.w &lt;- dWISHART(w, df=df, S=S)
dens.wG &lt;- dgamma(w, shape=df/2, rate=1/(2*S))
rbind(dens.w[1:10], dens.wG[1:10])

ldens.w &lt;- dWISHART(w, df=df, S=S, log=TRUE)
ldens.wG &lt;- dgamma(w, shape=df/2, rate=1/(2*S), log=TRUE)
rbind(ldens.w[1:10], ldens.wG[1:10])


### Bivariate Wishart
df &lt;- 2
S &lt;- matrix(c(1,3,3,13), nrow=2)

print(w2a &lt;- rWISHART(n=1, df=df, S=S))
dWISHART(w2a, df=df, S=S)

w2 &lt;- rWISHART(n=1000, df=df, S=S)
print(w2[1:10,])
apply(w2, 2, mean)                ## should be close to df*S
(df*S)[lower.tri(S, diag=TRUE)]

dens.w2 &lt;- dWISHART(w2, df=df, S=S)
ldens.w2 &lt;- dWISHART(w2, df=df, S=S, log=TRUE)
cbind(w2[1:10,], data.frame(Density=dens.w2[1:10], Log.Density=ldens.w2[1:10]))


### Trivariate Wishart
df &lt;- 3.5
S &lt;- matrix(c(1,2,3,2,20,26,3,26,70), nrow=3)

print(w3a &lt;- rWISHART(n=1, df=df, S=S))
dWISHART(w3a, df=df, S=S)

w3 &lt;- rWISHART(n=1000, df=df, S=S)
print(w3[1:10,])
apply(w3, 2, mean)                ## should be close to df*S
(df*S)[lower.tri(S, diag=TRUE)]

dens.w3 &lt;- dWISHART(w3, df=df, S=S)
ldens.w3 &lt;- dWISHART(w3, df=df, S=S, log=TRUE)
cbind(w3[1:10,], data.frame(Density=dens.w3[1:10], Log.Density=ldens.w3[1:10]))
</code></pre>

<hr>
<h2 id='Y2T'>
Transform fitted distribution of Y=trans(T) into distribution of T
</h2><span id='topic+Y2T'></span><span id='topic+Y2T.NMixPredDensMarg'></span><span id='topic+Y2T.NMixPlugDensMarg'></span><span id='topic+Y2T.NMixPredCDFMarg'></span><span id='topic+Y2T.NMixPredDensJoint2'></span><span id='topic+Y2T.NMixPlugDensJoint2'></span><span id='topic+Y2T.NMixPredCondDensMarg'></span><span id='topic+Y2T.NMixPlugCondDensMarg'></span><span id='topic+Y2T.NMixPredCondCDFMarg'></span><span id='topic+Y2T.NMixPredCondDensJoint2'></span><span id='topic+Y2T.NMixPlugCondDensJoint2'></span>

<h3>Description</h3>

<p>This method transforms fitted distributionof <code class="reqn">Y=\mbox{trans}(T)</code>
into distribution of <code class="reqn">T</code>. Default transformation is a logarithmic
transformation where
<code>trans(t)</code>=log(t), <code>itrans(y)</code>=exp(y), <code>dtrans(t)</code>=1/t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y2T(x, ...)

## S3 method for class 'NMixPredDensMarg'
Y2T(x, itrans=exp, dtrans=function(x){return(1 / x)}, ...)

## S3 method for class 'NMixPlugDensMarg'
Y2T(x, itrans=exp, dtrans=function(x){return(1 / x)}, ...)

## S3 method for class 'NMixPredCDFMarg'
Y2T(x, itrans=exp, ...)

## S3 method for class 'NMixPredDensJoint2'
Y2T(x, itrans=exp, dtrans=function(x){return(1 / x)}, ...)

## S3 method for class 'NMixPlugDensJoint2'
Y2T(x, itrans=exp, dtrans=function(x){return(1 / x)}, ...)

## S3 method for class 'NMixPredCondDensMarg'
Y2T(x, itrans=exp, dtrans=function(x){return(1 / x)}, ...)

## S3 method for class 'NMixPlugCondDensMarg'
Y2T(x, itrans=exp, dtrans=function(x){return(1 / x)}, ...)

## S3 method for class 'NMixPredCondCDFMarg'
Y2T(x, itrans=exp, dtrans=function(x){return(1 / x)}, ...)

## S3 method for class 'NMixPredCondDensJoint2'
Y2T(x, itrans=exp, dtrans=function(x){return(1 / x)}, ...)

## S3 method for class 'NMixPlugCondDensJoint2'
Y2T(x, itrans=exp, dtrans=function(x){return(1 / x)}, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Y2T_+3A_x">x</code></td>
<td>
<p>an object of appropriate class.</p>
</td></tr>
<tr><td><code id="Y2T_+3A_itrans">itrans</code></td>
<td>
<p>either an object of class <code>function</code> or a list of
objects of class <code>function</code> giving inverse transformations for
each margin. If <code>itrans</code> is a single function then it is
assumed that all margins were transformed in the same way.</p>
</td></tr>
<tr><td><code id="Y2T_+3A_dtrans">dtrans</code></td>
<td>
<p>either an object of class <code>function</code> or a list of
objects of class <code>function</code> giving derivatives of transformations for
each margin. If <code>dtrans</code> is a single function then it is
assumed that all margins were transformed in the same way.</p>
</td></tr>
<tr><td><code id="Y2T_+3A_...">...</code></td>
<td>
<p>optional additional arguments.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>An object of the same class as argument <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NMixPredDensMarg">NMixPredDensMarg</a></code>, <code><a href="#topic+NMixPlugDensMarg">NMixPlugDensMarg</a></code>,
<code><a href="#topic+NMixPredCDFMarg">NMixPredCDFMarg</a></code>,
<code><a href="#topic+NMixPredDensJoint2">NMixPredDensJoint2</a></code>, <code><a href="#topic+NMixPlugDensJoint2">NMixPlugDensJoint2</a></code>,
<code><a href="#topic+NMixPredCondDensMarg">NMixPredCondDensMarg</a></code>, <code><a href="#topic+NMixPlugCondDensMarg">NMixPlugCondDensMarg</a></code>,
<code><a href="#topic+NMixPredCondCDFMarg">NMixPredCondCDFMarg</a></code>,
<code><a href="#topic+NMixPredCondDensJoint2">NMixPredCondDensJoint2</a></code>, <code><a href="#topic+NMixPlugCondDensJoint2">NMixPlugCondDensJoint2</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
