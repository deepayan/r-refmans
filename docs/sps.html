<!DOCTYPE html><html lang="en"><head><title>Help for package sps</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sps}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sps-package'><p>sps: Sequential Poisson Sampling</p></a></li>
<li><a href='#expected_coverage'><p>Expected coverage</p></a></li>
<li><a href='#inclusion_prob'><p>Calculate inclusion probabilities</p></a></li>
<li><a href='#prop_allocation'><p>Construct a proportional allocation</p></a></li>
<li><a href='#sps'><p>Stratified sequential Poisson sampling</p></a></li>
<li><a href='#sps_repweights'><p>Bootstrap replicate weights for sequential Poisson sampling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Sequential Poisson Sampling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Sequential Poisson sampling is a variation of Poisson sampling for
    drawing probability-proportional-to-size samples with a given number of
    units, and is commonly used for price-index surveys. This package gives
    functions to draw stratified sequential Poisson samples according to the
    method by Ohlsson (1998, ISSN:0282-423X), as well as other order sample
    designs by Rosén (1997, &lt;<a href="https://doi.org/10.1016%2FS0378-3758%2896%2900186-3">doi:10.1016/S0378-3758(96)00186-3</a>&gt;), and generate
    appropriate bootstrap replicate weights according to the generalized
    bootstrap method by Beaumont and Patak
    (2012, &lt;<a href="https://doi.org/10.1111%2Fj.1751-5823.2011.00166.x">doi:10.1111/j.1751-5823.2011.00166.x</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://marberts.github.io/sps/">https://marberts.github.io/sps/</a>, <a href="https://github.com/marberts/sps">https://github.com/marberts/sps</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/marberts/sps/issues">https://github.com/marberts/sps/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-09 00:53:56 UTC; steve</td>
</tr>
<tr>
<td>Author:</td>
<td>Steve Martin <a href="https://orcid.org/0000-0003-2544-9480"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Justin Francis [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steve Martin &lt;marberts@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-09 01:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sps-package'>sps: Sequential Poisson Sampling</h2><span id='topic+sps-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Sequential Poisson sampling is a variation of Poisson sampling for drawing probability-proportional-to-size samples with a given number of units, and is commonly used for price-index surveys. This package gives functions to draw stratified sequential Poisson samples according to the method by Ohlsson (1998, ISSN:0282-423X), as well as other order sample designs by Rosén (1997, <a href="https://doi.org/10.1016/S0378-3758%2896%2900186-3">doi:10.1016/S0378-3758(96)00186-3</a>), and generate appropriate bootstrap replicate weights according to the generalized bootstrap method by Beaumont and Patak (2012, <a href="https://doi.org/10.1111/j.1751-5823.2011.00166.x">doi:10.1111/j.1751-5823.2011.00166.x</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Steve Martin <a href="mailto:marberts@protonmail.com">marberts@protonmail.com</a> (<a href="https://orcid.org/0000-0003-2544-9480">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Justin Francis [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://marberts.github.io/sps/">https://marberts.github.io/sps/</a>
</p>
</li>
<li> <p><a href="https://github.com/marberts/sps">https://github.com/marberts/sps</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/marberts/sps/issues">https://github.com/marberts/sps/issues</a>
</p>
</li></ul>


<hr>
<h2 id='expected_coverage'>Expected coverage</h2><span id='topic+expected_coverage'></span>

<h3>Description</h3>

<p>Find the expected number of strata covered by ordinary Poisson sampling
without stratification. As sequential and ordinary Poisson sampling have the
same sample size on average, this gives an approximation for the coverage
under sequential Poisson sampling.
</p>
<p>This function can also be used to calculate, e.g., the expected number of
enterprises covered within a stratum when sampling business establishments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_coverage(x, n, strata, alpha = 0.001, cutoff = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expected_coverage_+3A_x">x</code></td>
<td>
<p>A positive and finite numeric vector of sizes for units in the
population (e.g., revenue for drawing a sample of businesses).</p>
</td></tr>
<tr><td><code id="expected_coverage_+3A_n">n</code></td>
<td>
<p>A positive integer giving the sample size.</p>
</td></tr>
<tr><td><code id="expected_coverage_+3A_strata">strata</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving
the strata associated with units in the population. The default is to place
all units into a single stratum.</p>
</td></tr>
<tr><td><code id="expected_coverage_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector with values between 0 and 1 for each stratum,
ordered according to the levels of <code>strata</code>. Units with inclusion
probabilities greater than or equal to 1 - <code>alpha</code> are set to 1 for
each stratum. A single value is recycled for all strata. The default is
slightly larger than 0.</p>
</td></tr>
<tr><td><code id="expected_coverage_+3A_cutoff">cutoff</code></td>
<td>
<p>A positive numeric vector of cutoffs for each stratum, ordered
according to the levels of <code>strata</code>. Units with <code>x &gt;= cutoff</code> get
an inclusion probability of 1 for each stratum. A single value is recycled
for all strata. The default does not apply a cutoff.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expected number of strata covered by the sample design.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prop_allocation">prop_allocation()</a></code> for generating proportional-to-size allocations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a population with units of different size
x &lt;- c(rep(1:9, each = 3), 100, 100, 100)

# ... and 10 strata
s &lt;- rep(letters[1:10], each = 3)

# Should get about 7 to 8 strata in a sample on average
expected_coverage(x, 15, s)

</code></pre>

<hr>
<h2 id='inclusion_prob'>Calculate inclusion probabilities</h2><span id='topic+inclusion_prob'></span><span id='topic+becomes_ta'></span>

<h3>Description</h3>

<p>Calculate stratified (first-order) inclusion probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inclusion_prob(x, n, strata = NULL, alpha = 0.001, cutoff = Inf)

becomes_ta(x, alpha = 0.001, cutoff = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inclusion_prob_+3A_x">x</code></td>
<td>
<p>A positive and finite numeric vector of sizes for units in the
population (e.g., revenue for drawing a sample of businesses).</p>
</td></tr>
<tr><td><code id="inclusion_prob_+3A_n">n</code></td>
<td>
<p>A positive integer vector giving the sample size for each stratum,
ordered according to the levels of <code>strata</code>. A single value is recycled
for all strata. Non-integers are truncated towards 0.</p>
</td></tr>
<tr><td><code id="inclusion_prob_+3A_strata">strata</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving
the strata associated with units in the population. The default is to place
all units into a single stratum.</p>
</td></tr>
<tr><td><code id="inclusion_prob_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector with values between 0 and 1 for each stratum,
ordered according to the levels of <code>strata</code>. Units with inclusion
probabilities greater than or equal to 1 - <code>alpha</code> are set to 1 for
each stratum. A single value is recycled for all strata. The default is
slightly larger than 0.</p>
</td></tr>
<tr><td><code id="inclusion_prob_+3A_cutoff">cutoff</code></td>
<td>
<p>A positive numeric vector of cutoffs for each stratum, ordered
according to the levels of <code>strata</code>. Units with <code>x &gt;= cutoff</code> get
an inclusion probability of 1 for each stratum. A single value is recycled
for all strata. The default does not apply a cutoff.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within a stratum, the inclusion probability for a unit is given by
<code class="reqn">\pi = nx / \sum x</code>. These values can be greater
than 1 in practice, and so they are constructed iteratively by taking units
with <code class="reqn">\pi \geq 1 - \alpha</code> (from largest to smallest)
and assigning these units an inclusion probability of 1, with the remaining
inclusion probabilities recalculated at each step. If <code class="reqn">\alpha &gt; 0</code>, then
any ties among units with the same size are broken by their position.
</p>
<p>The <code>becomes_ta()</code> function reverses this operations and finds the critical
sample size at which a unit enters the take-all stratum. This value is
undefined for units that are always included in the sample (because their
size exceeds <code>cutoff</code>) or never included.
</p>


<h3>Value</h3>

<p><code>inclusion_prob()</code> returns a numeric vector of inclusion probabilities for
each unit in the population.
</p>
<p><code>becomes_ta()</code> returns an integer vector giving the sample size at which a
unit enters the take-all stratum.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sps">sps()</a></code> for drawing a sequential Poisson sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make inclusion probabilities for a population with units
# of different size
x &lt;- c(1:10, 100)
(pi &lt;- inclusion_prob(x, 5))

# The last unit is sufficiently large to be included in all
# samples with two or more units
becomes_ta(x)

# Use the inclusion probabilities to calculate the variance of the
# sample size for Poisson sampling
sum(pi * (1 - pi))

</code></pre>

<hr>
<h2 id='prop_allocation'>Construct a proportional allocation</h2><span id='topic+prop_allocation'></span>

<h3>Description</h3>

<p>Generate a proportional-to-size allocation for stratified sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_allocation(
  x,
  n,
  strata,
  initial = 0L,
  divisor = function(a) a + 1,
  ties = c("largest", "first")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_allocation_+3A_x">x</code></td>
<td>
<p>A positive and finite numeric vector of sizes for units in the
population (e.g., revenue for drawing a sample of businesses).</p>
</td></tr>
<tr><td><code id="prop_allocation_+3A_n">n</code></td>
<td>
<p>A positive integer giving the sample size.</p>
</td></tr>
<tr><td><code id="prop_allocation_+3A_strata">strata</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving
the strata associated with units in the population. The default is to place
all units into a single stratum.</p>
</td></tr>
<tr><td><code id="prop_allocation_+3A_initial">initial</code></td>
<td>
<p>A positive integer vector giving the initial (or minimal)
allocation for each stratum, ordered according to the levels of
<code>strata</code>. A single integer is recycled for each stratum using a special
algorithm to ensure a feasible allocation; see details. Non-integers are
truncated towards 0. The default allows for no units to be allocated to a
stratum.</p>
</td></tr>
<tr><td><code id="prop_allocation_+3A_divisor">divisor</code></td>
<td>
<p>A divisor function for the divisor (highest-averages)
apportionment method. The default uses the Jefferson (D'Hondt) method. See
details for other possible functions.</p>
</td></tr>
<tr><td><code id="prop_allocation_+3A_ties">ties</code></td>
<td>
<p>Either 'largest' to break ties in favor of the stratum with the
largest size, or 'first' to break ties in favor of the ordering of
<code>strata</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>prop_allocation()</code> function gives a sample size for each level in
<code>strata</code> that is proportional to the sum of <code>x</code> across strata and
adds up to <code>n</code>. This is done using the divisor (highest-averages)
apportionment method (Balinksi and Young, 1982, Appendix A), for which there
are a number of different divisor functions:
</p>

<dl>
<dt>Jefferson/D'Hondt</dt><dd><p><code style="white-space: pre;">&#8288;\(a) a + 1&#8288;</code></p>
</dd>
<dt>Webster/Sainte-Laguë</dt><dd><p><code style="white-space: pre;">&#8288;\(a) a + 0.5&#8288;</code></p>
</dd>
<dt>Imperiali</dt><dd><p><code style="white-space: pre;">&#8288;\(a) a + 2&#8288;</code></p>
</dd>
<dt>Huntington-Hill</dt><dd><p><code style="white-space: pre;">&#8288;\(a) sqrt(a * (a + 1))&#8288;</code></p>
</dd>
<dt>Danish</dt><dd><p><code style="white-space: pre;">&#8288;\(a) a + 1 / 3&#8288;</code></p>
</dd>
<dt>Adams</dt><dd><p><code style="white-space: pre;">&#8288;\(a) a&#8288;</code></p>
</dd>
<dt>Dean</dt><dd><p><code style="white-space: pre;">&#8288;\(a) a * (a + 1) / (a + 0.5)&#8288;</code></p>
</dd>
</dl>

<p>Note that a divisor function with <code class="reqn">d(0) = 0</code> (i.e., Huntington-Hill,
Adams, Dean) should have an initial allocation of at least 1 for all strata.
In all cases, ties are broken according to the sum of <code>x</code> if
<code>ties = 'largest'</code>; otherwise, if <code>ties = 'first'</code>, then ties are broken
according to the levels of <code>strata</code>.
</p>
<p>In cases where the number of units with non-zero size in a stratum is
smaller than its allocation, the allocation for that stratum is set to the
number of available units, with the remaining sample size reallocated to
other strata proportional to <code>x</code>. This is similar to <code>PROC
SURVEYSELECT</code> in SAS with <code>ALLOC = PROPORTIONAL</code>.
</p>
<p>Passing a single integer for the initial allocation first checks that
recycling this value for each stratum does not result in an allocation
larger than the sample size. If it does, then the value is reduced so that
recycling does not exceed the sample size. This recycled vector can be
further reduced in cases where it exceeds the number of units in a stratum,
the result of which is the initial allocation. This special recycling
ensures that the initial allocation is feasible.
</p>


<h3>Value</h3>

<p>A named integer vector of sample sizes for each stratum in <code>strata</code>.
</p>


<h3>References</h3>

<p>Balinksi, M. L. and Young, H. P. (1982).
<em>Fair Representation: Meeting the Ideal of One Man, One Vote</em>.
Yale University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sps">sps()</a></code> for stratified sequential Poisson sampling.
</p>
<p><code><a href="#topic+expected_coverage">expected_coverage()</a></code> to calculate the expected number of strata in a sample
without stratification.
</p>
<p><code>strAlloc()</code> in the <span class="pkg">PracTools</span> package for other allocation methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a population with units of different size
x &lt;- c(rep(1:9, each = 3), 100, 100, 100)

# ... and 10 strata
s &lt;- rep(letters[1:10], each = 3)

# Generate an allocation
prop_allocation(x, 15, s, initial = 1)

</code></pre>

<hr>
<h2 id='sps'>Stratified sequential Poisson sampling</h2><span id='topic+sps'></span><span id='topic+ps'></span><span id='topic+order_sampling'></span>

<h3>Description</h3>

<p>Draw a stratified probability-proportional-to-size sample using the
sequential and ordinary Poisson methods, and generate other order sampling
schemes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sps(x, n, strata = NULL, prn = NULL, alpha = 0.001, cutoff = Inf)

ps(x, n, strata = NULL, prn = NULL, alpha = 0.001, cutoff = Inf)

order_sampling(dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sps_+3A_x">x</code></td>
<td>
<p>A positive and finite numeric vector of sizes for units in the
population (e.g., revenue for drawing a sample of businesses).</p>
</td></tr>
<tr><td><code id="sps_+3A_n">n</code></td>
<td>
<p>A positive integer vector giving the sample size for each stratum,
ordered according to the levels of <code>strata</code>. A single value is recycled
for all strata. Non-integers are truncated towards 0.</p>
</td></tr>
<tr><td><code id="sps_+3A_strata">strata</code></td>
<td>
<p>A factor, or something that can be coerced into one, giving
the strata associated with units in the population. The default is to place
all units into a single stratum.</p>
</td></tr>
<tr><td><code id="sps_+3A_prn">prn</code></td>
<td>
<p>A numeric vector of permanent random numbers for units in the
population, distributed uniform between 0 and 1. The default does not use
permanent random numbers, instead generating a random vector when the
function is called.</p>
</td></tr>
<tr><td><code id="sps_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector with values between 0 and 1 for each stratum,
ordered according to the levels of <code>strata</code>. Units with inclusion
probabilities greater than or equal to 1 - <code>alpha</code> are set to 1 for
each stratum. A single value is recycled for all strata. The default is
slightly larger than 0.</p>
</td></tr>
<tr><td><code id="sps_+3A_cutoff">cutoff</code></td>
<td>
<p>A positive numeric vector of cutoffs for each stratum, ordered
according to the levels of <code>strata</code>. Units with <code>x &gt;= cutoff</code> get
an inclusion probability of 1 for each stratum. A single value is recycled
for all strata. The default does not apply a cutoff.</p>
</td></tr>
<tr><td><code id="sps_+3A_dist">dist</code></td>
<td>
<p>A function giving the fixed order distribution shape for an order
sampling scheme. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sps()</code> function draws a sample according to the sequential Poisson
procedure, the details of which are given by Ohlsson (1998). It is also
called uniform order sampling, as it is a type of order sampling; see Rosén
(1997, 2000) for a more general presentation of the method. This is the same
method used by <code>PROC SURVEYSELECT</code> in SAS with <code>METHOD =
SEQ_POISSON</code>.
</p>
<p>For each stratum, the sequential Poisson procedure starts by stratifying
units in the population based on their (target) inclusion probabilities
<code class="reqn">\pi</code>. Units with <code class="reqn">\pi = 0</code> are placed into a take-none stratum,
units with <code class="reqn">0 &lt; \pi &lt; 1</code> are placed into a take-some stratum, and units
with <code class="reqn">\pi = 1</code> are placed into a take-all stratum. As noted by
Ohlsson (1998), it can be useful to set <code class="reqn">\alpha</code> to a small positive
value when calculating inclusion probabilities, and this is the default
behavior.
</p>
<p>After units are appropriately stratified, a sample of take-some units is
drawn by assigning each unit a value <code class="reqn">\xi = u / \pi</code>, where <code class="reqn">u</code> is a
random deviate from the uniform distribution between 0 and 1. The units with
the smallest values for <code class="reqn">\xi</code> are included in the sample, along with the
take-all units. (Ties in <code class="reqn">\xi</code> are technically a measure-zero event&mdash;in
practice these are broken by position.) This results in a fixed sample size
at the expense of the sampling procedure being only approximately
probability-proportional-to-size (i.e., the inclusion probabilities from the
sample design are close but not exactly equal to <code class="reqn">\pi</code>; see Matei and
Tillé, 2007, for details on the exact computation).
</p>
<p>Ordinary Poisson sampling follows the same procedure as above, except that
all units with <code class="reqn">\xi &lt; 1</code> are included in the sample; consequently, while
it does not contain a fixed number of units, the procedure is strictly
probability-proportional-to-size. Despite this difference, the standard
Horvitz-Thompson estimator for the total (of the take-some stratum) is
asymptotically unbiased, normally distributed, and equally efficient under
both procedures. The <code>ps()</code> function draws a sample using the ordinary
Poisson method.
</p>
<p>A useful feature of sequential and ordinary Poisson sampling is the ability
to coordinate samples by using permanent random numbers for <code class="reqn">u</code>. Keeping
<code class="reqn">u</code> fixed when updating a sample retains a larger number of overlapping
units, whereas switching <code class="reqn">u</code> for <code class="reqn">u - z \bmod 1</code> or
<code class="reqn">1 - (u - z \bmod 1)</code>, for some <code class="reqn">z</code> between 0 and
1, when drawing different samples from the same frame reduces the number of
overlapping units.
</p>
<p>Despite the focus on sequential Poisson sampling, all order sampling
procedures follow the same approach as sequential Poisson sampling. The
<code>order_sampling()</code> function can be used to generate other order
sampling functions by passing an appropriate function to make the ranking
variable <code class="reqn">\xi</code>:
</p>

<dl>
<dt>Sequential Poisson sampling</dt><dd><p><code style="white-space: pre;">&#8288;\(x) x&#8288;</code></p>
</dd>
<dt>Successive sampling</dt><dd><p><code style="white-space: pre;">&#8288;\(x) log(1 - x)&#8288;</code></p>
</dd>
<dt>Pareto sampling</dt><dd><p><code style="white-space: pre;">&#8288;\(x) x / (1 - x)&#8288;</code></p>
</dd>
</dl>



<h3>Value</h3>

<p><code>sps()</code> and <code>ps()</code> return an object of class <code>sps_sample</code>.
This is an integer vector of indices for the units in the population that
form the sample, along with a <code>weights</code> attribute that gives the design
(inverse probability) weights for each unit in the sample (keeping in mind
that sequential Poisson sampling is only approximately
probability-proportional-to-size). <code>weights()</code> can be used to access
the design weights attribute of an <code>sps_sample</code> object, and <code>levels()</code> can
be used to determine which units are in the take-all or take-some
strata. <a href="base.html#topic+groupGeneric">Mathematical and binary/unary operators</a> strip
attributes, as does replacement.
</p>
<p><code>order_sampling</code> returns a function the with the same interface as
<code>sps()</code> and <code>ps()</code>.
</p>


<h3>References</h3>

<p>Matei, A., and Tillé, Y. (2007). Computational aspects of order
<code class="reqn">\pi</code>ps sampling schemes. <em>Computational Statistics &amp; Data Analysis</em>,
51: 3703-3717.
</p>
<p>Ohlsson, E. (1998). Sequential Poisson Sampling.
<em>Journal of Official Statistics</em>, 14(2): 149-162.
</p>
<p>Rosén, B. (1997). On sampling with probability proportional to size.
<em>Journal of Statistical Planning and Inference</em>, 62(2): 159-191.
</p>
<p>Rosén, B. (2000). On inclusion probabilities for order <code class="reqn">\pi</code>ps sampling.
<em>Journal of Statistical Planning and Inference</em>, 90(1): 117-143.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prop_allocation">prop_allocation()</a></code> for generating proportional-to-size allocations.
</p>
<p><code><a href="#topic+inclusion_prob">inclusion_prob()</a></code> for calculating the inclusion probabilities.
</p>
<p><code><a href="#topic+sps_repweights">sps_repweights()</a></code> for generating bootstrap replicate weights.
</p>
<p>The <code>UPpoisson()</code> and <code>UPopips()</code> functions in the <span class="pkg">sampling</span>
package for ordinary and sequential Poisson sampling, respectively. Note
that the algorithm for order sampling in the <code>UPopips()</code> function is
currently incorrect, giving a worse approximation for the inclusion
probabilities than it should.
</p>
<p>The <code style="white-space: pre;">&#8288;UP*&#8288;</code> functions in the <span class="pkg">sampling</span> package, the <code style="white-space: pre;">&#8288;S.*&#8288;</code>
functions in the <span class="pkg">TeachingSampling</span> package, and the <span class="pkg">pps</span> package
for other probability-proportional-to-size sampling methods.
</p>
<p>The <code>pps()</code> function in the <span class="pkg">prnsamplr</span> package for Pareto order
sampling with permanent random numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a population with units of different size
x &lt;- c(1:10, 100)

#---- Sequential Poisson sampling ----
# Draw a sequential Poisson sample
(samp &lt;- sps(x, 5))

# Get the design (inverse probability) weights
weights(samp)

# All units except 11 are in the take-some (TS) stratum
levels(samp)

# Ensure that the top 10% of units are in the sample
sps(x, 5, cutoff = quantile(x, 0.9))

#---- Ordinary Poisson sampling ----
# Ordinary Poisson sampling gives a random sample size for the
# take-some stratum
ps(x, 5)

#---- Stratified Sequential Poisson sampling ----
# Draw a stratified sample with a proportional allocation
strata &lt;- rep(letters[1:4], each = 5)
(allocation &lt;- prop_allocation(1:20, 12, strata))
(samp &lt;- sps(1:20, allocation, strata))

# Use the Horvitz-Thompson estimator to estimate the total
y &lt;- runif(20) * 1:20
sum(weights(samp) * y[samp])

#---- Useful properties of Sequential Poisson sampling ----
# It can be useful to set 'prn' in order to extend the sample
# to get a fixed net sample
u &lt;- runif(11)
(samp &lt;- sps(x, 6, prn = u))

# Removing unit 5 gives the same net sample
sps(x[-samp[5]], 6, prn = u[-samp[5]])

# Also useful for topping up a sample
all(samp %in% sps(x, 7, prn = u))

#---- Other order-sampling methods ----
# Generate new order-sampling functions from the parameters of
# the inverse generalized Pareto distribution
igpd &lt;- function(shape, scale = 1, location = 0) {
  if (shape == 0) {
    function(x) -scale * log(1 - x) + location
  } else {
    function(x) scale * (1 - (1 - x)^shape) / shape + location
  }
}

order_sampling2 &lt;- function(x) order_sampling(igpd(x))

order_sampling2(1)(x, 6, prn = u) # sequential Poisson
order_sampling2(0)(x, 6, prn = u) # successive
order_sampling2(-1)(x, 6, prn = u) # Pareto

</code></pre>

<hr>
<h2 id='sps_repweights'>Bootstrap replicate weights for sequential Poisson sampling</h2><span id='topic+sps_repweights'></span><span id='topic+min_tau'></span>

<h3>Description</h3>

<p>Produce bootstrap replicate weights that are appropriate for Poisson
sampling, and therefore approximately correct for sequential Poisson
sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sps_repweights(w, replicates = 1000L, tau = min_tau(1e-04), dist = NULL)

min_tau(tol)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sps_repweights_+3A_w">w</code></td>
<td>
<p>A numeric vector of design (inverse probability) weights for a
(sequential) Poisson sample.</p>
</td></tr>
<tr><td><code id="sps_repweights_+3A_replicates">replicates</code></td>
<td>
<p>A positive integer that gives the number of bootstrap
replicates (1,000 by default). Non-integers are truncated towards 0.</p>
</td></tr>
<tr><td><code id="sps_repweights_+3A_tau">tau</code></td>
<td>
<p>A number greater than or equal to 1 that gives the rescale factor
for the bootstrap weights. Setting to 1 does not rescale the
weights. This can also be a function that takes a vector of bootstrap
adjustments and returns a number larger than 1. The default automatically
picks the smallest feasible rescale factor (up to a small tolerance).</p>
</td></tr>
<tr><td><code id="sps_repweights_+3A_dist">dist</code></td>
<td>
<p>A function that produces random deviates with mean 0 and
standard deviation 1, such as <code><a href="stats.html#topic+rnorm">rnorm()</a></code>. The default uses the
pseudo-population method from section 4.1 of Beaumont and Patak (2012); see
details.</p>
</td></tr>
<tr><td><code id="sps_repweights_+3A_tol">tol</code></td>
<td>
<p>A non-negative number, strictly less than 1, that gives the
tolerance for determining the minimum feasible value of <code>tau</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Replicate weights are constructed using the generalized bootstrap method by
Beaumont and Patak (2012). Their method takes a vector of design weights
<code class="reqn">w</code>, finds a vector of adjustments <code class="reqn">a</code> for each bootstrap replicate,
and calculates the replicate weights as <code class="reqn">a w</code>.
</p>
<p>There are two ways to calculate the adjustments <code class="reqn">a</code>. The default
pseudo-population method randomly rounds <code class="reqn">w</code> for each replicate to
produce a collection of integer weights <code class="reqn">w'</code> that are used to generate a
random vector <code class="reqn">b</code> from the binomial distribution. The vector of
adjustments is then <code class="reqn">a = 1 + b - w' / w</code>. Specifying a
deviates-generating function for <code>dist</code> uses this function to produce a
random vector <code class="reqn">d</code> that is then used to make an adjustment <code class="reqn">a = 1 + d
\sqrt{1 - 1 / w}</code>.
</p>
<p>The adjustments can be rescaled by a value <code class="reqn">\tau \geq 1</code> to
prevent negative replicate weights. With this rescaling, the adjustment
becomes <code class="reqn">(a + \tau - 1) / \tau</code>. If <code class="reqn">\tau &gt; 1</code> then the resulting
bootstrap variance estimator should be multiplied by <code class="reqn">\tau^2</code>.
</p>


<h3>Value</h3>

<p><code>sps_repweights()</code> returns a matrix of bootstrap replicate weights
with <code>replicates</code> columns (one for each replicate) and <code>length(w)</code> rows
(one for each unit in the sample), with the value of <code>tau</code> as an attribute.
</p>
<p><code>min_tau()</code> returns a function that takes a vector of bootstrap adjustments
and returns the smallest value for <code class="reqn">\tau</code> such that the rescaled
adjustments are greater than or equal to <code>tol</code>.
</p>


<h3>Note</h3>

<p>As an alternative to the bootstrap, Ohlsson (1998, equations 2.13)
proposes an analytic estimator for the variance of the total <code class="reqn">\hat Y =
\sum wy</code> (for the take-some units) under sequential Poisson
sampling: </p>
<p style="text-align: center;"><code class="reqn">V(\hat Y) = \frac{n}{n - 1} \sum \left(1 -
\frac{1}{w}\right) \left(wy - \frac{\hat Y}{n}\right)^2.</code>
</p>
<p> See Rosén (1997, equation 3.11) for a
more general version of this estimator that can be applied to other order
sampling schemes. Replacing the left-most correction by <code class="reqn">n / (m - 1)</code>,
where <code class="reqn">m</code> is the number of units in the sample, gives a similar
estimator for the total under ordinary Poisson sampling, <code class="reqn">\hat Y = n / m
\sum wy</code>.
</p>


<h3>References</h3>

<p>Beaumont, J.-F. and Patak, Z. (2012). On the Generalized
Bootstrap for Sample Surveys with Special Attention to Poisson Sampling.
<em>International Statistical Review</em>, 80(1): 127-148.
</p>
<p>Ohlsson, E. (1998). Sequential Poisson Sampling.
<em>Journal of Official Statistics</em>, 14(2): 149-162.
</p>
<p>Rosén, B. (1997). On sampling with probability proportional to size.
<em>Journal of Statistical Planning and Inference</em>, 62(2): 159-191.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sps">sps()</a></code> for drawing a sequential Poisson sample.
</p>
<p><code>bootstrapFP()</code> (with <code>method = "wGeneralised"</code>) in the <span class="pkg">bootstrapFP</span>
package for calculating the variance of Horvitz-Thompson estimators using
the generalized bootstrap and <code>make_gen_boot_factors()</code> in the <span class="pkg">svrep</span>
package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a population with units of different size
x &lt;- c(1:10, 100)

# Draw a sequential Poisson sample
(samp &lt;- sps(x, 5))

# Make some bootstrap replicates
dist &lt;- list(
  pseudo_population = NULL,
  standard_normal = rnorm,
  exponential = \(x) rexp(x) - 1,
  uniform = \(x) runif(x, -sqrt(3), sqrt(3))
)

lapply(dist, sps_repweights, w = weights(samp), replicates = 5, tau = 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
