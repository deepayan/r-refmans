<!DOCTYPE html><html lang="en"><head><title>Help for package causaloptim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {causaloptim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#causaloptim-package'><p>An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects</p></a></li>
<li><a href='#analyze_graph'><p>Analyze the causal graph and effect to determine constraints and objective</p></a></li>
<li><a href='#btm_var'><p>Recursive function to get the last name in a list</p></a></li>
<li><a href='#causalproblemcheck'><p>Check conditions on causal problem</p></a></li>
<li><a href='#check_constraints_violated'><p>Check whether any of the observable constraints implied by the causal model are violated for a given distribution of observables</p></a></li>
<li><a href='#check_linear_objective'><p>Check linearity of objective function implied by a causal model and effect</p></a></li>
<li><a href='#check_parents'><p>Check for paths from from to to</p></a></li>
<li><a href='#constraintscheck'><p>Check constraints</p></a></li>
<li><a href='#create_causalmodel'><p>Create a structural causal model from a graph or a set of response functions</p></a></li>
<li><a href='#create_effect_vector'><p>Translate target effect to vector of response variables</p></a></li>
<li><a href='#create_linearcausalproblem'><p>Create linear causal problem from causal model and effect</p></a></li>
<li><a href='#create_q_matrix'><p>Translate response functions into matrix of counterfactuals</p></a></li>
<li><a href='#create_response_function'><p>Translate regular DAG to response functions</p></a></li>
<li><a href='#find_all_paths'><p>Find all paths in a causal model</p></a></li>
<li><a href='#get_default_effect'><p>Define default effect for a given graph</p></a></li>
<li><a href='#graphrescheck'><p>Check conditions on digraph</p></a></li>
<li><a href='#initialize_graph'><p>Initialize an igraph object for use with causaloptim</p></a></li>
<li><a href='#interpret_bounds'><p>Convert bounds string to a function</p></a></li>
<li><a href='#latex_bounds'><p>Latex bounds equations</p></a></li>
<li><a href='#list_to_path'><p>Recursive function to translate an effect list to a path sequence</p></a></li>
<li><a href='#opt_effect'><p>Compute a bound on the average causal effect</p></a></li>
<li><a href='#optimize_effect_2'><p>Run the optimizer to obtain symbolic bounds</p></a></li>
<li><a href='#parse_constraints'><p>Parse text that defines a the constraints</p></a></li>
<li><a href='#parse_effect'><p>Parse text that defines a causal effect</p></a></li>
<li><a href='#plot_graphres'><p>Plot the analyzed graph object</p></a></li>
<li><a href='#plot.linearcausalproblem'><p>Plot the graph from the causal problem with a legend describing attributes</p></a></li>
<li><a href='#print.causalmodel'><p>Print relevant information about the causal model</p></a></li>
<li><a href='#print.linearcausalproblem'><p>Print the causal problem</p></a></li>
<li><a href='#querycheck'><p>Check conditions on query</p></a></li>
<li><a href='#rdirichlet'><p>Sample from a Dirichlet distribution</p></a></li>
<li><a href='#sample_distribution'><p>Sample a distribution of observable probabilities that satisfy the causal model</p></a></li>
<li><a href='#simulate_bounds'><p>Simulate bounds</p></a></li>
<li><a href='#specify_graph'><p>Shiny interface to specify network structure and compute bounds</p></a></li>
<li><a href='#update_effect'><p>Update the effect in a linearcausalproblem object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An Interface to Specify Causal Graphs and Compute Bounds on
Causal Effects</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-16</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael C Sachs &lt;sachsmc@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>When causal quantities are not identifiable from the observed data, it still may be possible 
            to bound these quantities using the observed data. We outline a class of problems for which the 
            derivation of tight bounds is always a linear programming problem and can therefore, at least 
            theoretically, be solved using a symbolic linear optimizer. We extend and generalize the 
            approach of Balke and Pearl (1994) &lt;<a href="https://doi.org/10.1016%2FB978-1-55860-332-5.50011-0">doi:10.1016/B978-1-55860-332-5.50011-0</a>&gt; and we provide 
            a user friendly graphical interface for setting up such problems via directed acyclic 
            graphs (DAG), which only allow for problems within this class to be depicted. The user can 
            then define linear constraints to further refine their assumptions to meet their specific 
            problem, and then specify a causal query using a text interface. The program converts this 
            user defined DAG, query, and constraints, and returns tight bounds. The bounds can be 
            converted to R functions to evaluate them for specific datasets, and to latex code for 
            publication. The methods and proofs of tightness and validity of the bounds are described in
            a paper by Sachs, Jonzon, Gabriel, and Sjölander (2022) 
            &lt;<a href="https://doi.org/10.1080%2F10618600.2022.2071905">doi:10.1080/10618600.2022.2071905</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>shiny, rcdd</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), igraph</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sachsmc.github.io/causaloptim/">https://sachsmc.github.io/causaloptim/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sachsmc/causaloptim/issues/">https://github.com/sachsmc/causaloptim/issues/</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-17 08:39:45 UTC; micsac</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael C Sachs [aut, cre],
  Erin E Gabriel [aut],
  Arvid Sjölander [aut],
  Gustav Jonzon [aut],
  Alexander A Balke [ctb] ((C++ code)),
  Colorado Reed [ctb] ((graph-creator.js))</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-17 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='causaloptim-package'>An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects</h2><span id='topic+causaloptim-package'></span><span id='topic+causaloptim'></span>

<h3>Description</h3>

<p>Specify causal graphs using a visual interactive interface and then analyze them and compute symbolic bounds for the causal effects in terms of the observable parameters.
</p>


<h3>Details</h3>

<p>Run the shiny app by <code>results &lt;- specify_graph()</code>. See detailed instructions in the vignette <code>browseVignettes("causaloptim")</code>.
</p>


<h3>Author(s)</h3>

<p>Michael C Sachs, Arvid Sjölander, Gustav Jonzon, Alexander Balke, Colorado Reed, and Erin Gabriel
Maintainer: Michael C Sachs &lt;sachsmc at gmail.com&gt;
</p>


<h3>References</h3>

<p>Sachs, M. C., Jonzon, G., Sjölander, A., &amp; Gabriel, E. E. (2023). A general method for deriving tight symbolic bounds on causal effects. Journal of Computational and Graphical Statistics, 32(2), 567-576. <a href="https://www.tandfonline.com/doi/full/10.1080/10618600.2022.2071905">https://www.tandfonline.com/doi/full/10.1080/10618600.2022.2071905</a> .
</p>


<h3>See Also</h3>

<p><code>browseVignettes('causaloptim')</code> <a href="#topic+specify_graph">specify_graph</a>
</p>

<hr>
<h2 id='analyze_graph'>Analyze the causal graph and effect to determine constraints and objective</h2><span id='topic+analyze_graph'></span>

<h3>Description</h3>

<p>The graph must contain certain edge and vertex attributes which are documented
in the Details below. The shiny app run by <a href="#topic+specify_graph">specify_graph</a> will return a
graph in this format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_graph(graph, constraints, effectt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyze_graph_+3A_graph">graph</code></td>
<td>
<p>An <a href="igraph.html#topic+igraph-package">igraph-package</a> object that represents a directed acyclic graph with certain attributes. See Details.</p>
</td></tr>
<tr><td><code id="analyze_graph_+3A_constraints">constraints</code></td>
<td>
<p>A vector of character strings that represent the constraints on counterfactual quantities</p>
</td></tr>
<tr><td><code id="analyze_graph_+3A_effectt">effectt</code></td>
<td>
<p>A character string that represents the causal effect of interest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graph object must contain the following named vertex attributes: </p>

<dl>
<dt>name</dt><dd><p>The name of each vertex must be a valid R object name starting with a letter and no special characters. Good candidate names are for example, Z1, Z2, W2, X3, etc. </p>
</dd>
<dt>leftside</dt><dd><p>An indicator of whether the vertex is on the left side of the graph, 1 if yes, 0 if no.</p>
</dd>
<dt>latent</dt><dd><p>An indicator of whether the variable is latent (unobserved). There should always be a variable Ul on the left side that is latent and a parent of all variables on the left side, and another latent variable Ur on the right side that is a parent of all variables on the right side. </p>
</dd>
<dt>nvals</dt><dd><p>The number of possible values that the variable can take on, the default and minimum is 2 for 2 categories (0,1). In general, a variable with nvals of K can take on values 0, 1, ..., (K-1).</p>
</dd>
</dl>

<p>In addition, there must be the following edge attributes: </p>

<dl>
<dt>rlconnect</dt><dd><p>An indicator of whether the edge goes from the right side to the left side. Should be 0 for all edges.</p>
</dd>
<dt>edge.monotone</dt><dd><p>An indicator of whether the effect of the edge is monotone, meaning that if V1 -&gt; V2 and the edge is monotone, then a &gt; b implies V2(V1 = a) &gt;= V2(V1 = b). Only available for binary variables (nvals = 2).</p>
</dd>
</dl>

<p>The effectt parameter describes your causal effect of interest. The effectt parameter must be of the form
</p>
<p><code>p{V11(X=a)=a; V12(X=a)=b;...} op1 p{V21(X=b)=a; V22(X=c)=b;...} op2 ...</code>
</p>
<p>where Vij are names of variables in the graph, a, b are numeric values from 0:(nvals - 1), and op are either - or +. You can specify a single probability statement (i.e., no operator). Note that the probability statements begin with little p, and use curly braces, and items inside the probability statements are separated by ;. The variables may be potential outcomes which are denoted by parentheses. Variables may also be nested inside potential outcomes. Pure observations such as <code>p{Y = 1}</code> are not allowed if the left side contains any variables. 
There are 2 important rules to follow: 1) Only variables on the right side can be in the probability events, and if the left side is not empty: 2) none of the variables in the left side that are intervened upon can have any children in the left side, and all paths from the left to the right must be blocked by the intervention set. Here the intervention set is anything that is inside the smooth brackets (i.e., variable set to values).
</p>
<p>All of the following are valid effect statements:
</p>
<p><code>p{Y(X = 1) = 1} - p{Y(X = 0) = 1}</code>
</p>
<p><code>p{X(Z = 1) = 1; X(Z = 0) = 0}</code>
</p>
<p><code>p{Y(M(X = 0), X = 1) = 1} - p{Y(M(X = 0), X = 0) = 1}</code>
</p>
<p>The constraints are specified in terms of potential outcomes to constrain by writing the potential outcomes, values of their parents, and operators that determine the constraint (equalities or inequalities). For example,
<code>X(Z = 1) &gt;= X(Z = 0)</code>
</p>


<h3>Value</h3>

<p>A an object of class &quot;linearcausalproblem&quot;, which is a list with the
following components. This list can be passed to <a href="#topic+optimize_effect_2">optimize_effect_2</a>
which interfaces with the symbolic optimization program. Print and plot methods are also
available. </p>
 
<dl>
<dt>variables</dt><dd><p>Character vector of variable names
of potential outcomes, these start with 'q' to match Balke's notation</p>
</dd>
<dt>parameters</dt><dd><p>Character vector of parameter names of observed
probabilities, these start with 'p' to match Balke's notation</p>
</dd>
<dt>constraints</dt><dd><p>Character vector of parsed constraints</p>
</dd>
<dt>objective</dt><dd><p>Character string defining the objective to be optimized in
terms of the variables</p>
</dd> 
<dt>p.vals</dt><dd><p>Matrix of all possible values of the
observed data vector, corresponding to the list of parameters.</p>
</dd>
<dt>q.vals</dt><dd><p>Matrix of all possible values of the response function form
of the potential outcomes, corresponding to the list of variables.</p>
</dd>
<dt>parsed.query</dt><dd><p>A nested list containing information on the parsed
causal query.</p>
</dd> 
<dt>objective.nonreduced</dt><dd><p>The objective in terms of the
original variables, before algebraic variable reduction. The nonreduced
variables can be obtained by concatenating the columns of q.vals.</p>
</dd>
<dt>response.functions</dt><dd><p>List of response functions.</p>
</dd> 
<dt>graph</dt><dd><p>The graph as passed to the function.</p>
</dd> 
<dt>R</dt><dd><p>A matrix with coefficients
relating the p.vals to the q.vals p = R * q</p>
</dd> 
<dt>c0</dt><dd><p>A vector of coefficients relating the q.vals to the 
objective function theta = c0 * q</p>
</dd> 
<dt>iqR</dt><dd><p>A matrix with coefficients to represent the inequality
constraints</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>### confounded exposure and outcome
b &lt;- initialize_graph(igraph::graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y))
analyze_graph(b, constraints = NULL, effectt = "p{Y(X = 1) = 1} - p{Y(X = 0) = 1}")
</code></pre>

<hr>
<h2 id='btm_var'>Recursive function to get the last name in a list</h2><span id='topic+btm_var'></span>

<h3>Description</h3>

<p>Recursive function to get the last name in a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>btm_var(x, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="btm_var_+3A_x">x</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="btm_var_+3A_name">name</code></td>
<td>
<p>name of the top element of the list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the deepest nested list element
</p>


<h3>Examples</h3>

<pre><code class='language-R'>btm_var(list(X = list(Y = list(K = 1))))

</code></pre>

<hr>
<h2 id='causalproblemcheck'>Check conditions on causal problem</h2><span id='topic+causalproblemcheck'></span>

<h3>Description</h3>

<p>Check that a given causal problem (a causal DAG together with a causal query)
satisfies conditions that guarantee that the optimization problem is linear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>causalproblemcheck(digraph, query)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="causalproblemcheck_+3A_digraph">digraph</code></td>
<td>
<p>An <code>igraph</code> object representing a digraph.
</p>
<p>Expected vertex attributes: <code>leftside</code>, <code>latent</code> and <code>nvals</code>.
</p>
<p>Optional vertex attributes: <code>exposure</code> and <code>outcome</code>.
</p>
<p>Expected edge attributes: <code>rlconnect</code> and <code>edge.monotone</code>.</p>
</td></tr>
<tr><td><code id="causalproblemcheck_+3A_query">query</code></td>
<td>
<p>A string representing a causal query / effect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if conditions are met; <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- graph_from_literal(X - +Y, Ur - +X, Ur - +Y)
V(b)$leftside &lt;- c(0, 0, 0)
V(b)$latent &lt;- c(0, 0, 1)
V(b)$nvals &lt;- c(2, 2, 2)
V(b)$exposure &lt;- c(1, 0, 0)
V(b)$outcome &lt;- c(0, 1, 0)
E(b)$rlconnect &lt;- c(0, 0, 0)
E(b)$edge.monotone &lt;- c(0, 0, 0)
effectt &lt;- "p{Y(X=1)=1}-p{Y(X=0)=1}"
causalproblemcheck(digraph = b, query = effectt)

</code></pre>

<hr>
<h2 id='check_constraints_violated'>Check whether any of the observable constraints implied by the causal model are violated for a given distribution of observables</h2><span id='topic+check_constraints_violated'></span>

<h3>Description</h3>

<p>Check whether any of the observable constraints implied by the causal model are violated for a given distribution of observables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_constraints_violated(obj, probs, tol = 1e-12)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_constraints_violated_+3A_obj">obj</code></td>
<td>
<p>An object of class &quot;causalmodel&quot;</p>
</td></tr>
<tr><td><code id="check_constraints_violated_+3A_probs">probs</code></td>
<td>
<p>A named vector of observable probabilities, in the same order as obj$data$parameters</p>
</td></tr>
<tr><td><code id="check_constraints_violated_+3A_tol">tol</code></td>
<td>
<p>Tolerance for checking (in)equalities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either TRUE (violated) or FALSE (not violated) with messages indicating what constraints are violated if any.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Ur -+ X, Ur -+ Y))

iv_model &lt;- create_causalmodel(graph, prob.form = list(out = c("X", "Y"), cond = "Z"))
check_constraints_violated(iv_model, probs = sample_distribution(iv_model))

</code></pre>

<hr>
<h2 id='check_linear_objective'>Check linearity of objective function implied by a causal model and effect</h2><span id='topic+check_linear_objective'></span>

<h3>Description</h3>

<p>Check linearity of objective function implied by a causal model and effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_linear_objective(causal_model, effectt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_linear_objective_+3A_causal_model">causal_model</code></td>
<td>
<p>An object of class &quot;causalmodel&quot; as produce by <a href="#topic+create_causalmodel">create_causalmodel</a></p>
</td></tr>
<tr><td><code id="check_linear_objective_+3A_effectt">effectt</code></td>
<td>
<p>A character string that represents the causal effect of interest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The effectt parameter describes your causal effect of interest. The effectt parameter must be of the form
</p>
<p><code>p{V11(X=a)=a; V12(X=a)=b;...} op1 p{V21(X=b)=a; V22(X=c)=b;...} op2 ...</code>
</p>
<p>where Vij are names of variables in the graph, a, b are numeric values from 0:(nvals - 1), and op are either - or +. You can specify a single probability statement (i.e., no operator). Note that the probability statements begin with little p, and use curly braces, and items inside the probability statements are separated by ;. The variables may be potential outcomes which are denoted by parentheses. Variables may also be nested inside potential outcomes. 
</p>
<p>All of the following are valid effect statements:
</p>
<p><code>p{Y(X = 1) = 1} - p{Y(X = 0) = 1}</code>
</p>
<p><code>p{X(Z = 1) = 1; X(Z = 0) = 0}</code>
</p>
<p><code>p{Y(M(X = 0), X = 1) = 1} - p{Y(M(X = 0), X = 0) = 1}</code>
</p>
<p>The effect must be fully specified, that is, all parents of a variable that is intervened upon need to be specified. The function cannot infer missing values or marginalize over some parents but not others.
</p>


<h3>Value</h3>

<p>A logical value that is TRUE if the objective function is linear
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## regular IV case

ivgraph &lt;- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Ur -+ X, Ur -+ Y))
prob.form &lt;- list(out = c("Y", "X"), cond = "Z")

iv_model &lt;- create_causalmodel(graph = ivgraph,
            prob.form = prob.form)
check_linear_objective(iv_model, effectt = "p{Y(X = 1) = 1}")

#'  ## contaminated IV case

civgraph &lt;- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Z-+ Y, Ur -+ X, Ur -+ Y))

cont_iv &lt;- create_causalmodel(graph = civgraph, prob.form = prob.form)

check_linear_objective(cont_iv, effectt = "p{Y(X = 1) = 1}")

</code></pre>

<hr>
<h2 id='check_parents'>Check for paths from from to to</h2><span id='topic+check_parents'></span>

<h3>Description</h3>

<p>Check for paths from from to to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_parents(parent_lookup, from, to, prev = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_parents_+3A_parent_lookup">parent_lookup</code></td>
<td>
<p>A list of vectors</p>
</td></tr>
<tr><td><code id="check_parents_+3A_from">from</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="check_parents_+3A_to">to</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="check_parents_+3A_prev">prev</code></td>
<td>
<p>Should always be null when first called</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of paths or null if no path is found
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parent_lookup &lt;- list(M = "Am", Y = c("M", "Ay"), A = NULL, Am = "A", Ay = "A")
check_parents(parent_lookup, "A", "Y")
</code></pre>

<hr>
<h2 id='constraintscheck'>Check constraints</h2><span id='topic+constraintscheck'></span>

<h3>Description</h3>

<p>Check that a user-provided constraint is parsable, has valid variables and relations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraintscheck(constrainttext, graphres)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constraintscheck_+3A_constrainttext">constrainttext</code></td>
<td>
<p>A string representing a constraint.</p>
</td></tr>
<tr><td><code id="constraintscheck_+3A_graphres">graphres</code></td>
<td>
<p>An <code>igraph</code> object representing a DAG.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if all check pass; else <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graphres &lt;- graph_from_literal(Z -+ X, X -+ Y, Ul -+ Z, Ur -+ X, Ur -+ Y)
V(graphres)$leftside &lt;- c(1, 0, 0, 1, 0)
V(graphres)$latent &lt;- c(0, 0, 0, 1, 1)
V(graphres)$nvals &lt;- c(3, 2, 2, 2, 2)
V(graphres)$exposure &lt;- c(0, 1, 0, 0, 0)
V(graphres)$outcome &lt;- c(0, 0, 1, 0, 0)
E(graphres)$rlconnect &lt;- c(0, 0, 0, 0, 0)
E(graphres)$edge.monotone &lt;- c(0, 0, 0, 0, 0)
constrainttext &lt;- "X(Z = 1) &gt;= X(Z = 0)"
constraintscheck(constrainttext = constrainttext, graphres = graphres) # TRUE
</code></pre>

<hr>
<h2 id='create_causalmodel'>Create a structural causal model from a graph or a set of response functions</h2><span id='topic+create_causalmodel'></span>

<h3>Description</h3>

<p>Given either a graph or a set of response functions (i.e., either <code>graph</code> or <code>respvars</code> may be provided), and a specification of what conditional probabilities are observed, produce a causal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_causalmodel(
  graph = NULL,
  respvars = NULL,
  prob.form,
  p.vals,
  constraints = NULL,
  right.vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_causalmodel_+3A_graph">graph</code></td>
<td>
<p>A graph with special edge and vertex attributes, as produced by <a href="#topic+initialize_graph">initialize_graph</a></p>
</td></tr>
<tr><td><code id="create_causalmodel_+3A_respvars">respvars</code></td>
<td>
<p>List of response functions as produced by <a href="#topic+create_response_function">create_response_function</a></p>
</td></tr>
<tr><td><code id="create_causalmodel_+3A_prob.form">prob.form</code></td>
<td>
<p>A list with two named elements &quot;out&quot;, &quot;cond&quot; where each element is a character vector of variable names that appear in p.vals</p>
</td></tr>
<tr><td><code id="create_causalmodel_+3A_p.vals">p.vals</code></td>
<td>
<p>Data frame defining which probabilities are observable. The variable names of p.vals must all appear in prob.form. If missing, will assume that all combinations of the variables values are observed.</p>
</td></tr>
<tr><td><code id="create_causalmodel_+3A_constraints">constraints</code></td>
<td>
<p>A vector of character strings that represent the constraints on counterfactual quantities</p>
</td></tr>
<tr><td><code id="create_causalmodel_+3A_right.vars">right.vars</code></td>
<td>
<p>A vector of character strings indicating which variables are on the right side of the graph. Only required when graph is NULL. See examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that probabilities of the form p(out | cond) are observed, for each combination of values in p.vals. cond may be NULL in which case nothing is conditioned on.
</p>
<p>The constraints are specified in terms of potential outcomes to constrain by writing the potential outcomes, values of their parents, and operators that determine the constraint (equalities or inequalities). For example,
<code>X(Z = 1) &gt;= X(Z = 0)</code>
</p>


<h3>Value</h3>

<p>An object of class &quot;causalmodel&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## regular IV case

graph &lt;- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Ur -+ X, Ur -+ Y))

iv_model &lt;- create_causalmodel(graph, prob.form = list(out = c("X", "Y"), cond = "Z"))
# with monotonicity
iv_model_mono &lt;- create_causalmodel(graph, prob.form = list(out = c("X", "Y"), cond = "Z"),
                 constraints = list("X(Z = 1) &gt;= X(Z = 0)"))
                 
#showing the use of right.vars
b &lt;- initialize_graph(graph_from_literal(Ul -+ X -+ Y -+ Y2, Ur -+ Y, Ur -+ Y2))
V(b)$latent &lt;- c(1, 0, 1, 0, 1)
respvars &lt;- create_response_function(b)
create_causalmodel(graph = b, constraints = "Y2(Y = 1) &gt;= Y2(Y = 0)",
                   p.vals = expand.grid(X = 0:1, Y2 = 0:1), 
                   prob.form = list(out = "Y2", cond = "X"))
 ## need to specify right.vars because it cannot be inferred from the response functions alone
create_causalmodel(graph = NULL, respvars = respvars, 
                   constraints = "Y2(Y = 1) &gt;= Y2(Y = 0)",
                   p.vals = expand.grid(X = 0:1, Y2 = 0:1), 
                   prob.form = list(out = "Y2", cond = "X"), 
                   right.vars = c("Y", "Y2"))

</code></pre>

<hr>
<h2 id='create_effect_vector'>Translate target effect to vector of response variables</h2><span id='topic+create_effect_vector'></span>

<h3>Description</h3>

<p>Translate target effect to vector of response variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_effect_vector(causal_model, effect)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_effect_vector_+3A_causal_model">causal_model</code></td>
<td>
<p>An object of class &quot;causalmodel&quot; as produced by <a href="#topic+create_causalmodel">create_causalmodel</a></p>
</td></tr>
<tr><td><code id="create_effect_vector_+3A_effect">effect</code></td>
<td>
<p>Effect list, as returned by <a href="#topic+parse_effect">parse_effect</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the target effect in terms of qs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Ul -+ Z, Ur -+ X, Ur -+ Y))
constraints &lt;- "X(Z = 1) &gt;= X(Z = 0)"
effectt = "p{Y(X = 1) = 1} - p{Y(X = 0) = 1}"
p.vals &lt;- expand.grid(Z = 0:1, X = 0:1, Y = 0:1)
prob.form &lt;- list(out = c("X", "Y"), cond = "Z")
effect &lt;- parse_effect(effectt)
ivmod &lt;- create_causalmodel(graph, respvars = NULL, p.vals = p.vals, prob.form = prob.form, 
         constraints = constraints)
var.eff &lt;- create_effect_vector(ivmod, effect)
</code></pre>

<hr>
<h2 id='create_linearcausalproblem'>Create linear causal problem from causal model and effect</h2><span id='topic+create_linearcausalproblem'></span>

<h3>Description</h3>

<p>A more flexible alternative to <a href="#topic+analyze_graph">analyze_graph</a> that takes as inputs the 
causal model and effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_linearcausalproblem(causal_model, effectt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_linearcausalproblem_+3A_causal_model">causal_model</code></td>
<td>
<p>An object of class &quot;causalmodel&quot; as produce by <a href="#topic+create_causalmodel">create_causalmodel</a></p>
</td></tr>
<tr><td><code id="create_linearcausalproblem_+3A_effectt">effectt</code></td>
<td>
<p>A character string that represents the causal effect of interest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The effectt parameter describes your causal effect of interest. The effectt parameter must be of the form
</p>
<p><code>p{V11(X=a)=a; V12(X=a)=b;...} op1 p{V21(X=b)=a; V22(X=c)=b;...} op2 ...</code>
</p>
<p>where Vij are names of variables in the graph, a, b are numeric values from 0:(nvals - 1), and op are either - or +. You can specify a single probability statement (i.e., no operator). Note that the probability statements begin with little p, and use curly braces, and items inside the probability statements are separated by ;. The variables may be potential outcomes which are denoted by parentheses. Variables may also be nested inside potential outcomes. Pure observations such as <code>p{Y = 1}</code> are not allowed if the left side contains any variables. 
There are 2 important rules to follow: 1) Only variables on the right side can be in the probability events, and if the left side is not empty: 2) none of the variables in the left side that are intervened upon can have any children in the left side, and all paths from the left to the right must be blocked by the intervention set. Here the intervention set is anything that is inside the smooth brackets (i.e., variable set to values).
</p>
<p>All of the following are valid effect statements:
</p>
<p><code>p{Y(X = 1) = 1} - p{Y(X = 0) = 1}</code>
</p>
<p><code>p{X(Z = 1) = 1; X(Z = 0) = 0}</code>
</p>
<p><code>p{Y(M(X = 0), X = 1) = 1} - p{Y(M(X = 0), X = 0) = 1}</code>
</p>


<h3>Value</h3>

<p>A an object of class &quot;linearcausalproblem&quot;, which is a list with the
following components. This list can be passed to <a href="#topic+optimize_effect_2">optimize_effect_2</a>
which interfaces with the symbolic optimization program. Print and plot methods are also
available. </p>
 
<dl>
<dt>variables</dt><dd><p>Character vector of variable names
of potential outcomes, these start with 'q' to match Balke's notation</p>
</dd>
<dt>parameters</dt><dd><p>Character vector of parameter names of observed
probabilities, these start with 'p' to match Balke's notation</p>
</dd>
<dt>constraints</dt><dd><p>Character vector of parsed constraints</p>
</dd>
<dt>objective</dt><dd><p>Character string defining the objective to be optimized in
terms of the variables</p>
</dd> 
<dt>p.vals</dt><dd><p>Matrix of all possible values of the
observed data vector, corresponding to the list of parameters.</p>
</dd>
<dt>q.vals</dt><dd><p>Matrix of all possible values of the response function form
of the potential outcomes, corresponding to the list of variables.</p>
</dd>
<dt>parsed.query</dt><dd><p>A nested list containing information on the parsed
causal query.</p>
</dd> 
<dt>objective.nonreduced</dt><dd><p>The objective in terms of the
original variables, before algebraic variable reduction. The nonreduced
variables can be obtained by concatenating the columns of q.vals.</p>
</dd>
<dt>response.functions</dt><dd><p>List of response functions.</p>
</dd> 
<dt>graph</dt><dd><p>The graph as passed to the function.</p>
</dd> 
<dt>R</dt><dd><p>A matrix with coefficients
relating the p.vals to the q.vals p = R * q</p>
</dd> 
<dt>c0</dt><dd><p>A vector of coefficients relating the q.vals to the 
objective function theta = c0 * q</p>
</dd> 
<dt>iqR</dt><dd><p>A matrix with coefficients to represent the inequality
constraints</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>### confounded exposure and outcome
b &lt;- initialize_graph(igraph::graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y))
confmod &lt;- create_causalmodel(graph = b, prob.form =  list(out = c("X", "Y"), cond = NULL))
create_linearcausalproblem(confmod, effectt = "p{Y(X = 1) = 1}")
</code></pre>

<hr>
<h2 id='create_q_matrix'>Translate response functions into matrix of counterfactuals</h2><span id='topic+create_q_matrix'></span>

<h3>Description</h3>

<p>Translate response functions into matrix of counterfactuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_q_matrix(respvars, right.vars, cond.vars, constraints)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_q_matrix_+3A_respvars">respvars</code></td>
<td>
<p>A list of functions as returned by <a href="#topic+create_response_function">create_response_function</a></p>
</td></tr>
<tr><td><code id="create_q_matrix_+3A_right.vars">right.vars</code></td>
<td>
<p>Vertices of graph on the right side</p>
</td></tr>
<tr><td><code id="create_q_matrix_+3A_cond.vars">cond.vars</code></td>
<td>
<p>Vertices of graph on the left side</p>
</td></tr>
<tr><td><code id="create_q_matrix_+3A_constraints">constraints</code></td>
<td>
<p>A vector of character strings that represent the constraints</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 data frames of counterfactuals and their associated labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graphres &lt;- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Ul -+ Z, Ur -+ X, Ur -+ Y))
constraints &lt;- "X(Z = 1) &gt;= X(Z = 0)"
cond.vars &lt;- V(graphres)[V(graphres)$leftside == 1 &amp; names(V(graphres)) != "Ul"]
right.vars &lt;- V(graphres)[V(graphres)$leftside == 0 &amp; names(V(graphres)) != "Ur"] 
respvars &lt;- create_response_function(graphres)
create_q_matrix(respvars, right.vars, cond.vars, constraints)
</code></pre>

<hr>
<h2 id='create_response_function'>Translate regular DAG to response functions</h2><span id='topic+create_response_function'></span>

<h3>Description</h3>

<p>Translate regular DAG to response functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_response_function(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_response_function_+3A_graph">graph</code></td>
<td>
<p>An <a href="igraph.html#topic+aaa-igraph-package">aaa-igraph-package</a> object that represents a
directed acyclic graph that contains certain edge attributes. 
The shiny app returns a graph in this format and <a href="#topic+initialize_graph">initialize_graph</a> 
will add them to a regular igraph object with sensible defaults.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of functions representing the response functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### confounded exposure and outcome
b &lt;- initialize_graph(igraph::graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y))
create_response_function(b)
</code></pre>

<hr>
<h2 id='find_all_paths'>Find all paths in a causal model</h2><span id='topic+find_all_paths'></span>

<h3>Description</h3>

<p>Given a set of response functions, find all directed paths from from to to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_all_paths(respvars, from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_all_paths_+3A_respvars">respvars</code></td>
<td>
<p>A set of response functions as created by <a href="#topic+create_response_function">create_response_function</a></p>
</td></tr>
<tr><td><code id="find_all_paths_+3A_from">from</code></td>
<td>
<p>A character string indicating the start of the path</p>
</td></tr>
<tr><td><code id="find_all_paths_+3A_to">to</code></td>
<td>
<p>A character string indicating the end of the path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with all the paths or a list with NULL if there are none
</p>


<h3>Examples</h3>

<pre><code class='language-R'> b &lt;- initialize_graph(igraph::graph_from_literal(X -+ Z, Z -+ Y, X -+ Y, Ur -+ Z, Ur -+ Y))
 medmod &lt;- create_response_function(b)
 find_all_paths(medmod, "X", "Y")
 igraph::all_simple_paths(b, "X", "Y", mode = "out")

</code></pre>

<hr>
<h2 id='get_default_effect'>Define default effect for a given graph</h2><span id='topic+get_default_effect'></span>

<h3>Description</h3>

<p>Define default effect for a given graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_default_effect(graphres)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_default_effect_+3A_graphres">graphres</code></td>
<td>
<p>The graph object, should have vertex attributes &quot;outcome&quot; and &quot;exposure&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string that can be passed to <a href="#topic+parse_effect">parse_effect</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graphres &lt;- graph_from_literal(Z -+ X, X -+ Y, Ul -+ Z, Ur -+ X, Ur -+ Y)
V(graphres)$leftside &lt;- c(1, 0, 0, 1, 0)
V(graphres)$latent &lt;- c(0, 0, 0, 1, 1)
V(graphres)$nvals &lt;- c(3, 2, 2, 2, 2)
V(graphres)$exposure &lt;- c(0, 1, 0, 0, 0)
V(graphres)$outcome &lt;- c(0, 0, 1, 0, 0)
E(graphres)$rlconnect &lt;- c(0, 0, 0, 0, 0)
E(graphres)$edge.monotone &lt;- c(0, 0, 0, 0, 0)
get_default_effect(graphres = graphres) == "p{Y(X = 1)=1} - p{Y(X = 0)=1}" # TRUE
</code></pre>

<hr>
<h2 id='graphrescheck'>Check conditions on digraph</h2><span id='topic+graphrescheck'></span>

<h3>Description</h3>

<p>Check that a given digraph satisfies the conditions of 
'no left to right edges', 'no cycles', 'valid number of categories' and 'valid variable names'.
Optionally returns the digraph if all checks are passed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphrescheck(graphres, ret = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphrescheck_+3A_graphres">graphres</code></td>
<td>
<p>An <code>igraph</code> object representing a digraph.</p>
</td></tr>
<tr><td><code id="graphrescheck_+3A_ret">ret</code></td>
<td>
<p>A logical value. Default is <code>FALSE</code>.
Set to <code>TRUE</code> to also return <code>graphres</code> if all checks are passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>ret=FALSE</code> (default): <code>TRUE</code> if all checks pass; else <code>FALSE</code>.
If <code>ret=TRUE</code>: <code>graphres</code> if all checks pass; else <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graphres &lt;- graph_from_literal(X -+ Y, X -+ M, M -+ Y, Ul -+ X, Ur -+ M, Ur -+ Y)
V(graphres)$leftside &lt;- c(1, 0, 0, 1, 0)
V(graphres)$latent &lt;- c(0, 0, 0, 1, 1)
V(graphres)$nvals &lt;- c(2, 2, 2, 2, 2)
V(graphres)$exposure &lt;- c(0, 0, 0, 0, 0)
V(graphres)$outcome &lt;- c(0, 0, 0, 0, 0)
E(graphres)$rlconnect &lt;- c(0, 0, 0, 0, 0, 0)
E(graphres)$edge.monotone &lt;- c(0, 0, 0, 0, 0, 0)
graphrescheck(graphres = graphres) # TRUE
</code></pre>

<hr>
<h2 id='initialize_graph'>Initialize an igraph object for use with causaloptim</h2><span id='topic+initialize_graph'></span>

<h3>Description</h3>

<p>Checks for required attributes and adds defaults if missing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize_graph(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initialize_graph_+3A_graph">graph</code></td>
<td>
<p>An object of class igraph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph with the vertex attributes leftside, latent, and nvals, and edge attributes rlconnect and edge.monotone
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- igraph::graph_from_literal(X -+ Y)
b2 &lt;- initialize_graph(b)
V(b2)$nvals

</code></pre>

<hr>
<h2 id='interpret_bounds'>Convert bounds string to a function</h2><span id='topic+interpret_bounds'></span>

<h3>Description</h3>

<p>Convert bounds string to a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpret_bounds(bounds, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpret_bounds_+3A_bounds">bounds</code></td>
<td>
<p>The bounds element as returned by <a href="#topic+optimize_effect">optimize_effect</a></p>
</td></tr>
<tr><td><code id="interpret_bounds_+3A_parameters">parameters</code></td>
<td>
<p>Character vector defining parameters, as returned by <a href="#topic+analyze_graph">analyze_graph</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes arguments for the parameters, i.e., the observed probabilities and returns a vector of length 2: the lower bound and the upper bound.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y)
V(b)$leftside &lt;- c(0,0,0)
V(b)$latent &lt;- c(0,0,1)
V(b)$nvals &lt;- c(2,2,2)
E(b)$rlconnect &lt;- E(b)$edge.monotone &lt;- c(0, 0, 0)
obj &lt;- analyze_graph(b, constraints = NULL, effectt = "p{Y(X = 1) = 1} - p{Y(X = 0) = 1}")
bounds &lt;- optimize_effect_2(obj)
bounds_func &lt;- interpret_bounds(bounds$bounds, obj$parameters)
bounds_func(.1, .1, .4, .3)
# vectorized
do.call(bounds_func, lapply(1:4, function(i) runif(5)))
</code></pre>

<hr>
<h2 id='latex_bounds'>Latex bounds equations</h2><span id='topic+latex_bounds'></span>

<h3>Description</h3>

<p>Latex bounds equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latex_bounds(bounds, parameters, prob.sym = "P", brackets = c("(", ")"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latex_bounds_+3A_bounds">bounds</code></td>
<td>
<p>Vector of bounds as returned by <a href="#topic+optimize_effect_2">optimize_effect_2</a></p>
</td></tr>
<tr><td><code id="latex_bounds_+3A_parameters">parameters</code></td>
<td>
<p>The parameters object as returned by <a href="#topic+analyze_graph">analyze_graph</a></p>
</td></tr>
<tr><td><code id="latex_bounds_+3A_prob.sym">prob.sym</code></td>
<td>
<p>Symbol to use for probability statements in latex, usually &quot;P&quot; or &quot;pr&quot;</p>
</td></tr>
<tr><td><code id="latex_bounds_+3A_brackets">brackets</code></td>
<td>
<p>Length 2 vector with opening and closing bracket, usually <code>c("(", ")")</code>, or <code>c(" \{", "\}")</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with latex code for the bounds
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y)
V(b)$leftside &lt;- c(0,0,0)
V(b)$latent &lt;- c(0,0,1)
V(b)$nvals &lt;- c(2,2,2)
E(b)$rlconnect &lt;- E(b)$edge.monotone &lt;- c(0, 0, 0)
obj &lt;- analyze_graph(b, constraints = NULL, effectt = "p{Y(X = 1) = 1} - p{Y(X = 0) = 1}")
bounds &lt;- optimize_effect_2(obj)
latex_bounds(bounds$bounds, obj$parameters)
latex_bounds(bounds$bounds, obj$parameters, "Pr")
</code></pre>

<hr>
<h2 id='list_to_path'>Recursive function to translate an effect list to a path sequence</h2><span id='topic+list_to_path'></span>

<h3>Description</h3>

<p>Recursive function to translate an effect list to a path sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_to_path(x, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_to_path_+3A_x">x</code></td>
<td>
<p>A list of vars as returned by <a href="#topic+parse_effect">parse_effect</a></p>
</td></tr>
<tr><td><code id="list_to_path_+3A_name">name</code></td>
<td>
<p>The name of the outcome variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of characters describing the path sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nofill &lt;- "p{Y(X = 1, M1 = 1, M2(X = 1, M1 = 1)) = 1}"
eff2 &lt;- parse_effect(nofill)$vars[[1]][[1]]
list_to_path(eff2, "Y")

</code></pre>

<hr>
<h2 id='opt_effect'>Compute a bound on the average causal effect</h2><span id='topic+opt_effect'></span>

<h3>Description</h3>

<p>This helper function does the heavy lifting for <code><a href="#topic+optimize_effect_2">optimize_effect_2</a></code>.
For a given casual query, it computes either a lower or an upper bound on the corresponding causal effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_effect(opt, obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt_effect_+3A_opt">opt</code></td>
<td>
<p>A string. Either <code>"min"</code> or <code>"max"</code> for a lower or an upper bound, respectively.</p>
</td></tr>
<tr><td><code id="opt_effect_+3A_obj">obj</code></td>
<td>
<p>An object as returned by the function <code><a href="#topic+analyze_graph">analyze_graph</a></code>. Contains the casual query to be estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>optbound</code>; a list with the following named components: 
</p>

<ul>
<li> <p><code>expr</code> is the <em>main</em> output; an expression of the bound as a print-friendly string,
</p>
</li>
<li> <p><code>type</code> is either <code>"lower"</code> or <code>"upper"</code> according to the type of the bound,
</p>
</li>
<li> <p><code>dual_vertices</code> is a numeric matrix whose rows are the vertices of the convex polytope of the dual LP,
</p>
</li>
<li> <p><code>dual_vrep</code> is a V-representation of the dual convex polytope, including some extra data.
</p>
</li></ul>


<hr>
<h2 id='optimize_effect_2'>Run the optimizer to obtain symbolic bounds</h2><span id='topic+optimize_effect_2'></span><span id='topic+optimize_effect'></span>

<h3>Description</h3>

<p>Given an object with the linear programming problem set up, compute the bounds
using rcdd. Bounds are returned as text but can
be converted to R functions using <a href="#topic+interpret_bounds">interpret_bounds</a>, or latex code using
<a href="#topic+latex_bounds">latex_bounds</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_effect_2(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize_effect_2_+3A_obj">obj</code></td>
<td>
<p>Object as returned by <a href="#topic+analyze_graph">analyze_graph</a> or <a href="#topic+create_linearcausalproblem">create_linearcausalproblem</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;balkebound&quot; that is a list that contains the bounds and logs as character strings, and a function to compute the bounds
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- initialize_graph(graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y))
obj &lt;- analyze_graph(b, constraints = NULL, effectt = "p{Y(X = 1) = 1} - p{Y(X = 0) = 1}")
optimize_effect_2(obj)
</code></pre>

<hr>
<h2 id='parse_constraints'>Parse text that defines a the constraints</h2><span id='topic+parse_constraints'></span>

<h3>Description</h3>

<p>Parse text that defines a the constraints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_constraints(constraints, obsnames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_constraints_+3A_constraints">constraints</code></td>
<td>
<p>A list of character strings</p>
</td></tr>
<tr><td><code id="parse_constraints_+3A_obsnames">obsnames</code></td>
<td>
<p>Vector of names of the observed variables in the graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns indicating the variables being constrained, what the values of their parents are for the constraints, and the operator defining the constraint (equality or inequalities).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>constrainttext &lt;- "X(Z = 1) &gt;= X(Z = 0)"
obsnames &lt;- c("Z", "X", "Y")
parse_constraints(constraints = constrainttext, obsnames = obsnames)
</code></pre>

<hr>
<h2 id='parse_effect'>Parse text that defines a causal effect</h2><span id='topic+parse_effect'></span>

<h3>Description</h3>

<p>Parse text that defines a causal effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_effect(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_effect_+3A_text">text</code></td>
<td>
<p>Character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list that contains the following components:
</p>

<dl>
<dt>vars</dt><dd><p>For each element of the causal query, this 
indicates potential outcomes as names of the list elements, 
the variables that they depend on, and the values that any variables are being fixed to.</p>
</dd>
<dt>oper</dt><dd><p>The vector of operators (addition or subtraction) that combine the terms of the causal query.</p>
</dd>
<dt>values</dt><dd><p>The values that the potential outcomes are set to in the query.</p>
</dd>
<dt>pcheck</dt><dd><p>List of logicals for each element of the query that are TRUE if the element 
is a potential outcome and FALSE if it is an observational quantity.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>effectt &lt;- "p{Y(X = 1) = 1} - p{Y(X = 0) = 1}"
parse_effect(text = effectt)
</code></pre>

<hr>
<h2 id='plot_graphres'>Plot the analyzed graph object</h2><span id='topic+plot_graphres'></span>

<h3>Description</h3>

<p>Special plotting method for igraphs of this type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_graphres(graphres)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_graphres_+3A_graphres">graphres</code></td>
<td>
<p>an igraph object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.linearcausalproblem">plot.linearcausalproblem</a> which plots a graph with attributes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y)
V(b)$leftside &lt;- c(0,0,0)
V(b)$latent &lt;- c(0,0,1)
V(b)$nvals &lt;- c(2,2,2)
V(b)$exposure &lt;- c(1,0,0)
V(b)$outcome &lt;- c(0,1,0)
E(b)$rlconnect &lt;- c(0,0,0)
E(b)$edge.monotone &lt;- c(0,0,0)
plot(b)
</code></pre>

<hr>
<h2 id='plot.linearcausalproblem'>Plot the graph from the causal problem with a legend describing attributes</h2><span id='topic+plot.linearcausalproblem'></span>

<h3>Description</h3>

<p>Plot the graph from the causal problem with a legend describing attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linearcausalproblem'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.linearcausalproblem_+3A_x">x</code></td>
<td>
<p>object of class &quot;linearcausalproblem&quot;</p>
</td></tr>
<tr><td><code id="plot.linearcausalproblem_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>See Also</h3>

<p><a href="#topic+plot_graphres">plot_graphres</a> which plots the graph only
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y)
V(b)$leftside &lt;- c(0,0,0)
V(b)$latent &lt;- c(0,0,1)
V(b)$nvals &lt;- c(2,2,2)
V(b)$exposure &lt;- c(1,0,0)
V(b)$outcome &lt;- c(0,1,0)
E(b)$rlconnect &lt;- c(0,0,0)
E(b)$edge.monotone &lt;- c(0,0,0)
q &lt;- "p{Y(X=1)=1}-p{Y(X=0)=1}"
obj &lt;- analyze_graph(graph = b, constraints = NULL, effectt &lt;- q)
plot(obj)
</code></pre>

<hr>
<h2 id='print.causalmodel'>Print relevant information about the causal model</h2><span id='topic+print.causalmodel'></span>

<h3>Description</h3>

<p>Print relevant information about the causal model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'causalmodel'
print(x, omit_cf_constraints = FALSE, omit_obs_constraints = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.causalmodel_+3A_x">x</code></td>
<td>
<p>object of class &quot;causalmodel&quot;</p>
</td></tr>
<tr><td><code id="print.causalmodel_+3A_omit_cf_constraints">omit_cf_constraints</code></td>
<td>
<p>Do not print the counterfactual constraints</p>
</td></tr>
<tr><td><code id="print.causalmodel_+3A_omit_obs_constraints">omit_obs_constraints</code></td>
<td>
<p>Do not print the observable constraints</p>
</td></tr>
<tr><td><code id="print.causalmodel_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x, invisibly
</p>

<hr>
<h2 id='print.linearcausalproblem'>Print the causal problem</h2><span id='topic+print.linearcausalproblem'></span>

<h3>Description</h3>

<p>Print the causal problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linearcausalproblem'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.linearcausalproblem_+3A_x">x</code></td>
<td>
<p>object of class &quot;linearcausaloptim&quot;</p>
</td></tr>
<tr><td><code id="print.linearcausalproblem_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x, invisibly
</p>

<hr>
<h2 id='querycheck'>Check conditions on query</h2><span id='topic+querycheck'></span>

<h3>Description</h3>

<p>Given an admissible causal DAG, check that given a causal query satisfies 
conditions that guarantee the corresponding causal problem to be a linear program.
Throws error messages detailing any conditions violated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>querycheck(effecttext, graphres)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="querycheck_+3A_effecttext">effecttext</code></td>
<td>
<p>A string representing a causal query.</p>
</td></tr>
<tr><td><code id="querycheck_+3A_graphres">graphres</code></td>
<td>
<p>An <code>igraph</code> object representing a digraph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>effecttext</code> is parsable, contains only variables in <code>V(graphres)</code> 
and satisfies conditions for linearity; else <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graphres &lt;- graph_from_literal(X -+ Y, X -+ M, M -+ Y, Ul -+ X, Ur -+ M, Ur -+ Y)
V(graphres)$leftside &lt;- c(1, 0, 0, 1, 0)
V(graphres)$latent &lt;- c(0, 0, 0, 1, 1)
V(graphres)$nvals &lt;- c(2, 2, 2, 2, 2)
V(graphres)$exposure &lt;- c(0, 0, 0, 0, 0)
V(graphres)$outcome &lt;- c(0, 0, 0, 0, 0)
E(graphres)$rlconnect &lt;- c(0, 0, 0, 0, 0, 0)
E(graphres)$edge.monotone &lt;- c(0, 0, 0, 0, 0, 0)
effecttext &lt;- "p{Y(M(X = 0), X = 1) = 1} - p{Y(M(X = 0), X = 0) = 1}"
querycheck(effecttext = effecttext, graphres = graphres) # TRUE
</code></pre>

<hr>
<h2 id='rdirichlet'>Sample from a Dirichlet distribution</h2><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Generate a random vector from the k-dimensional symmetric Dirichlet distribution with concentration parameter alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdirichlet(k, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdirichlet_+3A_k">k</code></td>
<td>
<p>Length of the vector</p>
</td></tr>
<tr><td><code id="rdirichlet_+3A_alpha">alpha</code></td>
<td>
<p>Concentration parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qvals &lt;- rdirichlet(16, 1)
sum(qvals)
</code></pre>

<hr>
<h2 id='sample_distribution'>Sample a distribution of observable probabilities that satisfy the causal model</h2><span id='topic+sample_distribution'></span>

<h3>Description</h3>

<p>Sample a distribution of observable probabilities that satisfy the causal model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_distribution(
  obj,
  simplex_sampler = function(k) {
     rdirichlet(k, alpha = 1)
 }
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_distribution_+3A_obj">obj</code></td>
<td>
<p>An object of class &quot;causalmodel&quot;</p>
</td></tr>
<tr><td><code id="sample_distribution_+3A_simplex_sampler">simplex_sampler</code></td>
<td>
<p>A function to generate a random sample from the simplex in k dimensions, where k is the number of variables (q parameters, obj$data$variables). By default this is uniform (symmetric dirichlet with parameter 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of observable probabilities that satisfy the causal model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
graph &lt;- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Ur -+ X, Ur -+ Y))
prob.form &lt;- list(out = c("X", "Y"), cond = "Z")

iv_model &lt;- create_causalmodel(graph, prob.form = prob.form)
sample_distribution(iv_model)

</code></pre>

<hr>
<h2 id='simulate_bounds'>Simulate bounds</h2><span id='topic+simulate_bounds'></span>

<h3>Description</h3>

<p>Run a simple simulation based on the bounds. For each simulation, sample the set of counterfactual probabilities 
from a uniform distribution, translate into a multinomial distribution, and then compute the objective and the 
bounds in terms of the observable variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_bounds(obj, bounds, nsim = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_bounds_+3A_obj">obj</code></td>
<td>
<p>Object as returned by <a href="#topic+analyze_graph">analyze_graph</a></p>
</td></tr>
<tr><td><code id="simulate_bounds_+3A_bounds">bounds</code></td>
<td>
<p>Object as returned by <a href="#topic+optimize_effect_2">optimize_effect_2</a></p>
</td></tr>
<tr><td><code id="simulate_bounds_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulation replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns: objective, bound.lower, bound.upper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- initialize_graph(graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y))
obj &lt;- analyze_graph(b, constraints = NULL, effectt = "p{Y(X = 1) = 1} - p{Y(X = 0) = 1}")
bounds &lt;- optimize_effect_2(obj)
simulate_bounds(obj, bounds, nsim = 5)
</code></pre>

<hr>
<h2 id='specify_graph'>Shiny interface to specify network structure and compute bounds</h2><span id='topic+specify_graph'></span>

<h3>Description</h3>

<p>This launches the Shiny interface in the system's default web browser. The 
results of the computation will be displayed in the browser, but they can 
also be returned to the R session by assigning the result of the function call
to an object. See below for information on what is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specify_graph()
</code></pre>


<h3>Value</h3>

<p>If the button &quot;Exit and return graph object&quot; is clicked, then only the 
graph is returned as an <a href="igraph.html#topic+aaa-igraph-package">aaa-igraph-package</a> object. 
</p>
<p>If the bounds are computed and the button &quot;Exit and return objects to R&quot; is clicked, 
then a list is returned with the following elements: 
</p>

<dl>
<dt>graphres</dt><dd><p>The graph as drawn and interpreted, an <a href="igraph.html#topic+aaa-igraph-package">aaa-igraph-package</a> object.</p>
</dd>
<dt>obj</dt><dd><p>The objective and all necessary supporting information. This object is 
documented in <a href="#topic+analyze_graph">analyze_graph</a>. This can be passed directly to <a href="#topic+optimize_effect_2">optimize_effect_2</a>.</p>
</dd>
<dt>bounds.obs</dt><dd><p>Object of class 'balkebound' as returned by <a href="#topic+optimize_effect_2">optimize_effect_2</a>.</p>
</dd>
<dt>constraints</dt><dd><p>Character vector of the specified constraints. NULL if no constraints.</p>
</dd>
<dt>effect</dt><dd><p>Text describing the causal effect of interest.</p>
</dd>
<dt>boundsFunction</dt><dd><p>Function that takes parameters (observed probabilities) as arguments, and returns a vector of length 2 for the lower and upper bounds.</p>
</dd>
</dl>


<hr>
<h2 id='update_effect'>Update the effect in a linearcausalproblem object</h2><span id='topic+update_effect'></span>

<h3>Description</h3>

<p>If you want to use the same graph and response function, but change the 
effect of interest, this can save some computation time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_effect(obj, effectt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_effect_+3A_obj">obj</code></td>
<td>
<p>An object as returned by <a href="#topic+analyze_graph">analyze_graph</a></p>
</td></tr>
<tr><td><code id="update_effect_+3A_effectt">effectt</code></td>
<td>
<p>A character string that represents the causal effect of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A object of class linearcausalproblem, see <a href="#topic+analyze_graph">analyze_graph</a> for details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- igraph::graph_from_literal(X -+ Y, X -+ M, M -+ Y, Ul -+ X, Ur -+ Y, Ur -+ M)
V(b)$leftside &lt;- c(1, 0, 0, 1, 0)
V(b)$latent &lt;- c(0, 0, 0, 1, 1)
V(b)$nvals &lt;- c(2, 2, 2, 2, 2)
E(b)$rlconnect &lt;- c(0, 0, 0, 0, 0, 0)
E(b)$edge.monotone &lt;- c(0, 0, 0, 0, 0, 0)
CDE0_query &lt;- "p{Y(M = 0, X = 1) = 1} - p{Y(M = 0, X = 0) = 1}"
CDE0_obj &lt;- analyze_graph(b, constraints = NULL, effectt = CDE0_query)
CDE0_bounds &lt;- optimize_effect_2(CDE0_obj)
CDE0_boundsfunction &lt;- interpret_bounds(bounds = CDE0_bounds$bounds, 
parameters = CDE0_obj$parameters)
CDE1_query &lt;- "p{Y(M = 1, X = 1) = 1} - p{Y(M = 1, X = 0) = 1}"
CDE1_obj &lt;- update_effect(CDE0_obj, effectt = CDE1_query)
CDE1_bounds &lt;- optimize_effect_2(CDE1_obj)
CDE1_boundsfunction &lt;- interpret_bounds(bounds = CDE1_bounds$bounds, 
parameters = CDE1_obj$parameters)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
