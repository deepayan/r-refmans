<!DOCTYPE html><html><head><title>Help for package WRTDStidal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WRTDStidal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aiccrq'><p>Akaike's Information Criterion for weighted quantile regression</p></a></li>
<li><a href='#all_sims'><p>Simulate a response variable time series using all functions</p></a></li>
<li><a href='#annual_agg'><p>Create annual aggregations of WRTDS output</p></a></li>
<li><a href='#chldat'><p>Monthly chlorophyll time series for Hillsborough Bay</p></a></li>
<li><a href='#chllab'><p>Chlorophyll axis label</p></a></li>
<li><a href='#chngest'><p>Get trend for a single time period</p></a></li>
<li><a href='#createsrch'><p>Create a grid of half-window widths to evaluate</p></a></li>
<li><a href='#daydat'><p>Daily chlorophyll, salinity, and discharge time series for the Upper Patuxent River Estuary</p></a></li>
<li><a href='#dec_time'><p>Create decimal time from time vector</p></a></li>
<li><a href='#dynaplot'><p>Plot model response to salinity or flow as a lineplot for all months</p></a></li>
<li><a href='#fill_grd'><p>Add date columns and fill missing values in the interpolation grids</p></a></li>
<li><a href='#fillpo'><p>Fill the <code>predonobs</code> attribute</p></a></li>
<li><a href='#fitmoplot'><p>Plot the fitted results for a tidal object by month</p></a></li>
<li><a href='#fitplot'><p>Plot the fitted results for a tidal object</p></a></li>
<li><a href='#getwts'><p>Get weights for regression</p></a></li>
<li><a href='#goodfit'><p>Quantile regression goodness of fit</p></a></li>
<li><a href='#gradcols'><p>Get colors for plots</p></a></li>
<li><a href='#gridplot'><p>Plot variable response to salinity/flow as a gridded surface for all months</p></a></li>
<li><a href='#kendallSeasonalTrendTest'><p>Kendall seasonal trend test</p></a></li>
<li><a href='#kendallTrendTest'><p>Kendall trend test</p></a></li>
<li><a href='#lnQ_sim'><p>Simulate a discharge time series</p></a></li>
<li><a href='#lnres_err'><p>Simulate random errors from a time series</p></a></li>
<li><a href='#lnres_sim'><p>Simulate a water quality time series</p></a></li>
<li><a href='#modfit'><p>Fit weighted regression and get predicted/normalized response variable</p></a></li>
<li><a href='#nobsplot'><p>Plot number of observations in a WRTDS interpolation grid</p></a></li>
<li><a href='#obsplot'><p>Plot observed response variable and salinity/flow data</p></a></li>
<li><a href='#prdnrmplot'><p>Plot combined predicted and normalized results from a tidal object</p></a></li>
<li><a href='#resnorm'><p>Get salinity/flow normalized WRTDS predictions from interpolation grids</p></a></li>
<li><a href='#respred'><p>Get WRTDS predictions from interpolation grids</p></a></li>
<li><a href='#resscls'><p>Get the scale parameters for predicted values</p></a></li>
<li><a href='#samp_sim'><p>Sample a daily time series at a set frequency</p></a></li>
<li><a href='#seasplot'><p>Plot seasonal trends across all years</p></a></li>
<li><a href='#seasyrplot'><p>Plot seasonal model response by years</p></a></li>
<li><a href='#sliceplot'><p>Plot time slices within a tidal object</p></a></li>
<li><a href='#tidal'><p>Create a tidal class object</p></a></li>
<li><a href='#tidalmean'><p>Create a tidalmean class object</p></a></li>
<li><a href='#tidfit'><p>Monthly chlorophyll time series for Hillsborough Bay as a tidal object</p></a></li>
<li><a href='#tidfitmean'><p>Monthly chlorophyll time series for Hillsborough Bay as a tidal object for the conditional mean model</p></a></li>
<li><a href='#tidobj'><p>Monthly chlorophyll time series for Hillsborough Bay as a tidal object</p></a></li>
<li><a href='#tidobjmean'><p>Monthly chlorophyll time series for Hillsborough Bay as a tidal object, conditional mean model</p></a></li>
<li><a href='#winsrch_constrOptim'><p>Find the optimal half-window width combination</p></a></li>
<li><a href='#winsrch_grid'><p>Evaluate half-window width combinations</p></a></li>
<li><a href='#winsrch_optim'><p>Find the optimal half-window width combination</p></a></li>
<li><a href='#wrtds'><p>Get WRTDS prediction grid</p></a></li>
<li><a href='#wrtdscv'><p>Use k-fold cross-validation to evaluate WRTDS model fit</p></a></li>
<li><a href='#wrtdsperf'><p>Get WRTDS performance metrics</p></a></li>
<li><a href='#wrtdsrsd'><p>Get WRTDS residuals</p></a></li>
<li><a href='#wrtdstrnd'><p>Get WRTDS trends</p></a></li>
<li><a href='#wrtdstrnd_sk'><p>Get WRTDS trends using seasonal Kendall tests</p></a></li>
<li><a href='#wtsplot'><p>Plot the weights for an observation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Weighted Regression for Water Quality Evaluation in Tidal Waters</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcus W. Beck [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcus W. Beck &lt;mbeck@tbep.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An adaptation for estuaries (tidal waters) of weighted regression
    on time, discharge, and season to evaluate trends in water quality time series. 
    Please see Beck and Hagy (2015) &lt;<a href="https://doi.org/10.1007%2Fs10666-015-9452-8">doi:10.1007/s10666-015-9452-8</a>&gt; for 
    details.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fawda123/WRTDStidal/issues">https://github.com/fawda123/WRTDStidal/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, dplyr, fields, foreach, forecast, gridExtra, lubridate,
purrr, quantreg, RColorBrewer, survival, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel, EGRET, grDevices, magrittr, plotly, knitr,
rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ggplot2</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-19 23:12:34 UTC; mbeck</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-20 09:00:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='aiccrq'>Akaike's Information Criterion for weighted quantile regression</h2><span id='topic+aiccrq'></span>

<h3>Description</h3>

<p>Get AIC values for a single weighted quantile regression as used in WRTDS models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aiccrq(mod_in, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aiccrq_+3A_mod_in">mod_in</code></td>
<td>
<p>input crq model</p>
</td></tr>
<tr><td><code id="aiccrq_+3A_tau">tau</code></td>
<td>
<p>numeric indicating quantile to evaluate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AIC value is based on the log-likelihood estimate of the model that accounts for the specific quantile, the minimum of the objective function (rho), and the number of model parameters.  The residuals are specific to the WRTDS model such that this function cannot be applied to arbitrary crq models.
</p>


<h3>Value</h3>

<p>AIC estimate
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get wts for a model centered on the first observation
ref_in &lt;- tidobj[1, ]
ref_wts &lt;- getwts(tidobj, ref_in)

# get the model
mod &lt;- quantreg::crq(
   survival::Surv(res, not_cens, type = "left") ~ 
     dec_time + flo + sin(2*pi*dec_time) + cos(2*pi*dec_time), 
   weights = ref_wts,
   data = tidobj, 
   method = "Portnoy"
   )

aiccrq(mod)
</code></pre>

<hr>
<h2 id='all_sims'>Simulate a response variable time series using all functions</h2><span id='topic+all_sims'></span>

<h3>Description</h3>

<p>Simulate a response variable time series using all simulation functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_sims(dat_in, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_sims_+3A_dat_in">dat_in</code></td>
<td>
<p>input <code><a href="base.html#topic+data.frame">data.frame</a></code> that must include discharge and decimal time columns, see example dataset <code><a href="#topic+daydat">daydat</a></code></p>
</td></tr>
<tr><td><code id="all_sims_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+lnres_sim">lnres_sim</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function that combines <code><a href="#topic+lnQ_sim">lnQ_sim</a></code>, <code><a href="#topic+lnres_err">lnres_err</a></code>, and <code><a href="#topic+lnres_sim">lnres_sim</a></code>.  See the help documentation function for more details on each.
</p>


<h3>Value</h3>

<p>Original data frame with additional columns for simulated discharge (<code>lnQ_sim</code>), the random errors of the response variable (<code>errs</code>), the standard error estimates for each residual (<code>scls</code>), a flow-independent response variable time series (<code>lnres_noQ</code>), and a flow-dependent time series (<code>lnres_Q</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+daydat">daydat</a></code> for example data, <code><a href="#topic+lnQ_sim">lnQ_sim</a></code> for simulating discharge, <code><a href="#topic+lnres_err">lnres_err</a></code> for estimating the error structure of the response variable, and <code><a href="#topic+lnres_sim">lnres_sim</a></code> for simulating the response variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## example data
data(daydat)

## simulate
tmp &lt;- all_sims(daydat)

## End(Not run)
</code></pre>

<hr>
<h2 id='annual_agg'>Create annual aggregations of WRTDS output</h2><span id='topic+annual_agg'></span><span id='topic+annual_agg.default'></span>

<h3>Description</h3>

<p>Create annual aggregations of WRTDS output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annual_agg(dat_in, ...)

## Default S3 method:
annual_agg(dat_in, mo_strt = 10, min_mo = 9, logspace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annual_agg_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="annual_agg_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="annual_agg_+3A_mo_strt">mo_strt</code></td>
<td>
<p>numeric indicating month to start aggregation years, defaults to October for USGS water year from October to September</p>
</td></tr>
<tr><td><code id="annual_agg_+3A_min_mo">min_mo</code></td>
<td>
<p>numeric value from one to twelve indicating the minimum number of months with observations for averaging by years</p>
</td></tr>
<tr><td><code id="annual_agg_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating if aggregated data are to be shown in log-space or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WRTDS output is averaged by year for both predictions and flow-normalized predictions. Years are averaged only if one observation is contained in each of the minimum number of months specified by <code>min_mo</code> averaging, otherwise results are not returned for the given year.  Note that setting <code>min_mo</code> to values smaller than the default can produce inaccurate trends for years with very few results. 
</p>
<p>The function is used internally within <code><a href="#topic+prdnrmplot">prdnrmplot</a></code> and <code><a href="#topic+fitplot">fitplot</a></code>.
</p>


<h3>Value</h3>

<p>An aggregated data object for plotting, returns only model output and response variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## tidal object
annual_agg(tidfit)

## tidalmean object
annual_agg(tidfitmean)
</code></pre>

<hr>
<h2 id='chldat'>Monthly chlorophyll time series for Hillsborough Bay</h2><span id='topic+chldat'></span>

<h3>Description</h3>

<p>Monthly chlorophyll time series for the Hillsborough Bay segment of Tampa Bay.  Data are the median values of monthly observations across all water quality stations in Hillsborough Bay.  Date ranges are from January 1974 to December 2012 (452 observations).  Variables are date, chlorophyll-a (in log-space, labelled <code>res</code> for response), salinity as fraction of freshwater (i.e., 0 - 1, with higher values indicating more freshwater, label <code>flo</code> for flow), and the detection limit for all stations for the respective date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chldat
</code></pre>


<h3>Format</h3>

<p>A data frame with 452 rows and 4 variables:
</p>

<dl>
<dt><code>date</code></dt><dd><p>Date</p>
</dd>
<dt><code>res</code></dt><dd><p>numeric</p>
</dd>
<dt><code>flo</code></dt><dd><p>numeric</p>
</dd>
<dt><code>lim</code></dt><dd><p>numeric</p>
</dd>
</dl>


<hr>
<h2 id='chllab'>Chlorophyll axis label</h2><span id='topic+chllab'></span>

<h3>Description</h3>

<p>Get the chlorophyll axis label for observed or log-space, including units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chllab(logspace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chllab_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating if chlorophyll is in log space, otherwise observed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An expression indicating (log)-chlorophyll in the appropriate units
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## default
chllab()
</code></pre>

<hr>
<h2 id='chngest'>Get trend for a single time period</h2><span id='topic+chngest'></span>

<h3>Description</h3>

<p>Get trend for a single time period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chngest(x, y, single = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chngest_+3A_x">x</code></td>
<td>
<p>numeric of year values</p>
</td></tr>
<tr><td><code id="chngest_+3A_y">y</code></td>
<td>
<p>norm numeric of annually averaged response variable</p>
</td></tr>
<tr><td><code id="chngest_+3A_single">single</code></td>
<td>
<p>logical if trends are based on only first and last year of aggregated, i.e., no averaging of first/last three</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates trends using methods described in <code><a href="#topic+wrtdstrnd">wrtdstrnd</a></code>.  Used internally and is not to be called by the user. Function runs on individual time period groups defined by arguments in <code><a href="#topic+wrtdstrnd">wrtdstrnd</a></code>.
</p>

<hr>
<h2 id='createsrch'>Create a grid of half-window widths to evaluate</h2><span id='topic+createsrch'></span>

<h3>Description</h3>

<p>Create a grid of all unique combinations of half-window widths to evaluate.  The result can be passed to <code><a href="#topic+winsrch_grid">winsrch_grid</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createsrch(
  mos = c(seq(0.5, 1, by = 0.25), 2, 10),
  yrs = c(seq(5, 15, by = 3), 50),
  flo = c(seq(0.5, 1, by = 0.1), 5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createsrch_+3A_mos">mos</code></td>
<td>
<p>numeric vector of half-window widths for months, a value of one indicates twelve months</p>
</td></tr>
<tr><td><code id="createsrch_+3A_yrs">yrs</code></td>
<td>
<p>numeric vector of half-window widths for years, a value of one indicates one-year</p>
</td></tr>
<tr><td><code id="createsrch_+3A_flo">flo</code></td>
<td>
<p>numeric vector of half-window widths for salinity or flow, a value of one indicates the full range of values (100 percent)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weighting function uses a tri-cube weighting scheme such that weights diminish with distance from the center of the window.  For example, a value of one for the month window does not mean that all months are weighted equally even though the window covers an entire calendar year.
</p>


<h3>Value</h3>

<p>A matrix with number of rows equal to the product of the lengths of each input vector, where each row is a unique combination for the selected half-window widths.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+winsrch_grid">winsrch_grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>createsrch()
createsrch(1, 1, 1)
</code></pre>

<hr>
<h2 id='daydat'>Daily chlorophyll, salinity, and discharge time series for the Upper Patuxent River Estuary</h2><span id='topic+daydat'></span>

<h3>Description</h3>

<p>Combined daily flow observations from the USGS stream gage station 01594440 near Bowie, Maryland and daily chlorophyll and salinity records from the Jug Bay station of the Chesapeake Bay Maryland National Estuarine Research Reserve.  Daily chlorophyll concentrations were estimated from fluorescence values that did not include blue-green algae blooms.  These date are provided to illustrate examples with time series simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daydat
</code></pre>


<h3>Format</h3>

<p>A data frame with 3506 rows and 9 variables, 1985 to 2014:
</p>

<dl>
<dt><code>date</code></dt><dd><p>Date as daily time step</p>
</dd> 
<dt><code>flo</code></dt><dd><p>numeric for salinity, ppt</p>
</dd>
<dt><code>lnres</code></dt><dd><p>numeric for chlorophyll fluorescence as ln-transformed ug/l</p>
</dd>
<dt><code>Q</code></dt><dd><p>numeric for daily discharge m3/s</p>
</dd>
<dt><code>lnQ</code></dt><dd><p>numeric for daily discharge ln-transformed m3/s</p>
</dd>
<dt><code>jday</code></dt><dd><p>numeric for julian day</p>
</dd>
<dt><code>year</code></dt><dd><p>numeric for year</p>
</dd>
<dt><code>day</code></dt><dd><p>numeric for day from 1-31</p>
</dd>
<dt><code>dec_time</code></dt><dd><p>numeric for decimal time on the annual period</p>
</dd>
</dl>


<hr>
<h2 id='dec_time'>Create decimal time from time vector</h2><span id='topic+dec_time'></span><span id='topic+dec_time.Date'></span>

<h3>Description</h3>

<p>Create decimal time on an annual scale from an input time vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dec_time(date_in)

## S3 method for class 'Date'
dec_time(date_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dec_time_+3A_date_in">date_in</code></td>
<td>
<p>input time vector, usually a <code>date</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function is used internally within the package.
</p>


<h3>Value</h3>

<p>A named list of four numeric vectors including <code>day_num</code> (decimal day on an annual scale), <code>month</code> (month of the year as integer), <code>year</code>, and <code>dec_time</code> (decimal time as sum of <code>year</code> and <code>day_num</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- Sys.Date()
dts &lt;- seq.Date(dt - 365, dt, by = 'day') 

dec_time(dts)
</code></pre>

<hr>
<h2 id='dynaplot'>Plot model response to salinity or flow as a lineplot for all months</h2><span id='topic+dynaplot'></span><span id='topic+dynaplot.tidal'></span><span id='topic+dynaplot.tidalmean'></span>

<h3>Description</h3>

<p>Plot the relationship between the modelled response and salinity/flow across the time series using line plots for each month.  Each line corresponds to a unique year.  This can be used to evaluate temporal variation between the two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynaplot(dat_in, ...)

## S3 method for class 'tidal'
dynaplot(
  dat_in,
  month = c(1:12),
  tau = NULL,
  years = NULL,
  col_vec = NULL,
  alpha = 1,
  size = 1,
  logspace = TRUE,
  floscl = TRUE,
  allflo = FALSE,
  ncol = NULL,
  grids = TRUE,
  scales = NULL,
  pretty = TRUE,
  use_bw = TRUE,
  fac_nms = NULL,
  ...
)

## S3 method for class 'tidalmean'
dynaplot(
  dat_in,
  month = c(1:12),
  years = NULL,
  col_vec = NULL,
  alpha = 1,
  size = 1,
  logspace = TRUE,
  floscl = TRUE,
  allflo = FALSE,
  ncol = NULL,
  grids = TRUE,
  scales = NULL,
  pretty = TRUE,
  use_bw = TRUE,
  fac_nms = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynaplot_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_month">month</code></td>
<td>
<p>numeric input from 1 to 12 indicating the monthly predictions to plot</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_tau">tau</code></td>
<td>
<p>numeric vector of quantile to plot.  The function will plot the 'middle' quantile if none is specified, e.g., if 0.2, 0.3, and 0.4 are present in the fitted model object then 0.3 will be plotted.</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_years">years</code></td>
<td>
<p>numeric vector of years to plot, one to many, defaults to all</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_col_vec">col_vec</code></td>
<td>
<p>chr string of plot colors to use, passed to <code><a href="#topic+gradcols">gradcols</a></code> and <code><a href="ggplot2.html#topic+scale_colour_gradientn">scale_colour_gradientn</a></code> for line shading.  Any color palette from RColorBrewer can be used as a named input. Palettes from grDevices must be supplied as the returned string of colors for each palette.</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_alpha">alpha</code></td>
<td>
<p>numeric value from zero to one indicating line transparency</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_size">size</code></td>
<td>
<p>numeric value for line size</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating if plots are in log space</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_floscl">floscl</code></td>
<td>
<p>logical indicating if salinity/flow on x-axis is standardized (default) or in original scale</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_allflo">allflo</code></td>
<td>
<p>logical indicating if the salinity or flow values for plotting are limited to the fifth and ninety-fifth percentile of observed values for the month of interest</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_ncol">ncol</code></td>
<td>
<p>numeric argument passed to <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> indicating number of facet columns</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_grids">grids</code></td>
<td>
<p>logical indicating if grid lines are present</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_scales">scales</code></td>
<td>
<p>chr string passed to ggplot to change x/y axis scaling on facets, acceptable values are <code>'free'</code>, <code>'free_x'</code>, or <code>'free_y'</code></p>
</td></tr>
<tr><td><code id="dynaplot_+3A_pretty">pretty</code></td>
<td>
<p>logical indicating if my subjective idea of plot aesthetics is applied, otherwise the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> default themes are used.  The aesthetic arguments will not apply if <code>pretty = TRUE</code>.</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_use_bw">use_bw</code></td>
<td>
<p>logical indicating if the <code><a href="ggplot2.html#topic+theme_bw">theme_bw</a></code> theme is used</p>
</td></tr>
<tr><td><code id="dynaplot_+3A_fac_nms">fac_nms</code></td>
<td>
<p>optional chr string for facet labels, which must be equal in length to <code>month</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These plots can be used to examine how the relationship between the response variable and flow varies throughout the time series.  It is essentially identical to the plot produced by <code><a href="#topic+gridplot">gridplot</a></code>, except lines plots are returned that show the relationship of the response variable with salinity/flow using different lines for each year. The interpolation grid that is stored as an attribute in a fitted tidal object is used to create the plot.  Each plot is limited to the same month throughout the time series to limit seasonal variation.  Plots are also constrained to the fifth and ninety-fifth percentile of observed salinity/flow values during the month of interest to limit the predictions within the data domain. This behavior can be suppressed by changing the <code>allflo</code> argument. 
</p>
<p>Note that the year variable used for color mapping is treated as a continuous variable although it is an integer by definition.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be further modified
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitplot">fitplot</a></code>, <code><a href="#topic+gridplot">gridplot</a></code>, <code><a href="#topic+prdnrmplot">prdnrmplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load a fitted tidal object
data(tidfit)

# plot using defaults, 
# defaults to the fiftieth quantile for all years
dynaplot(tidfit)
## Not run: 
# change the defaults
dynaplot(tidfit, tau = 0.9, month = 2, years = seq(1980, 1990), 
 col_vec = rainbow(7), alpha = 0.5, size = 3) 
 
# plot a tidalmean object
data(tidfitmean)

dynaplot(tidfitmean)

## End(Not run)
</code></pre>

<hr>
<h2 id='fill_grd'>Add date columns and fill missing values in the interpolation grids</h2><span id='topic+fill_grd'></span>

<h3>Description</h3>

<p>Add date, year, month, and day columns to the interpolation grids using dates from <code>dat_in</code>. The <code><a href="fields.html#topic+interp.surface">interp.surface</a></code> function is used after splitting the interpolation matrix by month to fill missing values.  Function is used in <code><a href="#topic+wrtds">wrtds</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_grd(grd_in, dat_in, interp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_grd_+3A_grd_in">grd_in</code></td>
<td>
<p>interpolation grid to fill, either a single mean grid or an individual quantile grid created within <code><a href="#topic+wrtds">wrtds</a></code></p>
</td></tr>
<tr><td><code id="fill_grd_+3A_dat_in">dat_in</code></td>
<td>
<p><code><a href="#topic+tidal">tidal</a></code> or <code><a href="#topic+tidalmean">tidalmean</a></code> object</p>
</td></tr>
<tr><td><code id="fill_grd_+3A_interp">interp</code></td>
<td>
<p>logical for interpolation</p>
</td></tr>
</table>

<hr>
<h2 id='fillpo'>Fill the <code>predonobs</code> attribute</h2><span id='topic+fillpo'></span><span id='topic+fillpo.tidal'></span><span id='topic+fillpo.tidalmean'></span>

<h3>Description</h3>

<p>Fill the <code>predonobs</code> attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillpo(dat_in, ...)

## S3 method for class 'tidal'
fillpo(dat_in, ...)

## S3 method for class 'tidalmean'
fillpo(dat_in, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillpo_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="fillpo_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used in <code><a href="#topic+respred">respred</a></code> to fill the <code>predonobs</code> attribute.  This attribute is used to estimate performance metrics with <code><a href="#topic+wrtdsperf">wrtdsperf</a></code>.
</p>


<h3>Value</h3>

<p>The input tidal or tidalmean object with the filled <code>predonobs</code> attribute as predictions for the observed data as a data frame.
</p>

<hr>
<h2 id='fitmoplot'>Plot the fitted results for a tidal object by month</h2><span id='topic+fitmoplot'></span><span id='topic+fitmoplot.tidal'></span><span id='topic+fitmoplot.tidalmean'></span>

<h3>Description</h3>

<p>Plot a tidal object to view the response variable observations, predictions, and normalized results separately for each month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitmoplot(dat_in, ...)

## S3 method for class 'tidal'
fitmoplot(
  dat_in,
  month = c(1:12),
  tau = NULL,
  predicted = TRUE,
  logspace = TRUE,
  dt_rng = NULL,
  ncol = NULL,
  col_vec = NULL,
  grids = TRUE,
  pretty = TRUE,
  lwd = 1,
  size = 2,
  alpha = 1,
  ...
)

## S3 method for class 'tidalmean'
fitmoplot(
  dat_in,
  month = c(1:12),
  predicted = TRUE,
  logspace = TRUE,
  dt_rng = NULL,
  ncol = NULL,
  col_vec = NULL,
  grids = TRUE,
  pretty = TRUE,
  lwd = 1,
  size = 2,
  alpha = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitmoplot_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_month">month</code></td>
<td>
<p>numeric indicating months to plot</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_tau">tau</code></td>
<td>
<p>numeric vector of quantiles to plot, defaults to all in object if not supplied</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_predicted">predicted</code></td>
<td>
<p>logical indicating if standard predicted values are plotted, default <code>TRUE</code>, otherwise normalized predictions are plotted</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating if plots are in log space</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_dt_rng">dt_rng</code></td>
<td>
<p>Optional chr string indicating the date range of the plot. Must be two values in the format 'YYYY-mm-dd' which is passed to <code><a href="base.html#topic+as.Date">as.Date</a></code>.</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_ncol">ncol</code></td>
<td>
<p>numeric argument passed to <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> indicating number of facet columns</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_col_vec">col_vec</code></td>
<td>
<p>chr string of plot colors to use, passed to <code><a href="#topic+gradcols">gradcols</a></code>.  Any color palette from RColorBrewer can be used as a named input. Palettes from grDevices must be supplied as the returned string of colors for each palette.</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_grids">grids</code></td>
<td>
<p>logical indicating if grid lines are present</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_pretty">pretty</code></td>
<td>
<p>logical indicating if my subjective idea of plot aesthetics is applied, otherwise the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> default themes are used</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_lwd">lwd</code></td>
<td>
<p>numeric value indicating width of lines</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_size">size</code></td>
<td>
<p>numeric value indicating size of points</p>
</td></tr>
<tr><td><code id="fitmoplot_+3A_alpha">alpha</code></td>
<td>
<p>numeric value indicating transparency of points or lines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plots are similar to those produced by <code><a href="#topic+fitplot">fitplot</a></code> except the values are faceted by month.  This allows an evaluation of trends over time independent of seasonal variation.  Multiple observations within each month for each year are averaged for a smoother plot.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be further modified
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitplot">fitplot</a></code>, <code><a href="#topic+prdnrmplot">prdnrmplot</a></code>, <code><a href="#topic+sliceplot">sliceplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load a fitted tidal object
data(tidfit)

# plot using defaults
fitmoplot(tidfit)
## Not run:  
# get the same plot but use default ggplot settings
fitmoplot(tidfit, pretty = FALSE)

# plot specific quantiles
fitmoplot(tidfit, tau = c(0.1, 0.9))

# plot the normalized predictions
fitmoplot(tidfit, predicted = FALSE)

# modify the plot as needed using ggplot scales, etc.

library(ggplot2)

fitmoplot(tidfit, pretty = FALSE, linetype = 'dashed') + 
 theme_classic() + 
 scale_y_continuous(
   'Chlorophyll', 
   limits = c(0, 5)
   ) +
 scale_colour_manual( 
   'Predictions', 
   labels = c('lo', 'md', 'hi'), 
   values = c('red', 'green', 'blue'), 
   guide = guide_legend(reverse = TRUE)
   ) 
   
# plot a tidalmean object
data(tidfitmean)

fitmoplot(tidfitmean)    

## End(Not run)
</code></pre>

<hr>
<h2 id='fitplot'>Plot the fitted results for a tidal object</h2><span id='topic+fitplot'></span><span id='topic+fitplot.tidal'></span><span id='topic+fitplot.tidalmean'></span>

<h3>Description</h3>

<p>Plot a tidal object to view response variable observations, predictions, and normalized results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitplot(dat_in, ...)

## S3 method for class 'tidal'
fitplot(
  dat_in,
  tau = NULL,
  predicted = TRUE,
  annuals = TRUE,
  logspace = TRUE,
  dt_rng = NULL,
  col_vec = NULL,
  grids = TRUE,
  min_mo = 9,
  mo_strt = 10,
  pretty = TRUE,
  lwd = 1,
  size = 2,
  alpha = 1,
  ...
)

## S3 method for class 'tidalmean'
fitplot(
  dat_in,
  predicted = TRUE,
  annuals = TRUE,
  logspace = TRUE,
  dt_rng = NULL,
  col_vec = NULL,
  grids = TRUE,
  min_mo = 9,
  mo_strt = 10,
  pretty = TRUE,
  lwd = 1,
  size = 2,
  alpha = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitplot_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="fitplot_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="fitplot_+3A_tau">tau</code></td>
<td>
<p>numeric vector of quantiles to plot, defaults to all in object if not supplied</p>
</td></tr>
<tr><td><code id="fitplot_+3A_predicted">predicted</code></td>
<td>
<p>logical indicating if standard predicted values are plotted, default <code>TRUE</code>, otherwise normalized predictions are plotted</p>
</td></tr>
<tr><td><code id="fitplot_+3A_annuals">annuals</code></td>
<td>
<p>logical indicating if plots are annual aggregations of results</p>
</td></tr>
<tr><td><code id="fitplot_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating if plots are in log space</p>
</td></tr>
<tr><td><code id="fitplot_+3A_dt_rng">dt_rng</code></td>
<td>
<p>Optional chr string indicating the date range of the plot. Must be two values in the format 'YYYY-mm-dd' which is passed to <code><a href="base.html#topic+as.Date">as.Date</a></code>.</p>
</td></tr>
<tr><td><code id="fitplot_+3A_col_vec">col_vec</code></td>
<td>
<p>chr string of plot colors to use, passed to <code><a href="#topic+gradcols">gradcols</a></code>.  Any color palette from RColorBrewer can be used as a named input. Palettes from grDevices must be supplied as the returned string of colors for each palette.</p>
</td></tr>
<tr><td><code id="fitplot_+3A_grids">grids</code></td>
<td>
<p>logical indicating if grid lines are present</p>
</td></tr>
<tr><td><code id="fitplot_+3A_min_mo">min_mo</code></td>
<td>
<p>numeric value from one to twelve indicating the minimum number of months with observations for averaging by years, applies only if <code>annuals = TRUE</code>.  See <code><a href="#topic+annual_agg">annual_agg</a></code>.</p>
</td></tr>
<tr><td><code id="fitplot_+3A_mo_strt">mo_strt</code></td>
<td>
<p>numeric indicating month to start aggregation years, defaults to October for USGS water year from October to September, applies only if <code>annuals = TRUE</code>.  See <code><a href="#topic+annual_agg">annual_agg</a></code>.</p>
</td></tr>
<tr><td><code id="fitplot_+3A_pretty">pretty</code></td>
<td>
<p>logical indicating if my subjective idea of plot aesthetics is applied, otherwise the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> default themes are used</p>
</td></tr>
<tr><td><code id="fitplot_+3A_lwd">lwd</code></td>
<td>
<p>numeric value indicating width of lines</p>
</td></tr>
<tr><td><code id="fitplot_+3A_size">size</code></td>
<td>
<p>numeric value indicating size of points</p>
</td></tr>
<tr><td><code id="fitplot_+3A_alpha">alpha</code></td>
<td>
<p>numeric value indicating transparency of points or lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be further modified
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitmoplot">fitmoplot</a></code>, <code><a href="#topic+prdnrmplot">prdnrmplot</a></code>, <code><a href="#topic+sliceplot">sliceplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load a fitted tidal object
data(tidfit)

# plot using defaults
fitplot(tidfit)

# get the same plot but use default ggplot settings
fitplot(tidfit, pretty = FALSE)

# plot in log space
fitplot(tidfit, logspace = TRUE)

# plot specific quantiles
fitplot(tidfit, tau = c(0.1, 0.9))

# plot the normalized predictions
fitplot(tidfit, predicted = FALSE)

# plot as monthly values
fitplot(tidfit, annuals = FALSE) 

# format the x-axis is using annual aggregations
library(ggplot2)

fitplot(tidfit, annual = TRUE) + 
 scale_x_date(limits = as.Date(c('2000-01-01', '2012-01-01')))

# modify the plot as needed using ggplot scales, etc.

fitplot(tidfit, pretty = FALSE, linetype = 'dashed') + 
 theme_classic() + 
 scale_y_continuous(
   'Chlorophyll', 
   limits = c(0, 50)
   ) +
 scale_colour_manual( 
   'Predictions', 
   labels = c('lo', 'md', 'hi'), 
   values = c('red', 'green', 'blue'), 
   guide = guide_legend(reverse = TRUE)
   ) 
 
# plot a tidalmean object
data(tidfitmean)

fitplot(tidfitmean)  
</code></pre>

<hr>
<h2 id='getwts'>Get weights for regression</h2><span id='topic+getwts'></span><span id='topic+getwts.default'></span>

<h3>Description</h3>

<p>Get weights for WRTDS for a single observation using a tri-cubic weighting function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getwts(dat_in, ...)

## Default S3 method:
getwts(
  dat_in,
  ref_in,
  wt_vars = c("day_num", "dec_time", "flo"),
  wins = list(0.5, 10, NULL),
  all = FALSE,
  slice = TRUE,
  ngrzero = FALSE,
  wins_only = FALSE,
  min_obs = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getwts_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal object</p>
</td></tr>
<tr><td><code id="getwts_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="getwts_+3A_ref_in">ref_in</code></td>
<td>
<p>row of tidal object as reference for weights</p>
</td></tr>
<tr><td><code id="getwts_+3A_wt_vars">wt_vars</code></td>
<td>
<p>chr string of three elements indicating names of columns in tidal object that are used for reference row weights</p>
</td></tr>
<tr><td><code id="getwts_+3A_wins">wins</code></td>
<td>
<p>list of half-window widths for time, year, and flow</p>
</td></tr>
<tr><td><code id="getwts_+3A_all">all</code></td>
<td>
<p>logical to return individual weights rather than the product of all three, default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="getwts_+3A_slice">slice</code></td>
<td>
<p>logical indicating if data are subset by observations within the maximum window width for faster calculations</p>
</td></tr>
<tr><td><code id="getwts_+3A_ngrzero">ngrzero</code></td>
<td>
<p>logical indicating if count of observations with weights greater than zero is returned</p>
</td></tr>
<tr><td><code id="getwts_+3A_wins_only">wins_only</code></td>
<td>
<p>logical if the half-window widths should be returned as a list</p>
</td></tr>
<tr><td><code id="getwts_+3A_min_obs">min_obs</code></td>
<td>
<p>numeric vector for window widening if the number of observations with non-zero weights is less than the specified value, use <code>min_obs = NULL</code> to suppress this behavior</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default half-window widths for <code>day_num</code>, <code>year</code>, and <code>flow</code> are half a day (12 hours), 10 years, and half the range of salinity/flow in the input data.  The half-window widths are expanded by 10% until at least 100 observations have weights greater than zero.  This behavior can be suppressed by setting <code>min_obs = NULL</code>.
</p>


<h3>Value</h3>

<p>A vector of weights with length equal to the number of observations (rows) in the tidal object.  Vectors for all three weighting variables are returned if <code>all = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
data(tidobj)

# get weights for first row
first &lt;- tidobj[1, ]
wts &lt;- getwts(tidobj, first)

plot(wts, type = 'l')

## Not run: 

# get count of observations with grzero weights
sapply(1:nrow(tidobj), function(row) getwts(tidobj, tidobj[row, ], 
 ngrzero = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='goodfit'>Quantile regression goodness of fit</h2><span id='topic+goodfit'></span>

<h3>Description</h3>

<p>Calculate quantile regression goodness of fit using residuals and non-conditional residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goodfit(resid, resid_nl, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goodfit_+3A_resid">resid</code></td>
<td>
<p>numeric vector of residuals from the conditional quantile model</p>
</td></tr>
<tr><td><code id="goodfit_+3A_resid_nl">resid_nl</code></td>
<td>
<p>numeric vector of residuals from the non-conditional (null) quantile model</p>
</td></tr>
<tr><td><code id="goodfit_+3A_tau">tau</code></td>
<td>
<p>numeric value from zero to one for the estimated quantile</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goodness of fit measure for quantile regression is estimated as 1 minus the ratio between the sum of absolute deviations in the fully parameterized models and the sum of absolute deviations in the null (non-conditional) quantile model.  The values are useful for comparisons between quantile models, but they are not comparable to standard coefficients of determination. The latter is based on the variance of squared deviations, whereas goodness of fit values for quantile regression are based on absolute deviations.  Goodness of fit values will always be smaller than R2 values.
</p>


<h3>Value</h3>

<p>A numeric value from 0 to 1 indicating goodness of fit
</p>


<h3>References</h3>

<p>Koenker, R., Machado, J.A.F. 1999. Goodness of fit and related inference processes for quantile regression. Journal of the American Statistical Association. 94(448):1296-1310.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wrtdsrsd">wrtdsrsd</a></code> for residuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(quantreg)

## random variables
x &lt;- runif(100, 0, 10)
y &lt;- x + rnorm(100)

## quantile model
mod &lt;- rq(y ~ x, tau = 0.5)
res &lt;- resid(mod)

## non-conditional quantile model
mod_nl &lt;- rq(y ~ 1, tau = 0.5)
rsd_nl &lt;- resid(mod_nl)

goodfit(res, rsd_nl, 0.5)

## r2 of mean model for comparison
mod_lm &lt;- lm(y ~ x)

summary(mod_lm)$r.squared
</code></pre>

<hr>
<h2 id='gradcols'>Get colors for plots</h2><span id='topic+gradcols'></span>

<h3>Description</h3>

<p>Gets colors used for WRTDS plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradcols(col_vec = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradcols_+3A_col_vec">col_vec</code></td>
<td>
<p>chr string of plot colors to use, typically passed to <code><a href="ggplot2.html#topic+scale_colour_gradientn">scale_colour_gradientn</a></code> for shading. Any color palette from RColorBrewer can be used as a named input. Palettes from grDevices must be supplied as the returned string of colors for each palette.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function for retrieving a color palette that is used by most of the plotting functions.   Palettes from RColorBrewer will use the maximum number of colors.  The default palette is 'Spectral'.
</p>


<h3>Value</h3>

<p>A character vector of colors in hexadecimal notation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dynaplot">dynaplot</a></code>, <code><a href="#topic+gridplot">gridplot</a></code>, <code><a href="#topic+wtsplot">wtsplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## defaults
gradcols()

## another RColorBrewer palette
gradcols('Pastel2')

## a silly example
gradcols(rainbow(7))
</code></pre>

<hr>
<h2 id='gridplot'>Plot variable response to salinity/flow as a gridded surface for all months</h2><span id='topic+gridplot'></span><span id='topic+gridplot.tidal'></span><span id='topic+gridplot.tidalmean'></span>

<h3>Description</h3>

<p>Plot the relationship between the response variable and salinity/flow across the time series using a gridded surface for all months.   The response is shaded by relative values across all dates for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridplot(dat_in, ...)

## S3 method for class 'tidal'
gridplot(
  dat_in,
  month = c(1:12),
  tau = NULL,
  years = NULL,
  col_vec = NULL,
  col_lim = NULL,
  logspace = TRUE,
  floscl = TRUE,
  allflo = FALSE,
  flo_fac = 3,
  yr_fac = 3,
  ncol = NULL,
  grids = FALSE,
  pretty = TRUE,
  ...
)

## S3 method for class 'tidalmean'
gridplot(
  dat_in,
  month = c(1:12),
  years = NULL,
  col_vec = NULL,
  col_lim = NULL,
  logspace = TRUE,
  floscl = TRUE,
  allflo = FALSE,
  flo_fac = 3,
  yr_fac = 3,
  ncol = NULL,
  grids = FALSE,
  pretty = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridplot_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="gridplot_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="gridplot_+3A_month">month</code></td>
<td>
<p>numeric indicating months to plot or chr string 'all' to indicate all months with no plot facets</p>
</td></tr>
<tr><td><code id="gridplot_+3A_tau">tau</code></td>
<td>
<p>numeric vector of quantile to plot.  The function will plot the 'middle' quantile if none is specified, e.g., if 0.2, 0.3, and 0.4 are present in the fitted model object then 0.3 will be plotted.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_years">years</code></td>
<td>
<p>numeric vector for range of years to plot</p>
</td></tr>
<tr><td><code id="gridplot_+3A_col_vec">col_vec</code></td>
<td>
<p>chr string of plot colors to use, passed to <code><a href="#topic+gradcols">gradcols</a></code> and <code><a href="ggplot2.html#topic+scale_fill_gradientn">scale_fill_gradientn</a></code> for grid shading.  Any color palette from RColorBrewer can be used as a named input. Palettes from grDevices must be supplied as the returned string of colors for each palette.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_col_lim">col_lim</code></td>
<td>
<p>numeric vector of length two that defines the range of the color ramp in the legend, passed to <code><a href="ggplot2.html#topic+scale_fill_gradient">scale_fill_gradient</a></code>.  This is useful for fixing the color range to evaluate multiple plots.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating if plots are in log space</p>
</td></tr>
<tr><td><code id="gridplot_+3A_floscl">floscl</code></td>
<td>
<p>logical indicating if salinity/flow on x-axis is standardized (default) or in original scale</p>
</td></tr>
<tr><td><code id="gridplot_+3A_allflo">allflo</code></td>
<td>
<p>logical indicating if the salinity/flow values for plotting are limited to the fifth and ninety-fifth percentile of observed values for the month of interest</p>
</td></tr>
<tr><td><code id="gridplot_+3A_flo_fac">flo_fac</code></td>
<td>
<p>numeric value indicating the factor for smoothing the response variable across salinity/flow values. Increasing the value creates more smoothing and setting the value to 1 removes all smoothing.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_yr_fac">yr_fac</code></td>
<td>
<p>numeric value indicating the factor for smoothing the response variable across integer years. Increasing the value creates more smoothing and setting the value to 1 removes all smoothing.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_ncol">ncol</code></td>
<td>
<p>numeric argument passed to <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> indicating number of facet columns</p>
</td></tr>
<tr><td><code id="gridplot_+3A_grids">grids</code></td>
<td>
<p>logical indicating if grid lines are present</p>
</td></tr>
<tr><td><code id="gridplot_+3A_pretty">pretty</code></td>
<td>
<p>logical indicating if my subjective idea of plot aesthetics is applied, otherwise the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> default themes are used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These plots can be used to examine how the relationship between the response variable and salinity/flow varies throughout the time series for multiple months.  The plot is similar to that returned by <code><a href="#topic+dynaplot">dynaplot</a></code> except changes in the response are shown on a gridded surface of salinity/flow versus time.  Multiple months can also be viewed.  Color shading is in proportion to the value of the response variable and is relative across the plotted months.  The interpolation grid that is stored as an attribute in a fitted tidal object is used to create the plot.  By default, the plots are constrained to the fifth and ninety-fifth percentile of observed salinity/flow values during each month to limit the predictions within the data domain. This behavior can be suppressed by changing the <code>allflo</code> argument, although the predicted values of the response variable that are outside of the salinity/flow range for the plotted month are typically unrealistic.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be further modified
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dynaplot">dynaplot</a></code>, <code><a href="#topic+fitplot">fitplot</a></code>, <code><a href="#topic+gridplot">gridplot</a></code>, <code><a href="#topic+prdnrmplot">prdnrmplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load a fitted tidal object
data(tidfit)

## defaults to the fiftieth quantile
gridplot(tidfit)

## no facets, all months
gridplot(tidfit, month = 'all')

## change the defaults
gridplot(tidfit, tau = c(0.1), month = c(3, 6, 9, 12), 
 col_vec = c('red', 'blue', 'green'), flo_fac = 1)
 
## plot a tidalmean object
data(tidfitmean)

gridplot(tidfitmean)


## End(Not run)
</code></pre>

<hr>
<h2 id='kendallSeasonalTrendTest'>Kendall seasonal trend test</h2><span id='topic+kendallSeasonalTrendTest'></span><span id='topic+kendallSeasonalTrendTest.default'></span><span id='topic+kendallSeasonalTrendTest.data.frame'></span><span id='topic+kendallSeasonalTrendTest.formula'></span><span id='topic+kendallSeasonalTrendTest.matrix'></span>

<h3>Description</h3>

<p>Nonparametric test for monotonic trend Within each season based on Kendall's Tau statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kendallSeasonalTrendTest(y, ...)

## Default S3 method:
kendallSeasonalTrendTest(
  y,
  season,
  year,
  alternative = "two.sided",
  correct = TRUE,
  ci.slope = TRUE,
  conf.level = 0.95,
  independent.obs = TRUE,
  data.name = NULL,
  season.name = NULL,
  year.name = NULL,
  parent.of.data = NULL,
  subset.expression = NULL,
  ...
)

## S3 method for class 'data.frame'
kendallSeasonalTrendTest(y, ...)

## S3 method for class 'formula'
kendallSeasonalTrendTest(y, data = NULL, subset, na.action = na.pass, ...)

## S3 method for class 'matrix'
kendallSeasonalTrendTest(y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kendallSeasonalTrendTest_+3A_y">y</code></td>
<td>
<p>an object containing data for the trend test. In the default method, the argument <code>y</code> must be numeric vector of observations. When <code>y</code> is a <code>data frame</code>, all columns must be numeric. When <code>y</code> is a <code>matrix</code>, it must be a numeric matrix. In the formula method, <code>y</code> must be a formula of the form <code>y ~ season + year</code>, where <code>y</code>, <code>season</code>, and <code>year</code> specify what variables to use for the these arguments in the call to <code>kendallSeasonalTrendTest.default</code>. Missing (<code>NA</code>), undefined (<code>NaN</code>), and infinite (<code>Inf, -Inf</code>) values are allowed but will be removed.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_...">...</code></td>
<td>
<p>methods passed to or from other methods</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_season">season</code></td>
<td>
<p>numeric or character vector or a factor indicating the seasons in which the observations in y were taken. The length of <code>season</code> must equal the length of <code>y</code>.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_year">year</code></td>
<td>
<p>numeric vector indicating the years in which the observations in <code>y</code> were taken. The length of <code>year</code> must equal the length of <code>y</code>.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_alternative">alternative</code></td>
<td>
<p>character string indicating the kind of alternative hypothesis. The possible values are <code>"two.sided"</code> (tau not equal to 0; the default), <code>"less"</code> (tau less than 0), and <code>"greater"</code> (tau greater than 0).</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_correct">correct</code></td>
<td>
<p>logical scalar indicating whether to use the correction for continuity in computing the z-statistic that is based on the test statistic S'. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_ci.slope">ci.slope</code></td>
<td>
<p>logical scalar indicating whether to compute a confidence interval for the slope. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_conf.level">conf.level</code></td>
<td>
<p>numeric scalar between 0 and 1 indicating the confidence level associated with the confidence interval for the slope. The default value is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_independent.obs">independent.obs</code></td>
<td>
<p>logical scalar indicating whether to assume the observations in y are seially independent. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_data.name">data.name</code></td>
<td>
<p>character string indicating the name of the data used for the trend test. The default value is <code>deparse(substitute(y))</code>.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_season.name">season.name</code></td>
<td>
<p>character string indicating the name of the data used for the season. The default value is <code>deparse(substitute(season))</code>.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_year.name">year.name</code></td>
<td>
<p>character string indicating the name of the data used for the year. The default value is <code>deparse(substitute(year))</code>.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_parent.of.data">parent.of.data</code></td>
<td>
<p>character string indicating the source of the data used for the trend test.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_subset.expression">subset.expression</code></td>
<td>
<p>character string indicating the expression used to subset the data.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_data">data</code></td>
<td>
<p>specifies an optional data frame, list or environment (or object coercible by <code>as.data.frame</code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>kendallTrendTest</code> is called.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_subset">subset</code></td>
<td>
<p>specifies an optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="kendallSeasonalTrendTest_+3A_na.action">na.action</code></td>
<td>
<p>specifies a function which indicates what should happen when the data contain <code>NAs</code>. The default is <code><a href="stats.html#topic+na.pass">na.pass</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform a nonparametric test for a monotonic trend within each season based on Kendall's tau statistic, and optionally compute a confidence interval for the slope across all seasons.
</p>


<h3>Value</h3>

<p>A list object with elements for results of the test
</p>


<h3>References</h3>

<p>Hirsch, R.M., Slack, J.R., Smith, R.A. 1982. Techniques of trend analysis for monthly water quality data. Water Resources Research, 18:107-121.
</p>
<p>Millard, S. P. 2013. EnvStats: An R Package for Environmental Statistics. Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kendallSeasonalTrendTest(res ~ month + year, tidfitmean)
</code></pre>

<hr>
<h2 id='kendallTrendTest'>Kendall trend test</h2><span id='topic+kendallTrendTest'></span><span id='topic+kendallTrendTest.default'></span><span id='topic+kendallTrendTest.formula'></span>

<h3>Description</h3>

<p>Nonparametric test for monotonic trend based on Kendall's Tau statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kendallTrendTest(y, ...)

## Default S3 method:
kendallTrendTest(
  y,
  x = seq(along = y),
  alternative = "two.sided",
  correct = TRUE,
  ci.slope = TRUE,
  conf.level = 0.95,
  warn = TRUE,
  data.name = NULL,
  data.name.x = NULL,
  parent.of.data = NULL,
  subset.expression = NULL,
  ...
)

## S3 method for class 'formula'
kendallTrendTest(y, data = NULL, subset, na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kendallTrendTest_+3A_y">y</code></td>
<td>
<p>an object containing data for the trend test. In the default method, the argument <code>y</code> must be numeric vector of observations. In the formula method, <code>y</code> must be a formula of the form <code>y ~ 1</code> or <code>y ~ x</code>. The form <code>y ~ 1</code> indicates use the observations in the vector <code>y</code> for the test for trend and use the default value of the argument <code>x</code> in the call to <code>kendallTrendTest.default</code>. The form <code>y ~ x</code> indicates use the observations in the vector <code>y</code> for the test for trend and use the specified value of the argument <code>x</code> in the call to <code>kendallTrendTest.default</code>. Missing (<code>NA</code>), undefined (<code>NaN</code>), and infinite (<code>Inf, -Inf</code>) values are allowed but will be removed.</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_...">...</code></td>
<td>
<p>methods passed to or from other methods</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_x">x</code></td>
<td>
<p>numeric vector of &quot;predictor&quot; values. The length of <code>x</code> must equal the length of <code>y</code>. Missing (<code>NA</code>), undefined (<code>NaN</code>), and infinite (<code>Inf, -Inf</code>) values are allowed but will be removed. The default value of <code>x</code> is the vector of numbers <code>1, 2, ..., n</code> where <code>n</code> is the number of elements in <code>y</code>.</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_alternative">alternative</code></td>
<td>
<p>character string indicating the kind of alternative hypothesis. The possible values are <code>"two.sided"</code> (tau not equal to 0; the default), <code>"less"</code> (tau less than 0), and <code>"greater"</code> (tau greater than 0).</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_correct">correct</code></td>
<td>
<p>logical scalar indicating whether to use the correction for continuity in computing the z-statistic that is based on the test statistic S'. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_ci.slope">ci.slope</code></td>
<td>
<p>logical scalar indicating whether to compute a confidence interval for the slope. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_conf.level">conf.level</code></td>
<td>
<p>numeric scalar between 0 and 1 indicating the confidence level associated with the confidence interval for the slope. The default value is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_warn">warn</code></td>
<td>
<p>logical scalar indicating whether to print a warning message when <code>y</code> does not contain at least two non-missing values, or when <code>x</code> does not contain at least two unique non-missing values. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_data.name">data.name</code></td>
<td>
<p>character string indicating the name of the data used for the trend test. The default value is <code>deparse(substitute(y))</code>.</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_data.name.x">data.name.x</code></td>
<td>
<p>character string indicating the name of the data used for the predictor variable <code>x</code>. If <code>x</code> is not supplied this argument is ignored. When <code>x</code> is supplied, the default value is <code>deparse(substitute(x))</code>.</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_parent.of.data">parent.of.data</code></td>
<td>
<p>character string indicating the source of the data used for the trend test.</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_subset.expression">subset.expression</code></td>
<td>
<p>character string indicating the expression used to subset the data.</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_data">data</code></td>
<td>
<p>specifies an optional data frame, list or environment (or object coercible by <code>as.data.frame</code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>kendallTrendTest</code> is called.</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_subset">subset</code></td>
<td>
<p>specifies an optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="kendallTrendTest_+3A_na.action">na.action</code></td>
<td>
<p>specifies a function which indicates what should happen when the data contain <code>NAs</code>. The default is <code><a href="stats.html#topic+na.pass">na.pass</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>kendallTrendTest</code> performs Kendall's nonparametric test for a monotonic trend, which is a special case of the test for independence based on Kendall's tau statistic (see <code><a href="stats.html#topic+cor.test">cor.test</a></code>). The slope is estimated using the method of Theil (1950) and Sen (1968). When <code>ci.slope=TRUE</code>, the confidence interval for the slope is computed using Gilbert's (1987) Modification of the Theil/Sen Method.
</p>
<p>Kendall's test for a monotonic trend is a special case of the test for independence based on Kendall's tau statistic. The first section below explains the general case of testing for independence. The second section explains the special case of testing for monotonic trend. The last section explains how a simple linear regression model is a special case of a monotonic trend and how the slope may be estimated.
</p>


<h3>Value</h3>

<p>A list object with elements for results of the test
</p>


<h3>References</h3>

<p>Hirsch, R.M., Slack, J.R., Smith, R.A. 1982. Techniques of trend analysis for monthly water quality data. Water Resources Research, 18:107-121.
</p>
<p>Millard, S. P. 2013. EnvStats: An R Package for Environmental Statistics. Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kendallTrendTest(res ~ dec_time, tidfitmean)
</code></pre>

<hr>
<h2 id='lnQ_sim'>Simulate a discharge time series</h2><span id='topic+lnQ_sim'></span>

<h3>Description</h3>

<p>Simulate a discharge time series by modelling the statistical properties of an existing daily time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnQ_sim(dat_in, comps = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lnQ_sim_+3A_dat_in">dat_in</code></td>
<td>
<p>input <code><a href="base.html#topic+data.frame">data.frame</a></code> that must include discharge and decimal time columns, see example dataset <code><a href="#topic+daydat">daydat</a></code></p>
</td></tr>
<tr><td><code id="lnQ_sim_+3A_comps">comps</code></td>
<td>
<p>logical indicating if components of the simulated time series are returned, see value.</p>
</td></tr>
<tr><td><code id="lnQ_sim_+3A_seed">seed</code></td>
<td>
<p>optional numeric value for random generation seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Daily flow data are simulated as the additive combination of a stationary seasonal component and serially-correlated errors estimated from the observed data.  The stationary seasonal component is based on a seasonal regression of discharge over time.  The residuals from this regression are used to estimate the error distribution using an ARIMA model.  Parameters of the ARIMA model are chosen using stepwise estimation for nonseasonal univariate time series with the <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code> function.  Random errors from a standard normal distribution for the length of the original time series are generated using the model estimates with the <code><a href="stats.html#topic+arima.sim">arima.sim</a></code> function.  Finally, the errors are multiplied by the standard deviation of the original residuals and added to the seasonal component to create a simulated, daily log-flow time series.
</p>


<h3>Value</h3>

<p>The original data frame with an additional column of simulated data named <code>lnQ_sim</code> if <code>comps = FALSE</code>.  Otherwise, a two-element list is returned where the first element is 1) a list with the linear seasonal model fit to the observed time series and ARIMA model fit to the seasonal residuals, and 2) a data frame with the original data, the fit from the seasonal linear model (<code>seas_fit</code>), residuals from observed flow and seasonal fit (<code>seas_res</code>), standard deviation of seasonal residuals (<code>sd_seas</code>), simulated errors from the ARIMA model (<code>errs</code>), and simulated discharge time series (<code>sim_out</code>).  Note that <code>sim_out</code> vector is converted to the same range as the input flow record.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+daydat">daydat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## example data
data(daydat)

## simulate
lnQ_sim(daydat)

</code></pre>

<hr>
<h2 id='lnres_err'>Simulate random errors from a time series</h2><span id='topic+lnres_err'></span>

<h3>Description</h3>

<p>Simulate random errors of a water quality time series by modelling the statistical properties of an observed dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnres_err(dat_in, yr = NULL, comps = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lnres_err_+3A_dat_in">dat_in</code></td>
<td>
<p>input <code><a href="base.html#topic+data.frame">data.frame</a></code> that must include discharge and decimal time columns, see example dataset <code><a href="#topic+daydat">daydat</a></code></p>
</td></tr>
<tr><td><code id="lnres_err_+3A_yr">yr</code></td>
<td>
<p>numeric year value to use for the stationary model, defaults to the median year</p>
</td></tr>
<tr><td><code id="lnres_err_+3A_comps">comps</code></td>
<td>
<p>logical indicating if the WRTDS model used to get response error measures is also returned, see value.</p>
</td></tr>
<tr><td><code id="lnres_err_+3A_seed">seed</code></td>
<td>
<p>optional numeric value for random generation seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Random errors for a stationary seasonal water quality time series on a daily time step are generated by modelling residuals from an observed dataset.  First, a stationary seasonal model is created by fitting a <code><a href="#topic+wrtds">wrtds</a></code> model and estimating an error distribution the residuals using the <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code> function.  Accumulated standard errors from the regression are also retained for each residual.  Random errors using the estimated auto-regressive structures are simulated using <code><a href="stats.html#topic+arima.sim">arima.sim</a></code> for the entire year and multiplied by the corresponding standard error estimate from the regression.  The entire year is then repeated for every year in the observed time series.  The final simulated errors are rescaled to the range of the original residuals that were used to estimate the distribution.
</p>


<h3>Value</h3>

<p>The original data frame with additional columns for the random errors (<code>errs</code>) and the standard error estimates for each residual (<code>scls</code>).  If <code>comps = TRUE</code>, a two-element list is returned that also includes the WRTDS model used as a basis for errors and scale values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+daydat">daydat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## example data
data(daydat)

## get errors
lnres_err(daydat)

## End(Not run)
</code></pre>

<hr>
<h2 id='lnres_sim'>Simulate a water quality time series</h2><span id='topic+lnres_sim'></span>

<h3>Description</h3>

<p>Simulate a water quality time series with an estimated error structure and simulated discharge effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnres_sim(dat_in, lnQ_coef = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lnres_sim_+3A_dat_in">dat_in</code></td>
<td>
<p>input <code><a href="base.html#topic+data.frame">data.frame</a></code> that must include estimated error and simulated discharge time series, see <code><a href="#topic+lnres_err">lnres_err</a></code> and <code><a href="#topic+lnQ_sim">lnQ_sim</a></code> respectively</p>
</td></tr>
<tr><td><code id="lnres_sim_+3A_lnq_coef">lnQ_coef</code></td>
<td>
<p>numeric vector of coefficients of the same length of the time series in <code>dat_in</code> that is multiplied by the discharge vector, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a simulated water quality time series and requires error estimates for an observed water quality dataset and a simulated discharge time series.  The water quality time series is created as the additive combination of a seasonal, stationary time component (as in <code><a href="#topic+lnQ_sim">lnQ_sim</a></code> for discharge), a random error component from <code><a href="#topic+lnres_err">lnres_err</a></code>, and a simulated discharge time series from <code><a href="#topic+lnQ_sim">lnQ_sim</a></code>.  The discharge time series is considered an explicit component of the water quality time series and is first centered at zero prior to adding.  The optional vector of coefficients passed to <code>lnQ_coef</code> can mediate the influence of discharge on the water quality time series.  For example, a vector of all zeroes implies no effect, whereas a vector of all ones implies a constant effect (default).
</p>


<h3>Value</h3>

<p>The original data frame with additional columns for the seasonal water quality model (<code>lnres_seas</code>), a flow-independent water quality time series (<code>lnres_noQ</code>), and a flow-dependent time series (<code>lnres_Q</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+daydat">daydat</a></code> for the format of an input dataset, <code><a href="#topic+lnQ_sim">lnQ_sim</a></code> for simulating discharge, and <code><a href="#topic+lnres_err">lnres_err</a></code> for estimating the error distribution of the water quality time series, <code><a href="#topic+all_sims">all_sims</a></code> for completing all steps at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## example data
data(daydat)

## get simulated discharge
sims &lt;- lnQ_sim(daydat)

## get error structure of wq time series
sims &lt;- lnres_err(sims)

## get simulated wq time series using results from previous
lnres_sim(sims)

## End(Not run)
</code></pre>

<hr>
<h2 id='modfit'>Fit weighted regression and get predicted/normalized response variable</h2><span id='topic+modfit'></span><span id='topic+modfit.default'></span><span id='topic+modfit.tidal'></span><span id='topic+modfit.tidalmean'></span><span id='topic+modfit.data.frame'></span>

<h3>Description</h3>

<p>Fit weighted regression and get predicted/normalized response variable from a data frame.  This is a wrapper for multiple function used to create a weighted regression model and should be used rather than the individual functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modfit(dat_in, ...)

## Default S3 method:
modfit(dat_in, ...)

## S3 method for class 'tidal'
modfit(dat_in, ...)

## S3 method for class 'tidalmean'
modfit(dat_in, ...)

## S3 method for class 'data.frame'
modfit(dat_in, resp_type = "quantile", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modfit_+3A_dat_in">dat_in</code></td>
<td>
<p>input <code><a href="base.html#topic+data.frame">data.frame</a></code> for fitting the model, see details</p>
</td></tr>
<tr><td><code id="modfit_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="modfit_+3A_resp_type">resp_type</code></td>
<td>
<p>chr string indicating the type of model response to use, quantile or mean model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used as a convenience to combine several functions that accomplish specific tasks, primarily the creation of a tidal or tidalmean object, fitting of the weighted regression models with <code><a href="#topic+wrtds">wrtds</a></code>, extraction of fitted values from the interpolation grids using <code><a href="#topic+respred">respred</a></code>, and normalization of the fitted values from the interpolation grid using <code><a href="#topic+resnorm">resnorm</a></code>.  The format of the input should be a <code><a href="base.html#topic+data.frame">data.frame</a></code> with response variable observations as rows and the first four columns as date, response variable, salinity/flow, and detection limits.  The order of the columns may vary provided the order of each of the four critical variables is specified by the <code>ind</code> argument that is passed to the <code><a href="#topic+tidal">tidal</a></code> or <code><a href="#topic+tidalmean">tidalmean</a></code> function.  The response variable data are also assumed to be in log-space, otherwise use <code>reslog = FALSE</code> which is also passed to the <code><a href="#topic+tidal">tidal</a></code> or <code><a href="#topic+tidalmean">tidalmean</a></code> function.  The dataset described in <code><a href="#topic+chldat">chldat</a></code> is an example of the correct format.  
</p>
<p>For quantile models, the default conditional quantile that is predicted is the median (<code>tau = 0.5</code>, passed to the <code><a href="#topic+wrtds">wrtds</a></code> function).  Numerous other arguments affect the output and the default parameters may not be appropriate for all scenarios.  Arguments used by other functions can be specified explicitly with the initial call.  The documentation for the functions under &lsquo;see also&rsquo; should be consulted for available arguments, as well as the examples that illustrate common changes to the default values.
</p>


<h3>Value</h3>

<p>A tidal object with predicted and normalized response variable predictions, attributes updated accordingly.
</p>


<h3>See Also</h3>

<p>See the help files for <code><a href="#topic+tidal">tidal</a></code>, <code><a href="#topic+tidalmean">tidalmean</a></code>, <code><a href="#topic+wrtds">wrtds</a></code>, <code><a href="#topic+getwts">getwts</a></code>, <code><a href="#topic+respred">respred</a></code>, and <code><a href="#topic+resnorm">resnorm</a></code> for arguments that can be passed to this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load data
data(chldat)

## fit the model and get predicted/normalized data for response variable
# default median fit
# grids predicted across salinity range with ten values
res &lt;- modfit(chldat)

# for mean models
res &lt;- modfit(chldat, resp_type = 'mean')

## fit different quantiles and smaller interpolation grid
res &lt;- modfit(chldat, tau = c(0.2, 0.8), flo_div = 5)

## fit with different window widths
# half-window widths of one day, five years, and 0.3 salinity
res &lt;- modfit(chldat, wins = list(1, 5, 0.3))

## suppress console output
res &lt;- modfit(chldat, trace = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='nobsplot'>Plot number of observations in a WRTDS interpolation grid</h2><span id='topic+nobsplot'></span><span id='topic+nobsplot.default'></span><span id='topic+nobsplot.tidal'></span><span id='topic+nobsplot.tidalmean'></span>

<h3>Description</h3>

<p>Plot number of observations for each point in a WRTDS interpolation grid.  This is a diagnostic plot to identify sample size for each unique location in the domain of the time series that is considered during model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nobsplot(dat_in, ...)

## Default S3 method:
nobsplot(
  dat_in,
  month = "all",
  years = NULL,
  col_vec = NULL,
  allflo = TRUE,
  ncol = NULL,
  grids = FALSE,
  pretty = TRUE,
  ...
)

## S3 method for class 'tidal'
nobsplot(dat_in, ...)

## S3 method for class 'tidalmean'
nobsplot(dat_in, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobsplot_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="nobsplot_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="nobsplot_+3A_month">month</code></td>
<td>
<p>numeric indicating months to plot or chr string 'all' to indicate all months with no plot facets</p>
</td></tr>
<tr><td><code id="nobsplot_+3A_years">years</code></td>
<td>
<p>numeric vector of years to plot, defaults to all</p>
</td></tr>
<tr><td><code id="nobsplot_+3A_col_vec">col_vec</code></td>
<td>
<p>chr string of plot colors to use, passed to <code><a href="#topic+gradcols">gradcols</a></code> and <code><a href="ggplot2.html#topic+scale_fill_gradientn">scale_fill_gradientn</a></code> for grid shading.  Any color palette from RColorBrewer can be used as a named input. Palettes from grDevices must be supplied as the returned string of colors for each palette.</p>
</td></tr>
<tr><td><code id="nobsplot_+3A_allflo">allflo</code></td>
<td>
<p>logical indicating if the salinity/flow values for plotting are limited to the fifth and ninety-fifth percentile of observed values for the month of interest</p>
</td></tr>
<tr><td><code id="nobsplot_+3A_ncol">ncol</code></td>
<td>
<p>numeric argument passed to <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> indicating number of facet columns</p>
</td></tr>
<tr><td><code id="nobsplot_+3A_grids">grids</code></td>
<td>
<p>logical indicating if grid lines are present</p>
</td></tr>
<tr><td><code id="nobsplot_+3A_pretty">pretty</code></td>
<td>
<p>logical indicating if my subjective idea of plot aesthetics is applied, otherwise the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> default themes are used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plots can be used sample size as an indication of model fit for each unique location in the domain space of the time series.  The plots show grids of the number of observations with weights greater than zero for each unique date and salinity/flow combination.  The <code>obs</code> attribute in the <code>tidal</code> or <code>tidalmean</code> object is created during model fitting and has the same dimensions as the interpolation grid.  Each row is a unique date in the original dataset and each column is a salinity/flow value used to fit each regression (i.e., values in the <code>flo_grd</code> attribute). In general, low points in the grid may indicate locations in the time series where insufficient data could affect model fit.
</p>
<p>Unlike <code><a href="#topic+gridplot">gridplot</a></code>, interpolation of the grids for a smoother appearance is not allowed because the objective is to identify specific locations with low sample size.  For the former function, the objective is to characterize general trends over time rather values at specific locations.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be further modified
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wtsplot">wtsplot</a></code> for an alternative to evaluating weights with different window width combinations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load a fitted tidal object
data(tidfit)

## default plot
nobsplot(tidfit)

## no facets, all months
nobsplot(tidfit)

## change the defaults
nobsplot(tidfit, tau = c(0.1), month = c(3, 6, 9, 12), 
 col_vec = c('red', 'blue', 'green'), flo_fac = 1)
 
## plot a tidalmean object
data(tidfitmean)

nobsplot(tidfitmean)


## End(Not run)
</code></pre>

<hr>
<h2 id='obsplot'>Plot observed response variable and salinity/flow data</h2><span id='topic+obsplot'></span><span id='topic+obsplot.default'></span><span id='topic+obsplot.tidal'></span><span id='topic+obsplot.tidalmean'></span>

<h3>Description</h3>

<p>Plot observed response variable and salinity/flow time series from a tidal object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsplot(dat_in, ...)

## Default S3 method:
obsplot(
  dat_in,
  lines = TRUE,
  logspace = TRUE,
  dt_rng = NULL,
  pretty = TRUE,
  col = "black",
  lwd = 1,
  size = 2,
  alpha = 1,
  ...
)

## S3 method for class 'tidal'
obsplot(dat_in, ...)

## S3 method for class 'tidalmean'
obsplot(dat_in, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obsplot_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="obsplot_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="ggplot2.html#topic+geom_line">geom_line</a></code></p>
</td></tr>
<tr><td><code id="obsplot_+3A_lines">lines</code></td>
<td>
<p>logical indicating if a line plot is used, otherwise points</p>
</td></tr>
<tr><td><code id="obsplot_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating if plots are in log space</p>
</td></tr>
<tr><td><code id="obsplot_+3A_dt_rng">dt_rng</code></td>
<td>
<p>Optional chr string indicating the date range of the plot. Must be two values in the format 'YYYY-mm-dd' which is passed to <code><a href="base.html#topic+as.Date">as.Date</a></code>.</p>
</td></tr>
<tr><td><code id="obsplot_+3A_pretty">pretty</code></td>
<td>
<p>logical indicating if my subjective idea of plot aesthetics is applied, otherwise the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> default themes are used</p>
</td></tr>
<tr><td><code id="obsplot_+3A_col">col</code></td>
<td>
<p>chr string of plot color to use</p>
</td></tr>
<tr><td><code id="obsplot_+3A_lwd">lwd</code></td>
<td>
<p>numeric value indicating width of lines</p>
</td></tr>
<tr><td><code id="obsplot_+3A_size">size</code></td>
<td>
<p>numeric value indicating size of points</p>
</td></tr>
<tr><td><code id="obsplot_+3A_alpha">alpha</code></td>
<td>
<p>numeric value indicating transparency of points or lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be further modified
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitplot">fitplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load a fitted tidal object
data(tidfit)

## plot using defaults
obsplot(tidfit)
 
## changing default
obsplot(tidfit, alpha = 0.5, size = 4, col = 'blue', lines = FALSE)

## plot a tidalmean object
data(tidfitmean)

obsplot(tidfitmean)
</code></pre>

<hr>
<h2 id='prdnrmplot'>Plot combined predicted and normalized results from a tidal object</h2><span id='topic+prdnrmplot'></span><span id='topic+prdnrmplot.tidal'></span><span id='topic+prdnrmplot.tidalmean'></span>

<h3>Description</h3>

<p>Plot combined predicted and normalized results from a tidal object to evaluate the influence of salinity or flow changes on the response variable. The plot is similar to that produced by <code><a href="#topic+fitplot">fitplot</a></code> except predicted values are shown as points and observed values are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prdnrmplot(dat_in, ...)

## S3 method for class 'tidal'
prdnrmplot(
  dat_in,
  tau = NULL,
  annuals = TRUE,
  logspace = TRUE,
  dt_rng = NULL,
  col_vec = NULL,
  lwd = 1,
  size = 2,
  alpha = 1,
  min_mo = 9,
  mo_strt = 10,
  pretty = TRUE,
  plot = TRUE,
  ...
)

## S3 method for class 'tidalmean'
prdnrmplot(
  dat_in,
  annuals = TRUE,
  logspace = TRUE,
  dt_rng = NULL,
  col_vec = NULL,
  lwd = 1,
  size = 2,
  alpha = 1,
  min_mo = 9,
  mo_strt = 10,
  pretty = TRUE,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prdnrmplot_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="ggplot2.html#topic+geom_line">geom_line</a></code></p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_tau">tau</code></td>
<td>
<p>numeric vector of quantiles to plot, defaults to all in object if not supplied</p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_annuals">annuals</code></td>
<td>
<p>logical indicating if plots are annual aggregations of results</p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating if plots are in log space</p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_dt_rng">dt_rng</code></td>
<td>
<p>Optional chr string indicating the date range of the plot. Must be two values in the format 'YYYY-mm-dd' which is passed to <code><a href="base.html#topic+as.Date">as.Date</a></code>.</p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_col_vec">col_vec</code></td>
<td>
<p>chr string of plot colors to use, passed to <code><a href="#topic+gradcols">gradcols</a></code>.  Any color palette from RColorBrewer can be used as a named input. Palettes from grDevices must be supplied as the returned string of colors for each palette.</p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_lwd">lwd</code></td>
<td>
<p>numeric value indicating width of lines</p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_size">size</code></td>
<td>
<p>numeric value indicating size of points</p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_alpha">alpha</code></td>
<td>
<p>numeric value indicating transparency of points or lines</p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_min_mo">min_mo</code></td>
<td>
<p>numeric value from one to twelve indicating the minimum number of months with observations for averaging by years, applies only if <code>annuals = TRUE</code>.  See <code><a href="#topic+annual_agg">annual_agg</a></code>.</p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_mo_strt">mo_strt</code></td>
<td>
<p>numeric indicating month to start aggregation years, defaults to October for USGS water year from October to September, applies only if <code>annuals = TRUE</code>.  See <code><a href="#topic+annual_agg">annual_agg</a></code>.</p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_pretty">pretty</code></td>
<td>
<p>logical indicating if my subjective idea of plot aesthetics is applied, otherwise the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> default themes are used</p>
</td></tr>
<tr><td><code id="prdnrmplot_+3A_plot">plot</code></td>
<td>
<p>logical if plot is returned, otherwise data used in the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be further modified
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitplot">fitplot</a></code>, <code><a href="#topic+sliceplot">sliceplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load a fitted tidal object
data(tidfit)

## plot using defaults
prdnrmplot(tidfit)

## get the same plot but use default ggplot settings
prdnrmplot(tidfit, pretty = FALSE)

## plot in log space
prdnrmplot(tidfit, logspace = TRUE)

## plot specific quantiles
prdnrmplot(tidfit, tau = c(0.1, 0.9))

## plot the normalized predictions
prdnrmplot(tidfit, predicted = FALSE)

## plot as monthly values
prdnrmplot(tidfit, annuals = FALSE) 

## format the x-axis is using annual aggregations
library(ggplot2)

prdnrmplot(tidfit, annual = TRUE) + 
 scale_x_date(limits = as.Date(c('2000-01-01', '2012-01-01')))

## modify the plot as needed using ggplot scales, etc.
prdnrmplot(tidfit, pretty = FALSE, linetype = 'dashed') + 
 theme_classic() + 
 scale_y_continuous(
   'Chlorophyll', 
   limits = c(0, 50)
   ) +
 scale_colour_manual( 
   '', 
   labels = c('lo', 'md', 'hi'), 
   values = c('red', 'green', 'blue'), 
   guide = guide_legend(reverse = TRUE)
   ) 
 
 ## plot a tidalmean object
 data(tidfitmean)
 
 prdnrmplot(tidfitmean)
 
</code></pre>

<hr>
<h2 id='resnorm'>Get salinity/flow normalized WRTDS predictions from interpolation grids</h2><span id='topic+resnorm'></span><span id='topic+resnorm.tidal'></span><span id='topic+resnorm.tidalmean'></span>

<h3>Description</h3>

<p>Get normalized model predictions from WRTDS to remove the effect of salinity/flow on the response variable.  Predicted values in the interpolation grids are averaged across dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resnorm(dat_in, ...)

## S3 method for class 'tidal'
resnorm(dat_in, trace = TRUE, ...)

## S3 method for class 'tidalmean'
resnorm(dat_in, trace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resnorm_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="resnorm_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="resnorm_+3A_trace">trace</code></td>
<td>
<p>logical indicating if progress is shown in the console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used after <code>wrtds</code> to normalize predicted values of the response variable from the interpolation grid for each model.  The normalized values are based on the average of all predicted estimates across the range of salinity/flow values that have occurred on the same date throughout each year.  For example, normalized values for July 2000 are the mean predicted response at that date using the observed salinity/flow values that occur in July of all years.  The normalized values allow an interpretation of trends in the response variable that are independent of changes in salinity or freshwater inputs.
</p>


<h3>Value</h3>

<p>Appends columns to the data.frame for normalized values.  For, tidal objects, columns are named starting with the prefix &lsquo;norm&rsquo;, e.g., &lsquo;norm0.5&rsquo; are the normalized values for the fit through the median.  For tidalmean objects, columns are appended for the log-transformed and back-transformed normalized values, named &lsquo;norm&rsquo; and &lsquo;bt_norm&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##

# load a tidal object
data(tidobj)

# get flow-normalized values for each quantile
res &lt;- resnorm(tidobj)

# load a tidalmean object
data(tidobjmean)

# get flow-normalized values
res &lt;- resnorm(tidobjmean)

## End(Not run)
</code></pre>

<hr>
<h2 id='respred'>Get WRTDS predictions from interpolation grids</h2><span id='topic+respred'></span><span id='topic+respred.tidal'></span><span id='topic+respred.tidalmean'></span>

<h3>Description</h3>

<p>Get model predictions from WRTDS using linear interpolation of values in grids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>respred(dat_in, ...)

## S3 method for class 'tidal'
respred(dat_in, dat_pred = NULL, trace = TRUE, omit = TRUE, ...)

## S3 method for class 'tidalmean'
respred(dat_in, dat_pred = NULL, trace = TRUE, omit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="respred_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="respred_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="respred_+3A_dat_pred">dat_pred</code></td>
<td>
<p>optional data to predict using the interpolation grids in dat_in, defaults to observed data in <code>dat_in</code> if not supplied, see details</p>
</td></tr>
<tr><td><code id="respred_+3A_trace">trace</code></td>
<td>
<p>logical indicating if progress is shown in the console</p>
</td></tr>
<tr><td><code id="respred_+3A_omit">omit</code></td>
<td>
<p>logical indicating if observations in <code>dat_pred</code> that are outside of the range of data used to fit the model are removed, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used after <code>wrtds</code> to estimate predicted values of the response variable from the interpolation grids.  The estimated values are based on a bilinear interpolation of the four predicted response values at two salinity/flow and two date values nearest to the observed salinity/flow and date values to predict.  
</p>
<p>Data for <code>dat_pred</code> must be a data frame of two columns for date and flow variables (<code>date</code> and <code>numeric</code> objects).  The columns must be named 'date' and 'flo'.  Values that are outside of the range of data used to fit the model are removed with a warning.  It is assumed that the flow variable is not scaled (i.e., raw data) as in a <code>tidal</code> or <code>tidalmean</code> object. The dimensions of the output data are modified to match <code>dat_pred</code> if observations are removed.  The <code>omit</code> argument should not equal <code>FALSE</code> and is included only for use with <code><a href="#topic+wrtdscv">wrtdscv</a></code> to evaluate folds of the original dataset.
</p>


<h3>Value</h3>

<p>Appends columns to the input data.frame for the predicted values.  For tidal objects, columns are named starting with the prefix &lsquo;fit&rsquo;, e.g., &lsquo;fit0.5&rsquo; are the predicted values for the fit through the median.  For tidalmean objects, predicted values are appended for the mean model in log-space and the observed values from the back-transformed grids.  Columns are named as &lsquo;fits&rsquo; and &lsquo;bt_fits&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##

# load a tidal object
data(tidobj)

# get fitted values for each quantile
res &lt;- respred(tidobj)

# load a tidalmean object
data(tidobjmean)

# get predicted values
res &lt;- respred(tidobjmean)

</code></pre>

<hr>
<h2 id='resscls'>Get the scale parameters for predicted values</h2><span id='topic+resscls'></span><span id='topic+resscls.tidalmean'></span>

<h3>Description</h3>

<p>Get the scale parameters for predicted values of the response variable, only applies to <code><a href="#topic+tidalmean">tidalmean</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resscls(dat_in, ...)

## S3 method for class 'tidalmean'
resscls(dat_in, dat_pred = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resscls_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidalmean object</p>
</td></tr>
<tr><td><code id="resscls_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="resscls_+3A_dat_pred">dat_pred</code></td>
<td>
<p>optional data to predict using the interpolation grids in dat_in, defaults to observed data in <code>dat_in</code> if not supplied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used after <code>wrtds</code> to get scale parameters for predicted values of the response variable from the interpolation grids.  The values are based on a bilinear interpolation of the four predicted response values at two salinity/flow and two date values nearest to the observed salinity/flow and date values to predict.
</p>


<h3>Value</h3>

<p>Appends columns to the data.frame for the associated scale value for the predicted values.  A column is appended to the <code>dat_in</code> object, named &lsquo;scls&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##

# load a tidalmean object
data(tidobjmean)

# get predicted values
res &lt;- resscls(tidobjmean)

</code></pre>

<hr>
<h2 id='samp_sim'>Sample a daily time series at a set frequency</h2><span id='topic+samp_sim'></span>

<h3>Description</h3>

<p>Sample a daily water quality time series at a set monthly frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samp_sim(
  dat_in,
  unit = "month",
  irregular = TRUE,
  missper = 0,
  blck = 1,
  blckper = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samp_sim_+3A_dat_in">dat_in</code></td>
<td>
<p>input <code><a href="base.html#topic+data.frame">data.frame</a></code> that is returned from <code><a href="#topic+lnres_sim">lnres_sim</a></code> or <code><a href="#topic+all_sims">all_sims</a></code></p>
</td></tr>
<tr><td><code id="samp_sim_+3A_unit">unit</code></td>
<td>
<p>chr string indicating sampling unit, must be year, quarter, month, week, or yday for equivalent lubridate function</p>
</td></tr>
<tr><td><code id="samp_sim_+3A_irregular">irregular</code></td>
<td>
<p>logical indicating if monthly sampling is done randomly within each <code>unit</code>, otherwise the first value is returned</p>
</td></tr>
<tr><td><code id="samp_sim_+3A_missper">missper</code></td>
<td>
<p>numeric from 0-1 indicating percentage of observations used for test dataset</p>
</td></tr>
<tr><td><code id="samp_sim_+3A_blck">blck</code></td>
<td>
<p>numeric indicating block size for resampling test dataset, see details</p>
</td></tr>
<tr><td><code id="samp_sim_+3A_blckper">blckper</code></td>
<td>
<p>logical indicating if the value passed to <code>blck</code> is a proportion of <code>missper</code>, i.e., blocks are to be sized as a percentage of the total size of the missing data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended for sampling a simulated daily time series of water quality that is returned by <code><a href="#topic+lnres_sim">lnres_sim</a></code> or <code><a href="#topic+all_sims">all_sims</a></code>.
</p>
<p>The <code>missper</code> argument is used to create a test dataset as a proportion of all observations in the sub-sampled output dataset.  The test dataset is created with random block sampling appropriate for time series.  Block sampling of the output dataset occurs until the number of unique observations is equal to the percentage defined by <code>missper</code>.  Overlap of blocks are not doubly considered towards the observation counts to satisfy <code>missper</code>, i.e., sets of continuous observations longer than <code>blck</code> can be returned because of sampling overlap.  Setting <code>blck = 1</code> and <code>blockper = FALSE</code> is completely random sampling for missing data.  Values for <code>blck</code> must be 1 or greater if <code>blockper = FALSE</code> and 1 or less if <code>blckper = T</code>.  If <code>blck = 1</code> and <code>blckper = T</code>, the missing data will be one continuous block.
</p>


<h3>Value</h3>

<p>Original data frame with rows subset based on number of desired monthly samples.  If <code>missper &gt; 0</code>, a list is returned where the first element is the index values for the test dataset and the second is the complete subsampled dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lnres_sim">lnres_sim</a></code>, <code><a href="#topic+all_sims">all_sims</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## example data
data(daydat)

## simulate
tosamp &lt;- all_sims(daydat)

## sample
samp_sim(tosamp)

## sample and create test dataset
# test dataset is 30% size of monthly subsample using block sampling with size = 4
samp_sim(tosamp, missper = 0.3, blck = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='seasplot'>Plot seasonal trends across all years</h2><span id='topic+seasplot'></span><span id='topic+seasplot.tidal'></span><span id='topic+seasplot.tidalmean'></span>

<h3>Description</h3>

<p>Plot seasonal trends by combining annual data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasplot(dat_in, ...)

## S3 method for class 'tidal'
seasplot(
  dat_in,
  tau = NULL,
  predicted = TRUE,
  span = 0.4,
  lwd = 1,
  size = 2,
  alpha = 1,
  col_vec = NULL,
  grids = TRUE,
  logspace = TRUE,
  ...
)

## S3 method for class 'tidalmean'
seasplot(
  dat_in,
  predicted = TRUE,
  span = 0.4,
  lwd = 1,
  size = 2,
  alpha = 1,
  col_vec = NULL,
  grids = TRUE,
  logspace = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasplot_+3A_dat_in">dat_in</code></td>
<td>
<p>Input data object</p>
</td></tr>
<tr><td><code id="seasplot_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="seasplot_+3A_tau">tau</code></td>
<td>
<p>numeric of quantile to plot</p>
</td></tr>
<tr><td><code id="seasplot_+3A_predicted">predicted</code></td>
<td>
<p>logical indicating if seasonal smooth is based on model predictions, default <code>TRUE</code>, otherwise the smooth is based on flow-normalized predictions</p>
</td></tr>
<tr><td><code id="seasplot_+3A_span">span</code></td>
<td>
<p>numeric indicating the smoothing parameter for the loess fit, passed to <code><a href="ggplot2.html#topic+stat_smooth">stat_smooth</a></code></p>
</td></tr>
<tr><td><code id="seasplot_+3A_lwd">lwd</code></td>
<td>
<p>numeric value indicating width of lines</p>
</td></tr>
<tr><td><code id="seasplot_+3A_size">size</code></td>
<td>
<p>numeric value indicating size of points</p>
</td></tr>
<tr><td><code id="seasplot_+3A_alpha">alpha</code></td>
<td>
<p>numeric value indicating transparency of points or lines</p>
</td></tr>
<tr><td><code id="seasplot_+3A_col_vec">col_vec</code></td>
<td>
<p>chr string of plot colors to use, passed to <code><a href="#topic+gradcols">gradcols</a></code>.  Any color palette from RColorBrewer can be used as a named input. Palettes from grDevices must be supplied as the returned string of colors for each palette.</p>
</td></tr>
<tr><td><code id="seasplot_+3A_grids">grids</code></td>
<td>
<p>logical indicating if grid lines are present</p>
</td></tr>
<tr><td><code id="seasplot_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating if plots are in log space</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Seasonal variation across all years can be viewed by showing the observed annual data on a common y-axis.  The year value is removed from the results such that the y-axis shows only the day of the year.  A simple loess (locally estimated) polynomial smooth is added to show the seasonal trend in the results, where the smoother is fit through the model results for the observed data.  The fit can be smoothed through the model predictions or the flow-normalized predictions, neither of which are shown on the plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dynaplot">dynaplot</a></code>, <code><a href="#topic+fitmoplot">fitmoplot</a></code>, <code><a href="#topic+gridplot">gridplot</a></code>, and <code><a href="#topic+sliceplot">sliceplot</a></code> produce similar graphics except variation in the same month across years is emphasized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a fitted tidal object
data(tidfit)

# plot using defaults
# defaults to all quantiles for tidal object
seasplot(tidfit)

# tidalmean object
seasplot(tidfitmean)
</code></pre>

<hr>
<h2 id='seasyrplot'>Plot seasonal model response by years</h2><span id='topic+seasyrplot'></span><span id='topic+seasyrplot.tidal'></span><span id='topic+seasyrplot.tidalmean'></span>

<h3>Description</h3>

<p>Plot seasonal model response by years on a common axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasyrplot(dat_in, ...)

## S3 method for class 'tidal'
seasyrplot(
  dat_in,
  years = NULL,
  tau = NULL,
  predicted = TRUE,
  logspace = TRUE,
  col_vec = NULL,
  grids = TRUE,
  pretty = TRUE,
  lwd = 0.5,
  alpha = 1,
  ...
)

## S3 method for class 'tidalmean'
seasyrplot(
  dat_in,
  years = NULL,
  tau = NULL,
  predicted = TRUE,
  logspace = TRUE,
  col_vec = NULL,
  grids = TRUE,
  pretty = TRUE,
  lwd = 0.5,
  alpha = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasyrplot_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="seasyrplot_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="seasyrplot_+3A_years">years</code></td>
<td>
<p>numeric vector of years to plot</p>
</td></tr>
<tr><td><code id="seasyrplot_+3A_tau">tau</code></td>
<td>
<p>numeric vector of quantiles to plot, defaults to all in object if not supplied</p>
</td></tr>
<tr><td><code id="seasyrplot_+3A_predicted">predicted</code></td>
<td>
<p>logical indicating if standard predicted values are plotted, default <code>TRUE</code>, otherwise normalized predictions are plotted</p>
</td></tr>
<tr><td><code id="seasyrplot_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating if plots are in log space</p>
</td></tr>
<tr><td><code id="seasyrplot_+3A_col_vec">col_vec</code></td>
<td>
<p>chr string of plot colors to use, passed to <code><a href="#topic+gradcols">gradcols</a></code>.  Any color palette from RColorBrewer can be used as a named input. Palettes from grDevices must be supplied as the returned string of colors for each palette.</p>
</td></tr>
<tr><td><code id="seasyrplot_+3A_grids">grids</code></td>
<td>
<p>logical indicating if grid lines are present</p>
</td></tr>
<tr><td><code id="seasyrplot_+3A_pretty">pretty</code></td>
<td>
<p>logical indicating if my subjective idea of plot aesthetics is applied, otherwise the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> default themes are used</p>
</td></tr>
<tr><td><code id="seasyrplot_+3A_lwd">lwd</code></td>
<td>
<p>numeric value indicating width of lines</p>
</td></tr>
<tr><td><code id="seasyrplot_+3A_alpha">alpha</code></td>
<td>
<p>numeric value indicating transparency of points or lines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot is similar to that produced by <code><a href="#topic+seasplot">seasplot</a></code> except the model estimates are plotted for each year as connected lines, as compared to loess lines fit to the model results.  <code><a href="#topic+seasyrplot">seasyrplot</a></code> is also similar to <code><a href="#topic+sliceplot">sliceplot</a></code> except the x-axis and legend grouping variable are flipped. This is useful for evaluating between-year differences in seasonal trends.
</p>
<p>Multiple predictions per month are averaged for a smoother plot. 
</p>
<p>Note that the year variable used for color mapping is treated as a continuous variable although it is an integer by definition.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be further modified
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seasplot">seasplot</a></code>, <code><a href="#topic+sliceplot">sliceplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load a fitted tidal object
data(tidfit)

# plot using defaults
seasyrplot(tidfit)

# get the same plot but use default ggplot settings
seasyrplot(tidfit, pretty = FALSE)

# plot specific quantiles
seasyrplot(tidfit, tau = c(0.9))

# plot the normalized predictions
seasyrplot(tidfit, predicted = FALSE)

# modify the plot as needed using ggplot scales, etc.

library(ggplot2)

seasyrplot(tidfit, pretty = FALSE, linetype = 'dashed') + 
 theme_classic() + 
 scale_y_continuous(
   'Chlorophyll', 
   limits = c(0, 5)
   )
   
# plot a tidalmean object
data(tidfitmean)

seasyrplot(tidfitmean)    
</code></pre>

<hr>
<h2 id='sliceplot'>Plot time slices within a tidal object</h2><span id='topic+sliceplot'></span><span id='topic+sliceplot.tidal'></span><span id='topic+sliceplot.tidalmean'></span>

<h3>Description</h3>

<p>Plot time slices within a tidal object to view response variable observations, predictions, and normalized results at regular annual intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sliceplot(dat_in, ...)

## S3 method for class 'tidal'
sliceplot(
  dat_in,
  slices = c(1, 7),
  tau = NULL,
  dt_rng = NULL,
  col_vec = NULL,
  predicted = TRUE,
  logspace = TRUE,
  grids = TRUE,
  pretty = TRUE,
  lwd = 1,
  size = 2,
  alpha = 1,
  ...
)

## S3 method for class 'tidalmean'
sliceplot(
  dat_in,
  slices = c(1, 7),
  predicted = TRUE,
  dt_rng = NULL,
  col_vec = NULL,
  logspace = TRUE,
  grids = TRUE,
  pretty = TRUE,
  lwd = 1,
  size = 2,
  alpha = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sliceplot_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_slices">slices</code></td>
<td>
<p>numeric vector of calender months to plot, i.e., 1 - 12</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_tau">tau</code></td>
<td>
<p>numeric vector of quantile to plot.  The function will plot the 'middle' quantile if none is specified, e.g., if 0.2, 0.3, and 0.4 are present in the fitted model object then 0.3 will be plotted.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_dt_rng">dt_rng</code></td>
<td>
<p>Optional chr string indicating the date range of the plot. Must be two values in the format 'YYYY-mm-dd' which is passed to <code><a href="base.html#topic+as.Date">as.Date</a></code>.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_col_vec">col_vec</code></td>
<td>
<p>chr string of plot colors to use, passed to <code><a href="#topic+gradcols">gradcols</a></code>.  Any color palette from RColorBrewer can be used as a named input. Palettes from grDevices must be supplied as the returned string of colors for each palette.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_predicted">predicted</code></td>
<td>
<p>logical indicating if standard predicted values are plotted, default <code>TRUE</code>, otherwise normalized predictions are plotted</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating if plots are in log space</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_grids">grids</code></td>
<td>
<p>logical indicating if grid lines are present</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_pretty">pretty</code></td>
<td>
<p>logical indicating if my subjective idea of plot aesthetics is applied, otherwise the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> default themes are used</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_lwd">lwd</code></td>
<td>
<p>numeric value indicating width of lines</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_size">size</code></td>
<td>
<p>numeric value indicating size of points</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_alpha">alpha</code></td>
<td>
<p>numeric value indicating transparency of points or lines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a modification of <code><a href="#topic+fitplot">fitplot</a></code> that can be used to plot selected time slices from the results of a fitted <code><a href="#topic+tidal">tidal</a></code> object.  For example, all results for a particular month across all years can be viewed.  This is useful for evaluating between-year differences in results for constant season.  Only one quantile fit can be shown per plot because the grouping variable is mapped to the slices.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be further modified
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitplot">fitplot</a></code>, <code><a href="#topic+prdnrmplot">prdnrmplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load a fitted tidal object
data(tidfit)

# plot using defaults
sliceplot(tidfit)

# get different months - march and september
sliceplot(tidfit, slices = c(3, 9))

# normalized predictions, 10th percentile
sliceplot(tidfit, tau = 0.1, predicted = FALSE)

# normalized values all months, change line aesthetics, log-space, 90th 
# add title
library(ggplot2)
sliceplot(tidfit, 
 slices = 1:12, 
 size = 1.5, 
 tau = 0.9, 
 alpha = 0.6, 
 predicted = FALSE, 
 logspace = TRUE
) + 
ggtitle('Normalized predictions for all months, 90th percentile')

 ## plot a tidalmean object
 data(tidfitmean)
 
 sliceplot(tidfitmean)
</code></pre>

<hr>
<h2 id='tidal'>Create a tidal class object</h2><span id='topic+tidal'></span>

<h3>Description</h3>

<p>Prepare water quality data for weighted regression by creating a tidal class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidal(
  dat_in,
  ind = c(1, 2, 3, 4),
  reslab = NULL,
  flolab = NULL,
  reslog = TRUE,
  rm_miss = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidal_+3A_dat_in">dat_in</code></td>
<td>
<p>Input data frame for a water quality time series with four columns for date (Y-m-d format), response variable, salinity/flow, and detection limit for left-censored data</p>
</td></tr>
<tr><td><code id="tidal_+3A_ind">ind</code></td>
<td>
<p>four element numeric vector indicating column positions of date, response variable, salinity/flow, and detection limit of input data frame</p>
</td></tr>
<tr><td><code id="tidal_+3A_reslab">reslab</code></td>
<td>
<p>character string or expression for labelling the response variable in plots, defaults to log-chlorophyll in ug/L</p>
</td></tr>
<tr><td><code id="tidal_+3A_flolab">flolab</code></td>
<td>
<p>character string or expression for labelling the flow variable in plots, defaults to Salinity</p>
</td></tr>
<tr><td><code id="tidal_+3A_reslog">reslog</code></td>
<td>
<p>logical indicating if the response variable is already in log-space, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="tidal_+3A_rm_miss">rm_miss</code></td>
<td>
<p>logical indicating if missing observations in the input data are removed</p>
</td></tr>
<tr><td><code id="tidal_+3A_...">...</code></td>
<td>
<p>arguments passed from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper to <code><a href="base.html#topic+structure">structure</a></code> that is used to create a tidal object for use with weighted regression in tidal waters. Input data should be a four-column <code><a href="base.html#topic+data.frame">data.frame</a></code> with date, response variable, salinity/flow data, and detection limit for each observation of the response.  The response variable is assumed to be log-transformed, otherwise use <code>reslog = FALSE</code>.  Salinity data can be provided as fraction of freshwater or as parts per thousand.  The limit column can be entered as a sufficiently small number if all values are above the detection limit or no limit exists.  The current implementation of weighted regression for tidal waters only handles left-censored data.  Missing observations are also removed.
</p>


<h3>Value</h3>

<p>A tidal object as a data frame and attributes.  The data frame has columns ordered as date, response variable, salinity/flow (rescaled to 0, 1 range), detection limit, logical for detection limit, day number, month, year, and decimal time.  The attributes are as follows:
</p>

<dl>
<dt><code>names</code></dt><dd><p>Column names of the data frame</p>
</dd>
<dt><code>row.names</code></dt><dd><p>Row names of the data frame</p>
</dd>
<dt><code>class</code></dt><dd><p>Class of the object</p>
</dd>
<dt><code>half_wins</code></dt><dd><p>List of numeric values used for half-window widths for model fitting, in the same order as the wt_vars argument passed to <code><a href="#topic+getwts">getwts</a></code>. Initially will be NULL if <code>wrtds</code> has not been used.</p>
</dd>
<dt><code>fits</code></dt><dd><p>List of matrices with fits for the WRTDS interpolation grid, defaults to one list for the median quantile.  Initially will be <code>NULL</code> if <code><a href="#topic+wrtds">wrtds</a></code> has not been used.</p>
</dd>
<dt><code>predonobs</code></dt><dd><p>A <code>data.frame</code> of predictions using the observed data that were used to fit the model.  This is required for <code>wrtdsperf</code> if a novel dataset is used for predictions after fitting the model. Initially will be NULL if <code>respred</code> has not been used.</p>
</dd>
<dt><code>flo_grd</code></dt><dd><p>Numeric vector of salinity/flow values that was used for the interpolation grids</p>
</dd>
<dt><code>floobs_rng</code></dt><dd><p>Two element vector indicating the salinity/flow range of the observed data</p>
</dd>
<dt><code>nobs</code></dt><dd><p>List with one matrix showing the number of weights greater than zero for each date and salinity/flow combination used to create the fit matrices in <code>fits</code>.  Number of observations are the same for each quantile model.  Initially will be <code>NULL</code> if <code><a href="#topic+wrtds">wrtds</a></code> has not been used.</p>
</dd>
<dt><code>reslab</code></dt><dd><p>expression or character string for response variable label in plots</p>
</dd>
<dt><code>flolab</code></dt><dd><p>expression or character string for flow variable label in plots</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## raw data

data(chldat)

## format
chldat &lt;- tidal(chldat)

</code></pre>

<hr>
<h2 id='tidalmean'>Create a tidalmean class object</h2><span id='topic+tidalmean'></span>

<h3>Description</h3>

<p>Prepare water quality data for weighted regression for the mean response by creating a tidalmean class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidalmean(
  dat_in,
  ind = c(1, 2, 3, 4),
  reslab = NULL,
  flolab = NULL,
  reslog = TRUE,
  rm_miss = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidalmean_+3A_dat_in">dat_in</code></td>
<td>
<p>Input data frame for a water quality time series with four columns for date (Y-m-d format), response variable, salinity/flow, and detection limit for left-censored data</p>
</td></tr>
<tr><td><code id="tidalmean_+3A_ind">ind</code></td>
<td>
<p>four element numeric vector indicating column positions of date, response variable, salinity/flow, and detection limit of input data frame</p>
</td></tr>
<tr><td><code id="tidalmean_+3A_reslab">reslab</code></td>
<td>
<p>character string or expression for labelling the response variable in plots, defaults to log-chlorophyll in ug/L</p>
</td></tr>
<tr><td><code id="tidalmean_+3A_flolab">flolab</code></td>
<td>
<p>character string or expression for labelling the flow variable in plots, defaults to Salinity</p>
</td></tr>
<tr><td><code id="tidalmean_+3A_reslog">reslog</code></td>
<td>
<p>logical indicating if input response variable is already in log-space, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="tidalmean_+3A_rm_miss">rm_miss</code></td>
<td>
<p>logical indicating if missing observations in the input data are removed</p>
</td></tr>
<tr><td><code id="tidalmean_+3A_...">...</code></td>
<td>
<p>arguments passed from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper to <code><a href="base.html#topic+structure">structure</a></code> that is used to create a tidalmean object for use with weighted regression in tidal waters, specifically to model the mean response as compared to a conditional quantile. Input data should be a four-column <code><a href="base.html#topic+data.frame">data.frame</a></code> with date, response variable, salinity/flow data, and detection limit for each observation of the response.  The response data are assumed to be log-transformed, otherwise use <code>reslog = FALSE</code>.  Salinity data can be provided as fraction of freshwater or as parts per thousand.  The limit column can be entered as a sufficiently small number if all values are above the detection limit or no limit exists.  The current implementation of weighted regression for tidal waters only handles left-censored data.  Missing observations are also removed.  
</p>
<p>The tidalmean object structure is almost identical to the tidal object, with the exception of an additional attribute for the back-transformed interpolation grid.  This is included to account for retransformation bias of log-transformed variables associated with mean models.
</p>


<h3>Value</h3>

<p>A tidalmean object as a data frame and attributes.  The data frame has columns ordered as date, response variable, salinity/flow (rescaled to 0, 1 range), detection limit, logical for detection limit, day number, month, year, and decimal time.  The attributes are as follows:
</p>

<dl>
<dt><code>names</code></dt><dd><p>Column names of the data frame</p>
</dd>
<dt><code>row.names</code></dt><dd><p>Row names of the data frame</p>
</dd>
<dt><code>class</code></dt><dd><p>Class of the object</p>
</dd>
<dt><code>half_wins</code></dt><dd><p>List of numeric values used for half-window widths for model fitting, in the same order as the wt_vars argument passed to <code><a href="#topic+getwts">getwts</a></code>. Initially will be <code>NULL</code> if <code><a href="#topic+wrtds">wrtds</a></code> has not been used.</p>
</dd>
<dt><code>fits</code></dt><dd><p>List with a single element with fits for the WRTDS mean interpolation grid.  Initially will be NULL if <code>wrtds</code> has not been used.</p>
</dd>
<dt><code>predonobs</code></dt><dd><p>A <code>data.frame</code> of predictions using the observed data that were used to fit the model.  This is required for <code>wrtdsperf</code> if a novel dataset is used for predictions after fitting the model. Initially will be NULL if <code>respred</code> has not been used.</p>
</dd>
<dt><code>bt_fits</code></dt><dd><p>List with a single element with back-transformed fits for the WRTDS mean interpolation grid.  Initially will be NULL if <code>wrtds</code> has not been used.</p>
</dd>
<dt><code>flo_grd</code></dt><dd><p>Numeric vector of salinity/flow values that was used for the interpolation grids</p>
</dd>
<dt><code>floobs_rng</code></dt><dd><p>Two element vector indicating the salinity/flow range of the observed data</p>
</dd>
<dt><code>nobs</code></dt><dd><p>List with one matrix showing the number of weights greater than zero for each date and salinity/flow combination used to create the fit matrices in <code>fits</code>.  Initially will be <code>NULL</code> if <code><a href="#topic+wrtds">wrtds</a></code> has not been used.</p>
</dd>
<dt><code>reslab</code></dt><dd><p>expression or character string for response variable label in plots</p>
</dd>
<dt><code>flolab</code></dt><dd><p>expression or character string for flow variable label in plots</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## raw data

data(chldat)

## format
chldat &lt;- tidalmean(chldat)

</code></pre>

<hr>
<h2 id='tidfit'>Monthly chlorophyll time series for Hillsborough Bay as a tidal object</h2><span id='topic+tidfit'></span>

<h3>Description</h3>

<p>An identical object as <code><a href="#topic+tidobj">tidobj</a></code> with the addition of chlorophyll predictions and normalized estimates after running <code><a href="#topic+respred">respred</a></code> and <code><a href="#topic+resnorm">resnorm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidfit
</code></pre>


<h3>Format</h3>

<p>A <code><a href="#topic+tidal">tidal</a></code> and <code><a href="base.html#topic+data.frame">data.frame</a></code> object with 156 rows and 15 variables:
</p>

<dl>
<dt><code>date</code></dt><dd><p>Date</p>
</dd>
<dt><code>res</code></dt><dd><p>numeric</p>
</dd>
<dt><code>flo</code></dt><dd><p>numeric</p>
</dd>
<dt><code>lim</code></dt><dd><p>numeric</p>
</dd>
<dt><code>not_cens</code></dt><dd><p>logical</p>
</dd>
<dt><code>day_num</code></dt><dd><p>numeric</p>
</dd>
<dt><code>month</code></dt><dd><p>numeric</p>
</dd>
<dt><code>year</code></dt><dd><p>numeric</p>
</dd>
<dt><code>dec_time</code></dt><dd><p>numeric</p>
</dd>
<dt><code>fit0.1</code></dt><dd><p>numeric</p>
</dd>
<dt><code>fit0.5</code></dt><dd><p>numeric</p>
</dd>
<dt><code>fit0.9</code></dt><dd><p>numeric</p>
</dd>
<dt><code>norm0.1</code></dt><dd><p>numeric</p>
</dd>
<dt><code>norm0.5</code></dt><dd><p>numeric</p>
</dd>
<dt><code>norm0.9</code></dt><dd><p>numeric</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tidal">tidal</a></code> for full list of attributes in tidal objects, <code><a href="#topic+wrtds">wrtds</a></code> for creating the <code>fits</code> interpolation grids, and <code><a href="#topic+respred">respred</a></code> and <code><a href="#topic+resnorm">resnorm</a></code> for interpolating predicted and normalized values from the grids.
</p>

<hr>
<h2 id='tidfitmean'>Monthly chlorophyll time series for Hillsborough Bay as a tidal object for the conditional mean model</h2><span id='topic+tidfitmean'></span>

<h3>Description</h3>

<p>An identical object as <code><a href="#topic+tidobjmean">tidobjmean</a></code> with the addition of predicted and normalized chlorophyll (log-space and back-transformed) after running <code><a href="#topic+respred">respred</a></code> and <code><a href="#topic+resnorm">resnorm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidfitmean
</code></pre>


<h3>Format</h3>

<p>A <code><a href="#topic+tidalmean">tidalmean</a></code> and <code><a href="base.html#topic+data.frame">data.frame</a></code> object with 156 rows and 11 variables:
</p>

<dl>
<dt><code>date</code></dt><dd><p>Date</p>
</dd>
<dt><code>res</code></dt><dd><p>numeric</p>
</dd>
<dt><code>flo</code></dt><dd><p>numeric</p>
</dd>
<dt><code>lim</code></dt><dd><p>numeric</p>
</dd>
<dt><code>not_cens</code></dt><dd><p>logical</p>
</dd>
<dt><code>day_num</code></dt><dd><p>numeric</p>
</dd>
<dt><code>month</code></dt><dd><p>numeric</p>
</dd>
<dt><code>year</code></dt><dd><p>numeric</p>
</dd>
<dt><code>dec_time</code></dt><dd><p>numeric</p>
</dd>
<dt><code>fits</code></dt><dd><p>numeric</p>
</dd>
<dt><code>bt_fits</code></dt><dd><p>numeric</p>
</dd>
<dt><code>norm</code></dt><dd><p>numeric</p>
</dd>
<dt><code>bt_norms</code></dt><dd><p>numeric</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tidalmean">tidalmean</a></code> for full list of attributes in tidalmean objects, <code><a href="#topic+wrtds">wrtds</a></code> for creating the <code>fits</code>, <code>bt_fits</code>, and <code>scls</code> interpolation grids in the attributes, and <code><a href="#topic+respred">respred</a></code> and <code><a href="#topic+resnorm">resnorm</a></code> for interpolating predicted and normalized values from the grids.
</p>

<hr>
<h2 id='tidobj'>Monthly chlorophyll time series for Hillsborough Bay as a tidal object</h2><span id='topic+tidobj'></span>

<h3>Description</h3>

<p>Monthly chlorophyll time series for the Hillsborough Bay segment of Tampa Bay as a tidal object.  Raw data are those in <code><a href="#topic+chldat">chldat</a></code> with the addition of further processing using the <code><a href="#topic+tidal">tidal</a></code> and <code><a href="#topic+wrtds">wrtds</a></code> functions.  Model predictions are obtained for the tenth, median, and ninetieth conditional quantile of chlorophyll. The object also inherits methods from the <code><a href="base.html#topic+data.frame">data.frame</a></code> class.  The processed data includes columns for date, chlorophyll-a (<code>res</code>, in log-space), salinity as fraction of freshwater (<code>flo</code>, i.e., 0 - 1, with higher values indicating more freshwater), the detection limit for all stations for the respective date, a logical column indicating if the observed chlorophyll is at or below the detection limit, the date as decimal time minus the year, the month from 1 to 12, the year, and total decimal time.  Attributes include column names, row names, class of the object, matrices of interpolation grids from the weighted regression for each conditional quantile, and vector of salinity values that were used to create the interpolation grids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidobj
</code></pre>


<h3>Format</h3>

<p>A <code><a href="#topic+tidal">tidal</a></code> and <code><a href="base.html#topic+data.frame">data.frame</a></code> object with 156 rows and 9 variables:
</p>

<dl>
<dt><code>date</code></dt><dd><p>Date</p>
</dd>
<dt><code>res</code></dt><dd><p>numeric</p>
</dd>
<dt><code>flo</code></dt><dd><p>numeric</p>
</dd>
<dt><code>lim</code></dt><dd><p>numeric</p>
</dd>
<dt><code>not_cens</code></dt><dd><p>logical</p>
</dd>
<dt><code>day_num</code></dt><dd><p>numeric</p>
</dd>
<dt><code>month</code></dt><dd><p>numeric</p>
</dd>
<dt><code>year</code></dt><dd><p>numeric</p>
</dd>
<dt><code>dec_time</code></dt><dd><p>numeric</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tidal">tidal</a></code> for full list of attributes in tidal objects and <code><a href="#topic+wrtds">wrtds</a></code> for creating the <code>fits</code> interpolation grids.
</p>

<hr>
<h2 id='tidobjmean'>Monthly chlorophyll time series for Hillsborough Bay as a tidal object, conditional mean model</h2><span id='topic+tidobjmean'></span>

<h3>Description</h3>

<p>Monthly chlorophyll time series for the Hillsborough Bay segment of Tampa Bay as a tidal object.  Raw data are those in <code><a href="#topic+chldat">chldat</a></code> with the addition of further processing using the <code><a href="#topic+tidalmean">tidalmean</a></code> and <code><a href="#topic+wrtds">wrtds</a></code> functions.  Model predictions are obtained using weighted regression for the conditional mean of chlorophyll. The object also inherits methods from the <code><a href="base.html#topic+data.frame">data.frame</a></code> class.  The processed data includes columns for date, chlorophyll-a (<code>res</code>, in log-space), salinity as fraction of freshwater (<code>flo</code>, i.e., 0 - 1, with higher values indicating more freshwater), the detection limit for all stations for the respective date, a logical column indicating if the observed chlorophyll is at or below the detection limit, the date as decimal time minus the year, the month from 1 to 12, the year, and total decimal time.  Attributes include column names, row names, class of the object, an interpolation grid from the weighted regression for the mean response, a back-transformed interpolation grid from the weighted regression for the mean response, and vector of salinity values that were used to create the interpolation grids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidobjmean
</code></pre>


<h3>Format</h3>

<p>A <code><a href="#topic+tidalmean">tidalmean</a></code> and <code><a href="base.html#topic+data.frame">data.frame</a></code> object with 156 rows and 9 variables:
</p>

<dl>
<dt><code>date</code></dt><dd><p>Date</p>
</dd>
<dt><code>res</code></dt><dd><p>numeric</p>
</dd>
<dt><code>flo</code></dt><dd><p>numeric</p>
</dd>
<dt><code>lim</code></dt><dd><p>numeric</p>
</dd>
<dt><code>not_cens</code></dt><dd><p>logical</p>
</dd>
<dt><code>day_num</code></dt><dd><p>numeric</p>
</dd>
<dt><code>month</code></dt><dd><p>numeric</p>
</dd>
<dt><code>year</code></dt><dd><p>numeric</p>
</dd>
<dt><code>dec_time</code></dt><dd><p>numeric</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tidalmean">tidalmean</a></code> for full list of attributes in tidalmean objects and <code><a href="#topic+wrtds">wrtds</a></code> for creating the <code>fits</code>, <code>bt_fits</code>, and <code>scls</code> interpolation grids.
</p>

<hr>
<h2 id='winsrch_constrOptim'>Find the optimal half-window width combination</h2><span id='topic+winsrch_constrOptim'></span><span id='topic+winsrch_constrOptim.default'></span>

<h3>Description</h3>

<p>Find the optimal half-window width combination to use for weighted regression.  This differs from <code><a href="#topic+winsrch_optim">winsrch_optim</a></code> by using <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winsrch_constrOptim(dat_in, ...)

## Default S3 method:
winsrch_constrOptim(
  dat_in,
  wins_in = NULL,
  control = list(),
  lower = c(0.1, 1, 0.1),
  upper = c(2, 15, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="winsrch_constrOptim_+3A_dat_in">dat_in</code></td>
<td>
<p>input data object to use with weighted regression</p>
</td></tr>
<tr><td><code id="winsrch_constrOptim_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+wrtdscv">wrtdscv</a></code>, <code><a href="#topic+wrtds">wrtds</a></code>, or <code><a href="#topic+getwts">getwts</a></code></p>
</td></tr>
<tr><td><code id="winsrch_constrOptim_+3A_wins_in">wins_in</code></td>
<td>
<p>starting list of window weights for initializing the search algorithm</p>
</td></tr>
<tr><td><code id="winsrch_constrOptim_+3A_control">control</code></td>
<td>
<p>A list of control parameters passed to <code><a href="stats.html#topic+optim">optim</a></code> (see details in <code><a href="stats.html#topic+optim">optim</a></code> help file).</p>
</td></tr>
<tr><td><code id="winsrch_constrOptim_+3A_lower">lower</code></td>
<td>
<p>vector of minimum half-window widths to evaluate</p>
</td></tr>
<tr><td><code id="winsrch_constrOptim_+3A_upper">upper</code></td>
<td>
<p>vector of maximum half-window widths to evaluate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code><a href="stats.html#topic+optim">optim</a></code> to minimize the error returned by <code><a href="#topic+wrtdscv">wrtdscv</a></code> for a given window combination.  The search algorithm uses the limited-memory modification of the BFGS quasi-Newton method to impose upper and lower limits on the optimization search. These limits can be changed using the <code>lower</code> and <code>upper</code> arguments.
</p>


<h3>Value</h3>

<p>Some stuff
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wrtdscv">wrtdscv</a></code>, <code><a href="#topic+winsrch_grid">winsrch_grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# setup parallel backend
library(doParallel)
ncores &lt;- detectCores() - 1  
registerDoParallel(cores = ncores)

# run search function - takes a while
res &lt;- winsrch_optim(tidobjmean)

## End(Not run)
</code></pre>

<hr>
<h2 id='winsrch_grid'>Evaluate half-window width combinations</h2><span id='topic+winsrch_grid'></span><span id='topic+winsrch_grid.default'></span>

<h3>Description</h3>

<p>Evaluate a grid of half-window width combinations to use for weighted regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winsrch_grid(dat_in, ...)

## Default S3 method:
winsrch_grid(dat_in, grid_in = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="winsrch_grid_+3A_dat_in">dat_in</code></td>
<td>
<p>input data object to use with weighted regression</p>
</td></tr>
<tr><td><code id="winsrch_grid_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="winsrch_grid_+3A_grid_in">grid_in</code></td>
<td>
<p>optional input matrix of half-window widths created with <code><a href="#topic+createsrch">createsrch</a></code>, a default search grid is used if no input</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Processing time can be reduced by setting up a parallel backend, as in the examples.  Note that this is not effective for small k-values (e.g., &lt; 4) because each fold is sent to a processor, whereas the window width combinations in <code>grid_in</code> are evaluated in sequence.  
</p>
<p>This function should only be used to view the error surface associated with finite combinations of window-width combinations.  A faster function to identify the optimal window widths is provided by <code><a href="#topic+winsrch_optim">winsrch_optim</a></code>.
</p>


<h3>Value</h3>

<p>A data frame of the search grid with associated errors for each cross-validation result.  Errors for each grid row are averages of all errors for each fold used in cross-validation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createsrch">createsrch</a></code>, <code><a href="#topic+wrtdscv">wrtdscv</a></code>, <code><a href="#topic+winsrch_optim">winsrch_optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##
# setup parallel backend
library(doParallel)
ncores &lt;- detectCores() - 2 
registerDoParallel(cores = ncores)

# run search function using default search grid - takes a while
res &lt;- winsrch_grid(tidobjmean)

# view the error surface 
library(ggplot2)
ggplot(res, aes(x = factor(mos), y = factor(yrs), fill = err)) +
   geom_tile() + 
   facet_wrap(~ flo) + 
   scale_x_discrete(expand = c(0, 0)) +
   scale_y_discrete(expand = c(0,0)) +
   scale_fill_gradientn(colours = gradcols()) 

# optimal combo
res[which.min(res$err), ]

##
# create a custom search grid, e.g. years only
grid_in &lt;- createsrch(mos = 1, yrs = seq(1, 10), flo = 1)

res &lt;- winsrch_grid(tidobjmean, grid_in)


## End(Not run)
</code></pre>

<hr>
<h2 id='winsrch_optim'>Find the optimal half-window width combination</h2><span id='topic+winsrch_optim'></span><span id='topic+winsrch_optim.default'></span>

<h3>Description</h3>

<p>Find the optimal half-window width combination to use for weighted regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winsrch_optim(dat_in, ...)

## Default S3 method:
winsrch_optim(
  dat_in,
  wins_in = NULL,
  control = list(factr = 1e+07, parscale = c(1, 10, 1)),
  lower = c(0.1, 1, 0.1),
  upper = c(2, 15, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="winsrch_optim_+3A_dat_in">dat_in</code></td>
<td>
<p>input data object to use with weighted regression</p>
</td></tr>
<tr><td><code id="winsrch_optim_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+wrtdscv">wrtdscv</a></code>, <code><a href="#topic+wrtds">wrtds</a></code>, or <code><a href="#topic+getwts">getwts</a></code></p>
</td></tr>
<tr><td><code id="winsrch_optim_+3A_wins_in">wins_in</code></td>
<td>
<p>starting list of window weights for initializing the search algorithm</p>
</td></tr>
<tr><td><code id="winsrch_optim_+3A_control">control</code></td>
<td>
<p>A list of control parameters passed to <code><a href="stats.html#topic+optim">optim</a></code> (see details in <code><a href="stats.html#topic+optim">optim</a></code> help file).  The value passed to <code>factr</code> controls the convergence behavior of the <code>"L-BFGS-B"</code> method.  Values larger than the default will generally speed up the optimization with a potential loss of precision. <code>parscale</code> describes the scaling values of the parameters.</p>
</td></tr>
<tr><td><code id="winsrch_optim_+3A_lower">lower</code></td>
<td>
<p>vector of minimum half-window widths to evaluate</p>
</td></tr>
<tr><td><code id="winsrch_optim_+3A_upper">upper</code></td>
<td>
<p>vector of maximum half-window widths to evaluate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code><a href="stats.html#topic+optim">optim</a></code> to minimize the error returned by <code><a href="#topic+wrtdscv">wrtdscv</a></code> for a given window combination.  The search algorithm uses the limited-memory modification of the BFGS quasi-Newton method to impose upper and lower limits on the optimization search. These limits can be changed using the <code>lower</code> and <code>upper</code> arguments.
</p>


<h3>Value</h3>

<p>Some stuff
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wrtdscv">wrtdscv</a></code>, <code><a href="#topic+winsrch_grid">winsrch_grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# setup parallel backend
library(doParallel)
ncores &lt;- detectCores() - 1  
registerDoParallel(cores = ncores)

# run search function - takes a while
res &lt;- winsrch_optim(tidobjmean)

## End(Not run)
</code></pre>

<hr>
<h2 id='wrtds'>Get WRTDS prediction grid</h2><span id='topic+wrtds'></span><span id='topic+wrtds.tidal'></span><span id='topic+wrtds.tidalmean'></span>

<h3>Description</h3>

<p>Get WRTDS prediction grid for observations of the response variable in a tidal or tidalmean object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrtds(dat_in, ...)

## S3 method for class 'tidal'
wrtds(dat_in, flo_div = 10, tau = 0.5, trace = TRUE, fill_empty = FALSE, ...)

## S3 method for class 'tidalmean'
wrtds(dat_in, flo_div = 10, fill_empty = FALSE, trace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrtds_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="wrtds_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="wrtds_+3A_flo_div">flo_div</code></td>
<td>
<p>numeric indicating number of divisions across the range of salinity/flow to create the interpolation grid</p>
</td></tr>
<tr><td><code id="wrtds_+3A_tau">tau</code></td>
<td>
<p>numeric vector indicating conditional quantiles to fit in the weighted regression, can be many</p>
</td></tr>
<tr><td><code id="wrtds_+3A_trace">trace</code></td>
<td>
<p>logical indicating if progress is shown in the console</p>
</td></tr>
<tr><td><code id="wrtds_+3A_fill_empty">fill_empty</code></td>
<td>
<p>logical to fill missing values in interpolation grid using bilinear interpolation by season, see details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Appends interpolation grid attributes to the input object.  For a tidal object, this could include multiple grids for each quantile.  For tidalmean objects, only one grid is appended to the &lsquo;fits&rsquo; attribute, in addition to a back-transformed grid as the &lsquo;bt_fits&rsquo; attribute and a grid of the scale parameter of each prediction as the &lsquo;scls&rsquo; attribute.  Grid rows correspond to the dates in the input data.
</p>
<p>The <code>fill_empty</code> arguments uses bilinear interpolation of time by flow to fill missing data in the interpolation grids.  The grids are subset by month before interpolating to retain the seasonal variation captured by the models.  In general, this argument should not be used if more than ten percent of the interpolation grids are missing data.  It may be helpful to improve visual appearance of some of the plotting results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load data
data(chldat)

## as tidal object
dat_in &lt;- tidal(chldat)
res &lt;- wrtds(dat_in)

## as tidalmean object
dat_in &lt;- tidalmean(chldat)
res &lt;- wrtds(dat_in)

## multiple quantiles
res &lt;- wrtds(dat_in, tau = c(0.1, 0.5, 0.9))

## End(Not run)
</code></pre>

<hr>
<h2 id='wrtdscv'>Use k-fold cross-validation to evaluate WRTDS model fit</h2><span id='topic+wrtdscv'></span><span id='topic+wrtdscv.default'></span>

<h3>Description</h3>

<p>Use k-fold cross-validation to evaluate WRTDS model fit based on supplied half-window widths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrtdscv(dat_in, ...)

## Default S3 method:
wrtdscv(dat_in, wins, k = 10, seed_val = 123, trace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrtdscv_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object</p>
</td></tr>
<tr><td><code id="wrtdscv_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+wrtds">wrtds</a></code> or <code><a href="#topic+getwts">getwts</a></code>, e.g., <code>tau = 0.2</code> if a <code>tidal</code> object is used for <code>dat_in</code></p>
</td></tr>
<tr><td><code id="wrtdscv_+3A_wins">wins</code></td>
<td>
<p>list of input half-window widths of the order months, years, and salinity/flow, passed to <code><a href="#topic+getwts">getwts</a></code></p>
</td></tr>
<tr><td><code id="wrtdscv_+3A_k">k</code></td>
<td>
<p>number of folds to evaluate</p>
</td></tr>
<tr><td><code id="wrtdscv_+3A_seed_val">seed_val</code></td>
<td>
<p>seed to keep the same dataset divisions between window width comparisons</p>
</td></tr>
<tr><td><code id="wrtdscv_+3A_trace">trace</code></td>
<td>
<p>logical indicating if progress is printed in the console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default number of folds is ten.  Each fold can be evaluated with multiple cores if a parallel back end is created prior to running the function (see the examples).  This will greatly increase processing speed unless k is set to a small number.
</p>


<h3>Value</h3>

<p>Overall error is the average of all errors for each fold.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getwts">getwts</a></code>, <code><a href="#topic+wtsplot">wtsplot</a></code>, <code><a href="#topic+winsrch_grid">winsrch_grid</a></code>, <code><a href="#topic+winsrch_optim">winsrch_optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(doParallel)
ncores &lt;- detectCores() - 1  
registerDoParallel(cores = ncores)

# half-window widths to evaluate
# months, years, and salinity/flow
wins &lt;- list(0.5, 10, 0.5) 

# get ocv score for k = 10
wrtdscv(tidobjmean, wins = wins)

# get ocv score k = 2, tau = 0.2 
wrtdscv(tidobj, wins = wins, tau = 0.2)

## End(Not run)
</code></pre>

<hr>
<h2 id='wrtdsperf'>Get WRTDS performance metrics</h2><span id='topic+wrtdsperf'></span><span id='topic+wrtdsperf.tidal'></span><span id='topic+wrtdsperf.tidalmean'></span>

<h3>Description</h3>

<p>Get WRTDS performance metrics including goodness of fit, root mean square error, and normalized mean square error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrtdsperf(dat_in, ...)

## S3 method for class 'tidal'
wrtdsperf(dat_in, logspace = TRUE, ...)

## S3 method for class 'tidalmean'
wrtdsperf(dat_in, logspace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrtdsperf_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal object which must already have fitted model data</p>
</td></tr>
<tr><td><code id="wrtdsperf_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="wrtdsperf_+3A_logspace">logspace</code></td>
<td>
<p>logical if performance metrics use back-transformed residuals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Goodness of fit is calculated using the <code><a href="#topic+goodfit">goodfit</a></code> function for quantile regression described in Koenker and Mochado 1999.  Root mean square error is based on square root of the mean of the squared residuals.  Normalized mean square error described in Gershenfeld and Weigend 1993 is the sum of the squared errors divided by the sum of the non-conditional errors (i.e., sum of the squared values of the observed minus the mean of the observed).  This measure allows comparability of error values for data with different ranges, although the interpretation for quantile models is not clear.  The value is provided as a means of comparison for WRTDS models created from the same data set but with different window widths during model fitting.
</p>
<p>Performance metrics are only valid for observations and model residuals in log-space.  Metrics also only apply to the data used to fit the model, i.e., performance will not be evaluated for novel data if the <code>dat_pred</code> argument was used with  <code><a href="#topic+respred">respred</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with the metrics for each quantile model
</p>


<h3>References</h3>

<p>Gershenfeld, N.A., Weigend, A.S. 1993. The future of time series: learning and understanding. In: Weigend, A.S., Gershenfeld, N.A. (eds). Time Series Prediction: Forecasting the Future and Understanding the Past., second ed. Addison-Wesley, Santa Fe, New Mexico. pp. 1-70.
</p>
<p>Koenker, R., Machado, J.A.F. 1999. Goodness of fit and related inference processes for quantile regression. Journal of the American Statistical Association. 94(448):1296-1310.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wrtdsrsd">wrtdsrsd</a></code> for residuals, <code><a href="#topic+goodfit">goodfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load a fitted model object
data(tidfit)

## get performance metrics
wrtdsperf(tidfit)
</code></pre>

<hr>
<h2 id='wrtdsrsd'>Get WRTDS residuals</h2><span id='topic+wrtdsrsd'></span><span id='topic+wrtdsrsd.tidal'></span><span id='topic+wrtdsrsd.tidalmean'></span>

<h3>Description</h3>

<p>Get WRTDS residuals for each quantile model. These are used to estimate goodness of fit of the model predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrtdsrsd(dat_in, ...)

## S3 method for class 'tidal'
wrtdsrsd(dat_in, trace = TRUE, ...)

## S3 method for class 'tidalmean'
wrtdsrsd(dat_in, trace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrtdsrsd_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal object which must already have fitted model data</p>
</td></tr>
<tr><td><code id="wrtdsrsd_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="wrtdsrsd_+3A_trace">trace</code></td>
<td>
<p>logical indicating if progress is shown in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Columns are added to the data of the tidal object for residuals and non-conditional residuals. Both are required to assess the goodness of fit measure described for quantile regression in Koenker and Machado (1999).
</p>
<p>A tidal object with columns added to the <code>predonobs</code> attribute for the residuals ('rsd') and non-conditional residuals ('rsdnl') of each quantile model or a tidalmean object with columns added to the <code>predonobs</code> attribute for the residuals ('rsd') and back-transformed residuals ('bt_rsd').
</p>


<h3>References</h3>

<p>Koenker, R., Machado, J.A.F. 1999. Goodness of fit and related inference processes for quantile regression. Journal of the American Statistical Association. 94(448):1296-1310.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wrtds">wrtds</a></code>, <code><a href="#topic+wrtdsperf">wrtdsperf</a></code>, <code><a href="#topic+goodfit">goodfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load a fitted model object
data(tidfit)

## run the function
res &lt;- wrtdsrsd(tidfit)
head(res)
</code></pre>

<hr>
<h2 id='wrtdstrnd'>Get WRTDS trends</h2><span id='topic+wrtdstrnd'></span><span id='topic+wrtdstrnd.default'></span><span id='topic+wrtdstrnd.tidal'></span><span id='topic+wrtdstrnd.tidalmean'></span>

<h3>Description</h3>

<p>Get WRTDS trends for annual and monthly groupings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrtdstrnd(dat_in, ...)

## Default S3 method:
wrtdstrnd(
  dat_in,
  mobrks,
  yrbrks,
  molabs,
  yrlabs,
  aves = FALSE,
  mo_strt = 10,
  min_mo = 9,
  ...
)

## S3 method for class 'tidal'
wrtdstrnd(
  dat_in,
  mobrks,
  yrbrks,
  molabs,
  yrlabs,
  tau = NULL,
  aves = FALSE,
  mo_strt = 10,
  min_mo = 9,
  ...
)

## S3 method for class 'tidalmean'
wrtdstrnd(
  dat_in,
  mobrks,
  yrbrks,
  molabs,
  yrlabs,
  aves = FALSE,
  mo_strt = 10,
  min_mo = 9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrtdstrnd_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object which must already have fitted model data</p>
</td></tr>
<tr><td><code id="wrtdstrnd_+3A_...">...</code></td>
<td>
<p>methods passed to or from other methods</p>
</td></tr>
<tr><td><code id="wrtdstrnd_+3A_mobrks">mobrks</code></td>
<td>
<p>list of month groupings where each month is an integer from 1 to 12, see examples</p>
</td></tr>
<tr><td><code id="wrtdstrnd_+3A_yrbrks">yrbrks</code></td>
<td>
<p>numeric vector of breaks for years, see examples</p>
</td></tr>
<tr><td><code id="wrtdstrnd_+3A_molabs">molabs</code></td>
<td>
<p>character vector of names for month breaks, see examples</p>
</td></tr>
<tr><td><code id="wrtdstrnd_+3A_yrlabs">yrlabs</code></td>
<td>
<p>character vector of names for year breaks, see examples</p>
</td></tr>
<tr><td><code id="wrtdstrnd_+3A_aves">aves</code></td>
<td>
<p>logical if averages within each period are also returned</p>
</td></tr>
<tr><td><code id="wrtdstrnd_+3A_mo_strt">mo_strt</code></td>
<td>
<p>numeric indicating month to start aggregation years for annual trends, defaults to October for USGS water year from October to September, passed to <code><a href="#topic+annual_agg">annual_agg</a></code></p>
</td></tr>
<tr><td><code id="wrtdstrnd_+3A_min_mo">min_mo</code></td>
<td>
<p>numeric value from one to twelve indicating the minimum number of months with observations for averaging by years, passed to <code><a href="#topic+annual_agg">annual_agg</a></code></p>
</td></tr>
<tr><td><code id="wrtdstrnd_+3A_tau">tau</code></td>
<td>
<p>numeric vector of quantile for estimating trends</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trends are reported as percent changes of annual averages from the beginning to the end of each period.  To reduce the effects of odd years at the beginning and end of each period, percent changes are based on an average of the first three and last three annual averages.  For example, percent changes for January throughout an an entire time series from 1980 to 2000 would be the change of the average from January in 1980-1982 to the average from January in 1998-2000.  Annual trends, e.g., percent changes from 1980-1986, 1987-1993, etc. do not average by the first and last three years in each grouping because the values are already based on annual averages as returned by <code><a href="#topic+annual_agg">annual_agg</a></code>.  
</p>
<p>Note that the default minimum number of months argument (<code>min_mo</code>) may not be appropriate for all cases.  Annual estimates should first be evaluated with <code><a href="#topic+prdnrmplot">prdnrmplot</a></code> to verify that odd years with missing months are not driving results for the annual percent changes.  
</p>
<p>Averages in each period can be returned if <code>aves = TRUE</code>.  These averages are based on annual averages within each period for congruency with the trend estimates.  
</p>
<p>All trends are based on back-transformed, flow-normalized results. 
</p>
<p>The user must supply the annual and monthly aggregation periods to the appropriate arguments. These are passed to <code><a href="base.html#topic+cut">cut</a></code> and are left-open, right-closed along the interval.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with summary trends for each grouping
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load a fitted model object
data(tidfit)
data(tidfitmean)

## get trends

# setup month, year categories
mobrks &lt;- list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9), c(10, 11, 12))
yrbrks &lt;- c(1973, 1985, 1994, 2003, 2012)
molabs &lt;- c('JFM', 'AMJ', 'JAS', 'OND')
yrlabs &lt;- c('1974-1985', '1986-1994', '1995-2003', '2004-2012')

wrtdstrnd(tidfit, mobrks, yrbrks, molabs, yrlabs)
wrtdstrnd(tidfitmean, mobrks, yrbrks, molabs, yrlabs)

# get averages in each period
wrtdstrnd(tidfit, mobrks, yrbrks, molabs, yrlabs, aves = TRUE)
</code></pre>

<hr>
<h2 id='wrtdstrnd_sk'>Get WRTDS trends using seasonal Kendall tests</h2><span id='topic+wrtdstrnd_sk'></span><span id='topic+wrtdstrnd_sk.default'></span><span id='topic+wrtdstrnd_sk.tidal'></span><span id='topic+wrtdstrnd_sk.tidalmean'></span>

<h3>Description</h3>

<p>Get WRTDS trends using seasonal Kendall tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrtdstrnd_sk(dat_in, ...)

## Default S3 method:
wrtdstrnd_sk(dat_in, mobrks, yrbrks, molabs, yrlabs, ...)

## S3 method for class 'tidal'
wrtdstrnd_sk(
  dat_in,
  mobrks,
  yrbrks,
  molabs,
  yrlabs,
  tau = NULL,
  trndvar = "norm",
  ...
)

## S3 method for class 'tidalmean'
wrtdstrnd_sk(dat_in, mobrks, yrbrks, molabs, yrlabs, trndvar = "bt_norm", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrtdstrnd_sk_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal or tidalmean object which must already have fitted model data</p>
</td></tr>
<tr><td><code id="wrtdstrnd_sk_+3A_...">...</code></td>
<td>
<p>methods passed to or from other methods</p>
</td></tr>
<tr><td><code id="wrtdstrnd_sk_+3A_mobrks">mobrks</code></td>
<td>
<p>list of month groupings where each month is an integer from 1 to 12, see examples</p>
</td></tr>
<tr><td><code id="wrtdstrnd_sk_+3A_yrbrks">yrbrks</code></td>
<td>
<p>numeric vector of breaks for years, see examples</p>
</td></tr>
<tr><td><code id="wrtdstrnd_sk_+3A_molabs">molabs</code></td>
<td>
<p>character vector of names for month breaks, see examples</p>
</td></tr>
<tr><td><code id="wrtdstrnd_sk_+3A_yrlabs">yrlabs</code></td>
<td>
<p>character vector of names for year breaks, see examples</p>
</td></tr>
<tr><td><code id="wrtdstrnd_sk_+3A_tau">tau</code></td>
<td>
<p>numeric vector of quantile for estimating trends</p>
</td></tr>
<tr><td><code id="wrtdstrnd_sk_+3A_trndvar">trndvar</code></td>
<td>
<p>chr string of variable for trend evaluation, usually back-transformed, flow-normalized results, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trends are based on <code><a href="#topic+kendallSeasonalTrendTest">kendallSeasonalTrendTest</a></code> for user-specified time periods.  In general, the seasonal Kendall test evaluates monotonic trends using a non-parametric approach that accounts for seasonal variation in the time series.  
</p>
<p>All trends are based on back-transformed, flow-normalized results by default. The variable for evaluating trends can be changed with <code>'trndvar'</code> as <code>'res'</code>, <code>'norm'</code>, or <code>'fit'</code> for <code>tidal</code> objects and as <code>'res'</code>, <code>'bt_norm'</code>, or <code>'bt_fits'</code> for <code>tidalmean</code> objects.  In all cases, back-transformed variables are evaluated.
</p>
<p>The user must supply the annual and monthly aggregation periods to the appropriate arguments. These are passed to <code><a href="base.html#topic+cut">cut</a></code> and are left-open, right-closed along the interval.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with summary trends for each grouping, including <code>med</code> as the median value for the period of observation, <code>tau</code> as the magnitude and direction of the trend, <code>slope</code> as the Thiel-Sen slope for change per year, <code>chitest</code> as the significance test evaluating heterogeneity between seasons, <code>ztest</code> indicating significance of the overall trend, and <code>perchg</code> as 100 multiplied by the ratio of the annual slope to the median estimate of the time period (percent change per year).  
</p>
<p>As noted in <code><a href="#topic+kendallSeasonalTrendTest">kendallSeasonalTrendTest</a></code>, the overall test is not appropriate if <code>chitest</code> indicates a small p-value.
</p>


<h3>References</h3>

<p>Hirsch, R.M., Slack, J.R., Smith, R.A. 1982. Techniques of trend analysis for monthly water quality data. Water Resources Research, 18:107-121.
</p>
<p>Millard, S. P. 2013. EnvStats: An R Package for Environmental Statistics. Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load a fitted model object
data(tidfit)
data(tidfitmean)

## get trends

# setup month, year categories
mobrks &lt;- list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9), c(10, 11, 12))
yrbrks &lt;- c(1973, 1985, 1994, 2003, 2012)
molabs &lt;- c('JFM', 'AMJ', 'JAS', 'OND')
yrlabs &lt;- c('1974-1985', '1986-1994', '1995-2003', '2004-2012')

wrtdstrnd_sk(tidfit, mobrks, yrbrks, molabs, yrlabs)
wrtdstrnd_sk(tidfitmean, mobrks, yrbrks, molabs, yrlabs)

</code></pre>

<hr>
<h2 id='wtsplot'>Plot the weights for an observation</h2><span id='topic+wtsplot'></span><span id='topic+wtsplot.default'></span><span id='topic+wtsplot.tidal'></span><span id='topic+wtsplot.tidalmean'></span>

<h3>Description</h3>

<p>Create several plots showing the weights used to fit a model for a single observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtsplot(dat_in, ...)

## Default S3 method:
wtsplot(
  dat_in,
  ref = NULL,
  wins = list(0.5, 10, NULL),
  min_obs = TRUE,
  slice = FALSE,
  dt_rng = NULL,
  pt_rng = c(1, 12),
  col_vec = NULL,
  col_lns = NULL,
  alpha = 1,
  as_list = FALSE,
  ...
)

## S3 method for class 'tidal'
wtsplot(dat_in, ...)

## S3 method for class 'tidalmean'
wtsplot(dat_in, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtsplot_+3A_dat_in">dat_in</code></td>
<td>
<p>input tidal object</p>
</td></tr>
<tr><td><code id="wtsplot_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="wtsplot_+3A_ref">ref</code></td>
<td>
<p>chr string indicating the date at the center of the weighting window. Must be in the format 'YYYY-mm-dd' which is passed to <code><a href="base.html#topic+as.Date">as.Date</a></code>.  The closest observation is used if the actual is not present in the data.  Defaults to the mean date if not supplied.</p>
</td></tr>
<tr><td><code id="wtsplot_+3A_wins">wins</code></td>
<td>
<p>list with three elements passed to <code><a href="#topic+getwts">getwts</a></code> indicating the half-window widths for day, year, and salinity/flow</p>
</td></tr>
<tr><td><code id="wtsplot_+3A_min_obs">min_obs</code></td>
<td>
<p>logical to use window widening if less than 100 non-zero weights are found, passed to <code><a href="#topic+getwts">getwts</a></code></p>
</td></tr>
<tr><td><code id="wtsplot_+3A_slice">slice</code></td>
<td>
<p>logical indicating if only weights bounded by the year window (i.e., the limiting window for the combined weights) are shown, passed to <code><a href="#topic+getwts">getwts</a></code></p>
</td></tr>
<tr><td><code id="wtsplot_+3A_dt_rng">dt_rng</code></td>
<td>
<p>Optional chr string indicating the date range for all plots except seasonal (day) weights. Must be two values in the format 'YYYY-mm-dd' which is passed to <code><a href="base.html#topic+as.Date">as.Date</a></code>.</p>
</td></tr>
<tr><td><code id="wtsplot_+3A_pt_rng">pt_rng</code></td>
<td>
<p>numeric vector of two elements indicating point scaling for all weights in the plot of salinity/flow vs time.</p>
</td></tr>
<tr><td><code id="wtsplot_+3A_col_vec">col_vec</code></td>
<td>
<p>chr string of plot colors to use, passed to <code><a href="#topic+gradcols">gradcols</a></code> and <code><a href="ggplot2.html#topic+scale_colour_gradientn">scale_colour_gradientn</a></code> for weight shading.  The last value in the vector is used as the line color if <code>col_lns = NULL</code>.  Any color palette from RColorBrewer can be used as a named input. Palettes from grDevices must be supplied as the returned string of colors for each palette.</p>
</td></tr>
<tr><td><code id="wtsplot_+3A_col_lns">col_lns</code></td>
<td>
<p>chr string of line color in plots</p>
</td></tr>
<tr><td><code id="wtsplot_+3A_alpha">alpha</code></td>
<td>
<p>numeric value from zero to one indicating transparency of points and lines</p>
</td></tr>
<tr><td><code id="wtsplot_+3A_as_list">as_list</code></td>
<td>
<p>logical indicating if plots should be returned in a list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create diagnostic plots to view the effects of different weighting windows on model predictions.  The plots illustrate the weights that are used when fitting a weighted regression in reference to a single observation.  The process is repeated for all observations when the entire model is fit.  Five plots are produced by the function, each showing the weights in relation to time and the selected observation (i.e., center of the weighting window).  The top plot shows salinity/flow over time with the points colored and sized by the combined weight vector.  The remaining four plots show the weights over time for each separate weighting component (months/days, year, and salinity/flow) and the final combined vector.
</p>


<h3>Value</h3>

<p>A combined <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object created using <code><a href="gridExtra.html#topic+grid.arrange">grid.arrange</a></code>.  A list with elements for each individual plot will be returned if <code>as_list = TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getwts">getwts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load a fitted tidal object
data(tidfit)

## plot using defaults, 
wtsplot(tidfit)

## change the defaults
wtsplot(tidfit, ref = '2000-01-01', wins = list(0.5, 15, Inf), 
 dt_rng = c('1990-01-01', '2010-01-01'), 
 pt_rng = c(3, 8), col_vec = c('lightgreen', 'lightblue', 'purple'),
 alpha = 0.7)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
