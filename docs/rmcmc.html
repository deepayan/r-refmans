<!DOCTYPE html><html lang="en"><head><title>Help for package rmcmc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rmcmc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#barker_proposal'><p>Create a new Barker proposal object.</p></a></li>
<li><a href='#bimodal_barker_proposal'><p>Create a new Barker proposal object with bimodal noise distribution.</p></a></li>
<li><a href='#chain_state'><p>Construct a new chain state.</p></a></li>
<li><a href='#covariance_shape_adapter'><p>Create object to adapt proposal with shape based on estimate of target</p>
distribution covariance matrix.</a></li>
<li><a href='#dual_averaging_scale_adapter'><p>Create object to adapt proposal scale to coerce average acceptance rate</p>
using dual averaging scheme of Nesterov (2009) and Hoffman and Gelman (2014).</a></li>
<li><a href='#example_gaussian_stan_model'><p>Construct an example BridgeStan <code>StanModel</code> object for a Gaussian model.</p></a></li>
<li><a href='#hamiltonian_proposal'><p>Create a new Hamiltonian proposal object.</p></a></li>
<li><a href='#involution_hamiltonian'><p>Apply involution underlying Hamiltonian proposal to a chain state.</p></a></li>
<li><a href='#involution_langevin'><p>Apply involution underlying Langevin proposal to a chain state.</p></a></li>
<li><a href='#langevin_proposal'><p>Create a new Langevin proposal object.</p></a></li>
<li><a href='#log_density_ratio_barker'><p>Compute logarithm of Barker proposal density ratio.</p></a></li>
<li><a href='#log_density_ratio_hamiltonian'><p>Compute logarithm of Hamiltonian proposal density ratio.</p></a></li>
<li><a href='#log_density_ratio_langevin'><p>Compute logarithm of Langevin proposal density ratio.</p></a></li>
<li><a href='#log_density_ratio_random_walk'><p>Compute logarithm of random_walk proposal density ratio.</p></a></li>
<li><a href='#random_walk_proposal'><p>Create a new (Gaussian) random walk proposal object.</p></a></li>
<li><a href='#robust_shape_adapter'><p>Create object to adapt proposal shape (and scale) using robust adaptive</p>
Metropolis algorithm of Vihola (2012).</a></li>
<li><a href='#sample_barker'><p>Sample new state from Barker proposal.</p></a></li>
<li><a href='#sample_chain'><p>Sample a Markov chain</p></a></li>
<li><a href='#sample_hamiltonian'><p>Sample new state from Hamiltonian proposal.</p></a></li>
<li><a href='#sample_langevin'><p>Sample new state from Langevin proposal.</p></a></li>
<li><a href='#sample_metropolis_hastings'><p>Sample from Metropolis-Hastings kernel.</p></a></li>
<li><a href='#sample_random_walk'><p>Sample new state from random walk proposal.</p></a></li>
<li><a href='#scale_adapter'><p>Create object to adapt proposal scale to coerce average acceptance rate.</p></a></li>
<li><a href='#shape_adapter'><p>Create object to adapt proposal shape.</p></a></li>
<li><a href='#stochastic_approximation_scale_adapter'><p>Create object to adapt proposal scale to coerce average acceptance rate using</p>
a Robbins and Monro (1951) scheme.</a></li>
<li><a href='#target_distribution_from_log_density_formula'><p>Construct target distribution from a formula specifying log density.</p></a></li>
<li><a href='#target_distribution_from_stan_model'><p>Construct target distribution from a BridgeStan <code>StanModel</code> object.</p></a></li>
<li><a href='#variance_shape_adapter'><p>Create object to adapt proposal with per dimension scales based on estimates</p>
of target distribution variances.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Robust Markov Chain Monte Carlo Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for simulating Markov chains using the Barker proposal
    to compute Markov chain Monte Carlo (MCMC) estimates of expectations with
    respect to a target distribution on a real-valued vector space. The Barker
    proposal, described in Livingstone and Zanella (2022)
    &lt;<a href="https://doi.org/10.1111%2Frssb.12482">doi:10.1111/rssb.12482</a>&gt;, is a gradient-based MCMC algorithm inspired by the
    Barker accept-reject rule. It combines the robustness of simpler MCMC
    schemes, such as random-walk Metropolis, with the efficiency of
    gradient-based methods, such as the Metropolis adjusted Langevin algorithm. 
    The key function provided by the package is sample_chain(), which allows
    sampling a Markov chain with a specified target distribution as its
    stationary distribution. The chain is sampled by generating proposals and
    accepting or rejecting them using a Metropolis-Hasting acceptance rule.
    During an initial warm-up stage, the parameters of the proposal distribution
    can be adapted, with adapters available to both: tune the scale of the
    proposals by coercing the average acceptance rate to a target value; tune
    the shape of the proposals to match covariance estimates under the target 
    distribution. As well as the default Barker proposal, the package also
    provides implementations of alternative proposal distributions, such as
    (Gaussian) random walk and Langevin proposals. Optionally, if 'BridgeStan's
    R interface <a href="https://roualdes.github.io/bridgestan/latest/languages/r.html">https://roualdes.github.io/bridgestan/latest/languages/r.html</a>,
    available on GitHub <a href="https://github.com/roualdes/bridgestan">https://github.com/roualdes/bridgestan</a>, is installed,
    then 'BridgeStan' can be used to specify the target distribution to sample
    from.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bridgestan (&ge; 2.5.0), knitr, posterior, progress, ramcmc,
rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/UCL/rmcmc">https://github.com/UCL/rmcmc</a>, <a href="http://github-pages.ucl.ac.uk/rmcmc/">http://github-pages.ucl.ac.uk/rmcmc/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/UCL/rmcmc/issues">https://github.com/UCL/rmcmc/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, rlang, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-04 16:29:30 UTC; matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew M. Graham <a href="https://orcid.org/0000-0001-9104-7960"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Samuel Livingstone
    <a href="https://orcid.org/0000-0002-7277-086X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  University College London [cph],
  Engineering and Physical Sciences Research Council [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew M. Graham &lt;m.graham@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-04 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='barker_proposal'>Create a new Barker proposal object.</h2><span id='topic+barker_proposal'></span>

<h3>Description</h3>

<p>The Barker proposal is a gradient-based proposal inspired by the Barker
accept-reject rule and proposed in Livingstone and Zanella (2022). It offers
improved robustness compared to alternative gradient-based proposals such as
Langevin proposals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barker_proposal(
  scale = NULL,
  shape = NULL,
  sample_auxiliary = stats::rnorm,
  sample_uniform = stats::runif
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="barker_proposal_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of proposal distribution. A non-negative scalar
value determining scale of steps proposed.</p>
</td></tr>
<tr><td><code id="barker_proposal_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of proposal distribution. Either a vector
corresponding to a diagonal shape matrix with per-dimension scaling
factors, or a matrix allowing arbitrary linear transformations.</p>
</td></tr>
<tr><td><code id="barker_proposal_+3A_sample_auxiliary">sample_auxiliary</code></td>
<td>
<p>Function which generates a random vector from
auxiliary variable distribution.</p>
</td></tr>
<tr><td><code id="barker_proposal_+3A_sample_uniform">sample_uniform</code></td>
<td>
<p>Function which generates a random vector from standard
uniform distribution given an integer size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see the vignette:
<code>vignette("barker-proposal", package = "rmcmc")</code>
</p>


<h3>Value</h3>

<p>Proposal object. A list with entries
</p>

<ul>
<li> <p><code>sample</code>: a function to generate sample from proposal distribution given
current chain state,
</p>
</li>
<li> <p><code>log_density_ratio</code>: a  function to compute log density ratio for proposal
for a given pair of current and proposed chain states,
</p>
</li>
<li> <p><code>update</code>: a function to update parameters of proposal,
</p>
</li>
<li> <p><code>parameters</code>: a function to return list of current parameter values.
</p>
</li>
<li> <p><code>default_target_accept_prob</code>: a function returning the default target
acceptance rate to use for any scale adaptation.
</p>
</li>
<li> <p><code>default_initial_scale</code>: a function which given a dimension gives a default
value to use for the initial proposal scale parameter.
</p>
</li></ul>



<h3>References</h3>

<p>Livingstone, S., &amp; Zanella, G. (2022). The Barker proposal:
combining robustness and efficiency in gradient-based MCMC. <em>Journal of the
Royal Statistical Society Series B: Statistical Methodology</em>, 84(2),
496-523.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target_distribution &lt;- list(
  log_density = function(x) -sum(x^2) / 2,
  gradient_log_density = function(x) -x
)
proposal &lt;- barker_proposal(scale = 1.)
state &lt;- chain_state(c(0., 0.))
withr::with_seed(
  876287L, proposed_state &lt;- proposal$sample(state, target_distribution)
)
log_density_ratio &lt;- proposal$log_density_ratio(
  state, proposed_state, target_distribution
)
proposal$update(scale = 0.5)
</code></pre>

<hr>
<h2 id='bimodal_barker_proposal'>Create a new Barker proposal object with bimodal noise distribution.</h2><span id='topic+bimodal_barker_proposal'></span>

<h3>Description</h3>

<p>Convenience function for creating a Barker proposal with bimodal auxiliary
noise variable distribution, corresponding to equally-weighted normal
components with shared variance <code>sigma</code> and means <code style="white-space: pre;">&#8288;±sqrt(1 - sigma^2)&#8288;</code>.
This choice of noise distribution was suggested in Vogrinc et al. (2023) and
found to give improved performance over the default choice of a standard
normal auxiliary noise distribution in a range of targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bimodal_barker_proposal(
  sigma = 0.1,
  scale = NULL,
  shape = NULL,
  sample_uniform = stats::runif
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bimodal_barker_proposal_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of equally-weighted normal components in
bimodal auxiliary noise distribution, with corresponding means of
<code style="white-space: pre;">&#8288;±sqrt(1 - sigma^2)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="bimodal_barker_proposal_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of proposal distribution. A non-negative scalar
value determining scale of steps proposed.</p>
</td></tr>
<tr><td><code id="bimodal_barker_proposal_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of proposal distribution. Either a vector
corresponding to a diagonal shape matrix with per-dimension scaling
factors, or a matrix allowing arbitrary linear transformations.</p>
</td></tr>
<tr><td><code id="bimodal_barker_proposal_+3A_sample_uniform">sample_uniform</code></td>
<td>
<p>Function which generates a random vector from standard
uniform distribution given an integer size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see the vignette:
<code>vignette("adjusting-noise-distribution", package = "rmcmc")</code>
</p>


<h3>Value</h3>

<p>Proposal object. A list with entries
</p>

<ul>
<li> <p><code>sample</code>: a function to generate sample from proposal distribution given
current chain state,
</p>
</li>
<li> <p><code>log_density_ratio</code>: a  function to compute log density ratio for proposal
for a given pair of current and proposed chain states,
</p>
</li>
<li> <p><code>update</code>: a function to update parameters of proposal,
</p>
</li>
<li> <p><code>parameters</code>: a function to return list of current parameter values.
</p>
</li>
<li> <p><code>default_target_accept_prob</code>: a function returning the default target
acceptance rate to use for any scale adaptation.
</p>
</li>
<li> <p><code>default_initial_scale</code>: a function which given a dimension gives a default
value to use for the initial proposal scale parameter.
</p>
</li></ul>



<h3>References</h3>

<p>Vogrinc, J., Livingstone, S., &amp; Zanella, G. (2023). Optimal
design of the Barker proposal and other locally balanced
Metropolis–Hastings algorithms. <em>Biometrika</em>, 110(3), 579-595.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+barker_proposal">barker_proposal()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target_distribution &lt;- list(
  log_density = function(x) -sum(x^2) / 2,
  gradient_log_density = function(x) -x
)
proposal &lt;- bimodal_barker_proposal(scale = 1.)
state &lt;- chain_state(c(0., 0.))
withr::with_seed(
  876287L, proposed_state &lt;- proposal$sample(state, target_distribution)
)
log_density_ratio &lt;- proposal$log_density_ratio(
  state, proposed_state, target_distribution
)
proposal$update(scale = 0.5)
</code></pre>

<hr>
<h2 id='chain_state'>Construct a new chain state.</h2><span id='topic+chain_state'></span>

<h3>Description</h3>

<p>The chain state object provides cached access to target distribution
log density and its gradient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain_state(position, momentum = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chain_state_+3A_position">position</code></td>
<td>
<p>Position component of chain state.</p>
</td></tr>
<tr><td><code id="chain_state_+3A_momentum">momentum</code></td>
<td>
<p>Momentum component of chain state. Optional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New chain state object. A list with entries
</p>

<ul>
<li> <p><code>position</code>: A zero-argument function to evaluate position vector.
</p>
</li>
<li> <p><code>momentum</code>: A zero-argument function to evaluate momentum vector.
</p>
</li>
<li> <p><code>dimension</code>: A zero-argument function evaluate dimension of position and
momentum vectors.
</p>
</li>
<li> <p><code>update</code>: A function accepting arguments <code>position</code> and <code>momentum</code> for
updating the value of one or both of these state components.
</p>
</li>
<li> <p><code>copy</code>: A function for creating a copy of the state object including any
cached values.
</p>
</li>
<li> <p><code>log_density</code>: A function accepting argument <code>target_distribution</code> for
evaluating the log density of the target distribution at the current
state, with caching of the value to avoid recomputation on subsequent
calls.
</p>
</li>
<li> <p><code>gradient_log_density</code>: A function accepting argument <code>target_distribution</code>
for evaluating the gradient of the log density of the target distribution
at the current state, with caching of the value to avoid recomputation on
subsequent calls.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>state &lt;- chain_state(c(0.1, -0.5))
target_distribution &lt;- list(
  log_density = function(x) -sum(x^2) / 2,
  gradient_log_density = function(x) -x
)
state$gradient_log_density(target_distribution)
</code></pre>

<hr>
<h2 id='covariance_shape_adapter'>Create object to adapt proposal with shape based on estimate of target
distribution covariance matrix.</h2><span id='topic+covariance_shape_adapter'></span>

<h3>Description</h3>

<p>Corresponds to Algorithm 2 in Andrieu and Thoms (2009), which is itself a
restatement of method proposed in Haario et al. (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariance_shape_adapter(kappa = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covariance_shape_adapter_+3A_kappa">kappa</code></td>
<td>
<p>Decay rate exponent in <code style="white-space: pre;">&#8288;[0.5, 1]&#8288;</code> for adaptation learning rate.
Value of 1 (default) corresponds to computing empirical covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires <code>ramcmc</code> package to be installed for access to efficient rank-1
Cholesky update function <code>ramcmc::chol_update</code>.
</p>


<h3>Value</h3>

<p>List of functions with entries
</p>

<ul>
<li> <p><code>initialize</code>, a function for initializing adapter state and proposal
parameters at beginning of chain,
</p>
</li>
<li> <p><code>update</code> a function for updating adapter state and proposal parameters on
each chain iteration,
</p>
</li>
<li> <p><code>finalize</code> a function for performing any final updates to adapter state and
proposal parameters on completion of chain sampling (may be <code>NULL</code> if
unused).
</p>
</li>
<li> <p><code>state</code> a zero-argument function for accessing current values of adapter
state variables.
</p>
</li></ul>



<h3>References</h3>

<p>Andrieu, C., &amp; Thoms, J. (2008). A tutorial on adaptive MCMC.
<em>Statistics and Computing</em>, 18, 343-373.
</p>
<p>Haario, H., Saksman, E., &amp; Tamminen, J. (2001). An adaptive
Metropolis algorithm. <em>Bernoulli</em>, 7(2): 223-242.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proposal &lt;- barker_proposal()
adapter &lt;- covariance_shape_adapter()
adapter$initialize(proposal, chain_state(c(0, 0)))
</code></pre>

<hr>
<h2 id='dual_averaging_scale_adapter'>Create object to adapt proposal scale to coerce average acceptance rate
using dual averaging scheme of Nesterov (2009) and Hoffman and Gelman (2014).</h2><span id='topic+dual_averaging_scale_adapter'></span>

<h3>Description</h3>

<p>Create object to adapt proposal scale to coerce average acceptance rate
using dual averaging scheme of Nesterov (2009) and Hoffman and Gelman (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dual_averaging_scale_adapter(
  initial_scale = NULL,
  target_accept_prob = NULL,
  kappa = 0.75,
  gamma = 0.05,
  iteration_offset = 10,
  mu = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dual_averaging_scale_adapter_+3A_initial_scale">initial_scale</code></td>
<td>
<p>Initial value to use for scale parameter. If not set
explicitly a proposal and dimension dependent default will be used.</p>
</td></tr>
<tr><td><code id="dual_averaging_scale_adapter_+3A_target_accept_prob">target_accept_prob</code></td>
<td>
<p>Target value for average accept probability for
chain. If not set a proposal dependent default will be used.</p>
</td></tr>
<tr><td><code id="dual_averaging_scale_adapter_+3A_kappa">kappa</code></td>
<td>
<p>Decay rate exponent in <code style="white-space: pre;">&#8288;[0.5, 1]&#8288;</code> for adaptation learning rate.
Defaults to value recommended in Hoffman and Gelman (2014).</p>
</td></tr>
<tr><td><code id="dual_averaging_scale_adapter_+3A_gamma">gamma</code></td>
<td>
<p>Regularization coefficient for (log) scale in dual averaging
algorithm. Controls amount of regularization of (log) scale towards <code>mu</code>.
Should be set to a non-negative value. Defaults to value recommended in
Hoffman and Gelman (2014).</p>
</td></tr>
<tr><td><code id="dual_averaging_scale_adapter_+3A_iteration_offset">iteration_offset</code></td>
<td>
<p>Offset to chain iteration used for the iteration
based weighting of the adaptation statistic error estimate. Should be set
to a non-negative value. A value greater than zero has the effect of
stabilizing early iterations. Defaults to value recommended in
Hoffman and Gelman (2014).</p>
</td></tr>
<tr><td><code id="dual_averaging_scale_adapter_+3A_mu">mu</code></td>
<td>
<p>Value to regularize (log) scale towards. If <code>NULL</code> (the default),
<code>mu</code> will be set to <code>log(10 * initial_scale)</code>, as recommended in Hoffman
and Gelman (2014).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of functions with entries
</p>

<ul>
<li> <p><code>initialize</code>, a function for initializing adapter state and proposal
parameters at beginning of chain,
</p>
</li>
<li> <p><code>update</code> a function for updating adapter state and proposal parameters on
each chain iteration,
</p>
</li>
<li> <p><code>finalize</code> a function for performing any final updates to adapter state and
proposal parameters on completion of chain sampling (may be <code>NULL</code> if
unused).
</p>
</li>
<li> <p><code>state</code> a zero-argument function for accessing current values of adapter
state variables.
</p>
</li></ul>



<h3>References</h3>

<p>Nesterov, Y. (2009). Primal-dual subgradient methods for convex
problems. <em>Mathematical Programming</em>, 120(1), 221-259.
</p>
<p>Hoffman, M. D., &amp; Gelman, A. (2014). The No-U-Turn sampler:
adaptively setting path lengths in Hamiltonian Monte Carlo.
<em>Journal of Machine Learning Research</em>, 15(1), 1593-1623.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proposal &lt;- barker_proposal()
adapter &lt;- dual_averaging_scale_adapter(
  initial_scale = 1., target_accept_prob = 0.4
)
adapter$initialize(proposal, chain_state(c(0, 0)))
</code></pre>

<hr>
<h2 id='example_gaussian_stan_model'>Construct an example BridgeStan <code>StanModel</code> object for a Gaussian model.</h2><span id='topic+example_gaussian_stan_model'></span>

<h3>Description</h3>

<p>Requires BridgeStan package to be installed. Generative model is assumed to
be of the form <code>y ~ normal(mu, sigma)</code> for unknown <code>mu ~ normal(0, 3)</code> and
<code>sigma ~ half_normal(0, 3)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_gaussian_stan_model(n_data = 50, seed = 1234L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="example_gaussian_stan_model_+3A_n_data">n_data</code></td>
<td>
<p>Number of independent data points <code>y</code> to generate and condition
model against from <code>normal(0, 1)</code>.</p>
</td></tr>
<tr><td><code id="example_gaussian_stan_model_+3A_seed">seed</code></td>
<td>
<p>Integer seed for Stan model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BridgeStan StanModel object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- example_gaussian_stan_model(n_data = 5)
model$param_names()

</code></pre>

<hr>
<h2 id='hamiltonian_proposal'>Create a new Hamiltonian proposal object.</h2><span id='topic+hamiltonian_proposal'></span>

<h3>Description</h3>

<p>The Hamiltonian proposal augments the target distribution with normally
distributed auxiliary momenta variables and simulates the dynamics for a
Hamiltonian function corresponding to the negative logarithm of the density
of the resulting joint target distribution using a leapfrog integrator, with
the proposed new state being the forward integrate state with momenta negated
to ensure reversibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hamiltonian_proposal(
  n_step,
  scale = NULL,
  shape = NULL,
  sample_auxiliary = function(state) stats::rnorm(state$dimension()),
  sample_n_step = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hamiltonian_proposal_+3A_n_step">n_step</code></td>
<td>
<p>Number of leapfrog steps to simulate Hamiltonian dynamics for
in each proposed move, or parameter passed to function specified by
<code>sample_n_step</code> argument if not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="hamiltonian_proposal_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of proposal distribution. A non-negative scalar
value determining scale of steps proposed.</p>
</td></tr>
<tr><td><code id="hamiltonian_proposal_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of proposal distribution. Either a vector
corresponding to a diagonal shape matrix with per-dimension scaling
factors, or a matrix allowing arbitrary linear transformations.</p>
</td></tr>
<tr><td><code id="hamiltonian_proposal_+3A_sample_auxiliary">sample_auxiliary</code></td>
<td>
<p>A function which samples new values for auxiliary
variables (corresponding to a linear transform of momentum) given current
chain state, leaving their standard normal target distribution invariant.
Defaults to a function sampling independent standard normal random variates
but can be used to implement alternative updates such as partial momentum
refreshment. Function should accept a single argument which is passed the
current chain state.</p>
</td></tr>
<tr><td><code id="hamiltonian_proposal_+3A_sample_n_step">sample_n_step</code></td>
<td>
<p>Optionally a function which randomly samples number of
leapfrog steps to simulate in each proposed move from some integer-valued
distribution, or <code>NULL</code> (the default) to use a fixed deterministic number
of steps as specified by <code>n_step</code> argument. If a function it should accept
a single argument which will be passed the value of <code>n_step</code> which can
be used to specify parameter(s) of distribution to sample number of steps
from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Proposal object. A list with entries
</p>

<ul>
<li> <p><code>sample</code>: a function to generate sample from proposal distribution given
current chain state,
</p>
</li>
<li> <p><code>log_density_ratio</code>: a  function to compute log density ratio for proposal
for a given pair of current and proposed chain states,
</p>
</li>
<li> <p><code>update</code>: a function to update parameters of proposal,
</p>
</li>
<li> <p><code>parameters</code>: a function to return list of current parameter values.
</p>
</li>
<li> <p><code>default_target_accept_prob</code>: a function returning the default target
acceptance rate to use for any scale adaptation.
</p>
</li>
<li> <p><code>default_initial_scale</code>: a function which given a dimension gives a default
value to use for the initial proposal scale parameter.
</p>
</li></ul>



<h3>References</h3>

<p>Duane, S., Kennedy, A. D., Pendleton, B. J., &amp; Roweth, D. (1987).
Hybrid Monte Carlo. <em>Physics Letters B</em>, 195(2), 216-222.
</p>
<p>Neal, R. M. (2011). MCMC Using Hamiltonian Dynamics. In <em>Handbook
of Markov Chain Monte Carlo</em> (pp. 113-162). Chapman and Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target_distribution &lt;- list(
  log_density = function(x) -sum(x^2) / 2,
  gradient_log_density = function(x) -x
)

# Proposal with fixed number of leapfrog steps
proposal &lt;- hamiltonian_proposal(scale = 1., n_step = 5)
state &lt;- chain_state(c(0., 0.))
withr::with_seed(
  876287L, proposed_state &lt;- proposal$sample(state, target_distribution)
)
log_density_ratio &lt;- proposal$log_density_ratio(
  state, proposed_state, target_distribution
)
proposal$update(scale = 0.5)

# Proposal with number of steps randomly sampled uniformly from 5:10
sample_uniform_int &lt;- function(lower, upper) {
  lower + sample.int(upper - lower + 1, 1) - 1
}
proposal &lt;- hamiltonian_proposal(
  scale = 1.,
  n_step = c(5, 10),
  sample_n_step = function(n_step) sample_uniform_int(n_step[1], n_step[2])
)
withr::with_seed(
  876287L, proposed_state &lt;- proposal$sample(state, target_distribution)
)

# Proposal with partial momentum refreshment
partial_momentum_update &lt;- function(state, phi = pi / 4) {
  momentum &lt;- state$momentum()
  if (is.null(momentum)) {
    stats::rnorm(state$dimension())
  } else {
    cos(phi) * momentum + sin(phi) * stats::rnorm(length(momentum))
  }
}
proposal &lt;- hamiltonian_proposal(
  scale = 1.,
  n_step = 1,
  sample_auxiliary = partial_momentum_update
)
withr::with_seed(
  876287L, proposed_state &lt;- proposal$sample(state, target_distribution)
)
</code></pre>

<hr>
<h2 id='involution_hamiltonian'>Apply involution underlying Hamiltonian proposal to a chain state.</h2><span id='topic+involution_hamiltonian'></span>

<h3>Description</h3>

<p>Apply involution underlying Hamiltonian proposal to a chain state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>involution_hamiltonian(state, n_step, scale_and_shape, target_distribution)
</code></pre>


<h3>Value</h3>

<p>Chain state after involution is applied.
</p>

<hr>
<h2 id='involution_langevin'>Apply involution underlying Langevin proposal to a chain state.</h2><span id='topic+involution_langevin'></span>

<h3>Description</h3>

<p>Apply involution underlying Langevin proposal to a chain state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>involution_langevin(state, scale_and_shape, target_distribution)
</code></pre>


<h3>Value</h3>

<p>Chain state after involution is applied.
</p>

<hr>
<h2 id='langevin_proposal'>Create a new Langevin proposal object.</h2><span id='topic+langevin_proposal'></span>

<h3>Description</h3>

<p>The Langevin proposal is a gradient-based proposal corresponding to a
Euler-Maruyama time discretisation of a Langevin diffusion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>langevin_proposal(scale = NULL, shape = NULL, sample_auxiliary = stats::rnorm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="langevin_proposal_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of proposal distribution. A non-negative scalar
value determining scale of steps proposed.</p>
</td></tr>
<tr><td><code id="langevin_proposal_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of proposal distribution. Either a vector
corresponding to a diagonal shape matrix with per-dimension scaling
factors, or a matrix allowing arbitrary linear transformations.</p>
</td></tr>
<tr><td><code id="langevin_proposal_+3A_sample_auxiliary">sample_auxiliary</code></td>
<td>
<p>Function which generates a random vector from
auxiliary variable distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Proposal object. A list with entries
</p>

<ul>
<li> <p><code>sample</code>: a function to generate sample from proposal distribution given
current chain state,
</p>
</li>
<li> <p><code>log_density_ratio</code>: a  function to compute log density ratio for proposal
for a given pair of current and proposed chain states,
</p>
</li>
<li> <p><code>update</code>: a function to update parameters of proposal,
</p>
</li>
<li> <p><code>parameters</code>: a function to return list of current parameter values.
</p>
</li>
<li> <p><code>default_target_accept_prob</code>: a function returning the default target
acceptance rate to use for any scale adaptation.
</p>
</li>
<li> <p><code>default_initial_scale</code>: a function which given a dimension gives a default
value to use for the initial proposal scale parameter.
</p>
</li></ul>



<h3>References</h3>

<p>Besag, J. (1994). &quot;Comments on &quot;Representations of knowledge in
complex systems&quot; by U. Grenander and MI Miller&quot;. <em>Journal of the Royal
Statistical Society, Series B</em>. 56: 591–592.
</p>
<p>Roberts, G. O., &amp; Tweedie, R. L. (1996). Exponential convergence
of Langevin distributions and their discrete approximations. <em>Bernoulli</em> 2
(4), 341 - 363.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target_distribution &lt;- list(
  log_density = function(x) -sum(x^2) / 2,
  gradient_log_density = function(x) -x
)
proposal &lt;- langevin_proposal(scale = 1.)
state &lt;- chain_state(c(0., 0.))
withr::with_seed(
  876287L, proposed_state &lt;- proposal$sample(state, target_distribution)
)
log_density_ratio &lt;- proposal$log_density_ratio(
  state, proposed_state, target_distribution
)
proposal$update(scale = 0.5)
</code></pre>

<hr>
<h2 id='log_density_ratio_barker'>Compute logarithm of Barker proposal density ratio.</h2><span id='topic+log_density_ratio_barker'></span>

<h3>Description</h3>

<p>Compute logarithm of Barker proposal density ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_density_ratio_barker(
  state,
  proposed_state,
  target_distribution,
  scale_and_shape
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_density_ratio_barker_+3A_state">state</code></td>
<td>
<p>Current chain state.</p>
</td></tr>
<tr><td><code id="log_density_ratio_barker_+3A_proposed_state">proposed_state</code></td>
<td>
<p>Proposed chain state.</p>
</td></tr>
<tr><td><code id="log_density_ratio_barker_+3A_target_distribution">target_distribution</code></td>
<td>
<p>Target stationary distribution for chain. A list
with named entries <code>log_density</code> and <code>gradient_log_density</code> corresponding to
respectively functions for evaluating the logarithm of the (potentially
unnormalized) density of the target distribution and its gradient.
As an alternative to <code>gradient_log_density</code> an entry
<code>value_and_gradient_log_density</code> may instead be provided which is a function
returning both the value and gradient of the logarithm of the (unnormalized)
density of the target distribution as a list under the names <code>value</code> and
<code>gradient</code> respectively.</p>
</td></tr>
<tr><td><code id="log_density_ratio_barker_+3A_scale_and_shape">scale_and_shape</code></td>
<td>
<p>Scalar, vector or matrix which scales and shapes
proposal distribution. If a scalar (in which case the value should be
non-negative) the auxiliary vector will be isotropically scaled by the
value. If a vector (in which case the value should be equal in length to the
dimension of the space and all entries non-negative) each dimension of the
auxiliary vector will be scaled separately. If a matrix (in which case the
value should be a square matrix with size equal to the dimension of the
space) then by pre-multiplying the auxiliary vector arbitrary linear
transformations can be performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logarithm of proposal density ratio.
</p>

<hr>
<h2 id='log_density_ratio_hamiltonian'>Compute logarithm of Hamiltonian proposal density ratio.</h2><span id='topic+log_density_ratio_hamiltonian'></span>

<h3>Description</h3>

<p>Compute logarithm of Hamiltonian proposal density ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_density_ratio_hamiltonian(
  state,
  proposed_state,
  target_distribution,
  scale_and_shape
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_density_ratio_hamiltonian_+3A_state">state</code></td>
<td>
<p>Current chain state.</p>
</td></tr>
<tr><td><code id="log_density_ratio_hamiltonian_+3A_proposed_state">proposed_state</code></td>
<td>
<p>Proposed chain state.</p>
</td></tr>
<tr><td><code id="log_density_ratio_hamiltonian_+3A_target_distribution">target_distribution</code></td>
<td>
<p>Target stationary distribution for chain. A list
with named entries <code>log_density</code> and <code>gradient_log_density</code> corresponding to
respectively functions for evaluating the logarithm of the (potentially
unnormalized) density of the target distribution and its gradient.
As an alternative to <code>gradient_log_density</code> an entry
<code>value_and_gradient_log_density</code> may instead be provided which is a function
returning both the value and gradient of the logarithm of the (unnormalized)
density of the target distribution as a list under the names <code>value</code> and
<code>gradient</code> respectively.</p>
</td></tr>
<tr><td><code id="log_density_ratio_hamiltonian_+3A_scale_and_shape">scale_and_shape</code></td>
<td>
<p>Scalar, vector or matrix which scales and shapes
proposal distribution. If a scalar (in which case the value should be
non-negative) the auxiliary vector will be isotropically scaled by the
value. If a vector (in which case the value should be equal in length to the
dimension of the space and all entries non-negative) each dimension of the
auxiliary vector will be scaled separately. If a matrix (in which case the
value should be a square matrix with size equal to the dimension of the
space) then by pre-multiplying the auxiliary vector arbitrary linear
transformations can be performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logarithm of proposal density ratio.
</p>

<hr>
<h2 id='log_density_ratio_langevin'>Compute logarithm of Langevin proposal density ratio.</h2><span id='topic+log_density_ratio_langevin'></span>

<h3>Description</h3>

<p>Compute logarithm of Langevin proposal density ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_density_ratio_langevin(
  state,
  proposed_state,
  target_distribution,
  scale_and_shape
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_density_ratio_langevin_+3A_state">state</code></td>
<td>
<p>Current chain state.</p>
</td></tr>
<tr><td><code id="log_density_ratio_langevin_+3A_proposed_state">proposed_state</code></td>
<td>
<p>Proposed chain state.</p>
</td></tr>
<tr><td><code id="log_density_ratio_langevin_+3A_target_distribution">target_distribution</code></td>
<td>
<p>Target stationary distribution for chain. A list
with named entries <code>log_density</code> and <code>gradient_log_density</code> corresponding to
respectively functions for evaluating the logarithm of the (potentially
unnormalized) density of the target distribution and its gradient.
As an alternative to <code>gradient_log_density</code> an entry
<code>value_and_gradient_log_density</code> may instead be provided which is a function
returning both the value and gradient of the logarithm of the (unnormalized)
density of the target distribution as a list under the names <code>value</code> and
<code>gradient</code> respectively.</p>
</td></tr>
<tr><td><code id="log_density_ratio_langevin_+3A_scale_and_shape">scale_and_shape</code></td>
<td>
<p>Scalar, vector or matrix which scales and shapes
proposal distribution. If a scalar (in which case the value should be
non-negative) the auxiliary vector will be isotropically scaled by the
value. If a vector (in which case the value should be equal in length to the
dimension of the space and all entries non-negative) each dimension of the
auxiliary vector will be scaled separately. If a matrix (in which case the
value should be a square matrix with size equal to the dimension of the
space) then by pre-multiplying the auxiliary vector arbitrary linear
transformations can be performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logarithm of proposal density ratio.
</p>

<hr>
<h2 id='log_density_ratio_random_walk'>Compute logarithm of random_walk proposal density ratio.</h2><span id='topic+log_density_ratio_random_walk'></span>

<h3>Description</h3>

<p>Compute logarithm of random_walk proposal density ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_density_ratio_random_walk(
  state,
  proposed_state,
  target_distribution,
  scale_and_shape
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_density_ratio_random_walk_+3A_state">state</code></td>
<td>
<p>Current chain state.</p>
</td></tr>
<tr><td><code id="log_density_ratio_random_walk_+3A_proposed_state">proposed_state</code></td>
<td>
<p>Proposed chain state.</p>
</td></tr>
<tr><td><code id="log_density_ratio_random_walk_+3A_target_distribution">target_distribution</code></td>
<td>
<p>Target stationary distribution for chain. A list
with named entries <code>log_density</code> and <code>gradient_log_density</code> corresponding to
respectively functions for evaluating the logarithm of the (potentially
unnormalized) density of the target distribution and its gradient.
As an alternative to <code>gradient_log_density</code> an entry
<code>value_and_gradient_log_density</code> may instead be provided which is a function
returning both the value and gradient of the logarithm of the (unnormalized)
density of the target distribution as a list under the names <code>value</code> and
<code>gradient</code> respectively.</p>
</td></tr>
<tr><td><code id="log_density_ratio_random_walk_+3A_scale_and_shape">scale_and_shape</code></td>
<td>
<p>Scalar, vector or matrix which scales and shapes
proposal distribution. If a scalar (in which case the value should be
non-negative) the auxiliary vector will be isotropically scaled by the
value. If a vector (in which case the value should be equal in length to the
dimension of the space and all entries non-negative) each dimension of the
auxiliary vector will be scaled separately. If a matrix (in which case the
value should be a square matrix with size equal to the dimension of the
space) then by pre-multiplying the auxiliary vector arbitrary linear
transformations can be performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logarithm of proposal density ratio.
</p>

<hr>
<h2 id='random_walk_proposal'>Create a new (Gaussian) random walk proposal object.</h2><span id='topic+random_walk_proposal'></span>

<h3>Description</h3>

<p>The Gaussian random walk proposal samples a new proposed state by perturbing
the current state with zero-mean normally distributed noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_walk_proposal(
  scale = NULL,
  shape = NULL,
  sample_auxiliary = stats::rnorm
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_walk_proposal_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of proposal distribution. A non-negative scalar
value determining scale of steps proposed.</p>
</td></tr>
<tr><td><code id="random_walk_proposal_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of proposal distribution. Either a vector
corresponding to a diagonal shape matrix with per-dimension scaling
factors, or a matrix allowing arbitrary linear transformations.</p>
</td></tr>
<tr><td><code id="random_walk_proposal_+3A_sample_auxiliary">sample_auxiliary</code></td>
<td>
<p>Function which generates a random vector from
auxiliary variable distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Proposal object. A list with entries
</p>

<ul>
<li> <p><code>sample</code>: a function to generate sample from proposal distribution given
current chain state,
</p>
</li>
<li> <p><code>log_density_ratio</code>: a  function to compute log density ratio for proposal
for a given pair of current and proposed chain states,
</p>
</li>
<li> <p><code>update</code>: a function to update parameters of proposal,
</p>
</li>
<li> <p><code>parameters</code>: a function to return list of current parameter values.
</p>
</li>
<li> <p><code>default_target_accept_prob</code>: a function returning the default target
acceptance rate to use for any scale adaptation.
</p>
</li>
<li> <p><code>default_initial_scale</code>: a function which given a dimension gives a default
value to use for the initial proposal scale parameter.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>target_distribution &lt;- list(log_density = function(x) -sum(x^2) / 2)
proposal &lt;- random_walk_proposal(scale = 1.)
state &lt;- chain_state(c(0., 0.))
withr::with_seed(
  876287L, proposed_state &lt;- proposal$sample(state, target_distribution)
)
log_density_ratio &lt;- proposal$log_density_ratio(
  state, proposed_state, target_distribution
)
proposal$update(scale = 0.5)
</code></pre>

<hr>
<h2 id='robust_shape_adapter'>Create object to adapt proposal shape (and scale) using robust adaptive
Metropolis algorithm of Vihola (2012).</h2><span id='topic+robust_shape_adapter'></span>

<h3>Description</h3>

<p>Requires <code>ramcmc</code> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust_shape_adapter(
  initial_scale = NULL,
  target_accept_prob = NULL,
  kappa = 0.6
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust_shape_adapter_+3A_initial_scale">initial_scale</code></td>
<td>
<p>Initial value to use for scale parameter. If not set
explicitly a proposal and dimension dependent default will be used.</p>
</td></tr>
<tr><td><code id="robust_shape_adapter_+3A_target_accept_prob">target_accept_prob</code></td>
<td>
<p>Target value for average accept probability for
chain. If not set a proposal dependent default will be used.</p>
</td></tr>
<tr><td><code id="robust_shape_adapter_+3A_kappa">kappa</code></td>
<td>
<p>Decay rate exponent in <code style="white-space: pre;">&#8288;[0.5, 1]&#8288;</code> for adaptation learning rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of functions with entries
</p>

<ul>
<li> <p><code>initialize</code>, a function for initializing adapter state and proposal
parameters at beginning of chain,
</p>
</li>
<li> <p><code>update</code> a function for updating adapter state and proposal parameters on
each chain iteration,
</p>
</li>
<li> <p><code>finalize</code> a function for performing any final updates to adapter state and
proposal parameters on completion of chain sampling (may be <code>NULL</code> if
unused).
</p>
</li>
<li> <p><code>state</code> a zero-argument function for accessing current values of adapter
state variables.
</p>
</li></ul>



<h3>References</h3>

<p>Vihola, M. (2012). Robust adaptive Metropolis algorithm with
coerced acceptance rate. <em>Statistics and Computing</em>, 22, 997-1008.
<a href="https://doi.org/10.1007/s11222-011-9269-5">doi:10.1007/s11222-011-9269-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proposal &lt;- barker_proposal()
adapter &lt;- robust_shape_adapter(initial_scale = 1., target_accept_prob = 0.4)
adapter$initialize(proposal, chain_state(c(0, 0)))
</code></pre>

<hr>
<h2 id='sample_barker'>Sample new state from Barker proposal.</h2><span id='topic+sample_barker'></span>

<h3>Description</h3>

<p>Sample new state from Barker proposal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_barker(
  state,
  target_distribution,
  scale_and_shape,
  sample_auxiliary = stats::rnorm,
  sample_uniform = stats::runif
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_barker_+3A_state">state</code></td>
<td>
<p>Current chain state.</p>
</td></tr>
<tr><td><code id="sample_barker_+3A_target_distribution">target_distribution</code></td>
<td>
<p>Target stationary distribution for chain. A list
with named entries <code>log_density</code> and <code>gradient_log_density</code> corresponding to
respectively functions for evaluating the logarithm of the (potentially
unnormalized) density of the target distribution and its gradient.
As an alternative to <code>gradient_log_density</code> an entry
<code>value_and_gradient_log_density</code> may instead be provided which is a function
returning both the value and gradient of the logarithm of the (unnormalized)
density of the target distribution as a list under the names <code>value</code> and
<code>gradient</code> respectively.</p>
</td></tr>
<tr><td><code id="sample_barker_+3A_scale_and_shape">scale_and_shape</code></td>
<td>
<p>Scalar, vector or matrix which scales and shapes
proposal distribution. If a scalar (in which case the value should be
non-negative) the auxiliary vector will be isotropically scaled by the
value. If a vector (in which case the value should be equal in length to the
dimension of the space and all entries non-negative) each dimension of the
auxiliary vector will be scaled separately. If a matrix (in which case the
value should be a square matrix with size equal to the dimension of the
space) then by pre-multiplying the auxiliary vector arbitrary linear
transformations can be performed.</p>
</td></tr>
<tr><td><code id="sample_barker_+3A_sample_auxiliary">sample_auxiliary</code></td>
<td>
<p>Function which generates a random vector from
auxiliary variable distribution.</p>
</td></tr>
<tr><td><code id="sample_barker_+3A_sample_uniform">sample_uniform</code></td>
<td>
<p>Function which generates a random vector from standard
uniform distribution given an integer size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Proposed new chain state.
</p>

<hr>
<h2 id='sample_chain'>Sample a Markov chain</h2><span id='topic+sample_chain'></span>

<h3>Description</h3>

<p>Sample a Markov chain using Metropolis-Hastings kernel with a user-specified
target distribution and proposal (defaulting to Barker proposal), optionally
adapting proposal parameters in a warm-up stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_chain(
  target_distribution,
  initial_state,
  n_warm_up_iteration,
  n_main_iteration,
  proposal = barker_proposal(),
  adapters = list(scale_adapter(), shape_adapter()),
  show_progress_bar = TRUE,
  trace_warm_up = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_chain_+3A_target_distribution">target_distribution</code></td>
<td>
<p>Target stationary distribution for chain. One of:
</p>

<ul>
<li><p> A one-sided formula specifying expression for log density of target
distribution which will be passed to
<code><a href="#topic+target_distribution_from_log_density_formula">target_distribution_from_log_density_formula()</a></code> to construct functions
to evaluate log density and its gradient using <code><a href="stats.html#topic+deriv">deriv()</a></code>.
</p>
</li>
<li><p> A <code>bridgestan::StanModel</code> instance (requires <code>bridgestan</code> to be
installed) specifying target model and data. Will be passed to
<code><a href="#topic+target_distribution_from_stan_model">target_distribution_from_stan_model()</a></code> using default values for optional
arguments - to override call <code><a href="#topic+target_distribution_from_stan_model">target_distribution_from_stan_model()</a></code>
directly and pass the returned list as the <code>target_distribution</code> argument
here.
</p>
</li>
<li><p> A list with named entries <code>log_density</code> and <code>gradient_log_density</code>
corresponding to respectively functions for evaluating the logarithm of
the (potentially unnormalized) density of the target distribution and its
gradient (only required for gradient-based proposals). As an alternative
to <code>gradient_log_density</code> an entry <code>value_and_gradient_log_density</code> may
instead be provided which is a function returning both the value and
gradient of the logarithm of the (unnormalized) density of the target
distribution as a list under the names <code>value</code> and <code>gradient</code>
respectively. The list may also contain a named entry <code>trace_function</code>,
correspond to a function which given current chain state outputs a named
vector or list of variables to trace on each main (non-adaptive) chain
iteration. If a <code>trace_function</code> entry is not specified, then the default
behaviour is to trace the position component of the chain state along
with the log density of the target distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sample_chain_+3A_initial_state">initial_state</code></td>
<td>
<p>Initial chain state. Either a vector specifying just
the position component of the chain state or a list output by <code>chain_state</code>
specifying the full chain state.</p>
</td></tr>
<tr><td><code id="sample_chain_+3A_n_warm_up_iteration">n_warm_up_iteration</code></td>
<td>
<p>Number of warm-up (adaptive) chain iterations to
run.</p>
</td></tr>
<tr><td><code id="sample_chain_+3A_n_main_iteration">n_main_iteration</code></td>
<td>
<p>Number of main (non-adaptive) chain iterations to
run.</p>
</td></tr>
<tr><td><code id="sample_chain_+3A_proposal">proposal</code></td>
<td>
<p>Proposal distribution object. Defaults to Barker proposal,
that is the output of <code><a href="#topic+barker_proposal">barker_proposal()</a></code>. Proposal objects are lists which
must minimally define entries <code>sample</code>, a function to generate sample from
proposal distribution given current chain state and <code>log_density_ratio</code>, a
function to compute log density ratio for proposal for a given pair of
current and proposed chain states. If adapters are being used to adaptively
tune the proposal scale and shape parameters, which is the default
behaviour of <code>sample_chain</code>, then additionally the list must also define
entries: <code>update</code> a function for updating parameters of proposal,
<code>parameters</code> a function for getting current proposal parameter values,
<code>default_target_accept_prob</code> a function for getting proposal specific
default target acceptance probability for scale adaptation and
<code>default_initial_scale</code> a function for getting proposal and dimension
dependent default initial value for scale parameter.</p>
</td></tr>
<tr><td><code id="sample_chain_+3A_adapters">adapters</code></td>
<td>
<p>List of adapters to tune proposal parameters during warm-up.
Defaults to using list with instances of <code><a href="#topic+scale_adapter">scale_adapter()</a></code> and
<code><a href="#topic+shape_adapter">shape_adapter()</a></code>, corresponding to respectively, adapting the scale to
coerce the average acceptance rate to a target value using a dual-averaging
algorithm, and adapting the shape to an estimate of the covariance of the
target distribution.</p>
</td></tr>
<tr><td><code id="sample_chain_+3A_show_progress_bar">show_progress_bar</code></td>
<td>
<p>Whether to show progress bars during sampling.
Requires <code>progress</code> package to be installed to have an effect.</p>
</td></tr>
<tr><td><code id="sample_chain_+3A_trace_warm_up">trace_warm_up</code></td>
<td>
<p>Whether to record chain traces and adaptation /
transition statistics during (adaptive) warm-up iterations in addition to
(non-adaptive) main chain iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries
</p>

<ul>
<li> <p><code>final_state</code>: the final chain state,
</p>
</li>
<li> <p><code>traces</code>: a matrix with named columns contained traced variables for each
main chain iteration, with variables along columns and iterations along
rows.
</p>
</li>
<li> <p><code>statistics</code>: a matrix with named columns containing transition statistics
for each main chain iteration, with statistics along columns and iterations
along rows.
</p>
</li>
<li> <p><code>warm_up_traces</code>: a matrix with named columns contained traced variables
for each warm-up chain iteration, with variables along columns and
iterations along rows. Only present if <code>trace_warm_up = TRUE</code>.
</p>
</li>
<li> <p><code>warm_up_statistics</code>: a matrix with named columns containing adaptation and
transition statistics for each warm-up chain iteration, with statistics
along columns and iterations along rows. Only present if
<code>trace_warm_up = TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>target_distribution &lt;- list(
  log_density = function(x) -sum(x^2) / 2,
  gradient_log_density = function(x) -x
)
withr::with_seed(876287L, {
  results &lt;- sample_chain(
    target_distribution,
    initial_state = stats::rnorm(2),
    n_warm_up_iteration = 1000,
    n_main_iteration = 1000
  )
})
</code></pre>

<hr>
<h2 id='sample_hamiltonian'>Sample new state from Hamiltonian proposal.</h2><span id='topic+sample_hamiltonian'></span>

<h3>Description</h3>

<p>Sample new state from Hamiltonian proposal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_hamiltonian(
  state,
  target_distribution,
  n_step,
  scale_and_shape,
  sample_auxiliary,
  sample_n_step
)
</code></pre>

<hr>
<h2 id='sample_langevin'>Sample new state from Langevin proposal.</h2><span id='topic+sample_langevin'></span>

<h3>Description</h3>

<p>Sample new state from Langevin proposal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_langevin(
  state,
  target_distribution,
  scale_and_shape,
  sample_auxiliary = stats::rnorm
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_langevin_+3A_sample_auxiliary">sample_auxiliary</code></td>
<td>
<p>Function which generates a random vector from
auxiliary variable distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Proposal object. A list with entries
</p>

<ul>
<li> <p><code>sample</code>: a function to generate sample from proposal distribution given
current chain state,
</p>
</li>
<li> <p><code>log_density_ratio</code>: a  function to compute log density ratio for proposal
for a given pair of current and proposed chain states,
</p>
</li>
<li> <p><code>update</code>: a function to update parameters of proposal,
</p>
</li>
<li> <p><code>parameters</code>: a function to return list of current parameter values.
</p>
</li>
<li> <p><code>default_target_accept_prob</code>: a function returning the default target
acceptance rate to use for any scale adaptation.
</p>
</li>
<li> <p><code>default_initial_scale</code>: a function which given a dimension gives a default
value to use for the initial proposal scale parameter.
</p>
</li></ul>


<hr>
<h2 id='sample_metropolis_hastings'>Sample from Metropolis-Hastings kernel.</h2><span id='topic+sample_metropolis_hastings'></span>

<h3>Description</h3>

<p>Sample from Metropolis-Hastings kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_metropolis_hastings(
  state,
  target_distribution,
  proposal,
  sample_uniform = stats::runif
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_metropolis_hastings_+3A_state">state</code></td>
<td>
<p>Current chain state.</p>
</td></tr>
<tr><td><code id="sample_metropolis_hastings_+3A_target_distribution">target_distribution</code></td>
<td>
<p>Target stationary distribution for chain. A list
with named entries <code>log_density</code> and <code>gradient_log_density</code> corresponding to
respectively functions for evaluating the logarithm of the (potentially
unnormalized) density of the target distribution and its gradient.
As an alternative to <code>gradient_log_density</code> an entry
<code>value_and_gradient_log_density</code> may instead be provided which is a function
returning both the value and gradient of the logarithm of the (unnormalized)
density of the target distribution as a list under the names <code>value</code> and
<code>gradient</code> respectively.</p>
</td></tr>
<tr><td><code id="sample_metropolis_hastings_+3A_proposal">proposal</code></td>
<td>
<p>Proposal distribution object. Must define entries <code>sample</code>, a
function to generate sample from proposal distribution given current chain
state and <code>log_density_ratio</code>, a function to compute log density ratio for
proposal for a given pair of current and proposed chain states.</p>
</td></tr>
<tr><td><code id="sample_metropolis_hastings_+3A_sample_uniform">sample_uniform</code></td>
<td>
<p>Function which generates a random vector from standard
uniform distribution given an integer size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with named entries
</p>

<ul>
<li> <p><code>state</code>: corresponding to new chain state,
</p>
</li>
<li> <p><code>proposed_state</code>: corresponding to proposed chain state,
</p>
</li>
<li> <p><code>statistics</code>: a list with named entries for statistics of transition, here
this consisting of a named entry <code>accept_prob</code> for the Metropolis
acceptance probability.
</p>
</li></ul>


<hr>
<h2 id='sample_random_walk'>Sample new state from random walk proposal.</h2><span id='topic+sample_random_walk'></span>

<h3>Description</h3>

<p>Sample new state from random walk proposal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_random_walk(
  state,
  target_distribution,
  scale_and_shape,
  sample_auxiliary = stats::rnorm
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_random_walk_+3A_sample_auxiliary">sample_auxiliary</code></td>
<td>
<p>Function which generates a random vector from
auxiliary variable distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Proposal object. A list with entries
</p>

<ul>
<li> <p><code>sample</code>: a function to generate sample from proposal distribution given
current chain state,
</p>
</li>
<li> <p><code>log_density_ratio</code>: a  function to compute log density ratio for proposal
for a given pair of current and proposed chain states,
</p>
</li>
<li> <p><code>update</code>: a function to update parameters of proposal,
</p>
</li>
<li> <p><code>parameters</code>: a function to return list of current parameter values.
</p>
</li>
<li> <p><code>default_target_accept_prob</code>: a function returning the default target
acceptance rate to use for any scale adaptation.
</p>
</li>
<li> <p><code>default_initial_scale</code>: a function which given a dimension gives a default
value to use for the initial proposal scale parameter.
</p>
</li></ul>


<hr>
<h2 id='scale_adapter'>Create object to adapt proposal scale to coerce average acceptance rate.</h2><span id='topic+scale_adapter'></span>

<h3>Description</h3>

<p>Create object to adapt proposal scale to coerce average acceptance rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_adapter(
  algorithm = "dual_averaging",
  initial_scale = NULL,
  target_accept_prob = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_adapter_+3A_algorithm">algorithm</code></td>
<td>
<p>String specifying algorithm to use. One of:
</p>

<ul>
<li><p> &quot;stochastic_approximation&quot; to use a Robbins-Monro (1951) based scheme,
</p>
</li>
<li><p> &quot;dual_averaging&quot; to use dual-averaging scheme of Nesterov (2009).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_adapter_+3A_initial_scale">initial_scale</code></td>
<td>
<p>Initial value to use for scale parameter. If not set
explicitly a proposal and dimension dependent default will be used.</p>
</td></tr>
<tr><td><code id="scale_adapter_+3A_target_accept_prob">target_accept_prob</code></td>
<td>
<p>Target value for average accept probability for
chain. If not set a proposal dependent default will be used.</p>
</td></tr>
<tr><td><code id="scale_adapter_+3A_...">...</code></td>
<td>
<p>Any additional algorithmic parameters to pass through to
<code><a href="#topic+dual_averaging_scale_adapter">dual_averaging_scale_adapter()</a></code> or <code><a href="#topic+stochastic_approximation_scale_adapter">stochastic_approximation_scale_adapter()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of functions with entries
</p>

<ul>
<li> <p><code>initialize</code>, a function for initializing adapter state and proposal
parameters at beginning of chain,
</p>
</li>
<li> <p><code>update</code> a function for updating adapter state and proposal parameters on
each chain iteration,
</p>
</li>
<li> <p><code>finalize</code> a function for performing any final updates to adapter state and
proposal parameters on completion of chain sampling (may be <code>NULL</code> if
unused).
</p>
</li>
<li> <p><code>state</code> a zero-argument function for accessing current values of adapter
state variables.
</p>
</li></ul>



<h3>References</h3>

<p>Nesterov, Y. (2009). Primal-dual subgradient methods for convex
problems. <em>Mathematical Programming</em>, 120(1), 221-259.
</p>
<p>Robbins, H., &amp; Monro, S. (1951). A stochastic approximation
method. <em>The Annals of Mathematical Statistics</em>, 400-407.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dual_averaging_scale_adapter">dual_averaging_scale_adapter()</a></code>, <code><a href="#topic+stochastic_approximation_scale_adapter">stochastic_approximation_scale_adapter()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proposal &lt;- barker_proposal()
adapter &lt;- scale_adapter(initial_scale = 1., target_accept_prob = 0.4)
adapter$initialize(proposal, chain_state(c(0, 0)))
</code></pre>

<hr>
<h2 id='shape_adapter'>Create object to adapt proposal shape.</h2><span id='topic+shape_adapter'></span>

<h3>Description</h3>

<p>Create object to adapt proposal shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape_adapter(type = "covariance", kappa = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shape_adapter_+3A_type">type</code></td>
<td>
<p>Type of shape adapter to use. One of:
</p>

<ul>
<li><p> &quot;variance&quot;: Diagonal shape matrix adaptation based on estimates of target
distribution variances (see <code><a href="#topic+variance_shape_adapter">variance_shape_adapter()</a></code>),
</p>
</li>
<li><p> &quot;covariance&quot;: Dense shape matrix adaptation based on estimates of target
distribution covariance matrix (see <code><a href="#topic+covariance_shape_adapter">covariance_shape_adapter()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="shape_adapter_+3A_kappa">kappa</code></td>
<td>
<p>Decay rate exponent in <code style="white-space: pre;">&#8288;[0.5, 1]&#8288;</code> for adaptation learning rate.
Value of 1 (default) corresponds to computing empirical (co)variances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of functions with entries
</p>

<ul>
<li> <p><code>initialize</code>, a function for initializing adapter state and proposal
parameters at beginning of chain,
</p>
</li>
<li> <p><code>update</code> a function for updating adapter state and proposal parameters on
each chain iteration,
</p>
</li>
<li> <p><code>finalize</code> a function for performing any final updates to adapter state and
proposal parameters on completion of chain sampling (may be <code>NULL</code> if
unused).
</p>
</li>
<li> <p><code>state</code> a zero-argument function for accessing current values of adapter
state variables.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+variance_shape_adapter">variance_shape_adapter()</a></code>, <code><a href="#topic+covariance_shape_adapter">covariance_shape_adapter()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proposal &lt;- barker_proposal()
adapter &lt;- shape_adapter()
adapter$initialize(proposal, chain_state(c(0, 0)))
</code></pre>

<hr>
<h2 id='stochastic_approximation_scale_adapter'>Create object to adapt proposal scale to coerce average acceptance rate using
a Robbins and Monro (1951) scheme.</h2><span id='topic+stochastic_approximation_scale_adapter'></span>

<h3>Description</h3>

<p>When combined with <code><a href="#topic+covariance_shape_adapter">covariance_shape_adapter()</a></code> corresponds to Algorithm 4 in
Andrieu and Thoms (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stochastic_approximation_scale_adapter(
  initial_scale = NULL,
  target_accept_prob = NULL,
  kappa = 0.6
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stochastic_approximation_scale_adapter_+3A_initial_scale">initial_scale</code></td>
<td>
<p>Initial value to use for scale parameter. If not set
explicitly a proposal and dimension dependent default will be used.</p>
</td></tr>
<tr><td><code id="stochastic_approximation_scale_adapter_+3A_target_accept_prob">target_accept_prob</code></td>
<td>
<p>Target value for average accept probability for
chain. If not set a proposal dependent default will be used.</p>
</td></tr>
<tr><td><code id="stochastic_approximation_scale_adapter_+3A_kappa">kappa</code></td>
<td>
<p>Decay rate exponent in <code style="white-space: pre;">&#8288;[0.5, 1]&#8288;</code> for adaptation learning rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of functions with entries
</p>

<ul>
<li> <p><code>initialize</code>, a function for initializing adapter state and proposal
parameters at beginning of chain,
</p>
</li>
<li> <p><code>update</code> a function for updating adapter state and proposal parameters on
each chain iteration,
</p>
</li>
<li> <p><code>finalize</code> a function for performing any final updates to adapter state and
proposal parameters on completion of chain sampling (may be <code>NULL</code> if
unused).
</p>
</li>
<li> <p><code>state</code> a zero-argument function for accessing current values of adapter
state variables.
</p>
</li></ul>



<h3>References</h3>

<p>Andrieu, C., &amp; Thoms, J. (2008). A tutorial on adaptive MCMC.
<em>Statistics and Computing</em>, 18, 343-373.
</p>
<p>Robbins, H., &amp; Monro, S. (1951). A stochastic approximation
method. <em>The Annals of Mathematical Statistics</em>, 400-407.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proposal &lt;- barker_proposal()
adapter &lt;- stochastic_approximation_scale_adapter(
  initial_scale = 1., target_accept_prob = 0.4
)
adapter$initialize(proposal, chain_state(c(0, 0)))
</code></pre>

<hr>
<h2 id='target_distribution_from_log_density_formula'>Construct target distribution from a formula specifying log density.</h2><span id='topic+target_distribution_from_log_density_formula'></span>

<h3>Description</h3>

<p>Construct target distribution from a formula specifying log density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target_distribution_from_log_density_formula(log_density_formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="target_distribution_from_log_density_formula_+3A_log_density_formula">log_density_formula</code></td>
<td>
<p>Formula for which right-hand side specifies
expression for logarithm of (unnormalized) density of target distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries
</p>

<ul>
<li> <p><code>log_density</code>: A function to evaluate log density function for target
distribution given current position vector.
</p>
</li>
<li> <p><code>value_and_gradient_log_density</code>: A function to evaluate value and gradient
of log density function for target distribution given current position
vector, returning as a list with entries <code>value</code> and <code>gradient</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>target_distribution &lt;- target_distribution_from_log_density_formula(
  ~ (-(x^2 + y^2) / 8 - (x^2 - y)^2 - (x - 1)^2 / 10)
)
target_distribution$value_and_gradient_log_density(c(0.1, -0.3))
</code></pre>

<hr>
<h2 id='target_distribution_from_stan_model'>Construct target distribution from a BridgeStan <code>StanModel</code> object.</h2><span id='topic+target_distribution_from_stan_model'></span>

<h3>Description</h3>

<p>Construct target distribution from a BridgeStan <code>StanModel</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target_distribution_from_stan_model(
  model,
  include_log_density = TRUE,
  include_generated_quantities = FALSE,
  include_transformed_parameters = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="target_distribution_from_stan_model_+3A_model">model</code></td>
<td>
<p>Stan model object to use for target (posterior) distribution.</p>
</td></tr>
<tr><td><code id="target_distribution_from_stan_model_+3A_include_log_density">include_log_density</code></td>
<td>
<p>Whether to include an entry <code>log_density</code>
corresponding to current log density for target distribution in values
returned by trace function.</p>
</td></tr>
<tr><td><code id="target_distribution_from_stan_model_+3A_include_generated_quantities">include_generated_quantities</code></td>
<td>
<p>Whether to included generated quantities
in Stan model definition in values returned by trace function.</p>
</td></tr>
<tr><td><code id="target_distribution_from_stan_model_+3A_include_transformed_parameters">include_transformed_parameters</code></td>
<td>
<p>Whether to include transformed
parameters in Stan model definition in values returned by trace function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries
</p>

<ul>
<li> <p><code>log_density</code>: A function to evaluate log density function for target
distribution given current position vector.
</p>
</li>
<li> <p><code>value_and_gradient_log_density</code>: A function to evaluate value and gradient
of log density function for target distribution given current position
vector, returning as a list with entries <code>value</code> and <code>gradient</code>.
</p>
</li>
<li> <p><code>trace_function</code>: A function which given a <code>chain_state()</code> object returns a
named vector of values to trace during sampling. The constrained parameter
values of model will always be included.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- example_gaussian_stan_model()
target_distribution &lt;- target_distribution_from_stan_model(model)
withr::with_seed(
  876287L, state &lt;- chain_state(stats::rnorm(model$param_unc_num()))
)
state$log_density(target_distribution)
target_distribution$trace_function(state)

</code></pre>

<hr>
<h2 id='variance_shape_adapter'>Create object to adapt proposal with per dimension scales based on estimates
of target distribution variances.</h2><span id='topic+variance_shape_adapter'></span>

<h3>Description</h3>

<p>Corresponds to variance variant of Algorithm 2 in Andrieu and Thoms (2009),
which is itself a restatement of method proposed in Haario et al. (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance_shape_adapter(kappa = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variance_shape_adapter_+3A_kappa">kappa</code></td>
<td>
<p>Decay rate exponent in <code style="white-space: pre;">&#8288;[0.5, 1]&#8288;</code> for adaptation learning rate.
Value of 1 (default) corresponds to computing empirical variances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of functions with entries
</p>

<ul>
<li> <p><code>initialize</code>, a function for initializing adapter state and proposal
parameters at beginning of chain,
</p>
</li>
<li> <p><code>update</code> a function for updating adapter state and proposal parameters on
each chain iteration,
</p>
</li>
<li> <p><code>finalize</code> a function for performing any final updates to adapter state and
proposal parameters on completion of chain sampling (may be <code>NULL</code> if
unused).
</p>
</li>
<li> <p><code>state</code> a zero-argument function for accessing current values of adapter
state variables.
</p>
</li></ul>



<h3>References</h3>

<p>Andrieu, C., &amp; Thoms, J. (2008). A tutorial on adaptive MCMC.
<em>Statistics and Computing</em>, 18, 343-373.
</p>
<p>Haario, H., Saksman, E., &amp; Tamminen, J. (2001). An adaptive
Metropolis algorithm. <em>Bernoulli</em>, 7(2): 223-242.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proposal &lt;- barker_proposal()
adapter &lt;- variance_shape_adapter()
adapter$initialize(proposal, chain_state(c(0, 0)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
