<!DOCTYPE html><html><head><title>Help for package GGIR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GGIR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GGIR-package'>
<p>A package to process multi-day raw accelerometer data</p></a></li>
<li><a href='#appendRecords'>
<p>Append GGIR milestone data from neighbouring or overlapping recordings</p></a></li>
<li><a href='#applyCosinorAnalyses'>
<p>Apply Cosinor Analyses to time series</p></a></li>
<li><a href='#applyExtFunction'>
<p>Apply external function to acceleration data.</p></a></li>
<li><a href='#CalcSleepRegularityIndex'>
<p>Calculates Sleep Regularity Index</p></a></li>
<li><a href='#check_log'>
<p>Function to revise format of user-provided logs</p></a></li>
<li><a href='#check_myfun'>
<p>Checks myfun object before it is passed to applyExtfunction</p></a></li>
<li><a href='#check_params'>
<p>Check default parameters</p></a></li>
<li><a href='#checkMilestoneFolders'>
<p>Checks for existence of folders to process</p></a></li>
<li><a href='#convertEpochData'>
<p>convert external Epoch data to GGIR part 1 milestone data format</p></a></li>
<li><a href='#correctOlderMilestoneData'>
<p>Corrects milestone data from g.part1 generated in older GGIR versions</p></a></li>
<li><a href='#cosinorAnalyses'>
<p>Apply cosinor anlaysis and extended cosinor analysis</p></a></li>
<li><a href='#create_test_acc_csv'>
<p>Creates csv data file for testing purposes</p></a></li>
<li><a href='#create_test_sleeplog_csv'>
<p>Creates csv sleeplog file for testing purposes</p></a></li>
<li><a href='#createConfigFile'>
<p>Creates Config File based on variables in function GGIR environment</p></a></li>
<li><a href='#data.calibrate'>
<p>Example output from g.calibrate</p></a></li>
<li><a href='#data.getmeta'>
<p>Example output from g.getmeta</p></a></li>
<li><a href='#data.inspectfile'>
<p>Example output from g.inspectfile</p></a></li>
<li><a href='#data.metalong'>
<p>Metalong object as part of part 1 milestone data</p></a></li>
<li><a href='#data.ts'>
<p>Time series data.frame stored by part 5</p></a></li>
<li><a href='#datadir2fnames'>
<p>Generates vector of file names out of datadir input</p>
argument</a></li>
<li><a href='#detect_nonwear_clipping'>
<p>Detect non-wear and clipping time in the raw accelerometer data</p></a></li>
<li><a href='#extract_params'>
<p>Extract parameters from input and add them to params</p></a></li>
<li><a href='#extractID'>
<p>Extract ID from file header object</p></a></li>
<li><a href='#g.abr.day.names'>
<p>Abbreviates daynames to numbers, needed for report generation in</p>
g.plot5</a></li>
<li><a href='#g.analyse'>
<p>Function to analsyse meta-data generated by g.getmeta and g.impute</p></a></li>
<li><a href='#g.analyse.avy'>
<p>Function supports g.analyse. Not intended for direct use by user.</p></a></li>
<li><a href='#g.analyse.perday'>
<p>Function supports g.analyse. Not intended for direct use by user.</p></a></li>
<li><a href='#g.analyse.perfile'>
<p>Function supports g.analyse. Not intended for direct use by user.</p></a></li>
<li><a href='#g.applymetrics'>
<p>Extract metrics from acceleration signals</p></a></li>
<li><a href='#g.calibrate'>
<p>function to estimate calibration error and make recommendation for addressing it</p></a></li>
<li><a href='#g.conv.actlog'>
<p>Function to read activity log and make it useful for the rest of GGIR.</p></a></li>
<li><a href='#g.convert.part2.long'>
<p>Convert part 2 report to long format</p></a></li>
<li><a href='#g.create.sp.mat'>
<p>Converts sleep period information. Not intended for direct use</p></a></li>
<li><a href='#g.detecmidnight'>
<p>Detect all midnights in a time series</p></a></li>
<li><a href='#g.dotorcomma'>
<p>Assesses whether decimals in fileheader are stored with comma</p>
or dot separated decimals</a></li>
<li><a href='#g.extractheadervars'>
<p>Extracts header variables from header object</p></a></li>
<li><a href='#g.fragmentation'>
<p>Fragmentation metrics from time series.</p></a></li>
<li><a href='#g.getbout'>
<p>function to calculate bouts from vector of binary classes</p></a></li>
<li><a href='#g.getM5L5'>
<p>Extract M5 and L5 from time series</p></a></li>
<li><a href='#g.getmeta'>
<p>Function to extract meta-data (features) from data in accelerometer file</p></a></li>
<li><a href='#g.getstarttime'>
<p>Extract start time of a measurement</p></a></li>
<li><a href='#g.impute'>
<p>Function to identify invalid periods in the meta-data as generated by g.getmeta</p>
and to impute these invalid periods with the average of similar timepoints on other
days of the measurement</a></li>
<li><a href='#g.imputeTimegaps'>
<p>Impute gaps in three axis raw accelerometer data</p></a></li>
<li><a href='#g.inspectfile'>
<p>function to inspect accelerometer file for brand, sample frequency and header</p></a></li>
<li><a href='#g.intensitygradient'>
<p>Intensity gradient calculation</p></a></li>
<li><a href='#g.IVIS'>
<p>Calculates IV and IS</p></a></li>
<li><a href='#g.loadlog'>
<p>Load and clean sleeplog information</p></a></li>
<li><a href='#g.part1'>
<p>function to load and pre-process acceleration files</p></a></li>
<li><a href='#g.part2'>
<p>function to analyse and summarize pre-processed output from g.part1</p></a></li>
<li><a href='#g.part3'>
<p>Detection of sustained inactivity periods as needed for sleep detection</p>
in g.part4.</a></li>
<li><a href='#g.part4'>
<p>Labels detected sustained inactivity periods by g.part3 as either</p>
part of the Sleep Period Time window or not</a></li>
<li><a href='#g.part4_extractid'>
<p>Extracts ID from filename and finds matching rows in sleeplog</p></a></li>
<li><a href='#g.part5'>
<p>Merge output from physical activity and sleep analysis into one report</p></a></li>
<li><a href='#g.part5_analyseSegment'>
<p>Analyses the time series per time segment for part 5</p></a></li>
<li><a href='#g.part5_initialise_ts'>
<p>Initialise time series data from for part 5</p></a></li>
<li><a href='#g.part5.addfirstwake'>
<p>Adds first wake if it is missing in part 4 output.</p></a></li>
<li><a href='#g.part5.addsib'>
<p>Adds the sustained inactivity bout to the ts series.</p></a></li>
<li><a href='#g.part5.analyseRest'>
<p>Analyse rest (internal function)</p></a></li>
<li><a href='#g.part5.classifyNaps'>
<p>Classify Naps from identified sustained inactivty bouts</p></a></li>
<li><a href='#g.part5.definedays'>
<p>Fix missing night in part 4 output</p></a></li>
<li><a href='#g.part5.fixmissingnight'>
<p>Fix missing night in part 4 output</p></a></li>
<li><a href='#g.part5.handle_lux_extremes'>
<p>Check lux values for extremes and imputes or removes them</p></a></li>
<li><a href='#g.part5.lux_persegment'>
<p>Extract key lux variables per segment of the data.</p></a></li>
<li><a href='#g.part5.onsetwaketiming'>
<p>Identify wake and sleepperiod window timing</p></a></li>
<li><a href='#g.part5.savetimeseries'>
<p>Saves part 5 time series to csv files</p></a></li>
<li><a href='#g.part5.wakesleepwindows'>
<p>Label wake and sleepperiod window</p></a></li>
<li><a href='#g.part6'>
<p>Perform temporal pattern analyses</p></a></li>
<li><a href='#g.plot'>
<p>function to generate a plot for quality check purposes</p></a></li>
<li><a href='#g.plot5'>
<p>Generate user-friendly visual report. The first part of the report summarizes important daily metrics in bar plot format.</p>
The second part of the report shows the raw data and annotations in 24-hr periods.
Angle-z is shown with sleep annotations during the SPT (sleep period time) window.
ENMO is shown with daytime inactivity and PA (physical activity) annotations in the lower
section of each 24-hr plot. The PA annotations are based on a 10 minute bout metric and
80
of a 10 minute bout of MVPA. Vigorous PA is a short window of time above threshold.vig that
is part of a bout of MVPA. Light PA is a short window of time above threshold.lig that is
part of a bout of light PA.</a></li>
<li><a href='#g.readaccfile'>
<p>Generic functiont to read large blocks of accelerometer data</p></a></li>
<li><a href='#g.readtemp_movisens'>
<p>Reads the temperature from movisens files.</p></a></li>
<li><a href='#g.report.part2'>
<p>Generate report from milestone data produced by g.part2</p></a></li>
<li><a href='#g.report.part4'>
<p>Generate report from milestone data produced by g.part4</p></a></li>
<li><a href='#g.report.part5'>
<p>Generate report from milestone data produced by g.part5</p></a></li>
<li><a href='#g.report.part5_dictionary'>
<p>Generate data dictionary for reports from milestone data produced by g.part5</p></a></li>
<li><a href='#g.report.part6'>
<p>Generate report from milestone data produced by g.part6</p></a></li>
<li><a href='#g.shell.GGIR'>
<p>Wrapper function around function GGIR</p></a></li>
<li><a href='#g.sib.det'>
<p>sustiained inactivty bouts detection</p></a></li>
<li><a href='#g.sib.plot'>
<p>Create plot of sustained inactivity bouts</p></a></li>
<li><a href='#g.sib.sum'>
<p>sustiained inactivty bouts detection</p></a></li>
<li><a href='#g.sibreport'>
<p>Generate sustiained inactivty bouts report</p></a></li>
<li><a href='#g.weardec'>
<p>Detects whether accelerometer is worn</p></a></li>
<li><a href='#get_nw_clip_block_params'>
<p>Set monitor brand specific parameters</p></a></li>
<li><a href='#get_starttime_weekday_truncdata+20'>
<p>Get starttime (adjusted), weekday, and adjust data accordingly.</p></a></li>
<li><a href='#getfolderstructure'>
<p>Extracts folderstructure based on data directory.</p></a></li>
<li><a href='#GGIR'>
<p>Shell function for analysing an accelerometer dataset.</p></a></li>
<li><a href='#HASIB'>
<p>Heuristic algorithms for sustiained inactivty bouts detection</p></a></li>
<li><a href='#HASPT'>
<p>Heuristic Algorithms estimating SPT window.</p></a></li>
<li><a href='#identify_levels'>
<p>Identifies levels of behaviour for g.part5 function.</p></a></li>
<li><a href='#is_this_a_dst_night'>
<p>Check whether the night starting on a calendar date has DST.</p></a></li>
<li><a href='#is.ISO8601'>
<p>Check whether character timestamp is in iso8601 format.</p></a></li>
<li><a href='#isfilelist'>
<p>Checks whether datadir is a directory or a vector with</p>
filenames</a></li>
<li><a href='#ismovisens'>
<p>Checks whether the files to process are collected with movisens accelerometers.</p></a></li>
<li><a href='#iso8601chartime2POSIX'>
<p>Convert iso8601 timestamps to POSIX timestamp</p></a></li>
<li><a href='#load_params'>
<p>Load default parameters</p></a></li>
<li><a href='#parametersVignette'>
<p>Builds Section for Parameters Vignette</p></a></li>
<li><a href='#part6AlignIndividuals'><p>part6AlignIndividuals</p></a></li>
<li><a href='#part6PairwiseAggregation'><p>part6PairwiseAggregation</p></a></li>
<li><a href='#POSIXtime2iso8601'>
<p>Convert POSIX to iso8601 timestamp</p></a></li>
<li><a href='#read.myacc.csv'>
<p>Read custom csv files with accelerometer data</p></a></li>
<li><a href='#ShellDoc2Vignette'>
<p>Extract Definition from Shell Documentation</p></a></li>
<li><a href='#tidyup_df'>
<p>Round numeric columns and replace NA/NaN values by blank</p></a></li>
<li><a href='#updateBlocksize'>
<p>Update blocksize of data to be read depending on available memory.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Raw Accelerometer Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-02</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A tool to process and analyse data collected with wearable raw acceleration sensors as described in Migueles and colleagues (JMPB 2019), and van Hees and colleagues (JApplPhysiol 2014; PLoSONE 2015). The package has been developed and tested for binary data from 'GENEActiv' <a href="https://activinsights.com/">https://activinsights.com/</a>, binary (.gt3x) and .csv-export data from  'Actigraph' <a href="https://theactigraph.com">https://theactigraph.com</a> devices, and binary (.cwa) and .csv-export data from 'Axivity' <a href="https://axivity.com">https://axivity.com</a>. These devices are currently widely used in research on human daily physical activity. Further, the package can handle accelerometer data file from any other sensor brand providing that the data is stored in csv format. Also the package allows for external function embedding.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/wadpac/GGIR/">https://github.com/wadpac/GGIR/</a>,
<a href="https://groups.google.com/forum/#!forum/RpackageGGIR">https://groups.google.com/forum/#!forum/RpackageGGIR</a>,
<a href="https://wadpac.github.io/GGIR/">https://wadpac.github.io/GGIR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wadpac/GGIR/issues">https://github.com/wadpac/GGIR/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a> | file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown, actilifecounts, readxl</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, foreach, doParallel, signal, zoo, unisensR, ineq,
methods, psych, irr, lubridate, GGIRread, ActCR, read.gt3x</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats, utils, R (&ge; 3.5)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-02 15:17:28 UTC; vvanh</td>
</tr>
<tr>
<td>Author:</td>
<td>Vincent T van Hees [aut, cre],
  Jairo H Migueles <a href="https://orcid.org/0000-0003-0366-6935"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Severine Sabia [ctb],
  Matthew R Patterson [ctb],
  Zhou Fang [ctb],
  Joe Heywood [ctb],
  Joan Capdevila Pujol [ctb],
  Lena Kushleyeva [ctb],
  Mathilde Chen [ctb],
  Manasa Yerramalla [ctb],
  Patrick Bos <a href="https://orcid.org/0000-0002-6033-960X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Taren Sanders [ctb],
  Chenxuan Zhao [ctb],
  Medical Research Council UK [cph, fnd],
  Accelting [cph, fnd],
  French National Research Agency [cph, fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-02 15:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='GGIR-package'>
A package to process multi-day raw accelerometer data
</h2><span id='topic+GGIR-package'></span>

<h3>Description</h3>

<p>Disclaimer: If you are a new GGIR user then please see
<a href="https://wadpac.github.io/GGIR/">the GGIR github-pages</a>
for a narrative overview of GGIR.<br />
<br />
This document is primarily aimed at documenting the functions and their input arguments.<br />
<br />
Please note that there is google discussion group for this package (link below).<br />
<br />
You can thank us for sharing the code in this package and for developing
it as a generic purpose tool by citing the package name and by
citing the supporting publications (e.g. Migueles et al. 2019) in your publications.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  Package: </td><td style="text-align: left;"> GGIR</td>
</tr>
<tr>
 <td style="text-align: left;">
  Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
  Version: </td><td style="text-align: left;"> 3.1-2</td>
</tr>
<tr>
 <td style="text-align: left;">
  Date: </td><td style="text-align: left;"> 2024-07-02</td>
</tr>
<tr>
 <td style="text-align: left;">
  License: </td><td style="text-align: left;"> Apache License (== 2.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
  Discussion group: </td><td style="text-align: left;"> https://groups.google.com/forum/#!forum/rpackageggir</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>


<ul>
<li><p> Vincent T van Hees &lt;v.vanhees@accelting.com&gt; main creator and developer
</p>
</li>
<li><p> Zhou Fang developed calibration algorithm used in function <a href="#topic+g.calibrate">g.calibrate</a>
</p>
</li>
<li><p> Joe Heywood helped develop the functionality to process specific recording days
</p>
</li>
<li><p> Severine Sabia, Mathilde Chen, and Manasa Yerramalla extensively tested and provided feedback on various functions
</p>
</li>
<li><p> Joan Capdevila Pujol helped to improve various functions
</p>
</li>
<li><p> Jairo H Migueles &lt;jairohm@ugr.es&gt; helped to improve various functions
</p>
</li>
<li><p> Matthew R Patterson helped with enhancing the visual report.
</p>
</li>
<li><p> Lena Kushleyeva helped fix bug in sleep detection.
</p>
</li>
<li><p> Taren Sanders helped tidy up the parallel processing functionality
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Migueles JH, Rowlands AV, et al. GGIR: A Research Community-Driven Open Source
R Package for Generating Physical Activity and Sleep Outcomes From Multi-Day Raw
Accelerometer Data. Journal for the Measurement of Physical Behaviour. 2(3) 2019.
doi:10.1123/jmpb.2018-0063.
</p>
</li>
<li><p> van Hees VT, Gorzelniak L, Dean Leon EC, Eder M, Pias M, et al. (2013) Separating
Movement and Gravity Components in an Acceleration Signal and Implications for the
Assessment of Human Daily Physical Activity. PLoS ONE 8(4): e61691.
doi:10.1371/journal.pone.0061691
</p>
</li>
<li><p> van Hees VT, Fang Z, Langford J, Assah F, Mohammad A, da Silva IC, Trenell MI,
White T, Wareham NJ, Brage S. Auto-calibration of accelerometer data for
free-living physical activity assessment using local gravity and temperature:
an evaluation on four continents. J Appl Physiol (1985). 2014 Aug 7
</p>
</li>
<li><p> van Hees VT, Sabia S, et al. (2015) A novel, open access method to
assess sleep duration using a wrist-worn accelerometer, PLoS ONE, November 2015
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    #inspect file:
    I = g.inspectfile(datafile)

    #autocalibration:
    C = g.calibrate(datafile)

    #get meta-data:
    M = g.getmeta(datafile)
  
## End(Not run)
  data(data.getmeta)
  data(data.inspectfile)
  data(data.calibrate)

  #impute meta-data:
  IMP = g.impute(M = data.getmeta, I = data.inspectfile)
  #analyse and produce summary:
  A = g.analyse(I = data.inspectfile, C = data.calibrate, M = data.getmeta, IMP, ID = "01wk0")
  #plot data
  g.plot(IMP, M = data.getmeta, I = data.inspectfile, durplot=4)
</code></pre>

<hr>
<h2 id='appendRecords'>
Append GGIR milestone data from neighbouring or overlapping recordings
</h2><span id='topic+appendRecords'></span>

<h3>Description</h3>

<p>Append GGIR part 1 milestone data format from neighbouring or overlapping recording.
When recordings overlap we use data from newest recordings. When time gap is larger
than 2 days the recordings are not appended. Not intended for direct use by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   appendRecords(metadatadir, desiredtz = "", idloc = 1, maxRecordingInterval = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appendRecords_+3A_metadatadir">metadatadir</code></td>
<td>

<p>See <a href="#topic+g.part2">g.part2</a>
</p>
</td></tr>
<tr><td><code id="appendRecords_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="appendRecords_+3A_idloc">idloc</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="appendRecords_+3A_maxrecordinginterval">maxRecordingInterval</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='applyCosinorAnalyses'>
Apply Cosinor Analyses to time series
</h2><span id='topic+applyCosinorAnalyses'></span>

<h3>Description</h3>

<p>Wrapper function around <a href="#topic+cosinorAnalyses">cosinorAnalyses</a> that first prepares the time series
before applying the cosinorAnlayses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  applyCosinorAnalyses(ts, qcheck, midnightsi, epochsizes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyCosinorAnalyses_+3A_ts">ts</code></td>
<td>

<p>Data.frame with timestamps and acceleration metric.
</p>
</td></tr>
<tr><td><code id="applyCosinorAnalyses_+3A_qcheck">qcheck</code></td>
<td>

<p>Vector of equal length as number of rows in ts with value 1 for invalid
timestamps, 0 otherwise.
</p>
</td></tr>
<tr><td><code id="applyCosinorAnalyses_+3A_midnightsi">midnightsi</code></td>
<td>

<p>Indices for midnights in the time series
</p>
</td></tr>
<tr><td><code id="applyCosinorAnalyses_+3A_epochsizes">epochsizes</code></td>
<td>

<p>Epoch size for ts and qcheck respectively
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='applyExtFunction'>
Apply external function to acceleration data.
</h2><span id='topic+applyExtFunction'></span>

<h3>Description</h3>

<p>Applies external function to the raw acceleration data within GGIR.
This makes it easier for new algorithms developed to be pilotted
on accelerometer data while taking advantage of the existing comprehensive GGIR
data management and analysis infrastructure.
This function is not for direct interaction by user, please supply object 
<code>myfun</code> to <a href="#topic+GGIR">GGIR</a> or <a href="#topic+g.part1">g.part1</a>. Object <code>myfun</code>
is a list as detailed below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  applyExtFunction(data, myfun, sf, ws3, interpolationType=1)
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyExtFunction_+3A_data">data</code></td>
<td>

<p>Data data.frame as present internally in <a href="#topic+g.getmeta">g.getmeta</a>. It has at least
four columns of which the first is the timestamp followed by the x, y,
and z acceleration.
</p>
</td></tr>
<tr><td><code id="applyExtFunction_+3A_myfun">myfun</code></td>
<td>

<p>See details, in short: myfun is a list object that holds the external function
to be applied to the data and various parameters to aid in the process.
</p>
</td></tr>
<tr><td><code id="applyExtFunction_+3A_sf">sf</code></td>
<td>

<p>Sample frequency (Hertz) of the data object
</p>
</td></tr>
<tr><td><code id="applyExtFunction_+3A_ws3">ws3</code></td>
<td>

<p>Short epoch size (first value of windowsizes in <a href="#topic+g.getmeta">g.getmeta</a>).
</p>
</td></tr>
<tr><td><code id="applyExtFunction_+3A_interpolationtype">interpolationType</code></td>
<td>

<p>Integer to indicate type of interpolation to be used when resampling time series (mainly relevant for Axivity sensors), 1=linear, 2=nearest neighbour.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See package vignette for detailed tutorial with examples
on how to use the function embedding:
https://cran.r-project.org/web/package=GGIR/vignettes/applyExtFunction.pdf
Function applyExtFunction
is typically not used by the GGIR user directly.
</p>


<h3>Value</h3>

<p>The output of the external algorithm aggregated or repeated to fit the
short epoch length of GGIR. Therefore, the short epoch length of GGIR
should be a multitude of the resolution of the external function output,
or visa versa.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='CalcSleepRegularityIndex'>
Calculates Sleep Regularity Index
</h2><span id='topic+CalcSleepRegularityIndex'></span>

<h3>Description</h3>

<p>Calculates Sleep Regularity Index per day pair proposed by Phillips and 
colleagues in 2017 expanded with day-pair level estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  CalcSleepRegularityIndex(data = c(), epochsize = c(), desiredtz= c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcSleepRegularityIndex_+3A_data">data</code></td>
<td>

<p>Data.frame produced by function <a href="#topic+g.sib.det">g.sib.det</a>.
</p>
</td></tr>
<tr><td><code id="CalcSleepRegularityIndex_+3A_epochsize">epochsize</code></td>
<td>

<p>Numeric value of epoch size in seconds.
</p>
</td></tr>
<tr><td><code id="CalcSleepRegularityIndex_+3A_desiredtz">desiredtz</code></td>
<td>

<p>Character with timezone database name, see also <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates Sleep Regularity Index per day pair. Absense of missing data is not used 
as a criteria for calculation. Instead the code asses the fraction of the time for which
matching valid data points were found in both days. Later in g.part4 this fraction is used
to include or exclude days based on the excludenightcrit criteria it also uses for the other
sleep variables. In g.report.part4 these day-level SRI values are stored, but also
aggregated across all recording days, all weekend days, and all weekend days, respectively. 
Therefore, this function is broader in functionality than the algorithm proposed by Phillips and 
colleagues in 2017.
</p>


<h3>Value</h3>

<p>Data.frame with columns: day (day number); Sleep Regularity Index, which by definition must lie in the 
range -100 (reversed regularity), to 0 (random pattern), to 100 (perfect regularity);
weekday (e.g. Wednesday); frac_valid, number between 0 and 1 indicating the fraction of the 24 hour
period for which valid data was available in both the current and the next day, and; date.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> Andrew J. K. Phillips, William M. Clerx, et al. Irregular sleep/wake patterns 
are associated with poorer academic performance and delayed circadian and 
sleep/wake timing. Scientific Reports. 2017 June 12
</p>
</li></ul>


<hr>
<h2 id='check_log'>
Function to revise format of user-provided logs
</h2><span id='topic+check_log'></span>

<h3>Description</h3>

<p>Function to revise the format for missing values and dates in user-provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  check_log(log, dateformat, colid = 1, datecols = c(), 
            logPath, logtype)	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_log_+3A_log">log</code></td>
<td>

<p>Data frame with the log as read by <code>data.table::fread</code>.
</p>
</td></tr>
<tr><td><code id="check_log_+3A_dateformat">dateformat</code></td>
<td>

<p>Character specifying the expected date format used in the log.
</p>
</td></tr>
<tr><td><code id="check_log_+3A_colid">colid</code></td>
<td>

<p>Numeric with the column containing the file ID.
</p>
</td></tr>
<tr><td><code id="check_log_+3A_datecols">datecols</code></td>
<td>

<p>Numeric with the column/s containing the dates.
</p>
</td></tr>
<tr><td><code id="check_log_+3A_logpath">logPath</code></td>
<td>

<p>Character containing the full path to the activity log that is being checked.
</p>
</td></tr>
<tr><td><code id="check_log_+3A_logtype">logtype</code></td>
<td>

<p>Character which accepts &quot;activity log&quot; or &quot;study dates log&quot; at the moment.
Only used for warning messages.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame containing the revised log.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
Jairo H Migueles &lt;jairo@jhmigueles.com&gt;
</p>

<hr>
<h2 id='check_myfun'>
Checks myfun object before it is passed to applyExtfunction
</h2><span id='topic+check_myfun'></span>

<h3>Description</h3>

<p>Checks that object myfun is a list and check the elements of the
list for: that element names are as expected, that value of each
element is of the expected type and length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  check_myfun(myfun, windowsizes)
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_myfun_+3A_myfun">myfun</code></td>
<td>

<p>See <a href="#topic+applyExtFunction">applyExtFunction</a>
</p>
</td></tr>
<tr><td><code id="check_myfun_+3A_windowsizes">windowsizes</code></td>
<td>

<p>See <a href="#topic+g.getmeta">g.getmeta</a>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>0 if all checkes passed, 1 if one or more checks did not pass. Error
message are printed to the console with feedback on which checks did 
not pass.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='check_params'>
Check default parameters
</h2><span id='topic+check_params'></span>

<h3>Description</h3>

<p>Checks parameter objects for class and logical combinations.
Called from <a href="#topic+extract_params">extract_params</a>. Not intended for direct use by GGIR users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  check_params(params_sleep = c(), params_metrics = c(),
                        params_rawdata = c(), params_247 = c(),
                        params_phyact = c(), params_cleaning = c(),
                         params_output = c(), params_general = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_params_+3A_params_sleep">params_sleep</code></td>
<td>

<p>List with sleep parameters
</p>
</td></tr>
<tr><td><code id="check_params_+3A_params_metrics">params_metrics</code></td>
<td>

<p>List with parameters related to metrics
</p>
</td></tr>
<tr><td><code id="check_params_+3A_params_rawdata">params_rawdata</code></td>
<td>

<p>List with parameters related to raw data reading and processing
</p>
</td></tr>
<tr><td><code id="check_params_+3A_params_247">params_247</code></td>
<td>

<p>List with parameters related to 24/7 behavioural analysis, which includes anything
that does not fit with physical activity or sleep research
</p>
</td></tr>
<tr><td><code id="check_params_+3A_params_phyact">params_phyact</code></td>
<td>

<p>List with parameters related to physical activity analysis
</p>
</td></tr>
<tr><td><code id="check_params_+3A_params_cleaning">params_cleaning</code></td>
<td>

<p>List with parameters related to cleaning the time series, including masking and imputation
</p>
</td></tr>
<tr><td><code id="check_params_+3A_params_output">params_output</code></td>
<td>

<p>List with parameters related to how GGIR stores its output
</p>
</td></tr>
<tr><td><code id="check_params_+3A_params_general">params_general</code></td>
<td>

<p>List with parameters related to general topics
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lists of updated parameter objects 
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='checkMilestoneFolders'>
Checks for existence of folders to process
</h2><span id='topic+checkMilestoneFolders'></span>

<h3>Description</h3>

<p>Checks whether milestone folders exist, create them if needed,
and check whether folders are not empty. Only done for part 1 to 5
and not part 6, which is different and handled inside <a href="#topic+g.part6">g.part6</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  checkMilestoneFolders(metadatadir, partNumber)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkMilestoneFolders_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Character, path to root of outputfolder.
</p>
</td></tr>
<tr><td><code id="checkMilestoneFolders_+3A_partnumber">partNumber</code></td>
<td>

<p>Numeric, number from the set 2, 3, 4 or 5.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is produced
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='convertEpochData'>
convert external Epoch data to GGIR part 1 milestone data format
</h2><span id='topic+convertEpochData'></span>

<h3>Description</h3>

<p>convert externally created Epoch data to GGIR part 1 milestone data format. Function not
intended for direct use by user. The aim is to allow for using GGIR on top of
extrnally derived epoch data. See argument dataFormat in the <a href="#topic+GGIR">GGIR</a> for details on
how to use this functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   convertEpochData(datadir = c(), metadatadir = c(),
                    params_general = c(), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertEpochData_+3A_datadir">datadir</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="convertEpochData_+3A_metadatadir">metadatadir</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="convertEpochData_+3A_params_general">params_general</code></td>
<td>

<p>Parameters object see <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="convertEpochData_+3A_verbose">verbose</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='correctOlderMilestoneData'>
Corrects milestone data from g.part1 generated in older GGIR versions
</h2><span id='topic+correctOlderMilestoneData'></span>

<h3>Description</h3>

<p>Some older versions of GGIR stored the milestone data in part 1 as factor.
This function identifies when that occurs and convert the affected columns
to the appropriate class (e.g., numeric).</p>


<h3>Usage</h3>

<pre><code class='language-R'>  correctOlderMilestoneData(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctOlderMilestoneData_+3A_x">x</code></td>
<td>

<p>Data frame with metashort or metalong data as generated in <a href="#topic+g.part1">g.part1</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the class fixed in the appropriate columns (i.e., light and 
temperature columns)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    correctOlderMilestoneData(x)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='cosinorAnalyses'>
Apply cosinor anlaysis and extended cosinor analysis
</h2><span id='topic+cosinorAnalyses'></span>

<h3>Description</h3>

<p>Applies cosinor anlaysis from the ActCR package to the time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cosinorAnalyses(Xi, epochsize = 60, timeOffsetHours = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosinorAnalyses_+3A_xi">Xi</code></td>
<td>

<p>Vector with time series of movement indicators
</p>
</td></tr>
<tr><td><code id="cosinorAnalyses_+3A_epochsize">epochsize</code></td>
<td>

<p>Numeric epochsize in seconds
</p>
</td></tr>
<tr><td><code id="cosinorAnalyses_+3A_timeoffsethours">timeOffsetHours</code></td>
<td>

<p>Numeric time in hours relative to next midnight
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='create_test_acc_csv'>
Creates csv data file for testing purposes
</h2><span id='topic+create_test_acc_csv'></span>

<h3>Description</h3>

<p>Creates file in the Actigraph csv data format with dummy data
that can be used for testing. The file includes accelerometer data 
with bouts of higher acceleration, variations non-movement periods
in a range of accelerometer positions to allow for testing the
auto-calibration functionality.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  create_test_acc_csv(sf=3,Nmin=2000,storagelocation=c(),
                      start_time = NULL, starts_at_midnight = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_test_acc_csv_+3A_sf">sf</code></td>
<td>

<p>Sample frequency in Hertz, the default here is low to minimize file size
</p>
</td></tr>
<tr><td><code id="create_test_acc_csv_+3A_nmin">Nmin</code></td>
<td>

<p>Number of minutes (minimum is 720)
</p>
</td></tr>
<tr><td><code id="create_test_acc_csv_+3A_storagelocation">storagelocation</code></td>
<td>

<p>Location where the test file named testfile.csv will be stored
If no value is provided then the function uses the current 
working directory
</p>
</td></tr>
<tr><td><code id="create_test_acc_csv_+3A_start_time">start_time</code></td>
<td>

<p>Start time of the recording, in the hh:mm:ss format.
</p>
</td></tr>
<tr><td><code id="create_test_acc_csv_+3A_starts_at_midnight">starts_at_midnight</code></td>
<td>

<p>Boolean indicating whether the recording should start at 
midnight. Ignored if start_time is specified.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function does not produce any output values. Only the file is
stored
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    create_test_acc_csv()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='create_test_sleeplog_csv'>
Creates csv sleeplog file for testing purposes
</h2><span id='topic+create_test_sleeplog_csv'></span>

<h3>Description</h3>

<p>Creates sleeplog file in the format as expected by g.part4
with dummy data (23:00 onset, 07:00 waking time for every night).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  create_test_sleeplog_csv(Nnights = 7, storagelocation = c(),
                            advanced = FALSE, sep = ",")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_test_sleeplog_csv_+3A_nnights">Nnights</code></td>
<td>

<p>Number of nights (minimum is 1)
</p>
</td></tr>
<tr><td><code id="create_test_sleeplog_csv_+3A_storagelocation">storagelocation</code></td>
<td>

<p>Location where the test file named testfile.csv will be stored
If no value is provided then the function uses the current 
working directory
</p>
</td></tr>
<tr><td><code id="create_test_sleeplog_csv_+3A_advanced">advanced</code></td>
<td>

<p>Boolean to indicate whether to create an advanced sleeplog that also includes
logs of nap times and nonwear
</p>
</td></tr>
<tr><td><code id="create_test_sleeplog_csv_+3A_sep">sep</code></td>
<td>

<p>Character to indicate the column separator of the csv file.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function does not produce any output values. Only the file is
stored
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    create_test_sleeplog_csv()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='createConfigFile'>
Creates Config File based on variables in function GGIR environment
</h2><span id='topic+createConfigFile'></span>

<h3>Description</h3>

<p>Only used inside <a href="#topic+GGIR">GGIR</a>. Not intended for direct use by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  createConfigFile(config.parameters = c(), GGIRversion = "")	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createConfigFile_+3A_config.parameters">config.parameters</code></td>
<td>

<p>List with all arguments used in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="createConfigFile_+3A_ggirversion">GGIRversion</code></td>
<td>

<p>GGIR version mumber to be incorported in the ConfigFile.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='data.calibrate'>
Example output from g.calibrate
</h2><span id='topic+data.calibrate'></span>

<h3>Description</h3>

<p>data.calibrate is example output from <a href="#topic+g.calibrate">g.calibrate</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.calibrate)</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;data.calibrate&quot;
</p>


<h3>Source</h3>

<p>The data was collected on one individual for testing purposes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data.calibrate)
</code></pre>

<hr>
<h2 id='data.getmeta'>
Example output from g.getmeta
</h2><span id='topic+data.getmeta'></span>

<h3>Description</h3>

<p>data.getmeta is example output from <a href="#topic+g.getmeta">g.getmeta</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.getmeta)</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;data.getmeta&quot;
</p>


<h3>Source</h3>

<p>The data was collected on one individual for testing purposes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data.getmeta)
</code></pre>

<hr>
<h2 id='data.inspectfile'>
Example output from g.inspectfile
</h2><span id='topic+data.inspectfile'></span>

<h3>Description</h3>

<p>data.inspectfile is example output from <a href="#topic+g.inspectfile">g.inspectfile</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.inspectfile)</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;data.inspectfile&quot;
</p>


<h3>Source</h3>

<p>The data was collected on one individual for testing purposes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data.inspectfile)
</code></pre>

<hr>
<h2 id='data.metalong'>
Metalong object as part of part 1 milestone data
</h2><span id='topic+data.metalong'></span>

<h3>Description</h3>

<p>data.metalong is example of the metalong data.frame stored <a href="#topic+g.part1">g.part1</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.metalong)</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;data.metalong&quot;
</p>


<h3>Source</h3>

<p>The data was collected on one individual for testing purposes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(data.metalong)
</code></pre>

<hr>
<h2 id='data.ts'>
Time series data.frame stored by part 5
</h2><span id='topic+data.ts'></span>

<h3>Description</h3>

<p>data.ts is example of the data.frame stored <a href="#topic+g.part5">g.part5</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.ts)</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;data.ts&quot;
</p>


<h3>Source</h3>

<p>The data was collected on one individual for testing purposes and matches the data
in object data.metalong
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(data.ts)
</code></pre>

<hr>
<h2 id='datadir2fnames'>
Generates vector of file names out of datadir input
argument
</h2><span id='topic+datadir2fnames'></span>

<h3>Description</h3>

<p>Uses input argument datadir from <a href="#topic+g.part1">g.part1</a> and
the output from <a href="#topic+isfilelist">isfilelist</a> to generate vector of filenames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  datadir2fnames(datadir,filelist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datadir2fnames_+3A_datadir">datadir</code></td>
<td>

<p>See <a href="#topic+g.part1">g.part1</a>
</p>
</td></tr>
<tr><td><code id="datadir2fnames_+3A_filelist">filelist</code></td>
<td>

<p>Produced by <a href="#topic+isfilelist">isfilelist</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of filenames
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  datadir2fnames(datadir = "C:/mydatafolder",filelist=TRUE)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='detect_nonwear_clipping'>
Detect non-wear and clipping time in the raw accelerometer data
</h2><span id='topic+detect_nonwear_clipping'></span>

<h3>Description</h3>

<p>Detects periods in which the accelerometer has not been worn or the
accelerometer signal was stuck very close to the dynamic range limit
of the accelerometer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_nonwear_clipping(data = c(), windowsizes = c(5, 900, 3600), sf = 100,
                        clipthres = 7.5, sdcriter = 0.013, racriter = 0.05,
                        nonwear_approach = "2013",
                        params_rawdata = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_nonwear_clipping_+3A_data">data</code></td>
<td>

<p>Matrix with raw accelerometer data for X, Y, and Z axes.
</p>
</td></tr>
<tr><td><code id="detect_nonwear_clipping_+3A_windowsizes">windowsizes</code></td>
<td>

<p>Numeric vector of length three, with short, long epoch and window size in seconds.
</p>
</td></tr>
<tr><td><code id="detect_nonwear_clipping_+3A_sf">sf</code></td>
<td>

<p>Sample frequency in Hertz.
</p>
</td></tr>
<tr><td><code id="detect_nonwear_clipping_+3A_clipthres">clipthres</code></td>
<td>

<p>Threschold to detect clipping in _g_ units. Usually 0.5 _g_ below the 
dynamic range of the accelerometer.
</p>
</td></tr>
<tr><td><code id="detect_nonwear_clipping_+3A_sdcriter">sdcriter</code></td>
<td>

<p>Criteria to define non-wear time, defined as the estimated noise
measured in the raw accelerometer data.
</p>
</td></tr>
<tr><td><code id="detect_nonwear_clipping_+3A_racriter">racriter</code></td>
<td>

<p>Absolute criteria below which the absolute range of the accelerations
should be to define non-wear time.
</p>
</td></tr>
<tr><td><code id="detect_nonwear_clipping_+3A_nonwear_approach">nonwear_approach</code></td>
<td>

<p>Whether to use the traditional version of the non-wear detection algorithm
(nonwear_approach = &quot;2013&quot;, default) or the new version (nonwear_approach = &quot;2023&quot;). 
The 2013 version would use the longsize window (windowsizes[3], one hour as default)
to check the conditions for nonwear identification and would flag as nonwear the
mediumsize window (windowsizes[2], 15 min as default) in the middle. The 2023 
version differs in which it would flag as nonwear the full longsize window. For the 2013
method the longsize window is centered in the centre of the mediumsize window, while in 
the 2023 method the longsizewindow is aligned with its left edge to the left edge of the 
mediumsize window.
</p>
</td></tr>
<tr><td><code id="detect_nonwear_clipping_+3A_params_rawdata">params_rawdata</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the next numeric vectors: 
</p>

<ul>
<li><p> NWav (non-wear score), from 1 to 3 indicating the number of axes that met the non wear criteria. 
</p>
</li>
<li><p> CWav (clipping score), binary, 0-1 indicating non-clipping and clipping, respectively.
</p>
</li>
<li><p> nmin is the minimum numebr of windows in this block of data.
</p>
</li></ul>

<p>Each number in these vectors represent a long epoch duration (i.e., ws2, 900 seconds by default).
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
Jairo Hidalgo Migueles &lt;j.h.migueles@accelting.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> van Hees  et al. 2011, doi: 10.1371/journal.pone.0022922.
</p>
</li>
<li><p> van Hees et al. 2013, doi: 10.1371/journal.pone.0061691 (in supplementary material).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    detect_nonwear_clipping(data = data, windowsizes = c(900, 3600), sf = sf,
                            clipthres = clipthres, sdcriter = sdcriter, 
                            racriter = racriter, nonwear_approach = "old")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='extract_params'>
Extract parameters from input and add them to params
</h2><span id='topic+extract_params'></span>

<h3>Description</h3>

<p>Extracts parameters separately provided by input and adds them to the params objects.
Not intended for direct use by GGIR users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  extract_params(params_sleep = c(), params_metrics = c(),
                 params_rawdata = c(), params_247 = c(),
                 params_phyact = c(), params_cleaning = c(),
                 params_output = c(), params_general = c(), input = c(),
                 configfile_csv = c(), params2check = c("sleep", "metrics",
                 "rawdata", "247", "phyact",
                                           "cleaning", "output", "general"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_params_+3A_params_sleep">params_sleep</code></td>
<td>

<p>List with sleep parameters
</p>
</td></tr>
<tr><td><code id="extract_params_+3A_params_metrics">params_metrics</code></td>
<td>

<p>List with parameters related to metrics
</p>
</td></tr>
<tr><td><code id="extract_params_+3A_params_rawdata">params_rawdata</code></td>
<td>

<p>List with parameters related to raw data reading and processing
</p>
</td></tr>
<tr><td><code id="extract_params_+3A_params_247">params_247</code></td>
<td>

<p>List with parameters related to 24/7 behavioural analysis, which includes anything
that does not fit with physical activity or sleep research
</p>
</td></tr>
<tr><td><code id="extract_params_+3A_params_phyact">params_phyact</code></td>
<td>

<p>List with parameters related to physical activity analysis
</p>
</td></tr>
<tr><td><code id="extract_params_+3A_params_cleaning">params_cleaning</code></td>
<td>

<p>List with parameters related to cleaning the time series, including masking and imputation
</p>
</td></tr>
<tr><td><code id="extract_params_+3A_params_output">params_output</code></td>
<td>

<p>List with parameters related to how GGIR stores its output
</p>
</td></tr>
<tr><td><code id="extract_params_+3A_params_general">params_general</code></td>
<td>

<p>List with parameters related to general topics
</p>
</td></tr>
<tr><td><code id="extract_params_+3A_input">input</code></td>
<td>

<p>All objects provided by users
</p>
</td></tr>
<tr><td><code id="extract_params_+3A_configfile_csv">configfile_csv</code></td>
<td>

<p>Csv configuration file
</p>
</td></tr>
<tr><td><code id="extract_params_+3A_params2check">params2check</code></td>
<td>

<p>Character vector to indicate which params objects need to be checked.
This allows us to prevent the function from checking params objects that are not used
in the context where function extract_params is used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lists of updated parameter objects 
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='extractID'>
Extract ID from file header object
</h2><span id='topic+extractID'></span>

<h3>Description</h3>

<p>Extract ID from file header object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   extractID(hvars, idloc, fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractID_+3A_hvars">hvars</code></td>
<td>

<p>Object extracted with <a href="#topic+g.inspectfile">g.inspectfile</a>
</p>
</td></tr>
<tr><td><code id="extractID_+3A_idloc">idloc</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="extractID_+3A_fname">fname</code></td>
<td>

<p>File (base)name.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.abr.day.names'>
Abbreviates daynames to numbers, needed for report generation in
<a href="#topic+g.plot5">g.plot5</a>
</h2><span id='topic+g.abr.day.names'></span>

<h3>Description</h3>

<p>Abbreviates daynames Monday becomes MON and Sunday becomes SUN
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.abr.day.names(daynames)	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.abr.day.names_+3A_daynames">daynames</code></td>
<td>

<p>Vector of daynames in character format
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  daynames = c("Monday","Friday")
  daynames_converted = g.abr.day.names(daynames)
</code></pre>

<hr>
<h2 id='g.analyse'>
Function to analsyse meta-data generated by <a href="#topic+g.getmeta">g.getmeta</a> and <a href="#topic+g.impute">g.impute</a>
</h2><span id='topic+g.analyse'></span>

<h3>Description</h3>

<p>Analyses the output from other functions within the packages to generate a basic
descriptive summary for each accelerometer data file. Analyses include: Average 
acceleration per day, per measurement, L5M5 analyses (assessment of the five
hours with lowest acceleration and with highest acceleration). Further, the 
traditionally popular variable MVPA is automatically extracted in six variants:
without bout criteria in combination with epoch = epoch length as defined in
g.getmeta (first value of the input argument windowsizes), 1 minute,
and 5 minutes, and for bout durations 1 minute, 5 minutes or 10 minutes in
combination with the epoch length as defined in g.getmeta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.analyse(I, C, M, IMP, params_247 = c(), params_phyact = c(),
                      params_general = c(), params_cleaning = c(),
                      quantiletype = 7, myfun = c(), ID, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.analyse_+3A_i">I</code></td>
<td>

<p>the output from function <a href="#topic+g.inspectfile">g.inspectfile</a>
</p>
</td></tr>
<tr><td><code id="g.analyse_+3A_c">C</code></td>
<td>

<p>the output from function <a href="#topic+g.calibrate">g.calibrate</a>
</p>
</td></tr>
<tr><td><code id="g.analyse_+3A_m">M</code></td>
<td>

<p>the output from function <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
<tr><td><code id="g.analyse_+3A_imp">IMP</code></td>
<td>

<p>the output from function <a href="#topic+g.impute">g.impute</a>
</p>
</td></tr>
<tr><td><code id="g.analyse_+3A_params_247">params_247</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.analyse_+3A_params_phyact">params_phyact</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.analyse_+3A_params_general">params_general</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.analyse_+3A_params_cleaning">params_cleaning</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.analyse_+3A_quantiletype">quantiletype</code></td>
<td>

<p>type of quantile function to use (default recommended). For details, see 
quantile function in STATS package
</p>
</td></tr>
<tr><td><code id="g.analyse_+3A_myfun">myfun</code></td>
<td>

<p>External function object to be applied to raw data, see <a href="#topic+g.getmeta">g.getmeta</a>.
</p>
</td></tr>
<tr><td><code id="g.analyse_+3A_id">ID</code></td>
<td>

<p>ID extracted in g.part2.
</p>
</td></tr>
<tr><td><code id="g.analyse_+3A_...">...</code></td>
<td>

<p>Any argument used in the previous version of g.analyse, which will now
be used to overrule the arguments specified with the parameter objects.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>g.analyse generated two data,franeL
</p>
<table>
<tr><td><code>summary</code></td>
<td>
<p>summary for the file that was analysed</p>
</td></tr>
<tr><td><code>daysummary</code></td>
<td>
<p>summary per day for the file that was analysed</p>
</td></tr>
</table>
<p>These data.frames are used by function g.report.part2 to generate csv reports.
An exaplantion of all the columns in the data.frame and subsequent csv reports
can be found in the package vignette (Output part 2).
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(data.getmeta)
  data(data.inspectfile)
  data(data.calibrate)
  ## Not run: 
    #inspect file:
    I = g.inspectfile(datafile)
    
    #autocalibration:
    C = g.calibrate(datafile) 
    
    #get meta-data:
    M = g.getmeta(datafile, desiredtz = "Europe/London", 
    windowsizes = c(5, 900, 3600),
    daylimit = FALSE, offset = c(0, 0, 0), 
    scale = c(1, 1, 1), tempoffset = c(0, 0, 0))
  
## End(Not run)
  #impute meta-data:
  IMP = g.impute(M = data.getmeta, I = data.inspectfile, ID = "01wk0")
  
  #analyse and produce summary:
  A = g.analyse(I = data.inspectfile, C = data.calibrate,
  M = data.getmeta, IMP, ID = "01wk0")
</code></pre>

<hr>
<h2 id='g.analyse.avy'>
Function supports <a href="#topic+g.analyse">g.analyse</a>. Not intended for direct use by user.
</h2><span id='topic+g.analyse.avday'></span>

<h3>Description</h3>

<p>Generatess average day analyses and fills corresponding output
matrix, <a href="#topic+g.analyse">g.analyse</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.analyse.avday(doquan, averageday, M, IMP, t_TWDI, quantiletype,
                   ws3, doiglevels, firstmidnighti, ws2, midnightsi,
                   params_247 = c(), qcheck = c(), acc.metric = c(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.analyse.avy_+3A_doquan">doquan</code></td>
<td>
<p>Boolean whether quantile analysis should be done</p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_averageday">averageday</code></td>
<td>
<p> As produced by <a href="#topic+g.impute">g.impute</a></p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_m">M</code></td>
<td>
<p> As produced by <a href="#topic+g.getmeta">g.getmeta</a></p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_imp">IMP</code></td>
<td>
<p> As produced by <a href="#topic+g.impute">g.impute</a></p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_t_twdi">t_TWDI</code></td>
<td>
<p> Same as qwindow as described in <a href="#topic+g.analyse">g.analyse</a></p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_quantiletype">quantiletype</code></td>
<td>
<p>see <a href="#topic+g.analyse">g.analyse</a></p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_ws3">ws3</code></td>
<td>
<p> Epoch size in seconds</p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_doiglevels">doiglevels</code></td>
<td>
<p>Boolean to indicate whether iglevels should be calculated</p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_firstmidnighti">firstmidnighti</code></td>
<td>
<p>see <a href="#topic+g.detecmidnight">g.detecmidnight</a></p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_ws2">ws2</code></td>
<td>
<p>see <a href="#topic+g.weardec">g.weardec</a></p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_midnightsi">midnightsi</code></td>
<td>
<p>see <a href="#topic+g.detecmidnight">g.detecmidnight</a></p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_params_247">params_247</code></td>
<td>

<p>See <a href="#topic+g.part2">g.part2</a>
</p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_qcheck">qcheck</code></td>
<td>

<p>Vector with indicators of when data is valid (value=0) or invalid (value=1).
</p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_acc.metric">acc.metric</code></td>
<td>

<p>Character, see <a href="#topic+g.part1">g.part1</a>. Here, it is used to decided which acceleration metric
to use for IVIS and cosinor analyses.
</p>
</td></tr>
<tr><td><code id="g.analyse.avy_+3A_...">...</code></td>
<td>

<p>Any argument used in the previous version of g.analyse.avday, which will now
be used to overrule the arguments specified with the parameter objects.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>InterdailyStability</code></td>
<td>
</td></tr>
<tr><td><code>IntradailyVariability</code></td>
<td>
</td></tr>
<tr><td><code>igfullr_names</code></td>
<td>
</td></tr>
<tr><td><code>igfullr</code></td>
<td>
</td></tr>
<tr><td><code>QUAN</code></td>
<td>
</td></tr>
<tr><td><code>qlevels_names</code></td>
<td>
</td></tr>
<tr><td><code>ML5AD</code></td>
<td>
</td></tr>
<tr><td><code>ML5AD_names</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.analyse.perday'>
Function supports <a href="#topic+g.analyse">g.analyse</a>. Not intended for direct use by user.
</h2><span id='topic+g.analyse.perday'></span>

<h3>Description</h3>

<p>Generates day specific analyses and fills corresponding
output matrix, <a href="#topic+g.analyse">g.analyse</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.analyse.perday(ndays, firstmidnighti, time, nfeatures, 
                midnightsi, metashort, averageday,
                doiglevels, nfulldays,lastmidnight, ws3, ws2, qcheck,
                fname, idloc, sensor.location, wdayname, tooshort, includedaycrit,
                doquan, quantiletype, doilevels, domvpa,
                mvpanames, wdaycode, ID,
                deviceSerialNumber, ExtFunColsi, myfun, desiredtz = "",
                params_247 = c(), params_phyact = c(),
                ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.analyse.perday_+3A_ndays">ndays</code></td>
<td>
<p>Number of days in file</p>
</td></tr> 
<tr><td><code id="g.analyse.perday_+3A_firstmidnighti">firstmidnighti</code></td>
<td>
<p>see <a href="#topic+g.detecmidnight">g.detecmidnight</a></p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_time">time</code></td>
<td>
<p>timestamp column from metalong converted to character</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_nfeatures">nfeatures</code></td>
<td>
<p>estimate of number of variables that need to be stored in
the output matrix</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_midnightsi">midnightsi</code></td>
<td>
<p>see <a href="#topic+g.detecmidnight">g.detecmidnight</a></p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_metashort">metashort</code></td>
<td>
<p>see <a href="#topic+g.impute">g.impute</a></p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_averageday">averageday</code></td>
<td>
<p>As produced by <a href="#topic+g.impute">g.impute</a></p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_doiglevels">doiglevels</code></td>
<td>
<p>Boolean to indicate whether iglevels should be calculated</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_nfulldays">nfulldays</code></td>
<td>
<p>Number of days between the first and last midnight in the recording</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_lastmidnight">lastmidnight</code></td>
<td>
<p>see <a href="#topic+g.detecmidnight">g.detecmidnight</a></p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_ws3">ws3</code></td>
<td>
<p>Epoch size in seconds</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_ws2">ws2</code></td>
<td>
<p>see <a href="#topic+g.weardec">g.weardec</a></p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_qcheck">qcheck</code></td>
<td>
<p>vector with zeros and ones for each epoch, respenting the
quality check derived with g.impute</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_fname">fname</code></td>
<td>
<p>RData filename produced by g.part1</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_idloc">idloc</code></td>
<td>
<p>see <a href="#topic+g.analyse">g.analyse</a></p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_sensor.location">sensor.location</code></td>
<td>
<p>as produced by <a href="#topic+g.extractheadervars">g.extractheadervars</a></p>
</td></tr> 
<tr><td><code id="g.analyse.perday_+3A_wdayname">wdayname</code></td>
<td>
<p>character with weekdayname</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_tooshort">tooshort</code></td>
<td>
<p>0 (file not too short) or 1 (file too short)</p>
</td></tr> 
<tr><td><code id="g.analyse.perday_+3A_includedaycrit">includedaycrit</code></td>
<td>
<p>see <a href="#topic+g.analyse">g.analyse</a></p>
</td></tr> 
<tr><td><code id="g.analyse.perday_+3A_doquan">doquan</code></td>
<td>
<p>Boolean whether quantile analysis should be done</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_quantiletype">quantiletype</code></td>
<td>
<p>see <a href="#topic+g.analyse">g.analyse</a></p>
</td></tr> 
<tr><td><code id="g.analyse.perday_+3A_doilevels">doilevels</code></td>
<td>
<p>Boolean whether to generate ilevels, see <a href="#topic+g.analyse">g.analyse</a></p>
</td></tr> 
<tr><td><code id="g.analyse.perday_+3A_domvpa">domvpa</code></td>
<td>
<p>Boolean whether to do mvpa analysis</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_mvpanames">mvpanames</code></td>
<td>
<p>Matrix with 6 columns and 1 row holding the names for the six 
mvpa variables</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_wdaycode">wdaycode</code></td>
<td>
<p>Equal to M$wday as produced by <a href="#topic+g.getmeta">g.getmeta</a></p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_id">ID</code></td>
<td>
<p>Person Identification number, this can be numeric or character</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_deviceserialnumber">deviceSerialNumber</code></td>
<td>
<p>As produced by <a href="#topic+g.extractheadervars">g.extractheadervars</a></p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_extfuncolsi">ExtFunColsi</code></td>
<td>
<p>column index of metashort where metric is stored</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_myfun">myfun</code></td>
<td>
<p>External function object to be applied to raw data, see <a href="#topic+g.getmeta">g.getmeta</a>.</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_desiredtz">desiredtz</code></td>
<td>
<p>see <a href="#topic+g.part1">g.part1</a></p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_params_247">params_247</code></td>
<td>

<p>See <a href="#topic+g.part2">g.part2</a>
</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_params_phyact">params_phyact</code></td>
<td>

<p>See <a href="#topic+g.part2">g.part2</a>
</p>
</td></tr>
<tr><td><code id="g.analyse.perday_+3A_...">...</code></td>
<td>

<p>Any argument used in the previous version of g.analyse.perday, which will now
be used to overrule the arguments specified with the parameter objects.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>daysummary</code></td>
<td>
<p>Summary per day for the file that was analysed</p>
</td></tr>
<tr><td><code>ds_names</code></td>
<td>
<p>Variable names in daysummary</p>
</td></tr>
<tr><td><code>windowsummary</code></td>
<td>
<p>Window summary, only used when
selectdayfile is specified</p>
</td></tr>
<tr><td><code>ws_names</code></td>
<td>
<p>Variable names in windowsummary</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.analyse.perfile'>
Function supports <a href="#topic+g.analyse">g.analyse</a>. Not intended for direct use by user.
</h2><span id='topic+g.analyse.perfile'></span>

<h3>Description</h3>

<p>Generates recording specific analyses and fills corresponding
output matrix, <a href="#topic+g.analyse">g.analyse</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.analyse.perfile(I, C, metrics_nav,
                 AveAccAve24hr, doquan, doiglevels, tooshort,
                 params_247, params_cleaning, params_general,
                 output_avday, output_perday,
                 dataqual_summary, file_summary)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.analyse.perfile_+3A_i">I</code></td>
<td>
<p>output <a href="#topic+g.inspectfile">g.inspectfile</a></p>
</td></tr>
<tr><td><code id="g.analyse.perfile_+3A_c">C</code></td>
<td>
<p>output <a href="#topic+g.calibrate">g.calibrate</a></p>
</td></tr>
<tr><td><code id="g.analyse.perfile_+3A_metrics_nav">metrics_nav</code></td>
<td>
<p>List with three objects to help navigate the acceleration metrics</p>
</td></tr>
<tr><td><code id="g.analyse.perfile_+3A_aveaccave24hr">AveAccAve24hr</code></td>
<td>
<p>Average acceleration in an average 24 hour cycle</p>
</td></tr>
<tr><td><code id="g.analyse.perfile_+3A_doquan">doquan</code></td>
<td>
<p>Boolean whether quantile analysis should be done</p>
</td></tr>
<tr><td><code id="g.analyse.perfile_+3A_doiglevels">doiglevels</code></td>
<td>
<p>Boolean to indicate whether iglevels should be calculated</p>
</td></tr>
<tr><td><code id="g.analyse.perfile_+3A_tooshort">tooshort</code></td>
<td>
<p>0 (file not too short) or 1 (file too short)</p>
</td></tr>
<tr><td><code id="g.analyse.perfile_+3A_params_247">params_247</code></td>
<td>
<p>see <a href="#topic+GGIR">GGIR</a></p>
</td></tr>
<tr><td><code id="g.analyse.perfile_+3A_params_cleaning">params_cleaning</code></td>
<td>
<p>see <a href="#topic+GGIR">GGIR</a></p>
</td></tr>
<tr><td><code id="g.analyse.perfile_+3A_params_general">params_general</code></td>
<td>
<p>see <a href="#topic+GGIR">GGIR</a></p>
</td></tr>
<tr><td><code id="g.analyse.perfile_+3A_output_avday">output_avday</code></td>
<td>
<p>Output from g.analyse.avday</p>
</td></tr>
<tr><td><code id="g.analyse.perfile_+3A_output_perday">output_perday</code></td>
<td>
<p>Output from g.analyse.perday</p>
</td></tr>
<tr><td><code id="g.analyse.perfile_+3A_dataqual_summary">dataqual_summary</code></td>
<td>
<p>Data.frame with data quality summary indicators
produced in <a href="#topic+g.analyse">g.analyse</a></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>filesummary</code></td>
<td>
<p>summary for the file that was analysed</p>
</td></tr>
<tr><td><code>daysummary</code></td>
<td>
<p>Summary per day for the file that was analysed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.applymetrics'>
Extract metrics from acceleration signals
</h2><span id='topic+g.applymetrics'></span>

<h3>Description</h3>

<p>Function to extract metrics from acceleration signal. Not intended
for direct use by user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.applymetrics(data, sf, ws3, metrics2do,
                          n = 4, lb = 0.2, hb = 15,
                          zc.lb = 0.25, zc.hb = 3, 
                          zc.sb = 0.01, zc.order = 2,
                          actilife_LFE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.applymetrics_+3A_data">data</code></td>
<td>

<p>Three column matrix with x, y, and z acceleration data
</p>
</td></tr>
<tr><td><code id="g.applymetrics_+3A_n">n</code></td>
<td>

<p>filter order, see <a href="#topic+GGIR">GGIR</a> for details
</p>
</td></tr>
<tr><td><code id="g.applymetrics_+3A_sf">sf</code></td>
<td>

<p>sample frequency
</p>
</td></tr>
<tr><td><code id="g.applymetrics_+3A_ws3">ws3</code></td>
<td>

<p>Epoch size in seconds
</p>
</td></tr>
<tr><td><code id="g.applymetrics_+3A_metrics2do">metrics2do</code></td>
<td>

<p>Dataframe with Boolean indicator for all metrics whether
they should be extracted or not. For instance,
metrics2do$do.bfen = TRUE, indicates that the bfen metric
should be extracted
</p>
</td></tr>
<tr><td><code id="g.applymetrics_+3A_lb">lb</code></td>
<td>

<p>Lower boundery of cut-off frequencies, see <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.applymetrics_+3A_hb">hb</code></td>
<td>

<p>Higher boundery of cut-off frequencies, see <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.applymetrics_+3A_zc.lb">zc.lb</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.applymetrics_+3A_zc.hb">zc.hb</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.applymetrics_+3A_zc.sb">zc.sb</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.applymetrics_+3A_zc.order">zc.order</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.applymetrics_+3A_actilife_lfe">actilife_LFE</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with metric values in columns average per epoch (ws3)
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Gx = runif(n=10000,min=0,max=2)
  Gy = runif(n=10000,min=1,max=3)
  Gz = runif(n=10000,min=0,max=2)
  data = cbind(Gx, Gy, Gz)
  colnames(data) = c("x", "y", "z")
  metrics2do = data.frame(do.bfen=TRUE,do.enmo=TRUE,do.lfenmo=FALSE,
  do.en=FALSE,do.hfen=FALSE,do.hfenplus=FALSE,do.mad=FALSE,do.anglex=FALSE,
  do.angley=FALSE,do.anglez=FALSE,do.roll_med_acc_x=FALSE,
  do.roll_med_acc_y=FALSE,do.roll_med_acc_z=FALSE,
  do.dev_roll_med_acc_x=FALSE,do.dev_roll_med_acc_y=FALSE,
  do.dev_roll_med_acc_z=FALSE,do.enmoa=FALSE,
  do.lfx=FALSE, do.lfy=FALSE, do.lfz=FALSE, 
  do.hfx=FALSE, do.hfy=FALSE, do.hfz=FALSE, 
  do.bfx=FALSE, do.bfy=FALSE, do.bfz=FALSE,
  do.zcx=FALSE, do.zcy=FALSE, do.zcz=FALSE, 
  do.brondcounts=FALSE, do.neishabouricounts=FALSE)
  
  extractedmetrics = g.applymetrics(data,n=4,sf=40,ws3=5,metrics2do)
</code></pre>

<hr>
<h2 id='g.calibrate'>
function to estimate calibration error and make recommendation for addressing it
</h2><span id='topic+g.calibrate'></span>

<h3>Description</h3>

<p>Function starts by identifying ten second windows of non-movement. Next, the
average acceleration per axis per window is used to estimate calibration error 
(offset and scaling) per axis. The function provides recommended correction factors
to address the calibration error and a summary of the callibration procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.calibrate(datafile, params_rawdata = c(), params_general = c(),
              params_cleaning = c(), inspectfileobject = c(), verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.calibrate_+3A_datafile">datafile</code></td>
<td>

<p>Name of accelerometer file
</p>
</td></tr>
<tr><td><code id="g.calibrate_+3A_params_rawdata">params_rawdata</code></td>
<td>

<p>See <a href="#topic+g.part1">g.part1</a>
</p>
</td></tr>
<tr><td><code id="g.calibrate_+3A_params_general">params_general</code></td>
<td>

<p>See <a href="#topic+g.part1">g.part1</a>
</p>
</td></tr>
<tr><td><code id="g.calibrate_+3A_params_cleaning">params_cleaning</code></td>
<td>

<p>See <a href="#topic+g.part1">g.part1</a>
</p>
</td></tr>
<tr><td><code id="g.calibrate_+3A_inspectfileobject">inspectfileobject</code></td>
<td>

<p>Output from the function <a href="#topic+g.inspectfile">g.inspectfile</a>.
</p>
</td></tr>
<tr><td><code id="g.calibrate_+3A_verbose">verbose</code></td>
<td>

<p>Boolean (default = TRUE). to indicate whether console message should be printed. 
Note that warnings and error are always printed and can be suppressed with 
suppressWarning() or suppressMessages().
</p>
</td></tr>
<tr><td><code id="g.calibrate_+3A_...">...</code></td>
<td>

<p>Any argument used in the previous version of g.calibrate, which will now
be used to overrule the arguments specified with the parameter objects.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<table>
<tr><td><code>scale</code></td>
<td>
<p>scaling correction values, e.g. c(1,1,1) </p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>offset correction values, e.g. c(0,0,0)</p>
</td></tr>
<tr><td><code>tempoffset</code></td>
<td>
<p>correction values related to temperature, e.g. c(0,0,0)</p>
</td></tr>
<tr><td><code>cal.error.start</code></td>
<td>
<p>absolute difference between Euclidean norm during all
non-movement windows and 1 g before autocalibration</p>
</td></tr>
<tr><td><code>cal.error.end</code></td>
<td>
<p>absolute difference between Euclidean norm during all 
non-movement windows and 1 g after autocalibration</p>
</td></tr>
<tr><td><code>spheredata</code></td>
<td>
<p>average, standard deviation, Euclidean norm and temperature
(if available) for all ten second non-movement windows as used for the
autocalibration procedure</p>
</td></tr>
<tr><td><code>npoints</code></td>
<td>
<p>number of 10 second no-movement windows used to populate
the sphere</p>
</td></tr>
<tr><td><code>nhoursused</code></td>
<td>
<p>number of hours of measurement data scanned to find
the ten second time windows with no movement</p>
</td></tr>
<tr><td><code>meantempcal</code></td>
<td>
<p>mean temperature corresponding to the data as used for 
autocalibration. Only applies to data where temperate data is collected
and available to GGIR, such as GENEActiv, Axivity, and in some instances
ad-hoc .csv data.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
Zhou Fang
</p>


<h3>References</h3>


<ul>
<li><p> van Hees VT, Fang Z, Langford J, Assah F, Mohammad A, da Silva IC, Trenell MI, 
White T, Wareham NJ, Brage S. Auto-calibration of accelerometer data for
free-living physical activity assessment using local gravity and temperature: 
an evaluation on four continents. J Appl Physiol (1985). 2014 Aug 7
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    datafile = "C:/myfolder/testfile.bin"
    
    #Apply autocalibration:
    C = g.calibrate(datafile)
    print(C$scale)
    print(C$offset)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='g.conv.actlog'>
Function to read activity log and make it useful for the rest of GGIR.
</h2><span id='topic+g.conv.actlog'></span>

<h3>Description</h3>

<p>Function to read activity log and convert it into data.frame
that has for each ID and date a different qwindow vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.conv.actlog(qwindow, qwindow_dateformat="%d-%m-%Y", epochSize = 5)	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.conv.actlog_+3A_qwindow">qwindow</code></td>
<td>

<p>Path to csv file with activity log. Expected format of the activity diary is:
First column headers followed by one row per recording, first column is recording ID,
which needs to match with the ID GGIR extracts from the accelerometer file.
Followed by date column in format &quot;23-04-2017&quot;, where date format is specified by 
argument qwindow_dateformat (below). Use the character combination date, Date or 
DATE in the column name. This is followed by 
one or multiple columns with start times for the activity types in that day format in 
hours:minutes:seconds. The header of the column will be used as label for each activity
type. Insert a new date column before continuing with activity types for next day.
Leave missing values empty. If an activitylog is used then individuals who do 
not appear in the activitylog will still be processed with value c(0,24).
Dates with no activiy log data can be skipped, no need to have a column with the 
date followed by a column with the next date. If times in the activitylog are not multiple 
of the short window size (epoch length), the next epoch is considered (e.g., with epoch of 5 seconds, 
8:00:02 will be redefined as 8:00:05 in the activity log).
</p>
</td></tr>
<tr><td><code id="g.conv.actlog_+3A_qwindow_dateformat">qwindow_dateformat</code></td>
<td>

<p>Character specifying the date format used in the activity log.
</p>
</td></tr>
<tr><td><code id="g.conv.actlog_+3A_epochsize">epochSize</code></td>
<td>

<p>Short epoch size (first value of windowsizes in <a href="#topic+g.getmeta">g.getmeta</a>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with column ID, date and qwindow, where each
qwindow value is a qwindow vector
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.convert.part2.long'>
Convert part 2 report to long format
</h2><span id='topic+g.convert.part2.long'></span>

<h3>Description</h3>

<p>Not for direct access by used. This function is used 
inside g.report.part2 and convert2 part 2 report to long 
ormat if there
are multiple segments per day
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.convert.part2.long(daySUMMARY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.convert.part2.long_+3A_daysummary">daySUMMARY</code></td>
<td>

<p>Object available inside g.report.part2
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with long format version of daySUMMARY
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.create.sp.mat'>
Converts sleep period information. Not intended for direct use
</h2><span id='topic+g.create.sp.mat'></span>

<h3>Description</h3>

<p>Function to convert data into sleep period matrix part of g.part4.R.
Not intended for direct use by package user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.create.sp.mat(nsp,spo,sleepdet.t,daysleep=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.create.sp.mat_+3A_nsp">nsp</code></td>
<td>

<p>Integer indicating the number of sleep periods
</p>
</td></tr> 
<tr><td><code id="g.create.sp.mat_+3A_spo">spo</code></td>
<td>

<p>Empty matrix with overview of sleep periods, 5 columns and
as along as nps
</p>
</td></tr>
<tr><td><code id="g.create.sp.mat_+3A_sleepdet.t">sleepdet.t</code></td>
<td>

<p>Part of detected sleep from g.sib.det for one night and one 
sleep definition
</p>
</td></tr>
<tr><td><code id="g.create.sp.mat_+3A_daysleep">daysleep</code></td>
<td>

<p>Boolean to indicator whether this person woke up
after noon (daysleeper)
</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> spo matrix with start and end of each sleep period
</p>
</li>
<li><p> calendardate date corresponding to the day on which the night started
</p>
</li>
<li><p> item wdayname weekdayname
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.detecmidnight'>
Detect all midnights in a time series
</h2><span id='topic+g.detecmidnight'></span>

<h3>Description</h3>

<p>Detect all midnights in a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.detecmidnight(time,desiredtz, dayborder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.detecmidnight_+3A_time">time</code></td>
<td>

<p>Vector of timestamps, either in iso8601 or in POSIX format
</p>
</td></tr>
<tr><td><code id="g.detecmidnight_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+g.part2">g.part2</a>
</p>
</td></tr>
<tr><td><code id="g.detecmidnight_+3A_dayborder">dayborder</code></td>
<td>

<p>see <a href="#topic+g.analyse">g.analyse</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output of the function is list containing the following objects:<br />
</p>

<ul>
<li><p> firstmidnight = timestamp of first midnight
</p>
</li>
<li><p> firstmidnighti = index of first midnight
</p>
</li>
<li><p> lastmidnight = timestamp of last midnight
</p>
</li>
<li><p> lastmidnighti = index of last midnight
</p>
</li>
<li><p> midnights = timestamps of midnights
</p>
</li>
<li><p> midnightsi = indeces of midnights
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.dotorcomma'>
Assesses whether decimals in fileheader are stored with comma
or dot separated decimals
</h2><span id='topic+g.dotorcomma'></span>

<h3>Description</h3>

<p>The function is used by <a href="#topic+g.readaccfile">g.readaccfile</a> to assess how numeric data
should be interpretted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.dotorcomma(inputfile, dformat, mon, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.dotorcomma_+3A_inputfile">inputfile</code></td>
<td>

<p>full path to inputfile
</p>
</td></tr>
<tr><td><code id="g.dotorcomma_+3A_dformat">dformat</code></td>
<td>

<p>Data format code: 1=.bin, 2=.csv, 3=.wav, 4=.cwa, 5=.csv for ad-hoc monitor 
brand
</p>
</td></tr>
<tr><td><code id="g.dotorcomma_+3A_mon">mon</code></td>
<td>

<p>Monitor code (accelorometer brand): 0=undefined, 1=GENEA, 2=GENEActiv,
3=Actigraph, 4=Axivity, 5=Movisense, 6=Verisense
</p>
</td></tr>
<tr><td><code id="g.dotorcomma_+3A_...">...</code></td>
<td>

<p>Any input arguments needed for function <a href="#topic+read.myacc.csv">read.myacc.csv</a> if you
are working with a non-standard csv formatted files.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character object showing how decimals are separated
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    decn = g.dotorcomma(inputfile="C:/myfile.bin",dformat=1,mon=2)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='g.extractheadervars'>
Extracts header variables from header object
</h2><span id='topic+g.extractheadervars'></span>

<h3>Description</h3>

<p>Function is not intended for direct interaction by package end user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.extractheadervars(I)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.extractheadervars_+3A_i">I</code></td>
<td>

<p>Object produced by <a href="#topic+g.inspectfile">g.inspectfile</a>
</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> ID = participant identifier
</p>
</li>
<li><p> iid = investigator identifier
</p>
</li>
<li><p> HN = handedness
</p>
</li>
<li><p> BodyLocation = Attachement location of the sensor
</p>
</li>
<li><p> SX = sex
</p>
</li>
<li><p> deviceSerialNumber = serial number
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data.inspectfile)
headervars = g.extractheadervars(I=data.inspectfile)
</code></pre>

<hr>
<h2 id='g.fragmentation'>
Fragmentation metrics from time series.
</h2><span id='topic+g.fragmentation'></span>

<h3>Description</h3>

<p>The function is used by <a href="#topic+g.part5">g.part5</a> to derive time series 
fragmentation metrics. The function assumes that NA values and nonwear time is 
accounted for before the data enters the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.fragmentation(frag.metrics = c("mean", "TP", "Gini", "power",
        "CoV", "NFragPM", "all"), LEVELS = c(), Lnames=c(), xmin=1, mode = "day")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.fragmentation_+3A_frag.metrics">frag.metrics</code></td>
<td>

<p>Character with fragmentation metric to exract. Can be &quot;mean&quot;, &quot;TP&quot;, &quot;Gini&quot;, 
&quot;power&quot;, or &quot;CoV&quot;, &quot;NFragPM&quot;, or all the above metrics with &quot;all&quot;. See details.
</p>
</td></tr>
<tr><td><code id="g.fragmentation_+3A_levels">LEVELS</code></td>
<td>

<p>Numeric vector of behavioural level classes derived with <a href="#topic+identify_levels">identify_levels</a>
</p>
</td></tr>
<tr><td><code id="g.fragmentation_+3A_lnames">Lnames</code></td>
<td>

<p>Character vector with names of classes used in LEVELS, see details.
</p>
</td></tr>
<tr><td><code id="g.fragmentation_+3A_xmin">xmin</code></td>
<td>

<p>Numeric scalar to indicate the minimum recordable fragment length. In <a href="#topic+g.part5">g.part5</a>
this is derived from the epoch length.
</p>
</td></tr>
<tr><td><code id="g.fragmentation_+3A_mode">mode</code></td>
<td>

<p>Character to indicate whether input data is daytime (&quot;day&quot;) or sleep period time (&quot;spt&quot;).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See package vignette for description of fragmentation metrics.
In short, abbreviation &quot;TP&quot; refers to transition probality metrics,
abbreviation &quot;CoV&quot; refers to Coefficient of Variance, and
metric &quot;NFragPM&quot; refers to the Number of fragments per minute.
</p>
<p>Regarding the Lnames argument. The class names included in this are categorised
as follows:
</p>

<ul>
<li><p> Inactive, if name includes the character strings &quot;day_IN_unbt&quot; or &quot;day_IN_bts&quot;
</p>
</li>
<li><p> LIPA, if name includes the character strings &quot;day_LIG_unbt&quot; or &quot;day_LIG_bts&quot;
</p>
</li>
<li><p> MVPA, if name includes the character strings &quot;day_MOD_unbt&quot;, &quot;day_VIG_unbt&quot;, 
or &quot;day_MVPA_bts&quot;
</p>
</li></ul>



<h3>Value</h3>

<p>List with Character object showing how decimals are separated
</p>
<table>
<tr><td><code>TP_PA2IN</code></td>
<td>
<p>Transition probability physical activity to inactivity</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code>TP_IN2PA</code></td>
<td>
<p>Transition probability physical inactivity to activity</p>
</td></tr>
<tr><td><code>Nfrag_IN2LIPA</code></td>
<td>
<p>Number of inacitivty fragments succeeded by LIPA
(light physical activity)</p>
</td></tr>
<tr><td><code>TP_IN2LIPA</code></td>
<td>
<p>Transition probability physical inactivity to LIPA</p>
</td></tr>
<tr><td><code>Nfrag_IN2MVPA</code></td>
<td>
<p>Number of inacitivty fragments succeeded by MVPA
(moderate or vigorous physical activity)</p>
</td></tr>
<tr><td><code>TP_IN2MVPA</code></td>
<td>
<p>Transition probability physical inactivity to MVPA</p>
</td></tr>
<tr><td><code>Nfrag_MVPA</code></td>
<td>
<p>Number of MVPA fragments</p>
</td></tr>
<tr><td><code>Nfrag_LIPA</code></td>
<td>
<p>Number of LIPA fragments</p>
</td></tr>
<tr><td><code>mean_dur_MVPA</code></td>
<td>
<p>mean MVPA fragment duration</p>
</td></tr>
<tr><td><code>mean_dur_LIPA</code></td>
<td>
<p>mean LIPA fragment duration</p>
</td></tr>
<tr><td><code>Nfrag_IN</code></td>
<td>
<p>Number of inactivity fragments</p>
</td></tr>
<tr><td><code>Nfrag_PA</code></td>
<td>
<p>Number of activity fragments</p>
</td></tr>
<tr><td><code>mean_dur_IN</code></td>
<td>
<p>mean duration inactivity fragments</p>
</td></tr>
<tr><td><code>mean_dur_PA</code></td>
<td>
<p>mean duration activity fragments</p>
</td></tr>
<tr><td><code>Gini_dur_IN</code></td>
<td>
<p>Gini index corresponding to inactivity fragment durations</p>
</td></tr>
<tr><td><code>Gini_dur_PA</code></td>
<td>
<p>Gini index corresponding to activity fragment durations</p>
</td></tr>
<tr><td><code>CoV_dur_IN</code></td>
<td>
<p>Coefficient of Variance corresponding to inactivity fragment durations</p>
</td></tr>
<tr><td><code>CoV_dur_PA</code></td>
<td>
<p>Coefficient of Variance corresponding to activity fragment durations</p>
</td></tr>
<tr><td><code>alpha_dur_IN</code></td>
<td>
<p>Alpha of the fitted power distribution through inactivity fragment durations</p>
</td></tr>
<tr><td><code>alpha_dur_PA</code></td>
<td>
<p>Alpha of the fitted power distribution through activity fragment durations</p>
</td></tr>
<tr><td><code>x0.5_dur_IN</code></td>
<td>
<p>x0.5 corresponding to alpha_dur_IN</p>
</td></tr>
<tr><td><code>x0.5_dur_PA</code></td>
<td>
<p>x0.5 corresponding to alpha_dur_PA</p>
</td></tr>
<tr><td><code>W0.5_dur_IN</code></td>
<td>
<p>W0.5 corresponding to alpha_dur_IN</p>
</td></tr>
<tr><td><code>W0.5_dur_PA</code></td>
<td>
<p>W0.5 corresponding to alpha_dur_PA</p>
</td></tr>
<tr><td><code>NFragPM_IN</code></td>
<td>
<p>Number of IN fragments per minutes in IN</p>
</td></tr>
<tr><td><code>NFragPM_PA</code></td>
<td>
<p>Number of PA fragments per minutes in PA</p>
</td></tr>
<tr><td><code>SD_dur_IN</code></td>
<td>
<p>Standard deviation in the duration of inactivity fragments</p>
</td></tr>
<tr><td><code>SD_dur_PA</code></td>
<td>
<p>Standard deviation in the duration of physical activity fragments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    x = c(6, 5, 6, 7, 6, 6, 7, 6, 6, 5, 6, 6, 6, 5, 7, 6, 6, 5, 5, 5, 6, 7, 6,
        6, 6, 6, 7, 6, 5, 5, 5, 5, 5, 6, 6, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7, 6, 5, 6, 5, 6, 5, rep(12, 11), 5, 6, 6, 6, 5, 6, rep(9, 14), 6,
        5, 7, 7, 6, 7, 7, 7, 6, 6, 6, 5, 6, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 5)
  Lnames = c("spt_sleep", "spt_wake_IN", "spt_wake_LIG", "spt_wake_MOD",
            "spt_wake_VIG", "day_IN_unbt", "day_LIG_unbt", "day_MOD_unbt",
            "day_VIG_unbt", "day_MVPA_bts_10", "day_IN_bts_30",
             "day_IN_bts_10_30", "day_LIG_bts_10")
  out = g.fragmentation(frag.metrics = "all",
                        LEVELS = x,
                        Lnames=Lnames)
## End(Not run)
</code></pre>

<hr>
<h2 id='g.getbout'>
function to calculate bouts from vector of binary classes
</h2><span id='topic+g.getbout'></span>

<h3>Description</h3>

<p>To detect bouts of behaviour in time series. The function is used by <a href="#topic+g.analyse">g.analyse</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.getbout(x, boutduration, boutcriter = 0.8, ws3 = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.getbout_+3A_x">x</code></td>
<td>
<p>vector of zeros and/or ones to be screened for bouts of ones
</p>
</td></tr>
<tr><td><code id="g.getbout_+3A_boutduration">boutduration</code></td>
<td>
<p>duration of bout in epochs
</p>
</td></tr>
<tr><td><code id="g.getbout_+3A_boutcriter">boutcriter</code></td>
<td>
<p> Minimum percentage of boutduration for which the epoch values
are expected to meet the threshold criterium
</p>
</td></tr>
<tr><td><code id="g.getbout_+3A_ws3">ws3</code></td>
<td>
<p>epoch length in seconds, only needed for bout.metric =3, because
it needs to measure how many epochs equal 1 minute breaks
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with binary numbers indicator where bouts where detected
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
Jairo Hidalgo Migueles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  y = g.getbout(x=round(runif(1000, 0.4, 1)), boutduration = 120, boutcriter=0.9,
    ws3 = 5)
</code></pre>

<hr>
<h2 id='g.getM5L5'>
Extract M5 and L5 from time series
</h2><span id='topic+g.getM5L5'></span>

<h3>Description</h3>

<p>Extract M5 and L5 from time series, function used by <a href="#topic+g.analyse">g.analyse</a> and
not intended for direct use by package user. Please see <a href="#topic+g.analyse">g.analyse</a>
for further clarification on functionalities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.getM5L5(varnum,ws3,t0_LFMF,t1_LFMF,M5L5res,winhr,qM5L5=c(), 
  iglevels=c(), MX.ig.min.dur=10)	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.getM5L5_+3A_varnum">varnum</code></td>
<td>

<p>Numeric vector of epoch values
</p>
</td></tr>
<tr><td><code id="g.getM5L5_+3A_ws3">ws3</code></td>
<td>

<p>Small epoch size in seconds
</p>
</td></tr>
<tr><td><code id="g.getM5L5_+3A_t0_lfmf">t0_LFMF</code></td>
<td>

<p>Start hour of the day for the M5L5 analyses, e.g. 0 for midnight
</p>
</td></tr>
<tr><td><code id="g.getM5L5_+3A_t1_lfmf">t1_LFMF</code></td>
<td>

<p>End hour of the day for the M5L5 analyses, e.g. 24 for midnight
</p>
</td></tr>
<tr><td><code id="g.getM5L5_+3A_m5l5res">M5L5res</code></td>
<td>

<p>Resolution of hte M5L5 analyses in minutes
</p>
</td></tr>
<tr><td><code id="g.getM5L5_+3A_winhr">winhr</code></td>
<td>

<p>windowsize of M5L5 analyses, e.g. 5 hours
</p>
</td></tr>
<tr><td><code id="g.getM5L5_+3A_qm5l5">qM5L5</code></td>
<td>

<p>Percentiles (quantiles) to be calculated over L5 and M5 window.
</p>
</td></tr>
<tr><td><code id="g.getM5L5_+3A_iglevels">iglevels</code></td>
<td>

<p>See  <a href="#topic+g.analyse">g.analyse</a>. If provided then the intensity gradient will be calculated
for all MX windows larger or equal than argument MX.ig.min.dur
</p>
</td></tr>
<tr><td><code id="g.getM5L5_+3A_mx.ig.min.dur">MX.ig.min.dur</code></td>
<td>

<p>Minimum MX duration needed in order for intensity gradient to be calculated
</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> DAYL5HOUR = Starting time in hours of L5
</p>
</li>
<li><p> DAYL5VALUE = average acceleration during L5
</p>
</li>
<li><p> DAYM5HOUR = Starting time in hours of M5
</p>
</li>
<li><p> DAYM5VALUE = average acceleration during M5
</p>
</li>
<li><p> V5NIGHT = average acceleration between 1am and 6am
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    data(data.getmeta)
    g.getM5L5(varnum=data.getmeta,ws3=5,t0_LFMF=0,t1_LFMF=24,M5L5res=10,winhr=5)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='g.getmeta'>
Function to extract meta-data (features) from data in accelerometer file
</h2><span id='topic+g.getmeta'></span>

<h3>Description</h3>

<p>Reads a accelerometer file in blocks, extracts various features and stores average  feature
value per short or long epoch. Acceleration and angle metrics are stored at short
epoch length. The non-wear indication score, the clipping score, temperature
(if available), light (if available), and Euclidean norm are stored at long epoch
length. The function has been designed and thoroughly tested with accelerometer files
from GENEA and GENEActiv bin files. Further, the function should be able to cope with ActiGraph gt3x and
csv files, Axivity cwa and csv files, Movisens bin files, and ad-hoc csv files read through the
<a href="#topic+read.myacc.csv">read.myacc.csv</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.getmeta(datafile, params_metrics = c(), params_rawdata = c(),
                     params_general = c(), params_cleaning = c(), daylimit = FALSE,
                     offset = c(0, 0, 0), scale = c(1, 1, 1), tempoffset = c(0, 0, 0),
                     meantempcal = c(), myfun = c(), inspectfileobject = c(), 
                     verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.getmeta_+3A_datafile">datafile</code></td>
<td>

<p>name of accelerometer file
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_params_metrics">params_metrics</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_params_rawdata">params_rawdata</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_params_general">params_general</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_params_cleaning">params_cleaning</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_daylimit">daylimit</code></td>
<td>

<p>number of days to limit (roughly), if set to FALSE no daylimit
will be applied
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_offset">offset</code></td>
<td>

<p>offset correction value per axis, usage:
value = scale(value,center = -offset, scale = 1/scale)
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_scale">scale</code></td>
<td>

<p>scaling correction value per axis, usage:
value = scale(value,center = -offset, scale = 1/scale)
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_tempoffset">tempoffset</code></td>
<td>

<p>temperature offset correction value per axis, usage:
value = scale(value,center = -offset, scale = 1/scale)
+ scale(temperature, center = rep(averagetemperate,3), scale = 1/tempoffset)
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_meantempcal">meantempcal</code></td>
<td>

<p>mean temperature corresponding to the data as used for
autocalibration. If autocalibration is not done or if temperature was not
available then leave blank (default)
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_myfun">myfun</code></td>
<td>

<p>External function object to be applied to raw data.
See details <a href="#topic+applyExtFunction">applyExtFunction</a>.
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_inspectfileobject">inspectfileobject</code></td>
<td>

<p>Output from the function <a href="#topic+g.inspectfile">g.inspectfile</a>.
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_verbose">verbose</code></td>
<td>

<p>Boolean (default = TRUE). to indicate whether console message should be printed.
Note that warnings and error are always printed and can be suppressed with
suppressWarning() or suppressMessages().
</p>
</td></tr>
<tr><td><code id="g.getmeta_+3A_...">...</code></td>
<td>

<p>Any argument used in the previous version of g.getmeta, which will now
be used to overrule the arguments specified with the parameter objects.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>metalong</code></td>
<td>
<p>dataframe with long epoch meta-data: EN, non-wear score,
clipping score, temperature</p>
</td></tr>
<tr><td><code>metashort</code></td>
<td>
<p>dataframe with short epoch meta-data: timestamp and metric</p>
</td></tr>
<tr><td><code>tooshort</code></td>
<td>
<p>indicator of whether file was too short for processing (TRUE or FALSE)</p>
</td></tr>
<tr><td><code>corrupt</code></td>
<td>
<p>indicator of whether file was considered corrupt (TRUE or FALSE)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> van Hees VT, Gorzelniak L, Dean Leon EC, Eder M, Pias M, et al. (2013) Separating
Movement and Gravity Components in an Acceleration Signal and Implications for the
Assessment of Human Daily Physical Activity. PLoS ONE 8(4): e61691.
doi:10.1371/journal.pone.0061691
</p>
</li>
<li><p> Aittasalo M, Vaha-Ypya H, Vasankari T, Husu P, Jussila AM, and Sievanen H. Mean
amplitude deviation calculated from raw acceleration data: a novel method for
classifying the intensity of adolescents physical activity irrespective of accelerometer
brand. BMC Sports Science, Medicine and Rehabilitation (2015).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    datafile = "C:/myfolder/testfile.bin"

    #Extract meta-data:
    M = g.getmeta(datafile)

    #Inspect first couple of rows of long epoch length meta data:
    print(M$metalong[1:5,])

    #Inspect first couple of rows of short epoch length meta data:
    print(M$metalong[1:5,])
  
## End(Not run)
</code></pre>

<hr>
<h2 id='g.getstarttime'>
Extract start time of a measurement
</h2><span id='topic+g.getstarttime'></span>

<h3>Description</h3>

<p>Extract start time of a measurement. GGIR calculates all timestamps by
using the first timestamp and sample frequency. Not intended
for direct use by package user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.getstarttime(datafile, data, mon, dformat, desiredtz,
  configtz = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.getstarttime_+3A_datafile">datafile</code></td>
<td>

<p>Full path to data file
</p>
</td></tr>
<tr><td><code id="g.getstarttime_+3A_data">data</code></td>
<td>

<p>Data part of <a href="#topic+g.readaccfile">g.readaccfile</a> output
</p>
</td></tr>
<tr><td><code id="g.getstarttime_+3A_mon">mon</code></td>
<td>

<p>Same as in <a href="#topic+g.dotorcomma">g.dotorcomma</a>
</p>
</td></tr>
<tr><td><code id="g.getstarttime_+3A_dformat">dformat</code></td>
<td>

<p>Same as in <a href="#topic+g.dotorcomma">g.dotorcomma</a>
</p>
</td></tr>
<tr><td><code id="g.getstarttime_+3A_desiredtz">desiredtz</code></td>
<td>

<p>Same as in <a href="#topic+g.dotorcomma">g.dotorcomma</a>
</p>
</td></tr>
<tr><td><code id="g.getstarttime_+3A_configtz">configtz</code></td>
<td>

<p>Same as in <a href="#topic+g.dotorcomma">g.dotorcomma</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The starttime
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.impute'>
Function to identify invalid periods in the meta-data as generated by <a href="#topic+g.getmeta">g.getmeta</a>
and to impute these invalid periods with the average of similar timepoints on other
days of the measurement
</h2><span id='topic+g.impute'></span>

<h3>Description</h3>

<p>Functions takes the output from <a href="#topic+g.getmeta">g.getmeta</a> and information about the study
protocol to label impute invalid time segments in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.impute(M, I, params_cleaning = c(),
  desiredtz="", dayborder= 0, TimeSegments2Zero =c(), acc.metric = "ENMO", ID, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.impute_+3A_m">M</code></td>
<td>

<p>output from <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
<tr><td><code id="g.impute_+3A_i">I</code></td>
<td>

<p>output from <a href="#topic+g.inspectfile">g.inspectfile</a>
</p>
</td></tr>
<tr><td><code id="g.impute_+3A_params_cleaning">params_cleaning</code></td>
<td>

<p>See <a href="#topic+g.part1">g.part1</a>
</p>
</td></tr>
<tr><td><code id="g.impute_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+g.part1">g.part1</a>
</p>
</td></tr>
<tr><td><code id="g.impute_+3A_dayborder">dayborder</code></td>
<td>

<p>See <a href="#topic+g.part1">g.part1</a>
</p>
</td></tr>
<tr><td><code id="g.impute_+3A_timesegments2zero">TimeSegments2Zero</code></td>
<td>

<p>Optional data.frame to specify which time segments need to be ignored for the imputation,
and acceleration metrics to be imputed by zeros. The data.frame is expected
to contain two columns named windowstart and windowend, with the start- and end
time of the time segment in POSIXlt class.
</p>
</td></tr>
<tr><td><code id="g.impute_+3A_acc.metric">acc.metric</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.impute_+3A_id">ID</code></td>
<td>

<p>ID extracted in g.part2.
</p>
</td></tr>
<tr><td><code id="g.impute_+3A_...">...</code></td>
<td>

<p>Any argument used in the previous version of g.impute, which will now
be used to overrule the arguments specified with the parameter objects.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>metashort</code></td>
<td>
<p>imputed short epoch variables</p>
</td></tr>
<tr><td><code>rout</code></td>
<td>
<p>matrix to clarify when data was imputed for each long epoch time window
and the reason for imputation. Value = 1 indicates imputation. 
Columns 1 = monitor non wear, column 2 = clipping, column 3 = additional nonwear,
column 4 = protocol based exclusion and column5 = sum of column 1,2,3 and 4. </p>
</td></tr>
<tr><td><code>averageday</code></td>
<td>
<p>matrix with n columns for n metrics values and m rows for
m short epoch time windows in an average 24 hours period</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    #inspect file:
    I = g.inspectfile(datafile)
    #autocalibration:
    C = g.calibrate(datafile) 
    #get meta-data:
    M = g.getmeta(datafile)
  
## End(Not run)
  data(data.getmeta)
  data(data.inspectfile)
  #impute meta-data:
  IMP = g.impute(M=data.getmeta, I=data.inspectfile)
</code></pre>

<hr>
<h2 id='g.imputeTimegaps'>
Impute gaps in three axis raw accelerometer data
</h2><span id='topic+g.imputeTimegaps'></span>

<h3>Description</h3>

<p>Removes all sample with a zero in each of the three axes, and then (as default)
imputes time  gaps by the last recorded value per axis normalised to 1 _g_
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.imputeTimegaps(x, sf, k = 0.25, impute = TRUE, 
                   PreviousLastValue = c(0,0,1), 
                   PreviousLastTime = NULL, epochsize = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.imputeTimegaps_+3A_x">x</code></td>
<td>

<p>Data.frame with raw accelerometer data, and a timestamp column with
millisecond resolution.
</p>
</td></tr>
<tr><td><code id="g.imputeTimegaps_+3A_sf">sf</code></td>
<td>

<p>Sample frequency in Hertz
</p>
</td></tr>
<tr><td><code id="g.imputeTimegaps_+3A_k">k</code></td>
<td>

<p>Minimum time gap length to be imputed
</p>
</td></tr>
<tr><td><code id="g.imputeTimegaps_+3A_impute">impute</code></td>
<td>

<p>Boolean to indicate whether the time gaps identified should be imputed
</p>
</td></tr>
<tr><td><code id="g.imputeTimegaps_+3A_previouslastvalue">PreviousLastValue</code></td>
<td>

<p>Automatically identified last value in previous chunk of data read.
</p>
</td></tr>
<tr><td><code id="g.imputeTimegaps_+3A_previouslasttime">PreviousLastTime</code></td>
<td>

<p>Automatically identified last timestamp in previous chunk of data read.
</p>
</td></tr>
<tr><td><code id="g.imputeTimegaps_+3A_epochsize">epochsize</code></td>
<td>

<p>Numeric vector of length two, with short and long epoch sizes.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List including:
- x, data.frame based on input x with timegaps imputed (as default) or with 
recordings with 0 values in the three axes removed (if impute = FALSE)
- QClog, data.frame with information on the number of time gaps found and the 
total time imputed in minutes
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.inspectfile'>
function to inspect accelerometer file for brand, sample frequency and header
</h2><span id='topic+g.inspectfile'></span>

<h3>Description</h3>

<p>Inspects accelerometer file for key information, including: monitor brand, sample frequency and file header
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.inspectfile(datafile, desiredtz = "", params_rawdata = c(),
                         configtz = c(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.inspectfile_+3A_datafile">datafile</code></td>
<td>

<p>name of data file
</p>
</td></tr>
<tr><td><code id="g.inspectfile_+3A_desiredtz">desiredtz</code></td>
<td>

<p>Desired timezone, see documentation <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
<tr><td><code id="g.inspectfile_+3A_params_rawdata">params_rawdata</code></td>
<td>

<p>See <a href="#topic+g.part1">g.part1</a>
</p>
</td></tr>
<tr><td><code id="g.inspectfile_+3A_configtz">configtz</code></td>
<td>

<p>...
</p>
</td></tr>
<tr><td><code id="g.inspectfile_+3A_...">...</code></td>
<td>

<p>Any argument used in the previous version of g.getmeta, which will now
be used to overrule the arguments specified with the parameter objects.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>header</code></td>
<td>
<p>fileheader</p>
</td></tr>
<tr><td><code>monn</code></td>
<td>
<p>monitor name (genea, geneactive)</p>
</td></tr>
<tr><td><code>monc</code></td>
<td>
<p>monitor brand code (0 - ad-hoc file format, 1 = genea (non-commercial),
2 = GENEActive, 3 = actigraph, 4 = Axivity (AX3, AX6), 5 = Movisense, 6 = Verisense)</p>
</td></tr>
<tr><td><code>dformn</code></td>
<td>
<p>data format name, e.g bin, csv, cwa, gt3x</p>
</td></tr>
<tr><td><code>dformc</code></td>
<td>
<p>data format code (1 = .bin, 2 = .csv, 3 = .wav, 4 = .cwa, 5 = ad-hoc .csv, 6 = .gt3x)</p>
</td></tr>
<tr><td><code>sf</code></td>
<td>
<p>samplefrequency in Hertz</p>
</td></tr>
<tr><td><code>filename</code></td>
<td>
<p>filename</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.intensitygradient'>
Intensity gradient calculation
</h2><span id='topic+g.intensitygradient'></span>

<h3>Description</h3>

<p>Calculates the intensity gradient based on Rowlands et al. 2018.
The function assumes that the user has already calculated the value
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.intensitygradient(x,y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.intensitygradient_+3A_x">x</code></td>
<td>

<p>Numeric vector of mid-points of the bins (mg)
</p>
</td></tr>
<tr><td><code id="g.intensitygradient_+3A_y">y</code></td>
<td>

<p>Numeric vector of time spent in bins (minutes)
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>y_intercept</code></td>
<td>
<p>y-intercept of a linear regression line in log-log space</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>Beta coefficient of a linear regression line in log-log space</p>
</td></tr>
<tr><td><code>rsquared</code></td>
<td>
<p>R squared of x and y values in log-log space</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>References</h3>

<p>Rowlands A, Edwardson CL, et al. (2018) Beyond Cut Points: Accelerometer Metrics 
that Capture the Physical Activity Profile. MSSE 50(6):1. 
doi:10.1249/MSS.0000000000001561
</p>

<hr>
<h2 id='g.IVIS'>
Calculates IV and IS
</h2><span id='topic+g.IVIS'></span>

<h3>Description</h3>

<p>To extract interdaily stability and interdaily variability as originally proposed by
van Someren.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.IVIS(Xi, epochsizesecondsXi = 5, IVIS_epochsize_seconds = c(),
    IVIS_windowsize_minutes = 60, IVIS.activity.metric = 1,
    IVIS_acc_threshold = 20, IVIS_per_daypair = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.IVIS_+3A_xi">Xi</code></td>
<td>

<p>Vector with acceleration values, e.g. ENMO metric.
</p>
</td></tr>
<tr><td><code id="g.IVIS_+3A_epochsizesecondsxi">epochsizesecondsXi</code></td>
<td>

<p>Epoch size of the values in Xi expressed in seconds.
</p>
</td></tr>
<tr><td><code id="g.IVIS_+3A_ivis_epochsize_seconds">IVIS_epochsize_seconds</code></td>
<td>

<p>This argument has been depricated.
</p>
</td></tr>
<tr><td><code id="g.IVIS_+3A_ivis_windowsize_minutes">IVIS_windowsize_minutes</code></td>
<td>

<p>Window size of the Intradaily Variability (IV) and Interdaily
Stability (IS) metrics in minutes, needs to be able to add up to 24 hours.
</p>
</td></tr>
<tr><td><code id="g.IVIS_+3A_ivis.activity.metric">IVIS.activity.metric</code></td>
<td>

<p>Metric used for activity calculation.
Value = 1, uses continuous scaled acceleration.
Value = 2, tries to collapse acceleration into a binary score of rest
versus active to try to simulate the original approach.
</p>
</td></tr>
<tr><td><code id="g.IVIS_+3A_ivis_acc_threshold">IVIS_acc_threshold</code></td>
<td>

<p>Acceleration threshold to distinguish inactive from active
</p>
</td></tr>
<tr><td><code id="g.IVIS_+3A_ivis_per_daypair">IVIS_per_daypair</code></td>
<td>

<p>Boolean to indicate whether IVIS should be calculated per day pair and
then aggregated across day pairs weighted by day completeness (default FALSE).
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>InterdailyStability</code></td>
<td>
</td></tr>
<tr><td><code>IntradailyVariability</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> Eus J. W. Van Someren, Dick F. Swaab, Christopher C. Colenda, 
Wayne Cohen, W. Vaughn McCall &amp; Peter B. Rosenquist. Bright Light Therapy: 
Improved Sensitivity to Its Effects on Rest-Activity Rhythms in Alzheimer 
Patients by Application of Nonparametric Methods  Chronobiology
International. 1999. Volume 16, issue 4.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  Xi = abs(rnorm(n = 10000,mean = 0.2))
  IVISvariables = g.IVIS(Xi=Xi)
</code></pre>

<hr>
<h2 id='g.loadlog'>
Load and clean sleeplog information
</h2><span id='topic+g.loadlog'></span>

<h3>Description</h3>

<p>Loads sleeplog from a csv input file and applies sanity checks
before storing the output in a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.loadlog(loglocation=c(),coln1=c(),colid=c(),
    sleeplogsep=",", meta.sleep.folder = c(),
  desiredtz="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.loadlog_+3A_loglocation">loglocation</code></td>
<td>

<p>Location of the spreadsheet (csv) with sleep log information.
See package vignette for explanation on expected format
</p>
</td></tr>
<tr><td><code id="g.loadlog_+3A_coln1">coln1</code></td>
<td>

<p>Column number in the sleep log spreadsheet where the onset of the first
night starts
</p>
</td></tr>
<tr><td><code id="g.loadlog_+3A_colid">colid</code></td>
<td>

<p>Column number in the sleep log spreadsheet in which the participant
ID code is stored (default = 1)
</p>
</td></tr>
<tr><td><code id="g.loadlog_+3A_sleeplogsep">sleeplogsep</code></td>
<td>

<p>Value used as sep argument for reading sleeplog csv file, usually &quot;,&quot; or &quot;;&quot;.
This argument has been deprecated.
</p>
</td></tr>
<tr><td><code id="g.loadlog_+3A_meta.sleep.folder">meta.sleep.folder</code></td>
<td>

<p>Path to part3 milestone data, only specify if sleeplog is in advanced format.
</p>
</td></tr>
<tr><td><code id="g.loadlog_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+g.part4">g.part4</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with sleeplog, which can be either in basic format or in advanced
format. See GGIR package vignette for discussion of these two formats.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  sleeplog = g.loadlog(loglocation="C:/mysleeplog.csv",coln1=2,
  colid=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='g.part1'>
function to load and pre-process acceleration files
</h2><span id='topic+g.part1'></span>

<h3>Description</h3>

<p>Calls function <a href="#topic+g.getmeta">g.getmeta</a> and <a href="#topic+g.calibrate">g.calibrate</a>, and converts the
output to .RData-format which will be the input for <a href="#topic+g.part2">g.part2</a>. Here,
the function generates a folder structure to keep track of various output files.
The reason why these <a href="#topic+g.part1">g.part1</a> and <a href="#topic+g.part2">g.part2</a> are not merged as one
generic shell function is because g.part1 takes much
longer to and involves only minor decisions of interest to the movement scientist.
Function g.part2 on the other hand is relatively fast and comes with all the
decisions that directly impact on the variables that are of interest to the
movement scientist. Therefore, the user may want to run g.part1 overnight
or on a computing cluster, while g.part2 can then be the main playing ground
for the movement scientist. Function <a href="#topic+GGIR">GGIR</a> provides the main shell
that allows for operating g.part1 and g.part2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part1(datadir = c(), metadatadir = c(), f0 = 1, f1 = c(),
          myfun = c(), params_metrics = c(), params_rawdata = c(),
          params_cleaning = c(), params_general = c(), verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part1_+3A_datadir">datadir</code></td>
<td>

<p>Directory where the accelerometer files are stored, e.g. 
&quot;C:/mydata&quot;, or list of accelerometer filenames and directories, e.g. 
c(&quot;C:/mydata/myfile1.bin&quot;, &quot;C:/mydata/myfile2.bin&quot;).
</p>
</td></tr>
<tr><td><code id="g.part1_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Directory where the output needs to be stored. Note that this 
function will attempt to create folders in this directory and uses
those folder to keep output.
</p>
</td></tr>
<tr><td><code id="g.part1_+3A_f0">f0</code></td>
<td>

<p>File index to start with (default = 1). Index refers to the filenames sorted
in alphabetical order
</p>
</td></tr>
<tr><td><code id="g.part1_+3A_f1">f1</code></td>
<td>

<p>File index to finish with (defaults to number of files available, i.e., f1 = 0)
</p>
</td></tr>
<tr><td><code id="g.part1_+3A_myfun">myfun</code></td>
<td>

<p>External function object to be applied to raw data.
See details <a href="#topic+applyExtFunction">applyExtFunction</a>.
</p>
</td></tr>
<tr><td><code id="g.part1_+3A_params_metrics">params_metrics</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part1_+3A_params_rawdata">params_rawdata</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part1_+3A_params_cleaning">params_cleaning</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part1_+3A_params_general">params_general</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part1_+3A_verbose">verbose</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part1_+3A_...">...</code></td>
<td>

<p>If you are working with a non-standard csv formatted files, <a href="#topic+g.part1">g.part1</a> also takes any input
arguments needed for function <a href="#topic+read.myacc.csv">read.myacc.csv</a> and argument rmc.noise from
<a href="#topic+get_nw_clip_block_params">get_nw_clip_block_params</a>. First test these argument with function <a href="#topic+read.myacc.csv">read.myacc.csv</a> directly.
To ensure compatibility with R scripts written for older GGIR versions, the user can also
provide parameters listed in the params_ objects as direct argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GGIR comes with many processing parameters, which have been thematically grouped in
parameter objects (R list). By running print(load_params()) you can
see the default values of all the parameter objects. When g.part 1 is used via <a href="#topic+GGIR">GGIR</a>
you have the option to specifiy a configuration file, which will overrule the default
parameter values. Further, as user you can set parameter values as input argument to both <a href="#topic+g.part1">g.part1</a>
and <a href="#topic+GGIR">GGIR</a>. Directly specified argument overrule the configuration file and default values.
</p>
<p>See the GGIR package vignette or the details section in <a href="#topic+GGIR">GGIR</a> for a more elaborate overview of parameter objects and their usage across GGIR.
</p>


<h3>Value</h3>

<p>The function provides no values, it only ensures that the output from other
functions is stored in .RData(one file per accelerometer file) in folder structure
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> van Hees VT, Gorzelniak L, Dean Leon EC, Eder M, Pias M, et al. (2013) Separating
Movement and Gravity Components in an Acceleration Signal and Implications for the
Assessment of Human Daily Physical Activity. PLoS ONE 8(4): e61691.
doi:10.1371/journal.pone.0061691
</p>
</li>
<li><p> van Hees VT, Fang Z, Langford J, Assah F, Mohammad A, da Silva IC, Trenell MI,
White T, Wareham NJ, Brage S. Auto-calibration of accelerometer data for
free-living physical activity assessment using local gravity and temperature:
an evaluation on four continents. J Appl Physiol (1985). 2014 Aug 7
</p>
</li>
<li><p> Aittasalo M, Vaha-Ypya H, Vasankari T, Husu P, Jussila AM, and Sievanen H. Mean
amplitude deviation calculated from raw acceleration data: a novel method for
classifying the intensity of adolescents physical activity irrespective of accelerometer
brand. BMC Sports Science, Medicine and Rehabilitation (2015).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    datafile = "C:/myfolder/mydata"
    outputdir = "C:/myresults"
    g.part1(datadir,outputdir)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='g.part2'>
function to analyse and summarize pre-processed output from <a href="#topic+g.part1">g.part1</a>
</h2><span id='topic+g.part2'></span>

<h3>Description</h3>

<p>Loads the output from <a href="#topic+g.part1">g.part1</a> and then applies <a href="#topic+g.impute">g.impute</a> and
<a href="#topic+g.analyse">g.analyse</a>, after which the output is converted to .RData-format
which will be used by <a href="#topic+GGIR">GGIR</a> to generate reports.
The variables in these reports are the same variables as described in
<a href="#topic+g.analyse">g.analyse</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part2(datadir = c(), metadatadir = c(), f0 = c(), f1 = c(),
        myfun = c(), params_cleaning = c(), params_247 = c(),
        params_phyact = c(), params_output = c(), params_general = c(),
        verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part2_+3A_datadir">datadir</code></td>
<td>

<p>Directory where the accelerometer files are stored, e.g.
&quot;C:/mydata&quot;, or list of accelerometer filenames and directories, e.g.
c(&quot;C:/mydata/myfile1.bin&quot;, &quot;C:/mydata/myfile2.bin&quot;).
</p>
</td></tr>
<tr><td><code id="g.part2_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Directory that holds a folder 'meta' and inside this a folder 'basic'
which contains the milestone data produced by <a href="#topic+g.part1">g.part1</a>. The folderstructure
is normally created by <a href="#topic+g.part1">g.part1</a> and <a href="#topic+GGIR">GGIR</a> will recognise what
the value of metadatadir is.
</p>
</td></tr>
<tr><td><code id="g.part2_+3A_f0">f0</code></td>
<td>

<p>File index to start with (default = 1). Index refers to the filenames sorted
in alphabetical order
</p>
</td></tr>
<tr><td><code id="g.part2_+3A_f1">f1</code></td>
<td>

<p>File index to finish with (defaults to number of files available, i.e., f1 = 0)
</p>
</td></tr>
<tr><td><code id="g.part2_+3A_myfun">myfun</code></td>
<td>

<p>External function object to be applied to raw data.
See details <a href="#topic+applyExtFunction">applyExtFunction</a>.
</p>
</td></tr>
<tr><td><code id="g.part2_+3A_params_cleaning">params_cleaning</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part2_+3A_params_247">params_247</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part2_+3A_params_phyact">params_phyact</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part2_+3A_params_output">params_output</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part2_+3A_params_general">params_general</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part2_+3A_verbose">verbose</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part2_+3A_...">...</code></td>
<td>

<p>To ensure compatibility with R scripts written for older GGIR versions,
the user can also provide parameters listed in the params_ objects as direct argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GGIR comes with many processing parameters, which have been thematically grouped in
parameter objects (R list). By running print(load_params()) you can
see the default values of all the parameter objects. When g.part 2 is used via <a href="#topic+GGIR">GGIR</a>
you have the option to specifiy a configuration file, which will overrule the default
parameter values. Further, as user you can set parameter values as input argument to both g.part2
and <a href="#topic+GGIR">GGIR</a>. Directly specified argument overrule the configuration file and default values.
</p>
<p>See the GGIR package vignette or the details section in <a href="#topic+GGIR">GGIR</a> for a more elaborate overview of parameter objects and their usage across GGIR.
</p>


<h3>Value</h3>

<p>The function provides no values, it only ensures that other functions are called
and that their output is stored in the folder structure as created with <a href="#topic+g.part1">g.part1</a>.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> van Hees VT, Gorzelniak L, Dean Leon EC, Eder M, Pias M, et al. (2013) Separating
Movement and Gravity Components in an Acceleration Signal and Implications for the
Assessment of Human Daily Physical Activity. PLoS ONE 8(4): e61691.
doi:10.1371/journal.pone.0061691
</p>
</li>
<li><p> van Hees VT, Fang Z, Langford J, Assah F, Mohammad A, da Silva IC, Trenell MI,
White T, Wareham NJ, Brage S. Auto-calibration of accelerometer data for
free-living physical activity assessment using local gravity and temperature:
an evaluation on four continents. J Appl Physiol (1985). 2014 Aug 7
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    metadatadir = "C:/myresults/output_mystudy"
    g.part2(metadatadir)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='g.part3'>
Detection of sustained inactivity periods as needed for sleep detection
in g.part4.
</h2><span id='topic+g.part3'></span>

<h3>Description</h3>

<p>Function called by function GGIR. It estimates the sustained inactivity
periods in each day, which are used as input for g.part4 which then labels
them as nocturnal sleep or day time sustained inactivity periods.
Typical users should work with function GGIR only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.part3(metadatadir = c(), f0, f1, myfun = c(), 
  params_sleep = c(), params_metrics = c(), params_output = c(), 
  params_general = c(), verbose = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part3_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Directory that holds a folder 'meta' and inside this a folder 'basic'
which contains the milestone data produced by <a href="#topic+g.part1">g.part1</a>. The folderstructure
is normally created by <a href="#topic+g.part1">g.part1</a> and <a href="#topic+GGIR">GGIR</a> will recognise what
the value of metadatadir is.
</p>
</td></tr>
<tr><td><code id="g.part3_+3A_f0">f0</code></td>
<td>

<p>File index to start with (default = 1). Index refers to the filenames sorted
in alphabetical order
</p>
</td></tr>
<tr><td><code id="g.part3_+3A_f1">f1</code></td>
<td>

<p>File index to finish with (defaults to number of files available, i.e., f1 = 0)
</p>
</td></tr>
<tr><td><code id="g.part3_+3A_myfun">myfun</code></td>
<td>

<p>External function object to be applied to raw data.
See details <a href="#topic+applyExtFunction">applyExtFunction</a>.
</p>
</td></tr>
<tr><td><code id="g.part3_+3A_params_sleep">params_sleep</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part3_+3A_params_metrics">params_metrics</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part3_+3A_params_output">params_output</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part3_+3A_params_general">params_general</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part3_+3A_verbose">verbose</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part3_+3A_...">...</code></td>
<td>

<p>To ensure compatibility with R scripts written for older GGIR versions,
the user can also provide parameters listed in the params_ objects as direct argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GGIR comes with many processing parameters, which have been thematically grouped in
parameter objects (R list). By running print(load_params()) you can
see the default values of all the parameter objects. When g.part 3 is used via <a href="#topic+GGIR">GGIR</a>
you have the option to specifiy a configuration file, which will overrule the default
parameter values. Further, as user you can set parameter values as input argument to both g.part3
and <a href="#topic+GGIR">GGIR</a>. Directly specified argument overrule the configuration file and default values.
</p>
<p>See the GGIR package vignette or the details section in <a href="#topic+GGIR">GGIR</a> for a more elaborate overview of parameter objects and their usage across GGIR.
</p>


<h3>Value</h3>

<p>The function provides no values, it only ensures that other functions
are called and that their output is stored in .RData files.
<br />
</p>

<ul>
<li> <p><code>night</code> nightnumber
</p>
</li>
<li> <p><code>definition</code> definition of sustained inactivity. For example,
T10A5 refers to 10 minute window and a 5 degree angle (see paper for
further explaination).
</p>
</li>
<li> <p><code>start.time.day</code> timestamp when the day started
</p>
</li>
<li> <p><code>nsib.periods</code> number of sustained inactivity bouts
</p>
</li>
<li> <p><code>tot.sib.dur.hrs</code> total duration of all sustained inactivity bouts
</p>
</li>
<li> <p><code>fraction.night.invalid</code> fraction of the night for which
accelerometer data was invalid, e.g. monitor not worn
</p>
</li>
<li> <p><code>sib.period</code> number of sustained inactivity period
</p>
</li>
<li> <p><code>sib.onset.time</code> onset time of sustained inactivity period
</p>
</li>
<li> <p><code>sib.end.time</code> end time of sustained inactivity period
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> van Hees VT, Sabia S, et al. (2015) A novel, open access method to
assess sleep duration using a wrist-worn accelerometer, PLoS ONE, November 2015
</p>
</li>
<li><p> van Hees VT, Sabia S, et al. (2018) Estimating sleep parameters
using an accelerometer without sleep diary. Scientific Reports.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    metadatadir = "C:/myfolder/meta" # assumes that there is a subfolder in
    # metadatadir named 'basic' containing the output from g.part1
    g.part3(metadatadir=metadatadir, anglethreshold=5,
    timethreshold=5, overwrite=FALSE)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='g.part4'>
Labels detected sustained inactivity periods by g.part3 as either
part of the Sleep Period Time window or not
</h2><span id='topic+g.part4'></span>

<h3>Description</h3>

<p>Combines output from <a href="#topic+g.part3">g.part3</a> and guider information to estimate
sleep variables. See vignette paragraph &quot;Sleep and full day
time-use analysis in GGIR&quot; for an elaborate descript of the sleep detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> g.part4(datadir = c(), metadatadir = c(), f0 = f0, f1 = f1, params_sleep = c(), 
    params_metrics = c(),  params_cleaning = c(), params_output = c(),
                   params_general = c(), verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part4_+3A_datadir">datadir</code></td>
<td>

<p>Directory where the accelerometer files are stored, e.g. 
&quot;C:/mydata&quot;, or list of accelerometer filenames and directories, e.g. 
c(&quot;C:/mydata/myfile1.bin&quot;, &quot;C:/mydata/myfile2.bin&quot;).
</p>
</td></tr>
<tr><td><code id="g.part4_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Directory that holds a folder 'meta' and inside this a folder 'basic'
which contains the milestone data produced by <a href="#topic+g.part1">g.part1</a>. The folderstructure
is normally created by <a href="#topic+g.part1">g.part1</a> and <a href="#topic+GGIR">GGIR</a> will recognise what
the value of metadatadir is.
</p>
</td></tr>
<tr><td><code id="g.part4_+3A_f0">f0</code></td>
<td>

<p>File index to start with (default = 1). Index refers to the filenames sorted
in alphabetical order
</p>
</td></tr>
<tr><td><code id="g.part4_+3A_f1">f1</code></td>
<td>

<p>File index to finish with (defaults to number of files available, i.e., f1 = 0)
</p>
</td></tr>
<tr><td><code id="g.part4_+3A_params_sleep">params_sleep</code></td>
<td>

<p>List of parameters used for sleep analysis (GGIR part 3, 4, and 5): 
see documentation <a href="#topic+g.part3">g.part3</a>.
</p>
</td></tr>
<tr><td><code id="g.part4_+3A_params_metrics">params_metrics</code></td>
<td>

<p>List of parameters used for metrics extraction (GGIR part 1): 
see documentation <a href="#topic+g.part1">g.part1</a>.
</p>
</td></tr>
<tr><td><code id="g.part4_+3A_params_cleaning">params_cleaning</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part4_+3A_params_output">params_output</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part4_+3A_params_general">params_general</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part4_+3A_verbose">verbose</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part4_+3A_...">...</code></td>
<td>

<p>To ensure compatibility with R scripts written for older GGIR versions,
the user can also provide parameters listed in the params_ objects as direct argument.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function does not produce values but generates an RData file
in the milestone subfolder ms4.out which incudes a dataframe
named <code>nightsummary</code>. This dataframe is used in g.report.part4 to create
two reports one per night and one per person. See package vignette 
paragraph &quot;Output part 4&quot; for description of all the variables.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> van Hees VT, Sabia S, et al. (2018) AEstimating sleep parameters
using an accelerometer without sleep diary, Scientific Reports.
</p>
</li>
<li><p> van Hees VT, Sabia S, et al. (2015) A novel, open access method
to assess sleep duration using a wrist-worn accelerometer, PLoS ONE.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    metadatadir = "C:/myfolder/meta" # assumes that there is a subfolder in
    # metadatadir named 'ms3.out' containing the output from g.part3
    g.part4(metadatadir=metadatadir)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='g.part4_extractid'>
Extracts ID from filename and finds matching rows in sleeplog
</h2><span id='topic+g.part4_extractid'></span>

<h3>Description</h3>

<p>Extracts ID from filename and finds matching rows in sleeplog. Function not
designed for direct use by GGIR users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part4_extractid(idloc, fname, dolog, sleeplog, accid = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part4_extractid_+3A_idloc">idloc</code></td>
<td>

<p>See <a href="#topic+g.part4">g.part4</a>
</p>
</td></tr>
<tr><td><code id="g.part4_extractid_+3A_fname">fname</code></td>
<td>

<p>Full patth to filename
</p>
</td></tr>
<tr><td><code id="g.part4_extractid_+3A_dolog">dolog</code></td>
<td>

<p>Boolean to indicate whether to rely on a sleeplog
</p>
</td></tr>
<tr><td><code id="g.part4_extractid_+3A_sleeplog">sleeplog</code></td>
<td>

<p>Sleeplog data.frame passed on from g.part4
</p>
</td></tr>
<tr><td><code id="g.part4_extractid_+3A_accid">accid</code></td>
<td>

<p>ID extracted from the acceleration file in GGIR part3. If not available leave blank.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with accid the ID and matching_indices_sleeplog a vector with matching row
indices in the sleeplog
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.part5'>
Merge output from physical activity and sleep analysis into one report
</h2><span id='topic+g.part5'></span>

<h3>Description</h3>

<p>Function to merge the output from <a href="#topic+g.part2">g.part2</a> and <a href="#topic+g.part4">g.part4</a> into one report enhanced with
profiling of sleep and physical activity stratified across intensity levels and
based on bouted periods as well as non-bouted periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.part5(datadir = c(), metadatadir = c(), f0 = c(), f1 = c(),
                   params_sleep = c(), params_metrics = c(),
                   params_247 = c(), params_phyact = c(), 
                   params_cleaning = c(), params_output = c(),
                   params_general = c(), verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5_+3A_datadir">datadir</code></td>
<td>

<p>Directory where the accelerometer files are stored, e.g. 
&quot;C:/mydata&quot;, or list of accelerometer filenames and directories, e.g. 
c(&quot;C:/mydata/myfile1.bin&quot;, &quot;C:/mydata/myfile2.bin&quot;).
</p>
</td></tr>
<tr><td><code id="g.part5_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Directory that holds a folder 'meta' and inside this a folder 'basic'
which contains the milestone data produced by <a href="#topic+g.part1">g.part1</a>. The folderstructure
is normally created by <a href="#topic+g.part1">g.part1</a> and <a href="#topic+GGIR">GGIR</a> will recognise what
the value of metadatadir is.
</p>
</td></tr>
<tr><td><code id="g.part5_+3A_f0">f0</code></td>
<td>

<p>File index to start with (default = 1). Index refers to the filenames sorted
in alphabetical order
</p>
</td></tr>
<tr><td><code id="g.part5_+3A_f1">f1</code></td>
<td>

<p>File index to finish with (defaults to number of files available, i.e., f1 = 0)
</p>
</td></tr>
<tr><td><code id="g.part5_+3A_params_sleep">params_sleep</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part5_+3A_params_metrics">params_metrics</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part5_+3A_params_247">params_247</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part5_+3A_params_phyact">params_phyact</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part5_+3A_params_cleaning">params_cleaning</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part5_+3A_params_output">params_output</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part5_+3A_params_general">params_general</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part5_+3A_verbose">verbose</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part5_+3A_...">...</code></td>
<td>

<p>To ensure compatibility with R scripts written for older GGIR versions,
the user can also provide parameters listed in the params_ objects as direct argument.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function does not produce values but generates an RData file
in the milestone subfolder ms5.out which incudes a dataframe
named <code>output</code>. This dataframe is used in g.report.part5 to create
two reports one per day and one per person. See package vignette
paragraph &quot;Output part 5&quot; for description of all the variables.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    metadatadir = "C:/myfolder/meta"
    g.part5(metadatadir=metadatadir)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='g.part5_analyseSegment'>
Analyses the time series per time segment for part 5
</h2><span id='topic+g.part5_analyseSegment'></span>

<h3>Description</h3>

<p>Not intended for direct use by GGIR users, part of <a href="#topic+g.part5">g.part5</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5_analyseSegment(indexlog, timeList, levelList,
                                  segments,
                                  segments_names,
                                  dsummary, ds_names,
                                  params_general, params_output,
                                  params_sleep, params_247,
                                  params_phyact,
                                  sumSleep, sibDef,
                                  fullFilename,
                                  add_one_day_to_next_date,
                                  lightpeak_available,
                                  tail_expansion_log,
                                  foldernamei, sibreport = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5_analyseSegment_+3A_indexlog">indexlog</code></td>
<td>

<p>List of objects related to indices of window, file, and segment that
are passed on from <a href="#topic+g.part5">g.part5</a> to aid selecting time segments or keeping track
of where in file the code is.
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_timelist">timeList</code></td>
<td>

<p>List of objects related to time series passed on from <a href="#topic+g.part5">g.part5</a>.
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_levellist">levelList</code></td>
<td>

<p>List of objects related to intensity levels passed on from <a href="#topic+g.part5">g.part5</a>. 
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_segments">segments</code></td>
<td>

<p>List produced by <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_segments_names">segments_names</code></td>
<td>

<p>Vector produced by <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_dsummary">dsummary</code></td>
<td>

<p>Matrix to hold all daysummary (and segment summary)
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_ds_names">ds_names</code></td>
<td>

<p>Character vector with column names of the dsummary matrix. The code collects
these separately in this vector and assigns them at the end.
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_params_general">params_general</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_params_output">params_output</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_params_sleep">params_sleep</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_params_247">params_247</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_params_phyact">params_phyact</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_sumsleep">sumSleep</code></td>
<td>

<p>Section of data.frame produced by <a href="#topic+g.part4">g.part4</a> passed on from <a href="#topic+g.part5">g.part5</a>.
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_sibdef">sibDef</code></td>
<td>

<p>Character to identify sib definition. 
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_fullfilename">fullFilename</code></td>
<td>

<p>Character with full filename being processed
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_add_one_day_to_next_date">add_one_day_to_next_date</code></td>
<td>

<p>Boolean to indicate whether one day should be added to next date
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_lightpeak_available">lightpeak_available</code></td>
<td>

<p>Boolean to indicate whether light peak is available
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_tail_expansion_log">tail_expansion_log</code></td>
<td>

<p>Object generated in <a href="#topic+g.part1">g.part1</a> and passed on to <a href="#topic+g.part5">g.part5</a> when 
argument <code>recordingEndSleepHour</code> is used.
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_foldernamei">foldernamei</code></td>
<td>

<p>Character with folder name in which the data file is stored.
</p>
</td></tr>
<tr><td><code id="g.part5_analyseSegment_+3A_sibreport">sibreport</code></td>
<td>

<p>Sibreport object as passed on from <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with objects: indexlog, timeList, and the matrix with the prelimenary results
and column names (dsummary and ds_names, see input arguments above)
</p>

<hr>
<h2 id='g.part5_initialise_ts'>
Initialise time series data from for part 5
</h2><span id='topic+g.part5_initialise_ts'></span>

<h3>Description</h3>

<p>Initialise time series dataframe ts, part of <a href="#topic+g.part5">g.part5</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5_initialise_ts(IMP, M, params_247, params_general, longitudinal_axis = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5_initialise_ts_+3A_imp">IMP</code></td>
<td>

<p>Object derived from <a href="#topic+g.part2">g.part2</a>
</p>
</td></tr>
<tr><td><code id="g.part5_initialise_ts_+3A_m">M</code></td>
<td>

<p>Object derived from <a href="#topic+g.part1">g.part1</a>.
</p>
</td></tr>
<tr><td><code id="g.part5_initialise_ts_+3A_params_247">params_247</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.part5_initialise_ts_+3A_params_general">params_general</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a> 
</p>
</td></tr>
<tr><td><code id="g.part5_initialise_ts_+3A_longitudinal_axis">longitudinal_axis</code></td>
<td>

<p>As passed on from g.part5, which could be specified by user or estimated
from hip data in part 2. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame ts
</p>

<hr>
<h2 id='g.part5.addfirstwake'>
Adds first wake if it is missing in part 4 output.
</h2><span id='topic+g.part5.addfirstwake'></span>

<h3>Description</h3>

<p>Not intended for direct use by GGIR users.
Adds first wake if it is missing in part 4 output
as part of <a href="#topic+g.part5">g.part5</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5.addfirstwake(ts, summarysleep, nightsi, sleeplog,
  ID, Nepochsinhour, SPTE_end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5.addfirstwake_+3A_ts">ts</code></td>
<td>

<p>Data.frame object as passed on from <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
<tr><td><code id="g.part5.addfirstwake_+3A_summarysleep">summarysleep</code></td>
<td>

<p>Data.frame object as passed on from <a href="#topic+g.part5">g.part5</a> with
sleep summary information from <a href="#topic+g.part4">g.part4</a>.
</p>
</td></tr>
<tr><td><code id="g.part5.addfirstwake_+3A_nightsi">nightsi</code></td>
<td>

<p>Vector with indices for the nights
</p>
</td></tr>
<tr><td><code id="g.part5.addfirstwake_+3A_sleeplog">sleeplog</code></td>
<td>

<p>Data.frame with all sleeplog information
</p>
</td></tr>
<tr><td><code id="g.part5.addfirstwake_+3A_id">ID</code></td>
<td>

<p>Participant ID
</p>
</td></tr>
<tr><td><code id="g.part5.addfirstwake_+3A_nepochsinhour">Nepochsinhour</code></td>
<td>

<p>Number of epochs in an hour
</p>
</td></tr>
<tr><td><code id="g.part5.addfirstwake_+3A_spte_end">SPTE_end</code></td>
<td>

<p>Sleep period time end index
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame ts updated with first wakeup time
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.part5.addsib'>
Adds the sustained inactivity bout to the ts series.
</h2><span id='topic+g.part5.addsib'></span>

<h3>Description</h3>

<p>Not intended for direct use by GGIR users.
Adds the sustained inactivity bout to the ts series
as part of <a href="#topic+g.part5">g.part5</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5.addsib(ts, epochSize, part3_output, desiredtz,
              sibDefinition, nightsi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5.addsib_+3A_ts">ts</code></td>
<td>

<p>Data.frame object as passed on from <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
<tr><td><code id="g.part5.addsib_+3A_epochsize">epochSize</code></td>
<td>

<p>Short epoch size in seconds
</p>
</td></tr>
<tr><td><code id="g.part5.addsib_+3A_part3_output">part3_output</code></td>
<td>

<p>Segment of part 3 output relevant for current sleep definition
</p>
</td></tr>
<tr><td><code id="g.part5.addsib_+3A_desiredtz">desiredtz</code></td>
<td>

<p>see <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.part5.addsib_+3A_sibdefinition">sibDefinition</code></td>
<td>

<p>Character to indicate definition of sib (sustained inactivity bout)
</p>
</td></tr>
<tr><td><code id="g.part5.addsib_+3A_nightsi">nightsi</code></td>
<td>

<p>Vector with indices for the midnights
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame ts
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.part5.analyseRest'>
Analyse rest (internal function)
</h2><span id='topic+g.part5.analyseRest'></span>

<h3>Description</h3>

<p>Analyses overlap self-reported napping, non-wear and sib.
Internal function not intended for direct use by GGIR end-user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5.analyseRest(sibreport = NULL, dsummary = NULL,
                                ds_names = NULL, fi = NULL,
                                di = NULL, time = NULL, tz = NULL,
                                possible_nap_dur = 0,
                                possible_nap_edge_acc = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5.analyseRest_+3A_sibreport">sibreport</code></td>
<td>

<p>sibreport data.frame produced by <a href="#topic+g.sibreport">g.sibreport</a>
</p>
</td></tr>
<tr><td><code id="g.part5.analyseRest_+3A_dsummary">dsummary</code></td>
<td>

<p>matrix created internally by <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
<tr><td><code id="g.part5.analyseRest_+3A_ds_names">ds_names</code></td>
<td>

<p>character vector with variable names corresponding to dsummary
created internally by <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
<tr><td><code id="g.part5.analyseRest_+3A_fi">fi</code></td>
<td>

<p>Numeric scalar to indicate variable index, created internally by <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
<tr><td><code id="g.part5.analyseRest_+3A_di">di</code></td>
<td>

<p>Numeric scalar to indicate recording index, created internally by <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
<tr><td><code id="g.part5.analyseRest_+3A_time">time</code></td>
<td>

<p>Daytime section of time column from the ts object, created internally by <a href="#topic+g.part5">g.part5</a>,
</p>
</td></tr>
<tr><td><code id="g.part5.analyseRest_+3A_tz">tz</code></td>
<td>

<p>Timezone database name
</p>
</td></tr>
<tr><td><code id="g.part5.analyseRest_+3A_possible_nap_dur">possible_nap_dur</code></td>
<td>

<p>Minimum sib duration to be considered. For self-reported naps/nonwear
there is a minimum duration of 1 epoch.
</p>
</td></tr>
<tr><td><code id="g.part5.analyseRest_+3A_possible_nap_edge_acc">possible_nap_edge_acc</code></td>
<td>

<p>Maximum acceleration before or after the SIB for it to be considered.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with updated objects dsummary, ds_names, fi, and di
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.part5.classifyNaps'>
Classify Naps from identified sustained inactivty bouts
</h2><span id='topic+g.part5.classifyNaps'></span>

<h3>Description</h3>

<p>Classify Naps from identified sustained inactivty bouts, based on model
that was originally trained with hip-worn accelerometer data in 3-3.5 year olds.
Assume that metric ENMO is used and HASIB.algo is set to vanHees2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5.classifyNaps(sibreport = c(), desiredtz = "", 
        possible_nap_window = c(9, 18),
        possible_nap_dur = c(15, 240),
        nap_model = "hip3yr", HASIB.algo = "vanHees2015")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5.classifyNaps_+3A_sibreport">sibreport</code></td>
<td>

<p>Object generated by <a href="#topic+g.sibreport">g.sibreport</a>
</p>
</td></tr>
<tr><td><code id="g.part5.classifyNaps_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+g.getmeta">g.getmeta</a>.
</p>
</td></tr>
<tr><td><code id="g.part5.classifyNaps_+3A_possible_nap_window">possible_nap_window</code></td>
<td>

<p>Numeric vector of length two with range in clock hours during which naps are
assumed to take place.
</p>
</td></tr>
<tr><td><code id="g.part5.classifyNaps_+3A_possible_nap_dur">possible_nap_dur</code></td>
<td>

<p>Numeric vector of length two with range in duration (minutes) of a nap.
</p>
</td></tr>
<tr><td><code id="g.part5.classifyNaps_+3A_nap_model">nap_model</code></td>
<td>

<p>Character to specify classification model. Currently the only option is &quot;hip3yr&quot;, which
corresponds to a model trained with hip data in 3-3.5 olds trained with parent diary data.
</p>
</td></tr>
<tr><td><code id="g.part5.classifyNaps_+3A_hasib.algo">HASIB.algo</code></td>
<td>

<p>See <a href="#topic+g.part3">g.part3</a>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with classified naps and newly detected non-wear periods.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.part5.definedays'>
Fix missing night in part 4 output
</h2><span id='topic+g.part5.definedays'></span>

<h3>Description</h3>

<p>Not intended for direct use by GGIR users.
Defines when day windows start and end as part of <a href="#topic+g.part5">g.part5</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5.definedays(nightsi, wi, indjump, nightsi_bu, 
                     epochSize, qqq_backup = c(), ts,
                     timewindowi, Nwindows, qwindow, ID = NULL,
                     dayborder = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5.definedays_+3A_nightsi">nightsi</code></td>
<td>

<p>Vector with indices for the midnights
</p>
</td></tr>
<tr><td><code id="g.part5.definedays_+3A_wi">wi</code></td>
<td>

<p>Numeric to indicate window number
</p>
</td></tr>
<tr><td><code id="g.part5.definedays_+3A_indjump">indjump</code></td>
<td>

<p>Number of indices to jump
</p>
</td></tr>
<tr><td><code id="g.part5.definedays_+3A_nightsi_bu">nightsi_bu</code></td>
<td>

<p>See argument <code>nightsi</code> this is a backup of this object
</p>
</td></tr>
<tr><td><code id="g.part5.definedays_+3A_epochsize">epochSize</code></td>
<td>

<p>Numeric epoch size in seconds
</p>
</td></tr>
<tr><td><code id="g.part5.definedays_+3A_qqq_backup">qqq_backup</code></td>
<td>

<p>Backup of qqq object, which holds the start and end indices of a window
</p>
</td></tr>
<tr><td><code id="g.part5.definedays_+3A_ts">ts</code></td>
<td>

<p>Data.frame with time series
</p>
</td></tr>
<tr><td><code id="g.part5.definedays_+3A_timewindowi">timewindowi</code></td>
<td>

<p>Timewindow definition either &quot;MM&quot; or &quot;WW&quot;
</p>
</td></tr>
<tr><td><code id="g.part5.definedays_+3A_nwindows">Nwindows</code></td>
<td>

<p>Number of windows in the data
</p>
</td></tr>
<tr><td><code id="g.part5.definedays_+3A_qwindow">qwindow</code></td>
<td>

<p>qwindow argument
</p>
</td></tr>
<tr><td><code id="g.part5.definedays_+3A_id">ID</code></td>
<td>

<p>ID of participant
</p>
</td></tr>
<tr><td><code id="g.part5.definedays_+3A_dayborder">dayborder</code></td>
<td>

<p>dayborder argument
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of qqq and qqq_backup 
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.part5.fixmissingnight'>
Fix missing night in part 4 output
</h2><span id='topic+g.part5.fixmissingnight'></span>

<h3>Description</h3>

<p>Not intended for direct use by GGIR users.
If a night is missing in the part4 output then this function
tries to fix as part of <a href="#topic+g.part5">g.part5</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5.fixmissingnight(summarysleep, sleeplog = c(), ID)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5.fixmissingnight_+3A_summarysleep">summarysleep</code></td>
<td>

<p>Object produced by <a href="#topic+g.part4">g.part4</a>
</p>
</td></tr>
<tr><td><code id="g.part5.fixmissingnight_+3A_sleeplog">sleeplog</code></td>
<td>

<p>Sleeplog object as passed on from <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
<tr><td><code id="g.part5.fixmissingnight_+3A_id">ID</code></td>
<td>

<p>ID of participant
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corrected summarysleep_tmp2 object.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.part5.handle_lux_extremes'>
Check lux values for extremes and imputes or removes them
</h2><span id='topic+g.part5.handle_lux_extremes'></span>

<h3>Description</h3>

<p>Extreme values are imputed by mean of neightbours if they occur isolated or
in a sequence of two, and removed if they occure in a sequence of 3 or longer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5.handle_lux_extremes(lux)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5.handle_lux_extremes_+3A_lux">lux</code></td>
<td>

<p>Vector with lux values
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of imputed lux values and a vector with matching length named
correction_log indicating which timestamps where imputed (value=1),
replaced by NA (value=2) or untouched (value=0).
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.part5.lux_persegment'>
Extract key lux variables per segment of the data.
</h2><span id='topic+g.part5.lux_persegment'></span>

<h3>Description</h3>

<p>Extracts per segment of the day: mean lux, time above 1000 lux, time awake,
and time LUX imputed. Function not intended
for direct use by package user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5.lux_persegment(ts, sse, LUX_day_segments, epochSize, desiredtz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5.lux_persegment_+3A_ts">ts</code></td>
<td>

<p>Data.frame with time series
</p>
</td></tr>
<tr><td><code id="g.part5.lux_persegment_+3A_sse">sse</code></td>
<td>

<p>Indices corresponding to the current time window (e.g. MM or WW)
</p>
</td></tr>
<tr><td><code id="g.part5.lux_persegment_+3A_lux_day_segments">LUX_day_segments</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.part5.lux_persegment_+3A_epochsize">epochSize</code></td>
<td>

<p>Numeric epoch size in seconds
</p>
</td></tr>
<tr><td><code id="g.part5.lux_persegment_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with values (vector) of the derived variables and corresponding names (vector).
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.part5.onsetwaketiming'>
Identify wake and sleepperiod window timing
</h2><span id='topic+g.part5.onsetwaketiming'></span>

<h3>Description</h3>

<p>Not intended for direct use by GGIR users.
Labels timing of wakeing up and sleep onset as part of <a href="#topic+g.part5">g.part5</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5.onsetwaketiming(qqq, ts, min, sec, hour, timewindowi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5.onsetwaketiming_+3A_qqq">qqq</code></td>
<td>

<p>Start and end index of window to analyses
</p>
</td></tr>
<tr><td><code id="g.part5.onsetwaketiming_+3A_ts">ts</code></td>
<td>

<p>Data.frame with time series as created in <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
<tr><td><code id="g.part5.onsetwaketiming_+3A_min">min</code></td>
<td>

<p>Numeric vector with minute values
</p>
</td></tr>
<tr><td><code id="g.part5.onsetwaketiming_+3A_sec">sec</code></td>
<td>

<p>Numeric vector with second values
</p>
</td></tr>
<tr><td><code id="g.part5.onsetwaketiming_+3A_hour">hour</code></td>
<td>

<p>Numeric vector with hour values
</p>
</td></tr>
<tr><td><code id="g.part5.onsetwaketiming_+3A_timewindowi">timewindowi</code></td>
<td>

<p>Character to indicate what timewindow definition is used either &quot;MM&quot; or &quot;WW&quot;
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with objects: wake, onset, wakei, onseti, skiponset, and skipwake.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.part5.savetimeseries'>
Saves part 5 time series to csv files
</h2><span id='topic+g.part5.savetimeseries'></span>

<h3>Description</h3>

<p>Not intended for direct use by GGIR users.
Saves part 5 time series to csv files as part of <a href="#topic+g.part5">g.part5</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5.savetimeseries(ts, LEVELS, desiredtz, rawlevels_fname,
                              DaCleanFile = NULL,
                              includedaycrit.part5 = 2/3,
                              ID = NULL, params_output,
                              params_247 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5.savetimeseries_+3A_ts">ts</code></td>
<td>

<p>Data.frame with time series
</p>
</td></tr>
<tr><td><code id="g.part5.savetimeseries_+3A_levels">LEVELS</code></td>
<td>

<p>As produced as one of the objects in the output of <a href="#topic+identify_levels">identify_levels</a>
</p>
</td></tr>
<tr><td><code id="g.part5.savetimeseries_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part5.savetimeseries_+3A_rawlevels_fname">rawlevels_fname</code></td>
<td>

<p>Path to the file where the output should be stored
</p>
</td></tr>
<tr><td><code id="g.part5.savetimeseries_+3A_dacleanfile">DaCleanFile</code></td>
<td>

<p>Content of data_cleaning_file as documented in <a href="#topic+g.report.part5">g.report.part5</a>.
Only used in this function if save_ms5rawlevels is TRUE,  and it 
only affects the time 
series files stored.
</p>
</td></tr>
<tr><td><code id="g.part5.savetimeseries_+3A_includedaycrit.part5">includedaycrit.part5</code></td>
<td>

<p>See <a href="#topic+g.report.part5">g.report.part5</a>. Only used in this function if
save_ms5rawlevels is TRUE,  and it only affects the time 
series files stored.
</p>
</td></tr>
<tr><td><code id="g.part5.savetimeseries_+3A_id">ID</code></td>
<td>

<p>If data_cleaning_file is used then this argument specifies
which participant ID the data correspond with.
</p>
</td></tr>
<tr><td><code id="g.part5.savetimeseries_+3A_params_output">params_output</code></td>
<td>

<p>Parameters object, see <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.part5.savetimeseries_+3A_params_247">params_247</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function does not provide output, it only prepare data for saving
and saves it to a file. For documention on columns see main vignette.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.part5.wakesleepwindows'>
Label wake and sleepperiod window
</h2><span id='topic+g.part5.wakesleepwindows'></span>

<h3>Description</h3>

<p>Not intended for direct use by GGIR users.
Label wake and sleepperiod window as part of <a href="#topic+g.part5">g.part5</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.part5.wakesleepwindows(ts, part4_output, desiredtz,
                    nightsi, sleeplog, epochSize,ID, Nepochsinhour)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part5.wakesleepwindows_+3A_ts">ts</code></td>
<td>

<p>data.frame with time series
</p>
</td></tr>
<tr><td><code id="g.part5.wakesleepwindows_+3A_part4_output">part4_output</code></td>
<td>

<p>cleaned output from part 4
</p>
</td></tr>
<tr><td><code id="g.part5.wakesleepwindows_+3A_desiredtz">desiredtz</code></td>
<td>

<p><a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.part5.wakesleepwindows_+3A_nightsi">nightsi</code></td>
<td>

<p>vector with indices for the midnights
</p>
</td></tr>
<tr><td><code id="g.part5.wakesleepwindows_+3A_sleeplog">sleeplog</code></td>
<td>

<p>Data.frame with sleeplog information as loaded by <a href="#topic+g.loadlog">g.loadlog</a>
</p>
</td></tr>
<tr><td><code id="g.part5.wakesleepwindows_+3A_epochsize">epochSize</code></td>
<td>

<p>Short epochsize in seconds
</p>
</td></tr>
<tr><td><code id="g.part5.wakesleepwindows_+3A_id">ID</code></td>
<td>

<p>ID of the participant
</p>
</td></tr>
<tr><td><code id="g.part5.wakesleepwindows_+3A_nepochsinhour">Nepochsinhour</code></td>
<td>

<p>Number of epochs in an hour
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object ts
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.part6'>
Perform temporal pattern analyses
</h2><span id='topic+g.part6'></span>

<h3>Description</h3>

<p>This function aims to facilitate time-pattern analysis building on the labelled time
series derived in GGIR part 5
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.part6(datadir = c(), metadatadir = c(), f0 = c(), f1 = c(),
                   params_general = c(), params_phyact = c(), params_247 = c(),
                   verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.part6_+3A_datadir">datadir</code></td>
<td>

<p>Directory where the accelerometer files are stored, e.g. 
&quot;C:/mydata&quot;, or list of accelerometer filenames and directories, e.g. 
c(&quot;C:/mydata/myfile1.bin&quot;, &quot;C:/mydata/myfile2.bin&quot;).
</p>
</td></tr>
<tr><td><code id="g.part6_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Directory that holds a folder 'meta' and inside this a folder 'basic'
which contains the milestone data produced by <a href="#topic+g.part1">g.part1</a>. The folderstructure
is normally created by <a href="#topic+g.part1">g.part1</a> and <a href="#topic+GGIR">GGIR</a> will recognise what
the value of metadatadir is.
</p>
</td></tr>
<tr><td><code id="g.part6_+3A_f0">f0</code></td>
<td>

<p>File index to start with (default = 1). Index refers to the filenames sorted
in alphabetical order
</p>
</td></tr>
<tr><td><code id="g.part6_+3A_f1">f1</code></td>
<td>

<p>File index to finish with (defaults to number of files available, i.e., f1 = 0)
</p>
</td></tr>
<tr><td><code id="g.part6_+3A_params_general">params_general</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part6_+3A_params_phyact">params_phyact</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part6_+3A_params_247">params_247</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part6_+3A_verbose">verbose</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.part6_+3A_...">...</code></td>
<td>

<p>To ensure compatibility with R scripts written for older GGIR versions,
the user can also provide parameters listed in the params_ objects as direct argument.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function does not produce values but generates an RData file
in the milestone subfolder ms6.out which incudes ... (TO BE COMPLETED).
This dataframe is used in g.report.part6 to create
reports. See package vignette
paragraph (TO BE COMPLETED) for description of all the variables.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    metadatadir = "C:/myfolder/meta"
    g.part6(metadatadir=metadatadir)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='g.plot'>
function to generate a plot for quality check purposes
</h2><span id='topic+g.plot'></span>

<h3>Description</h3>

<p>Function takes meta-data as generated by <a href="#topic+g.getmeta">g.getmeta</a> and <a href="#topic+g.impute">g.impute</a>
to create a visual representation of imputed time periods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.plot(IMP, M, I, durplot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.plot_+3A_imp">IMP</code></td>
<td>

<p>output from <a href="#topic+g.impute">g.impute</a>
</p>
</td></tr>
<tr><td><code id="g.plot_+3A_m">M</code></td>
<td>

<p>output from <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
<tr><td><code id="g.plot_+3A_i">I</code></td>
<td>

<p>output from <a href="#topic+g.inspectfile">g.inspectfile</a>
</p>
</td></tr>
<tr><td><code id="g.plot_+3A_durplot">durplot</code></td>
<td>

<p>number of days to plot
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function only produces a plot, no values
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  #inspect file:
  I = g.inspectfile(datafile)
  
  #autocalibration:
  C = g.calibrate(datafile) 
  
  #get meta-data:
  M = g.getmeta(datafile)

## End(Not run)
data(data.getmeta)
data(data.inspectfile)

#impute meta-data:
IMP = g.impute(M = data.getmeta, I = data.inspectfile, strategy = 1,
hrs.del.start = 0, hrs.del.end = 0, maxdur = 0)

#plot data
g.plot(IMP, M = data.getmeta, I = data.inspectfile, durplot=4)
</code></pre>

<hr>
<h2 id='g.plot5'>
Generate user-friendly visual report. The first part of the report summarizes important daily metrics in bar plot format.
The second part of the report shows the raw data and annotations in 24-hr periods.
Angle-z is shown with sleep annotations during the SPT (sleep period time) window.
ENMO is shown with daytime inactivity and PA (physical activity) annotations in the lower
section of each 24-hr plot. The PA annotations are based on a 10 minute bout metric and
80
of a 10 minute bout of MVPA. Vigorous PA is a short window of time above threshold.vig that
is part of a bout of MVPA. Light PA is a short window of time above threshold.lig that is
part of a bout of light PA.
</h2><span id='topic+g.plot5'></span>

<h3>Description</h3>

<p>Function called by <a href="#topic+GGIR">GGIR</a> to generate report. Not intended
for direct use by user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.plot5(metadatadir = c(), dofirstpage = FALSE, viewingwindow = 1,
  f0 = c(), f1 = c(), overwrite = FALSE, metric="ENMO",desiredtz = "",
  threshold.lig = 30, threshold.mod = 100, threshold.vig = 400, 
  visualreport_without_invalid = TRUE, includedaycrit = 0.66, includenightcrit = 0.66,
  verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.plot5_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Directory that holds a folder 'meta' and inside this a folder 'basic'
which contains the milestone data produced by <a href="#topic+g.part1">g.part1</a>. The folderstructure
is normally created by <a href="#topic+g.part1">g.part1</a> and <a href="#topic+GGIR">GGIR</a> will recognise what
the value of metadatadir is.
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_dofirstpage">dofirstpage</code></td>
<td>

<p>Boolean to indicate whether a first page with historgrams summarizing the whole
measurement should be added
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_viewingwindow">viewingwindow</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_f0">f0</code></td>
<td>

<p>File index to start with (default = 1). Index refers to the filenames sorted
in alphabetical order
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_f1">f1</code></td>
<td>

<p>File index to finish with (defaults to number of files available, i.e., f1 = 0)
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_overwrite">overwrite</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_metric">metric</code></td>
<td>

<p>Which one of the metrics do you want to consider to describe behaviour. The
metric of interest need to be calculated in M (see <a href="#topic+g.part1">g.part1</a>)
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_threshold.lig">threshold.lig</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_threshold.mod">threshold.mod</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_threshold.vig">threshold.vig</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_visualreport_without_invalid">visualreport_without_invalid</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_includenightcrit">includenightcrit</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_includedaycrit">includedaycrit</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.plot5_+3A_verbose">verbose</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No values, this function only generates a plot
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
Matthew R Patterson &lt;mpatterson@shimmersensing.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    # generate plots for the first 10 files:
    g.plot5(metadatadir="C:/output_mystudy/meta/basic",dofirstpage=TRUE,
    viewingwindow = 1,f0=1,f1=10,overwrite=FALSE,desiredtz = "Europe/London",
    threshold.lig,threshold.mod,threshold.vig)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='g.readaccfile'>
Generic functiont to read large blocks of accelerometer data
</h2><span id='topic+g.readaccfile'></span>

<h3>Description</h3>

<p>The function is used by <a href="#topic+g.getmeta">g.getmeta</a> and <a href="#topic+g.calibrate">g.calibrate</a> to
read large blocks of the accelerometer file, which are processed and
then deleted from memory. This is needed for memory management.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.readaccfile(filename, blocksize, blocknumber, filequality,
                           ws, PreviousEndPage = 1, inspectfileobject = c(),
                           PreviousLastValue = c(0,0,1), PreviousLastTime = NULL,
                           params_rawdata = c(), params_general = c(), header = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.readaccfile_+3A_filename">filename</code></td>
<td>

<p>filename
</p>
</td></tr>
<tr><td><code id="g.readaccfile_+3A_blocksize">blocksize</code></td>
<td>

<p>Size of blocks (in file pages) to be read
</p>
</td></tr>
<tr><td><code id="g.readaccfile_+3A_blocknumber">blocknumber</code></td>
<td>

<p>Block number relative to start of file, starting with 1.
</p>
</td></tr>
<tr><td><code id="g.readaccfile_+3A_filequality">filequality</code></td>
<td>

<p>Single row dataframe with columns: filetooshort, filecorrupt,
and filedoesnotholdday. All with the value TRUE or FALSE
</p>
</td></tr>
<tr><td><code id="g.readaccfile_+3A_ws">ws</code></td>
<td>

<p>Larger windowsize for non-detection, see documentation <a href="#topic+g.part2">g.part2</a>
</p>
</td></tr>
<tr><td><code id="g.readaccfile_+3A_previousendpage">PreviousEndPage</code></td>
<td>

<p>Page number on which previous block ended (automatically assigned within
g.getmeta and g.calibrate).
</p>
</td></tr>
<tr><td><code id="g.readaccfile_+3A_inspectfileobject">inspectfileobject</code></td>
<td>

<p>Output from the function <a href="#topic+g.inspectfile">g.inspectfile</a>.
</p>
</td></tr>
<tr><td><code id="g.readaccfile_+3A_previouslastvalue">PreviousLastValue</code></td>
<td>

<p>Automatically identified last value in previous chunk of data read.
</p>
</td></tr>
<tr><td><code id="g.readaccfile_+3A_previouslasttime">PreviousLastTime</code></td>
<td>

<p>Automatically identified last timestamp in previous chunk of data read.
</p>
</td></tr>
<tr><td><code id="g.readaccfile_+3A_params_rawdata">params_rawdata</code></td>
<td>

<p>See <a href="#topic+g.part1">g.part1</a>
</p>
</td></tr>
<tr><td><code id="g.readaccfile_+3A_params_general">params_general</code></td>
<td>

<p>See <a href="#topic+g.part1">g.part1</a>
</p>
</td></tr>
<tr><td><code id="g.readaccfile_+3A_header">header</code></td>
<td>

<p>Header information that was extracted the previous time this file was read,
to be re-used instead of being extracted again.
</p>
</td></tr>
<tr><td><code id="g.readaccfile_+3A_...">...</code></td>
<td>

<p>Any input arguments needed for function <a href="#topic+read.myacc.csv">read.myacc.csv</a> if you
are working with a non-standard csv formatted files. Furter,
any argument used in the previous version of g.readaccfile, which will now
be used to overrule the arguments specified with the parameter objects.
</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>P</code> Block object extracted from file with format specific to
accelerometer brand
</p>
</li>
<li> <p><code>filequality</code> Same as in function arguments
</p>
</li>
<li> <p><code>isLastBlock</code> Boolean indicating whether this was the last block to read
</p>
</li>
<li> <p><code>endpage</code> Page number on which blocked ends, this will be
used as input for argument PreviousEndPage when reading the next block.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    filequality = data.frame(filetooshort = FALSE, filecorrupt = FALSE,
    filedoesnotholdday = FALSE)
    output = g.readaccfile(filename = "C:/myfile.bin", 
    blocksize = 20000, blocknumber = 1,
    selectdaysfile = c(), filequality = filequality,
    dayborder = 0, PreviousEndPage = c()) 
  
## End(Not run)
</code></pre>

<hr>
<h2 id='g.readtemp_movisens'>
Reads the temperature from movisens files.
</h2><span id='topic+g.readtemp_movisens'></span>

<h3>Description</h3>

<p>Reads the temperature from movisens files, resamples it and adds 
it to the matrix where accelerations are stored
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.readtemp_movisens(datafile, from = c(), to = c(), acc_sf, acc_length,
                    interpolationType=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.readtemp_movisens_+3A_datafile">datafile</code></td>
<td>

<p>Full path to the folder where the movisens bin files are stored. Note that 
movisens store a set of bin file in one folder per recording. GGIR will read 
the pertinent bin file to access to the temperature data.
</p>
</td></tr>
<tr><td><code id="g.readtemp_movisens_+3A_from">from</code></td>
<td>

<p>Origin point to derive the temperature from movisens files (automatically 
calculated by GGIR)
</p>
</td></tr>
<tr><td><code id="g.readtemp_movisens_+3A_to">to</code></td>
<td>

<p>End point to derive the temperature from movisens files (automatically 
calculated by GGIR)
</p>
</td></tr>
<tr><td><code id="g.readtemp_movisens_+3A_acc_sf">acc_sf</code></td>
<td>

<p>Sample frequency of acceleration data
</p>
</td></tr>
<tr><td><code id="g.readtemp_movisens_+3A_acc_length">acc_length</code></td>
<td>

<p>number of acceleration data samples
</p>
</td></tr>
<tr><td><code id="g.readtemp_movisens_+3A_interpolationtype">interpolationType</code></td>
<td>

<p>Integer to indicate type of interpolation to be used when resampling time series (mainly relevant for Axivity sensors), 1=linear, 2=nearest neighbour.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data matrix with the temperature values resampled at 64 Hz.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  P = g.readtemp_movisens(datafile, from = c(), to = c(), acc_sf = 64, acc_length = 3000)

## End(Not run)
</code></pre>

<hr>
<h2 id='g.report.part2'>
Generate report from milestone data produced by <a href="#topic+g.part2">g.part2</a>
</h2><span id='topic+g.report.part2'></span>

<h3>Description</h3>

<p>Creates report from milestone data produced by <a href="#topic+g.part2">g.part2</a>. Not intended
for direct use by package user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.report.part2(metadatadir = c(), f0 = c(), f1 = c(), maxdur = 0,
  store.long = FALSE, params_output, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.report.part2_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Directory that holds a folder 'meta' and inside this a folder 'basic'
which contains the milestone data produced by <a href="#topic+g.part1">g.part1</a>. The folderstructure
is normally created by <a href="#topic+g.part1">g.part1</a> and <a href="#topic+GGIR">GGIR</a> will recognise what
the value of metadatadir is.
</p>
</td></tr>
<tr><td><code id="g.report.part2_+3A_f0">f0</code></td>
<td>

<p>File index to start with (default = 1). Index refers to the filenames sorted
in alphabetical order
</p>
</td></tr>
<tr><td><code id="g.report.part2_+3A_f1">f1</code></td>
<td>

<p>File index to finish with (defaults to number of files available, i.e., f1 = 0)
</p>
</td></tr>
<tr><td><code id="g.report.part2_+3A_maxdur">maxdur</code></td>
<td>

<p>see <a href="#topic+g.part2">g.part2</a>
</p>
</td></tr>
<tr><td><code id="g.report.part2_+3A_store.long">store.long</code></td>
<td>

<p>Booelean to indicate whether output should stored in long
format in addition to default wide format. Automatically turned
to TRUE if using day segmentation with qwindow.
</p>
</td></tr>
<tr><td><code id="g.report.part2_+3A_params_output">params_output</code></td>
<td>

<p>Parameters object, see <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.report.part2_+3A_verbose">verbose</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function does not produce data, but only writes reports
in csv format and visual reports in pdf format
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.report.part4'>
Generate report from milestone data produced by <a href="#topic+g.part4">g.part4</a>
</h2><span id='topic+g.report.part4'></span>

<h3>Description</h3>

<p>Creates report from milestone data produced by <a href="#topic+g.part4">g.part4</a>. Not intended
for direct use by package user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.report.part4(datadir = c(), metadatadir = c(), loglocation = c(), f0 = c(),
  f1 = c(), data_cleaning_file = c(),
  sleepwindowType = "SPT", params_output, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.report.part4_+3A_datadir">datadir</code></td>
<td>

<p>Directory where the accelerometer files are stored, e.g. 
&quot;C:/mydata&quot;, or list of accelerometer filenames and directories, e.g. 
c(&quot;C:/mydata/myfile1.bin&quot;, &quot;C:/mydata/myfile2.bin&quot;).
</p>
</td></tr>
<tr><td><code id="g.report.part4_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Directory that holds a folder 'meta' and inside this a folder 'basic'
which contains the milestone data produced by <a href="#topic+g.part1">g.part1</a>. The folderstructure
is normally created by <a href="#topic+g.part1">g.part1</a> and <a href="#topic+GGIR">GGIR</a> will recognise what
the value of metadatadir is.
</p>
</td></tr>
<tr><td><code id="g.report.part4_+3A_loglocation">loglocation</code></td>
<td>

<p>see <a href="#topic+g.part4">g.part4</a>
</p>
</td></tr>
<tr><td><code id="g.report.part4_+3A_f0">f0</code></td>
<td>

<p>File index to start with (default = 1). Index refers to the filenames sorted
in alphabetical order
</p>
</td></tr>
<tr><td><code id="g.report.part4_+3A_f1">f1</code></td>
<td>

<p>File index to finish with (defaults to number of files available, i.e., f1 = 0)
</p>
</td></tr>
<tr><td><code id="g.report.part4_+3A_data_cleaning_file">data_cleaning_file</code></td>
<td>

<p>see <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.report.part4_+3A_sleepwindowtype">sleepwindowType</code></td>
<td>

<p>see <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.report.part4_+3A_params_output">params_output</code></td>
<td>

<p>Parameters object, see <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.report.part4_+3A_verbose">verbose</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function does not produce data, but only writes reports
in csv format and a visual report in pdf.
</p>
<p>The following files are stored in the root of the results folder:
part4_nightsummary_sleep_cleaned.csv
part4_summary_sleep_cleaned.csv
</p>
<p>The following files are stored in the folder results/QC:
part4_nightsummary_sleep_full.csv
part4_summary_sleep_full.csv
</p>
<p>If a sleeplog is used *_full.csv as stored in the QC folder includes estimates 
for all nights in the data, and *_cleaned.csv in the results folder includes
estimates for all nights in the data excluding the nights that did not had a
sleeplog entry or had no valid accelerometer data.
</p>
<p>If a sleep log is not used then * _cleaned.csv includes the nights that are
in *_full.csv excluding the nights with insufficient data.
</p>
<p>If you have a study where the sleeplog was available for a subset of the
participants, but you want to include all individuals in your analysis, 
then use the *_full.csv output and clean the night level data yourself
by excluding  rows with cleaningcode &gt; 1 which are the cases where no
or invalid accelerometer data was present.
</p>
<p>The above means that for studies with missing sleeplog entries for some
individuals and some nights using the *_full.csv output and excluding
rows (nights) with cleaningcode &gt; 1 will lead to the same as
* _cleaned.csv plus sleep estimates for the nights with missing
sleeplog, providing that there was enough accelerometer data for 
those nights.
</p>
<p>In other words, *_cleaned.csv is perfect if you only want to rely on 
nights with a sleeplog or if you do not use a sleeplog at all. For all
other scenarios We advise using the *_full.csv report and to clean it 
yourself.
</p>
<p>See package vignette sections &quot;Sleep analysis&quot; and &quot;Output part 4&quot;
for a more elaborative description of the sleep analysis and reporting.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.report.part5'>
Generate report from milestone data produced by <a href="#topic+g.part5">g.part5</a>
</h2><span id='topic+g.report.part5'></span>

<h3>Description</h3>

<p>Creates report from milestone data produced by <a href="#topic+g.part5">g.part5</a>. Not intended
for direct use by package user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.report.part5(metadatadir = c(), f0 = c(), f1 = c(), loglocation = c(),
                          params_cleaning = NULL,
                          LUX_day_segments = c(), params_output,
                          verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.report.part5_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Directory that holds a folder 'meta' and inside this a folder 'basic'
which contains the milestone data produced by <a href="#topic+g.part1">g.part1</a>. The folderstructure
is normally created by <a href="#topic+g.part1">g.part1</a> and <a href="#topic+GGIR">GGIR</a> will recognise what
the value of metadatadir is.
</p>
</td></tr>
<tr><td><code id="g.report.part5_+3A_f0">f0</code></td>
<td>

<p>File index to start with (default = 1). Index refers to the filenames sorted
in alphabetical order
</p>
</td></tr>
<tr><td><code id="g.report.part5_+3A_f1">f1</code></td>
<td>

<p>File index to finish with (defaults to number of files available, i.e., f1 = 0)
</p>
</td></tr>
<tr><td><code id="g.report.part5_+3A_loglocation">loglocation</code></td>
<td>

<p>see <a href="#topic+g.part4">g.part4</a>
</p>
</td></tr>
<tr><td><code id="g.report.part5_+3A_params_cleaning">params_cleaning</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.report.part5_+3A_lux_day_segments">LUX_day_segments</code></td>
<td>

<p>see <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
<tr><td><code id="g.report.part5_+3A_params_output">params_output</code></td>
<td>

<p>Parameters object, see <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.report.part5_+3A_verbose">verbose</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function does not produce data, but only writes reports
in csv format
</p>
<p>The following files are stored in the root of the results folder:
part5_daysummary_*
part5_personsummary_*
</p>
<p>The following files are stored in the folder results/QC:
part5_daysummary_full_*
</p>
<p>See package vignette paragraph &quot;Waking-waking or 24 hour time-use analysis&quot;
and &quot;Output part 5&quot; for a more elaborative description of
the full day time-use and analysis and reporting.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.report.part5_dictionary'>
Generate data dictionary for reports from milestone data produced by <a href="#topic+g.part5">g.part5</a>
</h2><span id='topic+g.report.part5_dictionary'></span>

<h3>Description</h3>

<p>Creates a data dictionary with the definitions of the outcomes exported in the
reports from milestone data produced by <a href="#topic+g.part5">g.part5</a>. Not intended
for direct use by package user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.report.part5_dictionary(metadatadir, params_output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.report.part5_dictionary_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Directory that holds a folder 'meta' and inside this a folder 'basic'
which contains the milestone data produced by <a href="#topic+g.part1">g.part1</a>. The folderstructure
is normally created by <a href="#topic+g.part1">g.part1</a> and <a href="#topic+GGIR">GGIR</a> will recognise what
the value of metadatadir is.
</p>
</td></tr>
<tr><td><code id="g.report.part5_dictionary_+3A_params_output">params_output</code></td>
<td>

<p>Parameters object, see <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function does not produce data, but only writes data dictionaries for the
reports in csv format
</p>
<p>The following files are stored in the root of the results folder:
part5_dictionary_daysummary_*
part5_dictionary_personsummary_*
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
Jairo Hidalgo Migueles &lt;jairo@jhmigueles.com&gt;
</p>

<hr>
<h2 id='g.report.part6'>
Generate report from milestone data produced by <a href="#topic+g.part6">g.part6</a>
</h2><span id='topic+g.report.part6'></span>

<h3>Description</h3>

<p>Creates report from milestone data produced by <a href="#topic+g.part6">g.part6</a>. Not intended
for direct use by package user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.report.part6(metadatadir = c(), f0 = c(), f1 = c(),
                          params_cleaning = NULL, params_output, 
                          verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.report.part6_+3A_metadatadir">metadatadir</code></td>
<td>

<p>Directory that holds a folder 'meta' and inside this a folder 'basic'
which contains the milestone data produced by <a href="#topic+g.part1">g.part1</a>. The folderstructure
is normally created by <a href="#topic+g.part1">g.part1</a> and <a href="#topic+GGIR">GGIR</a> will recognise what
the value of metadatadir is.
</p>
</td></tr>
<tr><td><code id="g.report.part6_+3A_f0">f0</code></td>
<td>

<p>File index to start with (default = 1). Index refers to the filenames sorted
in alphabetical order
</p>
</td></tr>
<tr><td><code id="g.report.part6_+3A_f1">f1</code></td>
<td>

<p>File index to finish with (defaults to number of files available, i.e., f1 = 0)
</p>
</td></tr>
<tr><td><code id="g.report.part6_+3A_params_cleaning">params_cleaning</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.report.part6_+3A_params_output">params_output</code></td>
<td>

<p>Parameters object, see <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="g.report.part6_+3A_verbose">verbose</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function does not produce data, but only writes reports
in csv format
</p>
<p>The following files are stored in the root of the results folder:
part6_summary.csv
</p>
<p>See package vignette &quot;HouseHoldCoanalysis&quot;.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.shell.GGIR'>
Wrapper function around function GGIR
</h2><span id='topic+g.shell.GGIR'></span>

<h3>Description</h3>

<p>This function used to be the central function in the package,
but has been renamed GGIR. You can still use function call g.shell.GGIR
but all arguments will be passed on to function GGIR. We have done this to preserve
consistency with older use cases of the GGIR package. All documentation can
now be found in <a href="#topic+GGIR">GGIR</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.shell.GGIR(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.shell.GGIR_+3A_...">...</code></td>
<td>

<p>Any of the parameters used by <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function provides no values, it only ensures that other functions are called
and that their output is stored. See <a href="#topic+GGIR">GGIR</a>.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.sib.det'>
sustiained inactivty bouts detection
</h2><span id='topic+g.sib.det'></span>

<h3>Description</h3>

<p>Detects sustiained inactivty bouts. Function not intended
for direct use by package user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.sib.det(M, IMP, I, twd = c(-12, 12),
             acc.metric = "ENMO", desiredtz = "",
             myfun=c(), sensor.location = "wrist", params_sleep = c(), zc.scale = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.sib.det_+3A_m">M</code></td>
<td>

<p>Object produced by <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
<tr><td><code id="g.sib.det_+3A_imp">IMP</code></td>
<td>

<p>Object produced by <a href="#topic+g.impute">g.impute</a>
</p>
</td></tr>
<tr><td><code id="g.sib.det_+3A_i">I</code></td>
<td>

<p>Object produced by <a href="#topic+g.inspectfile">g.inspectfile</a>
</p>
</td></tr>
<tr><td><code id="g.sib.det_+3A_twd">twd</code></td>
<td>

<p>Vector of length 2, indicating the time window to consider
as hours relative to midnight.
</p>
</td></tr>
<tr><td><code id="g.sib.det_+3A_acc.metric">acc.metric</code></td>
<td>

<p>Which one of the metrics do you want to consider to analyze L5. 
The metric of interest need to be calculated in
M (see <a href="#topic+g.part1">g.part1</a>)
</p>
</td></tr>
<tr><td><code id="g.sib.det_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+g.part3">g.part3</a>
</p>
</td></tr>
<tr><td><code id="g.sib.det_+3A_myfun">myfun</code></td>
<td>

<p>External function object to be applied to raw data.
See details <a href="#topic+applyExtFunction">applyExtFunction</a>.
</p>
</td></tr>
<tr><td><code id="g.sib.det_+3A_sensor.location">sensor.location</code></td>
<td>

<p>Character to indicate sensor location, default is wrist.
If it is hip HDCZA algorithm also requires longitudinal axis of sensor to be
between -45 and +45 degrees.
</p>
</td></tr>
<tr><td><code id="g.sib.det_+3A_params_sleep">params_sleep</code></td>
<td>

<p>See <a href="#topic+g.part3">g.part3</a>
</p>
</td></tr>
<tr><td><code id="g.sib.det_+3A_zc.scale">zc.scale</code></td>
<td>

<p>Used for zero-crossing counts only. Scaling factor to be applied after
counts are calculated (GGIR part 3). See <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
<tr><td><code id="g.sib.det_+3A_...">...</code></td>
<td>

<p>Any argument used in the previous version of g.sib.det, which will now
be used to overrule the arguments specified with the parameter objects.
</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> output = Dataframe for every epoch a classification
</p>
</li>
<li><p> detection.failed = Boolean whether detection failed
</p>
</li>
<li><p> L5list = L5 for every day (defined from noon to noon)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.sib.plot'>
Create plot of sustained inactivity bouts
</h2><span id='topic+g.sib.plot'></span>

<h3>Description</h3>

<p>Function create plot of sustained inactivity bouts for quality
check purposes as part of <a href="#topic+g.part3">g.part3</a>. Not intended for direct use by package user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.sib.plot(SLE, M, I, plottitle, nightsperpage=7, desiredtz="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.sib.plot_+3A_sle">SLE</code></td>
<td>

<p>Output from <a href="#topic+g.sib.det">g.sib.det</a>
</p>
</td></tr>
<tr><td><code id="g.sib.plot_+3A_m">M</code></td>
<td>

<p>Output from <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
<tr><td><code id="g.sib.plot_+3A_i">I</code></td>
<td>

<p>Output from <a href="#topic+g.inspectfile">g.inspectfile</a>
</p>
</td></tr>
<tr><td><code id="g.sib.plot_+3A_plottitle">plottitle</code></td>
<td>

<p>Title to be used in the plot
</p>
</td></tr>
<tr><td><code id="g.sib.plot_+3A_nightsperpage">nightsperpage</code></td>
<td>

<p>Number of nights to show per page
</p>
</td></tr>
<tr><td><code id="g.sib.plot_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+g.part3">g.part3</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function has no output other than the plot
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.sib.sum'>
sustiained inactivty bouts detection
</h2><span id='topic+g.sib.sum'></span>

<h3>Description</h3>

<p>Detects sustiained inactivty bouts. Function not intended
for direct use by package user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.sib.sum(SLE,M,ignorenonwear=TRUE,desiredtz="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.sib.sum_+3A_sle">SLE</code></td>
<td>

<p>Output from <a href="#topic+g.sib.det">g.sib.det</a>
</p>
</td></tr>
<tr><td><code id="g.sib.sum_+3A_m">M</code></td>
<td>

<p>Object produced by <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
<tr><td><code id="g.sib.sum_+3A_ignorenonwear">ignorenonwear</code></td>
<td>

<p>If TRUE then ignore detected monitor non-wear periods to avoid
confusion between monitor non-wear time and sustained inactivity
(default = TRUE)
</p>
</td></tr>
<tr><td><code id="g.sib.sum_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+g.part3">g.part3</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with per night and per definition of sustained inactivity bouts
the start and end time of each sustained inactivity bout
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.sibreport'>
Generate sustiained inactivty bouts report
</h2><span id='topic+g.sibreport'></span>

<h3>Description</h3>

<p>Generate sustained inactivity bout report. Function not intended
for direct use by package user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.sibreport(ts, ID, epochlength, logs_diaries=c(), desiredtz="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.sibreport_+3A_ts">ts</code></td>
<td>

<p>Data frame with time series as created inside function <a href="#topic+g.part5">g.part5</a>
</p>
</td></tr>
<tr><td><code id="g.sibreport_+3A_id">ID</code></td>
<td>

<p>Recording identifier (character or numeric)
</p>
</td></tr>
<tr><td><code id="g.sibreport_+3A_epochlength">epochlength</code></td>
<td>

<p>Numeric to indicate epoch length in seconds in the ts object
</p>
</td></tr>
<tr><td><code id="g.sibreport_+3A_logs_diaries">logs_diaries</code></td>
<td>

<p>Object produced by <a href="#topic+g.loadlog">g.loadlog</a> function
</p>
</td></tr>
<tr><td><code id="g.sibreport_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with one row per sustained inactivity bout and corresponding 
properties stored in the data.frame columns.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='g.weardec'>
Detects whether accelerometer is worn
</h2><span id='topic+g.weardec'></span>

<h3>Description</h3>

<p>Uses the object produced by <a href="#topic+g.part1">g.part1</a> to assess
whether the accelerometer was worn
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g.weardec(M, wearthreshold, ws2, nonWearEdgeCorrection = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.weardec_+3A_m">M</code></td>
<td>

<p>Object produced by <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
<tr><td><code id="g.weardec_+3A_wearthreshold">wearthreshold</code></td>
<td>

<p>Number of axis that at least need to meet the non-wear criteria
</p>
</td></tr>
<tr><td><code id="g.weardec_+3A_ws2">ws2</code></td>
<td>

<p>Large windowsize used in seconds to apply non-wear detection
Small window size not needed, because this is inherent to the object M
</p>
</td></tr>
<tr><td><code id="g.weardec_+3A_nonwearedgecorrection">nonWearEdgeCorrection</code></td>
<td>

<p>Boolean to indicated whether the EdgeCorrection as described in 2013
should be applied (default = TRUE, which is consistent with how code has been)
</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>r1</code> Participant id extracted from file
</p>
</li>
<li> <p><code>r2</code> Night number
</p>
</li>
<li> <p><code>r3</code> Detected onset of sleep expressed as hours 
since the previous midnight
</p>
</li>
<li> <p><code>LC</code> fraction of 15 minute windows with more than 5 percent
clipping
</p>
</li>
<li> <p><code>LC2</code> fraction of 15 minute windows with more than 80
percent clipping
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(data.getmeta)
  output = g.weardec(M = data.getmeta, wearthreshold = 2, ws2 = 900)
</code></pre>

<hr>
<h2 id='get_nw_clip_block_params'>
Set monitor brand specific parameters
</h2><span id='topic+get_nw_clip_block_params'></span>

<h3>Description</h3>

<p>Set monitor brand specific thresholds for non-wear detection, clipping
etection, and blocksizes to be loaded.
Not designed for direct use by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  get_nw_clip_block_params(chunksize, dynrange, monc, dformat, deviceSerialNumber,
    rmc.noise=c(), sf, rmc.dynamic_range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nw_clip_block_params_+3A_chunksize">chunksize</code></td>
<td>

<p>See <a href="#topic+g.calibrate">g.calibrate</a>
</p>
</td></tr>
<tr><td><code id="get_nw_clip_block_params_+3A_dynrange">dynrange</code></td>
<td>

<p>See <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
<tr><td><code id="get_nw_clip_block_params_+3A_monc">monc</code></td>
<td>

<p>See <a href="#topic+g.inspectfile">g.inspectfile</a>
</p>
</td></tr>
<tr><td><code id="get_nw_clip_block_params_+3A_dformat">dformat</code></td>
<td>

<p>See <a href="#topic+g.dotorcomma">g.dotorcomma</a>
</p>
</td></tr>
<tr><td><code id="get_nw_clip_block_params_+3A_deviceserialnumber">deviceSerialNumber</code></td>
<td>

<p>As produced by <a href="#topic+g.extractheadervars">g.extractheadervars</a>
</p>
</td></tr>
<tr><td><code id="get_nw_clip_block_params_+3A_rmc.noise">rmc.noise</code></td>
<td>

<p>Noise level of acceleration signal in _g_-units, used when working ad-hoc .csv data formats
using <a href="#topic+read.myacc.csv">read.myacc.csv</a>. The <a href="#topic+read.myacc.csv">read.myacc.csv</a> does not take rmc.noise as argument,
but when interacting with <a href="#topic+GGIR">GGIR</a> or <a href="#topic+g.part1">g.part1</a> rmc.noise is used.
There, rmc.noise is taken from the params_rawdata object if not explicitly specified by user.
</p>
</td></tr>
<tr><td><code id="get_nw_clip_block_params_+3A_sf">sf</code></td>
<td>

<p>Numeric, sample frequency in Hertz
</p>
</td></tr>
<tr><td><code id="get_nw_clip_block_params_+3A_rmc.dynamic_range">rmc.dynamic_range</code></td>
<td>

<p>Optional, please see <a href="#topic+read.myacc.csv">read.myacc.csv</a>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='get_starttime_weekday_truncdata+20'>
Get starttime (adjusted), weekday, and adjust data accordingly.
</h2><span id='topic+get_starttime_weekday_truncdata'></span>

<h3>Description</h3>

<p>Function not intended for direct use by user.
Used inside <a href="#topic+g.getmeta">g.getmeta</a> as an intermediate step between
loading the raw data and calibrating it. This step includes extracting
the starttime and adjusting it to nearest integer number of long epoch window
lengths in an hour, truncating the data accordingly, and extracting the 
corresponding weekday.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  get_starttime_weekday_truncdata(monc, 
  dformat, data, header, desiredtz, sf,
  datafile, ws2, configtz = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_starttime_weekday_truncdata+2B20_+3A_monc">monc</code></td>
<td>

<p>See <a href="#topic+g.inspectfile">g.inspectfile</a>
</p>
</td></tr>
<tr><td><code id="get_starttime_weekday_truncdata+2B20_+3A_dformat">dformat</code></td>
<td>

<p>See <a href="#topic+g.dotorcomma">g.dotorcomma</a>
</p>
</td></tr>
<tr><td><code id="get_starttime_weekday_truncdata+2B20_+3A_data">data</code></td>
<td>

<p>Data part of <a href="#topic+g.readaccfile">g.readaccfile</a> output
</p>
</td></tr>
<tr><td><code id="get_starttime_weekday_truncdata+2B20_+3A_header">header</code></td>
<td>

<p>Header part of <a href="#topic+g.readaccfile">g.readaccfile</a> output
</p>
</td></tr>
<tr><td><code id="get_starttime_weekday_truncdata+2B20_+3A_desiredtz">desiredtz</code></td>
<td>

<p>See <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
<tr><td><code id="get_starttime_weekday_truncdata+2B20_+3A_sf">sf</code></td>
<td>

<p>Numeric, sample frequency in Hertz
</p>
</td></tr>
<tr><td><code id="get_starttime_weekday_truncdata+2B20_+3A_datafile">datafile</code></td>
<td>

<p>See <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
<tr><td><code id="get_starttime_weekday_truncdata+2B20_+3A_ws2">ws2</code></td>
<td>

<p>Long epoch length
</p>
</td></tr>
<tr><td><code id="get_starttime_weekday_truncdata+2B20_+3A_configtz">configtz</code></td>
<td>

<p>See <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='getfolderstructure'>
Extracts folderstructure based on data directory.
</h2><span id='topic+getfolderstructure'></span>

<h3>Description</h3>

<p>Extracts folderstructure based on data directory. This is used when
accelerometer files are stored in a hierarchical folder structure and
the user likes to have a reference to the exact position in the folder
tree, rather than just the filename.  Function not
intended for direct use by package user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getfolderstructure(datadir=c(),referencefnames=c())	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getfolderstructure_+3A_datadir">datadir</code></td>
<td>

<p>Argument datadir as used in various other functions in GGIR
</p>
</td></tr>
<tr><td><code id="getfolderstructure_+3A_referencefnames">referencefnames</code></td>
<td>

<p>vector with filename to filter on
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with items:
</p>

<ul>
<li><p> fullfilenames: vector with all full paths to the folders including the
name of the file itself
</p>
</li>
<li><p> foldername: vector with only the names of the folder in which each file
is stroed (so only the most distal folder in the folder tree).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    folderstructure = getfolderstructure(datadir)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='GGIR'>
Shell function for analysing an accelerometer dataset.
</h2><span id='topic+GGIR'></span>

<h3>Description</h3>

<p>This function is designed to help users operate all steps of the
analysis. It helps to generate and structure milestone data,
and produces user-friendly reports. The function acts as a shell with
calls to <a href="#topic+g.part1">g.part1</a>, <a href="#topic+g.part2">g.part2</a>, <a href="#topic+g.part3">g.part3</a>,
<a href="#topic+g.part4">g.part4</a> and <a href="#topic+g.part5">g.part5</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GGIR(mode = 1:5,
     datadir = c(),
     outputdir = c(),
     studyname = c(),
     f0 = 1, f1 = 0,
     do.report = c(2, 4, 5, 6),
     configfile = c(),
     myfun = c(),
     verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GGIR_+3A_mode">mode</code></td>
<td>

<p>Numeric (default = 1:5).
Specify which of the five parts need to be run, e.g., mode = 1 makes
that <a href="#topic+g.part1">g.part1</a> is run; or mode = 1:5 makes
that the whole GGIR pipeline is run, from <a href="#topic+g.part1">g.part1</a> to <a href="#topic+g.part5">g.part5</a>.
Optionally mode can also include the number 6 to tell GGIR to run <a href="#topic+g.part6">g.part6</a>
which is currently under development.
</p>
</td></tr>
<tr><td><code id="GGIR_+3A_datadir">datadir</code></td>
<td>

<p>Character (default = c()).
Directory where the accelerometer files are stored, e.g.,
&quot;C:/mydata&quot;, or list of accelerometer filenames and directories, e.g.
c(&quot;C:/mydata/myfile1.bin&quot;, &quot;C:/mydata/myfile2.bin&quot;).
</p>
</td></tr>
<tr><td><code id="GGIR_+3A_outputdir">outputdir</code></td>
<td>

<p>Character (default = c()).
Directory where the output needs to be stored. Note that this
function will attempt to create folders in this directory and uses
those folder to keep output.
</p>
</td></tr>
<tr><td><code id="GGIR_+3A_studyname">studyname</code></td>
<td>

<p>Character (default = c()).
If the datadir is a folder, then the study will be given the name of the
data directory. If datadir is a list of filenames then the studyname as specified
by this input argument will be used as name for the study.
</p>
</td></tr>
<tr><td><code id="GGIR_+3A_f0">f0</code></td>
<td>

<p>Numeric (default = 1).
File index to start with (default = 1). Index refers to the filenames sorted
in alphabetical order.
</p>
</td></tr>
<tr><td><code id="GGIR_+3A_f1">f1</code></td>
<td>

<p>Numeric (default = 0).
File index to finish with (defaults to number of files available).
</p>
</td></tr>
<tr><td><code id="GGIR_+3A_do.report">do.report</code></td>
<td>

<p>Numeric (default = c(2, 4, 5, 6)).
For which parts to generate a summary spreadsheet: 2, 4, 5, and/or 6. Default is c(2, 4, 5, 6).
A report will be generated based on the available milestone data. When creating
milestone data with multiple machines it is advisable to turn the report
generation off when generating the milestone data, value = c(),
and then to merge the milestone data and turn report generation back
on while setting overwrite to FALSE.
</p>
</td></tr>
<tr><td><code id="GGIR_+3A_configfile">configfile</code></td>
<td>

<p>Character (default = c()).
Configuration file previously generated by function GGIR. See details.
</p>
</td></tr>
<tr><td><code id="GGIR_+3A_myfun">myfun</code></td>
<td>

<p>List (default = c()).
External function object to be applied to raw data. See package vignette for detailed tutorial with
examples on how to use the function embedding:
https://cran.r-project.org/package=GGIR/vignettes/ExternalFunction.html
</p>
</td></tr>
<tr><td><code id="GGIR_+3A_verbose">verbose</code></td>
<td>

<p>Boolean (default = TRUE).
to indicate whether console message should be printed. Note that warnings and error are
always printed and can be suppressed with suppressWarning() or suppressMessages().
</p>
</td></tr>
<tr><td><code id="GGIR_+3A_...">...</code></td>
<td>

<p>Any of the parameters used GGIR. Given the large number of parameters used in GGIR
we have grouped them in objects that start with &quot;params_&quot;. These are documented in the
details section. You cannot provide these objects as argument to function GGIR, but
you can provide the parameters inside them as input to function GGIR.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once you have used function GGIR and the output directory (outputdir) will be filled
with milestone data and results. Function GGIR stores all the explicitely
entered argument values and default values for the argument that are not explicitely
provided in a csv-file named config.csv stored in the root of the output folder.
The config.csv file is accepted as input to GGIR with argument <code>configfile</code>
to replace the specification of all the arguments, except <code>datadir</code> and <code>outputdir</code>.
</p>
<p>The practical value of this is that it eases the replication of analysis, because
instead of having to share you R script, sharing your config.csv file will be
sufficient. Further, the config.csv file contribute to the reproducibility
of your data analysis.
</p>
<p>Note: When combining a configuration file with explicitely provided argument
values, the explicitely provided argument values will overrule
the argument values in the configuration file. If a parameter is neither provided
via the configuration file nor as input then GGIR uses its default paramter values which
can be inspected with command <code>print(load_params())</code>, and if you are specifically
interested in a certain subgroup of parameters, e.g., physical activity, then you
can do <code>print(load_params()$params_phyact)</code>. These defaults are part of the GGIR
code and cannot be changed by the user.
</p>
<p>The parameters that can be used in GGIR are:
</p>


<h4>params_general</h4>

<p>A list of parameters used across all GGIR parts that do not fall in any of the other
categories.
</p>

<dl>
<dt>overwrite</dt><dd>
<p>Boolean (default = FALSE).
Do you want to overwrite analysis for which milestone
data exists? If overwrite = FALSE, then milestone data from a previous analysis will
be used if available and visual reports will not be created again.</p>
</dd>
<dt>dayborder</dt><dd>
<p>Numeric (default = 0).
Hour at which days start and end (dayborder = 4 would mean 4 am).</p>
</dd>
<dt>do.parallel</dt><dd>
<p>Boolean (default = TRUE).
Whether to use multi-core processing (only works if at least 4 CPU cores are available).</p>
</dd>
<dt>maxNcores</dt><dd>
<p>Numeric (default = NULL).
Maximum number of cores to use when argument do.parallel is set to true.
GGIR by default uses either the maximum number of available cores or the number of files to
process (whichever is lower), but this argument allows you to set a lower maximum.</p>
</dd>
<dt>acc.metric</dt><dd>
<p>Character (default = &quot;ENMO&quot;).
Which one of the acceleration metrics do you want to use for all acceleration magnitude
analyses in GGIR part 5 and the visual report? For example: &quot;ENMO&quot;, &quot;LFENMO&quot;, &quot;MAD&quot;,
&quot;NeishabouriCount_y&quot;, or &quot;NeishabouriCount_vm&quot;. Only one acceleration metric can be specified
and the selected metric needs to have been calculated in part 1 (see <a href="#topic+g.part1">g.part1</a>)
via arguments such as <code>do.enmo = TRUE</code> or <code>do.mad = TRUE</code>.</p>
</dd>
<dt>part5_agg2_60seconds</dt><dd>
<p>Boolean (default = FALSE).
Whether to use aggregate epochs to 60 seconds as part of the GGIR 
<a href="#topic+g.part5">g.part5</a> analysis. Aggregation is doen by averaging. 
Note that when working with count metrics such as Neishabouri counts this
means that the threshold can stay the same as in part 2, because again the
threshold is expressed relative to the original epoch size, even if averaged
per minute. For example if we want to use a cut-point 100 count per minute
then we specify <code>mvpathreshold = 100 * (5/60)</code> as well as
'threshold.mod = <code>100 * (5/60)</code> regardless of whether we set 
part5_agg2_60seconds to TRUE or FALSE.</p>
</dd>
<dt>print.filename</dt><dd>
<p>Boolean (default = FALSE).
Whether to print the filename before analysing it (in case do.parallel = FALSE).
Printing the filename can be useful to investigate
problems (e.g., to verify that which file is being read).</p>
</dd>
<dt>desiredtz</dt><dd>
<p>Character (default = &quot;&quot;, i.e., system timezone).
Timezone in which device was configured and experiments took place.
If experiments took place in a different timezone, then use this
argument for the timezone in which the experiments took place and
argument <code>configtz</code> to specify where the device was configured.
Use the &quot;TZ identifier&quot; as specified at
<a href="https://en.wikipedia.org/wiki/Zone.tab">https://en.wikipedia.org/wiki/Zone.tab</a>
to set desiredtz, e.g., &quot;Europe/London&quot;.</p>
</dd>
<dt>configtz</dt><dd>
<p>Character (default = &quot;&quot;, i.e., system timezone).
At the moment only functional for GENEActiv .bin, AX3 cwa, ActiGraph .gt3x,
and ad-hoc csv file format.
Timezone in which the accelerometer was configured. Only use this argument
if the timezone of configuration and timezone in which recording took
place are different. Use the &quot;TZ identifier&quot; as specified at
<a href="https://en.wikipedia.org/wiki/Zone.tab">https://en.wikipedia.org/wiki/Zone.tab</a>
to set configtz, e.g., &quot;Europe/London&quot;.</p>
</dd>
<dt>sensor.location</dt><dd>
<p>Character (default = &quot;wrist&quot;).
To indicate sensor location, default is wrist. If it is hip, the HDCZA algorithm for sleep detection
also requires longitudinal axis of sensor to be between -45 and +45 degrees.</p>
</dd>
<dt>windowsizes</dt><dd>
<p>Numeric vector, three values
(default = c(5, 900, 3600)).
To indicate the lengths of the windows as in c(window1, window2, window3):
window1 is the short epoch length in seconds, by default 5, and this is the time 
window over which acceleration and angle metrics are calculated;
window2 is the long epoch length in seconds for which non-wear and signal clipping 
are defined, default 900 (expected to be a multitude of 60 seconds);
window3 is the window length of data used for non-wear detection and by default 3600 seconds.
So, when window3 is larger than window2 we use overlapping windows,
while if window2 equals window3 non-wear periods are assessed by non-overlapping windows.</p>
</dd>
<dt>idloc</dt><dd>
<p>Numeric (default = 1).
If idloc = 1 the code assumes that ID number is stored in the obvious header field. Note that for ActiGraph data
the ID is never stored in the file header.
For value set to 2, 5, 6, and 7, GGIR looks at the filename and extracts the character string preceding the first
occurance of a &quot;_&quot; (idloc = 2), &quot; &quot; (space, idloc = 5), &quot;.&quot; (dot, idloc = 6),
and &quot;-&quot; (idloc = 7), respectively.
You may have noticed that idloc 3 and 4 are skipped, they were used for one study in 2012,
and not actively maintained anymore, but because it is legacy code not omitted.</p>
</dd>
<dt>expand_tail_max_hours</dt><dd>
<p>Numeric (default = NULL).
This parameter has been replaced by <code>recordingEndSleepHour</code>.</p>
</dd>
<dt>recordingEndSleepHour</dt><dd>
<p>Numeric (default = NULL).
Time (in hours) at which the recording should end (or later) to expand the
<a href="#topic+g.part1">g.part1</a> output with synthetic data to trigger sleep detection for last night.
Using argument <code>recordingEndSleepHour</code> implies the assumption that the
participant fell asleep at or before the end of the recording if the recording
ended at or after <code>recordingEndSleepHour</code> hour of the last day.
This assumption may not always hold true and should be used with caution.
The synthetic data for metashort entails: timestamps continuing
regularly, zeros for acceleration metrics other than EN, one for EN.
Angle columns are created in a way that it triggers the sleep detection using
the equation: <code>round(sin((1:length_expansion) / (900/epochsize))) * 15</code>.
To keep track of the tail expansion <a href="#topic+g.part1">g.part1</a> stores the length of the expansion in
the RData files, which is then passed via <a href="#topic+g.part2">g.part2</a>, <a href="#topic+g.part3">g.part3</a>,
and <a href="#topic+g.part4">g.part4</a> to <a href="#topic+g.part5">g.part5</a>. In <a href="#topic+g.part5">g.part5</a> the tail expansion
size is included as an additional variable in the csv-reports.
In the <a href="#topic+g.part4">g.part4</a> csv-report the last night is omitted, because we know
that sleep estimates from the last night will not be trustworthy. Similarly,
in the <a href="#topic+g.part5">g.part5</a> output columns related to the sleep assessment will
be omitted for the last window to avoid biasing the averages. Further,
the synthetic data are also ignored in the visualizations and time series
output to avoid biased output.</p>
</dd>
<dt>dataFormat</dt><dd>
<p>Character (default = &quot;raw&quot;).
To indicate what the format is of the data in datadir.
Alternatives: ukbiobank_csv, actiwatch_csv, actiwatch_awd, 
actigraph_csv, and sensewear_xls, which correspond to epoch level data 
files from, respecitively, UK Biobank in csv format, Actiwatch in csv 
format, Actiwatch in awd format, ActiGraph csv format, and Sensewear in
xls format (also works with xlsx). Here, the assumed epoch size for
UK Biobank csvdata is 5 seconds. 
The epoch size for the other non-raw data formats is 
flexible, but make sure that you set first value of argument 
<code>windowsizes</code> accordingly. Also when working with 
non-raw data formats specify argument <code>extEpochData_timeformat</code> as
documented below. For ukbiobank_csv nonwear is a column in the data itself,
for actiwatch_csv, actiwatch_awd, actigraph_csv, and sensewear_xls non-wear 
is detected as 60 minute rolling zeros. The length of this window can be 
modified with the third value of argument <code>windowsizes</code> expressed in
seconds.</p>
</dd>
<dt>maxRecordingInterval</dt><dd>
<p>Numeric (default = NULL).
To indicate the maximum gap in hours between repeated measurements with the same
ID for the recordings to be appended. So, the assumption is that the
ID can be matched, make sure argument <code>idloc</code> is set correctly.
If argument <code>maxRecordingInterval</code> is set to NULL (default) recordings
are not appended. If recordings overlap then GGIR will use the data from
the latest recording. If recordings are separated then the timegap between
the recordings is filled with data points that resemble monitor not worn.
The maximum value of maxFile gap is 504 (21 days). Only recordings from the
same accelerometer brand are appended. The part 2 csv report
will show number of appended recordings, sampling rate for each, time overlap or gap 
and the names of the filenames of the respective recording.</p>
</dd>
<dt>extEpochData_timeformat</dt><dd>
<p>Character (default = &quot;%d-%m-%Y %H:%M:%S&quot;).
To specify the time format used in the external epoch level data when
argument <code>dataFormat</code> is set to &quot;actiwatch_csv&quot;, &quot;actiwatch_awd&quot;, 
&quot;actigraph_csv&quot; or &quot;sensewear_xls&quot;. For example &quot;%Y-%m-%d %I:%M:%S %p&quot; for 
&quot;2023-07-11 01:24:01 PM&quot; or &quot;%m/%d/%Y %H:%M:%S&quot; &quot;2023-07-11 13:24:01&quot;
</p>
</dd>
</dl>




<h4>params_rawdata</h4>

<p>A list of parameters used to related to reading and pre-processing
raw data, excluding parameters related to metrics as those are in
the params_metrics object.
</p>

<dl>
<dt>backup.cal.coef</dt><dd>
<p>Character (default = &quot;retrieve&quot;).
Option to use backed-up calibration coefficient instead of
deriving the calibration coefficients when analysing the same file twice.
Argument backup.cal.coef has two usecase. Use case 1: If the auto-calibration
fails then the user has the option to provide back-up
calibration coefficients via this argument. The value of the argument needs to
be the name and directory of a csv-spreadsheet with the following column names
and subsequent values: &quot;filename&quot; with the names of accelerometer files on which
the calibration coefficients need to be applied in case auto-calibration fails;
&quot;scale.x&quot;, &quot;scale.y&quot;, and &quot;scale.z&quot; with the scaling coefficients; &quot;offset.x&quot;,
&quot;offset.y&quot;, and &quot;offset.z&quot; with the offset coefficients, and;
&quot;temperature.offset.x&quot;, &quot;temperature.offset.y&quot;, and &quot;temperature.offset.z&quot;
with the temperature offset coefficients. This can be useful for analysing
short lasting laboratory experiments with insufficient sphere data to perform
the auto-calibration, but for which calibration coefficients can be derived
in an alternative way.  It is the users responsibility to compile the
csv-spreadsheet. Instead of building this file the user can also
Use case 2: The user wants to avoid performing the auto-calibration repeatedly
on the same file. If backup.cal.coef value is set to &quot;retrieve&quot; (default) then
GGIR will look out for the &quot;data_quality_report.csv&quot; file in the outputfolder
QC, which holds the previously generated calibration coefficients. If you
do not want this happen, then deleted the data_quality_report.csv from the
QC folder or set it to value &quot;redo&quot;.</p>
</dd>
<dt>minimumFileSizeMB</dt><dd>
<p>Numeric (default = 2).
Minimum File size in MB required to enter processing.
This argument can help to avoid having short uninformative 
files to enter the analyses. Given that a typical accelerometer 
collects several MBs per hour, the default setting should only skip 
the very tiny files.</p>
</dd>
<dt>do.cal</dt><dd>
<p>Boolean (default = TRUE).
Whether to apply auto-calibration or not by <a href="#topic+g.calibrate">g.calibrate</a>.
Recommended setting is TRUE.</p>
</dd>
<dt>imputeTimegaps</dt><dd>
<p>Boolean (default = TRUE).
To indicate whether timegaps larger than 1 sample should be imputed.
Currently only used for .gt3x data and ActiGraph .csv format, where timegaps
can be expected as a result of Actigraph's idle sleep.mode configuration.</p>
</dd>
<dt>spherecrit</dt><dd>
<p>Numeric (default = 0.3).
The minimum required acceleration value (in g) on both sides of 0 g
for each axis. Used to judge whether the sphere is sufficiently populated</p>
</dd>
<dt>minloadcrit</dt><dd>
<p>Numeric (default = 168).
The minimum number of hours the code needs to read for the
autocalibration procedure to be effective (only sensitive to
multitudes of 12 hrs, other values will be ceiled).
After loading these hours only extra data is loaded if 
calibration error has not been reduced to under 0.01 g.</p>
</dd>
<dt>printsummary</dt><dd>
<p>Boolean (default = FALSE).
If TRUE will print a summary of the calibration procedure in
the console when done.</p>
</dd>
<dt>chunksize</dt><dd>
<p>Numeric (default = 1).
Value to specify the size of chunks to be
loaded as a fraction of an approximately 12 hour period for auto-calibration
procedure and as fraction of 24 hour period for the metric calculation, e.g., 
0.5 equals 6 and 12 hour chunks, respectively. 
For machines with less than 4Gb of RAM memory or with &lt; 2GB memory per process
when using <code>do.parallel = TRUE</code> a value below 1 is recommended.
The value is constrained by GGIR to not be lower than 0.05. Please note that
setting 0.05 will not produce output when 3rd value of parameter windowsizes
is 3600.</p>
</dd>
<dt>dynrange</dt><dd>
<p>Numeric (default = NULL).
Provide dynamic range of 8 gravity.</p>
</dd>
<dt>interpolationType</dt><dd>
<p>Integer (default = 1).
To indicate type of interpolation to be used
when resampling time series (mainly relevant for Axivity sensors),
1=linear, 2=nearest neighbour.</p>
</dd>
<dt>rmc.file</dt><dd>
<p>Character (default = NULL).
Filename of file to be read if it is in the working directory,
or full path to the file otherwise.
</p>
</dd>
<dt>rmc.nrow</dt><dd>
<p>Numeric (default = NULL).
Number of rows to read, same as nrow argument in <a href="utils.html#topic+read.csv">read.csv</a> and nrows in <a href="data.table.html#topic+fread">fread</a>.
The whole file is read by default (i.e., rmc.nrow = Inf).</p>
</dd>
<dt>rmc.skip</dt><dd>
<p>Numeric (default = 0).
Number of rows to skip, same as skip argument in <a href="utils.html#topic+read.csv">read.csv</a> and in <a href="data.table.html#topic+fread">fread</a>.</p>
</dd>
<dt>rmc.dec</dt><dd>
<p>Character (default = &quot;.&quot;).
Decimal used for numbers, same as dec argument in <a href="utils.html#topic+read.csv">read.csv</a> and in <a href="data.table.html#topic+fread">fread</a>.</p>
</dd>
<dt>rmc.firstrow.acc</dt><dd>
<p>Numeric (default = NULL).
First row (number) of the acceleration data.</p>
</dd>
<dt>rmc.firstrow.header</dt><dd>
<p>Numeric (default = NULL).
First row (number) of the header. Leave blank if the file does not have a header.</p>
</dd>
<dt>rmc.header.length</dt><dd>
<p>Numeric (default = NULL).
If file has header, specify header length (number of rows).</p>
</dd>
<dt>rmc.col.acc</dt><dd>
<p>Numeric, three values
(default = c(1, 2, 3)).
Vector with three column (numbers) in which the acceleration signals
are stored.</p>
</dd>
<dt>rmc.col.temp</dt><dd>
<p>Numeric (default = NULL).
Scalar with column (number) in which the temperature is stored.
Leave in default setting if no temperature is available. The temperature
will be used by <a href="#topic+g.calibrate">g.calibrate</a>.</p>
</dd>
<dt>rmc.col.time</dt><dd>
<p>Numeric (default = NULL).
Scalar with column (number) in which the timestamps are stored.
Leave in default setting if timestamps are not stored.</p>
</dd>
<dt>rmc.unit.acc</dt><dd>
<p>Character (default = &quot;g&quot;).
Character with unit of acceleration values: &quot;g&quot;, &quot;mg&quot;, or &quot;bit&quot;.</p>
</dd>
<dt>rmc.unit.temp</dt><dd>
<p>Character (default = &quot;C&quot;).
Character with unit of temperature values: (K)elvin, (C)elsius, or (F)ahrenheit.</p>
</dd>
<dt>rmc.unit.time</dt><dd>
<p>Character (default = &quot;POSIX&quot;).
Character with unit of timestamps: &quot;POSIX&quot;, &quot;UNIXsec&quot; (seconds since origin, see argument <code>rmc.origin</code>),
&quot;character&quot;, or &quot;ActivPAL&quot; (exotic timestamp format only used in the ActivPAL
activity monitor).</p>
</dd>
<dt>rmc.format.time</dt><dd>
<p>Character (default = &quot;
Character  giving a date-time format as used by <a href="base.html#topic+strptime">strptime</a>.
Only used for rmc.unit.time: character and POSIX.</p>
</dd>
<dt>rmc.bitrate</dt><dd>
<p>Numeric (default = NULL).
If unit of acceleration is a bit then provide bit rate, e.g., 12 bit.</p>
</dd>
<dt>rmc.dynamic_range</dt><dd>
<p>Numeric or character (default = NULL).
If unit of acceleration is a bit then provide dynamic range deviation
in g from zero, e.g., +/-6g would mean this argument needs to be 6. If you give this
argument a character value the code will search the file header for elements with
a name equal to the character value and use the corresponding numeric value
next to it as dynamic range.</p>
</dd>
<dt>rmc.unsignedbit</dt><dd>
<p>Boolean (default = TRUE).
If unsignedbit = TRUE means that bits are only positive numbers.
if unsignedbit = FALSE then bits are both positive and negative.</p>
</dd>
<dt>rmc.origin</dt><dd>
<p>Character (default = &quot;1970-01-01&quot;).
Origin of time when unit of time is UNIXsec, e.g., 1970-1-1.</p>
</dd>
<dt>rmc.desiredtz</dt><dd>
<p>Character (default = NULL).
Timezone in which experiments took place. This argument is scheduled to
be deprecated and is now used to overwrite <code>desiredtz</code> if not provided.</p>
</dd>
<dt>rmc.configtz</dt><dd>
<p>Character (default = NULL).
Timezone in which device was configured. This argument is scheduled to
be deprecated and is now used to overwrite <code>configtz</code> if not provided.</p>
</dd>
<dt>rmc.sf</dt><dd>
<p>Numeric (default = NULL).
Sample rate in Hertz, if this is stored in the file header then that will be used
instead (see argument <code>rmc.headername.sf</code>).</p>
</dd>
<dt>rmc.headername.sf</dt><dd>
<p>Character (default = NULL).
If file has a header: Row name under which the sample frequency can be found.</p>
</dd>
<dt>rmc.headername.sn</dt><dd>
<p>Character (default = NULL).
If file has a header: Row name under which the serial number can be found.</p>
</dd>
<dt>rmc.headername.recordingid</dt><dd>
<p>Character (default = NULL).
If file has a header: Row name under which the recording ID can be found.</p>
</dd>
<dt>rmc.header.structure</dt><dd>
<p>Character (default = NULL).
Used to split the header name from the header value, e.g., &quot;:&quot; or &quot; &quot;.</p>
</dd>
<dt>rmc.check4timegaps</dt><dd>
<p>Boolean (default = FALSE).
To indicate whether gaps in time should be imputed with zeros.
Some sensing equipment provides accelerometer with gaps in time. The rest of
GGIR is not designed for this, by setting this argument to TRUE the gaps
in time will be filled with zeros.</p>
</dd>
<dt>rmc.col.wear</dt><dd>
<p>Numeric (default = NULL).
If external wear detection outcome is stored as part of the data then this can be used by GGIR.
This argument specifies the column in which the wear detection (Boolean) is stored.</p>
</dd>
<dt>rmc.doresample</dt><dd>
<p>Boolean (default = FALSE).
To indicate whether to resample the data based on the available timestamps and extracted
sample rate from the file header.</p>
</dd>
<dt>rmc.noise</dt><dd>
<p>Numeric (default = 13).
Noise level of acceleration signal in m<em>g</em>-units, used when working ad-hoc .csv data formats
using <a href="#topic+read.myacc.csv">read.myacc.csv</a>. The <a href="#topic+read.myacc.csv">read.myacc.csv</a> does not take rmc.noise as argument,
but when interacting with <a href="#topic+GGIR">GGIR</a> or <a href="#topic+g.part1">g.part1</a> rmc.noise is used.</p>
</dd>
<dt>rmc.scalefactor.acc</dt><dd>
<p>Numeric value (default 1) to scale the acceleration signals via multiplication.
For example, if data is provided in m/s2 then by setting this to 1/9.81
we would derive gravitational units.
</p>
</dd>
<dt>frequency_tol</dt><dd>
<p>Number (default = 0.1) as passed on to readAxivity from the GGIRread package.
Represents the frequency tolerance as fraction between 0 and 1. When the relative bias
per data block is larger than this fraction then the data block will be imputed
by lack of movement with gravitational oriationed guessed from most recent
valid data block. Only applicable to Axivity .cwa data.
</p>
</dd>
</dl>




<h4>params_metrics</h4>

<p>A list of parameters used to specify the signal metrics that need to be extract in GGIR <a href="#topic+g.part1">g.part1</a>.
</p>

<dl>
<dt>do.anglex</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the angle of the X axis relative to the horizontal:
</p>
<p style="text-align: center;"><code class="reqn">angleX = (\tan{^{-1}\frac{acc_{rollmedian(x)}}{(acc_{rollmedian(y)})^2 +
        (acc_{rollmedian(z)})^2}}) * 180/\pi</code>
</p>
</dd>
<dt>do.angley</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the angle of the Y axis relative to the horizontal:
</p>
<p style="text-align: center;"><code class="reqn">angleY = (\tan{^{-1}\frac{acc_{rollmedian(y)}}{(acc_{rollmedian(x)})^2 +
        (acc_{rollmedian(z)})^2}}) * 180/\pi</code>
</p>
</dd>
<dt>do.anglez</dt><dd>
<p>Boolean (default = TRUE).
If TRUE, calculates the angle of the Z axis relative to the horizontal:
</p>
<p style="text-align: center;"><code class="reqn">angleZ = (\tan{^{-1}\frac{acc_{rollmedian(z)}}{(acc_{rollmedian(x)})^2 +
        (acc_{rollmedian(y)})^2}}) * 180/\pi</code>
</p>
</dd>
<dt>do.zcx</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates metric zero-crossing count for x-axis. For computation specifics
see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a></p>
</dd>
<dt>do.zcy</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates metric zero-crossing count for y-axis. For computation specifics
see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a></p>
</dd>
<dt>do.zcz</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates metric zero-crossing count for z-axis. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a></p>
</dd>
<dt>do.enmo</dt><dd>
<p>Boolean (default = TRUE).
If TRUE, calculates the metric: </p>
<p style="text-align: center;"><code class="reqn">ENMO = \sqrt{acc_x^2 + acc_y^2 + acc_z^2} - 1</code>
</p>

<p>(if ENMO &lt; 0, then ENMO = 0).</p>
</dd>
<dt>do.lfenmo</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric <code>ENMO</code> over the low-pass filtered accelerations
(for computation specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>).
The filter bound is defined by the parameter <code>hb</code>.</p>
</dd>
<dt>do.en</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the Euclidean Norm of the raw accelerations:
</p>
<p style="text-align: center;"><code class="reqn">EN = \sqrt{acc_x^2 + acc_y^2 + acc_z^2}</code>
</p>
</dd>
<dt>do.mad</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the Mean Amplitude Deviation:
</p>
<p style="text-align: center;"><code class="reqn">MAD = \frac{1}{n}\Sigma|r_i - \overline{r}|</code>
</p>
</dd>
<dt>do.enmoa</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric:
</p>
<p style="text-align: center;"><code class="reqn">ENMOa = \sqrt{acc_x^2 + acc_y^2 + acc_z^2} - 1</code>
</p>
<p> (if ENMOa &lt; 0, then ENMOa = |ENMOa|).</p>
</dd>
<dt>do.roll_med_acc_x</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.roll_med_acc_y</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.roll_med_acc_z</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.dev_roll_med_acc_x</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.dev_roll_med_acc_y</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.dev_roll_med_acc_z</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.bfen</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.hfen</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.hfenplus</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.lfen</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.lfx</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.lfy</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.lfz</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.hfx</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.hfy</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.hfz</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.bfx</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.bfy</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.bfz</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric. For computation
specifics see source code of function <a href="#topic+g.applymetrics">g.applymetrics</a>.</p>
</dd>
<dt>do.brondcounts</dt><dd>
<p>Boolean (default = FALSE).
this option has been deprecated (October 2022) due to issues with the 
activityCounts package that we used as a dependency.
If TRUE, calculated the metric via R package activityCounts.
We called them BrondCounts because there are large number of activity counts in
the physical activity and sleep research field. By calling them _brondcounts_
we clarify that these are the counts proposed by Jan Br&amp;#248;nd and implemented
in R by Ruben Brondeel. The _brondcounts_ are intended to be an imitation of
the counts produced by one of the closed source ActiLife software by ActiGraph.</p>
</dd>
<dt>do.neishabouricounts</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the metric via R package actilifecounts, which is an 
implementation of the algorithm used in the closed-source software ActiLife 
by ActiGraph (methods published in doi: 10.1038/s41598-022-16003-x). We use 
the name of the first author (instead of ActiLifeCounts) of the paper and 
call them NeishabouriCount under the uncertainty that ActiLife will implement 
this same algorithm over time. To use the Neishabouri counts for the physical 
activity intensity classification in part 5 (i.e., metric over the threshold.lig, 
threshold.mod, and threshold.vig would be applied), the <code>acc.metric</code> 
argument needs to be set as one of the following: &quot;NeishabouriCount_x&quot;,
&quot;NeishabouriCount_y&quot;, &quot;NeishabouriCount_z&quot;, &quot;NeishabouriCount_vm&quot; to use the 
counts in the x-, y-, z-axis or vector magnitude, respectively.</p>
</dd>
<dt>lb</dt><dd>
<p>Numeric (default = 0.2).
Lower boundary of the frequency filter (in Hertz) as used in the filter-based metrics.</p>
</dd>
<dt>hb</dt><dd>
<p>Numeric (default = 15).
Higher boundary of the frequency filter (in Hertz) as used in the filter-based metrics.</p>
</dd>
<dt>n</dt><dd>
<p>Numeric (default = n).
Order of the frequency filter as used in the filter-based metrics.</p>
</dd>
<dt>zc.lb</dt><dd>
<p>Numeric (default = 0.25).
Used for zero-crossing counts only. Lower boundary of cut-off frequency filter.</p>
</dd>
<dt>zc.hb</dt><dd>
<p>Numeric (default = 3).
Used for zero-crossing counts only. Higher boundary of cut-off frequencies in filter.</p>
</dd>
<dt>zc.sb</dt><dd>
<p>Numeric (default = 0.01).
Stop band used for calculation of zero crossing counts. Value is the acceleration threshold
in g units below which  acceleration will be rounded to zero.</p>
</dd>
<dt>zc.order</dt><dd>
<p>Numeric (default = 2).
Used for zero-crossing counts only. Order of frequency filter.</p>
</dd>
<dt>zc.scale</dt><dd>
<p>Numeric (default = 1)
Used for zero-crossing counts only. Scaling factor to be applied after
counts are calculated (GGIR part 3).</p>
</dd>
<dt>actilife_LFE</dt><dd>
<p>Boolean (default = FALSE).
If TRUE, calculates the NeishabouriCount metric with the low-frequency extension filter
as proposed in the closed source ActiLife software by ActiGraph. Only applicable to
the metric NeishabouriCount.</p>
</dd>
</dl>




<h4>params_cleaning</h4>

<p>A list of parameters used across all GGIR parts releated to masking or
imputing data, abbreviated as &quot;cleaning&quot;.
</p>

<dl>
<dt>do.imp</dt><dd>
<p>Boolean (default = TRUE).
Whether to impute missing values (e.g., suspected of monitor non-wear 
or clippling) or not by <a href="#topic+g.impute">g.impute</a> in GGIR <a href="#topic+g.part2">g.part2</a>.
Recommended setting is TRUE.</p>
</dd>
<dt>TimeSegments2ZeroFile</dt><dd>
<p>Character (default = NULL).
Takes path to a csv file that has columns &quot;windowstart&quot; and &quot;windowend&quot;
to refer to the start and end time of a time windows in format
&quot;2024-10-12 20:00:00&quot;, and &quot;filename&quot; of the GGIR
milestone data file without the &quot;meta_&quot; segment of the name. GGIR part 2
uses this to set all acceleration values to zero and the non-wear classification 
to zero (meaning sensor worn). Motivation: When the 
accelerometer is not worn during the night GGIR automatically labels them
as invalid, while the user may like to treat them as zero movement.
Disclaimer: This functionality was developed in 2019. With hindsight it
is not generic enough and in need for revision. Please contact GGIR 
maintainers if you would like us to invest time in improving this 
functionality.</p>
</dd>
<dt>data_cleaning_file</dt><dd>
<p>Character (default = NULL).
Optional path to a csv file you create that holds four columns:
ID, day_part5, relyonguider_part4, and night_part4. ID should hold the
participant ID. Columns day_part5 and night_part4 allow you to specify which
day(s) and night(s) need to be excluded from <a href="#topic+g.part5">g.part5</a> and 
<a href="#topic+g.part4">g.part4</a>, respectively. When including multiple day(s)/night(s) 
create a new line for each day/night.
So, this will be done regardless of whether the rest of GGIR thinks 
those day(s)/night(s) are valid. Column relyonguider_part4 allows you 
to specify for which nights <a href="#topic+g.part4">g.part4</a> should fully rely on the
guider. See also package vignette.</p>
</dd>
<dt>excludefirstlast.part5</dt><dd>
<p>Boolean (default = FALSE).
If TRUE then the first and last window (waking-waking,
midnight-midnight, or sleep onset-onset) are ignored in <a href="#topic+g.part5">g.part5</a>.</p>
</dd>
<dt>excludefirstlast</dt><dd>
<p>Boolean (default = FALSE).
If TRUE then the first and last night of the measurement are ignored for
the sleep assessment in <a href="#topic+g.part4">g.part4</a>.</p>
</dd>
<dt>excludefirst.part4</dt><dd>
<p>Boolean (default = FALSE).
If TRUE then the first night of the measurement are ignored for the sleep 
assessment in <a href="#topic+g.part4">g.part4</a>.</p>
</dd>
<dt>excludelast.part4</dt><dd>
<p>Boolean (default = FALSE).
If TRUE then the last night of the measurement are ignored for the sleep 
assessment in <a href="#topic+g.part4">g.part4</a>.</p>
</dd>
<dt>includenightcrit</dt><dd>
<p>Numeric (default = 16).
Minimum number of valid hours per night (24 hour window between noon and noon),
used for sleep assessment in <a href="#topic+g.part4">g.part4</a>.</p>
</dd>
<dt>minimum_MM_length.part5</dt><dd>
<p>Numeric (default = 23).
Minimum length in hours of a MM day to be included in the cleaned <a href="#topic+g.part5">g.part5</a> results.</p>
</dd>
<dt>study_dates_file</dt><dd>
<p>Character (default = c()).
Full path to csv file containing the first and last date of the expected 
wear period for every study participant (dates are provided per individual).
Expected format of the activity diary is: First column headers followed 
by one row per recording. There should be three columns: first column is 
recording ID, which needs to match with the ID GGIR extracts from the 
accelerometer file; second column should contain the first date of the 
study; and third column the last date of the study. Date columns should be
by default in format &quot;23-04-2017&quot;, or in the date format  specified by 
argument <code>study_dates_dateformat</code> (below). If not specified (default), 
then GGIR would use the first and last day of the recording as beginning 
and end of the study. Note that these dates are used on top of the 
<code>data_masking_strategy</code> selected.</p>
</dd>
<dt>study_dates_dateformat</dt><dd>
<p>Character (default = &quot;
To specify the date format used in the <code>study_dates_file</code> as used 
by <a href="base.html#topic+strptime">strptime</a>.</p>
</dd>
<dt>strategy</dt><dd>
<p>Deprecated and replaced by <code>data_masking_strategy</code>. If <code>strategy</code> 
is specified then its value is passed on and used for <code>data_masking_strategy</code>.</p>
</dd>
<dt>data_masking_strategy</dt><dd>
<p>Numeric (default = 1).
How to deal with knowledge about study protocol.
data_masking_strategy = 1 means select data based on <code>hrs.del.start</code> and <code>hrs.del.end</code>.
data_masking_strategy = 2 makes that only the data between the first
midnight and the last midnight is used.
data_masking_strategy = 3 selects the most active X days in the file where X is
specified by argument <code>ndayswindow</code>, where the days are a series 
of 24-h blocks starting any time in the day (X hours at the beginning and end
of this period can be deleted with arguments <code>hrs.del.start</code> and <code>hrs.del.end</code>)
data_masking_strategy = 4 to only use the data after the first midnight.
data_masking_strategy = 5 is similar to <code>data_masking_strategy = 3</code>, but it selects X complete
calendar days where X is specified by argument <code>ndayswindow</code> 
(X hours at the beginning and end of this period can be deleted with 
arguments <code>hrs.del.start</code> and <code>hrs.del.end</code>).</p>
</dd>
<dt>hrs.del.start</dt><dd>
<p>Numeric (default = 0).
How many HOURS after start of experiment did wearing
of monitor start? Used in GGIR <a href="#topic+g.part2">g.part2</a> when <code>data_masking_strategy = 1</code>.</p>
</dd>
<dt>hrs.del.end</dt><dd>
<p>Numeric (default = 0).
How many HOURS before the end of the experiment did
wearing of monitor definitely end? Used in GGIR <a href="#topic+g.part2">g.part2</a> when <code>data_masking_strategy = 1</code>.</p>
</dd>
<dt>maxdur</dt><dd>
<p>Numeric (default = 0).
How many DAYS after start of experiment did experiment
definitely stop? (set to zero if unknown).</p>
</dd>
<dt>ndayswindow</dt><dd>
<p>Numeric (default = 7).
If <code>data_masking_strategy</code> is set to 3 or 5, then this is the size of 
the window as a
number of days. For data_masking_strategy 3 value can be fractional, e.g. 7.5,
while for data_masking_strategy 5 it needs to be an integer.</p>
</dd>
<dt>includedaycrit.part5</dt><dd>
<p>Numeric (default = 2/3).
Inclusion criteria used in part 5 for number of valid hours during the 
waking hours of a day,
when value is smaller than or equal to 1 used as fraction of waking hours, 
when value above 1 used as absolute number of valid hours required.
Do not confuse this argument with argument <code>includedaycrit</code> which is
only used in GGIR part 2 and applies to the entire day.</p>
</dd>
<dt>segmentWEARcrit.part5</dt><dd>
<p>Numeric (default = 0.5).
Fraction of <code>qwindow</code> segment expected to be valid in part 5, where 
0.3 indicates that at least 30 percent of the time should be valid.</p>
</dd>
<dt>segmentDAYSPTcrit.part5</dt><dd>
<p>Numeric vector or length 2 (default = c(0.9, 0)).
Inclusion criteria for the proportion of the segment that should be 
classified as day (awake) and spt (sleep period time) to be considered 
valid. If you are interested in comparing time spent in behaviour then it
is better to set one of the two numbers to 0, and the other defines the 
proportion of the segment that should be classified as day or spt, respectively.
The default setting would focus on waking hour
segments and includes all segments that overlap for at least 90 percent 
with waking hours. In order to shift focus to the SPT you could use
c(0, 0.9) which ensures that all segments that overlap for at least
90 percent with the SPT are included.
Setting both to zero would be problematic when comparing time spent in
behaviours between days or individuals: A complete segment
would be averaged with an incomplete segments (someone going to bed or waking up
in the middle of a segment) by which it is no longer clear whether the person
is less active or sleeps more during that segment. Similarly it is not
clear whether the person has more wakefulness during SPT for a segment or
woke up or went to bed during the segment.
</p>
</dd>
<dt>includedaycrit</dt><dd>
<p>Numeric (default = 16).
Minimum required number of valid hours in calendar day specific to analysis 
in part 2. If you specify two values as in c(16, 16) then the first value 
will be used in part 2 and the second value will be used in part 5 and 
applied as a criterion on the full part 5 window. Note that this is then 
applied in addition to parameter includedaycrit.part5 which only looks 
at valid data during waking hours.</p>
</dd>
<dt>max_calendar_days</dt><dd>
<p>Numeric (default = 0).
The maximum number of calendar days to include (set to zero if unknown).</p>
</dd>
<dt>nonWearEdgeCorrection</dt><dd>
<p>Boolean (default = TRUE).
If TRUE then the non-wear detection around the edges of the recording (first
and last 3 hours) are corrected following description in vanHees2013 as
has been the default since then. This functionality is advisable when working 
with sleep clinic or exercise lab data typically lasting less than a day.
</p>
</dd>
<dt>nonwear_approach</dt><dd>
<p>Character (default = &quot;2023&quot;).
Whether to use the traditional version of the non-wear detection algorithm 
(nonwear_approach = &quot;2013&quot;) or the new version (nonwear_approach = &quot;2023&quot;). 
The 2013 version would use the longsize window (windowsizes[3], one hour 
as default) to check the conditions for nonwear identification and would 
flag as nonwear the mediumsize window (windowsizes[2], 15 min as default) 
in the middle. The 2023 version differs in which it would flag as nonwear 
the full longsize window. For the 2013 method the longsize window is centered 
in the centre of the mediumsize window, while in the 2023 method the longsizewindow 
is aligned with its left edge to the left edge of the mediumsize window.
</p>
</dd>
</dl>




<h4>params_phyact</h4>

<p>A list of parameters releated to physical activity as used in GGIR <a href="#topic+g.part2">g.part2</a> and GGIR <a href="#topic+g.part5">g.part5</a>.
</p>

<dl>
<dt>mvpathreshold</dt><dd>
<p>Numeric (default = 100).
Acceleration threshold for MVPA estimation in GGIR <a href="#topic+g.part2">g.part2</a>.
This can be a single number or an vector of numbers,
e.g., <code>mvpathreshold = c(100, 120)</code>.
In the latter case the code will estimate MVPA separately for each threshold.
If this variable is left blank, e.g., <code>mvpathreshold = c()</code>, then
MVPA is not estimated.</p>
</dd>
<dt>mvpadur</dt><dd>
<p>Numeric (default = 10).
The bout duration(s) for which MVPA will be calculated. Only used in GGIR <a href="#topic+g.part2">g.part2</a>.</p>
</dd>
<dt>boutcriter</dt><dd>
<p>Numeric (default = 0.8).
A number between 0 and 1, it defines what fraction of a bout needs to be above the
mvpathreshold, only used in GGIR <a href="#topic+g.part2">g.part2</a>.</p>
</dd>
<dt>threshold.lig</dt><dd>
<p>Numeric (default = 40).
In <a href="#topic+g.part5">g.part5</a>: Threshold for light physical activity to
separate inactivity from light. Value can be one number or an vector of multiple
numbers, e.g., <code>threshold.lig =c(30,40)</code>. If multiple numbers are entered then
analysis will be repeated for each combination of threshold values. Threshold is
applied to the first metric in the milestone data, so if you have only specified
<code>do.enmo = TRUE</code> then it will be applied to ENMO.</p>
</dd>
<dt>threshold.mod</dt><dd>
<p>Numeric (default = 100).
In <a href="#topic+g.part5">g.part5</a>: Threshold for moderate physical activity
to separate light from moderate. Value can be one number or an vector of
multiple numbers, e.g., <code>threshold.mod = c(100, 120)</code>.
If multiple numbers are entered then analysis will be repeated for each
combination of threshold values. Threshold is applied to the first metric in the
milestone data, so if you have only specified <code>do.enmo = TRUE</code>
then it will be applied to ENMO.</p>
</dd>
<dt>threshold.vig</dt><dd>
<p>Numeric (default = 400).
In <a href="#topic+g.part5">g.part5</a>: Threshold for vigorous physical activity
to separate moderate from vigorous. Value can be one number or an vector of
multiple numbers, e.g., <code>threshold.vig =c(400,500)</code>. If multiple numbers are
entered then analysis will be repeated for each combination of threshold values.
Threshold is applied to the first metric in the milestone data, so if you
have only specified <code>do.enmo = TRUE</code> then it will be applied to ENMO.</p>
</dd>
<dt>boutdur.mvpa</dt><dd>
<p>Numeric (default = c(1, 5, 10)).
Duration(s) of MVPA bouts in minutes to be extracted.
It will start with the identification of the longest to the shortest duration.
In the default setting, it will start with the 10 minute bouts, followed by 5 minute
bouts in the rest of the data, and followed by 1 minute bouts in the rest of the data.</p>
</dd>
<dt>boutdur.in</dt><dd>
<p>Numeric (default = c(10, 20, 30)).
Duration(s) of inactivity bouts in minutes to be extracted.
Inactivity bouts are detected in the segments of the data which
were not labelled as sleep or MVPA bouts.
It will start with the identification of the longest to the shortest duration.
In the default setting, it will start with the identification of 30 minute bouts,
followed by 20 minute bouts in the rest of the data, and followed by 10 minute
bouts in the rest of the data. Note that we use the term inactivity instead
of sedentary behaviour for the lowest intensity level of behaviour. The reason
for this is that GGIR does not attempt to classifying the activity type
sitting at the moment, by which we feel that using the term sedentary
behaviour would fail to communicate that.
</p>
</dd>
<dt>boutdur.lig</dt><dd>
<p>Numeric (default = c(1, 5, 10)).
Duration(s) of light activity bouts in minutes
to be extracted. Light activity bouts are detected in the segments of the data
which were not labelled as sleep, MVPA, or inactivity bouts.
It will start with the identification of the longest to the shortest duration.
In the default setting, this will start with the identification of
10 minute bouts, followed by 5 minute bouts in the rest of the data, and followed
by 1 minute bouts in the rest of the data.</p>
</dd>
<dt>boutcriter.mvpa</dt><dd>
<p>Numeric (default = 0.8).
A number between 0 and 1, it defines what fraction of a bout needs to be above the <code>threshold.mod</code>.</p>
</dd>
<dt>boutcriter.in</dt><dd>
<p>Numeric (default = 0.9).
A number between 0 and 1, it defines what fraction of a bout needs to be below the <code>threshold.lig</code>.</p>
</dd>
<dt>boutcriter.lig</dt><dd>
<p>Numeric (default = 0.8).
A number between 0 and 1, it defines what fraction of a bout needs to be between
the <code>threshold.lig</code> and the <code>threshold.mod</code>.</p>
</dd>
<dt>frag.metrics</dt><dd>
<p>Character (default = NULL).
Fragmentation metric to extract. Can be &quot;mean&quot;, &quot;TP&quot;, &quot;Gini&quot;,
&quot;power&quot;, or &quot;CoV&quot;, &quot;NFragPM&quot;, or all the above metrics with &quot;all&quot;.
See package vignette for description of fragmentation metrics.</p>
</dd>
<dt>part6_threshold_combi</dt><dd>
<p>Character (default = &quot;40_100_120&quot;) to indicate the threshold combination derived in
part 5 to be used for part 6
</p>
</dd>
</dl>




<h4>params_sleep</h4>

<p>A list of parameters used to configure the sleep analysis as performend in
GGIR <a href="#topic+g.part3">g.part3</a> and <a href="#topic+g.part4">g.part4</a>.
</p>

<dl>
<dt>relyonguider</dt><dd>
<p>Boolean (default = FALSE).
Sustained inactivity bouts (sib) that overlap with the guider are 
labelled as sleep. If <code>relyonguider = FALSE</code> and the sib overlaps only
partially with the guider then it is the sib that defines the edge 
of the SPT window and not the guider.
If <code>relyonguider = TRUE</code> and the sib overlaps only partially with the 
guider then it is the guider that defines the edge of the SPT window 
and not the sib. If participants were instructed NOT to wear the 
accelerometer during waking hours and <code>ignorenonware=FALSE</code> then 
set to <code>relyonguider=TRUE</code>, in all other scenarios set to FALSE.</p>
</dd>
<dt>relyonsleeplog</dt><dd>
<p>Boolean (default = FALSE).
Do not use, now replaced by argument relyonguider.
Values provided to argument relyonsleeplog will be passed on to
argument relyonguider to not preserve functionality of old R scripts.</p>
</dd>
<dt>def.noc.sleep</dt><dd>
<p>Numeric (default = 1).
The time window during which sustained
inactivity will be assumed to represent sleep, e.g., <code>def.noc.sleep = c(21, 9)</code>.
This is only used if no sleep log entry is available. If
left blank <code>def.noc.sleep = c()</code> then the 12 hour window centred
at the least active 5 hours of the 24 hour period will be used
instead. Here, L5 is hardcoded and will not change by changing
argument winhr in function <a href="#topic+g.part2">g.part2</a>. If def.noc.sleep is filled
with a single integer, e.g., <code>def.noc.sleep=c(1)</code> then the window
will be detected with based on built in algorithms.
See argument <code>HASPT.algo</code> from <a href="#topic+HASPT">HASPT</a> for specifying which of the
algorithms to use.</p>
</dd>
<dt>sleepwindowType</dt><dd>
<p>Character (default = &quot;SPT&quot;).
To indicate type of information in the sleeplog, &quot;SPT&quot; for sleep period time.
Set to &quot;TimeInBed&quot; if sleep log recorded time in bed to enable calculation
of sleep latency and sleep efficiency.</p>
</dd>
<dt>nnights</dt><dd>
<p>Numeric (default = NULL).
This argument has been deprecated.</p>
</dd>
<dt>loglocation</dt><dd>
<p>Character (default = NULL).
Path to csv file with sleep log information.
See package vignette for how to format this file.</p>
</dd>
<dt>colid</dt><dd>
<p>Numeric (default = 1).
Column number in the sleep log spreadsheet in which the participant ID code is stored.</p>
</dd>
<dt>coln1</dt><dd>
<p>Numeric (default = 2).
Column number in the sleep log spreadsheet where the onset of the first night starts.</p>
</dd>
<dt>ignorenonwear</dt><dd>
<p>Boolean (default = TRUE).
If TRUE then ignore detected monitor non-wear periods to avoid
confusion between monitor non-wear time and sustained inactivity.</p>
</dd>
<dt>constrain2range</dt><dd>
<p>Deprecated, used to be a Boolean (default = TRUE)
Whether or not to constrain the range of
threshold used in the diary free sleep period time window detection.</p>
</dd>
<dt>HASPT.algo</dt><dd>
<p>Character (default = &quot;HDCZA&quot;).
To indicate what algorithm should be used for the sleep period time detection.
Default &quot;HDCZA&quot; is Heuristic algorithm looking at Distribution of Change in Z-Angle as
described in van Hees et al. 2018. Other options included:
&quot;HorAngle&quot;, which is based on HDCZA but replaces non-movement detection of
the HDCZA algorithm by looking for time segments where the angle of the
longitudinal sensor axis has an angle relative to the horizontal plane
between -45 and +45 degrees. And &quot;NotWorn&quot; which is also the same as HDCZA
but looks for time segments when a rolling average of acceleration
magnitude is below 5 per cent of its standard deviation, see 
Cookbook vignette in the Annexes of https://wadpac.github.io/GGIR/ 
for more detailed guidance on how to use &quot;NotWorn&quot;.</p>
</dd>
<dt>HDCZA_threshold</dt><dd>
<p>Numeric (default = c())
If <code>HASPT.algo</code> is set to &quot;HDCZA&quot; and HDCZA_threshold is NOT NULL,
(e.g., HDCZA_threshold = 0.2), then that value will be used as threshold
in the 6th step in the diagram of Figure 1 in van Hees
et al. 2018 Scientific Report (doi: 10.1038/s41598-018-31266-z). However,
doing so has not been supported by research yet and is only intended to
facilitate methodological research, so we advise sticking with the default in
line with the publication. Further, if HDCZA_threshold is set to a numeric vector of
length 2, e.g. c(10, 15), that will be used as percentile and 
multiplier for the above mentioned 6th step.
</p>
</dd>
<dt>HASPT.ignore.invalid</dt><dd>
<p>Boolean (default = FALSE).
To indicate whether invalid time segments should be ignored in the
Sleep Period Time detection. If <code>FALSE</code> (default), the imputed 
angle or activity metric during the invalid time segments is used 
in the Sleep Period Time detection. If <code>TRUE</code>, invalid time 
segments are ignored for the Sleep Period Time detection 
(i.e., considered to be out of the Sleep Period Time). 
If <code>NA</code>, then invalid time segments are considered to be no movement
segments.
</p>
</dd>
<dt>HASIB.algo</dt><dd>
<p>Character (default = &quot;vanHees2015&quot;).
To indicate which algorithm should be used to define the
sustained inactivity bouts (i.e., likely sleep).
Options: &quot;vanHees2015&quot;, &quot;Sadeh1994&quot;, &quot;Galland2012&quot;.</p>
</dd>
<dt>Sadeh_axis</dt><dd>
<p>Character (default = &quot;Y&quot;).
To indicate which axis to use for the Sadeh1994 algorithm, and  other algortihms
that relied on count-based Actigraphy such as Galland2012.</p>
</dd>
<dt>sleeplogsep</dt><dd>
<p>Character (default = NULL).
This argument is deprecated.</p>
</dd>
<dt>nap_model</dt><dd>
<p>Character (default = NULL).
To specify classification model. Currently the only option is &quot;hip3yr&quot;, which
corresponds to a model trained with hip data in 3-3.5 olds trained with parent diary data.</p>
</dd>
<dt>longitudinal_axis</dt><dd>
<p>Integer (default = NULL).
To indicate which axis is the longitudinal axis.
If not provided, the function will estimate longitudinal axis as the axis
with the highest 24 hour lagged autocorrelation. Only used when
<code>sensor.location = "hip"</code> or <code>HASPT.algo = "HorAngle"</code>.</p>
</dd>
<dt>anglethreshold</dt><dd>
<p>Numeric (default = 5).
Angle threshold (degrees) for sustained inactivity periods detection.
The algorithm will look for periods of time (<code>timethreshold</code>)
in which the angle variability is lower than <code>anglethreshold</code>.
This can be specified as multiple thresholds, each of which will be implemented, e.g.,
<code>anglethreshold = c(5,10)</code>.</p>
</dd>
<dt>timethreshold</dt><dd>
<p>Numeric (default = 5).
Time threshold (minutes) for sustained inactivity periods detection.
The algorithm will look for periods of time (<code>timethreshold</code>)
in which the angle variability is lower than <code>anglethreshold</code>.
This can be specified as multiple thresholds, each of which will be implemented, e.g.,
<code>timethreshold = c(5,10)</code>.</p>
</dd>
<dt>possible_nap_window</dt><dd>
<p>Numeric (default = c(9, 18)).
Numeric vector of length two with range in clock hours during which naps are
assumed to take place, e.g., <code>possible_nap_window = c(9, 18)</code>. Currently
used in the context of an explorative nap classification algortihm that
was trained in 3.5 year olds. </p>
</dd>
<dt>possible_nap_dur</dt><dd>
<p>Numeric (default = c(15, 240)).
Numeric vector of length two with range in duration (minutes) of a nap,
e.g., <code>possible_nap_dur = c(15, 240)</code>. Currently
used in the context of an explorative nap classification algortihm that
was trained in 3.5 year olds.</p>
</dd>
<dt>sleepefficiency.metric</dt><dd>
<p>Numeric (default = 1).
If 1 (default), sleep efficiency is calculated as detected sleep time during
the SPT window divided by log-derived time in bed. If 2, sleep efficiency is
calculated as detected sleep time during the SPT window divided by detected
duration in sleep period time plus sleep latency (where sleep latency refers
to the difference between time in bed and sleep onset). sleepefficiency.metric is only considered
when argument <code>sleepwindowType = "TimeInBed"</code></p>
</dd>
<dt>possible_nap_edge_acc</dt><dd>
<p>Numeric (default = Inf).
Maximum acceleration before or after the SIB for the nap to be considered.
By default this will allow all possible naps.
</p>
</dd>
</dl>




<h4>params_247</h4>

<p>A list of parameters releated to description of 24/7 behaviours that do not fall
under conventional physical activity or sleep outcomes, these parameters are used
in GGIR <a href="#topic+g.part2">g.part2</a> and GGIR <a href="#topic+g.part5">g.part5</a>:
</p>

<dl>
<dt>qwindow</dt><dd>
<p>Numeric or character (default = c(0, 24)).
To specify windows over which all variables are calculated, e.g., acceleration 
distribution, number of valid hours, LXMX analysis, MVPA.
If numeric, qwindow should have length two, e.g., <code>qwindow = c(0, 24)</code>,
all variables will only be calculated over the full 24 hours in a day. If
<code>qwindow = c(8, 24)</code> variables will be calculated over the window 0-8, 8-24 and 0-24.
All days in the recording will be segmented based on these values.
If you want to use a day specific segmentation in each day then you can set 
qwindow to be the full path to activity diary file (character). Expected 
format of the activity diary is: First column headers followed by one row 
per recording, first column is recording ID, which needs to match with the 
ID GGIR extracts from the accelerometer file. Followed by date column in 
format &quot;23-04-2017&quot;, where date format is specified by argument 
<code>qwindow_dateformat</code> (below). Use the character combination date, 
Date or DATE in the column name. This is followed by one or multiple columns 
with start times for the activity types in that day format in hours:minutes:seconds. 
The header of the column will be used as label for each activity type. 
Insert a new date column before continuing with activity types for next day. 
Leave missing values empty. If an activity log is used then individuals who 
do not appear in the activity log will still be processed with value 
<code>qwindow = c(0, 24)</code>. Dates with no activity log data can be skipped,
no need to have a column with the date followed by a column with the next 
date. If times in the activity diary are not multiple of the short window 
size (epoch length), the next epoch is considered (e.g., with epoch of 5 
seconds, 8:00:02 will be redefined as 8:00:05 in the activity log).
When using the qwindow functionality in combination with GGIR part 5 then
make sure to check that arguments <code>segmentWEARcrit.part5</code> and 
<code>segmentDAYSPTcrit.part5</code> are specified to your research needs.
</p>
</dd>
<dt>qwindow_dateformat</dt><dd>
<p>Character (default = &quot;
To specify the date format used in the activity log as used by <a href="base.html#topic+strptime">strptime</a>.</p>
</dd>
<dt>M5L5res</dt><dd>
<p>Numeric (default = 10).
Resolution of L5 and M5 analysis in minutes.</p>
</dd>
<dt>winhr</dt><dd>
<p>Numeric (default = 5).
Vector of window size(s) (unit: hours) of LX and MX analysis,
where look for least and most active consecutive number of X hours.</p>
</dd>
<dt>qlevels</dt><dd>
<p>Numeric (default = NULL).
Vector of percentiles for which value needs to be extracted. These need to 
be expressed as a fraction of 1, e.g., c(0.1, 0.5, 0.75). There is no limit 
to the number of percentiles. If left empty then percentiles will not be extracted. 
Distribution will be derived from short epoch metric data. Argument qlevels 
can for example be used for the MX-metrics (e.g. Rowlands et al) as discussed in the
<a href="https://cran.r-project.org/package=GGIR/vignettes/GGIR.html">main package vignette</a></p>
</dd>
<dt>ilevels</dt><dd>
<p>Numeric (default = NULL).
Levels for acceleration value frequency distribution in m<em>g</em>, e.g., 
<code>ilevels = c(0,100,200)</code>. There is no limit to the number of levels. 
If left empty then the intensity levels will not be extracted. Distribution 
will be derived from short epoch metric data.</p>
</dd>
<dt>iglevels</dt><dd>
<p>Numeric (default = NULL).
Levels for acceleration value frequency distribution
in m<em>g</em> used for intensity gradient calculation (according to the method by
Rowlands 2018). By default this is argument is empty and the intensity gradient
calculation is not done. The user can either provide a single value (any) to
make the intensity gradient use the bins <code>iglevels = c(seq(0,4000,by=25), 8000)</code>
or the user could specify their own distribution. There is no constriction to the
number of levels.</p>
</dd>
<dt>IVIS_windowsize_minutes</dt><dd>
<p>Numeric (default = 60).
Window size of the Intradaily Variability (IV) and Interdaily
Stability (IS) metrics in minutes, needs to be able to add up to 24 hours.</p>
</dd>
<dt>IVIS_epochsize_seconds</dt><dd>
<p>Numeric (default = NULL).
This argument is deprecated.</p>
</dd>
<dt>IVIS.activity.metric</dt><dd>
<p>Numeric (default = 2).
Metric used for activity calculation.
Value = 1, uses continuous scaled acceleration.
Value = 2, tries to collapse acceleration into a binary score of rest
versus active to try to simulate the original approach.</p>
</dd>
<dt>IVIS_acc_threshold</dt><dd>
<p>Numeric (default = 20).
Acceleration threshold to distinguish inactive from active.</p>
</dd>
<dt>qM5L5</dt><dd>
<p>Numeric (default = NULL).
Percentiles (quantiles) to be calculated over L5 and M5 window.</p>
</dd>
<dt>MX.ig.min.dur</dt><dd>
<p>Numeric (default = 10).
Minimum MX duration needed in order for intensity gradient to be calculated.</p>
</dd>
<dt>LUXthresholds</dt><dd>
<p>Numeric (default = c(0, 100, 500, 1000, 3000, 5000, 10000)).
Vector with numeric sequence corresponding to
the thresholds used to calculate time spent in LUX ranges.</p>
</dd>
<dt>LUX_cal_constant</dt><dd>
<p>Numeric (default = NULL).
If both LUX_cal_constant and LUX_cal_exponent are
provided LUX values are converted based on formula y = constant * exp(x * exponent)</p>
</dd>
<dt>LUX_cal_exponent</dt><dd>
<p>Numeric (default = NULL).
If both LUX_cal_constant and LUX_cal_exponent are provided LUX
LUX values are converted based on formula y = constant * exp(x * exponent)</p>
</dd>
<dt>LUX_day_segments</dt><dd>
<p>Numeric (default = NULL).
Vector with hours at which the day should be segmented for
the LUX analysis.</p>
</dd>
<dt>L5M5window</dt><dd>
<p>Argument deprecated after version 1.5-24.
This argument used to define the start and end time, in 24 hour clock hours,
over which L5M5 needs to be calculated. Now this is done with argument qwindow.</p>
</dd>
<dt>cosinor</dt><dd>
<p>Boolean (default = FALSE). Whether to apply the cosinor analysis from the ActCR package.</p>
</dd>
<dt>part6CR</dt><dd>
<p>Boolean (default = FALSE) to indicate whether circadian rhythm analysis should be run by part 6.
</p>
</dd>
<dt>part6HCA</dt><dd>
<p>Boolean (default = FALSE) to indicate whether Household Co Analysis should 
be run by part 6.
</p>
</dd>
<dt>part6Window</dt><dd>
<p>Character vector with length two (default = c(&quot;start&quot;, &quot;end&quot;)) to indicate
the start and the end of the time series to be used for circadian rhythm analysis
in part 6. In other words, this parameters is not used for Household co-analysis.
Alternative values are: &quot;Wx&quot;, &quot;Ox&quot;, &quot;Hx&quot;, where &quot;x&quot; is a number to indicat
the xth wakeup, onset or hour of the recording. Negative values for &quot;x&quot;
are also possible and will count relative to the end of the recording. For example,
c(&quot;W1&quot;, &quot;W-1&quot;) goes from the first till the last wakeup, c(&quot;H5&quot;, &quot;H-5&quot;) 
ignores the first and last 5 hours, and c(&quot;O2&quot;, &quot;W10&quot;) goes from the second
onset till the 10th wakeup time.
</p>
</dd>
</dl>




<h4>params_output</h4>

<p>A list of parameters used to specify whether and how GGIR stores its output at various stages of the
process.
</p>

<dl>
<dt>storefolderstructure</dt><dd>
<p>Boolean (default = FALSE).
Store folder structure of the accelerometer data.</p>
</dd>
<dt>do.part2.pdf</dt><dd>
<p>Boolean (default = TRUE).
In <a href="#topic+g.part2">g.part2</a>: Whether to generate a pdf for <a href="#topic+g.part2">g.part2</a>.</p>
</dd>
<dt>do.part3.pdf</dt><dd>
<p>Boolean (default = TRUE).
In <a href="#topic+g.part3">g.part3</a>: Whether to generate a pdf for <a href="#topic+g.part3">g.part3</a>.</p>
</dd>
<dt>timewindow</dt><dd>
<p>Character (default = c(&quot;MM&quot;, &quot;WW&quot;)).
In <a href="#topic+g.part5">g.part5</a>: Timewindow over which summary statistics are derived.
Value can be &quot;MM&quot; (midnight to midnight), &quot;WW&quot; (waking time to waking time),
&quot;OO&quot; (sleep onset to sleep onset), or any combination of them.</p>
</dd>
<dt>save_ms5rawlevels</dt><dd>
<p>Boolean (default = FALSE).
In <a href="#topic+g.part5">g.part5</a>: Whether to save the time series classification (levels)
as csv or RData files (as defined by <code>save_ms5raw_format</code>). Note that 
time stamps will be stored in the column <code>timenum</code> in UTC format (i.e., 
seconds from 1970-01-01). To convert timenum to time stamp format, you 
need to specify your desired time zone, e.g., 
<code>as.POSIXct(mdat$timenum, tz = "Europe/London")</code>.</p>
</dd>
<dt>save_ms5raw_format</dt><dd>
<p>Character (default = &quot;csv&quot;).
In <a href="#topic+g.part5">g.part5</a>: To specify how data should be stored: either &quot;csv&quot; or 
&quot;RData&quot;. Only used if <code>save_ms5rawlevels = TRUE</code>.</p>
</dd>
<dt>save_ms5raw_without_invalid</dt><dd>
<p>Boolean (default = TRUE).
In <a href="#topic+g.part5">g.part5</a>: To indicate whether to remove invalid days from the 
time series output files. Only used if <code>save_ms5rawlevels = TRUE</code>.</p>
</dd>
<dt>epochvalues2csv</dt><dd>
<p>Boolean (default = FALSE).
In <a href="#topic+g.part2">g.part2</a>: If TRUE then epoch values are exported to a csv file.
Here, non-wear time is imputed where possible.</p>
</dd>
<dt>do.sibreport</dt><dd>
<p>Boolean (default = FALSE).
In <a href="#topic+g.part4">g.part4</a>: To indicate whether to generate report for the sustained 
inactivity bouts (SIB). If set to TRUE and when an advanced sleep diary is
available in part 4 then part 5 will use this to generate summary statistics
on the overlap between self-reported nonwear and napping with SIB. Here,
SIB can be filter based on argument possible_nap_edge_acc and the first value
of possible_nap_dur</p>
</dd>
<dt>do.visual</dt><dd>
<p>Boolean (default = TRUE).
In <a href="#topic+g.part4">g.part4</a>: If TRUE, the function will generate a pdf with a visual
representation of the overlap between the sleeplog entries and the accelerometer
detections. This can be used to visually verify that the sleeplog entries do
not come with obvious mistakes.</p>
</dd>
<dt>outliers.only</dt><dd>
<p>Boolean (default = FALSE).
In <a href="#topic+g.part4">g.part4</a>: Only used if <code>do.visual = TRUE</code>. If FALSE,
all available nights are included in the visual representation of the data and sleeplog.
If TRUE, then only nights with a difference in onset or waking time
larger than the variable of argument <code>criterror</code> will be included.</p>
</dd>
<dt>criterror</dt><dd>
<p>Numeric (default = 3).
In <a href="#topic+g.part4">g.part4</a>: Only used if <code>do.visual = TRUE</code> and <code>outliers.only = TRUE</code>.
criterror specifies the number of minimum number of hours difference
between sleep log and  accelerometer estimate for the night to be
included in the visualisation.</p>
</dd>
<dt>visualreport</dt><dd>
<p>Boolean (default = TRUE).
If TRUE, then generate visual report based on combined output
from <a href="#topic+g.part2">g.part2</a> and <a href="#topic+g.part4">g.part4</a>. Please note that the visual report
was initially developed to provide something to show to study participants
and not for data quality checking purposes. Over time we have improved
the visual report to also be useful for QC-ing the data. However, some of
the scorings as shown in the visual report are created for the visual report
only and may not reflect the scorings in the main GGIR analyses as reported in the
quantitative csv-reports. Most of our effort in the past 10 years has gone
into making sure that the csv-report are correct, while the visualreport has
mostly been a side project. This is unfortunate and we hope to find funding
in the future to design a new report specifically for the purpose of
QC-ing the analyses done by GGIR.</p>
</dd>
<dt>viewingwindow</dt><dd>
<p>Numeric (default = 1).
Centre the day as displayed around noon (<code>viewingwindow = 1</code>) or around 
midnight (<code>viewingwindow = 2</code>) in the visual report generated with 
<code>visualreport = TRUE</code>.</p>
</dd>
<dt>week_weekend_aggregate.part5</dt><dd>
<p>Boolean (default = FALSE).
In <a href="#topic+g.part5">g.part5</a>: To indicate whether week and weekend-days aggregates
should be stored. This is turned off by default as it generates a
large number of extra columns in the output report.</p>
</dd>
<dt>dofirstpage</dt><dd>
<p>Boolean (default = TRUE).
To indicate whether a first page with histograms summarizing the whole
measurement should be added in the file summary reports generated with <code>visualreport = TRUE</code>.</p>
</dd>
<dt>sep_reports</dt><dd>
<p>Character (default = &quot;,&quot;).
Value used as sep argument in <a href="data.table.html#topic+fwrite">fwrite</a> for writing csv reports.</p>
</dd>
<dt>dec_reports</dt><dd>
<p>Character (default = &quot;.&quot;).
Value used as dec argument in <a href="data.table.html#topic+fwrite">fwrite</a> for writing csv reports.</p>
</dd>
<dt>sep_config</dt><dd>
<p>Character (default = &quot;,&quot;).
Value used as sep argument in <a href="data.table.html#topic+fwrite">fwrite</a> for writing csv config file.</p>
</dd>
<dt>dec_config</dt><dd>
<p>Character (default = &quot;.&quot;).
Value used as dec argument in <a href="data.table.html#topic+fwrite">fwrite</a> for writing csv config file.</p>
</dd>
<dt>visualreport_without_invalid</dt><dd>
<p>Boolean (default = TRUE).
If TRUE, then reports generated with <code>visualreport = TRUE</code> only show
the windows with sufficiently valid data according to <code>includedaycrit</code>
when viewingwindow = 1 or <code>includenightcrit</code> when viewingwindow = 2</p>
</dd>
</dl>




<h3>Value</h3>

<p>The function provides no values, it only ensures that other functions are called
and that their output is stored. Further, a configuration file is stored containing
all the argument values used to facilitate reproducibility.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> van Hees VT, Gorzelniak L, Dean Leon EC, Eder M, Pias M, et al. (2013) Separating
Movement and Gravity Components in an Acceleration Signal and Implications for the
Assessment of Human Daily Physical Activity. PLoS ONE 8(4): e61691.
doi:10.1371/journal.pone.0061691
</p>
</li>
<li><p> van Hees VT, Fang Z, Langford J, Assah F, Mohammad A, da Silva IC, Trenell MI,
White T, Wareham NJ, Brage S. Auto-calibration of accelerometer data for
free-living physical activity assessment using local gravity and temperature:
an evaluation on four continents. J Appl Physiol (1985). 2014 Aug 7
</p>
</li>
<li><p> van Hees VT, Sabia S, et al. (2015) A novel, open access method to
assess sleep duration using a wrist-worn accelerometer, PLoS ONE, November 2015
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  mode = c(1,2,3,4,5)
  datadir = "C:/myfolder/mydata"
  outputdir = "C:/myresults"
  studyname ="test"
  f0 = 1
  f1 = 2
  GGIR(#-------------------------------
       # General parameters
       #-------------------------------
       mode = mode,
       datadir = datadir,
       outputdir = outputdir,
       studyname = studyname,
       f0 = f0,
       f1 = f1,
       overwrite = FALSE,
       do.imp = TRUE,
       idloc = 1,
       print.filename = FALSE,
       storefolderstructure = FALSE,
       #-------------------------------
       # Part 1 parameters:
       #-------------------------------
       windowsizes = c(5,900,3600),
       do.cal = TRUE,
       do.enmo = TRUE,
       do.anglez = TRUE,
       chunksize = 1,
       printsummary = TRUE,
       #-------------------------------
       # Part 2 parameters:
       #-------------------------------
       data_masking_strategy = 1,
       ndayswindow = 7,
       hrs.del.start = 1,
       hrs.del.end = 1,
       maxdur = 9,
       includedaycrit = 16,
       L5M5window = c(0,24),
       M5L5res = 10,
       winhr = c(5,10),
       qlevels = c(c(1380/1440),c(1410/1440)),
       qwindow = c(0,24),
       ilevels = c(seq(0,400,by=50),8000),
       mvpathreshold = c(100,120),
       #-------------------------------
       # Part 3 parameters:
       #-------------------------------
       timethreshold = c(5,10),
       anglethreshold = 5,
       ignorenonwear = TRUE,
       #-------------------------------
       # Part 4 parameters:
       #-------------------------------
       excludefirstlast = FALSE,
       includenightcrit = 16,
       def.noc.sleep = 1,
       loglocation = "D:/sleeplog.csv",
       outliers.only = FALSE,
       criterror = 4,
       relyonguider = FALSE,
       colid = 1,
       coln1 = 2,
       do.visual = TRUE,
       #-------------------------------
       # Part 5 parameters:
       #-------------------------------
       # Key functions: Merging physical activity with sleep analyses
       threshold.lig = c(30,40,50),
       threshold.mod = c(100,120),
       threshold.vig = c(400,500),
       excludefirstlast = FALSE,
       boutcriter = 0.8,
       boutcriter.in = 0.9,
       boutcriter.lig = 0.8,
       boutcriter.mvpa = 0.8,
       boutdur.in = c(10,20,30),
       boutdur.lig = c(1,5,10),
       boutdur.mvpa = c(1,5,10),
       timewindow = c("WW"),
       #-----------------------------------
       # Report generation
       #-------------------------------
       do.report = c(2,4,5))

       # For externally derived Actiwatch data in .AWD format:
       GGIR(datadir = "/media/actiwatch_awd", # folder with epoch level .AWD file
          outputdir = "/media/myoutput",
          dataFormat = "actiwatch_awd",
          extEpochData_timeformat = "%m/%d/%Y %H:%M:%S",
          mode = 1:5,
          do.report = c(2, 4, 5),
          windowsizes = c(60, 900, 3600), # 60 is the expected epoch length
          visualreport = FALSE,
          outliers.only = FALSE,
          overwrite = TRUE,
          HASIB.algo = "Sadeh1994",
          def.noc.sleep = c()) # &lt;= because we cannot use HDCZA for ZCY

       # For externally derived Actiwatch data in .CSV format:
       GGIR(datadir = "/media/actiwatch_csv", # folder with epoch level .AWD file
          outputdir = "/media/myoutput",
          dataFormat = "actiwatch_csv",
          extEpochData_timeformat = "%m/%d/%Y %H:%M:%S",
          mode = 1:5,
          do.report = c(2, 4, 5),
          windowsizes = c(15, 900, 3600), # 15 is the expected epoch length
          visualreport = FALSE,
          outliers.only = FALSE,
          HASIB.algo = "Sadeh1994",
          def.noc.sleep = c()) # &lt;= because we cannot use HDCZA for ZCY

       # For externally derived UK Biobank data in .CSV format:
       GGIR(datadir = "/media/ukbiobank",
           outputdir = "/media/myoutput",
           dataFormat = "ukbiobank_csv",
           extEpochData_timeformat = "%m/%d/%Y %H:%M:%S",
           mode = c(1:2),
           do.report = c(2),
           windowsizes = c(5, 900, 3600), # We know that data was stored in 5 second epoch
           desiredtz = "Europe/London", # We know that data was collected in the UK
           visualreport = FALSE,
           overwrite = TRUE)
        
       # For externally derived ActiGraph count data in .CSV format assuming
       # a study protocol where sensor was not worn during the night:
       GGIR(datadir = "/examplefiles",
           outputdir = "",
           dataFormat = "actigraph_csv",
           mode = 1:5,
           do.report = c(2, 4, 5),
           windowsizes = c(5, 900, 3600),
           threshold.in = round(100 * (5/60), digits = 2),
           threshold.mod = round(2500 * (5/60), digits = 2),
           threshold.vig = round(10000 * (5/60), digits = 2),
           extEpochData_timeformat = "%m/%d/%Y %H:%M:%S",
           do.neishabouricounts = TRUE,
           acc.metric = "NeishabouriCount_x",
           HASPT.algo = "NotWorn",
           HASIB.algo = "NotWorn",
           do.visual = TRUE,
           includedaycrit = 10,
           includenightcrit = 10,
           visualreport = FALSE,
           outliers.only = FALSE,
           save_ms5rawlevels = TRUE,
           ignorenonwear = FALSE,
           HASPT.ignore.invalid = FALSE,
           save_ms5raw_without_invalid = FALSE)
           
           
       # For externally derived Sensear data in .xls format:  
        GGIR(datadir = "C:/yoursenseweardatafolder",
            outputdir = "D:/youroutputfolder",
            mode = 1:5,
            windowsizes = c(60, 900, 3600),
            threshold.in = 1.5,
            threshold.mod = 3,
            threshold.vig = 6,
            dataFormat = "sensewear_xls",
            extEpochData_timeformat = "%d-%b-%Y %H:%M:%S",
            HASPT.algo = "NotWorn",
            desiredtz = "America/New_York",
            overwrite = TRUE,
            do.report = c(2, 4, 5),
            visualreport = FALSE)
           
  
## End(Not run)
</code></pre>

<hr>
<h2 id='HASIB'>
Heuristic algorithms for sustiained inactivty bouts detection
</h2><span id='topic+HASIB'></span>

<h3>Description</h3>

<p>Apply heuristic algorithms for sustiained inactivty bouts detection.
Function not intended for direct use by package user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  HASIB(HASIB.algo = "vanHees2015", timethreshold = c(), anglethreshold = c(), 
                 time = c(), anglez = c(), ws3 = c(), zeroCrossingCount = c(),
                 BrondCount = c(),
                 NeishabouriCount = c(), activity = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HASIB_+3A_hasib.algo">HASIB.algo</code></td>
<td>

<p>Character to indicator which sib algorithm should be used.
Default value: &quot;vanHees2015&quot;. Other options: &quot;Sadeh1994&quot;, &quot;Galland2012&quot;, &quot;ColeKripke1992&quot;
</p>
</td></tr>
<tr><td><code id="HASIB_+3A_anglethreshold">anglethreshold</code></td>
<td>

<p>See <a href="#topic+g.sib.det">g.sib.det</a>
</p>
</td></tr>
<tr><td><code id="HASIB_+3A_timethreshold">timethreshold</code></td>
<td>

<p>See <a href="#topic+g.sib.det">g.sib.det</a>
</p>
</td></tr>
<tr><td><code id="HASIB_+3A_time">time</code></td>
<td>

<p>Vector with time per short epoch
</p>
</td></tr>
<tr><td><code id="HASIB_+3A_anglez">anglez</code></td>
<td>

<p>Vector with z-angle per short epoch
</p>
</td></tr>
<tr><td><code id="HASIB_+3A_ws3">ws3</code></td>
<td>

<p>See <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
<tr><td><code id="HASIB_+3A_zerocrossingcount">zeroCrossingCount</code></td>
<td>

<p>Vector with zero crossing counts per epoch as required for count-based algorithms
</p>
</td></tr>
<tr><td><code id="HASIB_+3A_brondcount">BrondCount</code></td>
<td>

<p>Vector with Brond counts per epoch to be used by the count-based algorithms
</p>
</td></tr>
<tr><td><code id="HASIB_+3A_neishabouricount">NeishabouriCount</code></td>
<td>

<p>Vector with Neishabouri counts per epoch to be used by the count-based algorithms
</p>
</td></tr>
<tr><td><code id="HASIB_+3A_activity">activity</code></td>
<td>

<p>Magnitude of acceleration, only used when HASIB.algo is set to NotWorn.
Acceleration metric used is specified by argument <code>acc.metric</code> 
elsewhere in GGIR.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with binary indicator of sustained inactivity bout, 1 is yes, 0 is no.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='HASPT'>
Heuristic Algorithms estimating SPT window.
</h2><span id='topic+HASPT'></span>

<h3>Description</h3>

<p>As used in function <a href="#topic+g.sib.det">g.sib.det</a>. Function is not intended for direct use
by GGIR user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HASPT(angle, sptblocksize = 30, spt_max_gap = 60, ws3 = 5, 
      HASPT.algo="HDCZA", HDCZA_threshold = c(), invalid, 
      HASPT.ignore.invalid = FALSE, activity = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HASPT_+3A_angle">angle</code></td>
<td>

<p>Vector of epoch level estimates of angle
</p>
</td></tr>
<tr><td><code id="HASPT_+3A_sptblocksize">sptblocksize</code></td>
<td>

<p>Number to indicate minimum SPT block size (minutes)
</p>
</td></tr>
<tr><td><code id="HASPT_+3A_spt_max_gap">spt_max_gap</code></td>
<td>

<p>Number to indicate maximum gap (minutes) in SPT window blocks.
</p>
</td></tr>
<tr><td><code id="HASPT_+3A_ws3">ws3</code></td>
<td>

<p>Number representing epoch length in seconds
</p>
</td></tr>
<tr><td><code id="HASPT_+3A_haspt.algo">HASPT.algo</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="HASPT_+3A_hdcza_threshold">HDCZA_threshold</code></td>
<td>

<p>See <a href="#topic+GGIR">GGIR</a>
</p>
</td></tr>
<tr><td><code id="HASPT_+3A_invalid">invalid</code></td>
<td>

<p>Integer vector with per epoch an indicator of valid(=0) or invalid(=1) epoch.
</p>
</td></tr>
<tr><td><code id="HASPT_+3A_haspt.ignore.invalid">HASPT.ignore.invalid</code></td>
<td>

<p>Boolean to indicate whether invalid time segments should be ignored
</p>
</td></tr>
<tr><td><code id="HASPT_+3A_activity">activity</code></td>
<td>

<p>Magnitude of acceleration, only used when HASPT.algo is set to NotWorn.
Acceleration metric used is specified by argument <code>acc.metric</code> 
elsewhere in GGIR.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with start and end times of the SPT window and the threshold as used.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='identify_levels'>
Identifies levels of behaviour for g.part5 function.
</h2><span id='topic+identify_levels'></span>

<h3>Description</h3>

<p>Identifies levels of behaviour from acceleratioon
and sustained inactivity sibdetection (using angles). Function not
intended for direct use by package user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  identify_levels(ts, TRLi,TRMi,TRVi,
                  ws3, params_phyact, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_levels_+3A_ts">ts</code></td>
<td>

<p>Data.frame with time series genrated in .gpart5
</p>
</td></tr>
<tr><td><code id="identify_levels_+3A_trli">TRLi</code></td>
<td>

<p>Numeric acceleration threshold light
</p>
</td></tr>
<tr><td><code id="identify_levels_+3A_trmi">TRMi</code></td>
<td>

<p>Numeric acceleration threshold moderate
</p>
</td></tr>
<tr><td><code id="identify_levels_+3A_trvi">TRVi</code></td>
<td>

<p>Numeric acceleration threshold vigorous
</p>
</td></tr>
<tr><td><code id="identify_levels_+3A_ws3">ws3</code></td>
<td>

<p>Numeric size of epoch in seconds
</p>
</td></tr>
<tr><td><code id="identify_levels_+3A_params_phyact">params_phyact</code></td>
<td>

<p>See <a href="#topic+g.part2">g.part2</a>
</p>
</td></tr>
<tr><td><code id="identify_levels_+3A_...">...</code></td>
<td>

<p>Any argument used in the previous version of identify_level, which will now
be used to overrule the arguments specified with the parameter objects.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with items:
</p>

<ul>
<li><p> LEVELS
</p>
</li>
<li><p> OLEVELS
</p>
</li>
<li><p> Lnames
</p>
</li>
<li><p> bc.mvpa
</p>
</li>
<li><p> bc.lig
</p>
</li>
<li><p> bc.in
</p>
</li>
<li><p> ts
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    levels = identify_levels(TRLi,TRMi,TRVi,
                               boutdur.mvpa,boutcriter.mvpa,
                               boutdur.lig,boutcriter.lig,
                               boutdur.in,boutcriter.in,
                               ws3,bout.metric)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='is_this_a_dst_night'>
Check whether the night starting on a calendar date has DST.
</h2><span id='topic+is_this_a_dst_night'></span>

<h3>Description</h3>

<p>Tests whether the night that follows the input calendar date is a
night with day saving time (DST) and on what hour the time moved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is_this_a_dst_night(calendar_date=c(),tz="Europe/London")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_this_a_dst_night_+3A_calendar_date">calendar_date</code></td>
<td>

<p>Character in the format dd/mm/yyyy 
</p>
</td></tr>
<tr><td><code id="is_this_a_dst_night_+3A_tz">tz</code></td>
<td>

<p>Time zone in &quot;Europe/London&quot; format.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>dst_night_or_not</code></td>
<td>
<p>If value=0 no DST, if value=1 time moved forward,
if value=-1 time moved forward</p>
</td></tr>
<tr><td><code>dsthour</code></td>
<td>
<p>Either the double hour or the hour that was skipped, 
this differs between countries</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  test4dst = is_this_a_dst_night("23/03/2014",tz="Europe/London")
</code></pre>

<hr>
<h2 id='is.ISO8601'>
Check whether character timestamp is in iso8601 format.
</h2><span id='topic+is.ISO8601'></span>

<h3>Description</h3>

<p>Checks whether timestamp stored in character format is in ISO8601 format or not</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ISO8601(x)	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.ISO8601_+3A_x">x</code></td>
<td>

<p>Timestamps in character format either in ISO8601 or as &quot;yyyy-mm-dd hh:mm:ss&quot;.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x ="1980-1-1 18:00:00"
is.ISO8601(x)
</code></pre>

<hr>
<h2 id='isfilelist'>
Checks whether datadir is a directory or a vector with
filenames
</h2><span id='topic+isfilelist'></span>

<h3>Description</h3>

<p>Checks whether argument datadir used in various other functions in 
GGIR is the name of a directory that includes data files or whether
it is a vector with the full paths to one or more data files</p>


<h3>Usage</h3>

<pre><code class='language-R'>isfilelist(datadir)	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isfilelist_+3A_datadir">datadir</code></td>
<td>

<p>Argument datadir as used in various other functions in GGIR
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean whether it is a list of files (TRUE) or not (FALSE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
isitafilelist = isfilelist(datadir)

## End(Not run)
</code></pre>

<hr>
<h2 id='ismovisens'>
Checks whether the files to process are collected with movisens accelerometers.
</h2><span id='topic+ismovisens'></span>

<h3>Description</h3>

<p>Checks whether the files in the datadir folder are files collected
with movisens accelerometers. Note that movisens data are stored in one folder per recording that includes multiple bin-files
(instead of one file per recording as usual in other accelerometer brands). Therefore, datadir indicates
the directory where all the recording folders are stored, then, GGIR reads the pertinent bin files from
every folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ismovisens(data)	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ismovisens_+3A_data">data</code></td>
<td>

<p>Full path to the recording folder (with the bin files inside) or the 
datadir (where all the recording folders are stored).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean whether it is a movisens file (TRUE) or not (FALSE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    is.mv = ismovisens(data)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='iso8601chartime2POSIX'>
Convert iso8601 timestamps to POSIX timestamp
</h2><span id='topic+iso8601chartime2POSIX'></span>

<h3>Description</h3>

<p>To avoid ambiguities when sharing and comparing timestamps. All timestamps
are expressed in iso8601 format: https://en.wikipedia.org/wiki/ISO_8601
However, to generate plots in R we need to convert them back to POSIX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso8601chartime2POSIX(x,tz)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iso8601chartime2POSIX_+3A_x">x</code></td>
<td>

<p>Vector of timestamps in iso8601 in character format
</p>
</td></tr>
<tr><td><code id="iso8601chartime2POSIX_+3A_tz">tz</code></td>
<td>

<p>Timezone of data collection, e.g. &quot;Europe/London&quot;. 
See List_of_tz_database_time_zones on Wikipedia
for full list.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x ="2017-05-07T13:00:00+0200"
tz = "Europe/Amsterdam"
x_converted = iso8601chartime2POSIX(x,tz)
</code></pre>

<hr>
<h2 id='load_params'>
Load default parameters
</h2><span id='topic+load_params'></span>

<h3>Description</h3>

<p>Loads default paramter values
Not intended for direct use by GGIR users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  load_params(topic = c("sleep", "metrics", "rawdata", "247",
                        "phyact", "cleaning", "output", "general"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_params_+3A_topic">topic</code></td>
<td>

<p>Character vector with parameter groups to be loaded.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lists of parameter objects 
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>

<hr>
<h2 id='parametersVignette'>
Builds Section for Parameters Vignette
</h2><span id='topic+parametersVignette'></span>

<h3>Description</h3>

<p>Function extracts the documentation for a given GGIR argument as provided in the <a href="#topic+GGIR">GGIR</a> documentation
and builds the structure for the Parameters Vignette.
Function not designed for direct use by package user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  parametersVignette(params = "sleep")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parametersVignette_+3A_params">params</code></td>
<td>

<p>Character (default = &quot;sleep&quot;). 
Name of the parameters object to build its corresponding section in the Parameters vignette.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Structure for the vignette subsection.
</p>


<h3>Author(s)</h3>

<p>Jairo Hidalgo Migueles &lt;jairo.hidalgo.migueles@gmail.com&gt;
</p>

<hr>
<h2 id='part6AlignIndividuals'>part6AlignIndividuals</h2><span id='topic+part6AlignIndividuals'></span>

<h3>Description</h3>

<p>Align individual time series per household where households are identified
by the character or number string between the first and second '-' in the filename.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  part6AlignIndividuals(GGIR_ts_dir = NULL, outputdir = NULL,
                      path_ggirms = NULL, desiredtz = "", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="part6AlignIndividuals_+3A_ggir_ts_dir">GGIR_ts_dir</code></td>
<td>

<p>Character, path to time series directory in the GGIR output
</p>
</td></tr>
<tr><td><code id="part6AlignIndividuals_+3A_outputdir">outputdir</code></td>
<td>

<p>Directory where you would like to store the output
</p>
</td></tr>
<tr><td><code id="part6AlignIndividuals_+3A_path_ggirms">path_ggirms</code></td>
<td>

<p>path to GGIR created folder named meta, with the milestone data files
</p>
</td></tr>
<tr><td><code id="part6AlignIndividuals_+3A_desiredtz">desiredtz</code></td>
<td>

<p>Character, specifying the timezone database name of the timezone the 
data was collected in.
</p>
</td></tr>
<tr><td><code id="part6AlignIndividuals_+3A_verbose">verbose</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no object is returned, only files are created in the output directory
</p>

<hr>
<h2 id='part6PairwiseAggregation'>part6PairwiseAggregation</h2><span id='topic+part6PairwiseAggregation'></span>

<h3>Description</h3>

<p>Pairwise aggregation of the time series of a group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  part6PairwiseAggregation(outputdir = NULL, desiredtz = "", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="part6PairwiseAggregation_+3A_outputdir">outputdir</code></td>
<td>
<p>Directory where you would like to store your results</p>
</td></tr>
<tr><td><code id="part6PairwiseAggregation_+3A_desiredtz">desiredtz</code></td>
<td>
<p>Character, specifying the timezone database name 
of the timezone the data was collected in</p>
</td></tr>
<tr><td><code id="part6PairwiseAggregation_+3A_verbose">verbose</code></td>
<td>

<p>See details in <a href="#topic+GGIR">GGIR</a>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No object is returned, only files are created in the output directory
</p>

<hr>
<h2 id='POSIXtime2iso8601'>
Convert POSIX to iso8601 timestamp
</h2><span id='topic+POSIXtime2iso8601'></span>

<h3>Description</h3>

<p>To avoid ambiguities when sharing and comparing timestamps. All timestamps
are expressed in iso8601 format: https://en.wikipedia.org/wiki/ISO_8601
</p>


<h3>Usage</h3>

<pre><code class='language-R'>POSIXtime2iso8601(x,tz)	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="POSIXtime2iso8601_+3A_x">x</code></td>
<td>

<p>Vector of timestamps in POSIX format
</p>
</td></tr>
<tr><td><code id="POSIXtime2iso8601_+3A_tz">tz</code></td>
<td>

<p>Timezone of data collection, e.g. &quot;Europe/London&quot;.
See
https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
for full list
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x ="2017-05-07 13:15:17 CEST"
tz = "Europe/Amsterdam"
x_converted = POSIXtime2iso8601(x,tz)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.myacc.csv'>
Read custom csv files with accelerometer data
</h2><span id='topic+read.myacc.csv'></span>

<h3>Description</h3>

<p>Loads csv files with accelerometer data and standardises 
the output format (incl. unit of measurement, timestamp format,
header format, and column locations) to make the data compatible
with other GGIR functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  read.myacc.csv(rmc.file=c(), rmc.nrow=Inf, rmc.skip = c(), rmc.dec=".",
                          rmc.firstrow.acc = c(), rmc.firstrow.header=c(),
                          rmc.header.length = c(),
                          rmc.col.acc = 1:3, rmc.col.temp = c(), 
                          rmc.col.time=c(),
                          rmc.unit.acc = "g", rmc.unit.temp = "C", 
                          rmc.unit.time = "POSIX",
                          rmc.format.time = "%Y-%m-%d %H:%M:%OS",
                          rmc.bitrate = c(), rmc.dynamic_range = c(), 
                          rmc.unsignedbit = TRUE,
                          rmc.origin = "1970-01-01",
                          rmc.desiredtz = NULL,
                          rmc.configtz = NULL,
                          rmc.sf = c(),
                          rmc.headername.sf = c(),
                          rmc.headername.sn = c(),
                          rmc.headername.recordingid = c(),
                          rmc.header.structure = c(),
                          rmc.check4timegaps = FALSE,
                          rmc.col.wear = c(),
                          rmc.doresample = FALSE,
                          rmc.scalefactor.acc = 1,
                          interpolationType=1, 
                          PreviousLastValue = c(0, 0, 1),
                          PreviousLastTime = NULL,
                          desiredtz = NULL,
                          configtz = NULL,
                          header = NULL)	
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.myacc.csv_+3A_rmc.file">rmc.file</code></td>
<td>

<p>Filename of file to be read if it is in the working directory, or full path to the file otherwise.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.nrow">rmc.nrow</code></td>
<td>

<p>Number of rows to read, same as nrow argument in <a href="utils.html#topic+read.csv">read.csv</a> and nrows in <a href="data.table.html#topic+fread">fread</a>. The whole file is read by default (i.e., rmc.nrow = Inf).
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.skip">rmc.skip</code></td>
<td>

<p>Number of rows to skip, same as skip argument in <a href="utils.html#topic+read.csv">read.csv</a> and in <a href="data.table.html#topic+fread">fread</a>.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.dec">rmc.dec</code></td>
<td>

<p>Decimal used for numbers, same as skip argument in <a href="utils.html#topic+read.csv">read.csv</a> and in <a href="data.table.html#topic+fread">fread</a>.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.firstrow.acc">rmc.firstrow.acc</code></td>
<td>

<p>First row (number) of the acceleration data.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.firstrow.header">rmc.firstrow.header</code></td>
<td>

<p>First row (number) of the header. Leave blank if the file does not have
a header.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.header.length">rmc.header.length</code></td>
<td>

<p>If file has header, specify header length (numeric).
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.col.acc">rmc.col.acc</code></td>
<td>

<p>Vector with three column (numbers) in which the acceleration signals
are stored
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.col.temp">rmc.col.temp</code></td>
<td>

<p>Scalar with column (number) in which the temperature is stored.
Leave in default setting if no temperature is avaible. The temperature
will be used by <a href="#topic+g.calibrate">g.calibrate</a>.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.col.time">rmc.col.time</code></td>
<td>

<p>Scalar with column (number) in which the timestamps are stored.
Leave in default setting if timestamps are not stored. 
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.unit.acc">rmc.unit.acc</code></td>
<td>

<p>Character with unit of acceleration values: &quot;g&quot;, &quot;mg&quot;, or &quot;bit&quot;
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.unit.temp">rmc.unit.temp</code></td>
<td>

<p>Character with unit of temperature values: (K)elvin, (C)elsius, or (F)ahrenheit
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.unit.time">rmc.unit.time</code></td>
<td>

<p>Character with unit of timestamps: &quot;POSIX&quot;,
&quot;UNIXsec&quot; (seconds since origin, see argument rmc.origin), &quot;character&quot;, or
&quot;ActivPAL&quot; (exotic timestamp format only used in the ActivPAL
activity monitor).
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.format.time">rmc.format.time</code></td>
<td>

<p>Character string giving a date-time format as used by <a href="base.html#topic+strptime">strptime</a>. Only used for rmc.unit.time: character and POSIX.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.bitrate">rmc.bitrate</code></td>
<td>

<p>Numeric: If unit of acceleration is a bit then provide bit rate, e.g. 12 bit.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.dynamic_range">rmc.dynamic_range</code></td>
<td>

<p>Numeric, if unit of acceleration is a bit then provide dynamic range deviation
in g from zero, e.g. +/-6g would mean this argument needs to be 6. If you give this
argument a character value the code will search the file header for elements with
a name equal to the character value and use the corresponding numeric value
next to it as dynamic range.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.unsignedbit">rmc.unsignedbit</code></td>
<td>

<p>Boolean, if unsignedbit = TRUE means that bits are only positive numbers.
if unsignedbit = FALSE then bits are both positive and negative.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.origin">rmc.origin</code></td>
<td>

<p>Origin of time when unit of time is UNIXsec, e.g. 1970-1-1
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.desiredtz">rmc.desiredtz</code></td>
<td>

<p>Deprecated, please see <code>desiredtz</code>.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.configtz">rmc.configtz</code></td>
<td>

<p>Deprecated, please see <code>configtz</code>.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.sf">rmc.sf</code></td>
<td>

<p>Sample rate in Hertz, if this is stored in the file header then that will be used
instead.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.headername.sf">rmc.headername.sf</code></td>
<td>

<p>If file has a header: Row name (character) under which the sample
frequency can be found.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.headername.sn">rmc.headername.sn</code></td>
<td>

<p>If file has a header: Row name (character) under which the
serial number can be found.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.headername.recordingid">rmc.headername.recordingid</code></td>
<td>

<p>If file has a header: Row name (character) under which the
recording ID can be found.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.header.structure">rmc.header.structure</code></td>
<td>

<p>Character used to split the header name from the header
value, e.g. &quot;:&quot; or &quot; &quot;
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.check4timegaps">rmc.check4timegaps</code></td>
<td>

<p>Boolean to indicate whether gaps in time should be imputed with zeros.
Some sensing equipment provides accelerometer with gaps in time. The rest of 
GGIR is not designed for this, by setting this argument to TRUE the the gaps
in time will be filled with zeros.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.col.wear">rmc.col.wear</code></td>
<td>

<p>If external wear detection outcome is stored as part of the data then this can be used by GGIR.
This argument specifies the column in which the wear detection (Boolean) is stored.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.doresample">rmc.doresample</code></td>
<td>

<p>Boolean to indicate whether to resample the data based on the available timestamps and extracted 
sample rate from the file header
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_rmc.scalefactor.acc">rmc.scalefactor.acc</code></td>
<td>

<p>Numeric value (default 1) to scale the acceleration signals via multiplication.
For example, if data is provided in m/s2 then by setting this to 1/9.81
we would derive gravitational units.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_interpolationtype">interpolationType</code></td>
<td>

<p>Integer to indicate type of interpolation to be used when resampling time series (mainly relevant for Axivity sensors), 1=linear, 2=nearest neighbour.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_previouslastvalue">PreviousLastValue</code></td>
<td>

<p>Automatically identified last value in previous chunk of data read.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_previouslasttime">PreviousLastTime</code></td>
<td>

<p>Automatically identified last timestamp in previous chunk of data read.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_desiredtz">desiredtz</code></td>
<td>

<p>Timezone in which device was worn.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_configtz">configtz</code></td>
<td>

<p>Timezone in which device was configured. If equal to desiredtz you can leave
this in its default value.
</p>
</td></tr>
<tr><td><code id="read.myacc.csv_+3A_header">header</code></td>
<td>

<p>Header information that was extracted the previous time this file was read,
to be re-used instead of being extracted again.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To use this function in the context of GGIR use all arguments from this function,
except rmc.file, rmc.nrow, and  rmc.skip as input for function <a href="#topic+GGIR">GGIR</a> or <a href="#topic+g.part1">g.part1</a> and also specify argument rmc.noise, which is not part of this function but needed to tell GGIR what noise level to expect in the data. The rmc.noise is taken from the params_rawdata object if not explicitly specified by user.
</p>


<h3>Value</h3>

<p>List with objects data holding the time series of acceleration, and
header if it was available in the orignal file.
</p>


<h3>Author(s)</h3>

<p>Vincent T van Hees &lt;v.vanhees@accelting.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # create test files: No header, with temperature, with time
  N = 30
  sf = 30
  x = Sys.time()+((0:(N-1))/sf)
  timestamps = as.POSIXlt(x, origin="1970-1-1", tz = "Europe/London")
  mydata = data.frame(x = rnorm(N), time = timestamps, y = rnorm(N), z = rnorm(N),
            temp = rnorm(N) + 20)
  testfile = "testcsv1.csv"
  write.csv(mydata, file= testfile, row.names = FALSE)
  loadedData = read.myacc.csv(rmc.file=testfile, rmc.nrow=20, rmc.dec=".",
                      rmc.firstrow.acc = 1, rmc.firstrow.header=c(),
                      desiredtz = "",
                      rmc.col.acc = c(1,3,4), rmc.col.temp = 5, rmc.col.time=2,
                      rmc.unit.acc = "g", rmc.unit.temp = "C", rmc.origin = "1970-01-01")
  if (file.exists(testfile)) file.remove(testfile)
  
</code></pre>

<hr>
<h2 id='ShellDoc2Vignette'>
Extract Definition from Shell Documentation
</h2><span id='topic+ShellDoc2Vignette'></span>

<h3>Description</h3>

<p>Function extracts the documentation for a given GGIR argument as provided in the <a href="#topic+GGIR">GGIR</a> documentation.
Function not designed for direct use by package user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ShellDoc2Vignette(argument = "mode")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShellDoc2Vignette_+3A_argument">argument</code></td>
<td>

<p>Character (default = &quot;mode&quot;). 
Name of the argument to extract the definition.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character object with the definition of the argument.
</p>


<h3>Author(s)</h3>

<p>Jairo Hidalgo Migueles &lt;jairo.hidalgo.migueles@gmail.com&gt;
</p>

<hr>
<h2 id='tidyup_df'>
Round numeric columns and replace NA/NaN values by blank
</h2><span id='topic+tidyup_df'></span>

<h3>Description</h3>

<p>Identifies columns that can be coerced to numeric in a data frame, 
transforms these columns to numeric and round them to the specified digits. 
It also replaces NA and NaNs values by blank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tidyup_df(df = c(), digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyup_df_+3A_df">df</code></td>
<td>

<p>Data frame
</p>
</td></tr>
<tr><td><code id="tidyup_df_+3A_digits">digits</code></td>
<td>

<p>Integer indicating the number of decimal places (round) or significant digits (signif) to be used
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with all possible columns as numeric and rounded to the specified number of digits
</p>


<h3>Author(s)</h3>

<p>Jairo H Migueles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Test data frame
  df = data.frame(a = c("a", "b"), b = as.character(c(1.543218, 8.216856483)))
  tidyup_df(df = df, digits = 3)
</code></pre>

<hr>
<h2 id='updateBlocksize'>
Update blocksize of data to be read depending on available memory.
</h2><span id='topic+updateBlocksize'></span>

<h3>Description</h3>

<p>Function queries available memory to either lower or increase the blocksize
used by function <a href="#topic+g.readaccfile">g.readaccfile</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateBlocksize(blocksize, bsc_qc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateBlocksize_+3A_blocksize">blocksize</code></td>
<td>

<p>Number of filepages (binary data) or rows (other dataformats).
</p>
</td></tr>
<tr><td><code id="updateBlocksize_+3A_bsc_qc">bsc_qc</code></td>
<td>

<p>Data.frame with columns time (timestamp from Sys.time) and size (memory size).
This is used for housekeeping in <a href="#topic+g.calibrate">g.calibrate</a> and <a href="#topic+g.getmeta">g.getmeta</a>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with blocksize and bsc_qc, same format as input, although bsc_qc has one new
row.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
