<!DOCTYPE html><html><head><title>Help for package profExtrema</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {profExtrema}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#approxMaxMin'><p>Approximate coordinate profile functions</p></a></li>
<li><a href='#approxProfileExtrema'><p>Approximate profile extrema functions</p></a></li>
<li><a href='#bound_profiles'><p>Bound for profile extrema quantiles</p></a></li>
<li><a href='#cleanProfileResults'><p>Clean a profile extrema object</p></a></li>
<li><a href='#coastal_flooding'><p>Coastal flooding as function of offshore forcing conditions.</p></a></li>
<li><a href='#coordinateProfiles'><p>Coordinate profiles starting from a kriging model</p></a></li>
<li><a href='#coordProf_UQ'><p>Coordinate profiles UQ from a kriging model</p></a></li>
<li><a href='#getAllMaxMin'><p>Coordinate profile extrema with BFGS optimization</p></a></li>
<li><a href='#getChangePoints'><p>Coordinate profiles crossing points</p></a></li>
<li><a href='#getClosePoints'><p>Find close points</p></a></li>
<li><a href='#getMax'><p>Coordinate profile sup function</p></a></li>
<li><a href='#getMaxMinMC'><p>Coordinate profile extrema with MC</p></a></li>
<li><a href='#getMin'><p>Coordinate profile inf function</p></a></li>
<li><a href='#getPointProportion'><p>Obtain proportion of true observations in excursion set</p></a></li>
<li><a href='#getProfileExtrema'><p>Profile extrema with BFGS optimization</p></a></li>
<li><a href='#getProfileInf_optim'><p>Generic profile inf function computation with optim</p></a></li>
<li><a href='#getProfileSup_optim'><p>Generic profile sup function computation with optim</p></a></li>
<li><a href='#getSegments'><p>getSegments</p></a></li>
<li><a href='#grad_mean_Delta_T'><p>Gradient of the mean function of difference process</p></a></li>
<li><a href='#grad_var_Delta_T'><p>Gradient of the variance function of difference process</p></a></li>
<li><a href='#gradKm_dnewdata'><p>Gradient of posterior mean and variance</p></a></li>
<li><a href='#kGradSmooth'><p>First order approximation</p></a></li>
<li><a href='#mean_Delta_T'><p>mean function of difference process</p></a></li>
<li><a href='#obliqueProf_UQ'><p>Oblique profiles UQ from a kriging model</p></a></li>
<li><a href='#obliqueProfiles'><p>Oblique coordinate profiles starting from a kriging model</p></a></li>
<li><a href='#plot_univariate_profiles_UQ'><p>Univariate profile extrema with UQ</p></a></li>
<li><a href='#plotBivariateProfiles'><p>Plot bivariate profiles</p></a></li>
<li><a href='#plotMaxMin'><p>Plot coordinate profiles</p></a></li>
<li><a href='#plotOblique'><p>plotOblique</p></a></li>
<li><a href='#plotOneBivProfile'><p>Plot bivariate profiles</p></a></li>
<li><a href='#prof_mean_var_Delta'><p>Profile extrema for the mean and variance functions of difference process</p></a></li>
<li><a href='#profExtrema'><p>profExtrema package</p></a></li>
<li><a href='#setPlotOptions'><p>Set-up the plot options when NULL</p></a></li>
<li><a href='#var_Delta_T'><p>Variance function of difference process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Compute and Visualize Profile Extrema Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dario Azzimonti &lt;dario.azzimonti@gmail.com&gt;</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes profile extrema functions for arbitrary functions. If the function is expensive-to-evaluate it computes profile extrema by emulating the function with a Gaussian process (using package 'DiceKriging'). In this case uncertainty quantification on the profile extrema can also be computed. The different plotting functions for profile extrema give the user a tool to better locate excursion sets. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), DiceKriging, KrigInv, pGPx</td>
</tr>
<tr>
<td>Imports:</td>
<td>microbenchmark, quantreg, lhs, splines, methods, RColorBrewer,
utils, MASS, rcdd</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-20 16:51:36 UTC; dario</td>
</tr>
<tr>
<td>Author:</td>
<td>Dario Azzimonti <a href="https://orcid.org/0000-0001-5080-3061"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-21 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='approxMaxMin'>Approximate coordinate profile functions</h2><span id='topic+approxMaxMin'></span>

<h3>Description</h3>

<p>Evaluate profile extrema over other variables with approximations at few values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxMaxMin(f, fprime = NULL, d, opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approxMaxMin_+3A_f">f</code></td>
<td>
<p>the function to be evaluated</p>
</td></tr>
<tr><td><code id="approxMaxMin_+3A_fprime">fprime</code></td>
<td>
<p>derivative of the function</p>
</td></tr>
<tr><td><code id="approxMaxMin_+3A_d">d</code></td>
<td>
<p>dimension of the input domain</p>
</td></tr>
<tr><td><code id="approxMaxMin_+3A_opts">opts</code></td>
<td>
<p>a list containing the options for this function and the subfunctions getMax, getMin or getMaxMinMC, see documentation of getMax, getMin, getMaxMinMC for details. The options only for approxMaxMin are
</p>

<ul>
<li><p><code>limits:</code>an optional list with the upper and lower limits of each dimension, if NULL then for each dimension limits are 0,1
</p>
</li>
<li><p><code>smoother:</code>Select which smoother to use:a string that selects which smoother to use: </p>

<ul>
<li><p><code>"1order"</code>: first order interpolation with gradient
</p>
</li>
<li><p><code>"splineSmooth"</code>: smoothing spline with default degrees of freedom (DEFAULT OPTION)
</p>
</li>
<li><p><code>"quantSpline"</code>: profile inf and profile sup approximated with quantile spline regression at levels 0.1 and 0.9 respectively
</p>
</li></ul>

</li>
<li><p><code>heavyReturn:</code>If TRUE returns also all minimizers, default is FALSE.
</p>
</li>
<li><p><code>initDesign:</code>The design of few points where the expensive sup is evaluated.
</p>
</li>
<li><p><code>fullDesignSize:</code>The full design where the function is approximated.
</p>
</li>
<li><p><code>multistart:</code>number of multistarts for optim procedure.
</p>
</li>
<li><p><code>MonteCarlo:</code>if TRUE, computes sup with Monte Carlo procedure.
</p>
</li>
<li><p><code>numMCsamples:</code>number of MC samples for the sup.
</p>
</li>
<li><p><code>plts:</code>If TRUE, plots the max/min functions at each coordinate, default is FALSE.
</p>
</li>
<li><p><code>verb:</code>If TRUE, outputs intermediate results, default is FALSE.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two data frames (min, max) of the evaluations of <code class="reqn">f_sup(x_i) = sup_{x_j \neq i} f(x_1,\dots,x_d) </code> and <code class="reqn">f_inf(x_i) = inf_{x_j \neq i} f(x_1,\dots,x_d) </code>
for each i at the design Design. By default Design is a 100 equally spaced points for each dimension. It can be changed by defining it in options$Design
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
# Compute the coordinate profile extrema with full optimization on 2d example

# Define the function
g=function(x){
  return(-branin(x))
}
# Define the gradient
gprime = function(x){
  x1 = x[1]*15-5
  x2 = x[2]*15
  f1prime = (15*25)/(4*pi^4)*x1^3 - (15*75)/(2*pi^3)*x1^2 +
  (80*15)/(pi^2)*x1 - (5*15)/(pi^2)*x2*x1 +
  10*15/pi*x2 - 60*15/pi-10*15* (1 - 1/(8*pi))*sin(x1)
  f2prime = 2*15*(x2-5/(4*pi^2)*x1^2 +5/pi*x1-6)
  return(matrix(c(-f1prime,-f2prime),nrow=1))
}

# generic approximation options
init_des&lt;-lhs::maximinLHS(15,2)
options_approx&lt;- list(multistart=4,heavyReturn=TRUE,initDesign=init_des,fullDesignSize=100)

# 1order approximation
options_approx$smoother&lt;-"1order"
coordProf_approx_1order&lt;-approxMaxMin(f = g,fprime = gprime,d=2,opts = options_approx)

# quantile regression
options_approx$smoother&lt;-"quantSpline"
coordProf_approx_quantReg&lt;-approxMaxMin(f = g,fprime = gprime,d=2,opts = options_approx)



# Consider threshold=-10
threshold&lt;- -10
# obtain the points where the profiles take the threshold value
pp_change&lt;-getChangePoints(threshold = threshold,allRes = coordProf_approx_quantReg)
# evaluate g at a grid and plot the image
x&lt;-seq(0,1,,100)
grid&lt;-expand.grid(x,x)
g_evals&lt;- apply(X = grid,MARGIN = 1,FUN = g)
image(x = x,y = x,z = matrix(g_evals,nrow = 100),col = grey.colors(20))
contour(x=x,y=x,z=matrix(g_evals,nrow = 100), add=TRUE, nlevels = 20)
contour(x=x,y=x,z=matrix(g_evals,nrow = 100), add=TRUE, levels = threshold,col=2)
abline(h = pp_change$neverEx$`-10`[[2]],col="darkgreen",lwd=2)
abline(v = pp_change$neverEx$`-10`[[1]],col="darkgreen",lwd=2)
# Plot the coordinate profiles and a threshold
plotMaxMin(allRes = coordProf_approx_1order,threshold = threshold,changes = TRUE)
plotMaxMin(allRes = coordProf_approx_quantReg,threshold = threshold,changes = TRUE)

</code></pre>

<hr>
<h2 id='approxProfileExtrema'>Approximate profile extrema functions</h2><span id='topic+approxProfileExtrema'></span>

<h3>Description</h3>

<p>Evaluate profile extrema for a set of Psi with approximations at few values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxProfileExtrema(f, fprime = NULL, d, allPsi, opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approxProfileExtrema_+3A_f">f</code></td>
<td>
<p>the function to be evaluated</p>
</td></tr>
<tr><td><code id="approxProfileExtrema_+3A_fprime">fprime</code></td>
<td>
<p>derivative of the function</p>
</td></tr>
<tr><td><code id="approxProfileExtrema_+3A_d">d</code></td>
<td>
<p>dimension of the input domain</p>
</td></tr>
<tr><td><code id="approxProfileExtrema_+3A_allpsi">allPsi</code></td>
<td>
<p>a list containing the matrices Psi (dim <code class="reqn">pxd</code>) for which to compute the profile extrema</p>
</td></tr>
<tr><td><code id="approxProfileExtrema_+3A_opts">opts</code></td>
<td>
<p>a list containing the options for this function and the subfunctions <a href="#topic+getProfileSup_optim">getProfileSup_optim</a>, <a href="#topic+getProfileInf_optim">getProfileInf_optim</a> or <a href="#topic+getProfileExtrema">getProfileExtrema</a>. The options only for approxProfileExtrema are
</p>

<ul>
<li><p><code>limits:</code>an optional list with the upper and lower limits of input space dimension, if NULL then <code>limits=list(upper=rep(1,d),lower=rep(0,d))</code>
</p>
</li>
<li><p><code>smoother:</code>Select which smoother to use:a string that selects which smoother to use: </p>

<ul>
<li><p><code>"1order"</code>: first order interpolation with gradient
</p>
</li>
<li><p><code>"splineSmooth"</code>: smoothing spline with default degrees of freedom (DEFAULT OPTION)
</p>
</li>
<li><p><code>"quantSpline"</code>: profile inf and profile sup approximated with quantile spline regression at levels 0.1 and 0.9 respectively
</p>
</li></ul>

</li>
<li><p><code>heavyReturn:</code>If TRUE returns also all minimizers, default is FALSE.
</p>
</li>
<li><p><code>initDesign:</code>A list of the same length as allPsi containing the designs of few points where the expensive sup is evaluated. If Null it is automatically initialized
</p>
</li>
<li><p><code>fullDesignSize:</code>The full design where the function is approximated.
</p>
</li>
<li><p><code>multistart:</code>number of multistarts for optim procedure.
</p>
</li>
<li><p><code>numMCsamples:</code>number of MC samples for the sup.
</p>
</li>
<li><p><code>plts:</code>If TRUE, plots the max/min functions at each coordinate, default is FALSE.
</p>
</li>
<li><p><code>verb:</code>If TRUE, outputs intermediate results, default is FALSE.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two data frames (min, max) of the evaluations of <code class="reqn">f_sup(x_i) = sup_{x_j \neq i} f(x_1,\dots,x_d) </code> and <code class="reqn">f_inf(x_i) = inf_{x_j \neq i} f(x_1,\dots,x_d) </code>
for each i at the design Design. By default Design is a 100 equally spaced points for each dimension. It can be changed by defining it in options$Design
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the oblique profile extrema with approximate optimization on 2d example

# Define the function
testF &lt;- function(x,params,v1=c(1,0),v2=c(0,1)){
return(sin(crossprod(v1,x)*params[1]+params[2])+cos(crossprod(v2,x)*params[3]+params[4])-1.5)
}

testFprime &lt;- function(x,params,v1=c(1,0),v2=c(0,1)){
  return(matrix(c(params[1]*v1[1]*cos(crossprod(v1,x)*params[1]+params[2])-
                  params[3]*v2[1]*sin(crossprod(v2,x)*params[3]+params[4]),
                 params[1]*v1[2]*cos(crossprod(v1,x)*params[1]+params[2])-
                  params[3]*v2[2]*sin(crossprod(v2,x)*params[3]+params[4])),ncol=1))
}


# Define the main directions of the function
theta=pi/6
pparams&lt;-c(1,0,10,0)
vv1&lt;-c(cos(theta),sin(theta))
vv2&lt;-c(cos(theta+pi/2),sin(theta+pi/2))

# Define optimizer friendly function
f &lt;-function(x){
return(testF(x,pparams,vv1,vv2))
}
fprime &lt;- function(x){
 return(testFprime(x,pparams,vv1,vv2))
}

# Define list of directions where to evaluate the profile extrema
all_Psi &lt;- list(Psi1=vv1,Psi2=vv2)

# Evaluate profile extrema along directions of all_Psi
allOblique&lt;-approxProfileExtrema(f=f,fprime = fprime,d = 2,allPsi = all_Psi,
                                 opts = list(plts=FALSE,heavyReturn=TRUE))


# Consider threshold=0
threshold &lt;- 0

# Plot oblique profile extrema functions
plotMaxMin(allOblique,allOblique$Design,threshold = threshold)

## Since the example is two dimensional we can visualize the regions excluded by the profile extrema
# evaluate the function at a grid for plots
inDes&lt;-seq(0,1,,100)
inputs&lt;-expand.grid(inDes,inDes)
outs&lt;-apply(X = inputs,MARGIN = 1,function(x){return(testF(x,pparams,v1=vv1,v2=vv2))})

# obtain the points where the profiles take the threshold value
cccObl&lt;-getChangePoints(threshold = threshold,allRes = allOblique,Design = allOblique$Design)

# visualize the functions and the regions excluded

image(inDes,inDes,matrix(outs,ncol=100),col=grey.colors(20),main="Example and oblique profiles")
contour(inDes,inDes,matrix(outs,ncol=100),add=TRUE,nlevels = 20)
contour(inDes,inDes,matrix(outs,ncol=100),add=TRUE,levels = c(threshold),col=4,lwd=1.5)
plotOblique(cccObl$alwaysEx$`0`[[1]],all_Psi[[1]],col=3)
plotOblique(cccObl$alwaysEx$`0`[[2]],all_Psi[[2]],col=3)
plotOblique(cccObl$neverEx$`0`[[1]],all_Psi[[1]],col=2)
plotOblique(cccObl$neverEx$`0`[[2]],all_Psi[[2]],col=2)


</code></pre>

<hr>
<h2 id='bound_profiles'>Bound for profile extrema quantiles</h2><span id='topic+bound_profiles'></span>

<h3>Description</h3>

<p>The function bound_profiles computes the upper and lower bounds for the profile extrema quantiles of a Gaussian process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bound_profiles(objectUQ, mean_var_delta = NULL, beta = 0.0124,
  alpha = 0.025, allPsi = NULL, options_approx = NULL,
  options_full_sims = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bound_profiles_+3A_objectuq">objectUQ</code></td>
<td>
<p>an object returned by <a href="#topic+coordProf_UQ">coordProf_UQ</a> or the object saved in <code>obj$res_UQ</code>, if <code>obj</code> is the object returned by <a href="#topic+coordinateProfiles">coordinateProfiles</a></p>
</td></tr>
<tr><td><code id="bound_profiles_+3A_mean_var_delta">mean_var_delta</code></td>
<td>
<p>the profile extrema functions at <code>options_approx$design</code> for the mean and variance function of the difference process <code class="reqn">Z^\Delta = Z_x - \widetilde{Z}_x</code>. Object returned by <a href="#topic+prof_mean_var_Delta">prof_mean_var_Delta</a>.</p>
</td></tr>
<tr><td><code id="bound_profiles_+3A_beta">beta</code></td>
<td>
<p>the level of confidence for the approximate simulations</p>
</td></tr>
<tr><td><code id="bound_profiles_+3A_alpha">alpha</code></td>
<td>
<p>the level of confidence for the bound</p>
</td></tr>
<tr><td><code id="bound_profiles_+3A_allpsi">allPsi</code></td>
<td>
<p>optional list of matrices (dim <code class="reqn">pxd</code>) for which to compute the profile extrema. If NULL coordinate profiles are computed.</p>
</td></tr>
<tr><td><code id="bound_profiles_+3A_options_approx">options_approx</code></td>
<td>
<p>an optional list of options for <a href="#topic+approxMaxMin">approxMaxMin</a> (or <a href="#topic+approxProfileExtrema">approxProfileExtrema</a> if <code>allPsi</code> not NULL).</p>
</td></tr>
<tr><td><code id="bound_profiles_+3A_options_full_sims">options_full_sims</code></td>
<td>
<p>an optional list of options for <a href="#topic+getAllMaxMin">getAllMaxMin</a> (or <a href="#topic+getProfileExtrema">getProfileExtrema</a> if <code>allPsi</code> not NULL). If NULL the full computations are not excuted. NOTE: this computations might be very expensive!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing </p>

<ul>
<li><p><code>bound: </code>a list containing the upper/lower bound for profile sup and inf
</p>
</li>
<li><p><code>approx: </code>a list containing the upper/lower approximate quantiles for profile sup and inf
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='cleanProfileResults'>Clean a profile extrema object</h2><span id='topic+cleanProfileResults'></span>

<h3>Description</h3>

<p>The function cleanProfileResults cleans a profile extrema object to partially redo some computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanProfileResults(object, level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanProfileResults_+3A_object">object</code></td>
<td>
<p>a list containing profile extrema results.</p>
</td></tr>
<tr><td><code id="cleanProfileResults_+3A_level">level</code></td>
<td>
<p>an integer 1-4 denoting how much it should be removed from <code>object</code>. See Value for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns <code>object</code> with the deleted parts as selected by <code>level</code>. In particular </p>

<ul>
<li><p><code>1:</code>keep only <code>profMean_full</code>.
</p>
</li>
<li><p><code>2:</code>keep <code>profMean_full</code> and <code>profMean_approx</code>. Remove all UQ results.
</p>
</li>
<li><p><code>3:</code>keep <code>profMean_full</code> and <code>profMean_approx</code> and the pilot points. Remove all UQ simulations.
</p>
</li>
<li><p><code>4:</code>Remove only the bound computations.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
# Compute a kriging model from 50 evaluations of the Branin function
# Define the function
g=function(x){
  return(-branin(x))
}
gp_des&lt;-lhs::maximinLHS(20,2)
reals&lt;-apply(gp_des,1,g)
kmModel&lt;-km(design = gp_des,response = reals,covtype = "matern3_2")

threshold=-10

# Compute coordinate profiles on the posterior mean
# Increase multistart and size of designs for more precise results
options_full&lt;-list(multistart=2,heavyReturn=TRUE, Design = replicate(2,seq(0,1,,50)))
init_des&lt;-lhs::maximinLHS(12,2)
options_approx&lt;- list(multistart=2,heavyReturn=TRUE,initDesign=init_des,fullDesignSize=50)
cProfilesMean&lt;-coordinateProfiles(object=kmModel,threshold=threshold,options_full=options_full,
                                  options_approx=options_approx,uq_computations=FALSE,
                                  plot_level=3,plot_options=NULL,CI_const=NULL,return_level=2)

# If we want to run again the computation of approximate coordinate profiles
# we delete that result and run again the coordinate profiles function
cProfiles_full &lt;- cleanProfileResults(cProfilesMean,level=1)
## Not run: 
# Coordinate profiles with UQ with approximate profiles
plot_options&lt;-list(save=FALSE, titleProf = "Coordinate profiles",
                   title2d = "Posterior mean",qq_fill=TRUE)
cProfilesUQ&lt;-coordinateProfiles(object=cProfilesMean,threshold=threshold,options_full=options_full,
                                  options_approx=options_approx,uq_computations=TRUE,
                                  plot_level=3,plot_options=NULL,CI_const=NULL,return_level=2)
# If we would like to remove all UQ results
cProf_noUQ &lt;- cleanProfileResults(cProfilesUQ,level=2)

# If we would like to remove the simulations but keep the pilot points
cProf_noSims &lt;- cleanProfileResults(cProfilesUQ,level=3)
# the line above is useful, for example, if we need a more accurate UQ. In that case
# we obtain more simulations with the same pilot points and then combine the results.


## End(Not run)
</code></pre>

<hr>
<h2 id='coastal_flooding'>Coastal flooding as function of offshore forcing conditions.</h2><span id='topic+coastal_flooding'></span>

<h3>Description</h3>

<p>A dataset containing the results of a numerical simulation conducted with
the MARS model (Lazure and Dumas, 2008) for coastal flooding.
The numerical model was adapted to the Boucholeurs area (French Atlantic coast),
close to La Rochelle, and validated with data from the 2010 Xynthia storm event.
See Azzimonti et al. (2017+) and Rohmer et al. (2018) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coastal_flooding
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 6 variables:
</p>

<dl>
<dt>Tide</dt><dd><p>High tide level in meters;</p>
</dd>
<dt>Surge</dt><dd><p>Surge peak amplitude in meters;</p>
</dd>
<dt>phi</dt><dd><p>Phase difference between high tide and surge peak;</p>
</dd>
<dt>t-</dt><dd><p>Duration of the increasing part of the surge temporal signal (assumed to be triangular);</p>
</dd>
<dt>t+</dt><dd><p>Duration of the decreasing part of the surge temporal signal (assumed to be triangular);</p>
</dd>
<dt>Area</dt><dd><p>Flooded area in m^2.</p>
</dd>
</dl>


<h3>Details</h3>

<p>The data frame contains 5 input variables: <code>Tide</code>, <code>Surge</code>, <code>phi</code>, <code>t-</code>, <code>t+</code> detailing
the offshore forcing conditions for the model. All input variables are normalized
in <code class="reqn">[0,1]</code>. The response is <code>Area</code>, the area flooded in m^2.
</p>


<h3>References</h3>

<p>Azzimonti, D., Ginsbourger, D., Rohmer, J. and Idier, D. (2017+). <em>Profile extrema for visualizing and quantifying uncertainties on excursion regions. Application to coastal flooding.</em> arXiv:1710.00688.
</p>
<p>Rohmer, J., Idier, D., Paris, F., Pedreros, R., and Louisor, J. (2018). <em>Casting light on forcing and breaching scenarios that lead to marine inundation: Combining numerical simulations with a random-forest classification approach.</em> Environmental Modelling &amp; Software, 104:64-80.
</p>
<p>Lazure, P. and Dumas, F. (2008). <em>An external-internal mode coupling for a 3D hydrodynamical model for applications at regional scale (MARS)</em>. Advances in Water Resources, 31:233-250.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define inputs
inputs&lt;-data.frame(coastal_flooding[,-6])
colnames(inputs)&lt;-colnames(coastal_flooding[,-6])
colnames(inputs)[4:5]&lt;-c("tPlus","tMinus")

# put response in areaFlooded variable
areaFlooded&lt;-data.frame(coastal_flooding[,6])
colnames(areaFlooded)&lt;-colnames(coastal_flooding)[6]
response = sqrt(areaFlooded)


model &lt;- km(formula=~Tide+Surge+I(phi^2)+tMinus+tPlus,
            design = inputs,response = response,covtype="matern3_2")
# Fix threshold
threshold&lt;-sqrt(c(1.2e6,1.9e6,3.1e6,6.5e6))

# use the coordinateProfile function
## set up plot options
options_plots &lt;- list(save=FALSE, folderPlots = "./" ,
                      titleProf = "Coordinate profiles",
                      title2d = "Posterior mean",qq_fill=TRUE)
# set up full profiles options
options_full&lt;-list(multistart=15,heavyReturn=TRUE)
# set up approximation options
d &lt;- model@d
init_des&lt;-lhs::maximinLHS(5*d , d )
options_approx&lt;- list(multistart=2,heavyReturn=TRUE, initDesign=init_des,
                      fullDesignSize=100, smoother="quantSpline")

# run the coordinate profile extrema on the mean
CF_CoordProf_mean&lt;- coordinateProfiles(object = model, threshold = threshold,
                                       uq_computations = FALSE, options_approx = options_approx,
                                       plot_level=3, plot_options= options_plots, return_level=3,
                                       options_full=options_full)

## Not run: 
## UQ computations might require a long time
# set up simulation options
## reduce nsims and batchsize for faster/less accurate UQ
nsims=200
opts_sims&lt;-list(algorithm="B", lower=rep(0,d ),
                upper=rep(1,d ), batchsize=150,
                optimcontrol=list(method="genoud", pop.size=100,print.level=0),
                integcontrol = list(distrib="sobol",n.points=2000),nsim=nsims)

opts_sims$integration.param &lt;- integration_design(opts_sims$integcontrol,
                                                  d , opts_sims$lower,
                                                  opts_sims$upper,
                                                  model,threshold)
opts_sims$integration.param$alpha &lt;- 0.5

# run UQ computations
CF_CoordProf_UQ&lt;- coordinateProfiles(object = CF_CoordProf_mean, threshold = threshold,
                                     uq_computations = TRUE, options_approx = options_approx,
                                     plot_level=3, plot_options= options_plots, return_level=3,
                                     options_sims=opts_sims,options_full=options_full,
                                     options_bound = list(beta=0.024,alpha=0.05))

## End(Not run)

</code></pre>

<hr>
<h2 id='coordinateProfiles'>Coordinate profiles starting from a kriging model</h2><span id='topic+coordinateProfiles'></span>

<h3>Description</h3>

<p>The function coordinateProfiles computes the profile extrema functions for the posterior mean of a Gaussian process and its confidence bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordinateProfiles(object, threshold, options_full = NULL,
  options_approx = NULL, uq_computations = FALSE, plot_level = 0,
  plot_options = NULL, CI_const = NULL, return_level = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordinateProfiles_+3A_object">object</code></td>
<td>
<p>either a <a href="DiceKriging.html#topic+km">km</a> model or a list containing partial results. If <code>object</code> is a km model then all computations are carried out. If <code>object</code> is a list, then the function carries out all computations to complete the list results.</p>
</td></tr>
<tr><td><code id="coordinateProfiles_+3A_threshold">threshold</code></td>
<td>
<p>the threshold of interest</p>
</td></tr>
<tr><td><code id="coordinateProfiles_+3A_options_full">options_full</code></td>
<td>
<p>an optional list of options for getAllMaxMin, see <a href="#topic+getAllMaxMin">getAllMaxMin</a> for details.</p>
</td></tr>
<tr><td><code id="coordinateProfiles_+3A_options_approx">options_approx</code></td>
<td>
<p>an optional list of options for approxMaxMin, see <a href="#topic+approxMaxMin">approxMaxMin</a> for details.</p>
</td></tr>
<tr><td><code id="coordinateProfiles_+3A_uq_computations">uq_computations</code></td>
<td>
<p>boolean, if TRUE the uq computations for the profile mean are computed.</p>
</td></tr>
<tr><td><code id="coordinateProfiles_+3A_plot_level">plot_level</code></td>
<td>
<p>an integer to select the plots to return (0=no plots, 1=basic plots, 2= all plots)</p>
</td></tr>
<tr><td><code id="coordinateProfiles_+3A_plot_options">plot_options</code></td>
<td>
<p>an optional list of parameters for plots. See <a href="#topic+setPlotOptions">setPlotOptions</a> for currently available options.</p>
</td></tr>
<tr><td><code id="coordinateProfiles_+3A_ci_const">CI_const</code></td>
<td>
<p>an optional vector containing the constants for the CI. If not NULL, then profiles extrema for <code class="reqn">m_n(x) \pm CI_const[i]*s_n(x,x)</code> are computed.</p>
</td></tr>
<tr><td><code id="coordinateProfiles_+3A_return_level">return_level</code></td>
<td>
<p>an integer to select the amount of details returned</p>
</td></tr>
<tr><td><code id="coordinateProfiles_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to <a href="#topic+coordProf_UQ">coordProf_UQ</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If return_level=1 a list containing
</p>

<ul>
<li><p><code>profMean_full:</code>the results of <code>getAllMaxMin</code> for the posterior mean
</p>
</li>
<li><p><code>profMean_approx:</code>the results of <code>approxMaxMin</code> for the posterior mean
</p>
</li>
<li><p><code>res_UQ:</code>the results of <code>coordProf_UQ</code> for the posterior mean
</p>
</li></ul>

<p>if return_level=2 the same list as above but also including
</p>

<ul>
<li><p><code>abs_err:</code>the vector of maximum absolute approximation errors for the profile inf /sup on posterior mean for the chosen approximation
</p>
</li>
<li><p><code>times:</code>  a list containing
</p>

<ul>
<li><p><code>full:</code>computational time for the full computation of profile extrema
</p>
</li>
<li><p><code>approx:</code>computational time for the approximate computation of profile extrema
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
# Compute a kriging model from 50 evaluations of the Branin function
# Define the function
g=function(x){
  return(-branin(x))
}
gp_des&lt;-lhs::maximinLHS(20,2)
reals&lt;-apply(gp_des,1,g)
kmModel&lt;-km(design = gp_des,response = reals,covtype = "matern3_2")

threshold=-10

# Compute coordinate profiles on the posterior mean
# Increase multistart and size of designs for more precise results
options_full&lt;-list(multistart=2,heavyReturn=TRUE, Design = replicate(2,seq(0,1,,50)))
init_des&lt;-lhs::maximinLHS(12,2)
options_approx&lt;- list(multistart=2,heavyReturn=TRUE,initDesign=init_des,fullDesignSize=50)
cProfilesMean&lt;-coordinateProfiles(object=kmModel,threshold=threshold,options_full=options_full,
                                  options_approx=options_approx,uq_computations=FALSE,
                                  plot_level=3,plot_options=NULL,CI_const=NULL,return_level=2)
## Not run: 
# Coordinate profiles with UQ with approximate profiles
plot_options&lt;-list(save=FALSE, titleProf = "Coordinate profiles",
                   title2d = "Posterior mean",qq_fill=TRUE)
cProfilesUQ&lt;-coordinateProfiles(object=cProfilesMean,threshold=threshold,options_full=options_full,
                                  options_approx=options_approx,uq_computations=TRUE,
                                  plot_level=3,plot_options=NULL,CI_const=NULL,return_level=2)

# Coordinate profiles with UQ with fully optim profiles
options_full_sims&lt;-list(multistart=4,heavyReturn=TRUE, Design = replicate(2,seq(0,1,,60)))
cProfilesUQ&lt;-coordinateProfiles(object=cProfilesMean,threshold=threshold,options_full=options_full,
                                  options_approx=options_approx,uq_computations=TRUE,
                                  plot_level=3,plot_options=NULL,CI_const=NULL,return_level=2,
                                  options_full_sims=options_full_sims)

## End(Not run)
</code></pre>

<hr>
<h2 id='coordProf_UQ'>Coordinate profiles UQ from a kriging model</h2><span id='topic+coordProf_UQ'></span>

<h3>Description</h3>

<p>The function coordProf_UQ computes the profile extrema functions for posterior realizations of a Gaussian process and its confidence bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordProf_UQ(object, threshold, allResMean = NULL,
  quantiles_uq = c(0.05, 0.95), options_approx = NULL,
  options_full_sims = NULL, options_sims = NULL,
  options_bound = NULL, plot_level = 0, plot_options = NULL,
  return_level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordProf_UQ_+3A_object">object</code></td>
<td>
<p>either a <a href="DiceKriging.html#topic+km">km</a> model or a list containing partial results. If <code>object</code> is a km model then all computations are carried out. If <code>object</code> is a list, then the function carries out all computations to complete the results list.</p>
</td></tr>
<tr><td><code id="coordProf_UQ_+3A_threshold">threshold</code></td>
<td>
<p>the threshold of interest</p>
</td></tr>
<tr><td><code id="coordProf_UQ_+3A_allresmean">allResMean</code></td>
<td>
<p>a list resulting from <code>getAllMaxMin</code> or <code>approxMaxMin</code> for the profile extrema on the mean. If NULL the median from the observations is plotted</p>
</td></tr>
<tr><td><code id="coordProf_UQ_+3A_quantiles_uq">quantiles_uq</code></td>
<td>
<p>a vector containing the quantiles to be computed</p>
</td></tr>
<tr><td><code id="coordProf_UQ_+3A_options_approx">options_approx</code></td>
<td>
<p>an optional list of options for approxMaxMin, see <a href="#topic+approxMaxMin">approxMaxMin</a> for details.</p>
</td></tr>
<tr><td><code id="coordProf_UQ_+3A_options_full_sims">options_full_sims</code></td>
<td>
<p>an optional list of options for getAllMaxMin, see <a href="#topic+getAllMaxMin">getAllMaxMin</a> for details. If NULL the full computations are not excuted. NOTE: this computations might be very expensive!</p>
</td></tr>
<tr><td><code id="coordProf_UQ_+3A_options_sims">options_sims</code></td>
<td>
<p>an optional list of options for the posterior simulations.
</p>

<ul>
<li><p><code>algorithm:</code> string choice of the algorithm to select the pilot points (&quot;A&quot; or &quot;B&quot;, default &quot;B&quot;);
</p>
</li>
<li><p><code>lower:</code> <code class="reqn">d</code> dimensional vector with lower bounds for pilot points, default <code>rep(0,d)</code>;
</p>
</li>
<li><p><code>upper:</code> <code class="reqn">d</code> dimensional vector with upper bounds for pilot points, default <code>rep(1,d)</code>;
</p>
</li>
<li><p><code>batchsize:</code> number of pilot points, default <code>120</code>;
</p>
</li>
<li><p><code>optimcontrol:</code> list containing the options for optimization, see <a href="pGPx.html#topic+optim_dist_measure">optim_dist_measure</a>;
</p>
</li>
<li><p><code>integcontrol:</code> list containing the options for numerical integration of the criterion, see <a href="pGPx.html#topic+optim_dist_measure">optim_dist_measure</a>;
</p>
</li>
<li><p><code>integration.param:</code> list containing the integration design, obtained with the function <a href="KrigInv.html#topic+integration_design">integration_design</a>;
</p>
</li>
<li><p><code>nsim:</code> number of approximate GP simulations, default <code>300</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="coordProf_UQ_+3A_options_bound">options_bound</code></td>
<td>
<p>an optional list containing <code>beta</code> the confidence level for the approximation and <code>alpha</code> the confidence level for the bound. Note that <code>alpha &gt; 2*beta</code>. If <code>NULL</code>, the bound is not computed.</p>
</td></tr>
<tr><td><code id="coordProf_UQ_+3A_plot_level">plot_level</code></td>
<td>
<p>an integer to select the plots to return (0=no plots, 1=basic plots, 2= all plots)</p>
</td></tr>
<tr><td><code id="coordProf_UQ_+3A_plot_options">plot_options</code></td>
<td>
<p>an optional list of parameters for plots. See <a href="#topic+setPlotOptions">setPlotOptions</a> for currently available options.</p>
</td></tr>
<tr><td><code id="coordProf_UQ_+3A_return_level">return_level</code></td>
<td>
<p>an integer to select the amount of details returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If return_level=1 a list containing </p>

<ul>
<li><p><code>profSups:</code>an array <code>dxfullDesignSizexnsims</code> containing the profile sup for each coordinate for each realization.
</p>
</li>
<li><p><code>profInfs:</code>an array <code>dxfullDesignSizexnsims</code> containing the profile inf for each coordinate for each realization.
</p>
</li>
<li><p><code>prof_quantiles_approx:</code>a list containing the quantiles (levels set by <code>quantiles_uq</code>) of the profile extrema functions.
</p>
</li></ul>
<p> if return_level=2 the same list as above but also including <code>more:</code> a list containing </p>

<ul>
<li><p><code>times:</code>a list containing
</p>

<ul>
<li><p><code>tSpts:</code> computational time for selecting pilot points.
</p>
</li>
<li><p><code>tApprox1ord:</code>vector containing the computational time required for profile extrema computation for each realization
</p>
</li></ul>

</li>
<li><p><code>simuls:</code> a matrix containing the value of the field simulated at the pilot points
</p>
</li>
<li><p><code>sPts:</code>the pilot points
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
# Compute a kriging model from 50 evaluations of the Branin function
# Define the function
g&lt;-function(x){
  return(-branin(x))
}
gp_des&lt;-lhs::maximinLHS(20,2)
reals&lt;-apply(gp_des,1,g)
kmModel&lt;-km(design = gp_des,response = reals,covtype = "matern3_2")

threshold=-10
d&lt;-2

# Compute coordinate profiles UQ starting from GP model
# define simulation options
options_sims&lt;-list(algorithm="B", lower=rep(0,d), upper=rep(1,d),
                   batchsize=80, optimcontrol = list(method="genoud",pop.size=100,print.level=0),
                   integcontrol = list(distrib="sobol",n.points=1000), nsim=150)
# define 1 order approximation options
init_des&lt;-lhs::maximinLHS(15,d)
options_approx&lt;- list(multistart=4,heavyReturn=TRUE,
                      initDesign=init_des,fullDesignSize=100,
                      smoother="1order")
# define plot options
options_plots&lt;-list(save=FALSE, titleProf = "Coordinate profiles",
                    title2d = "Posterior mean",qq_fill=TRUE)
## Not run: 
# profile UQ on approximate coordinate profiles
cProfiles_UQ&lt;-coordProf_UQ(object = kmModel,threshold = threshold,allResMean = NULL,
                            quantiles_uq = c(0.05,0.95),options_approx = options_approx,
                            options_full_sims = NULL,options_sims = options_sims,
                            options_bound = NULL,plot_level = 3,
                            plot_options = options_plots,return_level = 3)
# profile UQ on full optim coordinate profiles
options_full_sims&lt;-list(multistart=4,heavyReturn=TRUE)
cProfiles_UQ_full&lt;-coordProf_UQ(object = cProfiles_UQ,threshold = threshold,allResMean = NULL,
                            quantiles_uq = c(0.05,0.95),options_approx = options_approx,
                            options_full_sims = options_full_sims,options_sims = options_sims,
                            options_bound = NULL,plot_level = 3,
                            plot_options = options_plots,return_level = 3)

# profile UQ on full optim coordinate profiles with bound
cProfiles_UQ_full_bound&lt;-coordProf_UQ(object = cProfiles_UQ_full,threshold = threshold,
                                      allResMean = NULL, quantiles_uq = c(0.05,0.95),
                                      options_approx = options_approx,
                                      options_full_sims = options_full_sims,
                                      options_sims = options_sims,
                                      options_bound = list(beta=0.024,alpha=0.05),
                                      plot_level = 3, plot_options = options_plots,
                                      return_level = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='getAllMaxMin'>Coordinate profile extrema with BFGS optimization</h2><span id='topic+getAllMaxMin'></span>

<h3>Description</h3>

<p>Evaluate coordinate profile extrema with full optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAllMaxMin(f, fprime = NULL, d, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAllMaxMin_+3A_f">f</code></td>
<td>
<p>the function to be evaluated</p>
</td></tr>
<tr><td><code id="getAllMaxMin_+3A_fprime">fprime</code></td>
<td>
<p>derivative of the function</p>
</td></tr>
<tr><td><code id="getAllMaxMin_+3A_d">d</code></td>
<td>
<p>dimension of the input domain</p>
</td></tr>
<tr><td><code id="getAllMaxMin_+3A_options">options</code></td>
<td>
<p>a list containing the options for this function and the subfunctions getMax, getMin
see documentation of getMax, getMin for details. The options only for getAllMaxMin are
</p>

<ul>
<li><p><code>Design:</code>an optional design matrix with the discretization of each dimension, if NULL then for each dimension Design[,coord] = seq(0,1,length.out=100)
</p>
</li>
<li><p><code>heavyReturn:</code>If TRUE returns also all minimizers, default is FALSE.
</p>
</li>
<li><p><code>plts:</code>If TRUE, plots the max/min functions at each coordinate, default is FALSE.
</p>
</li>
<li><p><code>verb:</code>If TRUE, outputs intermediate results, default is FALSE.
</p>
</li>
<li><p><code>MonteCarlo:</code>If TRUE, use the MC optimizer otherwise use standard optim.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two data frames (min, max) of the evaluations of <code class="reqn">f_sup(x_i) = sup_{x_j \neq i} f(x_1,\dots,x_d) </code> and <code class="reqn">f_inf(x_i) = inf_{x_j \neq i} f(x_1,\dots,x_d) </code>
for each i at the design Design. By default Design is a 100 equally spaced points for each dimension. It can be changed by defining it in options$Design
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
# Compute the coordinate profile extrema with full optimization on 2d example

# Define the function
g=function(x){
  return(-branin(x))
}
# Define the gradient
gprime = function(x){
  x1 = x[1]*15-5
  x2 = x[2]*15
  f1prime = (15*25)/(4*pi^4)*x1^3 - (15*75)/(2*pi^3)*x1^2 +
  (80*15)/(pi^2)*x1 - (5*15)/(pi^2)*x2*x1 +
  10*15/pi*x2 - 60*15/pi-10*15* (1 - 1/(8*pi))*sin(x1)
  f2prime = 2*15*(x2-5/(4*pi^2)*x1^2 +5/pi*x1-6)
  return(c(-f1prime,-f2prime))
}
# set up dimension
coordProf&lt;-getAllMaxMin(f = g,fprime = gprime,d=2,options = list(multistart=4,heavyReturn=TRUE))


# Consider threshold=-10
threshold&lt;- -10
# obtain the points where the profiles take the threshold value
pp_change&lt;-getChangePoints(threshold = threshold,allRes = coordProf)
# evaluate g at a grid and plot the image
x&lt;-seq(0,1,,100)
grid&lt;-expand.grid(x,x)
g_evals&lt;- apply(X = grid,MARGIN = 1,FUN = g)
image(x = x,y = x,z = matrix(g_evals,nrow = 100),col = grey.colors(20))
contour(x=x,y=x,z=matrix(g_evals,nrow = 100), add=TRUE, nlevels = 20)
contour(x=x,y=x,z=matrix(g_evals,nrow = 100), add=TRUE, levels = threshold,col=2)
abline(h = pp_change$neverEx$`-10`[[2]],col="darkgreen",lwd=2)
abline(v = pp_change$neverEx$`-10`[[1]],col="darkgreen",lwd=2)
# Plot the coordinate profiles and a threshold
plotMaxMin(allRes = coordProf,threshold = threshold,changes = TRUE)

</code></pre>

<hr>
<h2 id='getChangePoints'>Coordinate profiles crossing points</h2><span id='topic+getChangePoints'></span>

<h3>Description</h3>

<p>Obtain the points where the coordinate profile extrema functions cross the threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getChangePoints(threshold, Design = NULL, allRes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getChangePoints_+3A_threshold">threshold</code></td>
<td>
<p>if not null plots the level</p>
</td></tr>
<tr><td><code id="getChangePoints_+3A_design">Design</code></td>
<td>
<p>a d dimensional design corresponding to the points</p>
</td></tr>
<tr><td><code id="getChangePoints_+3A_allres">allRes</code></td>
<td>
<p>list containing the list <code>res</code> which contains the computed minima and maxima. The object returned by the function <code>getAllMaxMin</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing two lists with d components where
</p>

<ul>
<li><p>alwaysEx: each component is a numerical vector indicating the points <code class="reqn">x_i</code> where <code class="reqn">inf_{x^{-i}}f(x) &gt;</code> <code>threshold</code>;
</p>
</li>
<li><p>neverEx: each component is a numerical vector indicating the points <code class="reqn">x_i</code> where <code class="reqn">sup_{x^{-i}}f(x) &lt;</code> <code>threshold</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='getClosePoints'>Find close points</h2><span id='topic+getClosePoints'></span>

<h3>Description</h3>

<p>Obtain points close in one specific dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClosePoints(x, allPts, whichDim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClosePoints_+3A_x">x</code></td>
<td>
<p>one dimensional point</p>
</td></tr>
<tr><td><code id="getClosePoints_+3A_allpts">allPts</code></td>
<td>
<p>dataframe containing a list of d dimensional points</p>
</td></tr>
<tr><td><code id="getClosePoints_+3A_whichdim">whichDim</code></td>
<td>
<p>integer defining the dimension of x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the index in allPts (row number) of the closest point in allPts to x along the whichDim dimension
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='getMax'>Coordinate profile sup function</h2><span id='topic+getMax'></span>

<h3>Description</h3>

<p>Compute coordinate profile sup functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMax(x, f, fprime, coord, d, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMax_+3A_x">x</code></td>
<td>
<p>one dimensional point where the function is to be evaluated</p>
</td></tr>
<tr><td><code id="getMax_+3A_f">f</code></td>
<td>
<p>function to be optimized (takes a vector y of dimension d and returns a real number)</p>
</td></tr>
<tr><td><code id="getMax_+3A_fprime">fprime</code></td>
<td>
<p>derivative of f (same format)</p>
</td></tr>
<tr><td><code id="getMax_+3A_coord">coord</code></td>
<td>
<p>integer selecting the dimension that is fixed, the other ones are optimized over</p>
</td></tr>
<tr><td><code id="getMax_+3A_d">d</code></td>
<td>
<p>dimension of the input for f</p>
</td></tr>
<tr><td><code id="getMax_+3A_options">options</code></td>
<td>
<p>a list containing the options to be passed to optim:
</p>

<ul>
<li><p><code>par:</code>contains the starting point (a point in dimension d-1)
</p>
</li>
<li><p><code>method:</code> is the string denoting the chosen method for the optimization (see optim for details)
</p>
</li>
<li><p><code>lower:</code> the lower bounds for the optimization domain (see optim for details)
</p>
</li>
<li><p><code>upper:</code>the upper bounds for the optimization domain (see optim for details)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a real value corresponding to <code class="reqn">max_{x_1,\dots, x_{coord-1},x_{coord+1}, \dots, x_d} f(x_1,\dots,x_d)</code>
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='getMaxMinMC'>Coordinate profile extrema with MC</h2><span id='topic+getMaxMinMC'></span>

<h3>Description</h3>

<p>Compute coordinate profile extrema with MC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMaxMinMC(x, f, fprime, coord, d, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMaxMinMC_+3A_x">x</code></td>
<td>
<p>one dimensional point where the function is to be evaluated</p>
</td></tr>
<tr><td><code id="getMaxMinMC_+3A_f">f</code></td>
<td>
<p>function to be optimized (takes a vector y of dimension d and returns a real number)</p>
</td></tr>
<tr><td><code id="getMaxMinMC_+3A_fprime">fprime</code></td>
<td>
<p>derivative of f (same format)</p>
</td></tr>
<tr><td><code id="getMaxMinMC_+3A_coord">coord</code></td>
<td>
<p>integer selecting the dimension that is fixed, the other ones are optimized over</p>
</td></tr>
<tr><td><code id="getMaxMinMC_+3A_d">d</code></td>
<td>
<p>dimension of the input for f</p>
</td></tr>
<tr><td><code id="getMaxMinMC_+3A_options">options</code></td>
<td>
<p>a list containing the options to be passed to the MC optimizer:
</p>

<ul>
<li><p><code>par:</code>contains the starting point (a point in dimension d-1)
</p>
</li>
<li><p><code>numMCsamples:</code> number of MC samples
</p>
</li>
<li><p><code>rand</code>string that chooses the type of randomness in MC: &quot;unif&quot; (uniform in [lower,upper]), &quot;norm&quot; (independent normal with mean 0 and variance 1)
</p>
</li>
<li><p><code>lower:</code> the lower bounds for the optimization domain (see optim for details)
</p>
</li>
<li><p><code>upper:</code>the upper bounds for the optimization domain (see optim for details)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a real value corresponding to <code class="reqn">max_{x_1,\dots, x_{coord-1},x_{coord+1}, \dots, x_d} f(x_1,\dots,x_d)</code>
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='getMin'>Coordinate profile inf function</h2><span id='topic+getMin'></span>

<h3>Description</h3>

<p>Compute coordinate profile inf functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMin(x, f, fprime, coord, d, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMin_+3A_x">x</code></td>
<td>
<p>one dimensional point where the function is to be evaluated</p>
</td></tr>
<tr><td><code id="getMin_+3A_f">f</code></td>
<td>
<p>function to be optimized (takes a vector y of dimension d and returns a real number)</p>
</td></tr>
<tr><td><code id="getMin_+3A_fprime">fprime</code></td>
<td>
<p>derivative of f (same format)</p>
</td></tr>
<tr><td><code id="getMin_+3A_coord">coord</code></td>
<td>
<p>integer selecting the dimension that is fixed, the other ones are optimized over</p>
</td></tr>
<tr><td><code id="getMin_+3A_d">d</code></td>
<td>
<p>dimension of the input for f</p>
</td></tr>
<tr><td><code id="getMin_+3A_options">options</code></td>
<td>
<p>a list containing the options to be passed to optim:
</p>

<ul>
<li><p><code>par:</code>contains the starting point (a point in dimension d-1)
</p>
</li>
<li><p><code>method:</code>is the string denoting the chosen method for the optimization (see optim for details)
</p>
</li>
<li><p><code>lower:</code>the lower bounds for the optimization domain (see optim for details)
</p>
</li>
<li><p><code>upper:</code>the upper bounds for the optimization domain (see optim for details)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a real value corresponding to <code class="reqn">min_{x_1,\dots, x_{coord-1},x_{coord+1}, \dots, x_d} f(x_1,\dots,x_d)</code>
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='getPointProportion'>Obtain proportion of true observations in excursion set</h2><span id='topic+getPointProportion'></span>

<h3>Description</h3>

<p>Computes the proportion of observations in the excursion set from true function evaluations,
binned by the grid determined with <code>xBins</code>, <code>yBins</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPointProportion(pp, xBins, yBins, whichAbove, plt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPointProportion_+3A_pp">pp</code></td>
<td>
<p>a matrix of dimension nPts x 2 with the true points locations in 2 dimensions.</p>
</td></tr>
<tr><td><code id="getPointProportion_+3A_xbins">xBins</code></td>
<td>
<p>numerical vector with the ordered breaks of the grid along the x axis</p>
</td></tr>
<tr><td><code id="getPointProportion_+3A_ybins">yBins</code></td>
<td>
<p>numerical vector with the ordered breaks of the grid along the y axis</p>
</td></tr>
<tr><td><code id="getPointProportion_+3A_whichabove">whichAbove</code></td>
<td>
<p>boolean vector of dimension nPts, selects the points above</p>
</td></tr>
<tr><td><code id="getPointProportion_+3A_plt">plt</code></td>
<td>
<p>if not <code>TRUE</code> plots the grid, the points and the counts for each cell.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing <code>above</code>, the counts of points in excursion, <code>full</code> the counts per cell of all points,
<code>freq</code>, the relative frequence.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='getProfileExtrema'>Profile extrema with BFGS optimization</h2><span id='topic+getProfileExtrema'></span>

<h3>Description</h3>

<p>Evaluate profile extrema for a set of matrices allPsi with full optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getProfileExtrema(f, fprime = NULL, d, allPsi, opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getProfileExtrema_+3A_f">f</code></td>
<td>
<p>the function to be evaluated</p>
</td></tr>
<tr><td><code id="getProfileExtrema_+3A_fprime">fprime</code></td>
<td>
<p>derivative of the function</p>
</td></tr>
<tr><td><code id="getProfileExtrema_+3A_d">d</code></td>
<td>
<p>dimension of the input domain</p>
</td></tr>
<tr><td><code id="getProfileExtrema_+3A_allpsi">allPsi</code></td>
<td>
<p>a list containing the matrices Psi (dim <code class="reqn">pxd</code>) for which to compute the profile extrema</p>
</td></tr>
<tr><td><code id="getProfileExtrema_+3A_opts">opts</code></td>
<td>
<p>a list containing the options for this function and the subfunctions <a href="#topic+getProfileSup_optim">getProfileSup_optim</a>, <a href="#topic+getProfileInf_optim">getProfileInf_optim</a>. The options only for getProfileExtrema are
</p>

<ul>
<li><p><code>limits:</code>an optional list containing <code>lower</code> and <code>upper</code>, two vectors with the limits of the input space. If NULL then <code>limits=list(upper=rep(1,d),lower=rep(0,d))</code>
</p>
</li>
<li><p><code>discretization:</code>an optional integer representing the discretization size for the profile computation for each dimension of eta. Pay attention that this leads to a grid of size <code>discretization^p</code>.
</p>
</li>
<li><p><code>heavyReturn:</code>If TRUE returns also all minimizers, default is FALSE.
</p>
</li>
<li><p><code>plts:</code>If TRUE and p==1 for all Psi in allPsi, plots the profile functions at each Psi, default is FALSE.
</p>
</li>
<li><p><code>verb:</code>If TRUE, outputs intermediate results, default is FALSE.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two data frames (min, max) of the evaluations of <code class="reqn">P^sup_Psi f(eta) = sup_{Psi x = \eta} f(x) </code> and <code class="reqn">P^inf_Psi f(eta) = inf_{Psi x = \eta} f(x) </code>
discretized over 50 equally spaced points for each dimension for each Psi in <code>allPsi</code>. This number can be changed by defining it in options$discretization.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the oblique profile extrema with full optimization on 2d example

# Define the function
testF &lt;- function(x,params,v1=c(1,0),v2=c(0,1)){
return(sin(crossprod(v1,x)*params[1]+params[2])+cos(crossprod(v2,x)*params[3]+params[4])-1.5)
}

testFprime &lt;- function(x,params,v1=c(1,0),v2=c(0,1)){
  return(matrix(c(params[1]*v1[1]*cos(crossprod(v1,x)*params[1]+params[2])-
                  params[3]*v2[1]*sin(crossprod(v2,x)*params[3]+params[4]),
                 params[1]*v1[2]*cos(crossprod(v1,x)*params[1]+params[2])-
                  params[3]*v2[2]*sin(crossprod(v2,x)*params[3]+params[4])),ncol=1))
}


# Define the main directions of the function
theta=pi/6
pparams&lt;-c(1,0,10,0)
vv1&lt;-c(cos(theta),sin(theta))
vv2&lt;-c(cos(theta+pi/2),sin(theta+pi/2))

# Define optimizer friendly function
f &lt;-function(x){
return(testF(x,pparams,vv1,vv2))
}
fprime &lt;- function(x){
 return(testFprime(x,pparams,vv1,vv2))
}

# Define list of directions where to evaluate the profile extrema
all_Psi &lt;- list(Psi1=vv1,Psi2=vv2)



# Evaluate profile extrema along directions of all_Psi
allOblique&lt;-getProfileExtrema(f=f,fprime = fprime,d = 2,allPsi = all_Psi,
                              opts = list(plts=FALSE,discretization=100,multistart=8))


# Consider threshold=0
threshold &lt;- 0

# Plot oblique profile extrema functions
plotMaxMin(allOblique,allOblique$Design,threshold = threshold)

## Since the example is two dimensional we can visualize the regions excluded by the profile extrema
# evaluate the function at a grid for plots
inDes&lt;-seq(0,1,,100)
inputs&lt;-expand.grid(inDes,inDes)
outs&lt;-apply(X = inputs,MARGIN = 1,function(x){return(testF(x,pparams,v1=vv1,v2=vv2))})

# obtain the points where the profiles take the threshold value
cccObl&lt;-getChangePoints(threshold = threshold,allRes = allOblique,Design = allOblique$Design)

# visualize the functions and the regions excluded

image(inDes,inDes,matrix(outs,ncol=100),col=grey.colors(20),main="Example and oblique profiles")
contour(inDes,inDes,matrix(outs,ncol=100),add=TRUE,nlevels = 20)
contour(inDes,inDes,matrix(outs,ncol=100),add=TRUE,levels = c(threshold),col=4,lwd=1.5)
plotOblique(cccObl$alwaysEx$`0`[[1]],all_Psi[[1]],col=3)
plotOblique(cccObl$alwaysEx$`0`[[2]],all_Psi[[2]],col=3)
plotOblique(cccObl$neverEx$`0`[[1]],all_Psi[[1]],col=2)
plotOblique(cccObl$neverEx$`0`[[2]],all_Psi[[2]],col=2)


</code></pre>

<hr>
<h2 id='getProfileInf_optim'>Generic profile inf function computation with optim</h2><span id='topic+getProfileInf_optim'></span>

<h3>Description</h3>

<p>Compute profile inf function for an arbitrary matrix <code>Psi</code> with with the L-BFGS-B algorithm of <a href="stats.html#topic+optim">optim</a>. Here the linear equality constraint is eliminated by using the Null space of <code>Psi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getProfileInf_optim(eta, Psi, f, fprime, d, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getProfileInf_optim_+3A_eta">eta</code></td>
<td>
<p><code class="reqn">p</code> dimensional point where the function is to be evaluated</p>
</td></tr>
<tr><td><code id="getProfileInf_optim_+3A_psi">Psi</code></td>
<td>
<p>projection matrix of dimension <code>pxd</code></p>
</td></tr>
<tr><td><code id="getProfileInf_optim_+3A_f">f</code></td>
<td>
<p>function to be optimized (takes a vector y of dimension d and returns a real number)</p>
</td></tr>
<tr><td><code id="getProfileInf_optim_+3A_fprime">fprime</code></td>
<td>
<p>derivative of f (same format, returning a <code class="reqn">d</code> dimensional vector)</p>
</td></tr>
<tr><td><code id="getProfileInf_optim_+3A_d">d</code></td>
<td>
<p>dimension of the input for f</p>
</td></tr>
<tr><td><code id="getProfileInf_optim_+3A_options">options</code></td>
<td>
<p>a list containing the options to be passed to optim:
</p>

<ul>
<li><p><code>par:</code>contains the starting point (a point in dimension d)
</p>
</li>
<li><p><code>lower:</code> the lower bounds for the optimization domain (see optim for details)
</p>
</li>
<li><p><code>upper:</code>the upper bounds for the optimization domain (see optim for details)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a real value corresponding to <code class="reqn">min_{x \in D_Psi} f(x)</code>
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>See Also</h3>

<p><a href="#topic+getProfileSup_optim">getProfileSup_optim</a>, <a href="#topic+plotMaxMin">plotMaxMin</a>
</p>

<hr>
<h2 id='getProfileSup_optim'>Generic profile sup function computation with optim</h2><span id='topic+getProfileSup_optim'></span>

<h3>Description</h3>

<p>Compute profile sup function for an arbitrary matrix <code>Psi</code> with the L-BFGS-B algorithm of <a href="stats.html#topic+optim">optim</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getProfileSup_optim(eta, Psi, f, fprime, d, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getProfileSup_optim_+3A_eta">eta</code></td>
<td>
<p><code class="reqn">p</code> dimensional point where the function is to be evaluated</p>
</td></tr>
<tr><td><code id="getProfileSup_optim_+3A_psi">Psi</code></td>
<td>
<p>projection matrix of dimensions <code>p x d</code></p>
</td></tr>
<tr><td><code id="getProfileSup_optim_+3A_f">f</code></td>
<td>
<p>function to be optimized (takes a vector y of dimension d and returns a real number)</p>
</td></tr>
<tr><td><code id="getProfileSup_optim_+3A_fprime">fprime</code></td>
<td>
<p>derivative of f (same format, returning a <code class="reqn">d</code> dimensional vector)</p>
</td></tr>
<tr><td><code id="getProfileSup_optim_+3A_d">d</code></td>
<td>
<p>dimension of the input for f</p>
</td></tr>
<tr><td><code id="getProfileSup_optim_+3A_options">options</code></td>
<td>
<p>a list containing the options to be passed to optim:
</p>

<ul>
<li><p><code>par:</code>contains the starting point (a point in dimension d-1)
</p>
</li>
<li><p><code>lower:</code> the lower bounds for the optimization domain (see optim for details)
</p>
</li>
<li><p><code>upper:</code>the upper bounds for the optimization domain (see optim for details)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a real value corresponding to <code class="reqn">max_{x \in D_Psi} f(x)</code>
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>See Also</h3>

<p><a href="#topic+getProfileInf_optim">getProfileInf_optim</a>, <a href="#topic+plotMaxMin">plotMaxMin</a>
</p>

<hr>
<h2 id='getSegments'>getSegments</h2><span id='topic+getSegments'></span>

<h3>Description</h3>

<p>Auxiliary function for <code>getChangePoints</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSegments(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSegments_+3A_y">y</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots the sup and inf of the function for each dimension. If threshold is not NULL
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='grad_mean_Delta_T'>Gradient of the mean function of difference process</h2><span id='topic+grad_mean_Delta_T'></span>

<h3>Description</h3>

<p>The function grad_mean_Delta_T computes the gradient for the mean function of the difference process <code class="reqn">Z_x - \widetilde{Z}_x</code> at <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad_mean_Delta_T(x, kmModel, simupoints, T.mat, F.mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grad_mean_Delta_T_+3A_x">x</code></td>
<td>
<p>a matrix <code class="reqn">r x d</code> containing the <code class="reqn">r</code> points where the function is to be computed.</p>
</td></tr>
<tr><td><code id="grad_mean_Delta_T_+3A_kmmodel">kmModel</code></td>
<td>
<p>the <a href="DiceKriging.html#topic+km">km</a> model of the Gaussian process <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="grad_mean_Delta_T_+3A_simupoints">simupoints</code></td>
<td>
<p>the matrix <code class="reqn">l x d</code> containing the pilot points <code class="reqn">G</code>.</p>
</td></tr>
<tr><td><code id="grad_mean_Delta_T_+3A_t.mat">T.mat</code></td>
<td>
<p>the upper triangular factor of the Choleski decomposition of the covariance matrix of <code>rbind(kmModel@X,simupoints)</code></p>
</td></tr>
<tr><td><code id="grad_mean_Delta_T_+3A_f.mat">F.mat</code></td>
<td>
<p>the evaluation of the trend function at <code>rbind(kmModel@X,simupoints)</code>, see <a href="stats.html#topic+model.matrix">model.matrix</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the gradient for the mean function at <code>x</code> for the difference process <code class="reqn">Z^\Delta = Z_x - \widetilde{Z}_x</code>.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='grad_var_Delta_T'>Gradient of the variance function of difference process</h2><span id='topic+grad_var_Delta_T'></span>

<h3>Description</h3>

<p>The function grad_var_Delta_T computes the gradient for the variance function of the difference process <code class="reqn">Z_x - \widetilde{Z}_x</code> at <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad_var_Delta_T(x, kmModel, simupoints, T.mat, F.mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grad_var_Delta_T_+3A_x">x</code></td>
<td>
<p>a matrix <code class="reqn">r x d</code> containing the <code class="reqn">r</code> points where the function is to be computed.</p>
</td></tr>
<tr><td><code id="grad_var_Delta_T_+3A_kmmodel">kmModel</code></td>
<td>
<p>the <a href="DiceKriging.html#topic+km">km</a> model of the Gaussian process <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="grad_var_Delta_T_+3A_simupoints">simupoints</code></td>
<td>
<p>the matrix <code class="reqn">l x d</code> containing the pilot points <code class="reqn">G</code>.</p>
</td></tr>
<tr><td><code id="grad_var_Delta_T_+3A_t.mat">T.mat</code></td>
<td>
<p>the upper triangular factor of the Choleski decomposition of the covariance matrix of <code>rbind(kmModel@X,simupoints)</code></p>
</td></tr>
<tr><td><code id="grad_var_Delta_T_+3A_f.mat">F.mat</code></td>
<td>
<p>the evaluation of the trend function at <code>rbind(kmModel@X,simupoints)</code>, see <a href="stats.html#topic+model.matrix">model.matrix</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the gradient for the variance function at <code>x</code> for the difference process <code class="reqn">Z^\Delta = Z_x - \widetilde{Z}_x</code>.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='gradKm_dnewdata'>Gradient of posterior mean and variance</h2><span id='topic+gradKm_dnewdata'></span>

<h3>Description</h3>

<p>Computes the gradient of the posterior mean and variance of the kriging model in <code>object</code> at the points <code>newdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradKm_dnewdata(object, newdata, type, se.compute = TRUE,
  light.return = FALSE, bias.correct = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradKm_dnewdata_+3A_object">object</code></td>
<td>
<p>a <a href="DiceKriging.html#topic+km">km</a> object</p>
</td></tr>
<tr><td><code id="gradKm_dnewdata_+3A_newdata">newdata</code></td>
<td>
<p>a vector, matrix or data frame containing the points where to perform predictions.</p>
</td></tr>
<tr><td><code id="gradKm_dnewdata_+3A_type">type</code></td>
<td>
<p>a character corresponding to the type of kriging family (<code>"SK"</code> or <code>"UK"</code>).</p>
</td></tr>
<tr><td><code id="gradKm_dnewdata_+3A_se.compute">se.compute</code></td>
<td>
<p>an optional boolean indicating whether to compute the posterior variance or not. Default is TRUE.</p>
</td></tr>
<tr><td><code id="gradKm_dnewdata_+3A_light.return">light.return</code></td>
<td>
<p>an optional boolean indicating whether to return additional variables. Default is FALSE.</p>
</td></tr>
<tr><td><code id="gradKm_dnewdata_+3A_bias.correct">bias.correct</code></td>
<td>
<p>an optional boolean to correct bias in the UK variance. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing </p>

<ul>
<li><p><code>mean:</code> the gradient of the posterior mean at <code>newdata</code>.
</p>
</li>
<li><p><code>trend:</code> the gradient of the trend at <code>newdata</code>.
</p>
</li>
<li><p><code>s2:</code> the gradient of the posterior variance at <code>newdata</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='kGradSmooth'>First order approximation</h2><span id='topic+kGradSmooth'></span>

<h3>Description</h3>

<p>Compute first order approximation of function from evaluations and gradient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kGradSmooth(newPoints, profPoints, profEvals, profGradient)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kGradSmooth_+3A_newpoints">newPoints</code></td>
<td>
<p>vector of points where to approximate the function</p>
</td></tr>
<tr><td><code id="kGradSmooth_+3A_profpoints">profPoints</code></td>
<td>
<p>locations where the function was evaluated</p>
</td></tr>
<tr><td><code id="kGradSmooth_+3A_profevals">profEvals</code></td>
<td>
<p>value of the evaluation at profPoints</p>
</td></tr>
<tr><td><code id="kGradSmooth_+3A_profgradient">profGradient</code></td>
<td>
<p>value of the gradient at profPoints</p>
</td></tr>
</table>


<h3>Value</h3>

<p>approximated values of the function at newPoints
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='mean_Delta_T'>mean function of difference process</h2><span id='topic+mean_Delta_T'></span>

<h3>Description</h3>

<p>The function mean_Delta_T computes the mean function of the difference process <code class="reqn">Z_x - \widetilde{Z}_x</code> at <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_Delta_T(x, kmModel, simupoints, T.mat, F.mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_Delta_T_+3A_x">x</code></td>
<td>
<p>a matrix <code class="reqn">r x d</code> containing the <code class="reqn">r</code> points where the function is to be computed.</p>
</td></tr>
<tr><td><code id="mean_Delta_T_+3A_kmmodel">kmModel</code></td>
<td>
<p>the <a href="DiceKriging.html#topic+km">km</a> model of the Gaussian process <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="mean_Delta_T_+3A_simupoints">simupoints</code></td>
<td>
<p>the matrix <code class="reqn">l x d</code> containing the pilot points <code class="reqn">G</code>.</p>
</td></tr>
<tr><td><code id="mean_Delta_T_+3A_t.mat">T.mat</code></td>
<td>
<p>the upper triangular factor of the Choleski decomposition of the covariance matrix of <code>rbind(kmModel@X,simupoints)</code></p>
</td></tr>
<tr><td><code id="mean_Delta_T_+3A_f.mat">F.mat</code></td>
<td>
<p>the evaluation of the trend function at <code>rbind(kmModel@X,simupoints)</code>, see <a href="stats.html#topic+model.matrix">model.matrix</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the mean function at <code>x</code> for the difference process <code class="reqn">Z^\Delta = Z_x - \widetilde{Z}_x</code>.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='obliqueProf_UQ'>Oblique profiles UQ from a kriging model</h2><span id='topic+obliqueProf_UQ'></span>

<h3>Description</h3>

<p>The function obliqueProf_UQ computes the profile extrema functions for posterior realizations of a Gaussian process and its confidence bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obliqueProf_UQ(object, allPsi, threshold, allResMean = NULL,
  quantiles_uq = c(0.05, 0.95), options_approx = NULL,
  options_full_sims = NULL, options_sims = NULL,
  options_bound = NULL, plot_level = 0, plot_options = NULL,
  return_level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obliqueProf_UQ_+3A_object">object</code></td>
<td>
<p>either a <a href="DiceKriging.html#topic+km">km</a> model or a list containing partial results. If <code>object</code> is a km model then all computations are carried out. If <code>object</code> is a list, then the function carries out all computations to complete the results list.</p>
</td></tr>
<tr><td><code id="obliqueProf_UQ_+3A_allpsi">allPsi</code></td>
<td>
<p>a list containing the matrices Psi (dim <code class="reqn">pxd</code>) for which to compute the profile extrema</p>
</td></tr>
<tr><td><code id="obliqueProf_UQ_+3A_threshold">threshold</code></td>
<td>
<p>the threshold of interest</p>
</td></tr>
<tr><td><code id="obliqueProf_UQ_+3A_allresmean">allResMean</code></td>
<td>
<p>a list resulting from <code>getProfileExtrema</code> or <code>approxProfileExtrema</code> for the profile extrema on the mean. If NULL the median from the observations is plotted</p>
</td></tr>
<tr><td><code id="obliqueProf_UQ_+3A_quantiles_uq">quantiles_uq</code></td>
<td>
<p>a vector containing the quantiles to be computed</p>
</td></tr>
<tr><td><code id="obliqueProf_UQ_+3A_options_approx">options_approx</code></td>
<td>
<p>an optional list of options for approxProfileExtrema, see <a href="#topic+approxProfileExtrema">approxProfileExtrema</a> for details.</p>
</td></tr>
<tr><td><code id="obliqueProf_UQ_+3A_options_full_sims">options_full_sims</code></td>
<td>
<p>an optional list of options for getProfileExtrema, see <a href="#topic+getProfileExtrema">getProfileExtrema</a> for details. If NULL the full computations are not executed. NOTE: this computations might be very expensive!</p>
</td></tr>
<tr><td><code id="obliqueProf_UQ_+3A_options_sims">options_sims</code></td>
<td>
<p>an optional list of options for the posterior simulations.
</p>

<ul>
<li><p><code>algorithm:</code> string choice of the algorithm to select the pilot points (&quot;A&quot; or &quot;B&quot;, default &quot;B&quot;);
</p>
</li>
<li><p><code>lower:</code> <code class="reqn">d</code> dimensional vector with lower bounds for pilot points, default <code>rep(0,d)</code>;
</p>
</li>
<li><p><code>upper:</code> <code class="reqn">d</code> dimensional vector with upper bounds for pilot points, default <code>rep(1,d)</code>;
</p>
</li>
<li><p><code>batchsize:</code> number of pilot points, default <code>120</code>;
</p>
</li>
<li><p><code>optimcontrol:</code> list containing the options for optimization, see <a href="pGPx.html#topic+optim_dist_measure">optim_dist_measure</a>;
</p>
</li>
<li><p><code>integcontrol:</code> list containing the options for numerical integration of the criterion, see <a href="pGPx.html#topic+optim_dist_measure">optim_dist_measure</a>;
</p>
</li>
<li><p><code>integration.param:</code> list containing the integration design, obtained with the function <a href="KrigInv.html#topic+integration_design">integration_design</a>;
</p>
</li>
<li><p><code>nsim:</code> number of approximate GP simulations, default <code>300</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="obliqueProf_UQ_+3A_options_bound">options_bound</code></td>
<td>
<p>an optional list containing <code>beta</code> the confidence level for the approximation and <code>alpha</code> the confidence level for the bound. Note that <code>alpha &gt; 2*beta</code>. If <code>NULL</code>, the bound is not computed.</p>
</td></tr>
<tr><td><code id="obliqueProf_UQ_+3A_plot_level">plot_level</code></td>
<td>
<p>an integer to select the plots to return (0=no plots, 1=basic plots, 2= all plots)</p>
</td></tr>
<tr><td><code id="obliqueProf_UQ_+3A_plot_options">plot_options</code></td>
<td>
<p>an optional list of parameters for plots. See <a href="#topic+setPlotOptions">setPlotOptions</a> for currently available options.</p>
</td></tr>
<tr><td><code id="obliqueProf_UQ_+3A_return_level">return_level</code></td>
<td>
<p>an integer to select the amount of details returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If return_level=1 a list containing </p>

<ul>
<li><p><code>profSups:</code>an array <code>dxfullDesignSizexnsims</code> containing the profile sup for each coordinate for each realization.
</p>
</li>
<li><p><code>profInfs:</code>an array <code>dxfullDesignSizexnsims</code> containing the profile inf for each coordinate for each realization.
</p>
</li>
<li><p><code>prof_quantiles_approx:</code>a list containing the quantiles (levels set by <code>quantiles_uq</code>) of the profile extrema functions.
</p>
</li></ul>
<p> if return_level=2 the same list as above but also including <code>more:</code> a list containing </p>

<ul>
<li><p><code>times:</code>a list containing
</p>

<ul>
<li><p><code>tSpts:</code> computational time for selecting pilot points.
</p>
</li>
<li><p><code>tApprox1ord:</code>vector containing the computational time required for profile extrema computation for each realization
</p>
</li></ul>

</li>
<li><p><code>simuls:</code> a matrix containing the value of the field simulated at the pilot points
</p>
</li>
<li><p><code>sPts:</code>the pilot points
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
# Compute a kriging model from 50 evaluations of the Branin function
# Define the function
g&lt;-function(x){
  return(-branin(x))
}
gp_des&lt;-lhs::maximinLHS(20,2)
reals&lt;-apply(gp_des,1,g)
kmModel&lt;-km(design = gp_des,response = reals,covtype = "matern3_2")

threshold=-10
d&lt;-2

# Compute oblique profiles UQ starting from GP model
# define simulation options
options_sims&lt;-list(algorithm="B", lower=rep(0,d), upper=rep(1,d),
                   batchsize=80, optimcontrol = list(method="genoud",pop.size=100,print.level=0),
                   integcontrol = list(distrib="sobol",n.points=1000), nsim=150)
# define approximation options
options_approx&lt;- list(multistart=4,heavyReturn=TRUE,
                      initDesign=NULL,fullDesignSize=100,
                      smoother=NULL)
# define plot options
options_plots&lt;-list(save=FALSE, titleProf = "Coordinate profiles",
                    title2d = "Posterior mean",qq_fill=TRUE)

# Define the oblique directions
# (for theta=0 it is equal to coordinateProfiles)
theta=pi/4
allPsi = list(Psi1=matrix(c(cos(theta),sin(theta)),ncol=2),
              Psi2=matrix(c(cos(theta+pi/2),sin(theta+pi/2)),ncol=2))
## Not run: 
# here we reduce the number of simulations to speed up the example
# a higher number should be used
options_sims$nsim &lt;- 50

# profile UQ on approximate oblique profiles
oProfiles_UQ&lt;-obliqueProf_UQ(object = kmModel,threshold = threshold,allPsi=allPsi,
                             allResMean = NULL,quantiles_uq = c(0.05,0.95),
                             options_approx = options_approx, options_full_sims = NULL,
                             options_sims = options_sims,options_bound = NULL,
                             plot_level = 3, plot_options = options_plots,return_level = 3)
# profile UQ on full optim oblique profiles

options_full_sims&lt;-list(multistart=4,heavyReturn=TRUE)
oProfiles_UQ_full&lt;- obliqueProf_UQ(object = oProfiles_UQ,threshold = threshold,allPsi=allPsi,
                             allResMean = NULL,quantiles_uq = c(0.05,0.95),
                             options_approx = options_approx, options_full_sims = options_full_sims,
                             options_sims = options_sims,options_bound = NULL,
                             plot_level = 3, plot_options = options_plots,return_level = 3)



# profile UQ on full optim oblique profiles with bound
oProfiles_UQ_full_bound&lt;-obliqueProf_UQ(object = oProfiles_UQ_full,threshold = threshold,
                                        allPsi=allPsi, allResMean = NULL,
                                        quantiles_uq = c(0.05,0.95),
                                        options_approx = options_approx,
                                        options_full_sims = options_full_sims,
                                      options_sims = options_sims,
                                      options_bound = list(beta=0.024,alpha=0.05),
                                      plot_level = 3, plot_options = options_plots,
                                      return_level = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='obliqueProfiles'>Oblique coordinate profiles starting from a kriging model</h2><span id='topic+obliqueProfiles'></span>

<h3>Description</h3>

<p>The function obliqueProfiles computes the (oblique) profile extrema functions for the posterior mean of a Gaussian process and its confidence bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obliqueProfiles(object, allPsi, threshold, options_full = NULL,
  options_approx = NULL, uq_computations = FALSE, plot_level = 0,
  plot_options = NULL, CI_const = NULL, return_level = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obliqueProfiles_+3A_object">object</code></td>
<td>
<p>either a <a href="DiceKriging.html#topic+km">km</a> model or a list containing partial results. If <code>object</code> is a km model then all computations are carried out. If <code>object</code> is a list, then the function carries out all computations to complete the list results.</p>
</td></tr>
<tr><td><code id="obliqueProfiles_+3A_allpsi">allPsi</code></td>
<td>
<p>a list containing the matrices Psi (dim <code class="reqn">pxd</code>) for which to compute the profile extrema</p>
</td></tr>
<tr><td><code id="obliqueProfiles_+3A_threshold">threshold</code></td>
<td>
<p>the threshold of interest</p>
</td></tr>
<tr><td><code id="obliqueProfiles_+3A_options_full">options_full</code></td>
<td>
<p>an optional list of options for getProfileExtrema, see <a href="#topic+getProfileExtrema">getProfileExtrema</a> for details.</p>
</td></tr>
<tr><td><code id="obliqueProfiles_+3A_options_approx">options_approx</code></td>
<td>
<p>an optional list of options for approxProfileExtrema, see <a href="#topic+approxProfileExtrema">approxProfileExtrema</a> for details.</p>
</td></tr>
<tr><td><code id="obliqueProfiles_+3A_uq_computations">uq_computations</code></td>
<td>
<p>boolean, if TRUE the uq computations for the profile mean are computed.</p>
</td></tr>
<tr><td><code id="obliqueProfiles_+3A_plot_level">plot_level</code></td>
<td>
<p>an integer to select the plots to return (0=no plots, 1=basic plots, 2= all plots)</p>
</td></tr>
<tr><td><code id="obliqueProfiles_+3A_plot_options">plot_options</code></td>
<td>
<p>an optional list of parameters for plots. See <a href="#topic+setPlotOptions">setPlotOptions</a> for currently available options.</p>
</td></tr>
<tr><td><code id="obliqueProfiles_+3A_ci_const">CI_const</code></td>
<td>
<p>an optional vector containing the constants for the CI. If not NULL, then profiles extrema for <code class="reqn">m_n(x) \pm CI_const[i]*s_n(x,x)</code> are computed.</p>
</td></tr>
<tr><td><code id="obliqueProfiles_+3A_return_level">return_level</code></td>
<td>
<p>an integer to select the amount of details returned</p>
</td></tr>
<tr><td><code id="obliqueProfiles_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to <a href="#topic+obliqueProf_UQ">obliqueProf_UQ</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If return_level=1 a list containing
</p>

<ul>
<li><p><code>profMean_full:</code>the results of <code>getProfileExtrema</code> for the posterior mean
</p>
</li>
<li><p><code>profMean_approx:</code>the results of <code>approxProfileExtrema</code> for the posterior mean
</p>
</li>
<li><p><code>res_UQ:</code>the results of <code>obliqueProf_UQ</code> for the posterior mean
</p>
</li></ul>

<p>if return_level=2 the same list as above but also including
</p>

<ul>
<li><p><code>abs_err:</code>the vector of maximum absolute approximation errors for the profile inf /sup on posterior mean for the chosen approximation
</p>
</li>
<li><p><code>times:</code>  a list containing
</p>

<ul>
<li><p><code>full:</code>computational time for the full computation of profile extrema
</p>
</li>
<li><p><code>approx:</code>computational time for the approximate computation of profile extrema
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
# Compute a kriging model from 50 evaluations of the Branin function
# Define the function
g=function(x){
  return(-branin(x))
}
gp_des&lt;-lhs::maximinLHS(20,2)
reals&lt;-apply(gp_des,1,g)
kmModel&lt;-km(design = gp_des,response = reals,covtype = "matern3_2")

threshold=-10

# Compute oblique profiles on the posterior mean
# (for theta=0 it is equal to coordinateProfiles)
options_full&lt;-list(multistart=4,heavyReturn=TRUE,discretization=100)
options_approx&lt;- list(multistart=4,heavyReturn=TRUE,initDesign=NULL,fullDesignSize=100)
theta=pi/4
allPsi = list(Psi1=matrix(c(cos(theta),sin(theta)),ncol=2),
Psi2=matrix(c(cos(theta+pi/2),sin(theta+pi/2)),ncol=2))

## Not run: 
profMeans&lt;-obliqueProfiles(object = kmModel,allPsi = allPsi,threshold = threshold,
                           options_full = options_full,options_approx = options_approx,
                           uq_computations = FALSE,plot_level = 3,plot_options = NULL,
                           CI_const = NULL,return_level = 2)


# Approximate oblique profiles with UQ
plot_options&lt;-list(save=FALSE, titleProf = "Coordinate profiles",
                   title2d = "Posterior mean",qq_fill=TRUE)
options_sims&lt;-list(nsim=150)
obProfUQ&lt;-obliqueProfiles(object=profMeans,threshold=threshold,allPsi = allPsi,
                           options_full=options_full, options_approx=options_approx,
                           uq_computations=TRUE, plot_level=3,plot_options=NULL,
                           CI_const=NULL,return_level=2,options_sims=options_sims)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_univariate_profiles_UQ'>Univariate profile extrema with UQ</h2><span id='topic+plot_univariate_profiles_UQ'></span>

<h3>Description</h3>

<p>Function to plot the univariate profile extrema functions with UQ
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_univariate_profiles_UQ(objectUQ, plot_options, nsims, threshold,
  nameFile = "prof_UQ", quantiles_uq = c(0.05, 0.95),
  profMean = NULL, typeProf = "approx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_univariate_profiles_UQ_+3A_objectuq">objectUQ</code></td>
<td>
<p>an object returned by <a href="#topic+coordProf_UQ">coordProf_UQ</a> or the object saved in <code>obj$res_UQ</code>, if <code>obj</code> is the object returned by <a href="#topic+coordinateProfiles">coordinateProfiles</a>.</p>
</td></tr>
<tr><td><code id="plot_univariate_profiles_UQ_+3A_plot_options">plot_options</code></td>
<td>
<p>a list containing the same elements as the one passed to <a href="#topic+coordinateProfiles">coordinateProfiles</a></p>
</td></tr>
<tr><td><code id="plot_univariate_profiles_UQ_+3A_nsims">nsims</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="plot_univariate_profiles_UQ_+3A_threshold">threshold</code></td>
<td>
<p>threshold of interest</p>
</td></tr>
<tr><td><code id="plot_univariate_profiles_UQ_+3A_namefile">nameFile</code></td>
<td>
<p>the central name of the plot file</p>
</td></tr>
<tr><td><code id="plot_univariate_profiles_UQ_+3A_quantiles_uq">quantiles_uq</code></td>
<td>
<p>a vector containing the quantiles to be computed</p>
</td></tr>
<tr><td><code id="plot_univariate_profiles_UQ_+3A_profmean">profMean</code></td>
<td>
<p>the profile coordinate extrema functions for the mean. It is saved in <code>obj$profMean_full</code> or <code>obj$profMean_approx</code> if <code>obj</code> is an object returned by <a href="#topic+coordinateProfiles">coordinateProfiles</a>.</p>
</td></tr>
<tr><td><code id="plot_univariate_profiles_UQ_+3A_typeprof">typeProf</code></td>
<td>
<p>a string to choose with type of profile extrema for simulations to plot </p>

<ul>
<li><p>&quot;approx&quot;plots only the approximate profile extrema for simulations
</p>
</li>
<li><p>&quot;full&quot;plots only the full profile extrema for simulations
</p>
</li>
<li><p>&quot;both&quot;plots both the approximate and full profile extrema for simulations
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots either to the default graphical device or to pdf (according to the options passed in <code>plot_options</code>)
</p>

<hr>
<h2 id='plotBivariateProfiles'>Plot bivariate profiles</h2><span id='topic+plotBivariateProfiles'></span>

<h3>Description</h3>

<p>Plot bivariate profiles, for dimension up to 6.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBivariateProfiles(bivProf, allPsi, Design = NULL, threshold = NULL,
  whichIQR = NULL, plot_options = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBivariateProfiles_+3A_bivprof">bivProf</code></td>
<td>
<p>list returned by <code>obliqueProfiles</code>.</p>
</td></tr>
<tr><td><code id="plotBivariateProfiles_+3A_allpsi">allPsi</code></td>
<td>
<p>a list containing the matrices Psi (dim <code class="reqn">2xd</code>) for which to compute the profile extrema</p>
</td></tr>
<tr><td><code id="plotBivariateProfiles_+3A_design">Design</code></td>
<td>
<p>a matrix of dimension <code class="reqn">(2d)x numPsi</code> encoding the first (<code>Design[1:d,]</code>) and the second ((<code>Design[(d+1):(2*d),]</code>)) axis values.</p>
</td></tr>
<tr><td><code id="plotBivariateProfiles_+3A_threshold">threshold</code></td>
<td>
<p>if not <code>NULL</code> plots the level as a contour.</p>
</td></tr>
<tr><td><code id="plotBivariateProfiles_+3A_whichiqr">whichIQR</code></td>
<td>
<p>which quantiles to use for the inter-quantile range plot. If <code>NULL</code>, automatically selects the first and the last element of <code>bivProfres_UQ$prof_quantiles_approx</code></p>
</td></tr>
<tr><td><code id="plotBivariateProfiles_+3A_plot_options">plot_options</code></td>
<td>
<p>list as returned by <code>setPlotOptions</code>.</p>
</td></tr>
<tr><td><code id="plotBivariateProfiles_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots the 2d maps of the profile sup and inf of the function for each Psi in allPsi. If threshold is not NULL also contours the threshold level.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='plotMaxMin'>Plot coordinate profiles</h2><span id='topic+plotMaxMin'></span>

<h3>Description</h3>

<p>Plot coordinate profiles, for dimension up to 6.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMaxMin(allRes, Design = NULL, threshold = NULL, changes = FALSE,
  trueEvals = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMaxMin_+3A_allres">allRes</code></td>
<td>
<p>list containing the list <code>res</code> which contains the computed minima and maxima. The object returned by the function <code>getAllMaxMin</code>.</p>
</td></tr>
<tr><td><code id="plotMaxMin_+3A_design">Design</code></td>
<td>
<p>a d dimensional design corresponding to the points</p>
</td></tr>
<tr><td><code id="plotMaxMin_+3A_threshold">threshold</code></td>
<td>
<p>if not <code>NULL</code> plots the level</p>
</td></tr>
<tr><td><code id="plotMaxMin_+3A_changes">changes</code></td>
<td>
<p>boolean, if not <code>FALSE</code> plots the points where profile extrema take values near the threshold.</p>
</td></tr>
<tr><td><code id="plotMaxMin_+3A_trueevals">trueEvals</code></td>
<td>
<p>if not <code>NULL</code> adds to each plot the data points and the observed value</p>
</td></tr>
<tr><td><code id="plotMaxMin_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots the sup and inf of the function for each dimension. If threshold is not NULL
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='plotOblique'>plotOblique</h2><span id='topic+plotOblique'></span>

<h3>Description</h3>

<p>Auxiliary function for 2d plotting of excluded regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotOblique(changePoints, direction, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotOblique_+3A_changepoints">changePoints</code></td>
<td>
<p>Numerical vector with the change points (usually if <code>cp=getChangePoints(...)</code>, then this is cc$alwaysEx[[1]][[1]] for example)</p>
</td></tr>
<tr><td><code id="plotOblique_+3A_direction">direction</code></td>
<td>
<p>The Psi vector used for the direction</p>
</td></tr>
<tr><td><code id="plotOblique_+3A_...">...</code></td>
<td>
<p>parameters to be passed to abline</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adds to the current plot the lines <code class="reqn">x</code> s.t. <code>direction</code>^T <code class="reqn">x</code> = <code>changePoints[i]</code> for all i
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='plotOneBivProfile'>Plot bivariate profiles</h2><span id='topic+plotOneBivProfile'></span>

<h3>Description</h3>

<p>Plots the bivariate profiles stored in <code>allRes</code> for each Psi in <code>allPsi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotOneBivProfile(allRes, allPsi, Design = NULL, threshold = NULL,
  trueEvals = NULL, main_addendum = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotOneBivProfile_+3A_allres">allRes</code></td>
<td>
<p>list containing the list <code>res</code> which contains the computed minima and maxima. The object returned by the function <code>getProfileExtrema</code>.</p>
</td></tr>
<tr><td><code id="plotOneBivProfile_+3A_allpsi">allPsi</code></td>
<td>
<p>a list containing the matrices Psi (dim <code class="reqn">2xd</code>) for which to compute the profile extrema</p>
</td></tr>
<tr><td><code id="plotOneBivProfile_+3A_design">Design</code></td>
<td>
<p>a matrix of dimension <code class="reqn">(2d)x numPsi</code> encoding the first (<code>Design[1:d,]</code>) and the second ((<code>Design[(d+1):(2*d),]</code>)) axis values.</p>
</td></tr>
<tr><td><code id="plotOneBivProfile_+3A_threshold">threshold</code></td>
<td>
<p>if not <code>NULL</code> plots the level as a contour.</p>
</td></tr>
<tr><td><code id="plotOneBivProfile_+3A_trueevals">trueEvals</code></td>
<td>
<p>if not <code>NULL</code> adds to each plot the data points and the observed value</p>
</td></tr>
<tr><td><code id="plotOneBivProfile_+3A_main_addendum">main_addendum</code></td>
<td>
<p>additional string to add to image title. Default is empty string.</p>
</td></tr>
<tr><td><code id="plotOneBivProfile_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots the 2d maps of the profile sup and inf in <code>allRes</code> for each Psi in <code>allPsi</code>. If threshold is not NULL also contours the threshold level.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>


<h3>See Also</h3>

<p>plotBivariateProfiles
</p>

<hr>
<h2 id='prof_mean_var_Delta'>Profile extrema for the mean and variance functions of difference process</h2><span id='topic+prof_mean_var_Delta'></span>

<h3>Description</h3>

<p>The function prof_mean_var_Delta computes the profile extrema functions for the mean and variance functions of the difference process <code class="reqn">Z_x - \widetilde{Z}_x</code> at <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prof_mean_var_Delta(kmModel, simupoints, allPsi = NULL,
  options_full_sims = NULL, options_approx = NULL, F.mat = NULL,
  T.mat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prof_mean_var_Delta_+3A_kmmodel">kmModel</code></td>
<td>
<p>the <a href="DiceKriging.html#topic+km">km</a> model of the Gaussian process <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="prof_mean_var_Delta_+3A_simupoints">simupoints</code></td>
<td>
<p>the matrix <code class="reqn">l x d</code> containing the pilot points <code class="reqn">G</code>.</p>
</td></tr>
<tr><td><code id="prof_mean_var_Delta_+3A_allpsi">allPsi</code></td>
<td>
<p>optional list of matrices (dim <code class="reqn">pxd</code>) for which to compute the profile extrema. If NULL coordinate profiles are computed.</p>
</td></tr>
<tr><td><code id="prof_mean_var_Delta_+3A_options_full_sims">options_full_sims</code></td>
<td>
<p>an optional list of options for <a href="#topic+getAllMaxMin">getAllMaxMin</a>(or <a href="#topic+approxProfileExtrema">approxProfileExtrema</a> if <code>allPsi</code> not NULL). If NULL the full computations are not excuted. NOTE: this computations might be very expensive!</p>
</td></tr>
<tr><td><code id="prof_mean_var_Delta_+3A_options_approx">options_approx</code></td>
<td>
<p>an optional list of options for <a href="#topic+approxMaxMin">approxMaxMin</a> (or <a href="#topic+approxProfileExtrema">approxProfileExtrema</a> if <code>allPsi</code> not NULL).</p>
</td></tr>
<tr><td><code id="prof_mean_var_Delta_+3A_f.mat">F.mat</code></td>
<td>
<p>the evaluation of the trend function at <code>rbind(kmModel@X,simupoints)</code>, see <a href="stats.html#topic+model.matrix">model.matrix</a>, if <code>NULL</code> it is computed.</p>
</td></tr>
<tr><td><code id="prof_mean_var_Delta_+3A_t.mat">T.mat</code></td>
<td>
<p>the upper triangular factor of the Choleski decomposition of the covariance matrix of <code>rbind(kmModel@X,simupoints)</code>, if <code>NULL</code> it is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the profile extrema functions at <code>options_approx$design</code> for the mean and variance function of the difference process <code class="reqn">Z^\Delta = Z_x - \widetilde{Z}_x</code>.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='profExtrema'>profExtrema package</h2><span id='topic+profExtrema'></span><span id='topic+profExtrema-package'></span>

<h3>Description</h3>

<p>Computation and plots of profile extrema functions. The package main functions are: </p>

<dl>
<dt><strong>Computation:</strong></dt><dd> 
<ul>
<li> <p><code><a href="#topic+coordinateProfiles">coordinateProfiles</a></code>: Given a <a href="DiceKriging.html#topic+km">km</a> objects computes the coordinate profile extrema function for the posterior mean and its quantiles.
</p>
</li>
<li> <p><code><a href="#topic+coordProf_UQ">coordProf_UQ</a></code>: UQ part of <code>coordinateProfiles</code>.
</p>
</li>
<li> <p><code><a href="#topic+obliqueProfiles">obliqueProfiles</a></code>: Given a <a href="DiceKriging.html#topic+km">km</a> objects computes the profile extrema functions for a generic list of matrices Psi for the posterior mean and its quantiles.
</p>
</li>
<li> <p><code><a href="#topic+obliqueProf_UQ">obliqueProf_UQ</a></code>: The UQ part of <code>obliqueProfiles</code>.
</p>
</li>
<li> <p><code><a href="#topic+getAllMaxMin">getAllMaxMin</a></code>: computes coordinate profile extrema with full optimization for a deterministic function.
</p>
</li>
<li> <p><code><a href="#topic+approxMaxMin">approxMaxMin</a></code>: approximates coordinate profile extrema for a deterministic function.
</p>
</li>
<li> <p><code><a href="#topic+getProfileExtrema">getProfileExtrema</a></code>: computes profile extrema given a list of matrices Psi for a deterministic function.
</p>
</li>
<li> <p><code><a href="#topic+approxProfileExtrema">approxProfileExtrema</a></code>: approximates profile extrema given a list of matrices Psi for a deterministic function.
</p>
</li></ul>
 </dd>
<dt><strong>Plotting:</strong></dt><dd> 
<ul>
<li> <p><code><a href="#topic+plot_univariate_profiles_UQ">plot_univariate_profiles_UQ</a></code>: plots for the results of <code>coordProf_UQ</code> or <code>obliqueProf_UQ</code>. Note that this function only works for univariate profiles.
</p>
</li>
<li> <p><code><a href="#topic+plotBivariateProfiles">plotBivariateProfiles</a></code>: plots the bivariate maps results of a call to <code>obliqueProfiles</code> with a two dimensional projection matrix Psi.
</p>
</li>
<li> <p><code><a href="#topic+plotMaxMin">plotMaxMin</a></code>: simple plotting function for univariate profile extrema.
</p>
</li>
<li> <p><code><a href="#topic+plotOneBivProfile">plotOneBivProfile</a></code>: simple plotting function for bivariate profile extrema.
</p>
</li></ul>
  </dd>
</dl>



<h3>Details</h3>

<p>Package: profExtrema <br />
Type: Package <br />
Version: 0.2.1 <br />
Date: 2020-03-20
</p>


<h3>Note</h3>

<p>This work was supported in part the Hasler Foundation, grant number 16065 and by the Swiss National Science Foundation, grant number 167199. The author warmly thanks David Ginsbourger, Jrmy Rohmer and Dborah Idier for fruitful discussions and accurate, thought provoking suggestions.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti (dario.azzimonti@gmail.com) .
</p>


<h3>References</h3>

<p>Azzimonti, D., Bect, J., Chevalier, C., and Ginsbourger, D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850874.
</p>
<p>Azzimonti, D., Ginsbourger, D., Rohmer, J. and Idier, D. (2017+). Profile extrema for visualizing and quantifying uncertainties on excursion regions. Application to coastal flooding. arXiv:1710.00688.
</p>
<p>Chevalier, C. (2013). Fast uncertainty reduction strategies relying on Gaussian process models. PhD thesis, University of Bern.
</p>
<p>Chevalier, C., Picheny, V., Ginsbourger, D. (2014). An efficient and user-friendly implementation of batch-sequential inversion strategies based on kriging. Computational Statistics &amp; Data Analysis, 71: 1021-1034.
</p>
<p>Johnson, S. G.  The NLopt nonlinear-optimization package, http://ab-initio.mit.edu/nlopt
</p>
<p>Koenker, R. (2017). quantreg: Quantile Regression. R package version 5.33.
</p>
<p>Nocedal, J. and Wright, S. J. (2006). Numerical Optimization, second edition. Springer- Verlag, New York.
</p>
<p>Neuwirth, E. (2014). RColorBrewer: ColorBrewer Palettes. R package version 1.1-2.
</p>
<p>Roustant, O., Ginsbourger, D., Deville, Y. (2012). DiceKriging, DiceOptim: Two R Packages for the Analysis of Computer Experiments by Kriging-Based Metamodeling and Optimization. Journal of Statistical Software, 51(1): 1-55.
</p>

<hr>
<h2 id='setPlotOptions'>Set-up the plot options when NULL</h2><span id='topic+setPlotOptions'></span>

<h3>Description</h3>

<p>Function to set-up plot options for <a href="#topic+plot_univariate_profiles_UQ">plot_univariate_profiles_UQ</a>, <a href="#topic+plotBivariateProfiles">plotBivariateProfiles</a>, <a href="#topic+coordinateProfiles">coordinateProfiles</a>, <a href="#topic+coordProf_UQ">coordProf_UQ</a>, <a href="#topic+obliqueProfiles">obliqueProfiles</a> and <a href="#topic+obliqueProf_UQ">obliqueProf_UQ</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPlotOptions(plot_options = NULL, d, num_T, kmModel = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPlotOptions_+3A_plot_options">plot_options</code></td>
<td>
<p>the list of plot options to set-up</p>
</td></tr>
<tr><td><code id="setPlotOptions_+3A_d">d</code></td>
<td>
<p>number of coordinates</p>
</td></tr>
<tr><td><code id="setPlotOptions_+3A_num_t">num_T</code></td>
<td>
<p>number of thresholds of interest</p>
</td></tr>
<tr><td><code id="setPlotOptions_+3A_kmmodel">kmModel</code></td>
<td>
<p>a <a href="DiceKriging.html#topic+km">km</a> model, used to obtain the coordinates names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the properly set-up list containing the following fields </p>

<ul>
<li><p><code>save:</code>boolean, if TRUE saves the plots in <code>folderPlots</code>
</p>
</li>
<li><p><code>folderPlots:</code>a string containing the destination folder for plots, if <code>save==TRUE</code> default is <code>./</code>
</p>
</li>
<li><p><code>ylim:</code>a matrix <code>coord</code>x2 containing the ylim for each coordinate, if NULL in <code>plot_options</code> this is left NULL and automatically set at the plot time.
</p>
</li>
<li><p><code>titleProf:</code>a string containing the title for the coordinate profile plots, default is <code>"Coordinate profiles"</code>
</p>
</li>
<li><p><code>title2d:</code>a string containing the title for the 2d plots (if the input is 2d), default is <code>"Posterior mean"</code>
</p>
</li>
<li><p><code>design:</code>a <code class="reqn">dxr</code> matrix where <code class="reqn">d</code> is the input dimension and <code class="reqn">r</code> is the size of the discretization for plots at each dimension
</p>
</li>
<li><p><code>coord_names:</code>a <code class="reqn">d</code>-vector of characters naming the dimensions. If NULL and <code>kmModel</code> not NULL then it is the names of <code>kmModel@X</code> otherwise <code>x_1,...,x_d</code>
</p>
</li>
<li><p><code>id_save:</code>a string to be added to the plot file names, useful for serial computations on HPC, left as in <code>plot_options</code>.
</p>
</li>
<li><p><code>qq_fill:</code>if TRUE it fills the region between the first 2 quantiles in <code>quantiles_uq</code> and between the upper and lower bound in <code>objectUQ$bound$bound</code>, if <code>NULL</code>, it is set as <code>FALSE</code>.
</p>
</li>
<li><p><code>bound_cols:</code>a vector of two strings containing the names of the colors for upper and lower bound plots.
</p>
</li>
<li><p><code>qq_fill_colors:</code>a list containing the colors for qq_fill: <code>approx</code> for 2 quantiles, <code>bound_min</code> for bounds on the profile inf, <code>bound_max</code> for profile sup. Initialized only if <code>qq_fill==TRUE</code>.
</p>
</li>
<li><p><code>col_CCPthresh_nev:</code>Color palette of dimension <code>num_T</code> for the colors of the vertical lines delimiting the intersections between the profiles sup and the thresholds
</p>
</li>
<li><p><code>col_CCPthresh_alw:</code>Color palette of dimension <code>num_T</code> for the colors of the vertical lines delimiting the intersections between the profiles inf and the thresholds
</p>
</li>
<li><p><code>col_thresh:</code>Color palette of dimension <code>num_T</code> for the colors of the thresholds
</p>
</li>
<li><p><code>fun_evals:</code>integer denoting the level of plot for the true evaluations. </p>

<ul>
<li><p>0: default, no plots for true evaluations;
</p>
</li>
<li><p>1: plot the true evaluations as points in 2d plots, no true evaluation plots in 1d;
</p>
</li>
<li><p>2: plot true evaluations, in 2d with different color for values above threshold;
</p>
</li>
<li><p>3: plot true evaluations, in 2d plots in color, with background of the image colored as proportion of points inside excursion; </p>
</li></ul>

</li></ul>

<p>if all the fields are already filled then returns <code>plot_options</code>
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

<hr>
<h2 id='var_Delta_T'>Variance function of difference process</h2><span id='topic+var_Delta_T'></span>

<h3>Description</h3>

<p>The function var_Delta_T computes the gradient for the variance function of the difference process <code class="reqn">Z_x - \widetilde{Z}_x</code> at <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_Delta_T(x, kmModel, simupoints, T.mat, F.mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_Delta_T_+3A_x">x</code></td>
<td>
<p>a matrix <code class="reqn">r x d</code> containing the <code class="reqn">r</code> points where the function is to be computed.</p>
</td></tr>
<tr><td><code id="var_Delta_T_+3A_kmmodel">kmModel</code></td>
<td>
<p>the <a href="DiceKriging.html#topic+km">km</a> model of the Gaussian process <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="var_Delta_T_+3A_simupoints">simupoints</code></td>
<td>
<p>the matrix <code class="reqn">l x d</code> containing the pilot points <code class="reqn">G</code>.</p>
</td></tr>
<tr><td><code id="var_Delta_T_+3A_t.mat">T.mat</code></td>
<td>
<p>the upper triangular factor of the Choleski decomposition of the covariance matrix of <code>rbind(kmModel@X,simupoints)</code></p>
</td></tr>
<tr><td><code id="var_Delta_T_+3A_f.mat">F.mat</code></td>
<td>
<p>the evaluation of the trend function at <code>rbind(kmModel@X,simupoints)</code>, see <a href="stats.html#topic+model.matrix">model.matrix</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the variance function at <code>x</code> for the difference process <code class="reqn">Z^\Delta = Z_x - \widetilde{Z}_x</code>.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
