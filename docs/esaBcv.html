<!DOCTYPE html><html><head><title>Help for package esaBcv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {esaBcv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ESA'><p>Estimate Latent Factor Matrix With Known Number of Factors</p></a></li>
<li><a href='#EsaBcv'><p>Estimate Latent Factor Matrix</p></a></li>
<li><a href='#esaBcv_package'><p>esaBcv</p></a></li>
<li><a href='#plot.esabcv'><p>Plot Bi-cross-validation(BCV) Errors</p></a></li>
<li><a href='#simdat'><p>Example Dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Estimate Number of Latent Factors and Factor Matrix for Factor
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>These functions estimate the latent factors of a given matrix, no matter it is high-dimensional or not. It tries to first estimate the number of factors using bi-cross-validation and then estimate the latent factor matrix and the noise variances. For more information about the method, see Art B. Owen and Jingshu Wang 2015 archived article on factor model (&lt;<a href="https://arxiv.org/abs/1503.03515">arXiv:1503.03515</a>&gt;). </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>corpcor, svd</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-30 10:10:19 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>Art B. Owen [aut],
  Jingshu Wang [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jingshu Wang &lt;wangjingshususan@gmail.com&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-30 10:29:27 UTC</td>
</tr>
</table>
<hr>
<h2 id='ESA'>Estimate Latent Factor Matrix With Known Number of Factors</h2><span id='topic+ESA'></span>

<h3>Description</h3>

<p>Estimate the latent factor matrix and noise variance using early stopping
alternation (ESA) given the number of factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ESA(Y, r, X = NULL, center = F, niter = 3, svd.method = "fast")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ESA_+3A_y">Y</code></td>
<td>
<p>observed data matrix. p is the number of variables and
n is the sample size. Dimension is <code>c(n, p)</code></p>
</td></tr>
<tr><td><code id="ESA_+3A_r">r</code></td>
<td>
<p>The number of factors to use</p>
</td></tr>
<tr><td><code id="ESA_+3A_x">X</code></td>
<td>
<p>the known predictors of size <code>c(n, k)</code> if any. Default is NULL (no known predictors).
<code>k</code> is the number of known covariates.</p>
</td></tr>
<tr><td><code id="ESA_+3A_center">center</code></td>
<td>
<p>logical, whether to add an intercept term in the model.
Default is False.</p>
</td></tr>
<tr><td><code id="ESA_+3A_niter">niter</code></td>
<td>
<p>the number of iterations for ESA. Default is 3.</p>
</td></tr>
<tr><td><code id="ESA_+3A_svd.method">svd.method</code></td>
<td>
<p>either &quot;fast&quot;, &quot;propack&quot; or &quot;standard&quot;.
&quot;fast&quot; is using the <code><a href="corpcor.html#topic+fast.svd">fast.svd</a></code> function in package corpcor to compute SVD, &quot;propack&quot; is using the <code><a href="svd.html#topic+propack.svd">propack.svd</a></code> to compute SVD and &quot;standard&quot;
is using the <code><a href="base.html#topic+svd">svd</a></code> function in the base package. Because of PROPACK
issues, &quot;propack&quot; fails for some matrices, and when that happens,
the function will use &quot;fast&quot; to
compute the SVD of that matrix instead. Default method is &quot;fast&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model used is
</p>
<p style="text-align: center;"><code class="reqn">Y = 1 \mu' + X \beta + n^{1/2}U D V' + E \Sigma^{1/2}</code>
</p>

<p>where <code class="reqn">D</code> and <code class="reqn">\Sigma</code> are diagonal matrices, <code class="reqn">U</code> and <code class="reqn">V</code>
are orthogonal and <code class="reqn">\mu'</code>
and <code class="reqn">V'</code> mean _mu transposed_ and _V transposed_ respectively.
The entries of <code class="reqn">E</code> are assumed to be i.i.d. standard Gaussian.
The model assumes heteroscedastic noises and especially works well for
high-dimensional data. The method is based on Owen and Wang (2015). Notice that
when nonnull <code>X</code> is given or centering the data is required (which is essentially
adding a known covariate with all <code class="reqn">1</code>), for identifiability, it's required that
<code class="reqn">&lt;X, U&gt; = 0</code> or <code class="reqn">&lt;1, U&gt; = 0</code> respectively. Then the method will first make a rotation
of the data matrix to remove the known predictors or centers, and then use
the latter <code>n - k</code> (or <code>n - k - 1</code> if centering is required) samples to
estimate the latent factors.
</p>


<h3>Value</h3>

<p>The returned value is a list with components
</p>
<table>
<tr><td><code>estSigma</code></td>
<td>
<p>the diagonal entries of estimated <code class="reqn">\Sigma</code>
which is a vector of length <code>p</code></p>
</td></tr>
<tr><td><code>estU</code></td>
<td>
<p>the estimated <code class="reqn">U</code>. Dimension <code>c(n, r)</code></p>
</td></tr>
<tr><td><code>estD</code></td>
<td>
<p>the estimated diagonal entries of <code class="reqn">D</code>
which is a vector of length <code>r</code></p>
</td></tr>
<tr><td><code>estV</code></td>
<td>
<p>the estimated <code class="reqn">V</code>. Dimension is <code>c(p, r)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the estimated <code class="reqn">beta</code> which is a matrix of size <code>c(k, p)</code>.
Return NULL if the argument <code>X</code> is NULL.</p>
</td></tr>
<tr><td><code>estS</code></td>
<td>
<p>the estimated signal (factor) matrix <code class="reqn">S</code> where
</p>
<p style="text-align: center;"><code class="reqn">S = 1 \mu' + X \beta + n^{1/2}U D V'</code>
</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the sample centers of each variable which is a vector of length
<code>p</code>. It's an estimate of <code class="reqn">\mu</code>. Return
NULL if the argument <code>center</code> is False.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Art B. Owen and Jingshu Wang(2015), Bi-cross-validation for factor analysis,
<a href="http://arxiv.org/abs/1503.03515">http://arxiv.org/abs/1503.03515</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- matrix(rnorm(100), nrow = 10) + 3 * rnorm(10) %*% t(rep(1, 10))
ESA(Y, 1)
</code></pre>

<hr>
<h2 id='EsaBcv'>Estimate Latent Factor Matrix</h2><span id='topic+EsaBcv'></span>

<h3>Description</h3>

<p>Find out the best number of factors using Bi-Cross-Validation (BCV) with
Early-Stopping-Alternation (ESA) and then estimate the factor matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EsaBcv(Y, X = NULL, r.limit = 20, niter = 3, nRepeat = 12, only.r = F,
  svd.method = "fast", center = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EsaBcv_+3A_y">Y</code></td>
<td>
<p>observed data matrix. p is the number of variables and
n is the sample size. Dimension is <code>c(n, p)</code></p>
</td></tr>
<tr><td><code id="EsaBcv_+3A_x">X</code></td>
<td>
<p>the known predictors of size <code>c(n, k)</code> if any. Default is NULL (no known predictors).
<code>k</code> is the number of known covariates.</p>
</td></tr>
<tr><td><code id="EsaBcv_+3A_r.limit">r.limit</code></td>
<td>
<p>the maximum number of factor to try. Default is 20.
Can be set to Inf.</p>
</td></tr>
<tr><td><code id="EsaBcv_+3A_niter">niter</code></td>
<td>
<p>the number of iterations for ESA. Default is 3.</p>
</td></tr>
<tr><td><code id="EsaBcv_+3A_nrepeat">nRepeat</code></td>
<td>
<p>number of repeats of BCV. In other words, the random partition of <code class="reqn">Y</code>
will be repeated for <code>nRepeat</code> times. Default is 12.</p>
</td></tr>
<tr><td><code id="EsaBcv_+3A_only.r">only.r</code></td>
<td>
<p>whether only to estimate and return the number of factors.</p>
</td></tr>
<tr><td><code id="EsaBcv_+3A_svd.method">svd.method</code></td>
<td>
<p>either &quot;fast&quot;, &quot;propack&quot; or &quot;standard&quot;.
&quot;fast&quot; is using the <code><a href="corpcor.html#topic+fast.svd">fast.svd</a></code> function in package corpcor to compute SVD, &quot;propack&quot; is using the <code><a href="svd.html#topic+propack.svd">propack.svd</a></code> to compute SVD and &quot;standard&quot;
is using the <code><a href="base.html#topic+svd">svd</a></code> function in the base package. Because of PROPACK
issues, &quot;propack&quot; fails for some matrices, and when that happens,
the function will use &quot;fast&quot; to
compute the SVD of that matrix instead. Default method is &quot;fast&quot;.</p>
</td></tr>
<tr><td><code id="EsaBcv_+3A_center">center</code></td>
<td>
<p>logical, whether to add an intercept term in the model.
Default is False.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is
</p>
<p style="text-align: center;"><code class="reqn">Y = 1 \mu' + X \beta + n^{1/2}U D V' + E \Sigma^{1/2}</code>
</p>

<p>where <code class="reqn">D</code> and <code class="reqn">\Sigma</code> are diagonal matrices, <code class="reqn">U</code> and <code class="reqn">V</code>
are orthogonal and <code class="reqn">mu'</code>
and <code class="reqn">V'</code> represent _mu transposed_ and _V transposed_ respectively.
The entries of <code class="reqn">E</code> are assumed to be i.i.d. standard Gaussian.
The model assumes heteroscedastic noises and especially works well for
high-dimensional data. The method is based on Owen and Wang (2015).  Notice that
when nonnull <code>X</code> is given or centering the data is required (which is essentially
adding a known covariate with all <code class="reqn">1</code>), for identifiability, it's required that
<code class="reqn">&lt;X, U&gt; = 0</code> or <code class="reqn">&lt;1, U&gt; = 0</code> respectively. Then the method will first make a rotation
of the data matrix to remove the known predictors or centers, and then use
the latter <code>n - k</code> (or <code>n - k - 1</code> if centering is required) samples to
estimate the latent factors. The rotation idea first appears in Sun et.al. (2012).
</p>


<h3>Value</h3>

<p><code>EsaBcv</code> returns an obejct of <code><a href="base.html#topic+class">class</a></code> &quot;esabcv&quot;
The function <code>plot</code> plots the cross-validation results and points out the
number of factors estimated
An object of class &quot;esabcv&quot; is a list containing the following components:
</p>
<table>
<tr><td><code>best.r</code></td>
<td>
<p>the best number of factor estimated</p>
</td></tr>
<tr><td><code>estSigma</code></td>
<td>
<p>the diagonal entries of estimated <code class="reqn">\Sigma</code>
which is a vector of length <code>p</code></p>
</td></tr>
<tr><td><code>estU</code></td>
<td>
<p>the estimated <code class="reqn">U</code>. Dimension is <code>c(n, r)</code></p>
</td></tr>
<tr><td><code>estD</code></td>
<td>
<p>the estimated diagonal entries of <code class="reqn">D</code>
which is a vector of length <code>r</code></p>
</td></tr>
<tr><td><code>estV</code></td>
<td>
<p>the estimated <code class="reqn">V</code>. Dimension is <code>c(p, r)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the estimated <code class="reqn">\beta</code> which is a matrix of size <code>c(k, p)</code>.
Return NULL if the argument <code>X</code> is NULL.</p>
</td></tr>
<tr><td><code>estS</code></td>
<td>
<p>the estimated signal(factor) matrix <code class="reqn">S</code> where
</p>
<p style="text-align: center;"><code class="reqn">S = 1 \mu' + X \beta + n^{1/2}U D V'</code>
</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the sample centers of each variable which is a vector of length
<code>p</code>. It's an estimate of <code class="reqn">\mu</code>. Return
NULL if the argument <code>center</code> is False.</p>
</td></tr>
<tr><td><code>max.r</code></td>
<td>
<p>the actual maximum number of factors used. For the details of how this is decided,
please refer to Owen and Wang (2015)</p>
</td></tr>
<tr><td><code>result.list</code></td>
<td>
<p>a matrix with dimension <code>c(nRepeat, (max.r + 1))</code> storing
the detailed BCV entrywise MSE of each repeat for r from 0 to <code>max.r</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Art B. Owen and Jingshu Wang(2015), Bi-cross-validation for factor analysis,
<a href="http://arxiv.org/abs/1503.03515">http://arxiv.org/abs/1503.03515</a>
</p>
<p>Yunting Sun, Nancy R. Zhang and Art B. Owen, Multiple hypothesis testing adjusted for latent variables, with an application to the AGEMAP gene expression data. The Annuals of Applied Statistics, 6(4): 1664-1688, 2012
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ESA">ESA</a></code>, <code><a href="#topic+plot.esabcv">plot.esabcv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- matrix(rnorm(100), nrow = 10)
EsaBcv(Y)
</code></pre>

<hr>
<h2 id='esaBcv_package'>esaBcv</h2><span id='topic+esaBcv_package'></span><span id='topic+esaBcv_package-package'></span>

<h3>Description</h3>

<p>The esaBcv package provides functions to estimate the latent factors of a given
matrix, no matter it is high-dimensional or not. It tries to first estimate the
number of factors using Bi-cross-validation and then estimate the latent factor
matrix and the noise variances using an Early-stopping-alternation method.
The method is proposed by Art B. Owen and Jingshu Wang (2015).
</p>


<h3>Author(s)</h3>

<p>Maintainer: Jingshu Wang &lt;wangjingshususan@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>Owen and Wang (2015) Bi-cross-validation for factor analysis,
<a href="http://arxiv.org/abs/1503.03515">http://arxiv.org/abs/1503.03515</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(simdat)
result &lt;- EsaBcv(simdat$Y)
plot(result)


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.esabcv'>Plot Bi-cross-validation(BCV) Errors</h2><span id='topic+plot.esabcv'></span>

<h3>Description</h3>

<p>Plot the average BCV entrywise MSE against the number of factors tried,
with error bars and the best number of factors picked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'esabcv'
plot(x, start.r = 0, end.r = NA,
  xlab = "Number of Factors", ylab = "BCV MSE",
  main = "Bi-cross-validation Error", col.line = "BLUE", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.esabcv_+3A_x">x</code></td>
<td>
<p><code>esabcv</code> object, typically result of <code><a href="#topic+EsaBcv">EsaBcv</a></code>.</p>
</td></tr>
<tr><td><code id="plot.esabcv_+3A_start.r">start.r</code></td>
<td>
<p>the starting number of factors to display in the plot.</p>
</td></tr>
<tr><td><code id="plot.esabcv_+3A_end.r">end.r</code></td>
<td>
<p>the largest number of factors allowed to display in the plot.
Default is NA, which means to make <code>end.r</code> as <code>max.r</code>.</p>
</td></tr>
<tr><td><code id="plot.esabcv_+3A_xlab">xlab</code></td>
<td>
<p>title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.esabcv_+3A_ylab">ylab</code></td>
<td>
<p>title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.esabcv_+3A_main">main</code></td>
<td>
<p>title for the plot.</p>
</td></tr>
<tr><td><code id="plot.esabcv_+3A_col.line">col.line</code></td>
<td>
<p>the line color.</p>
</td></tr>
<tr><td><code id="plot.esabcv_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>esabcv</code> object contains the raw BCV result <code>result.list</code>,
which is a matrix with dimension <code>c(nRepeat, (max.r + 1))</code> where <code>nRepeat</code>
is the number of BCV repeats and <code>max.r</code> is the maximum number of factors tried.
If either tail of the error curve dominates, then the user has the option to change the start
and end rank for plotting.
</p>


<h3>Value</h3>

<p>A plot ploting the average BCV entrywise MSE against the number of
factors tried (start.r to <code>max.r + 1</code>), with error bars (one standard deviation)
in grey and selected number of factors marked by a red crossing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(simdat)
result &lt;- EsaBcv(simdat$Y)
plot(result)
plot(result, start.r = 1)


## End(Not run)
</code></pre>

<hr>
<h2 id='simdat'>Example Dataset</h2><span id='topic+simdat'></span>

<h3>Description</h3>

<p>The data is a simulated data set where the data matrix is generated from the latent
factor model
</p>
<p style="text-align: center;"><code class="reqn">Y = n^{1/2}U D V' + E \Sigma^{1/2}</code>
</p>

<p>where <code class="reqn">D</code> and <code class="reqn">\Sigma</code> are diagonal matrices, and <code class="reqn">U</code> and <code class="reqn">V</code>
are orthogonal. <code class="reqn">V'</code> means _V transposed_. For the factors, we include one giant
factor, five useful factors, one harmful factor and one undetectable factor.
For more details of the simulation method
used, please refer to Appendix A.1 of Owen and Wang (2015) Bi-cross-validation for factor analysis, <a href="http://arxiv.org/abs/1503.03515">http://arxiv.org/abs/1503.03515</a>.
</p>


<h3>Details</h3>

<p>The dataset is a list of components:
</p>

<ul>
<li><p><code>Y</code> a data matrix of 200 by 1000, where each row is a sample and each column
is a variable
</p>
</li>
<li><p><code>U</code> the orthogonal factor matrix <code class="reqn">U</code> of size 200 by 8.
</p>
</li>
<li><p><code>V</code> the orthogonal factor matrix <code class="reqn">V</code> of size 1000 by 8.
</p>
</li>
<li><p><code>D</code> the vector of diagonal entries of <code class="reqn">D</code>.
</p>
</li>
<li><p><code>Sigma</code> the vector of diagonal entries of <code class="reqn">\Sigma</code>.
</p>
</li>
<li><p><code>oracle.r</code> the oracle rank (the optimal number of factors that should be kept)
of the factor matrix.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
