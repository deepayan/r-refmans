<!DOCTYPE html><html><head><title>Help for package RaceID</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RaceID}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#barplotgene'><p>Gene Expression Barplot</p></a></li>
<li><a href='#baseLineVar'><p>Baseline gene expression variability</p></a></li>
<li><a href='#branchcells'><p>Differential Gene Expression between Links</p></a></li>
<li><a href='#calcAlphaG'><p>Function for calculating an aggregated dispersion parameter</p></a></li>
<li><a href='#calcVar'><p>Function for calculating total variance from VarID fit</p></a></li>
<li><a href='#calcVarFit'><p>Function for calculating the total variance fit</p></a></li>
<li><a href='#cc_genes'><p>Cell cycle markers for Mus Muscuus</p></a></li>
<li><a href='#CCcorrect'><p>Dimensional Reduction by PCA or ICA</p></a></li>
<li><a href='#cellsfromtree'><p>Extract Cells on Differentiation Trajectory</p></a></li>
<li><a href='#cleanNN'><p>Function for pruning k-nearest neighborhoods based on neighborhood overlap</p></a></li>
<li><a href='#clustdiffgenes'><p>Inference of differentially expressed genes in a cluster</p></a></li>
<li><a href='#clustexp'><p>Clustering of single-cell transcriptome data</p></a></li>
<li><a href='#clustheatmap'><p>Plotting a Heatmap of the Distance Matrix</p></a></li>
<li><a href='#compdist'><p>Computing a distance matrix for cell type inference</p></a></li>
<li><a href='#compentropy'><p>Compute transcriptome entropy of each cell</p></a></li>
<li><a href='#compfr'><p>Computation of a two dimensional Fruchterman-Rheingold representation</p></a></li>
<li><a href='#compMean'><p>Function for computing local gene expression averages</p></a></li>
<li><a href='#compmedoids'><p>Computes Medoids from a Clustering Partition</p></a></li>
<li><a href='#compNoise'><p>Function for computing local gene expression variability</p></a></li>
<li><a href='#comppvalue'><p>Computing P-values for Link Significance</p></a></li>
<li><a href='#compscore'><p>Compute StemID2 score</p></a></li>
<li><a href='#compTBNoise'><p>Function for fitting a negative binomial noise model of technical and biological variability across cells in pruned k-nearest neighbourhoods.</p></a></li>
<li><a href='#comptsne'><p>Computation of a two dimensional t-SNE representation</p></a></li>
<li><a href='#compumap'><p>Computation of a two dimensional umap representation</p></a></li>
<li><a href='#corrVar'><p>Function for regressing out the mean-variance dependence.</p>
This function corrects for the systematic dependence of the variance on the mean by a local regression.</a></li>
<li><a href='#createKnnMatrix'><p>Function to create a knn matrix</p></a></li>
<li><a href='#diffexpnb'><p>Function for differential expression analysis</p></a></li>
<li><a href='#diffgenes'><p>Compute Expression Differences between Clusters</p></a></li>
<li><a href='#diffNoisyGenes'><p>Function for extracting genes with elevated variability in a cluster</p></a></li>
<li><a href='#diffNoisyGenesTB'><p>Function for extracting genes with differential biological variability in a cluster</p></a></li>
<li><a href='#extractCounts'><p>Function for filtering count data</p></a></li>
<li><a href='#filterdata'><p>Data filtering</p></a></li>
<li><a href='#findoutliers'><p>Inference of outlier cells and final clustering</p></a></li>
<li><a href='#fitBackVar'><p>Function for computing a background model of gene expression variability</p></a></li>
<li><a href='#fitGammaRt'><p>Fitting a Gamma distribution to global cell-to-cell variability</p></a></li>
<li><a href='#fitLogVarLogMean'><p>Second order polynomial fit of mean-variance dependence</p>
This function corrects for the systematic dependence of the variance on the mean by a local regression.</a></li>
<li><a href='#fitNBtb'><p>Function for fitting a negative binomial noise model of technical and biological variability</p></a></li>
<li><a href='#fitNBtbCl'><p>Function for fitting a negative binomial noise model of technical and biological variability</p></a></li>
<li><a href='#fractDotPlot'><p>Dotplot of gene expression across clusters or samples</p></a></li>
<li><a href='#getExpData'><p>Function for extracting a filtered expression matrix from a <span class="pkg">RaceID</span> <code>SCseq</code> object</p></a></li>
<li><a href='#getfdata'><p>Extracting filtered expression data</p></a></li>
<li><a href='#getFilteredCounts'><p>Function for filtering count data</p></a></li>
<li><a href='#getNode'><p>Extract all genes for a module in a FateID self-orgaizing map</p></a></li>
<li><a href='#getproj'><p>Extract Projections of all Cells from a Cluster</p></a></li>
<li><a href='#graphCluster'><p>Function for infering clustering of the pruned k nearest neighbour graph</p></a></li>
<li><a href='#imputeexp'><p>Imputed expression matrix</p></a></li>
<li><a href='#inspectKNN'><p>Function for inspecting pruned k-nearest neighbourhoods</p></a></li>
<li><a href='#intestinalData'><p>Single-cell transcriptome data of intestinal epithelial cells</p></a></li>
<li><a href='#intestinalDataSmall'><p>Single-cell transcriptome data of intestinal epithelial cells</p></a></li>
<li><a href='#lineagegraph'><p>Inference of a Lineage Graph</p></a></li>
<li><a href='#Ltree-class'><p>The Ltree Class</p></a></li>
<li><a href='#maxNoisyGenes'><p>Function for extracting genes maximal variability</p></a></li>
<li><a href='#maxNoisyGenesTB'><p>Function for extracting genes maximal variability</p></a></li>
<li><a href='#noiseBaseFit'><p>Function for computing a fit to the baseline of gene expression variability</p></a></li>
<li><a href='#plotB'><p>Boxplots for features across clusters</p></a></li>
<li><a href='#plotbackground'><p>Plot Background Model</p></a></li>
<li><a href='#plotBackVar'><p>Function for plottinhg the background model of gene expression variability</p></a></li>
<li><a href='#plotdiffgenes'><p>Barplot of differentially expressed genes</p></a></li>
<li><a href='#plotdiffgenesnb'><p>Function for plotting differentially expressed genes</p></a></li>
<li><a href='#plotDiffNoise'><p>Function for plotting differentially variable genes</p></a></li>
<li><a href='#plotdimsat'><p>Plotting the Saturation of Explained Variance</p></a></li>
<li><a href='#plotdistanceratio'><p>Histogram of Cell-to-Cell Distances in Real versus Embedded Space</p></a></li>
<li><a href='#plotexpmap'><p>Highlighting gene expression in a dimensional reduction representation</p></a></li>
<li><a href='#plotExpNoise'><p>Noise-expression scatter plot</p></a></li>
<li><a href='#plotfeatmap'><p>Highlighting feature values in a dimensional reduction representation</p></a></li>
<li><a href='#plotgraph'><p>StemID2 Lineage Graph</p></a></li>
<li><a href='#plotjaccard'><p>Plot Jaccard Similarities</p></a></li>
<li><a href='#plotlabelsmap'><p>Plot labels in a dimensional reduction representation</p></a></li>
<li><a href='#plotlinkpv'><p>Heatmap of Link P-values</p></a></li>
<li><a href='#plotlinkscore'><p>Heatmap of Link Scores</p></a></li>
<li><a href='#plotmap'><p>Plotting a dimensional reduction representation</p></a></li>
<li><a href='#plotmarkergenes'><p>Plotting a Heatmap of Marker Gene Expression</p></a></li>
<li><a href='#plotMV'><p>Plot of Mean-Variance dependence and various fits</p></a></li>
<li><a href='#plotNoiseModel'><p>Function for plotting the baseline model of gene expression variability</p></a></li>
<li><a href='#plotoutlierprobs'><p>Plot Outlier Probabilities</p></a></li>
<li><a href='#plotPC'><p>Function to plot the selected number of principal components</p></a></li>
<li><a href='#plotPearsonRes'><p>Function for plotting the variance of Pearson residuals</p></a></li>
<li><a href='#plotPP'><p>Plotting function for posterior checks</p></a></li>
<li><a href='#plotPT'><p>Plotting pseudo-time in dimensional reduction representation</p></a></li>
<li><a href='#plotQQ'><p>Scatter plot of two noise-related quantaties of local pruned k-nearest neighbourhoods</p></a></li>
<li><a href='#plotQuantMap'><p>Plotting noise-related quantaties of local pruned k-nearest neighbourhoods</p></a></li>
<li><a href='#plotRegNB'><p>Function for plotting negative binomial regression</p></a></li>
<li><a href='#plotsaturation'><p>Plot Saturation of Within-Cluster Dispersion</p></a></li>
<li><a href='#plotsensitivity'><p>Plot Sensitivity</p></a></li>
<li><a href='#plotsilhouette'><p>Plot Cluster Silhouette</p></a></li>
<li><a href='#plotspantree'><p>Minimum Spanning Tree of RaceID3 clusters</p></a></li>
<li><a href='#plotsymbolsmap'><p>Plotting groups as different symbols in a dimensional reduction representation</p></a></li>
<li><a href='#plotTrProbs'><p>Function for plotting transition probabilities between clusters</p></a></li>
<li><a href='#plotUMINoise'><p>Plotting noise dependence on total UMI count</p></a></li>
<li><a href='#postfntb'><p>Posterior probability</p></a></li>
<li><a href='#priorfn'><p>Prior function for maximum a posterior inference</p></a></li>
<li><a href='#projback'><p>Compute Cell Projections for Randomized Background Distribution</p></a></li>
<li><a href='#projcells'><p>Compute transcriptome entropy of each cell</p></a></li>
<li><a href='#projenrichment'><p>Enrichment of cells on inter-cluster links</p></a></li>
<li><a href='#pruneKnn'><p>Function inferring a pruned knn matrix</p></a></li>
<li><a href='#pseudoTime'><p>Extract pseudo-time order of cells along a trajectory</p></a></li>
<li><a href='#quantKnn'><p>Noise-related quantaties of local pruned k-nearest neighbourhoods</p></a></li>
<li><a href='#RaceID-package'>
<p>Identification of Cell Types, Inference of Lineage Trees, and Prediction of Noise Dynamics from Single-Cell RNA-Seq Data</p></a></li>
<li><a href='#rcpp_hello_world'>
<p>Simple function using Rcpp</p></a></li>
<li><a href='#rfcorrect'><p>Random Forests-based Reclassification</p></a></li>
<li><a href='#SCseq'><p>The SCseq Class</p></a></li>
<li><a href='#Seurat2SCseq'><p>Converting a Seurat object to a RaceID/VarID object</p></a></li>
<li><a href='#testPrior'><p>Posterior check of the model</p></a></li>
<li><a href='#transitionProbs'><p>Function for the computation of transition probabilities between clusters</p></a></li>
<li><a href='#updateSC'><p>Function for updating a RaceID SCseq object with VarID results</p></a></li>
<li><a href='#varRegression'><p>Linear Regression of Sources of Variability</p></a></li>
<li><a href='#violinMarkerPlot'><p>Violin plot of marker gene expression or noise</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Identification of Cell Types, Inference of Lineage Trees, and
Prediction of Noise Dynamics from Single-Cell RNA-Seq Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Dominic Grün &lt;dominic.gruen@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominic Grün &lt;dominic.gruen@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Application of 'RaceID' allows inference of cell types and prediction of lineage trees by the 'StemID2' algorithm (Herman, J.S., Sagar, Grun D. (2018) &lt;<a href="https://doi.org/10.1038%2Fnmeth.4662">doi:10.1038/nmeth.4662</a>&gt;). 'VarID2' is part of this package and allows quantification of biological gene expression noise at single-cell resolution (Rosales-Alvarez, R.E., Rettkowski, J., Herman, J.S., Dumbovic, G., Cabezas-Wallscheid, N., Grun, D. (2023) &lt;<a href="https://doi.org/10.1186%2Fs13059-023-02974-1">doi:10.1186/s13059-023-02974-1</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coop, compiler, cluster, FateID, FNN, fpc, ggplot2, grDevices,
harmony, ica, igraph, irlba, leiden, locfit, methods, MASS,
Matrix, matrixStats, parallel, pheatmap, princurve, quadprog,
randomForest, runner, Rcpp, RColorBrewer, Rtsne, umap, vegan</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>batchelor, DESeq2, knitr, rmarkdown, SingleCellExperiment,
slingshot, SummarizedExperiment</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-03 21:25:45 UTC; d.grun</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-03 23:33:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='barplotgene'>Gene Expression Barplot</h2><span id='topic+barplotgene'></span>

<h3>Description</h3>

<p>This functions generates a barplot of gene expression across all clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barplotgene(object, g, n = NULL, logsc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barplotgene_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="barplotgene_+3A_g">g</code></td>
<td>
<p>Individual gene name or vector with a group of gene names corresponding to a subset of valid row names of the <code>ndata</code> slot
of the <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="barplotgene_+3A_n">n</code></td>
<td>
<p>String of characters representing the title of the plot. Default is <code>NULL</code> and the first element of <code>g</code> is chosen.</p>
</td></tr>
<tr><td><code id="barplotgene_+3A_logsc">logsc</code></td>
<td>
<p>logical. If <code>TRUE</code>, then gene expression values are log2-transformed after adding a pseudo-count of 0.1. Default is <code>FALSE</code>
and untransformed values are shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='baseLineVar'>Baseline gene expression variability</h2><span id='topic+baseLineVar'></span>

<h3>Description</h3>

<p>This function returns the base line variability as a function of the
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseLineVar(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseLineVar_+3A_x">x</code></td>
<td>
<p>mean expression. The corresponding corrected variance is returned.</p>
</td></tr>
<tr><td><code id="baseLineVar_+3A_y">y</code></td>
<td>
<p>object returned by <code>compNoise</code>, <code>noiseBaseFit</code>, <code>pruneKnn</code>  or <code>fitBackVar</code>. Depending on the input the funtion returns either
the background variability (for <code>pruneKnn</code> or <code>fitBackVar</code>) or the base line variability.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Base line (or background) variability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- noiseBaseFit(intestinalDataSmall,step=.01,thr=.05)
x &lt;- apply(intestinalDataSmall,1,mean)
baseLineVar(x,y)
</code></pre>

<hr>
<h2 id='branchcells'>Differential Gene Expression between Links</h2><span id='topic+branchcells'></span>

<h3>Description</h3>

<p>This function computes expression z-score between groups of cells from the same cluster residing on different links
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branchcells(object, br)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="branchcells_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
<tr><td><code id="branchcells_+3A_br">br</code></td>
<td>
<p>List containing two branches, where each component has to be two valid cluster numbers seperated by a <code>.</code> and with one common cluster in the two components. The lower number precedes the larger one, i.e. <code>1.3</code>.
For each component, the cluster number need to be ordered in increasing order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list ot four components:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>a vector with the number of significant links for each cluster.</p>
</td></tr>
<tr><td><code>scl</code></td>
<td>
<p>a vector with the delta entropy for each cluster.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>a vector with the StemID score for each cluster.</p>
</td></tr>
<tr><td><code>diffgenes</code></td>
<td>
<p>a vector with the StemID score for each cluster.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
sc &lt;- comptsne(sc)
ltr &lt;- Ltree(sc)
ltr &lt;- compentropy(ltr)
ltr &lt;- projcells(ltr)
ltr &lt;- lineagegraph(ltr)
ltr &lt;- comppvalue(ltr)
x &lt;- branchcells(ltr,list("1.3","3.6"))
head(x$diffgenes$z)
plotmap(x$scl)
plotdiffgenes(x$diffgenes,names(x$diffgenes$z)[1])

</code></pre>

<hr>
<h2 id='calcAlphaG'>Function for calculating an aggregated dispersion parameter</h2><span id='topic+calcAlphaG'></span>

<h3>Description</h3>

<p>This function calculates an aggregated dispersion parameter comprising global cell-to-cell variability of transcript counts and biological variability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcAlphaG(noise)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcAlphaG_+3A_noise">noise</code></td>
<td>
<p>List of noise parameters returned by <code>compTBNoise</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of aggregated dispersion parameters.
</p>

<hr>
<h2 id='calcVar'>Function for calculating total variance from VarID fit</h2><span id='topic+calcVar'></span>

<h3>Description</h3>

<p>This function calculates the total variance from a local VarID fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcVar(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcVar_+3A_w">w</code></td>
<td>
<p>List object returned by <code>fitNBtb</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of total variance estimates.
</p>

<hr>
<h2 id='calcVarFit'>Function for calculating the total variance fit</h2><span id='topic+calcVarFit'></span>

<h3>Description</h3>

<p>This function calculates a total variance fit comprising sampling noise, global cell-to-cell variability of transcript counts, and biological variability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcVarFit(noise, norm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcVarFit_+3A_noise">noise</code></td>
<td>
<p>List of noise parameters returned by <code>compTBNoise</code>.</p>
</td></tr>
<tr><td><code id="calcVarFit_+3A_norm">norm</code></td>
<td>
<p>Logical. If <code>TRUE</code> then total variance is normalized by the technical noise component (i.e., sampling noise plus global cell-to-cell variability in transcript counts.). Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of total variance fits.
</p>

<hr>
<h2 id='cc_genes'>Cell cycle markers for Mus Muscuus</h2><span id='topic+cc_genes'></span>

<h3>Description</h3>

<p>This dataset contains official gene symbols for markers of the S phase and G2/M phase of the cell cycle in mouse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_genes
</code></pre>


<h3>Format</h3>

<p>A list of two components with S phase marker (s) and G2M phase marker (g2m) gene symbols.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='CCcorrect'>Dimensional Reduction by PCA or ICA</h2><span id='topic+CCcorrect'></span>

<h3>Description</h3>

<p>This functions performs dimensional reduction by PCA or ICA and removes components enriched for particular gene sets, e.g. cell cycle related genes
genes associated with technical batch effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCcorrect(
  object,
  vset = NULL,
  CGenes = NULL,
  ccor = 0.4,
  pvalue = 0.01,
  quant = 0.01,
  nComp = NULL,
  dimR = FALSE,
  mode = "pca",
  logscale = FALSE,
  FSelect = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCcorrect_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="CCcorrect_+3A_vset">vset</code></td>
<td>
<p>List of vectors with genes sets. The loadings of each component are tested for enrichment in any of these gene sets and if the lower <code>quant</code> or upper 1 - <code>quant</code> fraction of genes ordered by loading is enriched at a p-value &lt; <code>pvalue</code> the component is discarded. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CCcorrect_+3A_cgenes">CGenes</code></td>
<td>
<p>Vector of gene names. If this argument is given, gene sets to be tested for enrichment in PCA- or ICA-components are defined by all genes with a Pearson's correlation of <code>&gt;ccor</code> to a gene in <code>CGenes</code>. The loadings of each component are tested for enrichment in any of these gene sets and if the lower <code>quant</code> or upper 1 - <code>quant</code> fraction of genes ordered by loading is enriched at a p-value &lt; <code>pvalue</code> the component is discarded. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CCcorrect_+3A_ccor">ccor</code></td>
<td>
<p>Positive number between 0 and 1. Correlation threshold used to detrmine correlating gene sets for all genes in <code>CGenes</code>. Default is 0.4.</p>
</td></tr>
<tr><td><code id="CCcorrect_+3A_pvalue">pvalue</code></td>
<td>
<p>Positive number between 0 and 1. P-value cutoff for determining enriched components. See <code>vset</code> or <code>CGenes</code>. Default is 0.01.</p>
</td></tr>
<tr><td><code id="CCcorrect_+3A_quant">quant</code></td>
<td>
<p>Positive number between 0 and 1. Upper and lower fraction of gene loadings used for determining enriched components. See <code>vset</code> or <code>CGenes</code>.
Default is 0.01.</p>
</td></tr>
<tr><td><code id="CCcorrect_+3A_ncomp">nComp</code></td>
<td>
<p>Number of PCA- or ICA-components to use. Default is <code>NULL</code> and the maximal number of components is computed.</p>
</td></tr>
<tr><td><code id="CCcorrect_+3A_dimr">dimR</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the number of principal components to use for downstream analysis is derived from a saturation criterion.
See function <code>plotdimsat</code>. Default is <code>FALSE</code> and all <code>nComp</code> components are used.</p>
</td></tr>
<tr><td><code id="CCcorrect_+3A_mode">mode</code></td>
<td>
<p><code>"pca"</code> or <code>"ica"</code> to perform either principal component analysis or independent component analysis. Default is <code>pca</code>.</p>
</td></tr>
<tr><td><code id="CCcorrect_+3A_logscale">logscale</code></td>
<td>
<p>logical. If <code>TRUE</code> data are log-transformed prior to PCA or ICA. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CCcorrect_+3A_fselect">FSelect</code></td>
<td>
<p>logical. If <code>TRUE</code>, then PCA or ICA is performed on the filtered expression matrix using only the features stored in slot<code>cluster$features</code>
as computed in the function <code>filterdata</code>. See <code>FSelect</code> for function <code>filterdata</code>. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an updated <code>SCseq</code> object with the principal or independent component matrix written to the slot <code>dimRed$x</code> of the <code>SCseq</code>
object. Additional information on the PCA or ICA is stored in slot <code>dimRed</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- CCcorrect(sc,dimR=TRUE,nComp=3)
</code></pre>

<hr>
<h2 id='cellsfromtree'>Extract Cells on Differentiation Trajectory</h2><span id='topic+cellsfromtree'></span>

<h3>Description</h3>

<p>This function extracts a vector of cells on a given differentiation trajectory in pseudo-temporal order determined from the projection coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellsfromtree(object, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellsfromtree_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
<tr><td><code id="cellsfromtree_+3A_z">z</code></td>
<td>
<p>Vector of valid cluster numbers ordered along the trajectory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list ot four components:
</p>
<table>
<tr><td><code>f</code></td>
<td>
<p>a vector of cells ids ordered along the trajectory defined by <code>z</code>.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>a vector of integer number. Number <code>i</code> indicates that a cell resides on the link between the i-th and (i+1)-th cluster in <code>z</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
sc &lt;- comptsne(sc)
ltr &lt;- Ltree(sc)
ltr &lt;- compentropy(ltr)
ltr &lt;- projcells(ltr)
ltr &lt;- lineagegraph(ltr)
ltr &lt;- comppvalue(ltr)
x &lt;- cellsfromtree(ltr,c(1,3,6,2))
</code></pre>

<hr>
<h2 id='cleanNN'>Function for pruning k-nearest neighborhoods based on neighborhood overlap</h2><span id='topic+cleanNN'></span>

<h3>Description</h3>

<p>This function compares the neighborhood of a cell with the neighorhoods of all of its k nearest neighors and prunes links to neighbors that do not co-occur in a defined minimum number of neighborhoods by setting their link p-value (entry  in <code>pvM</code> data.frame of <code>res</code> input object) to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanNN(res, minN = 2, no_cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanNN_+3A_res">res</code></td>
<td>
<p>List object with k nearest neighbour information returned by <code>pruneKnn</code> function.</p>
</td></tr>
<tr><td><code id="cleanNN_+3A_minn">minN</code></td>
<td>
<p>Positive integer number. Minimum of neighborhoods across the k nearest neighbours of a cell expected to share a neighbor with the cell. Default is 2.</p>
</td></tr>
<tr><td><code id="cleanNN_+3A_no_cores">no_cores</code></td>
<td>
<p>Positive integer number. Number of cores for multithreading. If set to <code>NULL</code> then the number of available cores minus two is used. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>res</code> object with update pvalue entries (<code>pvM</code> element).
</p>

<hr>
<h2 id='clustdiffgenes'>Inference of differentially expressed genes in a cluster</h2><span id='topic+clustdiffgenes'></span>

<h3>Description</h3>

<p>This functions computes differentially expressed genes in a (set of) cluster(s) by comparing to all remaining cells outside of the cluster (or a given background set of clusters) based on a negative binomial
model of gene expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustdiffgenes(object, cl, bgr = NULL, pvalue = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustdiffgenes_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="clustdiffgenes_+3A_cl">cl</code></td>
<td>
<p>A valid set of cluster numbers from the final cluster partition stored in the <code>cpart</code> slot of the <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="clustdiffgenes_+3A_bgr">bgr</code></td>
<td>
<p>Ordered vector of cluster numbers to be used as background set. If <code>NULL</code> then all clusters not in <code>cl</code> are used as background set.</p>
</td></tr>
<tr><td><code id="clustdiffgenes_+3A_pvalue">pvalue</code></td>
<td>
<p>Positive real number smaller than one. This is the p-value cutoff for the inference of differential gene expression. Default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two components. The first component <code>dg</code> contains a a data.frame of differentially expressed genes ordered by p-value in increasing order, with four columns:
</p>
<table>
<tr><td><code>mean.ncl</code></td>
<td>
<p>mean expression across cells outside of cluster <code>cl</code>.</p>
</td></tr>
<tr><td><code>mean.cl</code></td>
<td>
<p>mean expression across cells within cluster <code>cl</code>.</p>
</td></tr>
<tr><td><code>fc</code></td>
<td>
<p>fold-change of mean expression in cluster <code>cl</code> versus the remaining cells.</p>
</td></tr>
<tr><td><code>pv</code></td>
<td>
<p>inferred p-value for differential expression.</p>
</td></tr>
<tr><td><code>padj</code></td>
<td>
<p>Benjamini-Hochberg corrected FDR.</p>
</td></tr>
</table>
<p>The second component <code>de</code> contains the conventional output of <code>diffexpnb</code>, where set B corresponds to all clusters in <code>cl</code> and B to the background set (all clusters in <code>bgr</code> or not in <code>cl</code>). This component can be used for plotting by <code>plotdiffgenesnb</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
x &lt;- clustdiffgenes(sc,1)
head(x$dg[x$dg$fc&gt;1,])
</code></pre>

<hr>
<h2 id='clustexp'>Clustering of single-cell transcriptome data</h2><span id='topic+clustexp'></span>

<h3>Description</h3>

<p>This functions performs the initial clustering of the RaceID3 algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustexp(
  object,
  sat = TRUE,
  samp = NULL,
  cln = NULL,
  clustnr = 30,
  bootnr = 50,
  rseed = 17000,
  FUNcluster = "kmedoids",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustexp_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="clustexp_+3A_sat">sat</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the number of clusters is determined based on finding the saturation point of the mean within-cluster
dispersion as a function of the cluster number. Default is <code>TRUE</code>. If <code>FALSE</code>, then cluster number needs to be given as <code>cln</code>.</p>
</td></tr>
<tr><td><code id="clustexp_+3A_samp">samp</code></td>
<td>
<p>Number of random sample of cells used for the inference of cluster number and for inferring Jaccard similarities.
Default is 1000.</p>
</td></tr>
<tr><td><code id="clustexp_+3A_cln">cln</code></td>
<td>
<p>Number of clusters to be used. Default is <code>NULL</code> and the cluster number is inferred by the saturation criterion.</p>
</td></tr>
<tr><td><code id="clustexp_+3A_clustnr">clustnr</code></td>
<td>
<p>Maximum number of clusters for the derivation of the cluster number by the saturation of mean within-cluster-dispersion.
Default is 30.</p>
</td></tr>
<tr><td><code id="clustexp_+3A_bootnr">bootnr</code></td>
<td>
<p>Number of booststrapping runs for <code>clusterboot</code>. Default is 50.</p>
</td></tr>
<tr><td><code id="clustexp_+3A_rseed">rseed</code></td>
<td>
<p>Integer number. Random seed to enforce reproducible clustering results. Default is 17000.</p>
</td></tr>
<tr><td><code id="clustexp_+3A_funcluster">FUNcluster</code></td>
<td>
<p>Clustering method used by RaceID3. One of <code>"kmedoids", "kmeans", "hclust"</code>. Default is <code>"kmedoids"</code>.</p>
</td></tr>
<tr><td><code id="clustexp_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>FALSE</code> then status output messages are disabled. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SCseq</code> object with clustering data stored in slot <code>cluster</code> and slot <code>clusterpar</code>. The clustering partition is stored in
<code>cluster$kpart</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
</code></pre>

<hr>
<h2 id='clustheatmap'>Plotting a Heatmap of the Distance Matrix</h2><span id='topic+clustheatmap'></span>

<h3>Description</h3>

<p>This functions plots a heatmap of the distance matrix grouped by clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustheatmap(object, final = TRUE, hmethod = "single")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustheatmap_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="clustheatmap_+3A_final">final</code></td>
<td>
<p>logical. If <code>TRUE</code>, then cells are grouped based on final clusters after outlier identification.
If <code>FALSE</code>, then initial clusters prior to outlier identification are used for grouping. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="clustheatmap_+3A_hmethod">hmethod</code></td>
<td>
<p>Agglomeration method used for determining the cluster order from hierarchical clustering of the cluster medoids. See <code>hclust</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of cluster numbers ordered as determined by herarchical clustering of cluster the cluster medoids as depicted in the heatmap.
</p>

<hr>
<h2 id='compdist'>Computing a distance matrix for cell type inference</h2><span id='topic+compdist'></span>

<h3>Description</h3>

<p>This functions computes the distance matrix used for cell type inference by RaceID3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compdist(
  object,
  metric = "pearson",
  FSelect = TRUE,
  knn = NULL,
  alpha = 1,
  no_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compdist_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="compdist_+3A_metric">metric</code></td>
<td>
<p>Distances are computed from the filtered expression matrix after optional feature selection, dimensional reduction, and/or transformation (batch correction).
Possible values for <code>metric</code> are <code> spearman, pearson, logpearson, euclidean, kendall</code>.  Default is <code>"pearson"</code>. In case of the correlation based methods,
the distance is computed as 1 – correlation.</p>
</td></tr>
<tr><td><code id="compdist_+3A_fselect">FSelect</code></td>
<td>
<p>Logical parameter. If <code>TRUE</code>, then feature selection is performed prior to RaceID3 analysis. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compdist_+3A_knn">knn</code></td>
<td>
<p>Positive integer number of nearest neighbours used for imputing gene expression values. Default is <code>NULL</code> and no imputing is done.</p>
</td></tr>
<tr><td><code id="compdist_+3A_alpha">alpha</code></td>
<td>
<p>Positive real number. Relative weight of a cell versus its k nearest neigbour applied for imputing gene expression. A cell receives a weight of <code>alpha</code> while the weight of its k nearest neighbours is determined by quadratic programming. The sum across all weights is normalized to one, and the wieghted mean expression is used for computing the joint probability of a cell and each of its k nearest neighbours. These probabilities are applied for the derivation of the imputed gene expression for each cell. Default is 1. Larger values give more weight to the gene expression observed in a cell versus its neighbourhood.</p>
</td></tr>
<tr><td><code id="compdist_+3A_no_cores">no_cores</code></td>
<td>
<p>Positive integer number. Number of cores for multithreading during imputation. If set to <code>NULL</code> then the number of available cores minus two is used. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SCseq</code> object with the distance matrix in slot <code>distances</code>. If <code>FSelect=TRUE</code>, the genes used for computing the distance object are stored in
slot <code>cluster$features</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
</code></pre>

<hr>
<h2 id='compentropy'>Compute transcriptome entropy of each cell</h2><span id='topic+compentropy'></span>

<h3>Description</h3>

<p>This function computes the transcriptome entropy for each cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compentropy(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compentropy_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An Ltree class object with a vector of entropies for each cell in the same order as column names in slot sc@ndata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
sc &lt;- comptsne(sc)
ltr &lt;- Ltree(sc)
ltr &lt;- compentropy(ltr)
</code></pre>

<hr>
<h2 id='compfr'>Computation of a two dimensional Fruchterman-Rheingold representation</h2><span id='topic+compfr'></span>

<h3>Description</h3>

<p>This functions performs the computation of a Fruchterman-Rheingold graph layout based on an adjacency matrix derived
from the distance object in slot <code>distances</code> using the <span class="pkg">igraph</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compfr(object, knn = 10, rseed = 15555)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compfr_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="compfr_+3A_knn">knn</code></td>
<td>
<p>Positive integer number of nearest neighbours used for the inference of the Fruchterman-Rheingold layout. Default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="compfr_+3A_rseed">rseed</code></td>
<td>
<p>Integer number. Random seed to enforce reproducible layouts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SCseq</code> object with layout coordinates stored in slot <code>fr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
sc &lt;- compfr(sc)
</code></pre>

<hr>
<h2 id='compMean'>Function for computing local gene expression averages</h2><span id='topic+compMean'></span>

<h3>Description</h3>

<p>This function performs computation of locally averaged gene expression across the pruned k nearest neighbours at given link probability cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compMean(
  x,
  res,
  pvalue = 0.01,
  genes = NULL,
  regNB = FALSE,
  batch = NULL,
  regVar = NULL,
  offsetModel = TRUE,
  thetaML = FALSE,
  theta = 10,
  ngenes = NULL,
  span = 0.75,
  no_cores = NULL,
  seed = 12345
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compMean_+3A_x">x</code></td>
<td>
<p>Matrix of gene expression values with genes as rows and cells as columns. The matrix need to contain the same cell IDs as columns like the input matrix used to derive the pruned k nearest neighbours with the <code>pruneKnn</code> function. However, it may contain a different set of genes.</p>
</td></tr>
<tr><td><code id="compMean_+3A_res">res</code></td>
<td>
<p>List object with k nearest neighbour information returned by <code>pruneKnn</code> function.</p>
</td></tr>
<tr><td><code id="compMean_+3A_pvalue">pvalue</code></td>
<td>
<p>Positive real number between 0 and 1. All nearest neighbours with link probability <code>&lt; pvalue</code> are discarded. Default is 0.01.</p>
</td></tr>
<tr><td><code id="compMean_+3A_genes">genes</code></td>
<td>
<p>Vector of gene names corresponding to a subset of rownames of <code>x</code>. Only for these genes local gene expression averages are computed. Default is <code>NULL</code> and values for all genes are returned.</p>
</td></tr>
<tr><td><code id="compMean_+3A_regnb">regNB</code></td>
<td>
<p>logical. If <code>TRUE</code> then gene expression averages are computed from the pearson residuals obtained from a negative binomial regression to eliminate the dependence of the expression variance on the mean. If <code>FALSE</code> then averages are computed from raw UMI counts. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compMean_+3A_batch">batch</code></td>
<td>
<p>vector of batch variables. Component names need to correspond to valid cell IDs, i.e. column names of <code>expData</code>. If <code>regNB</code> is <code>TRUE</code>, than the batch variable will be regressed out simultaneously with the log UMI count per cell.An interaction term is included for the log UMI count with the batch variable. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="compMean_+3A_regvar">regVar</code></td>
<td>
<p>data.frame with additional variables to be regressed out simultaneously with the log UMI count and the batch variable (if <code>batch</code> is <code>TRUE</code>). Column names indicate variable names (name <code>beta</code> is reserved for the coefficient of the log UMI count), and rownames need to correspond to valid cell IDs, i.e. column names of <code>expData</code>. Interaction terms are included for each variable in <code>regVar</code> with the batch variable (if <code>batch</code> is <code>TRUE</code>). Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="compMean_+3A_offsetmodel">offsetModel</code></td>
<td>
<p>Logical parameter. Only considered if <code>regNB</code> is <code>TRUE</code>. If <code>TRUE</code> then the <code>beta</code> (log UMI count) coefficient is set to 1 and the intercept is computed analytically as the log ration of UMI counts for a gene and the total UMI count across all cells. Batch variables and additional variables in <code>regVar</code> are regressed out with an offset term given by the sum of the intercept and the log UMI count. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compMean_+3A_thetaml">thetaML</code></td>
<td>
<p>Logical parameter. Only considered if <code>offsetModel</code> equals <code>TRUE</code>. If <code>TRUE</code> then the dispersion parameter is estimated by a maximum likelihood fit. Otherwise, it is set to <code>theta</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compMean_+3A_theta">theta</code></td>
<td>
<p>Positive real number. Fixed value of the dispersion parameter. Only considered if <code>theaML</code> equals <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compMean_+3A_ngenes">ngenes</code></td>
<td>
<p>Positive integer number. Randomly sampled number of genes (from rownames of <code>expData</code>) used for predicting regression coefficients (if <code>regNB=TRUE</code>). Smoothed coefficients are derived for all genes. Default is <code>NULL</code> and all genes are used.</p>
</td></tr>
<tr><td><code id="compMean_+3A_span">span</code></td>
<td>
<p>Positive real number. Parameter for loess-regression (see <code>regNB</code>) controlling the degree of smoothing. Default is 0.75.</p>
</td></tr>
<tr><td><code id="compMean_+3A_no_cores">no_cores</code></td>
<td>
<p>Positive integer number. Number of cores for multithreading. If set to <code>NULL</code> then the number of available cores minus two is used. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="compMean_+3A_seed">seed</code></td>
<td>
<p>Integer number. Random number to initialize stochastic routines. Default is 12345.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List object of three components:
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>matrix with local gene expression averages, computed from Pearson residuals (if <code>regNB=TRUE</code>) or normalized UMI counts (if <code>regNB=FALSE</code>). In the latter case, the average UMI count for a local neighbourhood is normalized to one and rescaled by the median UMI count across neighborhoods.</p>
</td></tr>
<tr><td><code>regData</code></td>
<td>
<p>If <code>regNB=TRUE</code> this argument contains a list of four components: component <code>pearsonRes</code> contains a matrix of the Pearson Residual computed from the negative binomial regression, component <code>nbRegr</code> contains a matrix with the regression coefficients, component <code>nbRegrSmooth</code> contains a matrix with the smoothed regression coefficients, and <code>log_umi</code> is a vector with the total log UMI count for each cell. The regression coefficients comprise the dispersion parameter theta, the intercept, the regression coefficient beta for the log UMI count, and the regression coefficients of the batches (if <code>batch</code> is not <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- pruneKnn(intestinalDataSmall,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
mexp &lt;- compMean(intestinalDataSmall,res,pvalue=0.01,genes = NULL,no_cores=1)
</code></pre>

<hr>
<h2 id='compmedoids'>Computes Medoids from a Clustering Partition</h2><span id='topic+compmedoids'></span>

<h3>Description</h3>

<p>This functions computes cluster medoids given an <code>SCseq</code> object and a clustering partition. The medoids are either derived from the
distance matrix or, if the slot <code>distances</code> is empty, from the dimensionally reduced feature matrix in slot <code>dimRed$x</code> using the euclidean metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compmedoids(object, part)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compmedoids_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="compmedoids_+3A_part">part</code></td>
<td>
<p>Clustering partition. A vector of cluster numbers for (a subset of) cells (i.e. column names)
of slot <code>ndata</code> from the <code>SCseq</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of medoids (column names of slot <code>ndata</code> from the <code>SCseq</code> object) ordered by increasing cluster number.
</p>

<hr>
<h2 id='compNoise'>Function for computing local gene expression variability</h2><span id='topic+compNoise'></span>

<h3>Description</h3>

<p>This function performs computation of the local gene expression variability across the pruned k nearest neighbours at given link probability cutoff. The estimated variance is corrected for the mean dependence utilizing the baseline model of gene expression variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compNoise(
  x,
  res,
  pvalue = 0.01,
  genes = NULL,
  regNB = FALSE,
  batch = NULL,
  regVar = NULL,
  offsetModel = TRUE,
  thetaML = FALSE,
  theta = 10,
  ngenes = NULL,
  span = 0.75,
  step = 0.01,
  thr = 0.05,
  no_cores = NULL,
  seed = 12345
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compNoise_+3A_x">x</code></td>
<td>
<p>Matrix of gene expression values with genes as rows and cells as columns. The matrix need to contain the same cell IDs as columns like the input matrix used to derive the pruned k nearest neighbours with the <code>pruneKnn</code> function. However, it may contain a different set of genes.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_res">res</code></td>
<td>
<p>List object with k nearest neighbour information returned by <code>pruneKnn</code> function.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_pvalue">pvalue</code></td>
<td>
<p>Positive real number between 0 and 1. All nearest neighbours with link probability <code>&lt; pvalue</code> are discarded. Default is 0.01.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_genes">genes</code></td>
<td>
<p>Vector of gene names corresponding to a subset of rownames of <code>x</code>. Only for these genes local gene expression variability is computed. Default is <code>NULL</code> and values for all genes are returned.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_regnb">regNB</code></td>
<td>
<p>logical. If <code>TRUE</code> then gene expression variability is derived from the pearson residuals obtained from a negative binomial regression to eliminate the dependence of the expression variance on the mean. If <code>FALSE</code> then the mean dependence is regressed out from the raw variance using the baseline variance estimate. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_batch">batch</code></td>
<td>
<p>vector of batch variables. Component names need to correspond to valid cell IDs, i.e. column names of <code>expData</code>. If <code>regNB</code> is <code>TRUE</code>, than the batch variable will be regressed out simultaneously with the log UMI count per cell. An interaction term is included for the log UMI count with the batch variable. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_regvar">regVar</code></td>
<td>
<p>data.frame with additional variables to be regressed out simultaneously with the log UMI count and the batch variable (if <code>batch</code> is <code>TRUE</code>). Column names indicate variable names (name <code>beta</code> is reserved for the coefficient of the log UMI count), and rownames need to correspond to valid cell IDs, i.e. column names of <code>expData</code>. Interaction terms are included for each variable in <code>regVar</code> with the batch variable (if <code>batch</code> is <code>TRUE</code>). Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_offsetmodel">offsetModel</code></td>
<td>
<p>Logical parameter. Only considered if <code>regNB</code> is <code>TRUE</code>. If <code>TRUE</code> then the <code>beta</code> (log UMI count) coefficient is set to 1 and the intercept is computed analytically as the log ration of UMI counts for a gene and the total UMI count across all cells. Batch variables and additional variables in <code>regVar</code> are regressed out with an offset term given by the sum of the intercept and the log UMI count. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_thetaml">thetaML</code></td>
<td>
<p>Logical parameter. Only considered if <code>offsetModel</code> equals <code>TRUE</code>. If <code>TRUE</code> then the dispersion parameter is estimated by a maximum likelihood fit. Otherwise, it is set to <code>theta</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_theta">theta</code></td>
<td>
<p>Positive real number. Fixed value of the dispersion parameter. Only considered if <code>theaML</code> equals <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_ngenes">ngenes</code></td>
<td>
<p>Positive integer number. Randomly sampled number of genes (from rownames of <code>expData</code>) used for predicting regression coefficients (if <code>regNB=TRUE</code>). Smoothed coefficients are derived for all genes. Default is <code>NULL</code> and all genes are used.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_span">span</code></td>
<td>
<p>Positive real number. Parameter for loess-regression (see <code>regNB</code>) controlling the degree of smoothing. Default is 0.75.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_step">step</code></td>
<td>
<p>Positive real number between 0 and 1. See function <code>noiseBaseFit</code>. Default is 0.01.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_thr">thr</code></td>
<td>
<p>Positive real number between 0 and 1. See function <code>noiseBaseFit</code>. Default is 0.05.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_no_cores">no_cores</code></td>
<td>
<p>Positive integer number. Number of cores for multithreading. If set to <code>NULL</code> then the number of available cores minus two is used. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="compNoise_+3A_seed">seed</code></td>
<td>
<p>Integer number. Random number to initialize stochastic routines. Default is 12345.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List object of three components:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>the baseline noise model as computed by the <code>noiseBaseFit</code> function.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>matrix with local gene expression variability estimates, corrected for the mean dependence.</p>
</td></tr>
<tr><td><code>regData</code></td>
<td>
<p>If <code>regNB=TRUE</code> this argument contains a list of four components: component <code>pearsonRes</code> contains a matrix of the Pearson Residual computed from the negative binomial regression, component <code>nbRegr</code> contains a matrix with the regression coefficients, component <code>nbRegrSmooth</code> contains a matrix with the smoothed regression coefficients, and <code>log_umi</code> is a vector with the total log UMI count for each cell. The regression coefficients comprise the dispersion parameter theta, the intercept, the regression coefficient beta for the log UMI count, and the regression coefficients of the batches (if <code>batch</code> is not <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- pruneKnn(intestinalDataSmall,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
noise &lt;- compNoise(intestinalDataSmall,res,pvalue=0.01,genes = NULL,no_cores=1)
</code></pre>

<hr>
<h2 id='comppvalue'>Computing P-values for Link Significance</h2><span id='topic+comppvalue'></span>

<h3>Description</h3>

<p>This function computes a p-value for the significance (i.e. over-representation of assigned cells) of each inter-cluster link.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comppvalue(object, pthr = 0.01, sensitive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comppvalue_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
<tr><td><code id="comppvalue_+3A_pthr">pthr</code></td>
<td>
<p>p-value cutoff for link significance. This threshold is applied for the calculation of link scores reflecting how uniformly a link is occupied by cells.</p>
</td></tr>
<tr><td><code id="comppvalue_+3A_sensitive">sensitive</code></td>
<td>
<p>logical. Only relevant when <code>nmode=TRUE</code> in function <code>projcell</code>. If <code>TRUE</code>, then all cells on the most highly significant link are
and the link itself are disregard to test significance of the remaining links with a binomial p-value. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An Ltree class object with link p-value and occupancy data stored in slot <code>cdata</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
sc &lt;- comptsne(sc)
ltr &lt;- Ltree(sc)
ltr &lt;- compentropy(ltr)
ltr &lt;- projcells(ltr)
ltr &lt;- lineagegraph(ltr)
ltr &lt;- comppvalue(ltr)
</code></pre>

<hr>
<h2 id='compscore'>Compute StemID2 score</h2><span id='topic+compscore'></span>

<h3>Description</h3>

<p>This function extracts the number of links connecting a given cluster to other cluster, the delta median entropy of each cluster
(median entropy of a cluster after subtracting the minimum median entropy across all clusters), and the StemID2 score which is the product of both quantities for
each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compscore(object, nn = 1, scthr = 0, show = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compscore_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
<tr><td><code id="compscore_+3A_nn">nn</code></td>
<td>
<p>Positive integer number. Number of higher order neighbors to be included for the determination of links: indirect connections via <code>n-1</code> intermittant
neighbors are allowed. Default is 1.</p>
</td></tr>
<tr><td><code id="compscore_+3A_scthr">scthr</code></td>
<td>
<p>Real number between zero and one. Score threshold for links to be included in the calculation. For <code>scthr=0</code> all significant links are included. The
maximum score is one.</p>
</td></tr>
<tr><td><code id="compscore_+3A_show">show</code></td>
<td>
<p>logical. If <code>TRUE</code>, then plot heatmap of projections. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list ot three components:
</p>
<table>
<tr><td><code>links</code></td>
<td>
<p>a vector with the number of significant links for each cluster.</p>
</td></tr>
<tr><td><code>entropy</code></td>
<td>
<p>a vector with the delta entropy for each cluster.</p>
</td></tr>
<tr><td><code>StemIDscore</code></td>
<td>
<p>a vector with the StemID score for each cluster.</p>
</td></tr>
</table>

<hr>
<h2 id='compTBNoise'>Function for fitting a negative binomial noise model of technical and biological variability across cells in pruned k-nearest neighbourhoods.</h2><span id='topic+compTBNoise'></span>

<h3>Description</h3>

<p>This function fits negative binomial models to transcript counts of pruned k-nearest neighbourhoods inferred by <code>pruneKnn</code> thereby deconvoluting variability into sampling noise, global cell-to-cell variability of transcript counts, and residual variability, which corresponds to biological noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compTBNoise(
  res,
  expData,
  pvalue = 0.01,
  genes = NULL,
  minN = 5,
  no_cores = NULL,
  gamma = 0.5,
  x0 = 0,
  lower = 0,
  upper = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compTBNoise_+3A_res">res</code></td>
<td>
<p>List object with k nearest neighbour information returned by <code>pruneKnn</code> function.</p>
</td></tr>
<tr><td><code id="compTBNoise_+3A_expdata">expData</code></td>
<td>
<p>Matrix of gene expression values with genes as rows and cells as columns. These values have to correspond to unique molecular identifier counts.</p>
</td></tr>
<tr><td><code id="compTBNoise_+3A_pvalue">pvalue</code></td>
<td>
<p>Positive real number between 0 and 1. All nearest neighbours with link probability <code>&lt; pvalue</code> are discarded. Default is 0.01.</p>
</td></tr>
<tr><td><code id="compTBNoise_+3A_genes">genes</code></td>
<td>
<p>Vector of gene names corresponding to a subset of rownames of <code>expData</code>. Only for these genes local gene expression variability is computed. Default is <code>NULL</code> and values for all genes are returned.</p>
</td></tr>
<tr><td><code id="compTBNoise_+3A_minn">minN</code></td>
<td>
<p>Positive integer number. Noise inference is only done for k-nearest neighbourhoods with at least <code>minN</code> neighbours remaining after pruning.</p>
</td></tr>
<tr><td><code id="compTBNoise_+3A_no_cores">no_cores</code></td>
<td>
<p>Positive integer number. Number of cores for multithreading. If set to <code>NULL</code> then the number of available cores minus two is used. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="compTBNoise_+3A_gamma">gamma</code></td>
<td>
<p>Positive real number. Scale paramter of the cauchy prior. Default is 0.5.</p>
</td></tr>
<tr><td><code id="compTBNoise_+3A_x0">x0</code></td>
<td>
<p>Real number greater or equal to zero. Location parameter of the cauchy prior.</p>
</td></tr>
<tr><td><code id="compTBNoise_+3A_lower">lower</code></td>
<td>
<p>Real number greater or equal to zero. Lower bound for the maximum a posterior inference of the biological noise. Default is 0.</p>
</td></tr>
<tr><td><code id="compTBNoise_+3A_upper">upper</code></td>
<td>
<p>Real number greater or equal to zero. Upper bound for the maximum a posterior inference of the biological noise. Default is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List object of three components:
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>Vector of mean expression for all k-nearest neighbourhoods. Componenets are set to <code>NA</code> if less than <code>minN</code> neighbours are present in pruned neighbourhood. </p>
</td></tr>
<tr><td><code>rt</code></td>
<td>
<p>Vector of dispersion parameters capturing global cell-to-cell variability of transcript counts for all k-nearest neighbourhoods. Componenets are set to <code>NA</code> if less than <code>minN</code> neighbours are present in pruned neighbourhood.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>Matrix of biological noise estimates for all genes across for all k-nearest neighbourhoods. Componenets are set to <code>NA</code> if less than <code>minN</code> neighbours present in pruned neighbourhood.</p>
</td></tr>
<tr><td><code>pars</code></td>
<td>
<p>List of parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res &lt;- pruneKnn(intestinalDataSmall,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
noise &lt;- compTBNoise(res,intestinalDataSmall,pvalue=0.01,genes = NULL,no_cores=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='comptsne'>Computation of a two dimensional t-SNE representation</h2><span id='topic+comptsne'></span>

<h3>Description</h3>

<p>This functions performs the computation of a t-SNE map from the distance object in slot <code>distances</code> using the <span class="pkg">Rtsne</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comptsne(
  object,
  dimRed = FALSE,
  initial_cmd = TRUE,
  perplexity = 30,
  rseed = 15555
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comptsne_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="comptsne_+3A_dimred">dimRed</code></td>
<td>
<p>logical. If <code>TRUE</code> then the t-SNE is computed from the feature matrix in slot <code>dimRed$x</code> (if not equal to <code>NULL</code>).
Default is <code>FALSE</code> and the t-SNE is computed from the distance matrix stored in slot <code>distances</code>. If slot <code>distances</code> equals <code>NULL</code>
<code>dimRed</code> is automatially set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="comptsne_+3A_initial_cmd">initial_cmd</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the t-SNE map computation is initialized with a configuration obtained by classical
multidimensional scaling. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="comptsne_+3A_perplexity">perplexity</code></td>
<td>
<p>Positive number. Perplexity of the t-SNE map. Default is <code>30</code>.</p>
</td></tr>
<tr><td><code id="comptsne_+3A_rseed">rseed</code></td>
<td>
<p>Integer number. Random seed to enforce reproducible t-SNE map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SCseq</code> object with t-SNE coordinates stored in slot <code>tsne</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
sc &lt;- comptsne(sc)
</code></pre>

<hr>
<h2 id='compumap'>Computation of a two dimensional umap representation</h2><span id='topic+compumap'></span>

<h3>Description</h3>

<p>This functions performs the computation of a two-dimensional umap representation based on the distance matrix in
slot <code>distances</code> using the <span class="pkg">umap</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compumap(
  object,
  dimRed = FALSE,
  n_neighbors = 15,
  metric = "euclidean",
  n_epochs = 200,
  min_dist = 0.1,
  local_connectivity = 1,
  spread = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compumap_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="compumap_+3A_dimred">dimRed</code></td>
<td>
<p>logical. If <code>TRUE</code> then the umap is computed from the feature matrix in slot <code>dimRed$x</code> (if not equal to <code>NULL</code>).
Default is <code>FALSE</code> and the umap is computed from the distance matrix stored in slot <code>distances</code>. If slot <code>distances</code> equals <code>NULL</code>
<code>dimRed</code> is automatially set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="compumap_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>Umap parameter. See <code>help(umap.defaults)</code> after loading package <span class="pkg">umap</span>. Default is 15.</p>
</td></tr>
<tr><td><code id="compumap_+3A_metric">metric</code></td>
<td>
<p>Umap parameter. See <code>help(umap.defaults)</code> after loading package <span class="pkg">umap</span>. Default is &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="compumap_+3A_n_epochs">n_epochs</code></td>
<td>
<p>Umap parameter. See <code>help(umap.defaults)</code> after loading package <span class="pkg">umap</span>. Default is 200.</p>
</td></tr>
<tr><td><code id="compumap_+3A_min_dist">min_dist</code></td>
<td>
<p>Umap parameter. See <code>help(umap.defaults)</code> after loading package <span class="pkg">umap</span>. Default is 0.1.</p>
</td></tr>
<tr><td><code id="compumap_+3A_local_connectivity">local_connectivity</code></td>
<td>
<p>Umap parameter. See <code>help(umap.defaults)</code> after loading package <span class="pkg">umap</span>. Default is 1.</p>
</td></tr>
<tr><td><code id="compumap_+3A_spread">spread</code></td>
<td>
<p>Umap parameter. See <code>help(umap.defaults)</code> after loading package <span class="pkg">umap</span>. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SCseq</code> object with umap coordinates stored in slot <code>umap</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
sc &lt;- compumap(sc)
</code></pre>

<hr>
<h2 id='corrVar'>Function for regressing out the mean-variance dependence.
This function corrects for the systematic dependence of the variance on the mean by a local regression.</h2><span id='topic+corrVar'></span>

<h3>Description</h3>

<p>Function for regressing out the mean-variance dependence.
This function corrects for the systematic dependence of the variance on the mean by a local regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrVar(m, v, span = 0.75, degree = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrVar_+3A_m">m</code></td>
<td>
<p>Vector of mean expression estimates for a set of genes.</p>
</td></tr>
<tr><td><code id="corrVar_+3A_v">v</code></td>
<td>
<p>Vector of variance etsimates for a set of genes.</p>
</td></tr>
<tr><td><code id="corrVar_+3A_span">span</code></td>
<td>
<p>Parameter for the local regression. See help(loess). Default value is 0.75.</p>
</td></tr>
<tr><td><code id="corrVar_+3A_degree">degree</code></td>
<td>
<p>Parameter for the local regression. See help(loess). Default value is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of corrected variance estimates.
</p>

<hr>
<h2 id='createKnnMatrix'>Function to create a knn matrix</h2><span id='topic+createKnnMatrix'></span>

<h3>Description</h3>

<p>This creates an adjacency matrix, keeping only nearest neighbour with a link probability above a minimum probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createKnnMatrix(res, pvalue = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createKnnMatrix_+3A_res">res</code></td>
<td>
<p>List object with k nearest neighbour information returned by <code>pruneKnn</code> function.</p>
</td></tr>
<tr><td><code id="createKnnMatrix_+3A_pvalue">pvalue</code></td>
<td>
<p>Positive real number between 0 and 1. All nearest neighbours with link probability <code>&lt; pvalue</code> are discarded. Default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjacency matrix in sparse matrix format (see package <span class="pkg">Matrix</span>) with positive non-zero entries only for k nearest neighours with link probability <code>&gt;= pvalue</code>. The value of these entries equals the link probability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- pruneKnn(intestinalDataSmall,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
y &lt;- createKnnMatrix(res,pvalue=0.01)
</code></pre>

<hr>
<h2 id='diffexpnb'>Function for differential expression analysis</h2><span id='topic+diffexpnb'></span>

<h3>Description</h3>

<p>This function performs differential expression analysis between two sets of single cell transcriptomes. The inference is based on a noise model or relies on the <code>DESeq2</code> approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffexpnb(
  x,
  A,
  B,
  DESeq = FALSE,
  method = "pooled",
  norm = FALSE,
  vfit = NULL,
  locreg = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffexpnb_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis. This input has to be provided if <code>g</code> (see below) is given and corresponds to a valid gene ID, i. e. one of the rownames of <code>x</code>. The default value is <code>NULL</code>. In this case, cluster identities are highlighted in the plot.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_a">A</code></td>
<td>
<p>vector of cell IDs corresponding column names of <code>x</code>. Differential expression in set <code>A</code> versus set <code>B</code> will be evaluated.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_b">B</code></td>
<td>
<p>vector of cell IDs corresponding column names of <code>x</code>. Differential expression in set <code>A</code> versus set <code>B</code> will be evaluated.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_deseq">DESeq</code></td>
<td>
<p>logical value. If <code>TRUE</code>, then <span class="pkg">DESeq2</span> is used for the inference of differentially expressed genes. In this case, it is recommended to provide non-normalized input data <code>x</code>. The <span class="pkg">DESeq2</span> package needs to be installed from bioconductor. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_method">method</code></td>
<td>
<p>either &quot;per-condition&quot; or &quot;pooled&quot;. If DESeq is not used, this parameter determines, if the noise model is fitted for each set separately (&quot;per-condition&quot;) or for the pooled set comprising all cells in <code>A</code> and <code>B</code>. Default value is &quot;pooled&quot;.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_norm">norm</code></td>
<td>
<p>logical value. If <code>TRUE</code> then the total transcript count in each cell is normalized to the minimum number of transcripts across all cells in set <code>A</code> and <code>B</code>. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_vfit">vfit</code></td>
<td>
<p>function describing the background noise model. Inference of differentially expressed genes can be performed with a user-specified noise model describing the expression variance as a function of the mean expression. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_locreg">locreg</code></td>
<td>
<p>logical value. If <code>FALSE</code> then regression of a second order polynomial is perfomed to determine the relation of variance and mean. If <code>TRUE</code> a local regression is performed instead. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level function <code>DESeqDataSetFromMatrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>DESeq</code> equals <code>TRUE</code>, the function returns the output of <span class="pkg">DESeq2</span>. In this case list of the following two components is returned:
</p>
<table>
<tr><td><code>cds</code></td>
<td>
<p>object returned by the <span class="pkg">DESeq2</span> function <code>DESeqDataSetFromMatrix</code>.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>data frame containing the results of the <span class="pkg">DESeq2</span> analysis.</p>
</td></tr>
</table>
<p>Otherwise, a list of three components is returned:
</p>
<table>
<tr><td><code>vf1</code></td>
<td>
<p>a data frame of three columns, indicating the mean <code>m</code>, the variance <code>v</code> and the fitted variance <code>vm</code> for set <code>A</code>.</p>
</td></tr>
<tr><td><code>vf2</code></td>
<td>
<p>a data frame of three columns, indicating the mean <code>m</code>, the variance <code>v</code> and the fitted variance <code>vm</code> for set <code>B</code>.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>a data frame with the results of the differential gene expression analysis with the structure of the <code>DESeq</code> output, displaying mean expression of the two sets, fold change and log2 fold change between the two sets, the p-value for differential expression (<code>pval</code>) and the Benjamini-Hochberg corrected false discovery rate (<code>padj</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
A &lt;- names(sc@cpart)[sc@cpart %in% c(1,2)]
B &lt;- names(sc@cpart)[sc@cpart %in% c(3)]
y &lt;- diffexpnb(getfdata(sc,n=c(A,B)), A=A, B=B )
</code></pre>

<hr>
<h2 id='diffgenes'>Compute Expression Differences between Clusters</h2><span id='topic+diffgenes'></span>

<h3>Description</h3>

<p>This functions computes expression differences between clusters and ranks genes by z-score differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffgenes(object, cl1, cl2, mincount = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffgenes_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="diffgenes_+3A_cl1">cl1</code></td>
<td>
<p>A vector of valid cluster numbers (contained in the <code>cpart</code> slot of the <code>SCseq</code> object). Represents the first group of the comparison.</p>
</td></tr>
<tr><td><code id="diffgenes_+3A_cl2">cl2</code></td>
<td>
<p>A vector of valid cluster numbers (contained in the <code>cpart</code> slot of the <code>SCseq</code> object). Represents the second group of the comparison.</p>
</td></tr>
<tr><td><code id="diffgenes_+3A_mincount">mincount</code></td>
<td>
<p>Minimal normalized expression level of a gene to be included into the analysis. A gene needs to be expressed at this level in at least a single cell.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with four components:
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>a vector of z-scores in decreasing order with genes up-regulated in <code>cl1</code> appearing at the top of the list.</p>
</td></tr>
<tr><td><code>cl1</code></td>
<td>
<p>a <code>data.frame</code> with expression values for cells in <code>cl1</code>.</p>
</td></tr>
<tr><td><code>cl2</code></td>
<td>
<p>a <code>data.frame</code> with expression values for cells in <code>cl2</code>.</p>
</td></tr>
<tr><td><code>cl1n</code></td>
<td>
<p>a vector of cluster numbers for cells in <code>cl1</code>.</p>
</td></tr>
<tr><td><code>cl2n</code></td>
<td>
<p>a vector of cluster numbers for cells in <code>cl2</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
x &lt;- diffgenes(sc,1,2)
head(x$z)
plotdiffgenes(x,names(x$z)[1])
</code></pre>

<hr>
<h2 id='diffNoisyGenes'>Function for extracting genes with elevated variability in a cluster</h2><span id='topic+diffNoisyGenes'></span>

<h3>Description</h3>

<p>This function extracts genes with significantly elevated variability in a cluster on a basis of a Wilcoxon rank sum-test between cells in a cluster
and all remaining cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffNoisyGenes(noise, cl, set, bgr = NULL, no_cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffNoisyGenes_+3A_noise">noise</code></td>
<td>
<p>List object with the background noise model and a variability matrix, returned by the <code>compNoise</code> function.</p>
</td></tr>
<tr><td><code id="diffNoisyGenes_+3A_cl">cl</code></td>
<td>
<p>List object with clustering information, returned by the <code>graphCluster</code> function.</p>
</td></tr>
<tr><td><code id="diffNoisyGenes_+3A_set">set</code></td>
<td>
<p>Postive integer number or vector of integers corresponding to valid cluster numbers. The function reports genes with elevated variability in all
clusters contained in <code>set</code>.</p>
</td></tr>
<tr><td><code id="diffNoisyGenes_+3A_bgr">bgr</code></td>
<td>
<p>Postive integer number or vector of integers corresponding to valid cluster numbers. Background set for comparison. The function reports genes
with elevated variability in all clusters contained in <code>set</code> compared to clusters in <code>bgr</code>. Default is <code>NULL</code> and the comparison is against all
clusters not in <code>set</code>.</p>
</td></tr>
<tr><td><code id="diffNoisyGenes_+3A_no_cores">no_cores</code></td>
<td>
<p>Positive integer number. Number of cores for multithreading. If set to <code>NULL</code> then the number of available cores minus two is used. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame reporting the log2 fold change between clusters in <code>set</code> and the remaining clusters and the p-value for elevated variability for each genes. Rows are ordered by decreasing log2 fold change.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- pruneKnn(intestinalDataSmall,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
noise &lt;- compNoise(intestinalDataSmall,res,pvalue=0.01,genes = NULL,no_cores=1)
cl &lt;- graphCluster(res,pvalue=0.01)
ngenes &lt;- diffNoisyGenes(noise,cl,c(1,2),no_cores=1)
</code></pre>

<hr>
<h2 id='diffNoisyGenesTB'>Function for extracting genes with differential biological variability in a cluster</h2><span id='topic+diffNoisyGenesTB'></span>

<h3>Description</h3>

<p>This function infers genes with differential biological variability in a cluster versus a background set of clusters on the basis of a Wilcoxon rank sum-test between cells in a cluster
and in the background set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffNoisyGenesTB(
  noise,
  cl,
  set,
  bgr = NULL,
  no_cores = 1,
  minobs = 5,
  ps = 0.1,
  rseed = 17000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffNoisyGenesTB_+3A_noise">noise</code></td>
<td>
<p>List object with noise parameters returned by the <code>compTBNoise</code> function.</p>
</td></tr>
<tr><td><code id="diffNoisyGenesTB_+3A_cl">cl</code></td>
<td>
<p>List object with clustering information, returned by the <code>graphCluster</code> function.</p>
</td></tr>
<tr><td><code id="diffNoisyGenesTB_+3A_set">set</code></td>
<td>
<p>Postive integer number or vector of integers corresponding to valid cluster numbers. The function reports genes with differential variability in all
clusters contained in <code>set</code> versus vlusters in <code>bgr</code>.</p>
</td></tr>
<tr><td><code id="diffNoisyGenesTB_+3A_bgr">bgr</code></td>
<td>
<p>Postive integer number or vector of integers corresponding to valid cluster numbers. Background set for comparison. The function reports genes
with differential variability in all clusters contained in <code>set</code> compared to clusters in <code>bgr</code>. Default is <code>NULL</code> and <code>bgr</code> equals the set of all clusters not in <code>bgr</code>.</p>
</td></tr>
<tr><td><code id="diffNoisyGenesTB_+3A_no_cores">no_cores</code></td>
<td>
<p>Positive integer number. Number of cores for multithreading. If set to <code>NULL</code> then the number of available cores minus two is used. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffNoisyGenesTB_+3A_minobs">minobs</code></td>
<td>
<p>Positive integer number. Only genes with at least <code>minobs</code> neighbourhoods with non-zero biological noise levels in <code>set</code> are included for the p-value computation. Otherwise, a p-value or 0.5 is reported. Default is 5.</p>
</td></tr>
<tr><td><code id="diffNoisyGenesTB_+3A_ps">ps</code></td>
<td>
<p>Real number greater or equal to zero. A small random variable sampled from a uniform distribution in the interval <code>[0,ps]</code> is added to the noise quantification to avoid inclusion of genes with small noise differences. Default is 0.1.</p>
</td></tr>
<tr><td><code id="diffNoisyGenesTB_+3A_rseed">rseed</code></td>
<td>
<p>Integer number. Random seed to enforce reproducible results. Default is 17000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with five columns:
</p>
<table>
<tr><td><code>mu.set</code></td>
<td>
<p> Mean expression across clusters in <code>set</code>. </p>
</td></tr>
<tr><td><code>mu.bgr</code></td>
<td>
<p> Mean expression across clusters in <code>bgr</code> (or all clusters not in <code>set</code>). </p>
</td></tr>
<tr><td><code>mu.all</code></td>
<td>
<p> Mean expression across clusters in <code>set</code> and <code>bgr</code> (or all clusters). </p>
</td></tr>
<tr><td><code>eps.set</code></td>
<td>
<p> Average variability across clusters in <code>set</code>. </p>
</td></tr>
<tr><td><code>eps.bgr</code></td>
<td>
<p> Average variability across clusters in <code>bgr</code> (or all clusters not in <code>set</code>). </p>
</td></tr>
<tr><td><code>eps.all</code></td>
<td>
<p> Average variability across clusters in <code>set</code> and <code>bgr</code> (or all clusters). </p>
</td></tr>
<tr><td><code>log2FC</code></td>
<td>
<p>log2 fold change of variability between between clusters in <code>set</code> and clusters in <code>bgr</code> (or all clusters).</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>Banjamini-Hochberg corrected Wilcoxon rank sum test p-value for differential variability.</p>
</td></tr>
</table>
<p>Rows are ordered by decreasing log2 fold change of variability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res &lt;- pruneKnn(intestinalDataSmall,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
noise &lt;- compTBNoise(res,intestinalDataSmall,pvalue=0.01,genes = NULL,no_cores=1)
cl &lt;- graphCluster(res,pvalue=0.01)
ngenes &lt;- diffNoisyGenesTB(noise,cl,c(1,2),no_cores=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='extractCounts'>Function for filtering count data</h2><span id='topic+extractCounts'></span>

<h3>Description</h3>

<p>This function discards lowly expressed genes from a count matrix stored in an <code>SCseq</code> object, and returns (normalized or non-normalized) gene expression or noise values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractCounts(
  object,
  minexpr = 5,
  minnumber = 5,
  noise = FALSE,
  pt = NULL,
  n = NULL,
  g = NULL,
  norm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractCounts_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="extractCounts_+3A_minexpr">minexpr</code></td>
<td>
<p>Integer number greater or equal to zero. Minimum expression of a gene in at least <code>minnumber</code> cells to not be discarded. Default is 5.</p>
</td></tr>
<tr><td><code id="extractCounts_+3A_minnumber">minnumber</code></td>
<td>
<p>Integer number greater or equal to zero. Minimum number of cells required to have at least <code>minexpr</code> transcript counts for a gene to not be discarded. Default is 5.</p>
</td></tr>
<tr><td><code id="extractCounts_+3A_noise">noise</code></td>
<td>
<p>logical. If <code>TRUE</code>, then noise (in <code>object@noise</code>) is returned for the filtered genes and cells. Default is <code>FALSE</code> and gene expression counts are returned.</p>
</td></tr>
<tr><td><code id="extractCounts_+3A_pt">pt</code></td>
<td>
<p>List object returned by function <code>pseudoTime</code>. If given, then feature matrix is returned for cells in <code>pt$ord</code> and ordered by pseudo-time. Default is NULL and feature matrix is returned for all cells in <code>object$ndata</code>.</p>
</td></tr>
<tr><td><code id="extractCounts_+3A_n">n</code></td>
<td>
<p>Vector of valid column names corresponding to a subset of valid column names of the <code>object@ndata</code>. Default is <code>NULL</code> filtering is done on all cells in <code>object@ndata</code>. Only considered if <code>pt</code> is NULL.</p>
</td></tr>
<tr><td><code id="extractCounts_+3A_g">g</code></td>
<td>
<p>Vector of gene IDs (valid row names of <code>object@ndata</code>). If given, then all genes not in <code>g</code> are discarded prior to filtering. Default is NULL and filtering is done on all genes in <code>object@ndata</code>.</p>
</td></tr>
<tr><td><code id="extractCounts_+3A_norm">norm</code></td>
<td>
<p>logical. If <code>TRUE</code>, then transcipt counts are normalized to the minimum number of total transcript counts across all cells in the feature matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Filtered expression matrix.
</p>

<hr>
<h2 id='filterdata'>Data filtering</h2><span id='topic+filterdata'></span>

<h3>Description</h3>

<p>This function allows filtering of genes and cells to be used in the RaceID3 analysis.
It also can perform batch effect correction using an internal method or a recently published alternative <code>mnnCorrect</code> from the <span class="pkg">batchelor</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterdata(
  object,
  mintotal = 3000,
  minexpr = 5,
  minnumber = 5,
  LBatch = NULL,
  knn = 10,
  CGenes = NULL,
  FGenes = NULL,
  ccor = 0.4,
  bmode = "RaceID",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterdata_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="filterdata_+3A_mintotal">mintotal</code></td>
<td>
<p>minimum total transcript number required. Cells with less than <code>mintotal</code> transcripts are filtered out. Default is 3000.</p>
</td></tr>
<tr><td><code id="filterdata_+3A_minexpr">minexpr</code></td>
<td>
<p>minimum required transcript count of a gene in at least <code>minnumber</code> cells. All other genes are filtered out. Default is 5.</p>
</td></tr>
<tr><td><code id="filterdata_+3A_minnumber">minnumber</code></td>
<td>
<p>See <code>minexpr</code>. Default is 5.</p>
</td></tr>
<tr><td><code id="filterdata_+3A_lbatch">LBatch</code></td>
<td>
<p>List of experimental batches used for batch effect correction. Each list element contains a vector with cell names
(i.e. column names of the input expression data) falling into this batch. Default is <code>NULL</code>, i.e. no batch correction.</p>
</td></tr>
<tr><td><code id="filterdata_+3A_knn">knn</code></td>
<td>
<p>Number of nearest neighbors used to infer corresponding cell types in different batches. Defult is 10.</p>
</td></tr>
<tr><td><code id="filterdata_+3A_cgenes">CGenes</code></td>
<td>
<p>List of gene names. All genes with correlated expression to any of the genes in <code>CGenes</code> are filtered out for cell type inference.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="filterdata_+3A_fgenes">FGenes</code></td>
<td>
<p>List of gene names to be filtered out for cell type inference. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="filterdata_+3A_ccor">ccor</code></td>
<td>
<p>Correlation coefficient used as a trehshold for determining genes correlated to genes in <code>CGenes</code>.
Only genes correlating  less than <code>ccor</code> to all genes in <code>CGenes</code> are retained for analysis. Default is 0.4.</p>
</td></tr>
<tr><td><code id="filterdata_+3A_bmode">bmode</code></td>
<td>
<p>Method used for batch effect correction. Any of <code>"RaceID","mnnCorrect"</code>. If <code>mnnCorrect</code> from the
<span class="pkg">batchelor</span> package is desired, this package needs to be installed from bioconductor. Default is <code>"RaceID"</code>.</p>
</td></tr>
<tr><td><code id="filterdata_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>FALSE</code> then status output messages are disabled. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An SCseq class object with filtered and normalized expression data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
</code></pre>

<hr>
<h2 id='findoutliers'>Inference of outlier cells and final clustering</h2><span id='topic+findoutliers'></span>

<h3>Description</h3>

<p>This functions performs the outlier identification based on the clusters infered with the <code>clustexp</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findoutliers(
  object,
  probthr = 0.001,
  outminc = 5,
  outlg = 2,
  outdistquant = 0.95,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findoutliers_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="findoutliers_+3A_probthr">probthr</code></td>
<td>
<p>outlier probability threshold for a minimum of <code>outlg</code> genes to be an outlier cell. This probability is computed from a negative binomial
background model of expression in a cluster. Default is 0.001.</p>
</td></tr>
<tr><td><code id="findoutliers_+3A_outminc">outminc</code></td>
<td>
<p>minimal transcript count of a gene in a clusters to be tested for being an outlier gene. Default is 5.</p>
</td></tr>
<tr><td><code id="findoutliers_+3A_outlg">outlg</code></td>
<td>
<p>Minimum number of outlier genes required for being an outlier cell. Default is 2.</p>
</td></tr>
<tr><td><code id="findoutliers_+3A_outdistquant">outdistquant</code></td>
<td>
<p>Real number between zero and one. Outlier cells are merged to outlier clusters if their distance smaller than the outdistquant-quantile of
the distance distribution of  pairs of cells in the orginal clusters after outlier removal. Default is 0.95.</p>
</td></tr>
<tr><td><code id="findoutliers_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>FALSE</code> then status output messages are disabled. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SCseq</code> object with outlier data stored in slot <code>out</code> and slot <code>outlierpar</code>. The final clustering partition is stored in
<code>cpart</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
</code></pre>

<hr>
<h2 id='fitBackVar'>Function for computing a background model of gene expression variability</h2><span id='topic+fitBackVar'></span>

<h3>Description</h3>

<p>This funtion fits a second order polynomial to the variance-mean dependence across all genes in log space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitBackVar(x, mthr = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitBackVar_+3A_x">x</code></td>
<td>
<p>Matrix of transcript counts with genes as rows and cells as columns.</p>
</td></tr>
<tr><td><code id="fitBackVar_+3A_mthr">mthr</code></td>
<td>
<p>Real number. Threshold of log2 mean expression. Genes with mean expression <code>&lt; mthr</code> are discarded prior to fitting the polynomial. Default is -1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List object of four components:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>model fit as returned by the <code>lm</code> function.</p>
</td></tr>
<tr><td><code>genes</code></td>
<td>
<p>genes with expression variance greater than the polynomial fit.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>mean expression of all genes</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>expression variance of all genes</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bg &lt;- fitBackVar(intestinalDataSmall)
</code></pre>

<hr>
<h2 id='fitGammaRt'>Fitting a Gamma distribution to global cell-to-cell variability</h2><span id='topic+fitGammaRt'></span>

<h3>Description</h3>

<p>This function fits a Gamma distribution to the total transcript counts distribution across a given group of cells. Total transcript counts are normalized by the mean total transcript count across the group. This function is used to infer a Gamma distribution of the global cell-to-cell variability across pruned nearest neighbourhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGammaRt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitGammaRt_+3A_x">x</code></td>
<td>
<p>Transcript count matrix with cells as columns and genes as rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shape parameter of the Gamma distribution. This parameter corresponds to the dispersion explained by the global cell-to-cell variability of UMI counts in a negative binomial model.
</p>

<hr>
<h2 id='fitLogVarLogMean'>Second order polynomial fit of mean-variance dependence
This function corrects for the systematic dependence of the variance on the mean by a local regression.</h2><span id='topic+fitLogVarLogMean'></span>

<h3>Description</h3>

<p>Second order polynomial fit of mean-variance dependence
This function corrects for the systematic dependence of the variance on the mean by a local regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitLogVarLogMean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitLogVarLogMean_+3A_x">x</code></td>
<td>
<p>Matrix of transcript counts with genes as rows and cells as columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Second order polynomial model as obtained by <code>lm</code>.
</p>

<hr>
<h2 id='fitNBtb'>Function for fitting a negative binomial noise model of technical and biological variability</h2><span id='topic+fitNBtb'></span>

<h3>Description</h3>

<p>This function fits a negative binomial model to transcript counts of a group of cells thereby deconvoluting variability into sampling noise, global cell-to-cell variability of transcript counts, and residual variability, which corresponds to biological noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitNBtb(z, gamma = 2, x0 = 0, lower = 0, upper = 100, grad = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitNBtb_+3A_z">z</code></td>
<td>
<p>Transcript count matrix with cells as columns and genes as rows.</p>
</td></tr>
<tr><td><code id="fitNBtb_+3A_gamma">gamma</code></td>
<td>
<p>Positive real number. Scale paramter of the cauchy prior. Default is 2.</p>
</td></tr>
<tr><td><code id="fitNBtb_+3A_x0">x0</code></td>
<td>
<p>Real number greater or equal to zero. Location parameter of the cauchy prior.</p>
</td></tr>
<tr><td><code id="fitNBtb_+3A_lower">lower</code></td>
<td>
<p>Real number greater or equal to zero. Lower bound for the maximum a posterior inference of the biological noise. Default is 0.</p>
</td></tr>
<tr><td><code id="fitNBtb_+3A_upper">upper</code></td>
<td>
<p>Real number greater or equal to zero. Upper bound for the maximum a posterior inference of the biological noise. Default is 100.</p>
</td></tr>
<tr><td><code id="fitNBtb_+3A_grad">grad</code></td>
<td>
<p>Logical. If <code>TRUE</code> then maximum a posterior value is inferred by determining the root of the gradient function. Otherwise, the maximum of the posterior probability is determined numerically. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with four columns:
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>Mean expression.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>Biological noise.</p>
</td></tr>
<tr><td><code>rt</code></td>
<td>
<p>Dispersion parameter capturing global cell-to-cell variability of transcript counts.</p>
</td></tr>
<tr><td><code>alphaG</code></td>
<td>
<p>Dispersion parameter capturing global cell-to-cell variability of transcript counts and biological noise.</p>
</td></tr>
</table>

<hr>
<h2 id='fitNBtbCl'>Function for fitting a negative binomial noise model of technical and biological variability</h2><span id='topic+fitNBtbCl'></span>

<h3>Description</h3>

<p>This function fits a negative binomial model to transcript counts of a group of cells thereby deconvoluting variability into sampling noise, global cell-to-cell variability of transcript counts, and residual variability, which corresponds to biological noise. Local mean and and global cell-to-cell variability of transcript counts are pre-computed arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitNBtbCl(z, mu, rt, gamma = 2, x0 = 0.1, lower = 0, upper = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitNBtbCl_+3A_z">z</code></td>
<td>
<p>Transcript count matrix with cells as columns and genes as rows.</p>
</td></tr>
<tr><td><code id="fitNBtbCl_+3A_mu">mu</code></td>
<td>
<p>Vector of mean expression values across cells in <code>z</code>.</p>
</td></tr>
<tr><td><code id="fitNBtbCl_+3A_rt">rt</code></td>
<td>
<p>Vector of dispersion parameters explaining global cell-to-cell variability of transcript counts across cells in <code>z</code>.</p>
</td></tr>
<tr><td><code id="fitNBtbCl_+3A_gamma">gamma</code></td>
<td>
<p>Positive real number. Scale paramter of the cauchy prior. Default is 2.</p>
</td></tr>
<tr><td><code id="fitNBtbCl_+3A_x0">x0</code></td>
<td>
<p>Real number greater or equal to zero. Location parameter of the cauchy prior.</p>
</td></tr>
<tr><td><code id="fitNBtbCl_+3A_lower">lower</code></td>
<td>
<p>Real number greater or equal to zero. Lower bound for the maximum a posterior inference of the biological noise. Default is 0.</p>
</td></tr>
<tr><td><code id="fitNBtbCl_+3A_upper">upper</code></td>
<td>
<p>Real number greater or equal to zero. Upper bound for the maximum a posterior inference of the biological noise. Default is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of biological noise parameters across  cells in <code>z</code>.
</p>

<hr>
<h2 id='fractDotPlot'>Dotplot of gene expression across clusters or samples</h2><span id='topic+fractDotPlot'></span>

<h3>Description</h3>

<p>This is a plotting function for visualizing gene expression across subsets of clusters or samples. The diameter of a dot reflects the fraction of cells
expressing a gene, and the color indicates the expression z-score across all clusters or samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fractDotPlot(
  object,
  genes,
  cluster = NULL,
  samples = NULL,
  subset = NULL,
  zsc = FALSE,
  logscale = TRUE,
  cap = Inf,
  flo = -Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fractDotPlot_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="fractDotPlot_+3A_genes">genes</code></td>
<td>
<p>vector of valid gene names corresponding to row names of slot <code>ndata</code>. The expression for this genes is shown.</p>
</td></tr>
<tr><td><code id="fractDotPlot_+3A_cluster">cluster</code></td>
<td>
<p>vector of valid cluster numbers contained in slot <code>cpart</code>. Default is <code>NULL</code>. If not given, then the <code>samples</code> argument is expected.
If both are given, only the <code>samples</code> argument is considered. If both are <code>NULL</code>, then <code>cluster</code> is initialized with all clusters.</p>
</td></tr>
<tr><td><code id="fractDotPlot_+3A_samples">samples</code></td>
<td>
<p>vector of sample names for all cells. Length and order has to correspond to <code>colnames</code> of slot <code>ndata</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fractDotPlot_+3A_subset">subset</code></td>
<td>
<p>vector of unique sample names to show in the expression dotplot. Each sample names in <code>subset</code> has to occur in <code>samples</code>.
Default is <code>NULL</code>. If not given and <code>samples</code> is not <code>NULL</code>, the subset is intialized with all sample names occuring in <code>samples</code>.</p>
</td></tr>
<tr><td><code id="fractDotPlot_+3A_zsc">zsc</code></td>
<td>
<p>logical. If <code>TRUE</code> then a z-score transformation is applied. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fractDotPlot_+3A_logscale">logscale</code></td>
<td>
<p>logical. If <code>TRUE</code> then a log2 transformation is applied. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fractDotPlot_+3A_cap">cap</code></td>
<td>
<p>real number. Upper limit for the expression, log2 expression, or z-score. Values larges then <code>cap</code> are replaced by <code>cap</code>.</p>
</td></tr>
<tr><td><code id="fractDotPlot_+3A_flo">flo</code></td>
<td>
<p>real number. Lower limit for the expression, log2 expression, or z-score. Values smaller then <code>flo</code> are replaced by <code>flo</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='getExpData'>Function for extracting a filtered expression matrix from a <span class="pkg">RaceID</span> <code>SCseq</code> object</h2><span id='topic+getExpData'></span>

<h3>Description</h3>

<p>This function for extracts a filtered expression matrix from a <span class="pkg">RaceID</span> <code>SCseq</code> object. The <code>filterdata</code> function from
the <span class="pkg">RaceID</span> package has to be run on the <code>SCseq</code> object before.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExpData(object, genes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getExpData_+3A_object">object</code></td>
<td>
<p><span class="pkg">RaceID</span> <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="getExpData_+3A_genes">genes</code></td>
<td>
<p>Vector of valid gene identifiers corresponding to valid rownames of the input expression data. An expression matrix is returned only for these genes.
Default is <code>NULL</code> and an expression matrix is returned for all genes retained after filtering of the <code>SCseq</code> object, i.e. all genes in <code>genes</code>
slot of the <code>SCseq</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>noise Sparse Matrix with genes as rows and cells as columns after filtering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
d &lt;- getExpData(sc)
res &lt;- pruneKnn(d,distM=sc@distances,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
</code></pre>

<hr>
<h2 id='getfdata'>Extracting filtered expression data</h2><span id='topic+getfdata'></span>

<h3>Description</h3>

<p>This functions allows the extraction of a filtered and normalized expression matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getfdata(object, g = NULL, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getfdata_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="getfdata_+3A_g">g</code></td>
<td>
<p>Vector of gene names to be included corresponding to a subset of valid row names of the <code>ndata</code> slot
of the <code>SCseq</code> object. Default is <code>NULL</code> and data for all genes remaining after filtering by the <code>filterdata</code> function are shown.</p>
</td></tr>
<tr><td><code id="getfdata_+3A_n">n</code></td>
<td>
<p>Vector of valid column names corresponding to a subset of valid column names of the <code>ndata</code> slot
of the <code>SCseq</code> object. Default is <code>NULL</code> and data for all cells remaining after filtering by the <code>filterdata</code> function are shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of filtered expression data with genes as rows and cells as columns.
</p>

<hr>
<h2 id='getFilteredCounts'>Function for filtering count data</h2><span id='topic+getFilteredCounts'></span>

<h3>Description</h3>

<p>This function discards lowly expressed genes from a count matrix stored in an <code>SCseq</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFilteredCounts(object, minnumber = 5, minexpr = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFilteredCounts_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="getFilteredCounts_+3A_minnumber">minnumber</code></td>
<td>
<p>Integer number greater or equal to zero. Minimum number of cells required to have at least <code>minexpr</code> transcript counts for a gene to not be discarded. Default is 5.</p>
</td></tr>
<tr><td><code id="getFilteredCounts_+3A_minexpr">minexpr</code></td>
<td>
<p>Integer number greater or equal to zero. Minimum expression of a gene in at least <code>minnumber</code> cells to not be discarded. Default is 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Filtered expression matrix.
</p>

<hr>
<h2 id='getNode'>Extract all genes for a module in a FateID self-orgaizing map</h2><span id='topic+getNode'></span>

<h3>Description</h3>

<p>Extract a vector of all genes corresponding to a given module of a FateID self-organizing map (SOM) of pseudo-time ordered gene expression (or noise) profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNode(ps, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNode_+3A_ps">ps</code></td>
<td>
<p>FateID SOM. List object.</p>
</td></tr>
<tr><td><code id="getNode_+3A_n">n</code></td>
<td>
<p>Integer number of SOM module.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of gene IDs in module <code>n</code>.
</p>

<hr>
<h2 id='getproj'>Extract Projections of all Cells from a Cluster</h2><span id='topic+getproj'></span>

<h3>Description</h3>

<p>This function extracts projections of all cells in a cluster and plots a heatmap of these hierarchically clustered projections (rows)
to all other clusters (columns). A minimum spanning tree of the cluster centers is overlaid for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getproj(object, i, show = TRUE, zscore = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getproj_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
<tr><td><code id="getproj_+3A_i">i</code></td>
<td>
<p>Cluster number. This number has to correspond to one of the RaceID3 clusters included for the StemID2 inference, i.e. to a number present
in slot <code>ldata$lp</code>.</p>
</td></tr>
<tr><td><code id="getproj_+3A_show">show</code></td>
<td>
<p>logical. If <code>TRUE</code>, then plot heatmap of projections. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getproj_+3A_zscore">zscore</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>show=TRUE</code>, then plot z-score-transformed projections. If <code>TRUE</code> and <code>show=FALSE</code>,
then plot untransformed projections. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list ot two components:
</p>
<table>
<tr><td><code>pr</code></td>
<td>
<p>a data.frame of projections for all cells in cluster <code>i</code> (rows) onto all other clusters (columns).</p>
</td></tr>
<tr><td><code>prz</code></td>
<td>
<p>a data.frame of z-transformed projections for all cells in cluster <code>i</code> (rows) onto all other clusters (columns).</p>
</td></tr>
</table>

<hr>
<h2 id='graphCluster'>Function for infering clustering of the pruned k nearest neighbour graph</h2><span id='topic+graphCluster'></span>

<h3>Description</h3>

<p>This function derives a graph object from the pruned k nearest neighbours and infers clusters by modularity
optimizatio nusing the Louvain or the Leiden algorithm on this graph.
A Fruchterman-Rheingold graph layout is also derived from the pruned nearest neighbours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphCluster(
  res,
  pvalue = 0.01,
  use.weights = TRUE,
  use.leiden = FALSE,
  leiden.resolution = 1,
  min.size = 2,
  rseed = 12345
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphCluster_+3A_res">res</code></td>
<td>
<p>List object with k nearest neighbour information returned by <code>pruneKnn</code> function.</p>
</td></tr>
<tr><td><code id="graphCluster_+3A_pvalue">pvalue</code></td>
<td>
<p>Positive real number between 0 and 1. All nearest neighbours with link probability <code>&lt; pvalue</code> are discarded. Default is 0.01.</p>
</td></tr>
<tr><td><code id="graphCluster_+3A_use.weights">use.weights</code></td>
<td>
<p>logical. If TRUE, then nearest-neighbor link probabilities are used to build a graph as input for Louvain clustering. If FALSE, then all links have equal weight. Default is TRUE.</p>
</td></tr>
<tr><td><code id="graphCluster_+3A_use.leiden">use.leiden</code></td>
<td>
<p>logical. If TRUE, then the Leiden algorithm is used. If FALSE, the Louvain algorithm is used. Default is FALSE.</p>
</td></tr>
<tr><td><code id="graphCluster_+3A_leiden.resolution">leiden.resolution</code></td>
<td>
<p>Positive real number. Resolution parameter for the Leiden algorithm.</p>
</td></tr>
<tr><td><code id="graphCluster_+3A_min.size">min.size</code></td>
<td>
<p>Positive integer number. Minimum cluster size. All clusters with less than <code>min.size</code> elements are aggregated into one cluster, to which the largest cluster number is assigned. See output value <code>residual.cluster</code>. Default value is 2.</p>
</td></tr>
<tr><td><code id="graphCluster_+3A_rseed">rseed</code></td>
<td>
<p>Integer number. Random seed to enforce reproducible clustering results. Default is 12345.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List object of three components:
</p>
<table>
<tr><td><code>partition</code></td>
<td>
<p> Vector with clustering partition.</p>
</td></tr>
<tr><td><code>fr</code></td>
<td>
<p> Data.frame with Fruchterman-Rheingold graph layout.</p>
</td></tr>
<tr><td><code>residual.cluster</code></td>
<td>
<p> In case clusters with less than <code>min.size</code> elements occur in the cluster partition, these are grouped into a common cluster, to which the largest cluster number is assigned. If this grouping was done, the cluster number is given by this value. Otherwise, the value of this object is NULL.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- pruneKnn(intestinalDataSmall,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
cl &lt;- graphCluster(res,pvalue=0.01)
</code></pre>

<hr>
<h2 id='imputeexp'>Imputed expression matrix</h2><span id='topic+imputeexp'></span>

<h3>Description</h3>

<p>This functions returns an imputed expression matrix based on the imputing computed with <code>compdist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeexp(object, genes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputeexp_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="imputeexp_+3A_genes">genes</code></td>
<td>
<p>vector of valid gene names corresponding to row names of slot <code>ndata</code>. Default is <code>NULL</code> and imputing is done for all genes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An expression matrix with imputed expression values after size normalization. Genes are in rows and cells in columns.
</p>

<hr>
<h2 id='inspectKNN'>Function for inspecting pruned k-nearest neighbourhoods</h2><span id='topic+inspectKNN'></span>

<h3>Description</h3>

<p>This function allows inspection of the local background model and the pruning of nearest neighbours for a given cell. A dimensional reduction representation is plotted where k nearest neighours and outliers are highlighted. Alternatively, the dependence of the transcript count variance or, alternatively, the coefficient of variation (CV) on the mean in log2 space is plotted. The  mean-variance dependence is plotted along with a loess-regression, a second order polynomial fit, and the background model of the local variability. The CV plot also highlights the local variability associated with cell-to-cell variability of total transcript counts, as calculated directly from the mean and variance of total transcript counts (turquoise) or from a local fit of a gamma distribution (orange).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspectKNN(
  i,
  expData,
  res,
  cl,
  object = NULL,
  nb = res$pars$nb,
  pvalue = 0.01,
  backModel = NULL,
  alpha = res$alpha[i],
  plotSymbol = FALSE,
  id = NULL,
  degree = 2,
  span = 0.75,
  cv = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspectKNN_+3A_i">i</code></td>
<td>
<p>Either integer column index or column name of <code>expData</code>. Pruning is inspected for the neighbourhood of this cell.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_expdata">expData</code></td>
<td>
<p>Matrix of gene expression values with genes as rows and cells as columns. These values have to correspond to unique molecular identifier counts.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_res">res</code></td>
<td>
<p>List object with k nearest neighbour information returned by <code>pruneKnn</code> function.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_cl">cl</code></td>
<td>
<p>List object with clustering information, returned by the <code>graphCluster</code> function.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object. Required if <code>plotSymbol</code> is <code>TRUE</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_nb">nb</code></td>
<td>
<p>Input parameter of <code>pruneKnn</code>. See <code>help(pruneKnn)</code>. Default is res$pars$nb.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_pvalue">pvalue</code></td>
<td>
<p>Positive real number between 0 and 1. All nearest neighbours with link probability <code>&lt; pvalue</code> are pruned. Default is 0.01.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_backmodel">backModel</code></td>
<td>
<p>Optional background model. Second order polynomial fitting the mean-variance dpendence on log2 scales as returned by <code>lm</code>. Default is <code>NULL</code> and the local background model is computed as in <code>pruneKnn</code>.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_alpha">alpha</code></td>
<td>
<p>Input parameter of <code>pruneKnn</code>. See <code>help(pruneKnn)</code>. Default is res$pars$alpha.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_plotsymbol">plotSymbol</code></td>
<td>
<p>Logical. If <code>TRUE</code> then a dimensional reduction representation is plotted highlighting cell <code>i</code>, all k nearest neighbours, all outliers, and the stringest outlier in different colours. Function <code>plotsymbolsmap</code> is used. Additional parameter for this function, such as <code>um=TRUE</code> can be given. Default is <code>FALSE</code>, and the local mean-variance dependence is plotted along with a second order polynomial fit and a local regression. See <code>plotMV</code>.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_id">id</code></td>
<td>
<p>Valid column name of expData. If <code>plotSymbol=TRUE</code> this corresponding cell is highlighted in the dimensional reduction representation.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_degree">degree</code></td>
<td>
<p>Input parameter for mean-variance fit. See <code>plotMV</code>.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_span">span</code></td>
<td>
<p>Input parameter for mean-variance fit. See <code>plotMV</code>.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_cv">cv</code></td>
<td>
<p>Input parameter for mean-variance fit. See <code>plotMV</code>.</p>
</td></tr>
<tr><td><code id="inspectKNN_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>plotsymbolsmap</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List object with six components:
</p>
<table>
<tr><td><code>pv.neighbours.cell</code></td>
<td>
<p>Vector of outlier p-values (Bonferroni-corrected) for each of the k-nearest neighbours.</p>
</td></tr>
<tr><td><code>cluster.neighours</code></td>
<td>
<p>Vector of cluster numbers for central cell and each of the k-nearest neighbours.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p><code>alpha</code> parameter used for pruning.</p>
</td></tr>
<tr><td><code>expr.neighbours</code></td>
<td>
<p>Matrix of normalized transcript counts for the central cell and each of the k-nearest neighbours (normalized to the minimum number of total trascript counts across all neighours). Additional columns indicate inferred local mean, standard deviation, and strongest outlier p-value. Rows are sorted by p-values of the strongest outlier cell in increasing order. </p>
</td></tr>
<tr><td><code>pv.neighbours</code></td>
<td>
<p>Matrix of outlier p-values of all genes for the central cells and each of the k-nearest neighbours. Rows are sorted by p-values of the strongest outlier cell in increasing order.</p>
</td></tr>
<tr><td><code>strongest.outlier</code></td>
<td>
<p>Column name of strongest outlier.</p>
</td></tr>
</table>

<hr>
<h2 id='intestinalData'>Single-cell transcriptome data of intestinal epithelial cells</h2><span id='topic+intestinalData'></span>

<h3>Description</h3>

<p>This dataset contains gene expression values, i. e. transcript counts, of 278 intestinal epithelial cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intestinalData
</code></pre>


<h3>Format</h3>

<p>A sparse matrix (using the <span class="pkg">Matrix</span>) with cells as columns and genes as rows. Entries are raw transcript counts.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>References</h3>

<p>Grün et al. (2016) Cell Stem Cell 19(2): 266-77 &lt;DOI:10.1016/j.stem.2016.05.010&gt;
(<a href="https://pubmed.ncbi.nlm.nih.gov/27345837/">PubMed</a>)
</p>

<hr>
<h2 id='intestinalDataSmall'>Single-cell transcriptome data of intestinal epithelial cells</h2><span id='topic+intestinalDataSmall'></span>

<h3>Description</h3>

<p>This dataset is a smaller subset of the original dataset, which contains gene expression values, i. e. transcript counts, of 278 intestinal epithelial cells.
The dataset is included for quick testing and examples. Only cells with &gt;10,000 transcripts per cell and only genes with &gt;20 transcript counts in &gt;10 cells were retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intestinalDataSmall
</code></pre>


<h3>Format</h3>

<p>A sparse matrix (using the <span class="pkg">Matrix</span>) with cells as columns and genes as rows. Entries are raw transcript counts.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>References</h3>

<p>Grün et al. (2016) Cell Stem Cell 19(2): 266-77 &lt;DOI:10.1016/j.stem.2016.05.010&gt;
(<a href="https://pubmed.ncbi.nlm.nih.gov/27345837/">PubMed</a>)
</p>

<hr>
<h2 id='lineagegraph'>Inference of a Lineage Graph</h2><span id='topic+lineagegraph'></span>

<h3>Description</h3>

<p>This function assembles a lineage graph based on the cell projections onto inter-cluster links.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineagegraph(object, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lineagegraph_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
<tr><td><code id="lineagegraph_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>FALSE</code> then status output messages are disabled. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An Ltree class object with lineage graph-related data stored in slots <code>ltcoord</code>, <code>prtree</code>, and <code>cdata</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
sc &lt;- comptsne(sc)
ltr &lt;- Ltree(sc)
ltr &lt;- compentropy(ltr)
ltr &lt;- projcells(ltr)
ltr &lt;- lineagegraph(ltr)
</code></pre>

<hr>
<h2 id='Ltree-class'>The Ltree Class</h2><span id='topic+Ltree-class'></span><span id='topic+Ltree'></span>

<h3>Description</h3>

<p>The Ltree class is the central object storing all information generated during lineage tree inference by the StemID algorithm.
It comprises a number of slots for a variety of objects.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ltree-class_+3A_object">object</code></td>
<td>
<p>An Ltree object.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>sc</code></dt><dd><p>An <code>SCseq</code> object with the RaceID3 analysis of the single-cell RNA-seq data for which a lineage tree should be derived.</p>
</dd>
<dt><code>ldata</code></dt><dd><p>List object storing information on the clustering partition, the distance matrix, and the cluster centers in dimensionally-reduced
input space and in two-dimensional t-sne space. Elements:
<code>lp</code>: vector with the filtered partition into clusters after discarding clusters with cthr cells or less.
<code>pdi</code>:matrix with the coordinates of all cells in the embedded space. Clusters with <code>cthr</code> transcripts or less were discarded (see function <code>projcells</code>).
Rows are medoids and columns are coordinates.
<code>cn</code>: data.frame with the coordinates of the cluster medoids in the embedded space. Clusters with <code>cthr</code> transcripts or less were discarded.
Rows are medoids and columns are coordinates.
<code>m</code>: vector with the numbers of the clusters which survived the filtering.
<code>pdil</code>:    data.frame with coordinates of cells in the two-dimensional t-SNE representation computed by RaceID3. Clusters with <code>cthr</code> transcripts or less were
discarded. Rows are cells and columns are coordinates.
<code>cnl</code>:    data.frame with the coordinates of the cluster medoids in the two-dimensional t-SNE representation computed by RaceID3. Clusters with <code>cthr</code>
transcripts or less were discarded. Rows are medoids and columns are coordinates.</p>
</dd>
<dt><code>entropy</code></dt><dd><p>Vector with transcriptome entropy computed for each cell.</p>
</dd>
<dt><code>trproj</code></dt><dd><p>List containing two data.frames. Elements:
<code>res</code>:    data.frame with three columns for each cell. The first column <code>o</code> shows the cluster of a cell,
the second column <code>l</code> shows the cluster number for the link the cell is assigned to, and the third column <code>h</code> shows the projection as a fraction of the length
of the inter-cluster link. Parallel projections are positive, while anti-parallel projections are negative.
<code>rma</code>: data.frame with all projection coordinates for each cell. Rows are cells and columns are clusters. Projections are given as a fraction of the length of the
inter-cluster link. Parallel projections are positive, while anti-parallel projections are negative. The column corresponding to the originating cluster of a cell
shows <code>NA</code>.</p>
</dd>
<dt><code>par</code></dt><dd><p>List of parameters used for the StemID2 analysis.</p>
</dd>
<dt><code>prback</code></dt><dd><p>data.frame of the same structure as the <code>trproj$res</code>. In case randomizations are used to compute significant projections, the projections of all
<code>pdishuff</code> randomizations are appended to this data.frame and therefore the number of rows corresponds to the number of cells multiplied by <code>pdishuf</code>. See
function <code>projback</code>.</p>
</dd>
<dt><code>prbacka</code></dt><dd><p>data.frame reporting the aggregated results of the randomizations with four columns. Column <code>n</code> denotes the number of the randomization sample,
column <code>o</code> and <code>l</code> contain the numbers of the originating and the terminal cluster, respectively, for each inter-cluster link and column <code>count</code> shows
the number of cells assigned to this link in randomization sample <code>n</code>. The discrete distribution for the computation of the link p-value is given by the data
contained in this object (if <code>nmode=FALSE</code>).</p>
</dd>
<dt><code>ltcoord</code></dt><dd><p>Matrix storing projection coordinates of all cells in the two-dimensional t-SNE space, used for visualization.</p>
</dd>
<dt><code>prtree</code></dt><dd><p>List with two elements. The first element <code>l</code> stores a list with the projection coordinates for each link. The name of each element identifies the
link and is composed of two cluster numbers separated by a dot. The second element <code>n</code> is a list of the same structure and contains the cell names corresponding
to the projection coordinates stored in <code>l</code>.</p>
</dd>
<dt><code>cdata</code></dt><dd><p>list of data.frames, each with cluster ids as rows and columns:
<code>counts</code> data.frame indicating the number of cells on the links connecting the cluster of origin (rows) to other clusters (columns).
<code>counts.br</code> data.frame containing the cell counts on cluster connections averaged across the randomized background samples (if <code>nmode = FALSE</code>) or as derived
from sampling statistics (if <code>nmode = TRUE</code>).
<code>pv.e</code> matrix of enrichment p-values estimated from sampling statistics (if <code>nmode = TRUE</code>); entries are 0 if the observed number of cells on the respective
link exceeds the <code>(1 – pethr)</code>-quantile of the randomized background distribution and 0.5 otherwise (if <code>nmode = FALSE</code>).
<code>pv.d</code> matrix of depletion p-values estimated from sampling statistics (if <code>nmode = TRUE</code>); entries are 0 if the observed number of cells on the respective
link is lower than the <code>pethr</code>-quantile of the randomized background distribution and 0.5 otherwise (if <code>nmode = FALSE</code>).
<code>pvn.e</code> matrix of enrichment p-values estimated from sampling statistics (if <code>nmode = TRUE</code>); 1- quantile, with the quantile estimated from the number of cells on a link as derived from the randomized background distribution (if <code>nmode = FALSE</code>). 
<code>pvn.d</code> matrix of depletion p-values estimated from sampling statistics (if <code>nmode = TRUE</code>); quantile estimated from the number of cells on a link as derived from the randomized background distribution (if <code>nmode = FALSE</code>).</p>
</dd>
</dl>

<hr>
<h2 id='maxNoisyGenes'>Function for extracting genes maximal variability</h2><span id='topic+maxNoisyGenes'></span>

<h3>Description</h3>

<p>This function extracts genes with maximal variability in a cluster or in the entire data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxNoisyGenes(noise, cl = NULL, set = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxNoisyGenes_+3A_noise">noise</code></td>
<td>
<p>List object with the background noise model and a variability matrix, returned by the <code>compNoise</code> function.</p>
</td></tr>
<tr><td><code id="maxNoisyGenes_+3A_cl">cl</code></td>
<td>
<p>List object with clustering information, returned by the <code>graphCluster</code> function. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="maxNoisyGenes_+3A_set">set</code></td>
<td>
<p>Postive integer number or vector of integers corresponding to valid cluster numbers. Noise levels are computed across all cells in this subset of clusters. Default is <code>NULL</code> and noise levels are computed across all cells.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with average gene expression variability in decreasing order, computed across all cells or only cells in a set of clusters (if <code>cl</code> and
<code>set</code> are given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- pruneKnn(intestinalDataSmall,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
noise &lt;- compNoise(intestinalDataSmall,res,pvalue=0.01,genes = NULL,no_cores=1)
mgenes &lt;- maxNoisyGenes(noise)
</code></pre>

<hr>
<h2 id='maxNoisyGenesTB'>Function for extracting genes maximal variability</h2><span id='topic+maxNoisyGenesTB'></span>

<h3>Description</h3>

<p>This function extracts genes with maximal variability in a cluster or in the entire data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxNoisyGenesTB(noise, cl = NULL, set = NULL, minobs = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxNoisyGenesTB_+3A_noise">noise</code></td>
<td>
<p>List object with noise parameters returned by the <code>compTBNoise</code> function.</p>
</td></tr>
<tr><td><code id="maxNoisyGenesTB_+3A_cl">cl</code></td>
<td>
<p>List object with clustering information, returned by the <code>graphCluster</code> function. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="maxNoisyGenesTB_+3A_set">set</code></td>
<td>
<p>Postive integer number or vector of integers corresponding to valid cluster numbers. Noise levels are computed across all cells in this subset of clusters. Default is <code>NULL</code> and noise levels are computed across all cells.</p>
</td></tr>
<tr><td><code id="maxNoisyGenesTB_+3A_minobs">minobs</code></td>
<td>
<p>Positive integer number. Only genes with at least <code>minobs</code> neighbourhoods with non-zero biological noise levels in <code>set</code> are included. Default is 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with average gene expression variability in decreasing order, computed across all cells or only cells in a set of clusters (if <code>cl</code> and
<code>set</code> are given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- pruneKnn(intestinalDataSmall,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
noise &lt;- compNoise(intestinalDataSmall,res,pvalue=0.01,genes = NULL,no_cores=1)
mgenes &lt;- maxNoisyGenes(noise)
</code></pre>

<hr>
<h2 id='noiseBaseFit'>Function for computing a fit to the baseline of gene expression variability</h2><span id='topic+noiseBaseFit'></span>

<h3>Description</h3>

<p>This function fits a second order polynomial to the baseline variance-mean dependence across all genes in log space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noiseBaseFit(x, step = 0.01, thr = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noiseBaseFit_+3A_x">x</code></td>
<td>
<p>Matrix of gene expression values with genes as rows and cells as columns.</p>
</td></tr>
<tr><td><code id="noiseBaseFit_+3A_step">step</code></td>
<td>
<p>Positive real number between 0 and 1. Bin size for the computation. The interval of mean gene expression values is divided into bins with equal number of data points and <code>step</code> equals the fraction of data points in each bin. Default is 0.01.</p>
</td></tr>
<tr><td><code id="noiseBaseFit_+3A_thr">thr</code></td>
<td>
<p>Positive real number between 0 and 1. In each mean expression bin defined by <code>step</code> the lowest <code>thr</code>-quantile of the gene expression variance distribution is selected. The selected data points from all bins are used for a second order polynomial fit of the variance-mean dependence in log space. Default is 0.05.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List object of three components:
</p>
<table>
<tr><td><code>nfit</code></td>
<td>
<p>model fit as returned by the <code>lm</code> function.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>mean expression of all genes</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>expression variance of all genes</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- noiseBaseFit(intestinalDataSmall,step=.01,thr=.05)
</code></pre>

<hr>
<h2 id='plotB'>Boxplots for features across clusters</h2><span id='topic+plotB'></span>

<h3>Description</h3>

<p>Function to generate boxplots of a feature vector across different clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotB(x, part, cluster = NULL, set = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotB_+3A_x">x</code></td>
<td>
<p>Vector of real numbers.</p>
</td></tr>
<tr><td><code id="plotB_+3A_part">part</code></td>
<td>
<p>Vector with cluster partition, e.g., element <code>partition</code> returned by the <code>graphCluster</code> function.</p>
</td></tr>
<tr><td><code id="plotB_+3A_cluster">cluster</code></td>
<td>
<p>Positive integer corresponing to valid cluster number or <code>NULL</code>. If valid cluster number, then a horizontal line is drawn indicating the median value of <code>x</code> for the corresponding cluster. If <code>NULL</code> no line is drawn. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotB_+3A_set">set</code></td>
<td>
<p>Ordered set of valid cluster numbers. If <code>box</code> equals <code>TRUE</code> than data will only be plotted for these clusters in the give</p>
</td></tr>
<tr><td><code id="plotB_+3A_...">...</code></td>
<td>
<p>Additional parameters of <code>boxplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotbackground'>Plot Background Model</h2><span id='topic+plotbackground'></span>

<h3>Description</h3>

<p>This functions produces a scatter plot showing the gene expression variance as a function of the mean and the inferred
polynomial fit of the background model computed by RaceID3. It also shows a local regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotbackground(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotbackground_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotBackVar'>Function for plottinhg the background model of gene expression variability</h2><span id='topic+plotBackVar'></span>

<h3>Description</h3>

<p>This function plots the variance against mean expression across all genes and a second order polynomial to the variance-mean dependence in log space. It also plots a local regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBackVar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBackVar_+3A_x">x</code></td>
<td>
<p>List object returned by function <code>fitBackVar</code> or list object returned by function <code>pruneKnn</code> (if it was run with <code>FSelect=TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bg &lt;- fitBackVar(intestinalDataSmall)
plotBackVar(bg)
</code></pre>

<hr>
<h2 id='plotdiffgenes'>Barplot of differentially expressed genes</h2><span id='topic+plotdiffgenes'></span>

<h3>Description</h3>

<p>This functions produces a barplot of differentially expressed genes derived by the function <code>diffgenes</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotdiffgenes(z, gene)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotdiffgenes_+3A_z">z</code></td>
<td>
<p>Output of <code>diffgenes</code></p>
</td></tr>
<tr><td><code id="plotdiffgenes_+3A_gene">gene</code></td>
<td>
<p>Valid gene name. Has to correspond to one of the rownames of the <code>ndata</code> slot of the <code>SCseq</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
x &lt;- diffgenes(sc,1,2)
head(x$z)
plotdiffgenes(x,names(x$z)[1])
</code></pre>

<hr>
<h2 id='plotdiffgenesnb'>Function for plotting differentially expressed genes</h2><span id='topic+plotdiffgenesnb'></span>

<h3>Description</h3>

<p>This is a plotting function for visualizing the output of the <code>diffexpnb</code> or <code>clustdiffgenes</code> function as MA plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotdiffgenesnb(
  x,
  pthr = 0.05,
  padj = TRUE,
  lthr = 0,
  mthr = -Inf,
  Aname = NULL,
  Bname = NULL,
  show_names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotdiffgenesnb_+3A_x">x</code></td>
<td>
<p>output of the function <code>diffexpnb</code>.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_pthr">pthr</code></td>
<td>
<p>real number between 0 and 1. This number represents the p-value cutoff applied for displaying differentially expressed genes. Default value is 0.05. The parameter <code>padj</code> (see below) determines if this cutoff is applied to the uncorrected p-value or to the Benjamini-Hochberg corrected false discovery rate.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_padj">padj</code></td>
<td>
<p>logical value. If <code>TRUE</code>, then genes with a Benjamini-Hochberg corrected false discovery rate lower than <code>pthr</code> are displayed. If <code>FALSE</code>, then genes with a p-value lower than <code>pthr</code> are displayed.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_lthr">lthr</code></td>
<td>
<p>real number between 0 and Inf. Differentially expressed genes are displayed only for log2 fold-changes greater than <code>lthr</code>. Default value is 0.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_mthr">mthr</code></td>
<td>
<p>real number between -Inf and Inf. Differentially expressed genes are displayed only for log2 mean expression greater than <code>mthr</code>. Default value is -Inf.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_aname">Aname</code></td>
<td>
<p>name of expression set <code>A</code>, which was used as input to <code>diffexpnb</code>. If provided, this name is used in the axis labels. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_bname">Bname</code></td>
<td>
<p>name of expression set <code>B</code>, which was used as input to <code>diffexpnb</code>. If provided, this name is used in the axis labels. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_show_names">show_names</code></td>
<td>
<p>logical value. If <code>TRUE</code> then gene names displayed for differentially expressed genes. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_...">...</code></td>
<td>
<p>Additional arguments for function <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
A &lt;- names(sc@cpart)[sc@cpart %in% c(1,2)]
B &lt;- names(sc@cpart)[sc@cpart %in% c(3)]
y &lt;- diffexpnb(getfdata(sc,n=c(A,B)), A=A, B=B )
plotdiffgenesnb(y)
</code></pre>

<hr>
<h2 id='plotDiffNoise'>Function for plotting differentially variable genes</h2><span id='topic+plotDiffNoise'></span>

<h3>Description</h3>

<p>This is a plotting function for visualizing the output of the <code>diffNoisyGenesTB</code> function as MA plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDiffNoise(
  x,
  pthr = 0.05,
  mu = TRUE,
  lthr = 0,
  ps = 0.01,
  mthr = -Inf,
  set.name = NULL,
  bgr.name = NULL,
  show_names = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiffNoise_+3A_x">x</code></td>
<td>
<p>output of the function <code>diffNoisyGenesTB</code>.</p>
</td></tr>
<tr><td><code id="plotDiffNoise_+3A_pthr">pthr</code></td>
<td>
<p>real number between 0 and 1. This number represents the p-value cutoff applied for displaying differentially variable genes. Default value is 0.05.</p>
</td></tr>
<tr><td><code id="plotDiffNoise_+3A_mu">mu</code></td>
<td>
<p>logical value. If <code>TRUE</code> then the log2 fold change in variability is plotted as a function of log2 average expresion. Otherwise, it is plotted as a function of mean variability.</p>
</td></tr>
<tr><td><code id="plotDiffNoise_+3A_lthr">lthr</code></td>
<td>
<p>real number between 0 and Inf. Differentially variable genes are displayed only for log2 fold-changes greater than <code>lthr</code>. Default value is 0.</p>
</td></tr>
<tr><td><code id="plotDiffNoise_+3A_ps">ps</code></td>
<td>
<p>positive real number. Pseudo-count added to component <code>mu.all</code> and <code>epsilon.all</code> of argument <code>x</code> to avoid taking logarithm of zero. Default is 0.01.</p>
</td></tr>
<tr><td><code id="plotDiffNoise_+3A_mthr">mthr</code></td>
<td>
<p>real number between -Inf and Inf. Differentially variable genes are displayed only for log2 mean expression (or mean noise, if <code>mu</code> equals <code>FALSE</code>) greater than <code>mthr</code>. Default value is -Inf.</p>
</td></tr>
<tr><td><code id="plotDiffNoise_+3A_set.name">set.name</code></td>
<td>
<p>name of <code>set</code>, which was used as input to <code>diffNoisyGenesTB</code>. If provided, this name is used in the axis labels. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotDiffNoise_+3A_bgr.name">bgr.name</code></td>
<td>
<p>name of <code>bgr</code>, which was used as input to <code>diffNoisyGenesTB</code>. If provided, this name is used in the axis labels. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotDiffNoise_+3A_show_names">show_names</code></td>
<td>
<p>logical value. If <code>TRUE</code> then gene names displayed for differentially variable genes. Default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotdimsat'>Plotting the Saturation of Explained Variance</h2><span id='topic+plotdimsat'></span>

<h3>Description</h3>

<p>This functions plots the explained variance as a function of PCA/ICA components computed by the function <code>CCcorrect</code>. The number of components where
the change in explained variability upon adding further components approaches linear behaviour demarcates the saturation point and is highlighted in blue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotdimsat(object, change = TRUE, lim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotdimsat_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="plotdimsat_+3A_change">change</code></td>
<td>
<p>logical. If <code>TRUE</code> then the change in explained variance is plotted. Default is <code>FALSE</code> and the explained variance is shown.</p>
</td></tr>
<tr><td><code id="plotdimsat_+3A_lim">lim</code></td>
<td>
<p>Number of components included for he calculation and shown in the plot. Default is <code>NULL</code> and all components are included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotdistanceratio'>Histogram of Cell-to-Cell Distances in Real versus Embedded Space</h2><span id='topic+plotdistanceratio'></span>

<h3>Description</h3>

<p>This function plots a histogram of the ratios of cell-to-cell distances in the original versus the high-dimensional embedded space used as input for
the StemID2 inferences. The embedded space approximates correlation-based distances by Euclidean distances obtained by classical multi-dimensional scaling.
A minimum spanning tree of the cluster centers is overlaid for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotdistanceratio(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotdistanceratio_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='plotexpmap'>Highlighting gene expression in a dimensional reduction representation</h2><span id='topic+plotexpmap'></span>

<h3>Description</h3>

<p>This functions highlights gene expression in a two-dimensional t-SNE map, UMAP, or a Fruchterman-Rheingold graph layout
of the singe-cell transcriptome data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotexpmap(
  object,
  g,
  n = NULL,
  logsc = FALSE,
  imputed = FALSE,
  fr = FALSE,
  um = FALSE,
  cells = NULL,
  cex = 0.5,
  map = TRUE,
  leg = TRUE,
  noise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotexpmap_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="plotexpmap_+3A_g">g</code></td>
<td>
<p>Individual gene name or vector with a group of gene names corresponding to a subset of valid row names of the <code>ndata</code> slot
of the <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="plotexpmap_+3A_n">n</code></td>
<td>
<p>String of characters representing the title of the plot. Default is <code>NULL</code> and the first element of <code>g</code> is chosen.</p>
</td></tr>
<tr><td><code id="plotexpmap_+3A_logsc">logsc</code></td>
<td>
<p>logical. If <code>TRUE</code>, then gene expression values are log2-transformed after adding a pseudo-count of 0.1. Default is <code>FALSE</code>
and untransformed values are shown.</p>
</td></tr>
<tr><td><code id="plotexpmap_+3A_imputed">imputed</code></td>
<td>
<p>logical. If <code>TRUE</code> and imputing was done by calling <code>compdist</code> with <code>knn &gt; 0</code>, then imputed expression values are shown. If <code>FALSE</code>, then raw counts are shown. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotexpmap_+3A_fr">fr</code></td>
<td>
<p>logical. If <code>TRUE</code> then plot Fruchterman-Rheingold layout. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotexpmap_+3A_um">um</code></td>
<td>
<p>logical. If <code>TRUE</code> then plot umap dimensional reduction representation. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotexpmap_+3A_cells">cells</code></td>
<td>
<p>Vector of valid cell names corresponding to column names of slot <code>ndata</code> of the <code>SCseq</code> object. Gene expression is ony shown for
this subset.</p>
</td></tr>
<tr><td><code id="plotexpmap_+3A_cex">cex</code></td>
<td>
<p>size of data points. Default value is 0.5.</p>
</td></tr>
<tr><td><code id="plotexpmap_+3A_map">map</code></td>
<td>
<p>logical. If <code>TRUE</code> then data points are shown. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotexpmap_+3A_leg">leg</code></td>
<td>
<p>logical. If <code>TRUE</code> then the legend is shown. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotexpmap_+3A_noise">noise</code></td>
<td>
<p>logical. If <code>TRUE</code> then display local gene expression variability instead of gene expression (requires VarID analysis)/ Default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotExpNoise'>Noise-expression scatter plot</h2><span id='topic+plotExpNoise'></span>

<h3>Description</h3>

<p>Plotting noise (epsilon) as a function of normalized or non-normalized expression for a given gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotExpNoise(g, object, noise, set = NULL, ps = 0.1, norm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotExpNoise_+3A_g">g</code></td>
<td>
<p>Valid gene ID with available expression and noise estimates.</p>
</td></tr>
<tr><td><code id="plotExpNoise_+3A_object">object</code></td>
<td>
<p><span class="pkg">RaceID</span> <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="plotExpNoise_+3A_noise">noise</code></td>
<td>
<p>List object returned by the <code>compTBNoise</code> function.</p>
</td></tr>
<tr><td><code id="plotExpNoise_+3A_set">set</code></td>
<td>
<p>Set of valid cluster numbers. Default is <code>NULL</code> and data are plotted for cells from all clusters.</p>
</td></tr>
<tr><td><code id="plotExpNoise_+3A_ps">ps</code></td>
<td>
<p>Real number. Pseudo-count added to noise and expression estimates. Default is 0.1.</p>
</td></tr>
<tr><td><code id="plotExpNoise_+3A_norm">norm</code></td>
<td>
<p>logical. If <code>FALSE</code>, then noise is plotted versus non-normalized expression. Default is <code>TRUE</code> and noise is plotted against normalized expression.</p>
</td></tr>
<tr><td><code id="plotExpNoise_+3A_...">...</code></td>
<td>
<p>Additional arguments of <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='plotfeatmap'>Highlighting feature values in a dimensional reduction representation</h2><span id='topic+plotfeatmap'></span>

<h3>Description</h3>

<p>This functions highlights feature values in a two-dimensional t-SNE map, UMAP, or a Fruchterman-Rheingold graph layout
of the singe-cell transcriptome data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotfeatmap(
  object,
  g,
  n = NULL,
  logsc = FALSE,
  fr = FALSE,
  um = FALSE,
  cells = NULL,
  cex = 1,
  map = TRUE,
  leg = TRUE,
  flo = NULL,
  ceil = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotfeatmap_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="plotfeatmap_+3A_g">g</code></td>
<td>
<p>Vector of real numbered features to highlight in the dimensional reduction representation, NAs will be highlighted in grey.</p>
</td></tr>
<tr><td><code id="plotfeatmap_+3A_n">n</code></td>
<td>
<p>String of characters representing the title of the plot. Default is <code>NULL</code> and the first element of <code>g</code> is chosen.</p>
</td></tr>
<tr><td><code id="plotfeatmap_+3A_logsc">logsc</code></td>
<td>
<p>logical. If <code>TRUE</code>, then feature values are log2-transformed. Default is <code>FALSE</code>.
and untransformed values are shown.</p>
</td></tr>
<tr><td><code id="plotfeatmap_+3A_fr">fr</code></td>
<td>
<p>logical. If <code>TRUE</code> then plot Fruchterman-Rheingold layout. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotfeatmap_+3A_um">um</code></td>
<td>
<p>logical. If <code>TRUE</code> then plot umap dimensional reduction representation. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotfeatmap_+3A_cells">cells</code></td>
<td>
<p>Vector of valid cell names corresponding to column names of slot <code>ndata</code> of the <code>SCseq</code> object. Gene expression is ony shown for
this subset.</p>
</td></tr>
<tr><td><code id="plotfeatmap_+3A_cex">cex</code></td>
<td>
<p>size of data points. Default value is 1.</p>
</td></tr>
<tr><td><code id="plotfeatmap_+3A_map">map</code></td>
<td>
<p>logical. If <code>TRUE</code> then data points are shown. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotfeatmap_+3A_leg">leg</code></td>
<td>
<p>logical. If <code>TRUE</code> then the legend is shown. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotfeatmap_+3A_flo">flo</code></td>
<td>
<p>Numeric. Lower bound for feature values. All values smaller then <code>flo</code> are replaced by <code>flo</code>.
#' Default is <code>NULL</code> and no <code>fllo</code> is applied.</p>
</td></tr>
<tr><td><code id="plotfeatmap_+3A_ceil">ceil</code></td>
<td>
<p>Numeric. Upper bound for feature values. All values larger then <code>ceil</code> are replaced by <code>ceil</code>.
Default is <code>NULL</code> and no <code>ceil</code> is applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotgraph'>StemID2 Lineage Graph</h2><span id='topic+plotgraph'></span>

<h3>Description</h3>

<p>This function plots a graph of lineage trajectories connecting RaceID3 cluster medoids as inferred by StemID2 to approximate the lineage tree. The plot
highlights significant links, where colour indicates the level of significance and width indicates the link score. The node colour reflects the level
of transcriptome entropy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotgraph(
  object,
  showCells = FALSE,
  showMap = TRUE,
  tp = 0.5,
  scthr = 0,
  cex = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotgraph_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
<tr><td><code id="plotgraph_+3A_showcells">showCells</code></td>
<td>
<p>logical. If <code>TRUE</code>, then projections of cells are shown in the plot. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotgraph_+3A_showmap">showMap</code></td>
<td>
<p>logical. Tf <code>TRUE</code>, then show transparent t-SNE map (with transparency <code>tp</code>) of cells in the background. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotgraph_+3A_tp">tp</code></td>
<td>
<p>Real number between zero and one. Level of transparency of the t-SNE map. Deafault is 0.5. See <code>showMap</code>.</p>
</td></tr>
<tr><td><code id="plotgraph_+3A_scthr">scthr</code></td>
<td>
<p>Real number between zero and one. Score threshold for links to be shown in the graph. For <code>scthr=0</code> all significant links are shown.
The maximum score is one. Default is 0.</p>
</td></tr>
<tr><td><code id="plotgraph_+3A_cex">cex</code></td>
<td>
<p>real positive number. Size of data points. Deault is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='plotjaccard'>Plot Jaccard Similarities</h2><span id='topic+plotjaccard'></span>

<h3>Description</h3>

<p>This functions plots a barchart of Jaccard similarities for the RaceID3 clusters before outlier identification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotjaccard(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotjaccard_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotlabelsmap'>Plot labels in a dimensional reduction representation</h2><span id='topic+plotlabelsmap'></span>

<h3>Description</h3>

<p>This functions plots cell labels into a two-dimensional t-SNE map, UMAP, or a Fruchterman-Rheingold graph layout
of the singe-cell transcriptome data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotlabelsmap(object, labels = NULL, fr = FALSE, um = FALSE, cex = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotlabelsmap_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="plotlabelsmap_+3A_labels">labels</code></td>
<td>
<p>Vector of labels for all cells to be highlighted in the t-SNE map. The order has to be the same as for the
columns in slot <code>ndata</code> of the <code>SCseq</code> object. Default is <code>NULL</code> and cell names are highlighted.</p>
</td></tr>
<tr><td><code id="plotlabelsmap_+3A_fr">fr</code></td>
<td>
<p>logical. If <code>TRUE</code> then plot Fruchterman-Rheingold layout. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotlabelsmap_+3A_um">um</code></td>
<td>
<p>logical. If <code>TRUE</code> then plot umap dimensional reduction representation. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotlabelsmap_+3A_cex">cex</code></td>
<td>
<p>positive real number. Size of the labels. Default is 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotlinkpv'>Heatmap of Link P-values</h2><span id='topic+plotlinkpv'></span>

<h3>Description</h3>

<p>This function plots a heatmap of link p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotlinkpv(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotlinkpv_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='plotlinkscore'>Heatmap of Link Scores</h2><span id='topic+plotlinkscore'></span>

<h3>Description</h3>

<p>This function plots a heatmap of link score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotlinkscore(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotlinkscore_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='plotmap'>Plotting a dimensional reduction representation</h2><span id='topic+plotmap'></span>

<h3>Description</h3>

<p>This functions plots a two-dimensional t-SNE map, UMAP, or a Fruchterman-Rheingold graph layout
of the singe-cell transcriptome data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmap(object, final = TRUE, tp = 1, fr = FALSE, um = FALSE, cex = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotmap_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_final">final</code></td>
<td>
<p>logical. If <code>TRUE</code>, then highlight final clusters after outlier identification. If <code>FALSE</code>, then highlight initial
clusters prior to outlier identification. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_tp">tp</code></td>
<td>
<p>Number between 0 and 1 to change transparency of dots in the map. Default is 1.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_fr">fr</code></td>
<td>
<p>logical. If <code>TRUE</code> then plot Fruchterman-Rheingold layout. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_um">um</code></td>
<td>
<p>logical. If <code>TRUE</code> then plot umap dimensional reduction representation. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_cex">cex</code></td>
<td>
<p>size of data points. Default value is 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotmarkergenes'>Plotting a Heatmap of Marker Gene Expression</h2><span id='topic+plotmarkergenes'></span>

<h3>Description</h3>

<p>This functions generates a heatmap of expression for  defined group of genes and can highlight the clustering partition and another sample grouping,
e.g. origin or cell type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmarkergenes(
  object,
  genes,
  imputed = FALSE,
  cthr = 0,
  cl = NULL,
  cells = NULL,
  order.cells = FALSE,
  aggr = FALSE,
  norm = FALSE,
  cap = NULL,
  flo = NULL,
  samples = NULL,
  cluster_cols = FALSE,
  cluster_rows = TRUE,
  cluster_set = FALSE,
  samples_col = NULL,
  zsc = FALSE,
  logscale = TRUE,
  noise = FALSE,
  fontsize = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotmarkergenes_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_genes">genes</code></td>
<td>
<p>A vector with a group of gene names corresponding to a subset of valid row names of the <code>ndata</code> slot
of the <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_imputed">imputed</code></td>
<td>
<p>logical. If <code>TRUE</code> and imputing was done by calling <code>compdist</code> with <code>knn &gt; 0</code>, then imputed expression values are shown.
If <code>FALSE</code>, then raw counts are shown. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_cthr">cthr</code></td>
<td>
<p>Interger number greater or equal zero. Only clusters with <code>&gt;cthr</code> cells are included in the t-SNE map. Default is 0.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_cl">cl</code></td>
<td>
<p>Vector of valid cluster numbers contained in slot <code>cpart</code> of the <code>SCseq</code> object. Default is <code>NULL</code> and all clusters with <code>&gt;cthr</code>
cells are included.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_cells">cells</code></td>
<td>
<p>Vector of valid cell names corresponding to column names of slot <code>ndata</code> of the <code>SCseq</code> object. Gene expression is only shown for
this subset.
Default is <code>NULL</code> and all cells are included. The set of <code>cells</code> is intersected with the subset of clusters in <code>cl</code> if given.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_order.cells">order.cells</code></td>
<td>
<p>logical. If <code>TRUE</code>, then columns of the heatmap are ordered by cell name and not by cluster number. If <code>cells</code> are given, then columns are ordered as in <code>cells</code>.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_aggr">aggr</code></td>
<td>
<p>logical. If <code>TRUE</code>, then only average expression is shown for each cluster. Default is <code>FALSE</code> and expression in individual cells is shown.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_norm">norm</code></td>
<td>
<p>logical. If <code>TRUE</code>, then expression of each gene across clusters is normalized to 1, in order to depict all genes on the same scale.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_cap">cap</code></td>
<td>
<p>Numeric. Upper bound for gene expression. All values larger then <code>cap</code> are replaced by <code>cap</code>.
Default is <code>NULL</code> and no <code>cap</code> is applied.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_flo">flo</code></td>
<td>
<p>Numeric. Lower bound for gene expression. All values smaller then <code>flo</code> are replaced by <code>flo</code>.
Default is <code>NULL</code> and no <code>flo</code> is applied.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_samples">samples</code></td>
<td>
<p>A vector with a group of sample names for each cell in the same order as the column names of the <code>ndata</code> slot of the <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_cluster_cols">cluster_cols</code></td>
<td>
<p>logical. If <code>TRUE</code>, then columns are clustered. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_cluster_rows">cluster_rows</code></td>
<td>
<p>logical. If <code>TRUE</code>, then rows are clustered. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_cluster_set">cluster_set</code></td>
<td>
<p>logical. If <code>TRUE</code> then clusters are ordered by hierarchical clustering of the cluster medoids.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_samples_col">samples_col</code></td>
<td>
<p>Vector of colors used for highlighting all samples contained in <code>samples</code> in the heatmap. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_zsc">zsc</code></td>
<td>
<p>logical. If <code>TRUE</code> then a z-score transformation is applied. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_logscale">logscale</code></td>
<td>
<p>logical. If <code>TRUE</code> then a log2 transformation is applied. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_noise">noise</code></td>
<td>
<p>logical. If <code>TRUE</code> then display local gene expression variability instead of gene expression (requires VarID analysis)/ Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotmarkergenes_+3A_fontsize">fontsize</code></td>
<td>
<p>postive real number. Font size of gene name labels. Default is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with clustering information for rows and columns returned by the function <code>pheatmap</code> from the package <span class="pkg">pheatmap</span>.
</p>

<hr>
<h2 id='plotMV'>Plot of Mean-Variance dependence and various fits</h2><span id='topic+plotMV'></span>

<h3>Description</h3>

<p>This functions plots the dependence of the transcript count variance or, alternatively, the coefficient of variation (CV) on the mean in log2 space. The  mean-variance dependence is plotted along with a loess-regression, a second order polynomial fit, and the background model of the local variability. The CV plot also highlights the local variability associated with cell-to-cell variability of total transcript counts, as calculated directly from the mean and variance of total transcript counts (turquoise) or from a local fit of a gamma distribution (orange).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMV(x, cv = FALSE, ret = FALSE, span = 0.75, degree = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMV_+3A_x">x</code></td>
<td>
<p>Transcript count matrix.</p>
</td></tr>
<tr><td><code id="plotMV_+3A_cv">cv</code></td>
<td>
<p>Logical. If <code>TRUE</code> then the coefficient of variation is plotted instead of the variance. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotMV_+3A_ret">ret</code></td>
<td>
<p>Logical. If <code>TRUE</code> then a second order polynomial fit is returned. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plotMV_+3A_span">span</code></td>
<td>
<p>Parameter for the local regression. See help(loess). Default value is 0.75.</p>
</td></tr>
<tr><td><code id="plotMV_+3A_degree">degree</code></td>
<td>
<p>Parameter for the local regression. See help(loess). Default value is 2.</p>
</td></tr>
<tr><td><code id="plotMV_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>ret=FALSE</code> second order polynomial fit as returned by <code>lm</code>.
</p>

<hr>
<h2 id='plotNoiseModel'>Function for plotting the baseline model of gene expression variability</h2><span id='topic+plotNoiseModel'></span>

<h3>Description</h3>

<p>This function plots the variance against mean expression across all genes and a second order polynomial to the base line of the variance-mean dependence in log space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNoiseModel(x, corrected = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNoiseModel_+3A_x">x</code></td>
<td>
<p>List object returned by function <code>noiseBaseFit</code> or function <code>compNoise</code>.</p>
</td></tr>
<tr><td><code id="plotNoiseModel_+3A_corrected">corrected</code></td>
<td>
<p>logical value. If <code>TRUE</code>, then the variance is plotted after regressing our the mean dependence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- noiseBaseFit(intestinalDataSmall,step=.01,thr=.05)
plotNoiseModel(x)
</code></pre>

<hr>
<h2 id='plotoutlierprobs'>Plot Outlier Probabilities</h2><span id='topic+plotoutlierprobs'></span>

<h3>Description</h3>

<p>This functions plots a barchart of outlier probabilities across all cells in each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotoutlierprobs(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotoutlierprobs_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotPC'>Function to plot the selected number of principal components</h2><span id='topic+plotPC'></span>

<h3>Description</h3>

<p>This functions plots the percentage variability explained the first one hundred (or <code>pcaComp</code>) pricipal components of the PCA performed in the function <code>pruneKnn</code> if the parameter <code>large</code> was TRUE. The selected number of principal components (if <code>pcaComp</code> was NULL) is determined by an elbow criterion and highlighted by a blue circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPC(res, logDiff = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPC_+3A_res">res</code></td>
<td>
<p>List object with k nearest neighbour information returned by <code>pruneKnn</code> function.</p>
</td></tr>
<tr><td><code id="plotPC_+3A_logdiff">logDiff</code></td>
<td>
<p>logical. If <code>TRUE</code>, then plot log2 of the difference in variability explained by PC i and PC i+1.</p>
</td></tr>
</table>

<hr>
<h2 id='plotPearsonRes'>Function for plotting the variance of Pearson residuals</h2><span id='topic+plotPearsonRes'></span>

<h3>Description</h3>

<p>This function plots the variance versus the mean of the Pearson residuals obtained by the negative binomial regression computed by the function <code>compY</code> if <code>regNB</code> is <code>TRUE</code>. A local regression is also shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPearsonRes(y, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPearsonRes_+3A_y">y</code></td>
<td>
<p>List object returned by the <code>compNoise</code> or <code>pruneKnn</code> function (if run with <code>regNB=TRUE</code>).</p>
</td></tr>
<tr><td><code id="plotPearsonRes_+3A_log">log</code></td>
<td>
<p>logical. If <code>TRUE</code> then the y-axis is log-transformed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotPearsonRes_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- pruneKnn(intestinalDataSmall,no_cores=1)
plotPearsonRes(res,log=TRUE)
</code></pre>

<hr>
<h2 id='plotPP'>Plotting function for posterior checks</h2><span id='topic+plotPP'></span>

<h3>Description</h3>

<p>This function plots various statistics for the posterior check
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPP(pp, y = NULL, umi.eps = FALSE, i = 1, log.scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPP_+3A_pp">pp</code></td>
<td>
<p>List object returned by <code>testPrior</code> function.</p>
</td></tr>
<tr><td><code id="plotPP_+3A_y">y</code></td>
<td>
<p>One of &quot;mean&quot;, &quot;median&quot;, &quot;var&quot;, &quot;cor&quot;, or <code>NULL</code>. If <code>NULL</code> then the ratios between the predicted and the actual variances across all sampled genes and neighbourhoods are shown as boxplots for all tested values of the prior parameter <code>gamma</code>. If <code>y</code> equals &quot;mean&quot;, &quot;median&quot;, or &quot;var&quot;, the mean, median, or variance is plotted for all <code>gamma</code> values. If <code>y</code> equal &quot;cor&quot;, then the correlation between the total transcript count of a cell and the local noise estimate <code>epsilon</code> is plotted for all values of <code>gamma</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotPP_+3A_umi.eps">umi.eps</code></td>
<td>
<p>Logical. If <code>TRUE</code> then a scatter plot of the local noise estimate <code>epsilon</code> and the total transcript count is produced for a given element <code>i</code> of the <code>pp$noise</code> corresponding to a value of the prior parameter <code>gamma</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotPP_+3A_i">i</code></td>
<td>
<p>Positive integer number. Index of <code>pp$noise</code>, corresponding to a value of the prior parameter <code>gamma</code> to be used for plotting is <code>umi.eps=TRUE</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="plotPP_+3A_log.scale">log.scale</code></td>
<td>
<p>Logical. If <code>TRUE</code> then the ratio between the predicted and the actual variance is transformed to a log2-scale prior to computations and plotting. If <code>umi.eps=TRUE</code>, total transcript counts and <code>epsilon</code> estimates are log2-transformed for plotting. Default is <code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plotPT'>Plotting pseudo-time in dimensional reduction representation</h2><span id='topic+plotPT'></span>

<h3>Description</h3>

<p>Highlight clusters or pseudotime in dimensional reduction representation and indicate trajectory derived by <span class="pkg">slingshot</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPT(pt, object, clusters = TRUE, lineages = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPT_+3A_pt">pt</code></td>
<td>
<p>List object returned by function <code>pseudoTime</code>.</p>
</td></tr>
<tr><td><code id="plotPT_+3A_object">object</code></td>
<td>
<p><span class="pkg">RaceID</span> <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="plotPT_+3A_clusters">clusters</code></td>
<td>
<p>logical. If <code>TRUE</code>, then clusters are highlighted. Otherwise, pseudotime is highlighted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotPT_+3A_lineages">lineages</code></td>
<td>
<p>logical. If <code>TRUE</code>, then lineages as linear connections of clusters are hghlighted. Otherwise, continuous trajectories are shown. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotQQ'>Scatter plot of two noise-related quantaties of local pruned k-nearest neighbourhoods</h2><span id='topic+plotQQ'></span>

<h3>Description</h3>

<p>Displaying two noise-related quantaties of local pruned k-nearest neighbourhoods in a scatterplot highlighting VarID clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotQQ(x, m, n, object, cluster = NULL, cex = 0.5, show.cor = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotQQ_+3A_x">x</code></td>
<td>
<p>List object returned by <code>quantKnn</code> function.</p>
</td></tr>
<tr><td><code id="plotQQ_+3A_m">m</code></td>
<td>
<p>Component name of <code>x</code>. One of &quot;noise.av&quot;, &quot;noise.ratio&quot;, &quot;local.corr&quot;, &quot;umi&quot;.</p>
</td></tr>
<tr><td><code id="plotQQ_+3A_n">n</code></td>
<td>
<p>Component name of <code>x</code>. One of &quot;noise.av&quot;, &quot;noise.ratio&quot;, &quot;local.corr&quot;, &quot;umi&quot;.</p>
</td></tr>
<tr><td><code id="plotQQ_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="plotQQ_+3A_cluster">cluster</code></td>
<td>
<p>Valid cluster number or vector of cluster numbers, contained in <code>object@cpart</code>. If given, then cells of clusters in <code>cluster</code> are circled in black.</p>
</td></tr>
<tr><td><code id="plotQQ_+3A_cex">cex</code></td>
<td>
<p>Real positive number. Size of data points. Default is 0.5.</p>
</td></tr>
<tr><td><code id="plotQQ_+3A_show.cor">show.cor</code></td>
<td>
<p>logical. If <code>TRUE</code> then Pearson's correlation is shown in the legend. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotQQ_+3A_...">...</code></td>
<td>
<p>Additional parameters of <code>plot</code> (e.g., <code>log</code>, see <code>help(plot)</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotQuantMap'>Plotting noise-related quantaties of local pruned k-nearest neighbourhoods</h2><span id='topic+plotQuantMap'></span>

<h3>Description</h3>

<p>Plotting noise-related quantaties of local pruned k-nearest neighbourhoods in the dimensional reduction representation chosen for <code>quantKnn</code> or as boxplot across clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotQuantMap(
  x,
  n,
  object,
  box = FALSE,
  cluster = NULL,
  set = NULL,
  logsc = FALSE,
  cex = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotQuantMap_+3A_x">x</code></td>
<td>
<p>List object returned by <code>quantKnn</code> function.</p>
</td></tr>
<tr><td><code id="plotQuantMap_+3A_n">n</code></td>
<td>
<p>Component name of <code>x</code>. One of &quot;noise.av&quot;, &quot;noise.ratio&quot;, &quot;local.corr&quot;, &quot;umi&quot;.</p>
</td></tr>
<tr><td><code id="plotQuantMap_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="plotQuantMap_+3A_box">box</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then data are shown as boxplot across clusers. Default is <code>FALSE</code> and a dimensional reduction representation is shown.</p>
</td></tr>
<tr><td><code id="plotQuantMap_+3A_cluster">cluster</code></td>
<td>
<p>Valid cluster number or vector of cluster numbers, contained in <code>object@cpart</code>. If given and <code>box=TRUE</code> then the median of the feature values across clusters in <code>cluster</code> is indicated as a black solid line in the boxplot. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotQuantMap_+3A_set">set</code></td>
<td>
<p>Ordered set of valid cluster numbers. If <code>box</code> equals <code>TRUE</code> than data will only be plotted for these clusters in the given order. Default is <code>NULL</code> and data for all clutsers will be shown.</p>
</td></tr>
<tr><td><code id="plotQuantMap_+3A_logsc">logsc</code></td>
<td>
<p>logical. If <code>TRUE</code>, then feature values are log2-transformed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotQuantMap_+3A_cex">cex</code></td>
<td>
<p>Real positive number. Size of data points. Default is 0.5.</p>
</td></tr>
<tr><td><code id="plotQuantMap_+3A_...">...</code></td>
<td>
<p>Additional parameters of <code>plotfeatmap</code> if <code>box=FALSE</code> (e.g., <code>um</code> or <code>fr</code> to select dimensional reduction representation, see <code>help(plotfeatmap)</code>), or of <code>plotB</code> (e.g., <code>ylim</code>, see <code>help(plotB)</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotRegNB'>Function for plotting negative binomial regression</h2><span id='topic+plotRegNB'></span>

<h3>Description</h3>

<p>This function plots the parameters obatined by the negative binomial regression of the transcript counts on the total transcript count in each cells.
Smoothed parameter estimates are also shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRegNB(expData, y, par.nb = NULL, span = 0.75, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRegNB_+3A_expdata">expData</code></td>
<td>
<p>Matrix of gene expression values with genes as rows and cells as columns. The matrix needs to contain the same cell IDs as columns like the input matrix.
used to derive the pruned k nearest neighbours with the <code>pruneKnn</code> function.</p>
</td></tr>
<tr><td><code id="plotRegNB_+3A_y">y</code></td>
<td>
<p>List object returned by the <code>compNoise</code> or <code>pruneKnn</code> function (if run with <code>regNB=TRUE</code>).</p>
</td></tr>
<tr><td><code id="plotRegNB_+3A_par.nb">par.nb</code></td>
<td>
<p>Parameter to be plotted, i.e. valid column of <code>res$regData$nbRegr</code>.
of the log total UMI count. <code>intercept</code> is the intercept inferred by the regression. Default is <code>NULL</code> and <code>theta</code> is shown.</p>
</td></tr>
<tr><td><code id="plotRegNB_+3A_span">span</code></td>
<td>
<p>Positive real number. Parameter for loess-regression (see <code>large</code>) controlling the degree of smoothing. Default is 0.75.</p>
</td></tr>
<tr><td><code id="plotRegNB_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- pruneKnn(intestinalDataSmall,no_cores=1)
plotRegNB(intestinalDataSmall,res,"theta")
</code></pre>

<hr>
<h2 id='plotsaturation'>Plot Saturation of Within-Cluster Dispersion</h2><span id='topic+plotsaturation'></span>

<h3>Description</h3>

<p>This functions plots the (change in the) mean within-cluster dispersion as a function of the cluster number
and highlights the saturation point inferred based on the saturation criterion applied by RaceID3: The number of clusters where
the change in within-cluster dispersion upon adding further clusters approaches linear behaviour demarcates the saturation
point and is highlighted in blue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsaturation(object, disp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotsaturation_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="plotsaturation_+3A_disp">disp</code></td>
<td>
<p>logical. If <code>FALSE</code>, then the change of the within-cluster dispersion is plotted. if <code>TRUE</code> the actual dispersion
is plotted. Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotsensitivity'>Plot Sensitivity</h2><span id='topic+plotsensitivity'></span>

<h3>Description</h3>

<p>This functions plots the number of outliers as a function of the outlier probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsensitivity(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotsensitivity_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotsilhouette'>Plot Cluster Silhouette</h2><span id='topic+plotsilhouette'></span>

<h3>Description</h3>

<p>This functions produces a silhouette plot for RaceID3 clusters prior or post outlier identification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsilhouette(object, final = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotsilhouette_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="plotsilhouette_+3A_final">final</code></td>
<td>
<p>logical. If <code>TRUE</code>, then plot silhouette coefficients for final clusters after outlier identification.
Default is <code>FALSE</code> and silhouette coefficients are plotted for initial clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotspantree'>Minimum Spanning Tree of RaceID3 clusters</h2><span id='topic+plotspantree'></span>

<h3>Description</h3>

<p>This function plots a minimum spanning tree of the RaceID3 cluster medoids in a two-dimensional reduction representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotspantree(object, tp = 0.5, cex = 1, projections = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotspantree_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
<tr><td><code id="plotspantree_+3A_tp">tp</code></td>
<td>
<p>Real number between zero and one. Level of transparency of the t-SNE map. Deafault is 0.5.</p>
</td></tr>
<tr><td><code id="plotspantree_+3A_cex">cex</code></td>
<td>
<p>real positive number. Size of data points. Deault is 1.</p>
</td></tr>
<tr><td><code id="plotspantree_+3A_projections">projections</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the projections of the cells onto the inter-medoid links as computed by StemID
are shown. Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='plotsymbolsmap'>Plotting groups as different symbols in a dimensional reduction representation</h2><span id='topic+plotsymbolsmap'></span>

<h3>Description</h3>

<p>This functions highlights groups of cells by different symbols in a two-dimensional t-SNE map, UMAP, or a Fruchterman-Rheingold graph layout
of the singe-cell transcriptome data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsymbolsmap(
  object,
  types,
  subset = NULL,
  samples_col = NULL,
  cex = 0.5,
  fr = FALSE,
  um = FALSE,
  leg = TRUE,
  map = TRUE,
  cex.legend = 0.75,
  leg.pos = "topleft"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotsymbolsmap_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="plotsymbolsmap_+3A_types">types</code></td>
<td>
<p>Vector assigning each cell to a type to be highlighted in the t-SNE map. The order has to be the same as for the
columns in slot <code>ndata</code> of the <code>SCseq</code> object. Default is <code>NULL</code> and each cell is highlighted by a different symbol.</p>
</td></tr>
<tr><td><code id="plotsymbolsmap_+3A_subset">subset</code></td>
<td>
<p>Vector containing a subset of types from <code>types</code> to be highlighted in the map. Default is <code>NULL</code> and all
types are shown.</p>
</td></tr>
<tr><td><code id="plotsymbolsmap_+3A_samples_col">samples_col</code></td>
<td>
<p>Vector of colors used for highlighting all samples contained in <code>samples</code> in the map. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotsymbolsmap_+3A_cex">cex</code></td>
<td>
<p>size of data points. Default value is 0.5.</p>
</td></tr>
<tr><td><code id="plotsymbolsmap_+3A_fr">fr</code></td>
<td>
<p>logical. If <code>TRUE</code> then plot Fruchterman-Rheingold layout. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotsymbolsmap_+3A_um">um</code></td>
<td>
<p>logical. If <code>TRUE</code> then plot umap dimensional reduction representation. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotsymbolsmap_+3A_leg">leg</code></td>
<td>
<p>logical. If <code>TRUE</code> then the legend is shown. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotsymbolsmap_+3A_map">map</code></td>
<td>
<p>logical. If <code>TRUE</code> then data points are shown. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotsymbolsmap_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Positive real number. Size of data points and text in the legend. Default is 0.75.</p>
</td></tr>
<tr><td><code id="plotsymbolsmap_+3A_leg.pos">leg.pos</code></td>
<td>
<p>Position of the legend. a single keyword from the list ‘&quot;bottomright&quot;’, ‘&quot;bottom&quot;’, ‘&quot;bottomleft&quot;’,‘&quot;left&quot;’, ‘&quot;topleft&quot;’, ‘&quot;top&quot;’, ‘&quot;topright&quot;’, ‘&quot;right&quot;’ and‘&quot;center&quot;’. This places the legend on the inside of the plot frame at the given location.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plotTrProbs'>Function for plotting transition probabilities between clusters</h2><span id='topic+plotTrProbs'></span>

<h3>Description</h3>

<p>This function plots the transitions probabilities in a dimensional reduction representation of a <span class="pkg">RaceID</span> <code>SCseq</code> object updates with the
<code>updateSC</code> function.
in order to utilize <span class="pkg">RaceID</span> functions for visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTrProbs(
  object,
  probs,
  tp = 0.5,
  prthr = 0,
  cthr = 0,
  fr = FALSE,
  um = FALSE,
  cex = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTrProbs_+3A_object">object</code></td>
<td>
<p><span class="pkg">RaceID</span> <code>SCseq</code> object, updated with the <code>updateSC</code> function.</p>
</td></tr>
<tr><td><code id="plotTrProbs_+3A_probs">probs</code></td>
<td>
<p>Matrix of transition probabilities between clusters, returned by the <code>transitionProbs</code> function.</p>
</td></tr>
<tr><td><code id="plotTrProbs_+3A_tp">tp</code></td>
<td>
<p>Positive real number between 0 and 1. Transparency of the data points in the dimensional reduction map. Default is 0.5.</p>
</td></tr>
<tr><td><code id="plotTrProbs_+3A_prthr">prthr</code></td>
<td>
<p>Positive real number between 0 and 1. Threshold of transition probabilities. Only transitions with probability <code>&gt;prthr</code> are
displayed in the map. Default is 0.</p>
</td></tr>
<tr><td><code id="plotTrProbs_+3A_cthr">cthr</code></td>
<td>
<p>Integer number greater or equal 0 defining the minimum clusters size for inclusion into the map. Default is 0.</p>
</td></tr>
<tr><td><code id="plotTrProbs_+3A_fr">fr</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then a Fruchterman-Rheingold graph layout is shown (in case it has been computed for the <span class="pkg">RaceID</span> bject), otherwise a t-SNE map is shown. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotTrProbs_+3A_um">um</code></td>
<td>
<p>Logical. If <code>TRUE</code> then plot umap dimensional reduction representation. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotTrProbs_+3A_cex">cex</code></td>
<td>
<p>Real positive number. Size of data points. Default is 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
d &lt;- getExpData(sc)
res &lt;- pruneKnn(d,distM=sc@distances,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
cl &lt;- graphCluster(res,pvalue=0.01)
sc &lt;- updateSC(sc,res=res,cl=cl)
sc &lt;- comptsne(sc)
probs &lt;-transitionProbs(res,cl,pvalue=0.01)
plotTrProbs(sc,probs,tp=.5,prthr=0,cthr=0,fr=FALSE)
</code></pre>

<hr>
<h2 id='plotUMINoise'>Plotting noise dependence on total UMI count</h2><span id='topic+plotUMINoise'></span>

<h3>Description</h3>

<p>This function plots the dependence of mean noise per cell on the total UMI count per cell. It serves as a basis for choosing the prior parameter <code>gamma</code> (see function <code>compTBNoise</code>). With a proper parameter choice, there should be no correlation between the two quantities. If a positive correlation is observed, <code>gamma</code> should be increased in order to weaken the prior. If the correlation is negative, <code>gamma</code> should be decreased in order to increase the strength of the prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotUMINoise(object, noise, log.scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotUMINoise_+3A_object">object</code></td>
<td>
<p><span class="pkg">RaceID</span> <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="plotUMINoise_+3A_noise">noise</code></td>
<td>
<p>object returned by <code>compTBNoise</code> function.</p>
</td></tr>
<tr><td><code id="plotUMINoise_+3A_log.scale">log.scale</code></td>
<td>
<p>Logical. If <code>TRUE</code>  total transcript counts and <code>epsilon</code> estimates are log2-transformed for plotting. Default is <code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='postfntb'>Posterior probability</h2><span id='topic+postfntb'></span>

<h3>Description</h3>

<p>Non-normalized negative log posterior probability with a negative binomial likelihood and Cauchy prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postfntb(eps, z, x0, gamma, mu, rt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postfntb_+3A_eps">eps</code></td>
<td>
<p>Positive real number. Residual (biological) noise.</p>
</td></tr>
<tr><td><code id="postfntb_+3A_z">z</code></td>
<td>
<p>Vector of integer number greater or equal zero. Transcript counts.</p>
</td></tr>
<tr><td><code id="postfntb_+3A_x0">x0</code></td>
<td>
<p>Real number. Location parameter.</p>
</td></tr>
<tr><td><code id="postfntb_+3A_gamma">gamma</code></td>
<td>
<p>Positive real number. Scale parameter.</p>
</td></tr>
<tr><td><code id="postfntb_+3A_mu">mu</code></td>
<td>
<p>Positive real number. Mean expression.</p>
</td></tr>
<tr><td><code id="postfntb_+3A_rt">rt</code></td>
<td>
<p>Positive real number. Technical noise parameter. See help(fitGammaRt).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative non-normalized log posterior probability fro maximum a posterior inference.
</p>

<hr>
<h2 id='priorfn'>Prior function for maximum a posterior inference</h2><span id='topic+priorfn'></span>

<h3>Description</h3>

<p>A prior function specified as Cauchy probability density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priorfn(x, x0, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priorfn_+3A_x">x</code></td>
<td>
<p>Vector or real numbers (quantiles)</p>
</td></tr>
<tr><td><code id="priorfn_+3A_x0">x0</code></td>
<td>
<p>Real number. Location parameter.</p>
</td></tr>
<tr><td><code id="priorfn_+3A_gamma">gamma</code></td>
<td>
<p>Positive real number. Scale parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of probabilities
</p>

<hr>
<h2 id='projback'>Compute Cell Projections for Randomized Background Distribution</h2><span id='topic+projback'></span>

<h3>Description</h3>

<p>This function computes the projections of cells onto inter-cluster links for randomized cell positions in a high-dimensional embedded space. Significance
of link based on an increased number of cells on a link is inferred based on this background model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projback(object, pdishuf = 500, fast = FALSE, rseed = 17000, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projback_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
<tr><td><code id="projback_+3A_pdishuf">pdishuf</code></td>
<td>
<p>Number of randomizations of cell positions for which to compute projections of cells on inter-cluster links. Default is 2000.
No randomizations are needed in this mode and the function will do nothing. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="projback_+3A_fast">fast</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>nmode=FALSE</code> cells will still be assigned to links based on maximum projections but a fast approximate background model
will be used to infer significance. The function will do nothing in this case. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="projback_+3A_rseed">rseed</code></td>
<td>
<p>Integer number used as seed to ensure reproducibility of randomizations. Defaut is 17000.</p>
</td></tr>
<tr><td><code id="projback_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>FALSE</code> then status output messages are disabled. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An Ltree class object with all information on randomized cell projections onto links stored in the <code>prbacka</code> slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
sc &lt;- comptsne(sc)
ltr &lt;- Ltree(sc)
ltr &lt;- compentropy(ltr)
ltr &lt;- projcells(ltr,nmode=FALSE)
ltr &lt;- projback(ltr,pdishuf=50)
</code></pre>

<hr>
<h2 id='projcells'>Compute transcriptome entropy of each cell</h2><span id='topic+projcells'></span>

<h3>Description</h3>

<p>This function computes the projections of cells onto inter-cluster links in a high-dimensional embedded space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projcells(object, cthr = 5, nmode = TRUE, knn = 3, fr = FALSE, um = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projcells_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
<tr><td><code id="projcells_+3A_cthr">cthr</code></td>
<td>
<p>Positive integer number. Clusters to be included into the StemID2 analysis must contain more than <code>cthr</code> cells. Default is 5.</p>
</td></tr>
<tr><td><code id="projcells_+3A_nmode">nmode</code></td>
<td>
<p>logical. If <code>TRUE</code>, then a cell of given cluster is assigned to the link to the cluster with the smallest average distance of
the <code>knn</code> nearest neighbours within this cluster. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="projcells_+3A_knn">knn</code></td>
<td>
<p>Positive integer number. See <code>nmode</code>. Default is 3.</p>
</td></tr>
<tr><td><code id="projcells_+3A_fr">fr</code></td>
<td>
<p>logical. Use Fruchterman-Rheingold layout instead of t-SNE for dimensional-reduction representation of the lineage graph. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="projcells_+3A_um">um</code></td>
<td>
<p>logical. Use umap representation instead of t-SNE for dimensional-reduction representation of the lineage graph. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An Ltree class object with all information on cell projections onto links stored in the <code>ldata</code> slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
sc &lt;- comptsne(sc)
ltr &lt;- Ltree(sc)
ltr &lt;- compentropy(ltr)
ltr &lt;- projcells(ltr)
</code></pre>

<hr>
<h2 id='projenrichment'>Enrichment of cells on inter-cluster links</h2><span id='topic+projenrichment'></span>

<h3>Description</h3>

<p>This function plots a heatmap of the enrichment ratios of cells on significant links.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projenrichment(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projenrichment_+3A_object">object</code></td>
<td>
<p><code>Ltree</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='pruneKnn'>Function inferring a pruned knn matrix</h2><span id='topic+pruneKnn'></span>

<h3>Description</h3>

<p>This function determines k nearest neighbours for each cell in gene expression space, and tests if the links are supported by a negative binomial joint distribution of gene expression. A probability is assigned to each link which is given by the minimum joint probability across all genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pruneKnn(
  expData,
  distM = NULL,
  large = TRUE,
  regNB = TRUE,
  bmethod = NULL,
  batch = NULL,
  regVar = NULL,
  offsetModel = TRUE,
  thetaML = FALSE,
  theta = 10,
  ngenes = 2000,
  span = 0.75,
  pcaComp = NULL,
  tol = 1e-05,
  algorithm = "kd_tree",
  metric = "pearson",
  genes = NULL,
  knn = 25,
  do.prune = TRUE,
  alpha = 1,
  nb = 3,
  no_cores = NULL,
  FSelect = FALSE,
  pca.scale = FALSE,
  ps = 1,
  seed = 12345,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pruneKnn_+3A_expdata">expData</code></td>
<td>
<p>Matrix of gene expression values with genes as rows and cells as columns. These values have to correspond to unique molecular identifier counts. Alternatively, a Seurat object could be used as input, after normalization, PCA-dimensional reduction, and shared-nearest neighbour inference.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_distm">distM</code></td>
<td>
<p>Optional distance matrix used for determining k nearest neighbours. Default is <code>NULL</code> and the distance matrix is computed using a metric given by the parameter <code>metric</code>.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_large">large</code></td>
<td>
<p>logical. If <code>TRUE</code> then no distance matrix is required and nearest neighbours are inferred by the <span class="pkg">FNN</span> package based on a reduced
feature matrix computed by a principle component analysis. Only the first <code>pcaComp</code> principle components are considered. Prior to principal component
analysis a negative binomial regression is performed to eliminate the dependence on the total number of transcripts per cell. The pearson residuals of
this regression serve as input for the principal component analysis after smoothing the parameter dependence on the mean by a <code>loess</code> regression.
Deafult is <code>TRUE</code>. Recommended mode for very large datasets, where storing a distance matrix requires too much memory. <code>distM</code>
will be ignored if <code>large</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_regnb">regNB</code></td>
<td>
<p>logical. If <code>TRUE</code> then gene a negative binomial regression is performed to prior to the principle component analysis if <code>large = TRUE</code>. See <code>large</code>. Otherwise, transcript counts in each cell are normalized to one, multipled by the minimal total transcript count across all cells, followed by adding a pseudocount of 0.1 and taking the logarithm.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_bmethod">bmethod</code></td>
<td>
<p>Character string indicating the batch correction method. If &quot;harmony&quot;, then batch correction is performed by the <span class="pkg">harmony</span> package. Default is <code>NULL</code> and batch correction will be done by negative binomial regression.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_batch">batch</code></td>
<td>
<p>vector of batch variables. Component names need to correspond to valid cell IDs, i.e. column names of <code>expData</code>. If <code>regNB</code> is <code>TRUE</code>, than the batch variable will be regressed out simultaneously with the log UMI count per cell. An interaction term is included for the log UMI count with the batch variable. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_regvar">regVar</code></td>
<td>
<p>data.frame with additional variables to be regressed out simultaneously with the log UMI count and the batch variable (if <code>batch</code> is <code>TRUE</code>). Column names indicate variable names (name <code>beta</code> is reserved for the coefficient of the log UMI count), and rownames need to correspond to valid cell IDs, i.e. column names of <code>expData</code>. Interaction terms are included for each variable in <code>regVar</code> with the batch variable (if <code>batch</code> is <code>TRUE</code>). Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_offsetmodel">offsetModel</code></td>
<td>
<p>Logical parameter. Only considered if <code>regNB</code> is <code>TRUE</code>. If <code>TRUE</code> then the <code>beta</code> (log UMI count) coefficient is set to 1 and the intercept is computed analytically as the log ration of UMI counts for a gene and the total UMI count across all cells. Batch variables and additional variables in <code>regVar</code> are regressed out with an offset term given by the sum of the intercept and the log UMI count. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_thetaml">thetaML</code></td>
<td>
<p>Logical parameter. Only considered if <code>offsetModel</code> equals <code>TRUE</code>. If <code>TRUE</code> then the dispersion parameter is estimated by a maximum likelihood fit. Otherwise, it is set to <code>theta</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_theta">theta</code></td>
<td>
<p>Positive real number. Fixed value of the dispersion parameter. Only considered if <code>theaML</code> equals <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_ngenes">ngenes</code></td>
<td>
<p>Positive integer number. Randomly sampled number of genes (from rownames of <code>expData</code>) used for predicting regression coefficients (if <code>regNB=TRUE</code>). Smoothed coefficients are derived for all genes. Default is 2000.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_span">span</code></td>
<td>
<p>Positive real number. Parameter for loess-regression (see <code>large</code>) controlling the degree of smoothing. Default is 0.75.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_pcacomp">pcaComp</code></td>
<td>
<p>Positive integer number. Number of princple components to be included if <code>large</code> is <code>TRUE</code>. Default is <code>NULL</code> and the number of principal components used for dimensionality reduction of the feature matrix is derived by an elbow criterion. However, the minimum number of components will be set to 15 if the elbow criterion results in a smaller number. The derived number can be be plotted using the <code>plotPC</code> function.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_tol">tol</code></td>
<td>
<p>Numerical value greater than zero. Tolerance for numerical PCA using <span class="pkg">irlba</span>. Default value is 1e-6.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm for fast k nearest neighbour inference, using the <code>get.knn</code> function from the <span class="pkg">FNN</span> package.
See <code>help(get.knn)</code>. Deafult is &quot;kd_tree&quot;.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_metric">metric</code></td>
<td>
<p>Distances are computed from the  expression matrix <code>x</code> after optionally including only genes given as argument <code>genes</code> or after optional feature selection (see <code>FSelect</code>).
Possible values for <code>metric</code> are <code>"pearson", "spearman", "logpearson",  "euclidean"</code>.  Default is <code>"pearson"</code>. In case of the correlation based methods,
the distance is computed as 1 – correlation. This parameter is only used if <code>large</code> is FALSE and <code>distM</code> is NULL.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_genes">genes</code></td>
<td>
<p>Vector of gene names corresponding to a subset of rownames of <code>x</code>. Only these genes are used for the computation of a distance matrix and for the computation of joint probabilities of nearest neighbours. Default is <code>NULL</code> and all genes are used.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_knn">knn</code></td>
<td>
<p>Positive integer number. Number of nearest neighbours considered for each cell. Default is 25.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_do.prune">do.prune</code></td>
<td>
<p>Logical parameter. If <code>TRUE</code>, then pruning of k-nearest neighbourhoods is performed. If <code>FALSE</code>, then no pruning is done. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_alpha">alpha</code></td>
<td>
<p>Positive real number. Relative weight of a cell versus its k nearest neigbour applied for the derivation of joint probabilities. A cell receives a weight of <code>alpha</code> while the weights of its k nearest neighbours as determined by quadratic programming sum up to one. The sum across all weights and alpha is normalized to one, and the weighted mean expression is used for computing the link porbabilities for each of the k nearest neighbours. Larger values give more weight to the gene expression observed in a cell versus its neighbourhood. Typical values should be in the range of 0 to 10. Default is value is 1. If <code>alpha</code> is set to NULL it is inferred by an optimization, i.e., <code>alpha</code> is minimized under the constraint that the gene expression in a cell does not deviate more then one standard deviation from the predicted weigthed mean, where the standard deviation is calculated from the predicted mean using the background model (the average dependence of the variance on the mean expression). This procedure is coputationally more intense and inceases the run time of the function significantly.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_nb">nb</code></td>
<td>
<p>Positive integer number. Number of genes with the lowest outlier probability included for calculating the link probabilities for the knn pruning. The link probability is computed as the geometric mean across these genes. Default is 3.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_no_cores">no_cores</code></td>
<td>
<p>Positive integer number. Number of cores for multithreading. If set to <code>NULL</code> then the number of available cores minus two is used. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_fselect">FSelect</code></td>
<td>
<p>Logical parameter. If <code>TRUE</code>, then feature selection is performed prior to distance matrix calculation and VarID analysis. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_pca.scale">pca.scale</code></td>
<td>
<p>Logical parameter. If <code>TRUE</code>, then input features are scaled prior to PCA transformation. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_ps">ps</code></td>
<td>
<p>Real number greater or equal to zero. Pseudocount to be added to counts within local neighbourhoods for outlier identification and pruning. Default is 1.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_seed">seed</code></td>
<td>
<p>Integer number. Random number to initialize stochastic routines. Default is 12345.</p>
</td></tr>
<tr><td><code id="pruneKnn_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>HarmonyMatrix</code> function of the <span class="pkg">harmony</span> package, if <code>batch</code> is not <code>NULL</code> and <code>bmethod="harmony"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List object of six components:
</p>
<table>
<tr><td><code>distM</code></td>
<td>
<p>Distance matrix.</p>
</td></tr>
<tr><td><code>dimRed</code></td>
<td>
<p>PCA transformation of <code>expData</code> including the first <code>pcaComp</code> principle components, computed on including <code>genes</code> or variable genes only if <code>Fselect</code> equals <code>TRUE</code>. Is is set to <code>NULL</code> if <code>large</code> equals <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>pvM</code></td>
<td>
<p>Matrix of link probabilities between a cell and each of its k nearest neighbours (Bonferroni-corrected p-values). Column <code>i</code> shows the k nearest neighbour link probabilities for cell <code>i</code> in matrix <code>x</code>. </p>
</td></tr>
<tr><td><code>pvM.raw</code></td>
<td>
<p>Matrix of uncorrected link probabilities between a cell and each of its k nearest neighbours (without multiple-testing correction). Column <code>i</code> shows the k nearest neighbour link probabilities for cell <code>i</code> in matrix <code>x</code>. </p>
</td></tr>
<tr><td><code>NN</code></td>
<td>
<p>Matrix of column indices of k nearest neighbours for each cell according to input matrix <code>x</code>. First entry corresponds to index of the cell itself. Columns contain the k nearest neighbour indices for cell <code>i</code> in matrix <code>x</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>List object with background model of gene expression as obtained by <code>fitBackVar</code> function.</p>
</td></tr>
<tr><td><code>regData</code></td>
<td>
<p>If <code>regNB=TRUE</code> this argument contains a list of four components: component <code>pearsonRes</code> contains a matrix of the Pearson Residual computed from the negative binomial regression, component <code>nbRegr</code> contains a matrix with the regression coefficients, component <code>nbRegrSmooth</code> contains a matrix with the smoothed regression coefficients, and <code>log_umi</code> is a vector with the total log UMI count for each cell. The regression coefficients comprise the dispersion parameter theta, the intercept, the regression coefficient beta for the log UMI count, and the regression coefficients of the batches (if <code>batch</code> is not <code>NULL</code>).</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Vector of inferred values for the <code>alpha</code> parameter for each neighbourhood (if input parameter <code>alpha</code> is NULL; otherwise all values are equal to the input parameter).</p>
</td></tr>
<tr><td><code>pars</code></td>
<td>
<p>List object storing the run parameters.</p>
</td></tr>
<tr><td><code>pca</code></td>
<td>
<p>Principal component analysis of the of the input data, if <code>large</code> is TRUE. Output or the function <code>irlba</code> from the <span class="pkg">irlba</span> package with <code>pcaComp</code> principal components, or 100 principal components if <code>pcaComp</code> is NULL.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- pruneKnn(intestinalDataSmall,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
</code></pre>

<hr>
<h2 id='pseudoTime'>Extract pseudo-time order of cells along a trajectory</h2><span id='topic+pseudoTime'></span>

<h3>Description</h3>

<p>Extract pseudo-time order of cells along a trajectory defined by a set of clusters using the <span class="pkg">slingshot</span> algorithm. If the <span class="pkg">slingshot</span> package is unavailable, the function falls back to inference by principal curve analysis using the <span class="pkg">princurve</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudoTime(
  object,
  set,
  m = NULL,
  useSlingshot = TRUE,
  map = "umap",
  x = NULL,
  n_neighbors = 15,
  metric = "euclidean",
  n_epochs = 200,
  min_dist = 0.1,
  local_connectivity = 1,
  spread = 1,
  initial_cmd = TRUE,
  perplexity = 30,
  rseed = 15555,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudoTime_+3A_object">object</code></td>
<td>
<p><span class="pkg">RaceID</span> <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_set">set</code></td>
<td>
<p>Set of valid ordered cluster numbers (in <code>object@cpart</code>) defining the trajectory for which the pseudo-temporal order of cells should be computed computed. Only clusters on a single, linear trajectory should be given.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_m">m</code></td>
<td>
<p>Existing dimensional reduction representation of RaceID object. Either <code>"fr"</code>, <code>"tsne"</code> or <code>"umap"</code>. Default is NULL and dimensional reduction representation is computed for all cells in <code>set</code>.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_useslingshot">useSlingshot</code></td>
<td>
<p>logical. If <code>TRUE</code> and the <span class="pkg">slingshot</span> package is available, trajectory inference will be done using slingshot. If <code>FALSE</code>, inference will be done by principal curve analysis using the <span class="pkg">princurve</span> package. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_map">map</code></td>
<td>
<p>Either <code>"tsne"</code> or <code>"umap"</code>. If <code>m</code> is NULL this argument determines the algorithm (UMAP or t-SNE) for computing the dimensional reduction representation of all cells <code>set</code> used for pseudo-temporal ordering by the <code>Bioconductor</code> package <code>slingshot</code>. Default is <code>"umap"</code>.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_x">x</code></td>
<td>
<p>Optional feature matrix, which will be directly used for computation of the dimensional reduction representation. Default is NULL and <code>object@dimRed$x</code> is used, unless empty. In this case, <code>getfdata(object)</code> is used.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>Umap parameter (used if <code>map="umap"</code> and <code>m=NULL</code>). See <code>help(umap.defaults)</code> after loading package <span class="pkg">umap</span>. Default is 15.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_metric">metric</code></td>
<td>
<p>Umap parameter (used if <code>map="umap"</code> and <code>m=NULL</code>). See <code>help(umap.defaults)</code> after loading package <span class="pkg">umap</span>. Default is &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_n_epochs">n_epochs</code></td>
<td>
<p>Umap parameter (used if <code>map="umap"</code> and <code>m=NULL</code>). See <code>help(umap.defaults)</code> after loading package <span class="pkg">umap</span>. Default is 200.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_min_dist">min_dist</code></td>
<td>
<p>Umap parameter (used if <code>map="umap"</code> and <code>m=NULL</code>). See <code>help(umap.defaults)</code> after loading package <span class="pkg">umap</span>. Default is 0.1.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_local_connectivity">local_connectivity</code></td>
<td>
<p>Umap parameter (used if <code>map="umap"</code> and <code>m=NULL</code>). See <code>help(umap.defaults)</code> after loading package <span class="pkg">umap</span>. Default is 1.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_spread">spread</code></td>
<td>
<p>Umap parameter (used if <code>map="umap"</code> and <code>m=NULL</code>). See <code>help(umap.defaults)</code> after loading package <span class="pkg">umap</span>. Default is 1.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_initial_cmd">initial_cmd</code></td>
<td>
<p>logical. t-SNE parameter (used if <code>map="tsne"</code> and <code>m=NULL</code>). If <code>TRUE</code>, then the t-SNE map computation is initialized with a configuration obtained by classical
multidimensional scaling. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_perplexity">perplexity</code></td>
<td>
<p>Positive number. t-SNE parameter (used if <code>map="tsne"</code> and <code>m=NULL</code>). Perplexity of the t-SNE map. Default is <code>30</code>.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_rseed">rseed</code></td>
<td>
<p>Integer number. Random seed to enforce reproducible dimensional reduction computation.</p>
</td></tr>
<tr><td><code id="pseudoTime_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the <code>getCurves</code> function of the <span class="pkg">slingshot</span> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List object of six components:
</p>
<table>
<tr><td><code>pt</code></td>
<td>
<p>Vector of pseudo-time value obtained by <span class="pkg">slingshot</span>.</p>
</td></tr>
<tr><td><code>ord</code></td>
<td>
<p>Vector of cells in <code>set</code> ordered by pseudo-time, starting with the first cluster in <code>set</code>.</p>
</td></tr>
<tr><td><code>set</code></td>
<td>
<p>Vector of cluster numbers defining the trajectory used for pseudo-time inference.</p>
</td></tr>
<tr><td><code>part</code></td>
<td>
<p>Vector of cluster numbers of all cells in <code>set</code>.</p>
</td></tr>
<tr><td><code>rd</code></td>
<td>
<p>Two-dimensional matrix with x- and y-coordinates of dimensional reduction representation used for <code>slingshot</code>.</p>
</td></tr>
<tr><td><code>sls</code></td>
<td>
<p><code>slingshot</code> data object.</p>
</td></tr>
</table>

<hr>
<h2 id='quantKnn'>Noise-related quantaties of local pruned k-nearest neighbourhoods</h2><span id='topic+quantKnn'></span>

<h3>Description</h3>

<p>This function computes a number of noise-related quantities for all pruned k-nearest neighbourhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantKnn(res, noise, object, pvalue = 0.01, minN = 5, no_cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantKnn_+3A_res">res</code></td>
<td>
<p>List object with k nearest neighbour information returned by <code>pruneKnn</code> function.</p>
</td></tr>
<tr><td><code id="quantKnn_+3A_noise">noise</code></td>
<td>
<p>List of noise parameters returned by <code>compTBNoise</code>.</p>
</td></tr>
<tr><td><code id="quantKnn_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="quantKnn_+3A_pvalue">pvalue</code></td>
<td>
<p>Positive real number between 0 and 1. All nearest neighbours with link probability <code>&lt; pvalue</code> are discarded. Default is 0.01.</p>
</td></tr>
<tr><td><code id="quantKnn_+3A_minn">minN</code></td>
<td>
<p>Positive integer number. Noise inference is only done for k-nearest neighbourhoods with at least <code>minN</code> neighbours remaining after pruning.</p>
</td></tr>
<tr><td><code id="quantKnn_+3A_no_cores">no_cores</code></td>
<td>
<p>Positive integer number. Number of cores for multithreading. If set to <code>NULL</code> then the number of available cores minus two is used. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List object with eight components:
</p>
<table>
<tr><td><code>noise.av</code></td>
<td>
<p>Vector of biological noise average across all genes for each k-nearest neighbourhood.</p>
</td></tr>
<tr><td><code>noise.ratio</code></td>
<td>
<p>Vector of ratio between total noise and technical noise averaged across all genes for each k-nearest neighbourhood.</p>
</td></tr>
<tr><td><code>local.corr</code></td>
<td>
<p>Vector of average Spearman's correlation coefficient between all cell in a pruned k-nearest neighourhood. </p>
</td></tr>
<tr><td><code>umi</code></td>
<td>
<p>Vector of total UMI counts for all cells.</p>
</td></tr>
</table>

<hr>
<h2 id='RaceID-package'>
Identification of Cell Types, Inference of Lineage Trees, and Prediction of Noise Dynamics from Single-Cell RNA-Seq Data
</h2><span id='topic+RaceID-package'></span><span id='topic+RaceID'></span>

<h3>Description</h3>

<p>RaceID is a clustering algorithm for the identification of cell types from single-cell RNA-sequencing data. It was specifically designed for the detection of rare cells which correspond to outliers in conventional clustering methods. The package contains RaceID3, the most recently published version of this algorithm, and StemID2, an algorithm for the identification of lineage trees based on RaceID3 analysis. RaceID3 utilizes single cell expression data, and was designed to work well with quantitative single-cell RNA-seq data incorporating unique molecular identifiers. It requires a gene-by-cell expression matrix as input and produces a clustering partition representing cell types. StemID2 assembles these cell types into a lineage tree.
The RaceID package (&gt;= v0.1.4) also contains functions for a VarID analysis. VarID comprises a sensitive clustering method utilizing pruned k-nearest neighbor networks, connecting only cells with links supported by a background model of gene expression. These pruned k-nearest neighbor networks further enable the definition of homogenous neighborhoods for the quantification of local gene expression
variability in cell state space.
</p>


<h3>Details</h3>

<p>For details please see vignette.</p>


<h3>Author(s)</h3>

<p>Dominic Grun, dominic.gruen@gmail.com.
</p>
<p>Maintainer: Dominic Grun &lt;dominic.gruen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Herman, J.S., Sagar, Grun D. (2018) &lt;DOI:10.1038/nmeth.4662&gt;
Rosales-Alvarez, R.E., Rettkowski, J., Herman, J.S., Dumbovic, G., Cabezas-Wallscheid, N., Grun, D. (2023) &lt;DOI:10.1186/s13059-023-02974-1&gt;</p>

<hr>
<h2 id='rcpp_hello_world'>
Simple function using Rcpp
</h2><span id='topic+rcpp_hello_world'></span>

<h3>Description</h3>

<p>Simple function using Rcpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_hello_world()	
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rcpp_hello_world()

## End(Not run)
</code></pre>

<hr>
<h2 id='rfcorrect'>Random Forests-based Reclassification</h2><span id='topic+rfcorrect'></span>

<h3>Description</h3>

<p>This functions applies random forests-based reclassification of cell clusters to enhance robustness of the final clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfcorrect(
  object,
  rfseed = 12345,
  nbtree = NULL,
  final = TRUE,
  nbfactor = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfcorrect_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="rfcorrect_+3A_rfseed">rfseed</code></td>
<td>
<p>Seed for enforcing reproducible results. Default is 12345.</p>
</td></tr>
<tr><td><code id="rfcorrect_+3A_nbtree">nbtree</code></td>
<td>
<p>Number of trees to be built. Default is <code>NULL</code> and the number of tree is given by the number of cells times <code>nbfactor</code>.</p>
</td></tr>
<tr><td><code id="rfcorrect_+3A_final">final</code></td>
<td>
<p>logical. If <code>TRUE</code>, then reclassification of cell types using out-of-bag analysis is performed based on the final clusters
after outlier identification. If <code>FALSE</code>, then the cluster partition prior to outlier idenitifcation is used for reclassification.</p>
</td></tr>
<tr><td><code id="rfcorrect_+3A_nbfactor">nbfactor</code></td>
<td>
<p>Positive integer number. See <code>nbtree</code>.</p>
</td></tr>
<tr><td><code id="rfcorrect_+3A_...">...</code></td>
<td>
<p>additional input arguments to the <code>randomForest</code> function of the <span class="pkg">randomForest</span> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an updated <code>SCseq</code> object with random forests votes written to slot <code>out$rfvotes</code>. The clustering
partition prior or post outlier identification (slot <code>cluster$kpart</code> or <code>cpart</code>, if parameter <code>final</code> equals <code>FALSE</code>
or <code>TRUE</code>, respectively) is overwritten with the partition derived from  the reclassification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
sc &lt;- clustexp(sc)
sc &lt;- findoutliers(sc)
sc &lt;- rfcorrect(sc)
</code></pre>

<hr>
<h2 id='SCseq'>The SCseq Class</h2><span id='topic+SCseq'></span><span id='topic+SCseq-class'></span>

<h3>Description</h3>

<p>The SCseq class is the central object storing all information generated during cell type identification with the RaceID3 algorithm.
It comprises a number of slots for a variety of objects.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCseq_+3A_object">object</code></td>
<td>
<p>An SCseq object.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>expdata</code></dt><dd><p>The raw expression data matrix with cells as columns and genes as rows in sparse matrix format.</p>
</dd>
<dt><code>ndata</code></dt><dd><p>Filtered data with expression normalized to one for each cell.</p>
</dd>
<dt><code>noise</code></dt><dd><p>Matrix with local gene expression noise estimates (used for VarID analysis)</p>
</dd>
<dt><code>counts</code></dt><dd><p>Vector with total transcript counts for each cell in <code>ndata</code> remaining after filtering.</p>
</dd>
<dt><code>genes</code></dt><dd><p>Vector with gene names of all genes in <code>ndata</code> remaining after filtering.</p>
</dd>
<dt><code>dimRed</code></dt><dd><p>list object object storing information on a feature matrix obtained by dimensional reduction, batch effect correction etc.
Component <code>x</code> stores the actual feature matrix.</p>
</dd>
<dt><code>distances</code></dt><dd><p>distance (or dis-similarity) matrix computed by RaceID3.</p>
</dd>
<dt><code>imputed</code></dt><dd><p>list with two matrices computed for imputing gene expression. The first matrix <code>nn</code> contains the cell indices of the <code>knn</code> nearest neighbours,
the second matrix contains the probabilities at which each cell contributes to thye imputed gene expression value for the cell correponding to the columns.</p>
</dd>
<dt><code>tsne</code></dt><dd><p>data.frame with coordinates of two-dimensional tsne layout computed by RaceID3.</p>
</dd>
<dt><code>fr</code></dt><dd><p>data.frame with coordinates of two-dimensional Fruchterman-Rheingold graphlayout computed by RaceID3.</p>
</dd>
<dt><code>umap</code></dt><dd><p>data.frame with coordinates of two-dimensional umap representation computed by RaceID3.</p>
</dd>
<dt><code>cluster</code></dt><dd><p>list storing information on the initial clustering step of the RaceID3 algorithm</p>
</dd>
<dt><code>background</code></dt><dd><p>list storing the polynomial fit for the background model of gene expression variability computed by RaceID3,
which is used for outlier identification.</p>
</dd>
<dt><code>out</code></dt><dd><p>list storing information on outlier cells used for the prediction of rare cell types by RaceID3</p>
</dd>
<dt><code>cpart</code></dt><dd><p>vector containing the final clustering (i.e. cell type) partition computed by RaceID3</p>
</dd>
<dt><code>fcol</code></dt><dd><p>vector contaning the colour scheme for the RaceID3 clusters</p>
</dd>
<dt><code>medoids</code></dt><dd><p>vector containing the cell ids for th cluster medoids</p>
</dd>
<dt><code>filterpar</code></dt><dd><p>list containing the parameters used for cell and gene filterung</p>
</dd>
<dt><code>clusterpar</code></dt><dd><p>list containing the parameters used for clustering</p>
</dd>
<dt><code>outlierpar</code></dt><dd><p>list containing the parameters used for outlier identification</p>
</dd>
</dl>

<hr>
<h2 id='Seurat2SCseq'>Converting a Seurat object to a RaceID/VarID object</h2><span id='topic+Seurat2SCseq'></span>

<h3>Description</h3>

<p>This function expects a class <code>Seurat</code> object from the <span class="pkg">Seurat</span> package as input and converts this into a <span class="pkg">RaceID</span> <code>SCseq</code> object. The function transfers the counts, initializes <code>ndata</code> and <code>fdata</code> without further filtering, transfers the PCA cell embeddings from the <code>Seurat</code> object to <code>dimRed</code>, transfers the clustering partition, and <code>umap</code> and <code>tsne</code> dimensional reduction (if available). CAUTION: Cluster numbers in RaceID start at 1 by default. Hence, all Seurat cluster numbers are shifted by 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Seurat2SCseq(Se, rseed = 12345)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Seurat2SCseq_+3A_se">Se</code></td>
<td>
<p><span class="pkg">Seurat</span> object.</p>
</td></tr>
<tr><td><code id="Seurat2SCseq_+3A_rseed">rseed</code></td>
<td>
<p>Integer number. Random seed for sampling cluster colours.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><span class="pkg">RaceID</span> <code>SCseq</code> object.
</p>

<hr>
<h2 id='testPrior'>Posterior check of the model</h2><span id='topic+testPrior'></span>

<h3>Description</h3>

<p>This functions compares variance estimates obtained from the maximum a posterior estimate with a given prior to the data. The ratio between the predicted variance and the actual variance for a random subset of genes is computed across all pruned k nearest neighbourhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testPrior(
  res,
  expData,
  gamma = c(0.2, 0.5, 1, 5, 1000),
  rseed = 12345,
  ngenes = 200,
  pvalue = 0.01,
  minN = 5,
  no_cores = NULL,
  x0 = 0,
  lower = 0,
  upper = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testPrior_+3A_res">res</code></td>
<td>
<p>List object with k nearest neighbour information returned by <code>pruneKnn</code>.</p>
</td></tr>
<tr><td><code id="testPrior_+3A_expdata">expData</code></td>
<td>
<p>Matrix of gene expression values with genes as rows and cells as columns. These values have to correspond to unique molecular identifier counts.</p>
</td></tr>
<tr><td><code id="testPrior_+3A_gamma">gamma</code></td>
<td>
<p>Vector of <code>gamma</code>-values to test for the Cauchy prior distribution. Default is <code>c(0.2,0.5,1,5,1000)</code>. Large values correspond to weak priors (<code>gamma=1000</code> corresponds to a maximum likelihood estimate).</p>
</td></tr>
<tr><td><code id="testPrior_+3A_rseed">rseed</code></td>
<td>
<p>Integer number. Random seed to enforce reproducible gene sampling. Default is 12345.</p>
</td></tr>
<tr><td><code id="testPrior_+3A_ngenes">ngenes</code></td>
<td>
<p>Positive integer number. Randomly sampled number of genes (from rownames of <code>expData</code>) used for noise estimation. Genes are sampled uniformly across the entire expression range. Default is 200.</p>
</td></tr>
<tr><td><code id="testPrior_+3A_pvalue">pvalue</code></td>
<td>
<p>Input parameter for <code>compTBNoise</code>. See <code>help(compTBNoise)</code>.</p>
</td></tr>
<tr><td><code id="testPrior_+3A_minn">minN</code></td>
<td>
<p>Input parameter for <code>compTBNoise</code>. See <code>help(compTBNoise)</code>.</p>
</td></tr>
<tr><td><code id="testPrior_+3A_no_cores">no_cores</code></td>
<td>
<p>Input parameter for <code>compTBNoise</code>. See <code>help(compTBNoise)</code>.</p>
</td></tr>
<tr><td><code id="testPrior_+3A_x0">x0</code></td>
<td>
<p>Input parameter for <code>compTBNoise</code>. See <code>help(compTBNoise)</code>.</p>
</td></tr>
<tr><td><code id="testPrior_+3A_lower">lower</code></td>
<td>
<p>Input parameter for <code>compTBNoise</code>. See <code>help(compTBNoise)</code>.</p>
</td></tr>
<tr><td><code id="testPrior_+3A_upper">upper</code></td>
<td>
<p>Input parameter for <code>compTBNoise</code>. See <code>help(compTBNoise)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of three components:
</p>
<table>
<tr><td><code>pp.var.ratio</code></td>
<td>
<p>List of vectors for each gamma value of ratios between predicted and actual variances across all sampled genes and neighbourhoods.</p>
</td></tr>
<tr><td><code>noise</code></td>
<td>
<p>List of noise objects obtained from <code>compTBNoise</code> for each gamma value.</p>
</td></tr>
<tr><td><code>tc</code></td>
<td>
<p>Vector of total transcript counts for all cells</p>
</td></tr>
</table>

<hr>
<h2 id='transitionProbs'>Function for the computation of transition probabilities between clusters</h2><span id='topic+transitionProbs'></span>

<h3>Description</h3>

<p>This function computes transition probabilities between clusters based on the link probabilities of the pruned k nearest neighbour graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitionProbs(res, cl, pvalue = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitionProbs_+3A_res">res</code></td>
<td>
<p>List object with k nearest neighbour information returned by <code>pruneKnn</code> function.</p>
</td></tr>
<tr><td><code id="transitionProbs_+3A_cl">cl</code></td>
<td>
<p>List object with clustering information, returned by the <code>graphCluster</code> function. If an aggregated cluster of tiny clusters (singletons) exists, stored in <code>residual.cluster</code>, this cluster is disregarded, and no links with this clusters are inferred.</p>
</td></tr>
<tr><td><code id="transitionProbs_+3A_pvalue">pvalue</code></td>
<td>
<p>Positive real number between 0 and 1. All nearest neighbours with link probability <code>&lt; pvalue</code> are discarded. Default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of transition probabilities between clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- pruneKnn(intestinalDataSmall,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
cl &lt;- graphCluster(res,pvalue=0.01)
probs &lt;-transitionProbs(res,cl,pvalue=0.01) 
</code></pre>

<hr>
<h2 id='updateSC'>Function for updating a RaceID SCseq object with VarID results</h2><span id='topic+updateSC'></span>

<h3>Description</h3>

<p>This function updates a <span class="pkg">RaceID</span> <code>SCseq</code> object with a distance matrix or dimensionally reduced feature matrix,
a clustering partition, and/or a matrix of gene expression variability,
in order to utilize <span class="pkg">RaceID</span> functions for visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateSC(object, res = NULL, cl = NULL, noise = NULL, flo = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateSC_+3A_object">object</code></td>
<td>
<p><span class="pkg">RaceID</span> <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="updateSC_+3A_res">res</code></td>
<td>
<p>List object returned by <code>pruneKnn</code> function to update <code>SCseq</code> with distance matrix and/or dimensionally reduced feature matrix
in <code>res</code>. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="updateSC_+3A_cl">cl</code></td>
<td>
<p>List object with clustering information, returned by the <code>graphCluster</code> function to update <code>SCseq</code> object with clustering
partition and Fruchterman-Rheingold layout. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="updateSC_+3A_noise">noise</code></td>
<td>
<p>List object with the background noise model and a variability matrix, returned by the <code>compNoise</code> or <code>compTBNoise</code> function, to update <code>SCseq</code>
object with a noise matrix. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="updateSC_+3A_flo">flo</code></td>
<td>
<p>Real number. Lower cutoff for the gene expression variability. All values <code>&lt; flo</code> in the variability matrix are set to this level. Default is <code>NULL</code> and values are not reset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SCseq</code> object with a distance matrix (slot <code>distances</code>) and a dimensionally reduced feature matrix (slot <code>dimRed$x</code>), or clustering partition (slot <code>cpart</code> and <code>cluster$kpart</code>) derived from the VarID analysis, and/or with a gene expression variability matrix in slot <code>noise</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
sc &lt;- compdist(sc)
d &lt;- getExpData(sc)
res &lt;- pruneKnn(d,distM=sc@distances,knn=10,alpha=1,no_cores=1,FSelect=FALSE)
cl &lt;- graphCluster(res,pvalue=0.01)
sc &lt;- updateSC(sc,res=res,cl=cl)
sc &lt;- comptsne(sc)
plotmap(sc)
</code></pre>

<hr>
<h2 id='varRegression'>Linear Regression of Sources of Variability</h2><span id='topic+varRegression'></span>

<h3>Description</h3>

<p>This functions regresses out variability associated with particular sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varRegression(object, vars = NULL, logscale = FALSE, Batch = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varRegression_+3A_object">object</code></td>
<td>
<p><code>SCseq</code> class object.</p>
</td></tr>
<tr><td><code id="varRegression_+3A_vars">vars</code></td>
<td>
<p>data.frame of variables to be regressed out. Each column corresponds to a variable and each variable corresponds to a cell.
The object must contain all cells, i.e. column names of the slot <code>ndata</code> from the <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="varRegression_+3A_logscale">logscale</code></td>
<td>
<p>logical. If <code>TRUE</code> data are log-transformed prior to regression. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="varRegression_+3A_batch">Batch</code></td>
<td>
<p>logical. If <code>TRUE</code>, then the function will regress out batch-associated variability based on genes stored in the <code>filterpar$BGenes</code>
slot of the <code>SCseq</code> object. This requires prior batch correction with the <code>filterdata</code> function using <code>bmode="RaceID"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an updated <code>SCseq</code> object with the corrected expression matrix written to the slot <code>dimRed$x</code> of the <code>SCseq</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc &lt;- SCseq(intestinalDataSmall)
sc &lt;- filterdata(sc)
b &lt;- sub("(\\_\\d+)$","",colnames(intestinalData))
vars &lt;- data.frame(row.names=colnames(intestinalData),batch=b)
sc   &lt;- varRegression(sc,vars)
</code></pre>

<hr>
<h2 id='violinMarkerPlot'>Violin plot of marker gene expression or noise</h2><span id='topic+violinMarkerPlot'></span>

<h3>Description</h3>

<p>Displaying violin plots of gene expression or gene expression noise (epsilon) across (a set of) clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>violinMarkerPlot(g, object, noise = NULL, set = NULL, ti = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="violinMarkerPlot_+3A_g">g</code></td>
<td>
<p>Valid gene ID corresponding to a (set of) rownames of <code>object@ndata</code> or <code>noise</code>.</p>
</td></tr>
<tr><td><code id="violinMarkerPlot_+3A_object">object</code></td>
<td>
<p><span class="pkg">RaceID</span> <code>SCseq</code> object.</p>
</td></tr>
<tr><td><code id="violinMarkerPlot_+3A_noise">noise</code></td>
<td>
<p>List of noise parameters returned by <code>compTBNoise</code>. If this argument is given, then the distribution of noise (epsilon) is plotted. Default is NULL and normalized gene expression (normalized by median count across all clusters in <code>set</code>) is plotted.</p>
</td></tr>
<tr><td><code id="violinMarkerPlot_+3A_set">set</code></td>
<td>
<p>Postive integer number or vector of integers corresponding to valid cluster numbers. Violin plots are shown for all clusters in <code>set</code>. Default is NULL and data are shown for all clusters in <code>object@cpart</code>.</p>
</td></tr>
<tr><td><code id="violinMarkerPlot_+3A_ti">ti</code></td>
<td>
<p>String of characters representing the title of the plot. Default is <code>NULL</code> and the first element of <code>g</code> is chosen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
