<!DOCTYPE html><html lang="en"><head><title>Help for package FAVA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FAVA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootstrap_fava'><p>Statistically compare FAVA values between pairs of relative abundance matrices.</p></a></li>
<li><a href='#fava'><p>Compute the Fst of a matrix of compositional vectors</p></a></li>
<li><a href='#fava_norm'><p>Compute the normalized Fst of a matrix of compositional vectors</p></a></li>
<li><a href='#gini_simpson'><p>Compute the Gini-Simpson index of a compositional vector</p></a></li>
<li><a href='#gini_simpson_mean'><p>Compute the mean Gini-Simpson index of the rows in a matrix of compositional vectors</p></a></li>
<li><a href='#gini_simpson_pooled'><p>Compute the pooled Gini-Simpson index of the rows in a matrix of compositional vectors</p></a></li>
<li><a href='#plot_relabund'><p>Visualize a relative abundance matrix as a stacked bar plot.</p></a></li>
<li><a href='#relab_phyloseq'><p>Generate a relative abundance matrix with sample metadata and OTU abundances from a  phyloseq object.</p></a></li>
<li><a href='#time_weights'><p>Compute a normalized weighting vector based on a vector of sampling times.</p></a></li>
<li><a href='#window_fava'><p>Compute FAVA in sliding windows.</p></a></li>
<li><a href='#window_list'><p>Generate sliding windows of specified length given the maximum number of samples</p></a></li>
<li><a href='#window_plot'><p>Generate a plot of FAVA in sliding windows.</p></a></li>
<li><a href='#xue_microbiome_sample'><p>Temporal microbiome composition data</p></a></li>
<li><a href='#xue_species_info'><p>Table of species information</p></a></li>
<li><a href='#xue_species_similarity'><p>Species similarity matrix for the species included in xue_microbiome_sample</p></a></li>
<li><a href='#xue_species_tree'><p>Phylogenetic tree for the species included in xue_microbiome_sample</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Quantify Compositional Variability Across Relative Abundance
Vectors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the statistic FAVA, an Fst-based Assessment of Variability across 
  vectors of relative Abundances, as well as a suite of helper functions which enable the 
  visualization and statistical analysis of relative abundance data. The 'FAVA' R package 
  accompanies the paper, “Quantifying compositional variability in microbial communities
  with FAVA” by Morrison, Xue, and Rosenberg (2024) &lt;<a href="https://doi.org/10.1101%2F2024.07.03.601929">doi:10.1101/2024.07.03.601929</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://maikemorrison.github.io/FAVA/">https://maikemorrison.github.io/FAVA/</a>,
<a href="https://maikemorrison.github.io/FAVA/articles/microbiome_tutorial.html">https://maikemorrison.github.io/FAVA/articles/microbiome_tutorial.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MaikeMorrison/FAVA/issues">https://github.com/MaikeMorrison/FAVA/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, rlang, tidyr, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>patchwork (&ge; 1.2.0), rmarkdown, viridis, kableExtra, purrr,
ape, gridExtra, phyloseq, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-09 20:42:35 UTC; maikem</td>
</tr>
<tr>
<td>Author:</td>
<td>Maike Morrison <a href="https://orcid.org/0000-0003-0430-1401"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maike Morrison &lt;maikem@stanford.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-10 21:10:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootstrap_fava'>Statistically compare FAVA values between pairs of relative abundance matrices.</h2><span id='topic+bootstrap_fava'></span>

<h3>Description</h3>

<p><code>bootstrap_fava</code> uses bootstrapping to statistically compare FAVA values between pairs of relative abundance matrices. <code>bootstrap_fava</code> takes the same options as <code>fava</code>, so, as with <code>fava</code>, you can separately analyze multiple populations or groups of samples (specify <code>group</code>), and account for similarity among categories (specify <code>S</code>) or uneven weighting of rows (specify <code>w</code> or <code>time</code>). <code>bootstrap_fava</code> follows the bootstrapping procedure defined by Efron and Tibshirani (1993). Details on the bootstrapping procedure are available in the Methods section of the accompanying paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_fava(
  relab_matrix,
  n_replicates = 1000,
  group,
  K = NULL,
  S = NULL,
  w = NULL,
  time = NULL,
  normalized = FALSE,
  seed = NULL,
  alternative = "two.sided"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap_fava_+3A_relab_matrix">relab_matrix</code></td>
<td>
<p>A matrix or data frame with rows containing non-negative entries that sum to 1. Each row represents a sample, each column represents a category, and each entry represents the abundance of that category in the sample. If <code>relab_matrix</code> contains any metadata, it must be on the left-hand side of the matrix, the right <code>K</code> entries of each row must sum to 1, and <code>K</code> must be specified. Otherwise, all entries of each row must sum to 1.</p>
</td></tr>
<tr><td><code id="bootstrap_fava_+3A_n_replicates">n_replicates</code></td>
<td>
<p>The number of bootstrap replicate matrices to generate. Default is <code>n_replicates = 1000</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_fava_+3A_group">group</code></td>
<td>
<p>A string (or vector of strings) specifying the name(s) of the column(s) that describes which group(s) each row (sample) belongs to. Use if <code>relab_matrix</code> is a single matrix containing multiple groups of samples you wish to compare.</p>
</td></tr>
<tr><td><code id="bootstrap_fava_+3A_k">K</code></td>
<td>
<p>Optional; an integer specifying the number of categories in the data. Default is <code>K=ncol(relab_matrix)</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_fava_+3A_s">S</code></td>
<td>
<p>Optional; a K x K similarity matrix with diagonal elements equal to 1 and off-diagonal elements between 0 and 1. Entry <code>S[i,k]</code> for <code>i!=k</code> is the similarity between category and <code>i</code> and category <code>k</code>, equaling 1 if the categories are to be treated as identical and equaling 0 if they are to be treated as totally dissimilar. The default value is <code>S = diag(ncol(relab_matrix))</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_fava_+3A_w">w</code></td>
<td>
<p>Optional; a vector of length <code>I</code> with non-negative entries that sum to 1. Entry <code>w[i]</code> represents the weight placed on row <code>i</code> in the computation of the mean abundance of each category across rows. The default value is <code>w = rep(1/nrow(relab_matrix), nrow(relab_matrix))</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_fava_+3A_time">time</code></td>
<td>
<p>Optional; a string specifying the name of the column that describes the sampling time for each row. Include if you wish to weight FAVA by the distance between samples.</p>
</td></tr>
<tr><td><code id="bootstrap_fava_+3A_normalized">normalized</code></td>
<td>
<p>Optional; should normalized FAVA be used? Default is <code>normalized = FALSE</code>; use <code>normalized = TRUE</code> to compute normalized FAVA. FAVA can only be normalized if it is not weighted.</p>
</td></tr>
<tr><td><code id="bootstrap_fava_+3A_seed">seed</code></td>
<td>
<p>Optional; an integer to be used as a random seed for the simulations.</p>
</td></tr>
<tr><td><code id="bootstrap_fava_+3A_alternative">alternative</code></td>
<td>
<p>Optional; do you want to do a one- or two.sided test? Default is <code>alternative = "two.sided"</code>. If you wish to do a one-sided test, specify either <code>alternative = "lesser"</code> or <code>alternative = "greater"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing the following entries:
</p>

<ul>
<li> <p><code>p_values</code>: The probability of observing the observed difference in variability between each pair of groups if there were no difference between groups. Computed as the fraction of bootstrap differences greater than or equal to the observed difference. Depends on what <code>alternative</code> is specified (&quot;greater&quot;, &quot;lesser&quot;, or &quot;two.sided&quot;).
</p>
</li>
<li> <p><code>bootstrap_distribution_plot</code>: The distribution of bootstrap replicate differences in each variability value. The observed differences are shown in red. The further the red points are from 0, the more significant the statistical difference between groups.
</p>
</li>
<li> <p><code>observed_stats</code>: The observed diversity statistics for the groups.
</p>
</li>
<li> <p><code>bootstrap_stats</code>: The bootstrap replicate diversity statistics for the groups.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Statistically compare values of FAVA between
# subjects in the xue_microbiome_sample data:

 boot_out = bootstrap_fava(relab_matrix = xue_microbiome_sample,
               n_replicates = 20, # should use 1000 for a real analysis
               seed = 1,
               group = "subject",
               K = 524,
               S = xue_species_similarity)

# Table of P-values comparing values of FAVA between group 1 and group 2:
 boot_out$P_values

 # Plots of the bootstrap distributions of differences in FAVA between each pair of matrices,
 # and how the true observed differences (red dots) compare to the distribution.
 boot_out$bootstrap_distribution_plot
</code></pre>

<hr>
<h2 id='fava'>Compute the Fst of a matrix of compositional vectors</h2><span id='topic+fava'></span>

<h3>Description</h3>

<p>This function computes the population-genetic statistic Fst on any matrix with rows that sum to 1. Values of 0 are achieved when each row is a permutation of (1,0,..., 0) and at least two categories have non-zero abundance across all rows. The value equals 1 when each row is identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fava(
  relab_matrix,
  K = NULL,
  S = NULL,
  w = NULL,
  time = NULL,
  group = NULL,
  normalized = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fava_+3A_relab_matrix">relab_matrix</code></td>
<td>
<p>A matrix or data frame with rows containing non-negative entries that sum to 1. Each row represents
a sample, each column represents a category, and each entry represents the abundance of that category in the sample.
If <code>relab_matrix</code> contains any metadata, it must be on the left-hand side of the matrix,
the right <code>K</code> entries of each row must sum to 1, and <code>K</code> must be specified. Otherwise, all entries of
each row must sum to 1.</p>
</td></tr>
<tr><td><code id="fava_+3A_k">K</code></td>
<td>
<p>Optional; an integer specifying the number of categories in the data. Default is <code>K=ncol(relab_matrix)</code>.</p>
</td></tr>
<tr><td><code id="fava_+3A_s">S</code></td>
<td>
<p>Optional; a K x K similarity matrix with diagonal elements equal to 1 and off-diagonal elements between 0 and 1. Entry <code>S[i,k]</code> for <code>i!=k</code> is the similarity between category and <code>i</code> and category <code>k</code>, equaling 1 if the categories are to be treated as identical and equaling 0 if they are to be treated as totally dissimilar. The default value is <code>S = diag(ncol(relab_matrix))</code>.</p>
</td></tr>
<tr><td><code id="fava_+3A_w">w</code></td>
<td>
<p>Optional; a vector of length <code>I</code> with non-negative entries that sum to 1. Entry <code>w[i]</code> represents the weight placed on row <code>i</code> in the computation of the mean abundance of each category across rows. The default value is <code>w = rep(1/nrow(relab_matrix), nrow(relab_matrix))</code>.</p>
</td></tr>
<tr><td><code id="fava_+3A_time">time</code></td>
<td>
<p>Optional; a string specifying the name of the column that describes the sampling time for each row. Include if you wish to weight FAVA by the distance between samples.</p>
</td></tr>
<tr><td><code id="fava_+3A_group">group</code></td>
<td>
<p>Optional; a string (or vector of strings) specifying the name(s) of the column(s) that describes which group(s) each row (sample) belongs to. Use if <code>relab_matrix</code> is a single matrix containing multiple groups of samples you wish to compare.</p>
</td></tr>
<tr><td><code id="fava_+3A_normalized">normalized</code></td>
<td>
<p>Optional; should normalized FAVA be used? Default is <code>normalized = FALSE</code>; use <code>normalized = TRUE</code> to compute normalized FAVA. FAVA can only be normalized if it is not weighted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the Fst of
# the following compositional vectors:
q1 = c(1,   0,   0,   0)
q2 = c(0.5, 0.5, 0,   0)
q3 = c(1/4, 1/4, 1/4, 1/4)
q4 = c(0,   0,   1,   0)
relative_abundances = matrix(c(q1, q2, q3, q4),
                  byrow = TRUE, nrow = 4)

fava(relative_abundances)

# Incoporating weights:

# Compute fava ignoring
# rows 2 and 3
row_weights = c(0.5, 0, 0, 0.5)
fava(relative_abundances, w = row_weights)

# Compute fava assuming that
# categories 1 and 2 are identical:
similarity_matrix = diag(4)
similarity_matrix[1,2] = 1
similarity_matrix[2,1] = 1
fava(relative_abundances, S = similarity_matrix)

# Assume categories 1 and 2 are identical AND
# ignore rows 2 and 4:
row_weights = c(0.5, 0, 0.5, 0)
fava(relative_abundances, w = row_weights, S = similarity_matrix)
</code></pre>

<hr>
<h2 id='fava_norm'>Compute the normalized Fst of a matrix of compositional vectors</h2><span id='topic+fava_norm'></span>

<h3>Description</h3>

<p>This function computes the normalized Fst given the number of rows and the mean abundance of the most abundant category.
We employ the normalization employed in the <a href="https://github.com/MaikeMorrison/FSTruct">FSTruct package</a> by
Morrison, Alcala, and Rosenberg (2020) doi: <a href="https://doi.org/10.1111/1755-0998.13647">10.1111/1755-0998.13647</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fava_norm(relab_matrix, K = ncol(relab_matrix))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fava_norm_+3A_relab_matrix">relab_matrix</code></td>
<td>
<p>A matrix or data frame with rows containing non-negative entries that sum to 1. Each row represents
a sample, each column represents a category, and each entry represents the abundance of that category in the sample.
If <code>relab_matrix</code> contains any metadata, it must be on the left-hand side of the matrix,
the right <code>K</code> entries of each row must sum to 1, and <code>K</code> must be specified. Otherwise, all entries of
each row must sum to 1.</p>
</td></tr>
<tr><td><code id="fava_norm_+3A_k">K</code></td>
<td>
<p>Optional; an integer specifying the number of categories in the data. Default is <code>K=ncol(relab_matrix)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the weighted fava of
# the following compositional vectors:
q1 = c(1,   0,   0,   0)
q2 = c(0.5, 0.5, 0,   0)
q3 = c(1/4, 1/4, 1/4, 1/4)
q4 = c(0,   0,   1,   0)
relative_abundances = matrix(c(q1, q2, q3, q4),
                  byrow = TRUE, nrow = 4)

fava_norm(relative_abundances)
</code></pre>

<hr>
<h2 id='gini_simpson'>Compute the Gini-Simpson index of a compositional vector</h2><span id='topic+gini_simpson'></span>

<h3>Description</h3>

<p>This function computes the Gini-Simpson index, a statistical measure of variability known in population genetics as heterozygosity, of avector of non-negative entries which sum to 1. The function returns a number between 0 and 1 which quantifies the variability of the vector. Values of 0 are achieved when the vector is a permutation of (1,0,..., 0). The value approaches 1 as the number of categories K increases when the vector is equal to (1/K, 1/K, ..., 1/K).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini_simpson(q, K = length(q), S = diag(K))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gini_simpson_+3A_q">q</code></td>
<td>
<p>A vector with <code>K=length(q)</code> non-negative entries that sum to 1.</p>
</td></tr>
<tr><td><code id="gini_simpson_+3A_k">K</code></td>
<td>
<p>Optional; an integer specifying the number of categories in the data. Default is <code>K=length(q)</code>.</p>
</td></tr>
<tr><td><code id="gini_simpson_+3A_s">S</code></td>
<td>
<p>Optional; a K x K similarity matrix with diagonal elements equal to 1 and off-diagonal elements between 0 and 1. Entry <code>S[i,k]</code> for <code>i!=k</code> is the similarity between category and <code>i</code> and category <code>k</code>, equalling 1 if the categories are to be treated as identical and equaling 0 if they are to be treated as totally dissimilar. The default value is <code>S = diag(ncol(q))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute unweighted Gini-Simpson index:
gini_simpson(q = c(0.4, 0.3, 0.3))

# Compute Gini-Simpson index assuming that
# categories 1 and 2 are identical:
similarity_matrix = diag(3)
similarity_matrix[1,2] = 1
similarity_matrix[2,1] = 1
gini_simpson(q = c(0.4, 0.3, 0.3), S = similarity_matrix)
</code></pre>

<hr>
<h2 id='gini_simpson_mean'>Compute the mean Gini-Simpson index of the rows in a matrix of compositional vectors</h2><span id='topic+gini_simpson_mean'></span>

<h3>Description</h3>

<p>This function computes the mean Gini-Simpson index, a statistical measure of variability known in population genetics as heterozygosity, of a set of vectors of non-negative entries which sum to 1. The function returns a number between 0 and 1 which quantifies the mean variability of the vectors. Values of 0 are achieved when each vector is a permutation of (1,0,..., 0). The value approaches 1 as the number of categories K increases when the vectors are equal to (1/K, 1/K, ..., 1/K).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini_simpson_mean(
  relab_matrix,
  K = NULL,
  S = NULL,
  w = NULL,
  time = NULL,
  group = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gini_simpson_mean_+3A_relab_matrix">relab_matrix</code></td>
<td>
<p>A matrix or data frame with rows containing non-negative entries that sum to 1. Each row represents
a sample, each column represents a category, and each entry represents the abundance of that category in the sample.
If <code>relab_matrix</code> contains any metadata, it must be on the left-hand side of the matrix,
the right <code>K</code> entries of each row must sum to 1, and <code>K</code> must be specified. Otherwise, all entries of
each row must sum to 1.</p>
</td></tr>
<tr><td><code id="gini_simpson_mean_+3A_k">K</code></td>
<td>
<p>Optional; an integer specifying the number of categories in the data. Default is <code>K=ncol(relab_matrix)</code>.</p>
</td></tr>
<tr><td><code id="gini_simpson_mean_+3A_s">S</code></td>
<td>
<p>Optional; a K x K similarity matrix with diagonal elements equal to 1 and off-diagonal elements between 0 and 1. Entry <code>S[i,k]</code> for <code>i!=k</code> is the similarity between category and <code>i</code> and category <code>k</code>, equalling 1 if the categories are to be treated as identical and equaling 0 if they are to be treated as totally dissimilar. The default value is <code>S = diag(ncol(relab_matrix))</code>.</p>
</td></tr>
<tr><td><code id="gini_simpson_mean_+3A_w">w</code></td>
<td>
<p>Optional; a vector of length <code>I</code> with non-negative entries that sum to 1. Entry <code>w[i]</code> represents the weight placed on row <code>i</code> in the computation of the mean abundance of each category across rows. The default value is <code>w = rep(1/nrow(relab_matrix), nrow(relab_matrix))</code>.</p>
</td></tr>
<tr><td><code id="gini_simpson_mean_+3A_time">time</code></td>
<td>
<p>Optional; a string specifying the name of the column that describes the sampling time for each row. Include if you wish to weight FAVA by the distance between samples.</p>
</td></tr>
<tr><td><code id="gini_simpson_mean_+3A_group">group</code></td>
<td>
<p>Optional; a string (or vector of strings) specifying the name(s) of the column(s) that describes which group(s) each row (sample) belongs to. Use if <code>relab_matrix</code> is a single matrix containing multiple groups of samples you wish to compare.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To compute the mean Gini-Simpson index of
# the following compositional vectors...
q1 = c(1,   0,   0,   0)
q2 = c(0.5, 0.5, 0,   0)
q3 = c(1/4, 1/4, 1/4, 1/4)
q4 = c(0,   0,   1,   0)

# we could compute the mean manually:
mean(sapply(list(q1, q2, q3, q4), gini_simpson))

# Or we could use gini_simpson_mean:
relative_abundances = matrix(c(q1, q2, q3, q4),
                  byrow = TRUE, nrow = 4)

gini_simpson_mean(relative_abundances)

# Incoporating weights:

# Compute mean Gini-Simpson index ignoring
# rows 2 and 3
row_weights = c(0.5, 0, 0, 0.5)
gini_simpson_mean(relative_abundances, w = row_weights)

# Compute mean Gini-Simpson index assuming that
# categories 1 and 2 are identical:
similarity_matrix = diag(4)
similarity_matrix[1,2] = 1
similarity_matrix[2,1] = 1
gini_simpson_mean(relative_abundances, S = similarity_matrix)

# Assume categories 1 and 2 are identical AND
# ignore rows 2 and 4:
row_weights = c(0.5, 0, 0.5, 0)
gini_simpson_mean(relative_abundances, w = row_weights, S = similarity_matrix)
</code></pre>

<hr>
<h2 id='gini_simpson_pooled'>Compute the pooled Gini-Simpson index of the rows in a matrix of compositional vectors</h2><span id='topic+gini_simpson_pooled'></span>

<h3>Description</h3>

<p>This function computes the Gini-Simpson index of a &quot;pooled&quot; vector equal to <code>colMeans(relab_matrix)</code>. Values of 0 are achieved when this pooled vector is a permutation of (1,0,..., 0). The value approaches 1 as the number of categories K increases when this pooled vector is equal to (1/K, 1/K, ..., 1/K).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini_simpson_pooled(
  relab_matrix,
  K = NULL,
  S = NULL,
  w = NULL,
  time = NULL,
  group = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gini_simpson_pooled_+3A_relab_matrix">relab_matrix</code></td>
<td>
<p>A matrix or data frame with rows containing non-negative entries that sum to 1. Each row represents
a sample, each column represents a category, and each entry represents the abundance of that category in the sample.
If <code>relab_matrix</code> contains any metadata, it must be on the left-hand side of the matrix,
the right <code>K</code> entries of each row must sum to 1, and <code>K</code> must be specified. Otherwise, all entries of
each row must sum to 1.</p>
</td></tr>
<tr><td><code id="gini_simpson_pooled_+3A_k">K</code></td>
<td>
<p>Optional; an integer specifying the number of categories in the data. Default is <code>K=ncol(relab_matrix)</code>.</p>
</td></tr>
<tr><td><code id="gini_simpson_pooled_+3A_s">S</code></td>
<td>
<p>Optional; a K x K similarity matrix with diagonal elements equal to 1 and off-diagonal elements between 0 and 1. Entry <code>S[i,k]</code> for <code>i!=k</code> is the similarity between category and <code>i</code> and category <code>k</code>, equalling 1 if the categories are to be treated as identical and equaling 0 if they are to be treated as totally dissimilar. The default value is <code>S = diag(ncol(relab_matrix))</code>.</p>
</td></tr>
<tr><td><code id="gini_simpson_pooled_+3A_w">w</code></td>
<td>
<p>Optional; a vector of length <code>I</code> with non-negative entries that sum to 1. Entry <code>w[i]</code> represents the weight placed on row <code>i</code> in the computation of the mean abundance of each category across rows. The default value is <code>w = rep(1/nrow(relab_matrix), nrow(relab_matrix))</code>.</p>
</td></tr>
<tr><td><code id="gini_simpson_pooled_+3A_time">time</code></td>
<td>
<p>Optional; a string specifying the name of the column that describes the sampling time for each row. Include if you wish to weight FAVA by the distance between samples.</p>
</td></tr>
<tr><td><code id="gini_simpson_pooled_+3A_group">group</code></td>
<td>
<p>Optional; a string (or vector of strings) specifying the name(s) of the column(s) that describes which group(s) each row (sample) belongs to. Use if <code>relab_matrix</code> is a single matrix containing multiple groups of samples you wish to compare.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To compute the pooled Gini-Simpson index of
# the following compositional vectors...
q1 = c(1,   0,   0,   0)
q2 = c(0.5, 0.5, 0,   0)
q3 = c(1/4, 1/4, 1/4, 1/4)
q4 = c(0,   0,   1,   0)

# we could compute the mean manually:
qPooled = (q1 + q2 + q3 + q4)/4
gini_simpson(qPooled)

# Or we could use gini_simpson_pooled:
relative_abundances = matrix(c(q1, q2, q3, q4),
                  byrow = TRUE, nrow = 4)

gini_simpson_pooled(relative_abundances)

# Incoporating weights:

# Compute pooled Gini-Simpson index ignoring
# rows 2 and 3
row_weights = c(0.5, 0, 0, 0.5)
gini_simpson_pooled(relative_abundances, w = row_weights)

# Compute pooled Gini-Simpson index assuming that
# categories 1 and 2 are identical:
similarity_matrix = diag(4)
similarity_matrix[1,2] = 1
similarity_matrix[2,1] = 1
gini_simpson_pooled(relative_abundances, S = similarity_matrix)

# Assume categories 1 and 2 are identical AND
# ignore rows 2 and 4:
row_weights = c(0.5, 0, 0.5, 0)
gini_simpson_pooled(relative_abundances, w = row_weights, S = similarity_matrix)
</code></pre>

<hr>
<h2 id='plot_relabund'>Visualize a relative abundance matrix as a stacked bar plot.</h2><span id='topic+plot_relabund'></span>

<h3>Description</h3>

<p>This function enables graphical visualization of a matrix of compostional data.
In the output plot, each vertical bar represents a single vector;
the height of each color in the bar corresponds to the abundance of each category
in that vector. Because this function produces a
ggplot object, its output can be modified using
standard ggplot2 syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_relabund(
  relab_matrix,
  group = NULL,
  time = NULL,
  w = NULL,
  K = NULL,
  arrange = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_relabund_+3A_relab_matrix">relab_matrix</code></td>
<td>
<p>A matrix or data frame with rows containing non-negative entries that sum to 1. Each row represents
a sample, each column represents a category, and each entry represents the abundance of that category in the sample.
If <code>relab_matrix</code> contains any metadata, it must be on the left-hand side of the matrix,
the right <code>K</code> entries of each row must sum to 1, and <code>K</code> must be specified. Otherwise, all entries of
each row must sum to 1.</p>
</td></tr>
<tr><td><code id="plot_relabund_+3A_group">group</code></td>
<td>
<p>Optional; a string specifying the name of the column that describes which group each row (sample) belongs to. Use if <code>matrices</code> is a single matrix containing multiple groups of samples you wish to compare.</p>
</td></tr>
<tr><td><code id="plot_relabund_+3A_time">time</code></td>
<td>
<p>Optional; a string specifying the name of the column that describes the sampling time for each row. Include if you wish to weight FAVA by the distance between samples.</p>
</td></tr>
<tr><td><code id="plot_relabund_+3A_w">w</code></td>
<td>
<p>Optional; a vector of length <code>I</code> with non-negative entries that sum to 1. Entry <code>w[i]</code> represents the weight placed on row <code>i</code> in the computation of the mean abundance of each category across rows. The default value is <code>w = rep(1/nrow(relab_matrix), nrow(relab_matrix))</code>.</p>
</td></tr>
<tr><td><code id="plot_relabund_+3A_k">K</code></td>
<td>
<p>Optional; an integer specifying the number of categories in the data. Default is <code>K=ncol(relab_matrix)</code>.</p>
</td></tr>
<tr><td><code id="plot_relabund_+3A_arrange">arrange</code></td>
<td>
<p>Optional; controls horizontal ordering of samples and vertical ordering of categories.
If <code>arrange = TRUE</code> or <code>arrange = "both"</code>, samples are ordered by the categories of greatest
abundance and categories are ordered in decreasing abundance. If <code>arrange = "vertical"</code>, sample
order is unchanged but categories are ordered in decreasing abundance. If <code>arrange = "horizontal"</code>,
samples are ordered by the most abundant categories, but category order is unchanged. If <code>arrange</code> is missing
or <code>arrange = FALSE</code>, neither order is changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object containing a bar plot visualization of the relative abundance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Make an example matrix of compositional data
# Each row is an individual. Rows sum to 1.
population_A = matrix(c(
    .5, .3, .2,
    .4, .2, .4,
    .5, .4, .1,
    .6, .1, .3,
    .2, 0, .8
  ),
  nrow = 5,
  byrow = TRUE
  )

  plot_relabund(relab_matrix = population_A,
              K = 3, # How many categories per vector?
              arrange = FALSE
              )
  plot_relabund(relab_matrix = population_A,
              K = 3, # How many categories per vector?
              arrange = "horizontal"
              )
  plot_relabund(relab_matrix = population_A,
              K = 3, # How many categories per vector?
              arrange = "vertical"
              )
   plot_relabund(relab_matrix = population_A,
              K = 3, # How many categories per vector?
              arrange = TRUE  # could also be "both"
              )


# You can modify the plot as you would any ggplot2 object
plot_relabund(relab_matrix = population_A,
              K = 3, # How many categories per vector?
              arrange = TRUE
              ) +
  # Below are example, optional modifications to the default plot
  ggplot2::ggtitle("Population A") +
  ggplot2::scale_fill_brewer("Blues") +
  ggplot2::scale_color_brewer("Blues") +
  ggplot2::xlab("Individuals")
  # Note that both scale_fill and scale_color are needed to change the color of the bars.


  # Plot a dataset which has 2 populations

  population_B = matrix(c(
    .9, 0, .1,
    .6, .4, 0,
    .7, 0, .3,
    .3, .4, .3,
    .5, .3, .2
  ),
  nrow = 5,
  byrow = TRUE
  )


  populations_AB = cbind(data.frame(c("A", "A", "A", "A", "A",
                                     "B", "B", "B", "B", "B")),
                         rbind(population_A, population_B))
  colnames(populations_AB) = c("population", "category_1", "category_2", "category_3")


 plot_relabund(relab_matrix = populations_AB, group = "population")
 plot_relabund(relab_matrix = populations_AB, group = "population", arrange = "vertical")
 plot_relabund(relab_matrix = populations_AB, group = "population", arrange = "horizontal")
 plot_relabund(relab_matrix = populations_AB, group = "population", arrange = "both")


</code></pre>

<hr>
<h2 id='relab_phyloseq'>Generate a relative abundance matrix with sample metadata and OTU abundances from a  phyloseq object.</h2><span id='topic+relab_phyloseq'></span>

<h3>Description</h3>

<p>The R package phyloseq streamlines the storage and analysis of microbiome sequence data. This function takes a phyloseq object and extracts the OTU table and the sample metadata and combines them into one relative abundance matrix with rows corresponding to samples, metadata on the left-hand side, and OTU relative abundances on the right-hand side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relab_phyloseq(phyloseq_object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relab_phyloseq_+3A_phyloseq_object">phyloseq_object</code></td>
<td>
<p>A phyloseq object containing both an OTU table (<code>otu_table</code>) and sample metadata (<code>sample_data</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with rows representing samples and columns representing sample data categories or OTU relative abundances.
OTU abundances are automatically normalized so that they sum to 1 for each sample, though a warning will be provided if a
renormalization was necessary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("phyloseq", quietly = TRUE)) {
  data(GlobalPatterns, package = "phyloseq")

# Make a small phyloseq object for demonstration
phyloseq_subset = phyloseq::subset_taxa(phyloseq::subset_samples(GlobalPatterns,
                                                                 X.SampleID %in%
                                                                 c("CL3", "CC1")),
                                        Order == "Cenarchaeales")
  otu_table = relab_phyloseq(phyloseq_subset)
  otu_table[, 1:10]
}
</code></pre>

<hr>
<h2 id='time_weights'>Compute a normalized weighting vector based on a vector of sampling times.</h2><span id='topic+time_weights'></span>

<h3>Description</h3>

<p>This function takes a vector of sampling times, <code class="reqn">t = (t_1, t_2, \ldots, t_I)</code>
and computes a normalized vector which can be used to weight each sample based on
the time between the subsequent and the preceding samples. The weighting vector <code class="reqn">w</code>
is defined such that each entry, <code class="reqn">w_i = d_i / 2T</code>, where <code class="reqn">T=t_I - t_1</code> and
<code class="reqn">d_i = t_{i+1} - t_{i-1}</code> for <code class="reqn">i</code> not equal to 1 or I. <code class="reqn">d_1 = t_2-t_1</code> and <code class="reqn">d_I = t_I-t_{I-1}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_weights(times, group = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_weights_+3A_times">times</code></td>
<td>
<p>A numeric vector of sampling times. Each entry must be
greater than the previous entry.</p>
</td></tr>
<tr><td><code id="time_weights_+3A_group">group</code></td>
<td>
<p>Optional; a character vector specifying the group identity of each
sampling time. Use if there are samples from multiple replicates or subjects
in one dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Each entry provides a weight for each entry in the
provided <code>times</code> vector. If <code>group</code> is not specified, the vector sums to 1. If
<code>group</code> is specified, the vector sums to the number of distinct groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time_vector = c(1, 8, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
                32, 33, 34, 35, 36, 37, 38, 39, 44, 50, 57, 64)

time_weights(times = time_vector)
</code></pre>

<hr>
<h2 id='window_fava'>Compute FAVA in sliding windows.</h2><span id='topic+window_fava'></span>

<h3>Description</h3>

<p>This function computes FAVA in sliding window slices of a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_fava(
  relab_matrix,
  window_size,
  window_step = 1,
  group = NULL,
  index = NULL,
  time = NULL,
  w = NULL,
  S = NULL,
  K = NULL,
  normalized = FALSE,
  alpha = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="window_fava_+3A_relab_matrix">relab_matrix</code></td>
<td>
<p>A matrix or data frame with rows containing non-negative entries that sum to 1. Each row represents
a sample, each column represents a category, and each entry represents the abundance of that category in the sample.
If <code>relab_matrix</code> contains any metadata, it must be on the left-hand side of the matrix,
the right <code>K</code> entries of each row must sum to 1, and <code>K</code> must be specified. Otherwise, all entries of
each row must sum to 1.</p>
</td></tr>
<tr><td><code id="window_fava_+3A_window_size">window_size</code></td>
<td>
<p>An integer number specifying the number of samples per window.</p>
</td></tr>
<tr><td><code id="window_fava_+3A_window_step">window_step</code></td>
<td>
<p>Optional; an integer specifying the distance between the first entry of adjacent windows. Default is <code>window_step=1</code>.</p>
</td></tr>
<tr><td><code id="window_fava_+3A_group">group</code></td>
<td>
<p>Optional; a string specifying the name of the column that describes which group each row (sample) belongs to. Use if <code>relab_matrix</code> is a single matrix containing multiple groups of samples you wish to compare.</p>
</td></tr>
<tr><td><code id="window_fava_+3A_index">index</code></td>
<td>
<p>Optional; a string specifying the name of the column in <code>relab_matrix</code> containing an index for each sample. For example, if <code>relab_matrix</code> contains time series data, <code>index</code> would be the column containing the time of each sample. If <code>index</code> is not specified but <code>time</code> is, <code>time</code> is by default used as the index.</p>
</td></tr>
<tr><td><code id="window_fava_+3A_time">time</code></td>
<td>
<p>Optional; a string specifying the name of the column that describes the sampling time for each row. Include if you wish to weight FAVA by the distance between samples.</p>
</td></tr>
<tr><td><code id="window_fava_+3A_w">w</code></td>
<td>
<p>Optional; a vector of length <code>I</code> with non-negative entries that sum to 1. Entry <code>w[i]</code> represents the weight placed on row <code>i</code> in the computation of the mean abundance of each category across rows. The default value is <code>w = rep(1/nrow(relab_matrix), nrow(relab_matrix))</code>.</p>
</td></tr>
<tr><td><code id="window_fava_+3A_s">S</code></td>
<td>
<p>Optional; a K x K similarity matrix with diagonal elements equal to 1 and off-diagonal elements between 0 and 1. Entry <code>S[i,k]</code> for <code>i!=k</code> is the similarity between category and <code>i</code> and category <code>k</code>, equaling 1 if the categories are to be treated as identical and equaling 0 if they are to be treated as totally dissimilar. The default value is <code>S = diag(ncol(relab_matrix))</code>.</p>
</td></tr>
<tr><td><code id="window_fava_+3A_k">K</code></td>
<td>
<p>Optional; an integer specifying the number of categories in the data. Default is <code>K=ncol(relab_matrix)</code>.</p>
</td></tr>
<tr><td><code id="window_fava_+3A_normalized">normalized</code></td>
<td>
<p>Optional; should normalized FAVA be used? Default is <code>normalized = FALSE</code>; use <code>normalized = TRUE</code> to compute normalized FAVA. FAVA can only be normalized if it is not weighted.</p>
</td></tr>
<tr><td><code id="window_fava_+3A_alpha">alpha</code></td>
<td>
<p>Optional; number between 0 and 1 specifying the opacity of the horizontal
lines plotted. Default is <code>alpha = 0.5</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values of FAVA for each window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(.3,.7,0,.1,0,.9,.2,.5,.3,.1,.8,.1,.3,.4,.3,.6,.4,0,0,.5,.5),
           ncol = 3, byrow = TRUE)
window_out = window_fava(relab_matrix = A, window_size = 4, normalized = TRUE)
</code></pre>

<hr>
<h2 id='window_list'>Generate sliding windows of specified length given the maximum number of samples</h2><span id='topic+window_list'></span>

<h3>Description</h3>

<p>This function generates a list of of sliding windows conditional on two parameters: the length of each window (number of samples) and the total number of samples present in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_list(window_size, length, window_step = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="window_list_+3A_window_size">window_size</code></td>
<td>
<p>An integer number specifying the number of samples per window.</p>
</td></tr>
<tr><td><code id="window_list_+3A_length">length</code></td>
<td>
<p>An integer number specifying the total number of samples.</p>
</td></tr>
<tr><td><code id="window_list_+3A_window_step">window_step</code></td>
<td>
<p>Optional; an integer number specifying the distance between the first entry of adjacent windows. Default is <code>window_step=1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of samples of sample indices. Each list entry represents one window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>window_list(window_size = 6, length = 40)
window_list(window_size = 6, length = 40, window_step = 2)
</code></pre>

<hr>
<h2 id='window_plot'>Generate a plot of FAVA in sliding windows.</h2><span id='topic+window_plot'></span>

<h3>Description</h3>

<p>This function generates a plot of normalized or unnormalized, weighted or
unweighted FAVA computed in sliding windows across samples for one or many
groups of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_plot(window_fava, alpha = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="window_plot_+3A_window_fava">window_fava</code></td>
<td>
<p>The output of <code>window_fava</code>.</p>
</td></tr>
<tr><td><code id="window_plot_+3A_alpha">alpha</code></td>
<td>
<p>Optional; number between 0 and 1 specifying the opacity of the horizontal
lines plotted. Default is <code>alpha = 0.5</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(.3,.7,0,.1,0,.9,.2,.5,.3,.1,.8,.1,.3,.4,.3,.6,.4,0,0,.5,.5),
           ncol = 3, byrow = TRUE)
window_out = window_fava(relab_matrix = A, window_size = 4, normalized = TRUE)
window_out$window_data
window_out$window_plot
</code></pre>

<hr>
<h2 id='xue_microbiome_sample'>Temporal microbiome composition data</h2><span id='topic+xue_microbiome_sample'></span>

<h3>Description</h3>

<p>A subset of the data generated by Xue et al. (2024) detailing longitudinal
composition of the human gut microbiome for three subjects who experience an
antiobitic perturbation between days 29 and 34. We include only the subjects
XAA, XBA, and XCA. Data from doi: <a href="https://doi.org/10.1101/2023.09.26.559480">10.1101/2023.09.26.559480</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xue_microbiome_sample
</code></pre>


<h3>Format</h3>



<h4><code>xue_microbiome_sample</code></h4>

<p>A data frame with 75 rows and 1,348 columns:
</p>

<dl>
<dt>subject</dt><dd><p>Subject ID: XBA, XDA, or XMA</p>
</dd>
<dt>timepoint</dt><dd><p>Time (days) of sample collection</p>
</dd>
<dt>...</dt><dd><p>Species names</p>
</dd>
</dl>
<p>...

</p>


<hr>
<h2 id='xue_species_info'>Table of species information</h2><span id='topic+xue_species_info'></span>

<h3>Description</h3>

<p>A data frame providing taxonomic information for the species included in xue_species_tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xue_species_info
</code></pre>


<h3>Format</h3>



<h4><code>xue_species_info</code></h4>

<p>A data frame with 1346 rows and 9 columns:
</p>

<dl>
<dt>species_id</dt><dd><p>The species_id given in xue_microbiome_sample</p>
</dd>
<dt>kingdom, phylum, class, order, family, genus, species</dt><dd><p>The corresponding taxonomic category for each species</p>
</dd>
<dt>species_id_number</dt><dd><p>The numeric code associated with each species, as used in xue_species_tree</p>
</dd>
</dl>



<hr>
<h2 id='xue_species_similarity'>Species similarity matrix for the species included in xue_microbiome_sample</h2><span id='topic+xue_species_similarity'></span>

<h3>Description</h3>

<p>A similarity matrix, with entry (i,j) corresponding to the pairwise similarity
between species i and species j. This similarity matrix was derived from a
phylogenetic distance matrix, inferred from the tree xue_species_tree,
using the expression s(i,j) = exp(-d(i,j)), where d(i,j) is the phylogenetic
distance between species i and j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xue_species_similarity
</code></pre>


<h3>Format</h3>



<h4><code>xue_species_similarity</code></h4>

<p>A data frame with 524 rows and 524 columns, each corresponding to one species.
</p>


<hr>
<h2 id='xue_species_tree'>Phylogenetic tree for the species included in xue_microbiome_sample</h2><span id='topic+xue_species_tree'></span>

<h3>Description</h3>

<p>A phylogenetic tree in the Newick format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xue_species_tree
</code></pre>


<h3>Format</h3>



<h4><code>xue_species_tree</code></h4>

<p>A Newick tree.
</p>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
