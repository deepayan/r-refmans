<!DOCTYPE html><html><head><title>Help for package VBTree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VBTree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#advbtinq'><p>Using double list to visit vector binary tree</p></a></li>
<li><a href='#advbtsub'><p>Using double list to generate sub tree from vector binary tree</p></a></li>
<li><a href='#arr2dl'><p>Convert a structured character array to double list</p></a></li>
<li><a href='#arr2vbt'><p>Convert a structured character array to double list</p></a></li>
<li><a href='#chrvec2dl'><p>Convert character vector to a double list</p></a></li>
<li><a href='#datatest'>
<p>A test data structurized column names.</p></a></li>
<li><a href='#datavisit'><p>Extract subset of data using different methods</p></a></li>
<li><a href='#dl2arr'><p>Convert a double list to array</p></a></li>
<li><a href='#dl2ts'><p>Convert a double list to tensor</p></a></li>
<li><a href='#dl2vbt'><p>Convert a double list to vector binary tree</p></a></li>
<li><a href='#hello'><p>Welcome message</p></a></li>
<li><a href='#trvs'><p>Make traversal from vector binary tree</p></a></li>
<li><a href='#trvseleinq'><p>Using character element to visit the traversal table</p></a></li>
<li><a href='#trvsidxinq'><p>Using vector to visit the traversal table</p></a></li>
<li><a href='#trvssubinq'><p>Using sub vector binary tree to visit the traversal table</p></a></li>
<li><a href='#ts2dl'><p>Convert a structured character tensor to double list</p></a></li>
<li><a href='#ts2vbt'><p>Convert a structured character tensor to double list</p></a></li>
<li><a href='#vbt2arr'><p>Convert a vector binary tree to array</p></a></li>
<li><a href='#vbt2dl'><p>Convert a vector binary tree to double list</p></a></li>
<li><a href='#vbt2ts'><p>Convert a vector binary tree to tensor</p></a></li>
<li><a href='#vbtinq'><p>Using vector to visit vector binary tree</p></a></li>
<li><a href='#VBTree-package'>
<p>Vector Binary Tree to Make Your Data Management More Efficient</p></a></li>
<li><a href='#vbtsub'><p>Using vector to generate sub tree from vector binary tree</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Vector Binary Tree to Make Your Data Management More Efficient</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-09</td>
</tr>
<tr>
<td>Description:</td>
<td>Vector binary tree provides a new data structure, to
 make your data visiting and management more efficient. If the
 data has structured column names, it can read these names and
 factorize them through specific split pattern, then build the mappings
 within double list, vector binary tree, array and tensor mutually, through
 which the batched data processing is achievable easily. The methods of
 array and tensor are also applicable. Detailed methods are described in
 Chen Zhang et al. (2020) &lt;<a href="https://doi.org/10.35566%2Fisdsa2019c8">doi:10.35566/isdsa2019c8</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>tensorA</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CubicZebra/VBTree">https://github.com/CubicZebra/VBTree</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CubicZebra/VBTree/issues">https://github.com/CubicZebra/VBTree/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-11 09:20:13 UTC; Chen</td>
</tr>
<tr>
<td>Author:</td>
<td>Chen Zhang [aut, cre, cph] (0009-0007-7689-5030)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chen Zhang &lt;chen.zhang_06sept@foxmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-12 09:00:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='advbtinq'>Using double list to visit vector binary tree</h2><span id='topic+advbtinq'></span>

<h3>Description</h3>

<p>Advanced visiting for the vector binary tree. Return a double list by specific assigment determined by
the argument <code>inq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advbtinq(x, inq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="advbtinq_+3A_x">x</code></td>
<td>
<p>The vector binary tree to be visited. Traversal is acheivable through invalid assignment in desired layer.</p>
</td></tr>
<tr><td><code id="advbtinq_+3A_inq">inq</code></td>
<td>
<p>An integer double list to determine the location to be visited. The length of <code>inq</code> should be the same
as the layers of visited vector binary tree, while all elements in vector in each layer of <code>inq</code> should not over
the intrinsic length of visited vector binary tree layer, otherwise all elements will be returned in this layer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a double list according to the argument <code>inq</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vbtinq">vbtinq</a></code>, <code><a href="#topic+vbtsub">vbtsub</a></code>, <code><a href="#topic+advbtsub">advbtsub</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make vector binary tree:
colnamevbt &lt;- dl2vbt(chrvec2dl(colnames(datatest)))

#Visit by specific assignment:
visit &lt;- list(c(2), c(3:6), c(2,4), 1)
advbtinq(colnamevbt, visit)

#Traversal of the second layers:
visit &lt;- list(c(2), colnamevbt$dims[2]+1, c(2,4), 1)
advbtinq(colnamevbt, visit)

#Invalid assignments in 1st and 3rd layers:
visit &lt;- list(c(3), c(3:6), c(5), 1)
advbtinq(colnamevbt, visit)
</code></pre>

<hr>
<h2 id='advbtsub'>Using double list to generate sub tree from vector binary tree</h2><span id='topic+advbtsub'></span>

<h3>Description</h3>

<p>Advanced visiting for the vector binary tree. Generating a sub tree from visited vector binary tree,
through specific assigment determined by the argument <code>inq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>advbtsub(x, inq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="advbtsub_+3A_x">x</code></td>
<td>
<p>The vector binary tree to be visited. Traversal is acheivable through invalid assignment in desired
layers.</p>
</td></tr>
<tr><td><code id="advbtsub_+3A_inq">inq</code></td>
<td>
<p>An integer double list to determine the visiting location. The length of <code>inq</code> should be the same
as the layers of visited vector binary tree. If any assign element in specificed layer exceeds its intrinsic
length of visited vector binary tree layer, all elements will be returned in this layer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a sub tree from visited vector binary tree, according to the argument <code>inq</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vbtinq">vbtinq</a></code>, <code><a href="#topic+vbtsub">vbtsub</a></code>, <code><a href="#topic+advbtinq">advbtinq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make vector binary tree:
colnamevbt &lt;- dl2vbt(chrvec2dl(colnames(datatest)))

#Visit by specific assignment:
visit &lt;- list(c(2), c(3:6), c(2,4), 1)
advbtsub(colnamevbt, visit)

#Traversal of the second layers:
visit &lt;- list(c(2), colnamevbt$dims[2]+1, c(2,4), 1)
advbtsub(colnamevbt, visit)

#Invalid assignments in 1st and 3rd layers:
visit &lt;- list(c(3), c(3:6), c(5), 1)
advbtsub(colnamevbt, visit)
</code></pre>

<hr>
<h2 id='arr2dl'>Convert a structured character array to double list</h2><span id='topic+arr2dl'></span>

<h3>Description</h3>

<p>Convert a structured character array to a double list. All character elements in array will be splited by
a specific pattern then sorted intrinsically in each layer of the double list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arr2dl(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arr2dl_+3A_x">x</code></td>
<td>
<p>A structured character array to be converted.</p>
</td></tr>
<tr><td><code id="arr2dl_+3A_...">...</code></td>
<td>
<p>Argument in <code><a href="#topic+chrvec2dl">chrvec2dl</a></code> to control split pattern.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a double list based on the input array.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arr2vbt">arr2vbt</a></code>, <code><a href="#topic+chrvec2dl">chrvec2dl</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Write the column names of datatest into a array:
arr &lt;- dl2arr(chrvec2dl(colnames(datatest)))

#Recover the double list from character array:
arr2dl(arr)
</code></pre>

<hr>
<h2 id='arr2vbt'>Convert a structured character array to double list</h2><span id='topic+arr2vbt'></span>

<h3>Description</h3>

<p>Convert a structured character array to a vector binary tree. All character elements in array will be splited by
a specific pattern then sorted intrinsically in each layer of the vector binary tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arr2vbt(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arr2vbt_+3A_x">x</code></td>
<td>
<p>A structured character array to be converted.</p>
</td></tr>
<tr><td><code id="arr2vbt_+3A_...">...</code></td>
<td>
<p>Argument in <code><a href="#topic+chrvec2dl">chrvec2dl</a></code> to control split pattern.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a vector binary tree based on the input array.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arr2dl">arr2dl</a></code>, <code><a href="#topic+chrvec2dl">chrvec2dl</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Write the column names of datatest into a array:
arr &lt;- dl2arr(chrvec2dl(colnames(datatest)))

#Recover the vector binary tree from character array:
arr2vbt(arr)
</code></pre>

<hr>
<h2 id='chrvec2dl'>Convert character vector to a double list</h2><span id='topic+chrvec2dl'></span>

<h3>Description</h3>

<p>Structurize a character vector to a double list. Layers in the double list will be determined
by the given pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chrvec2dl(x, splt = "-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chrvec2dl_+3A_x">x</code></td>
<td>
<p>a character vector to be converted.</p>
</td></tr>
<tr><td><code id="chrvec2dl_+3A_splt">splt</code></td>
<td>
<p>a string pattern to make defination for spliting each layer of double list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a character double list splited by defined pattern, the default pattern is &quot;-&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example using default dataset:

charvector &lt;- colnames(datatest)
chrvec2dl(charvector, "-")
</code></pre>

<hr>
<h2 id='datatest'>
A test data structurized column names.
</h2><span id='topic+datatest'></span>

<h3>Description</h3>

<p>A test data with 56 different columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("datatest")</code></pre>


<h3>Details</h3>

<p>A test data structurized column names, with two data type &quot;Strain&quot; and &quot;Stress&quot;, 7 different temperatures, 4 kinds
strain rates and one level of compression rate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datatest
</code></pre>

<hr>
<h2 id='datavisit'>Extract subset of data using different methods</h2><span id='topic+datavisit'></span>

<h3>Description</h3>

<p>Extract the subset of data by column names using tensor, array, double list, integer vector, or vector binary tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datavisit(data, inq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datavisit_+3A_data">data</code></td>
<td>
<p>A data.frame with structured column names.</p>
</td></tr>
<tr><td><code id="datavisit_+3A_inq">inq</code></td>
<td>
<p>An argument to determine the subset to be extracted by column names. A tensor, array, double list, integer vector and
vector binary tree is available format of <code>inq</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list which contains the item index, column name, column coordinate and the data in corresponding column for each
element contained in the assignment of <code>inq</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vbtinq">vbtinq</a></code>, <code><a href="#topic+advbtinq">advbtinq</a></code>, <code><a href="#topic+trvseleinq">trvseleinq</a></code>,
<code><a href="#topic+trvsidxinq">trvsidxinq</a></code>, <code><a href="#topic+trvssubinq">trvssubinq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#View the data to be visited:
summary(datatest)
colnames(datatest)

#Structurize colnames of data into vector binary tree:
dl &lt;- chrvec2dl(colnames(datatest))
vbt &lt;- dl2vbt(dl)
vbt

#Setting subset in different forms, for example the pattern
#"Strain-(900~1100)-(0.01, 1)-0.6" is desired:
subunregdl &lt;- list(c(1), c(1:5), c(2,4), c(1)) # undefined double list
subregdl &lt;- advbtinq(vbt, subunregdl) # regularized double list
subvbt &lt;- dl2vbt(subregdl) # sub vector binary tree
subts &lt;- vbt2ts(subvbt) # tensor
subarr &lt;- vbt2arr(subvbt) # array
subchrvec &lt;- as.vector(subarr) # character vector

#Visit the data through different methods:
datavisit(datatest, subunregdl) # by handmade double list
datavisit(datatest, subregdl) # by defined double list
datavisit(datatest, subvbt) # by vector binary tree
datavisit(datatest, subts) # by tensor
datavisit(datatest, subarr) # by array
datavisit(datatest, subchrvec) # by character vector
</code></pre>

<hr>
<h2 id='dl2arr'>Convert a double list to array</h2><span id='topic+dl2arr'></span>

<h3>Description</h3>

<p>Convert a double list to an array. The pure numeric layers will be sorted intrinsically then all
elements will be bound in certain order as one character element, and filled into the proper location in the array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dl2arr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dl2arr_+3A_x">x</code></td>
<td>
<p>A double list to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an array filled with the binding character elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dl2vbt">dl2vbt</a></code>, <code><a href="#topic+dl2ts">dl2ts</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make column names of datatest into double list:
dl &lt;- chrvec2dl(colnames(datatest), "-")

#Convert the double list to a tensor:
dl2arr(dl)
</code></pre>

<hr>
<h2 id='dl2ts'>Convert a double list to tensor</h2><span id='topic+dl2ts'></span>

<h3>Description</h3>

<p>Convert a double list to a tensor. The pure numeric layers will be sorted intrinsically then all
elements will be bound in certain order as one character element, and filled into the proper location in the tensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dl2ts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dl2ts_+3A_x">x</code></td>
<td>
<p>A double list to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a tensor filled with the binding character elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dl2vbt">dl2vbt</a></code>, <code><a href="#topic+dl2arr">dl2arr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make column names of datatest into double list:
dl &lt;- chrvec2dl(colnames(datatest), "-")

#Convert the double list to a tensor:
dl2ts(dl)
</code></pre>

<hr>
<h2 id='dl2vbt'>Convert a double list to vector binary tree</h2><span id='topic+dl2vbt'></span>

<h3>Description</h3>

<p>Convert a double list to vector binary tree. The pure numeric layers will be sorted intrinsically then
all elements be exported in character form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dl2vbt(x, regularize = TRUE, splt = "-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dl2vbt_+3A_x">x</code></td>
<td>
<p>A double list to be converted.</p>
</td></tr>
<tr><td><code id="dl2vbt_+3A_regularize">regularize</code></td>
<td>
<p>A boolean value to control the treatment of empty layers of double listed to be converted.
The default value <code>TRUE</code> will fill the empty layer by mark &quot;*&quot;. The default value is recommanded.</p>
</td></tr>
<tr><td><code id="dl2vbt_+3A_splt">splt</code></td>
<td>
<p>A string pattern to split the binding elements in each layer if the sub-constructure exists.
The default pattern uses &quot;-&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a vector binary tree.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vbtinq">vbtinq</a></code>, <code><a href="#topic+vbtsub">vbtsub</a></code>, <code><a href="#topic+advbtinq">advbtinq</a></code>,
<code><a href="#topic+advbtsub">advbtsub</a></code>, <code><a href="#topic+trvssubinq">trvssubinq</a></code>, <code><a href="#topic+dl2ts">dl2ts</a></code>,
<code><a href="#topic+dl2arr">dl2arr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Structurize the column names of datatest:
colname &lt;- colnames(datatest)
colnamedl &lt;- chrvec2dl(colname, "-")
colnamevbt &lt;- dl2vbt(colnamedl)

#Simple data cleaning for sub-constructure existing double list;
#Make unregulated double list:
unregdl &lt;- list(c("7", 2, 10), c("chr", "5"), c(),
c("var2", "var1", "var3"), c("M-8-9", "3-2"), c("6-3", "2-7"))
regvbt &lt;- dl2vbt(unregdl)
regvbt2 &lt;- dl2vbt(unregdl, FALSE) # not recommended
</code></pre>

<hr>
<h2 id='hello'>Welcome message</h2><span id='topic+hello'></span>

<h3>Description</h3>

<p>Welcome message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hello()
</code></pre>


<h3>Value</h3>

<p>exit code of zero
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hello()
</code></pre>

<hr>
<h2 id='trvs'>Make traversal from vector binary tree</h2><span id='topic+trvs'></span>

<h3>Description</h3>

<p>Generating a table of traversal from given vector binary tree, in order to construct correct
mapping relationships within double list, vector binary tree, array and tensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trvs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trvs_+3A_x">x</code></td>
<td>
<p>A vector binary tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a traversal table from the given vector binary tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make vector binary tree:
colnamevbt &lt;- dl2vbt(chrvec2dl(colnames(datatest)))

#Construct traversal table:
trvs(colnamevbt)
</code></pre>

<hr>
<h2 id='trvseleinq'>Using character element to visit the traversal table</h2><span id='topic+trvseleinq'></span>

<h3>Description</h3>

<p>Visit the traversal table generated from a vector binary tree through the character element determined by the argument <code>inq</code>, and return
an inquiry result containing its numeric item index, the character pattern and its corresponding coordinate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trvseleinq(trvs, inq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trvseleinq_+3A_trvs">trvs</code></td>
<td>
<p>The traversal table to be visited, which should be generated from the vector binary tree by the function trvs().</p>
</td></tr>
<tr><td><code id="trvseleinq_+3A_inq">inq</code></td>
<td>
<p>A desired character element to match the traversal table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an inquiry result with a numeric item index, a character pattern and its coordinate in form of integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make traversal table:
trav &lt;- trvs(dl2vbt(chrvec2dl(colnames(datatest))))

#Visit specific element by character pattern:
trvseleinq(trav,"Strain-1100-0.001-0.6")
</code></pre>

<hr>
<h2 id='trvsidxinq'>Using vector to visit the traversal table</h2><span id='topic+trvsidxinq'></span>

<h3>Description</h3>

<p>Visit the traversal table generated from a vector binary tree through the coordinate determined by the argument <code>inq</code>, and return
an inquiry result containing its numeric item index, its corresponding character pattern and the coordinate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trvsidxinq(trvs, inq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trvsidxinq_+3A_trvs">trvs</code></td>
<td>
<p>The traversal table to be visited, which should be generated from the vector binary tree by the function trvs().</p>
</td></tr>
<tr><td><code id="trvsidxinq_+3A_inq">inq</code></td>
<td>
<p>An integer vector to assign the coordinate corresponding to the element to be visited.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an inquiry result with a numeric item index, a character pattern and its coordinate in form of integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make traversal table:
trav &lt;- trvs(dl2vbt(chrvec2dl(colnames(datatest))))

#Visit specific element by its coordinate:
trvsidxinq(trav,c(1,2,3,1))
</code></pre>

<hr>
<h2 id='trvssubinq'>Using sub vector binary tree to visit the traversal table</h2><span id='topic+trvssubinq'></span>

<h3>Description</h3>

<p>Visit the traversal table generated from a vector binary tree through the sub vector binary tree determined by the argument <code>inq</code>, and
return an inquiry list containing the numeric index, the character pattern and the corresponding coordinate for each item.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trvssubinq(trvs, inq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trvssubinq_+3A_trvs">trvs</code></td>
<td>
<p>The traversal table to be visited, which should be generated from the vector binary tree by the function trvs().</p>
</td></tr>
<tr><td><code id="trvssubinq_+3A_inq">inq</code></td>
<td>
<p>A sub tree generated from the original vector binary tree, to determine the subset of elements to be visited.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list containing the numeric index, the character pattern and the corresponding coordinate for each item.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vbtsub">vbtsub</a></code>, <code><a href="#topic+advbtsub">advbtsub</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make original vector binary tree and its traversal table:
vbt &lt;- dl2vbt(chrvec2dl(colnames(datatest)))
trav &lt;- trvs(vbt)

#Visit all elements defined by sub vector binary tree:
#example 1: visit all "Stress-*-*-*" patterns;
#make sub vector binary tree through vbtsub() then execute inquiry:
subvbt &lt;- vbtsub(vbt, c(2,-1,-1,-1))
trvssubinq(trav, subvbt)

#example 2: visit all "Strain-("950", "1050")-("0.001", "0.1")-*" patterns;
#make sub vector binary tree through advbtsub() then execute inquiry:
subvbt &lt;- advbtsub(vbt, list(1, c(2,4), c(1,3), 1))
trvssubinq(trav, subvbt)
</code></pre>

<hr>
<h2 id='ts2dl'>Convert a structured character tensor to double list</h2><span id='topic+ts2dl'></span>

<h3>Description</h3>

<p>Convert a structured character tensor to a double list. All character elements in tensor will be splited by
a specific pattern then sorted intrinsically in each layer of the double list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts2dl(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts2dl_+3A_x">x</code></td>
<td>
<p>A structured character tensor to be converted.</p>
</td></tr>
<tr><td><code id="ts2dl_+3A_...">...</code></td>
<td>
<p>Argument in <code><a href="#topic+chrvec2dl">chrvec2dl</a></code> to control split pattern.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a double list based on the input tensor.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts2vbt">ts2vbt</a></code>, <code><a href="#topic+chrvec2dl">chrvec2dl</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Write the column names of datatest into a tensor:
ts &lt;- dl2ts(chrvec2dl(colnames(datatest)))

#Recover the double list from character tensor:
ts2dl(ts)
</code></pre>

<hr>
<h2 id='ts2vbt'>Convert a structured character tensor to double list</h2><span id='topic+ts2vbt'></span>

<h3>Description</h3>

<p>Convert a structured character tensor to a vector binary tree. All character elements in tensor will be splited by
a specific pattern then sorted intrinsically in each layer of the vector binary tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts2vbt(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts2vbt_+3A_x">x</code></td>
<td>
<p>A structured character tensor to be converted.</p>
</td></tr>
<tr><td><code id="ts2vbt_+3A_...">...</code></td>
<td>
<p>Argument in <code><a href="#topic+chrvec2dl">chrvec2dl</a></code> to control split pattern.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a vector binary tree based on the input tensor.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts2dl">ts2dl</a></code>, <code><a href="#topic+chrvec2dl">chrvec2dl</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Write the column names of datatest into a tensor:
ts &lt;- dl2ts(chrvec2dl(colnames(datatest)))

#Recover the vector binary tree from character tensor:
ts2vbt(ts)
</code></pre>

<hr>
<h2 id='vbt2arr'>Convert a vector binary tree to array</h2><span id='topic+vbt2arr'></span>

<h3>Description</h3>

<p>Convert a vector binary tree to an array. The pure numeric layers will be sorted intrinsically then all
elements will be bound in certain order as one character element, and filled into the proper location in the array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vbt2arr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vbt2arr_+3A_x">x</code></td>
<td>
<p>A vector binary tree to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an array filled with the binding character elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vbt2dl">vbt2dl</a></code>, <code><a href="#topic+vbt2ts">vbt2ts</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make column names of datatest into vector binary tree:
vbt &lt;- dl2vbt(chrvec2dl(colnames(datatest), "-"))

#Convert the vector binary tree to an array:
vbt2arr(vbt)
</code></pre>

<hr>
<h2 id='vbt2dl'>Convert a vector binary tree to double list</h2><span id='topic+vbt2dl'></span>

<h3>Description</h3>

<p>Recover a vector binary tree to double list for easy visualization. Empty layers in vector binary
tree will be marked by the symbol &quot;*&quot; as default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vbt2dl(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vbt2dl_+3A_x">x</code></td>
<td>
<p>A vector binary tree to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a double list based on input vector binary tree.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vbtinq">vbtinq</a></code>, <code><a href="#topic+vbtsub">vbtsub</a></code>, <code><a href="#topic+advbtinq">advbtinq</a></code>,
<code><a href="#topic+advbtsub">advbtsub</a></code>, <code><a href="#topic+trvssubinq">trvssubinq</a></code>, <code><a href="#topic+vbt2ts">vbt2ts</a></code>,
<code><a href="#topic+vbt2arr">vbt2arr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Recover vector binary tree to a double list for easy visualization:
vbt &lt;- dl2vbt(chrvec2dl(colnames(datatest))) #make vector binary tree
vbt2dl(vbt)
</code></pre>

<hr>
<h2 id='vbt2ts'>Convert a vector binary tree to tensor</h2><span id='topic+vbt2ts'></span>

<h3>Description</h3>

<p>Convert a vector binary tree to a tensor. The pure numeric layers will be sorted intrinsically then all
elements will be bound in certain order as one character element, and filled into the proper location in the tensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vbt2ts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vbt2ts_+3A_x">x</code></td>
<td>
<p>A vector binary tree to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a tensor filled with the binding character elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vbt2dl">vbt2dl</a></code>, <code><a href="#topic+vbt2arr">vbt2arr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make column names of datatest into vector binary tree:
vbt &lt;- dl2vbt(chrvec2dl(colnames(datatest), "-"))

#Convert the vector binary tree to a tensor:
vbt2ts(vbt)
</code></pre>

<hr>
<h2 id='vbtinq'>Using vector to visit vector binary tree</h2><span id='topic+vbtinq'></span>

<h3>Description</h3>

<p>Visit the vector binary tree and return a double list through specific assigment determined
by the argument <code>inq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vbtinq(x, inq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vbtinq_+3A_x">x</code></td>
<td>
<p>The vector binary tree to be visited. Traversal is available by setting -1 in desired layer.</p>
</td></tr>
<tr><td><code id="vbtinq_+3A_inq">inq</code></td>
<td>
<p>An integer vector to determine desired location. The length of <code>inq</code> should be the same
as the layers of visited vector binary tree. If any assignment in specificed layer exceeds its intrinsic
length of visited vector binary tree layer, all elements will be returned in this layer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a double list according to the argument <code>inq</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vbtsub">vbtsub</a></code>, <code><a href="#topic+advbtinq">advbtinq</a></code>, <code><a href="#topic+advbtsub">advbtsub</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make vector binary tree:
colnamevbt &lt;- dl2vbt(chrvec2dl(colnames(datatest)))

#Visit by specific assignment:
vbtinq(colnamevbt, c(2, 3, 1, 1))

#Traversal of the second layers:
vbtinq(colnamevbt, c(2, -1, 1, 1))

#Invalid assignments in 1st and 3rd layers:
vbtinq(colnamevbt, c(4, 3, 7, 1))
</code></pre>

<hr>
<h2 id='VBTree-package'>
Vector Binary Tree to Make Your Data Management More Efficient
</h2><span id='topic+VBTree-package'></span><span id='topic+VBTree'></span>

<h3>Description</h3>

<p>Vector binary tree provides a new data structure, to
 make your data visiting and management more efficient. If the
 data has structured column names, it can read these names and
 factorize them through specific split pattern, then build the mappings
 within double list, vector binary tree, array and tensor mutually, through
 which the batched data processing is achievable easily. The methods of
 array and tensor are also applicable. Detailed methods are described in
 Chen Zhang et al. (2020) &lt;doi:10.35566/isdsa2019c8&gt;.
</p>


<h3>Details</h3>

<p>This package provide an efficient approach to manage data by structurizing the column names. A column name is generally seen as a character object, while if
it has a very organized pattern, such as &quot;*-*-*-*&quot; for example (each * mark presents a different condition), it must has a certain mapping relationship to a
specific tensor. This package uses two data structure: double list and vector binary tree, to implement the conversion between the character vector and tensor.
It affords various inquiry methods, which was mainly drived by vector binary tree, to extract the highly customizable subset from original data.
</p>


<h3>Author(s)</h3>

<p>Chen Zhang [aut, cre, cph] (0009-0007-7689-5030)
</p>
<p>Maintainer: Chen Zhang &lt;chen.zhang_06sept@foxmail.com&gt;
</p>


<h3>References</h3>

<p>Sedgewick, Robert &amp; Wayne, Kevin (2011). Algorithms, 4th Edition.. Addison-Wesley
</p>
<p>Prakash, P. K. S. &amp; Rao, Achyutuni Sri Krishna (2016). R Data Structures and Algorithms. Packt Publishing
</p>


<h3>See Also</h3>

<p><code><a href="tensorA.html#topic+to.tensor">to.tensor</a></code>, <code><a href="tensorA.html#topic+pos.tensor">pos.tensor</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#View the data to be visited:
summary(datatest)
colnames(datatest)

#Structurize colnames of data into vector binary tree:
dl &lt;- chrvec2dl(colnames(datatest))
vbt &lt;- dl2vbt(dl)
vbt

#Setting subset in different forms, for example the pattern
#"Strain-(900~1100)-(0.01, 1)-0.6" is desired:
subunregdl &lt;- list(c(1), c(1:5), c(2,4), c(1)) # undifined double list
subregdl &lt;- advbtinq(vbt, subunregdl) # regularized double list
subvbt &lt;- dl2vbt(subregdl) # sub vector binary tree
subts &lt;- vbt2ts(subvbt) # tensor
subarr &lt;- vbt2arr(subvbt) # array
subchrvec &lt;- as.vector(subarr) # character vector

#Visit the data through different methods:
datavisit(datatest, subunregdl) # by handmade double list
datavisit(datatest, subregdl) # by defined double list
datavisit(datatest, subvbt) # by vector binary tree
datavisit(datatest, subts) # by tensor
datavisit(datatest, subarr) # by array
datavisit(datatest, subchrvec) # by character vector

</code></pre>

<hr>
<h2 id='vbtsub'>Using vector to generate sub tree from vector binary tree</h2><span id='topic+vbtsub'></span>

<h3>Description</h3>

<p>Visit the vector binary tree and generate a sub tree from visited vector binary tree, through
specific assigment determined by the argument <code>inq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vbtsub(x, inq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vbtsub_+3A_x">x</code></td>
<td>
<p>The vector binary tree to be visited. Traversal is available by setting -1 in desired layer.</p>
</td></tr>
<tr><td><code id="vbtsub_+3A_inq">inq</code></td>
<td>
<p>An integer vector to determine the visiting location. The length of <code>inq</code> should be the same
as the layers of visited vector binary tree. If any assignment in specificed layer exceeds its intrinsic
length of visited vector binary tree layer, all elements will be returned in this layer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a sub tree from visited vector binary tree, according to the argument <code>inq</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vbtinq">vbtinq</a></code>, <code><a href="#topic+advbtinq">advbtinq</a></code>, <code><a href="#topic+advbtsub">advbtsub</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Make vector binary tree:
colnamevbt &lt;- dl2vbt(chrvec2dl(colnames(datatest)))

#Generating sub tree by specific assignment:
vbtsub(colnamevbt, c(2, 3, 1, 1))

#Generating sub tree with traversal in the second layers:
vbtsub(colnamevbt, c(2, -1, 1, 1))

#Generating sub tree with invalid assignments in 1st and 3rd layers:
vbtsub(colnamevbt, c(4, 3, 7, 1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
