<!DOCTYPE html><html><head><title>Help for package daiquiri</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {daiquiri}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggregate_data'><p>Aggregate source data</p></a></li>
<li><a href='#close_log'><p>Close any active log file</p></a></li>
<li><a href='#daiquiri_report'><p>Create a data quality report from a data frame</p></a></li>
<li><a href='#daiquiri-package'><p>daiquiri: Data Quality Reporting for Temporal Datasets</p></a></li>
<li><a href='#export_aggregated_data'><p>Export aggregated data</p></a></li>
<li><a href='#field_types'><p>Create field_types specification</p></a></li>
<li><a href='#field_types_available'><p>Types of data fields available for specification</p></a></li>
<li><a href='#initialise_log'><p>Initialise a log file</p></a></li>
<li><a href='#prepare_data'><p>Prepare source data</p></a></li>
<li><a href='#read_data'><p>Read delimited data for optimal use with daiquiri</p></a></li>
<li><a href='#report_data'><p>Generate report from existing objects</p></a></li>
<li><a href='#template_field_types'><p>Print a template field_types() specification to console</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Quality Reporting for Temporal Datasets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate reports that enable quick visual review of 
    temporal shifts in record-level data. Time series plots showing aggregated 
    values are automatically created for each data field (column) depending on its 
    contents (e.g. min/max/mean values for numeric data, no. of distinct 
    values for categorical data), as well as overviews for missing values, 
    non-conformant values, and duplicated rows. The resulting reports are shareable 
    and can contribute to forming a transparent record of the entire analysis process. 
    It is designed with Electronic Health Records in mind, but can be used for 
    any type of record-level temporal data (i.e. tabular data where each row represents 
    a single "event", one column contains the "event date", and other columns 
    contain any associated values for the event).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/daiquiri">https://github.com/ropensci/daiquiri</a>,
<a href="https://ropensci.github.io/daiquiri/">https://ropensci.github.io/daiquiri/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/daiquiri/issues">https://github.com/ropensci/daiquiri/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.12.8), readr (&ge; 2.0.0), ggplot2 (&ge; 3.1.0),
scales (&ge; 1.1.0), cowplot (&ge; 0.9.3), rmarkdown, reactable (&ge;
0.2.3), utils, stats, xfun (&ge; 0.15)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, testthat (&ge; 3.0.0), codemetar</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-18 12:57:09 UTC; pquan</td>
</tr>
<tr>
<td>Author:</td>
<td>T. Phuong Quan <a href="https://orcid.org/0000-0001-8566-1817"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jack Cregan [ctb],
  University of Oxford [cph],
  National Institute for Health Research (NIHR) [fnd],
  Brad Cannell [rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>T. Phuong Quan &lt;phuong.quan@ndm.ox.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-18 16:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggregate_data'>Aggregate source data</h2><span id='topic+aggregate_data'></span>

<h3>Description</h3>

<p>Aggregates a <code>daiquiri_source_data</code> object based on the <code><a href="#topic+field_types">field_types()</a></code> specified at load time.
Default time period for aggregation is a calendar day
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_data(source_data, aggregation_timeunit = "day", show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_data_+3A_source_data">source_data</code></td>
<td>
<p>A <code>daiquiri_source_data</code> object returned from
<code><a href="#topic+prepare_data">prepare_data()</a></code> function</p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_aggregation_timeunit">aggregation_timeunit</code></td>
<td>
<p>Unit of time to aggregate over. Specify one of
<code>"day"</code>, <code>"week"</code>, <code>"month"</code>, <code>"quarter"</code>, <code>"year"</code>. The <code>"week"</code> option is
Monday-based. Default = <code>"day"</code></p>
</td></tr>
<tr><td><code id="aggregate_data_+3A_show_progress">show_progress</code></td>
<td>
<p>Print progress to console. Default = <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>daiquiri_aggregated_data</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare_data">prepare_data()</a></code>, <code><a href="#topic+report_data">report_data()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load example data into a data.frame
raw_data &lt;- read_data(
  system.file("extdata", "example_prescriptions.csv", package = "daiquiri"),
  delim = ",",
  col_names = TRUE
)

# validate and prepare the data for aggregation
source_data &lt;- prepare_data(
  raw_data,
  field_types = field_types(
    PrescriptionID = ft_uniqueidentifier(),
    PrescriptionDate = ft_timepoint(),
    AdmissionDate = ft_datetime(includes_time = FALSE),
    Drug = ft_freetext(),
    Dose = ft_numeric(),
    DoseUnit = ft_categorical(),
    PatientID = ft_ignore(),
    Location = ft_categorical(aggregate_by_each_category = TRUE)
  ),
  override_column_names = FALSE,
  na = c("", "NULL")
)

# aggregate the data
aggregated_data &lt;- aggregate_data(
  source_data,
  aggregation_timeunit = "day"
)

aggregated_data


</code></pre>

<hr>
<h2 id='close_log'>Close any active log file</h2><span id='topic+close_log'></span>

<h3>Description</h3>

<p>Close any active log file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>close_log()
</code></pre>


<h3>Value</h3>

<p>If a log file was found, the path to the log file that was closed,
otherwise an empty string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>close_log()
</code></pre>

<hr>
<h2 id='daiquiri_report'>Create a data quality report from a data frame</h2><span id='topic+daiquiri_report'></span>

<h3>Description</h3>

<p>Accepts record-level data from a data frame, validates it against the
expected type of content of each column, generates a collection of time
series plots for visual inspection, and saves a report to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daiquiri_report(
  df,
  field_types,
  override_column_names = FALSE,
  na = c("", "NA", "NULL"),
  dataset_description = NULL,
  aggregation_timeunit = "day",
  report_title = "daiquiri data quality report",
  save_directory = ".",
  save_filename = NULL,
  show_progress = TRUE,
  log_directory = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daiquiri_report_+3A_df">df</code></td>
<td>
<p>A data frame. Rectangular data can be read from file using
<code><a href="#topic+read_data">read_data()</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="daiquiri_report_+3A_field_types">field_types</code></td>
<td>
<p><code><a href="#topic+field_types">field_types()</a></code> object specifying names and types of
fields (columns) in the supplied <code>df</code>. See also <a href="#topic+field_types_available">field_types_available</a>.</p>
</td></tr>
<tr><td><code id="daiquiri_report_+3A_override_column_names">override_column_names</code></td>
<td>
<p>If <code>FALSE</code>, column names in the supplied <code>df</code>
must match the names specified in <code>field_types</code> exactly. If <code>TRUE</code>, column
names in the supplied <code>df</code> will be replaced with the names specified in
<code>field_types</code>. The specification must therefore contain the columns in the
correct order. Default = <code>FALSE</code></p>
</td></tr>
<tr><td><code id="daiquiri_report_+3A_na">na</code></td>
<td>
<p>vector containing strings that should be interpreted as missing
values, Default = <code>c("","NA","NULL")</code>.</p>
</td></tr>
<tr><td><code id="daiquiri_report_+3A_dataset_description">dataset_description</code></td>
<td>
<p>Short description of the dataset being checked.
This will appear on the report. If blank, the name of the data frame object
will be used</p>
</td></tr>
<tr><td><code id="daiquiri_report_+3A_aggregation_timeunit">aggregation_timeunit</code></td>
<td>
<p>Unit of time to aggregate over. Specify one of
<code>"day"</code>, <code>"week"</code>, <code>"month"</code>, <code>"quarter"</code>, <code>"year"</code>. The <code>"week"</code> option is
Monday-based. Default = <code>"day"</code></p>
</td></tr>
<tr><td><code id="daiquiri_report_+3A_report_title">report_title</code></td>
<td>
<p>Title to appear on the report</p>
</td></tr>
<tr><td><code id="daiquiri_report_+3A_save_directory">save_directory</code></td>
<td>
<p>String specifying directory in which to save the
report. Default is current directory.</p>
</td></tr>
<tr><td><code id="daiquiri_report_+3A_save_filename">save_filename</code></td>
<td>
<p>String specifying filename for the report, excluding any
file extension. If no filename is supplied, one will be automatically
generated with the format <code>daiquiri_report_YYMMDD_HHMMSS</code>.</p>
</td></tr>
<tr><td><code id="daiquiri_report_+3A_show_progress">show_progress</code></td>
<td>
<p>Print progress to console. Default = <code>TRUE</code></p>
</td></tr>
<tr><td><code id="daiquiri_report_+3A_log_directory">log_directory</code></td>
<td>
<p>String specifying directory in which to save log file.
If no directory is supplied, progress is not logged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing information relating to the supplied parameters as
well as the resulting <code>daiquiri_source_data</code> and <code>daiquiri_aggregated_data</code>
objects.
</p>


<h3>Details</h3>

<p>In order for the package to detect any non-conformant
values in numeric or datetime fields, these should be present in the data
frame in their raw character format. Rectangular data from a text file will
automatically be read in as character type if you use the <code><a href="#topic+read_data">read_data()</a></code>
function. Data frame columns that are not of class character will still be
processed according to the <code>field_types</code> specified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data()</a></code>, <code><a href="#topic+field_types">field_types()</a></code>,
<code><a href="#topic+field_types_available">field_types_available()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load example data into a data.frame
raw_data &lt;- read_data(
  system.file("extdata", "example_prescriptions.csv", package = "daiquiri"),
  delim = ",",
  col_names = TRUE
)

# create a report in the current directory
daiq_obj &lt;- daiquiri_report(
  raw_data,
  field_types = field_types(
    PrescriptionID = ft_uniqueidentifier(),
    PrescriptionDate = ft_timepoint(),
    AdmissionDate = ft_datetime(includes_time = FALSE, na = "1800-01-01"),
    Drug = ft_freetext(),
    Dose = ft_numeric(),
    DoseUnit = ft_categorical(),
    PatientID = ft_ignore(),
    Location = ft_categorical(aggregate_by_each_category = TRUE)
  ),
  override_column_names = FALSE,
  na = c("", "NULL"),
  dataset_description = "Example data provided with package",
  aggregation_timeunit = "day",
  report_title = "daiquiri data quality report",
  save_directory = ".",
  save_filename = "example_data_report",
  show_progress = TRUE,
  log_directory = NULL
)



</code></pre>

<hr>
<h2 id='daiquiri-package'>daiquiri: Data Quality Reporting for Temporal Datasets</h2><span id='topic+daiquiri'></span><span id='topic+daiquiri-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Generate reports that enable quick visual review of temporal shifts in record-level data. Time series plots showing aggregated values are automatically created for each data field (column) depending on its contents (e.g. min/max/mean values for numeric data, no. of distinct values for categorical data), as well as overviews for missing values, non-conformant values, and duplicated rows. The resulting reports are shareable and can contribute to forming a transparent record of the entire analysis process. It is designed with Electronic Health Records in mind, but can be used for any type of record-level temporal data (i.e. tabular data where each row represents a single &quot;event&quot;, one column contains the &quot;event date&quot;, and other columns contain any associated values for the event).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: T. Phuong Quan <a href="mailto:phuong.quan@ndm.ox.ac.uk">phuong.quan@ndm.ox.ac.uk</a> (<a href="https://orcid.org/0000-0001-8566-1817">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Jack Cregan [contributor]
</p>
</li>
<li><p>  University of Oxford [copyright holder]
</p>
</li>
<li><p>  National Institute for Health Research (NIHR) [funder]
</p>
</li>
<li><p> Brad Cannell [reviewer]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ropensci/daiquiri">https://github.com/ropensci/daiquiri</a>
</p>
</li>
<li> <p><a href="https://ropensci.github.io/daiquiri/">https://ropensci.github.io/daiquiri/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/daiquiri/issues">https://github.com/ropensci/daiquiri/issues</a>
</p>
</li></ul>


<hr>
<h2 id='export_aggregated_data'>Export aggregated data</h2><span id='topic+export_aggregated_data'></span>

<h3>Description</h3>

<p>Export aggregated data to disk.  Creates a separate file for each aggregated
field in dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_aggregated_data(
  aggregated_data,
  save_directory,
  save_file_prefix = "",
  save_file_type = "csv"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_aggregated_data_+3A_aggregated_data">aggregated_data</code></td>
<td>
<p>A <code>daiquiri_aggregated_data</code> object</p>
</td></tr>
<tr><td><code id="export_aggregated_data_+3A_save_directory">save_directory</code></td>
<td>
<p>String. Full or relative path for save folder</p>
</td></tr>
<tr><td><code id="export_aggregated_data_+3A_save_file_prefix">save_file_prefix</code></td>
<td>
<p>String. Optional prefix for the exported filenames</p>
</td></tr>
<tr><td><code id="export_aggregated_data_+3A_save_file_type">save_file_type</code></td>
<td>
<p>String. Filetype extension supported by <code>readr</code>,
currently only csv allowed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(invisibly) The <code>daiquiri_aggregated_data</code> object that was passed in
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
raw_data &lt;- read_data(
  system.file("extdata", "example_prescriptions.csv", package = "daiquiri"),
  delim = ",",
  col_names = TRUE
)

source_data &lt;- prepare_data(
  raw_data,
  field_types = field_types(
    PrescriptionID = ft_uniqueidentifier(),
    PrescriptionDate = ft_timepoint(),
    AdmissionDate = ft_datetime(includes_time = FALSE),
    Drug = ft_freetext(),
    Dose = ft_numeric(),
    DoseUnit = ft_categorical(),
    PatientID = ft_ignore(),
    Location = ft_categorical(aggregate_by_each_category = TRUE)
  ),
  override_column_names = FALSE,
  na = c("", "NULL")
)

aggregated_data &lt;- aggregate_data(
  source_data,
  aggregation_timeunit = "day"
)

export_aggregated_data(
  aggregated_data,
  save_directory = ".",
  save_file_prefix = "ex_"
)




</code></pre>

<hr>
<h2 id='field_types'>Create field_types specification</h2><span id='topic+field_types'></span>

<h3>Description</h3>

<p>Specify the names and types of fields in the source data frame. This is
important because the data in each field will be aggregated in different
ways, depending on its <code>field_type</code>.  See <a href="#topic+field_types_available">field_types_available</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>field_types(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="field_types_+3A_...">...</code></td>
<td>
<p>names and types of fields (columns) in source data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field_types</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+field_types_available">field_types_available()</a></code>, <code><a href="#topic+template_field_types">template_field_types()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fts &lt;- field_types(
  PatientID = ft_uniqueidentifier(),
  TestID = ft_ignore(),
  TestDate = ft_timepoint(),
  TestName = ft_categorical(aggregate_by_each_category = FALSE),
  TestResult = ft_numeric(),
  ResultDate = ft_datetime(),
  ResultComment = ft_freetext(),
  Location = ft_categorical()
)

fts
</code></pre>

<hr>
<h2 id='field_types_available'>Types of data fields available for specification</h2><span id='topic+field_types_available'></span><span id='topic+ft_timepoint'></span><span id='topic+ft_uniqueidentifier'></span><span id='topic+ft_categorical'></span><span id='topic+ft_numeric'></span><span id='topic+ft_datetime'></span><span id='topic+ft_freetext'></span><span id='topic+ft_simple'></span><span id='topic+ft_strata'></span><span id='topic+ft_ignore'></span>

<h3>Description</h3>

<p>Each column in the source dataset must be assigned to a particular <code>ft_xx</code>
depending on the type of data that it contains. This is done through a
<code><a href="#topic+field_types">field_types()</a></code> specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ft_timepoint(includes_time = TRUE, format = "", na = NULL)

ft_uniqueidentifier(na = NULL)

ft_categorical(aggregate_by_each_category = FALSE, na = NULL)

ft_numeric(na = NULL)

ft_datetime(includes_time = TRUE, format = "", na = NULL)

ft_freetext(na = NULL)

ft_simple(na = NULL)

ft_strata(na = NULL)

ft_ignore()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="field_types_available_+3A_includes_time">includes_time</code></td>
<td>
<p>If <code>TRUE</code>, additional aggregated values will be
generated using the time portion (and if no time portion is present then
midnight will be assumed). If <code>FALSE</code>, aggregated values will ignore any
time portion. Default = <code>TRUE</code></p>
</td></tr>
<tr><td><code id="field_types_available_+3A_format">format</code></td>
<td>
<p>Where datetime values are not in the format <code>YYYY-MM-DD</code> or
<code style="white-space: pre;">&#8288;YYYY-MM-DD HH:MM:SS&#8288;</code>, an alternative format can be specified at the per
field level, using <code><a href="readr.html#topic+parse_datetime">readr::col_datetime()</a></code> format specifications, e.g.
<code>format = "%d/%m/%Y"</code>. When a format is supplied, it must match the
complete string.</p>
</td></tr>
<tr><td><code id="field_types_available_+3A_na">na</code></td>
<td>
<p>Column-specific vector of strings that should be interpreted as missing
values (in addition to those specified at dataset level)</p>
</td></tr>
<tr><td><code id="field_types_available_+3A_aggregate_by_each_category">aggregate_by_each_category</code></td>
<td>
<p>If <code>TRUE</code>, aggregated values will be
generated for each distinct subcategory as well as for the field overall.
If <code>FALSE</code>, aggregated values will only be generated for the field overall.
Default = <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field_type</code> object denoting the type of data in the column
</p>


<h3>Details</h3>

<p><code>ft_timepoint()</code> - identifies the data field which should
be used as the independent time variable. There should be one and only one
of these specified.
</p>
<p><code>ft_uniqueidentifier()</code> - identifies data fields which
contain a (usually computer-generated) identifier for an entity, e.g. a
patient. It does not need to be unique within the dataset.
</p>
<p><code>ft_categorical()</code> - identifies data fields which should
be treated as categorical.
</p>
<p><code>ft_numeric()</code> - identifies data fields which contain numeric values that
should be treated as continuous. Any values which contain non-numeric
characters (including grouping marks) will be classed as non-conformant
</p>
<p><code>ft_datetime()</code> - identifies data fields which contain date
values that should be treated as continuous.
</p>
<p><code>ft_freetext()</code> - identifies data fields which contain
free text values. Only presence/missingness will be evaluated.
</p>
<p><code>ft_simple()</code> - identifies data fields where you only
want presence/missingness to be evaluated (but which are not necessarily
free text).
</p>
<p><code>ft_strata()</code> - identifies a categorical data field which should
be used to stratify the rest of the data.
</p>
<p><code>ft_ignore()</code> - identifies data fields which should be
ignored.  These will not be loaded.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+field_types">field_types()</a></code>, <code><a href="#topic+template_field_types">template_field_types()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fts &lt;- field_types(
  PatientID = ft_uniqueidentifier(),
  TestID = ft_ignore(),
  TestDate = ft_timepoint(),
  TestName = ft_categorical(aggregate_by_each_category = FALSE),
  TestResult = ft_numeric(),
  ResultDate = ft_datetime(),
  ResultComment = ft_freetext(),
  Location = ft_categorical()
)

ft_simple()
</code></pre>

<hr>
<h2 id='initialise_log'>Initialise a log file</h2><span id='topic+initialise_log'></span>

<h3>Description</h3>

<p>Choose a directory in which to save the log file. If this is not called, no
log file is created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialise_log(log_directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialise_log_+3A_log_directory">log_directory</code></td>
<td>
<p>String containing directory to save log file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string containing the full path to the newly-created log
file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_name &lt;- initialise_log(".")

log_name

</code></pre>

<hr>
<h2 id='prepare_data'>Prepare source data</h2><span id='topic+prepare_data'></span>

<h3>Description</h3>

<p>Validate a data frame against a <code><a href="#topic+field_types">field_types()</a></code> specification, and prepare
for aggregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_data(
  df,
  field_types,
  override_column_names = FALSE,
  na = c("", "NA", "NULL"),
  dataset_description = NULL,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_data_+3A_df">df</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_field_types">field_types</code></td>
<td>
<p><code><a href="#topic+field_types">field_types()</a></code> object specifying names and types of
fields (columns) in the supplied <code>df</code>. See also <a href="#topic+field_types_available">field_types_available</a>.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_override_column_names">override_column_names</code></td>
<td>
<p>If <code>FALSE</code>, column names in the supplied <code>df</code>
must match the names specified in <code>field_types</code> exactly. If <code>TRUE</code>, column
names in the supplied <code>df</code> will be replaced with the names specified in
<code>field_types</code>. The specification must therefore contain the columns in the
correct order. Default = <code>FALSE</code></p>
</td></tr>
<tr><td><code id="prepare_data_+3A_na">na</code></td>
<td>
<p>vector containing strings that should be interpreted as missing
values. Default = <code>c("","NA","NULL")</code>. Additional column-specific values
can be specified in the <code><a href="#topic+field_types">field_types()</a></code> object</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_dataset_description">dataset_description</code></td>
<td>
<p>Short description of the dataset being checked.
This will appear on the report. If blank, the name of the data frame object
will be used</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_show_progress">show_progress</code></td>
<td>
<p>Print progress to console. Default = <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>daiquiri_source_data</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+field_types">field_types()</a></code>, <code><a href="#topic+field_types_available">field_types_available()</a></code>,
<code><a href="#topic+aggregate_data">aggregate_data()</a></code>, <code><a href="#topic+report_data">report_data()</a></code>,
<code><a href="#topic+daiquiri_report">daiquiri_report()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example data into a data.frame
raw_data &lt;- read_data(
  system.file("extdata", "example_prescriptions.csv", package = "daiquiri"),
  delim = ",",
  col_names = TRUE
)

# validate and prepare the data for aggregation
source_data &lt;- prepare_data(
  raw_data,
  field_types = field_types(
    PrescriptionID = ft_uniqueidentifier(),
    PrescriptionDate = ft_timepoint(),
    AdmissionDate = ft_datetime(includes_time = FALSE),
    Drug = ft_freetext(),
    Dose = ft_numeric(),
    DoseUnit = ft_categorical(),
    PatientID = ft_ignore(),
    Location = ft_categorical(aggregate_by_each_category = TRUE)
  ),
  override_column_names = FALSE,
  na = c("", "NULL"),
  dataset_description = "Example data provided with package"
)

source_data
</code></pre>

<hr>
<h2 id='read_data'>Read delimited data for optimal use with daiquiri</h2><span id='topic+read_data'></span>

<h3>Description</h3>

<p>Popular file readers such as <code>readr::read_delim()</code> perform datatype
conversion by default, which can interfere with daiquiri's ability to detect
non-conformant values. Use this function instead to ensure optimal
compatibility with daiquiri's features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_data(
  file,
  delim = NULL,
  col_names = TRUE,
  quote = "\"",
  trim_ws = TRUE,
  comment = "",
  skip = 0,
  n_max = Inf,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_data_+3A_file">file</code></td>
<td>
<p>A string containing path of file containing data to load, or a
URL starting <code style="white-space: pre;">&#8288;http://&#8288;</code>, <code style="white-space: pre;">&#8288;file://&#8288;</code>, etc. Compressed files with extension
<code>.gz</code>, <code>.bz2</code>, <code>.xz</code> and <code>.zip</code> are supported.</p>
</td></tr>
<tr><td><code id="read_data_+3A_delim">delim</code></td>
<td>
<p>Single character used to separate fields within a record. E.g.
<code>","</code> or <code>"\t"</code></p>
</td></tr>
<tr><td><code id="read_data_+3A_col_names">col_names</code></td>
<td>
<p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector of column
names. If <code>TRUE</code>, the first row of the input will be used as the column
names, and will not be included in the data frame. If <code>FALSE</code>, column names
will be generated automatically. Default = <code>TRUE</code></p>
</td></tr>
<tr><td><code id="read_data_+3A_quote">quote</code></td>
<td>
<p>Single character used to quote strings.</p>
</td></tr>
<tr><td><code id="read_data_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace be trimmed from each
field?</p>
</td></tr>
<tr><td><code id="read_data_+3A_comment">comment</code></td>
<td>
<p>A string used to identify comments. Any text after the comment
characters will be silently ignored</p>
</td></tr>
<tr><td><code id="read_data_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data. If <code>comment</code> is
supplied any commented lines are ignored after skipping</p>
</td></tr>
<tr><td><code id="read_data_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of lines to read.</p>
</td></tr>
<tr><td><code id="read_data_+3A_show_progress">show_progress</code></td>
<td>
<p>Display a progress bar? Default = <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is aimed at non-expert users of R, and operates as a restricted
implementation of <code><a href="readr.html#topic+read_delim">readr::read_delim()</a></code>. If you prefer to use <code>read_delim()</code>
directly, ensure you set the following parameters: <code>col_types = readr::cols(.default = "c")</code> and <code>na = character()</code>
</p>


<h3>Value</h3>

<p>A data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+field_types">field_types()</a></code>, <code><a href="#topic+field_types_available">field_types_available()</a></code>,
<code><a href="#topic+aggregate_data">aggregate_data()</a></code>, <code><a href="#topic+report_data">report_data()</a></code>,
<code><a href="#topic+daiquiri_report">daiquiri_report()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raw_data &lt;- read_data(
  system.file("extdata", "example_prescriptions.csv", package = "daiquiri"),
  delim = ",",
  col_names = TRUE
)

head(raw_data)
</code></pre>

<hr>
<h2 id='report_data'>Generate report from existing objects</h2><span id='topic+report_data'></span>

<h3>Description</h3>

<p>Generate report from previously-created <code>daiquiri_source_data</code> and
<code>daiquiri_aggregated_data</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report_data(
  source_data,
  aggregated_data,
  report_title = "daiquiri data quality report",
  save_directory = ".",
  save_filename = NULL,
  format = "html",
  show_progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report_data_+3A_source_data">source_data</code></td>
<td>
<p>A <code>daiquiri_source_data</code> object returned from
<code><a href="#topic+prepare_data">prepare_data()</a></code> function</p>
</td></tr>
<tr><td><code id="report_data_+3A_aggregated_data">aggregated_data</code></td>
<td>
<p>A <code>daiquiri_aggregated_data</code> object returned from
<code><a href="#topic+aggregate_data">aggregate_data()</a></code> function</p>
</td></tr>
<tr><td><code id="report_data_+3A_report_title">report_title</code></td>
<td>
<p>Title to appear on the report</p>
</td></tr>
<tr><td><code id="report_data_+3A_save_directory">save_directory</code></td>
<td>
<p>String specifying directory in which to save the
report. Default is current directory.</p>
</td></tr>
<tr><td><code id="report_data_+3A_save_filename">save_filename</code></td>
<td>
<p>String specifying filename for the report, excluding any
file extension. If no filename is supplied, one will be automatically
generated with the format <code>daiquiri_report_YYMMDD_HHMMSS</code>.</p>
</td></tr>
<tr><td><code id="report_data_+3A_format">format</code></td>
<td>
<p>File format of the report. Currently only <code>"html"</code> is supported</p>
</td></tr>
<tr><td><code id="report_data_+3A_show_progress">show_progress</code></td>
<td>
<p>Print progress to console. Default = <code>TRUE</code></p>
</td></tr>
<tr><td><code id="report_data_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to <code>rmarkdown::render()</code>. Cannot
include any of <code>input</code>, <code>output_dir</code>, <code>output_file</code>, <code>params</code>, <code>quiet</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the name and path of the saved report
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare_data">prepare_data()</a></code>, <code><a href="#topic+aggregate_data">aggregate_data()</a></code>,
<code><a href="#topic+daiquiri_report">daiquiri_report()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load example data into a data.frame
raw_data &lt;- read_data(
  system.file("extdata", "example_prescriptions.csv", package = "daiquiri"),
  delim = ",",
  col_names = TRUE
)

# validate and prepare the data for aggregation
source_data &lt;- prepare_data(
  raw_data,
  field_types = field_types(
    PrescriptionID = ft_uniqueidentifier(),
    PrescriptionDate = ft_timepoint(),
    AdmissionDate = ft_datetime(includes_time = FALSE),
    Drug = ft_freetext(),
    Dose = ft_numeric(),
    DoseUnit = ft_categorical(),
    PatientID = ft_ignore(),
    Location = ft_categorical(aggregate_by_each_category = TRUE)
  ),
  override_column_names = FALSE,
  na = c("", "NULL"),
  dataset_description = "Example data provided with package",
  show_progress = TRUE
)

# aggregate the data
aggregated_data &lt;- aggregate_data(
  source_data,
  aggregation_timeunit = "day",
  show_progress = TRUE
)

# save a report in the current directory using the previously-created objects
report_data(
  source_data,
  aggregated_data,
  report_title = "daiquiri data quality report",
  save_directory = ".",
  save_filename = "example_data_report",
  show_progress = TRUE
)



</code></pre>

<hr>
<h2 id='template_field_types'>Print a template field_types() specification to console</h2><span id='topic+template_field_types'></span>

<h3>Description</h3>

<p>Helper function to generate template code for a <code><a href="#topic+field_types">field_types()</a></code> specification,
based on the supplied data frame. All fields (columns) in the specification
will be defined using the <code>default_field_type</code>, and the console output can be
copied and edited before being used as input to <code><a href="#topic+daiquiri_report">daiquiri_report()</a></code>
or <code><a href="#topic+prepare_data">prepare_data()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>template_field_types(df, default_field_type = ft_ignore())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="template_field_types_+3A_df">df</code></td>
<td>
<p>data frame including the column names for the template
specification</p>
</td></tr>
<tr><td><code id="template_field_types_+3A_default_field_type">default_field_type</code></td>
<td>
<p><code>field_type</code> to be used for each column. Default =
<code><a href="#topic+ft_ignore">ft_ignore()</a></code>. See  <code><a href="#topic+field_types_available">field_types_available()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(invisibly) Character string containing the template code
</p>


<h3>See Also</h3>

<p><code><a href="#topic+field_types">field_types()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  col1 = rep("2022-01-01", 5),
  col2 = rep(1, 5),
  col3 = 1:5,
  col4 = rnorm(5)
)

template_field_types(df, default_field_type = ft_numeric())
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
