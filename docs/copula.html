<!DOCTYPE html><html><head><title>Help for package copula</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {copula}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#copula-package'><p>Multivariate Dependence Modeling with Copulas</p></a></li>
<li><a href='#.pairsCond'><p>Pairs Plot of a cu.u Object (Internal Use)</p></a></li>
<li><a href='#absdPsiMC'><p>Absolute Value of Generator Derivatives via Monte Carlo</p></a></li>
<li><a href='#acopula-class'><p>Class &quot;acopula&quot; of Archimedean Copula Families</p></a></li>
<li><a href='#acR'><p>Distribution of the Radial Part of an Archimedean Copula</p></a></li>
<li><a href='#allComp'><p>All Components of a (Inner or Outer) Nested Archimedean Copula</p></a></li>
<li><a href='#An'><p>Nonparametric Rank-based Estimators of the Pickands Dependence Function</p></a></li>
<li><a href='#archmCopula'><p>Construction of Archimedean Copula Class Object</p></a></li>
<li><a href='#archmCopula-class'><p>Class &quot;archmCopula&quot;</p></a></li>
<li><a href='#assocMeasures'><p>Dependence Measures for Bivariate Copulas</p></a></li>
<li><a href='#Bernoulli'><p>Compute Bernoulli Numbers</p></a></li>
<li><a href='#beta.Blomqvist'><p>Sample and Population Version of Blomqvist's Beta for Archimedean Copulas</p></a></li>
<li><a href='#cCopula'><p>Conditional Distributions and Their Inverses from Copulas</p></a></li>
<li><a href='#cloud2-methods'><p>Cloud Plot Methods ('cloud2') in Package 'copula'</p></a></li>
<li><a href='#coeffG'><p>Coefficients of Polynomial used for Gumbel Copula</p></a></li>
<li><a href='#contour-methods'><p>Methods for Contour Plots in Package 'copula'</p></a></li>
<li><a href='#contourplot2-methods'><p>Contour Plot  Methods 'contourplot2' in Package 'copula'</p></a></li>
<li><a href='#copFamilies'><p>Specific Archimedean Copula Families (&quot;acopula&quot; Objects)</p></a></li>
<li><a href='#Copula'><p>Density, Evaluation, and Random Number Generation for Copula Functions</p></a></li>
<li><a href='#copula-class'><p>Mother Classes &quot;Copula&quot;, etc of all Copulas in the Package</p></a></li>
<li><a href='#copula-internal'><p>Internal Copula Functions</p></a></li>
<li><a href='#corKendall'><p>(Fast) Computation of Pairwise Kendall's Taus</p></a></li>
<li><a href='#dDiag'><p>Density of the Diagonal of (Nested) Archimedean Copulas</p></a></li>
<li><a href='#describeCop'><p>Copula (Short) Description as String</p></a></li>
<li><a href='#dnacopula'><p>Density Evaluation for (Nested) Archimedean Copulas</p></a></li>
<li><a href='#ellipCopula'><p>Construction of Elliptical Copula Class Objects</p></a></li>
<li><a href='#ellipCopula-class'><p>Class &quot;ellipCopula&quot; of Elliptical Copulas</p></a></li>
<li><a href='#emde'><p>Minimum Distance Estimators for (Nested) Archimedean Copulas</p></a></li>
<li><a href='#emle'><p>Maximum Likelihood Estimators for (Nested) Archimedean Copulas</p></a></li>
<li><a href='#empCopula'><p>The Empirical Copula</p></a></li>
<li><a href='#empCopula-class'><p>Class &quot;empCopula&quot; of Empirical Copulas</p></a></li>
<li><a href='#enacopula'><p>Estimation Procedures for (Nested) Archimedean Copulas</p></a></li>
<li><a href='#estim.misc'><p>Various Estimators for (Nested) Archimedean Copulas</p></a></li>
<li><a href='#evCopula'><p>Construction of Extreme-Value Copula Objects</p></a></li>
<li><a href='#evCopula-class'><p>Classes Representing Extreme-Value Copulas</p></a></li>
<li><a href='#evTestA'><p>Bivariate Test of Extreme-Value Dependence Based on Pickands'</p>
Dependence Function</a></li>
<li><a href='#evTestC'><p>Large-sample Test of Multivariate Extreme-Value Dependence</p></a></li>
<li><a href='#evTestK'><p>Bivariate Test of Extreme-Value Dependence Based on Kendall's Distribution</p></a></li>
<li><a href='#exchEVTest'><p>Test of Exchangeability for Certain Bivariate Copulas</p></a></li>
<li><a href='#exchTest'><p>Test of Exchangeability for a Bivariate Copula</p></a></li>
<li><a href='#fgmCopula'><p>Construction of a fgmCopula Class Object</p></a></li>
<li><a href='#fgmCopula-class'><p>Class &quot;fgmCopula&quot; - Multivariate Multiparameter Farlie-Gumbel-Morgenstern Copulas</p></a></li>
<li><a href='#fhCopula'><p>Construction of Fréchet-Hoeffding Bound Copula Objects</p></a></li>
<li><a href='#fhCopula-class'><p>Class &quot;fhCopula&quot; of Fréchet-Hoeffding Bound Copulas</p></a></li>
<li><a href='#fitCopula'><p>Fitting Copulas to Data &ndash; Copula Parameter Estimation</p></a></li>
<li><a href='#fitCopula-class'><p>Classes of Fitted Multivariate Models: Copula, Mvdc</p></a></li>
<li><a href='#fitLambda'><p>Non-parametric Estimators of the Matrix of Tail-Dependence Coefficients</p></a></li>
<li><a href='#fitMvdc'><p>Estimation of Multivariate Models Defined via Copulas</p></a></li>
<li><a href='#fixParam'><p>Fix a Subset of a Copula Parameter Vector</p></a></li>
<li><a href='#gasoil'><p>Daily Crude Oil and Natural Gas Prices from 2003 to 2006</p></a></li>
<li><a href='#generator'><p>Generator Functions for Archimedean and Extreme-Value Copulas</p></a></li>
<li><a href='#getAcop'><p>Get &quot;acopula&quot; Family Object by Name</p></a></li>
<li><a href='#getIniParam'><p>Get Initial Parameter Estimate for Copula</p></a></li>
<li><a href='#getTheta'><p>Get the Parameter(s) of a Copula</p></a></li>
<li><a href='#ggraph-tools'><p>Computations for Graphical GOF Test via Pairwise Rosenblatt Transforms</p></a></li>
<li><a href='#gnacopula'><p>Goodness-of-fit Testing for (Nested) Archimedean Copulas</p></a></li>
<li><a href='#gofCopula'><p>Goodness-of-fit Tests for Copulas</p></a></li>
<li><a href='#gofEVCopula'><p>Goodness-of-fit Tests for Bivariate Extreme-Value Copulas</p></a></li>
<li><a href='#gofOtherTstat'><p>Various Goodness-of-fit Test Statistics</p></a></li>
<li><a href='#gofTstat'><p>Goodness-of-fit Test Statistics</p></a></li>
<li><a href='#htrafo'><p>GOF Testing Transformation of Hering and Hofert</p></a></li>
<li><a href='#indepCopula'><p>Construction of Independence Copula Objects</p></a></li>
<li><a href='#indepCopula-class'><p>Class &quot;indepCopula&quot;</p></a></li>
<li><a href='#indepTest'><p>Test Independence of Continuous Random Variables via Empirical Copula</p></a></li>
<li><a href='#initOpt'><p>Initial Interval or Value for Parameter Estimation of Archimedean</p>
Copulas</a></li>
<li><a href='#interval'><p>Construct Simple &quot;interval&quot; Object</p></a></li>
<li><a href='#interval-class'><p>Class &quot;interval&quot; of Simple Intervals</p></a></li>
<li><a href='#K'><p>Kendall Distribution Function for Archimedean Copulas</p></a></li>
<li><a href='#khoudrajiCopula'><p>Construction of copulas using Khoudraji's device</p></a></li>
<li><a href='#khoudrajiCopula-class'><p>Class <code>"khoudrajiCopula"</code> and its Subclasses</p></a></li>
<li><a href='#log1mexp'><p>Compute  f(a) = <code class="reqn">\mathrm{log}</code>(1 +/- <code class="reqn">\mathrm{exp}</code>(-a))</p>
Numerically Optimally</a></li>
<li><a href='#loss'><p>LOSS and ALAE Insurance Data</p></a></li>
<li><a href='#margCopula'><p>Marginal copula of a Copula With Specified Margins</p></a></li>
<li><a href='#math-fun'><p>Sinc, Zolotarev's, and Other Mathematical Utility Functions</p></a></li>
<li><a href='#matrix_tools'><p>Tools to Work with Matrices</p></a></li>
<li><a href='#mixCopula'><p>Create Mixture of Copulas</p></a></li>
<li><a href='#mixCopula-class'><p>Class <code>"mixCopula"</code> of Copula Mixtures</p></a></li>
<li><a href='#moCopula'><p>The Marshall-Olkin Copula</p></a></li>
<li><a href='#moCopula-class'><p>Class &quot;moCopula&quot; of Marshall-Olkin Copulas</p></a></li>
<li><a href='#multIndepTest'><p>Independence Test Among Continuous Random Vectors Based on the</p>
Empirical Copula Process</a></li>
<li><a href='#multSerialIndepTest'><p>Serial Independence Test for Multivariate Time Series via Empirical Copula</p></a></li>
<li><a href='#Mvdc'><p>Multivariate Distributions Constructed from Copulas</p></a></li>
<li><a href='#mvdc-class'><p>Class &quot;mvdc&quot;: Multivariate Distributions from Copulas</p></a></li>
<li><a href='#nacFrail.time'><p>Timing for Sampling Frailties of Nested Archimedean Copulas</p></a></li>
<li><a href='#nacopula-class'><p>Class &quot;nacopula&quot; of Nested Archimedean Copulas</p></a></li>
<li><a href='#nacPairthetas'><p>Pairwise Thetas of Nested Archimedean Copulas</p></a></li>
<li><a href='#nesdepth'><p>Nesting Depth of a Nested Archimedean Copula (&quot;nacopula&quot;)</p></a></li>
<li><a href='#onacopula'><p>Constructing (Outer) Nested Archimedean Copulas</p></a></li>
<li><a href='#opower'><p>Outer Power Transformation of Archimedean Copulas</p></a></li>
<li><a href='#pairs2'><p>Scatter-Plot Matrix ('pairs') for Copula Distributions with Nice Defaults</p></a></li>
<li><a href='#pairsRosenblatt'><p>Plots for Graphical GOF Test via Pairwise Rosenblatt Transforms</p></a></li>
<li><a href='#persp-methods'><p>Methods for Function &lsquo;persp&rsquo; in Package &lsquo;copula&rsquo;</p></a></li>
<li><a href='#plackettCopula'><p>Construction of a Plackett Copula</p></a></li>
<li><a href='#plackettCopula-class'><p>Class &quot;plackettCopula&quot; of Plackett Copulas</p></a></li>
<li><a href='#plot-methods'><p>Methods for 'plot' in Package 'copula'</p></a></li>
<li><a href='#pnacopula'><p>Evaluation of (Nested) Archimedean Copulas</p></a></li>
<li><a href='#pobs'><p>Pseudo-Observations</p></a></li>
<li><a href='#polylog'><p>Polylogarithm <code class="reqn">\mathrm{Li_s(z)}</code> and Debye Functions</p></a></li>
<li><a href='#polynEval'><p>Evaluate Polynomials</p></a></li>
<li><a href='#printNacopula'><p>Print Compact Overview of a Nested Archimedean Copula (&quot;nacopula&quot;)</p></a></li>
<li><a href='#prob'><p>Computing Probabilities of Hypercubes</p></a></li>
<li><a href='#qqplot2'><p>Q-Q Plot with Rugs and Pointwise Asymptotic Confidence Intervals</p></a></li>
<li><a href='#radSymTest'><p>Test of Exchangeability for a Bivariate Copula</p></a></li>
<li><a href='#rdj'><p>Daily Returns of Three Stocks in the Dow Jones</p></a></li>
<li><a href='#retstable'><p>Sampling Exponentially Tilted Stable Distributions</p></a></li>
<li><a href='#rF01FrankJoe'><p>Sample Univariate Distributions Involved in Nested Frank and Joe Copulas</p></a></li>
<li><a href='#rFFrankJoe'><p>Sampling Distribution F for Frank and Joe</p></a></li>
<li><a href='#rlog'><p>Sampling Logarithmic Distributions</p></a></li>
<li><a href='#rnacModel'><p>Random nacopula Model</p></a></li>
<li><a href='#rnacopula'><p>Sampling Nested Archimedean Copulas</p></a></li>
<li><a href='#rnchild'><p>Sampling Child 'nacopula's</p></a></li>
<li><a href='#rotCopula'><p>Construction and Class of Rotated aka Reflected Copulas</p></a></li>
<li><a href='#RSpobs'><p>Pseudo-Observations of Radial and Uniform Part of Elliptical and Archimedean Copulas</p></a></li>
<li><a href='#rstable1'><p>Random numbers from (Skew) Stable Distributions</p></a></li>
<li><a href='#safeUroot'><p>One-dimensional Root (Zero) Finding - Extra &quot;Safety&quot; for Convenience</p></a></li>
<li><a href='#serialIndepTest'><p>Serial Independence Test for Continuous Time Series Via Empirical Copula</p></a></li>
<li><a href='#setTheta'><p>Specify the Parameter(s) of a Copula</p></a></li>
<li><a href='#show-methods'><p>Methods for 'show()' in Package 'copula'</p></a></li>
<li><a href='#Sibuya'><p>Sibuya Distribution - Sampling and Probabilities</p></a></li>
<li><a href='#SMI.12'><p>SMI Data &ndash; 141 Days in Winter 2011/2012</p></a></li>
<li><a href='#splom2-methods'><p>Methods for Scatter Plot Matrix 'splom2' in Package 'copula'</p></a></li>
<li><a href='#Stirling'><p>Eulerian and Stirling Numbers of First and Second Kind</p></a></li>
<li><a href='#tauAMH'><p>Ali-Mikhail-Haq (&quot;AMH&quot;)'s and Joe's Kendall's Tau</p></a></li>
<li><a href='#uranium'><p>Uranium Exploration Dataset of Cook &amp; Johnson (1986)</p></a></li>
<li><a href='#varianceReduction'><p>Variance-Reduction Methods</p></a></li>
<li><a href='#wireframe2-methods'><p>Perspective Plots - 'wireframe2' in Package 'copula'</p></a></li>
<li><a href='#xvCopula'><p>Model (copula) selection based on <code>k</code>-fold cross-validation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1-3</td>
</tr>
<tr>
<td>VersionNote:</td>
<td>Last CRAN: 1.1-2 on 2023-01-20</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Dependence with Copulas</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, methods, stats4, Matrix (&ge; 1.5-0), lattice,
colorspace, gsl, ADGofTest, stabledist (&ge; 0.6-4), mvtnorm,
pcaPP, pspline, numDeriv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, KernSmooth, sfsmisc, scatterplot3d, Rmpfr, bbmle,
knitr, rmarkdown, abind, crop, gridExtra, lcopula, mev,
mvnormtest, parallel, partitions, polynom, qrng, randtoolbox,
rugarch, Runuran, tseries, VGAM, VineCopula, zoo</td>
</tr>
<tr>
<td>SuggestsNote:</td>
<td>packages {abind, ..., zoo} (last lines above) are only
used in vignettes, demos and a few tests.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Enhances:</td>
<td>nor1mix, copulaData</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>pdfcrop (part of TexLive) is required to rebuild
the vignettes.</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes (S4) of commonly used elliptical, Archimedean,
 extreme-value and other copula families, as well as their rotations,
 mixtures and asymmetrizations. Nested Archimedean copulas, related
 tools and special functions. Methods for density, distribution, random
 number generation, bivariate dependence measures, Rosenblatt transform,
 Kendall distribution function, perspective and contour plots. Fitting of
 copula models with potentially partly fixed parameters, including
 standard errors. Serial independence tests, copula specification tests
 (independence, exchangeability, radial symmetry, extreme-value
 dependence, goodness-of-fit) and model selection based on
 cross-validation. Empirical copula, smoothed versions, and
 non-parametric estimators of the Pickands dependence function.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a> | file LICENCE</td>
</tr>
<tr>
<td>Collate:</td>
<td>AllClass.R Classes.R AllGeneric.R Auxiliaries.R aux-acopula.R
asymCopula.R mixCopula.R rotCopula.R Copula.R special-func.R
amhCopula.R claytonCopula.R frankCopula.R cop_objects.R
nacopula.R dC-dc.R amhExpr.R An.R archmCopula.R cCopula.R
claytonExpr.R ellipCopula.R empCopula.R empPsi.R acR.R
estimation.R evCopula.R evTests.R exchTests.R fgmCopula.R
fitCopula.R fitLambda.R fitMvdc.R fixedPar.R frankExpr.R
galambosCopula.R galambosExpr-math.R galambosExpr.R
ggraph-tools.R pairsRosenblatt.R prob.R gofTrafos.R
gofEVTests.R gofCopula.R graphics.R gumbelCopula.R gumbelExpr.R
huslerReissCopula.R huslerReissExpr.R indepCopula.R fhCopula.R
lowfhCopula.R upfhCopula.R indepTests.R joeCopula.R K.R
logseries.R mvdc.R margCopula.R matrix_tools.R normalCopula.R
obs.R opower.R plackettCopula.R plackettExpr.R moCopula.R
rstable1.R safeUroot.R schlatherCopula.R stable.R timing.R
tCopula.R tawnCopula.R tawnExpr.R tevCopula.R
varianceReduction.R wrapper.R xvCopula.R zzz.R</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://copula.r-forge.r-project.org/">https://copula.r-forge.r-project.org/</a>,
<a href="https://r-forge.r-project.org/projects/copula/">https://r-forge.r-project.org/projects/copula/</a>,
<a href="https://CRAN.r-project.org/package=copula">https://CRAN.r-project.org/package=copula</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://r-forge.r-project.org/tracker/?func=add&amp;group_id=2140&amp;atid=5417">https://r-forge.r-project.org/tracker/?func=add&amp;group_id=2140&amp;atid=5417</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 15:36:21 UTC; maechler</td>
</tr>
<tr>
<td>Author:</td>
<td>Marius Hofert <a href="https://orcid.org/0000-0001-8009-4665"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Ivan Kojadinovic <a href="https://orcid.org/0000-0002-2903-1543"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jun Yan <a href="https://orcid.org/0000-0003-4401-7296"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Johanna G. Nešlehová
    <a href="https://orcid.org/0000-0001-9634-4796"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (evTestK()),
  Rebecca Morger [ctb] (fitCopula.ml(): code for free mixCopula weight
    parameters)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-07 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='copula-package'>Multivariate Dependence Modeling with Copulas</h2><span id='topic+copula-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">copula</span> package provides (S4) classes of commonly used
elliptical, (nested) Archimedean, extreme value and other copula families;
methods for density, distribution, random number generation, and plots.
</p>
<p>Fitting copula models and goodness-of-fit tests.
Independence and serial (univariate and multivariate) independence tests,
and other copula related tests.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> copula</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1-3</td>
</tr>
<tr>
 <td style="text-align: left;">
VersionNote: </td><td style="text-align: left;"> Last CRAN: 1.1-2 on 2023-01-20</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-12-07</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Multivariate Dependence with Copulas</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Marius", "Hofert", role = "aut", email = "marius.hofert@uwaterloo.ca",       comment = c(ORCID = "0000-0001-8009-4665"))
	   , person("Ivan", "Kojadinovic", role = "aut", email = "ivan.kojadinovic@univ-pau.fr",  comment = c(ORCID = "0000-0002-2903-1543"))
	   , person("Martin","Maechler", role=c("aut","cre"), email="maechler@stat.math.ethz.ch", comment = c(ORCID = "0000-0002-8685-9910"))
	   , person("Jun", "Yan", role = "aut", email = "jun.yan@uconn.edu",                      comment = c(ORCID = "0000-0003-4401-7296"))
	   , person(c("Johanna", "G."), "Nešlehová", role = "ctb", comment = c("evTestK()", ORCID = "0000-0001-9634-4796"))
	   , person("Rebecca", "Morger", role = "ctb", comment = "fitCopula.ml(): code for free mixCopula weight parameters")
	   )</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> stats, graphics, methods, stats4, Matrix (&gt;= 1.5-0), lattice, colorspace,
gsl, ADGofTest, stabledist (&gt;= 0.6-4), mvtnorm, pcaPP, pspline, numDeriv</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> MASS, KernSmooth, sfsmisc, scatterplot3d, Rmpfr, bbmle, knitr, rmarkdown,
abind, crop, gridExtra, lcopula, mev, mvnormtest, parallel, partitions,
polynom, qrng, randtoolbox, rugarch, Runuran, tseries, VGAM, VineCopula, zoo</td>
</tr>
<tr>
 <td style="text-align: left;">
SuggestsNote: </td><td style="text-align: left;"> packages {abind, ..., zoo} (last lines above) are only used
in vignettes, demos and a few tests.</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Enhances: </td><td style="text-align: left;"> nor1mix, copulaData</td>
</tr>
<tr>
 <td style="text-align: left;">
SystemRequirements: </td><td style="text-align: left;"> pdfcrop (part of TexLive) is required to rebuild the vignettes.</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Classes (S4) of commonly used elliptical, Archimedean,
 extreme-value and other copula families, as well as their rotations,
 mixtures and asymmetrizations. Nested Archimedean copulas, related
 tools and special functions. Methods for density, distribution, random
 number generation, bivariate dependence measures, Rosenblatt transform,
 Kendall distribution function, perspective and contour plots. Fitting of
 copula models with potentially partly fixed parameters, including
 standard errors. Serial independence tests, copula specification tests
 (independence, exchangeability, radial symmetry, extreme-value
 dependence, goodness-of-fit) and model selection based on
 cross-validation. Empirical copula, smoothed versions, and
 non-parametric estimators of the Pickands dependence function.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 3) | file LICENCE</td>
</tr>
<tr>
 <td style="text-align: left;">
Collate: </td><td style="text-align: left;"> AllClass.R Classes.R AllGeneric.R
Auxiliaries.R aux-acopula.R
asymCopula.R mixCopula.R rotCopula.R Copula.R
special-func.R amhCopula.R claytonCopula.R frankCopula.R cop_objects.R
nacopula.R dC-dc.R
amhExpr.R An.R
archmCopula.R cCopula.R
claytonExpr.R ellipCopula.R empCopula.R empPsi.R acR.R
estimation.R evCopula.R evTests.R
exchTests.R fgmCopula.R fitCopula.R fitLambda.R fitMvdc.R
fixedPar.R
frankExpr.R galambosCopula.R galambosExpr-math.R galambosExpr.R
ggraph-tools.R pairsRosenblatt.R prob.R
gofTrafos.R gofEVTests.R gofCopula.R
graphics.R gumbelCopula.R gumbelExpr.R
huslerReissCopula.R huslerReissExpr.R indepCopula.R
fhCopula.R lowfhCopula.R upfhCopula.R
indepTests.R joeCopula.R K.R logseries.R mvdc.R
margCopula.R
matrix_tools.R normalCopula.R
obs.R
opower.R plackettCopula.R plackettExpr.R moCopula.R
rstable1.R safeUroot.R
schlatherCopula.R stable.R
timing.R
tCopula.R tawnCopula.R tawnExpr.R tevCopula.R
varianceReduction.R
wrapper.R xvCopula.R zzz.R</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://copula.r-forge.r-project.org/, https://r-forge.r-project.org/projects/copula/,
https://CRAN.r-project.org/package=copula</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://r-forge.r-project.org/tracker/?func=add&amp;group_id=2140&amp;atid=5417</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Marius Hofert [aut] (&lt;https://orcid.org/0000-0001-8009-4665&gt;),
  Ivan Kojadinovic [aut] (&lt;https://orcid.org/0000-0002-2903-1543&gt;),
  Martin Maechler [aut, cre] (&lt;https://orcid.org/0000-0002-8685-9910&gt;),
  Jun Yan [aut] (&lt;https://orcid.org/0000-0003-4401-7296&gt;),
  Johanna G. Nešlehová [ctb] (evTestK(),
    &lt;https://orcid.org/0000-0001-9634-4796&gt;),
  Rebecca Morger [ctb] (fitCopula.ml(): code for free mixCopula weight
    parameters)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
.pairsCond              Pairs Plot of a cu.u Object (Internal Use)
A..Z                    Sinc, Zolotarev's, and Other Mathematical
                        Utility Functions
An                      Nonparametric Rank-based Estimators of the
                        Pickands Dependence Function
Bernoulli               Compute Bernoulli Numbers
Copula                  Density, Evaluation, and Random Number
                        Generation for Copula Functions
Eulerian                Eulerian and Stirling Numbers of First and
                        Second Kind
K                       Kendall Distribution Function for Archimedean
                        Copulas
Mvdc                    Multivariate Distributions Constructed from
                        Copulas
RSpobs                  Pseudo-Observations of Radial and Uniform Part
                        of Elliptical and Archimedean Copulas
SMI.12                  SMI Data - 141 Days in Winter 2011/2012
Sibuya                  Sibuya Distribution - Sampling and
                        Probabilities
absdPsiMC               Absolute Value of Generator Derivatives via
                        Monte Carlo
acopula-class           Class "acopula" of Archimedean Copula Families
acopula-families        Specific Archimedean Copula Families ("acopula"
                        Objects)
allComp                 All Components of a (Inner or Outer) Nested
                        Archimedean Copula
archmCopula             Construction of Archimedean Copula Class Object
archmCopula-class       Class "archmCopula"
beta.                   Sample and Population Version of Blomqvist's
                        Beta for Archimedean Copulas
cCopula                 Conditional Distributions and Their Inverses
                        from Copulas
cloud2-methods          Cloud Plot Methods ('cloud2') in Package
                        'copula'
coeffG                  Coefficients of Polynomial used for Gumbel
                        Copula
contour-methods         Methods for Contour Plots in Package 'copula'
contourplot2-methods    Contour Plot Methods 'contourplot2' in Package
                        'copula'
copula-class            Mother Classes "Copula", etc of all Copulas in
                        the Package
copula-package          Multivariate Dependence Modeling with Copulas
corKendall              (Fast) Computation of Pairwise Kendall's Taus
dDiag                   Density of the Diagonal of (Nested) Archimedean
                        Copulas
describeCop             Copula (Short) Description as String
dnacopula               Density Evaluation for (Nested) Archimedean
                        Copulas
ebeta                   Various Estimators for (Nested) Archimedean
                        Copulas
ellipCopula             Construction of Elliptical Copula Class Objects
ellipCopula-class       Class "ellipCopula" of Elliptical Copulas
emde                    Minimum Distance Estimators for (Nested)
                        Archimedean Copulas
emle                    Maximum Likelihood Estimators for (Nested)
                        Archimedean Copulas
empCopula               The Empirical Copula
empCopula-class         Class "empCopula" of Empirical Copulas
enacopula               Estimation Procedures for (Nested) Archimedean
                        Copulas
evCopula                Construction of Extreme-Value Copula Objects
evCopula-class          Classes Representing Extreme-Value Copulas
evTestA                 Bivariate Test of Extreme-Value Dependence
                        Based on Pickands' Dependence Function
evTestC                 Large-sample Test of Multivariate Extreme-Value
                        Dependence
evTestK                 Bivariate Test of Extreme-Value Dependence
                        Based on Kendall's Distribution
exchEVTest              Test of Exchangeability for Certain Bivariate
                        Copulas
exchTest                Test of Exchangeability for a Bivariate Copula
fgmCopula               Construction of a fgmCopula Class Object
fgmCopula-class         Class "fgmCopula" - Multivariate Multiparameter
                        Farlie-Gumbel-Morgenstern Copulas
fhCopula                Construction of Fréchet-Hoeffding Bound Copula
                        Objects
fhCopula-class          Class "fhCopula" of Fréchet-Hoeffding Bound
                        Copulas
fitCopula               Fitting Copulas to Data - Copula Parameter
                        Estimation
fitCopula-class         Classes of Fitted Multivariate Models: Copula,
                        Mvdc
fitLambda               Non-parametric Estimators of the Matrix of
                        Tail-Dependence Coefficients
fitMvdc                 Estimation of Multivariate Models Defined via
                        Copulas
fixParam                Fix a Subset of a Copula Parameter Vector
gasoil                  Daily Crude Oil and Natural Gas Prices from
                        2003 to 2006
getAcop                 Get "acopula" Family Object by Name
getIniParam             Get Initial Parameter Estimate for Copula
getTheta                Get the Parameter(s) of a Copula
gnacopula               Goodness-of-fit Testing for (Nested)
                        Archimedean Copulas
gofBTstat               Various Goodness-of-fit Test Statistics
gofCopula               Goodness-of-fit Tests for Copulas
gofEVCopula             Goodness-of-fit Tests for Bivariate
                        Extreme-Value Copulas
gofTstat                Goodness-of-fit Test Statistics
htrafo                  GOF Testing Transformation of Hering and Hofert
iPsi                    Generator Functions for Archimedean and
                        Extreme-Value Copulas
indepCopula             Construction of Independence Copula Objects
indepCopula-class       Class "indepCopula"
indepTest               Test Independence of Continuous Random
                        Variables via Empirical Copula
initOpt                 Initial Interval or Value for Parameter
                        Estimation of Archimedean Copulas
interval                Construct Simple "interval" Object
interval-class          Class "interval" of Simple Intervals
khoudrajiCopula         Construction of copulas using Khoudraji's
                        device
khoudrajiCopula-class   Class '"khoudrajiCopula"' and its Subclasses
log1mexp                Compute f(a) = log(1 +/- exp(-a)) Numerically
                        Optimally
loss                    LOSS and ALAE Insurance Data
margCopula              Marginal copula of a Copula With Specified
                        Margins
mixCopula               Create Mixture of Copulas
mixCopula-class         Class '"mixCopula"' of Copula Mixtures
moCopula                The Marshall-Olkin Copula
moCopula-class          Class "moCopula" of Marshall-Olkin Copulas
multIndepTest           Independence Test Among Continuous Random
                        Vectors Based on the Empirical Copula Process
multSerialIndepTest     Serial Independence Test for Multivariate Time
                        Series via Empirical Copula
mvdc-class              Class "mvdc": Multivariate Distributions from
                        Copulas
nacFrail.time           Timing for Sampling Frailties of Nested
                        Archimedean Copulas
nacPairthetas           Pairwise Thetas of Nested Archimedean Copulas
nacopula-class          Class "nacopula" of Nested Archimedean Copulas
nesdepth                Nesting Depth of a Nested Archimedean Copula
                        ("nacopula")
onacopula               Constructing (Outer) Nested Archimedean Copulas
opower                  Outer Power Transformation of Archimedean
                        Copulas
p2P                     Tools to Work with Matrices
pacR                    Distribution of the Radial Part of an
                        Archimedean Copula
pairs2                  Scatter-Plot Matrix ('pairs') for Copula
                        Distributions with Nice Defaults
pairsRosenblatt         Plots for Graphical GOF Test via Pairwise
                        Rosenblatt Transforms
pairwiseCcop            Computations for Graphical GOF Test via
                        Pairwise Rosenblatt Transforms
persp-methods           Methods for Function 'persp' in Package
                        'copula'
plackettCopula          Construction of a Plackett Copula
plackettCopula-class    Class "plackettCopula" of Plackett Copulas
plot-methods            Methods for 'plot' in Package 'copula'
pnacopula               Evaluation of (Nested) Archimedean Copulas
pobs                    Pseudo-Observations
polylog                 Polylogarithm Li_s(z) and Debye Functions
polynEval               Evaluate Polynomials
printNacopula           Print Compact Overview of a Nested Archimedean
                        Copula ("nacopula")
prob                    Computing Probabilities of Hypercubes
qqplot2                 Q-Q Plot with Rugs and Pointwise Asymptotic
                        Confidence Intervals
rAntitheticVariates     Variance-Reduction Methods
rF01Frank               Sample Univariate Distributions Involved in
                        Nested Frank and Joe Copulas
rFFrank                 Sampling Distribution F for Frank and Joe
radSymTest              Test of Exchangeability for a Bivariate Copula
rdj                     Daily Returns of Three Stocks in the Dow Jones
retstable               Sampling Exponentially Tilted Stable
                        Distributions
rlog                    Sampling Logarithmic Distributions
rnacModel               Random nacopula Model
rnacopula               Sampling Nested Archimedean Copulas
rnchild                 Sampling Child 'nacopula's
rotCopula               Construction and Class of Rotated aka Reflected
                        Copulas
rstable1                Random numbers from (Skew) Stable Distributions
safeUroot               One-dimensional Root (Zero) Finding - Extra
                        "Safety" for Convenience
serialIndepTest         Serial Independence Test for Continuous Time
                        Series Via Empirical Copula
setTheta                Specify the Parameter(s) of a Copula
show-methods            Methods for 'show()' in Package 'copula'
splom2-methods          Methods for Scatter Plot Matrix 'splom2' in
                        Package 'copula'
tau                     Dependence Measures for Bivariate Copulas
tauAMH                  Ali-Mikhail-Haq ("AMH")'s and Joe's Kendall's
                        Tau
uranium                 Uranium Exploration Dataset of Cook &amp; Johnson
                        (1986)
wireframe2-methods      Perspective Plots - 'wireframe2' in Package
                        'copula'
xvCopula                Model (copula) selection based on 'k'-fold
                        cross-validation
</pre>

<p>Further information is available in the following vignettes:<br /><br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>AC_Liouville</code> </td><td style="text-align: left;"> Archimedean Liouville Copulas (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>AR_Clayton</code> </td><td style="text-align: left;"> MLE and Quantile Evaluation for a Clayton AR(1) Model with Student Marginals (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>GIG</code> </td><td style="text-align: left;"> Generalized Inverse Gaussian Archimedean Copulas (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>HAXC</code> </td><td style="text-align: left;"> Hierarchical Archimax Copulas (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>NALC</code> </td><td style="text-align: left;"> Nested Archimedean Lévy Copulas (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>copula_GARCH</code> </td><td style="text-align: left;"> The Copula GARCH Model (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>dNAC</code> </td><td style="text-align: left;"> Densities of Two-Level Nested Archimedean Copulas (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>empiricial_copulas</code> </td><td style="text-align: left;"> Exploring Empirical Copulas (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>logL_visualization</code> </td><td style="text-align: left;"> Log-Likelihood Visualization for Archimedean Copulas (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>qrng</code> </td><td style="text-align: left;"> Quasi-Random Numbers for Copula Models (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>wild_animals</code> </td><td style="text-align: left;"> Wild Animals: Examples of Nonstandard Copulas (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Frank-Rmpfr</code> </td><td style="text-align: left;"> Numerically stable Frank Copulas via Multiprecision (Rmpfr) (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>nacopula-pkg</code> </td><td style="text-align: left;"> Nested Archimedean Copulas Meet R (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rhoAMH-dilog</code> </td><td style="text-align: left;"> Beautiful Spearman's Rho for AMH Copula (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <span class="pkg">copula</span> package provides
</p>

<ul>
<li><p> Classes (S4) of commonly used copulas including
elliptical (normal and t; <code><a href="#topic+ellipCopula-class">ellipCopula</a></code>),
Archimedean (Clayton, Gumbel, Frank, Joe, and Ali-Mikhail-Haq; ;
<code><a href="#topic+archmCopula-class">archmCopula</a></code> and <code><a href="#topic+acopula-class">acopula</a></code>),
extreme value (Gumbel, Husler-Reiss, Galambos, Tawn, and t-EV; <code><a href="#topic+evCopula-class">evCopula</a></code>),
and other families (Plackett and Farlie-Gumbel-Morgenstern).
</p>
</li>
<li><p> Methods for density, distribution, random number generation
(<code><a href="#topic+dCopula">dCopula</a></code>, <code><a href="#topic+pCopula">pCopula</a></code> and <code><a href="#topic+rCopula">rCopula</a></code>);
bivariate dependence measures (<code><a href="#topic+rho">rho</a></code>, <code><a href="#topic+tau">tau</a></code>,
etc), perspective and contour plots.
</p>
</li>
<li><p> Functions (and methods) for fitting copula models including
variance estimates (<code><a href="#topic+fitCopula">fitCopula</a></code>).
</p>
</li>
<li><p> Independence tests among random variables and vectors.
</p>
</li>
<li><p> Serial independence tests for univariate and multivariate
continuous time series.
</p>
</li>
<li><p> Goodness-of-fit tests for copulas based on multipliers, and
the parametric bootstrap, with several transformation options.
</p>
</li>
<li><p> Bivariate and multivariate tests of extreme-value dependence.
</p>
</li>
<li><p> Bivariate tests of exchangeability.
</p>
</li></ul>

<p>Now with former package <span class="pkg">nacopula</span> for working with nested Archimedean copulas.
Specifically,
</p>

<ul>
<li><p> it provides procedures for computing function values and cube
volumes (<code><a href="#topic+prob">prob</a></code>),
</p>
</li>
<li><p> characteristics such as Kendall's tau and tail dependence
coefficients (via family objects, e.g.,
<code><a href="#topic+acopula-families">copGumbel</a></code>),
</p>
</li>
<li><p> efficient sampling algorithms (<code><a href="#topic+rnacopula">rnacopula</a></code>),
</p>
</li>
<li><p> various estimators and goodness-of-fit tests.
</p>
</li>
<li><p> The package also contains related univariate distributions and special functions
such as the Sibuya distribution (<code><a href="#topic+Sibuya">Sibuya</a></code>), the
polylogarithm (<code><a href="#topic+polylog">polylog</a></code>), Stirling and Eulerian numbers
(<code><a href="#topic+Eulerian">Eulerian</a></code>).
</p>
</li></ul>

<p>Further information is available in the following <a href="utils.html#topic+vignettes">vignettes</a>:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>nacopula-pkg</code> </td><td style="text-align: left;"> Nested Archimedean Copulas Meet R (<a href="../doc/nacopula-pkg.pdf">../doc/nacopula-pkg.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Frank-Rmpfr</code>  </td><td style="text-align: left;"> Numerically Stable Frank via Multiprecision in R (<a href="../doc/Frank-Rmpfr">../doc/Frank-Rmpfr</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>For a list of exported functions, use <code>help(package = "copula")</code>.
</p>


<h3>References</h3>

<p>Yan, J. (2007)
Enjoy the Joy of Copulas: With a Package <span class="pkg">copula</span>.
<em>Journal of Statistical Software</em> <b>21</b>(4), 1&ndash;21.
<a href="https://www.jstatsoft.org/v21/i04/">https://www.jstatsoft.org/v21/i04/</a>.
</p>
<p>Kojadinovic, I. and Yan, J. (2010).
Modeling Multivariate Distributions with Continuous Margins Using the
copula R Package.
<em>Journal of Statistical Software</em> <b>34</b>(9), 1&ndash;20.
<a href="https://www.jstatsoft.org/v34/i09/">https://www.jstatsoft.org/v34/i09/</a>.
</p>
<p>Hofert, M. and Mächler, M. (2011),
Nested Archimedean Copulas Meet R: The nacopula Package.,
<em>Journal of Statistical Software</em> <b>39</b>(9), 1&ndash;20.
<a href="https://www.jstatsoft.org/v39/i09/">https://www.jstatsoft.org/v39/i09/</a>.
</p>
<p>Nelsen, R. B. (2006)
<em>An introduction to Copulas</em>. Springer, New York.
</p>


<h3>See Also</h3>

<p>The following CRAN packages currently use (&lsquo;depend on&rsquo;) <span class="pkg">copula</span>:
<a href="https://CRAN.R-project.org/package=CoClust"><span class="pkg">CoClust</span></a>, <a href="https://CRAN.R-project.org/package=copulaedas"><span class="pkg">copulaedas</span></a>, <a href="https://CRAN.R-project.org/package=Depela"><span class="pkg">Depela</span></a>,
<a href="https://CRAN.R-project.org/package=HAC"><span class="pkg">HAC</span></a>, <a href="https://CRAN.R-project.org/package=ipptoolbox"><span class="pkg">ipptoolbox</span></a>, <a href="https://CRAN.R-project.org/package=vines"><span class="pkg">vines</span></a>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some of the more important functions (and their examples) are

example(fitCopula)## fitting Copulas
example(fitMvdc)  ## fitting multivariate distributions via Copulas
example(nacopula) ## nested Archimedean Copulas

## Independence Tests:  These also draw a 'Dependogram':
example(indepTest)       ## Testing for Independence
example(serialIndepTest) ## Testing for Serial Independence

</code></pre>

<hr>
<h2 id='.pairsCond'>Pairs Plot of a cu.u Object (Internal Use)</h2><span id='topic+.pairsCond'></span>

<h3>Description</h3>

<p><code>.pairsCond()</code> is an internal function for plotting the pairwise
Rosenblatt transforms, i.e., the pairwise conditional distributions,
as returned by <code><a href="#topic+pairwiseCcop">pairwiseCcop</a>()</code>, via the principal function
<code><a href="#topic+pairsRosenblatt">pairsRosenblatt</a>()</code>.
</p>
<p>The intention is that <code><a href="#topic+pairsRosenblatt">pairsRosenblatt</a>()</code> be called,
rather than this auxiliary function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pairsCond(gcu.u, panel = points, colList,
     col = par("col"), bg = par("bg"), labels, ...,
     text.panel = textPanel, label.pos = 0.5,
     cex.labels = NULL, font.labels = 1, gap = 0,
     axes = TRUE, panel.border = TRUE, key = TRUE,
     keyOpt = list(space= 2.5, width= 1.5, axis= TRUE,
                   rug.at= numeric(), title= NULL, line= 5),
     main = NULL, main.centered = FALSE,
     line.main = if(is.list(main)) 5/4*par("cex.main")* rev(seq_along(main)) else 2,
     sub = NULL, sub.centered = FALSE, line.sub = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".pairsCond_+3A_gcu.u">gcu.u</code></td>
<td>
<p>(n,d,d)-array of pairwise Rosenblatt-transformed u's as returned by
<code><a href="#topic+pairwiseCcop">pairwiseCcop</a>()</code>.</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_panel">panel</code></td>
<td>
<p>panel function, as for <code><a href="graphics.html#topic+pairs">pairs</a>()</code>.</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_collist">colList</code></td>
<td>
<p>list of colors and information as returned by
<code><a href="#topic+pairsColList">pairsColList</a>()</code>.</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_col">col</code></td>
<td>
<p><em>instead</em> of <code>colList</code>, specifying the points' color.</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_bg">bg</code></td>
<td>
<p><em>instead</em> of <code>colList</code>, specifying the constant
background color.</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_labels">labels</code></td>
<td>
<p>pairs() argument; can be missing (in which
case a suitable default is chosen or can be &quot;none&quot; [or
something else])</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_...">...</code></td>
<td>
<p>further arguments, as for <code><a href="graphics.html#topic+pairs">pairs</a></code>.  These are
passed to <code>panel()</code>, and <code><a href="graphics.html#topic+axis">axis</a></code>, may also contain
<code>font.main</code>, <code>cex.main</code>, and <code>adj</code>, for title
adjustments; further, <code>oma</code> for modifying the default
<code><a href="graphics.html#topic+par">par</a>("oma")</code>.</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_text.panel">text.panel</code>, <code id=".pairsCond_+3A_label.pos">label.pos</code>, <code id=".pairsCond_+3A_cex.labels">cex.labels</code>, <code id=".pairsCond_+3A_font.labels">font.labels</code>, <code id=".pairsCond_+3A_gap">gap</code></td>
<td>
<p>see
<code><a href="graphics.html#topic+pairs">pairs</a>()</code>.</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_axes">axes</code></td>
<td>
<p>logical indicating whether axes are drawn.</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_panel.border">panel.border</code></td>
<td>
<p>logical indicating whether a border is drawn
around the pairs (to mimic the behavior of <code><a href="graphics.html#topic+image">image</a>()</code>).</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_key">key</code></td>
<td>
<p>logical indicating whether a color key is drawn.</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_keyopt">keyOpt</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> of options for the color key;
</p>

<dl>
<dt><code>space</code>:</dt><dd><p>white space in height of characters in
inch to specify the the distance of the key to the pairs plot.</p>
</dd>
<dt><code>width</code>:</dt><dd><p>key width in height of characters in inch.</p>
</dd>
<dt><code>axis</code>:</dt><dd><p>logical indicating whether an axis for the
color key is drawn.</p>
</dd>
<dt><code>rug.at</code>:</dt><dd><p>values where rugs are plotted at the key.</p>
</dd>
<dt><code>title</code>:</dt><dd><p>key title.</p>
</dd>
<dt><code>line</code>:</dt><dd><p>key placement (horizontal distance from color
key in lines).</p>
</dd>
</dl>

</td></tr>
<tr><td><code id=".pairsCond_+3A_main">main</code></td>
<td>
<p>title</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_main.centered">main.centered</code></td>
<td>
<p>logical indicating if the title should be
centered or not; the default <code>FALSE</code> centers it according to
the pairs plot, not the whole plotting region.</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_line.main">line.main</code></td>
<td>
<p>title placement (vertical distance from pairs plot in
lines).</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_sub">sub</code></td>
<td>
<p>sub-title</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_sub.centered">sub.centered</code></td>
<td>
<p>logical indicating if the sub-title
should be centered or not; see <code>main.centered</code>.</p>
</td></tr>
<tr><td><code id=".pairsCond_+3A_line.sub">line.sub</code></td>
<td>
<p>sub-title placement, see <code>line.main</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>based on pairs.default() and
filled.contour() from R-2.14.1 - used in Hofert and Maechler (2013)
</p>


<h3>Author(s)</h3>

<p>Marius Hofert and Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairsRosenblatt">pairsRosenblatt</a>()</code>, the prinicipal function, calling
<code>.pairsCond()</code>.
</p>

<hr>
<h2 id='absdPsiMC'>Absolute Value of Generator Derivatives via Monte Carlo</h2><span id='topic+absdPsiMC'></span><span id='topic+psiDabsMC'></span>

<h3>Description</h3>

<p>Computes the absolute values of the <code class="reqn">d</code>th generator derivative
<code class="reqn">\psi^{(d)}</code> via Monte Carlo simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absdPsiMC(t, family, theta, degree = 1, n.MC,
          method = c("log", "direct", "pois.direct", "pois"),
          log = FALSE, is.log.t = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absdPsiMC_+3A_t">t</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code> vector of evaluation points.</p>
</td></tr>
<tr><td><code id="absdPsiMC_+3A_family">family</code></td>
<td>
<p>Archimedean family (name or object).</p>
</td></tr>
<tr><td><code id="absdPsiMC_+3A_theta">theta</code></td>
<td>
<p>parameter value.</p>
</td></tr>
<tr><td><code id="absdPsiMC_+3A_degree">degree</code></td>
<td>
<p>order <code class="reqn">d</code> of the derivative.</p>
</td></tr>
<tr><td><code id="absdPsiMC_+3A_n.mc">n.MC</code></td>
<td>
<p>Monte Carlo sample size.</p>
</td></tr>
<tr><td><code id="absdPsiMC_+3A_method">method</code></td>
<td>
<p>different methods:
</p>

<dl>
<dt><code>"log"</code>:</dt><dd><p>evaluates the logarithm of the sum involved
in the Monte Carlo approximation in a numerically stable way;</p>
</dd>
<dt><code>"direct"</code>:</dt><dd><p>directly evaluates the sum;</p>
</dd>
<dt><code>"pois.direct"</code>:</dt><dd><p>interprets the sum in terms of the
density of a Poisson distribution and evaluates this density directly;</p>
</dd>
<dt><code>"pois"</code>:</dt><dd><p>as for <code>method="pois"</code> but evaluates
the logarithm of the Poisson density in a numerically stable way.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="absdPsiMC_+3A_log">log</code></td>
<td>
<p>if TRUE the logarithm of absdPsi is returned.</p>
</td></tr>
<tr><td><code id="absdPsiMC_+3A_is.log.t">is.log.t</code></td>
<td>
<p>if TRUE the argument <code>t</code> contains the logarithm of the
&ldquo;mathematical&rdquo; <code class="reqn">t</code>, i.e., conceptually,
<code>psi(t, *) == psi(log(t), *, is.log.t=TRUE)</code>, where the latter
may potentially be numerically accurate, e.g., for <code class="reqn">t =
      10^{500}</code>, where as the former would just return <code class="reqn">psi(Inf, *) = 0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The absolute value of the <code class="reqn">d</code>th derivative of the
Laplace-Stieltjes transform
<code class="reqn">\psi=\mathcal{LS}[F]</code> can be approximated via
</p>
<p style="text-align: center;"><code class="reqn">(-1)^d\psi^{(d)}(t)=\int_0^\infty
    x^d\exp(-tx)\,dF(x)\approx\frac{1}{N}\sum_{k=1}^NV_k^d\exp(-V_kt),\
    t&gt; 0,</code>
</p>

<p>where <code class="reqn">V_k\sim F,\ k\in\{1,\dots,N\}</code>.
This approximation is used where <code class="reqn">d=</code><code>degree</code> and
<code class="reqn">N=</code><code>n.MC</code>.  Note that this is comparably fast even if
<code>t</code> contains many evaluation points, since the random variates
<code class="reqn">V_k\sim F,\ k\in\{1,\dots,N\}</code> only have
to be generated once, not depending on <code>t</code>.
</p>


<h3>Value</h3>

<p><code><a href="base.html#topic+numeric">numeric</a></code> vector of the same length as <code>t</code> containing
the absolute values of the generator derivatives.
</p>


<h3>References</h3>

<p>Hofert, M., Mächler, M., and McNeil, A. J. (2013).
Archimedean Copulas in High Dimensions: Estimators and Numerical
Challenges Motivated by Financial Applications.
<em>Journal de la Société Française de
Statistique</em>
<b>154</b>(1), 25&ndash;63.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+acopula-families">acopula-families</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- c(0:100,Inf)
set.seed(1)
(ps &lt;- absdPsiMC(t, family="Gumbel", theta=2, degree=10, n.MC=10000, log=TRUE))
## Note: The absolute value of the derivative at 0 should be Inf for
## Gumbel, however, it is always finite for the Monte Carlo approximation
set.seed(1)
ps2 &lt;- absdPsiMC(log(t), family="Gumbel", theta=2, degree=10,
                 n.MC=10000, log=TRUE, is.log.t = TRUE)
stopifnot(all.equal(ps[-1], ps2[-1], tolerance=1e-14))
## Now is there an advantage of using "is.log.t" ?
sapply(eval(formals(absdPsiMC)$method), function(MM)
       absdPsiMC(780, family="Gumbel", method = MM,
                 theta=2, degree=10, n.MC=10000, log=TRUE, is.log.t = TRUE))
## not really better, yet...
</code></pre>

<hr>
<h2 id='acopula-class'>Class &quot;acopula&quot; of Archimedean Copula Families</h2><span id='topic+acopula-class'></span><span id='topic+acopula'></span><span id='topic+initialize+2Cacopula-method'></span><span id='topic+show+2Cacopula-method'></span>

<h3>Description</h3>

<p>This class <code>"acopula"</code> of Archimedean Copula Families
is mainly used for providing objects of known Archimedean families
with all related functions.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("acopula", ...)</code>.
For several well-known Archimedean
copula families, the package <span class="pkg">copula</span> already provides such
family objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>A string (class <code>"character"</code>) describing
the copula family, for example, &quot;AMH&quot; (or simply &quot;A&quot;), &quot;Clayton&quot; (&quot;C&quot;),
&quot;Frank&quot; (&quot;F&quot;), &quot;Gumbel&quot; (&quot;G&quot;), or &quot;Joe&quot; (&quot;J&quot;).</p>
</dd>
<dt><code>theta</code>:</dt><dd><p>Parameter value, a <code><a href="base.html#topic+numeric">numeric</a></code>, where
<code>NA</code> means &ldquo;unspecified&rdquo;.</p>
</dd>
<dt><code>psi</code>, <code>iPsi</code>:</dt><dd><p>The (Archimedean) generator
<code class="reqn">\psi</code> (with <code class="reqn">\psi</code>(t)=<code class="reqn">\exp</code>(-t) being the
generator of the independence copula) and its inverse
(<code><a href="base.html#topic+function">function</a></code>). <code>iPsi</code> has an optional argument
<code>log</code> which, if <code>TRUE</code> returns the logarithm of inverse of the
generator.</p>
</dd>
<dt><code>absdPsi</code>:</dt><dd><p>A <code><a href="base.html#topic+function">function</a></code> which computes the absolute
value of the derivative of the generator <code class="reqn">\psi</code> for the given
parameter <code>theta</code> and of the given <code>degree</code> (defaults to 1).
Note that there is no informational loss by computing the absolute value
since the derivatives alternate in sign (the generator derivative
is simply (-1)^<code>degree</code><code class="reqn">*</code><code>absdPsi</code>).  The
number <code>n.MC</code> denotes the sample size for a Monte Carlo evaluation
approach.  If <code>n.MC</code> is zero (the default), the
generator derivatives are evaluated with their exact formulas.  The
optional parameter <code>log</code> (defaults to <code>FALSE</code>) indicates whether
or not the logarithmic value is returned.</p>
</dd>
<dt><code>absdiPsi</code>:</dt><dd><p>a <code><a href="base.html#topic+function">function</a></code> computing the
absolute value of the derivative of the generator inverse
(<code>iPsi()</code>) for the given parameter <code>theta</code>.  The optional
parameter <code>log</code> (defaults to <code>FALSE</code>) indicates whether
the logarithm of the absolute value of the first derivative of
<code>iPsi()</code> is returned.</p>
</dd>
<dt><code>dDiag</code>:</dt><dd><p>a <code><a href="base.html#topic+function">function</a></code> computing the density of the
diagonal of the Archimedean copula at <code>u</code> with parameter
<code>theta</code>.  The parameter <code>log</code> is as described before.</p>
</dd>
<dt><code>dacopula</code>:</dt><dd><p>a <code><a href="base.html#topic+function">function</a></code> computing the density
of the Archimedean copula at <code>u</code> with parameter <code>theta</code>.  The
meanings of the parameters <code>n.MC</code> and <code>log</code> are as
described before.</p>
</dd>
<dt><code>score</code>:</dt><dd><p>a <code><a href="base.html#topic+function">function</a></code> computing the
<em>derivative</em> of the density with respect to the parameter
<code class="reqn">\theta</code>.</p>
</dd>
<dt><code>uscore</code>:</dt><dd><p>a <code><a href="base.html#topic+function">function</a></code> computing the
<em>derivative</em> of the density with respect to the each of the arguments.</p>
</dd>
<dt><code>paraInterval</code>:</dt><dd><p>Either <code><a href="base.html#topic+NULL">NULL</a></code> or an object of class
<code>"<a href="#topic+interval-class">interval</a>"</code>, which is typically obtained from a call
such as <code><a href="#topic+interval">interval</a>("[a,b)")</code>.</p>
</dd>
<dt><code>paraConstr</code>:</dt><dd><p>A function of <code>theta</code> returning
<code>TRUE</code> if and only if <code>theta</code> is a valid parameter value.  Note
that <code>paraConstr</code> is built automatically from the interval,
whenever the <code>paraInterval</code> slot is valid.
<code>"<a href="#topic+interval-class">interval</a>"</code>.</p>
</dd>
<dt><code>nestConstr</code>:</dt><dd><p>A <code><a href="base.html#topic+function">function</a></code>, which returns
<code>TRUE</code> if and only if the two provided parameters <code>theta0</code> and
<code>theta1</code> satisfy the sufficient nesting condition for this family.</p>
</dd>
<dt><code>V0</code>:</dt><dd><p>A <code><a href="base.html#topic+function">function</a></code> which samples <code>n</code> random
variates from the distribution <code class="reqn">F</code> with Laplace-Stieltjes transform
<code class="reqn">\psi</code> and parameter <code>theta</code>.</p>
</dd>
<dt><code>dV0</code>:</dt><dd><p>A <code><a href="base.html#topic+function">function</a></code> which computes either the
probability mass function or the probability density function (depending
on the Archimedean family) of the distribution function whose
Laplace-Stieltjes transform equals the generator <code class="reqn">\psi</code> at the
argument <code>x</code> (possibly a vector) for the given parameter
<code>theta</code>.  An optional argument <code>log</code> indicates whether
the logarithm of the mass or density is computed (defaults to
<code>FALSE</code>).</p>
</dd>
<dt><code>V01</code>:</dt><dd><p>A <code><a href="base.html#topic+function">function</a></code> which gets a vector of
realizations of <code>V0</code>, two parameters <code>theta0</code> and <code>theta1</code>
which satisfy the sufficient nesting condition, and which
returns a vector of the same length as <code>V0</code> with random variates from
the distribution function <code class="reqn">F_{01}</code> with Laplace-Stieltjes
transform <code class="reqn">\psi_{01}</code> (see <code>dV01</code>) and parameters
<code class="reqn">\theta_0=\,</code><code>theta0</code>,
<code class="reqn">\theta_1=\,</code><code>theta1</code>.</p>
</dd>
<dt><code>dV01</code>:</dt><dd><p>Similar to <code>dV0</code> with the difference being that
this <code><a href="base.html#topic+function">function</a></code> computes the probability mass or density
function for the Laplace-Stieltjes transform
</p>
<p style="text-align: center;"><code class="reqn">\psi_{01}(t;V_0) = \exp(-V_0\psi_0^{-1}(\psi_1(t))),
      </code>
</p>

<p>corresponding to the distribution function <code class="reqn">F_{01}</code>.
</p>
<p>Arguments are the evaluation point(s) <code>x</code>, the value(s) <code>V0</code>,
and the parameters <code>theta0</code> and <code>theta1</code>.  As for
<code>dV0</code>, the optional argument <code>log</code> can be specified
(defaults to <code>FALSE</code>). Note that if <code>x</code> is a vector,
<code>V0</code> must either have length one (in which case <code>V0</code> is
the same for every component of <code>x</code>) or <code>V0</code> must be of
the same length as <code>x</code> (in which case the components of
<code>V0</code> correspond to the ones of <code>x</code>).</p>
</dd>
<dt><code>tau</code>, <code>iTau</code>:</dt><dd><p>Compute Kendall's tau of the bivariate
Archimedean copula with generator <code class="reqn">\psi</code> as a
<code><a href="base.html#topic+function">function</a></code> of <code>theta</code>, respectively, <code>theta</code> as a
function of Kendall's tau.</p>
</dd>
<dt><code>lambdaL</code>, <code>lambdaU</code>, <code>lambdaLInv</code>,
<code>lambdaUInv</code>:</dt><dd><p>Compute the lower (upper) tail-dependence coefficient
of the bivariate Archimedean copula with generator <code class="reqn">\psi</code> as a
<code><a href="base.html#topic+function">function</a></code> of <code>theta</code>, respectively, <code>theta</code> as a
function of the lower (upper) tail-dependence coefficient.</p>
</dd>
</dl>

<p>For more details about Archimedean families, corresponding distributions and
properties, see the references.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "acopula")</code>: is used to
automatically construct the function slot <code>paraConstr</code>, when
the <code>paraInterval</code> is provided (typically via
<code><a href="#topic+interval">interval</a>()</code>).</p>
</dd>
<dt>show</dt><dd><p><code>signature("acopula")</code>: compact overview of the copula.</p>
</dd>
</dl>



<h3>References</h3>


<p>See those of the families, for example, <code><a href="#topic+copGumbel">copGumbel</a></code>.
</p>


<h3>See Also</h3>

<p>Specific provided copula family objects, for example,
<code><a href="#topic+copAMH">copAMH</a></code>, <code><a href="#topic+copClayton">copClayton</a></code>, <code><a href="#topic+copFrank">copFrank</a></code>,
<code><a href="#topic+copGumbel">copGumbel</a></code>, <code><a href="#topic+copJoe">copJoe</a></code>.
<br /> To access these, you may also use <code><a href="#topic+getAcop">getAcop</a></code>.
</p>
<p>A <em>nested</em> Archimedean copula <em>without</em>
child copulas (see class <code>"<a href="#topic+nacopula-class">nacopula</a>"</code>)
is a proper Archimedean copula, and hence,
<code><a href="#topic+onacopula">onacopula</a>()</code> can be used to construct a specific
parametrized Archimedean copula; see the example below.
</p>
<p>Alternatively, <code><a href="#topic+setTheta">setTheta</a></code> also returns such a
(parametrized) Archimedean copula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## acopula class information
showClass("acopula")

## Information and structure of Clayton copulas
copClayton
str(copClayton)

## What are admissible parameters for Clayton copulas?
copClayton@paraInterval

## A Clayton "acopula" with Kendall's tau = 0.8 :
(cCl.2 &lt;- setTheta(copClayton, iTau(copClayton, 0.8)))

## Can two Clayton copulas with parameters theta0 and theta1 be nested?
## Case 1: theta0 = 3, theta1 = 2
copClayton@nestConstr(theta0 = 3, theta1 = 2)
## -&gt; FALSE as the sufficient nesting criterion is not fulfilled
## Case 2: theta0 = 2, theta1 = 3
copClayton@nestConstr(theta0 = 2, theta1 = 3) # TRUE

## For more examples, see  help("acopula-families")
</code></pre>

<hr>
<h2 id='acR'>Distribution of the Radial Part of an Archimedean Copula</h2><span id='topic+pacR'></span><span id='topic+qacR'></span>

<h3>Description</h3>

<p><code>pacR()</code> computes the distribution function <code class="reqn">F_R</code> of the radial
part of an Archimedean copula, given by
</p>
<p style="text-align: center;"><code class="reqn">F_R(x)=1-\sum_{k=0}^{d-1}
    \frac{(-x)^k\psi^{(k)}(x)}{k!},\ x\in[0,\infty);</code>
</p>

<p>The formula (in a slightly more general form) is given by
McNeil and G. Nešlehová (2009).
</p>
<p><code>qacR()</code> computes the quantile function of <code class="reqn">F_R</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pacR(x, family, theta, d, lower.tail = TRUE, log.p = FALSE, ...)
qacR(p, family, theta, d, log.p = FALSE, interval,
     tol = .Machine$double.eps^0.25, maxiter = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acR_+3A_x">x</code></td>
<td>
<p>numeric vector of nonnegative evaluation points for <code class="reqn">F_R</code>.</p>
</td></tr>
<tr><td><code id="acR_+3A_p">p</code></td>
<td>
<p>numeric vector 
of evaluation points of the  quantile function.</p>
</td></tr>
<tr><td><code id="acR_+3A_family">family</code></td>
<td>
<p>Archimedean family.</p>
</td></tr>
<tr><td><code id="acR_+3A_theta">theta</code></td>
<td>
<p>parameter <code class="reqn">theta</code>.</p>
</td></tr>
<tr><td><code id="acR_+3A_d">d</code></td>
<td>
<p>dimension <code class="reqn">d</code>.</p>
</td></tr>
<tr><td><code id="acR_+3A_lower.tail">lower.tail</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>; if <code>TRUE</code>,
probabilities are <code class="reqn">P[X &lt;= x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="acR_+3A_log.p">log.p</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are given as <code class="reqn">\log p</code>.</p>
</td></tr>
<tr><td><code id="acR_+3A_interval">interval</code></td>
<td>
<p>root-search interval.</p>
</td></tr>
<tr><td><code id="acR_+3A_tol">tol</code></td>
<td>
<p>see <code><a href="stats.html#topic+uniroot">uniroot</a>()</code>.</p>
</td></tr>
<tr><td><code id="acR_+3A_maxiter">maxiter</code></td>
<td>
<p>see <code><a href="stats.html#topic+uniroot">uniroot</a>()</code>.</p>
</td></tr>
<tr><td><code id="acR_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the procedure for
computing derivatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distribution function of the radial part evaluated at
<code>x</code>, or its inverse, the quantile at <code>p</code>.</p>


<h3>References</h3>

<p>McNeil, A. J., G. Nešlehová, J. (2009).
Multivariate Archimedean copulas, <code class="reqn">d</code>-monotone functions and
<code class="reqn">l_1</code>-norm symmetric distributions. <em>The Annals of Statistics</em>
<b>37</b>(5b), 3059&ndash;3097.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## setup
family &lt;- "Gumbel"
tau &lt;- 0.5
m &lt;- 256
dmax &lt;- 20
x &lt;- seq(0, 20, length.out=m)

## compute and plot pacR() for various d's
y &lt;- vapply(1:dmax, function(d)
            pacR(x, family=family, theta=iTau(archmCopula(family), tau), d=d),
            rep(NA_real_, m))
plot(x, y[,1], type="l", ylim=c(0,1),
     xlab = quote(italic(x)), ylab = quote(F[R](x)),
     main = substitute(italic(F[R](x))~~ "for" ~ d==1:.D, list(.D = dmax)))
for(k in 2:dmax) lines(x, y[,k])
</code></pre>

<hr>
<h2 id='allComp'>All Components of a (Inner or Outer) Nested Archimedean Copula</h2><span id='topic+allComp'></span>

<h3>Description</h3>

<p>Given the nested Archimedean copula <code>x</code>, return an integer vector
of the <em>indices</em> of all components of the corresponding
<code><a href="#topic+outer_nacopula-class">outer_nacopula</a></code> which are components of <code>x</code>,
either direct components or components of possible child copulas.  This
is typically only used by programmers investigating the exact nesting
structure.
</p>
<p>For an <code><a href="#topic+outer_nacopula-class">outer_nacopula</a></code> object
<code>x</code>, <code>allComp(x)</code> must be the same as
<code>1:<a href="base.html#topic+dim">dim</a>(x)</code>, whereas its &ldquo;inner&rdquo; component copulas
will each contain a <em>subset</em> of those indices only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allComp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allComp_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from class <code><a href="#topic+nacopula-class">nacopula</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="base.html#topic+integer">integer</a></code> vector of indices <code class="reqn">j</code> of all components
<code class="reqn">u_j</code> as described in the description above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> C3 &lt;- onacopula("AMH", C(0.7135, 1, C(0.943, 2:3)))
 allComp(C3) # components are 1:3
 allComp(C3@childCops[[1]]) # for the child, only  (2, 3)
</code></pre>

<hr>
<h2 id='An'>Nonparametric Rank-based Estimators of the Pickands Dependence Function</h2><span id='topic+An.biv'></span><span id='topic+An'></span><span id='topic+Anfun'></span>

<h3>Description</h3>

<p>Bivariate and multivariate versions of the nonparametric rank-based
estimators of the Pickands dependence function <code class="reqn">A</code>, studied in
Genest and Segers (2009) and Gudendorf and Segers (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>An.biv(x, w, estimator = c("CFG", "Pickands"), corrected = TRUE,
       ties.method = eval(formals(rank)$ties.method))
An(x, w, ties.method = eval(formals(rank)$ties.method))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="An_+3A_x">x</code></td>
<td>
<p> a data matrix that will be transformed to
pseudo-observations. If <code>An.biv</code> is called, <code>x</code> has to
have two columns.</p>
</td></tr>
<tr><td><code id="An_+3A_w">w</code></td>
<td>
<p> if <code>An.biv</code> is called, a vector of points in [0,1]
where to evaluate the estimated bivariate Pickands dependence
function. If the multivariate estimator <code>An</code> is used instead,
<code>w</code> needs to be a matrix with the same number of columns as
<code>x</code> whose lines are elements of the multivariate unit simplex
(see the last reference).</p>
</td></tr>
<tr><td><code id="An_+3A_estimator">estimator</code></td>
<td>
<p>specifies which nonparametric rank-based estimator
of the unknown Pickands dependence function to use in the bivariate
case; can be either
<code>"CFG"</code>(Capéraà-Fougères-Genest) or
<code>"Pickands"</code>.</p>
</td></tr>
<tr><td><code id="An_+3A_corrected">corrected</code></td>
<td>
<p> TRUE means that the bivariate estimators will be
corrected to ensure that their value at 0 and 1 is 1.</p>
</td></tr>
<tr><td><code id="An_+3A_ties.method">ties.method</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string specifying how ranks
should be computed if
there are ties in any of the coordinate samples of <code>x</code>; passed
to <code><a href="#topic+pobs">pobs</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details can be found in the references.
</p>


<h3>Value</h3>

<p><code>An.biv()</code> returns a vector containing the values of the
estimated Pickands dependence function at the points in <code>w</code> (and
is the same as former <code>Anfun()</code>).
</p>
<p>The function <code>An</code> computes simultaneously the three corrected
multivariate estimators studied in Gudendorf and Segers (2011) at the
points in <code>w</code> and retuns a list whose components are
</p>
<table>
<tr><td><code>P</code></td>
<td>
<p> values of the Pickands estimator at the points in <code>w</code>.</p>
</td></tr>
<tr><td><code>CFG</code></td>
<td>
<p> values of the CFG estimator at the points in <code>w</code>.</p>
</td></tr>
<tr><td><code>HT</code></td>
<td>
<p> values of the Hall-Tajvidi estimator at the points in <code>w</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>C. Genest and J. Segers (2009).
Rank-based inference for bivariate extreme-value copulas.
<em>Annals of Statistics</em> <b>37</b>, 2990&ndash;3022.
</p>
<p>G. Gudendorf and J. Segers (2011). Nonparametric estimation of
multivariate extreme-value copulas. <em>Journal of Statistical
Planning and Inference</em> <b>142</b>, 3073&ndash;3085.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evCopula">evCopula</a></code>, <code><a href="#topic+A">A</a></code>, and <code><a href="#topic+evTestA">evTestA</a></code>.
Further, <code><a href="#topic+evTestC">evTestC</a></code>, <code><a href="#topic+evTestK">evTestK</a></code>,
<code><a href="#topic+exchEVTest">exchEVTest</a></code>, and <code><a href="#topic+gofEVCopula">gofEVCopula</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## True Pickands dependence functions
curve(A(gumbelCopula(4   ), x), 0, 1)
curve(A(gumbelCopula(2   ), x), add=TRUE, col=2)
curve(A(gumbelCopula(1.33), x), add=TRUE, col=3)

## CFG estimator
curve(An.biv(rCopula(1000, gumbelCopula(4   )), x), lty=2, add=TRUE)
curve(An.biv(rCopula(1000, gumbelCopula(2   )), x), lty=2, add=TRUE, col=2)
curve(An.biv(rCopula(1000, gumbelCopula(1.33)), x), lty=2, add=TRUE, col=3)

## Pickands estimator
curve(An.biv(rCopula(1000, gumbelCopula(4   )), x, estimator="Pickands"),
      lty=3, add=TRUE)
curve(An.biv(rCopula(1000, gumbelCopula(2   )), x, estimator="Pickands"),
      lty=3, add=TRUE, col=2)
curve(An.biv(rCopula(1000, gumbelCopula(1.33)), x, estimator="Pickands"),
      lty=3, add=TRUE, col=3)

legend("bottomleft",  paste0("Gumbel(", format(c(4, 2, 1.33)),")"),
       lwd=1, col=1:3, bty="n")
legend("bottomright", c("true", "CFG est.", "Pickands est."), lty=1:3, bty="n")

## Relationship between An.biv and An
u &lt;- c(runif(100),0,1) # include 0 and 1
x &lt;- rCopula(1000, gumbelCopula(4))
r &lt;- An(x, cbind(1-u, u))
all.equal(r$CFG, An.biv(x, u))
all.equal(r$P, An.biv(x, u, estimator="Pickands"))

## A trivariate example
x &lt;- rCopula(1000, gumbelCopula(4, dim = 3))
u &lt;- matrix(runif(300), 100, 3)
w &lt;- u / apply(u, 1, sum)
r &lt;- An(x, w)

## Endpoint corrections are applied
An(x, cbind(1, 0, 0))
An(x, cbind(0, 1, 0))
An(x, cbind(0, 0, 1))

</code></pre>

<hr>
<h2 id='archmCopula'>Construction of Archimedean Copula Class Object</h2><span id='topic+archmCopula'></span><span id='topic+claytonCopula'></span><span id='topic+frankCopula'></span><span id='topic+gumbelCopula'></span><span id='topic+amhCopula'></span><span id='topic+joeCopula'></span>

<h3>Description</h3>

<p>Constructs an Archimedean copula class object with its corresponding
parameter and dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>archmCopula(family, param = NA_real_, dim = 2, ...)

claytonCopula(param = NA_real_, dim = 2,
          use.indepC = c("message", "TRUE", "FALSE"))
frankCopula(param = NA_real_, dim = 2,
          use.indepC = c("message", "TRUE", "FALSE"))
gumbelCopula(param = NA_real_, dim = 2,
          use.indepC = c("message", "TRUE", "FALSE"))
amhCopula(param = NA_real_, dim = 2,
          use.indepC = c("message", "TRUE", "FALSE"))
joeCopula(param = NA_real_, dim = 2,
          use.indepC = c("message", "TRUE", "FALSE"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archmCopula_+3A_family">family</code></td>
<td>
<p>a character string specifying the family of an
Archimedean copula.  Currently supported families are &quot;clayton&quot;,
&quot;frank&quot;, &quot;amh&quot;, &quot;gumbel&quot;, and &quot;joe&quot;.
</p>
</td></tr>
<tr><td><code id="archmCopula_+3A_param">param</code></td>
<td>
<p>number (<code><a href="base.html#topic+numeric">numeric</a></code>) specifying the copula parameter.</p>
</td></tr>
<tr><td><code id="archmCopula_+3A_dim">dim</code></td>
<td>
<p>the dimension of the copula.</p>
</td></tr>
<tr><td><code id="archmCopula_+3A_...">...</code></td>
<td>
<p>further arguments, passed to the individual creator
functions (<code>claytonCopula()</code>, etc).</p>
</td></tr>
<tr><td><code id="archmCopula_+3A_use.indepc">use.indepC</code></td>
<td>
<p>a string specifying if the independence copula
<code><a href="#topic+indepCopula">indepCopula</a></code>, should be returned in the case where the
parameter <code class="reqn">\theta</code>, <code>param</code>, is at the boundary or limit
case where the corresponding Archimedean copula is the independence
copula.
The default does return <code>indepCopula()</code> with a message, using
<code>"TRUE"</code> does it without a message.  This makes the resulting
object more useful typically, but does not return a formal
Archimedean copula of the desired family, something needed e.g., for
fitting purposes, where you'd use <code>use.indepC="FALSE"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>archmCopula()</code> is a wrapper for <code>claytonCopula()</code>,
<code>frankCopula()</code>, <code>gumbelCopula()</code>, <code>amhCopula()</code> and
<code>joeCopula</code>.
</p>
<p>For the mathematical definitions of the respective Archimedean families,
see <code><a href="#topic+copClayton">copClayton</a></code>.
</p>
<p>For <code class="reqn">d = 2</code>, i.e. <code>dim = 2</code>, the AMH, Clayton and Frank copulas
allow to model negative Kendall's tau (<code><a href="#topic+tau">tau</a></code>) behavior via
negative <code class="reqn">\theta</code>, for AMH and Clayton
<code class="reqn">-1 \le \theta</code>, and for Frank
<code class="reqn">-\infty &lt; \theta</code>.
The respective boundary cases are
</p>

<dl>
<dt>AMH:</dt><dd><p><code class="reqn">\tau(\theta = -1) = -0.1817258</code>,</p>
</dd>
<dt>Clayton:</dt><dd><p><code class="reqn">\tau(\theta = -1) = -1</code>,</p>
</dd>
<dt>Frank:</dt><dd><p><code class="reqn">\tau(\theta = -Inf) = -1</code> (as limit).</p>
</dd>
</dl>

<p>For the Ali-Mikhail-Haq copula family (<code>"amhCopula"</code>), only the
bivariate case is available; however <code><a href="#topic+copAMH">copAMH</a></code> has no such
limitation.
</p>







<p>Note that in all cases except for Frank and AMH, and <code class="reqn">d = 2</code> and
<code class="reqn">theta &lt; 0</code>, the densities (<code><a href="#topic+dCopula">dCopula</a>()</code> methods) are
evaluated via the <code>dacopula</code> slot of the corresponding
<code><a href="#topic+acopula-class">acopula</a></code>-classed Archimedean copulas, implemented
in a numeric stable way without any restriction on the dimension <code class="reqn">d</code>.
<br />
Similarly, the (cumulative) distribution function
(&ldquo;&quot;the copula&quot;&rdquo; <code class="reqn">C()</code>) is evaluated via the corresponding
<code><a href="#topic+acopula-class">acopula</a></code>-classed Archimedean copula's functions in
the <code>psi</code> and <code>iPsi</code> slots.
</p>


<h3>Value</h3>

<p>An Archimedean copula object of class <code>"claytonCopula"</code>,
<code>"frankCopula"</code>, <code>"gumbelCopula"</code>, <code>"amhCopula"</code>, or <code>"joeCopula"</code>.
</p>


<h3>References</h3>

<p>R.B. Nelsen (2006), <em>An introduction to Copulas</em>, Springer, New York.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+acopula-class">acopula</a></code>-classed Archimedean copulas, such as
<code><a href="#topic+copClayton">copClayton</a></code>, <code><a href="#topic+copGumbel">copGumbel</a></code>, etc, notably for
mathematical definitions including the meaning of <code>param</code>.
</p>
<p><code><a href="#topic+fitCopula">fitCopula</a></code> for fitting such copulas to data.
</p>
<p><code><a href="#topic+ellipCopula">ellipCopula</a></code>, <code><a href="#topic+evCopula">evCopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clayton.cop &lt;- claytonCopula(2, dim = 3)
## scatterplot3d(rCopula(1000, clayton.cop))

## negative param (= theta) is allowed for dim = 2 :
tau(claytonCopula(-0.5)) ## = -1/3
tauClayton &lt;- Vectorize(function(theta) tau(claytonCopula(theta, dim=2)))
plot(tauClayton, -1, 10, xlab=quote(theta), ylim = c(-1,1), n=1025)
abline(h=-1:1,v=0, col="#11111150", lty=2); axis(1, at=-1)

tauFrank &lt;- Vectorize(function(theta) tau(frankCopula(theta, dim=2)))
plot(tauFrank, -40, 50, xlab=quote(theta), ylim = c(-1,1), n=1025)
abline(h=-1:1,v=0, col="#11111150", lty=2)

## tauAMH() is function in our package
iTau(amhCopula(), -1) # -1 with a range warning
iTau(amhCopula(), (5 - 8*log(2)) / 3) # -1 with a range warning

ic &lt;- frankCopula(0) # independence copula (with a "message")
stopifnot(identical(ic,
   frankCopula(0, use.indepC = "TRUE")))# indep.copula  withOUT message
(fC &lt;- frankCopula(0, use.indepC = "FALSE"))
## a Frank copula which corresponds to the indep.copula (but is not)

frankCopula(dim = 3)# with NA parameters
frank.cop &lt;- frankCopula(3)# dim=2
persp(frank.cop, dCopula)

gumbel.cop &lt;- archmCopula("gumbel", 5)
stopifnot(identical(gumbel.cop, gumbelCopula(5)))
contour(gumbel.cop, dCopula)

amh.cop &lt;- amhCopula(0.5)
u. &lt;- as.matrix(expand.grid(u=(0:10)/10, v=(0:10)/10, KEEP.OUT.ATTRS=FALSE))
du &lt;- dCopula(u., amh.cop)
stopifnot(is.finite(du) | apply(u. == 0, 1,any)| apply(u. == 1, 1,any))

## A 7-dim Frank copula
frank.cop &lt;- frankCopula(3, dim = 7)
x &lt;- rCopula(5, frank.cop)
## dCopula now *does* work:
dCopula(x, frank.cop)

## A 7-dim Gumbel copula
gumbelC.7 &lt;- gumbelCopula(2, dim = 7)
dCopula(x, gumbelC.7)

## A 12-dim Joe copula
joe.cop &lt;- joeCopula(iTau(joeCopula(), 0.5), dim = 12)
x &lt;- rCopula(5, joe.cop)
dCopula(x, joe.cop)
</code></pre>

<hr>
<h2 id='archmCopula-class'>Class &quot;archmCopula&quot;</h2><span id='topic+archmCopula-class'></span><span id='topic+claytonCopula-class'></span><span id='topic+frankCopula-class'></span><span id='topic+gumbelCopula-class'></span><span id='topic+amhCopula-class'></span><span id='topic+joeCopula-class'></span>

<h3>Description</h3>

<p>Archimedean copula class.</p>


<h3>Objects from the Class</h3>

<p>Created by calls of the form <code>new("archmCopula", ...)</code> or rather
typically by <code><a href="#topic+archmCopula">archmCopula</a>()</code>.  Implemented
families are Clayton, Gumbel, Frank, Joe, and Ali-Mikhail-Haq.
</p>


<h3>Slots</h3>


<dl>
<dt><code>exprdist</code>:</dt><dd><p>Object of class <code>"expression"</code>:
expressions of the cdf and pdf of the copula. These expressions
are used in function <code><a href="#topic+pCopula">pCopula</a></code> and <code><a href="#topic+dCopula">dCopula</a></code>. </p>
</dd>
<dt><code>dimension, parameters</code>, etc:</dt><dd><p>all inherited from the
super class <code><a href="#topic+copula-class">copula</a></code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>dCopula</dt><dd><p><code>signature(copula = "claytonCopula")</code>: ... </p>
</dd>
<dt>pCopula</dt><dd><p><code>signature(copula = "claytonCopula")</code>: ... </p>
</dd>
<dt>rCopula</dt><dd><p><code>signature(copula = "claytonCopula")</code>: ... </p>
</dd>
<dt>dCopula</dt><dd><p><code>signature(copula = "frankCopula")</code>: ... </p>
</dd>
<dt>pCopula</dt><dd><p><code>signature(copula = "frankCopula")</code>: ... </p>
</dd>
<dt>rCopula</dt><dd><p><code>signature(copula = "frankCopula")</code>: ... </p>
</dd>
<dt>dCopula</dt><dd><p><code>signature(copula = "gumbelCopula")</code>: ... </p>
</dd>
<dt>pCopula</dt><dd><p><code>signature(copula = "gumbelCopula")</code>: ... </p>
</dd>
<dt>rCopula</dt><dd><p><code>signature(copula = "gumbelCopula")</code>: ... </p>
</dd>
<dt>dCopula</dt><dd><p><code>signature(copula = "amhCopula")</code>: ... </p>
</dd>
<dt>pCopula</dt><dd><p><code>signature(copula = "amhCopula")</code>: ... </p>
</dd>
<dt>rCopula</dt><dd><p><code>signature(copula = "amhCopula")</code>: ... </p>
</dd>
<dt>dCopula</dt><dd><p><code>signature(copula = "joeCopula")</code>: ... </p>
</dd>
<dt>pCopula</dt><dd><p><code>signature(copula = "joeCopula")</code>: ... </p>
</dd>
<dt>rCopula</dt><dd><p><code>signature(copula = "joeCopula")</code>: ... </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"archmCopula"</code> extends class <code>"<a href="#topic+copula-class">copula</a>"</code>
directly. Class <code>"claytonCopula"</code>, <code>"frankCopula"</code>,
<code>"gumbelCopula"</code>, <code>"amhCopula"</code> and <code>"joeCopula"</code>
extends class <code>"archmCopula"</code> directly.
</p>


<h3>Note</h3>

<p><code>"gumbelCopula"</code> is also of class <code>"<a href="#topic+evCopula-class">evCopula</a>"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+archmCopula">archmCopula</a></code>, for constructing such copula objects;
<code><a href="#topic+copula-class">copula-class</a></code>.
</p>

<hr>
<h2 id='assocMeasures'>Dependence Measures for Bivariate Copulas</h2><span id='topic+tau'></span><span id='topic+rho'></span><span id='topic+kendallsTau'></span><span id='topic+spearmansRho'></span><span id='topic+iTau'></span><span id='topic+iRho'></span><span id='topic+calibKendallsTau'></span><span id='topic+calibSpearmansRho'></span><span id='topic+tailIndex'></span><span id='topic+lambda'></span><span id='topic+tau-methods'></span><span id='topic+tau+2CANY-method'></span><span id='topic+tau+2Ccopula-method'></span><span id='topic+tau+2CarchmCopula-method'></span><span id='topic+tau+2CamhCopula-method'></span><span id='topic+tau+2CclaytonCopula-method'></span><span id='topic+tau+2CfrankCopula-method'></span><span id='topic+tau+2CgumbelCopula-method'></span><span id='topic+tau+2CindepCopula-method'></span><span id='topic+tau+2ClowfhCopula-method'></span><span id='topic+tau+2CupfhCopula-method'></span><span id='topic+tau+2CjoeCopula-method'></span><span id='topic+tau+2CnormalCopula-method'></span><span id='topic+tau+2CtCopula-method'></span><span id='topic+tau+2CfgmCopula-method'></span><span id='topic+tau+2CplackettCopula-method'></span><span id='topic+tau+2CmoCopula-method'></span><span id='topic+tau+2CgalambosCopula-method'></span><span id='topic+tau+2ChuslerReissCopula-method'></span><span id='topic+tau+2CtawnCopula-method'></span><span id='topic+tau+2CtevCopula-method'></span><span id='topic+tau+2CevCopula-method'></span><span id='topic+tau+2Cacopula-method'></span><span id='topic+tau+2Cnacopula-method'></span><span id='topic+tau+2CrotCopula-method'></span><span id='topic+rho-methods'></span><span id='topic+rho+2CANY-method'></span><span id='topic+rho+2Ccopula-method'></span><span id='topic+rho+2CnormalCopula-method'></span><span id='topic+rho+2CtCopula-method'></span><span id='topic+rho+2CclaytonCopula-method'></span><span id='topic+rho+2CfrankCopula-method'></span><span id='topic+rho+2CgumbelCopula-method'></span><span id='topic+rho+2CamhCopula-method'></span><span id='topic+rho+2CfgmCopula-method'></span><span id='topic+rho+2CplackettCopula-method'></span><span id='topic+rho+2CmoCopula-method'></span><span id='topic+rho+2CgalambosCopula-method'></span><span id='topic+rho+2ChuslerReissCopula-method'></span><span id='topic+rho+2CindepCopula-method'></span><span id='topic+rho+2ClowfhCopula-method'></span><span id='topic+rho+2CupfhCopula-method'></span><span id='topic+rho+2CtawnCopula-method'></span><span id='topic+rho+2CtevCopula-method'></span><span id='topic+rho+2CevCopula-method'></span><span id='topic+rho+2Cacopula-method'></span><span id='topic+rho+2Cnacopula-method'></span><span id='topic+rho+2CrotCopula-method'></span><span id='topic+lambda-methods'></span><span id='topic+lambda+2CANY-method'></span><span id='topic+lambda+2Ccopula-method'></span><span id='topic+lambda+2CevCopula-method'></span><span id='topic+lambda+2CclaytonCopula-method'></span><span id='topic+lambda+2CfrankCopula-method'></span><span id='topic+lambda+2CgumbelCopula-method'></span><span id='topic+lambda+2CindepCopula-method'></span><span id='topic+lambda+2ClowfhCopula-method'></span><span id='topic+lambda+2CupfhCopula-method'></span><span id='topic+lambda+2CamhCopula-method'></span><span id='topic+lambda+2CjoeCopula-method'></span><span id='topic+lambda+2CplackettCopula-method'></span><span id='topic+lambda+2CmoCopula-method'></span><span id='topic+lambda+2CnormalCopula-method'></span><span id='topic+lambda+2CtCopula-method'></span><span id='topic+lambda+2Cacopula-method'></span><span id='topic+lambda+2Cnacopula-method'></span><span id='topic+lambda+2CrotCopula-method'></span><span id='topic+iTau-methods'></span><span id='topic+iTau+2CANY-method'></span><span id='topic+iTau+2Ccopula-method'></span><span id='topic+iTau+2CellipCopula-method'></span><span id='topic+iTau+2CnormalCopula-method'></span><span id='topic+iTau+2CtCopula-method'></span><span id='topic+iTau+2CarchmCopula-method'></span><span id='topic+iTau+2CamhCopula-method'></span><span id='topic+iTau+2CclaytonCopula-method'></span><span id='topic+iTau+2CfrankCopula-method'></span><span id='topic+iTau+2CgumbelCopula-method'></span><span id='topic+iTau+2CjoeCopula-method'></span><span id='topic+iTau+2CplackettCopula-method'></span><span id='topic+iTau+2CfgmCopula-method'></span><span id='topic+iTau+2CgalambosCopula-method'></span><span id='topic+iTau+2ChuslerReissCopula-method'></span><span id='topic+iTau+2CtawnCopula-method'></span><span id='topic+iTau+2CtevCopula-method'></span><span id='topic+iTau+2Cnacopula-method'></span><span id='topic+iTau+2Cacopula-method'></span><span id='topic+iTau+2CrotCopula-method'></span><span id='topic+iRho-methods'></span><span id='topic+iRho+2CANY-method'></span><span id='topic+iRho+2Ccopula-method'></span><span id='topic+iRho+2CellipCopula-method'></span><span id='topic+iRho+2CnormalCopula-method'></span><span id='topic+iRho+2CtCopula-method'></span><span id='topic+iRho+2CarchmCopula-method'></span><span id='topic+iRho+2CclaytonCopula-method'></span><span id='topic+iRho+2CfrankCopula-method'></span><span id='topic+iRho+2CgumbelCopula-method'></span><span id='topic+iRho+2CgalambosCopula-method'></span><span id='topic+iRho+2ChuslerReissCopula-method'></span><span id='topic+iRho+2CtawnCopula-method'></span><span id='topic+iRho+2CtevCopula-method'></span><span id='topic+iRho+2CplackettCopula-method'></span><span id='topic+iRho+2CfgmCopula-method'></span><span id='topic+iRho+2Cnacopula-method'></span><span id='topic+iRho+2CrotCopula-method'></span>

<h3>Description</h3>

<p>These functions compute Kendall's tau, Spearman's rho, and the tail
dependence index for <em>bivariate</em> copulas.  <code>iTau</code> and <code>iRho</code>,
sometimes called &ldquo;calibration&rdquo; functions are the inverses: they
determine (&ldquo;calibrate&rdquo;) the copula parameter (which must be
one-dimensional!) given the value of Kendall's tau or Spearman's rho.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tau (copula, ...)
rho (copula, ...)
lambda(copula, ...)
iTau (copula, tau, ...)
iRho (copula, rho, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assocMeasures_+3A_copula">copula</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>"<a href="#topic+copula-class">copula</a>"</code>
(or also <code>"<a href="#topic+acopula-class">acopula</a>"</code> or
<code>"<a href="#topic+nacopula-class">nacopula</a>"</code>; note however that some methods
may not be available for some copula families).</p>
</td></tr>
<tr><td><code id="assocMeasures_+3A_tau">tau</code></td>
<td>
<p> a numerical value of Kendall's tau in [-1, 1]. </p>
</td></tr>
<tr><td><code id="assocMeasures_+3A_rho">rho</code></td>
<td>
<p> a numerical value of Spearman's rho in [-1, 1]. </p>
</td></tr>
<tr><td><code id="assocMeasures_+3A_...">...</code></td>
<td>
<p> currently nothing. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calibration functions <code>iTau()</code> and <code>iRho()</code> in fact
return a moment estimate of the parameter for one-parameter copulas.
</p>
<p>When there are no closed-form expressions for Kendall's tau or
Spearman's rho, the calibration functions use numerical
approximation techniques (see the last reference).  For closed-form
expressions, see Frees and Valdez (1998).  For the t copula, the
calibration function based on Spearman's rho uses the corresponding
expression for the normal copula as an approximation.
</p>


<h3>References</h3>

<p>E.W. Frees and E.A. Valdez (1998)
Understanding relationships using copulas.
<em>North American Actuarial Journal</em> <b>2</b>, 1&ndash;25.
</p>
<p>Iwan Kojadinovic and Jun Yan (2010) 
Comparison of three semiparametric methods for estimating dependence
parameters in copula models.
<em>Insurance: Mathematics and Economics</em> <b>47</b>, 52&ndash;63.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+acopula-class">acopula</a></code> class objects have slots,
<code>tau</code>, <code>lambdaL</code>, and <code>lambdaU</code> providing functions for
<code>tau()</code>, and the two tail indices <code>lambda()</code>,
and slot <code>iTau</code> for <code>iTau()</code>, see the
examples and <code><a href="#topic+copGumbel">copGumbel</a></code>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gumbel.cop &lt;- gumbelCopula(3)
tau(gumbel.cop)
rho(gumbel.cop)
lambda(gumbel.cop)
iTau(joeCopula(), 0.5)
stopifnot(all.equal(tau(gumbel.cop), copGumbel@tau(3)),

          all.equal(lambda(gumbel.cop),
                    c(copGumbel@lambdaL(3), copGumbel@lambdaU(3)),
                    check.attributes=FALSE),

          all.equal(iTau (gumbel.cop, 0.681),
                    copGumbel@iTau(0.681))
)

## let us compute the sample versions
x &lt;- rCopula(200, gumbel.cop)
cor(x, method = "kendall")
cor(x, method = "spearman")
## compare with the true parameter value 3
iTau(gumbel.cop, cor(x, method="kendall" )[1,2])
iRho(gumbel.cop, cor(x, method="spearman")[1,2])
</code></pre>

<hr>
<h2 id='Bernoulli'>Compute Bernoulli Numbers</h2><span id='topic+Bernoulli'></span><span id='topic+Bernoulli.all'></span>

<h3>Description</h3>

<p>Compute the <code class="reqn">n</code>th Bernoulli number, or
generate all Bernoulli numbers up to the <code class="reqn">n</code>th,
using diverse <code>method</code>s, that is, algorithms.
</p>
<p><b>NOTE</b> the current default methods will be changed &ndash; to get
better accuracy!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bernoulli    (n, method = c("sumBin", "sumRamanujan", "asymptotic"),
              verbose = FALSE)
Bernoulli.all(n, method = c("A-T", "sumBin", "sumRamanujan", "asymptotic"),
              precBits = NULL, verbose = getOption("verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bernoulli_+3A_n">n</code></td>
<td>
<p>positive integer, indicating the index of the largest (and
last) of the Bernoulli numbers needed.</p>
</td></tr>
<tr><td><code id="Bernoulli_+3A_method">method</code></td>
<td>
<p>character string, specifying which method should be
applied. The default for <code>Bernoulli.all()</code>, <code>"A-T"</code>
stands for the Akiyama-Tanigawa algorithm
which is nice and simple but has bad numerical properties.  It can
however work with high precision &quot;mpfr&quot;-numbers, see <code>precBits</code>.
<code>"sumRamanujan"</code> is somewhat more efficient but not yet implemented.</p>
</td></tr>
<tr><td><code id="Bernoulli_+3A_precbits">precBits</code></td>
<td>
<p>currently only for <code>method = "A-T"</code> &ndash;
<code>NULL</code> or a positive integer indicating the precision of the
initial numbers in bits, using package <a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a>'s multiprecision
arithmetic.</p>
</td></tr>
<tr><td><code id="Bernoulli_+3A_verbose">verbose</code></td>
<td>
<p>(for <code>"A-T"</code>:) logical indicating if the
intermediate results of the algorithm should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>Bernoulli()</code>:</dt><dd><p>a number</p>
</dd>
<dt><code>Bernoulli.all()</code>:</dt><dd><p>a numeric vector of length n,
containing B(n)</p>
</dd>
</dl>



<h3>References</h3>

<p>Kaneko, Masanobu (2000)
The Akiyama-Tanigawa algorithm for Bernoulli numbers;
Journal of Integer Sequences <b>3</b>, article 00.2.9
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Eulerian">Eulerian</a></code>, <code><a href="#topic+Stirling1">Stirling1</a></code>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The example for the paper
MASS::fractions(Bernoulli.all(8, verbose=TRUE))

B10 &lt;- Bernoulli.all(10)
MASS::fractions(B10)

system.time(B50  &lt;- Bernoulli.all(50))#  {does not cache} -- still "no time"
system.time(B100 &lt;- Bernoulli.all(100))# still less than a milli second

## Using Bernoulli() is not much slower, but hopefully *more* accurate!
## Check first - TODO
system.time(B.1c &lt;- Bernoulli(100))# caches ..
system.time(B1c. &lt;- Bernoulli(100))# ==&gt; now much faster
stopifnot(identical(B.1c, B1c.))

if(FALSE)## reset the cache:
assign("Bern.tab", list(), envir = copula:::.nacopEnv)

## More experiments in the source of the copula package ../tests/Stirling-etc.R
</code></pre>

<hr>
<h2 id='beta.Blomqvist'>Sample and Population Version of Blomqvist's Beta for Archimedean Copulas</h2><span id='topic+beta.'></span><span id='topic+betan'></span><span id='topic+beta.hat'></span>

<h3>Description</h3>

<p>Compute the population (<code>beta.()</code>) and sample
(<code>betan()</code>) version of Blomqvist's beta for an Archimedean
copula.
</p>
<p>See the reference below for definitions and formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.(cop, theta, d, scaling=FALSE)
betan(u, scaling=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.Blomqvist_+3A_cop">cop</code></td>
<td>
<p>an Archimedean copula (of dimension <code class="reqn">d</code>) to be
estimated.</p>
</td></tr>
<tr><td><code id="beta.Blomqvist_+3A_theta">theta</code></td>
<td>
<p>copula parameter.</p>
</td></tr>
<tr><td><code id="beta.Blomqvist_+3A_d">d</code></td>
<td>
<p>dimension.</p>
</td></tr>
<tr><td><code id="beta.Blomqvist_+3A_scaling">scaling</code></td>
<td>
<p>logical, if true, the factors 2^(d-1)/(2^(d-1)-1) and
2^(1-d) in Blomqvist's beta are omitted.</p>
</td></tr>
<tr><td><code id="beta.Blomqvist_+3A_u">u</code></td>
<td>
<p>For <code>betan</code>: 	(<code class="reqn">n\times d</code>)-matrix of
d-dimensional observations distributed according to the copula.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>beta.</code>:</dt><dd><p>a number, being the population version of
Blomqvist's beta for the corresponding
Archimedean copula;</p>
</dd>
<dt><code>betan</code>:</dt><dd><p>a number, being the sample version of
Blomqvist's beta for the given data.</p>
</dd>
</dl>



<h3>References</h3>

<p>Schmid and Schmidt (2007),
Nonparametric inference on multivariate versions of Blomqvist's beta
and related measures of tail dependence,
<em>Metrika</em> <b>66</b>, 323&ndash;354.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+acopula-class">acopula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beta.(copGumbel, 2.5, d = 5)

d.set &lt;- c(2:6, 8, 10, 15, 20, 30)
cols &lt;- adjustcolor(colorRampPalette(c("red", "orange", "blue"),
                                     space = "Lab")(length(d.set)), 0.8)
## AMH:
for(i in seq_along(d.set))
   curve(Vectorize(beta.,"theta")(copAMH, x, d = d.set[i]), 0, .999999,
         main = "Blomqvist's beta(.) for  AMH",
         xlab = quote(theta), ylab = quote(beta(theta, AMH)),
         add = (i &gt; 1), lwd=2, col=cols[i])
mtext("NB:  d=2 and d=3 are the same")
legend("topleft", paste("d =",d.set), bty="n", lwd=2, col=cols)

## Gumbel:
for(i in seq_along(d.set))
   curve(Vectorize(beta.,"theta")(copGumbel, x, d = d.set[i]), 1, 10,
         main = "Blomqvist's beta(.) for  Gumbel",
         xlab = quote(theta), ylab = quote(beta(theta, Gumbel)),
         add=(i &gt; 1), lwd=2, col=cols[i])
legend("bottomright", paste("d =",d.set), bty="n", lwd=2, col=cols)

## Clayton:
for(i in seq_along(d.set))
   curve(Vectorize(beta.,"theta")(copClayton, x, d = d.set[i]), 1e-5, 10,
         main = "Blomqvist's beta(.) for  Clayton",
         xlab = quote(theta), ylab = quote(beta(theta, Gumbel)),
         add=(i &gt; 1), lwd=2, col=cols[i])
legend("bottomright", paste("d =",d.set), bty="n", lwd=2, col=cols)

## Joe:
for(i in seq_along(d.set))
   curve(Vectorize(beta.,"theta")(copJoe, x, d = d.set[i]), 1, 10,
         main = "Blomqvist's beta(.) for  Joe",
         xlab = quote(theta), ylab = quote(beta(theta, Gumbel)),
         add=(i &gt; 1), lwd=2, col=cols[i])
legend("bottomright", paste("d =",d.set), bty="n", lwd=2, col=cols)

## Frank:
for(i in seq_along(d.set))
   curve(Vectorize(beta.,"theta")(copFrank, x, d = d.set[i]), 1e-5, 50,
         main = "Blomqvist's beta(.) for  Frank",
         xlab = quote(theta), ylab = quote(beta(theta, Gumbel)),
         add=(i &gt; 1), lwd=2, col=cols[i])
legend("bottomright", paste("d =",d.set), bty="n", lwd=2, col=cols)

## Shows the numeric problems:
curve(Vectorize(beta.,"theta")(copFrank, x, d = 29), 35, 42, col="violet")
</code></pre>

<hr>
<h2 id='cCopula'>Conditional Distributions and Their Inverses from Copulas</h2><span id='topic+cacopula'></span><span id='topic+rtrafo'></span><span id='topic+cCopula'></span>

<h3>Description</h3>

<p>Compute the conditional distribution function
<code class="reqn">C(u_d\,|\,u_1,\dots, u_{d-1})</code>
of <code class="reqn">u_d</code> given <code class="reqn">u_1,\dots,u_{d-1}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
cCopula(u, copula, indices = 1:dim(copula), inverse = FALSE,
        log = FALSE, drop = FALSE, ...)

## Deprecated (use cCopula() instead):
rtrafo(u, copula, indices = 1:dim(copula), inverse = FALSE, log = FALSE)
cacopula(u, cop, n.MC = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cCopula_+3A_u">u</code></td>
<td>
<p>data <code><a href="base.html#topic+matrix">matrix</a></code> in <code class="reqn">[0,1]^(n, d)</code> of
<code class="reqn">U(0,1)^d</code> samples if <code>inverse = FALSE</code>
and (pseudo-/copula-)observations if <code>inverse = TRUE</code>.</p>
</td></tr>
<tr><td><code id="cCopula_+3A_copula">copula</code>, <code id="cCopula_+3A_cop">cop</code></td>
<td>
<p>copula, i.e., an object of class
<code>"<a href="#topic+Copula-class">Copula</a>"</code> with specified parameters; currently,
the conditional distribution is only provided for Archimedean and
elliptical copulas.</p>
</td></tr>
<tr><td><code id="cCopula_+3A_indices">indices</code></td>
<td>
<p>vector of indices <code class="reqn">j</code> (in <code class="reqn">\{1,\dots,d\}</code>
(<code class="reqn">d =</code> copula dimension); unique; sorted in increasing order) for which
<code class="reqn">C_{j|1,\dots,j-1}(u_j\,|\,u_1,\dots,u_{j-1})</code> (or, if
<code>inverse = TRUE</code>,
<code class="reqn">C^-_{j|1,\dots,j-1}(u_j\,|\,u_1,\dots,u_{j-1})</code>)
is computed.</p>
</td></tr>
<tr><td><code id="cCopula_+3A_inverse">inverse</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether the inverse
<code class="reqn">C^-_{j|1,\dots,j-1}(u_j\,|\,u_1,\dots,u_{j-1})</code>
is returned.</p>
</td></tr>
<tr><td><code id="cCopula_+3A_n.mc">n.MC</code></td>
<td>
<p>integer Monte Carlo sample size; for Archimedean copulas only,
used if positive.</p>
</td></tr>
<tr><td><code id="cCopula_+3A_log">log</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> indicating whether the logarithmic
values are returned.</p>
</td></tr>
<tr><td><code id="cCopula_+3A_drop">drop</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> indicating whether a vector should
be returned (instead of a 1&ndash;row matrix) when <code>n</code> is 1.</p>
</td></tr>
<tr><td><code id="cCopula_+3A_...">...</code></td>
<td>
<p>additional arguments (currently only used if
<code>inverse = TRUE</code> in which case they are passed on to the
underlying <code><a href="stats.html#topic+uniroot">uniroot</a>()</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default and if fed with a sample of the corresponding copula,
<code>cCopula()</code> computes the Rosenblatt
transform; see Rosenblatt (1952).  The involved high-order derivatives
for Archimedean copulas were derived in Hofert et al. (2012).
</p>
<p><em>Sampling</em>, that is, random number generation,
can be achieved by using <code>inverse=TRUE</code>.  In this case,
the inverse Rosenblatt transformation is used, which, for sampling
purposes, is also known as <em>conditional distribution method</em>.
Note that, for Archimedean copulas not being Clayton, this can be slow
as it involves numerical root finding in each (but the first) component.
</p>


<h3>Value</h3>

<p>An <code class="reqn">(n, k)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> (unless <code>n == 1</code> and
<code>drop</code> is true, where a <code class="reqn">k</code>-vector is returned) where <code class="reqn">k</code>
is the length of <code>indices</code>.  This matrix contains the conditional
copula function values
<code class="reqn">C_{j|1,\dots,j-1}(u_j\,|\,u_1,\dots,u_{j-1})</code>
or, if <code>inverse = TRUE</code>, their inverses
<code class="reqn">C^-_{j|1,\dots,j-1}(u_j\,|\,u_1,\dots,u_{j-1})</code>
for all <code class="reqn">j</code> in <code>indices</code>.
</p>


<h3>Note</h3>

<p>For some (but not all) families, this function also makes sense on the
boundaries (if the corresponding limits can be computed).
</p>


<h3>References</h3>

<p>Genest, C., Rémillard, B., and Beaudoin, D. (2009).
Goodness-of-fit tests for copulas: A review and a power study.
<em>Insurance: Mathematics and Economics</em> <b>44</b>, 199&ndash;213.
</p>
<p>Rosenblatt, M. (1952).
Remarks on a Multivariate Transformation,
<em>The Annals of Mathematical Statistics</em> <b>23</b>, 3, 470&ndash;472.
</p>
<p>Hofert, M., Mächler, M., and McNeil, A. J. (2012).
Likelihood inference for Archimedean copulas in high dimensions
under known margins. <em>Journal of Multivariate Analysis</em>
<b>110</b>, 133&ndash;150.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+htrafo">htrafo</a></code>; <code><a href="#topic+acopula-families">acopula-families</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1) Sampling from a conditional distribution of a Clayton copula given u_1

## Define the copula
tau &lt;- 0.5
theta &lt;- iTau(claytonCopula(), tau = tau)
d &lt;- 2
cc &lt;- claytonCopula(theta, dim = d)
n &lt;- 1000
set.seed(271)

## A small u_1
u1 &lt;- 0.05
U &lt;- cCopula(cbind(u1, runif(n)), copula = cc, inverse = TRUE)
plot(U[,2], ylab = quote(U[2]))

## A large u_1
u1 &lt;- 0.95
U &lt;- cCopula(cbind(u1, runif(n)), copula = cc, inverse = TRUE)
plot(U[,2], ylab = quote(U[2]))


## 2) Sample via conditional distribution method and then apply the
##    Rosenblatt transform
##    Note: We choose the numerically more involved (and thus slower)
##          Gumbel case here

## Define the copula
tau &lt;- 0.5
theta &lt;- iTau(gumbelCopula(), tau = tau)
d &lt;- 5
gc &lt;- gumbelCopula(theta, dim = d)
n &lt;- 200
set.seed(271)
U. &lt;- matrix(runif(n*d), ncol = d) # U(0,1)^d


## Transform to Gumbel sample via conditional distribution method
U &lt;- cCopula(U., copula = gc, inverse = TRUE) # slow for ACs except Clayton
splom2(U) # scatter-plot matrix copula sample

## Rosenblatt transform back to U(0,1)^d (as a check)
U. &lt;- cCopula(U, copula = gc)
splom2(U.) # U(0,1)^d again


## 3) cCopula() for elliptical copulas

tau &lt;- 0.5
theta &lt;- iTau(claytonCopula(), tau = tau)
d &lt;- 5
cc &lt;- claytonCopula(theta, dim = d)
set.seed(271)
n &lt;- 1000
U &lt;- rCopula(n, copula = cc)
X &lt;- qnorm(U) # X now follows a meta-Clayton model with N(0,1) marginals
U &lt;- pobs(X) # build pseudo-observations

fN &lt;- fitCopula(normalCopula(dim = d), data = U) # fit a Gauss copula
U.RN &lt;- cCopula(U, copula = fN@copula)
splom2(U.RN, cex = 0.2) # visible but not so clearly

f.t &lt;- fitCopula(tCopula(dim = d), U)
U.Rt &lt;- cCopula(U, copula = f.t@copula) # transform with a fitted t copula
splom2(U.Rt, cex = 0.2) # still visible but not so clear

## Inverse (and check consistency)
U.N &lt;- cCopula(U.RN, copula = fN @copula, inverse = TRUE)
U.t &lt;- cCopula(U.Rt, copula = f.t@copula, inverse = TRUE)

tol &lt;- 1e-14
stopifnot(
    all.equal(U, U.N),
    all.equal(U, U.t),
    all.equal(log(U.RN),
              cCopula(U, copula = fN @copula, log = TRUE), tolerance = tol),
    all.equal(log(U.Rt),
              cCopula(U, copula = f.t@copula, log = TRUE), tolerance = tol)
)

## 4) cCopula() for a more sophisticated mixture copula (bivariate case only!)

tau &lt;- 0.5
cc &lt;- claytonCopula(iTau(claytonCopula(), tau = tau)) # first mixture component
tc &lt;- tCopula(iTau(tCopula(), tau = tau), df = 3) # t_3 copula
tc90 &lt;- rotCopula(tc, flip = c(TRUE, FALSE)) # t copula rotated by 90 degrees
wts &lt;- c(1/2, 1/2) # mixture weights
mc &lt;- mixCopula(list(cc, tc90), w = wts) # mixture copula with one copula rotated

set.seed(271)
U &lt;- rCopula(n, copula = mc)
U. &lt;- cCopula(U, copula = mc) # Rosenblatt transform back to U(0,1)^2 (as a check)
plot(U., xlab = quote(U*"'"[1]), ylab = quote(U*"'"[2])) # check for uniformity
</code></pre>

<hr>
<h2 id='cloud2-methods'>Cloud Plot Methods ('cloud2') in Package 'copula'</h2><span id='topic+cloud2'></span><span id='topic+cloud2-methods'></span><span id='topic+cloud2+2Cmatrix-method'></span><span id='topic+cloud2+2Cdata.frame-method'></span><span id='topic+cloud2+2CCopula-method'></span><span id='topic+cloud2+2Cmvdc-method'></span>

<h3>Description</h3>

<p>Function and Methods <code>cloud2()</code> to draw (<a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>)
<code><a href="lattice.html#topic+cloud">cloud</a></code> plots of two-dimensional distributions from
package <span class="pkg">copula</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
cloud2(x,
      xlim = range(x[,1], finite = TRUE),
      ylim = range(x[,2], finite = TRUE),
      zlim = range(x[,3], finite = TRUE),
      xlab = NULL, ylab = NULL, zlab = NULL,
      scales = list(arrows = FALSE, col = "black"),
      par.settings = standard.theme(color = FALSE), ...)
## S4 method for signature 'data.frame'
cloud2(x,
      xlim = range(x[,1], finite = TRUE),
      ylim = range(x[,2], finite = TRUE),
      zlim = range(x[,3], finite = TRUE),
      xlab = NULL, ylab = NULL, zlab = NULL,
      scales = list(arrows = FALSE, col = "black"),
      par.settings = standard.theme(color = FALSE), ...)
## S4 method for signature 'Copula'
cloud2(x, n,
      xlim = 0:1, ylim = 0:1, zlim = 0:1,
      xlab = quote(U[1]), ylab = quote(U[2]), zlab = quote(U[3]), ...)
## S4 method for signature 'mvdc'
cloud2(x, n,
      xlim = NULL, ylim = NULL, zlim = NULL,
      xlab = quote(X[1]), ylab = quote(X[2]), zlab = quote(X[3]), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cloud2-methods_+3A_x">x</code></td>
<td>
<p>a <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code>,
<code>"<a href="methods.html#topic+data.frame-class">data.frame</a>"</code>, <code>"<a href="#topic+Copula-class">Copula</a>"</code> or
a <code>"<a href="#topic+mvdc-class">mvdc</a>"</code> object.</p>
</td></tr>
<tr><td><code id="cloud2-methods_+3A_xlim">xlim</code>, <code id="cloud2-methods_+3A_ylim">ylim</code>, <code id="cloud2-methods_+3A_zlim">zlim</code></td>
<td>
<p>the x-, y- and z-axis limits.</p>
</td></tr>
<tr><td><code id="cloud2-methods_+3A_xlab">xlab</code>, <code id="cloud2-methods_+3A_ylab">ylab</code>, <code id="cloud2-methods_+3A_zlab">zlab</code></td>
<td>
<p>the x-, y- and z-axis labels.</p>
</td></tr>
<tr><td><code id="cloud2-methods_+3A_scales">scales</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> determining how the axes are drawn;
see <code><a href="lattice.html#topic+cloud">cloud</a>()</code>.</p>
</td></tr>
<tr><td><code id="cloud2-methods_+3A_par.settings">par.settings</code></td>
<td>
<p>see <code><a href="lattice.html#topic+cloud">cloud</a>()</code>.</p>
</td></tr>
<tr><td><code id="cloud2-methods_+3A_n">n</code></td>
<td>
<p>when <code>x</code> is not matrix-like: The sample size of the
random sample drawn from <code>x</code>.</p>
</td></tr>
<tr><td><code id="cloud2-methods_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the underlying
<code><a href="lattice.html#topic+cloud">cloud</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &ldquo;trellis&rdquo; as returned by <code><a href="lattice.html#topic+cloud">cloud</a>()</code>.
</p>


<h3>Methods</h3>

<p>Cloud plots for objects of class <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code> ,
<code>"<a href="methods.html#topic+data.frame-class">data.frame</a>"</code>, <code>"<a href="#topic+Copula-class">Copula</a>"</code> or
<code>"<a href="#topic+mvdc-class">mvdc</a>"</code>.
</p>


<h3>See Also</h3>

<p>The <span class="pkg">lattice</span>-based <code><a href="#topic+splom2-methods">splom2-methods</a></code> for data, and
<code><a href="#topic+wireframe2-methods">wireframe2-methods</a></code> and
<code><a href="#topic+contourplot2-methods">contourplot2-methods</a></code> for functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For 'matrix' objects
cop &lt;- gumbelCopula(2, dim = 3)
n &lt;- 1000
set.seed(271)
U &lt;- rCopula(n, copula = cop)
cloud2(U, xlab = quote(U[1]), ylab = quote(U[2]), zlab = quote(U[3]))

## For 'Copula' objects
set.seed(271)
cloud2(cop, n = n) # same as above

## For 'mvdc' objects
mvNN &lt;- mvdc(cop, c("norm", "norm", "exp"),
             list(list(mean = 0, sd = 1), list(mean = 1), list(rate = 2)))
cloud2(mvNN, n = n)
</code></pre>

<hr>
<h2 id='coeffG'>Coefficients of Polynomial used for Gumbel Copula</h2><span id='topic+coeffG'></span>

<h3>Description</h3>

<p>Compute the coefficients <code class="reqn">a_{d,k}(\theta)</code> involved in the
generator (psi) derivatives and the copula density of Gumbel copulas.
</p>
<p>For non-small dimensions <code class="reqn">d</code>, these are numerically challenging to
compute accurately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeffG(d, alpha,
       method = c("sort", "horner", "direct", "dsumSibuya",
                  paste("dsSib", eval(formals(dsumSibuya)$method), sep = ".")),
       log = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coeffG_+3A_d">d</code></td>
<td>
<p>number of coefficients, (the copula dimension), d &gt;= 1.</p>
</td></tr>
<tr><td><code id="coeffG_+3A_alpha">alpha</code></td>
<td>
<p>parameter <code class="reqn">1/\theta</code> in <code class="reqn">(0,1]</code>; you may use
<code><a href="Rmpfr.html#topic+mpfr">mpfr</a>(alph, precBits = &lt;n_prec&gt;)</code>
for higher precision methods (<code>"Rmpfr*"</code>) from package
<a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a>.</p>
</td></tr>
<tr><td><code id="coeffG_+3A_method">method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string, one of
</p>

<dl>
<dt><code>"sort"</code>:</dt><dd><p>compute coefficients via <code class="reqn">exp(log())</code>
pulling out the maximum, and sort.</p>
</dd>
<dt><code>"horner"</code>:</dt><dd><p>uses polynomial evaluation, our internal
<code>polynEval()</code>.</p>
</dd>
<dt><code>"direct"</code>:</dt><dd><p>brute force approach.</p>
</dd>
<dt><code>"dsSib.&lt;FOO&gt;"</code>:</dt><dd><p>uses <code><a href="#topic+dsumSibuya">dsumSibuya</a>(..., method= "&lt;FOO&gt;")</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="coeffG_+3A_log">log</code></td>
<td>
<p>logical determining if the logarithm (<code><a href="base.html#topic+log">log</a></code>) is
to be returned.</p>
</td></tr>
<tr><td><code id="coeffG_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if some information should be shown,
currently for <code>method == "sort"</code> only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of length <code>d</code>, of values
</p>
<p style="text-align: center;"><code class="reqn">% latex
    a_k(\theta, d) = (-1)^{d-k}\sum_{j=k}^d \alpha^j * s(d,j) * S(j,k),
    k \in \{1,\ldots,d\}.</code>
</p>



<h3>Note</h3>

<p>There are still known numerical problems (with non-&quot;Rmpfr&quot; methods; and
those are slow), e.g., for d=100,
alpha=0.8 and  <code class="reqn">sign(s(n,k)) = (-1)^{n-k}</code>.
</p>
<p>As a consequence, the <code>method</code>s and its defaults may change in
the future, and so the exact implementation of <code>coeffG()</code> is
still considered somewhat experimental.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a.k  &lt;- coeffG(16, 0.55)
plot(a.k, xlab = quote(k), ylab = quote(a[k]),
     main = "coeffG(16, 0.55)", log = "y", type = "o", col = 2)
a.kH &lt;- coeffG(16, 0.55, method = "horner")
stopifnot(all.equal(a.k, a.kH, tol = 1e-11))# 1.10e-13 (64-bit Lnx, nb-mm4)
</code></pre>

<hr>
<h2 id='contour-methods'>Methods for Contour Plots in Package 'copula'</h2><span id='topic+contour-methods'></span><span id='topic+contour+2CindepCopula-method'></span><span id='topic+contour+2CCopula-method'></span><span id='topic+contour+2Cmvdc-method'></span>

<h3>Description</h3>

<p>Methods for function <code><a href="graphics.html#topic+contour">contour</a></code> to draw contour lines aka a
level plot for objects from package <span class="pkg">copula</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'Copula'
contour(x, FUN,
                   n.grid = 26, delta = 0,
                   xlab = quote(u[1]), ylab = quote(u[2]),
                   box01 = TRUE, ...)
## S4 method for signature 'mvdc'
contour(x, FUN, xlim, ylim, n.grid = 26,
                   xlab = quote(x[1]), ylab = quote(x[2]),
		   box01 = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour-methods_+3A_x">x</code></td>
<td>
<p>a <code>"<a href="#topic+Copula-class">Copula</a>"</code> or
a <code>"<a href="#topic+mvdc-class">mvdc</a>"</code> object.</p>
</td></tr>
<tr><td><code id="contour-methods_+3A_fun">FUN</code></td>
<td>
<p>the <code><a href="base.html#topic+function">function</a></code> to be plotted; typically
<code><a href="#topic+dCopula">dCopula</a></code> or <code><a href="#topic+pCopula">pCopula</a></code>.</p>
</td></tr>
<tr><td><code id="contour-methods_+3A_n.grid">n.grid</code></td>
<td>
<p>the number of grid points used in each dimension.  This
can be a vector of length two, giving the number of grid points used
in x- and y-direction, respectively; the function <code>FUN</code> will be
evaluated on the corresponding (x,y)-grid.</p>
</td></tr>
<tr><td><code id="contour-methods_+3A_delta">delta</code></td>
<td>
<p>a small number in <code class="reqn">[0, \frac 1 2)</code>
influencing the evaluation boundaries. The x- and y- vectors will
have the range <code>[0+delta, 1-delta]</code>, the default being <code>[0,1]</code>.</p>
</td></tr>
<tr><td><code id="contour-methods_+3A_xlab">xlab</code>, <code id="contour-methods_+3A_ylab">ylab</code></td>
<td>
<p>the x-axis and y-axis labels.</p>
</td></tr>
<tr><td><code id="contour-methods_+3A_xlim">xlim</code>, <code id="contour-methods_+3A_ylim">ylim</code></td>
<td>
<p>the <code><a href="base.html#topic+range">range</a></code> of the x and
y variables, respectively.</p>
</td></tr>
<tr><td><code id="contour-methods_+3A_box01">box01</code></td>
<td>
<p>a logical specifying if a faint rectangle should be drawn
on the boundary of <code class="reqn">[0,1]^2</code> (often useful for copulas, but
typically <em>not</em> for general multivariate distributions
(<code>"mvdc"</code>)).</p>
</td></tr>
<tr><td><code id="contour-methods_+3A_...">...</code></td>
<td>
<p>further arguments for (the default method of)
<code><a href="graphics.html#topic+contour">contour</a>()</code>, e.g., <code>nlevels</code>, <code>levels</code>, etc.</p>
</td></tr>
</table>


<h3>Methods</h3>

<p>Contour lines are drawn for <code>"<a href="#topic+Copula-class">Copula</a>"</code> or
<code>"<a href="#topic+mvdc-class">mvdc</a>"</code> objects, see <code>x</code> in the
<em>Arguments</em> section.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+persp-methods">persp-methods</a></code> for &ldquo;perspective&rdquo; aka
&ldquo;3D&rdquo; plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>contour(frankCopula(-0.8), dCopula)
contour(frankCopula(-0.8), dCopula, delta=1e-6)
contour(frankCopula(-1.2), pCopula)
contour(claytonCopula(2), pCopula)

## the Gumbel copula density is "extreme"
## --&gt; use fine grid (and enough levels):
r &lt;- contour(gumbelCopula(3), dCopula, n=200, nlevels=100)
range(r$z)# [0, 125.912]
## Now superimpose contours of three resolutions:
contour(r, levels = seq(1, max(r$z), by=2), lwd=1.5)
contour(r, levels = (1:13)/2, add=TRUE, col=adjustcolor(1,3/4), lty=2)
contour(r, levels = (1:13)/4, add=TRUE, col=adjustcolor(2,1/2),
        lty=3, lwd=3/4)

x &lt;- mvdc(gumbelCopula(3), c("norm", "norm"),
          list(list(mean = 0, sd =1), list(mean = 1)))
contour(x, dMvdc, xlim=c(-2, 2), ylim=c(-1, 3))
contour(x, pMvdc, xlim=c(-2, 2), ylim=c(-1, 3))
</code></pre>

<hr>
<h2 id='contourplot2-methods'>Contour Plot  Methods 'contourplot2' in Package 'copula'</h2><span id='topic+contourplot2'></span><span id='topic+contourplot2-methods'></span><span id='topic+contourplot2+2Cmatrix-method'></span><span id='topic+contourplot2+2Cdata.frame-method'></span><span id='topic+contourplot2+2CCopula-method'></span><span id='topic+contourplot2+2Cmvdc-method'></span>

<h3>Description</h3>

<p>Methods for <code>contourplot2()</code>, a version of
<code><a href="lattice.html#topic+contourplot">contourplot</a>()</code> from <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>, to draw
contour plots of two dimensional distributions from package <span class="pkg">copula</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## NB: The 'matrix' and 'data.frame' methods are identical - documenting the former
## S4 method for signature 'matrix'
contourplot2(x, aspect = 1,
      xlim = range(x[,1], finite = TRUE),
      ylim = range(x[,2], finite = TRUE),
      xlab = NULL, ylab = NULL,
      cuts = 16, labels = !region, pretty = !labels,
      scales = list(alternating = c(1,1), tck = c(1,0)),
      region = TRUE, ...,
      col.regions = gray(seq(0.4, 1, length.out = max(100, 4*cuts))))

## S4 method for signature 'Copula'
contourplot2(x, FUN, n.grid = 26, delta = 0,
      xlim = 0:1, ylim = 0:1,
      xlab = quote(u[1]), ylab = quote(u[2]), ...)
## S4 method for signature 'mvdc'
contourplot2(x, FUN, n.grid = 26, xlim, ylim,
      xlab = quote(x[1]), ylab = quote(x[2]), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contourplot2-methods_+3A_x">x</code></td>
<td>
<p>a <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code>,
<code>"<a href="methods.html#topic+data.frame-class">data.frame</a>"</code>, <code>"<a href="#topic+Copula-class">Copula</a>"</code> or
a <code>"<a href="#topic+mvdc-class">mvdc</a>"</code> object.</p>
</td></tr>
<tr><td><code id="contourplot2-methods_+3A_aspect">aspect</code></td>
<td>
<p>the aspect ratio.</p>
</td></tr>
<tr><td><code id="contourplot2-methods_+3A_xlim">xlim</code>, <code id="contourplot2-methods_+3A_ylim">ylim</code></td>
<td>
<p>the x- and y-axis limits.</p>
</td></tr>
<tr><td><code id="contourplot2-methods_+3A_xlab">xlab</code>, <code id="contourplot2-methods_+3A_ylab">ylab</code></td>
<td>
<p>the x- and y-axis labels. If at least one is
<code>NULL</code>, useful <code>xlab</code> and <code>ylab</code> are determined
automatically; the behavior depends on the class of <code>x</code>.</p>
</td></tr>
<tr><td><code id="contourplot2-methods_+3A_cuts">cuts</code></td>
<td>
<p>the number of levels; see <code><a href="lattice.html#topic+contourplot">contourplot</a>()</code>.
Note that specifying <code>useRaster = TRUE</code> is often considerably
more efficient notably for larger values of <code>cuts</code>.</p>
</td></tr>
<tr><td><code id="contourplot2-methods_+3A_labels">labels</code>, <code id="contourplot2-methods_+3A_pretty">pretty</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>s indicating whether the contour
lines are labeled and whether pretty labels are enforced; in
<span class="pkg">copula</span> versions before <code>0.999-18</code>, implicitly
<code>pretty = TRUE</code> was used (giving <b>un</b>equal z-cut
spacing), see <code><a href="lattice.html#topic+contourplot">contourplot</a>()</code>.</p>
</td></tr>
<tr><td><code id="contourplot2-methods_+3A_scales">scales</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> determining how the axes are drawn;
see <code><a href="lattice.html#topic+contourplot">contourplot</a>()</code>.</p>
</td></tr>
<tr><td><code id="contourplot2-methods_+3A_region">region</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> indicating whether regions
between contour lines should be filled as in a level plot; see
<code><a href="lattice.html#topic+contourplot">contourplot</a>()</code>.</p>
</td></tr>
<tr><td><code id="contourplot2-methods_+3A_col.regions">col.regions</code></td>
<td>
<p>the colors of the regions if <code>region = TRUE</code>;
see <code><a href="lattice.html#topic+contourplot">contourplot</a>()</code>.</p>
</td></tr>
<tr><td><code id="contourplot2-methods_+3A_fun">FUN</code></td>
<td>
<p>the <code><a href="base.html#topic+function">function</a></code> to be plotted; typically
<code><a href="#topic+dCopula">dCopula</a></code> or <code><a href="#topic+pCopula">pCopula</a></code>.</p>
</td></tr>
<tr><td><code id="contourplot2-methods_+3A_n.grid">n.grid</code></td>
<td>
<p>the number of grid points used in each dimension.  This
can be a vector of length two, giving the number of grid points used
in x- and y-direction, respectively; the function <code>FUN</code> will be
evaluated on the corresponding (x,y)-grid.</p>
</td></tr>
<tr><td><code id="contourplot2-methods_+3A_delta">delta</code></td>
<td>
<p>a small number in <code class="reqn">[0, \frac 1 2)</code>
influencing the evaluation boundaries. The x- and y- vectors will
have the range <code>[0+delta, 1-delta]</code>, the default being <code>[0,1]</code>.</p>
</td></tr>
<tr><td><code id="contourplot2-methods_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the underlying
<code><a href="lattice.html#topic+contourplot">contourplot</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &ldquo;trellis&rdquo; as returned by <code><a href="lattice.html#topic+contourplot">contourplot</a>()</code>.
</p>


<h3>Methods</h3>

<p>Contourplot plots for objects of class <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code> ,
<code>"<a href="methods.html#topic+data.frame-class">data.frame</a>"</code>, <code>"<a href="#topic+Copula-class">Copula</a>"</code> or
<code>"<a href="#topic+mvdc-class">mvdc</a>"</code>.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+contour-methods">contour-methods</a></code> for drawing perspective plots via base graphics.
</p>
<p>The <span class="pkg">lattice</span>-based <code><a href="#topic+wireframe2-methods">wireframe2-methods</a></code> for functions,
and <code><a href="#topic+cloud2-methods">cloud2-methods</a></code> and <code><a href="#topic+splom2-methods">splom2-methods</a></code> for data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For 'matrix' objects
## The Frechet--Hoeffding bounds W and M
n.grid &lt;- 26
u &lt;- seq(0, 1, length.out = n.grid)
grid &lt;- expand.grid("u[1]" = u, "u[2]" = u)
W &lt;- function(u) pmax(0, rowSums(u)-1) # lower bound W
M &lt;- function(u) apply(u, 1, min) # upper bound M
x.W &lt;- cbind(grid, "W(u[1],u[2])" = W(grid)) # evaluate W on 'grid'
x.M &lt;- cbind(grid, "M(u[1],u[2])" = M(grid)) # evaluate M on 'grid'
contourplot2(x.W) # contour plot of W
contourplot2(x.M) # contour plot of M

## For 'Copula' objects
cop &lt;- frankCopula(-4)
contourplot2(cop, pCopula) # the copula
contourplot2(cop, pCopula, xlab = "x", ylab = "y") # adjusting the labels
contourplot2(cop, dCopula) # the density

## For 'mvdc' objects
mvNN &lt;- mvdc(gumbelCopula(3), c("norm", "norm"),
             list(list(mean = 0, sd = 1), list(mean = 1)))
xl &lt;- c(-2, 2)
yl &lt;- c(-1, 3)
contourplot2(mvNN, FUN = dMvdc, xlim = xl, ylim = yl, contour = FALSE)
contourplot2(mvNN, FUN = dMvdc, xlim = xl, ylim = yl)
contourplot2(mvNN, FUN = dMvdc, xlim = xl, ylim = yl, region = FALSE, labels = FALSE)
contourplot2(mvNN, FUN = dMvdc, xlim = xl, ylim = yl, region = FALSE)
contourplot2(mvNN, FUN = dMvdc, xlim = xl, ylim = yl,
             col.regions = colorRampPalette(c("royalblue3", "maroon3"), space="Lab"))
</code></pre>

<hr>
<h2 id='copFamilies'>Specific Archimedean Copula Families (&quot;acopula&quot; Objects)</h2><span id='topic+acopula-families'></span><span id='topic+copAMH'></span><span id='topic+copClayton'></span><span id='topic+copFrank'></span><span id='topic+copGumbel'></span><span id='topic+copJoe'></span>

<h3>Description</h3>

<p>Specific Archimedean families (<code>"<a href="#topic+acopula-class">acopula</a>"</code> objects)
implemented in the package <span class="pkg">copula</span>.
</p>
<p>These families are &ldquo;classical&rdquo; as from p. 116 of Nelsen (2007).
More specifially, see Table 1 of Hofert (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copAMH
copClayton
copFrank
copGumbel
copJoe
</code></pre>


<h3>Details</h3>

<p>All these are objects of the formal class <code>"<a href="#topic+acopula-class">acopula</a>"</code>.
</p>

<dl>
<dt><code>copAMH</code>:</dt><dd><p>Archimedean family of Ali-Mikhail-Haq with
parametric generator
</p>
<p style="text-align: center;"><code class="reqn">\psi(t)=(1-\theta)/(\exp(t)-\theta),\	t\in[0,\infty],
      </code>
</p>

<p>with <code class="reqn">\theta\in[0,1)</code>.  The range of
admissible Kendall's tau is <code class="reqn">[0,1/3)</code>. 
</p>
<p>Note that the lower and upper tail-dependence coefficients are
both zero, that is, this copula family does not allow for tail dependence.</p>
</dd>
<dt><code>copClayton</code>:</dt><dd><p>Archimedean family of Clayton with
parametric generator
</p>
<p style="text-align: center;"><code class="reqn">\psi(t)=(1+t)^{-1/\theta},\ t\in[0,\infty],</code>
</p>

<p>with <code class="reqn">\theta\in(0,\infty)</code>.  The range of
admissible Kendall's tau, as well as that of the lower
tail-dependence coefficient, is (0,1).  For dimension <code class="reqn">d = 2</code>,
<code class="reqn">\theta\in(-1,\infty)</code> is admissible where
negative <code class="reqn">\theta</code> allow negative Kendall's taus.
Note that this copula does not allow for upper tail dependence.</p>
</dd>
<dt><code>copFrank</code>:</dt><dd><p>Archimedean family of Frank with parametric
generator
</p>
<p style="text-align: center;"><code class="reqn">-\log(1-(1-e^{-\theta})\exp(-t))/\theta,\ t\in[0,\infty]</code>
</p>

<p>with <code class="reqn">\theta\in(0,\infty)</code>.  The range of
admissible Kendall's tau is (0,1).  Note that this copula family
does not allow for tail dependence.</p>
</dd>
<dt><code>copGumbel</code>:</dt><dd><p>Archimedean family of Gumbel with
parametric generator
</p>
<p style="text-align: center;"><code class="reqn">\exp(-t^{1/\theta}),\ t\in[0,\infty]</code>
</p>

<p>with
<code class="reqn">\theta\in[1,\infty)</code>.  The range of
admissible Kendall's tau, as well as that of the upper
tail-dependence coefficient, is [0,1).  Note that this copula does
not allow for lower tail dependence.</p>
</dd>
<dt><code>copJoe</code>:</dt><dd><p>Archimedean family of Joe with parametric
generator
</p>
<p style="text-align: center;"><code class="reqn">1-(1-\exp(-t))^{1/\theta},\ t\in[0,\infty]</code>
</p>

<p>with <code class="reqn">\theta\in[1,\infty)</code>.  The range of
admissible Kendall's tau, as well as that of the upper
tail-dependence coefficient, is [0,1).  Note that this copula does
not allow for lower tail dependence.</p>
</dd>
</dl>

<p>Note that staying within one of these Archimedean families, all of
them can be nested if two (generic) generator parameters
<code class="reqn">\theta_0</code>, <code class="reqn">\theta_1</code> satisfy
<code class="reqn">\theta_0\le\theta_1</code>.
</p>


<h3>Value</h3>

<p>A <code>"<a href="#topic+acopula-class">acopula</a>"</code> object.
</p>


<h3>References</h3>

<p>Nelsen, R. B. (2007).
<em>An Introduction to Copulas</em> (2nd ed.).
Springer.
</p>
<p>Hofert, M. (2010).
<em>Sampling Nested Archimedean Copulas with Applications to CDO Pricing</em>.
Suedwestdeutscher Verlag fuer Hochschulschriften AG &amp; Co. KG.
</p>
<p>Hofert, M. (2011).
Efficiently sampling nested Archimedean copulas.
<em>Computational Statistics &amp; Data Analysis</em> <b>55</b>, 57&ndash;70.
</p>
<p>Hofert, M. and Mächler, M. (2011).
Nested Archimedean Copulas Meet R: The nacopula Package.
<em>Journal of Statistical Software</em> <b>39</b>(9), 1&ndash;20.
<a href="https://www.jstatsoft.org/v39/i09/">https://www.jstatsoft.org/v39/i09/</a>.
</p>


<h3>See Also</h3>

<p>The class definition, <code>"<a href="#topic+acopula-class">acopula</a>"</code>.
<code><a href="#topic+onacopula">onacopula</a></code> and <code><a href="#topic+setTheta">setTheta</a></code> for such
Archimedean copulas with specific parameters.
<br />
<code><a href="#topic+getAcop">getAcop</a></code> accesses these families
&ldquo;programmatically&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Print a copAMH object and its structure
copAMH
str(copAMH)

## Show admissible parameters for a Clayton copula
copClayton@paraInterval

## Generate random variates from a Log(p) distribution via V0 of Frank
p &lt;- 1/2
copFrank@V0(100, -log(1-p))

## Plot the upper tail-dependence coefficient as a function in the
## parameter for Gumbel's family
curve(copGumbel@lambdaU(x), xlim = c(1, 10), ylim = c(0,1), col = 4)

## Plot Kendall's tau as a function in the parameter for Joe's family
curve(copJoe@tau(x), xlim = c(1, 10), ylim = c(0,1), col = 4)

## ------- Plot psi() and tau() - and properties of all families ----

## The copula families currently provided:
(famNms &lt;- ls("package:copula", patt="^cop[A-Z]"))

op &lt;- par(mfrow= c(length(famNms), 2),
          mar = .6+ c(2,1.4,1,1), mgp = c(1.1, 0.4, 0))
for(nm in famNms) { Cf &lt;- get(nm)
   thet &lt;- Cf@iTau(0.3)
   curve(Cf@psi(x, theta = thet), 0, 5,
         xlab = quote(x), ylab="", ylim=0:1, col = 2,
         main = substitute(list(NAM ~~~ psi(x, theta == TH), tau == 0.3),
                           list(NAM=Cf@name, TH=thet)))
   I &lt;- Cf@paraInterval
   Iu &lt;- pmin(10, I[2])
   curve(Cf@tau(x), I[1], Iu, col = 3,
         xlab = bquote(theta %in% .(format(I))), ylab = "",
         main = substitute(NAM ~~ tau(theta), list(NAM=Cf@name)))
}
par(op)

## Construct a bivariate Clayton copula with parameter theta
theta &lt;- 2
C2 &lt;- onacopula("Clayton", C(theta, 1:2))
C2@copula # is an "acopula" with specific parameter theta

curve(C2@copula@psi(x, C2@copula@theta),
      main = quote("Generator" ~~ psi ~~ " of Clayton A.copula"),
      xlab = quote(theta1), ylab = quote(psi(theta1)),
      xlim = c(0,5), ylim = c(0,1), col = 4)

## What is the corresponding Kendall's tau?
C2@copula@tau(theta) # 0.5

## What are the corresponding tail-dependence coefficients?
C2@copula@lambdaL(theta)
C2@copula@lambdaU(theta)

## Generate n pairs of random variates from this copula
U &lt;- rnacopula(n = 1000, C2)
## and plot the generated pairs of random variates
plot(U, asp=1, main = "n = 1000 from  Clayton(theta = 2)")
</code></pre>

<hr>
<h2 id='Copula'>Density, Evaluation, and Random Number Generation for Copula Functions</h2><span id='topic+Copula'></span><span id='topic+dCopula'></span><span id='topic+pCopula'></span><span id='topic+rCopula'></span><span id='topic+dcopula'></span><span id='topic+pcopula'></span><span id='topic+rcopula'></span><span id='topic+dCopula+2Cmatrix+2CclaytonCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CfrankCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CgumbelCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CnormalCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CtCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CgalambosCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CamhCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CjoeCopula-method'></span><span id='topic+dCopula+2Cmatrix+2ChuslerReissCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CtawnCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CtevCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CplackettCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CfgmCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CmoCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CindepCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CfhCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CempCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CkhoudrajiBivCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CkhoudrajiExplicitCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CrotCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CrotExplicitCopula-method'></span><span id='topic+dCopula+2Cmatrix+2CmixCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CclaytonCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CfrankCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CgumbelCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CgalambosCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CamhCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CjoeCopula-method'></span><span id='topic+pCopula+2Cmatrix+2ChuslerReissCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CtawnCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CtevCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CplackettCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CfgmCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CmoCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CindepCopula-method'></span><span id='topic+pCopula+2Cmatrix+2ClowfhCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CupfhCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CempCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CkhoudrajiCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CrotCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CrotExplicitCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CmixCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CclaytonCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CfrankCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CgumbelCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CnormalCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CtCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CgalambosCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CamhCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CjoeCopula-method'></span><span id='topic+rCopula+2Cnumeric+2ChuslerReissCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CplackettCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CfgmCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CmoCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CevCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CindepCopula-method'></span><span id='topic+rCopula+2Cnumeric+2ClowfhCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CupfhCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CempCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CkhoudrajiCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CrotCopula-method'></span><span id='topic+rCopula+2Cnumeric+2CmixCopula-method'></span><span id='topic+rCopula+2Cnumeric+2Cnacopula-method'></span>

<h3>Description</h3>

<p>Density (<code>dCopula</code>), distribution function (<code>pCopula</code>), and
random generation (<code>rCopula</code>) for a <code>copula</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCopula(u, copula, log=FALSE, ...)
pCopula(u, copula, ...)
rCopula(n, copula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Copula_+3A_copula">copula</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>"<a href="#topic+Copula-class">Copula</a>"</code>,
(i.e., <code>"<a href="#topic+copula-class">copula</a>"</code> or  <code>"<a href="#topic+nacopula-class">nacopula</a>"</code>).</p>
</td></tr>
<tr><td><code id="Copula_+3A_u">u</code></td>
<td>
<p>a vector of the copula dimension <code class="reqn">d</code> or a matrix with <code class="reqn">d</code>
columns, giving the points where the density or distribution
function needs to be evaluated.  Note that in all cases, values
outside of the cube <code class="reqn">[0,1]^d</code> are treated equivalently
to those on the cube boundary.  So, e.g., the density is zero.
</p>
</td></tr>
<tr><td><code id="Copula_+3A_log">log</code></td>
<td>
<p>logical indicating if the <code class="reqn">\log(f(\cdot))</code>
should be returned instead of <code class="reqn">f(\cdot)</code>.</p>
</td></tr>
<tr><td><code id="Copula_+3A_n">n</code></td>
<td>
<p>(for <code>rCopula()</code>:) number of observations to be generated.</p>
</td></tr>
<tr><td><code id="Copula_+3A_...">...</code></td>
<td>
<p>further optional arguments for some methods, e.g.,
<code>method</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density (<code>dCopula</code>) and distribution function
(<code>pCopula</code>) methods for Archimedean copulas now use the
corresponding function slots of the Archimedean copula objects, such
as <code><a href="#topic+copClayton">copClayton</a></code>, <code><a href="#topic+copGumbel">copGumbel</a></code>, etc.
</p>
<p>If an <code class="reqn">u_j</code> is outside <code class="reqn">(0,1)</code> we declare the density to be
zero, and this is true even when another <code class="reqn">u_k, k \ne j</code>
is <code><a href="base.html#topic+NA">NA</a></code> or <code><a href="base.html#topic+NaN">NaN</a></code>; see also the
&ldquo;outside&rdquo; example.
</p>
<p>The distribution function of a <code>t</code> copula uses <code>pmvt</code> from
package <span class="pkg">mvtnorm</span>; similarly, the density (<code>dCopula</code>) calls
<code><a href="mvtnorm.html#topic+dmvt">dmvt</a></code> from CRAN package <a href="https://CRAN.R-project.org/package=mvtnorm"><span class="pkg">mvtnorm</span></a>.
The <code>normalCopula</code> methods use <code>dmvnorm</code> and <code>pmvnorm</code>
from the same package.
</p>
<p>The random number generator for an Archimedean copula uses the
conditional approach for the bivariate case and the Marshall-Olkin (1988)
approach for dimension greater than 2.
</p>


<h3>Value</h3>

<p><code>dCopula()</code> gives the density, <code>pCopula()</code> gives the
distribution function, and <code>rCopula()</code> generates random variates.
</p>


<h3>References</h3>

<p>Frees, E. W.  and Valdez, E. A. (1998). Understanding relationships using
copulas.
<em>North American Actuarial Journal</em> <b>2</b>, 1&ndash;25.
</p>
<p>Genest, C. and Favre, A.-C. (2007).
Everything you always wanted to know about copula modeling but were
afraid to ask.
<em>Journal of Hydrologic Engineering</em> <b>12</b>, 347&ndash;368.
</p>
<p>Joe, H. (1997). <em>Multivariate Models and Dependence Concepts</em>.
Chapman and Hall, London.
</p>
<p>Marshall, A. W. and Olkin, I. (1988)
Families of multivariate distributions.
<em>Journal of the American Statistical Association</em> <b>83</b>, 834&ndash;841.
</p>
<p>Nelsen, R. B. (2006)
<em>An introduction to Copulas</em>. Springer, New York.
</p>


<h3>See Also</h3>

<p>the <code><a href="#topic+copula-class">copula</a></code> and <code><a href="#topic+acopula-class">acopula</a></code>
classes, the acopula families, <code><a href="#topic+acopula-families">acopula-families</a></code>.
Constructor functions such as
<code><a href="#topic+ellipCopula">ellipCopula</a></code>, <code><a href="#topic+archmCopula">archmCopula</a></code>,
<code><a href="#topic+fgmCopula">fgmCopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm.cop &lt;- normalCopula(0.5)
norm.cop
## one d-vector =^= 1-row matrix, works too :
dCopula(c(0.5, 0.5), norm.cop)
pCopula(c(0.5, 0.5), norm.cop)

u &lt;- rCopula(100, norm.cop)
plot(u)
dCopula(u, norm.cop)
pCopula(u, norm.cop)
persp  (norm.cop, dCopula)
contour(norm.cop, pCopula)

## a 3-dimensional normal copula
u &lt;- rCopula(1000, normalCopula(0.5, dim = 3))
if(require(scatterplot3d))
  scatterplot3d(u)

## a 3-dimensional clayton copula
cl3 &lt;- claytonCopula(2, dim = 3)
v &lt;- rCopula(1000, cl3)
pairs(v)
if(require(scatterplot3d))
  scatterplot3d(v)

## Compare with the "nacopula" version :
fu1 &lt;- dCopula(v, cl3)
fu2 &lt;- copClayton@dacopula(v, theta = 2)
Fu1 &lt;- pCopula(v, cl3)
Fu2 &lt;- pCopula(v, onacopula("Clayton", C(2.0, 1:3)))
## The density and cumulative values are the same:
stopifnot(all.equal(fu1, fu2, tolerance= 1e-14),
          all.equal(Fu1, Fu2, tolerance= 1e-15))

## NA and "outside" u[]
u &lt;- v[1:12,]
## replace some by values outside (0,1) and some by NA/NaN
u[1, 2:3] &lt;- c(1.5, NaN); u[2, 1] &lt;- 2; u[3, 1:2] &lt;- c(NA, -1)
u[cbind(4:9, 1:3)] &lt;- c(NA, NaN)
f &lt;- dCopula(u, cl3)
cbind(u, f) # note: f(.) == 0 at [1] and [3] inspite of NaN/NA
stopifnot(f[1:3] == 0, is.na(f[4:9]), 0 &lt; f[10:12])
</code></pre>

<hr>
<h2 id='copula-class'>Mother Classes &quot;Copula&quot;, etc of all Copulas in the Package</h2><span id='topic+copula-class'></span><span id='topic+Copula-class'></span><span id='topic+dimCopula-class'></span><span id='topic+parCopula-class'></span><span id='topic+xcopula-class'></span><span id='topic+Xcopula-class'></span><span id='topic+dim+2Ccopula-method'></span><span id='topic+dim+2CXcopula-method'></span><span id='topic+dim+2CdimCopula-method'></span>

<h3>Description</h3>

<p>A copula is a multivariate distribution with uniform margins.
The virtual class <code>"Copula"</code> is the mother (or &ldquo;super
class&rdquo;) of all copula classes in the package <span class="pkg">copula</span> which
encompasses classes of the former packages <span class="pkg">nacopula</span> and <span class="pkg">copula</span>.
</p>
<p>The virtual class <code>"parCopula"</code> extends <code>"Copula"</code> and is
the super class of all copulas that can be fully <em>par</em>ametrized and
hence fitted to data.  For these, at least the <code><a href="base.html#topic+dim">dim</a>()</code> method
must be well defined.
</p>
<p>The virtual class <code>"dimCopula"</code> extends <code>"Copula"</code> and has
an explicit slot <code>dimension</code>, with corresponding trivial
<code><a href="base.html#topic+dim">dim</a>()</code> method.
</p>
<p>The virtual class <code>"copula"</code> extends bot <code>"dimCopula"</code> and
<code>"parCopula"</code> and is the mother of all copula classes from former
package <span class="pkg">copula</span>.  It has set of slots for (the dimension and)
parameter vector, see below.
</p>
<p>The virtual class <code>"Xcopula"</code> contains a slot <code>copula</code> of class
<code>"parCopula"</code>.
</p>
<p>The virtual class <code>"xcopula"</code> extends <code>"parCopula"</code> and
<code>"Xcopula"</code>; an (&ldquo;actual&rdquo;) class example are
the rotated copulas, <code><a href="#topic+rotCopula-class">rotCopula</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects are typically created by are by <code><a href="#topic+tCopula">tCopula</a>()</code>,
<code><a href="#topic+evCopula">evCopula</a>()</code>, etc.
</p>


<h3>Slots</h3>

<p>Class <code>"dimCopula"</code> and its subclasses, notably
<code>"copula"</code>, have a slot
</p>
 <dl>
<dt><code>dimension</code>:</dt><dd><p>an <code>"integer"</code> (of length 1), the
copula dimension <code class="reqn">d</code>.</p>
</dd> </dl>

<p>Class <code>"copula"</code> (and its subclasses) have <em>additional</em> slots
</p>

<dl>
<dt><code>parameters</code>:</dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code> vector of
parameter values, can be NA (i.e., <code><a href="base.html#topic+NA_real_">NA_real_</a></code>).</p>
</dd>
<dt><code>param.names</code>:</dt><dd><p><code>"character"</code> vector of parameter
names (and hence of the same length as <code>parameters</code>).</p>
</dd>
<dt><code>param.lowbnd</code>:</dt><dd><p>lower bounds for the parameters, of
class <code>"numeric"</code>.</p>
</dd>
<dt><code>param.upbnd</code>:</dt><dd><p>upper bounds for the parameters, of class
<code>"numeric"</code>.</p>
</dd>
<dt><code>fullname</code>:</dt><dd><p><b>deprecated</b>; object of class <code>"character"</code>, family names
of the copula.</p>
</dd>
</dl>



<h3>Warning</h3>

<p>This implementation is still at the experimental
stage and is subject to change during the development.
</p>


<h3>Note</h3>

<p>The <code>"copula"</code> class is extended by the
<code><a href="#topic+evCopula-class">evCopula</a></code>, <code><a href="#topic+archmCopula-class">archmCopula</a></code>,
and <code><a href="#topic+ellipCopula-class">ellipCopula</a></code> classes.  Instances of
such copulas can be created via functions <code><a href="#topic+evCopula">evCopula</a></code>,
<code><a href="#topic+archmCopula">archmCopula</a></code> and <code><a href="#topic+ellipCopula">ellipCopula</a></code>.
</p>
<p><code>"plackettCopula"</code> and <code><a href="#topic+fgmCopula-class">fgmCopula</a></code> are
special types of copulas which do not belong to either one of the
three classes above.
</p>


<h3>See Also</h3>

<p>Help for the (sub)classes
<code><a href="#topic+archmCopula-class">archmCopula</a></code>,
<code><a href="#topic+ellipCopula-class">ellipCopula</a></code>,
<code><a href="#topic+evCopula-class">evCopula</a></code>, and
<code><a href="#topic+fgmCopula-class">fgmCopula</a></code>.
</p>
<p>The Archimedean and nested Archimedean classes (from former package
<span class="pkg">nacopula</span>), with a more extensive list of slots (partly instead
of methods),
<code><a href="#topic+acopula-class">acopula</a></code>, and <code><a href="#topic+nacopula-class">nacopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- evCopula("husler", 1.25)
dim(hc)
smoothScatter(u &lt;- rCopula(2^11, hc))
lambda   (hc)
tau (hc)
rho(hc)
str(hc)
</code></pre>

<hr>
<h2 id='copula-internal'>Internal Copula Functions</h2><span id='topic+schlatherCopula-class'></span>

<h3>Description</h3>

<p>Internal Copula functions
</p>


<h3>Details</h3>

<p>These are not to be called by the user (or in some cases are just
waiting for proper documentation to be written).
</p>

<hr>
<h2 id='corKendall'>(Fast) Computation of Pairwise Kendall's Taus</h2><span id='topic+corKendall'></span>

<h3>Description</h3>

<p>For a data matrix <code>x</code>, compute the Kendall's tau
&ldquo;correlation&rdquo; matrix, i.e., all pairwise Kendall's taus
between the columns of <code>x</code>.
</p>
<p>By default and when <code>x</code> has no missing values
(<code><a href="base.html#topic+NA">NA</a></code>s), the fast <code class="reqn">O(n log(n))</code> algorithm of
<code><a href="pcaPP.html#topic+cor.fk">cor.fk</a>()</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corKendall(x, checkNA = TRUE,
           use = if(checkNA &amp;&amp; anyNA(x)) "pairwise" else "everything")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corKendall_+3A_x">x</code></td>
<td>
<p>data, a n x p matrix (or less efficiently a
data.frame), or a numeric vector which is treated as n x 1 matrix.</p>
</td></tr>
<tr><td><code id="corKendall_+3A_checkna">checkNA</code></td>
<td>
<p>logical indicating if <code>x</code> should be checked for
<code><a href="base.html#topic+NA">NA</a></code>s and in the case of NA's <em>and</em> when <code>use</code>
is not specified (<code><a href="base.html#topic+missing">missing</a></code>), <code>cor(*, use =
      "pairwise")</code> should be used.  Note that <code>corKendall(x,
      checkNA = FALSE)</code> will produce an error when <code>x</code> has NA's.</p>
</td></tr>
<tr><td><code id="corKendall_+3A_use">use</code></td>
<td>
<p>a string to determine the treatment of <code><a href="base.html#topic+NA">NA</a></code>s in
<code>x</code>, see <code><a href="stats.html#topic+cor">cor</a></code>; its default determined via
<code>checkNA</code>.  When this differs from <code>"everything"</code>, <span class="rlang"><b>R</b></span>'s
<code><a href="stats.html#topic+cor">cor</a></code> is used; otherwise <a href="https://CRAN.R-project.org/package=pcaPP"><span class="pkg">pcaPP</span></a>'s
<code><a href="pcaPP.html#topic+cor.fk">cor.fk</a>()</code> which cannot deal with <code><a href="base.html#topic+NA">NA</a></code>s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">p \times p</code> matrix <code class="reqn">K</code> of pairwise Kendall's taus, with
<code>K[i,j] := tau(x[,i], x[,j])</code>.
</p>


<h3>See Also</h3>

<p><code><a href="pcaPP.html#topic+cor.fk">cor.fk</a>()</code> from <a href="https://CRAN.R-project.org/package=pcaPP"><span class="pkg">pcaPP</span></a> (used by default
when there are no missing values (<code>NA</code>s) in <code>x</code>).
</p>
<p><code><a href="#topic+etau">etau</a>()</code> or <code><a href="#topic+fitCopula">fitCopula</a>(*, method = "itau")</code>
make use of <code>corKendall()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## If there are no NA's, corKendall() is faster than cor(*, "kendall")
## and gives the same :

system.time(C1 &lt;- cor(swiss, method="kendall"))
system.time(C2 &lt;- corKendall(swiss))
stopifnot(all.equal(C1, C2,  tol = 1e-5))

## In the case of missing values (NA), corKendall() reverts to
## cor(*, "kendall", use = "pairwise") {no longer very fast} :

swM &lt;- swiss # shorter names and three missings:
colnames(swM) &lt;- abbreviate(colnames(swiss), min=6)
swM[1,2] &lt;- swM[7,3] &lt;- swM[25,5] &lt;- NA
(C3 &lt;- corKendall(swM)) # now automatically uses the same as
stopifnot(identical(C3, cor(swM, method="kendall", use="pairwise")))
## and is quite close to the non-missing "truth":
stopifnot(all.equal(unname(C3), unname(C2), tol = 0.06)) # rel.diff.= 0.055

try(corKendall(swM, checkNA=FALSE)) # --&gt; Error
## the error is really from  pcaPP::cor.fk(swM)
</code></pre>

<hr>
<h2 id='dDiag'>Density of the Diagonal of (Nested) Archimedean Copulas</h2><span id='topic+dDiag'></span>

<h3>Description</h3>

<p>Evaluate the density of the diagonal of a <code class="reqn">d</code>-dimensional (nested)
Archimedean copula.  Note that the diagonal of a copula is a cumulative
distribution function.  Currently, only Archimedean copulas are implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dDiag(u, cop, log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dDiag_+3A_u">u</code></td>
<td>
<p>a numeric vector of evaluation points.</p>
</td></tr>
<tr><td><code id="dDiag_+3A_cop">cop</code></td>
<td>
<p>a (nested) Archimedean copula object of class
<code>"<a href="#topic+outer_nacopula-class">outer_nacopula</a>"</code>.  This also determines the dimension
via the <code>comp</code> slot</p>
</td></tr>
<tr><td><code id="dDiag_+3A_log">log</code></td>
<td>
<p>logical indicating if the <code><a href="base.html#topic+log">log</a></code> of the density of the
diagonal should be returned instead of just the diagonal density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector containing the values of the density of the
diagonal of the Archimedean copula at <code>u</code>.</p>


<h3>References</h3>

<p>Hofert, M., Mächler, M., and McNeil, A. J. (2013).
Archimedean Copulas in High Dimensions: Estimators and Numerical
Challenges Motivated by Financial Applications.
<em>Journal de la Société Française de
Statistique</em>
<b>154</b>(1), 25&ndash;63.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+acopula-class">acopula</a></code> class, <code><a href="#topic+dnacopula">dnacopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>th. &lt;- c(0.1, 0.2, 0.5, 0.8, 1.4, 2., 5.)
curve(dDiag(x, cop=onacopulaL("Clayton", list(th.[1], 1:3))), 0, 1,
      n=1000, ylab="dDiag(x, *)", main="Diagonal densities of Clayton")
abline(h=0, lty=3)
for(j in 2:length(th.))
  curve(dDiag(x, cop=onacopulaL("Clayton", list(th.[j], 1:3))), add=TRUE,
	     col=j, n=1000)
legend("topleft", do.call(expression, lapply(th., function(th)
                                 substitute(theta == TH, list(TH=th)))),
       lty = 1, col=seq_along(th.), bty="n")
</code></pre>

<hr>
<h2 id='describeCop'>Copula (Short) Description as String</h2><span id='topic+describeCop'></span><span id='topic+describeCop-methods'></span><span id='topic+describeCop+2CCopula+2Cmissing-method'></span><span id='topic+describeCop+2Ccopula+2Ccharacter-method'></span><span id='topic+describeCop+2CXcopula+2CANY-method'></span><span id='topic+describeCop+2CarchmCopula+2Ccharacter-method'></span><span id='topic+describeCop+2CellipCopula+2Ccharacter-method'></span><span id='topic+describeCop+2CfgmCopula+2Ccharacter-method'></span><span id='topic+describeCop+2CmoCopula+2Ccharacter-method'></span><span id='topic+describeCop+2CindepCopula+2Ccharacter-method'></span><span id='topic+describeCop+2CkhoudrajiCopula+2Ccharacter-method'></span><span id='topic+describeCop+2CmixCopula+2Ccharacter-method'></span><span id='topic+describeCop+2CrotCopula+2Ccharacter-method'></span><span id='topic+describeCop+2CfhCopula+2Ccharacter-method'></span><span id='topic+describeCop+2CempCopula+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Describe a <code><a href="#topic+copula-class">copula</a></code> object, i.e., its basic
properties as a string.  This is a utility used when
<code><a href="base.html#topic+print">print</a>()</code>ing or <code><a href="base.html#topic+plot">plot</a>()</code>ting copulas, e.g.,
after a fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describeCop(x, kind = c("short", "very short", "long"), prefix = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="describeCop_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+copula-class">copula</a></code> object, or a generalization
such as  <code><a href="#topic+parCopula-class">parCopula</a></code>.</p>
</td></tr>
<tr><td><code id="describeCop_+3A_kind">kind</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the size (or
&ldquo;complexity&rdquo; of the copula description desired.</p>
</td></tr>
<tr><td><code id="describeCop_+3A_prefix">prefix</code></td>
<td>
<p>a string to be prefixed to the returned string, which
can be useful for indentation in describing extended copulas such
as Khoudraji copulas.</p>
</td></tr>
<tr><td><code id="describeCop_+3A_...">...</code></td>
<td>
<p>further arguments; unused currently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+character">character</a></code> string.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "archmCopula", kind = "ANY")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(x = "copula", kind = "character")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(x = "copula", kind = "missing")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(x = "ellipCopula", kind = "character")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(x = "fgmCopula", kind = "ANY")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(x = "xcopula", kind = "ANY")</code></dt><dd><p> .. </p>
</dd>
</dl>



<h3>See Also</h3>

<p>Copula class definition <code><a href="#topic+copula-class">copula</a></code>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## FIXME
</code></pre>

<hr>
<h2 id='dnacopula'>Density Evaluation for (Nested) Archimedean Copulas</h2><span id='topic+dnacopula'></span><span id='topic+dCopula+2Cmatrix+2Cnacopula-method'></span><span id='topic+dCopula+2Cnumeric+2Cnacopula-method'></span>

<h3>Description</h3>

<p>For a (nested) Archimedean copula (object of class <code><a href="#topic+nacopula-class">nacopula</a></code>)
<code>x</code>, <code>dCopula(u, x)</code> (or also currently still <code>dnacopula(x, u)</code>)
evaluates the density of <code>x</code> at the given vector or matrix <code>u</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,nacopula'
dCopula(u, copula, log=FALSE, ...)

## *Deprecated*:
dnacopula(x, u, log=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnacopula_+3A_copula">copula</code>, <code id="dnacopula_+3A_x">x</code></td>
<td>
<p>an object of class <code>"<a href="#topic+outer_nacopula-class">outer_nacopula</a>"</code>.</p>
</td></tr>
<tr><td><code id="dnacopula_+3A_u">u</code></td>
<td>
<p>argument of the copula x.  Note that u can be a matrix in which case
the density is computed for each row of the matrix and the vector of
values is returned.</p>
</td></tr>
<tr><td><code id="dnacopula_+3A_log">log</code></td>
<td>
<p>logical indicating if the <code><a href="base.html#topic+log">log</a></code> of the density
should be returned.</p>
</td></tr>
<tr><td><code id="dnacopula_+3A_...">...</code></td>
<td>

<p>optional arguments passed to the copula's <code>dacopula</code>
function (slot), such as <code>n.MC</code> (non-negative integer) for
possible Monte Carlo evaluation (see <code>dacopula</code> in
<code><a href="#topic+acopula-class">acopula</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If it exists, the density of an Archimedean copula <code class="reqn">C</code> with
generator <code class="reqn">\psi</code> at <code class="reqn">\bm{u}\in(0,1)^d</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">c(\bm{u})=\psi^{(d)}(\psi^{-1}(u_1)+\dots+\psi^{-1}(u_d))
    \prod_{j=1}^d(\psi^{-1}(u_j))^\prime
    = \frac{\psi^{(d)}(\psi^{-1}(u_1)+\dots+\psi^{-1}(u_d))}{
      \prod_{j=1}^d\psi^\prime(\psi^{-1}(u_j))}.
  </code>
</p>



<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector containing the values of the density of the
Archimedean copula at <code>u</code>.
</p>


<h3>Note</h3>

<p><code><a href="#topic+dCopula">dCopula</a>(u, copula)</code> is a <em>generic</em> function with
methods for <em>all</em> our copula classes, see <code><a href="#topic+dCopula">dCopula</a></code>.
</p>


<h3>References</h3>

<p>Hofert, M., Mächler, M., and McNeil, A. J. (2012).
Likelihood inference for Archimedean copulas in high dimensions
under known margins. <em>Journal of Multivariate Analysis</em>
<b>110</b>, 133&ndash;150.
</p>
<p>Hofert, M., Mächler, M., and McNeil, A. J. (2013).
Archimedean Copulas in High Dimensions: Estimators and Numerical
Challenges Motivated by Financial Applications.
<em>Journal de la Société Française de
Statistique</em>
<b>154</b>(1), 25&ndash;63.
</p>


<h3>See Also</h3>

<p>For more details about the derivatives of an Archimedean generator,
see, for example, <code>absdPsi</code> in class <code><a href="#topic+acopula-class">acopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct a twenty-dimensional Gumbel copula with parameter chosen
## such that Kendall's tau of the bivariate margins is 0.25.
theta &lt;- copJoe@iTau(.25)
C20 &lt;- onacopula("J", C(theta, 1:20))

## Evaluate the copula density at the point u = (0.5,...,0.5)
u &lt;- rep(0.5, 20)
dCopula(u, C20)

## the same with Monte Carlo based on 10000 simulated "frailties"
dCopula(u, C20, n.MC = 10000)

## Evaluate the exact log-density at several points
u &lt;- matrix(runif(100), ncol=20)
dCopula(u, C20, log = TRUE)

## Back-compatibility check
stopifnot(identical( dCopula (u, C20), suppressWarnings(
                    dnacopula(C20, u))),
          identical( dCopula (u, C20, log = TRUE), suppressWarnings(
                    dnacopula(C20, u, log = TRUE))))
</code></pre>

<hr>
<h2 id='ellipCopula'>Construction of Elliptical Copula Class Objects</h2><span id='topic+ellipCopula'></span><span id='topic+normalCopula'></span><span id='topic+tCopula'></span><span id='topic+dispstrToep'></span><span id='topic+pCopula+2Cmatrix+2CnormalCopula-method'></span><span id='topic+pCopula+2Cmatrix+2CtCopula-method'></span>

<h3>Description</h3>

<p>Creating elliptical copula objects with corresponding dimension and
parameters, including the dispersion structure <code class="reqn">P</code> (pronounced &ldquo;Rho&rdquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipCopula (family, param, dim = 2, dispstr = "ex", df = 4, ...)

normalCopula(param, dim = 2, dispstr = "ex")

     tCopula(param, dim = 2, dispstr = "ex", df = 4,
             df.fixed = FALSE, df.min = 0.01)

dispstrToep(perm = NULL, check = TRUE)

## S4 method for signature 'matrix,normalCopula'
pCopula(u, copula, algorithm=NULL, keepAttr=FALSE, ...)
## S4 method for signature 'matrix,tCopula'
pCopula(u, copula, algorithm=NULL, keepAttr=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipCopula_+3A_family">family</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the family of an
elliptical copula.  Must be <code>"normal"</code> (the default) or <code>"t"</code>.</p>
</td></tr>
<tr><td><code id="ellipCopula_+3A_param">param</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> vector specifying the parameter values;
<code>P2p()</code> accesses this vector, whereas
<code><a href="#topic+p2P">p2P</a>()</code> and <code><a href="#topic+getSigma">getSigma</a>()</code> provide
the corresponding &ldquo;P&rdquo; matrix, see below.</p>
</td></tr>
<tr><td><code id="ellipCopula_+3A_dim">dim</code></td>
<td>
<p> the dimension of the copula. </p>
</td></tr>
<tr><td><code id="ellipCopula_+3A_dispstr">dispstr</code></td>
<td>
<p>a string specifying the &ldquo;dispersion structure&rdquo;,
i.e., type of the symmetric positive definite matrix characterizing the
elliptical copula.  Currently available structures are <code>"ex"</code> for
<b>ex</b>changeable, <code>"ar1"</code> for <code class="reqn">AR(1)</code>, <code>"toep"</code> for
Toeplitz (<code><a href="stats.html#topic+toeplitz">toeplitz</a></code>), and <code>"un"</code> for
<b>un</b>structured.
</p>
<p>The dispersion structure for Toeplitz can (and often should) now be
specified by <code>dispstrToep()</code>, see there.</p>
</td></tr>
<tr><td><code id="ellipCopula_+3A_df">df</code></td>
<td>
<p>integer value specifying the number of degrees of freedom
of the multivariate t distribution used to construct the t copulas.</p>
</td></tr>
<tr><td><code id="ellipCopula_+3A_df.fixed">df.fixed</code></td>
<td>
<p>logical specifying if the degrees of freedom <code>df</code> will be
considered as a parameter (to be estimated) or not.  The default,
<code>FALSE</code>, means that <code>df</code> is to be estimated if the object is
passed as argument to <code><a href="#topic+fitCopula">fitCopula</a></code>.</p>
</td></tr>
<tr><td><code id="ellipCopula_+3A_df.min">df.min</code></td>
<td>
<p>non-negative number; the strict lower bound for
<code>df</code>, mainly during fitting when <code>df.fixed=FALSE</code>, with
<code><a href="#topic+fitCopula">fitCopula</a></code>.</p>
</td></tr>

<tr><td><code id="ellipCopula_+3A_copula">copula</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>"<a href="#topic+Copula-class">Copula</a>"</code>, in our
case inheriting from <code>"<a href="#topic+ellipCopula-class">ellipCopula</a>"</code>.</p>
</td></tr>
<tr><td><code id="ellipCopula_+3A_u">u</code></td>
<td>
<p>a vector of the copula dimension <code class="reqn">d</code> or a matrix with <code class="reqn">d</code>
columns, giving the points where the distribution function needs to be
evaluated.  Note that values outside of the cube <code class="reqn">[0,1]^d</code> are
treated equivalently to those on the cube boundary.</p>
</td></tr>
<tr><td><code id="ellipCopula_+3A_algorithm">algorithm</code></td>
<td>
<p><code>NULL</code> or an <code>"algorithm"</code> object for package
<a href="https://CRAN.R-project.org/package=mvtnorm"><span class="pkg">mvtnorm</span></a>'s <code>pmvt()</code> or <code>pmvnorm()</code> functions, see
<code><a href="mvtnorm.html#topic+algorithms">algorithms</a></code>.  Note that for larger dimensions,
the monte-carlo based <code>GenzBretz(..)</code> must be used, consequently
with slightly random results.  By default, <code>algorithm = NULL</code>,
<code>algorithm</code> is chosen separately for each row <code>x &lt;- u[i,]</code>, for
</p>

<dl>
<dt><code>normalCopula</code>:</dt><dd><p> via hidden function
<code>pmvnormAlgo(dim, x, ...)</code>
which currently is defined as 
</p>
<pre> pmvnormAlgo &lt;- function(dim, x, ...) {
    if(dim &lt;= 3 &amp;&amp; !anyNA(x) &amp;&amp; (!any(xI &lt;- x == Inf) || all(xI)))
        TVPACK(...)
    else if(dim &lt;= 5)
        Miwa(...)
    else
        GenzBretz(...)
  }</pre>
</dd>
<dt><code>tCopula</code>:</dt><dd><p> via (hidden) <code>pmvtAlgo(dim, x, ...)</code>
which is the same as <code>pmvnormAlgo()</code> above, but as <code>Miwa()</code>
is not applicable, without the <code>else if(dim &lt;= 5) Miwa(...)</code>
clause.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="ellipCopula_+3A_keepattr">keepAttr</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> passed to
<code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code> or <code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="ellipCopula_+3A_...">...</code></td>
<td>
<p>for the <code>pCopula()</code> methods, optional arguments to the
corresponding algorithm.</p>
</td></tr>

<tr><td><code id="ellipCopula_+3A_perm">perm</code></td>
<td>
<p>an <code><a href="base.html#topic+integer">integer</a></code> vector of length <code class="reqn">d =</code><code>dim</code>,
which must be a permutation of <code>1:d</code> specifying the (column)
ordering of the variables which has Toeplitz dispersion.</p>
</td></tr>
<tr><td><code id="ellipCopula_+3A_check">check</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> specifying if the validity of
<code>perm</code> should be checked (not strictly, currently).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For
</p>

<dl>
<dt><code>ellipCopula()</code>, <code>normalCopula()</code>, or <code>tCopula()</code>:</dt><dd>
<p>an elliptical copula object of class <code>"<a href="#topic+normalCopula-class">normalCopula</a>"</code>
or <code>"<a href="#topic+tCopula-class">tCopula</a>"</code>.</p>
</dd>
<dt>dispstrToep():</dt><dd><p>the <code><a href="base.html#topic+character">character</a></code> string <code>"toep"</code>,
optionally with attribute (see <code><a href="base.html#topic+attributes">attributes</a></code>,
<code><a href="base.html#topic+attr">attr</a></code>) <code>"perm"</code> with a permutation <code class="reqn">p</code> of
<code>1:d</code>, such that (the column permuted) <code class="reqn">U_p</code>, or in
the data case the column-permuted matrix <code>U[,p]</code> has as
dispersion matrix <code>toeplitz(c(1, par))</code>, with <code>par</code> the
respective parameter vector of bivariate &ldquo;correlations&rdquo;
<code class="reqn">\rho_{i,j}</code>.
</p>
<p>Note that the result of <code>dispstrToep()</code> is currently stored in the
<code>dispstr</code> slot of the copula object.</p>
</dd>
<dt>pCopula(u, *): </dt><dd><p>the numerical vector of copula probabilites of
length <code>nrow(u)</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>ellipCopula()</code> is a wrapper for <code>normalCopula()</code> and
<code>tCopula()</code>.
</p>
<p>The  <code><a href="#topic+pCopula">pCopula</a>()</code> methods for the normal- and t-copulas
accept optional arguments to be passed to the underlying
(numerical integration) algorithms from package <a href="https://CRAN.R-project.org/package=mvtnorm"><span class="pkg">mvtnorm</span></a>'s
<code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code> and <code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>,
respectively, notably <code>algorithm</code>, see
<code><a href="mvtnorm.html#topic+GenzBretz">GenzBretz</a></code>, or <code>abseps</code>
which defaults to <code>0.001</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p2P">p2P</a>()</code>, and <code><a href="#topic+getSigma">getSigma</a>()</code> for construction and
extraction of the dispersion matrix <code class="reqn">P</code> or <code class="reqn">Sigma</code> matrix of
(generalized)
correlations.
</p>
<p><code><a href="#topic+archmCopula">archmCopula</a></code>, <code><a href="#topic+fitCopula">fitCopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalCopula(c(0.5, 0.6, 0.7), dim = 3, dispstr = "un")
t.cop &lt;- tCopula(c(0.5, 0.3), dim = 3, dispstr = "toep",
                 df = 2, df.fixed = TRUE)
getSigma(t.cop) # P matrix (with diagonal = 1)
stopifnot(all.equal(toeplitz(c(1, .5, .3)), getSigma(t.cop)))

## dispersion "AR1" :
nC.7 &lt;- normalCopula(0.8, dim = 7, dispstr = "ar1")
getSigma(nC.7)
stopifnot(all.equal(toeplitz(.8^(0:6)), getSigma(nC.7)))

## from the wrapper
norm.cop &lt;- ellipCopula("normal", param = c(0.5, 0.6, 0.7),
                        dim = 3, dispstr = "un")
if(require("scatterplot3d") &amp;&amp; dev.interactive(orNone=TRUE)) {
  ## 3d scatter plot of 1000 random observations
  scatterplot3d(rCopula(1000, norm.cop))
  scatterplot3d(rCopula(1000, t.cop))
}
set.seed(12)
uN &lt;- rCopula(512, norm.cop)
set.seed(2); pN1 &lt;- pCopula(uN, norm.cop)
set.seed(3); pN2 &lt;- pCopula(uN, norm.cop)
stopifnot(identical(pN1, pN2)) # no longer random for dim = 3
(Xtras &lt;- copula:::doExtras())
if(Xtras) { ## a bit more accurately:
  set.seed(4); pN1. &lt;- pCopula(uN, norm.cop, abseps = 1e-9)
  set.seed(5); pN2. &lt;- pCopula(uN, norm.cop, abseps = 1e-9)
  stopifnot(all.equal(pN1., pN2., 1e-5))# see 3.397e-6
  ## but increasing the required precision (e.g., abseps=1e-15) does *NOT* help
}

## For smaller copula dimension 'd', alternatives are available and
## non-random, see ?GenzBretz from package 'mvtnorm' :
has_mvtn &lt;- "package:mvtnorm" %in% search() #% &lt;&lt; (workaround ESS Rd render bug)
if(!has_mvtn)
  require("mvtnorm")# -&gt; GenzBretz(), Miva(), and TVPACK() are available
## Note that Miwa() would become very slow for dimensions 5, 6, ..
set.seed(4); pN1.M &lt;- pCopula(uN, norm.cop, algorithm = Miwa(steps = 512))
set.seed(5); pN2.M &lt;- pCopula(uN, norm.cop, algorithm = Miwa(steps = 512))
stopifnot(all.equal(pN1.M, pN2.M, tol= 1e-15))# *no* randomness
set.seed(4); pN1.T &lt;- pCopula(uN, norm.cop, algorithm = TVPACK(abseps = 1e-10))
set.seed(5); pN2.T &lt;- pCopula(uN, norm.cop, algorithm = TVPACK(abseps = 1e-14))
stopifnot(all.equal(pN1.T, pN2.T, tol= 1e-15))# *no* randomness (but no effect of 'abseps')
if(!has_mvtn)
   detach("package:mvtnorm")# (revert)


## Versions with unspecified parameters:
tCopula()
allEQ &lt;- function(u,v) all.equal(u, v, tolerance=0)
stopifnot(allEQ(ellipCopula("norm"), normalCopula()),
          allEQ(ellipCopula("t"), tCopula()))
tCopula(dim=3)
tCopula(dim=4, df.fixed=TRUE)
tCopula(dim=5, disp = "toep", df.fixed=TRUE)
normalCopula(dim=4, disp = "un")

## Toeplitz after *permutation* dispersions (new in copula 1.1-0) ---------
tpar &lt;- c(7,5,3)/8 # *gives* pos.def.:
(ev &lt;- eigen(toeplitz(c(1, tpar)), symmetric=TRUE, only.values=TRUE)$values)
stopifnot(ev &gt; 0)
N4.   &lt;- ellipCopula("normal", dim=4, param=tpar, dispstr = "toep") #"regular"
## reversed order is "the same" for toeplitz structure:
N4.pr &lt;- ellipCopula("normal", dim=4, param=tpar, dispstr = dispstrToep(4:1))
N4.p1 &lt;- ellipCopula("normal", dim=4, param=tpar, dispstr = dispstrToep(c(4,1:3)))
N4.p2 &lt;- ellipCopula("normal", dim=4, param=tpar, dispstr = dispstrToep(c(4:3,1:2)))
N4.p3 &lt;- ellipCopula("normal", dim=4, param=tpar, dispstr = dispstrToep(c(2,4,1,3)))

(pm &lt;- attr(N4.p3@dispstr, "perm")) # (2 4 1 3)
ip &lt;- c(3,1,4,2) # the *inverse* permutation of (2 4 1 3) = Matrix::invPerm(pm)
(Sp3 &lt;- getSigma(N4.p3)) # &lt;-- "permuted toeplitz"
Sp3[ip, ip] # re-ordered rows &amp; columns =&gt; *is* toeplitz :
stopifnot(exprs = {
  ## permutations  pm  and  ip  are inverses:
  pm[ip] == 1:4
  ip[pm] == 1:4
  is.matrix(T4 &lt;- toeplitz(c(1, tpar)))
  identical(getSigma(N4.),   T4)
  identical(getSigma(N4.pr), T4) # 4:1 and 1:4 is "the same" for Rho
  identical(Sp3[ip, ip]  ,   T4)
  identical(Sp3,      T4[pm,pm])
})
## Data generation -- NB: The U matrices are equal only "in distribution":
set.seed(7); U.p3 &lt;- rCopula(1000, N4.p3)
set.seed(7); U.   &lt;- rCopula(1000, N4.)
stopifnot(exprs = {
 all.equal(loglikCopula(tpar, u=U.p3,      copula= N4.p3),
           loglikCopula(tpar, u=U.p3[,ip], copula= N4.) -&gt; LL3)
 all.equal(loglikCopula(tpar, u=U.,      copula= N4.),
           loglikCopula(tpar, u=U.[,pm], copula= N4.p3) -&gt; LL.)
})
c(LL. , LL3)# similar but different
if(Xtras) {
  fm.  &lt;- fitCopula(N4.  , U.  )
  fm.3 &lt;- fitCopula(N4.p3, U.p3)
  summary(fm.3)
  stopifnot(all.equal(coef(fm.), coef(fm.3), tol = 0.01))# similar but different
}
</code></pre>

<hr>
<h2 id='ellipCopula-class'>Class &quot;ellipCopula&quot; of Elliptical Copulas</h2><span id='topic+ellipCopula-class'></span><span id='topic+normalCopula-class'></span><span id='topic+tCopula-class'></span>

<h3>Description</h3>

<p>Copulas generated from elliptical multivariate distributions, notably
Normal- and t-copulas (of specific class <code>"normalCopula"</code> or
<code>"tCopula"</code>, respectively).
</p>


<h3>Objects from the Class</h3>

<p>Objects are typically created by <code><a href="#topic+ellipCopula">ellipCopula</a>()</code>,
<code><a href="#topic+normalCopula">normalCopula</a>()</code>, or <code><a href="#topic+tCopula">tCopula</a>()</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dispstr</code>:</dt><dd><p><code>"<a href="base.html#topic+character">character</a>"</code> string indicating
how the dispersion matrix is parameterized; one of <code>"ex"</code>,
<code>"ar1"</code>, <code>"toep"</code>, or <code>"un"</code>, see the <code>dispstr</code>
argument of <code><a href="#topic+ellipCopula">ellipCopula</a>()</code>.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>"numeric"</code>, dimension
of the copula. </p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>a <code><a href="base.html#topic+numeric">numeric</a></code>, (vector of) the parameter
value(s).</p>
</dd>
<dt><code>param.names</code>:</dt><dd><p><code><a href="base.html#topic+character">character</a></code> vector with names
for the <code>parameters</code> slot, of the same length.</p>
</dd>
<dt><code>param.lowbnd</code>:</dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code> vector of lower
bounds for the <code>parameters</code> slot, of the same length.</p>
</dd>
<dt><code>param.upbnd</code>:</dt><dd><p>upper bounds for <code>parameters</code>,
analogous to <code>parm.lowbnd</code>.</p>
</dd>
<dt><code>fullname</code>:</dt><dd><p><b>deprecated</b>; object of class <code>"character"</code>, family names
of the copula.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"ellipCopula"</code> extends class <code><a href="#topic+copula-class">copula</a></code>
directly. Classes <code>"normalCopula"</code> and <code>"tCopula"</code> extend
<code>"ellipCopula"</code> directly.
</p>


<h3>Methods</h3>

<p>Many methods are available, notably <code><a href="#topic+dCopula">dCopula</a></code>,
<code><a href="#topic+pCopula">pCopula</a></code>, and <code><a href="#topic+rCopula">rCopula</a></code>.
Use, e.g., <code><a href="utils.html#topic+methods">methods</a>(class = "tCopula")</code> to find others.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ellipCopula">ellipCopula</a></code> which also documents <code>tCopula()</code> and
<code><a href="#topic+normalCopula">normalCopula</a>()</code>;
<code><a href="#topic+copula-class">copula-class</a></code>.
</p>

<hr>
<h2 id='emde'>Minimum Distance Estimators for (Nested) Archimedean Copulas</h2><span id='topic+emde'></span>

<h3>Description</h3>

<p>Compute minimum distance estimators for (nested) Archimedean copulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emde(u, cop,
     method=c("mde.chisq.CvM", "mde.chisq.KS",
              "mde.gamma.CvM", "mde.gamma.KS"),
     interval=initOpt(cop@copula@name),
     include.K = FALSE, repara = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emde_+3A_u">u</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix of (pseudo-)observations (each
value in <code class="reqn">[0,1]</code>) from the copula, where <code class="reqn">n</code> denotes the
sample size and <code class="reqn">d</code> the dimension.</p>
</td></tr>
<tr><td><code id="emde_+3A_cop">cop</code></td>
<td>
<p><code><a href="#topic+outer_nacopula-class">outer_nacopula</a></code> to be estimated
(currently only Archimedean copulas are provided).</p>
</td></tr>
<tr><td><code id="emde_+3A_method">method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the distance
method, which has to be one (or a unique abbreviation) of
</p>

<dl>
<dt><code>"mde.chisq.CvM"</code></dt><dd><p>map to an Erlang distribution and
using a chi-square distribution and Cramér-von Mises distance;</p>
</dd>
<dt><code>"mde.chisq.KS"</code></dt><dd><p>map to an Erlang distribution and
using a chi-square distribution and Kolmogorov-Smirnov distance;</p>
</dd>
<dt><code>"mde.gamma.CvM"</code></dt><dd><p>map to an Erlang distribution and
using a Erlang distribution and Cramér-von Mises distance;</p>
</dd>
<dt><code>"mde.gamma.KS"</code></dt><dd><p>map to an Erlang distribution and using
a Kolmogorov-Smirnov distance.</p>
</dd>
</dl>

<p>The four methods are described in Hofert et al. (2013); see also the
&lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="emde_+3A_interval">interval</code></td>
<td>
<p>bivariate vector denoting the interval where
optimization takes place.  The default is computed as described in
Hofert et al. (2013).</p>
</td></tr>
<tr><td><code id="emde_+3A_include.k">include.K</code></td>
<td>
<p>logical indicating whether the last component, the
(possibly numerically challenging) Kendall distribution function
<code class="reqn">K</code>, is used (<code>include.K=TRUE</code>) or not.  Note that the default is
<code><a href="base.html#topic+FALSE">FALSE</a></code> here, where it is <code>TRUE</code> in the underlying
<code><a href="#topic+htrafo">htrafo</a>()</code> function.</p>
</td></tr>
<tr><td><code id="emde_+3A_repara">repara</code></td>
<td>
<p>logical indicating whether the distance function to be
optimized is reparametrized (the default); see the code for more
details.</p>
</td></tr>
<tr><td><code id="emde_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="stats.html#topic+optimize">optimize</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, <code><a href="#topic+htrafo">htrafo</a></code> is applied to map the
<code class="reqn">n\times d</code>-matrix of given realizations to a
<code class="reqn">n\times d</code>-matrix or <code class="reqn">n\times (d-1)</code>-matrix, depending on whether the last
component is included (<code>include.K=TRUE</code>) or not.  Second, using
either the sum of squares of the standard normal quantile function
(<code>method="mde.chisq.CvM"</code> and
<code>method="mde.chisq.KS"</code>) or the sum of negative logarithms
(<code>method="mde.gamma.CvM"</code> and <code>method="mde.gamma.KS"</code>), a map to a
chi-square or an Erlang distribution is applied, respectively.  Finally, a
Cramér-von Mises (<code>method="mde.chisq.CvM"</code> and
<code>method="mde.gamma.CvM"</code>) or Kolmogorov-Smirnov
(<code>method="mde.chisq.KS"</code> and <code>method="mde.gamma.KS"</code>) distance is
applied.  This is repeated in an optimization until the copula parameter is
found such that this distance is minimized.
</p>
<p>Note that the same transformations as described above are applied for
goodness-of-fit testing; see the &lsquo;See Also&rsquo; section).
</p>


<h3>Value</h3>

<p><code><a href="base.html#topic+list">list</a></code> as returned by <code><a href="stats.html#topic+optimize">optimize</a></code>, including the
minimum distance estimator.
</p>


<h3>References</h3>

<p>Hofert, M., Mächler, M., and McNeil, A. J. (2013).
Archimedean Copulas in High Dimensions: Estimators and Numerical
Challenges Motivated by Financial Applications.
<em>Journal de la Société Française de
Statistique</em>
<b>154</b>(1), 25&ndash;63.
</p>
<p>Hering, C. and Hofert, M. (2014),
Goodness-of-fit tests for Archimedean copulas in high dimensions,
<em>Innovations in Quantitative Risk Management</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+enacopula">enacopula</a></code> (wrapper for different estimators),
<code><a href="#topic+gofCopula">gofCopula</a></code> (wrapper for different goodness-of-fit tests),
<code><a href="#topic+htrafo">htrafo</a></code> (transformation to a multivariate uniform
distribution), and
<code><a href="#topic+K">K</a></code> (Kendall distribution function).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau &lt;- 0.25
(theta &lt;- copGumbel@iTau(tau)) # 4/3
d &lt;- 20
(cop &lt;- onacopulaL("Gumbel", list(theta,1:d)))

set.seed(1)
n &lt;- 200
U &lt;- rnacopula(n, cop)

(meths &lt;- eval(formals(emde)$method)) # "mde.chisq.CvM", ...
fun &lt;- function(meth, u, cop, theta){
	run.time &lt;- system.time(val &lt;- emde(u, cop=cop, method=meth)$minimum)
	list(value=val, error=val-theta, utime.ms=1000*run.time[[1]])
}
(res &lt;- sapply(meths, fun, u=U, cop=cop, theta=theta))
</code></pre>

<hr>
<h2 id='emle'>Maximum Likelihood Estimators for (Nested) Archimedean Copulas</h2><span id='topic+emle'></span><span id='topic+.emle'></span>

<h3>Description</h3>

<p>Compute (simulated) maximum likelihood estimators for (nested)
Archimedean copulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emle(u, cop, n.MC=0, optimizer="optimize", method,
     interval=initOpt(cop@copula@name),
     start=list(theta=initOpt(cop@copula@name, interval=FALSE, u=u)),
     ...)
.emle(u, cop, n.MC=0,
      interval=initOpt(cop@copula@name), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emle_+3A_u">u</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix of (pseudo-)observations (each
value in <code class="reqn">[0,1]</code>) from the copula, with <code class="reqn">n</code> the sample size
and <code class="reqn">d</code> the dimension.</p>
</td></tr>
<tr><td><code id="emle_+3A_cop">cop</code></td>
<td>
<p><code><a href="#topic+outer_nacopula-class">outer_nacopula</a></code> to be estimated
(currently only non-nested, that is,
Archimedean copulas are admitted).</p>
</td></tr>
<tr><td><code id="emle_+3A_n.mc">n.MC</code></td>
<td>
<p><code><a href="base.html#topic+integer">integer</a></code>, if positive, <em>simulated</em> maximum
likelihood estimation (SMLE) is used with sample size equal to
<code>n.MC</code>; otherwise (<code>n.MC=0</code>), MLE.  In SMLE, the <code class="reqn">d</code>th
generator derivative and thus the copula density is evaluated via
(Monte Carlo) simulation, whereas MLE uses the explicit formulas for
the generator derivatives; see the details below.
</p>
</td></tr>
<tr><td><code id="emle_+3A_optimizer">optimizer</code></td>
<td>
<p>a string or <code>NULL</code>, indicating the optimizer to
be used, where <code>NULL</code> means to use <code><a href="stats.html#topic+optim">optim</a></code> via the
standard <span class="rlang"><b>R</b></span> function <code><a href="stats4.html#topic+mle">mle</a>()</code> from (base <span class="rlang"><b>R</b></span>) package <span class="pkg">stats4</span>,
whereas the default, <code>"optimize"</code> uses <code><a href="stats.html#topic+optimize">optimize</a></code> via
the <span class="rlang"><b>R</b></span> function <code><a href="bbmle.html#topic+mle2">mle2</a>()</code> from package <a href="https://CRAN.R-project.org/package=bbmle"><span class="pkg">bbmle</span></a>.</p>
</td></tr>
<tr><td><code id="emle_+3A_method">method</code></td>
<td>
<p>only when <code>optimizer</code> is <code>NULL</code> or
<code>"optim"</code>, the method to be used for <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="emle_+3A_interval">interval</code></td>
<td>
<p>bivariate vector denoting the interval where
optimization takes place.  The default is computed as described in
Hofert et al. (2012).</p>
</td></tr>
<tr><td><code id="emle_+3A_start">start</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> of initial values, passed through.</p>
</td></tr>
<tr><td><code id="emle_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="stats.html#topic+optimize">optimize</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exact formulas for the generator derivatives were derived in Hofert
et al. (2012).  Based on these formulas one can compute the
(log-)densities of the Archimedean copulas.  Note that for some
densities, the formulas are numerically highly non-trivial to compute
and considerable efforts were put in to make the computations
numerically feasible even in large dimensions (see the source code of
the Gumbel copula, for example).  Both MLE and SMLE showed good
performance in the simulation study conducted by Hofert et
al. (2013) including the challenging 100-dimensional case.
Alternative estimators (see also <code><a href="#topic+enacopula">enacopula</a></code>) often used
because of their numerical feasibility, might break down in much
smaller dimensions.
</p>
<p>Note: SMLE for Clayton currently faces serious numerical issues and is
due to further research.  This is only interesting from a theoretical point
of view, since the exact derivatives are known and numerically non-critical
to evaluate.
</p>


<h3>Value</h3>


<dl>
<dt>emle</dt><dd>
<p>an <span class="rlang"><b>R</b></span> object of class <code>"<a href="bbmle.html#topic+mle2-class">mle2</a>"</code> (and
thus useful for obtaining confidence intervals) with the
(simulated) maximum likelihood estimator.</p>
</dd>
<dt>.emle</dt><dd><p><code><a href="base.html#topic+list">list</a></code> as returned by
<code><a href="stats.html#topic+optimize">optimize</a>()</code> including the maximum likelihood
estimator (does not confidence intervals but is typically faster).</p>
</dd>
</dl>



<h3>References</h3>

<p>Hofert, M., Mächler, M., and McNeil, A. J. (2012).
Likelihood inference for Archimedean copulas in high dimensions
under known margins. <em>Journal of Multivariate Analysis</em>
<b>110</b>, 133&ndash;150.
</p>
<p>Hofert, M., Mächler, M., and McNeil, A. J. (2013).
Archimedean Copulas in High Dimensions: Estimators and Numerical
Challenges Motivated by Financial Applications.
<em>Journal de la Société Française de
Statistique</em> <b>154</b>(1), 25&ndash;63.
</p>


<h3>See Also</h3>

<p><code><a href="bbmle.html#topic+mle2">mle2</a></code> from package <span class="pkg">bbmle</span> and
<code><a href="stats4.html#topic+mle">mle</a></code> from <span class="pkg">stats4</span> on which <code>mle2</code> is
modeled. <code><a href="#topic+enacopula">enacopula</a></code> (wrapper for different estimators).
<code><a href="utils.html#topic+demo">demo</a>(opC-demo)</code> and <code><a href="utils.html#topic+demo">demo</a>(GIG-demo)</code> for
examples of two-parameter families.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau &lt;- 0.25
(theta &lt;- copGumbel@iTau(tau)) # 4/3
d &lt;-  20
(cop &lt;- onacopulaL("Gumbel", list(theta,1:d)))

set.seed(1)
n &lt;- 200
U &lt;- rnacopula(n,cop)

## Estimation
system.time(efm &lt;- emle(U, cop))
summary(efm) # using bblme's 'mle2' method

## Profile likelihood plot [using S4 methods from bbmle/stats4] :
pfm &lt;- profile(efm)
ci  &lt;- confint(pfm, level=0.95)
ci
stopifnot(ci[1] &lt;= theta, theta &lt;= ci[2])
plot(pfm)               # |z| against theta, |z| = sqrt(deviance)
plot(pfm, absVal=FALSE, #  z  against theta
     show.points=TRUE) # showing how it's interpolated
## and show the true theta:
abline(v=theta, col="lightgray", lwd=2, lty=2)
axis(1, pos = 0, at=theta, label=quote(theta[0]))

## Plot of the log-likelihood, MLE  and  conf.int.:
logL &lt;- function(x) -efm@minuslogl(x)
       # == -sum(copGumbel@dacopula(U, theta=x, log=TRUE))
logL. &lt;- Vectorize(logL)
I &lt;- c(cop@copula@iTau(0.1), cop@copula@iTau(0.4))
curve(logL., from=I[1], to=I[2], xlab=quote(theta),
      ylab="log-likelihood",
      main="log-likelihood for Gumbel")
abline(v = c(theta, efm@coef), col="magenta", lwd=2, lty=2)
axis(1, at=c(theta, efm@coef), padj = c(-0.5, -0.8), hadj = -0.2,
     col.axis="magenta", label= expression(theta[0], hat(theta)[n]))
abline(v=ci, col="gray30", lwd=2, lty=3)
text(ci[2], extendrange(par("usr")[3:4], f= -.04)[1],
     "95% conf. int.", col="gray30", adj = -0.1)
</code></pre>

<hr>
<h2 id='empCopula'>The Empirical Copula</h2><span id='topic+F.n'></span><span id='topic+dCn'></span><span id='topic+C.n'></span><span id='topic+empCopula'></span><span id='topic+Cn'></span><span id='topic+toEmpMargins'></span>

<h3>Description</h3>

<p>Computes the empirical copula (according to a provided method) and
auxiliary tools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empCopula(X, smoothing = c("none", "beta", "checkerboard",
                           "schaake.shuffle"), offset = 0,
          ties.method = c("max", "average", "first", "last", "random", "min"))
C.n(u, X, smoothing = c("none", "beta", "checkerboard"), offset = 0,
    ties.method = c("max", "average", "first", "last", "random", "min"))
dCn(u, U, j.ind = 1:d, b = 1/sqrt(nrow(U)), ...)
F.n(x, X, offset = 0, smoothing = c("none", "beta", "checkerboard"))
Cn(x, w) ## &lt;-- deprecated!  use  C.n(w, x) instead!
toEmpMargins(U, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empCopula_+3A_x">X</code></td>
<td>
<p>an <code class="reqn">(n, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of pseudo-observations
with <code class="reqn">d</code> columns (as <code>x</code> or <code>u</code>). Recall that a
multivariate random sample can be transformed to pseudo-observations
via <code><a href="#topic+pobs">pobs</a>()</code>. For <code>F.n()</code> and if <code>smoothing !=
      "none"</code>, <code>X</code> can also be a general, multivariate sample,
in which case the empirical distribution function is computed.</p>
</td></tr>
<tr><td><code id="empCopula_+3A_u">u</code>, <code id="empCopula_+3A_w">w</code></td>
<td>
<p>an <code class="reqn">(m, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> with elements in
<code class="reqn">[0,1]</code> whose rows contain the evaluation points of the
empirical copula.</p>
</td></tr>
<tr><td><code id="empCopula_+3A_u">U</code></td>
<td>
<p>an <code class="reqn">(n,d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of
pseudo- (or copula-)observations (elements in <code class="reqn">[0,1]</code>,
same number <code class="reqn">d</code> of columns as <code>u</code> (for <code>dCn()</code>))
or <code>x</code> (for <code>toEmpMargins()</code>).</p>
</td></tr>
<tr><td><code id="empCopula_+3A_x">x</code></td>
<td>
<p>an <code class="reqn">(m, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> whose rows
contain the evaluation points of the empirical distribution&lt; function
(if <code>smoothing = "none"</code>) or copula (if <code>smoothing != "none"</code>).</p>
</td></tr>
<tr><td><code id="empCopula_+3A_smoothing">smoothing</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string specifying the type of
smoothing of the empirical distribution function (for <code>F.n()</code>)
or the empirical copula (for <code>C.n()</code>). Available are:
</p>

<dl>
<dt><code>"none"</code></dt><dd><p>the original empirical distribution function
or empirical copula.</p>
</dd>
<dt><code>"beta"</code></dt><dd><p>the empirical beta smoothed distribution
function or empirical beta copula.</p>
</dd>
<dt><code>"checkerboard"</code></dt><dd><p>empirical checkerboard construction.</p>
</dd>
<dt><code>"schaake.shuffle"</code></dt><dd><p>in each dimension, <code>n</code>
(so <code>nrow(X)</code>-many) sorted standard uniforms are used
to construct a smooth sample, from which one draws with
replacement as many observations as required; only available
for the empirical copula and only for sampling.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="empCopula_+3A_ties.method">ties.method</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string specifying how ranks should be computed if
there are ties in any of the coordinate samples of <code>x</code>; passed
to <code><a href="#topic+pobs">pobs</a></code>.</p>
</td></tr>
<tr><td><code id="empCopula_+3A_j.ind">j.ind</code></td>
<td>
<p><code><a href="base.html#topic+integer">integer</a></code> vector of indices <code class="reqn">j</code> between 1
and <code class="reqn">d</code> indicating the dimensions with respect to which
first-order partial derivatives are approximated.</p>
</td></tr>
<tr><td><code id="empCopula_+3A_b">b</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code> giving the bandwidth for approximating
first-order partial derivatives.</p>
</td></tr>
<tr><td><code id="empCopula_+3A_offset">offset</code></td>
<td>
<p>used in scaling the result which is of the form
<code>sum(....)/(n+offset)</code>; defaults to zero.</p>
</td></tr>
<tr><td><code id="empCopula_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>dCn()</code> or
<code>sort()</code> underlying <code>toEmpMargins()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given pseudo-observations from a distribution with continuous margins
and copula C, the <em>empirical copula</em> is the (default) empirical
distribution function of these pseudo-observations.  It is thus a
natural nonparametric estimator of C. The function <code>C.n()</code>
computes the empirical copula or two alternative smoothed versions of
it: the <em>empirical beta copula</em> or the <em>empirical
checkerboard copula</em>; see Eqs. (2.1) and (4.1) in Segers, Sibuya and
Tsukahara (2017), and the references therein. <code>empCopula()</code>
is the constructor of an object of class <code><a href="#topic+empCopula-class">empCopula</a></code>.
</p>
<p>The function <code>dCn()</code> approximates first-order partial derivatives
of the unknown copula using the empirical copula.
</p>
<p>The function <code>F.n()</code> computes the empirical distribution function
of a multivariate sample. Note that <code>C.n(u, X, smoothing="none",
  *)</code> simply calls <code>F.n(u, pobs(X), *)</code> after checking <code>u</code>.
</p>
<p>There are several asymptotically equivalent definitions of the
empirical copula. <code>C.n(, smoothing = "none")</code> is simply defined
as the empirical distribution function computed from the
pseudo-observations, that is,
</p>
<p style="text-align: center;"><code class="reqn">C_n(\bm{u})=\frac{1}{n}\sum_{i=1}^n\mathbf{1}_{\{\hat{\bm{U}}_i\le\bm{u}\}},</code>
</p>
<p> where <code class="reqn">\hat{\bm{U}}_i</code>,
<code class="reqn">i\in\{1,\dots,n\}</code>, denote the pseudo-observations and
<code class="reqn">n</code> the sample size. Internally, <code>C.n(,smoothing = "none")</code>
is just a wrapper for <code>F.n()</code> and is expected to be fed with the
pseudo-observations.
</p>
<p>The approximation for the <code class="reqn">j</code>th partial derivative of the unknown
copula <code class="reqn">C</code> is implemented as, for example, in Rémillard and Scaillet
(2009), 
and given by
</p>
<p style="text-align: center;"><code class="reqn">\hat{\dot{C}}_{jn}(\bm{u})=\frac{C_n(u_1,..,u_{j-1},min(u_j+b,1),u_{j+1},..,u_d)-C_n(u_1,..,u_{j-1},max(u_j-b,0),u_{j+1},..,u_d)}{2b},</code>
</p>

<p>where <code class="reqn">b</code> denotes the bandwidth and <code class="reqn">C_n</code> the empirical copula.
</p>


<h3>Value</h3>

<p><code>empCopula()</code> is the constructor for objects of class
<code><a href="#topic+empCopula-class">empCopula</a></code>.
</p>
<p><code>C.n()</code> returns the empirical copula of the pseudo-observations
<code>X</code> evaluated at <code>u</code> (or a smoothed version of it).






</p>
<p><code>dCn()</code> returns a vector (<code>length(j.ind)</code> is 1) or a matrix
(with number of columns equal to <code>length(j.ind)</code>), containing
the approximated first-order partial derivatives of the unknown
copula at <code>u</code> with respect to the arguments in <code>j.ind</code>.
</p>
<p><code>F.n()</code> returns the empirical distribution function of <code>X</code>
evaluated at <code>x</code> if <code>smoothing = "none"</code>, the empirical beta
copula evaluated at <code>x</code> if <code>smoothing = "beta"</code> and the empirical
checkerboard copula evaluated at <code>x</code> if <code>smoothing =
    "checkerboard"</code>.





</p>
<p><code>toEmpMargins()</code> transforms the copula sample <code>U</code> to the
empirical margins based on the sample <code>x</code>.
</p>


<h3>Note</h3>

<p>The first version of our empirical copula implementation, <code>Cn()</code>,
had its two arguments <em>reversed</em> compared to <code>C.n()</code>, and is
deprecated now.  You <b>must</b> swap its arguments to transform to
new code.
</p>
<p>The use of the two smoothed versions assumes implicitly no
ties in the component samples of the data.
</p>


<h3>References</h3>

<p>Rüschendorf, L. (1976).  Asymptotic distributions of
multivariate rank order statistics,
<em>Annals of Statistics</em> <b>4</b>, 912&ndash;923.
</p>
<p>Deheuvels, P. (1979).  La fonction de dépendance empirique et ses
propriétés: un test non paramétrique d'indépendance,
<em>Acad. Roy. Belg. Bull. Cl. Sci.</em>, 5th Ser. <b>65</b>, 274&ndash;292.
</p>
<p>Deheuvels, P. (1981).  A non parametric test for independence,
<em>Publ. Inst. Statist. Univ. Paris</em> <b>26</b>, 29&ndash;50.
</p>
<p>Clark, M., Gangopadhyay, S., Hay, L., Rajagopalan, B. and Wilby,
R. (2004). The Schaake Shuffle: A Method for Reconstructing Space-Time
Variability in Forecasted Precipitation and Temperature Fields.
<em>Journal of Hydrometeorology</em>, pages 243-262.
</p>
<p>Rémillard, B. and Scaillet, O. (2009). Testing for equality
between two copulas. <em>Journal of Multivariate Analysis</em>, 100(3),
pages 377-386.
</p>
<p>Segers, J., Sibuya, M. and Tsukahara, H. (2017). The Empirical Beta
Copula. <em>Journal of Multivariate Analysis</em>, 155, pages 35&ndash;51,
<a href="https://arxiv.org/abs/1607.04430">https://arxiv.org/abs/1607.04430</a>.
</p>
<p>Kiriliouk, A., Segers, J. and Tsukahara, H. (2020).
Resampling Procedures with Empirical Beta Copulas.
<a href="https://arxiv.org/abs/1905.12466">https://arxiv.org/abs/1905.12466</a>.
</p>





<h3>See Also</h3>

<p><code><a href="#topic+pobs">pobs</a>()</code> for computing pseudo-observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate data X (from a meta-Gumbel model with N(0,1) margins)
n &lt;- 100
d &lt;- 3
family &lt;- "Gumbel"
theta &lt;- 2
cop &lt;- onacopulaL(family, list(theta=theta, 1:d))
set.seed(1)
X &lt;- qnorm(rCopula(n, cop)) # meta-Gumbel data with N(0,1) margins

## Evaluate empirical copula
u &lt;- matrix(runif(n*d), n, d) # random points were to evaluate the empirical copula
ec &lt;- C.n(u, X = X)

## Compare the empirical copula with the true copula
pc &lt;- pCopula(u, copula = cop)
mean(abs(pc - ec)) # ~= 0.012 -- increase n to decrease this error

## The same for the two smoothed versions
beta &lt;- C.n(u, X, smoothing = "beta")
mean(abs(pc - beta))
check &lt;- C.n(u, X, smoothing = "checkerboard")
mean(abs(pc - check))

## Compare the empirical copula with F.n(pobs())
U &lt;- pobs(X) # pseudo-observations
stopifnot(identical(ec, F.n(u, X = pobs(U)))) # even identical

## Compare the empirical copula based on U at U with the Kendall distribution
## Note: Theoretically, C(U) ~ K, so K(C_n(U, U = U)) should approximately be U(0,1)
plot(ecdf(pK(C.n(U, X), cop = cop@copula, d = d)), asp = 1, xaxs="i", yaxs="i")
segments(0,0, 1,1, col=adjustcolor("blue",1/3), lwd=5, lty = 2)
abline(v=0:1, col="gray70", lty = 2)

## Compare the empirical copula and the true copula on the diagonal
C.n.diag &lt;- function(u) C.n(do.call(cbind, rep(list(u), d)), X = X) # diagonal of C_n
C.diag &lt;- function(u) pCopula(do.call(cbind, rep(list(u), d)), cop) # diagonal of C
curve(C.n.diag, from = 0, to = 1, # empirical copula diagonal
      main = paste("True vs empirical diagonal of a", family, "copula"),
      xlab = "u", ylab = quote("True C(u,..,u) and empirical"~C[n](u,..,u)))
curve(C.diag, lty = 2, add = TRUE) # add true copula diagonal
legend("bottomright", lty = 2:1, bty = "n", inset = 0.02,
       legend = expression(C, C[n]))

## Approximate partial derivatives w.r.t. the 2nd and 3rd component
j.ind &lt;- 2:3 # indices w.r.t. which the partial derivatives are computed
## Partial derivatives based on the empirical copula and the true copula
der23 &lt;- dCn(u, U = pobs(U), j.ind = j.ind)
der23. &lt;- copula:::dCdu(archmCopula(family, param=theta, dim=d), u=u)[,j.ind]
## Approximation error
summary(as.vector(abs(der23-der23.)))

## For an example of using F.n(), see help(mvdc)% ./Mvdc.Rd

## Generate a bivariate empirical copula object (various smoothing methods)
n &lt;- 10 # sample size
d &lt;- 2 # dimension
set.seed(271)
X &lt;- rCopula(n, copula = claytonCopula(3, dim = d))
ecop.orig  &lt;- empCopula(X) # smoothing = "none"
ecop.beta  &lt;- empCopula(X, smoothing = "beta")
ecop.check &lt;- empCopula(X, smoothing = "checkerboard")

## Sample from these (smoothed) empirical copulas
m &lt;- 50
U.orig  &lt;-  rCopula(m, copula = ecop.orig)
U.beta  &lt;-  rCopula(m, copula = ecop.beta)
U.check &lt;-  rCopula(m, copula = ecop.check)

## Plot
wireframe2(ecop.orig,  FUN = pCopula, draw.4.pCoplines = FALSE)
wireframe2(ecop.beta,  FUN = pCopula)
wireframe2(ecop.check, FUN = pCopula)
## Density (only exists when smoothing = "beta")
wireframe2(ecop.beta,  FUN = dCopula)

## Transform a copula sample to empirical margins
set.seed(271)
X &lt;- qexp(rCopula(1000, copula = claytonCopula(2))) # multivariate distribution
U &lt;- rCopula(917, copula = gumbelCopula(2)) # new copula sample
X. &lt;- toEmpMargins(U, x = X) # tranform U to the empirical margins of X
plot(X.) # Gumbel sample with empirical margins of X
</code></pre>

<hr>
<h2 id='empCopula-class'>Class &quot;empCopula&quot; of Empirical Copulas</h2><span id='topic+empCopula-class'></span><span id='topic+dim+2CempCopula-method'></span>

<h3>Description</h3>

<p>Empirical Copula class.
</p>


<h3>Objects from the Class</h3>

<p>Created by calls of the form <code>new("empCopula", ...)</code> or rather
typically by <code><a href="#topic+empCopula">empCopula</a>()</code> based on a matrix
<code>X</code> of pseudo-observations.  Smoothing options are available, see
there.
</p>


<h3>Slots</h3>


<dl>
<dt><code>X</code>:</dt><dd><p><code><a href="base.html#topic+matrix">matrix</a></code> of pseudo-observations based
on which the empirical copula is constructed.</p>
</dd>
<dt><code>smoothing</code>:</dt><dd><p><code><a href="base.html#topic+character">character</a></code> string determining
the smoothing method.</p>
</dd>
<dt><code>offset</code>:</dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code> giving the shift in the
normalizing factor for computing the empirical copula.</p>
</dd>

<dt><code>ties.method</code>:</dt><dd><p>a string indicating <code><a href="base.html#topic+rank">rank</a>()</code>'s
ties method for computing the empirical copula.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>The class constructor are <code><a href="#topic+empCopula">empCopula</a>()</code>, also for
examples.
</p>

<hr>
<h2 id='enacopula'>Estimation Procedures for (Nested) Archimedean Copulas</h2><span id='topic+enacopula'></span>

<h3>Description</h3>

<p>A set of ten different estimators, currently for one-parameter
Archimedean copulas, of possibly quite high dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enacopula(u, cop,
          method = c("mle", "smle", "dmle",
                     "mde.chisq.CvM", "mde.chisq.KS",
                     "mde.gamma.CvM", "mde.gamma.KS",
                     "tau.tau.mean", "tau.theta.mean", "beta"),
          n.MC = if (method == "smle") 10000 else 0,
          interval = initOpt(cop@copula@name),
          xargs = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enacopula_+3A_u">u</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix of (pseudo-)observations (each
value in <code class="reqn">[0,1]</code>) from the copula to be estimated, where <code class="reqn">n</code>
denotes the sample size and <code class="reqn">d</code> the dimension.  Consider applying the
function <code><a href="#topic+pobs">pobs</a></code> first in order to obtain <code>u</code>.</p>
</td></tr>
<tr><td><code id="enacopula_+3A_cop">cop</code></td>
<td>
<p><code><a href="#topic+outer_nacopula-class">outer_nacopula</a></code> to be estimated
(currently only Archimedean copulas are provided).</p>
</td></tr>
<tr><td><code id="enacopula_+3A_method">method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the
estimation method to be used, which has to be one (or a unique
abbreviation) of
</p>

<dl>
<dt><code>"mle"</code></dt><dd><p>maximum likelihood estimator (MLE) computed
via <code><a href="#topic+.emle">.emle</a></code>.</p>
</dd>
<dt><code>"smle"</code></dt><dd><p>simulated maximum likelihood estimator (SMLE)
computed with the function <code><a href="#topic+.emle">.emle</a></code>, where
<code>n.MC</code> gives the Monte Carlo sample size.</p>
</dd>
<dt><code>"dmle"</code></dt><dd><p>MLE based on the diagonal (DMLE); see
<code><a href="#topic+edmle">edmle</a></code>.</p>
</dd>
<dt><code>"mde.chisq.CvM"</code></dt><dd><p>minimum distance estimator based
on the chisq distribution and Cramér-von Mises
distance; see <code><a href="#topic+emde">emde</a></code>.</p>
</dd>
<dt><code>"mde.chisq.KS"</code></dt><dd><p>minimum distance estimation based on
the chisq distribution and Kolmogorov-Smirnov distance; see
<code><a href="#topic+emde">emde</a></code>.</p>
</dd>
<dt><code>"mde.gamma.CvM"</code></dt><dd><p>minimum distance estimation based on
the Erlang distribution and Cramér-von Mises distance;
see <code><a href="#topic+emde">emde</a></code>.</p>
</dd>
<dt><code>"mde.gamma.KS"</code></dt><dd><p>minimum distance estimation based on
the Erlang distribution and Kolmogorov-Smirnov distance; see
<code><a href="#topic+emde">emde</a></code>.</p>
</dd>
<dt><code>"tau.tau.mean"</code></dt><dd><p>averaged pairwise Kendall's tau estimator</p>
</dd>
<dt><code>"tau.theta.mean"</code></dt><dd><p>average of pairwise Kendall's tau
estimators</p>
</dd>
<dt><code>"beta"</code></dt><dd><p>multivariate Blomqvist's beta estimator</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="enacopula_+3A_n.mc">n.MC</code></td>
<td>
<p>only for <code>method = "smle"</code>: <code><a href="base.html#topic+integer">integer</a></code>,
sample size for simulated maximum likelihood estimation.</p>
</td></tr>
<tr><td><code id="enacopula_+3A_interval">interval</code></td>
<td>
<p>bivariate vector denoting the interval where
optimization takes place.  The default is computed as described in
Hofert et al. (2012).  Used for all methods except
<code>"tau.tau.mean"</code> and <code>"tau.theta.mean"</code>.</p>
</td></tr>
<tr><td><code id="enacopula_+3A_xargs">xargs</code></td>
<td>
<p>list of additional arguments for the chosen estimation method.</p>
</td></tr>
<tr><td><code id="enacopula_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="stats.html#topic+optimize">optimize</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+enacopula">enacopula</a></code> serves as a wrapper for the different
implemented estimators and provides a uniform framework to utilize
them.  For more information, see the single estimators as given in the
section &lsquo;See Also&rsquo;.
</p>
<p>Note that Hofert, Mächler, and McNeil (2013) compared these
estimators. Their findings include a rather poor performance and numerically
challenging problems of some of these estimators. In particular, the
estimators obtained by <code>method="mde.gamma.CvM"</code>,
<code>method="mde.gamma.KS"</code>, <code>method="tau.theta.mean"</code>, and
<code>method="beta"</code> should be used with care (or not at all). Overall, MLE
performed best (by far).
</p>


<h3>Value</h3>

<p>the estimated parameter, <code class="reqn">\hat{\theta}</code>, that is, currently a
number as only one-parameter Archimedean copulas are considered.
</p>


<h3>References</h3>

<p>Hofert, M., Mächler, M., and McNeil, A. J. (2012).
Likelihood inference for Archimedean copulas in high dimensions
under known margins. <em>Journal of Multivariate Analysis</em>
<b>110</b>, 133&ndash;150.
</p>
<p>Hofert, M., Mächler, M., and McNeil, A. J. (2013).
Archimedean Copulas in High Dimensions: Estimators and Numerical
Challenges Motivated by Financial Applications.
<em>Journal de la Société Française de
Statistique</em>
<b>154</b>(1), 25&ndash;63.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emle">emle</a></code> which returns an object of <code>"<a href="stats4.html#topic+mle-class">mle</a>"</code>
providing useful methods not available for other estimators.
<code><a href="utils.html#topic+demo">demo</a>(opC-demo)</code> and <code>vignette("GIG", package="copula")</code> for
examples of two-parameter families.
<code><a href="#topic+edmle">edmle</a></code> for the diagonal maximum likelihood estimator.
<code><a href="#topic+emde">emde</a></code> for the minimum distance estimators.
<code><a href="#topic+etau">etau</a></code> for the estimators based on Kendall's tau.
<code><a href="#topic+ebeta">ebeta</a></code> for the estimator based on Blomqvist's beta.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau &lt;- 0.25
(theta &lt;- copGumbel@iTau(tau)) # 4/3
d &lt;- 12
(cop &lt;- onacopulaL("Gumbel", list(theta,1:d)))

set.seed(1)
n &lt;- 100
U &lt;- rnacopula(n, cop)

meths &lt;- eval(formals(enacopula)$method)

fun &lt;- function(meth, u, cop, theta) {
	run.time &lt;- system.time(val &lt;- enacopula(u, cop=cop, method=meth))
	list(value=val, error=val-theta, utime.ms=1000*run.time[[1]])
}
t(res &lt;- sapply(meths, fun, u=U, cop=cop, theta=theta))
</code></pre>

<hr>
<h2 id='estim.misc'>Various Estimators for (Nested) Archimedean Copulas</h2><span id='topic+ebeta'></span><span id='topic+edmle'></span><span id='topic+etau'></span>

<h3>Description</h3>

<p>Various Estimators for (Nested) Archimedean Copulas, namely,
</p>

<dl>
<dt>ebeta</dt><dd><p>Method-of-moments-like estimator based on (a
multivariate version of) Blomqvist'sbeta.</p>
</dd>
<dt>edmle</dt><dd><p>Maximum likelihood estimator based on the diagonal of a
(nested) Archimedean copula.</p>
</dd>
<dt>etau</dt><dd><p>Method-of-moments-like estimators based on (bivariate)
Kendall's tau.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>ebeta(u, cop, interval = initOpt(cop@copula@name), ...)
edmle(u, cop, interval = initOpt(cop@copula@name), warn=TRUE, ...)
 etau(u, cop, method = c("tau.mean", "theta.mean"), warn=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estim.misc_+3A_u">u</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix of (pseudo-)observations (each
value in <code class="reqn">[0,1]</code>) from the copula, where <code class="reqn">n</code> denotes the
sample size and <code class="reqn">d</code> the dimension.</p>
</td></tr>
<tr><td><code id="estim.misc_+3A_cop">cop</code></td>
<td>
<p><code><a href="#topic+outer_nacopula-class">outer_nacopula</a></code> to be estimated
(currently only Archimedean copulas are provided).</p>
</td></tr>
<tr><td><code id="estim.misc_+3A_interval">interval</code></td>
<td>
<p>bivariate vector denoting the interval where
optimization takes place.  The default is computed as described in Hofert et
al. (2013).</p>
</td></tr>
<tr><td><code id="estim.misc_+3A_method">method</code></td>
<td>
<p>a character string specifying the method (only
for <code>etau</code>), which has to be one (or a unique abbreviation) of
</p>

<dl>
<dt><code>"tau.mean"</code></dt><dd><p>method-of-moments-like estimator based on
the average of pairwise sample versions of Kendall’s tau;</p>
</dd>
<dt><code>"theta.mean"</code></dt><dd><p>average of the method-of-moments-like
Kendall's tau estimators.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="estim.misc_+3A_warn">warn</code></td>
<td>
<p>logical indicating if warnings are printed:
</p>

<dl>
<dt><code>edmle()</code></dt><dd><p>for the family of <code>"Gumbel"</code> if the
diagonal maximum-likelihood estimator is smaller than 1.</p>
</dd>
<dt><code>etau()</code></dt><dd><p>for the family of <code>"AMH"</code> if tau is outside
<code class="reqn">[0, 1/3]</code> and in general if at least one of the computed
pairwise sample	versions of Kendall's tau is negative.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="estim.misc_+3A_...">...</code></td>
<td>
<p>additional arguments passed to
<code><a href="#topic+corKendall">corKendall</a></code> (for <code>etau</code>, but see &lsquo;Details&rsquo;),
to <code><a href="stats.html#topic+optimize">optimize</a></code> (for <code>edmle</code>), or
to <code><a href="#topic+safeUroot">safeUroot</a></code> (for <code>ebeta</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>ebeta</code>, the parameter is estimated with a
method-of-moments-like procedure such that the population version of
the multivariate Blomqvist's beta matches its sample version.
</p>
<p>Note that the copula diagonal is a distribution function and the
maximum of all components of a random vector following the copula is
distributed according to this distribution function.  For
<code>edmle</code>, the parameter is estimated via maximum-likelihood
estimation based on the diagonal.
</p>
<p>For <code>etau</code>, <code><a href="#topic+corKendall">corKendall</a>(u, ...)</code> is used and if there
are no <code><a href="base.html#topic+NA">NA</a></code>s in <code>u</code>, by default (if no additional
arguments are provided), <code>corKendall()</code> calls the <code class="reqn">O(n log(n))</code>
fast <code><a href="pcaPP.html#topic+cor.fk">cor.fk</a>()</code> from package <a href="https://CRAN.R-project.org/package=pcaPP"><span class="pkg">pcaPP</span></a>
instead of the <code class="reqn">O(n^2)</code> <code><a href="stats.html#topic+cor">cor</a>(*, method="kendall")</code>.
Conversely, when <code>u</code> has <code>NA</code>s, by default,
<code><a href="#topic+corKendall">corKendall</a>(u, ...)</code> will use
<code><a href="stats.html#topic+cor">cor</a>(u, method="kendall", use = "pairwise")</code> such that
<code>etau(u, *)</code> will work.
<br />
Furthermore, <code>method="tau.mean"</code> means that the average
of sample versions of Kendall's tau are computed first and then the
parameter is determined such that the population version of Kendall's
tau matches this average (if possible); the <code>method="theta.mean"</code>
stands for first computing all pairwise Kendall's tau estimators and
then returning the mean of these estimators.
</p>
<p>For more details, see Hofert et al. (2013).
</p>
<p>Note that these estimators should be used with care; see the
performance results in Hofert et al. (2013).  In particular,
<code>etau</code> should be used with the (default) method <code>"tau.mean"</code>
since <code>"theta.mean"</code> is both slower and more prone to errors.
</p>


<h3>Value</h3>


<dl>
<dt><code>ebeta</code></dt><dd><p>the return value of <code><a href="#topic+safeUroot">safeUroot</a></code>
(that is, typically almost the same as the value of
<code><a href="stats.html#topic+uniroot">uniroot</a></code>) giving the Blomqvist beta estimator.</p>
</dd>
<dt><code>edmle</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> as returned by
<code><a href="stats.html#topic+optimize">optimize</a></code>, including the diagonal maximum likelihood
estimator.</p>
</dd>
<dt><code>etau</code></dt><dd><p>method-of-moments-like estimator based on
Kendall's tau for the chosen method.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hofert, M., Mächler, M., and McNeil, A. J. (2013).
Archimedean Copulas in High Dimensions: Estimators and Numerical
Challenges Motivated by Financial Applications.
<em>Journal de la Société Française de
Statistique</em>
<b>154</b>(1), 25&ndash;63.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corKendall">corKendall</a>()</code>.
</p>
<p>The more sophisticated estimators <code><a href="#topic+emle">emle</a></code> (Maximum Likelihood) and
<code><a href="#topic+emde">emde</a></code> (Minimum Distance). <code><a href="#topic+enacopula">enacopula</a></code>
(wrapper for different estimators).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau &lt;- 0.25
(theta &lt;- copGumbel@iTau(tau)) # 4/3 = 1.333..
d &lt;- 20
(cop &lt;- onacopulaL("Gumbel", list(theta,1:d)))

set.seed(1)
n &lt;- 200
U &lt;- rnacopula(n, cop)

system.time(theta.hat.beta &lt;- ebeta(U, cop=cop))
theta.hat.beta$root

system.time(theta.hat.dmle &lt;- edmle(U, cop=cop))
theta.hat.dmle$minimum

system.time(theta.hat.etau &lt;- etau(U, cop=cop, method="tau.mean"))
theta.hat.etau

system.time(theta.hat.etau. &lt;- etau(U, cop=cop, method="theta.mean"))
theta.hat.etau.

## etau()  in the case of missing values (NA's)
## ------                 ---------------------
##' @title add Missing Values completely at random
##' @param x  matrix or vector
##' @param prob desired probability ("fraction") of missing values (\code{\link{NA}}s).
##' @return x[] with some (100*prob percent) entries replaced by \code{\link{NA}}s.
addNAs &lt;- function(x, prob) {
    np &lt;- length(x)
    x[sample.int(np, prob*np)] &lt;- NA
    x
}

## UM[] := U[] with 5% missing values
set.seed(7); UM &lt;- addNAs(U, p = 0.05)
mean(is.na(UM)) # 0.05
## This error if x has NA's was happening for  etau(UM, cop=cop)
## before copula version 0.999-17 (June 2017) :
try(eM &lt;- etau(UM, cop=cop, use = "everything"))
        #  --&gt; Error ... NA/NaN/Inf in foreign function call
## The new default:
eM0 &lt;- etau(UM, cop=cop, use = "pairwise")
eM1 &lt;- etau(UM, cop=cop, use = "complete")
##  use = "complete" is really equivalent to dropping all obs. with with missing values:
stopifnot(all.equal(eM1, etau(na.omit(UM), cop=cop), tol = 1e-15))
## but  use = "pairwise" ---&gt; cor(*, use = "pairwise") is much better:
rbind(etau.U = theta.hat.etau, etau.UM.pairwise = eM0, etau.UM.complete = eM1)
</code></pre>

<hr>
<h2 id='evCopula'>Construction of Extreme-Value Copula Objects</h2><span id='topic+evCopula'></span><span id='topic+galambosCopula'></span><span id='topic+huslerReissCopula'></span><span id='topic+tawnCopula'></span><span id='topic+tevCopula'></span>

<h3>Description</h3>

<p>Constructs an extreme-value copula class object with its corresponding
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evCopula(family, param, dim = 2, ...)
galambosCopula(param)
huslerReissCopula(param)
tawnCopula(param)
tevCopula(param, df = 4, df.fixed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evCopula_+3A_family">family</code></td>
<td>
<p>a character string specifying the family of an
extreme-value copula.  Currently implemented are 
<code>"galambos", "gumbel", "huslerReiss", "tawn", "tev"</code>.</p>
</td></tr>
<tr><td><code id="evCopula_+3A_param">param</code></td>
<td>
<p> a numeric vector specifying the parameter values. </p>
</td></tr>
<tr><td><code id="evCopula_+3A_dim">dim</code></td>
<td>
<p>the dimension of the copula.  Currently, only <code>"gumbel"</code>
allows <code>dim &gt; 2</code>.</p>
</td></tr>
<tr><td><code id="evCopula_+3A_df">df</code></td>
<td>
<p>a number specifying the degrees of freedom of the t
extreme-value copula, <code>tevCopula()</code>.</p>
</td></tr>
<tr><td><code id="evCopula_+3A_df.fixed">df.fixed</code></td>
<td>
<p>logical; if true, the degrees of freedom will never be
considered as a parameter to be estimated; <code>FALSE</code> means that
<code>df</code> will be estimated if the object is passed as argument to
<code><a href="#topic+fitCopula">fitCopula</a></code>.</p>
</td></tr>
<tr><td><code id="evCopula_+3A_...">...</code></td>
<td>
<p> currently nothing. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"<a href="#topic+gumbelCopula-class">gumbelCopula</a>"</code>,
<code>"<a href="#topic+galambosCopula-class">galambosCopula</a>"</code>,
<code>"<a href="#topic+huslerReissCopula-class">huslerReissCopula</a>"</code>,
<code>"<a href="#topic+tawnCopula-class">tawnCopula</a>"</code>, or <code>"<a href="#topic+tevCopula-class">tevCopula</a>"</code>.
</p>


<h3>Note</h3>

<p>The Gumbel copula is both an Archimedean and an extreme-value copula,
with principal documentation on <code><a href="#topic+gumbelCopula">gumbelCopula</a></code> (or
<code><a href="#topic+archmCopula">archmCopula</a></code>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ellipCopula">ellipCopula</a></code>, <code><a href="#topic+archmCopula">archmCopula</a></code>,
<code><a href="#topic+gofEVCopula">gofEVCopula</a></code>, <code><a href="#topic+An">An</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gumbel is both
stopifnot(identical(   evCopula("gumbel"), gumbelCopula()),
          identical(archmCopula("gumbel"), gumbelCopula()))

## For a given degree of dependence these copulas are strikingly similar :

tau &lt;- 1/3

gumbel.cop      &lt;- gumbelCopula     (iTau(gumbelCopula(),      tau))
galambos.cop    &lt;- galambosCopula   (iTau(galambosCopula(),    tau))
huslerReiss.cop &lt;- huslerReissCopula(iTau(huslerReissCopula(), tau))
tawn.cop        &lt;- tawnCopula       (iTau(tawnCopula(),        tau))
tev.cop         &lt;- tevCopula        (iTau(tevCopula(),         tau))

curve(A(gumbel.cop, x), 0, 1, ylab = "A(&lt;cop&gt;( iTau(&lt;cop&gt;(), tau)), x)",
      main = paste("A(x) for five Extreme Value cop. w/  tau =", format(tau)))
curve(A(galambos.cop, x), lty=2, add=TRUE)
curve(A(huslerReiss.cop, x), lty=3, add=TRUE)
curve(A(tawn.cop, x), lty=4, add=TRUE)
curve(A(tev.cop, x), lty=5, col=2, add=TRUE)# very close to Gumbel

## And look at the differences
curve(A(gumbel.cop, x) - A(tawn.cop, x), ylim = c(-1,1)*0.005,
      ylab = '', main = "A(&lt;Gumbel&gt;, x) - A(&lt;EV-Cop.&gt;, x)")
abline(h=0, lty=2)
curve(A(gumbel.cop, x) - A(galambos.cop, x), add=TRUE, col=2)
curve(A(gumbel.cop, x) - A(huslerReiss.cop, x), add=TRUE, col=3)
curve(A(gumbel.cop, x) - A(tev.cop, x), add=TRUE, col=4, lwd=2)


## the t-EV-copula has always positive tau :
curve(vapply(x, function(x) tau(tevCopula(x)), 0.), -1, 1,
      n=257, ylim=0:1, xlab=quote(rho),ylab=quote(tau),
      main= quote(tau( tevCopula(rho) )), col = 2, lwd = 2)
rect(-1,0,1,1, lty = 2, border = adjustcolor("black", 0.5))
</code></pre>

<hr>
<h2 id='evCopula-class'>Classes Representing Extreme-Value Copulas</h2><span id='topic+evCopula-class'></span><span id='topic+galambosCopula-class'></span><span id='topic+huslerReissCopula-class'></span><span id='topic+tawnCopula-class'></span><span id='topic+tevCopula-class'></span>

<h3>Description</h3>

<p>Class <code>evCopula</code> is the virtual (mother) class of all
extreme-value copulas.  There currently are five subclasses,
<code>"galambosCopula"</code>, <code>"huslerReissCopula"</code>,
<code>"tawnCopula"</code>, <code>"tevCopula"</code>, and <code>"gumbelCopula"</code>,
the latter of which is also an Archimedean copula, see the page for
class <code>"<a href="#topic+archmCopula-class">archmCopula</a>"</code>.
</p>


<h3>Objects from the Class</h3>

<p><code>evCopula</code> is a virtual class: No objects may be created from it.
Objects of class <code>"galambosCopula"</code> etc, can be created by calls
of the form <code>new("galambosCopula", ...)</code>, but typically rather by
<code><a href="#topic+galambosCopula">galambosCopula</a>()</code>, etc, see there.
</p>


<h3>Slots</h3>

<p>All slots are inherited from the mother class
<code>"<a href="#topic+copula-class">copula</a>"</code>, see there.
</p>


<h3>Methods</h3>


<dl>
<dt>dCopula</dt><dd><p><code>signature(copula = "galambosCopula")</code>: ... </p>
</dd>
<dt>pCopula</dt><dd><p><code>signature(copula = "galambosCopula")</code>: ... </p>
</dd>
<dt>rCopula</dt><dd><p><code>signature(copula = "galambosCopula")</code>: ... </p>
</dd>
<dt>dCopula</dt><dd><p><code>signature(copula = "huslerReissCopula")</code>: ... </p>
</dd>
<dt>pCopula</dt><dd><p><code>signature(copula = "huslerReissCopula")</code>: ... </p>
</dd>
<dt>rCopula</dt><dd><p><code>signature(copula = "huslerReissCopula")</code>: ... </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"evCopula"</code> extends class <code>"<a href="#topic+copula-class">copula</a>"</code>
directly. Classes <code>"galambosCopula"</code>, <code>"huslerReissCopula"</code>,
<code>"tawnCopula"</code>, and <code>"tevCopula"</code> extend class
<code>"evCopula"</code> directly.
</p>


<h3>Note</h3>



<p>Objects of class <code>"<a href="#topic+gumbelCopula-class">gumbelCopula</a>"</code> are also of class
<code>"<a href="#topic+archmCopula-class">archmCopula</a>"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evCopula">evCopula</a></code>,
<code><a href="#topic+evTestC">evTestC</a></code>,
<code><a href="#topic+evTestK">evTestK</a></code>,
<code><a href="#topic+gofEVCopula">gofEVCopula</a></code>,
<code><a href="#topic+copula-class">copula-class</a></code>.
</p>

<hr>
<h2 id='evTestA'>Bivariate Test of Extreme-Value Dependence Based on Pickands'
Dependence Function</h2><span id='topic+evTestA'></span>

<h3>Description</h3>

<p>Test of bivariate extreme-value dependence based on the process
comparing the empirical copula with a natural nonparametric
estimator of the unknown copula derived under extreme-value
dependence.  The test statistics are defined in the third reference.
Approximate p-values for the test statistics are obtained
by means of a <em>multiplier</em> technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evTestA(x, N = 1000, derivatives = c("An","Cn"),
        ties.method = eval(formals(rank)$ties.method),
        trace.lev = 0, report.err = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evTestA_+3A_x">x</code></td>
<td>
<p> a data matrix that will be transformed to pseudo-observations. </p>
</td></tr>
<tr><td><code id="evTestA_+3A_n">N</code></td>
<td>
<p>number of multiplier iterations to be used to simulate
realizations of the test statistic under the null hypothesis.</p>
</td></tr>
<tr><td><code id="evTestA_+3A_derivatives">derivatives</code></td>
<td>
<p>string specifying how the derivatives of the unknown
copula are estimated, either <code>"An"</code> or <code>"Cn"</code>.  The former
gives better results for samples smaller than 400 but is slower.</p>
</td></tr>
<tr><td><code id="evTestA_+3A_ties.method">ties.method</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string specifying how ranks
should be computed if there are ties in any of the coordinate
samples of <code>x</code>; passed to <code><a href="#topic+pobs">pobs</a></code>.</p>
</td></tr>
<tr><td><code id="evTestA_+3A_trace.lev">trace.lev</code></td>
<td>
<p>integer indicating the level of diagnostic tracing to be
printed to the console (from low-level algorithm).</p>
</td></tr>
<tr><td><code id="evTestA_+3A_report.err">report.err</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if numerical
integration errors should be reported in a summary way.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details are available in the third reference.
See also Genest and Segers (2009) and Remillard and Scaillet (2009).
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p> value of the test statistic. </p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p> corresponding approximate p-value. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This test was derived under the assumption of continuous margins,
which implies that ties occur with probability zero.  The
presence of ties in the data might substantially affect the
approximate p-value.
</p>


<h3>References</h3>

<p>Genest, C. and Segers, J. (2009). Rank-based inference for bivariate
extreme-value copulas. <em>Annals of Statistics</em>, 37, pages 2990-3022.
</p>
<p>Rémillard, B. and Scaillet, O. (2009). Testing for equality
between two copulas. <em>Journal of Multivariate Analysis</em>, 100(3),
pages 377-386.
</p>
<p>Kojadinovic, I. and Yan, J. (2010).
Nonparametric rank-based tests of bivariate extreme-value dependence.
<em>Journal of Multivariate Analysis</em> <b>101</b>, 2234&ndash;2249.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+evTestK">evTestK</a></code>, <code><a href="#topic+evTestC">evTestC</a></code>,
<code><a href="#topic+evCopula">evCopula</a></code>,
<code><a href="#topic+gofEVCopula">gofEVCopula</a></code>, <code><a href="#topic+An">An</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Do these data come from an extreme-value copula?
set.seed(63)
uG &lt;- rCopula(100, gumbelCopula (3))
uC &lt;- rCopula(100, claytonCopula(3))
## these two take 21 sec on nb-mm4 (Intel Core i7-5600U @ 2.60GHz):
evTestA(uG)
evTestA(uC) # significant even though Clayton is *NOT* an extreme value copula

## These are fast:
evTestA(uG, derivatives = "Cn")
evTestA(uC, derivatives = "Cn") # small p-value even though Clayton is *NOT* an EV copula.


</code></pre>

<hr>
<h2 id='evTestC'>Large-sample Test of Multivariate Extreme-Value Dependence</h2><span id='topic+evTestC'></span>

<h3>Description</h3>

<p>Test of multivariate extreme-value dependence based on the empirical
copula and max-stability. The test statistics are defined in the second
reference. Approximate p-values for the test statistics are obtained
by means of a <em>multiplier</em> technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evTestC(x, N = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evTestC_+3A_x">x</code></td>
<td>
<p> a data matrix that will be transformed to pseudo-observations. </p>
</td></tr>
<tr><td><code id="evTestC_+3A_n">N</code></td>
<td>
<p> number of multiplier iterations to be used to
simulate realizations of the test statistic under the null
hypothesis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details are available in the second reference.
See also Remillard and Scaillet (2009).
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p> value of the test statistic. </p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p> corresponding approximate p-value. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This test was derived under the assumption of continuous margins,
which implies that ties occur with probability zero. The
presence of ties in the data might substantially affect the
approximate p-value.
</p>


<h3>References</h3>

<p>Rémillard, B. and Scaillet, O. (2009). Testing for equality
between two copulas. <em>Journal of Multivariate Analysis</em>, 100(3),
pages 377-386.
</p>
<p>Kojadinovic, I., Segers, J., and Yan, J. (2011). Large-sample tests of
extreme-value dependence for multivariate copulas. <em>The Canadian
Journal of Statistics</em> <b>39</b>, 4, pages 703-720.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evTestK">evTestK</a></code>, <code><a href="#topic+evTestA">evTestA</a></code>, <code><a href="#topic+evCopula">evCopula</a></code>,
<code><a href="#topic+gofEVCopula">gofEVCopula</a></code>, <code><a href="#topic+An">An</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Do these data come from an extreme-value copula?
evTestC(rCopula(200, gumbelCopula(3)))
evTestC(rCopula(200, claytonCopula(3)))

## Three-dimensional examples
evTestC(rCopula(200, gumbelCopula(3, dim=3)))
evTestC(rCopula(200, claytonCopula(3, dim=3)))

</code></pre>

<hr>
<h2 id='evTestK'>Bivariate Test of Extreme-Value Dependence Based on Kendall's Distribution</h2><span id='topic+evTestK'></span>

<h3>Description</h3>

<p>Test of extreme-value dependence based on the  bivariate probability integral
transformation. The test statistic is defined in Ben Ghorbal,
G. Nešlehová, and Genest (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evTestK(x, method = c("fsample","asymptotic","jackknife"), ties = NA, N = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evTestK_+3A_x">x</code></td>
<td>
<p> a data matrix. </p>
</td></tr>
<tr><td><code id="evTestK_+3A_method">method</code></td>
<td>
<p> specifies the variance estimation method; can be either
<code>"fsample"</code> (finite-sample, the default), <code>"asymptotic"</code>
or <code>"jackknife"</code>.</p>
</td></tr>
<tr><td><code id="evTestK_+3A_ties">ties</code></td>
<td>
<p> logical; if <code>TRUE</code>, the original test is adapted to
take the presence of ties in the coordinate samples of <code>x</code> into
account; the default value of <code>NA</code> indicates that the
presence/absence of ties will be checked for automatically.</p>
</td></tr>
<tr><td><code id="evTestK_+3A_n">N</code></td>
<td>
<p> number of samples to be used to estimate a bias term if
<code>ties = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code for this test was generously provided by Johanna
G. Nešlehová.  More details are available in Appendix
B of Ben Ghorbal, G. Nešlehová and Genest (2009).
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p> value of the test statistic. </p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p> corresponding p-value. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Ghorbal, M. B., Genest, C., and G. Nešlehová, J. (2009)
On the test of Ghoudi, Khoudraji, and Rivest for extreme-value dependence.
<em>The Canadian Journal of Statistics</em> <b>37</b>, 1&ndash;9.
</p>
<p>Kojadinovic, I. (2017). Some copula inference procedures adapted to
the presence of ties. <em>Computational Statistics and Data
Analysis</em> <b>112</b>, 24&ndash;41, <a href="https://arxiv.org/abs/1609.05519">https://arxiv.org/abs/1609.05519</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+evTestC">evTestC</a></code>, <code><a href="#topic+evTestA">evTestA</a></code>, <code><a href="#topic+evCopula">evCopula</a></code>,
<code><a href="#topic+gofEVCopula">gofEVCopula</a></code>, <code><a href="#topic+An">An</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(321)
## Do the data come from an extreme-value copula?
evTestK(Ug &lt;- rCopula(200, gumbelCopula(3))) # not significant =&gt; yes, EV
    dim(Uc &lt;- rCopula(200, claytonCopula(3)))
## Clayton:                       tests are highly significant =&gt; no, not EV
(K1 &lt;- evTestK(Uc))
(K2 &lt;- evTestK(Uc, method = "asymptotic"))

system.time(print(K3 &lt;- evTestK(Uc, method = "jackknife")))
## slower: 1.06 sec (2015 intel core i7)


</code></pre>

<hr>
<h2 id='exchEVTest'>Test of Exchangeability for Certain Bivariate Copulas</h2><span id='topic+exchEVTest'></span>

<h3>Description</h3>

<p>Test for assessing the exchangeability of the underlying
bivariate copula when it is either extreme-value or left-tail
decreasing.  The test uses the nonparametric estimators of the
Pickands dependence function studied by Genest and Segers (2009).
</p>
<p>The test statistic is defined in the second reference.
An approximate p-value for the test statistic is obtained
by means of a <em>multiplier</em> technique if there are no ties in the
component series of the bivariate data, or by means of an appropriate
bootstrap otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exchEVTest(x, N = 1000,  estimator = c("CFG", "Pickands"),
           ties = NA, ties.method = eval(formals(rank)$ties.method),
           m = 100, derivatives = c("Cn", "An"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exchEVTest_+3A_x">x</code></td>
<td>
<p>a data matrix that will be transformed to
pseudo-observations.</p>
</td></tr>
<tr><td><code id="exchEVTest_+3A_n">N</code></td>
<td>
<p>number of multiplier or boostrap iterations to be used to
simulate realizations of the test statistic under the null
hypothesis.</p>
</td></tr>
<tr><td><code id="exchEVTest_+3A_estimator">estimator</code></td>
<td>
<p>string specifying which nonparametric estimator of
the Pickands dependence function <code class="reqn">A()</code> to use; can be either
<code>"CFG"</code> or <code>"Pickands"</code>; see Genest and Segers (2009).</p>
</td></tr>
<tr><td><code id="exchEVTest_+3A_ties">ties</code></td>
<td>
<p>logical; if <code>FALSE</code>, approximate p-values are computed by
means of a multiplier bootstrap; if <code>TRUE</code>, a boostrap adapted to the
presence of ties in any of the coordinate samples of <code>x</code>
is used; the default value of <code>NA</code> indicates that the
presence/absence of ties will be checked for automatically.</p>
</td></tr>
<tr><td><code id="exchEVTest_+3A_ties.method">ties.method</code></td>
<td>
<p>string specifying how ranks should be computed if
there are ties in any of the coordinate samples of <code>x</code>; passed
to <code><a href="#topic+pobs">pobs</a></code>.</p>
</td></tr>
<tr><td><code id="exchEVTest_+3A_derivatives">derivatives</code></td>
<td>
<p>a string specifying how the derivatives of the
unknown copula are estimated; can be either <code>"An"</code> or <code>"Cn"</code>.
The former should be used under the assumption of extreme-value
dependence.  The latter is faster; see the second reference.</p>
</td></tr>
<tr><td><code id="exchEVTest_+3A_m">m</code></td>
<td>
<p>integer specifying the size of the integration grid for the
statistic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details are available in the references.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p> value of the test statistic. </p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p> corresponding approximate p-value. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Genest, C. and Segers, J. (2009)
Rank-based inference for bivariate extreme-value copulas.
<em>Annals of Statistics</em> <b>37</b>, 2990&ndash;3022.
</p>
<p>Kojadinovic, I. and Yan, J. (2012)
A nonparametric test of exchangeability for extreme-value and left-tail
decreasing bivariate copulas.
<em>The Scandinavian Journal of Statistics</em> <b>39:3</b>, 480&ndash;496.
</p>
<p>Kojadinovic, I. (2017). Some copula inference procedures adapted to
the presence of ties. <em>Computational Statistics and Data
Analysis</em> <b>112</b>, 24&ndash;41, <a href="https://arxiv.org/abs/1609.05519">https://arxiv.org/abs/1609.05519</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+exchTest">exchTest</a></code>, <code><a href="#topic+radSymTest">radSymTest</a></code>, <code><a href="#topic+gofCopula">gofCopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from an exchangeable left-tail decreasing copulas
exchEVTest(rCopula(200,  gumbelCopula(3)))
exchEVTest(rCopula(200, claytonCopula(3)))

## An asymmetric Khoudraji-Gumbel-Hougaard copula
kc &lt;- khoudrajiCopula(copula1 = indepCopula(),
                      copula2 = gumbelCopula(4),
                      shapes = c(0.4, 0.95))
exchEVTest(rCopula(200, kc))
</code></pre>

<hr>
<h2 id='exchTest'>Test of Exchangeability for a Bivariate Copula</h2><span id='topic+exchTest'></span>

<h3>Description</h3>

<p>Test for assessing the exchangeability of the underlying
bivariate copula based on the empirical copula.
The test statistics are defined in the first two references.
Approximate p-values for the test statistics are obtained
by means of a <em>multiplier</em> technique if there are no ties in the
component series of the bivariate data, or by means of an appropriate
bootstrap otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exchTest(x, N = 1000, ties = NA,
         ties.method = eval(formals(rank)$ties.method), m = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exchTest_+3A_x">x</code></td>
<td>
<p> a data matrix that will be transformed to pseudo-observations.</p>
</td></tr>
<tr><td><code id="exchTest_+3A_n">N</code></td>
<td>
<p> number of multiplier or boostrap iterations to be used to
simulate realizations of the test statistic under the null
hypothesis.</p>
</td></tr>
<tr><td><code id="exchTest_+3A_ties">ties</code></td>
<td>
<p> logical; if <code>FALSE</code>, approximate p-values are computed by
means of a multiplier bootstrap; if <code>TRUE</code>, a boostrap adapted to the
presence of ties in any of the coordinate samples of <code>x</code>
is used; the default value of <code>NA</code> indicates that the
presence/absence of ties will be checked for automatically.</p>
</td></tr>
<tr><td><code id="exchTest_+3A_ties.method">ties.method</code></td>
<td>
<p>string specifying how ranks should be computed if
there are ties in any of the coordinate samples of <code>x</code>; passed
to <code><a href="#topic+pobs">pobs</a></code>.</p>
</td></tr>
<tr><td><code id="exchTest_+3A_m">m</code></td>
<td>
<p> if <code>m=0</code>, integration in the Cramér&ndash;von Mises
statistic is carried out with respect to the empirical copula; if
<code>m &gt; 0</code>, integration is carried out with respect to the Lebesgue
measure and <code>m</code> specifies the size of the integration grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details are available in the references.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p> value of the test statistic. </p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p> corresponding approximate p-value. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Genest, C., G. Nešlehová, J. and Quessy,
J.-F. (2012).  Tests of symmetry for bivariate copulas. <em>Annals
of the Institute of Statistical Mathematics</em> <b>64</b>, 811&ndash;834.
</p>
<p>Kojadinovic, I. and Yan, J. (2012). A nonparametric test of
exchangeability for extreme-value and left-tail
decreasing bivariate copulas. <em>The Scandinavian Journal of
Statistics</em> <b>39:3</b>, 480&ndash;496.
</p>
<p>Kojadinovic, I. (2017). Some copula inference procedures adapted to
the presence of ties. <em>Computational Statistics and Data
Analysis</em> <b>112</b>, 24&ndash;41, <a href="https://arxiv.org/abs/1609.05519">https://arxiv.org/abs/1609.05519</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+radSymTest">radSymTest</a></code>, <code><a href="#topic+exchEVTest">exchEVTest</a></code>, <code><a href="#topic+gofCopula">gofCopula</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from an exchangeable copulas
exchTest(rCopula(200,  gumbelCopula(3)))
exchTest(rCopula(200, claytonCopula(3)))

## An asymmetric Khoudraji-Clayton copula
kc &lt;- khoudrajiCopula(copula1 = indepCopula(),
                      copula2 = claytonCopula(6),
                      shapes = c(0.4, 0.95))
exchTest(rCopula(200, kc))
</code></pre>

<hr>
<h2 id='fgmCopula'>Construction of a fgmCopula Class Object</h2><span id='topic+fgmCopula'></span>

<h3>Description</h3>

<p>Constructs a multivariate multiparameter Farlie-Gumbel-Morgenstern
copula class object with its corresponding parameters and dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgmCopula(param, dim = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgmCopula_+3A_param">param</code></td>
<td>
<p>a numeric vector specifying the parameter values.</p>
</td></tr>
<tr><td><code id="fgmCopula_+3A_dim">dim</code></td>
<td>
<p>the dimension of the copula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Farlie-Gumbel-Morgenstern copula object of class
<code>"<a href="#topic+fgmCopula-class">fgmCopula</a>"</code>.
</p>


<h3>Note</h3>

<p>The verification of the validity of the parameter values is of high
complexity and may not work for high dimensional copulas.
</p>
<p>The random number generation needs to be properly tested, especially
for dimensions higher than 2.
</p>


<h3>References</h3>

<p>Nelsen, R. B. (2006), <em>An introduction to Copulas</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Copula">Copula</a></code>, <code><a href="#topic+copula-class">copula-class</a></code>,
<code><a href="#topic+fitCopula">fitCopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a bivariate example
fgm.cop &lt;- fgmCopula(1)
x &lt;- rCopula(1000, fgm.cop)
cor(x, method = "kendall")
tau(fgm.cop)
cor(x, method = "spearman")
rho(fgm.cop)
persp  (fgm.cop, dCopula)
contour(fgm.cop, dCopula)

## a trivariate example with wrong parameter values
try(
 fgm2.cop &lt;- fgmCopula(c(1,1,1,1), dim = 3)
) # Error: "Bad vector of parameters"

## a trivariate example with satisfactory parameter values
fgm2.cop &lt;- fgmCopula(c(.2,-.2,-.4,.6), dim = 3)
fgm2.cop
</code></pre>

<hr>
<h2 id='fgmCopula-class'>Class &quot;fgmCopula&quot; - Multivariate Multiparameter Farlie-Gumbel-Morgenstern Copulas</h2><span id='topic+fgmCopula-class'></span>

<h3>Description</h3>

<p>The class of multivariate multiparameter Farlie-Gumbel-Morgenstern
copulas are typically created via <code><a href="#topic+fgmCopula">fgmCopula</a>(..)</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects are typically created by <code><a href="#topic+fgmCopula">fgmCopula</a>(..)</code>, or more
low-level by (careful) calls to <code>new("fgmCopula", ..)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>exprdist</code>:</dt><dd><p>Object of class <code>"expression"</code>,
expressions for the cdf and pdf of the copula. These expressions
are used in function <code>pCopula()</code> and <code>dCopula()</code>.</p>
</dd>
<dt><code>subsets.char</code>:</dt><dd><p>Object of class <code>"character"</code>,
containing the subsets of integers used for naming the parameters. </p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>"numeric"</code>, the
dimension of the copula. </p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
parameter values. </p>
</dd>
<dt><code>param.names</code>:</dt><dd><p>Object of class <code>"character"</code>,
parameter names. </p>
</dd>
<dt><code>param.lowbnd</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
parameter lower bound. </p>
</dd>
<dt><code>param.upbnd</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
parameter upper bound. </p>
</dd>
<dt><code>fullname</code>:</dt><dd><p>Object of class <code>"character"</code>, family names
of the copula (deprecated).</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>dCopula</dt><dd><p><code>signature(copula = "fgmCopula")</code>: ... </p>
</dd>
<dt>pCopula</dt><dd><p><code>signature(copula = "fgmCopula")</code>: ... </p>
</dd>
<dt>rCopula</dt><dd><p><code>signature(copula = "fgmCopula")</code>: ... </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"fgmCopula"</code> extends class <code>"<a href="#topic+copula-class">copula</a>"</code> directly.
</p>


<h3>Note</h3>

<p>The verification of the validity of the parameter values is of high
complexity and may not work for high dimensional copulas.
</p>
<p>The random number generation needs to be properly tested, especially
for dimensions higher than 2.
</p>


<h3>References</h3>

<p>Nelsen, R. B. (2006), <em>An introduction to Copulas</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+copula-class">copula-class</a></code>, <code><a href="#topic+fgmCopula-class">fgmCopula-class</a></code>; to create such
objects, use <code><a href="#topic+fgmCopula">fgmCopula</a>()</code>; see there, also for examples.
</p>

<hr>
<h2 id='fhCopula'>Construction of Fréchet-Hoeffding Bound Copula Objects</h2><span id='topic+fhCopula'></span><span id='topic+lowfhCopula'></span><span id='topic+upfhCopula'></span>

<h3>Description</h3>

<p>Constructs the Fréchet-Hoeffding lower and upper bound
copulas aka <code class="reqn">W</code> and <code class="reqn">M</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fhCopula(family = c("upper", "lower"), dim = 2L)

lowfhCopula(dim = 2L)
 upfhCopula(dim = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fhCopula_+3A_family">family</code></td>
<td>
<p>a character string specifying the
Fréchet-Hoeffding bound copula.</p>
</td></tr>
<tr><td><code id="fhCopula_+3A_dim">dim</code></td>
<td>
<p>the dimension of the copula; note that the lower
Fréchet-Hoeffding bound is only available in the bivariate case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copula object of class <code>"<a href="#topic+lowfhCopula-class">lowfhCopula</a>"</code>
or <code>"<a href="#topic+upfhCopula-class">upfhCopula</a>"</code>.
</p>


<h3>Note</h3>

<p><code>fhCopula()</code> is a wrapper for <code>lowfhCopula()</code> and
<code>upfhCopula()</code>.
</p>
<p>The <code><a href="#topic+dCopula">dCopula</a>()</code> method will simply return an error
for these copulas (as their density does not exist).  Also,
since the Fréchet-Hoeffding bound copulas are not
parametric, certain methods available for parametric copulas are
not available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Lower bound  W : -------------------------

try(W &lt;- lowfhCopula(dim = 3)) # lower bound is *not* a copula for dim &gt; 2
W &lt;- lowfhCopula()
wireframe2(W, FUN = pCopula)
plot(W, n=100) # perfect anti-correlation ( rho = tau = -1 )

## Upper bound  M : -------------------------

wireframe2(upfhCopula(dim = 2), pCopula)
M &lt;- upfhCopula(dim = 3)
set.seed(271)
splom2(M, n = 100) # "random" data: all perfectly correlated
</code></pre>

<hr>
<h2 id='fhCopula-class'>Class &quot;fhCopula&quot; of Fréchet-Hoeffding Bound Copulas</h2><span id='topic+fhCopula-class'></span><span id='topic+lowfhCopula-class'></span><span id='topic+upfhCopula-class'></span>

<h3>Description</h3>

<p>Fréchet-Hoeffding bound copula class.
</p>


<h3>Objects from the Class</h3>

<p>Created by calls of the form <code>new("fhCopula", ...)</code> or rather
typically by <code><a href="#topic+fhCopula">fhCopula</a>()</code>, <code>lowfhCopula()</code>, or
<code>upfhCopula()</code>.  Actual (sub) classes are the lower and upper
Fréchet-Hoeffding bound copulas <code>lowfhCopula()</code>
(<code class="reqn">W</code>), and <code>upfhCopula()</code> (<code class="reqn">M</code>).
</p>


<h3>Slots</h3>


<dl>
<dt><code>dimension</code>:</dt><dd><p>inherited from
super class <code>"<a href="#topic+dimCopula-class">dimCopula</a>"</code>.</p>
</dd>
<dt><code>exprdist</code>:</dt><dd><p>an <code><a href="base.html#topic+expression">expression</a></code> of length two,
named <code>"cdf"</code> with the <span class="rlang"><b>R</b></span> expression of the CDF, and
<code>"pdf"</code> which is empty as the PDF does not exist (everywhere).</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+ellipCopula">ellipCopula</a></code>, <code><a href="#topic+archmCopula">archmCopula</a></code>,
<code><a href="#topic+evCopula">evCopula</a></code>.
</p>
<p>The class constructors are <code><a href="#topic+fhCopula">fhCopula</a>()</code>,
<code>lowfhCopula()</code>, and <code>upfhCopula()</code>.  See there for
examples.
</p>

<hr>
<h2 id='fitCopula'>Fitting Copulas to Data &ndash; Copula Parameter Estimation</h2><span id='topic+fitCopula'></span><span id='topic+fitCopula-methods'></span><span id='topic+fitCopula+2Ccopula-method'></span><span id='topic+fitCopula+2CparCopula-method'></span><span id='topic+fitCopula+2CrotCopula-method'></span><span id='topic+loglikCopula'></span><span id='topic+loglikCopulaMany'></span><span id='topic+optimMeth'></span>

<h3>Description</h3>

<p>Parameter estimation of copulas, i.e., fitting of a copula model to
multivariate (possibly &ldquo;pseudo&rdquo;) observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikCopula(param = getTheta(copula), u, copula,
             error = c("-Inf", "warn-Inf", "let-it-be"))

loglikCopulaMany(pList, u, copula)

## Generic [and "rotCopula" method] : %- ../R/fitCopula.R
fitCopula(copula, data, ...)
## S4 method for signature 'parCopula'
fitCopula(copula, data,
          method = c("mpl", "ml", "itau", "irho", "itau.mpl"),
          posDef = is(copula, "ellipCopula"),
          start = NULL, lower = NULL, upper = NULL,
          optim.method = optimMeth(copula, method, dim = d),
          optim.control = list(maxit=1000),
          estimate.variance = NA, hideWarnings = FALSE, ...)

optimMeth(copula, method, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitCopula_+3A_param">param</code></td>
<td>
<p>vector of <em>free</em> (see <code><a href="#topic+isFree">isFree</a>()</code> and
<code><a href="#topic+getTheta">getTheta</a>()</code>) parameter values.</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_plist">pList</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> of <em>free</em> parameter vectors (as
<code>param</code> above).  In the 1D case, <code>length(param) == 1</code>, may
also be a numeric vector.</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_u">u</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix of (pseudo-)observations in
<code class="reqn">[0,1]^d</code> for computing the copula log-likelihood, where <code class="reqn">n</code> denotes
the sample size and <code class="reqn">d</code> the dimension.  Consider applying the function
<code><a href="#topic+pobs">pobs</a>()</code> first in order to obtain such data.</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_data">data</code></td>
<td>
<p>as <code class="reqn">u</code>, an <code class="reqn">n\times d</code>-matrix of data.  For
<code>method</code> being <code>"mpl"</code>, <code>"ml"</code> or <code>"itau.mpl"</code>,
this has to be data in <code class="reqn">[0,1]^d</code>.  For <code>method</code> being
<code>"itau"</code> or <code>"irho"</code>, it can either be data in <code class="reqn">[0,1]^d</code>
or in the whole <code class="reqn">d</code>-dimensional space.</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_copula">copula</code></td>
<td>
<p>a <code>"<a href="#topic+copula-class">copula</a>"</code> object.</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_error">error</code></td>
<td>
<p>(for <code>loglikCopula()</code>:) a <code><a href="base.html#topic+character">character</a></code>
string specifying how errors in the underlying <code><a href="#topic+dCopula">dCopula</a>()</code>
calls should be handled:
</p>

<dl>
<dt><code>"-Inf"</code>:</dt><dd><p>the value of the log likelihood should silently be set
to <code>-Inf</code>.</p>
</dd>
<dt><code>"warn-Inf"</code>:</dt><dd><p>signal a <code><a href="base.html#topic+warning">warning</a></code> about the error and
set the value to <code>-Inf</code>.</p>
</dd>
<dt><code>"let-it-be"</code>:</dt><dd><p>the error is signalled and hence the likelihood
computation fails.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="fitCopula_+3A_method">method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the copula
parameter estimator used.  This can be one of:
</p>

<dl>
<dt>&quot;mpl&quot;</dt><dd><p>Maximum pseudo-likelihood estimator (based on
&ldquo;pseudo-observations&rdquo; in <code class="reqn">[0,1]^d</code>, typical obtained
via <code><a href="#topic+pobs">pobs</a>()</code>).</p>
</dd>
<dt>&quot;ml&quot;</dt><dd><p>As <code>"mpl"</code> just with a different variance
estimator.  For this to be correct (thus giving the true MLE),
<code>data</code> are assumed to be observations from the true
underlying copula whose parameter is to be estimated.</p>
</dd>
<dt>&quot;itau&quot;</dt><dd><p>Inversion of Kendall's tau estimator. <code>data</code>
can be either in <code class="reqn">[0,1]^d</code> (true or pseudo-observations of
the underlying copula to be estimated) or in the <code class="reqn">d</code>-dimensional space.</p>
</dd>
<dt>&quot;irho&quot;</dt><dd><p>As <code>"itau"</code> just with Spearman's rho instead of
Kendall's tau.</p>
</dd>
<dt>&quot;itau.mpl&quot;</dt><dd><p>This is the estimator of <code class="reqn">t</code> copula
parameters suggested by Mashal and Zeevi (2002) based on the
idea of inverting Kendall's tau for estimating the correlation
matrix as introduced in a RiskLab report in 2001 later published
as Embrechts et al. (2003); see also
Demarta and McNeil (2005). The
given <code>data</code> has to be in <code class="reqn">[0,1]^d</code> (either true or
pseudo-observations of the underlying copula to be estimated).
Note that this method requires <code>dispstr = "un"</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="fitCopula_+3A_posdef">posDef</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> indicating whether a proper
correlation matrix is computed.</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_start">start</code></td>
<td>
<p>a <code><a href="base.html#topic+vector">vector</a></code> of starting values for the
parameter optimization via <code><a href="stats.html#topic+optim">optim</a>()</code>.</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_lower">lower</code>, <code id="fitCopula_+3A_upper">upper</code></td>
<td>
<p>Lower or upper parameter bounds for the
optimization methods <code>"Brent"</code> or <code>"L-BFGS-B"</code>.</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_optim.control">optim.control</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> of control parameters
passed to <code><a href="stats.html#topic+optim">optim</a>(*, control=optim.control)</code>.</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_optim.method">optim.method</code></td>
<td>
<p>a character string specify the optimization
method <em>or</em> a <code><a href="base.html#topic+function">function</a></code> which when called with
arguments <code>(copula, method, dim)</code> will return such a character string,
see <code><a href="stats.html#topic+optim">optim</a>()</code>'s <code>method</code>; only used when
<code>method = "mpl"</code> or <code>"ml"</code>.
</p>
<p>The default has been changed (for <span class="pkg">copula</span> 0.999-16, in
Aug. 2016) from <code>"BFGS"</code> to the result of
<code>optimMeth(copula, method, dim)</code> which is often
<code>"L-BFGS-B"</code>.</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_dim">dim</code></td>
<td>
<p>integer, the data and copula dimension, <code class="reqn">d \ge 2</code>.</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_estimate.variance">estimate.variance</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> indicating whether
the estimator's asymptotic variance is computed (if available for
the given <code>copula</code>; the default <code>NA</code> computes it for the
<code>method</code>s <code>"itau"</code> and <code>"irho"</code>, cannot (yet) compute
it for <code>"itau.mpl"</code> and only computes it for <code>"mpl"</code> or <code>"ml"</code>
if the optimization converged).</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_hidewarnings">hideWarnings</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code>, which, if
<code><a href="base.html#topic+TRUE">TRUE</a></code>, suppresses warnings from the involved
likelihood maximization (typically when the likelihood is
evaluated at invalid parameter values).</p>
</td></tr>
<tr><td><code id="fitCopula_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>method</code> specific auxiliary
functions, e.g., <code>traceOpt = TRUE</code> (or <code>traceOpt = 10</code>) for tracing
<code><a href="stats.html#topic+optimize">optimize</a></code> (every 10-th function evaluation) for method
<code>"itau.mpl"</code>, and for &ldquo;manual&rdquo; tracing with method
<code>"ml"</code> or <code>"mpl"</code> also showing parameter values
(notably for <code>optim.method="Brent"</code>),
see the extra arguments of namespace-hidden function
<code>fitCopula.ml()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only difference between <code>"mpl"</code> and <code>"ml"</code> is in the
variance-covariance estimate, <em>not</em> in the parameter
(<code class="reqn">\theta</code>) estimates.
</p>
<p>If method <code>"mpl"</code> in <code>fitCopula()</code> is used and if
<code>start</code> is not assigned a value, estimates obtained from method
<code>"itau"</code> are used as initial values in the optimization. Standard
errors are computed as explained in Genest, Ghoudi and Rivest (1995);
see also Kojadinovic and Yan (2010, Section 3).  Their estimation
requires the computation of certain partial derivatives of the (log)
density.  These have been implemented for six copula families thus far:
the Clayton, Gumbel-Hougaard, Frank, Plackett, normal and <code class="reqn">t</code> copula
families.  For other families, numerical differentiation based on
<code><a href="numDeriv.html#topic+grad">grad</a>()</code> from package <a href="https://CRAN.R-project.org/package=numDeriv"><span class="pkg">numDeriv</span></a>
is used (and a warning message is displayed).
</p>
<p>In the multiparameter elliptical case and when the estimation is based
on Kendall's tau or Spearman's rho, the estimated correlation matrix
may not always be positive-definite. In that case,
<code><a href="Matrix.html#topic+nearPD">nearPD</a>(*, corr=TRUE)</code> (from <a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a>) is
applied to get a proper correlation matrix.
</p>
<p>For normal and <code class="reqn">t</code> copulas, <code>fitCopula(, method = "mpl")</code> and
<code>fitCopula(, method = "ml")</code> maximize the log-likelihood based on
<a href="https://CRAN.R-project.org/package=mvtnorm"><span class="pkg">mvtnorm</span></a>'s <code>dmvnorm()</code> and <code>dmvt()</code>, respectively.
The latter two functions set the respective densities to zero if the
correlation matrices of the corresponding distributions are not
positive definite. As such, the estimated correlation matrices
will be positive definite.
</p>
<p>If methods <code>"itau"</code> or <code>"irho"</code> are used in
<code>fitCopula()</code>, an estimate of the asymptotic variance (if
available for the copula under consideration) will be correctly
computed only if the argument <code>data</code> consists of pseudo-observations
(see <code><a href="#topic+pobs">pobs</a>()</code>).
</p>
<p>Consider the <code class="reqn">t</code> copula with <code>df.fixed=FALSE</code> (see
<code><a href="#topic+ellipCopula">ellipCopula</a>()</code>).  In this case, the methods <code>"itau"</code>
and <code>"irho"</code> cannot be used in <code>fitCopula()</code> as they cannot
estimate the degrees of freedom parameter <code>df</code>.  For the methods
<code>"mpl"</code> and <code>"itau.mpl"</code> the asymptotic variance cannot be
(fully) estimated (yet).  For the methods <code>"ml"</code> and <code>"mpl"</code>,
when <code>start</code> is not specified, the starting value for <code>df</code>
is set to <code>copula@df</code>, typically 4.
</p>
<p>To implement the <em>Inference Functions for Margins</em> (IFM) method
(see, e.g., Joe 2005), set <code>method="ml"</code> and note that
<code>data</code> need to be parametric pseudo-observations obtained from <em>fitted</em>
parametric marginal distribution functions.  The returned large-sample
variance will then underestimate the true variance (as the procedure
cannot take into account the (unknown) estimation error for the margins).
</p>
<p>The fitting procedures based on <code><a href="stats.html#topic+optim">optim</a>()</code> generate
warnings because invalid parameter values are tried during the
optimization process.  When the number of parameters is one and the
parameter space is bounded, using <code>optim.method="Brent"</code> is
likely to give less warnings.  Furthermore, from experience,
<code>optim.method="Nelder-Mead"</code> is sometimes a more robust
alternative to <code>optim.method="BFGS"</code> or <code>"L-BFGS-B"</code>.
</p>
<p>There are methods for <code><a href="stats.html#topic+vcov">vcov</a>()</code>, <code><a href="stats.html#topic+coef">coef</a>()</code>,
<code><a href="stats.html#topic+logLik">logLik</a>()</code>, and <code><a href="stats.html#topic+nobs">nobs</a>()</code>.
</p>


<h3>Value</h3>

<p><code>loglikCopula()</code> returns the copula log-likelihood evaluated at the
parameter (vector) <code>param</code> given the data <code>u</code>.
</p>
<p><code>loglikCopulaMany()</code> returns a numeric vector of such
log-likelihoods; it assumes consistent parameter values, corresponding to
<code>loglikCopula()</code>'s <code>error = "let-it-be"</code>, for speed.
</p>
<p>The return value of <code>fitCopula()</code> is an object of class
<code>"<a href="#topic+fitCopula-class">fitCopula</a>"</code> (inheriting from hidden class
<code>"fittedMV"</code>), containing (among others!) the slots
</p>

<dl>
<dt>estimate</dt><dd><p>The parameter estimates.</p>
</dd>
<dt>var.est</dt><dd><p>The large-sample (i.e., asymptotic) variance estimate of the parameter
estimator unless <code>estimate.variance=FALSE</code> where it is
<code>matrix(numeric(), 0,0)</code> (to be distinguishable from cases when the
covariance estimates failed partially).</p>
</dd>
<dt>copula</dt><dd><p>The fitted copula object.</p>
</dd>
</dl>

<p>The <code><a href="base.html#topic+summary">summary</a>()</code> method for <code>"fitCopula"</code> objects
returns an S3 &ldquo;class&rdquo; <code>"summary.fitCopula"</code>, which is simply a list
with components <code>method</code>, <code>loglik</code> and <code>convergence</code>,
all three from the corresponding slots of the
<code>"<a href="#topic+fitCopula-class">fitCopula</a>"</code> objects, and <code>coefficients</code>
(a matrix of estimated coefficients, standard errors, t values and p-values).
</p>


<h3>References</h3>

<p>Genest, C. (1987). Frank's family of bivariate distributions.
<em>Biometrika</em> <b>74</b>, 549&ndash;555.
</p>
<p>Genest, C. and Rivest, L.-P. (1993). Statistical inference procedures
for bivariate Archimedean copulas.
<em>Journal of the American Statistical Association</em> <b>88</b>, 1034&ndash;1043.
</p>
<p>Rousseeuw, P. and Molenberghs, G. (1993). Transformation of nonpositive
semidefinite correlation matrices.
<em>Communications in Statistics: Theory and Methods</em> <b>22</b>, 965&ndash;984.
</p>
<p>Genest, C., Ghoudi, K., and Rivest, L.-P. (1995). A semiparametric
estimation procedure of dependence parameters in multivariate
families of distributions. <em>Biometrika</em> <b>82</b>, 543&ndash;552.
</p>
<p>Joe, H. (2005). Asymptotic efficiency of the two-stage estimation
method for copula-based models.
<em>Journal of Multivariate Analysis</em> <b>94</b>, 401&ndash;419.
</p>
<p>Mashal, R. and Zeevi, A. (2002). Beyond Correlation: Extreme Co-movements Between
Financial Assets.
<a href="https://www0.gsb.columbia.edu/faculty/azeevi/PAPERS/BeyondCorrelation.pdf">https://www0.gsb.columbia.edu/faculty/azeevi/PAPERS/BeyondCorrelation.pdf</a> (2016-04-05)
</p>
<p>Demarta, S. and McNeil, A. J. (2005). The t copula and related copulas.
<em>International Statistical Review</em> <b>73</b>, 111&ndash;129.
</p>
<p>Genest, C. and Favre, A.-C. (2007). Everything you always wanted to know about
copula modeling but were afraid to ask.
<em>Journal of Hydrologic Engineering</em> <b>12</b>, 347&ndash;368.
</p>
<p>Kojadinovic, I. and Yan, J. (2010). Comparison of three semiparametric methods
for estimating dependence parameters in copula models.
<em>Insurance: Mathematics and Economics</em> <b>47</b>, 52&ndash;63.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Copula">Copula</a></code>,
<code><a href="#topic+fitMvdc">fitMvdc</a></code> for fitting multivariate distributions
<em>including</em> the margins,
<code><a href="#topic+gofCopula">gofCopula</a></code> for goodness-of-fit tests.
</p>
<p>For maximum likelihood of (nested) Archimedean copulas, see
<code><a href="#topic+emle">emle</a></code>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(Xtras &lt;- copula:::doExtras()) # determine whether examples will be extra (long)
n &lt;- if(Xtras) 200 else 64 # sample size

## A Gumbel copula
set.seed(7) # for reproducibility
gumbel.cop &lt;- gumbelCopula(3, dim=2)
x &lt;- rCopula(n, gumbel.cop) # "true" observations (simulated)
u &lt;- pobs(x)                # pseudo-observations
## Inverting Kendall's tau
fit.tau &lt;- fitCopula(gumbelCopula(), u, method="itau")
fit.tau
confint(fit.tau) # work fine !
confint(fit.tau, level = 0.98)
summary(fit.tau) # a bit more, notably "Std. Error"s
coef(fit.tau)# named vector
coef(fit.tau, SE = TRUE)# matrix

## Inverting Spearman's rho
fit.rho &lt;- fitCopula(gumbelCopula(), u, method="irho")
summary(fit.rho)
## Maximum pseudo-likelihood
fit.mpl &lt;- fitCopula(gumbelCopula(), u, method="mpl")
fit.mpl
## Maximum likelihood -- use 'x', not 'u' ! --
fit.ml &lt;- fitCopula(gumbelCopula(), x, method="ml")
summary(fit.ml) # now prints a bit more than simple 'fit.ml'
## ... and what's the log likelihood (in two different ways):
(ll. &lt;- logLik(fit.ml))
stopifnot(all.equal(as.numeric(ll.),
            loglikCopula(coef(fit.ml), u=x, copula=gumbel.cop)))

## A Gauss/normal copula

## With multiple/*un*constrained parameters
set.seed(6) # for reproducibility
normal.cop &lt;- normalCopula(c(0.6, 0.36, 0.6), dim=3, dispstr="un")
x &lt;- rCopula(n, normal.cop) # "true" observations (simulated)
u &lt;- pobs(x)                # pseudo-observations
## Inverting Kendall's tau
fit.tau &lt;- fitCopula(normalCopula(dim=3, dispstr="un"), u, method="itau")
fit.tau
## Inverting Spearman's rho
fit.rho &lt;- fitCopula(normalCopula(dim=3, dispstr="un"), u, method="irho")
fit.rho
## Maximum pseudo-likelihood
fit.mpl &lt;- fitCopula(normalCopula(dim=3, dispstr="un"), u, method="mpl")
summary(fit.mpl)
coef(fit.mpl) # named vector
coef(fit.mpl, SE = TRUE) # the matrix, with SE
## Maximum likelihood (use 'x', not 'u' !)
fit.ml &lt;- fitCopula(normalCopula(dim=3, dispstr="un"), x, method="ml", traceOpt=TRUE)
summary(fit.ml)
confint(fit.ml)
confint(fit.ml, level = 0.999) # clearly non-0

## Fix some of the parameters
param &lt;- c(.6, .3, NA_real_)
attr(param, "fixed") &lt;- c(TRUE, FALSE, FALSE)
ncp &lt;- normalCopula(param = param, dim = 3, dispstr = "un")
fixedParam(ncp) &lt;- c(TRUE, TRUE, FALSE)
## 'traceOpt = 5': showing every 5-th log likelihood evaluation:
summary(Fxf.mpl &lt;- fitCopula(ncp, u, method = "mpl", traceOpt = 5))
Fxf.mpl@copula # reminding of the fixed param. values

## With dispstr = "toep" :
normal.cop.toep &lt;- normalCopula(c(0, 0), dim=3, dispstr="toep")
## Inverting Kendall's tau
fit.tau &lt;- fitCopula(normalCopula(dim=3, dispstr="toep"), u, method="itau")
fit.tau
## Inverting Spearman's rho
fit.rho &lt;- fitCopula(normalCopula(dim=3, dispstr="toep"), u, method="irho")
summary(fit.rho)
## Maximum pseudo-likelihood
fit.mpl &lt;- fitCopula(normalCopula(dim=3, dispstr="toep"), u, method="mpl")
fit.mpl
## Maximum likelihood (use 'x', not 'u' !)
fit.ml &lt;- fitCopula(normalCopula(dim=3, dispstr="toep"), x, method="ml")
summary(fit.ml)

## With dispstr = "ar1"
normal.cop.ar1 &lt;- normalCopula(c(0), dim=3, dispstr="ar1")
## Inverting Kendall's tau
summary(fit.tau &lt;- fitCopula(normalCopula(dim=3, dispstr="ar1"), u, method="itau"))
## Inverting Spearman's rho
summary(fit.rho &lt;- fitCopula(normalCopula(dim=3, dispstr="ar1"), u, method="irho"))
## Maximum pseudo-likelihood
summary(fit.mpl &lt;- fitCopula(normalCopula(dim=3, dispstr="ar1"), u, method="mpl"))
## Maximum likelihood (use 'x', not 'u' !)
fit.ml &lt;- fitCopula(normalCopula(dim=3, dispstr="ar1"), x, method="ml")
summary(fit.ml)

## A t copula with variable df (df.fixed=FALSE)
(tCop &lt;- tCopula(c(0.2,0.4,0.6), dim=3, dispstr="un", df=5))
set.seed(101)
x &lt;- rCopula(n, tCop) # "true" observations (simulated)
## Maximum likelihood (start = (rho[1:3], df))
summary(tc.ml &lt;- fitCopula(tCopula(dim=3, dispstr="un"), x, method="ml",
                           start = c(0,0,0, 10)))
## Maximum pseudo-likelihood (the asymptotic variance cannot be estimated)
u &lt;- pobs(x)          # pseudo-observations
tc.mpl &lt;- fitCopula(tCopula(dim=3, dispstr="un"),
                     u, method="mpl", estimate.variance=FALSE,
                     start= c(0,0,0, 10))
summary(tc.mpl)
</code></pre>

<hr>
<h2 id='fitCopula-class'>Classes of Fitted Multivariate Models: Copula, Mvdc</h2><span id='topic+fittedMV-class'></span><span id='topic+fitCopula-class'></span><span id='topic+fitMvdc-class'></span><span id='topic+summaryFitCopula-class'></span><span id='topic+summaryFitMvdc-class'></span><span id='topic+summary+2CfitCopula-method'></span><span id='topic+summary+2CfitMvdc-method'></span>

<h3>Description</h3>

<p>Classes and summary methods related to copula model fitting.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to <code><a href="#topic+fitCopula">fitCopula</a></code> or
<code><a href="#topic+fitMvdc">fitMvdc</a></code>, respectively or to their <code>summary</code> methods.
</p>


<h3>Slots</h3>

<p>The &ldquo;mother class&rdquo;, <code>"fittedMV"</code> has the slots
</p>

<dl>
<dt><code>estimate</code>:</dt><dd><p><code>numeric</code>, the estimated parameters.</p>
</dd>
<dt><code>var.est</code>:</dt><dd><p><code>numeric</code>, variance matrix estimate of
the parameter estimator. See note below.</p>
</dd>
<dt><code>loglik</code>:</dt><dd><p><code>numeric</code>, log likelihood evaluated at
the maximizer.</p>
</dd>
<dt><code>nsample</code>:</dt><dd><p><code>numeric</code>, integer representing the
sample size.</p>
</dd>
<dt><code>method</code>:</dt><dd><p><code>character</code>, method of estimation.</p>
</dd>
<dt><code>fitting.stats</code>:</dt><dd><p>a <code><a href="base.html#topic+list">list</a></code>, currently
containing the numeric <code>convergence</code> code from
<code><a href="stats.html#topic+optim">optim</a></code>, the <code>counts</code>, <code>message</code>, and all
the <code>control</code> arguments explicitly passed to <code><a href="stats.html#topic+optim">optim</a>()</code>.
Since <span class="pkg">copula</span> version 1.0-1 also keeps information about
parameter transformations, currently needed only for
<code><a href="#topic+mixCopula">mixCopula</a></code> fits with free weights.</p>
</dd>
</dl>

<p>In addition, the <code>"fitCopula"</code> class has a slot
</p>

<dl>
<dt><code>copula</code>:</dt><dd><p>the <em>fitted</em> copula, of class
<code>"<a href="#topic+copula-class">copula</a>"</code>.</p>
</dd>
</dl>

<p>whereas the <code>"fitMvdc"</code> has
</p>

<dl>
<dt><code>mvdc</code>:</dt><dd><p>the <em>fitted</em> distribution, of class
<code>"<a href="#topic+mvdc-class">mvdc</a>"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Classes <code>"fitCopula"</code> and <code>"fitMvdc"</code> extend class
<code>"fittedMV"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>summary</dt><dd><p><code>signature(object = "fitMvdc")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "fitCopula")</code>: ... </p>
</dd>
</dl>

<p>Further, there are S3 methods (class <code>"fittedMV"</code>) for
<code><a href="stats.html#topic+coef">coef</a>()</code>, <code><a href="stats.html#topic+vcov">vcov</a>()</code> and <code><a href="stats.html#topic+logLik">logLik</a>()</code>,
see <code><a href="#topic+fitMvdc">fitMvdc</a></code>.
</p>


<h3>References</h3>

<p>Genest, C., Ghoudi, K., and Rivest, L.-P. (1995). A semiparametric
estimation procedure of dependence parameters in multivariate
families of distributions. <em>Biometrika</em> <b>82</b>, 543&ndash;552.
</p>

<hr>
<h2 id='fitLambda'>Non-parametric Estimators of the Matrix of Tail-Dependence Coefficients</h2><span id='topic+fitLambda'></span>

<h3>Description</h3>

<p>Computing non-parametric estimators of the (matrix of) tail-dependence coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitLambda(u, method = c("Schmid.Schmidt", "Schmidt.Stadtmueller", "t"),
          p = 1/sqrt(nrow(u)), lower.tail = TRUE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitLambda_+3A_u">u</code></td>
<td>
<p><code class="reqn">n\times d</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of (pseudo-)observations in
<code class="reqn">[0,1]^d</code> for estimating the (matrix of) tail-dependence coefficients.</p>
</td></tr>
<tr><td><code id="fitLambda_+3A_method">method</code></td>
<td>
<p>the method with which the tail-dependence coefficients
are computed:
</p>

<dl>
<dt><code>method = "Schmid.Schmidt"</code>:</dt><dd><p>nonparametric estimator
of Schmid and Schmidt (2007) (see also Jaworksi et al. (2009, p. 231))
computed for all pairs (pairwise conditional Spearman's rho
for <code>u &lt;= p</code>).</p>
</dd>
<dt><code>method = "Schmidt.Stadtmueller"</code>:</dt><dd><p>nonparametric
estimator of Schmidt and Stadtmueller (2006)
computed for all pairs (pairwise empirical tail copula
for <code>u &lt;= p</code>).</p>
</dd>
<dt><code>method = "t"</code>:</dt><dd><p>fits pairwise <code class="reqn">t</code> copulas and
returns the implied tail-dependence coefficient.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="fitLambda_+3A_p">p</code></td>
<td>
<p>(small) cut-off parameter in <code class="reqn">[0,1]</code> below (for
<code>tail = "lower"</code>) or above (for <code>tail = "upper"</code>) which
the estimation takes place.</p>
</td></tr>
<tr><td><code id="fitLambda_+3A_lower.tail">lower.tail</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether the lower
(the default) or upper tail-dependence coefficient is computed; in
case of the latter, the lower tail dependence coefficient of
the flipped data <code>1-u</code> is computed.</p>
</td></tr>
<tr><td><code id="fitLambda_+3A_verbose">verbose</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> indicating whether a progress
bar is displayed.</p>
</td></tr>
<tr><td><code id="fitLambda_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the underlying functions
(at the moment only to <code><a href="stats.html#topic+optimize">optimize</a>()</code> in case <code>method
    = "t"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As seen in the examples, be careful using nonparametric estimators,
they might not perform too well (depending on <code>p</code> and in
general). After all, the notion of tail dependence is a limit,
finite sample sizes may not be able to capture limits well.
</p>


<h3>Value</h3>

<p>The matrix of pairwise coefficients of tail dependence; for
<code>method = "t"</code> a <code><a href="base.html#topic+list">list</a></code> with components
<code>Lambda</code>,
the matrix of pairwise estimated correlation coefficients <code>P</code>
and the matrix of pairwise estimated degrees of freedom <code>Nu</code>.
</p>


<h3>References</h3>

<p>Jaworski, P., Durante, F., Härdle, W. K., Rychlik, T. (2010).
<em>Copula Theory and Its Applications</em>
Springer, Lecture Notes in Statistics &ndash; Proceedings.
</p>
<p>Schmid, F., Schmidt, R. (2007). Multivariate conditional versions of
Spearman's rho and related measures of tail dependence.
<em>Journal of Multivariate Analysis</em> <b>98</b>, 1123&ndash;1140.
<a href="https://doi.org/10.1016/j.jmva.2006.05.005">doi:10.1016/j.jmva.2006.05.005</a>
</p>
<p>Schmidt, R., Stadtmueller, U. (2006). Non-parametric Estimation of
Tail Dependence.
<em>Scandinavian Journal of Statistics</em> <b>33</b>(2), 307&ndash;335.
<a href="https://doi.org/10.1111/j.1467-9469.2005.00483.x">doi:10.1111/j.1467-9469.2005.00483.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lambda">lambda</a>()</code> computes the true (lower and upper) tail
coefficients for a given copula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10000 # sample size
p &lt;- 0.01 # cut-off

## Bivariate case
d &lt;- 2
cop &lt;- claytonCopula(2, dim = d)
set.seed(271)
U &lt;- rCopula(n, copula = cop) # generate observations (unrealistic)
(lam.true &lt;- lambda(cop)) # true tail-dependence coefficients lambda
(lam.C &lt;- c(lower = fitLambda(U, p = p)[2,1],
            upper = fitLambda(U, p = p, lower.tail = FALSE)[2,1])) # estimate lambdas
## =&gt; pretty good
U. &lt;- pobs(U) # pseudo-observations (realistic)
(lam.C. &lt;- c(lower = fitLambda(U., p = p)[2,1],
             upper = fitLambda(U., p = p, lower.tail = FALSE)[2,1])) # estimate lambdas
## =&gt; The pseudo-observations do have an effect...

## Higher-dimensional case
d &lt;- 5
cop &lt;- claytonCopula(2, dim = d)
set.seed(271)
U &lt;- rCopula(n, copula = cop) # generate observations (unrealistic)
(lam.true &lt;- lambda(cop)) # true tail-dependence coefficients lambda
(Lam.C &lt;- list(lower = fitLambda(U, p = p),
               upper = fitLambda(U, p = p, lower.tail = FALSE))) # estimate Lambdas
## =&gt; Not too good
U. &lt;- pobs(U) # pseudo-observations (realistic)
(Lam.C. &lt;- list(lower = fitLambda(U., p = p),
                upper = fitLambda(U., p = p, lower.tail = FALSE))) # estimate Lambdas
## =&gt; Performance not too great here in either case
</code></pre>

<hr>
<h2 id='fitMvdc'>Estimation of Multivariate Models Defined via Copulas</h2><span id='topic+fitMvdc'></span><span id='topic+coef.fittedMV'></span><span id='topic+logLik.fittedMV'></span><span id='topic+vcov.fittedMV'></span><span id='topic+loglikMvdc'></span>

<h3>Description</h3>

<p>Fitting copula-based multivariate distributions
(<code>"<a href="#topic+mvdc-class">mvdc</a>"</code>) to multivariate data,
estimating both the marginal and the copula parameters.
</p>
<p>If you assume (non parametric) margins, in other words, take the
empirical distributions for all margins, you can use
<code><a href="#topic+fitCopula">fitCopula</a>(*, <a href="#topic+pobs">pobs</a>(x))</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikMvdc(param, x, mvdc)
fitMvdc(data, mvdc, start, optim.control = list(), method = "BFGS",
        lower = -Inf, upper = Inf,
        estimate.variance = fit$convergence == 0, hideWarnings = TRUE)

## S3 method for class 'fittedMV'
coef(object, SE = FALSE, orig = TRUE, ...)
## S3 method for class 'fittedMV'
logLik(object, ...)
## S3 method for class 'fittedMV'
vcov(object, orig = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitMvdc_+3A_param">param</code></td>
<td>
<p>a vector of parameter values.  When specifying parameters for
<code>mvdc</code> objects, the parameters must be ordered with the
marginals first and the copula parameters last.  When the
<code>mvdc</code> object has <code>marginsIdentical = TRUE</code>, only the
parameters of one marginal must be specified.</p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_x">x</code></td>
<td>
<p>a data matrix.</p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_mvdc">mvdc</code></td>
<td>
<p>a <code>"<a href="#topic+mvdc-class">mvdc</a>"</code> object. </p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_data">data</code></td>
<td>
<p>a data matrix.</p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_start">start</code></td>
<td>
<p>a vector of starting value for <code>"param"</code>.  See
<code>"param"</code> above for ordering of this vector.</p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_optim.control">optim.control</code></td>
<td>
<p>a list of controls to be passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_method">method</code></td>
<td>
<p>the method for <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_lower">lower</code>, <code id="fitMvdc_+3A_upper">upper</code></td>
<td>
<p>bounds on each parameter, passed to
<code><a href="stats.html#topic+optim">optim</a></code>, typically &ldquo;box constraints&rdquo; for
<code>method = "L-BFGS-B"</code>.</p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_estimate.variance">estimate.variance</code></td>
<td>
<p>logical; if true (as by default, if the
optimization converges), the asymptotic variance is estimated.</p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_hidewarnings">hideWarnings</code></td>
<td>
<p>logical indicating if warning messages from
likelihood maximization, e.g., from evaluating at invalid parameter
values, should be suppressed (via <code><a href="base.html#topic+suppressWarnings">suppressWarnings</a></code>).</p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>"<a href="#topic+fitMvdc-class">fitMvdc</a>"</code>.</p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_se">SE</code></td>
<td>
<p>for the <code><a href="stats.html#topic+coef">coef</a></code> method, a logical indicating if
standard errors should be returned in addition to the estimated
parameters (in a <code><a href="base.html#topic+matrix">matrix</a></code>).  This is equivalent, but
more efficient than, e.g., <code>coef(summary(object))</code>.</p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_orig">orig</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, relevant currently only for
<code><a href="#topic+mixCopula">mixCopula</a></code> fits with free weights.  <code>orig</code> indicates
if the weights should be shown in original scale (<code>orig=TRUE</code>) or
in the transformed log- aka lambda-space.</p>
</td></tr>
<tr><td><code id="fitMvdc_+3A_...">...</code></td>
<td>
<p>potentially further arguments to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value <code>loglikMvdc()</code> is the log likelihood evaluated
for the given value of <code>param</code>.
</p>
<p>The return value of <code>fitMvdc()</code> is an object of class
<code>"<a href="#topic+fitMvdc-class">fitMvdc</a>"</code> 
(see there), containing slots (among others!):
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>the estimate of the parameters.</p>
</td></tr>
<tr><td><code>var.est</code></td>
<td>
<p>large-sample (i.e., asymptotic) variance estimate of the parameter
estimator (filled with <code>NA</code> if <code>estimate.variance = FALSE</code>).</p>
</td></tr>
<tr><td><code>mvdc</code></td>
<td>
<p>the <em>fitted</em> multivariate distribution, see
<code><a href="#topic+mvdc-class">mvdc</a></code>.</p>
</td></tr>
</table>
<p>The <code><a href="base.html#topic+summary">summary</a>()</code> method for <code>"fitMvdc"</code> objects
returns a S3 &ldquo;class&rdquo; <code>"summary.fitMvdc"</code>, simply a list
with components <code>method</code>, <code>loglik</code>, and <code>convergence</code>,
all three from corresponding slots of the
<code>"<a href="#topic+fitMvdc-class">fitMvdc</a>"</code> objects, and
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a matrix of estimated coefficients, standard
errors, t values and p-values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>User-defined marginal distributions can be used as long as the
<code>"{dpq}"</code> functions are defined.
See <code>vignette("AR_Clayton", package="copula")</code>.
</p>
<p>When covariates are available for marginal distributions or for the copula,
one can construct the loglikelihood function and feed it to <code>"optim"</code>
to estimate all the parameters.
</p>
<p>Finally, note that some of the fitting functions generate error
messages because invalid parameter values are tried during the
optimization process (see <code><a href="stats.html#topic+optim">optim</a></code>).  This should be rarer
since 2013, notably for likelihood based methods (as the likelihood
is now rather set to <code>-Inf</code> than giving an error).
</p>
<p>Previously, <code>loglikMvdc()</code> had an argument <code>hideWarnings</code>;
nowadays, do use <code><a href="base.html#topic+suppressWarnings">suppressWarnings</a>(..)</code> if you are sure
you do not want to see them.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvdc">mvdc</a></code> and <code><a href="#topic+mvdc-class">mvdc</a></code>;
further, <code><a href="#topic+Copula">Copula</a></code>, <code><a href="#topic+fitCopula">fitCopula</a></code>,
<code><a href="#topic+gofCopula">gofCopula</a></code>.
</p>
<p>For fitting univariate marginals, <code><a href="MASS.html#topic+fitdistr">fitdistr</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G3 &lt;- gumbelCopula(3, dim=2)
gMvd2  &lt;- mvdc(G3, c("exp","exp"),
               param = list(list(rate=2), list(rate=4)))
## with identical margins:
gMvd.I &lt;- mvdc(G3, "exp",
               param = list(rate=3), marginsIdentical=TRUE)

(Xtras &lt;- copula:::doExtras()) # determine whether examples will be extra (long)
n &lt;- if(Xtras) 10000 else 200 # sample size (realistic vs short for example)

set.seed(11)
x &lt;- rMvdc(n, gMvd2)
## Default:     hideWarnings = FALSE .. i.e. show warnings here
fit2 &lt;- fitMvdc(x, gMvd2, start = c(1,1, 2))
fit2
confint(fit2)
summary(fit2) # slightly more
## The estimated, asymptotic var-cov matrix [was used for confint()]:
vcov(fit2)

## with even more output for the "identical margin" case:
fitI &lt;- fitMvdc(x, gMvd.I, start = c(3, 2),
                optim.control=list(trace= TRUE, REPORT= 2))
summary(fitI)
coef(fitI, SE = TRUE)
stopifnot(is.matrix(coef(fitI, SE = TRUE)),
          is.matrix(print( confint(fitI) )) )

## a wrong starting value can already be *the* problem:
f2 &lt;- try(fitMvdc(x, gMvd.I, start = c(1, 1),
           optim.control=list(trace= TRUE, REPORT= 2)))
##--&gt; Error in optim( ... ) : non-finite finite-difference value [2]

##==&gt; "Solution" :  Using a more robust (but slower) optim() method:
fI.2 &lt;- fitMvdc(x, gMvd.I, start = c(1, 1), method = "Nelder",
                optim.control=list(trace= TRUE))
fI.2


</code></pre>

<hr>
<h2 id='fixParam'>Fix a Subset of a Copula Parameter Vector</h2><span id='topic+fixParam'></span><span id='topic+fixedParam+3C-'></span><span id='topic+fixedParam+3C-+2Ccopula+2Clogical-method'></span><span id='topic+fixedParam+3C-+2CkhoudrajiCopula+2Clogical-method'></span><span id='topic+fixedParam+3C-+2CmixCopula+2Clogical-method'></span><span id='topic+fixedParam+3C-+2CrotCopula+2Clogical-method'></span><span id='topic+isFree'></span><span id='topic+isFree+2CparCopula-method'></span><span id='topic+isFree+2Ccopula-method'></span><span id='topic+isFree+2CkhoudrajiCopula-method'></span><span id='topic+isFree+2CmixCopula-method'></span><span id='topic+isFree+2CrotCopula-method'></span><span id='topic+isFreeP'></span><span id='topic+nParam'></span><span id='topic+nParam+2CparCopula-method'></span><span id='topic+nParam+2Ccopula-method'></span><span id='topic+nParam+2CkhoudrajiCopula-method'></span><span id='topic+nParam+2CmixCopula-method'></span><span id='topic+nParam+2CrotCopula-method'></span>

<h3>Description</h3>

<p>It is sometimes useful to keep fixed some components of a copula
parameter vector whereas the others are &ldquo;free&rdquo; and will be
estimated, e.g., by <code><a href="#topic+fitCopula">fitCopula</a></code>.
</p>
<p>The first two functions set or modify the &ldquo;fixedness&rdquo;, whereas
<code>isFree()</code>, <code>isFreeP()</code> and <code>nParam()</code> are utilities
enquiring about the &ldquo;fixedness&rdquo; of the parameters (of a copula).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixParam(param, fixed = TRUE)
fixedParam(copula) &lt;- value

isFreeP(param)
## S4 method for signature 'copula'
isFree(copula)
## and specific '*Copula' methods
## S4 method for signature 'copula'
nParam(copula, freeOnly = FALSE)
## and specific '*Copula' methods
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixParam_+3A_param">param</code></td>
<td>
<p>numeric parameter vector</p>
</td></tr>
<tr><td><code id="fixParam_+3A_fixed">fixed</code>, <code id="fixParam_+3A_value">value</code></td>
<td>
<p>logical vector of the same length as <code>param</code>
indicating for each component <code>param[j]</code> if it is (going to be)
fixed or not.</p>
</td></tr>
<tr><td><code id="fixParam_+3A_copula">copula</code></td>
<td>
<p>a <code>"<a href="#topic+copula-class">copula</a>"</code> object.</p>
</td></tr>
<tr><td><code id="fixParam_+3A_freeonly">freeOnly</code></td>
<td>
<p>logical (scalar) indicating if only free parameters
should be counted or all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fixParam(param)</code> returns a <code><a href="base.html#topic+numeric">numeric</a></code> vector with
attribute <code>"fixed"</code>(a <code><a href="base.html#topic+logical">logical</a></code>, either <code>TRUE</code>
or vector of the same length as <code>param</code>) to indicate which
components of <code>param</code> are to be held fixed or not.
</p>
<p><code>fixedParam&lt;-</code>, a generic function, returns a
<code>"<a href="#topic+copula-class">copula</a>"</code> object
with a partly fixed parameter (slot), i.e., corresponding to
<code>fixParam()</code> above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitCopula">fitCopula</a></code> for fitting;
t-copulas, <code><a href="#topic+tCopula">tCopula</a>(*, df.fixed=TRUE)</code> now uses parameter
fixing for <code>"df"</code>.
</p>
<p><code><a href="#topic+setTheta">setTheta</a>()</code> for setting or <em>changing</em> the
<em>non-fixed</em> parameter values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nc1 &lt;- normalCopula(dim = 3, fixParam(c(.6,.3,.2), c(TRUE, FALSE,FALSE)),
                    dispstr = "un")
nc1
nc13 &lt;- nc12 &lt;- nc1
fixedParam(nc12) &lt;- c(TRUE, TRUE, FALSE) ; nc12
fixedParam(nc13) &lt;- c(TRUE, FALSE, TRUE) ; nc13
set.seed(17); x &lt;- rCopula(100, nc1)
summary(f.13 &lt;- fitCopula(nc13, x, method = "ml"))
f.13@copula  # 'rho.2' is estimated; the others kept fixed

## Setting to 'FALSE' (removes the "fixed" parts completely):
nc0 &lt;- nc13; fixedParam(nc0) &lt;- FALSE
nc0
stopifnot(is.null(attributes(nc0@parameters)))
</code></pre>

<hr>
<h2 id='gasoil'>Daily Crude Oil and Natural Gas Prices from 2003 to 2006</h2><span id='topic+gasoil'></span>

<h3>Description</h3>

<p>Three years of daily prices (from July 2003 to July 2006) of crude oil
and natural gas. These data should be very close to those analysed in
Grégoire, Genest and Gendron (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gasoil, package="copula")</code></pre>


<h3>Format</h3>

<p>A data frame of 762 daily prices from 2003 to 2006.
</p>

<dl>
<dt><code>date</code></dt><dd><p>date (of class <code><a href="base.html#topic+Date">Date</a></code>).</p>
</dd>
<dt><code>oil</code></dt><dd><p>daily price of crude oil</p>
</dd>
<dt><code>gas</code></dt><dd><p>daily price of natural gas</p>
</dd>
</dl>



<h3>References</h3>

<p>Grégoire, V., Genest, C., and Gendron, M. (2008)
Using copulas to model price dependence in energy markets.
<em>Energy Risk</em> <b>5</b>(5), 58&ndash;64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gasoil)
## Log Scaled  Oil &amp; Gas Prices :
lattice :: xyplot(oil + gas ~ date, data = gasoil, auto.key=TRUE,
                  type = c("l","r"),
                  scales=list(y = list(log = TRUE), equispaced.log = FALSE))
</code></pre>

<hr>
<h2 id='generator'>Generator Functions for Archimedean and Extreme-Value Copulas</h2><span id='topic+iPsi'></span><span id='topic+iPsi-methods'></span><span id='topic+iPsi+2CclaytonCopula-method'></span><span id='topic+iPsi+2CfrankCopula-method'></span><span id='topic+iPsi+2CgumbelCopula-method'></span><span id='topic+iPsi+2CamhCopula-method'></span><span id='topic+iPsi+2CjoeCopula-method'></span><span id='topic+genInv'></span><span id='topic+psi'></span><span id='topic+psi-methods'></span><span id='topic+psi+2CclaytonCopula-method'></span><span id='topic+psi+2CfrankCopula-method'></span><span id='topic+psi+2CgumbelCopula-method'></span><span id='topic+psi+2CamhCopula-method'></span><span id='topic+psi+2CjoeCopula-method'></span><span id='topic+genFun'></span><span id='topic+iPsi'></span><span id='topic+iPsi-methods'></span><span id='topic+iPsi+2CclaytonCopula-method'></span><span id='topic+iPsi+2CfrankCopula-method'></span><span id='topic+iPsi+2CgumbelCopula-method'></span><span id='topic+iPsi+2CamhCopula-method'></span><span id='topic+iPsi+2CjoeCopula-method'></span><span id='topic+genFunDer1'></span><span id='topic+genFunDer2'></span><span id='topic+diPsi'></span><span id='topic+diPsi-methods'></span><span id='topic+diPsi+2CclaytonCopula-method'></span><span id='topic+diPsi+2CfrankCopula-method'></span><span id='topic+diPsi+2CgumbelCopula-method'></span><span id='topic+diPsi+2CamhCopula-method'></span><span id='topic+diPsi+2CjoeCopula-method'></span><span id='topic+Afun'></span><span id='topic+A'></span><span id='topic+A-methods'></span><span id='topic+A+2CgalambosCopula-method'></span><span id='topic+A+2CgumbelCopula-method'></span><span id='topic+A+2ChuslerReissCopula-method'></span><span id='topic+A+2CtawnCopula-method'></span><span id='topic+A+2CtevCopula-method'></span><span id='topic+A+2CkhoudrajiCopula-method'></span><span id='topic+A+2CindepCopula-method'></span><span id='topic+AfunDer'></span><span id='topic+dAdu'></span><span id='topic+dAdu-methods'></span><span id='topic+dAdu+2CgalambosCopula-method'></span><span id='topic+dAdu+2CgumbelCopula-method'></span><span id='topic+dAdu+2ChuslerReissCopula-method'></span><span id='topic+dAdu+2CtawnCopula-method'></span><span id='topic+dAdu+2CtevCopula-method'></span>

<h3>Description</h3>

<p>Methods to evaluate the generator function, the inverse generator
function, and derivatives of the inverse of the generator function for
Archimedean copulas. For extreme-value copulas, the &ldquo;Pickands
dependence function&rdquo; plays the role of a generator function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi(copula, s)
iPsi(copula, u, ...)
diPsi(copula, u, degree=1, log=FALSE, ...)

A(copula, w)
dAdu(copula, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generator_+3A_copula">copula</code></td>
<td>
<p>an object of class <code>"<a href="#topic+copula-class">copula</a>"</code>. </p>
</td></tr>
<tr><td><code id="generator_+3A_u">u</code>, <code id="generator_+3A_s">s</code>, <code id="generator_+3A_w">w</code></td>
<td>
<p>numerical vector at which these functions are to be
evaluated. </p>
</td></tr>
<tr><td><code id="generator_+3A_...">...</code></td>
<td>
<p>further arguments for specific families.</p>
</td></tr>
<tr><td><code id="generator_+3A_degree">degree</code></td>
<td>
<p>the degree of the derivative (defaults to 1).</p>
</td></tr>
<tr><td><code id="generator_+3A_log">log</code></td>
<td>
<p>logical indicating if the <code><a href="base.html#topic+log">log</a></code> of the
<em>absolute</em> derivative is desired.  Note that the derivatives
of <code class="reqn">psi</code> alternate in sign.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>psi()</code> and <code>iPsi()</code> are, respectively, the generator
function <code class="reqn">\psi()</code> and its inverse <code class="reqn">\psi^{(-1)}</code> for
an Archimedean copula, see <code><a href="#topic+pnacopula">pnacopula</a></code> for definition and
more details.
</p>
<p><code>diPsi()</code> computes (currently only the first two) derivatives of
<code>iPsi()</code> (<code class="reqn">= \psi^{(-1)}</code>).
</p>
<p><code>A()</code>, the &ldquo;Pickands dependence function&rdquo;, can be seen as the
generator function of an extreme-value copula. For instance, in the
bivariate case, we have the following result (see, e.g., Gudendorf and
Segers 2009):
</p>
<p>A bivariate copula <code class="reqn">C</code> is an extreme-value copula if and only if
</p>
<p style="text-align: center;"><code class="reqn">C(u,v) = (uv)^{A(\log(v) / \log(uv))}, \qquad (u,v) \in (0,1]^2
  \setminus \{(1,1)\},</code>
</p>
<p> where <code class="reqn">A: [0, 1] \to [1/2, 1]</code> is convex and satisfies <code class="reqn">\max(t, 1-t) \le A(t) \le
  1</code> for all <code class="reqn">t \in [0, 1]</code>.
<br />
In the <code class="reqn">d</code>-variate case, there is a similar characterization,
except that this time, the Pickands dependence function <code class="reqn">A</code> is
defined on the <code class="reqn">d</code>-dimensional unit simplex.
</p>
<p><code>dAdu()</code> returns a data.frame containing the 1st and 2nd
derivative of <code>A()</code>.
</p>


<h3>References</h3>

<p>Gudendorf, G. and Segers, J. (2010).
Extreme-value copulas. In <em>Copula theory and its applications</em>,
Jaworski, P., Durante, F., Härdle, W. and Rychlik, W., Eds.
Springer-Verlag, Lecture Notes in Statistics, 127&ndash;146,
<a href="https://doi.org/10.1007/978-3-642-12465-5">doi:10.1007/978-3-642-12465-5</a>; preprint at
<a href="https://arxiv.org/abs/0911.1015">https://arxiv.org/abs/0911.1015</a>.
</p>


<h3>See Also</h3>

<p>Nonparametric estimators for <code class="reqn">A()</code> are available, see
<code><a href="#topic+An">An</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## List the available methods (and their definitions):
showMethods("A")
showMethods("iPsi", incl=TRUE)
</code></pre>

<hr>
<h2 id='getAcop'>Get &quot;acopula&quot; Family Object by Name</h2><span id='topic+getAcop'></span><span id='topic+getAname'></span><span id='topic+.ac.shortNames'></span><span id='topic+.ac.longNames'></span><span id='topic+.ac.objNames'></span><span id='topic+.ac.classNames'></span>

<h3>Description</h3>

<p>Get one of our &quot;acopula&quot; family objects (see <a href="#topic+acopula-families">acopula-families</a>
by name.
</p>
<p>Named strings for &ldquo;translation&rdquo; between different names and
forms of Archimedean copulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAcop (family, check = TRUE)
getAname(family, objName = FALSE)

.ac.shortNames
.ac.longNames
.ac.objNames
.ac.classNames
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAcop_+3A_family">family</code></td>
<td>
<p>either a <code><a href="base.html#topic+character">character</a></code> string, the short or longer
form of the Archimedean family name (for example, &quot;Clayton&quot; or simply &quot;C&quot;;
see the <code><a href="#topic+acopula-families">acopula-families</a></code> documentation), or an
<code><a href="#topic+acopula-class">acopula</a></code> family object, or an object inheriting
from class <code><a href="#topic+archmCopula-class">archmCopula</a></code>.</p>
</td></tr>
<tr><td><code id="getAcop_+3A_check">check</code></td>
<td>
<p>logical indicating whether the class of the return value
should be checked to be <code>"<a href="#topic+acopula-class">acopula</a>"</code>.</p>
</td></tr>
<tr><td><code id="getAcop_+3A_objname">objName</code></td>
<td>
<p>logical indicating that the <em>name</em> of the <span class="rlang"><b>R</b></span>
object should be returned, instead of the family name, e.g.,
<code>"copClayton"</code> instead of <code>"Clayton"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getAcop()</code> returns an <code>"<a href="#topic+acopula-class">acopula</a>"</code> family
object, typically one of one of our predefined ones.
</p>
<p><code>getAname()</code> returns a <code><a href="base.html#topic+character">character</a></code> string, the name
of an <code>"<a href="#topic+acopula-class">acopula</a>"</code> family object.
</p>
<p><code>.as.longnames</code> etc are named string constants, useful in
programming for all our (five) standard Archimedean families.
</p>


<h3>See Also</h3>

<p>Our predefined <code><a href="#topic+acopula-families">acopula-families</a></code>;
the class definition <code>"<a href="#topic+acopula-class">acopula</a>"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getAcop("Gumbel")

## different ways of getting the same "acopula" family object:
stopifnot(## Joe (three ways):
          identical(getAcop("J"), getAcop("Joe")),
          identical(getAcop("J"), copJoe),
          ## Frank (yet another two different ways):
          identical(getAcop(frankCopula()), copFrank),
          identical(getAcop("frankCopula"), copFrank))

stopifnot(
  identical(getAname(claytonCopula()), getAname("C")),
  identical(getAname(copClayton), "Clayton"), identical(getAname("J"), "Joe"),
  identical(getAname(amhCopula(), TRUE), "copAMH"),
  identical(getAname(joeCopula(), TRUE), "copJoe")
)

.ac.shortNames
.ac.longNames
.ac.objNames
.ac.classNames
</code></pre>

<hr>
<h2 id='getIniParam'>Get Initial Parameter Estimate for Copula</h2><span id='topic+getIniParam'></span><span id='topic+getIniParam+2CmixCopula-method'></span><span id='topic+getIniParam+2CparCopula-method'></span>

<h3>Description</h3>

<p>A (S4) generic function and methods providing a typically cheap method to get
valid parameters for the <code>copula</code>, given the <code>data</code>.  This is
used, e.g., in <code><a href="#topic+fitCopula">fitCopula</a>()</code> when <code>start</code> is not
specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIniParam(copula, data, default, named = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIniParam_+3A_copula">copula</code></td>
<td>
<p>a <code>"<a href="#topic+copula-class">copula</a>"</code> object.</p>
</td></tr>
<tr><td><code id="getIniParam_+3A_data">data</code></td>
<td>
<p>an <code class="reqn">n\times d</code>-matrix of data to which the copula should be fitted.</p>
</td></tr>
<tr><td><code id="getIniParam_+3A_default">default</code></td>
<td>
<p>a parameter vector of correct length, to be used when no
method is available or the method does &ldquo;not work&rdquo;.</p>
</td></tr>
<tr><td><code id="getIniParam_+3A_named">named</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the result should have
<code><a href="base.html#topic+names">names</a></code>.</p>
</td></tr>
<tr><td><code id="getIniParam_+3A_...">...</code></td>
<td>
<p>optional further arguments to underlying methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+numeric">numeric</a></code> vector of correct length, say <code>param</code>, which
should e.g., &ldquo;work&rdquo; in <code><a href="#topic+loglikCopula">loglikCopula</a>(param, u = data, copula)</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(copula = "parCopula")</code></dt><dd><p>Close to a <em>default</em>
method (as class <code>"<a href="#topic+parCopula-class">parCopula</a>"</code> contains most
copulas), currently mainly trying to use a version of
<code><a href="#topic+fitCopula">fitCopula</a>(*, method = "itau")</code> (itself based on moment
matching <code><a href="#topic+iTau">iTau</a>()</code>).</p>
</dd>
<dt><code>signature(copula = "mixCopula")</code></dt><dd>
<p>a relatively simple method, for the copula parameters, trying
<code>getInitParam(cop[[k]])</code> for each component, and using equal weights <code>w[k]</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+getTheta">getTheta</a>()</code> gets such a vector <em>from</em> a <code>copula</code> object;
<code><a href="#topic+fitCopula">fitCopula</a></code>, <code><a href="#topic+loglikCopula">loglikCopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # TODO !
</code></pre>

<hr>
<h2 id='getTheta'>Get the Parameter(s) of a Copula</h2><span id='topic+getTheta'></span><span id='topic+getTheta-methods'></span><span id='topic+getTheta+2CparCopula-method'></span><span id='topic+getTheta+2Ccopula-method'></span><span id='topic+getTheta+2Cacopula-method'></span><span id='topic+getTheta+2CXcopula-method'></span><span id='topic+getTheta+2CkhoudrajiCopula-method'></span><span id='topic+getTheta+2CmixCopula-method'></span><span id='topic+getTheta+2CrotCopula-method'></span>

<h3>Description</h3>

<p>Get the parameter (vector) <code class="reqn">\theta</code> (<code>theta</code>) of
a copula, see <code><a href="#topic+setTheta">setTheta</a></code> for more background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
getTheta(copula, freeOnly = TRUE, attr = FALSE, named = attr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTheta_+3A_copula">copula</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>"<a href="#topic+parCopula-class">parCopula</a>"</code>,
e.g., <code>"<a href="#topic+copula-class">copula</a>"</code>.</p>
</td></tr>

<tr><td><code id="getTheta_+3A_freeonly">freeOnly</code></td>
<td>
<p>logical indicating that only non-fixed aka
&ldquo;free&rdquo; parameters are to be returned (as vector).</p>
</td></tr>
<tr><td><code id="getTheta_+3A_attr">attr</code></td>
<td>
<p>logical indicating if <code><a href="base.html#topic+attributes">attributes</a></code> (such as
lower and uppder bounds for each parameters) are to be returned as well.</p>
</td></tr>
<tr><td><code id="getTheta_+3A_named">named</code></td>
<td>
<p>logical if the resulting parameter vector should have
<code><a href="base.html#topic+names">names</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parameter vector of the copula, a <code><a href="base.html#topic+numeric">numeric</a></code> vector,
possibly with names and other attributes (depending on the <code>attr</code>
and <code>named</code> arguments).
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(copula = "parCopula")</code></dt><dd><p>a default method,
returning <code>numeric(0).</code></p>
</dd>
<dt><code>signature(copula = "copula")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(copula = "acopula")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(copula = "khoudrajiCopula")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(copula = "mixCopula")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(copula = "rotCopula")</code></dt><dd><p> .. </p>
</dd>
<dt><code>signature(copula = "Xcopula")</code></dt><dd><p> .. </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+setTheta">setTheta</a></code>, its inverse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showMethods("getTheta")

getTheta(setTheta(copClayton, 0.5)) # is 0.5

</code></pre>

<hr>
<h2 id='ggraph-tools'>Computations for Graphical GOF Test via Pairwise Rosenblatt Transforms</h2><span id='topic+pairwiseCcop'></span><span id='topic+pairwiseIndepTest'></span><span id='topic+pviTest'></span><span id='topic+gpviTest'></span>

<h3>Description</h3>

<p>Tools for computing a graphical goodness-of-fit (GOF) test based on pairwise
Rosenblatt transformed data.
</p>

<dl>
<dt><code>pairwiseCcop()</code> </dt><dd><p>computes a <code class="reqn">(n,d,d)</code>-<code><a href="base.html#topic+array">array</a></code>
which contains pairwise Rosenblatt-transformed data.</p>
</dd>
<dt><code>pairwiseIndepTest()</code> </dt><dd><p>takes such an array as input and
computes a <code class="reqn">(d,d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of test results from
pairwise tests of independence (as by <code><a href="#topic+indepTest">indepTest</a>()</code>).</p>
</dd>
<dt><code>pviTest()</code> </dt><dd><p>can be used to extract the matrix of p-values from
the return matrix of <code>pairwiseIndepTest()</code>.</p>
</dd>
<dt><code>gpviTest()</code> </dt><dd><p>takes such a matrix of p-values and computes a
global p-value with the method provided.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>pairwiseCcop(u, copula, ...)
pairwiseIndepTest(cu.u, N=256,
        iTest = indepTestSim(n, p=2, m=2, N=N, verbose = idT.verbose, ...),
        verbose=TRUE, idT.verbose = verbose, ...)

 pviTest(piTest)
gpviTest(pvalues, method=p.adjust.methods, globalFun=min)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggraph-tools_+3A_u">u</code></td>
<td>
<p><code class="reqn">(n,d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of copula data.</p>
</td></tr>
<tr><td><code id="ggraph-tools_+3A_copula">copula</code></td>
<td>
<p>copula object used for the Rosenblatt transform
(<code class="reqn">H_0</code> copula).</p>
</td></tr>
<tr><td><code id="ggraph-tools_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the internal function
which computes the conditional copulas (for <code>pairwiseCcop()</code>).
Can be used to pass, for example, the degrees of freedom
parameter <code>df</code> for t-copulas.
</p>
<p>For <code>pairwiseIndepTest()</code>,
... are passed to <code><a href="#topic+indepTestSim">indepTestSim</a>()</code>.</p>
</td></tr>
<tr><td><code id="ggraph-tools_+3A_cu.u">cu.u</code></td>
<td>
<p><code class="reqn">(n,d,d)</code>-<code><a href="base.html#topic+array">array</a></code> as returned by
<code>pairwiseCcop()</code>.</p>
</td></tr>
<tr><td><code id="ggraph-tools_+3A_n">N</code></td>
<td>
<p>argument of <code><a href="#topic+indepTestSim">indepTestSim</a>()</code>.</p>
</td></tr>
<tr><td><code id="ggraph-tools_+3A_itest">iTest</code></td>
<td>
<p>the result of (a version of) <code><a href="#topic+indepTestSim">indepTestSim</a>()</code>;
as it does <em>not</em> depend on the data, and is costly to compute,
it can be computed separately and passed here.</p>
</td></tr>
<tr><td><code id="ggraph-tools_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+integer">integer</a></code> (or <code><a href="base.html#topic+logical">logical</a></code>)
indicating if and how much progress should be printed during the
computation of the tests for independence.</p>
</td></tr>
<tr><td><code id="ggraph-tools_+3A_idt.verbose">idT.verbose</code></td>
<td>
<p>logical, passed as <code>verbose</code> argument to
<code><a href="#topic+indepTestSim">indepTestSim</a>()</code>.</p>
</td></tr>
<tr><td><code id="ggraph-tools_+3A_pitest">piTest</code></td>
<td>
<p><code class="reqn">(d,d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of <code>indepTest</code>
objects as returned by <code>pairwiseIndepTest()</code>.</p>
</td></tr>
<tr><td><code id="ggraph-tools_+3A_pvalues">pvalues</code></td>
<td>
<p><code class="reqn">(d,d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of p-values.</p>
</td></tr>
<tr><td><code id="ggraph-tools_+3A_method">method</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> vector of adjustment methods for
p-values; see <code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code> for more details.</p>
</td></tr>
<tr><td><code id="ggraph-tools_+3A_globalfun">globalFun</code></td>
<td>
<p><code><a href="base.html#topic+function">function</a></code> determining how to compute a
global p-value from a matrix of pairwise adjusted p-values.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>pairwiseCcop</dt><dd><p><code class="reqn">(n,d,d)</code>-<code><a href="base.html#topic+array">array</a></code> <code>cu.u</code>
with <code>cu.u[i,j]</code> containing <code class="reqn">C(u_i\,|\,u_j)</code>
for <code class="reqn">i\neq j</code> and <code class="reqn">u_i</code> for <code class="reqn">i=j</code>.</p>
</dd>
<dt>pairwiseIndepTest</dt><dd><p><code class="reqn">(d,d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of lists
with test results as returned by <code><a href="#topic+indepTest">indepTest</a>()</code>.  The
test results correspond to pairwise tests of independence as
conducted by <code><a href="#topic+indepTest">indepTest</a>()</code>.</p>
</dd>
<dt>pviTest</dt><dd><p><code class="reqn">(d,d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of p-values.</p>
</dd>
<dt>gpviTest</dt><dd><p>global p-values for the specified methods.</p>
</dd>
</dl>



<h3>Note</h3>

<p>If <code>u</code> are distributed according to or &ldquo;perfectly&rdquo; sampled
from a copula, p-values on GOF tests for that copula should be uniformly
distributed in <code class="reqn">[0,1]</code>.
</p>


<h3>References</h3>

<p>Hofert and Mächler (2014),
see <code><a href="#topic+pairsRosenblatt">pairsRosenblatt</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairsRosenblatt">pairsRosenblatt</a></code> 
for where these tools are used, including
<code><a href="utils.html#topic+demo">demo</a>(gof_graph)</code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## demo(gof_graph)
</code></pre>

<hr>
<h2 id='gnacopula'>Goodness-of-fit Testing for (Nested) Archimedean Copulas</h2><span id='topic+gnacopula'></span>

<h3>Description</h3>

<p><code>gnacopula()</code> conducts a goodness-of-fit test for the given
(<code class="reqn">H_0</code>-)copula <code>cop</code> based on the (copula-)data <code>u</code>.
</p>
<p>NOTE: <code>gnacopula()</code> is deprecated, call <code>gofCopula()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnacopula(u, cop, n.bootstrap,
          estim.method = eval(formals(enacopula)$method),
          include.K=TRUE, n.MC=0, trafo=c("Hering.Hofert", "Rosenblatt"),
          method=eval(formals(gofTstat)$method), verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnacopula_+3A_u">u</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix of values in <code class="reqn">[0,1]</code>;
should be (pseudo-/copula-)observations from the copula to be
tested. Consider applying the function <code><a href="#topic+pobs">pobs</a>()</code> first
in order to obtain <code>u</code>.</p>
</td></tr>
<tr><td><code id="gnacopula_+3A_cop">cop</code></td>
<td>
<p><code class="reqn">H_0</code>-<code>"<a href="#topic+outer_nacopula-class">outer_nacopula</a>"</code> with specified
parameters to be tested for (currently only Archimedean copulas are
provided).</p>
</td></tr>
<tr><td><code id="gnacopula_+3A_n.bootstrap">n.bootstrap</code></td>
<td>
<p>positive integer specifying the number of bootstrap
replicates.</p>
</td></tr>
<tr><td><code id="gnacopula_+3A_estim.method">estim.method</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code>
string determining the estimation method; see
<code><a href="#topic+enacopula">enacopula</a>()</code>.  We currently only recommend the default
<code>"mle"</code> (or maybe <code>"smle"</code>).</p>
</td></tr>
<tr><td><code id="gnacopula_+3A_include.k">include.K</code></td>
<td>
<p>logical indicating whether the last component, involving the
Kendall distribution function <code><a href="#topic+K">K</a>()</code>, is used in the transformation
<code><a href="#topic+htrafo">htrafo</a>()</code> of Hering and Hofert (2011).  Note that this only
applies to <code>trafo="Hering.Hofert"</code>.</p>
</td></tr>
<tr><td><code id="gnacopula_+3A_n.mc">n.MC</code></td>
<td>
<p>parameter <code>n.MC</code> for <code><a href="#topic+htrafo">htrafo</a>()</code> (and thus
for <code><a href="#topic+K">K</a>()</code>) if <code>trafo="Hering.Hofert"</code> and for
<code><a href="#topic+cCopula">cCopula</a>()</code> if <code>trafo="Rosenblatt"</code>.</p>
</td></tr>
<tr><td><code id="gnacopula_+3A_trafo">trafo</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the multivariate
transformation performed for goodness-of-fit testing, which has to be one
(or a unique abbreviation) of
</p>

<dl>
<dt><code>"Hering.Hofert"</code></dt><dd><p>for the multivariate transformation of
Hering and Hofert (2011); see <code><a href="#topic+htrafo">htrafo</a>()</code>.</p>
</dd>
<dt><code>"Rosenblatt"</code></dt><dd><p>for the multivariate transformation of
Rosenblatt (1952); see <code><a href="#topic+cCopula">cCopula</a>()</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="gnacopula_+3A_method">method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the
goodness-of-fit test statistic to be used; see <code><a href="#topic+gofTstat">gofTstat</a>()</code>.</p>
</td></tr>
<tr><td><code id="gnacopula_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, the progress of the bootstrap is
displayed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>.</p>
</td></tr>
<tr><td><code id="gnacopula_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+enacopula">enacopula</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>gnacopula()</code> performs a parametric bootstrap for the
goodness-of-fit test specified by <code>trafo</code> and <code>method</code>.  The
transformation given by <code>trafo</code> specifies the multivariate
transformation which is first applied to the (copula-) data <code>u</code>
(typically, the pseudo-observations are used); see
<code><a href="#topic+htrafo">htrafo</a>()</code> or <code><a href="#topic+cCopula">cCopula</a>()</code> for more details. The
argument <code>method</code> specifies the particular goodness-of-fit test
carried out, which is either the Anderson-Darling test for the
univariate standard uniform distribution (for <code>method="AnChisq"</code> or
<code>method="AnGamma"</code>) in a one-dimensional setup or the tests
described in Genest et al. (2009) for the
multivariate standard uniform distribution directly in a multivariate
setup.  As estimation method, the method provided by
<code>estim.method</code> is used.
</p>
<p>Note that a finite-sample correction is made when computing p-values;
see <code><a href="#topic+gofCopula">gofCopula</a>()</code> for details.
</p>
<p>A word of warning: Do work carefully with the variety of different
goodness-of-fit tests that can be performed with <code>gnacopula()</code>.
For example, among the possible estimation methods at hand, only
MLE is known to be consistent (under conditions to be verified).
Furthermore, for the tests based on the Anderson-Darling test
statistic, it is theoretically not clear whether the parametric bootstrap
converges.  Consequently, the results obtained should be treated with
care.  Moreover, several estimation methods are known to be prone to
numerical errors (see Hofert et al. (2013)) and are thus not
recommended to be used in the parametric bootstrap. A warning is given if
<code>gnacopula()</code> is called with a method not being MLE.
</p>


<h3>Value</h3>

<p><code>gnacopula</code> returns an <span class="rlang"><b>R</b></span> object of class <code>"htest"</code>.
This object contains a list with the bootstrap results including the
components
</p>

<dl>
<dt><code>p.value</code>:</dt><dd><p>the bootstrapped p-value;</p>
</dd>
<dt><code>statistic</code>:</dt><dd><p>the value of the test statistic computed
for the data <code>u</code>;</p>
</dd>
<dt><code>data.name</code>:</dt><dd><p>the name of <code>u</code>;</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a <code><a href="base.html#topic+character">character</a></code> describing the
goodness-of-fit test applied;</p>
</dd>
<dt><code>estimator</code>:</dt><dd><p>the estimator computed for the data <code>u</code>;</p>
</dd>
<dt><code>bootStats</code>:</dt><dd><p>a list with component <code>estimator</code>
containing the estimators for all bootstrap replications and
component <code>statistic</code> containing the values of the test statistic
for each bootstrap replication.</p>
</dd>
</dl>



<h3>References</h3>

<p>Genest, C., Rémillard, B., and Beaudoin, D. (2009),
Goodness-of-fit tests for copulas: A review and a power study
<em>Insurance: Mathematics and Economics</em> <b>44</b>, 199&ndash;213.
</p>
<p>Rosenblatt, M. (1952),
Remarks on a Multivariate Transformation,
<em>The Annals of Mathematical Statistics</em> <b>23</b>, 3, 470&ndash;472.
</p>
<p>Hering, C. and Hofert, M. (2011),
Goodness-of-fit tests for Archimedean copulas in large dimensions,
submitted.
</p>
<p>Hofert, M., Mächler, M., and McNeil, A. J. (2012).
Likelihood inference for Archimedean copulas in high dimensions
under known margins. <em>Journal of Multivariate Analysis</em>
<b>110</b>, 133&ndash;150.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gofTstat">gofTstat</a>()</code> for the implemented test statistis,
<code><a href="#topic+htrafo">htrafo</a>()</code> and <code><a href="#topic+cCopula">cCopula</a>()</code> involved and
<code><a href="#topic+K">K</a>()</code> for the Kendall distribution function.
</p>
<p><code><a href="#topic+gofCopula">gofCopula</a>()</code> for other (parametric bootstrap) based
goodness-of-fit tests.
</p>

<hr>
<h2 id='gofCopula'>Goodness-of-fit Tests for Copulas</h2><span id='topic+gofCopula'></span><span id='topic+gofCopula-methods'></span><span id='topic+gofCopula+2Ccopula-method'></span><span id='topic+gofCopula+2CparCopula-method'></span><span id='topic+gofCopula+2CrotCopula-method'></span><span id='topic+gofMB'></span><span id='topic+gofPB'></span>

<h3>Description</h3>

<p>The goodness-of-fit tests are based, by default, on the empirical
process comparing the empirical copula with a parametric estimate of
the copula derived under the null hypothesis, the default test
statistic, &quot;Sn&quot;, being the Cramer-von Mises functional <code class="reqn">S_n</code>
defined in Equation (2) of Genest, Remillard and Beaudoin (2009). In
that case, approximate p-values for the test statistic can be obtained
either using a <em>parametric bootstrap</em> (see references two and
three) or by means of a faster <em>multiplier</em> approach (see
references four and five).
</p>
<p>Alternative test statistics can be used, in particular if a
<em>parametric bootstrap</em> is employed.
</p>
<p>The prinicipal function is <code>gofCopula()</code> which, depending on
<code>simulation</code> either calls <code>gofPB()</code> or <code>gofMB()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Generic [and "rotCopula" method] ------ Main function ------
gofCopula(copula, x, ...)
## S4 method for signature 'copula'
gofCopula(copula, x, N = 1000,
          method = c("Sn", "SnB", "SnC", "Rn"),
          estim.method = c("mpl", "ml", "itau", "irho", "itau.mpl"),
          simulation = c("pb", "mult"), test.method = c("family", "single"),
          verbose = interactive(), ties = NA,
          ties.method = c("max", "average", "first", "last", "random", "min"),
          fit.ties.meth = eval(formals(rank)$ties.method), ...)

## (Deprecated) internal 'helper' functions : ---
gofPB(copula, x, N, method = c("Sn", "SnB", "SnC"),
      estim.method = c("mpl", "ml", "itau", "irho", "itau.mpl"),
      trafo.method = if(method == "Sn") "none" else c("cCopula", "htrafo"),
      trafoArgs = list(), test.method = c("family", "single"),
      verbose = interactive(), useR = FALSE, ties = NA,
      ties.method = c("max", "average", "first", "last", "random", "min"),
      fit.ties.meth = eval(formals(rank)$ties.method), ...)

gofMB(copula, x, N, method = c("Sn", "Rn"),
      estim.method = c("mpl", "ml", "itau", "irho"),
      test.method = c("family", "single"), verbose = interactive(),
      useR = FALSE, m = 1/2, zeta.m = 0, b = 1/sqrt(nrow(x)),
      ties.method = c("max", "average", "first", "last", "random", "min"),
      fit.ties.meth = eval(formals(rank)$ties.method), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gofCopula_+3A_copula">copula</code></td>
<td>
<p>object of class <code>"<a href="#topic+copula-class">copula</a>"</code> representing the
hypothesized copula family.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_x">x</code></td>
<td>
<p>a data matrix that will be transformed to pseudo-observations
using <code><a href="#topic+pobs">pobs</a>()</code>.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_n">N</code></td>
<td>
<p>number of bootstrap or multiplier replications to be used to
obtain approximate realizations of the test statistic under the null
hypothesis.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_method">method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the
goodness-of-fit test statistic to be used.  For <code>simulation = "pb"</code>,
one of &quot;Sn&quot;, &quot;SnB&quot; or &quot;SnC&quot; with <code>trafo.method != "none"</code> if
<code>method != "Sn"</code>.
For <code>simulation = "mult"</code>, one of
<code>"Sn"</code> or <code>"Rn"</code>, where the latter is <code class="reqn">R_n</code> from
Genest et al. (2013).</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_estim.method">estim.method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the
estimation method to be used to estimate the dependence
parameter(s); see <code><a href="#topic+fitCopula">fitCopula</a>()</code>.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_simulation">simulation</code></td>
<td>
<p>a string specifying the resampling method for
generating approximate realizations of the test statistic under the null
hypothesis; can be either <code>"pb"</code> (parametric bootstrap) or
<code>"mult"</code> (multiplier).</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_test.method">test.method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the
test method to be used. Only in exceptional cases should this be
different from the default <code>test.method = "family"</code>.
If <code>test.method = "single"</code>, a test precisely for the provided
copula (not its parametric family) is conducted. This makes sense only for
specific applications such as testing random number generators.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_verbose">verbose</code></td>
<td>
<p>a logical specifying if progress of the parametric bootstrap
should be displayed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_...">...</code></td>
<td>
<p>for <code>gofCopula</code>, additional arguments passed to
<code>gofPB()</code> or <code>gofMB()</code>;
for <code>gofPB()</code> and <code>gofMB()</code>: additional arguments passed
to <code><a href="#topic+fitCopula">fitCopula</a>()</code>.  These may notably contain
<code>hideWarnings</code>, and
<code>optim.method</code>, <code>optim.control</code>, <code>lower</code>,
or <code>upper</code> depending on the <code>optim.method</code>.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_trafo.method">trafo.method</code></td>
<td>
<p>only for the parametric bootstrap (<code>"pb"</code>):
String specifying the transformation to
<code class="reqn">U[0,1]^d</code>; either <code>"none"</code> or one of <code>"cCopula"</code>,
see <code><a href="#topic+cCopula">cCopula</a>()</code>, or <code>"htrafo"</code>, see
<code><a href="#topic+htrafo">htrafo</a>()</code>.  If <code>method != "Sn"</code>, one needs to set
<code>trafo.method != "none"</code>.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_trafoargs">trafoArgs</code></td>
<td>
<p>only for the parametric bootstrap.  A
<code><a href="base.html#topic+list">list</a></code> of optional arguments passed to the
transformation method (see <code>trafo.method</code> above).</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_user">useR</code></td>
<td>
<p>logical indicating whether an <span class="rlang"><b>R</b></span> or C implementation is
used.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_ties.method">ties.method</code></td>
<td>
<p>string specifying how ranks should be computed,
except for fitting, if there are ties in any of the coordinate
samples of <code>x</code>; passed to <code><a href="#topic+pobs">pobs</a></code>.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_fit.ties.meth">fit.ties.meth</code></td>
<td>
<p>string specifying how ranks should be computed
when fitting by maximum pseudo-likelihood if there are ties in any
of the coordinate samples of <code>x</code>; passed to <code><a href="#topic+pobs">pobs</a></code>.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_ties">ties</code></td>
<td>
<p>only for the parametric bootstrap.  Logical indicating
whether a version of the parametric boostrap adapted to the
presence of ties in any of the coordinate samples of <code>x</code>
should be used; the default value of <code>NA</code> indicates that the
presence/absence of ties will be checked for automatically.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_m">m</code>, <code id="gofCopula_+3A_zeta.m">zeta.m</code></td>
<td>
<p>only for the multiplier with <code>method = "Rn"</code>.
<code>m</code> is the power and <code>zeta.m</code> is the adjustment
parameter <code class="reqn">\zeta_m</code> for the denominator of the test
statistic.</p>
</td></tr>
<tr><td><code id="gofCopula_+3A_b">b</code></td>
<td>
<p>only for the multiplier.  <code>b</code> is the bandwidth required
for the estimation of the first-order partial derivatives based on
the empirical copula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the parametric bootstrap is used, the dependence parameters of
the hypothesized copula family can be estimated by any estimation
method available for the family, up to a few exceptions.
If the multiplier is used, any of the rank-based methods
can be used in the bivariate case, but only maximum pseudo-likelihood
estimation can be used in the multivariate (multiparameter) case.
</p>
<p>The price to pay for the higher computational efficiency of the
multiplier is more programming work as certain
partial derivatives need to be computed for each hypothesized
parametric copula family. When estimation is based on maximization of
the pseudo-likelihood, these have been implemented for six copula
families thus far: the Clayton, Gumbel-Hougaard, Frank, Plackett,
normal and <code class="reqn">t</code> copula families.  For other families, numerical
differentiation based on <code><a href="numDeriv.html#topic+grad">grad</a>()</code> from package
<a href="https://CRAN.R-project.org/package=numDeriv"><span class="pkg">numDeriv</span></a> is used (and a warning message is displayed).
</p>
<p>Although the empirical processes involved in the multiplier and the
parametric bootstrap-based test are asymptotically equivalent under
the null, the finite-sample behavior of the two tests might differ
significantly.
</p>
<p>Both for the parametric bootstrap and the multiplier,
the approximate p-value is computed as
</p>
<p style="text-align: center;"><code class="reqn">(0.5 +\sum_{b=1}^N\mathbf{1}_{\{T_b\ge T\}})/(N+1),</code>
</p>

<p>where <code class="reqn">T</code> and <code class="reqn">T_b</code> denote the test statistic and
the bootstrapped test statistc, respectively. This ensures that the
approximate p-value is a number strictly between 0 and 1, which is
sometimes necessary for further treatments. See Pesarin (2001) for
more details.
</p>
<p>For the normal and <code class="reqn">t</code> copulas, several dependence structures can
be hypothesized: <code>"ex"</code> for exchangeable, <code>"ar1"</code> for AR(1),
<code>"toep"</code> for Toeplitz, and <code>"un"</code> for unstructured (see
<code><a href="#topic+ellipCopula">ellipCopula</a>()</code>). For the <code class="reqn">t</code> copula,
<code>"df.fixed"</code> has to be set to <code>TRUE</code>, which implies that the
degrees of freedom are not considered as a parameter to be estimated.
</p>
<p>The former argument <code>print.every</code> is deprecated and not
supported anymore; use <code>verbose</code> instead.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>corresponding approximate p-value.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>estimates of the parameters for the hypothesized
copula family.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>These tests were theoretically studied and implemented under the
assumption of continuous margins, which implies that ties in the
component samples occur with probability zero. The presence of ties in
the data might substantially affect the approximate p-values. Through
argument <code>ties</code>, the user can however select a version of the
parametric bootstrap adapted to the presence of ties. No such adaption
exists for the multiplier for the moment.
</p>







<h3>References</h3>

<p>Genest, C., Huang, W., and Dufour, J.-M. (2013).  A regularized
goodness-of-fit test for copulas.  <em>Journal de la
Société française de statistique</em>
<b>154</b>, 64&ndash;77.
</p>
<p>Genest, C. and Rémillard, B. (2008). Validity of the parametric
bootstrap for goodness-of-fit testing in semiparametric models.
<em>Annales de l'Institut Henri Poincare: Probabilites et Statistiques</em>
<b>44</b>, 1096&ndash;1127.
</p>
<p>Genest, C., Rémillard, B., and Beaudoin, D. (2009).
Goodness-of-fit tests for copulas: A review and a power study.
<em>Insurance: Mathematics and Economics</em> <b>44</b>, 199&ndash;214.
</p>
<p>Kojadinovic, I., Yan, J., and Holmes M. (2011).
Fast large-sample goodness-of-fit tests for copulas.
<em>Statistica Sinica</em> <b>21</b>, 841&ndash;871.
</p>
<p>Kojadinovic, I. and Yan, J. (2011). A goodness-of-fit test for
multivariate multiparameter copulas based on multiplier central limit
theorems. <em>Statistics and Computing</em> <b>21</b>, 17&ndash;30.
</p>
<p>Kojadinovic, I. and Yan, J. (2010).
Modeling Multivariate Distributions with Continuous Margins Using the
copula R Package.
<em>Journal of Statistical Software</em> <b>34</b>(9), 1&ndash;20,
<a href="https://www.jstatsoft.org/v34/i09/">https://www.jstatsoft.org/v34/i09/</a>.
</p>
<p>Kojadinovic, I. (2017). Some copula inference procedures adapted to
the presence of ties. <em>Computational Statistics and Data
Analysis</em> <b>112</b>, 24&ndash;41, <a href="https://arxiv.org/abs/1609.05519">https://arxiv.org/abs/1609.05519</a>.
</p>
<p>Pesarin, F. (2001).
<em>Multivariate Permutation Tests: With Applications in Biostatistics</em>.
Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitCopula">fitCopula</a>()</code> for the underlying estimation procedure and
<code><a href="#topic+gofTstat">gofTstat</a>()</code> for details on *some* of the available test
statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The following example is available in batch through
## demo(gofCopula)

n &lt;- 200; N &lt;- 1000 # realistic (but too large for interactive use)
n &lt;-  60; N &lt;-  200 # (time (and tree !) saving ...)

## A two-dimensional data example ----------------------------------
set.seed(271)
x &lt;- rCopula(n, claytonCopula(3))

## Does the Gumbel family seem to be a good choice (statistic "Sn")?
gofCopula(gumbelCopula(), x, N=N)
## With "SnC", really s..l..o..w.. --- with "SnB", *EVEN* slower
gofCopula(gumbelCopula(), x, N=N, method = "SnC", trafo.method = "cCopula")
## What about the Clayton family?
gofCopula(claytonCopula(), x, N=N)

## Similar with a different estimation method
gofCopula(gumbelCopula (), x, N=N, estim.method="itau")
gofCopula(claytonCopula(), x, N=N, estim.method="itau")


## A three-dimensional example  ------------------------------------
x &lt;- rCopula(n, tCopula(c(0.5, 0.6, 0.7), dim = 3, dispstr = "un"))

## Does the Gumbel family seem to be a good choice?
g.copula &lt;- gumbelCopula(dim = 3)
gofCopula(g.copula, x, N=N)
## What about the t copula?
t.copula &lt;- tCopula(dim = 3, dispstr = "un", df.fixed = TRUE)
if(FALSE) ## this is *VERY* slow currently
  gofCopula(t.copula, x, N=N)

## The same with a different estimation method
gofCopula(g.copula, x, N=N, estim.method="itau")
if(FALSE) # still really slow
  gofCopula(t.copula, x, N=N, estim.method="itau")

## The same using the multiplier approach
gofCopula(g.copula, x, N=N, simulation="mult")
gofCopula(t.copula, x, N=N, simulation="mult")
if(FALSE) # no yet possible
    gofCopula(t.copula, x, N=N, simulation="mult", estim.method="itau")

</code></pre>

<hr>
<h2 id='gofEVCopula'>Goodness-of-fit Tests for Bivariate Extreme-Value Copulas</h2><span id='topic+gofEVCopula'></span>

<h3>Description</h3>

<p>Goodness-of-fit tests for extreme-value copulas based on the
empirical process comparing one of the two nonparameteric
rank-based estimator of the Pickands dependence function studied in
Genest and Segers (2009) with a parametric estimate
of the Pickands dependence function derived under the null hypothesis.
The test statistic is the Cramer-von Mises functional Sn defined
in Equation (5) of Genest, Kojadinovic, G. Nešlehová, and Yan (2010).
Approximate p-values for the test statistic are obtained using a
parametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gofEVCopula(copula, x, N = 1000,
            method = c("mpl", "ml", "itau", "irho"),
            estimator = c("CFG", "Pickands"), m = 1000,
            verbose = interactive(),
            ties.method = c("max", "average", "first", "last", "random", "min"),
            fit.ties.meth = eval(formals(rank)$ties.method), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gofEVCopula_+3A_copula">copula</code></td>
<td>
<p> object of class <code>"<a href="#topic+evCopula-class">evCopula</a>"</code>
representing the hypothesized extreme-value copula family.</p>
</td></tr>
<tr><td><code id="gofEVCopula_+3A_x">x</code></td>
<td>
<p> a data matrix that will be transformed to pseudo-observations. </p>
</td></tr>
<tr><td><code id="gofEVCopula_+3A_n">N</code></td>
<td>
<p> number of bootstrap samples to be used to
simulate realizations of the test statistic under the null
hypothesis.</p>
</td></tr>
<tr><td><code id="gofEVCopula_+3A_method">method</code></td>
<td>
<p> estimation method to be used to estimate the
dependence parameter(s); can be either <code>"mpl"</code>
(maximum pseudo-likelihood), <code>"itau"</code> (inversion of
Kendall's tau) or <code>"irho"</code> (inversion of Spearman's rho). </p>
</td></tr>
<tr><td><code id="gofEVCopula_+3A_estimator">estimator</code></td>
<td>
<p> specifies which nonparametric rank-based estimator
of the unknown Pickands dependence function to use; can be either
<code>"CFG"</code> (Caperaa-Fougeres-Genest) or  <code>"Pickands"</code>.</p>
</td></tr>
<tr><td><code id="gofEVCopula_+3A_m">m</code></td>
<td>
<p> number of points of the uniform grid on [0,1] used to
compute the test statistic numerically.</p>
</td></tr>
<tr><td><code id="gofEVCopula_+3A_verbose">verbose</code></td>
<td>
<p>a logical specifying if progress of the bootstrap
should be displayed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>.</p>
</td></tr>
<tr><td><code id="gofEVCopula_+3A_ties.method">ties.method</code></td>
<td>
<p>string specifying how ranks should be computed,
except for fitting, if there are ties in any of the coordinate
samples of <code>x</code>; passed to <code><a href="#topic+pobs">pobs</a></code>.</p>
</td></tr>
<tr><td><code id="gofEVCopula_+3A_fit.ties.meth">fit.ties.meth</code></td>
<td>
<p>string specifying how ranks should be computed
when fitting by maximum pseudo-likelihood if there are ties in any
of the coordinate samples of <code>x</code>; passed to <code><a href="#topic+pobs">pobs</a></code>.</p>
</td></tr>
<tr><td><code id="gofEVCopula_+3A_...">...</code></td>
<td>
<p>further optional arguments, passed to
<code><a href="#topic+fitCopula">fitCopula</a>()</code>, notably <code>optim.method</code>, the
<code>method</code> for <code><a href="stats.html#topic+optim">optim</a>()</code>.  In <span class="pkg">copula</span> versions
<code>0.999-14</code> and earlier, the default for that was
<code>"Nelder-Mead"</code>, but now is the same as for <code>fitCopula()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details can be found in the second reference.
</p>
<p>The former argument <code>print.every</code> is deprecated and not
supported anymore; use <code>verbose</code> instead.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p> value of the test statistic. </p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p> corresponding approximate p-value. </p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p> estimates of the parameters for the hypothesized
copula family. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>For a given degree of dependence, the most popular bivariate
extreme-value copulas are strikingly similar.
</p>


<h3>References</h3>

<p>Genest, C. and Segers, J. (2009). Rank-based inference for bivariate
extreme-value copulas. <em>Annals of Statistics</em> <b>37</b>, 2990&ndash;3022.
</p>
<p>Genest, C. Kojadinovic, I., G. Nešlehová, J., and
Yan, J. (2011). A goodness-of-fit test for bivariate extreme-value copulas.
<em>Bernoulli</em> <b>17</b>(1), 253&ndash;275.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+evCopula">evCopula</a></code>, <code><a href="#topic+evTestC">evTestC</a></code>, <code><a href="#topic+evTestA">evTestA</a></code>,
<code><a href="#topic+evTestK">evTestK</a></code>, <code><a href="#topic+gofCopula">gofCopula</a></code>, <code><a href="#topic+An">An</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100; N &lt;- 1000 # realistic (but too large currently for CRAN checks)
n &lt;-  60; N &lt;-  200 # (time (and tree !) saving ...)
x &lt;- rCopula(n, claytonCopula(3))


## Does the Gumbel family seem to be a good choice?
gofEVCopula(gumbelCopula(), x, N=N)


## The same with different (and cheaper) estimation methods:
gofEVCopula(gumbelCopula(), x, N=N, method="itau")
gofEVCopula(gumbelCopula(), x, N=N, method="irho")


## The same with different extreme-value copulas
gofEVCopula(galambosCopula(), x, N=N)
gofEVCopula(galambosCopula(), x, N=N, method="itau")
gofEVCopula(galambosCopula(), x, N=N, method="irho")

gofEVCopula(huslerReissCopula(), x, N=N)
gofEVCopula(huslerReissCopula(), x, N=N, method="itau")
gofEVCopula(huslerReissCopula(), x, N=N, method="irho")

gofEVCopula(tevCopula(df.fixed=TRUE), x, N=N)
gofEVCopula(tevCopula(df.fixed=TRUE), x, N=N, method="itau")
gofEVCopula(tevCopula(df.fixed=TRUE), x, N=N, method="irho")

</code></pre>

<hr>
<h2 id='gofOtherTstat'>Various Goodness-of-fit Test Statistics</h2><span id='topic+gofBTstat'></span>

<h3>Description</h3>

<p><code>gofBTstat()</code> computes supposedly Beta distributed test
statistics for checking uniformity of <code>u</code> on the unit sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gofBTstat(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gofOtherTstat_+3A_u">u</code></td>
<td>
<p><code class="reqn">(n,d)</code>-matrix of values whose rows supposedly follow a
uniform distribution on the unit sphere in <code class="reqn">\mathbf{R}^d</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">(n,d-1)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> where the <code class="reqn">(i,k)</code>th entry is
</p>
<p style="text-align: center;"><code class="reqn">B_{ik}=\frac{\sum_{j=1}^k u_{ij}^2}{\sum_{j=1}^d u_{ij}^2}.
  </code>
</p>



<h3>References</h3>

<p>Li, R.-Z., Fang, K.-T., and Zhu, L.-X. (1997).
Some Q-Q probability plots to test spherical and elliptical symmetry.
<em>Journal of Computational and Graphical Statistics</em> <b>6</b>(4), 435&ndash;450.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data on the unit sphere
n &lt;- 360
d &lt;- 5
set.seed(1)
x &lt;- matrix(rnorm(n*d), ncol=d)
U &lt;- x/sqrt(rowSums(x^2))

## compute the test statistics B_k, k in {1,..,d-1}
Bmat &lt;- gofBTstat(U)

## (graphically) check if Bmat[,k] follows a Beta(k/2, (d-k)/2) distribution
qqp &lt;- function(k, Bmat) {
    d &lt;- ncol(Bmat)+1L
    tit &lt;- substitute(plain("Beta")(.A.,.B.)~~ bold("Q-Q Plot"),
                      list(.A. = k/2, .B. = (d-k)/2))
    qqplot2(Bmat[,k], qF=function(p) qbeta(p, shape1=k/2, shape2=(d-k)/2),
            main.args=list(text=tit, side=3, cex=1.3, line=1.1, xpd=NA))
}
qqp(1, Bmat=Bmat) # k=1
qqp(3, Bmat=Bmat) # k=3
</code></pre>

<hr>
<h2 id='gofTstat'>Goodness-of-fit Test Statistics</h2><span id='topic+gofTstat'></span><span id='topic+gofT2stat'></span>

<h3>Description</h3>

<p><code>gofTstat()</code> computes various goodness-of-fit test statistics
typically used in <code><a href="#topic+gofCopula">gofCopula</a>(*, simulation = "pb")</code>.
<code>gofT2stat()</code> computes the two-sample goodness of fit test
statistic of Rémillard and Scaillet (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gofTstat(u, method = c("Sn", "SnB", "SnC", "AnChisq", "AnGamma"),
         useR = FALSE, ...)
gofT2stat(u1, u2, useR = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gofTstat_+3A_u">u</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix of values in <code class="reqn">[0,1]</code>,
supposedly independent uniform observations in the
hypercube, that is, <code class="reqn">U_i \sim U[0,1]^d</code>, i.i.d.,
for <code class="reqn">i \in \{1,\dots,n\}</code>.</p>
</td></tr>
<tr><td><code id="gofTstat_+3A_u1">u1</code>, <code id="gofTstat_+3A_u2">u2</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrices of copula samples
to be compare against. The two matrices must have an equal number
of columns <code class="reqn">d</code> but can differ in <code class="reqn">n</code> (number of rows).</p>
</td></tr>
<tr><td><code id="gofTstat_+3A_method">method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the
goodness-of-fit test statistic to be used, which has to be one (or a unique
abbreviation) of
</p>

<dl>
<dt><code>"Sn"</code></dt><dd><p>for computing the test statistic
<code class="reqn">S_n</code> from Genest,
Rémillard, Beaudoin (2009).</p>
</dd>
<dt><code>"SnB"</code></dt><dd><p>for computing the test statistic
<code class="reqn">S_n^{(B)}</code> from Genest,
Rémillard, Beaudoin (2009).</p>
</dd>
<dt><code>"SnC"</code></dt><dd><p>for computing the test statistic
<code class="reqn">S_n^{(C)}</code> from Genest et al. (2009).</p>
</dd>
<dt><code>"AnChisq"</code></dt><dd><p>Anderson-Darling test statistic for
computing (supposedly) <code class="reqn">\mathrm{U}[0,1]</code>-distributed
(under <code class="reqn">H_0</code>) random variates via the distribution function
of the chi-square distribution with <code class="reqn">d</code>
degrees of freedom. To be more precise, the Anderson-Darling
test statistc of the variates
</p>
<p style="text-align: center;"><code class="reqn">\chi_d^2\Bigl(\sum_{j=1}^d(\Phi^{-1}(u_{ij}))^2\Bigr)</code>
</p>

<p>is computed (via <code>ADGofTest::ad.test</code>), where
<code class="reqn">\Phi^{-1}</code> denotes the quantile function
of the standard normal distribution function,
<code class="reqn">\chi_d^2</code> denotes the distribution function
of the chi-square distribution with <code class="reqn">d</code> degrees of freedom,
and <code class="reqn">u_{ij}</code> is the <code class="reqn">j</code>th component in the <code class="reqn">i</code>th row
of <code>u</code>.</p>
</dd>
<dt><code>"AnGamma"</code></dt><dd><p>similar to <code>method="AnChisq"</code> but
based on the variates
</p>
<p style="text-align: center;"><code class="reqn">\Gamma_d\Bigl(\sum_{j=1}^d(-\log u_{ij})\Bigr),</code>
</p>

<p>where <code class="reqn">\Gamma_d</code> denotes the distribution
function of the gamma distribution with shape parameter <code class="reqn">d</code>
and shape parameter one	(being equal to an
Erlang(<code class="reqn">d</code>) distribution function).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="gofTstat_+3A_user">useR</code></td>
<td>
<p>logical indicating whether an <span class="rlang"><b>R</b></span> or C implementation is used.</p>
</td></tr>
<tr><td><code id="gofTstat_+3A_...">...</code></td>
<td>
<p>additional arguments passed for computing the different
test statistics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions should be used with care. The different test statistics
were implemented (partly) for different purposes and goodness-of-fit
tests and should be used only with knowledge about such tests (see the
references for more details).
</p>


<h3>Value</h3>

<p>The value of the test statistic, a <code><a href="base.html#topic+numeric">numeric</a></code>.
</p>


<h3>References</h3>

<p>Genest, C., Rémillard, B., and Beaudoin, D. (2009),
Goodness-of-fit tests for copulas: A review and a power study
<em>Insurance: Mathematics and Economics</em> <b>44</b>, 199&ndash;213.
</p>
<p>Rosenblatt, M. (1952),
Remarks on a Multivariate Transformation,
<em>The Annals of Mathematical Statistics</em> <b>23</b>, 3, 470&ndash;472.
</p>
<p>Hering, C. and Hofert, M. (2014),
Goodness-of-fit tests for Archimedean copulas in high dimensions,
<em>Innovations in Quantitative Risk Management</em>.
</p>
<p>Hofert, M., Mächler, M., and McNeil, A. J. (2012).
Likelihood inference for Archimedean copulas in high dimensions
under known margins. <em>Journal of Multivariate Analysis</em>
<b>110</b>, 133&ndash;150.
</p>
<p>Rémillard, B. and Scaillet, O. (2009).
Testing for equality between two copulas.
<em>Journal of Multivariate Analysis</em>
<b>100</b>, 377&ndash;386.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gofCopula">gofCopula</a>()</code> for goodness-of-fit tests where (some of)
the test statistics of <code>gofTstat()</code> are used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate data
cop &lt;- archmCopula("Gumbel", param=iTau(gumbelCopula(), 0.5), dim=5)
set.seed(1)
U &lt;- rCopula(1000, cop)

## compute Sn (as is done in a parametric bootstrap, for example)
Uhat &lt;- pobs(U) # pseudo-observations
u &lt;- cCopula(Uhat, copula = cop) # Rosenblatt transformed data (with correct copula)
gofTstat(u, method = "Sn", copula = cop) # compute test statistic Sn; requires copula argument
</code></pre>

<hr>
<h2 id='htrafo'>GOF Testing Transformation of Hering and Hofert</h2><span id='topic+htrafo'></span>

<h3>Description</h3>

<p>The transformation described in Hering and Hofert
(2014), for Archimedean copulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htrafo(u, copula, include.K = TRUE, n.MC = 0, inverse = FALSE,
       method = eval(formals(qK)$method), u.grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="htrafo_+3A_u">u</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix with values in <code class="reqn">[0,1]</code>.  If
<code>inverse=FALSE</code> (the default), <code>u</code> contains
(pseudo-/copula-)observations from the copula <code>copula</code> based on
which the transformation is carried out; consider applying the
function <code><a href="#topic+pobs">pobs</a>()</code> first in order to obtain <code>u</code>.  If
<code>inverse=TRUE</code>, <code>u</code> contains <code class="reqn">U[0,1]^d</code> distributed
values which are transformed to copula-based (<code>copula</code>) ones.</p>
</td></tr>
<tr><td><code id="htrafo_+3A_copula">copula</code></td>
<td>
<p>an Archimedean copula specified as
<code>"<a href="#topic+outer_nacopula-class">outer_nacopula</a>"</code> or <code>"<a href="#topic+archmCopula-class">archmCopula</a>"</code>.</p>
</td></tr>
<tr><td><code id="htrafo_+3A_include.k">include.K</code></td>
<td>
<p>logical indicating whether the last component, involving the
Kendall distribution function <code><a href="#topic+K">K</a></code>, is used in <code>htrafo()</code>.</p>
</td></tr>
<tr><td><code id="htrafo_+3A_n.mc">n.MC</code></td>
<td>
<p>parameter <code>n.MC</code> for <code><a href="#topic+K">K</a></code>.</p>
</td></tr>
<tr><td><code id="htrafo_+3A_inverse">inverse</code></td>
<td>
<p>logical indicating whether the inverse of the
transformation is returned.</p>
</td></tr>
<tr><td><code id="htrafo_+3A_method">method</code></td>
<td>
<p>method to compute <code><a href="#topic+qK">qK</a>()</code>.</p>
</td></tr>
<tr><td><code id="htrafo_+3A_u.grid">u.grid</code></td>
<td>
<p>argument of <code><a href="#topic+qK">qK</a>()</code> (for <code>method="discrete"</code>).</p>
</td></tr>
<tr><td><code id="htrafo_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+qK">qK</a>()</code> if
<code>inverse = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code class="reqn">d</code>-dimensional random vector
<code class="reqn">\bm{U}</code> following an Archimedean copula <code class="reqn">C</code> with
generator <code class="reqn">\psi</code>, Hering and Hofert (2014) showed that
<code class="reqn">\bm{U}^\prime\sim\mathrm{U}[0,1]^d</code>, where
</p>
<p style="text-align: center;"><code class="reqn">U_{j}^\prime=\left(\frac{\sum_{k=1}^{j}\psi^{-1}(U_{k})}{
  	  \sum_{k=1}^{j+1}\psi^{-1}(U_{k})}\right)^{j},\ j\in\{1,\dots,d-1\},\
  	U_{d}^\prime=K(C(\bm{U})).</code>
</p>

<p><code>htrafo</code> applies this transformation row-wise to
<code>u</code> and thus returns either an <code class="reqn">n\times d</code>- or an
<code class="reqn">n\times (d-1)</code>-matrix, depending on whether the last
component <code class="reqn">U^\prime_d</code> which involves the (possibly
numerically challenging) Kendall distribution function <code class="reqn">K</code> is used
(<code>include.K=TRUE</code>) or not (<code>include.K=FALSE</code>).
</p>


<h3>Value</h3>

<p><code>htrafo()</code> returns an
<code class="reqn">n\times d</code>- or <code class="reqn">n\times (d-1)</code>-matrix
(depending on whether <code>include.K</code> is <code>TRUE</code> or
<code>FALSE</code>) containing the transformed input <code>u</code>.
</p>


<h3>References</h3>

<p>Hering, C. and Hofert, M. (2014).
Goodness-of-fit tests for Archimedean copulas in high dimensions.
<em>Innovations in Quantitative Risk Management</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sample and build pseudo-observations (what we normally have available)
## of a Clayton copula
tau &lt;- 0.5
theta &lt;- iTau(claytonCopula(), tau = tau)
d &lt;- 5
cc &lt;- claytonCopula(theta, dim = d)
set.seed(271)
n &lt;- 1000
U &lt;- rCopula(n, copula = cc)
X &lt;- qnorm(U) # X now follows a meta-Gumbel model with N(0,1) marginals
U &lt;- pobs(X) # build pseudo-observations

## Graphically check if the data comes from a meta-Clayton model
## with the transformation of Hering and Hofert (2014):
U.H &lt;- htrafo(U, copula = cc) # transform the data
splom2(U.H, cex = 0.2) # looks good

## The same for an 'outer_nacopula' object
cc. &lt;- onacopulaL("Clayton", list(theta, 1:d))
U.H. &lt;- htrafo(U, copula = cc.)
splom2(U.H., cex = 0.2) # looks good

## What about a meta-Gumbel model?
## The parameter is chosen such that Kendall's tau equals (the same) tau
gc &lt;- gumbelCopula(iTau(gumbelCopula(), tau = tau), dim = d)

## Plot of the transformed data (Hering and Hofert (2014)) to see the
## deviations from uniformity
U.H.. &lt;- htrafo(U, copula = gc)
splom2(U.H.., cex = 0.2) # deviations visible
</code></pre>

<hr>
<h2 id='indepCopula'>Construction of Independence Copula Objects</h2><span id='topic+indepCopula'></span>

<h3>Description</h3>

<p>Constructs an independence copula with its corresponding dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indepCopula(dim = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indepCopula_+3A_dim">dim</code></td>
<td>
<p>the dimension of the copula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An independence copula object of class <code>"<a href="#topic+indepCopula-class">indepCopula</a>"</code>.
</p>


<h3>See Also</h3>

<p>Mathematically, the independence copula is also a special
(boundary) case of e.g., classes <code>"<a href="#topic+archmCopula-class">archmCopula</a>"</code>,
<code>"<a href="#topic+ellipCopula-class">ellipCopula</a>"</code>, and <code>"<a href="#topic+evCopula-class">evCopula</a>"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>indep.cop &lt;- indepCopula(3)
x &lt;- rCopula(10, indep.cop)
dCopula(x, indep.cop)
persp(indepCopula(), pCopula)
</code></pre>

<hr>
<h2 id='indepCopula-class'>Class &quot;indepCopula&quot;</h2><span id='topic+indepCopula-class'></span>

<h3>Description</h3>

<p>Independence copula class.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("indepCopula", ...)</code>
or by function <code><a href="#topic+indepCopula">indepCopula</a>()</code>.  Such objects can be
useful as special cases of parametric copulas, bypassing
copula-specific computations such as distribution, density, and sampler.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dimension</code>:</dt><dd><p>Object of class <code>"numeric"</code>, dimension
of the copula.</p>
</dd>
<dt><code>exprdist</code>:</dt><dd><p>an <code><a href="base.html#topic+expression">expression</a></code> of length two,
for the &ldquo;formulas&rdquo; of the cdf and pdf of the copula.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>A</dt><dd><p><code>signature(copula = "indepCopula")</code>: ... </p>
</dd>
<dt>dCopula</dt><dd><p><code>signature(copula = "indepCopula")</code>: ... </p>
</dd>
<dt>pCopula</dt><dd><p><code>signature(copula = "indepCopula")</code>: ... </p>
</dd>
<dt>rCopula</dt><dd><p><code>signature(copula = "indepCopula")</code>: ... </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"indepCopula"</code> directly extends classes
<code>"<a href="#topic+dimCopula-class">dimCopula</a>"</code> and <code>"<a href="#topic+parCopula-class">parCopula</a>"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indepCopula">indepCopula</a></code>; documentation for classes
<code><a href="#topic+dimCopula-class">dimCopula</a></code> and
<code><a href="#topic+parCopula-class">parCopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getClass("indepCopula")
</code></pre>

<hr>
<h2 id='indepTest'>Test Independence of Continuous Random Variables via Empirical Copula</h2><span id='topic+indepTest'></span><span id='topic+indepTestSim'></span><span id='topic+dependogram'></span>

<h3>Description</h3>

<p>Multivariate independence test based on the empirical
copula process as proposed by Christian Genest and Bruno
Rémillard.  The test can be seen as composed of
three steps: (i) a simulation step, which consists of simulating the
distribution of the test statistics under independence for the sample
size under consideration; (ii) the test itself, which consists of
computing the approximate p-values of the test statistics with respect
to the empirical distributions obtained in step (i); and (iii) the
display of a graphic, called a <em>dependogram</em>, enabling to
understand the type of departure from independence, if any.  More
details can be found in the articles cited in the reference section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indepTestSim(n, p, m = p, N = 1000, verbose = interactive())
indepTest(x, d, alpha=0.05)
dependogram(test, pvalues = FALSE, print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indepTest_+3A_n">n</code></td>
<td>
<p> sample size when simulating the distribution of the test
statistics under independence.</p>
</td></tr>
<tr><td><code id="indepTest_+3A_p">p</code></td>
<td>
<p> dimension of the data when simulating the distribution of the test
statistics under independence.</p>
</td></tr>
<tr><td><code id="indepTest_+3A_m">m</code></td>
<td>
<p>maximum cardinality of the subsets of variables for which a
test statistic is to be computed.  It makes sense to consider <code class="reqn">m
      \ll p</code> especially when <code>p</code> is large.</p>
</td></tr>
<tr><td><code id="indepTest_+3A_n">N</code></td>
<td>
<p>number of repetitions when simulating under independence.</p>
</td></tr>
<tr><td><code id="indepTest_+3A_verbose">verbose</code></td>
<td>
<p>a logical specifying if progress
should be displayed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>.</p>
</td></tr>
<tr><td><code id="indepTest_+3A_x">x</code></td>
<td>
<p> data frame or data matrix containing realizations (one per
line) of the random vector whose independence is to be tested.</p>
</td></tr>
<tr><td><code id="indepTest_+3A_d">d</code></td>
<td>
<p> object of class <code>"indepTestDist"</code> as returned by
the function <code>indepTestSim()</code>.  It can be regarded as the
empirical distribution of the test statistics under independence.</p>
</td></tr>
<tr><td><code id="indepTest_+3A_alpha">alpha</code></td>
<td>
<p> significance level used in the computation of the
critical values for the test statistics.</p>
</td></tr>
<tr><td><code id="indepTest_+3A_test">test</code></td>
<td>
<p>object of class <code>"indepTest"</code> as returned by <code>indepTest()</code>.</p>
</td></tr>
<tr><td><code id="indepTest_+3A_pvalues">pvalues</code></td>
<td>
<p> logical indicating whether the dependogram should be
drew from test statistics or the corresponding p-values.</p>
</td></tr>
<tr><td><code id="indepTest_+3A_print">print</code></td>
<td>
<p> logical indicating whether details should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current (C code) implementation of <code>indepTestSim()</code>
uses (RAM) memory of size <code class="reqn">O(n^2 p)</code>, and time

<code class="reqn">O(N n^2 p)</code>.  This renders it unfeasible when
<code>n</code> is large.
</p>
<p>See the references below for more details, especially Genest
and Rémillard (2004).
</p>
<p>The former argument <code>print.every</code> is deprecated and not
supported anymore; use <code>verbose</code> instead.
</p>


<h3>Value</h3>

<p>The function <code>indepTestSim()</code> returns an object of class
<code>"indepTestDist"</code> whose attributes are: <code>sample.size</code>,
<code>data.dimension</code>, <code>max.card.subsets</code>,
<code>number.repetitons</code>, <code>subsets</code> (list of the subsets for
which test statistics have been computed), <code>subsets.binary</code>
(subsets in binary 'integer' notation),
<code>dist.statistics.independence</code> (a <code>N</code> line matrix containing
the values of the test statistics for each subset and each repetition)
and <code>dist.global.statistic.independence</code> (a vector a length
<code>N</code> containing the values of the global Cramér-von Mises test
statistic for each repetition &ndash; see Genest <em>et al</em> (2007), p.175).
</p>
<p>The function <code>indepTest()</code> returns an object of class
<code>"indepTest"</code> whose attributes are: <code>subsets</code>,
<code>statistics</code>, <code>critical.values</code>, <code>pvalues</code>,
<code>fisher.pvalue</code> (a p-value resulting from a combination <em>à la</em>
Fisher of the subset statistic p-values), <code>tippett.pvalue</code> (a p-value
resulting from a combination <em>à la</em> Tippett of the subset
statistic p-values),
<code>alpha</code> (global significance level of the test), <code>beta</code>
(1 - <code>beta</code> is the significance level per statistic),
<code>global.statistic</code> (value of the global Cramér-von Mises
statistic derived directly from the independence empirical copula
process - see Genest <em>et al</em> (2007), p.175) and
<code>global.statistic.pvalue</code> (corresponding p-value).
</p>


<h3>References</h3>


<p>Deheuvels, P. (1979).
La fonction de dépendance empirique et ses
propriétés: un test non paramétrique d'indépendance,
<em>Acad. Roy. Belg. Bull. Cl. Sci.</em>, 5th Ser. <b>65</b>, 274&ndash;292.
</p>
<p>Deheuvels, P. (1981)
A non parametric test for independence,
<em>Publ. Inst. Statist. Univ. Paris</em>. <b>26</b>, 29&ndash;50.
</p>
<p>Genest, C. and Rémillard, B. (2004)
Tests of independence and randomness based on the empirical copula process.
<em>Test</em> <b>13</b>, 335&ndash;369.
</p>
<p>Genest, C., Quessy, J.-F., and Rémillard, B. (2006).
Local efficiency of a Cramer-von Mises test of independence,
<em>Journal of Multivariate Analysis</em> <b>97</b>, 274&ndash;294.
</p>
<p>Genest, C., Quessy, J.-F., and Rémillard, B. (2007)
Asymptotic local efficiency of Cramér-von Mises tests for multivariate independence.
<em>The Annals of Statistics</em> <b>35</b>, 166&ndash;191.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serialIndepTest">serialIndepTest</a></code>,
<code><a href="#topic+multIndepTest">multIndepTest</a></code>,
<code><a href="#topic+multSerialIndepTest">multSerialIndepTest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Consider the following example taken from
## Genest and Remillard (2004), p 352:

set.seed(2004)
x &lt;- matrix(rnorm(500),100,5)
x[,1] &lt;- abs(x[,1]) * sign(x[,2] * x[,3])
x[,5] &lt;- x[,4]/2 + sqrt(3) * x[,5]/2

## In order to test for independence "within" x, the first step consists
## in simulating the distribution of the test statistics under
## independence for the same sample size and dimension,
## i.e. n=100 and p=5. As we are going to consider all the subsets of
## {1,...,5} whose cardinality is between 2 and 5, we set p=m=5.

## For a realistic N = 1000 (default), this takes a few seconds:
N. &lt;- if(copula:::doExtras()) 1000 else 120
N.
system.time(d &lt;- indepTestSim(100, 5, N = N.))
## For N=1000,  2 seconds (lynne 2015)
## You could save 'd' for future use, via  saveRDS()

## The next step consists of performing the test itself (and print its results):
(iTst &lt;- indepTest(x,d))

## Display the dependogram with the details:
dependogram(iTst, print=TRUE)

## We could have tested for a weaker form of independence, for instance,
## by only computing statistics for subsets whose cardinality is between 2
## and 3. Consider for instance the following data:
y &lt;- matrix(runif(500),100,5)
## and perform the test:
system.time( d &lt;- indepTestSim(100,5,3, N=N.) )
iTy &lt;- indepTest(y,d)
iTy
dependogram(iTy, print=TRUE)


</code></pre>

<hr>
<h2 id='initOpt'>Initial Interval or Value for Parameter Estimation of Archimedean
Copulas</h2><span id='topic+initOpt'></span>

<h3>Description</h3>

<p>Compute an initial interval or initial value for optimization/estimation
routines (only a heuristic; if this fails, choose your own interval or value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initOpt(family, tau.range=NULL, interval = TRUE, u,
        method = c("tau.Gumbel", "tau.mean"), warn = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initOpt_+3A_family">family</code></td>
<td>
<p>Archimedean family to find an initial interval for.</p>
</td></tr>
<tr><td><code id="initOpt_+3A_tau.range">tau.range</code></td>
<td>
<p>numeric vector containing lower and upper admissible
Kendall's tau, or <code>NULL</code> which choses family-specific defaults,
see the function definition.</p>
</td></tr>
<tr><td><code id="initOpt_+3A_interval">interval</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether an initial interval
(the default) or an initial value should be returned.</p>
</td></tr>
<tr><td><code id="initOpt_+3A_u">u</code></td>
<td>
<p>matrix of realizations following the copula family specified
by <code>family</code>.  Note that <code>u</code> can be omitted if
<code>interval=TRUE</code>.</p>
</td></tr>
<tr><td><code id="initOpt_+3A_method">method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the method to be
used to compute an estimate of Kendall's tau.  This has to be one (or a
unique abbreviation) of
</p>

<dl>
<dt><code>"tau.Gumbel"</code></dt><dd><p>an estimator based on the diagonal
maximum-likelihood estimator for Gumbel is used.</p>
</dd>
<dt><code>"tau.mean"</code></dt><dd><p>an estimator based on the mean of pairwise sample
versions of Kendall's tau is applied.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="initOpt_+3A_warn">warn</code></td>
<td>
<p>logical indicating if warnings are printed for
<code>method="tau.Gumbel"</code> when the diagonal maximum-likelihood
estimator is smaller than <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="initOpt_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>cor()</code> when
<code>method="tau.mean"</code>.  Note that otherwise (no additional arg.),
the much faster <code><a href="pcaPP.html#topic+cor.fk">cor.fk</a>()</code> from package
<a href="https://CRAN.R-project.org/package=pcaPP"><span class="pkg">pcaPP</span></a> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>method="tau.mean"</code> and <code>interval=FALSE</code>, the mean of pairwise
sample versions of Kendall's tau is computed as an estimator of the Kendall's
tau of the Archimedean copula family provided.  This can be slow, especially
if the dimension is large.  Method <code>method="tau.Gumbel"</code> (the default)
uses the explicit and thus very fast diagonal maximum-likelihood estimator for
Gumbel's family to find initial values.  Given this estimator
<code class="reqn">\hat{\theta}^\mathrm{G}</code>, the corresponding Kendall's tau
is <code class="reqn">\tau^\mathrm{G}(\hat{\theta}^\mathrm{G})</code> where
<code class="reqn">\tau^\mathrm{G}(\theta)=(\theta-1)/\theta</code>
denotes Kendall's tau for Gumbel.  This provides an estimator of Kendall's tau
which is typically much faster to evaluate than, pairwise Kendall's taus.
Given the estimated &lsquo;amount of concordance&rsquo; based on Kendall's tau, one
can obtain an initial value for the provided family by applying
<code class="reqn">\tau^{-1}</code>, that is, the inverse of Kendall's tau of the
family for which the initial value is to be computed.  Note that if the
estimated Kendall's tau does not lie in the range of Kendall's tau as provided
by the bivariate vector <code>tau.range</code>, the point in <code>tau.range</code>
closest to the estimated Kendall's tau is chosen.
</p>
<p>The default (<code>interval=TRUE</code>) returns a reasonably large initial
interval; see the default of <code>tau.range</code> in the definition of
<code>initOpt</code> for the chosen values (in terms of Kendall's tau).  These
default values cover a large range of concordance.  If this interval is
(still) too small, one can adjust it by providing <code>tau.range</code>. If it is
too large, a &lsquo;distance to concordance&rsquo; can be used to determine
parameter values such that the corresponding Kendall's taus share a certain
distance to the initial value.  For more details, see Hofert et al. (2012).
Finally, let us note that for the case <code>interval=TRUE</code>, <code>u</code> is not
required.
</p>


<h3>Value</h3>

<p>initial interval which can be used for optimization (for example, for
<code><a href="#topic+emle">emle</a></code>).
</p>


<h3>References</h3>

<p>Hofert, M., Mächler, M., and McNeil, A. J. (2012).
Likelihood inference for Archimedean copulas in high dimensions
under known margins. <em>Journal of Multivariate Analysis</em>
<b>110</b>, 133&ndash;150.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+enacopula">enacopula</a></code>, <code><a href="#topic+emle">emle</a></code>, <code><a href="#topic+edmle">edmle</a></code>,
<code><a href="#topic+emde">emde</a></code>, and <code><a href="#topic+ebeta">ebeta</a></code> (where <code>initOpt</code> is
applied to find initial intervals).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Definition of the function:
initOpt

## Generate some data:
tau &lt;- 0.25
(theta &lt;- copGumbel@iTau(tau)) # 4/3
d &lt;- 20
(cop &lt;- onacopulaL("Gumbel", list(theta,1:d)))

set.seed(1)
n &lt;- 200
U &lt;- rnacopula(n, cop)

## Initial interval:
initOpt("Gumbel") # contains theta

## Initial values:
initOpt("Gumbel", interval=FALSE, u=U) # 1.3195
initOpt("Gumbel", interval=FALSE, u=U, method="tau.mean") # 1.2844
</code></pre>

<hr>
<h2 id='interval'>Construct Simple &quot;interval&quot; Object</h2><span id='topic+interval'></span>

<h3>Description</h3>

<p>Easy construction of an object of class <code><a href="#topic+interval-class">interval</a></code>,
using typical mathematical notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval(ch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval_+3A_ch">ch</code></td>
<td>
<p>a character string specifying the interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="#topic+interval-class">interval</a></code> object.
</p>


<h3>See Also</h3>

<p>the <code><a href="#topic+interval-class">interval</a></code> class documentation,
notably its reference to more sophisticated interval classes available
for <span class="rlang"><b>R</b></span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>interval("[0, 1)")

## Two ways to specify open interval borders:
identical(interval("]-1,1["),
          interval("(-1,1)"))

## infinite :
interval("[0, Inf)")

## arithmetic with scalars works:
4 + 2 * interval("[0, 1.5)") # -&gt;  [4, 7)

## str() to look at internals:
str( interval("[1.2, 7]") )
</code></pre>

<hr>
<h2 id='interval-class'>Class &quot;interval&quot; of Simple Intervals</h2><span id='topic+interval-class'></span><span id='topic+maybeInterval-class'></span><span id='topic+format+2Cinterval-method'></span><span id='topic+show+2Cinterval-method'></span><span id='topic++25in+25+2Cnumeric+2Cinterval-method'></span><span id='topic+Summary+2Cinterval-method'></span>

<h3>Description</h3>

<p>The S4 <code><a href="base.html#topic+class">class</a></code> <code>"interval"</code> is a simple class for numeric
intervals.
</p>
<p><code>"maybeInterval"</code> is a class union (see
<code><a href="methods.html#topic+setClassUnion">setClassUnion</a></code>) of <code>"interval"</code> and <code>"NULL"</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("interval", ...)</code>,
but typically they are built via <code><a href="#topic+interval">interval</a>()</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>numeric vector of length two, specifying the
interval ranges.</p>
</dd>
<dt><code>open</code>:</dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> vector of length two,
specifying if the interval is open or closed on the left and
right, respectively.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"interval"</code> extends <code>"<a href="methods.html#topic+numeric-class">numeric</a>"</code>, from
data part, and <code>"maybeInterval"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>&quot;%in%&quot;</dt><dd><p><code>signature(x = "numeric", table = "interval")</code>:
check if <code>x</code> is inside the interval, carefully differentiating
open and closed intervals.</p>
</dd>
<dt>format</dt><dd><p><code>signature(x = "interval")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "interval")</code>: ... </p>
</dd>
<dt>Summary</dt><dd><p><code>signature(x = "interval")</code>: Group methods,
notably <code><a href="base.html#topic+range">range</a>()</code>, <code><a href="base.html#topic+min">min</a>()</code>, etc.</p>
</dd>
</dl>



<h3>Note</h3>

<p>There are more sophisticated interval classes, functions and methods,
notably in package <a href="https://CRAN.R-project.org/package=intervals"><span class="pkg">intervals</span></a>.  We only use this as a simple
interface in order to specify our copula functions consistently.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interval">interval</a></code> constructs &quot;interval&quot; objects conveniently.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>-1:2 %in% interval("(0, Inf)")
## 0 is *not* inside
</code></pre>

<hr>
<h2 id='K'>Kendall Distribution Function for Archimedean Copulas</h2><span id='topic+Kn'></span><span id='topic+pK'></span><span id='topic+qK'></span><span id='topic+dK'></span><span id='topic+rK'></span><span id='topic+K'></span>

<h3>Description</h3>

<p>The <em>Kendall distribution</em> of an Archimedean
copula is defined by
</p>
<p style="text-align: center;"><code class="reqn">K(u) = P(C(U_1,U_2,\dots,U_d) \le u),</code>
</p>

<p>where <code class="reqn">u \in [0,1]</code>, and the <code class="reqn">d</code>-dimensional
<code class="reqn">(U_1,U_2,\dots,U_d)</code> is distributed according
to the copula <code class="reqn">C</code>.  Note that the random variable
<code class="reqn">C(U_1,U_2,\dots,U_d)</code> is known as
&ldquo;probability integral transform&rdquo;.  Its distribution function
<code class="reqn">K</code> is equal to the identity if <code class="reqn">d = 1</code>, but is non-trivial for
<code class="reqn">d \ge 2</code>.
</p>
<p><code>Kn()</code> computes the empirical Kendall distribution function,
<code>pK()</code> the distribution function (so <code class="reqn">K()</code> itself),
<code>qK()</code> the quantile function, <code>dK()</code> the density, and
<code>rK()</code> random number generation from <code class="reqn">K()</code> for an Archimedean
copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kn(u, x, method = c("GR", "GNZ")) # empirical Kendall distribution function
dK(u, copula, d, n.MC = 0, log.p = FALSE) # density
pK(u, copula, d, n.MC = 0, log.p = FALSE) # df
qK(p, copula, d, n.MC = 0, log.p = FALSE, # quantile function
   method = c("default", "simple", "sort", "discrete", "monoH.FC"),
   u.grid, xtraChecks = FALSE, ...)
rK(n, copula, d) # random number generation
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="K_+3A_u">u</code></td>
<td>
<p>evaluation point(s) (in <code class="reqn">[0,1]</code>).</p>
</td></tr>
<tr><td><code id="K_+3A_x">x</code></td>
<td>
<p>data (in the <code class="reqn">d</code>-dimensional space) based on which the
Kendall distribution function is estimated.</p>
</td></tr>
<tr><td><code id="K_+3A_copula">copula</code></td>
<td>
<p><code><a href="#topic+acopula-class">acopula</a></code> with specified parameter, or
(currently for <code>rK</code> only) a <code><a href="#topic+outer_nacopula-class">outer_nacopula</a></code>.</p>
</td></tr>
<tr><td><code id="K_+3A_d">d</code></td>
<td>
<p>dimension (not used when <code>copula</code> is an
<code><a href="#topic+outer_nacopula-class">outer_nacopula</a></code>).</p>
</td></tr>
<tr><td><code id="K_+3A_n.mc">n.MC</code></td>
<td>
<p><code><a href="base.html#topic+integer">integer</a></code>, if positive, a Monte Carlo approach
is applied with sample size equal to <code>n.MC</code> to evaluate the
generator derivatives involved; otherwise
(<code>n.MC = 0</code>) the exact formula is used based on the generator
derivatives as found by Hofert et al. (2012).</p>
</td></tr>
<tr><td><code id="K_+3A_log.p">log.p</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>; if <code>TRUE</code>, probabilities
<code class="reqn">p</code> are given as <code class="reqn">\log p</code>.</p>
</td></tr>
<tr><td><code id="K_+3A_p">p</code></td>
<td>
<p>probabilities or log-probabilities if <code>log.p</code> is true.</p>
</td></tr>
<tr><td><code id="K_+3A_method">method</code></td>
<td>
<p>for <code>qK()</code>, character string for the method how to
compute the quantile function of <code class="reqn">K</code>; available are:
</p>

<dl>
<dt>&quot;default&quot;</dt><dd><p>default method. Currently chooses
<code>method="monoH.FC"</code> with <code>u.grid = 0:128/128</code>. This
is fast but not too accurate (see example).</p>
</dd>
<dt>&quot;simple&quot;</dt><dd><p>straightforward root finding based on
<code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</dd>
<dt>&quot;sort&quot;</dt><dd><p>root finding based on <code><a href="stats.html#topic+uniroot">uniroot</a></code> but
first sorting <code>u</code>.</p>
</dd>
<dt>&quot;discrete&quot;</dt><dd><p>first, <code class="reqn">K</code> is evaluated at the given grid
points <code>u.grid</code> (which should contain 0 and 1). Based on these
probabilities, quantiles are computed with <code><a href="base.html#topic+findInterval">findInterval</a></code>.</p>
</dd>
<dt>&quot;monoH.FC&quot;</dt><dd><p>first, <code class="reqn">K</code> is evaluated at the given grid points
<code>u.grid</code>.  A monotone spline is then used to approximate <code class="reqn">K</code>.
Based on this approximation, quantiles are computed with
<code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</dd>
</dl>

<p>For <code>Kn()</code>, character string indicating the method according
to which the empirical Kendall distribution is computed; available are:
</p>

<dl>
<dt>&quot;GR&quot;</dt><dd><p>the default. Computed as in Genest and Rivest (1993,
Equations (4) and (5)).</p>
</dd>
<dt>&quot;GNZ&quot;</dt><dd><p>computed as in Genest et al. (2011, Equation (19) and
Lemma 1); this is guaranteed to satisfy that the estimator lies above
the diagonal at any point in [0,1).</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="K_+3A_u.grid">u.grid</code></td>
<td>
<p>(for <code>method="discrete"</code>:) The grid on which
<code class="reqn">K</code> is evaluated, a <code><a href="base.html#topic+numeric">numeric</a></code> vector.</p>
</td></tr>
<tr><td><code id="K_+3A_xtrachecks">xtraChecks</code></td>
<td>
<p><em>experimental</em> logical indicating if extra
checks should be done before calling <code><a href="stats.html#topic+uniroot">uniroot</a>()</code> in some cases.</p>
</td></tr>
<tr><td><code id="K_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="stats.html#topic+uniroot">uniroot</a></code> (for
<code>method="default"</code>, <code>method="simple"</code>, <code>method="sort"</code>, and
<code>method="monoH.FC"</code>) or <code><a href="base.html#topic+findInterval">findInterval</a></code> (for
<code>method="discrete"</code>), notably <code>tol</code>
(<code><a href="stats.html#topic+uniroot">uniroot</a></code>) for increased accuracy.</p>
</td></tr>
<tr><td><code id="K_+3A_n">n</code></td>
<td>
<p>sample size for <code>rK</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a completely monotone Archimedean generator <code class="reqn">\psi</code>,
</p>
<p style="text-align: center;"><code class="reqn">K(u)=\sum_{k=0}^{d-1}
    \frac{\psi^{(k)}(\psi^{-1}(u))}{k!} (-\psi^{-1}(u))^k,\ u\in[0,1];</code>
</p>

<p>see Barbe et al. (1996).  The corresponding density is
</p>
<p style="text-align: center;"><code class="reqn">\frac{(-1)^d\psi^{(d)}(\psi^{-1}(u))}{(d-1)!}
    (-(\psi^{-1})'(u))(\psi^{-1}(u))^{d-1}</code>
</p>



<h3>Value</h3>

<p>The empirical Kendall distribution function, density, distribution
function, quantile function and random number generator.
</p>


<h3>Note</h3>

<p>Currently, the <code>"default"</code> method of <code>qK()</code> is fast but
not very accurate, see the &lsquo;Examples&rsquo; for more accuracy (with
more CPU effort).
</p>


<h3>References</h3>

<p>Barbe, P., Genest, C., Ghoudi, K., and Rémillard, B. (1996),
On Kendall's Process,
<em>Journal of Multivariate Analysis</em> <b>58</b>, 197&ndash;229.
</p>
<p>Hofert, M., Mächler, M., and McNeil, A. J. (2012).
Likelihood inference for Archimedean copulas in high dimensions
under known margins. <em>Journal of Multivariate Analysis</em>
<b>110</b>, 133&ndash;150. <a href="https://doi.org/10.1016/j.jmva.2012.02.019">doi:10.1016/j.jmva.2012.02.019</a>
</p>
<p>Genest, C. and Rivest, L.-P. (1993). Statistical inference procedures
for bivariate Archimedean copulas.
<em>Journal of the American Statistical Association</em> <b>88</b>, 1034&ndash;1043.
</p>
<p>Genest, C., G. Nešlehová, J., and Ziegel, J. (2011).
Inference in multivariate Archimedean copula models. <em>TEST</em>
<b>20</b>, 223&ndash;256.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+htrafo">htrafo</a></code> or <code><a href="#topic+emde">emde</a></code> (where <code><a href="#topic+K">K</a></code> is used);
<code><a href="stats.html#topic+splinefun">splinefun</a>(*, "monoHC")</code> for that method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau &lt;- 0.5
(theta &lt;- copGumbel@iTau(tau)) # 2
d &lt;- 20
(cop &lt;- onacopulaL("Gumbel", list(theta,1:d)))

## Basic check of the empirical Kendall distribution function
set.seed(271)
n &lt;- 1000
U &lt;- rCopula(n, copula = cop)
X &lt;- qnorm(U)
K.sample &lt;- pCopula(U, copula = cop)
u &lt;- seq(0, 1, length.out = 256)
edfK &lt;- ecdf(K.sample)
plot(u, edfK(u), type = "l", ylim = 0:1,
     xlab = quote(italic(u)), ylab = quote(K[n](italic(u)))) # simulated
K.n &lt;- Kn(u, x = X)
lines(u, K.n, col = "royalblue3") # Kn
## Difference at 0
edfK(0) # edf of K at 0
K.n[1] # K_n(0); this is &gt; 0 since K.n is the edf of a discrete distribution
## =&gt; therefore, Kn(K.sample, x = X) is not uniform
plot(Kn(K.sample, x = X), ylim = 0:1)
## Note: Kn(0) -&gt; 0 for n -&gt; Inf

## Compute Kendall distribution function
u &lt;- seq(0,1, length.out = 255)
Ku    &lt;- pK(u, copula = cop@copula, d = d) # exact
Ku.MC &lt;- pK(u, copula = cop@copula, d = d, n.MC = 1000) # via Monte Carlo
stopifnot(all.equal(log(Ku),
		    pK(u, copula = cop@copula, d = d, log.p=TRUE)))# rel.err 3.2e-16

## Build sample from K
set.seed(1)
n &lt;- 200
W &lt;- rK(n, copula = cop)

## Plot empirical distribution function based on W
## and the corresponding theoretical Kendall distribution function
## (exact and via Monte Carlo)
plot(ecdf(W), col = "blue", xlim = 0:1, verticals=TRUE,
     main = quote("Empirical"~ F[n](C(U)) ~
                     "and its Kendall distribution" ~ K(u)),
     do.points = FALSE, asp = 1)
abline(0,1, lty = 2); abline(h = 0:1, v = 0:1, lty = 3, col = "gray")
lines(u, Ku.MC, col = "red") # not quite monotone
lines(u, Ku, col = "black")  # strictly  monotone:
stopifnot(diff(Ku) &gt;= 0)
legend(.25, .75, expression(F[n], K[MC](u), K(u)),
       col=c("blue" , "red", "black"), lty = 1, lwd = 1.5, bty = "n")

if(require("Rmpfr")) { # pK() now also works with high precision numbers:
 uM &lt;- mpfr(0:255, 99)/256
 if(FALSE) {
   # not yet, now fails in  polyG() :
   KuM &lt;- pK(uM, copula = cop@copula, d = d)
  ##  debug(copula:::.pK)
  debug(copula:::polyG)
 }
}# if( Rmpfr )


## Testing qK
pexpr &lt;- quote( 0:63/63 );  p &lt;- eval(pexpr)
d &lt;- 10
cop &lt;- onacopulaL("Gumbel", list(theta = 2, 1:d))
system.time(qK0 &lt;- qK(p, copula = cop@copula, d = d)) # "default" - fast


system.time(qK1  &lt;- qK(p, copula= cop@copula, d=d, method = "simple"))
system.time(qK1. &lt;- qK(p, copula= cop@copula, d=d, method = "simple", tol = 1e-12))
system.time(qK2  &lt;- qK(p, copula= cop@copula, d=d, method = "sort"))
system.time(qK2. &lt;- qK(p, copula= cop@copula, d=d, method = "sort",   tol = 1e-12))
system.time(qK3  &lt;- qK(p, copula= cop@copula, d=d, method = "discrete", u.grid = 0:1e4/1e4))
system.time(qK4  &lt;- qK(p, copula= cop@copula, d=d, method = "monoH.FC",
                       u.grid = 0:5e2/5e2))
system.time(qK4. &lt;- qK(p, copula= cop@copula, d=d, method = "monoH.FC",
                       u.grid = 0:5e2/5e2, tol = 1e-12))
system.time(qK5  &lt;- qK(p, copula= cop@copula, d=d, method = "monoH.FC",
                       u.grid = 0:5e3/5e3))
system.time(qK5. &lt;- qK(p, copula= cop@copula, d=d, method = "monoH.FC",
                       u.grid = 0:5e3/5e3, tol = 1e-12))
system.time(qK6  &lt;- qK(p, copula= cop@copula, d=d, method = "monoH.FC",
                       u.grid = (0:5e3/5e3)^2))
system.time(qK6. &lt;- qK(p, copula= cop@copula, d=d, method = "monoH.FC",
                       u.grid = (0:5e3/5e3)^2, tol = 1e-12))

## Visually they all coincide :
cols &lt;- adjustcolor(c("gray50", "gray80", "light blue",
                      "royal blue", "purple3", "purple4", "purple"), 0.6)
matplot(p, cbind(qK0, qK1, qK2, qK3, qK4, qK5, qK6), type = "l", lwd = 2*7:1, lty = 1:7, col = cols,
        xlab = bquote(p == .(pexpr)), ylab = quote({K^{-1}}(u)),
        main = "qK(p, method = *)")
legend("topleft", col = cols, lwd = 2*7:1, lty = 1:7, bty = "n", inset = .03,
       legend= paste0("method= ",
             sQuote(c("default", "simple", "sort",
                      "discrete(1e4)", "monoH.FC(500)", "monoH.FC(5e3)", "monoH.FC(*^2)"))))

## See they *are* inverses  (but only approximately!):
eqInv &lt;- function(qK) all.equal(p, pK(qK, cop@copula, d=d), tol=0)

eqInv(qK0 ) # "default"	       0.03  worst
eqInv(qK1 ) # "simple"	       0.0011 - best
eqInv(qK1.) # "simple", e-12   0.00000 (8.73 e-13) !
eqInv(qK2 ) # "sort"	       0.0013 (close)
eqInv(qK2.) # "sort", e-12     0.00000 (7.32 e-12)
eqInv(qK3 ) # "discrete"       0.0026
eqInv(qK4 ) # "monoH.FC(500)"  0.0095
eqInv(qK4.) # "m.H.FC(5c)e-12" 0.00963
eqInv(qK5 ) # "monoH.FC(5e3)"  0.001148
eqInv(qK5.) # "m.H.FC(5k)e-12" 0.000989
eqInv(qK6 ) # "monoH.FC(*^2)"  0.001111
eqInv(qK6.) # "m.H.FC(*^2)e-12"0.00000 (1.190 e-09)

## and ensure the differences are not too large
stopifnot(
 all.equal(qK0, qK1, tol = 1e-2) # !
 ,
 all.equal(qK1, qK2, tol = 1e-4)
 ,
 all.equal(qK2, qK3, tol = 1e-3)
 ,
 all.equal(qK3, qK4, tol = 1e-3)
 ,
 all.equal(qK4, qK0, tol = 1e-2) # !
)


stopifnot(all.equal(p, pK(qK0, cop@copula, d=d), tol = 0.04))
</code></pre>

<hr>
<h2 id='khoudrajiCopula'>Construction of copulas using Khoudraji's device</h2><span id='topic+khoudrajiCopula'></span><span id='topic+asymCopula'></span><span id='topic+asymExplicitCopula'></span>

<h3>Description</h3>

<p>Creates an object representing a copula constructed using
<em>Khoudraji's device</em> (Khoudraji, 1995). The resulting <span class="rlang"><b>R</b></span> object
is either of class <code>"<a href="#topic+khoudrajiBivCopula-class">khoudrajiBivCopula</a>"</code>,
<code>"<a href="#topic+khoudrajiExplicitCopula-class">khoudrajiExplicitCopula</a>"</code>
or <code>"<a href="#topic+khoudrajiCopula-class">khoudrajiCopula</a>"</code>.
</p>
<p>In the bivariate case, given two copulas <code class="reqn">C_1</code> and <code class="reqn">C_2</code>,
Khoudraji's device consists of defining a copula whose c.d.f. is given
by:
</p>
<p style="text-align: center;"><code class="reqn">C_1(u_1^{1 - a_1}, u_2^{1 - a_2}) C_2(u_1^{a_1}, u_2^{a_2})</code>
</p>

<p>where <code class="reqn">a_1</code> and <code class="reqn">a_2</code> are <em>shape parameters</em> in [0,1].
</p>
<p>The construction principle (see also Genest et al. 1998) is a special
case of that considered in Liebscher (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>khoudrajiCopula(copula1 = indepCopula(), copula2 = indepCopula(dim = d),
                shapes = rep(NA_real_, dim(copula1)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="khoudrajiCopula_+3A_copula1">copula1</code>, <code id="khoudrajiCopula_+3A_copula2">copula2</code></td>
<td>
<p>each a <code><a href="#topic+copula-class">copula</a></code> (possibly
generalized, e.g., also a <code>"<a href="#topic+rotCopula-class">rotCopula</a>"</code>) of the
same dimension <code class="reqn">d</code>.  By default independence copulas, where
<code>copula2</code> gets the dimension from <code>copula1</code>.</p>
</td></tr>
<tr><td><code id="khoudrajiCopula_+3A_shapes">shapes</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code> vector of length <code class="reqn">d</code>,
with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the argument copulas are bivariate, an object of class
<code>"<a href="#topic+khoudrajiBivCopula-class">khoudrajiBivCopula</a>"</code> will be constructed.  If
they are exchangeable and <code class="reqn">d</code>-dimensional with <code class="reqn">d &gt; 2</code>, and if
they have explicit p.d.f. and c.d.f. expressions, an object of class
<code>"<a href="#topic+khoudrajiExplicitCopula-class">khoudrajiExplicitCopula</a>"</code> will be
constructed.  For the latter two classes, density evaluation is implemented,
and fitting and goodness-of-fit testing can be attempted. If <code class="reqn">d &gt;
  2</code> but one of the argument copulas does not have explicit p.d.f. and
c.d.f. expressions, or is not exchangeable, an object of class
<code>"<a href="#topic+khoudrajiCopula-class">khoudrajiCopula</a>"</code> will be constructed, for which
density evaluation is not possible.
</p>


<h3>Value</h3>

<p>A new object of class <code>"<a href="#topic+khoudrajiBivCopula-class">khoudrajiBivCopula</a>"</code> in
dimension two or of class
<code>"<a href="#topic+khoudrajiExplicitCopula-class">khoudrajiExplicitCopula</a>"</code> or
<code>"<a href="#topic+khoudrajiCopula-class">khoudrajiCopula</a>"</code> when <code class="reqn">d &gt; 2</code>.
</p>


<h3>References</h3>

<p>Genest, C., Ghoudi, K., and Rivest, L.-P. (1998), Discussion of
&quot;Understanding relationships using copulas&quot;, by Frees, E., and
Valdez, E., <em>North American Actuarial Journal</em> <b>3</b>,
143&ndash;149.
</p>
<p>Khoudraji, A. (1995), Contributions à l'étude des copules et
àla modélisation des valeurs extrêmes
bivariées, <em>PhD thesis, Université Laval</em>, Québec,
Canada.
</p>
<p>Liebscher, E. (2008), Construction of asymmetric multivariate copulas,
<em>Journal of Multivariate Analysis</em> <b>99</b>, 2234&ndash;2250.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A bivariate Khoudraji-Clayton copula
kc &lt;- khoudrajiCopula(copula2 = claytonCopula(6),
                      shapes = c(0.4, 0.95))
class(kc) # "kh..._Biv_Copula"
kc
contour(kc, dCopula, nlevels = 20, main = "dCopula(&lt;khoudrajiBivCopula&gt;)")

## A Khoudraji-Clayton copula with second shape parameter fixed
kcf &lt;- khoudrajiCopula(copula2 = claytonCopula(6),
                       shapes = fixParam(c(0.4, 0.95), c(FALSE, TRUE)))
kcf. &lt;- setTheta(kcf, c(3, 0.2)) # (change *free* param's only)
validObject(kcf) &amp; validObject(kcf.)

## A "nested" Khoudraji bivariate copula
kgkcf &lt;- khoudrajiCopula(copula1 = gumbelCopula(3),
                         copula2 = kcf,
                         shapes = c(0.7, 0.25))
kgkcf # -&gt; 6 parameters (1 of 6 is 'fixed')
contour(kgkcf, dCopula, nlevels = 20,
        main = "dCopula(&lt;khoudrajiBivC.(nested)&gt;)")

(Xtras &lt;- copula:::doExtras()) # determine whether examples will be extra (long)
n &lt;- if(Xtras) 300 else 64 # sample size (realistic vs short for example)

u &lt;- rCopula(n, kc)
plot(u)

## For likelihood (or fitting), specify the "free" (non-fixed) param's:
##           C1:  C2c C2s1    sh1  sh2
loglikCopula(c(3,   6, 0.4,   0.7, 0.25),
             u = u, copula = kgkcf)

## Fitting takes time (using numerical differentiation) and may be difficult:

## Starting values are required for all parameters
f.IC &lt;- fitCopula(khoudrajiCopula(copula2 = claytonCopula()),
                  start = c(1.1, 0.5, 0.5), data = pobs(u),
                  optim.method = "Nelder-Mead")
summary(f.IC)
confint(f.IC) # (only interesting for reasonable sample size)

## Because of time,  don't run these by default :

## Second shape parameter fixed to 0.95
kcf2 &lt;- khoudrajiCopula(copula2 = claytonCopula(),
                        shapes = fixParam(c(NA_real_, 0.95), c(FALSE, TRUE)))
system.time(
f.ICf &lt;- fitCopula(kcf2, start = c(1.1, 0.5), data = pobs(u),
                   optim.method = "Nelder-Mead")
) # ~ 7-8 sec
confint(f.ICf) # !
coef(f.ICf, SE=TRUE)

## With a different optimization method
system.time(
f.IC2 &lt;- fitCopula(kcf2, start = c(1.1, 0.5), data = pobs(u),
                   optim.method = "BFGS")
)
printCoefmat(coef(f.IC2, SE=TRUE), digits = 3) # w/o unuseful extra digits


if(Xtras &gt;= 2) { # really S..L..O..W... --------

## GOF example
optim.method &lt;- "Nelder-Mead" #try "BFGS" as well
gofCopula(kcf2, x = u, start = c(1.1, 0.5), optim.method = optim.method)
gofCopula(kcf2, x = u, start = c(1.1, 0.5), optim.method = optim.method,
          sim = "mult")
## The goodness-of-fit tests should hold their level
## but this would need to be tested

## Another example under the alternative
u &lt;- rCopula(n, gumbelCopula(4))
gofCopula(kcf2, x = u, start = c(1.1, 0.5), optim.method = optim.method)
gofCopula(kcf2, x = u, start = c(1.1, 0.5), optim.method = optim.method,
          sim = "mult")

}## ------ end { really slow gofC*() } --------

## Higher-dimensional constructions

## A three dimensional Khoudraji-Clayton copula
kcd3 &lt;- khoudrajiCopula(copula1 = indepCopula(dim=3),
                        copula2 = claytonCopula(6, dim=3),
                        shapes = c(0.4, 0.95, 0.95))

n &lt;- if(Xtras) 1000 else 100 # sample size (realistic vs short for example)
u &lt;- rCopula(n, kcd3)
splom2(u)
v &lt;- matrix(runif(15), 5, 3)
dCopula(v, kcd3)

## A four dimensional Khoudraji-Normal copula
knd4 &lt;- khoudrajiCopula(copula1 = indepCopula(dim=4),
                        copula2 = normalCopula(.9, dim=4),
                        shapes = c(0.4, 0.95, 0.95, 0.95))
knd4
stopifnot(class(knd4) == "khoudrajiCopula")
u &lt;- rCopula(n, knd4)
splom2(u)
## TODO :
## dCopula(v, knd4) ## not implemented

</code></pre>

<hr>
<h2 id='khoudrajiCopula-class'>Class <code>"khoudrajiCopula"</code> and its Subclasses</h2><span id='topic+asymCopula-class'></span><span id='topic+asym2Copula-class'></span><span id='topic+khoudrajiCopula-class'></span><span id='topic+khoudrajiBivCopula-class'></span><span id='topic+khoudrajiExplicitCopula-class'></span><span id='topic+dim+2CkhoudrajiCopula-method'></span>

<h3>Description</h3>

<p>The <em>virtual</em> class <code>"asymCopula"</code> of (conceptually) all
asymmetric copulas and its &lsquo;subclass&rsquo; <code>"asym2copula"</code> of
those which are constructed from two copulas.
</p>
<p>More specifically, the class <code>"khoudrajiCopula"</code> and its two
subclasses <code>"khoudrajiBivCopula"</code> and <code>"khoudrajiExplicitCopula"</code>
represent copulas constructed using Khoudraji's device from two copulas of
the same dimension; see <code><a href="#topic+khoudrajiCopula">khoudrajiCopula</a>()</code> for more details.
</p>


<h3>Objects from the Class</h3>

<p>Objects are typically created via <code><a href="#topic+khoudrajiCopula">khoudrajiCopula</a>(...)</code>.
</p>


<h3>Slots</h3>

<p>As these classes extend <code>"<a href="#topic+copula-class">copula</a>"</code>, they have all
its slots: <code>dimension</code>, <code>parameters</code>, <code>param.names</code>,
<code>param.lowbnd</code>, <code>param.upbnd</code>, and <code>fullname</code>.
The classes <code>"khoudrajiCopula"</code> and <code>"khoudrajiBivCopula"</code>
have the extra slots
</p>

<dl>
<dt><code>copula1</code>:</dt><dd><p>object of class <code>"<a href="#topic+copula-class">copula</a>"</code>.</p>
</dd>
<dt><code>copula2</code>:</dt><dd><p>second object of class  <code>"<a href="#topic+copula-class">copula</a>"</code>.</p>
</dd>
</dl>

<p>In addition to these, the class <code>"khoudrajiExplicitCopula"</code> has the slots
</p>

<dl>
<dt><code>exprdist</code>:</dt><dd><p>an <code><a href="base.html#topic+expression">expression</a></code>, ...</p>
</dd>
<dt><code>derExprs1</code>:</dt><dd><p>an <code><a href="base.html#topic+expression">expression</a></code> of length <code class="reqn">d</code>, ...</p>
</dd>
<dt><code>derExprs2</code>:</dt><dd><p>an <code><a href="base.html#topic+expression">expression</a></code> of length <code class="reqn">d</code>, ...</p>
</dd>
</dl>



<h3>Methods</h3>

<p>When possible, methods are defined at the <code>"khoudrajiCopula"</code>
class level.  The implementation of method <code><a href="#topic+dCopula">dCopula</a></code> for
instance is however not possible at that level.  In addition, it
differs for <code>"khoudrajiBivCopula"</code> and
<code>"khoudrajiExplicitCopula"</code> classes.
</p>


<h3>References</h3>

<p>Genest, C., Ghoudi, K., and Rivest, L.-P. (1998), Discussion of
&quot;Understanding relationships using copulas&quot;, by Frees, E., and
Valdez, E., <em>North American Actuarial Journal</em> <b>3</b>,
143&ndash;149.
</p>
<p>Khoudraji, A. (1995), Contributions à l'étude des copules et
àla modélisation des valeurs extrêmes
bivariées, <em>PhD thesis, Université Laval</em>, Québec,
Canada.
</p>
<p>Liebscher, E. (2008), Construction of asymmetric multivariate copulas,
<em>Journal of Multivariate Analysis</em> <b>99</b>, 2234&ndash;2250.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+khoudrajiCopula">khoudrajiCopula</a>()</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("khoudrajiCopula")# two subclasses

## all methods applicable to these subclasses:
(meths &lt;- sapply(names(getClass("khoudrajiCopula")@subclasses),
                 function(CL) methods(class = CL),
                 simplify=FALSE))
</code></pre>

<hr>
<h2 id='log1mexp'>Compute  f(a) = <code class="reqn">\mathrm{log}</code>(1 +/- <code class="reqn">\mathrm{exp}</code>(-a))
Numerically Optimally</h2><span id='topic+log1pexp'></span><span id='topic+log1mexp'></span>

<h3>Description</h3>

<p>Compute f(a) = log(1 - exp(-a)), respectively
g(x) = log(1 + exp(x))  quickly numerically accurately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log1mexp(a, cutoff = log(2))
log1pexp(x, c0 = -37, c1 = 18, c2 = 33.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log1mexp_+3A_a">a</code></td>
<td>
<p>numeric vector of positive values</p>
</td></tr>
<tr><td><code id="log1mexp_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="log1mexp_+3A_cutoff">cutoff</code></td>
<td>
<p>positive number; <code>log(2)</code> is &ldquo;optimal&rdquo;,

but the exact value is unimportant, and anything in
<code class="reqn">[0.5, 1]</code> is fine.</p>
</td></tr>
<tr><td><code id="log1mexp_+3A_c0">c0</code>, <code id="log1mexp_+3A_c1">c1</code>, <code id="log1mexp_+3A_c2">c2</code></td>
<td>
<p>cutoffs for <code>log1pexp</code>; see below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>f(a) == log(1 - exp(-a)) == log1p(-exp(-a)) ==
log(-expm1(-a))
</p>
<p>or
</p>
<p>g(x) == log(1 + exp(x)) == log1p(exp(x))
</p>
<p>computed accurately and quickly
</p>


<h3>References</h3>


<p>Martin Mächler (2012).
Accurately Computing <code class="reqn">\log(1-\exp(-|a|))</code>;
<a href="https://CRAN.R-project.org/package=Rmpfr/vignettes/log1mexp-note.pdf">https://CRAN.R-project.org/package=Rmpfr/vignettes/log1mexp-note.pdf</a>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 2^seq(-58,10, length = 256)
fExpr &lt;- expression(
          log(1 - exp(-a)),
          log(-expm1(-a)),
          log1p(-exp(-a)),
          log1mexp(a))
names(fExpr) &lt;- c("DEF", "expm1", "log1p", "F")
str(fa &lt;- do.call(cbind, as.list(fExpr)))
head(fa)# expm1() works here
tail(fa)# log1p() works here

## graphically:
lwd &lt;- 1.5*(5:2); col &lt;- adjustcolor(1:4, 0.4)
op &lt;- par(mfcol=c(1,2), mgp = c(1.25, .6, 0), mar = .1+c(3,2,1,1))
  matplot(a, fa, type = "l", log = "x", col=col, lwd=lwd)
  legend("topleft", fExpr, col=col, lwd=lwd, lty=1:4, bty="n")
  # expm1() &amp; log1mexp() work here

  matplot(a, -fa, type = "l", log = "xy", col=col, lwd=lwd)
  legend("left", paste("-",fExpr), col=col, lwd=lwd, lty=1:4, bty="n")
  # log1p() &amp; log1mexp() work here
par(op)

curve(log1pexp, -10, 10, asp=1)
abline(0,1, h=0,v=0, lty=3, col="gray")

## Cutoff c1 for log1pexp() -- not often "needed":
curve(log1p(exp(x)) - log1pexp(x), 16, 20, n=2049)
## need for *some* cutoff:
x &lt;- seq(700, 720, by=2)
cbind(x, log1p(exp(x)), log1pexp(x))

## Cutoff c2 for log1pexp():
curve((x+exp(-x)) - x, 20, 40, n=1025)
curve((x+exp(-x)) - x, 33.1, 33.5, n=1025)
</code></pre>

<hr>
<h2 id='loss'>LOSS and ALAE Insurance Data</h2><span id='topic+loss'></span>

<h3>Description</h3>

<p>Indemnity payment and allocated loss adjustment expense from an insurance
company.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(loss, package="copula")</code></pre>


<h3>Format</h3>

<p>A data frame with 1500 observations of the following 4 variables:
</p>

<dl>
<dt><code>loss</code></dt><dd><p>a numeric vector of loss amount up to the <code>limit</code>.</p>
</dd>
<dt><code>alae</code></dt><dd><p>a numeric vector of the corresponding allocated loss
adjustment expense.</p>
</dd>
<dt><code>limit</code></dt><dd><p>a numeric vector of limit (-99 means no limit).</p>
</dd>
<dt><code>censored</code></dt><dd><p>1 means censored (limit reached) and 0 otherwise.</p>
</dd>
</dl>



<h3>References</h3>

<p>Frees, E. and Valdez, E. (1998). Understanding relationships using
copulas. <em>North American Actuarial Journal</em> <b>2</b>, 1&ndash;25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(loss)
</code></pre>

<hr>
<h2 id='margCopula'>Marginal copula of a Copula With Specified Margins</h2><span id='topic+margCopula'></span><span id='topic+margCopula+2CarchmCopula+2Clogical-method'></span><span id='topic+margCopula+2CnormalCopula+2Clogical-method'></span><span id='topic+margCopula+2CtCopula+2Clogical-method'></span>

<h3>Description</h3>

<p>The marginal copula of a copula <code class="reqn">C(u_1,\dots, u_d)</code> is simply the
restriction of <code class="reqn">C</code> on a subset of the the coordinate (directions) <code class="reqn">u_1,\dots,u_d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margCopula(copula, keep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margCopula_+3A_copula">copula</code></td>
<td>
<p>a <code>"<a href="#topic+copula-class">copula</a>"</code> (<span class="rlang"><b>R</b></span> object) of
dimension, <code class="reqn">d</code>, say.</p>
</td></tr>
<tr><td><code id="margCopula_+3A_keep">keep</code></td>
<td>
<p>logical vector (of length <code>d</code>) indicating which margins to keep.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The marginal copula of a copula is needed in practical data analysis when
one or more of the components of some multivariate observations is
missing.  For normal/t/Archimedean copulas, the marginal copulas can be
easily obtained.  For a general copula, this may not be an easy problem.
</p>
<p>The current implementation only supports normal/t/Archimedean
copulas.  <code>margCopula</code> is generic function with methods for the
different copula classes.
</p>


<h3>Value</h3>

<p>The marginal copula of the specified margin(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tc &lt;- tCopula(8:2 / 10, dim = 8, dispstr = "toep")
margCopula(tc, c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE))

nc &lt;- normalCopula(.8, dim = 8, dispstr = "ar1")
mnc &lt;- margCopula(nc, c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE))
mnc7 &lt;- margCopula(nc, (1:8) != 1)
stopifnot(dim(nc) == 8, dim(mnc) == 4, dim(mnc7) == 7)

gc &lt;- gumbelCopula(2, dim = 8)
margCopula(gc, c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE))
</code></pre>

<hr>
<h2 id='math-fun'>Sinc, Zolotarev's, and Other Mathematical Utility Functions</h2><span id='topic+A..Z'></span><span id='topic+sinc'></span>

<h3>Description</h3>

<p><code>sinc(x)</code> computes the <em>sinc function</em>
<code class="reqn">s(x)=\sin(x)/x</code> for <code class="reqn">x\ne 0</code> and
<code class="reqn">s(0) = 1</code>, such that <code class="reqn">s()</code> is continuous, also at <code class="reqn">x = 0</code>.
</p>
<p><code>A..Z(x, a)</code> computes Zolotarev's function to
the power <code>1-a</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinc(x)
A..Z(x, alpha, I.alpha = 1 - alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="math-fun_+3A_x">x</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code> argument in <code class="reqn">[0,\pi]</code>,
typically a vector.</p>
</td></tr>
<tr><td><code id="math-fun_+3A_alpha">alpha</code></td>
<td>
<p>parameter in (0,1].</p>
</td></tr>
<tr><td><code id="math-fun_+3A_i.alpha">I.alpha</code></td>
<td>
<p>must be <code> = 1 - alpha</code>, maybe more accurately
when <code>alpha</code> is very close to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details about Zolotarev's function, see, for example, Devroye (2009).
</p>


<h3>Value</h3>

<p><code>A..Z(x,alpha)</code> is <code class="reqn">\tilde A_{Z}(x,\alpha)</code>,
defined as
</p>
<p style="text-align: center;"><code class="reqn">\frac{\sin(\alpha x)^\alpha\sin((1-\alpha)x)^{1-\alpha}}{\sin(x)},\
    x\in[0,\pi],</code>
</p>

<p>where <code class="reqn">\alpha\in(0,1]</code> is <code>alpha</code>.
</p>


<h3>References</h3>

<p>Devroye, L. (2009)
Random variate generation for exponentially and polynomially tilted
stable distributions,
<em>ACM Transactions on Modeling and Computer Simulation</em> <b>19</b>,
18, 1&ndash;20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+retstable">retstable</a></code> internally makes use of these functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(sinc, -15,25); abline(h=0,v=0, lty=2)
curve(A..Z(x, 0.25), xlim = c(-4,4),
      main = "Zolotarev's function A(x) ^ 1-alpha")
</code></pre>

<hr>
<h2 id='matrix_tools'>Tools to Work with Matrices</h2><span id='topic+p2P'></span><span id='topic+P2p'></span><span id='topic+getSigma'></span><span id='topic+extremePairs'></span>

<h3>Description</h3>

<p><code>p2P()</code> creates a <code><a href="base.html#topic+matrix">matrix</a></code> from a given
<code><a href="base.html#topic+vector">vector</a></code> of parameters.  <code>P2p()</code> creates a
numeric vector from a given <code><a href="base.html#topic+matrix">matrix</a></code>,
currently useful for elliptical copulas.
</p>
<p><code>getSigma()</code> returns the <code class="reqn">d \times d</code> symmetric
matrix <code class="reqn">\Sigma</code> which is called &ldquo;Rho&rdquo; as well, written
(capital Greek <code class="reqn">\rho</code> !) as <code class="reqn">P</code> (and hence sometimes
erronously pronounced &quot;Pee&quot;).
Note that <code>getSigma()</code> works for all elliptical copulas and uses
<code>p2P()</code> for the &ldquo;unstuctured&rdquo; case, <code>dispstr = "un"</code>.
</p>
<p><code>extremePairs()</code> identifies pairs with the largest (or smallest
or both) entries in a symmetric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2P(param, d = floor(1 + sqrt(2*length(param))))
P2p(P)
getSigma(copula)
extremePairs(x, n = 6, method = c("largest", "smallest", "both"),
             use.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_tools_+3A_param">param</code></td>
<td>
<p>a parameter vector.</p>
</td></tr>
<tr><td><code id="matrix_tools_+3A_d">d</code></td>
<td>
<p>dimension of the resulting <code><a href="base.html#topic+matrix">matrix</a></code>.  The default
is correct under the assumption (of <code>p2P()</code> in general!) that
<code>param</code> is the lower-triangular part of a correlation matrix
<code>P</code> and hence corresponds to <code><a href="#topic+ellipCopula">ellipCopula</a>(.., dispstr
      = "un")</code>.</p>
</td></tr>
<tr><td><code id="matrix_tools_+3A_p">P</code></td>
<td>
<p>a <code><a href="base.html#topic+matrix">matrix</a></code> which should be converted to a vector.</p>
</td></tr>
<tr><td><code id="matrix_tools_+3A_copula">copula</code></td>
<td>
<p>an <b>elliptical</b> copula, i.e., an object (extending)
class <code><a href="#topic+ellipCopula-class">ellipCopula</a></code>; typically resulting from
<code><a href="#topic+tCopula">tCopula</a>()</code> or <code><a href="#topic+normalCopula">normalCopula</a>()</code>.</p>
</td></tr>
<tr><td><code id="matrix_tools_+3A_x">x</code></td>
<td>
<p>a symmetric <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="matrix_tools_+3A_n">n</code></td>
<td>
<p>the number of pairs with smallest (or largest) values to be
displayed.</p>
</td></tr>
<tr><td><code id="matrix_tools_+3A_method">method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string indicating the method
to be used (with <code>"largest"</code> to comute the <code>n</code> pairs with
largest entries in <code>x</code> (sorted in decreasing order); with
<code>"smallest"</code> to compute the <code>n</code> pairs with smallest entries
in <code>x</code> (sorted in increasing order); and with <code>"both"</code> to
comute the 2<code>n</code> pairs with <code>n</code> largest entries and
<code>n</code> smallest entries (sorted in decreasing order)).</p>
</td></tr>
<tr><td><code id="matrix_tools_+3A_use.names">use.names</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether
<code>colnames(x)</code> are used as labels (if <code>!is.null(colnames(x))</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These auxiliary functions are often used when working with
elliptical copulas.
</p>


<h3>Value</h3>


<dl>
<dt><code>p2P</code>:</dt><dd><p>a symmetric <code><a href="base.html#topic+matrix">matrix</a></code> with ones on the
diagonal and the values of <code>param</code> filled column-wise below the
diagonal (which corresponds to row-wise filling above the diagonal).</p>
</dd>
<dt><code>P2p</code>:</dt><dd><p><code><a href="base.html#topic+vector">vector</a></code> of column-wise below-diagonal
entries of <code>P</code> (equal to the row-wise above-diagonal entries in
case of a symmetric matrix).</p>
</dd>
<dt><code>getSigma</code>:</dt><dd><p><code><a href="base.html#topic+matrix">matrix</a></code> as from <code>p2P()</code>
for all cases of elliptical copulas.</p>
</dd>
<dt><code>extremePairs</code>:</dt><dd><p>a <code><a href="base.html#topic+data.frame">data.frame</a></code>
consisting of three columns (<code>row</code> (index or name), <code>col</code> (index or name),
<code>value</code>).</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+ellipCopula">ellipCopula</a></code>, <code><a href="#topic+tCopula">tCopula</a></code>, <code><a href="#topic+normalCopula">normalCopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## display the two simple definitions:
p2P
P2p

param &lt;- (2:7)/10
tC &lt;- tCopula(param, dim = 4, dispstr = "un", df = 3)
## consistency of the three functions :
P &lt;- p2P(param) # (using the default 'd')
stopifnot(identical(param, P2p(P)),
	  identical(P, getSigma(tC)))

## Toeplitz case:
(tCt &lt;- tCopula((2:6)/10, dim = 6, disp = "toep"))
(rhoP &lt;- tCt@getRho(tCt))
stopifnot(identical(getSigma (tCt),
		    toeplitz (c(1, rhoP))))

## "AR1" case:
nC.7 &lt;- normalCopula(0.8, dim = 7, dispstr = "ar1")
(Sar1.7 &lt;- getSigma(nC.7))
0.8^(0:(7-1)) #  1  0.8  0.64  0.512 ..
stopifnot(all.equal(Sar1.7, toeplitz(0.8^(0:(7-1)))))
</code></pre>

<hr>
<h2 id='mixCopula'>Create Mixture of Copulas</h2><span id='topic+mixCopula'></span>

<h3>Description</h3>

<p>A mixture of <code class="reqn">m</code> copulas of dimension <code class="reqn">d</code> with weights
<code class="reqn">w_j</code>, <code class="reqn">j=1,2,\ldots,m</code> is itself a <code class="reqn">d</code>-dimensional copula,
with cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">C(x) = \sum_{j=1}^m w_j C_j(x),</code>
</p>

<p>and (probability) density function
</p>
<p style="text-align: center;"><code class="reqn">c(x) = \sum_{j=1}^m w_j c_j(x),</code>
</p>

<p>where <code class="reqn">C_j</code> are the CDFs and <code class="reqn">c_j</code> are the
densities of the <code class="reqn">m</code> component copulas,
<code class="reqn">j=1,2,\ldots,m</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixCopula(coplist, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixCopula_+3A_coplist">coplist</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> of length <code class="reqn">m (\ge 1)</code> copulas (each inheriting from <code><a href="#topic+parCopula-class">parCopula</a></code>), all
of the same dimension.</p>
</td></tr>
<tr><td><code id="mixCopula_+3A_w">w</code></td>
<td>
<p>numeric vector of length <code class="reqn">m</code> of non-negative mixture
weights, or <code>NULL</code>, which means equal weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It easy to see that the tail dependencies <code><a href="#topic+lambda">lambda</a>()</code> and
Spearman's rank correlation <code><a href="#topic+rho">rho</a>()</code> can be computed as
mixture of the individual measures.
</p>


<h3>Value</h3>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code><a href="#topic+mixCopula-class">mixCopula</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+khoudrajiCopula">khoudrajiCopula</a></code>, <code><a href="#topic+rotCopula">rotCopula</a></code> also create new
copula models from existing ones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mC &lt;- mixCopula(list(gumbelCopula(2.5, dim=3),
                     claytonCopula(pi, dim=3),
                     tCopula(0.7, dim=3)),
                c(2,2,4)/8)
mC
stopifnot(dim(mC) == 3)

set.seed(17)
uM &lt;- rCopula(600, mC)
splom2(uM, main = "mixCopula( (gumbel, clayton, t-Cop) )")
d.uM &lt;- dCopula(uM, mC)
p.uM &lt;- pCopula(uM, mC)

## mix a Gumbel with a rotated Gumbel (with equal weights 1/2):
mGG &lt;- mixCopula(list(gumbelCopula(2), rotCopula(gumbelCopula(1.5))))
rho(mGG)   # 0.57886
lambda(mGG)# both lower and upper tail dependency

loglikCopula(c(2.5, pi, rho.1=0.7, df = 4, w = c(2,2,4)/8),
                    u = uM, copula = mC)
## define (profiled) log-likelihood function of two arguments (df, rho) :
ll.df &lt;- Vectorize(function(df, rho)
                   loglikCopula(c(2.5, pi, rho.1=rho, df=df, w = c(2,2,4)/8),
                                uM, mC))
(df. &lt;- 1/rev(seq(1/8, 1/2, length=21)))# in [2, 8] equidistant in 1/. scale

ll. &lt;- ll.df(df., rho = (rh1 &lt;- 0.7))
plot(df., ll., type = "b", main = "loglikCopula((.,.,rho = 0.7, df, ..), u, &lt;mixCopula&gt;)")

if(!exists("Xtras")) Xtras &lt;- copula:::doExtras() ; cat("Xtras: ", Xtras,"\n")
if (Xtras) withAutoprint({
  Rhos &lt;- seq(0.55, 0.70, by = 0.01)
  ll.m &lt;- matrix(NA, nrow=length(df.), ncol=length(Rhos))
  for(k in seq_along(Rhos)) ll.m[,k] &lt;- ll.df(df., rho = Rhos[k])
  tit &lt;- "loglikelihood(&lt;tCop&gt;, true param. for rest)"
  persp         (df., Rhos, ll.m, phi=30, theta = 50, ticktype="detailed", main = tit)
  filled.contour(df., Rhos, ll.m, xlab="df", ylab = "rho", main = tit)
})

## fitCopula() example -----------------------------------------------------

## 1) with "fixed" weights :

(mNt &lt;- mixCopula(list(normalCopula(0.95), tCopula(-0.7)), w = c(1, 2) / 3))
set.seed(1452) ; U &lt;- pobs(rCopula(1000, mNt))
(m1 &lt;- mixCopula(list(normalCopula(), tCopula()), w = mNt@w))

getTheta(m1, freeOnly = TRUE, attr = TRUE)
getTheta(m1, named=TRUE)
isFree(m1) # all of them; --&gt; now fix the weights :
fixedParam(m1) &lt;- fx &lt;- c(FALSE, FALSE, FALSE, TRUE, TRUE)
stopifnot(identical(isFree(m1), !fx))

if(Xtras) withAutoprint({ ## time
  system.time( # ~ 16 sec (nb-mm4) :
    fit &lt;- fitCopula(m1, start = c(0, 0, 10), data = U)
  )
  fit
  summary(fit) #-&gt; incl  'Std.Error' (which seems small for rho1 !)
})

## 2) with "free" weights (possible since copula 1.0-0):

(mNt2 &lt;- mixCopula(list(normalCopula(0.9), tCopula(-0.8)), w = c(1, 3) / 4))
set.seed(1959) ; U2 &lt;- pobs(rCopula(2000, mNt2))
if(Xtras) withAutoprint({ ## time
  m2 &lt;- mixCopula(list(normalCopula(), tCopula()), w = mNt@w)
  system.time( # ~ 13.5 sec (lynne) :
    f2 &lt;- fitCopula(m2, start = c(0, 0, 10, c(1/2, 1/2)), data = U2)
  )
  f2
  summary(f2) # NA for 'Std. Error' as did *not* estimate.variance
  summary(f2, orig=FALSE) # default 'orig=TRUE': w-scale;  whereas
     coef(f2, orig=FALSE) # 'orig=FALSE' =&gt; shows 'l-scale' instead
})


</code></pre>

<hr>
<h2 id='mixCopula-class'>Class <code>"mixCopula"</code> of Copula Mixtures</h2><span id='topic+mixCopula-class'></span><span id='topic+dim+2CmixCopula-method'></span><span id='topic+lambda+2CmixCopula-method'></span><span id='topic+rho+2CmixCopula-method'></span>

<h3>Description</h3>

<p>The class <code>"mixCopula"</code> is the class of all finite mixtures of
copulas.
</p>
<p>These are given by (a list of) <code class="reqn">m</code> &ldquo;arbitrary&rdquo; copulas, and
their respective <code class="reqn">m</code> non-negative probability weights.
</p>


<h3>Objects from the Class</h3>

<p>Objects are typically created by <code><a href="#topic+mixCopula">mixCopula</a>()</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>w</code>:</dt><dd><p>Object of class <code>"mixWeights"</code>, basically a
non-negative <code><a href="base.html#topic+numeric">numeric</a></code> vector of length, say <code class="reqn">m</code>,
which sums to one.</p>
</dd>
<dt><code>cops</code>:</dt><dd><p>Object of class <code>"parClist"</code>, a
<code><a href="base.html#topic+list">list</a></code> of (parametrized) copulas, <code>"<a href="#topic+parCopula-class">parCopula</a>"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+parCopula-class">parCopula</a>"</code>, directly.
Class <code>"<a href="#topic+Copula-class">Copula</a>"</code>, by class &quot;parCopula&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>dim</dt><dd><p><code>signature(x = "mixCopula")</code>: dimension of copula.</p>
</dd>
<dt>rho</dt><dd><p><code>signature(x = "mixCopula")</code>: Spearman's rho of
copula <code>x</code>.</p>
</dd>
<dt>lambda</dt><dd><p><code>signature(x = "mixCopula")</code>: lower and upper
tail dependecies <code><a href="#topic+lambda">lambda</a></code>, <code class="reqn">(\lambda[L],\lambda[U])</code>,
of the mixture copula.</p>
</dd>
</dl>



<h3>Note</h3>

<p>As the probability weights must some to one (<code>1</code>), which is part
of the validity (see <code><a href="methods.html#topic+validObject">validObject</a></code>) of an object of class
<code>"mixWeights"</code>, the number of &ldquo;free&rdquo; parameters inherently
is (at most) one <em>less</em> than the number of mixture components
<code class="reqn">m</code>.
</p>
<p>Because of that, it does not make sense to fix (see
<code><a href="#topic+fixParam">fixParam</a></code> or <code><a href="#topic+fixedParam+3C-">fixedParam&lt;-</a></code>)
all but one of the weights: Either all are fixed, or at least two must
be free.  Further note, that the definition of free or fixed
parameters, and the meaning of the methods (for <code>mixCopula</code>) of
<code><a href="#topic+getTheta">getTheta</a></code>, <code><a href="#topic+setTheta">setTheta</a></code> and
<code><a href="#topic+fixedParam+3C-">fixedParam&lt;-</a></code> will probably change in a next release of
package <span class="pkg">copula</span>, where it is planned to use a reparametrization
better suited for <code><a href="#topic+fitCopula">fitCopula</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixCopula">mixCopula</a></code> for creation and examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("mixCopula")
</code></pre>

<hr>
<h2 id='moCopula'>The Marshall-Olkin Copula</h2><span id='topic+moCopula'></span>

<h3>Description</h3>

<p>Computes Marshall-Olkin copulas in the bivariate case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moCopula(param = NA_real_, dim = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moCopula_+3A_param">param</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code> vector of length two specifying the
copula parameters (in <code class="reqn">[0,1]</code>).</p>
</td></tr>
<tr><td><code id="moCopula_+3A_dim">dim</code></td>
<td>
<p>the dimension of the copula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>moCopula()</code> is the constructor for objects of class
<code><a href="#topic+moCopula-class">moCopula</a></code>.
</p>


<h3>Note</h3>

<p>Marshall-Olkin copulas are only implemented for <code>dim = 2L</code>.
</p>


<h3>See Also</h3>

<p>The <code>"<a href="#topic+moCopula-class">moCopula</a>"</code> class, its mathematical
definition, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- c(0.2, 0.7)
MO &lt;- moCopula(alpha)
tau(MO) # 0.18
lambda(MO)
stopifnot(all.equal(lambda(MO),
                    c(lower = 0, upper = 0.2)))
wireframe2  (MO, FUN = pCopula) # if you look carefully, you can see the kink
contourplot2(MO, FUN = pCopula)
set.seed(271)
plot(rCopula(1000, MO))
</code></pre>

<hr>
<h2 id='moCopula-class'>Class &quot;moCopula&quot; of Marshall-Olkin Copulas</h2><span id='topic+moCopula-class'></span>

<h3>Description</h3>

<p>The Marshall-Olkin copula class.
</p>
<p>The (2-dimensional) &quot;MO&quot; copula with parameter
<code class="reqn">\bold\theta\in [0,1]^2</code> is (i.e., its CDF is)
</p>
<p style="text-align: center;"><code class="reqn">C(u_1, u_2) = min(u_1 * u_2^(1 - \theta_2), u_1^(1 - \theta_1) * u_2).%
  </code>
</p>

<p>Consequently, the density is undefined on a curve (in <code class="reqn">[0,1]^2</code>),
namely for the points <code class="reqn">\bold{u}=(u_1,u_2)</code> where two
expressions in the above <code class="reqn">min(f(u), g(u))</code> are equal,
<code class="reqn">f(u)=g(u)</code>.  It is easy to see that that is equivalent to


</p>
<p style="text-align: center;"><code class="reqn">u_1^{\theta_1} = u_2^{\theta_2}.</code>
</p>




<h3>Objects from the Class</h3>

<p>Objects can be created by <code>new("moCopula", ...)</code> but are
typically produced by <code><a href="#topic+moCopula">moCopula</a>(...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dimension</code>:</dt><dd><p>Numeric (scalar), the dimension of the copula.</p>
</dd>
<dt><code>exprdist</code>:</dt><dd><p>a length two <code><a href="base.html#topic+expression">expression</a></code> with
expressions for the CDF and PDF of the copula.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>numeric vector of two parameter values in <code class="reqn">[0,1]</code>.</p>
</dd>
<dt><code>param.names</code>:</dt><dd><p><code>"<a href="base.html#topic+character">character</a>"</code> vector of length two.</p>
</dd>
<dt><code>param.lowbnd</code>:</dt><dd><p>numeric vector of two values in <code class="reqn">[0,1]</code>.</p>
</dd>
<dt><code>param.upbnd</code>:</dt><dd><p>numeric vector of two values in <code class="reqn">[0,1]</code>.</p>
</dd>
<dt><code>fullname</code>:</dt><dd><p>(deprecated; do not use!)</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Typical copula methods work, see <code>"<a href="#topic+moCopula-class">moCopula</a>"</code>
and use <code>methods(class = "moCopula")</code>.
</p>


<h3>Extends</h3>

<p>Class <code>"moCopula"</code> extends class <code>"<a href="#topic+copula-class">copula</a>"</code> directly.
</p>


<h3>References</h3>

<p>Nelsen, R. B. (2006), <em>An introduction to Copulas</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moCopula">moCopula</a></code> for constructing them;
<code><a href="#topic+copula-class">copula-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>moCopula()@exprdist[["cdf"]] # a simple definition

methods(class = "moCopula")
contourplot2(moCopula(c(.1, .8)), pCopula, main= "moCopula((0.1, 0.8))")

Xmo &lt;- rCopula(5000, moCopula(c(.2, .5)))
try( # gives an error, as there is no density (!):
loglikCopula(c(.1, .2), Xmo, moCopula())
)

plot(moCopula(c(.9, .2)), n = 10000, xaxs="i", yaxs="i",
     # opaque color (for "density effect"):
     pch = 16, col = adjustcolor("black", 0.3))
</code></pre>

<hr>
<h2 id='multIndepTest'>Independence Test Among Continuous Random Vectors Based on the
Empirical Copula Process</h2><span id='topic+multIndepTest'></span>

<h3>Description</h3>

<p>Analog of the independence test based on the empirical copula process
proposed by Christian Genest and Bruno Rémillard (see
<code><a href="#topic+indepTest">indepTest</a></code>) for <em>random vectors</em>.  The main
difference comes from the fact that critical values and p-values are
obtained through the bootstrap/permutation methodology, since, here,
test statistics are not distribution-free.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multIndepTest(x, d, m = length(d), N = 1000, alpha = 0.05,
              verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multIndepTest_+3A_x">x</code></td>
<td>
<p> data frame (<code><a href="base.html#topic+data.frame">data.frame</a></code>) or  matrix containing
realizations (one per line) of the random vectors whose independence
is to be tested.</p>
</td></tr>
<tr><td><code id="multIndepTest_+3A_d">d</code></td>
<td>
<p> dimensions of the random vectors whose realizations are given
in <code>x</code>.  It is required that <code>sum(d) == ncol(x)</code>.</p>
</td></tr>
<tr><td><code id="multIndepTest_+3A_m">m</code></td>
<td>
<p> maximum cardinality of the subsets of random vectors for
which a test statistic is to be computed. It makes sense to consider
<code>m &lt;&lt; p</code> especially when <code>p</code> is large.</p>
</td></tr>
<tr><td><code id="multIndepTest_+3A_n">N</code></td>
<td>
<p> number of bootstrap/permutation samples.</p>
</td></tr>
<tr><td><code id="multIndepTest_+3A_alpha">alpha</code></td>
<td>
<p> significance level used in the computation of the
critical values for the test statistics.</p>
</td></tr>
<tr><td><code id="multIndepTest_+3A_verbose">verbose</code></td>
<td>
<p> a logical specifying if progress
should be displayed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the references below for more details, especially the last one.
</p>


<h3>Value</h3>

<p>The function <code>"multIndepTest"</code> returns an object of class
<code>"indepTest"</code> whose attributes are: <code>subsets</code>,
<code>statistics</code>, <code>critical.values</code>, <code>pvalues</code>,
<code>fisher.pvalue</code> (a p-value resulting from a combination <em>à la</em>
Fisher of the subset statistic p-values), <code>tippett.pvalue</code> (a p-value
resulting from a combination <em>à la</em> Tippett of the subset
statistic p-values), <code>alpha</code> (global significance level of the
test), <code>beta</code> (1 - <code>beta</code> is the significance level per
statistic), <code>global.statistic</code> (value of the global Cramér-von
Mises statistic derived directly from the independence empirical
copula process - see <code>In</code> in the last reference) and
<code>global.statistic.pvalue</code> (corresponding p-value).
</p>
<p>The former argument <code>print.every</code> is deprecated and not
supported anymore; use <code>verbose</code> instead.
</p>


<h3>References</h3>

<p>Deheuvels, P. (1979). La fonction de dépendance empirique et ses
propriétés: un test non paramétrique d'indépendance, <em>Acad. Roy.
Belg. Bull. Cl. Sci.</em>, 5th Ser. <b>65</b>, 274&ndash;292.
</p>
<p>Deheuvels, P. (1981), A non parametric test for independence,
<em>Publ. Inst. Statist. Univ. Paris</em>. <b>26</b>, 29&ndash;50.
</p>
<p>Genest, C. and Rémillard, B. (2004), Tests of independence and
randomness based on the empirical copula process. <em>Test</em>
<b>13</b>, 335&ndash;369.
</p>
<p>Genest, C., Quessy, J.-F., and Rémillard, B. (2006). Local
efficiency of a Cramer-von Mises test of independence,
<em>Journal of Multivariate Analysis</em> <b>97</b>, 274&ndash;294.
</p>
<p>Genest, C., Quessy, J.-F., and Rémillard, B. (2007), Asymptotic
local efficiency of Cramér-von Mises tests for multivariate
independence. <em>The Annals of Statistics</em> <b>35</b>, 166&ndash;191.
</p>
<p>Kojadinovic, I. and Holmes, M. (2009), Tests of independence among
continuous random vectors based on Cramér-von Mises functionals
of the empirical copula process. <em>Journal of Multivariate
Analysis</em> <b>100</b>, 1137&ndash;1154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indepTest">indepTest</a></code>,
<code><a href="#topic+serialIndepTest">serialIndepTest</a></code>,
<code><a href="#topic+multSerialIndepTest">multSerialIndepTest</a></code>,
<code><a href="#topic+dependogram">dependogram</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Consider the following example taken from
## Kojadinovic and Holmes (2008):

n &lt;- 100

## Generate data
y &lt;- matrix(rnorm(6*n),n,6)
y[,1] &lt;- y[,2]/2 + sqrt(3)/2*y[,1]
y[,3] &lt;- y[,4]/2 + sqrt(3)/2*y[,3]
y[,5] &lt;- y[,6]/2 + sqrt(3)/2*y[,5]

nc &lt;- normalCopula(0.3,dim=3)
x &lt;- cbind(y,rCopula(n, nc),rCopula(n, nc))

x[,1] &lt;- abs(x[,1]) * sign(x[,3] * x[,5])
x[,2] &lt;- abs(x[,2]) * sign(x[,3] * x[,5])
x[,7] &lt;- x[,7] + x[,10]
x[,8] &lt;- x[,8] + x[,11]
x[,9] &lt;- x[,9] + x[,12]

## Dimensions of the random vectors
d &lt;- c(2,2,2,3,3)

## Run the test
test &lt;- multIndepTest(x,d)
test

## Display the dependogram
dependogram(test,print=TRUE)
</code></pre>

<hr>
<h2 id='multSerialIndepTest'>Serial Independence Test for Multivariate Time Series via Empirical Copula</h2><span id='topic+multSerialIndepTest'></span>

<h3>Description</h3>

<p>Analog of the serial independence test based on the empirical
copula process proposed by Christian Genest and Bruno Rémillard (see
<code><a href="#topic+serialIndepTest">serialIndepTest</a></code>) for <em>multivariate</em> time
series.  The main difference comes from the fact that critical values
and p-values are obtained through the bootstrap/permutation
methodology, since, here, test statistics are not distribution-free.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multSerialIndepTest(x, lag.max, m = lag.max+1, N = 1000, alpha = 0.05,
                    verbose = interactive())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multSerialIndepTest_+3A_x">x</code></td>
<td>
<p>data frame or matrix of multivariate continuous time series
whose serial independence is to be tested.</p>
</td></tr>
<tr><td><code id="multSerialIndepTest_+3A_lag.max">lag.max</code></td>
<td>
<p> maximum lag.</p>
</td></tr>
<tr><td><code id="multSerialIndepTest_+3A_m">m</code></td>
<td>
<p> maximum cardinality of the subsets of 'lags' for
which a test statistic is to be computed.  It makes sense to consider
<code>m &lt;&lt; lag.max+1</code> especially when <code>lag.max</code> is large.</p>
</td></tr>
<tr><td><code id="multSerialIndepTest_+3A_n">N</code></td>
<td>
<p> number of bootstrap/permutation samples.</p>
</td></tr>
<tr><td><code id="multSerialIndepTest_+3A_alpha">alpha</code></td>
<td>
<p> significance level used in the computation of the
critical values for the test statistics.</p>
</td></tr>
<tr><td><code id="multSerialIndepTest_+3A_verbose">verbose</code></td>
<td>
<p> a logical specifying if progress
should be displayed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the references below for more details, especially the last
one.
</p>
<p>The former argument <code>print.every</code> is deprecated and not
supported anymore; use <code>verbose</code> instead.
</p>


<h3>Value</h3>

<p>The function <code>"multSerialIndepTest"</code> returns an object of class
<code>"indepTest"</code> whose attributes are: <code>subsets</code>,
<code>statistics</code>, <code>critical.values</code>, <code>pvalues</code>,
<code>fisher.pvalue</code> (a p-value resulting from a combination <em>à la</em>
Fisher of the subset statistic p-values), <code>tippett.pvalue</code> (a p-value
resulting from a combination <em>à la</em> Tippett of the subset
statistic p-values), <code>alpha</code> (global significance level of the
test), <code>beta</code> (1 - <code>beta</code> is the significance level per statistic),
<code>global.statistic</code> (value of the global Cramér-von Mises
statistic derived directly from
the independence empirical copula process - see <code>In</code> in the last
reference) and <code>global.statistic.pvalue</code> (corresponding p-value).
</p>


<h3>References</h3>

<p>Deheuvels, P. (1979)  La fonction de dépendance empirique et ses
propriétés: un test non paramétrique d'indépendance.
<em>Acad. Roy. Belg. Bull. Cl. Sci.</em>, 5th Ser. <b>65</b>, 274&ndash;292.
</p>
<p>Deheuvels, P. (1981)  A non parametric test for independence.
<em>Publ. Inst. Statist. Univ. Paris</em> <b>26</b>, 29&ndash;50.
</p>
<p>Genest, C. and Rémillard, B. (2004)
Tests of independence and randomness based on the empirical copula
process.
<em>Test</em> <b>13</b>, 335&ndash;369.
</p>
<p>Ghoudi, K., Kulperger, R., and Rémillard, B. (2001)
A nonparametric test of serial independence for times series and residuals.
<em>Journal of Multivariate Analysis</em> <b>79</b>, 191&ndash;218.
</p>
<p>Kojadinovic, I. and Yan, J. (2011)
Tests of multivariate serial independence based on a Möbius
decomposition of the independence empirical copula process.
<em>Annals of the Institute of Statistical Mathematics</em> <b>63</b>, 347&ndash;373.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serialIndepTest">serialIndepTest</a></code>,
<code><a href="#topic+indepTest">indepTest</a></code>,
<code><a href="#topic+multIndepTest">multIndepTest</a></code>,
<code><a href="#topic+dependogram">dependogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A multivariate time series {minimal example for demo purposes}
d &lt;- 2
n &lt;- 100 # sample size *and* "burn-in" size
param &lt;- 0.25
A &lt;- matrix(param,d,d) # the bivariate AR(1)-matrix
set.seed(17)
ar &lt;- matrix(rnorm(2*n * d), 2*n,d) # used as innovations
for (i in 2:(2*n))
  ar[i,] &lt;- A %*% ar[i-1,] + ar[i,]
## drop burn-in :
x &lt;- ar[(n+1):(2*n),]

## Run the test
test &lt;- multSerialIndepTest(x,3)
test

## Display the dependogram
dependogram(test,print=TRUE)
</code></pre>

<hr>
<h2 id='Mvdc'>Multivariate Distributions Constructed from Copulas</h2><span id='topic+Mvdc'></span><span id='topic+mvdc'></span><span id='topic+dMvdc'></span><span id='topic+pMvdc'></span><span id='topic+rMvdc'></span><span id='topic+dmvdc'></span><span id='topic+pmvdc'></span><span id='topic+rmvdc'></span>

<h3>Description</h3>

<p>Density, distribution function, and random generator for a
multivariate distribution via copula and <em>parametric</em> margins.
</p>
<p>For likelihood and fitting these distributions to data, see
<code><a href="#topic+fitMvdc">fitMvdc</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvdc(copula, margins, paramMargins, marginsIdentical = FALSE,
     check = TRUE, fixupNames = TRUE)
dMvdc(x, mvdc, log=FALSE)
pMvdc(x, mvdc)
rMvdc(n, mvdc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mvdc_+3A_copula">copula</code></td>
<td>
<p>an object of <code>"<a href="#topic+copula-class">copula</a>"</code>. </p>
</td></tr>
<tr><td><code id="Mvdc_+3A_margins">margins</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> vector specifying all the
parametric marginal distributions.  See details below.</p>
</td></tr>
<tr><td><code id="Mvdc_+3A_parammargins">paramMargins</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> whose each component is a
list (or numeric vectors) of named components, giving the parameter
values of the marginal distributions.  See details below.</p>
</td></tr>
<tr><td><code id="Mvdc_+3A_marginsidentical">marginsIdentical</code></td>
<td>
<p> logical variable restricting the marginal
distributions to be identical. </p>
</td></tr>
<tr><td><code id="Mvdc_+3A_check">check</code></td>
<td>
<p>logical indicating to apply quick checks about existence of
<code>margins</code> &ldquo;p*&rdquo; and &ldquo;d*&rdquo; functions.</p>
</td></tr>
<tr><td><code id="Mvdc_+3A_fixupnames">fixupNames</code></td>
<td>
<p>logical indicating if the parameters of the margins
should get automatic names (from <code><a href="base.html#topic+formals">formals</a>(p&lt;mar_i&gt;)</code>).</p>
</td></tr>
<tr><td><code id="Mvdc_+3A_mvdc">mvdc</code></td>
<td>
<p>a <code>"<a href="#topic+mvdc-class">mvdc</a>"</code> object. </p>
</td></tr>
<tr><td><code id="Mvdc_+3A_x">x</code></td>
<td>
<p>a numeric vector of length the copula dimension, say <code class="reqn">d</code>,
or a matrix with the number of columns being <code class="reqn">d</code>, giving the
coordinates of the points where the density or distribution function
needs to be evaluated.</p>
</td></tr>
<tr><td><code id="Mvdc_+3A_log">log</code></td>
<td>
<p>logical indicating if the <code><a href="base.html#topic+log">log</a></code> density should
be returned.</p>
</td></tr>
<tr><td><code id="Mvdc_+3A_n">n</code></td>
<td>
<p>number of observations to be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The characters in argument <code>margins</code> are used to construct
density, distribution, and quantile function names.  For
example, <code>norm</code> can be used to specify marginal distribution,
because <code><a href="stats.html#topic+dnorm">dnorm</a></code>, <code>pnorm</code>, and <code>qnorm</code> are all
available.
</p>
<p>A user-defined distribution, for example, <code>fancy</code>, can be used as
margin <em><b>provided</b></em> that <code>dfancy</code>, <code>pfancy</code>, and
<code>qfancy</code> are available.
</p>
<p>Each component list in argument <code>paramMargins</code> is a
<code><a href="base.html#topic+list">list</a></code> with named components which are used to specify the
parameters of the marginal distributions.  For example, the list
</p>
<pre>    paramMargins = list(list(mean = 0, sd = 2), list(rate = 2))</pre>
<p>can be used to specify that the first margin is normal with mean 0 and
standard deviation 2, and the second margin is exponential with rate 2.
</p>


<h3>Value</h3>

<p><code>mvdc()</code> constructs an object of class <code>"<a href="#topic+mvdc-class">mvdc</a>"</code>.
<code>dMvdc()</code> gives the density, <code>pMvdc()</code> gives the cumulative
distribution function, and <code>rMvdc()</code> generates random variates.
</p>


<h3>Note</h3>

<p><code>mvdc()</code>, <code><a href="#topic+fitMvdc">fitMvdc</a></code>, etc, are only for
<em>parametric</em> margins.
If you do not want to model all margins parametrically, use the
standard copula approach, transforming the data by their
empirical margins via <code><a href="#topic+pobs">pobs</a></code> and modelling the copula
alone, e.g., using <code><a href="#topic+fitCopula">fitCopula</a></code>, i.e., conceptually,
using </p>
<pre>     fitCopula(.., pobs(x))</pre>



<h3>See Also</h3>

<p><code><a href="#topic+ellipCopula">ellipCopula</a></code>,
<code><a href="#topic+archmCopula">archmCopula</a></code>;
the classes <code><a href="#topic+mvdc-class">mvdc</a></code> and <code><a href="#topic+copula-class">copula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## construct a bivariate distribution whose marginals
## are normal and exponential respectively, coupled
## together via a normal copula
mv.NE &lt;- mvdc(normalCopula(0.75), c("norm", "exp"),
              list(list(mean = 0, sd =2), list(rate = 2)))
dim(mv.NE)
mv.NE  # using its print() / show() method

persp  (mv.NE, dMvdc, xlim = c(-4, 4), ylim=c(0, 2), main = "dMvdc(mv.NE)")
persp  (mv.NE, pMvdc, xlim = c(-4, 4), ylim=c(0, 2), main = "pMvdc(mv.NE)")
contour(mv.NE, dMvdc, xlim = c(-4, 4), ylim=c(0, 2))

# Generate (bivariate) random numbers from that, and visualize
x.samp &lt;- rMvdc(250, mv.NE)
plot(x.samp)
summary(fx &lt;- dMvdc(x.samp, mv.NE))
summary(Fx &lt;- pMvdc(x.samp, mv.NE))
op &lt;- par(mfcol=c(1,2))
pp &lt;- persp(mv.NE, pMvdc, xlim = c(-5,5), ylim=c(0,2),
            main = "pMvdc(mv.NE)", ticktype="detail")
px &lt;- copula:::perspMvdc(x.samp, FUN = F.n, xlim = c(-5, 5), ylim = c(0, 2),
                         main = "F.n(x.samp)", ticktype="detail")
par(op)
all.equal(px, pp)# about 5% difference

</code></pre>

<hr>
<h2 id='mvdc-class'>Class &quot;mvdc&quot;: Multivariate Distributions from Copulas</h2><span id='topic+mvdc-class'></span><span id='topic+dim+2Cmvdc-method'></span><span id='topic+show+2Cmvdc-method'></span>

<h3>Description</h3>

<p><code>"mvdc"</code> is a <code><a href="base.html#topic+class">class</a></code> representing
<b>m</b>ulti<b>v</b>ariate <b>d</b>istributions constructed via
<b>c</b>opula and margins, using Sklar's theorem. </p>


<h3>Objects from the Class</h3>

<p>Objects are typically created by <code><a href="#topic+mvdc">mvdc</a>()</code>, or
can be created by calls of the form <code>new("mvdc", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>copula</code>:</dt><dd><p>Object of class <code>"<a href="#topic+copula-class">copula</a>"</code>,
specifying the copula.</p>
</dd>
<dt><code>margins</code>:</dt><dd><p>Object of class <code>"character"</code>,
specifying the marginal distributions. </p>
</dd>
<dt><code>paramMargins</code>:</dt><dd><p>Object of class <code>"list"</code>, whose
each component is a list of named components, giving the parameter
values of the marginal distributions. See <code><a href="#topic+mvdc">mvdc</a></code>. </p>
</dd>
<dt><code>marginsIdentical</code>:</dt><dd><p>Object of class <code>"logical"</code>,
that, if TRUE, restricts the marginal distributions to be
identical, default is <code>FALSE</code>. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>contour</dt><dd><p><code>signature(x = "mvdc")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "mvdc")</code>: the dimension of the
distribution; this is the same as <code>dim(x@copula)</code>.</p>
</dd>
<dt>persp</dt><dd><p><code>signature(x = "mvdc")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "mvdc")</code>: quite compactly display
the content of the &quot;mvdc&quot; <code>object</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+mvdc">mvdc</a></code>, 
also for examples; for fitting, <code><a href="#topic+fitMvdc">fitMvdc</a></code>.
</p>

<hr>
<h2 id='nacFrail.time'>Timing for Sampling Frailties of Nested Archimedean Copulas</h2><span id='topic+nacFrail.time'></span>

<h3>Description</h3>

<p>This function provides measurements of user run times for the frailty
variables involved in a nested Archimedean copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nacFrail.time(n, family, taus, digits = 3, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nacFrail.time_+3A_n">n</code></td>
<td>
<p>integer specifying the sample size to be used for the random
variates <code class="reqn">V_0</code> and <code class="reqn">V_{01}</code>.</p>
</td></tr>
<tr><td><code id="nacFrail.time_+3A_family">family</code></td>
<td>
<p>the Archimedean family (class
<code>"<a href="#topic+acopula-class">acopula</a>"</code>) for which <code class="reqn">V_0</code> and
<code class="reqn">V_{01}</code> are sampled.</p>
</td></tr>
<tr><td><code id="nacFrail.time_+3A_taus">taus</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code> vector of Kendall's taus.  This vector is
converted to a vector of copula parameters <code class="reqn">\theta</code>, which then serve as
<code class="reqn">\theta_0</code> and <code class="reqn">\theta_1</code> for a three-dimensional
fully nested Archimedean copula of the specified <code>family</code>.  First, for
each <code class="reqn">\theta_0</code>, <code>n</code> random variates <code class="reqn">V_0</code> are
generated.  Then, given the particular <code class="reqn">\theta_0</code> and the
realizations <code class="reqn">V_0</code>, <code>n</code> random variates
<code class="reqn">V_{01}</code> are generated for each <code class="reqn">\theta_1</code>
fulfilling the sufficient nesting condition; see <code>paraConstr</code>
in <code><a href="#topic+acopula-class">acopula</a></code>.</p>
</td></tr>
<tr><td><code id="nacFrail.time_+3A_digits">digits</code></td>
<td>
<p>number of digits for the output.</p>
</td></tr>
<tr><td><code id="nacFrail.time_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if <code>nacFrail.time</code> output
should generated while the random variates are generated (defaults
to <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">k \times k</code> matrix of user run time measurements in milliseconds
(<code>1000*<a href="base.html#topic+system.time">system.time</a>(.)[1]</code>) where <code class="reqn">k</code> is <code>length(taus)</code>.
The first column contains the run times for generating the
<code class="reqn">V_0</code>s.  For the submatrix that remains if the first column is
removed, row <code class="reqn">i</code> (for <code class="reqn">{\theta_0}_i</code>) contains the run times
for the <code class="reqn">V_{01}</code>s for a particular <code class="reqn">\theta_0</code> and all the
admissible <code class="reqn">\theta_1</code>s.
</p>


<h3>See Also</h3>

<p>The class <code><a href="#topic+acopula-class">acopula</a></code> and our predefined <code>"acopula"</code>
family objects in <code><a href="#topic+acopula-families">acopula-families</a></code>.  For some timings on a
standard notebook, see <code><a href="utils.html#topic+demo">demo</a>(timings)</code> (or the file
&lsquo;<span class="file">timings.R</span>&rsquo; in the demo folder).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## takes about 7 seconds:% so we rather test a much smaller set in R CMD check

nacFrail.time(10000, "Gumbel", taus=  c(0.05,(1:9)/10, 0.95))

system.time(
print( nacFrail.time(1000,  "Gumbel", taus = c(0.5,1,6,9)/10) )
)
</code></pre>

<hr>
<h2 id='nacopula-class'>Class &quot;nacopula&quot; of Nested Archimedean Copulas</h2><span id='topic+outer_nacopula-class'></span><span id='topic+nacopula-class'></span><span id='topic+dim+2Cnacopula-method'></span>

<h3>Description</h3>

<p>Class of nested Archimedean Copulas, <code>"nacopula"</code>,
and its <em>specification</em> <code>"outer_nacopula"</code>
differ only by the validation method, which is stricter for the
outer(most) copula (the root copula).
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("nacopula", ...)</code>,
which is only intended for experts.  Root copulas are typically constructed by
<code><a href="#topic+onacopula">onacopula</a>(.)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>copula</code>:</dt><dd><p>an object of class
<code>"<a href="#topic+acopula-class">acopula</a>"</code>, denoting the top-level Archimedean
copula of the nested Archimedean copula, that is, the root copula.</p>
</dd>
<dt><code>comp</code>:</dt><dd><p>an <code><a href="base.html#topic+integer">integer</a></code> vector (possibly of
length 0) of indices of components in <code>1:d</code> which are not
nested Archimedean copulas.  Here, <code class="reqn">d</code> denotes the
<em>dimension</em> of the random vectors under consideration; see
the <code>dim()</code> method below.</p>
</dd>
<dt><code>childCops</code>:</dt><dd><p>a (possibly empty) <code><a href="base.html#topic+list">list</a></code> of
further nested Archimedean copulas (child copulas), that is, objects
of class <code>"nacopula"</code>.  The <code>"nacopula"</code> objects
therefore contain <code>"<a href="#topic+acopula-class">acopula</a>"</code> objects as
special cases.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>dim</dt><dd><p><code>signature(x = "nacopula"):</code> returns the dimension
<code class="reqn">d</code> of the random vector <code class="reqn">U</code> following <code>x</code>.</p>
</dd>
<dt>show</dt><dd><p><code>signature("nacopula"):</code> calling
<code><a href="#topic+printNacopula">printNacopula</a></code> for a compact overview of the nested
Archimedean copula under consideration.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+onacopula">onacopula</a></code> for building (outer) &quot;nacopula&quot; objects.  For the
class definition of the <code>copula</code> component, see
<code><a href="#topic+acopula-class">acopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## nacopula and outer_nacopula class information
showClass("nacopula")
showClass("outer_nacopula")

## Construct a three-dimensional nested Frank copula with parameters
## chosen such that the Kendall's tau of the respective bivariate margins
## are 0.2 and 0.5.
theta0 &lt;- copFrank@iTau(.2)
theta1 &lt;- copFrank@iTau(.5)
C3 &lt;- onacopula("F", C(theta0, 1, C(theta1, c(2,3))))

C3 # displaying it, using show(C3); see help(printNacopula)

## What is the dimension of this copula?
dim(C3)

## What are the indices of direct components of the root copula?
C3@comp

## How does the list of child nested Archimedean copulas look like?
C3@childCops # only one child for this copula, components 2, 3

</code></pre>

<hr>
<h2 id='nacPairthetas'>Pairwise Thetas of Nested Archimedean Copulas</h2><span id='topic+nacPairthetas'></span>

<h3>Description</h3>

<p>Return a <code class="reqn">d * d</code> matrix of pairwise thetas for a nested Archimedean
copula (<code><a href="#topic+nacopula-class">nacopula</a></code>) of dimension <code class="reqn">d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nacPairthetas(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nacPairthetas_+3A_x">x</code></td>
<td>
<p>an (outer) nacopula (with thetas sets).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (<code class="reqn">d \times d</code>) matrix of thetas, say <code>T</code>, where
<code>T[j,k]</code> = theta of the bivariate Archimedean copula
<code class="reqn">C(U_j,U_k)</code>.
</p>


<h3>See Also</h3>

<p>the class <code><a href="#topic+nacopula-class">nacopula</a></code> (with its <code><a href="base.html#topic+dim">dim</a></code>
method).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## test with
options(width=97)

(mm &lt;- rnacModel("Gumbel", d=15, pr.comp = 0.25, order="random"))
stopifnot(isSymmetric(PT &lt;- nacPairthetas(mm)))
round(PT, 2)

## The tau's -- "Kendall's correlation matrix" :
round(copGumbel@tau(PT), 2)

## do this several times:
m1 &lt;- rnacModel("Gumbel", d=15, pr.comp = 1/8, order="seq")
stopifnot(isSymmetric(PT &lt;- nacPairthetas(m1)))
m1; PT

m100 &lt;- rnacModel("Gumbel", d= 100, pr.comp = 1/16, order="seq")
system.time(PT &lt;- nacPairthetas(m100))# how slow {non-optimal algorithm}?
##-- very fast, still!
stopifnot(isSymmetric(PT))
m100

## image(PT)# not ok -- want one color per theta
nt &lt;- length(th0 &lt;- unique(sort(PT[!is.na(PT)])))
th1 &lt;- c(th0[1]/2, th0, 1.25*th0[nt])
ths &lt;- (th1[-1]+th1[-(nt+2)])/2
image(log(PT), breaks = ths, col = heat.colors(nt))

## Nicer and easier:
require(Matrix)
image(as(log(PT),"Matrix"), main = "log( nacPairthetas( m100 ))",
      useAbs=FALSE, useRaster=TRUE, border=NA)
</code></pre>

<hr>
<h2 id='nesdepth'>Nesting Depth of a Nested Archimedean Copula (&quot;nacopula&quot;)</h2><span id='topic+nesdepth'></span>

<h3>Description</h3>

<p>Compute the nesting depth of a nested Archimedean copula which is the
length of the longest branch in the tree representation of the copula,
and hence at least one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nesdepth(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nesdepth_+3A_x">x</code></td>
<td>
<p>object of class <code>"<a href="#topic+nacopula-class">nacopula</a>"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer, the nesting depth of the nested Archimedean copula.
An (unnested) Archimedean copula has depth <code>1</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nacopula-class">dim</a></code> of nacopulas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>F2 &lt;- onacopula("F", C(1.9, 1, C(4.5, c(2,3))))
F2
F3 &lt;- onacopula("Clayton", C(1.5, 3:1,
                             C(2.5, 4:5,
                               C(15, 9:6))))
nesdepth(F2) # 2
nesdepth(F3) # 3

</code></pre>

<hr>
<h2 id='onacopula'>Constructing (Outer) Nested Archimedean Copulas</h2><span id='topic+onacopula'></span><span id='topic+onacopulaL'></span><span id='topic+nacopula'></span><span id='topic+nac2list'></span>

<h3>Description</h3>

<p>Constructing (outer) nested Archimedean copulas (class
<code><a href="#topic+outer_nacopula-class">outer_nacopula</a></code>) is most conveniently done via
<code>onacopula()</code>, using a nested <code class="reqn">C(...)</code> notation.
</p>
<p>Slightly less conveniently, but with the option to pass a <code><a href="base.html#topic+list">list</a></code>
structure, <code>onacopulaL()</code> can be used, typically from inside
another function programmatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onacopula (family, nacStructure)
onacopulaL(family, nacList)
nac2list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="onacopula_+3A_family">family</code></td>
<td>
<p>either a <code><a href="base.html#topic+character">character</a></code> string, the short
or longer form of the Archimedean family name (for example,
&quot;Clayton&quot; or simply &quot;C&quot;); see the <code><a href="#topic+acopula-families">acopula-families</a></code>
documentation, or an <code><a href="#topic+acopula-class">acopula</a></code> family object.</p>
</td></tr>
<tr><td><code id="onacopula_+3A_nacstructure">nacStructure</code></td>
<td>
<p>a &ldquo;formula&rdquo; of the form
</p>
<p style="text-align: center;"><code class="reqn">C(\theta, c(i_1,\dots,i_c),\mathrm{list}(C(..), ..., C(..))).</code>
</p>

<p>Note that <code class="reqn">C()</code> has (maximally) three arguments: the first is
the copula parameter (vector) <code class="reqn">\theta</code>, the second a
(possibly empty) vector of integer indices of components (for the
<code>comp</code> slot in <code><a href="#topic+nacopula-class">nacopula</a></code>s), and finally a
(possibly empty) list of child copulas, each specified with in the
<code class="reqn">C(..)</code> notation themselves.</p>
</td></tr>


<tr><td><code id="onacopula_+3A_naclist">nacList</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> of length 3 (or 2), with elements
</p>

<ol>
<li><p> theta: <code class="reqn">\theta</code>
</p>
</li>
<li> <p><code>comp</code>: components <code class="reqn">c(i_1,\dots,i_c)</code>
</p>
</li>
<li> <p><code>children</code>: a <a href="base.html#topic+list">list</a> which must be a
<code>nacList</code> itself and may be missing to denote the empty
<code>list()</code>.
</p>
</li></ol>

</td></tr>
<tr><td><code id="onacopula_+3A_x">x</code></td>
<td>
<p>an <code>"<a href="#topic+nacopula-class">nacopula</a>"</code>, (typically
<code>"<a href="#topic+outer_nacopula-class">outer_nacopula</a>"</code>) object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>onacopula[L]()</code>:
An outer nested Archimedean copula object, that is, of class
<code>"<a href="#topic+outer_nacopula-class">outer_nacopula</a>"</code>.
</p>
<p><code>nac2list</code>: a <code><a href="base.html#topic+list">list</a></code> exactly like the <code>naclist</code>
argument to <code>onacopulaL</code>.
</p>


<h3>References</h3>

<p>Those of the Archimedean families, for example, <code><a href="#topic+copGumbel">copGumbel</a></code>.
</p>


<h3>See Also</h3>

<p>The class definitions <code>"<a href="#topic+nacopula-class">nacopula</a>"</code>,
<code>"<a href="#topic+outer_nacopula-class">outer_nacopula</a>"</code>, and <code>"<a href="#topic+acopula-class">acopula</a>"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct a ten-dimensional Joe copula with parameter such that
## Kendall's tau equals 0.5
theta &lt;- copJoe@iTau(0.5)
C10 &lt;- onacopula("J",C(theta,1:10))

## Equivalent construction with onacopulaL():
C10. &lt;- onacopulaL("J",list(theta,1:10))
stopifnot(identical(C10, C10.),
          identical(nac2list(C10), list(theta, 1:10)))

## Construct a three-dimensional nested Gumbel copula with parameters
## such that Kendall's tau of the respective bivariate margins are 0.2
## and 0.5.
theta0 &lt;- copGumbel@iTau(.2)
theta1 &lt;- copGumbel@iTau(.5)
C3 &lt;- onacopula("G", C(theta0, 1, C(theta1, c(2,3))))

## Equivalent construction with onacopulaL():
str(NAlis &lt;- list(theta0, 1, list(list(theta1, c(2,3)))))
C3. &lt;- onacopulaL("Gumbel", NAlis)
stopifnot(identical(C3, C3.))

## An exercise: assume you got the copula specs as character string:
na3spec &lt;- "C(theta0, 1, C(theta1, c(2,3)))"
na3call &lt;- parse(text = na3spec)[[1]]
C3.s &lt;- onacopula("Gumbel", na3call)
stopifnot(identical(C3, C3.s))

## Good error message if the component ("coordinate") indices are wrong
## or do not match:
err &lt;- try(onacopula("G", C(theta0, 2, C(theta1, c(3,2)))))

## Compute the probability of falling in [0,.01]^3 for this copula
pCopula(rep(.01,3), C3)

## Compute the probability of falling in the cube [.99,1]^3
prob(C3, rep(.99, 3), rep(1, 3))

## Construct a 6-dimensional, partially nested Gumbel copula of the form
## C_0(C_1(u_1, u_2), C_2(u_3, u_4), C_3(u_5, u_6))
theta &lt;- 2:5
copG &lt;- onacopulaL("Gumbel", list(theta[1], NULL, list(list(theta[2], c(1,2)),
                                                       list(theta[3], c(3,4)),
                                                       list(theta[4], c(5,6)))))
set.seed(1)
U &lt;- rCopula(5000, copG)
pairs(U, pch=".", gap=0, labels = as.expression( lapply(1:dim(copG),
                                     function(j) bquote(italic(U[.(j)]))) ))
</code></pre>

<hr>
<h2 id='opower'>Outer Power Transformation of Archimedean Copulas</h2><span id='topic+opower'></span>

<h3>Description</h3>

<p>Build a new Archimedean copula by applying the outer power
transformation to a given Archimedean copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opower(copbase, thetabase)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opower_+3A_copbase">copbase</code></td>
<td>
<p>a &quot;base&quot; copula, that is, a copula of class
<code><a href="#topic+acopula-class">acopula</a></code>.  Must be one of the predefined families.</p>
</td></tr>
<tr><td><code id="opower_+3A_thetabase">thetabase</code></td>
<td>
<p>the univariate parameter <code class="reqn">\theta</code> for the
generator of the base copula <code>copbase</code>.  Hence, the copula which
is transformed is fixed, that is, does not depend on a parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new <code><a href="#topic+acopula-class">acopula</a></code> object, namely the outer power copula
based on the provided copula family <code>copbase</code> with fixed
parameter <code>thetabase</code>.  The transform introduces a parameter
<code>theta</code>, so one obtains a parametric Archimedean family object as
return value.
</p>
<p>The <code><a href="base.html#topic+environment">environment</a></code> of all function slots contains objects
<code>cOP</code> (which is the outer power copula itself), <code>copbase</code>,
and <code>thetabase</code>.
</p>


<h3>References</h3>

<p>Hofert, M. (2010),
<em>Sampling Nested Archimedean Copulas with Applications to CDO Pricing</em>,
Suedwestdeutscher Verlag fuer Hochschulschriften AG &amp; Co. KG.
</p>


<h3>See Also</h3>

<p>The class <code><a href="#topic+acopula-class">acopula</a></code> and our predefined &quot;acopula&quot;
family objects in <code><a href="#topic+acopula-families">acopula-families</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct an outer power Clayton copula with parameter thetabase such
## that Kendall's tau equals 0.2
thetabase &lt;- copClayton@iTau(0.2)
opC &lt;- opower(copClayton, thetabase) # "acopula" obj. (unspecified theta)

## Construct a 3d nested Archimedean copula based on opC, that is, a nested
## outer power Clayton copula.  The parameters theta are chosen such that
## Kendall's tau equals 0.4 and 0.6 for the outer and inner sector,
## respectively.
theta0 &lt;- opC@iTau(0.4)
theta1 &lt;- opC@iTau(0.6)
opC3d &lt;- onacopulaL(opC, list(theta0, 1, list(list(theta1, 2:3))))
## or opC3d &lt;- onacopula(opC, C(theta0, 1, C(theta1, c(2,3))))

## Compute the corresponding lower and upper tail-dependence coefficients
rbind(theta0 = c(
      lambdaL = opC@lambdaL(theta0),
      lambdaU = opC@lambdaU(theta0) # =&gt; opC3d has upper tail dependence
      ),
      theta1 = c(
      lambdaL = opC@lambdaL(theta1),
      lambdaU = opC@lambdaU(theta1) # =&gt; opC3d has upper tail dependence
      ))

## Sample opC3d
n &lt;- 1000
U &lt;- rnacopula(n, opC3d)

## Plot the generated vectors of random variates of the nested outer
## power Clayton copula.
splom2(U)

## Construct such random variates "by hand"
## (1) draw V0 and V01
V0  &lt;- opC@ V0(n, theta0)
V01 &lt;- opC@V01(V0, theta0, theta1)
## (2) build U
U &lt;- cbind(
opC@psi(rexp(n)/V0,  theta0),
opC@psi(rexp(n)/V01, theta1),
opC@psi(rexp(n)/V01, theta1))
</code></pre>

<hr>
<h2 id='pairs2'>Scatter-Plot Matrix ('pairs') for Copula Distributions with Nice Defaults</h2><span id='topic+pairs2'></span>

<h3>Description</h3>

<p>A version of <span class="pkg">graphics</span>' package <code><a href="graphics.html#topic+pairs">pairs</a>()</code>,
particularly useful for visualizing dependence in multivariate
(copula) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs2(x, labels = NULL, labels.null.lab = "U", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs2_+3A_x">x</code></td>
<td>
<p>a numeric <code><a href="base.html#topic+matrix">matrix</a></code> or an <span class="rlang"><b>R</b></span> object for which
<code><a href="base.html#topic+as.matrix">as.matrix</a>(x)</code> returns such a matrix.</p>
</td></tr>
<tr><td><code id="pairs2_+3A_labels">labels</code></td>
<td>
<p>the variable names, typically unspecified.</p>
</td></tr>
<tr><td><code id="pairs2_+3A_labels.null.lab">labels.null.lab</code></td>
<td>
<p>the <code><a href="base.html#topic+character">character</a></code> string
determining the &ldquo;base name&rdquo; of the variable labels in case
<code>labels</code> is <code>NULL</code> and <code>x</code> does not have all column names given.</p>
</td></tr>
<tr><td><code id="pairs2_+3A_...">...</code></td>
<td>
<p>further arguments, passed to <code><a href="graphics.html#topic+pairs">pairs</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+invisible">invisible</a>()</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splom2">splom2</a>()</code> for a similar function based on
<code><a href="lattice.html#topic+splom">splom</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a 100 x 7 matrix of random variates from a t distribution
## with four degrees of freedom and plot the generated data
U &lt;- matrix(rt(700, df = 4), ncol = 7)
pairs2(U, pch = ".")
</code></pre>

<hr>
<h2 id='pairsRosenblatt'>Plots for Graphical GOF Test via Pairwise Rosenblatt Transforms</h2><span id='topic+pairsRosenblatt'></span><span id='topic+pairsColList'></span>

<h3>Description</h3>

<p><code>pairsColList()</code> creates a <code><a href="base.html#topic+list">list</a></code> containing
information about colors for a given matrix of (approximate aka
&ldquo;pseudo&rdquo;) p-values.  These colors are used in
<code>pairsRosenblatt()</code> for visualizing a graphical
goodness-of-fit test based on pairwise Rosenblatt transformed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairsRosenblatt(cu.u, pvalueMat=pviTest(pairwiseIndepTest(cu.u)),
                method = c("scatter", "QQchisq", "QQgamma",
                           "PPchisq", "PPgamma", "none"),
                g1, g2, col = "B&amp;W.contrast",
                colList = pairsColList(pvalueMat, col=col),
                main=NULL,
                sub = gpviString(pvalueMat, name = "pp-values"),
		panel = NULL, do.qqline = TRUE,
                keyOpt = list(title="pp-value", rug.at=pvalueMat), ...)

pairsColList(P, pdiv = c(1e-04, 0.001, 0.01, 0.05, 0.1, 0.5),
             signif.P = 0.05, pmin0 = 1e-05, bucketCols = NULL,
             fgColMat = NULL, bgColMat = NULL, col = "B&amp;W.contrast",
             BWcutoff = 170,
             bg.col = c("ETHCL", "zurich", "zurich.by.fog", "baby",
                        "heat", "greenish"),
             bg.ncol.gap = floor(length(pdiv)/3),
             bg.col.bottom = NULL, bg.col.top = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairsRosenblatt_+3A_cu.u">cu.u</code></td>
<td>
<p><code class="reqn">(n,d,d)</code>-<code><a href="base.html#topic+array">array</a></code> of pairwise
Rosenblatt-transformed observations as returned by
<code><a href="#topic+pairwiseCcop">pairwiseCcop</a>()</code>.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_pvaluemat">pvalueMat</code></td>
<td>
<p><code class="reqn">(d,d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of p-values (or pp-values).</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_method">method</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> indicating the plot method
to be used. Currently possible are:
</p>

<dl>
<dt><code>"scatter"</code></dt><dd><p>a simple scatter plot.</p>
</dd>
<dt><code>"QQchisq"</code></dt><dd><p>a Q-Q plot after a map to the
<code class="reqn">\chi^2</code> distribution.</p>
</dd>
<dt><code>"QQgamma"</code></dt><dd><p>a Q-Q plot after a map to the
gamma distribution.</p>
</dd>
<dt><code>"PPchisq"</code></dt><dd><p>a P-P plot after a map to the
<code class="reqn">\chi^2</code> distribution.</p>
</dd>
<dt><code>"PPgamma"</code></dt><dd><p>a P-P plot after a map to the
gamma distribution.</p>
</dd>
<dt><code>"none"</code></dt><dd><p>no points are plotted.</p>
</dd>
</dl>

<p>Note: These methods merely just set <code>g1</code> and <code>g2</code>
correctly; see the code for more details.
</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_g1">g1</code></td>
<td>
<p><code><a href="base.html#topic+function">function</a></code> from
<code class="reqn">[0,1]^n\to[0,1]^n</code>
applied to &quot;x&quot; for plotting in one panel.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_g2">g2</code></td>
<td>
<p><code><a href="base.html#topic+function">function</a></code> from
<code class="reqn">[0,1]^{n\times 2}\to[0,1]^n</code>
applied to &quot;y&quot; for plotting in one panel.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_collist">colList</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> of colors and information as
returned by <code>pairsColList()</code>.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_main">main</code></td>
<td>
<p>title.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_sub">sub</code></td>
<td>
<p>sub-title with a smart default containing a global (p)p-value.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_panel">panel</code></td>
<td>
<p>a <code>panel</code> function as for <code><a href="graphics.html#topic+pairs">pairs</a></code>, or,
by default, <code>NULL</code>, where the panel is set as <code><a href="graphics.html#topic+points">points</a></code>
or &ldquo;<code>points</code> <code class="reqn">+</code> <code>qqline</code>&rdquo; if the method is
&quot;QQ....&quot; and <code>do.qqline</code> is true.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_do.qqline">do.qqline</code></td>
<td>
<p>if <code>method = "QQ...."</code>, specify if the plot
panels should also draw a <code><a href="stats.html#topic+qqline">qqline</a>()</code>.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_keyopt">keyOpt</code></td>
<td>
<p>argument passed to <code><a href="#topic+.pairsCond">.pairsCond</a>()</code> for
options for the key.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+.pairsCond">.pairsCond</a>()</code>
(for <code>pairsRosenblatt()</code>)
and to <code>heat_hcl()</code> (for <code>pairsColList</code>;
used to generate the color palette), see Details.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_p">P</code></td>
<td>
<p><code class="reqn">d \times d</code> <code><a href="base.html#topic+matrix">matrix</a></code> of p-values.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_pdiv">pdiv</code></td>
<td>
<p>numeric vector of strictly increasing p-values in
(0,1) that determine the &ldquo;buckets&rdquo; for the background
colors of <code><a href="#topic+.pairsCond">.pairsCond</a>()</code> which creates the
pairs-like goodness-of-fit plot.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_signif.p">signif.P</code></td>
<td>
<p>significance level (must be an element of <code>pdiv</code>).</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_pmin0">pmin0</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> indicating the lower endpoint of
the p-value buckets if <code>pmin</code> is zero.  If set to 0, the lowest
value of the p-value buckets will also be 0.
</p>
<p>Note that <code>pmin0</code> should be in (0, <code>min(pdiv)</code>) when using
<code>pairsColList()</code> for <code><a href="#topic+.pairsCond">.pairsCond</a>()</code>.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_bucketcols">bucketCols</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> of length as <code>pdiv</code> containing the
colors for the buckets.  If not specified, either
<code>bg.col.bottom</code> and <code>bg.col.top</code> are used (if provided) or
<code>bg.col</code> (if provided).</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_fgcolmat">fgColMat</code></td>
<td>
<p><code class="reqn">(d,d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> with foreground colors (the
default will be black if the background color is bright
and white if it is dark; see also <code>BWcutoff</code>).</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_bgcolmat">bgColMat</code></td>
<td>
<p><code class="reqn">(d,d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of background colors;
do not change this unless you know what you are doing.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_col">col</code></td>
<td>
<p>foreground color (defaults to &quot;B&amp;W.contrast&quot; which switches
black/white according to <code>BWcutoff</code>), passed to
<code><a href="#topic+.pairsCond">.pairsCond</a>()</code>.  If <code>colList</code> is not specified,
this color is used to construct the points' color.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_bwcutoff">BWcutoff</code></td>
<td>
<p>number in (0, 255) for switching
foreground color if <code>col="B&amp;W.contrast"</code>.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_bg.col">bg.col</code></td>
<td>
<p>color scheme for the background colors.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_bg.ncol.gap">bg.ncol.gap</code></td>
<td>
<p>number of colors left out as &quot;gap&quot; for
color buckets below/above <code>signif.P</code> (to make
significance/non-significance more visible).</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_bg.col.bottom">bg.col.bottom</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> of length 3 containing a HCL
color specification. If <code>bg.col.bottom</code> is provided and
<code>bucketCols</code> is not, <code>bg.col.bottom</code> is used as the color
for the bucket of smallest p-values.</p>
</td></tr>
<tr><td><code id="pairsRosenblatt_+3A_bg.col.top">bg.col.top</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> of length 3 containing a HCL
color specification. If <code>bg.col.top</code> is provided and
<code>bucketCols</code> is not, <code>bg.col.top</code> is used as the color for
the bucket of largest p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extra arguments of <code>pairsRosenblatt()</code> are passed to
<code><a href="#topic+.pairsCond">.pairsCond</a>()</code>, these notably may include <code>key</code>, true
by default, which draws a color key for the colors used as panel
background encoding (pseudo) p-values.
</p>
<p><code>pairsColList()</code> is basically an auxiliary function to specify
the colors used in the graphical goodness-of-fit test as
conducted by <code>pairsRosenblatt()</code>. The latter is described in
detail in Hofert and Mächler (2013).
See also <code><a href="utils.html#topic+demo">demo</a>(gof_graph)</code>.
</p>


<h3>Value</h3>


<dl>
<dt><code>pairsRosenblatt</code>: </dt><dd><p>invisibly, the result of <code><a href="#topic+.pairsCond">.pairsCond</a>()</code>.</p>
</dd>
<dt><code>pairsColList</code>: </dt><dd><p>a named <code><a href="base.html#topic+list">list</a></code> with components
</p>

<dl>
<dt><code>fgColMat</code></dt><dd><p><code><a href="base.html#topic+matrix">matrix</a></code> of foreground colors.</p>
</dd>
<dt><code>bgColMat</code></dt><dd><p><code><a href="base.html#topic+matrix">matrix</a></code> of background colors
(corresponding to <code>P</code>).</p>
</dd>
<dt><code>bucketCols</code></dt><dd><p><code><a href="base.html#topic+vector">vector</a></code> containing the colors
corresponding to <code>pvalueBuckets</code> as described above.</p>
</dd>
<dt><code>pvalueBuckets</code></dt><dd><p><code><a href="base.html#topic+vector">vector</a></code> containing the
endpoints of the p-value buckets.</p>
</dd>
</dl>

</dd>
</dl>



<h3>References</h3>

<p>Hofert, M. and Mächler, M. (2014)
A graphical goodness-of-fit test for dependence models in higher dimensions;
<em>Journal of Computational and Graphical Statistics</em>,
<b>23</b>(3), 700&ndash;716.  <a href="https://doi.org/10.1080/10618600.2013.812518">doi:10.1080/10618600.2013.812518</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairwiseCcop">pairwiseCcop</a>()</code> for the tools behind the scenes.
<code><a href="utils.html#topic+demo">demo</a>(gof_graph)</code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 2-dim example {d = 2} ===============
##
## "t" Copula with 22. degrees of freedom; and (pairwise) tau = 0.5
nu &lt;- 2.2 # degrees of freedom
## Define the multivariate distribution
tCop &lt;- ellipCopula("t", param=iTau(ellipCopula("t", df=nu), tau = 0.5),
                    dim=2, df=nu)
set.seed(19)
X &lt;- qexp(rCopula(n = 400, tCop))

## H0 (wrongly): a Normal copula, with correct tau
copH0 &lt;- ellipCopula("normal", param=iTau(ellipCopula("normal"), tau = 0.5))

## create array of pairwise copH0-transformed data columns
cu.u &lt;- pairwiseCcop(pobs(X), copula = copH0)

## compute pairwise matrix of p-values and corresponding colors
pwIT &lt;- pairwiseIndepTest(cu.u, N=200) # (d,d)-matrix of test results

round(pmat &lt;- pviTest(pwIT), 3) # pick out p-values
## .286 and .077
pairsRosenblatt(cu.u, pvalueMat= pmat)



### A shortened version of   demo(gof_graph) -------------------------------

N &lt;- 32 ## too small, for "testing"; realistically, use a larger one:
if(FALSE)
N &lt;- 100

## 5d Gumbel copula ##########

n &lt;- 250 # sample size
d &lt;- 5 # dimension
family &lt;- "Gumbel" # copula family
tau &lt;- 0.5
set.seed(17)
## define and sample the copula (= H0 copula), build pseudo-observations
cop &lt;- getAcop(family)
th &lt;- cop@iTau(tau) # correct parameter value
copH0 &lt;- onacopulaL(family, list(th, 1:d)) # define H0 copula
U. &lt;- pobs(rCopula(n, cop=copH0))

## create array of pairwise copH0-transformed data columns
cu.u &lt;- pairwiseCcop(U., copula = copH0)

## compute pairwise matrix of p-values and corresponding colors
pwIT &lt;- pairwiseIndepTest(cu.u, N=N, verbose=interactive()) # (d,d)-matrix of test results
round(pmat &lt;- pviTest(pwIT), 3) # pick out p-values
## Here (with seed=1):  no significant ones, smallest = 0.0603

## Plots ---------------------

## plain (too large plot symbols here)
pairsRosenblatt(cu.u, pvalueMat=pmat, pch=".")

## with title, no subtitle
pwRoto &lt;- "Pairwise Rosenblatt transformed observations"
pairsRosenblatt(cu.u, pvalueMat=pmat, pch=".", main=pwRoto, sub=NULL)

## two-line title including expressions, and centered
title &lt;- list(paste(pwRoto, "to test"),
              substitute(italic(H[0]:C~~bold("is Gumbel with"~~tau==tau.)),
                         list(tau.=tau)))
line.main &lt;- c(4, 1.4)
pairsRosenblatt(cu.u, pvalueMat=pmat, pch=".",
                main=title, line.main=line.main, main.centered=TRUE)

## Q-Q plots -- can, in general, better detect outliers
pairsRosenblatt(cu.u, pvalueMat=pmat, method="QQchisq", cex=0.2)
</code></pre>

<hr>
<h2 id='persp-methods'>Methods for Function &lsquo;persp&rsquo; in Package &lsquo;copula&rsquo;</h2><span id='topic+persp-methods'></span><span id='topic+persp+2CCopula-method'></span><span id='topic+persp+2Cmvdc-method'></span>

<h3>Description</h3>

<p>Methods for function <code><a href="graphics.html#topic+persp">persp</a></code> to draw perspective plots (of
two dimensional distributions from package <span class="pkg">copula</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Copula'
persp(x, FUN, n.grid = 26, delta = 0,
      xlab = "u1", ylab = "u2",
      zlab = deparse(substitute(FUN))[1], zlim = NULL,
      theta = -30, phi = 30, expand = 0.618,
      ticktype = "detail", ...)
## S4 method for signature 'mvdc'
persp(x, FUN, xlim, ylim, n.grid = 26,
      xlab = "x1", ylab = "x2", zlab = deparse(substitute(FUN))[1],
      theta = -30, phi = 30, expand = 0.618,
      ticktype = "detail", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persp-methods_+3A_x">x</code></td>
<td>
<p>a <code>"<a href="#topic+Copula-class">Copula</a>"</code> or a <code>"<a href="#topic+mvdc-class">mvdc</a>"</code> object.</p>
</td></tr>
<tr><td><code id="persp-methods_+3A_fun">FUN</code></td>
<td>
<p>the <code><a href="base.html#topic+function">function</a></code> to be plotted; typically
<code><a href="#topic+dCopula">dCopula</a></code> or <code><a href="#topic+pCopula">pCopula</a></code>.</p>
</td></tr>
<tr><td><code id="persp-methods_+3A_n.grid">n.grid</code></td>
<td>
<p>the number of grid points used in each dimension.  This
can be a vector of length two, giving the number of grid points used
in x- and y-direction, respectively; the function <code>FUN</code> will be
evaluated on the corresponding (x,y)-grid.</p>
</td></tr>
<tr><td><code id="persp-methods_+3A_delta">delta</code></td>
<td>
<p>A small number in <code class="reqn">[0, \frac 1 2)</code>
influencing the evaluation boundaries. The x- and y- vectors will
have the range <code>[0+delta, 1-delta]</code>, the default being <code>[0,1]</code>.</p>
</td></tr>
<tr><td><code id="persp-methods_+3A_xlim">xlim</code>, <code id="persp-methods_+3A_ylim">ylim</code></td>
<td>
<p>The <code><a href="base.html#topic+range">range</a></code> of the x and
y variables, respectively.</p>
</td></tr>
<tr><td><code id="persp-methods_+3A_xlab">xlab</code>, <code id="persp-methods_+3A_ylab">ylab</code>, <code id="persp-methods_+3A_zlab">zlab</code>, <code id="persp-methods_+3A_zlim">zlim</code>, <code id="persp-methods_+3A_theta">theta</code>, <code id="persp-methods_+3A_phi">phi</code>, <code id="persp-methods_+3A_expand">expand</code>, <code id="persp-methods_+3A_ticktype">ticktype</code>, <code id="persp-methods_+3A_...">...</code></td>
<td>
<p>Arguments
for (the default method of) <code><a href="graphics.html#topic+persp">persp</a>()</code>, the ones
enumerated here all with <em>different</em> defaults than there.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+invisible">invisible</a></code>; a list with the following components:
</p>
<table>
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>The numeric vectors, as passed to <code><a href="graphics.html#topic+persp.default">persp.default</a></code>.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>The matrix of evaluated <code>FUN</code> values on the grid as
passed to <code><a href="graphics.html#topic+persp.default">persp.default</a></code>.</p>
</td></tr>
<tr><td><code>persp</code></td>
<td>
<p>the <code class="reqn">4 \times 4</code> transformation matrix
returned by <code><a href="graphics.html#topic+persp.default">persp.default</a></code>.</p>
</td></tr>
</table>


<h3>Methods</h3>

<p>Perspective plots for both <code>"<a href="#topic+copula-class">copula</a>"</code> or
<code>"<a href="#topic+mvdc-class">mvdc</a>"</code> objects, see <code>x</code> in the
<em>Arguments</em> section.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+contour-methods">contour-methods</a></code> for drawing contour lines of the
same functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>persp(claytonCopula(2),   pCopula, main = "CDF of claytonCopula(2)")
persp(  frankCopula(1.5), dCopula, main = "Density of frankCopula(1.5)")
persp(  frankCopula(1.5), dCopula, main = "c_[frank(1.5)](.)", zlim = c(0,2))

## Examples with negative tau:
(th1 &lt;- iTau(amhCopula(), -0.1))
persp(amhCopula(th1), dCopula)
persp(amhCopula(th1), pCopula, ticktype = "simple") # no axis ticks
persp(  frankCopula(iTau(  frankCopula(), -0.1)), dCopula)
persp(claytonCopula(iTau(claytonCopula(), -0.1)), dCopula)
##
cCop.2 &lt;- function(u, copula, ...) cCopula(u, copula, ...)[,2]
persp(    amhCopula(iTau(    amhCopula(), -0.1)), cCop.2, main="cCop(AMH...)[,2]")
persp(  frankCopula(iTau(  frankCopula(), -0.1)), cCop.2, main="cCop(frankC)[,2]")
## and  Clayton  also looks "the same" ...

## MVDC Examples ------------------------------------
mvNN &lt;- mvdc(gumbelCopula(3), c("norm", "norm"),
          list(list(mean = 0, sd = 1), list(mean = 1)))
persp(mvNN, dMvdc, xlim=c(-2, 2), ylim=c(-1, 3), main = "Density")
persp(mvNN, pMvdc, xlim=c(-2, 2), ylim=c(-1, 3), main = "Cumulative Distr.")
</code></pre>

<hr>
<h2 id='plackettCopula'>Construction of a Plackett Copula</h2><span id='topic+plackettCopula'></span>

<h3>Description</h3>

<p>Constructs a Plackett copula (class <code>"plackettCopula}"</code>) with its
corresponding parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plackettCopula(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plackettCopula_+3A_param">param</code></td>
<td>
<p>a number (numeric vector of length one) specifying the
<em>non negative</em> parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Plackett copula object of class <code>"<a href="#topic+plackettCopula-class">plackettCopula</a>"</code>.
</p>


<h3>References</h3>

<p>Plackett, R. L. (1965). A Class of Bivariate Distributions.
<em>Journal of the American Statistical Association</em> <b>60</b>, 516&ndash;522.
</p>


<h3>See Also</h3>

<p>The <code>"<a href="#topic+plackettCopula-class">plackettCopula</a>"</code> class;
<code><a href="#topic+ellipCopula">ellipCopula</a></code>, <code><a href="#topic+archmCopula">archmCopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plackett.cop &lt;- plackettCopula(param=2)
lambda(plackett.cop) # 0 0 : no tail dependencies
## For really large param values (here, 1e20 and Inf are equivalent):
set.seed(1); Xe20 &lt;- rCopula(5000, plackettCopula(1e20))
set.seed(1); Xinf &lt;- rCopula(5000, plackettCopula(Inf))
stopifnot(all.equal(Xe20, Xinf))
</code></pre>

<hr>
<h2 id='plackettCopula-class'>Class &quot;plackettCopula&quot; of Plackett Copulas</h2><span id='topic+plackettCopula-class'></span>

<h3>Description</h3>

<p>The Plackett copula class.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by <code>new("plackettCopula", ...)</code> but are
typically produced by <code><a href="#topic+plackettCopula">plackettCopula</a>(alpha)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dimension</code>:</dt><dd><p>Numeric (scalar), the dimension of the copula.</p>
</dd>
<dt><code>exprdist</code>:</dt><dd><p>a length two <code><a href="base.html#topic+expression">expression</a></code> with
expressions for the CDF and PDF of the copula.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>a number (numeric vector of length one) specifying the
<em>non negative</em> parameter.</p>
</dd>
<dt><code>param.names</code>:</dt><dd><p>the <code>"<a href="base.html#topic+character">character</a>"</code> string <code>"alpha"</code>.</p>
</dd>
<dt><code>param.lowbnd</code>:</dt><dd><p>the number <code>0</code>.</p>
</dd>
<dt><code>param.upbnd</code>:</dt><dd><p>the number <code>Inf</code>.</p>
</dd>
<dt><code>fullname</code>:</dt><dd><p>(deprecated; do not use!)</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Typical copula methods work, see <code>"<a href="#topic+plackettCopula-class">plackettCopula</a>"</code>
and use <code>methods(class = "plackettCopula")</code>.
</p>


<h3>Extends</h3>

<p>Class <code>"plackettCopula"</code> extends class <code>"<a href="#topic+copula-class">copula</a>"</code> directly.
</p>


<h3>References</h3>

<p>Nelsen, R. B. (2006), <em>An introduction to Copulas</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+copula-class">copula-class</a></code>, <code><a href="#topic+plackettCopula">plackettCopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(plackettCopula())

plackettCopula()@exprdist[["cdf"]]
methods(class = "plackettCopula")
contourplot2(plackettCopula(7), pCopula)
wireframe2(plackettCopula(5), dCopula, main= "plackettCopula(5)")
</code></pre>

<hr>
<h2 id='plot-methods'>Methods for 'plot' in Package 'copula'</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CCopula+2CANY-method'></span><span id='topic+plot+2Cmvdc+2CANY-method'></span>

<h3>Description</h3>

<p>Methods for <code><a href="base.html#topic+plot">plot</a>()</code> to draw a scatter plot of a random
sample from bivariate distributions from package <span class="pkg">copula</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'Copula,ANY'
plot(x, n, xlim = 0:1, ylim = 0:1,
      xlab = quote(U[1]), ylab = quote(U[2]), main = NULL, ...)
## S4 method for signature 'mvdc,ANY'
plot(x, n, xlim = NULL, ylim = NULL,
      xlab = quote(X[1]), ylab = quote(X[2]), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>a <em>bivariate</em> <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code>,
<code>"<a href="methods.html#topic+data.frame-class">data.frame</a>"</code>, <code>"<a href="#topic+Copula-class">Copula</a>"</code> or
a <code>"<a href="#topic+mvdc-class">mvdc</a>"</code> object.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_n">n</code></td>
<td>
<p>when <code>x</code> is not matrix-like: The sample size of the
random sample drawn from <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_xlim">xlim</code>, <code id="plot-methods_+3A_ylim">ylim</code></td>
<td>
<p>the x- and y-axis limits.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_xlab">xlab</code>, <code id="plot-methods_+3A_ylab">ylab</code></td>
<td>
<p>the x- and y-axis labels.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_main">main</code></td>
<td>
<p>the main title; when true, shows the call's <code>x</code>
&ldquo;expression&rdquo;.  By default, when <code>NULL</code> and the <code>x</code>
expression matches <code>"[Cc]opula"</code> that expression is used as
well.  This smart default is somewhat experimental; feedback is welcome.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+plot">plot</a></code>
methods, i.e., typically <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible().
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splom2">splom2</a>()</code> for a scatter-plot <em>matrix</em> based on
<code><a href="lattice.html#topic+splom">splom</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For 2-dim. 'copula' objects -------------------------
## Plot uses  n  compula samples
n &lt;- 1000 # sample size
set.seed(271) # (reproducibility)
plot(tCopula(-0.8, df = 1.25), n = n) # automatic main title!

nu &lt;- 3 # degrees of freedom
tau &lt;- 0.5 # Kendall's tau
th &lt;- iTau(tCopula(df = nu), tau) # corresponding parameter
cop &lt;- tCopula(th, df = nu) # define 2-d copula object
plot(cop, n = n)

## For 2-dim. 'mvdc' objects ---------------------------
mvNN &lt;- mvdc(cop, c("norm", "norm"),
             list(list(mean = 0, sd = 1), list(mean = 1)))
plot(mvNN, n = n)
</code></pre>

<hr>
<h2 id='pnacopula'>Evaluation of (Nested) Archimedean Copulas</h2><span id='topic+pnacopula'></span><span id='topic+pCopula+2Cmatrix+2Cnacopula-method'></span><span id='topic+pCopula+2Cnumeric+2Cnacopula-method'></span>

<h3>Description</h3>

<p>For a (nested) Archimedean copula (object of class <code><a href="#topic+nacopula-class">nacopula</a></code>)
<code>x</code>, <code>pCopula(u, x)</code> (or also currently still <code>pnacopula(x, u)</code>)
evaluates the copula <code>x</code> at the given vector or matrix <code>u</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,nacopula'
pCopula(u, copula, ...)

## *Deprecated*:
pnacopula(x, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnacopula_+3A_copula">copula</code>, <code id="pnacopula_+3A_x">x</code></td>
<td>
<p>(nested) Archimedean copula of dimension <code class="reqn">d</code>, that is, an
object of class <code><a href="#topic+nacopula-class">nacopula</a></code>, typically from
<code><a href="#topic+onacopula">onacopula</a>(..)</code>.</p>
</td></tr>
<tr><td><code id="pnacopula_+3A_u">u</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> vector of length <code class="reqn">d</code> or matrix
with <code class="reqn">d</code> columns.</p>
</td></tr>
<tr><td><code id="pnacopula_+3A_...">...</code></td>
<td>
<p>unused: potential optional arguments passed from and to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value of an Archimedean copula <code class="reqn">C</code> with generator <code class="reqn">\psi</code> at
<code class="reqn">u</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">C(\bm{u})=\psi(\psi^{-1}(u_1)+\dots+\psi^{-1}(u_d)),\ \bm{u}\in[0,1]^d.
  </code>
</p>

<p>The value of a nested Archimedean copula is defined similarly.  Note that a
d-dimensional copula is called <em>nested Archimedean</em> if it is an
Archimedean copula with arguments possibly replaced by other nested
Archimedean copulas.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> in <code class="reqn">[0,1]</code> which is the copula evaluated
at <code>u</code>. (Currently not parallelized.)
</p>


<h3>Note</h3>

<p><code><a href="#topic+pCopula">pCopula</a>(u, copula)</code> is a <em>generic</em> function with
methods for <em>all</em> our copula classes, see <code><a href="#topic+pCopula">pCopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct a three-dimensional nested Joe copula with parameters
## chosen such that the Kendall's tau of the respective bivariate margins
## are 0.2 and 0.5.
theta0 &lt;- copJoe@iTau(.2)
theta1 &lt;- copJoe@iTau(.5)
C3 &lt;- onacopula("J", C(theta0, 1, C(theta1, c(2,3))))

## Evaluate this copula at the vector u
u &lt;- c(.7,.8,.6)
pCopula(u, C3)

## Evaluate this copula at the matrix v
v &lt;- matrix(runif(300), ncol=3)
pCopula(v, C3)

## Back-compatibility check
stopifnot(identical( pCopula (u, C3), suppressWarnings(
                    pnacopula(C3, u))),
          identical( pCopula (v, C3), suppressWarnings(
                    pnacopula(C3, v))))
</code></pre>

<hr>
<h2 id='pobs'>Pseudo-Observations</h2><span id='topic+pobs'></span>

<h3>Description</h3>

<p>Compute the pseudo-observations for the given data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pobs(x, na.last = "keep",
     ties.method = eval(formals(rank)$ties.method), lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pobs_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix (or <code class="reqn">d</code>-vector) of random
variates to be converted to pseudo-observations.</p>
</td></tr>
<tr><td><code id="pobs_+3A_na.last">na.last</code></td>
<td>
<p>string passed to <code><a href="base.html#topic+rank">rank</a></code>; see there.</p>
</td></tr>
<tr><td><code id="pobs_+3A_ties.method">ties.method</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string specifying how ranks
should be computed if there are ties in any of the coordinate
samples of <code>x</code>; passed to <code><a href="base.html#topic+rank">rank</a></code>.</p>
</td></tr>
<tr><td><code id="pobs_+3A_lower.tail">lower.tail</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> which, if <code>FALSE</code>,
returns the pseudo-observations when applying the
empirical marginal survival functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">n</code> realizations
<code class="reqn">\bm{x}_i=(x_{i1},\dots,x_{id})^T</code>,
<code class="reqn">i\in\{1,\dots,n\}</code> of a random vector <code class="reqn">\bm{X}</code>,
the pseudo-observations are defined via <code class="reqn">u_{ij}=r_{ij}/(n+1)</code> for
<code class="reqn">i\in\{1,\dots,n\}</code> and <code class="reqn">j\in\{1,\dots,d\}</code>, where <code class="reqn">r_{ij}</code> denotes the rank of <code class="reqn">x_{ij}</code> among all
<code class="reqn">x_{kj}</code>, <code class="reqn">k\in\{1,\dots,n\}</code>.  When there are
no ties in any of the coordinate samples of <code>x</code>, the
pseudo-observations can thus also be computed by component-wise applying the
marginal empirical distribution functions to the data and scaling the result by
<code class="reqn">n/(n+1)</code>. This asymptotically negligible scaling factor is used to
force the variates to fall inside the open unit hypercube, for example, to
avoid problems with density evaluation at the boundaries. Note that
<code>pobs(, lower.tail=FALSE)</code> simply returns <code>1-pobs()</code>.
</p>


<h3>Value</h3>

<p><code><a href="base.html#topic+matrix">matrix</a></code> (or <code><a href="base.html#topic+vector">vector</a></code>) of the same
dimensions as <code>x</code> containing the pseudo-observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple definition of the function:
pobs
## Draw from a multivariate normal distribution
d &lt;- 10
set.seed(1)
P &lt;- Matrix::nearPD(matrix(pmin(pmax(runif(d*d), 0.3), 0.99), ncol=d))$mat
diag(P) &lt;- rep(1, d)
n &lt;- 500
x &lt;- MASS::mvrnorm(n, mu = rep(0, d), Sigma = P)

## Compute pseudo-observations (should roughly follow a Gauss
## copula with correlation matrix P)
u &lt;- pobs(x)
plot(u[,5],u[,10], xlab=quote(italic(U)[1]), ylab=quote(italic(U)[2]))

## All components: pairwise plot
pairs(u, gap=0, pch=".", labels =
      as.expression( lapply(1:d, function(j) bquote(italic(U[.(j)]))) ))
</code></pre>

<hr>
<h2 id='polylog'>Polylogarithm <code class="reqn">\mathrm{Li_s(z)}</code> and Debye Functions</h2><span id='topic+polylog'></span><span id='topic+debye1'></span><span id='topic+debye2'></span>

<h3>Description</h3>

<p>Compute the polylogarithm function <code class="reqn">\mathrm{Li_s(z)}</code>,
initially defined as the power series,
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Li}_s(z) = \sum_{k=1}^\infty {z^k \over k^s},</code>
</p>

<p>for <code class="reqn">|z| &lt; 1</code>, and then more generally (by analytic continuation) as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Li}_1(z) = -\log(1-z),</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Li}_{s+1}(z) = \int_0^z \frac{\mathrm{Li}_s(t)}{t}\,dt.</code>
</p>

<p>Currently, mainly the case of negative integer <code class="reqn">s</code> is well supported,
as that is used for some of the Archimedean copula densities.
</p>
<p>For <code class="reqn">s = 2</code>, <code class="reqn">\mathrm{Li_2(z)}</code> is also called
&lsquo;dilogarithm&rsquo; or &ldquo;Spence's function&rdquo;.  The
<code>"default"</code> method uses the <code><a href="gsl.html#topic+dilog">dilog</a></code> or
<code><a href="gsl.html#topic+complex_dilog">complex_dilog</a></code> function from package <a href="https://CRAN.R-project.org/package=gsl"><span class="pkg">gsl</span></a>,
respectively when <code class="reqn">s = 2</code>.
</p>
<p>Also compute the Debye_n functions, for <code class="reqn">n=1</code> and <code class="reqn">n=2</code>, in a
slightly more general manner than the <span class="pkg">gsl</span> package functions
<code><a href="gsl.html#topic+debye_1">debye_1</a></code> and <code>debye_2</code> (which cannot deal with
non-finite <code>x</code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polylog(z, s,
        method = c("default", "sum", "negI-s-Stirling",
                   "negI-s-Eulerian", "negI-s-asymp-w"),
        logarithm = FALSE, is.log.z = FALSE, is.logmlog = FALSE,
        asymp.w.order = 0, n.sum)

debye1(x)
debye2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polylog_+3A_z">z</code></td>
<td>
<p>numeric or complex vector</p>
</td></tr>
<tr><td><code id="polylog_+3A_s">s</code></td>
<td>
<p>complex number; current implementation is aimed at
<code class="reqn">s \in \{0,-1,\dots\}</code></p>
</td></tr>
<tr><td><code id="polylog_+3A_method">method</code></td>
<td>
<p>a string specifying the algorithm to be used.</p>
</td></tr>
<tr><td><code id="polylog_+3A_logarithm">logarithm</code></td>
<td>
<p>logical specified to return log(Li.(.)) instead of Li.(.)</p>
</td></tr>
<tr><td><code id="polylog_+3A_is.log.z">is.log.z</code></td>
<td>
<p>logical; if TRUE, the specified <code>z</code> argument is
really <code class="reqn">w = \log(z)</code>;
that is, we compute <code class="reqn">\mathrm{Li}_s(\exp(w))</code>, and
we typically have <code class="reqn">w &lt; 0</code>, or equivalently, <code class="reqn">z &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="polylog_+3A_is.logmlog">is.logmlog</code></td>
<td>
<p>logical; if TRUE, the specified argument <code>z</code> is
<code class="reqn">lw = \log(-w) = \log(-\log(z))</code>
(where as above, <code class="reqn">w = \log(z)</code>).</p>
</td></tr>
<tr><td><code id="polylog_+3A_asymp.w.order">asymp.w.order</code></td>
<td>
<p>currently only default is implemented.</p>
</td></tr>
<tr><td><code id="polylog_+3A_n.sum">n.sum</code></td>
<td>
<p>for <code>method="sum"</code> only: the number of terms used.</p>
</td></tr>
<tr><td><code id="polylog_+3A_x">x</code></td>
<td>
<p>numeric vector, may contain <code>Inf</code>, <code><a href="base.html#topic+NA">NA</a></code>, and
negative values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Almost entirely taken from
<a href="https://en.wikipedia.org/wiki/Polylogarithm">https://en.wikipedia.org/wiki/Polylogarithm</a>:
</p>
<p>For integer values of the polylogarithm order, the following
explicit expressions are obtained by repeated application of
<code class="reqn">z \frac{\partial}{\partial z}</code> to
<code class="reqn">\mathrm{Li}_1(z)</code>:
</p>
<p style="text-align: center;"><code class="reqn">
  \mathrm{Li}_{1}(z) = -\log(1-z), \ \
  \mathrm{Li}_{0}(z) = {z \over 1-z}, \ \
  \mathrm{Li}_{-1}(z) = {z \over (1-z)^2}, \ \
  \mathrm{Li}_{-2}(z) = {z \,(1+z) \over (1-z)^3},
</code>
</p>

<p><code class="reqn">\mathrm{Li}_{-3}(z) = {z \,(1+4z+z^2) \over (1-z)^4}</code>, etc.
</p>
<p>Accordingly, the polylogarithm reduces to a ratio of polynomials in
z, and is therefore a rational function of z, for all nonpositive
integer orders.  The general case may be expressed as a finite sum:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Li}_{-n}(z) =
  \left(z \,{\partial \over \partial z} \right)^n \frac{z}{1-z}
  = \sum_{k=0}^n k! \,S(n+1,k+1) \left({z \over {1-z}} \right)^{k+1}
  \ \ (n=0,1,2,\ldots),</code>
</p>

<p>where <code class="reqn">S(n,k)</code> are the Stirling numbers of the second kind.
</p>
<p>Equivalent formulae applicable to negative integer orders are
(Wood 1992, § 6) ...
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Li}_{-n}(z) = {1 \over (1-z)^{n+1}} \sum_{k=0}^{n-1}
  			\left\langle {n \atop k} \right\rangle z^{n-k} =
			\frac{z \sum_{k=0}^{n-1} \left\langle {n \atop k} \right
			  \rangle z^k}{(1-z)^{n+1}},
      \qquad (n=1,2,3,\ldots) ~, </code>
</p>

<p>where <code class="reqn">\left\langle {n \atop k} \right\rangle</code>  are the
Eulerian numbers; see also <code><a href="#topic+Eulerian">Eulerian</a></code>.
</p>


<h3>Value</h3>

<p>numeric/complex vector as <code>z</code>, or <code>x</code>, respectively.
</p>


<h3>References</h3>

<p>Wikipedia (2011) <em>Polylogarithm</em>,
<a href="https://en.wikipedia.org/wiki/Polylogarithm">https://en.wikipedia.org/wiki/Polylogarithm</a>.
</p>
<p>Wood, D. C. (June 1992).
The Computation of Polylogarithms.  Technical Report 15-92.
Canterbury, UK: University of Kent Computing Laboratory.
<a href="https://www.cs.kent.ac.uk/pubs/1992/110/">https://www.cs.kent.ac.uk/pubs/1992/110/</a>.
</p>
<p>Apostol, T. M. (2010), <em>&quot;Polylogarithm&quot;</em>, in the
NIST Handbook of Mathematical Functions, <a href="https://dlmf.nist.gov/25.12">https://dlmf.nist.gov/25.12</a>
</p>
<p>Lewin, L. (1981).
<em>Polylogarithms and Associated Functions</em>.
New York: North-Holland. ISBN 0-444-00550-1.
</p>
<p>For Debye functions:  Levin (1981) above, and <br />
Wikipedia (2014) <em>Debye function</em>,
<a href="https://en.wikipedia.org/wiki/Debye_function">https://en.wikipedia.org/wiki/Debye_function</a>.
</p>


<h3>See Also</h3>

<p>The polylogarithm is used in MLE for some Archimedean copulas; see
<code><a href="#topic+emle">emle</a></code>;
</p>
<p>The Debye functions are used for <code><a href="#topic+tau">tau</a></code> or
<code><a href="#topic+rho">rho</a></code> computations of the Frank copula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The dilogarithm,  polylog(z, s = 2) = Li_2(.) -- mathmatically defined on C \ [1, Inf)
## so x -&gt; 1 is a limit case:
polylog(z = 1, s = 2)
## in the limit, should be equal to
pi^2 / 6

## Default method uses  GSL's dilog():
rLi2 &lt;- curve(polylog(x, 2), -5, 1, n= 1+ 6*64, col=2, lwd=2)
abline(c(0,1), h=0,v=0:1, lty=3, col="gray40")
## "sum" method gives the same for |z| &lt; 1 and large number of terms:
ii &lt;- which(abs(rLi2$x) &lt; 1)
stopifnot(all.equal(rLi2$y[ii],
            polylog(rLi2$x[ii], 2, "sum", n.sum = 1e5),
          tolerance = 1e-15))


z1 &lt;- c(0.95, 0.99, 0.995, 0.999, 0.9999)
L   &lt;- polylog(         z1,  s=-3,method="negI-s-Euler") # close to Inf
LL  &lt;- polylog(     log(z1), s=-3,method="negI-s-Euler",is.log.z=TRUE)
LLL &lt;- polylog(log(-log(z1)),s=-3,method="negI-s-Euler",is.logmlog=TRUE)
all.equal(L, LL)
all.equal(L, LLL)

p.Li &lt;- function(s.set, from = -2.6, to = 1/4, ylim = c(-1, 0.5),
                 colors = c("orange","brown", palette()), n = 201, ...)
{
    s.set &lt;- sort(s.set, decreasing = TRUE)
    s &lt;- s.set[1] # &lt;_ for auto-ylab
    curve(polylog(x, s, method="negI-s-Stirling"), from, to,
          col=colors[1], ylim=ylim, n=n, ...)
    abline(h=0,v=0, col="gray")
    for(is in seq_along(s.set)[-1])
        curve(polylog(x, s=s.set[is], method="negI-s-Stirling"),
              add=TRUE, col = colors[is], n=n)
    s &lt;- rev(s.set)
    legend("bottomright",paste("s =",s), col=colors[2-s], lty=1, bty="n")
}

## yellow is unbearable (on white):
palette(local({p &lt;- palette(); p[p=="yellow"] &lt;- "goldenrod"; p}))

## Wikipedia page plot (+/-):
p.Li(1:-3, ylim= c(-.8, 0.6), colors = c(2:4,6:7))

## and a bit more:
p.Li(1:-5)

## For the range we need it:
ccol &lt;- c(NA,NA, rep(palette(),10))
p.Li(-1:-20, from=0, to=.99, colors=ccol, ylim = c(0, 10))
## log-y scale:
p.Li(-1:-20, from=0, to=.99, colors=ccol, ylim = c(.01, 1e7),
     log = "y", yaxt = "n")
if(require(sfsmisc)) eaxis(2) else axis(2)
</code></pre>

<hr>
<h2 id='polynEval'>Evaluate Polynomials</h2><span id='topic+polynEval'></span>

<h3>Description</h3>

<p>Evaluate a univariate polynomial at <code>x</code> (typically a vector), that is,
compute, for a given vector of coefficients <code>coef</code>, the polynomial
<code>coef[1] + coef[2]*x + ... + coef[p+1]*x^p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polynEval(coef, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polynEval_+3A_coef">coef</code></td>
<td>
<p>numeric vector.  If a vector, <code>x</code> can be an
array and the result matches <code>x</code>.</p>
</td></tr>
<tr><td><code id="polynEval_+3A_x">x</code></td>
<td>
<p>numeric vector or array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The stable Horner rule is used for evaluation.
</p>
<p>Using the C code speeds up the already fast <span class="rlang"><b>R</b></span> code available in
<code><a href="sfsmisc.html#topic+polyn.eval">polyn.eval</a>()</code> in package <a href="https://CRAN.R-project.org/package=sfsmisc"><span class="pkg">sfsmisc</span></a>.
</p>


<h3>Value</h3>

<p>numeric vector or array, with the same dimensions as <code>x</code>,
containing the polynomial values <code class="reqn">p(x)</code>.
</p>


<h3>See Also</h3>

<p>For a much more sophisticated treatment of polynomials, use the
<code>polynom</code> package (for example, evaluation can be done via
<code><a href="polynom.html#topic+predict.polynomial">predict.polynomial</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>polynEval(c(1,-2,1), x = -2:7) # (x - 1)^2
polynEval(c(0, 24, -50, 35, -10, 1),
          x = matrix(0:5, 2,3)) # 5 zeros!
</code></pre>

<hr>
<h2 id='printNacopula'>Print Compact Overview of a Nested Archimedean Copula (&quot;nacopula&quot;)</h2><span id='topic+printNacopula'></span><span id='topic+show+2Cnacopula-method'></span>

<h3>Description</h3>

<p>Print a compact overview of a nested Archimedean copula, that is, an
object of class <code>"<a href="#topic+nacopula-class">nacopula</a>"</code>.
Calling <code>printNacopula</code> explicitly allows to customize the
printing behavior.  Otherwise, the <code><a href="methods.html#topic+show">show</a>()</code> method calls
<code>printNacopula</code> with default arguments only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printNacopula(x, labelKids=NA, deltaInd=, indent.str="",
	              digits=getOption("digits"),
	              width=getOption("width"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printNacopula_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+nacopula-class">nacopula</a></code>.</p>
</td></tr>
<tr><td><code id="printNacopula_+3A_labelkids">labelKids</code></td>
<td>
<p>logical specifying if child copulas should be labeled;
If <code>NA</code> (as per default), on each level, children are labeled
only if they are not only-child.</p>
</td></tr>
<tr><td><code id="printNacopula_+3A_deltaind">deltaInd</code></td>
<td>
<p>by how much should each child be indented <em>more</em>
than its parent? (non-negative integer).  The default is three
with <code>labelKids</code> being the default or <code>TRUE</code>, otherwise it is
five (for <code>labelKids=FALSE</code>).</p>
</td></tr>
<tr><td><code id="printNacopula_+3A_indent.str">indent.str</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the
indentation, that is, the string that should be <em>prepended</em> on the
first line of output, and determine the amount of blanks for the
remaining lines.</p>
</td></tr>
<tr><td><code id="printNacopula_+3A_digits">digits</code>, <code id="printNacopula_+3A_width">width</code></td>
<td>
<p>number of significant digits, and desired print
width; see <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="printNacopula_+3A_...">...</code></td>
<td>
<p>potentially further arguments, passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly, <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C8 &lt;- onacopula("F", C(1.9, 1,
                       list(K1 = C(5.7, c(2,5)),
                            abc= C(5.0, c(3,4,6),
                                   list(L2 = C(11.5, 7:8))))))
C8 # -&gt; printNacopula(C8)
printNacopula(C8, delta=10)
printNacopula(C8, labelKids=TRUE)
</code></pre>

<hr>
<h2 id='prob'>Computing Probabilities of Hypercubes</h2><span id='topic+prob'></span><span id='topic+prob-methods'></span><span id='topic+prob+2CCopula-method'></span>

<h3>Description</h3>

<p>Compute probabilities of a <code class="reqn">d-</code>dimensional random vector <code class="reqn">U</code>
distributed according to a given copula <code>x</code> to
fall in a hypercube <code class="reqn">(l,u]</code>, where <code class="reqn">l</code> and <code class="reqn">u</code> denote the
lower and upper corners of the hypercube, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob(x, l, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_+3A_x">x</code></td>
<td>
<p>copula of dimension <code class="reqn">d</code>, that is, an object
inheriting from <code><a href="#topic+Copula-class">Copula</a></code>.</p>
</td></tr>
<tr><td><code id="prob_+3A_l">l</code>, <code id="prob_+3A_u">u</code></td>
<td>
<p><code class="reqn">d</code>-dimensional, <code><a href="base.html#topic+numeric">numeric</a></code>, lower and
upper hypercube boundaries, respectively, satisfying
<code class="reqn">0 \le l_i \le u_i \le 1</code>,
for <code class="reqn">i\in{1,\dots,d}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> in <code class="reqn">[0,1]</code> which is the probability
<code class="reqn">P(l_i&lt; U_i \le u_i)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pCopula">pCopula</a>(.)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct a three-dimensional nested Joe copula with parameters
## chosen such that the Kendall's tau of the respective bivariate margins
## are 0.2 and 0.5.
theta0 &lt;- copJoe@iTau(.2)
theta1 &lt;- copJoe@iTau(.5)
C3 &lt;- onacopula("J", C(theta0, 1, C(theta1, c(2,3))))

## Compute the probability of a random vector distributed according to
## this copula to fall inside the cube with lower point l and upper
## point u.
l &lt;- c(.7,.8,.6)
u &lt;- c(1,1,1)
prob(C3, l, u)

## ditto for a bivariate normal copula with rho = 0.8 :
prob(normalCopula(0.8), c(.2,.4), c(.3,.6))
</code></pre>

<hr>
<h2 id='qqplot2'>Q-Q Plot with Rugs and Pointwise Asymptotic Confidence Intervals</h2><span id='topic+qqplot2'></span>

<h3>Description</h3>

<p>A Q-Q plot (possibly) with rugs and pointwise approximate (via the
Central Limit Theorem) two-sided 1-<code class="reqn">\alpha</code> confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqplot2(x, qF, log = "", qqline.args = if(log=="x" || log=="y")
        list(untf=TRUE) else list(),
        rug.args = list(tcl=-0.6*par("tcl")),
        alpha = 0.05, CI.args = list(col="gray40"),
        CI.mtext = list(text=paste0("Pointwise asymptotic ", 100*(1-alpha),
                        "% confidence intervals"), side=4,
                        cex=0.6*par("cex.main"), adj=0, col="gray40"),
        main = quote(bold(italic(F)~~"Q-Q plot")),
        main.args = list(text=main, side=3, line=1.1, cex=par("cex.main"),
                         font=par("font.main"), adj=par("adj"), xpd=NA),
        xlab = "Theoretical quantiles", ylab = "Sample quantiles",
        file="", width=6, height=6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqplot2_+3A_x">x</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code>.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_qf">qF</code></td>
<td>
<p>(theoretical) quantile function against which the Q-Q plot
is created.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_log">log</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string indicating whether log-scale should be
used; see <code>?plot.default</code>.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_qqline.args">qqline.args</code></td>
<td>
<p>argument <code><a href="base.html#topic+list">list</a></code> passed to
<code><a href="stats.html#topic+qqline">qqline</a>()</code> for creating the Q-Q line. Use
<code>qqline.args=NULL</code> to omit the Q-Q line.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_rug.args">rug.args</code></td>
<td>
<p>argument <code><a href="base.html#topic+list">list</a></code> passed to
<code><a href="graphics.html#topic+rug">rug</a>()</code> for creating the rugs. Use
<code>rug.args=NULL</code> to omit the rugs.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_alpha">alpha</code></td>
<td>
<p>significance level.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_ci.args">CI.args</code></td>
<td>
<p>argument <code><a href="base.html#topic+list">list</a></code> passed to
<code><a href="graphics.html#topic+lines">lines</a>()</code> for plotting the confidence intervals. Use
<code>CI.args=NULL</code> to omit the confidence intervals.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_ci.mtext">CI.mtext</code></td>
<td>
<p>argument <code><a href="base.html#topic+list">list</a></code> passed to
<code><a href="graphics.html#topic+mtext">mtext</a>()</code> for plotting information about the confidence
intervals. Use <code>CI.mtext=NULL</code> to omit the information.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_main">main</code></td>
<td>
<p>title (can be an expression; use &quot;&quot; for no title).</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_main.args">main.args</code></td>
<td>
<p>argument <code><a href="base.html#topic+list">list</a></code> passed to
<code><a href="graphics.html#topic+mtext">mtext</a>()</code> for plotting the title. Use
<code>main.args=NULL</code> to omit the title.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_xlab">xlab</code></td>
<td>
<p>x axis label.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_ylab">ylab</code></td>
<td>
<p>y axis label.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_file">file</code></td>
<td>
<p>file name including the extension &ldquo;.pdf&rdquo;.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_width">width</code></td>
<td>
<p>width parameter of <code><a href="grDevices.html#topic+pdf">pdf</a>()</code>.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_height">height</code></td>
<td>
<p>height parameter of <code><a href="grDevices.html#topic+pdf">pdf</a>()</code>.</p>
</td></tr>
<tr><td><code id="qqplot2_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+plot">plot</a>()</code> based
for plotting the points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the source code for how the confidence intervals are constructed precisely.
</p>


<h3>Value</h3>

<p><code><a href="base.html#topic+invisible">invisible</a>()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+plot">plot</a>()</code> for the underlying plot function,
<code><a href="stats.html#topic+qqline">qqline</a>()</code> for how the Q-Q line is implemented,
<code><a href="graphics.html#topic+rug">rug</a>()</code> for how the rugs are constructed,
<code><a href="graphics.html#topic+lines">lines</a>()</code> for how the confidence intervals are drawn, and
<code><a href="graphics.html#topic+mtext">mtext</a>()</code> for how the title and information about the
confidence intervals is printed.
<code><a href="grDevices.html#topic+pdf">pdf</a>()</code> for plotting to pdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 250
df &lt;- 7
set.seed(1)
x &lt;- rchisq(n, df=df)

## Q-Q plot against the true quantiles (of a chi^2_3 distribution)
qqplot2(x, qF = function(p) qchisq(p, df=df),
        main = substitute(bold(italic(chi[NU])~~"Q-Q Plot"), list(NU=df)))

## in log-log scale
qqplot2(x, qF = function(p) qchisq(p, df=df), log="xy",
        main = substitute(bold(italic(chi[NU])~~"Q-Q Plot"), list(NU=df)))

## Q-Q plot against wrong quantiles (of an Exp(1) distribution)
qqplot2(x, qF=qexp, main = quote(bold(Exp(1)~~"Q-Q Plot")))
</code></pre>

<hr>
<h2 id='radSymTest'>Test of Exchangeability for a Bivariate Copula</h2><span id='topic+radSymTest'></span>

<h3>Description</h3>

<p>Test for assessing the radial symmetry of the underlying multivariate
copula based on the empirical copula.  The test statistic is a
multivariate extension of the definition adopted in the first
reference. An approximate p-value for the test statistic is obtained
by means of a appropriate <em>bootstrap</em> which can take the presence
of ties in the component series of the data into accont; see the
second reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radSymTest(x, N = 1000, ties = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radSymTest_+3A_x">x</code></td>
<td>
<p> a data matrix that will be transformed to pseudo-observations.</p>
</td></tr>
<tr><td><code id="radSymTest_+3A_n">N</code></td>
<td>
<p> number of boostrap iterations to be used to
simulate realizations of the test statistic under the null
hypothesis.</p>
</td></tr>
<tr><td><code id="radSymTest_+3A_ties">ties</code></td>
<td>
<p> logical; if <code>TRUE</code>, the boostrap procedure is
adapted to the presence of ties in any of the coordinate samples
of <code>x</code>; the default value of <code>NA</code> indicates that the
presence/absence of ties will be checked for automatically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More details are available in the second reference.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p> value of the test statistic. </p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p> corresponding approximate p-value. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Genest, C. and G. Nešlehová, J. (2014).  On tests of
radial symmetry for bivariate copulas. <em>Statistical Papers</em>
<b>55</b>, 1107&ndash;1119.
</p>
<p>Kojadinovic, I. (2017). Some copula inference procedures adapted to
the presence of ties. <em>Computational Statistics and Data
Analysis</em> <b>112</b>, 24&ndash;41, <a href="https://arxiv.org/abs/1609.05519">https://arxiv.org/abs/1609.05519</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+exchTest">exchTest</a></code>, <code><a href="#topic+exchEVTest">exchEVTest</a></code>, <code><a href="#topic+gofCopula">gofCopula</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from radially symmetric copulas
radSymTest(rCopula(200, frankCopula(3)))
radSymTest(rCopula(200, normalCopula(0.7, dim = 3)))

## Data from non radially symmetric copulas
radSymTest(rCopula(200, claytonCopula(3)))
radSymTest(rCopula(200, gumbelCopula(2, dim=3)))
</code></pre>

<hr>
<h2 id='rdj'>Daily Returns of Three Stocks in the Dow Jones</h2><span id='topic+rdj'></span>

<h3>Description</h3>

<p>Five years of daily log-returns (from 1996 to 2000) of Intel
(INTC), Microsoft (MSFT) and General Electric (GE) stocks. These
data were analysed in Chapter 5 of McNeil, Frey and
Embrechts (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rdj, package="copula")</code></pre>


<h3>Format</h3>

<p>A data frame of 1262 daily log-returns from 1996 to 2000.
</p>

<dl>
<dt><code>Date</code></dt><dd><p>the date, of class <code>"<a href="base.html#topic+Date">Date</a>"</code>.</p>
</dd>
<dt><code>INTC</code></dt><dd><p>daily log-return of the Intel stock</p>
</dd>
<dt><code>MSFT</code></dt><dd><p>daily log-return of the Microsoft stock</p>
</dd>
<dt><code>GE</code></dt><dd><p>daily log-return of the General Electric</p>
</dd>
</dl>



<h3>References</h3>

<p>McNeil, A. J., Frey, R., and Embrechts, P. (2005).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rdj)
str(rdj)# 'Date' is of class "Date"

with(rdj, {
   matplot(Date, rdj[,-1], type = "o", xaxt = "n", ylim = .15* c(-1,1),
           main = paste("rdj - data;  n =", nrow(rdj)))
   Axis(Date, side=1)
})
legend("top", paste(1:3, names(rdj[,-1])), col=1:3, lty=1:3, bty="n")


x &lt;- rdj[, -1] # '-1' : not the Date
## a t-copula (with a vague inital guess of Rho entries)
tCop &lt;- tCopula(rep(.2, 3), dim=3, dispstr="un", df=10, df.fixed=TRUE)
ft &lt;- fitCopula(tCop, data = pobs(x))
ft
ft@copula # the fitted t-copula as tCopula object
system.time(
g.C &lt;- gofCopula(claytonCopula(dim=3), as.matrix(x), simulation = "mult")
) ## 5.3 sec
system.time(
g.t &lt;- gofCopula(ft@copula, as.matrix(x), simulation = "mult")
) ## 8.1 sec


</code></pre>

<hr>
<h2 id='retstable'>Sampling Exponentially Tilted Stable Distributions</h2><span id='topic+retstable'></span><span id='topic+retstableR'></span>

<h3>Description</h3>

<p>Generating random variates of an exponentially tilted stable
distribution of the form
</p>
<p style="text-align: center;"><code class="reqn">\tilde{S}(\alpha, 1, (\cos(\alpha\pi/2)V_0)^{1/\alpha},
    V_0\mathbf{1}_{\{\alpha=1\}}, h\mathbf{1}_{\{\alpha\ne 1\}}; 1),
  </code>
</p>

<p>with parameters
<code class="reqn">\alpha\in(0,1]</code>, <code class="reqn">V_0\in(0,\infty)</code>,
and <code class="reqn">h\in[0,\infty)</code> and corresponding
Laplace-Stieltjes transform
</p>
<p style="text-align: center;"><code class="reqn">\exp(-V_0((h+t)^\alpha-h^\alpha)),\ t\in[0,\infty];
  </code>
</p>

<p>see the references for more details about this distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retstable(alpha, V0, h = 1, method = NULL)
retstableR(alpha, V0, h = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retstable_+3A_alpha">alpha</code></td>
<td>
<p>parameter in <code class="reqn">(0,1]</code>.</p>
</td></tr>
<tr><td><code id="retstable_+3A_v0">V0</code></td>
<td>
<p>vector of values in <code class="reqn">(0,\infty)</code> (for example, when
sampling nested Clayton copulas, these are random variates from
<code class="reqn">F_0</code>), that is, the distribution corresponding to
<code class="reqn">\psi_0</code>.</p>
</td></tr>
<tr><td><code id="retstable_+3A_h">h</code></td>
<td>
<p>parameter in <code class="reqn">[0,\infty)</code>.</p>
</td></tr>
<tr><td><code id="retstable_+3A_method">method</code></td>
<td>
<p>a character string denoting the method to use, currently
either <code>"MH"</code> (Marius Hofert's algorithm) or <code>"LD"</code> (Luc Devroye's
algorithm).  By default, when <code>NULL</code>, a smart choice is
made to use the fastest of these methods depending on the
specific values of <code class="reqn">V_0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>retstableR</code> is a pure <span class="rlang"><b>R</b></span> version of <code>"MH"</code>, however, not as fast as
<code>retstable</code> (implemented in C, based on both methods) and therefore not
recommended in simulations when run time matters.
</p>


<h3>Value</h3>

<p>A vector of variates from <code class="reqn">\tilde{S}(\alpha, 1, .....)</code>; see above.
</p>


<h3>References</h3>

<p>Devroye, L. (2009)
Random variate generation for exponentially and polynomially
tilted stable distributions,
<em>ACM Transactions on Modeling and Computer Simulation</em> <b>19</b>, 18, 1&ndash;20.
</p>
<p>Hofert, M. (2011)
Efficiently sampling nested Archimedean copulas,
<em>Computational Statistics &amp; Data Analysis</em> <b>55</b>, 57&ndash;70.
</p>
<p>Hofert, M. (2012),
Sampling exponentially tilted stable distributions,
<em>ACM Transactions on Modeling and Computer Simulation</em> <b>22</b>, 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rstable1">rstable1</a></code> for sampling stable distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Draw random variates from an exponentially tilted stable distribution
## with given alpha, V0, and h = 1
alpha &lt;- .2
V0 &lt;- rgamma(200, 1)
rETS &lt;- retstable(alpha, V0)

## Distribution plot the random variates -- log-scaled
hist(log(rETS), prob=TRUE)
lines(density(log(rETS)), col=2)
rug (log(rETS))
</code></pre>

<hr>
<h2 id='rF01FrankJoe'>Sample Univariate Distributions Involved in Nested Frank and Joe Copulas</h2><span id='topic+rF01Frank'></span><span id='topic+rF01Joe'></span>

<h3>Description</h3>

<p><code>rF01Frank</code>:
Generate a vector of random variates <code class="reqn">V_{01}\sim F_{01}</code>
with Laplace-Stieltjes transform
</p>
<p style="text-align: center;"><code class="reqn">\psi_{01}(t;V_0)=
    \Bigl(\frac{1-(1-\exp(-t)(1-e^{-\theta_1}))^{\theta_0/\theta_1}}{%
      1-e^{-\theta_0}}\Bigr)^{V_0}.</code>
</p>

<p>for the given	realizations <code class="reqn">V_0</code> of Frank's <code class="reqn">F_0</code> and the
parameters <code class="reqn">\theta_0,\theta_1\in(0,\infty)</code>
such that <code class="reqn">\theta_0\le\theta_1</code>.  This distribution
appears on sampling nested Frank copulas.  The parameter <code>rej</code> is used
to determine the cut-off point of two algorithms that are involved in
sampling <code class="reqn">F_{01}</code>.  If
<code class="reqn">\code{rej} &lt; V_0\theta_0(1-e^{-\theta_0})^{V_0-1}</code>
a rejection from <code class="reqn">F_{01}</code> of Joe is applied (see
<code>rF01Joe</code>; the meaning of the parameter <code>approx</code> is
explained below), otherwise a sum is sampled with a logarithmic
envelope for each summand.
</p>
<p><code>rF01Joe</code>:
Generate a vector of random variates <code class="reqn">V_{01}\sim F_{01}</code>
with Laplace-Stieltjes transform
</p>
<p style="text-align: center;"><code class="reqn">\psi_{01}(t;V_0)=(1-(1-\exp(-t))^\alpha)^{V_0}.</code>
</p>

<p>for the given realizations <code class="reqn">V_0</code> of Joe's <code class="reqn">F_0</code> and
the parameter <code class="reqn">\alpha\in(0,1]</code>.  This distribution
appears on sampling nested Joe copulas.  Here,
<code class="reqn">\alpha=\theta_0/\theta_1</code>, where
<code class="reqn">\theta_0,\theta_1\in[1,\infty)</code> such
that <code class="reqn">\theta_0\le\theta_1</code>.  The parameter
<code>approx</code> denotes the largest number of summands in the
sum-representation of <code class="reqn">V_{01}</code> before the asymptotic
</p>
<p style="text-align: center;"><code class="reqn">V_{01}=V_0^{1/\alpha}S(\alpha,1,\cos^{1/\alpha}(\alpha\pi/2),
    \mathbf{1}_{\{\alpha=1\}};1)</code>
</p>

<p>is used to sample <code class="reqn">V_{01}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rF01Frank(V0, theta0, theta1, rej, approx)
rF01Joe(V0, alpha, approx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rF01FrankJoe_+3A_v0">V0</code></td>
<td>
<p>a vector of random variates from <code class="reqn">F_0</code>.</p>
</td></tr>
<tr><td><code id="rF01FrankJoe_+3A_theta0">theta0</code>, <code id="rF01FrankJoe_+3A_theta1">theta1</code>, <code id="rF01FrankJoe_+3A_alpha">alpha</code></td>
<td>
<p>parameters
<code class="reqn">\theta_0,\theta_1</code>
and <code class="reqn">\alpha</code> as described above.</p>
</td></tr>
<tr><td><code id="rF01FrankJoe_+3A_rej">rej</code></td>
<td>
<p>parameter value as described above.</p>
</td></tr>
<tr><td><code id="rF01FrankJoe_+3A_approx">approx</code></td>
<td>
<p>parameter value as described above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of positive <code><a href="base.html#topic+integer">integer</a></code>s of length <code>n</code>
containing the generated random variates.
</p>


<h3>References</h3>

<p>Hofert, M. (2011).
Efficiently sampling nested Archimedean copulas.
<em>Computational Statistics &amp; Data Analysis</em> <b>55</b>, 57&ndash;70.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rFFrank">rFFrank</a></code>, <code><a href="#topic+rFJoe">rFJoe</a></code>, <code><a href="#topic+rSibuya">rSibuya</a></code>,
and <code><a href="#topic+rnacopula">rnacopula</a></code>.
</p>
<p><code><a href="#topic+rnacopula">rnacopula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sample n random variates V0 ~ F0 for Frank and Joe with parameter
## chosen such that Kendall's tau equals 0.2 and plot histogram
n &lt;- 1000
theta0.F &lt;- copFrank@iTau(0.2)
V0.F &lt;- copFrank@V0(n,theta0.F)
hist(log(V0.F), prob=TRUE); lines(density(log(V0.F)), col=2, lwd=2)
theta0.J &lt;- copJoe@iTau(0.2)
V0.J &lt;- copJoe@V0(n,theta0.J)
hist(log(V0.J), prob=TRUE); lines(density(log(V0.J)), col=2, lwd=2)

## Sample corresponding V01 ~ F01 for Frank and Joe and plot histogram
## copFrank@V01 calls rF01Frank(V0, theta0, theta1, rej=1, approx=10000)
## copJoe@V01 calls rF01Joe(V0, alpha, approx=10000)
theta1.F &lt;- copFrank@iTau(0.5)
V01.F &lt;- copFrank@V01(V0.F,theta0.F,theta1.F)
hist(log(V01.F), prob=TRUE); lines(density(log(V01.F)), col=2, lwd=2)
theta1.J &lt;- copJoe@iTau(0.5)
V01.J &lt;- copJoe@V01(V0.J,theta0.J,theta1.J)
hist(log(V01.J), prob=TRUE); lines(density(log(V01.J)), col=2, lwd=2)
</code></pre>

<hr>
<h2 id='rFFrankJoe'>Sampling Distribution F for Frank and Joe</h2><span id='topic+rFFrank'></span><span id='topic+rFJoe'></span>

<h3>Description</h3>

<p>Generate a vector of variates <code class="reqn">V \sim F</code> from the distribution
function <code class="reqn">F</code> with Laplace-Stieltjes transform
</p>
<p style="text-align: center;"><code class="reqn">(1-(1-\exp(-t)(1-e^{-\theta_1}))^\alpha)/(1-e^{-\theta_0}),
  </code>
</p>

<p>for Frank, or
</p>
<p style="text-align: center;"><code class="reqn">1-(1-\exp(-t))^\alpha,</code>
</p>
<p> for Joe, respectively,
where <code class="reqn">\theta_0</code> and <code class="reqn">\theta_1</code> denote two parameters
of Frank (that is, <code class="reqn">\theta_0,\theta_1\in(0,\infty)</code>) and Joe (that is, <code class="reqn">\theta_0,\theta_1\in[1,\infty)</code>) satisfying
<code class="reqn">\theta_0\le\theta_1</code>
and <code class="reqn">\alpha=\theta_0/\theta_1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rFFrank(n, theta0, theta1, rej)
rFJoe(n, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rFFrankJoe_+3A_n">n</code></td>
<td>
<p>number of variates from <code class="reqn">F</code>.</p>
</td></tr>
<tr><td><code id="rFFrankJoe_+3A_theta0">theta0</code></td>
<td>
<p>parameter <code class="reqn">\theta_0</code>.</p>
</td></tr>
<tr><td><code id="rFFrankJoe_+3A_theta1">theta1</code></td>
<td>
<p>parameter <code class="reqn">\theta_1</code>.</p>
</td></tr>
<tr><td><code id="rFFrankJoe_+3A_rej">rej</code></td>
<td>
<p>method switch for <code>rFFrank</code>: if <code>theta0</code> &gt;
<code>rej</code> a rejection from Joe's family (Sibuya distribution) is
applied (otherwise, a logarithmic envelope is used).</p>
</td></tr>
<tr><td><code id="rFFrankJoe_+3A_alpha">alpha</code></td>
<td>
<p>parameter <code class="reqn">\alpha=
      \theta_0/\theta_1</code> in <code class="reqn">(0,1]</code> for
<code>rFJoe</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rFFrank(n, theta0, theta1, rej)</code> calls
<code><a href="#topic+rF01Frank">rF01Frank</a>(rep(1,n), theta0, theta1, rej, 1)</code> and
<code>rFJoe(n, alpha)</code> calls <code><a href="#topic+rSibuya">rSibuya</a>(n, alpha)</code>.
</p>


<h3>Value</h3>

<p>numeric vector of random variates <code class="reqn">V</code> of length <code>n</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rF01Frank">rF01Frank</a></code>, <code><a href="#topic+rF01Joe">rF01Joe</a></code>, also for references.
<code><a href="#topic+rSibuya">rSibuya</a></code>, and <code><a href="#topic+rnacopula">rnacopula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple definition of the functions:
rFFrank
rFJoe
</code></pre>

<hr>
<h2 id='rlog'>Sampling Logarithmic Distributions</h2><span id='topic+rlog'></span><span id='topic+rlogR'></span>

<h3>Description</h3>

<p>Generating random variates from a Log(p) distribution with probability
mass function
</p>
<p style="text-align: center;"><code class="reqn">p_k=\frac{p^k}{-\log(1-p)k},\ k\in\mathbf{N},
      </code>
</p>

<p>where <code class="reqn">p\in(0,1)</code>.  The implemented algorithm is the
one named &ldquo;LK&rdquo; in Kemp (1981).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rlog(n, p, Ip = 1 - p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlog_+3A_n">n</code></td>
<td>
<p>sample size, that is, length of the resulting vector of random
variates.</p>
</td></tr>
<tr><td><code id="rlog_+3A_p">p</code></td>
<td>
<p>parameter in <code class="reqn">(0,1)</code>.</p>
</td></tr>
<tr><td><code id="rlog_+3A_ip">Ip</code></td>
<td>
<p><code class="reqn">= 1 - p</code>, possibly more accurate, e.g, when
<code class="reqn">p\approx 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For documentation and didactical purposes, <code>rlogR</code> is a pure-<span class="rlang"><b>R</b></span>
implementation of <code>rlog</code>.  However, <code>rlogR</code> is not as fast as
<code>rlog</code> (the latter being implemented in C).
</p>


<h3>Value</h3>

<p>A vector of positive <code><a href="base.html#topic+integer">integer</a></code>s of length <code>n</code> containing the
generated random variates.
</p>


<h3>Note</h3>

<p>In the <span class="pkg">copula</span> package, the Log(p) distribution is needed only
for generating Frank copula observations, namely in
<code><a href="#topic+copFrank">copFrank</a>@V0()</code>, where <code class="reqn">p = 1 - exp(-\theta)</code>, i.e.,
<code>p = -expm1(-theta)</code> and <code>Ip = exp(-theta)</code>.
</p>
<p>For large <code class="reqn">\theta</code> it would be desirable to pass <code>-theta</code>
to <code>rlog()</code> instead of <code>p</code>.  This has not yet been implemented.
</p>


<h3>References</h3>

<p>Kemp, A. W. (1981),
Efficient Generation of Logarithmically Distributed Pseudo-Random Variables,
<em>Journal of the Royal Statistical Society: Series C (Applied
Statistics)</em> <b>30</b>, 3, 249&ndash;253.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sample n random variates from a Log(p) distribution and plot a
## "histogram"
n &lt;- 1000
p &lt;- .5
X &lt;- rlog(n, p)
table(X) ## distribution on the integers {1, 2, ..}
## ==&gt; The following plot is more reasonable than a  hist(X, prob=TRUE) :
plot(table(X)/n, type="h", lwd=10, col="gray70")

## case closer to numerical boundary:
lV &lt;- log10(V &lt;- rlog(10000, Ip = 2e-9))# Ip = exp(-theta) &lt;==&gt; theta ~= 20
hV &lt;- hist(lV, plot=FALSE)
dV &lt;- density(lV)
## Plot density and histogram on log scale with nice axis labeling &amp; ticks:
plot(dV, xaxt="n", ylim = c(0, max(hV$density, dV$y)),
     main = "Density of [log-transformed] Log(p),  p=0.999999..")
abline(h=0, lty=3); rug(lV); lines(hV, freq=FALSE, col = "light blue"); lines(dV)
rx &lt;- range(pretty(par("usr")[1:2]))
sx &lt;- outer(1:9, 10^(max(0,rx[1]):rx[2]))
axis(1, at=log10(sx),     labels= FALSE, tcl = -0.3)
axis(1, at=log10(sx[1,]), labels= formatC(sx[1,]), tcl = -0.75)
</code></pre>

<hr>
<h2 id='rnacModel'>Random nacopula Model</h2><span id='topic+rnacModel'></span>

<h3>Description</h3>

<p>Randomly construct a nested Archimedean copula model,

</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnacModel(family, d, pr.comp, rtau0 = function() rbeta(1, 2,4),
          order=c("random", "each", "seq"), digits.theta = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnacModel_+3A_family">family</code></td>
<td>
<p>the Archimedean family</p>
</td></tr>
<tr><td><code id="rnacModel_+3A_d">d</code></td>
<td>
<p>integer &gt;=2; the dimension</p>
</td></tr>
<tr><td><code id="rnacModel_+3A_pr.comp">pr.comp</code></td>
<td>
<p>probability of a direct component on each level</p>
</td></tr>
<tr><td><code id="rnacModel_+3A_rtau0">rtau0</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> to generate a (random) tau,
corresponding to theta0, the outermost theta.</p>
</td></tr>
<tr><td><code id="rnacModel_+3A_order">order</code></td>
<td>
<p>string indicating how the component IDs are selected.</p>
</td></tr>
<tr><td><code id="rnacModel_+3A_digits.theta">digits.theta</code></td>
<td>
<p>integer specifying the number of digits to round
the theta values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of <code><a href="#topic+outer_nacopula-class">outer_nacopula</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnacopula">rnacopula</a></code> for generating <code class="reqn">d</code>-dimensional
observations from an (outer) <code><a href="#topic+nacopula-class">nacopula</a></code>, e.g., from
the <em>result</em> of <code>rnacModel()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Implicitly tests the function {with validity of outer_nacopula ..}
set.seed(11)
for(i in 1:40) {
  m1 &lt;- rnacModel("Gumbel", d=sample(20:25, 1), pr.comp = 0.3,
		  rtau0 = function() 0.25)
  m2 &lt;- rnacModel("Joe", d=3, pr.comp = 0.1, order="each")
  mC &lt;- rnacModel("Clayton", d=20, pr.comp = 0.3,
		  rtau0 = function() runif(1, 0.1, 0.5))
  mF &lt;- rnacModel("Frank", d=sample(20:25, 1), pr.comp = 0.3, order="seq")
}
</code></pre>

<hr>
<h2 id='rnacopula'>Sampling Nested Archimedean Copulas</h2><span id='topic+rnacopula'></span>

<h3>Description</h3>

<p>Random number generation for nested Archimedean copulas (of class
<code><a href="#topic+outer_nacopula-class">outer_nacopula</a></code>, specifically), aka
<em>sampling</em> nested Archimedean copulas will generate <code>n</code>
random vectors of dimension <code class="reqn">d</code> (= <code>dim(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnacopula(n, copula, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnacopula_+3A_n">n</code></td>
<td>
<p>integer specifying the sample size, that is, the number of
copula-distributed random vectors <code class="reqn">\mathbf{U}_i</code>, to be generated.</p>
</td></tr>
<tr><td><code id="rnacopula_+3A_copula">copula</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of <code><a href="base.html#topic+class">class</a></code>
<code>"<a href="#topic+outer_nacopula-class">outer_nacopula</a>"</code>, typically from
<code><a href="#topic+onacopula">onacopula</a>()</code>.</p>
</td></tr>
<tr><td><code id="rnacopula_+3A_x">x</code></td>
<td>
<p>only for back compatibility: former name of <code>copula</code> argument.</p>
</td></tr>
<tr><td><code id="rnacopula_+3A_...">...</code></td>
<td>
<p>possibly further arguments for the given copula family.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generation happens by calling <code><a href="#topic+rnchild">rnchild</a>()</code> on
each child copula (which itself recursively descends the tree implied
by the nested Archimedean structure).  The algorithm is based on a
mixture representation of the generic distribution functions
<code class="reqn">F_{0}</code> and <code class="reqn">F_{01}</code> and is presented in
McNeil (2008) and Hofert (2011a).  Details about how to efficiently sample the
distribution functions <code class="reqn">F_{0}</code> and <code class="reqn">F_{01}</code> can be found in
Hofert (2010), Hofert (2012), and Hofert and Mächler (2011).
</p>


<h3>Value</h3>

<p><code><a href="base.html#topic+numeric">numeric</a></code> matrix containing the generated vectors of
random variates from the nested Archimedean copula object <code>copula</code>.
</p>


<h3>References</h3>

<p>McNeil, A. J. (2008).
Sampling nested Archimedean copulas.
<em>Journal of Statistical Computation and Simulation</em> <b>78</b>, 6,
567&ndash;581.
</p>
<p>Hofert, M. (2010).
Efficiently sampling nested Archimedean copulas.
<em>Computational Statistics &amp; Data Analysis</em> <b>55</b>, 57&ndash;70.
</p>
<p>Hofert, M. (2012), A stochastic representation and sampling algorithm
for nested Archimedean copulas.
<em>Journal of Statistical Computation and Simulation</em>, <b>82</b>,
9, 1239&ndash;1255.
</p>
<p>Hofert, M. (2012).
Sampling exponentially tilted stable distributions.
<em>ACM Transactions on Modeling and Computer Simulation</em> <b>22</b>,
1 (3rd article).
</p>
<p>Hofert, M. and Mächler, M. (2011).
Nested Archimedean Copulas Meet R: The nacopula Package.
<em>Journal of Statistical Software</em> <b>39</b>, 9, 1&ndash;20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnchild">rnchild</a></code>; classes <code>"<a href="#topic+nacopula-class">nacopula</a>"</code> and
<code>"<a href="#topic+outer_nacopula-class">outer_nacopula</a>"</code>; see also <code><a href="#topic+onacopula">onacopula</a>()</code>.
<code><a href="#topic+rnacModel">rnacModel</a></code> creates random nacopula <em>models</em>, i.e.,
the input <code>copula</code> for <code>rnacopula(n, copula)</code>.
</p>
<p>Further, those of the Archimedean families, for example,
<code><a href="#topic+copGumbel">copGumbel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct a three-dimensional nested Clayton copula with parameters
## chosen such that the Kendall's tau of the respective bivariate margins
## are 0.2 and 0.5 :
C3 &lt;- onacopula("C", C(copClayton@iTau(0.2), 1,
                       C(copClayton@iTau(0.5), c(2,3))))
C3

## Sample n vectors of random variates from this copula.  This involves
## sampling exponentially tilted stable distributions
n &lt;- 1000
U &lt;- rnacopula(n, C3)

## Plot the drawn vectors of random variates
splom2(U)
</code></pre>

<hr>
<h2 id='rnchild'>Sampling Child 'nacopula's</h2><span id='topic+rnchild'></span>

<h3>Description</h3>

<p>Method for generating vectors of random numbers of nested Archimedean
copulas which are child copulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnchild(x, theta0, V0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnchild_+3A_x">x</code></td>
<td>
<p>an <code>"<a href="#topic+nacopula-class">nacopula</a>"</code> object, typically emerging from an
<code>"<a href="#topic+outer_nacopula-class">outer_nacopula</a>"</code> object constructed with
<code><a href="#topic+onacopula">onacopula</a>()</code>.</p>
</td></tr>
<tr><td><code id="rnchild_+3A_theta0">theta0</code></td>
<td>
<p>the parameter (vector) of the parent Archimedean copula
which contains <code>x</code> as a child.</p>
</td></tr>
<tr><td><code id="rnchild_+3A_v0">V0</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> vector of realizations of
<code class="reqn">V_{0}</code> following <code class="reqn">F_{0}</code> whose length determines the
number of generated vectors, that is, for each realization
<code class="reqn">V_{0}</code>, a vector of variates from <code>x</code> is generated.</p>
</td></tr>
<tr><td><code id="rnchild_+3A_...">...</code></td>
<td>
<p>possibly further arguments for the given copula family.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generation is done recursively, descending the tree implied by the
nested Archimedean structure.  The algorithm is based on a mixture
representation and requires sampling <code class="reqn">V_{01}\sim F_{01}</code>
given random variates <code class="reqn">V_0\sim F_{0}</code>.  Calling
<code>"rnchild"</code> is only intended for experts.  The typical call of
this function takes place through <code><a href="#topic+rnacopula">rnacopula</a>()</code>.
</p>


<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr><td><code>U</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> matrix containing the vector of random
variates from the child copula.  The number of rows of this matrix
therefore equals the length of <code class="reqn">V_{0}</code> and the number of
columns corresponds to the dimension of the child copula.</p>
</td></tr>
<tr><td><code>indcol</code></td>
<td>
<p>an <code><a href="base.html#topic+integer">integer</a></code> vector of indices of <code>U</code>
(the vector following a nested Archimedean copula of which <code>x</code> is
a child) whose corresponding components of <code>U</code> are arguments of
the nested Archimedean copula <code>x</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rnacopula">rnacopula</a></code>, also for the references.
Further, classes <code>"<a href="#topic+nacopula-class">nacopula</a>"</code> and
<code>"<a href="#topic+outer_nacopula-class">outer_nacopula</a>"</code>; see also <code><a href="#topic+onacopula">onacopula</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct a three-dimensional nested Clayton copula with parameters
## chosen such that the Kendall's tau of the respective bivariate margins
## are 0.2 and 0.5.
theta0 &lt;- copClayton@iTau(.2)
theta1 &lt;- copClayton@iTau(.5)
C3 &lt;- onacopula("C", C(theta0, 1, C(theta1, c(2,3))))
## Sample n random variates V0 ~ F0 (a Gamma(1/theta0,1) distribution)
n &lt;- 1000
V0 &lt;- copClayton@V0(n, theta0)

## Given these variates V0, sample the child copula, that is, the bivariate
## nested Clayton copula with parameter theta1
U23 &lt;- rnchild(C3@childCops[[1]], theta0, V0)

## Now build the three-dimensional vectors of random variates by hand
U1 &lt;- copClayton@psi(rexp(n)/V0, theta0)
U &lt;- cbind(U1, U23$U)

## Plot the vectors of random variates from the three-dimensional nested
## Clayton copula
splom2(U)
</code></pre>

<hr>
<h2 id='rotCopula'>Construction and Class of Rotated aka Reflected Copulas</h2><span id='topic+rotCopula'></span><span id='topic+rotCopula-class'></span><span id='topic+dim+2CrotCopula-method'></span>

<h3>Description</h3>

<p>Constructs a &ldquo;reflected&rdquo; or &ldquo;rotated&rdquo; copula from an
initial copula and a vector of logicals indicating which dimension to
&ldquo;flip&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotCopula(copula, flip = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotCopula_+3A_copula">copula</code></td>
<td>
<p>an object of class <code>"<a href="#topic+Copula-class">Copula</a>"</code>.</p>
</td></tr>
<tr><td><code id="rotCopula_+3A_flip">flip</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> vector (of length 1 or
<code>dim(copula)</code>) indicating which dimension should be
&ldquo;flipped&rdquo;; by default, all the components are flipped,
implying that the resulting copula is the <em>&ldquo;survival copula&rdquo;</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &ldquo;rotated&rdquo; or &ldquo;reflected&rdquo; copula object of class <code>"rotCopula"</code>.
</p>


<h3>Slots</h3>

<p>of a <code>"rotCopula"</code> object
</p>

<dl>
<dt><code>copula</code>:</dt><dd><p>Object of class <code>"<a href="#topic+copula-class">copula</a>"</code>.</p>
</dd>
<dt><code>flip</code>:</dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> vector of length <code class="reqn">d</code>
(the copula dimension) specifying which margins are flipped;
corresponds to the <code>flip</code> argument of <code>rotCopula()</code>. </p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>the copula dimension <code class="reqn">d</code>, an <code><a href="base.html#topic+integer">integer</a></code>.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code> vector specifying
the parameters.</p>
</dd>
<dt><code>param.lowbnd</code>, and <code>param.upbnd</code>:</dt><dd><p><code>numeric</code>
vector of the same length as <code>parameters</code>, specifying
(component wise) bounds for each of the parameters.</p>
</dd>
<dt><code>param.names</code>:</dt><dd><p><code><a href="base.html#topic+character">character</a></code> vector (of same
length as <code>parameters</code>) with parameter names.</p>
</dd>
<dt><code>fullname</code>:</dt><dd><p><b>deprecated</b>; a <code>character</code> string describing the
rotated copula.</p>
</dd>
</dl>



<h3>Note</h3>

<p>When there are an even number of flips, the resulting copula
can be seen as a <em>rotated</em> version of <code>copula</code>.  In the
other cases, e.g., <code>flip = c(FALSE,TRUE)</code> in 2d, it is rather a
a <em>reflected</em> or &ldquo;mirrored&rdquo; copula.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitCopula">fitCopula</a></code> for fitting such copulas to data,
<code><a href="#topic+gofCopula">gofCopula</a></code> for goodness-of-fit tests for such copulas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Two-dimensional examples: First the Clayton(3) survival copula:
survC &lt;- rotCopula(claytonCopula(3)) # default: flip = 'all TRUE'
contourplot2(survC, dCopula)

## Now, a reflected Clayton copula:
r10C  &lt;- rotCopula(claytonCopula(3), flip = c(TRUE, FALSE))

contourplot2(r10C, dCopula, nlevels = 20, main = "dCopula(&lt;rotCopula&gt;)")
contourplot2(r10C, pCopula, nlevels = 20, main = "pCopula(&lt;rotCopula&gt;)")
rho(r10C)
tau(r10C) # -0.6

n &lt;- 1000
u &lt;- rCopula(n, r10C)
rho.n &lt;- cor(u[,1], u[,2], method = "spearman")
tau.n &lt;- cor(u[,1], u[,2], method = "kendall")

## "Calibration"
rc. &lt;- rotCopula(claytonCopula(), flip = c(TRUE, FALSE))
iRho(rc., rho.n)
iTau(rc., tau.n)

## Fitting
fitCopula(rc., data = pobs(u), method = "irho")
fitCopula(rc., data = pobs(u), method = "itau")
fitCopula(rc., data = pobs(u), method = "mpl")

## Goodness-of-fit testing -- the first, parametric bootstrap, is *really* slow
## Not run: gofCopula(rc., x = u)
gofCopula(rc., x = u, simulation = "mult")

## A four-dimensional example: a rotated Frank copula
rf &lt;- rotCopula(frankCopula(10, dim = 4),
                flip = c(TRUE, FALSE, TRUE, FALSE))

n &lt;- 1000
u &lt;- rCopula(n, rf)
splom2(u)

pCopula(c(0.6,0.7,0.6,0.8), rf)
C.n(cbind(0.6,0.7,0.6,0.8),  u)

## Fitting
(rf. &lt;- rotCopula(frankCopula(dim=4),
                  flip = c(TRUE, FALSE, TRUE, FALSE)))
## fitCopula(rf., data = pobs(u), method = "irho")
## FIXME above: not related to rotCopula but frankCopula
fitCopula(rf., data = pobs(u), method = "itau")
fitCopula(rf., data = pobs(u), method = "mpl")

## Goodness-of-fit testing (first ("PB") is really slow, see above):
## Not run: gofCopula(rf., x = u)
gofCopula(rf., x = u, simulation = "mult") # takes 3.7 sec [lynne, 2015]
</code></pre>

<hr>
<h2 id='RSpobs'>Pseudo-Observations of Radial and Uniform Part of Elliptical and Archimedean Copulas</h2><span id='topic+RSpobs'></span>

<h3>Description</h3>

<p>Given a matrix of iid multivariate data from a meta-elliptical or
meta-Archimedean model, <code>RSpobs()</code> computes pseudo-observations
of the radial part <code class="reqn">R</code> and the vector <code class="reqn">\bm{S}</code> which
follows a uniform distribution on the unit sphere (for elliptical
copulas) or the unit simplex (for Archimedean copulas). These
quantities can be used for (graphical) goodness-of-fit tests, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RSpobs(x, do.pobs = TRUE, method = c("ellip", "archm"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RSpobs_+3A_x">x</code></td>
<td>
<p>an <code class="reqn">(n, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of data; if
<code>do.pobs=FALSE</code>, the rows of <code>x</code> are assumed to lie in the
<code class="reqn">d</code>-dimensional unit hypercube (if they do not, this leads to an
error).</p>
</td></tr>
<tr><td><code id="RSpobs_+3A_do.pobs">do.pobs</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether
<code><a href="#topic+pobs">pobs</a>()</code> is applied to <code>x</code> for transforming the
data to the <code class="reqn">d</code>-dimensional unit hypercube.</p>
</td></tr>
<tr><td><code id="RSpobs_+3A_method">method</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string indicating the assumed
underlying model, being meta-elliptical if <code>method="ellip"</code> (in
which case <code>S</code> should be approximately uniform on the
<code class="reqn">d</code>-dimensional unit sphere) or
meta-Archimedean if <code>method="archm"</code> (in which case <code>S</code>
should be approximately uniform on the <code class="reqn">d</code>-dimensional unit simplex).</p>
</td></tr>
<tr><td><code id="RSpobs_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the implemented
methods. These can be
</p>

<dl>
<dt><code>method="ellip"</code></dt><dd><p><code>qQg()</code>
(the quantile <code><a href="base.html#topic+function">function</a></code> of the (assumed)
distribution function <code class="reqn">G_g</code> as given in Genest,
Hofert, G. Nešlehová
(2014)); if provided, <code>qQg()</code> is used in the transformation for
obtaining pseudo-observations of <code class="reqn">R</code> and <code class="reqn">\bm{S}</code>
(see the code for more details).</p>
</dd>
<dt><code>method="archm"</code></dt><dd><p><code>iPsi()</code> (the assumed underlying
generator inverse); if provided, <code>iPsi()</code> is used in the
transformation for obtaining pseudo-observations of <code class="reqn">R</code> and
<code class="reqn">\bm{S}</code> (see the code for more details).</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>The construction of the pseudo-obersvations of the radial part and the
uniform distribution on the unit sphere/simplex is described in
Genest, Hofert, G. Nešlehová (2014).
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with components <code>R</code> (an
<code class="reqn">n</code>-<code><a href="base.html#topic+vector">vector</a></code> containing the pseudo-observations
of the radial part) and <code>S</code> (an <code class="reqn">(n,
    d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> containing the pseudo-observations of the
uniform distribution (on the unit sphere/simplex)).
</p>


<h3>References</h3>

<p>Genest, C., Hofert, M., G. Nešlehová, J., (2014).
Is the dependence Archimedean, elliptical, or what?
<em>To be submitted</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pobs">pobs</a>()</code> for computing the &ldquo;classical&rdquo;
pseudo-observations.</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
n &lt;- 250 # sample size
d &lt;- 5 # dimension
nu &lt;- 3 # degrees of freedom

## Build a mean vector and a dispersion matrix,
## and generate multivariate t_nu data:
mu &lt;- rev(seq_len(d)) # d, d-1, .., 1
L &lt;- diag(d) # identity in dim d
L[lower.tri(L)] &lt;- 1:(d*(d-1)/2)/d # Cholesky factor (diagonal &gt; 0)
Sigma &lt;- crossprod(L) # pos.-def. dispersion matrix (*not* covariance of X)
X &lt;- rep(mu, each=n) + mvtnorm::rmvt(n, sigma=Sigma, df=nu) # multiv. t_nu data
## note: this is *wrong*: mvtnorm::rmvt(n, mean=mu, sigma=Sigma, df=nu)

## compute pseudo-observations of the radial part and uniform distribution
## once for 1a), once for 1b) below
RS.t    &lt;- RSpobs(X, method="ellip", qQg=function(p) qt(p, df=nu)) # 'correct'
RS.norm &lt;- RSpobs(X, method="ellip", qQg=qnorm) # for testing 'wrong' distribution
stopifnot(length(RS.norm$R) == n, length(RS.t$R) == n,
          dim(RS.norm$S) == c(n,d), dim(RS.t$S) == c(n,d))

## 1) Graphically testing the radial part

## 1a) Q-Q plot of R against the correct quantiles
qqplot2(RS.t$R, qF=function(p) sqrt(d*qf(p, df1=d, df2=nu)),
        main.args=list(text= substitute(bold(italic(F[list(d.,nu.)](r^2/d.))~~"Q-Q Plot"),
                                        list(d.=d, nu.=nu)),
		       side=3, cex=1.3, line=1.1, xpd=NA))

## 1b) Q-Q plot of R against the quantiles of F_R for a multivariate normal
##     distribution
qqplot2(RS.norm$R, qF=function(p) sqrt(qchisq(p, df=d)),
        main.args=list(text= substitute(bold(italic(chi[D_]) ~~ "Q-Q Plot"), list(D_=d)),
               side=3, cex=1.3, line=1.1, xpd=NA))

## 2) Graphically testing the angular distribution

## auxiliary function
qqp &lt;- function(k, Bmat) {
    d &lt;- ncol(Bmat) + 1
    qqplot2(Bmat[,k],
            qF = function(p) qbeta(p, shape1=k/2, shape2=(d-k)/2),
            main.args=list(text= substitute(plain("Beta")(s1,s2) ~~ bold("Q-Q Plot"),
                                            list(s1 = k/2, s2 = (d-k)/2)),
  	                   side=3, cex=1.3, line=1.1, xpd=NA))
}

## 2a) Q-Q plot of the 'correct' angular distribution
##     (Bmat[,k] should follow a Beta(k/2, (d-k)/2) distribution)
Bmat.t &lt;- gofBTstat(RS.t$S)
qqp(1, Bmat=Bmat.t) # k=1
qqp(3, Bmat=Bmat.t) # k=3

## 2b) Q-Q plot of the 'wrong' angular distribution
Bmat.norm &lt;- gofBTstat(RS.norm$S)
qqp(1, Bmat=Bmat.norm) # k=1
qqp(3, Bmat=Bmat.norm) # k=3

## 3) Graphically check independence between radial part and B_1 and B_3

## 'correct' distributions (multivariate t)
plot(pobs(cbind(RS.t$R, Bmat.t[,1])), # k = 1
          xlab=quote(italic(R)), ylab=quote(italic(B)[1]),
          main=quote(bold("Rank plot between"~~italic(R)~~"and"~~italic(B)[1])))
plot(pobs(cbind(RS.t$R, Bmat.t[,3])), # k = 3
	  xlab=quote(italic(R)), ylab=quote(italic(B)[3]),
          main=quote(bold("Rank plot between"~~italic(R)~~"and"~~italic(B)[3])))

## 'wrong' distributions (multivariate normal)
plot(pobs(cbind(RS.norm$R, Bmat.norm[,1])), # k = 1
          xlab=quote(italic(R)), ylab=quote(italic(B)[1]),
          main=quote(bold("Rank plot between"~~italic(R)~~"and"~~italic(B)[1])))
plot(pobs(cbind(RS.norm$R, Bmat.norm[,3])), # k = 3
	  xlab=quote(italic(R)), ylab=quote(italic(B)[3]),
          main=quote(bold("Rank plot between"~~italic(R)~~"and"~~italic(B)[3])))
</code></pre>

<hr>
<h2 id='rstable1'>Random numbers from (Skew) Stable Distributions</h2><span id='topic+rstable1'></span><span id='topic+rstable'></span>

<h3>Description</h3>

<p>Generate random numbers of the stable distribution
</p>
<p style="text-align: center;"><code class="reqn">S(\alpha, \beta, \gamma, \delta; k)</code>
</p>
<p> with characteristic
exponent <code class="reqn">\alpha\in(0,2]</code>,
skewness <code class="reqn">\beta\in[-1,1]</code>,
scale    <code class="reqn">\gamma\in[0,\infty)</code>, and
location <code class="reqn">\delta\in\mathbf{R}</code>; see Nolan (2010) for
the parameterization <code class="reqn">k\in\{0,1\}</code>.  The case
<code class="reqn">\gamma=0</code> is understood as the unit jump at <code class="reqn">\delta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstable1(n, alpha, beta, gamma = 1, delta = 0, pm = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstable1_+3A_n">n</code></td>
<td>
<p>an <code><a href="base.html#topic+integer">integer</a></code>, the number of observations to generate.</p>
</td></tr>
<tr><td><code id="rstable1_+3A_alpha">alpha</code></td>
<td>
<p>characteristic exponent <code class="reqn">\alpha\in(0,2]</code>.</p>
</td></tr>
<tr><td><code id="rstable1_+3A_beta">beta</code></td>
<td>
<p>skewness <code class="reqn">\beta\in[-1,1]</code>.</p>
</td></tr>
<tr><td><code id="rstable1_+3A_gamma">gamma</code></td>
<td>
<p>scale <code class="reqn">\gamma\in[0,\infty)</code>.</p>
</td></tr>
<tr><td><code id="rstable1_+3A_delta">delta</code></td>
<td>
<p>location <code class="reqn">\delta\in\mathbf{R}</code>.</p>
</td></tr>
<tr><td><code id="rstable1_+3A_pm">pm</code></td>
<td>
<p>0 or 1, denoting which parametrization (as by Nolan) is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use the approach of John Nolan for generating random variates of
stable distributions.  The function <code>rstable1</code> provides two basic
parametrizations, by default,
</p>
<p><code>pm = 1</code>, the so called &ldquo;S&rdquo;, &ldquo;S1&rdquo;, or &ldquo;1&rdquo;
parameterization.  This is the parameterization used by Samorodnitsky and
Taqqu (1994), and is a slight modification of Zolotarev's (A)
parameterization.  It is the form with the most simple form of the
characteristic function; see Nolan (2010, p. 8).
</p>
<p><code>pm = 0</code> is the &ldquo;S0&rdquo; parameterization: based on the (M)
representation of Zolotarev for an alpha stable distribution with
skewness beta.  Unlike the Zolotarev (M) parameterization, gamma and
delta are straightforward scale and shift parameters.  This
representation is continuous in all 4 parameters.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector of length <code>n</code> containing the
generated random variates.
</p>


<h3>References</h3>

<p>Chambers, J. M., Mallows, C. L., and Stuck, B. W. (1976),
<em>A Method for Simulating Stable Random Variables</em>,
J.  Amer.  Statist.  Assoc. <b>71</b>, 340&ndash;344.
</p>
<p>Nolan, J. P. (2012),
<em>Stable Distributions&mdash;Models for Heavy Tailed Data</em>,
Birkhaeuser, in progress.
</p>
<p>Samoridnitsky, G. and Taqqu, M. S. (1994),
<em>Stable Non-Gaussian Random Processes, Stochastic Models
with Infinite Variance</em>,
Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p><code><a href="stabledist.html#topic+rstable">rstable</a></code> which also allows the
2-parametrization and provides further functionality for
stable distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # Generate and plot a series of stable random variates
   set.seed(1953)
   r &lt;- rstable1(n = 1000, alpha = 1.9, beta = 0.3)
   plot(r, type = "l", main = "stable: alpha=1.9 beta=0.3",
        col = "steelblue"); grid()

   hist(r, "Scott", prob = TRUE, ylim = c(0,0.3),
        main = "Stable S(1.9, 0.3; 1)")
   lines(density(r), col="red2", lwd = 2)
</code></pre>

<hr>
<h2 id='safeUroot'>One-dimensional Root (Zero) Finding - Extra &quot;Safety&quot; for Convenience</h2><span id='topic+safeUroot'></span>

<h3>Description</h3>

<p><code>safeUroot()</code> as a &ldquo;safe&rdquo; version of
<code><a href="stats.html#topic+uniroot">uniroot</a>()</code> searches for a root (that is, zero) of the
function <code>f</code> with respect to its first argument.
</p>
<p>&ldquo;Safe&rdquo; means searching for the correct <code>interval
    = c(lower,upper)</code> if <code>sign(f(x))</code> does not satisfy the
requirements at the interval end points; see the &lsquo;Details&rsquo;
section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>safeUroot(f, interval, ...,
       lower = min(interval), upper = max(interval),
       f.lower = f(lower, ...), f.upper = f(upper, ...),
       Sig = NULL, check.conv = FALSE,
       tol = .Machine$double.eps^0.25, maxiter = 1000, trace = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="safeUroot_+3A_f">f</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="safeUroot_+3A_interval">interval</code></td>
<td>
<p>interval</p>
</td></tr>
<tr><td><code id="safeUroot_+3A_...">...</code></td>
<td>
<p>additional named or unnamed arguments to be passed
to <code>f</code></p>
</td></tr>
<tr><td><code id="safeUroot_+3A_lower">lower</code>, <code id="safeUroot_+3A_upper">upper</code></td>
<td>
<p>lower and upper endpoint of search interval</p>
</td></tr>
<tr><td><code id="safeUroot_+3A_f.lower">f.lower</code>, <code id="safeUroot_+3A_f.upper">f.upper</code></td>
<td>
<p>function value at <code>lower</code> or <code>upper</code>
endpoint, respectively.</p>
</td></tr>
<tr><td><code id="safeUroot_+3A_sig">Sig</code></td>
<td>
<p><em>desired</em> sign of <code>f(upper)</code>, or <code><a href="base.html#topic+NULL">NULL</a></code>.</p>
</td></tr>
<tr><td><code id="safeUroot_+3A_check.conv">check.conv</code></td>
<td>
<p>logical indicating whether a convergence warning of the
underlying <code><a href="stats.html#topic+uniroot">uniroot</a></code> should be caught as an error.</p>
</td></tr>
<tr><td><code id="safeUroot_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy, that is, convergence tolerance.</p>
</td></tr>
<tr><td><code id="safeUroot_+3A_maxiter">maxiter</code></td>
<td>
<p>maximal number of iterations</p>
</td></tr>
<tr><td><code id="safeUroot_+3A_trace">trace</code></td>
<td>
<p>number determining tracing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If it is <em>known how</em> <code class="reqn">f</code> changes sign at the root
<code class="reqn">x_0</code>, that is, if the function is increasing or decreasing there,
<code>Sig</code> can be specified, typically as <code class="reqn">S := \pm 1</code>,
to require <code class="reqn">S = \mathrm{sign}(f(x_0 + \epsilon))</code>
at the solution.  In that case, the search interval <code class="reqn">[l,u]</code> must
be such that <code class="reqn">S * f(l) &lt;= 0</code> and <code class="reqn">S * f(u) &gt;= 0</code>.
</p>
<p>Otherwise, by default, when <code>Sig=NULL</code>, the search interval
<code class="reqn">[l,u]</code> must satisfy <code class="reqn">f(l) * f(u) &lt;= 0</code>.
</p>
<p>In both cases, when the requirement is not satisfied, <code>safeUroot()</code>
tries to enlarge the interval until the requirement <em>is</em> satisfied.
</p>





<h3>Value</h3>

<p>A list with four components, <code>root</code>, <code>f.root</code>, <code>iter</code>
and <code>estim.prec</code>; see <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- function(x) (121 - x^2)/(x^2+1)
f2 &lt;- function(x) exp(-x)*(x - 12)

try(uniroot(f1, c(0,10)))
try(uniroot(f2, c(0,2)))
##--&gt; error: f() .. end points not of opposite sign

## where as safeUroot() simply first enlarges the search interval:
safeUroot(f1, c(0,10),trace=1)
safeUroot(f2, c(0,2), trace=2)

## no way to find a zero of a positive function:
try( safeUroot(exp, c(0,2), trace=TRUE) )

## Convergence checking :
safeUroot(sinc, c(0,5), maxiter=4) #-&gt; "just" a warning
try( # an error, now with  check.conv=TRUE
  safeUroot(sinc, c(0,5), maxiter=4, check.conv=TRUE) )
</code></pre>

<hr>
<h2 id='serialIndepTest'>Serial Independence Test for Continuous Time Series Via Empirical Copula</h2><span id='topic+serialIndepTest'></span><span id='topic+serialIndepTestSim'></span>

<h3>Description</h3>

<p>Computes the serial independence test based on the empirical copula
process as proposed in Ghoudi et al.(2001) and Genest and Rémillard (2004).
The test, which is the serial analog of <code><a href="#topic+indepTest">indepTest</a></code>, can be
seen as composed of three steps:
</p>

<dl>
<dt>(i)</dt><dd><p>a simulation step, which consists in simulating the
distribution of the test statistics under serial independence for
the sample size under consideration;</p>
</dd>
<dt>(ii)</dt><dd><p>the test itself, which consists in computing the
approximate p-values of the test statistics with respect to the
empirical distributions obtained in step (i);</p>
</dd>
<dt>(iii)</dt><dd><p>the display of a graphic, called a <em>dependogram</em>,
enabling to understand the type of departure from serial
independence, if any.</p>
</dd>
</dl>

<p>More details can be found in the articles cited in the reference section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serialIndepTestSim(n, lag.max, m=lag.max+1, N=1000, verbose = interactive())
serialIndepTest(x, d, alpha=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serialIndepTest_+3A_n">n</code></td>
<td>
<p> length of the time series when simulating the distribution of
the test statistics under serial independence.</p>
</td></tr>
<tr><td><code id="serialIndepTest_+3A_lag.max">lag.max</code></td>
<td>
<p> maximum lag.</p>
</td></tr>
<tr><td><code id="serialIndepTest_+3A_m">m</code></td>
<td>
<p> maximum cardinality of the subsets of 'lags' for which a test
statistic is to be computed. It makes sense to consider <code>m &lt;&lt;
      lag.max+1</code> especially when <code>lag.max</code> is large.</p>
</td></tr>
<tr><td><code id="serialIndepTest_+3A_n">N</code></td>
<td>
<p> number of repetitions when simulating under serial
independence.</p>
</td></tr>
<tr><td><code id="serialIndepTest_+3A_verbose">verbose</code></td>
<td>
<p> a logical specifying if progress
should be displayed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>.</p>
</td></tr>
<tr><td><code id="serialIndepTest_+3A_x">x</code></td>
<td>
<p> numeric vector containing the time series whose serial
independence is to be tested.</p>
</td></tr>
<tr><td><code id="serialIndepTest_+3A_d">d</code></td>
<td>
<p> object of class <code>serialIndepTestDist</code> as returned by the
function <code>serialIndepTestSim</code>. It can be regarded as the
empirical distribution of the test statistics under serial
independence.</p>
</td></tr>
<tr><td><code id="serialIndepTest_+3A_alpha">alpha</code></td>
<td>
<p> significance level used in the computation of the
critical values for the test statistics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the references below for more details, especially the third
and fourth ones.</p>


<h3>Value</h3>

<p>The function <code>serialIndepTestSim()</code> returns an object of S3 class
<code>"serialIndepTestDist"</code> with list components <code>sample.size</code>,
<code>lag.max</code>, <code>max.card.subsets</code>, <code>number.repetitons</code>,
<code>subsets</code> (list of the subsets for which test statistics have
been computed), <code>subsets.binary</code> (subsets in binary 'integer'
notation), <code>dist.statistics.independence</code> (a <code>N</code> line matrix
containing the values of the test statistics for each subset and each
repetition) and <code>dist.global.statistic.independence</code> (a vector a
length <code>N</code> containing the values of the serial version of the
global Cramér-von Mises test statistic for each repetition &mdash; see
last reference p.175).
</p>
<p>The function <code>serialIndepTest()</code> returns an object of S3 class
<code>"indepTest"</code> with list components <code>subsets</code>,
<code>statistics</code>, <code>critical.values</code>, <code>pvalues</code>,
<code>fisher.pvalue</code> (a p-value resulting from a combination <em>à la</em>
Fisher of the subset statistic p-values), <code>tippett.pvalue</code> (a
p-value resulting from a combination <em>à la</em> Tippett of the subset
statistic p-values), <code>alpha</code> (global significance level of the
test), <code>beta</code> (1 - <code>beta</code> is the significance level per
statistic), <code>global.statistic</code> (value of the global Cramér-von
Mises statistic derived directly from the serial independence
empirical copula process &mdash; see last reference p 175) and
<code>global.statistic.pvalue</code> (corresponding p-value).
</p>
<p>The former argument <code>print.every</code> is deprecated and not
supported anymore; use <code>verbose</code> instead.
</p>


<h3>References</h3>

<p>Deheuvels, P. (1979). La fonction de dépendance empirique et ses
propriétés: un test non paramétrique d'indépendance, <em>Acad. Roy.
Belg. Bull. Cl. Sci.</em>, 5th Ser. 65:274&ndash;292.
</p>
<p>Deheuvels, P. (1981), A non parametric test for independence,
<em>Publ. Inst. Statist. Univ. Paris</em>. 26:29&ndash;50.
</p>
<p>Genest, C. and Rémillard, B. (2004)
Tests of independence and randomness based on the empirical copula
process.
<em>Test</em> <b>13</b>, 335&ndash;369.
</p>
<p>Genest, C., Quessy, J.-F., and Rémillard, B. (2006)
Local efficiency of a Cramer-von Mises test of independence.
<em>Journal of Multivariate Analysis</em> <b>97</b>, 274&ndash;294.
</p>
<p>Genest, C., Quessy, J.-F., and Rémillard, B. (2007)
Asymptotic local efficiency of Cramér-von Mises tests for multivariate
independence. <em>The Annals of Statistics</em> <b>35</b>, 166&ndash;191.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indepTest">indepTest</a></code>,
<code><a href="#topic+multIndepTest">multIndepTest</a></code>,
<code><a href="#topic+multSerialIndepTest">multSerialIndepTest</a></code>,
<code><a href="#topic+dependogram">dependogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## AR 1 process

ar &lt;-  numeric(200)
ar[1] &lt;- rnorm(1)
for (i in 2:200)
  ar[i] &lt;- 0.5 * ar[i-1] + rnorm(1)
x &lt;- ar[101:200]

## In order to test for serial independence, the first step consists
## in simulating the distribution of the test statistics under
## serial independence for the same sample size, i.e. n=100.
## As we are going to consider lags up to 3, i.e., subsets of
## {1,...,4} whose cardinality is between 2 and 4 containing {1},
## we set lag.max=3. This may take a while...

d &lt;- serialIndepTestSim(100,3)

## The next step consists in performing the test itself:

test &lt;- serialIndepTest(x,d)

## Let us see the results:

test

## Display the dependogram:

dependogram(test,print=TRUE)

## NB: In order to save d for future use, the saveRDS() function can be used.
</code></pre>

<hr>
<h2 id='setTheta'>Specify the Parameter(s) of a Copula</h2><span id='topic+setTheta'></span><span id='topic+setTheta+2Cacopula+2CANY-method'></span><span id='topic+setTheta+2Ccopula+2CANY-method'></span><span id='topic+setTheta+2CXcopula+2CANY-method'></span><span id='topic+setTheta+2Couter_nacopula+2Cnumeric-method'></span><span id='topic+setTheta+2CellipCopula+2CANY-method'></span><span id='topic+setTheta+2CkhoudrajiCopula+2CANY-method'></span><span id='topic+setTheta+2CmixCopula+2CANY-method'></span>

<h3>Description</h3>

<p>Set or change the parameter <code class="reqn">\theta</code> (<code>theta</code>) of
a copula.  The name &lsquo;theta&rsquo; has been from its use in (nested)
Archimedean copulas, where <code>x</code> is of class
<code>"<a href="#topic+acopula-class">acopula</a>"</code> or
<code>"<a href="#topic+outer_nacopula-class">outer_nacopula</a>"</code>.  This is used for constructing
copula models with specified parameter, as, for example, in
<code><a href="#topic+onacopula">onacopula</a>()</code>, or also <code><a href="#topic+gofCopula">gofCopula</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTheta(x, value, na.ok = TRUE, noCheck = FALSE, freeOnly = TRUE, ...)

## S4 method for signature 'acopula,ANY'
setTheta(x, value, na.ok = TRUE, noCheck = FALSE, freeOnly = TRUE, ...)
## S4 method for signature 'copula,ANY'
setTheta(x, value, na.ok = TRUE, noCheck = FALSE, freeOnly = TRUE, ...)
## S4 method for signature 'Xcopula,ANY'
setTheta(x, value, na.ok = TRUE, noCheck = FALSE, freeOnly = TRUE, ...)
## S4 method for signature 'outer_nacopula,numeric'
setTheta(x, value, na.ok = TRUE, noCheck = FALSE, freeOnly = TRUE, ...)
## S4 method for signature 'khoudrajiCopula,ANY'
setTheta(x, value, na.ok = TRUE, noCheck = FALSE, freeOnly = TRUE, ...)

## S4 method for signature 'mixCopula,ANY'
setTheta(x, value, na.ok = TRUE, noCheck = FALSE, freeOnly = TRUE,
         treat.negative = c("set.0", "warn.set0", "stop"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setTheta_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+Copula-class">Copula</a></code>, i.e., any
copula from package <span class="pkg">copula</span>.</p>
</td></tr>
<tr><td><code id="setTheta_+3A_value">value</code></td>
<td>
<p>parameter value or vector, <code><a href="base.html#topic+numeric">numeric</a></code> or
<code><a href="base.html#topic+NA">NA</a></code> (when <code>na.ok</code> is true), corresponding to the
<em>&ldquo;free&rdquo;</em> parameters.</p>
</td></tr>
<tr><td><code id="setTheta_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
<tr><td><code id="setTheta_+3A_na.ok">na.ok</code></td>
<td>
<p>logical indicating if <code><a href="base.html#topic+NA">NA</a></code> values are ok for
<code>theta</code>.</p>
</td></tr>
<tr><td><code id="setTheta_+3A_nocheck">noCheck</code></td>
<td>
<p>logical indicating if parameter constraint checks should
be skipped.</p>
</td></tr>
<tr><td><code id="setTheta_+3A_freeonly">freeOnly</code></td>
<td>
<p>logical indicating that only non-fixed aka
&ldquo;free&rdquo; parameters are to be set.  If true as by default,
<code>setTheta()</code> modifies only the free parameters of the copula;
see also <code><a href="#topic+fixParam">fixParam</a></code>.</p>
</td></tr>
<tr><td><code id="setTheta_+3A_treat.negative">treat.negative</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string indicating how
negative mixture weights should be handled.  If not <code>"stop"</code>
which produces an error via <code><a href="base.html#topic+stop">stop</a></code>, negative mixture
weights are replaced by zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <span class="rlang"><b>R</b></span> object of the same class as <code>x</code>, with the main parameter (vector)
(often called <code>theta</code>) set to <code>value</code>.
</p>


<h3>See Also</h3>

<p>the &ldquo;inverse&rdquo; function, a &ldquo;getter&rdquo; method, is
<code><a href="#topic+getTheta">getTheta</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myC &lt;- setTheta(copClayton, 0.5)
myC
## Frank copula with Kendall's tau = 0.8 :
(myF.8 &lt;- setTheta(copFrank, iTau(copFrank, tau = 0.8)))

# negative theta is ok for dim = 2 :
myF &lt;- setTheta(copFrank, -2.5, noCheck=TRUE)
myF@tau(myF@theta) # -0.262

myT &lt;- setTheta(tCopula(df.fixed=TRUE), 0.7)
stopifnot(all.equal(myT, tCopula(0.7, df.fixed=TRUE),
                    check.environment=FALSE, tolerance=0))

(myT2 &lt;- setTheta(tCopula(dim=3, df.fixed=TRUE), 0.7))
## Setting 'rho' and 'df'  --- for default df.fixed=FALSE :
(myT3 &lt;- setTheta(tCopula(dim=3), c(0.7, 4)))
</code></pre>

<hr>
<h2 id='show-methods'>Methods for 'show()' in Package 'copula'</h2><span id='topic+show-methods'></span><span id='topic+show+2CnormalCopula-method'></span><span id='topic+show+2CtCopula-method'></span><span id='topic+show+2CparCopula-method'></span><span id='topic+show+2CfitCopula-method'></span><span id='topic+show+2CfitMvdc-method'></span>

<h3>Description</h3>

<p>Methods for function <code><a href="methods.html#topic+show">show</a></code> in package <span class="pkg">copula</span>.
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;parCopula&quot;</dt><dd><p>see <code><a href="#topic+Copula">Copula</a></code>. </p>
</dd>
<dt>object = &quot;fitMvdc&quot;</dt><dd><p>(see <code><a href="#topic+fitMvdc">fitMvdc</a></code>): and</p>
</dd>
<dt>object = &quot;fitCopula&quot;</dt><dd><p>(see <code><a href="#topic+fitCopula">fitCopula</a></code>): these call the
(hidden) <code><a href="base.html#topic+print">print</a></code> method, with its default argument.
Using <code><a href="base.html#topic+print">print</a>()</code> instead, allows to set <code>digits</code>, e.g.</p>
</dd>
<dt>object = &quot;fitMvdc&quot;</dt><dd><p>see <code><a href="#topic+fitCopula">fitCopula</a></code>. </p>
</dd>
</dl>

<hr>
<h2 id='Sibuya'>Sibuya Distribution - Sampling and Probabilities</h2><span id='topic+Sibuya'></span><span id='topic+rSibuya'></span><span id='topic+pSibuya'></span><span id='topic+dSibuya'></span><span id='topic+rSibuyaR'></span><span id='topic+dsumSibuya'></span>

<h3>Description</h3>

<p>The Sibuya distribution <code class="reqn">\mathrm{Sib}(\alpha)</code> can be
defined by its Laplace transform
</p>
<p style="text-align: center;"><code class="reqn">1-(1-\exp(-t))^\alpha,\ t\in[0,\infty),</code>
</p>

<p>its distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(k)=1-(-1)^k{\alpha-1\choose k}=1-\frac{1}{kB(k,1-\alpha)},\
    k\in\mathbf{N}</code>
</p>

<p>(where <code class="reqn">B</code> denotes the beta function) or its probability
mass function </p>
<p style="text-align: center;"><code class="reqn">p_k={\alpha\choose k}(-1)^{k-1},\ k\in\mathbf{N},
  </code>
</p>

<p>where <code class="reqn">\alpha\in(0,1]</code>.
</p>
<p><code>pSibuya</code> evaluates the distribution function.
</p>
<p><code>dSibuya</code> evaluates the probability mass function.
</p>
<p><code>rSibuya</code> generates random variates from
<code class="reqn">\mathrm{Sib}(\alpha)</code> with
the algorithm described in Hofert (2011), Proposition 3.2.
</p>
<p><code>dsumSibuya</code> gives the probability mass function of the
<code class="reqn">n</code>-fold convolution of Sibuya variables, that is, the sum of <code class="reqn">n</code>
independent Sibuya random variables,
<code class="reqn">S = \sum_{i=1}^n X_i</code>, where
<code class="reqn">X_i \sim \mathrm{Sib}(\alpha)</code>.
</p>
<p>This probability mass function can be shown (see Hofert
(2010, pp. 99)) to be
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^n{n\choose j}{j\alpha\choose k} (-1)^{k-j},\
    k\in\{n,n+1,\dots\}.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>rSibuya(n, alpha)
dSibuya(x, alpha, log=FALSE)
pSibuya(x, alpha, lower.tail=TRUE, log.p=FALSE)

dsumSibuya(x, n, alpha,
           method=c("log", "direct", "diff", "exp.log",
                    "Rmpfr", "Rmpfr0", "RmpfrM", "Rmpfr0M"),
           mpfr.ctrl = list(minPrec = 21, fac = 1.25, verbose=TRUE),
           log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sibuya_+3A_n">n</code></td>
<td>

<p>for <code>rSibuya</code>: sample size, that is, length of the resulting
vector of random variates.
<br />
for <code>dsumSibuya</code>: the number <code class="reqn">n</code> of summands.
</p>
</td></tr>
<tr><td><code id="Sibuya_+3A_alpha">alpha</code></td>
<td>
<p>parameter in <code class="reqn">(0,1]</code>.</p>
</td></tr>
<tr><td><code id="Sibuya_+3A_x">x</code></td>
<td>
<p>vector of <code><a href="base.html#topic+integer">integer</a></code> values (&ldquo;quantiles&rdquo;)
<code class="reqn">x</code> at which to compute the probability mass or cumulative probability.</p>
</td></tr>
<tr><td><code id="Sibuya_+3A_log">log</code>, <code id="Sibuya_+3A_log.p">log.p</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>; if TRUE, probabilities p are
given as log(p).</p>
</td></tr>
<tr><td><code id="Sibuya_+3A_lower.tail">lower.tail</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>; if TRUE (the default), probabilities
are <code class="reqn">P(X \le x)</code>, otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="Sibuya_+3A_method">method</code></td>
<td>
<p>character string specifying which computational method is to be
applied.  Implemented are:
</p>

<dl>
<dt><code>"log"</code></dt><dd><p>evaluates the logarithm of the sum
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^n {n\choose j}{j\alpha\choose x} (-1)^{x-j}</code>
</p>

<p>in a numerically stable way;</p>
</dd>
<dt><code>"direct"</code></dt><dd><p>directly evaluates the sum;</p>
</dd>
<dt><code>"Rmpfr*"</code></dt><dd><p>are as <code>method="direct"</code> but use
high-precision arithmetic; <code>"Rmpfr"</code> and <code>"Rmpfr0"</code> return
<code><a href="base.html#topic+double">double</a></code>s whereas <code>"RmpfrM"</code> and <code>"Rmpfr0M"</code> give
<code><a href="Rmpfr.html#topic+mpfr">mpfr</a></code> high-precision numbers.
Whereas <code>"Rmpfr"</code> and <code>"RmpfrM"</code> each adapt to high
enough precision, the <code>"Rmpfr0*"</code> ones do not adapt.<br />
For all <code>"Rmpfr*"</code> methods, <code>alpha</code> can be set to a
<code><a href="Rmpfr.html#topic+mpfr-class">mpfr</a></code> number of specified
precision and this will determine the precision of all parts of
the internal computations.
</p>
</dd>
<dt><code>"diff"</code></dt><dd><p>interprets the sum as a forward difference
and computes it via <code>diff</code>;</p>
</dd>
<dt><code>"exp.log"</code></dt><dd><p>is as <code>method="log"</code> but without
numerically stable evaluation (not recommended, use with care).</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="Sibuya_+3A_mpfr.ctrl">mpfr.ctrl</code></td>
<td>
<p>for <code>method = "Rmpfr"</code> or <code>"RmpfrM"</code> only: a
list of
<br /> <code>minPrec</code>: minimal (estimated) precision in bits,
<br /> <code>fac</code>: factor with which current precision is multiplied if
it is not sufficient.
<br /> <code>verbose</code>: determining if and how much is printed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Sibuya distribution has <b>no</b> finite moments, that is, specifically
infinite mean and variance.
</p>
<p>For documentation and didactical purposes, <code>rSibuyaR</code> is a pure-<span class="rlang"><b>R</b></span>
implementation of <code>rSibuya</code>, of course slower than <code>rSibuya</code>
as the latter is implemented in C.
</p>
<p>Note that the sum to evaluate for <code>dsumSibuya</code> is numerically
highly challenging, even already for small
<code class="reqn">\alpha</code> values (for example, <code class="reqn">n \ge 10</code>),
and therefore should be used with care.  It may require high-precision
arithmetic which can be accessed with <code>method="Rmpfr"</code> (and the
<a href="https://CRAN.R-project.org/package=Rmpfr"><span class="pkg">Rmpfr</span></a> package).
</p>


<h3>Value</h3>


<dl>
<dt>rSibuya:</dt><dd><p>A vector of positive <code><a href="base.html#topic+integer">integer</a></code>s of
length <code>n</code> containing the generated random variates.</p>
</dd>
<dt>dSibuya, pSibuya:</dt><dd><p>a vector of
probabilities of the same length as <code>x</code>.</p>
</dd>
<dt>dsumSibuya:</dt><dd><p>a vector of probabilities, positive if and only if
<code>x &gt;= n</code> and of the same length as <code>x</code> (or <code>n</code> if
that is longer).</p>
</dd>
</dl>



<h3>References</h3>

<p>Hofert, M. (2010).
<em>Sampling Nested Archimedean Copulas with Applications to CDO Pricing</em>.
Südwestdeutscher Verlag fuer Hochschulschriften AG &amp; Co. KG.
</p>
<p>Hofert, M. (2011).
Efficiently sampling nested Archimedean copulas.
<em>Computational Statistics &amp; Data Analysis</em> <b>55</b>, 57&ndash;70.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rFJoe">rFJoe</a></code> and <code><a href="#topic+rF01Joe">rF01Joe</a></code> (where <code>rSibuya</code> is
applied).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sample n random variates from a Sibuya(alpha) distribution and plot a
## histogram
n &lt;- 1000
alpha &lt;- .4
X &lt;- rSibuya(n, alpha)
hist(log(X), prob=TRUE); lines(density(log(X)), col=2, lwd=2)
</code></pre>

<hr>
<h2 id='SMI.12'>SMI Data &ndash; 141 Days in Winter 2011/2012</h2><span id='topic+SMI.12'></span><span id='topic+lSMI'></span>

<h3>Description</h3>

<p><code>SMI.12</code> contains the close prices of all 20 constituents of
the Swiss Market Index (SMI) from 2011-09-09 to 2012-03-28.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SMI.12)
</code></pre>


<h3>Format</h3>

<p><code>SMI.12</code> is conceptually a multivariate time series,
here simply stored as <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+matrix">matrix</a></code>,
where the <code><a href="base.html#topic+rownames">rownames</a></code> are dates (of week days).
</p>
<p>The format is:
</p>
<p>num [1:141, 1:20] 16.1 15.7 15.7 16.1 16.6 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : chr [1:141] &quot;2011-09-09&quot; &quot;2011-09-12&quot; &quot;2011-09-13&quot; &quot;2011-09-14&quot; ...
..$ : chr [1:20] &quot;ABBN&quot; &quot;ATLN&quot; &quot;ADEN&quot; &quot;CSGN&quot; ...
</p>
<p>... from 2011-09-09 to 2012-03-28
</p>
<p><code>lSMI</code> is the list of the original data (<em>before</em> <code>NA</code>
&ldquo;imputation&rdquo;).
</p>


<h3>Source</h3>

<p>The data was drawn from Yahoo! Finance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SMI.12)
## maybe
head(SMI.12)

str(D.12 &lt;- as.Date(rownames(SMI.12)))
summary(D.12)

matplot(D.12, SMI.12, type="l", log = "y",
        main = "The 20 SMI constituents  (2011-09 -- 2012-03)",
        xaxt="n", xlab = "2011  /  2012")
Axis(D, side=1)



if(FALSE) { ##--- This worked up to mid 2012, but no longer ---
 begSMI &lt;- "2011-09-09"
 endSMI &lt;- "2012-03-28"
 ##-- read *public* data ------------------------------
 stopifnot(require(zoo), # -&gt; to access all the zoo methods
           require(tseries))
 symSMI &lt;- c("ABBN.VX","ATLN.VX","ADEN.VX","CSGN.VX","GIVN.VX","HOLN.VX",
	     "BAER.VX","NESN.VX","NOVN.VX","CFR.VX", "ROG.VX", "SGSN.VX",
	     "UHR.VX", "SREN.VX","SCMN.VX","SYNN.VX","SYST.VX","RIGN.VX",
	     "UBSN.VX","ZURN.VX")
 lSMI &lt;- sapply(symSMI, function(sym)
		get.hist.quote(instrument = sym, start= begSMI, end= endSMI,
			       quote = "Close", provider = "yahoo",
			       drop=TRUE))
 ## check if stock data have the same length for each company.
 sapply(lSMI, length)
 ## "concatenate" all:
 SMIo &lt;- do.call(cbind, lSMI)
 ## and fill in the NAs :
 SMI.12 &lt;- na.fill(SMIo, "extend")
 colnames(SMI.12) &lt;- sub("\\.VX", "", colnames(SMI.12))
 SMI.12 &lt;- as.matrix(SMI.12)
}##----       --- original download

zoo.there &lt;- "package:zoo" %in% search()
if(zoo.there || require("zoo")) {
  stopifnot(identical(SMI.12,
     local({ S &lt;- as.matrix(na.fill(do.call(cbind, lSMI), "extend"))
             colnames(S) &lt;- sub("\\.VX", "", colnames(S)); S })))
  if(!zoo.there) detach("package:zoo")
}

</code></pre>

<hr>
<h2 id='splom2-methods'>Methods for Scatter Plot Matrix 'splom2' in Package 'copula'</h2><span id='topic+splom2'></span><span id='topic+splom2-methods'></span><span id='topic+splom2+2Cmatrix-method'></span><span id='topic+splom2+2Cdata.frame-method'></span><span id='topic+splom2+2CCopula-method'></span><span id='topic+splom2+2Cmvdc-method'></span>

<h3>Description</h3>

<p>Methods <code>splom2()</code> to draw scatter-plot matrices of
(random samples of) distributions from package <span class="pkg">copula</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
splom2(x, varnames = NULL, varnames.null.lab = "U",
      xlab = "", col.mat = NULL, bg.col.mat = NULL, ...)
## ditto an identical  'data.frame'  method

## S4 method for signature 'Copula'
splom2(x, n, ...)
## S4 method for signature 'mvdc'
splom2(x, n, varnames.null.lab = "X", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splom2-methods_+3A_x">x</code></td>
<td>
<p>a <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code>,
<code>"<a href="methods.html#topic+data.frame-class">data.frame</a>"</code>, <code>"<a href="#topic+Copula-class">Copula</a>"</code> or
a <code>"<a href="#topic+mvdc-class">mvdc</a>"</code> object.</p>
</td></tr>
<tr><td><code id="splom2-methods_+3A_n">n</code></td>
<td>
<p>when <code>x</code> is not matrix-like: The sample size of the
random sample drawn from <code>x</code>.</p>
</td></tr>
<tr><td><code id="splom2-methods_+3A_varnames">varnames</code></td>
<td>
<p>the variable names, typically unspecified.</p>
</td></tr>
<tr><td><code id="splom2-methods_+3A_varnames.null.lab">varnames.null.lab</code></td>
<td>
<p>the <code><a href="base.html#topic+character">character</a></code> string
determining the &ldquo;base name&rdquo; of the variable labels in case
<code>varnames</code> is <code>NULL</code> and <code>x</code> does not have all column names given.</p>
</td></tr>
<tr><td><code id="splom2-methods_+3A_xlab">xlab</code></td>
<td>
<p>the x-axis label.</p>
</td></tr>
<tr><td><code id="splom2-methods_+3A_col.mat">col.mat</code></td>
<td>
<p>a matrix of colors (or one color) for the plot symbols;
if <code>NULL</code> (as by default),
<code><a href="lattice.html#topic+trellis.par.get">trellis.par.get</a>("plot.symbol")$col</code> is used
for all symbols.
(Note that in <span class="pkg">copula</span> version 0.999-15, this was not true; instead
<code>"black"</code> was used.)</p>
</td></tr>
<tr><td><code id="splom2-methods_+3A_bg.col.mat">bg.col.mat</code></td>
<td>
<p>a matrix of colors for the background (the default is the
setting as obtained from
<code><a href="lattice.html#topic+trellis.par.get">trellis.par.get</a>("background")$col</code>).</p>
</td></tr>
<tr><td><code id="splom2-methods_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the underlying
<code><a href="lattice.html#topic+splom">splom</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>From <code><a href="lattice.html#topic+splom">splom</a>()</code>, an <span class="rlang"><b>R</b></span> object of class <code>"trellis"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairs2">pairs2</a>()</code> for a similar function (for matrices and data
frames) based on <code><a href="graphics.html#topic+pairs">pairs</a>()</code>.
</p>
<p>The <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>-based <code><a href="#topic+cloud2-methods">cloud2-methods</a></code> for 3D data, and
<code><a href="#topic+wireframe2-methods">wireframe2-methods</a></code> and
<code><a href="#topic+contourplot2-methods">contourplot2-methods</a></code> for functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For 'matrix' objects
## Create a 100 x 7 matrix of random variates from a t distribution
## with four degrees of freedom and plot the generated data
n &lt;- 1000 # sample size
d &lt;- 3 # dimension
nu &lt;- 4 # degrees of freedom
tau &lt;- 0.5 # Kendall's tau
th &lt;- iTau(tCopula(df = nu), tau) # corresponding parameter
cop &lt;- tCopula(th, dim = d, df = nu) # define copula object
set.seed(271)
U &lt;- rCopula(n, copula = cop)
splom2(U)

## For 'copula' objects
set.seed(271)
splom2(cop, n = n) # same as above

## For 'rotCopula' objects: ---&gt; Examples in rotCopula

## For 'mvdc' objects
mvNN &lt;- mvdc(cop, c("norm", "norm", "exp"),
             list(list(mean = 0, sd = 1), list(mean = 1), list(rate = 2)))
splom2(mvNN, n = n)
</code></pre>

<hr>
<h2 id='Stirling'>Eulerian and Stirling Numbers of First and Second Kind</h2><span id='topic+Eulerian'></span><span id='topic+Stirling1'></span><span id='topic+Stirling2'></span><span id='topic+Eulerian.all'></span><span id='topic+Stirling1.all'></span><span id='topic+Stirling2.all'></span>

<h3>Description</h3>

<p>Compute Eulerian numbers and Stirling numbers of the first and second
kind, possibly vectorized for all <code class="reqn">k</code> &ldquo;at once&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Stirling1(n, k)
Stirling2(n, k, method = c("lookup.or.store", "direct"))
Eulerian (n, k, method = c("lookup.or.store", "direct"))

Stirling1.all(n)
Stirling2.all(n)
Eulerian.all (n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Stirling_+3A_n">n</code></td>
<td>
<p>positive integer (<code>0</code> is allowed for <code>Eulerian()</code>).</p>
</td></tr>
<tr><td><code id="Stirling_+3A_k">k</code></td>
<td>
<p>integer in <code>0:n</code>.</p>
</td></tr>
<tr><td><code id="Stirling_+3A_method">method</code></td>
<td>
<p>for <code>Eulerian()</code> and <code>Stirling2()</code>, string
specifying the method to be used.  <code>"direct"</code> uses the explicit
formula (which may suffer from some cancelation for &ldquo;large&rdquo;
<code>n</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Eulerian numbers:<br />
<code class="reqn">A(n,k) =</code> the number of permutations of 1,2,...,n with exactly <code class="reqn">k</code>
ascents (or exactly <code class="reqn">k</code> descents).
</p>
<p>Stirling numbers of the first kind:<br />
<code class="reqn">s(n,k) = (-1)^{n-k}</code> times
the number of permutations of 1,2,...,n with exactly <code class="reqn">k</code> cycles.
</p>
<p>Stirling numbers of the second kind:<br />
<code class="reqn">S^{(k)}_n</code> is the number of ways of partitioning a set
of <code class="reqn">n</code> elements into <code class="reqn">k</code> non-empty subsets.
</p>


<h3>Value</h3>

<p><code class="reqn">A(n,k)</code>, <code class="reqn">s(n,k)</code> or <code class="reqn">S(n,k) = S^{(k)}_n</code>, respectively.
</p>
<p><code>Eulerian.all(n)</code> is the same as <code>sapply(0:(n-1), Eulerian, n=n)</code>
(for <code class="reqn">n &gt; 0</code>), <br />
<code>Stirling1.all(n)</code> is the same as <code>sapply(1:n, Stirling1, n=n)</code>,
and<br />
<code>Stirling2.all(n)</code> is the same as <code>sapply(1:n, Stirling2, n=n)</code>,
but more efficient.
</p>


<h3>Note</h3>

<p>For typical double precision arithmetic,<br />
<code>Eulerian*(n, *)</code> overflow (to <code>Inf</code>) for <code class="reqn">n \ge 172</code>,<br />
<code>Stirling1*(n, *)</code> overflow (to <code class="reqn">\pm</code><code>Inf</code>) for
<code class="reqn">n \ge 171</code>, and<br />
<code>Stirling2*(n, *)</code> overflow (to <code>Inf</code>) for <code class="reqn">n \ge 220</code>.
</p>


<h3>References</h3>

<p><b>Eulerians:</b>
</p>
<p>NIST Digital Library of Mathematical Functions,
26.14: <a href="https://dlmf.nist.gov/26.14">https://dlmf.nist.gov/26.14</a>
</p>
<p><b>Stirling numbers:</b>
</p>
<p>Abramowitz and Stegun
24,1,4 (p. 824-5 ; Table 24.4, p.835);
Closed Form : p.824 &quot;C.&quot;
</p>
<p>NIST Digital Library of Mathematical Functions,
26.8: <a href="https://dlmf.nist.gov/26.8">https://dlmf.nist.gov/26.8</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Stirling1(7,2)
Stirling2(7,3)

Stirling1.all(9)
Stirling2.all(9)
</code></pre>

<hr>
<h2 id='tauAMH'>Ali-Mikhail-Haq (&quot;AMH&quot;)'s and Joe's Kendall's Tau</h2><span id='topic+tauAMH'></span><span id='topic+tauJoe'></span>

<h3>Description</h3>

<p>Compute Kendall's Tau of an Ali-Mikhail-Haq (&quot;AMH&quot;) or Joe Archimedean
copula with parameter <code>theta</code>.  In both cases, analytical
expressions are available, but need alternatives in some cases.
</p>

<dl>
<dt><code>tauAMH()</code>:</dt><dd><p>Analytically, given as
</p>
<p style="text-align: center;"><code class="reqn">1-\frac{2((1-\theta)^2\log(1-\theta) + \theta)}{3\theta^2},</code>
</p>

<p>for <code>theta</code><code class="reqn">=\theta</code>;
numerically, care has to be taken when <code class="reqn">\theta \to 0</code>,
avoiding accuracy loss already, for example, for <code class="reqn">\theta</code> as
large as <code>theta = 0.001</code>.</p>
</dd>
<dt><code>tauJoe()</code>:</dt><dd>
<p>Analytically,
</p>
<p style="text-align: center;"><code class="reqn">1- 4\sum_{k=1}^\infty\frac{1}{k(\theta k+2)(\theta(k-1)+2)},</code>
</p>

<p>the infinite sum can be expressed by three <code class="reqn">\psi()</code>
(<code><a href="base.html#topic+psigamma">psigamma</a></code>) function terms.
</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>tauAMH(theta)
tauJoe(theta, method = c("hybrid", "digamma", "sum"), noTerms=446)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tauAMH_+3A_theta">theta</code></td>
<td>
<p>numeric vector with values in <code class="reqn">[-1,1]</code> for AMH, or
<code class="reqn">[0.238734, Inf)</code> for Joe.</p>
</td></tr>
<tr><td><code id="tauAMH_+3A_method">method</code></td>
<td>
<p>string specifying the method for <code>tauJoe()</code>.  Use the
default, unless for research about the method.  Up to <span class="pkg">copula</span>
version 0.999-0, the only (implicit) method was <code>"sum"</code>.</p>
</td></tr>
<tr><td><code id="tauAMH_+3A_noterms">noTerms</code></td>
<td>
<p>the number of summation terms for the <code>"sum"</code>
method; its default, <code>446</code> gives an absolute error smaller
than <code class="reqn">10^{-5}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>tauAMH()</code>:</dt><dd>
<p>For small <code>theta</code> (<code class="reqn">=\theta</code>), we use Taylor series
approximations of up to order 7,
</p>
<p style="text-align: center;"><code class="reqn">\tau_A(\theta) = \frac{2}{9}\theta\Bigl(1 + \theta\Bigl(\frac 1 4 +
      \frac{\theta}{10}\Bigl(1 + \theta\Bigl(\frac 1 2 + \theta \frac 2
      7\Bigr) \Bigr)\Bigr)\Bigr) + O(\theta^6),</code>
</p>

<p>where we found that dropping the last two terms (e.g., only using 5 terms
from the <code class="reqn">k=7</code> term Taylor polynomial) is actually numerically
advantageous.</p>
</dd>
<dt><code>tauJoe()</code>:</dt><dd>
<p>The <code>"sum"</code> method simply replaces the infinite sum by a finite
sum (with <code>noTerms</code> terms.  The more accurate or faster methods,
use analytical summation formulas, using the <code><a href="base.html#topic+digamma">digamma</a></code>
aka <code class="reqn">\psi</code> function, see, e.g.,
<a href="https://en.wikipedia.org/wiki/Digamma_function#Series_formula">https://en.wikipedia.org/wiki/Digamma_function#Series_formula</a>.
</p>
<p>The smallest sensible <code class="reqn">\theta</code> value, i.e., <code>th</code> for which
<code>tauJoe(th) == -1</code> is easily determined via
<code>str(uniroot(function(th) tauJoe(th)-(-1), c(0.1, 0.3), tol = 1e-17), digits=12)</code>
to be <code>0.2387339899</code>.</p>
</dd>
</dl>


<h3>Value</h3>

<p>a vector of the same length as <code>theta</code> (<code class="reqn">= \theta</code>), with
<code class="reqn">\tau</code> values
</p>
<p>for <code>tauAMH</code>: in <code class="reqn">[(5 - 8 log 2)/3, 1/3] ~= [-0.1817, 0.3333]</code>,
of <code class="reqn">\tau_A(\theta) = 1 -
    2(\theta+(1-\theta)^2\log(1-\theta))/(3\theta^2)</code>,
numerically accurately, to at least around 12 decimal digits.
</p>
<p>for  <code>tauJoe</code>: in [-1,1].
</p>


<h3>See Also</h3>

<p><code><a href="#topic+acopula-families">acopula-families</a></code>, and their class definition,
<code>"<a href="#topic+acopula-class">acopula</a>"</code>.  <code><a href="#topic+etau">etau</a>()</code> for
method-of-moments estimators based on Kendall's tau.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tauAMH(c(0, 2^-40, 2^-20))
curve(tauAMH,  0, 1)
curve(tauAMH, -1, 1)# negative taus as well
curve(tauAMH, 1e-12, 1, log="xy") # linear, tau ~= 2/9*theta in the limit

curve(tauJoe, 1,      10)
curve(tauJoe, 0.2387, 10)# negative taus (*not* valid for Joe: no 2-monotone psi()!)
</code></pre>

<hr>
<h2 id='uranium'>Uranium Exploration Dataset of Cook &amp; Johnson (1986)</h2><span id='topic+uranium'></span>

<h3>Description</h3>

<p>These data consist of log concentrations of 7 chemical elements in 655
water samples collected near Grand Junction, CO (from the Montrose
quad-rangle of Western Colorado).  Concentrations were
measured for the following elements: Uranium (U), Lithium (Li), Cobalt
(Co), Potassium (K), Cesium (Cs), Scandium (Sc), And Titanium (Ti).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(uranium, package="copula")</code></pre>


<h3>Format</h3>

<p>A data frame with 655 observations of the following 7 variables:
</p>

<dl>
<dt><code>U</code></dt><dd><p>(numeric) log concentration of Uranium.</p>
</dd>
<dt><code>Li</code></dt><dd><p>(numeric) log concentration of Lithium.</p>
</dd>
<dt><code>Co</code></dt><dd><p>(numeric) log concentration of Colbalt.</p>
</dd>
<dt><code>K</code></dt><dd><p>(numeric) log concentration of Potassium.</p>
</dd>
<dt><code>Cs</code></dt><dd><p>(numeric) log concentration of Cesium.</p>
</dd>
<dt><code>Sc</code></dt><dd><p>(numeric) log concentration of Scandum.</p>
</dd>
<dt><code>Ti</code></dt><dd><p>(numeric) log concentration of Titanium.</p>
</dd>
</dl>



<h3>References</h3>

<p>Cook, R. D.  and  Johnson, M. E. (1986)
Generalized BurrParetologistic distributions with applications to a
uranium exploration data set.
<em>Technometrics</em> <b>28</b>, 123&ndash;131.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(uranium)
</code></pre>

<hr>
<h2 id='varianceReduction'>Variance-Reduction Methods</h2><span id='topic+rAntitheticVariates'></span><span id='topic+rLatinHypercube'></span>

<h3>Description</h3>

<p>Computing antithetic variates or Latin hypercube samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rAntitheticVariates(u)
rLatinHypercube(u, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varianceReduction_+3A_u">u</code></td>
<td>
<p>a <code class="reqn">n\times d</code>-<code><a href="base.html#topic+matrix">matrix</a></code> (or
<code class="reqn">d</code>-<code><a href="base.html#topic+vector">vector</a></code>) of random variates in the unit hypercube.</p>
</td></tr>
<tr><td><code id="varianceReduction_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the underlying <code><a href="base.html#topic+rank">rank</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rAntitheticVariates()</code> takes any copula sample <code class="reqn">u</code>, builds
<code class="reqn">1-u</code>, and returns the two matrices in the form of an array; this
can be used for the variance-reduction method of (componentwise)
antithetic variates.
</p>
<p><code>rLatinHypercube()</code> takes any copula sample,
shifts its marginal ranks minus 1 by standard uniforms and then
divides by the sample size in order to obtain a Latin hypercubed
sample.
</p>


<h3>Value</h3>


<dl>
<dt><code>rAntitheticVariates()</code></dt><dd><p><code><a href="base.html#topic+array">array</a></code> of dimension
<code class="reqn">n\times d\times 2</code>, say <code>r</code>, where <code>r[,,1]</code>
contains the original sample <code>u</code> and <code>r[,,2]</code> contains
the sample <code>1-u</code>.</p>
</dd>
<dt><code>rLatinHypercube()</code></dt><dd><p><code><a href="base.html#topic+matrix">matrix</a></code> of the same
dimensions as <code>u</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Cambou, M., Hofert, M. and Lemieux, C. (2016).
Quasi-random numbers for copula models.
<em>Statistics and Computing</em>, 1&ndash;23.
</p>
<p>Packham, N. and Schmidt, W. M. (2010).
Latin hypercube sampling with dependence and applications in finance.
<em>Journal of Computational Finance</em> <b>13</b>(3), 81&ndash;111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### 1 Basic plots ##############################################################

## Generate data from a Gumbel copula
cop &lt;- gumbelCopula(iTau(gumbelCopula(), tau = 0.5))
n &lt;- 1e4
set.seed(271)
U &lt;- rCopula(n, copula = cop)

## Transform the sample to a Latin Hypercube sample
U.LH &lt;- rLatinHypercube(U)

## Plot
## Note: The 'variance-reducing property' is barely visible, but that's okay
layout(rbind(1:2))
plot(U,    xlab = quote(U[1]), ylab = quote(U[2]), pch = ".", main = "U")
plot(U.LH, xlab = quote(U[1]), ylab = quote(U[2]), pch = ".", main = "U.LH")
layout(1) # reset layout

## Transform the sample to an Antithetic variate sample
U.AV &lt;- rAntitheticVariates(U)
stopifnot(identical(U.AV[,,1],  U ),
          identical(U.AV[,,2], 1-U))

## Plot original sample and its corresponding (componentwise) antithetic variates
layout(rbind(1:2))
plot(U.AV[,,1], xlab = quote(U[1]), ylab = quote(U[2]), pch=".", main= "U")
plot(U.AV[,,2], xlab = quote(U[1]), ylab = quote(U[2]), pch=".", main= "1 - U")
layout(1) # reset layout


### 2 Small variance-reduction study for exceedance probabilities ##############

## Auxiliary function for approximately computing P(U_1 &gt; u_1,..., U_d &gt; u_d)
## by Monte Carlo simulation based on pseudo-random numbers, Latin hypercube
## sampling and quasi-random numbers.
sProb &lt;- function(n, copula, u)
{
    d &lt;- length(u)
    stopifnot(n &gt;= 1, inherits(copula, "Copula"), 0 &lt; u, u &lt; 1,
              d == dim(copula))
    umat &lt;- rep(u, each = n)
    ## Pseudo-random numbers
    U &lt;- rCopula(n, copula = copula)
    PRNG &lt;- mean(rowSums(U &gt; umat) == d)
    ## Latin hypercube sampling (based on the recycled 'U')
    U. &lt;- rLatinHypercube(U)
    LHS &lt;- mean(rowSums(U. &gt; umat) == d)
    ## Quasi-random numbers
    U.. &lt;- cCopula(sobol(n, d = d, randomize = TRUE), copula = copula,
                   inverse = TRUE)
    QRNG &lt;- mean(rowSums(U.. &gt; umat) == d)
    ## Return
    c(PRNG = PRNG, LHS = LHS, QRNG = QRNG)
}

## Simulate the probabilities of falling in (u_1,1] x ... x (u_d,1]
library(qrng) # for quasi-random numbers
(Xtras &lt;- copula:::doExtras()) # determine whether examples will be extra (long)
B &lt;- if(Xtras)  500 else 100 # number of replications
n &lt;- if(Xtras) 1000 else 200 # sample size
d &lt;- 2 # dimension; note: for d &gt; 2, the true value depends on the seed
nu &lt;- 3 # degrees of freedom
th &lt;- iTau(tCopula(df = nu), tau = 0.5) # correlation parameter
cop &lt;- tCopula(param = th, dim = d, df = nu) # t copula
u &lt;- rep(0.99, d) # lower-left endpoint of the considered cube
set.seed(42) # for reproducibility
true &lt;- prob(cop, l = u, u = rep(1, d)) # true exceedance probability
system.time(res &lt;- replicate(B, sProb(n, copula = cop, u = u)))

## "abbreviations":
PRNG &lt;- res["PRNG",]
LHS  &lt;- res["LHS" ,]
QRNG &lt;- res["QRNG",]

## Compute the variance-reduction factors and % improvements
vrf  &lt;- var(PRNG) / var(LHS)                    # variance reduction factor w.r.t. LHS
vrf. &lt;- var(PRNG) / var(QRNG)                   # variance reduction factor w.r.t. QRNG
pim  &lt;- (var(PRNG) - var(LHS)) / var(PRNG) *100 # improvement w.r.t. LHS
pim. &lt;- (var(PRNG) - var(QRNG))/ var(PRNG) *100 # improvement w.r.t. QRNG

## Boxplot
boxplot(list(PRNG = PRNG, LHS = LHS, QRNG = QRNG), notch = TRUE,
        main = substitute("Simulated exceedance probabilities" ~
                              P(bold(U) &gt; bold(u))~~ "for a" ~ t[nu.]~"copula",
                          list(nu. = nu)),
        sub = sprintf(
           "Variance-reduction factors and %% improvements: %.1f (%.0f%%), %.1f (%.0f%%)",
            vrf, pim, vrf., pim.))
abline(h = true, lty = 3) # true value
mtext(sprintf("B = %d replications with n = %d and d = %d", B, n, d), side = 3)
</code></pre>

<hr>
<h2 id='wireframe2-methods'>Perspective Plots - 'wireframe2' in Package 'copula'</h2><span id='topic+wireframe2'></span><span id='topic+wireframe2-methods'></span><span id='topic+wireframe2+2Cmatrix-method'></span><span id='topic+wireframe2+2Cdata.frame-method'></span><span id='topic+wireframe2+2CCopula-method'></span><span id='topic+wireframe2+2Cmvdc-method'></span>

<h3>Description</h3>

<p>Generic function and methods <code>wireframe2()</code> to draw
(<a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>) <code><a href="lattice.html#topic+wireframe">wireframe</a></code> (aka
&ldquo;perspective&rdquo;) plots of two-dimensional distributions from
package <span class="pkg">copula</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
wireframe2(x,
      xlim = range(x[,1], finite = TRUE),
      ylim = range(x[,2], finite = TRUE),
      zlim = range(x[,3], finite = TRUE),
      xlab = NULL, ylab = NULL, zlab = NULL,
      alpha.regions = 0.5, scales = list(arrows = FALSE, col = "black"),
      par.settings = standard.theme(color = FALSE),
      draw.4.pCoplines = FALSE, ...)

## _identical_ method for  'data.frame'  as for  'matrix'

## S4 method for signature 'Copula'
wireframe2(x, FUN, n.grid = 26, delta = 0,
      xlim = 0:1, ylim = 0:1, zlim = NULL,
      xlab = quote(u[1]), ylab = quote(u[2]),
      zlab = list(deparse(substitute(FUN))[1], rot = 90),
      draw.4.pCoplines = identical(FUN, pCopula), ...)

## S4 method for signature 'mvdc'
wireframe2(x, FUN, n.grid = 26, xlim, ylim, zlim = NULL,
      xlab = quote(x[1]), ylab = quote(x[2]),
      zlab = list(deparse(substitute(FUN))[1], rot = 90), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wireframe2-methods_+3A_x">x</code></td>
<td>
<p>a <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code>,
<code>"<a href="methods.html#topic+data.frame-class">data.frame</a>"</code>, <code>"<a href="#topic+Copula-class">Copula</a>"</code> or
a <code>"<a href="#topic+mvdc-class">mvdc</a>"</code> object.</p>
</td></tr>
<tr><td><code id="wireframe2-methods_+3A_xlim">xlim</code>, <code id="wireframe2-methods_+3A_ylim">ylim</code>, <code id="wireframe2-methods_+3A_zlim">zlim</code></td>
<td>
<p>the x-, y- and z-axis limits.</p>
</td></tr>
<tr><td><code id="wireframe2-methods_+3A_xlab">xlab</code>, <code id="wireframe2-methods_+3A_ylab">ylab</code>, <code id="wireframe2-methods_+3A_zlab">zlab</code></td>
<td>
<p>the x-, y- and z-axis labels.</p>
</td></tr>
<tr><td><code id="wireframe2-methods_+3A_alpha.regions">alpha.regions</code></td>
<td>
<p>see <code><a href="lattice.html#topic+wireframe">wireframe</a>()</code>.</p>
</td></tr>
<tr><td><code id="wireframe2-methods_+3A_scales">scales</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> determining how the axes are drawn;
see <code><a href="lattice.html#topic+wireframe">wireframe</a>()</code>.</p>
</td></tr>
<tr><td><code id="wireframe2-methods_+3A_par.settings">par.settings</code></td>
<td>
<p>See <code><a href="lattice.html#topic+wireframe">wireframe</a>()</code>.</p>
</td></tr>
<tr><td><code id="wireframe2-methods_+3A_fun">FUN</code></td>
<td>
<p>the <code><a href="base.html#topic+function">function</a></code> to be plotted; for a &quot;copula&quot;, typically
<code><a href="#topic+dCopula">dCopula</a></code> or <code><a href="#topic+pCopula">pCopula</a></code>; for an &quot;mvdc&quot;,
rather <code><a href="#topic+dMvdc">dMvdc</a></code>, etc.  In general of the form
<code>function(x, copula)</code>.</p>
</td></tr>
<tr><td><code id="wireframe2-methods_+3A_n.grid">n.grid</code></td>
<td>
<p>the number of grid points used in each dimension.  This
can be a vector of length two, giving the number of grid points used
in x- and y-direction, respectively; the function <code>FUN</code> will be
evaluated on the corresponding (x,y)-grid.</p>
</td></tr>
<tr><td><code id="wireframe2-methods_+3A_delta">delta</code></td>
<td>
<p>a small number in <code class="reqn">[0, \frac 1 2)</code>
influencing the evaluation boundaries. The x- and y- vectors will
have the range <code>[0+delta, 1-delta]</code>, the default being <code>[0,1]</code>.</p>
</td></tr>
<tr><td><code id="wireframe2-methods_+3A_draw.4.pcoplines">draw.4.pCoplines</code></td>
<td>
<p>logical indicating if the 4 known border
segments of a copula distribution function, i.e., <code><a href="#topic+pCopula">pCopula</a></code>,
should be drawn.  If true, the line segments are drawn with
<code>col.4 = "#668b5580"</code>, <code>lwd.4 = 5</code>, and <code>lty.4 = "82"</code>
which you can modify (via the <code>...</code> below).  Applies only
when you do <em>not</em> set <code>panel.3d.wireframe</code> (via the <code>...</code>).</p>
</td></tr>
<tr><td><code id="wireframe2-methods_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the underlying <code><a href="lattice.html#topic+wireframe">wireframe</a>()</code>,
such as <code>shade</code>, <code>drape</code>, <code>aspect</code>, etc., or (if you
do not specify <code>panel.3d.wireframe</code> differently), to the
function <code><a href="lattice.html#topic+panel.3dwire">panel.3dwire</a></code> from the <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>
package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &ldquo;trellis&rdquo; as returned by <code><a href="lattice.html#topic+wireframe">wireframe</a>()</code>.
</p>


<h3>Methods</h3>

<p>Wireframe plots for objects of class <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code> ,
<code>"<a href="methods.html#topic+data.frame-class">data.frame</a>"</code>, <code>"<a href="#topic+Copula-class">Copula</a>"</code> or
<code>"<a href="#topic+mvdc-class">mvdc</a>"</code>.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+persp-methods">persp-methods</a></code> for drawing perspective plots via base graphics.
</p>
<p>The <span class="pkg">lattice</span>-based <code><a href="#topic+contourplot2-methods">contourplot2-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For 'matrix' objects
## The Frechet--Hoeffding bounds W and M
n.grid &lt;- 26
u &lt;- seq(0, 1, length.out = n.grid)
grid &lt;- expand.grid("u[1]" = u, "u[2]" = u)
W &lt;- function(u) pmax(0, rowSums(u)-1) # lower bound W
M &lt;- function(u) apply(u, 1, min) # upper bound M
x.W &lt;- cbind(grid, "W(u[1],u[2])" = W(grid)) # evaluate W on 'grid'
x.M &lt;- cbind(grid, "M(u[1],u[2])" = M(grid)) # evaluate M on 'grid'
wireframe2(x.W)
wireframe2(x.W, shade = TRUE) # plot of W
wireframe2(x.M, drape = TRUE) # plot of M

## For 'Copula' objects
cop &lt;- frankCopula(-4)
wireframe2(cop, pCopula) # the copula
wireframe2(cop, pCopula, shade = TRUE) # ditto, "shaded"
wireframe2(cop, pCopula, shade = TRUE, col = "gray60") # ditto, "shaded"+grid
wireframe2(cop, pCopula, drape = TRUE, xlab = quote(x[1])) # adjusting an axis label
wireframe2(cop, dCopula, delta=0.01) # the density
wireframe2(cop, dCopula) # =&gt; the density is set to 0 on the margins
wireframe2(cop, function(u, copula) dCopula(u, copula, log=TRUE),
           zlab = list(quote(log(c(u[1],u[2]))), rot=90), main = "dCopula(.., log=TRUE)")


## For 'mvdc' objects
mvNN &lt;- mvdc(gumbelCopula(3), c("norm", "norm"),
             list(list(mean = 0, sd = 1), list(mean = 1)))
wireframe2(mvNN, dMvdc, xlim=c(-2, 2), ylim=c(-1, 3))
</code></pre>

<hr>
<h2 id='xvCopula'>Model (copula) selection based on <code>k</code>-fold cross-validation</h2><span id='topic+xvCopula'></span>

<h3>Description</h3>

<p>Computes the leave-one-out cross-validation criterion (or a
<code>k</code>-fold version of it) for the hypothesized parametric copula
family using, by default, maximum pseudo-likelihood estimation.
</p>
<p>The leave-one-out criterion is a crossvalidated log likelihood. It is
denoted by <code class="reqn">\widehat{xv}_n</code> in Grønneberg and Hjort
(2014) and defined in equation (42) therein. When computed for several
parametric copula families, it is thus meaningful to select the family
maximizing the criterion.
</p>
<p>For <code class="reqn">k &lt; n</code>, <code class="reqn">n</code> the sample size, the <code>k</code>-fold version is
an approximation of the leave-one-out criterion that uses <code class="reqn">k</code>
randomly chosen (almost) equally sized data blocks instead of <code class="reqn">n</code>.
When <code class="reqn">n</code> is large, <code class="reqn">k</code>-fold cross-validation is considerably
faster (if <code class="reqn">k</code> is &ldquo;small&rdquo; compared to <code class="reqn">n</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xvCopula(copula, x, k = NULL, verbose = interactive(),
         ties.method = eval(formals(rank)$ties.method), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xvCopula_+3A_copula">copula</code></td>
<td>
<p>object of class <code>"<a href="#topic+copula-class">copula</a>"</code>
representing the hypothesized copula family.</p>
</td></tr>
<tr><td><code id="xvCopula_+3A_x">x</code></td>
<td>
<p>a data matrix that will be transformed to pseudo-observations.</p>
</td></tr>
<tr><td><code id="xvCopula_+3A_k">k</code></td>
<td>
<p>the number of data blocks; if <code>k = NULL</code>, <code>nrow(x)</code>
blocks are considered (which corresponds to leave-one-out
cross-validation).</p>
</td></tr>
<tr><td><code id="xvCopula_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating if progress of the cross validation
should be displayed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>.</p>
</td></tr>
<tr><td><code id="xvCopula_+3A_ties.method">ties.method</code></td>
<td>
<p>string specifying how ranks should be computed if
there are ties in any of the coordinate samples of <code>x</code> and
fitting is based on maximum pseudo-likelihood; passed
to <code><a href="#topic+pobs">pobs</a></code>.</p>
</td></tr>
<tr><td><code id="xvCopula_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+fitCopula">fitCopula</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number equal to the cross-validation criterion
multiplied by the sample size.
</p>


<h3>Note</h3>

<p>Note that <code>k</code>-fold cross-validation with <code>k &lt; n</code>
shuffles the lines of <code>x</code> prior to forming the blocks.  The
result thus depends on the value of the random seed.
</p>
<p>The default estimation method is maximum pseudo-likelihood estimation
but this can be changed if necessary along with all the other
arguments of <code><a href="#topic+fitCopula">fitCopula</a>()</code>.
</p>


<h3>References</h3>

<p>Grønneberg, S., and Hjort, N.L. (2014)
The copula information criteria.
<em>Scandinavian Journal of Statistics</em> <b>41</b>, 436&ndash;459.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitCopula">fitCopula</a>()</code> for the underlying estimation procedure and
<code><a href="#topic+gofCopula">gofCopula</a>()</code> for goodness-of-fit tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A two-dimensional data example ----------------------------------
x &lt;- rCopula(200, claytonCopula(3))


## Model (copula) selection -- takes time: each fits 200 copulas to 199 obs.
xvCopula(gumbelCopula(), x)
xvCopula(frankCopula(), x)
xvCopula(joeCopula(), x)
xvCopula(claytonCopula(), x)
xvCopula(normalCopula(), x)
xvCopula(tCopula(), x)
xvCopula(plackettCopula(), x)


## The same with 5-fold cross-validation [to save time ...]
set.seed(1) # k-fold is random (for k &lt; n) !
xvCopula(gumbelCopula(),  x, k=5)
xvCopula(frankCopula(),   x, k=5)
xvCopula(joeCopula(),     x, k=5)
xvCopula(claytonCopula(), x, k=5)
xvCopula(normalCopula(),  x, k=5)
xvCopula(tCopula(),       x, k=5)
xvCopula(plackettCopula(),x, k=5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
