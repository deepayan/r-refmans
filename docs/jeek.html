<!DOCTYPE html><html lang="en"><head><title>Help for package jeek</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jeek}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jeek-package'><p>A Fast and Scalable Joint Estimator for Integrating Additional Knowledge in</p>
Learning Multiple Related Sparse Gaussian Graphical Models</a></li>
<li><a href='#cancer'><p>Microarray data set for breast cancer</p></a></li>
<li><a href='#exampleData'><p>A simulated toy dataset that includes 2 data matrices (from 2 related</p>
tasks).</a></li>
<li><a href='#exampleDataGraph'><p>A simulated toy dataset that includes 3 igraph objects</p></a></li>
<li><a href='#jeek'><p>A Fast and Scalable Joint Estimator for Integrating Additional Knowledge in</p>
Learning Multiple Related Sparse Gaussian Graphical Models</a></li>
<li><a href='#nip_37_data'><p>NIPS word count dataset</p></a></li>
<li><a href='#plot.jeek'><p>Plot jeek result specified by user input</p></a></li>
<li><a href='#returngraph'><p>return igraph object from jeek result specified by user input</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-07-03</td>
</tr>
<tr>
<td>Title:</td>
<td>A Fast and Scalable Joint Estimator for Integrating Additional
Knowledge in Learning Multiple Related Sparse Gaussian
Graphical Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Beilun Wang &lt;bw4mw@virginia.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a fast and scalable joint estimator for integrating additional knowledge in learning multiple related sparse Gaussian Graphical Models (JEEK). The JEEK algorithm can be used to fast estimate multiple related precision matrices in a large-scale. For instance, it can identify multiple gene networks from multi-context gene expression datasets. By performing data-driven network inference from high-dimensional and heterogeneous data sets, this tool can help users effectively translate aggregated data into knowledge that take the form of graphs among entities. Please run demo(jeek) to learn the basic functions provided by this package. For further details, please read the original paper: Beilun Wang, Arshdeep Sekhon, Yanjun Qi "A Fast and Scalable Joint Estimator for Integrating Additional Knowledge in Learning Multiple Related Sparse Gaussian Graphical Models" (ICML 2018) &lt;<a href="https://doi.org/10.48550/arXiv.1806.00548">doi:10.48550/arXiv.1806.00548</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), lpSolve, pcaPP, igraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/QData/jeek">https://github.com/QData/jeek</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/QData/jeek">https://github.com/QData/jeek</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-03 19:36:28 UTC; Karen Chen</td>
</tr>
<tr>
<td>Author:</td>
<td>Beilun Wang [aut, cre],
  Yanjun Qi [aut],
  Zhaoyang Wang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-07 15:40:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='jeek-package'>A Fast and Scalable Joint Estimator for Integrating Additional Knowledge in
Learning Multiple Related Sparse Gaussian Graphical Models</h2><span id='topic+jeek-package'></span>

<h3>Description</h3>

<p>This is an R implementation of a Fast and Scalable Joint Estimator for
Integrating Additional Knowledge in Learning Multiple Related Sparse
Gaussian Graphical Models (JEEK).The JEEK algorithm can be used to fast
estimate multiple related precision matrices in a large-scale. For instance,
it can identify multiple gene networks from multi-context gene expression
datasets. By performing data-driven network inference from high-dimensional
and heterogenous data sets, this tool can help users effectively translate
aggregated data into knowledge that take the form of graphs among entities.
Please run demo(jeek) to learn the basic functions provided by this package.
For further details, please read the original paper: Beilun Wang, Arshdeep
Sekhon, Yanjun Qi (2018).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> jeek</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.1.0</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2018-07-03</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
<p> We consider
the problem of including additional knowledge in estimating sparse Gaussian
graphical models (sGGMs) from aggregated samples, arising often in
bioinformatics and neuroimaging applications. Previous joint sGGM estimators
either fail to use existing knowledge or cannot scale-up to many tasks
(large <code class="reqn">K</code>) under a high-dimensional (large <code class="reqn">p</code>) situation.  In this
paper, we propose a novel Joint Elementary Estimator incorporating
additional Knowledge (JEEK) to infer multiple related sparse Gaussian
Graphical models from large-scale heterogeneous data. Using domain knowledge
as weights, we design a novel hybrid norm as the minimization objective to
enforce the superposition of two weighted sparsity constraints, one on the
shared interactions and the other on the task-specific structural patterns.
This enables JEEK to elegantly consider various forms of existing knowledge
based on the domain at hand and avoid the need to design knowledge-specific
optimization. JEEK is solved through a fast and entry-wise parallelizable
solution that largely improves the computational efficiency of the
state-of-the-art <code class="reqn">O(p^5K^4)</code> to <code class="reqn">O(p^2K^4)</code>. We conduct a rigorous
statistical analysis showing that JEEK achieves the same convergence rate
<code class="reqn">O(\log(Kp)/n_{tot})</code> as the state-of-the-art estimators that are much
harder to compute. Empirically, on multiple synthetic datasets and one
real-world data from neuroscience, JEEK outperforms the speed of the
state-of-arts significantly while achieving the same level of prediction
accuracy.
</p>


<h3>Author(s)</h3>

<p>Beilun Wang, Zhaoyang Wang
</p>
<p>Maintainer: Beilun Wang - bw4mw at virginia dot edu
</p>


<h3>References</h3>

<p>Beilun Wang, Arshdeep Sekhon, Yanjun Qi. A Fast and Scalable
Joint Estimator for Integrating Additional Knowledge in Learning Multiple
Related Sparse Gaussian Graphical Models. &lt;arXiv:1806.00548&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(exampleData)
result = jeek(X = exampleData, 0.3, covType = "cov", parallel = TRUE)
plot.jeek(results)

## End(Not run)
</code></pre>

<hr>
<h2 id='cancer'>Microarray data set for breast cancer</h2><span id='topic+cancer'></span>

<h3>Description</h3>

<p><em>et al</em>'s paper. It concerns one hundred thirty-three patients with
stage I&ndash;III breast cancer.  Patients were treated with chemotherapy prior
to surgery. Patient response to the treatment can be classified as either a
pathologic complete response (pCR) or residual disease (not-pCR). Hess
<em>et al</em> developed and tested a reliable multigene predictor for
treatment response on this data set, composed by a set of 26 genes having a
high predictive value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cancer)
</code></pre>


<h3>Format</h3>

<p>a list of two objects: dataframe with 133 observations of 26 features and
factors indicating whether each sample (out of 133) is of type &quot;not&quot; or type &quot;pcr&quot;</p>


<h3>Details</h3>

<p>The dataset splits into 2 parts (pCR and not pCR), on which network
inference algorithms should be applied independently or in the multitask
framework: only individuals from the same classes should be consider as
independent and identically distributed.
</p>


<h3>References</h3>

<p>J.A. Mejia, D. Booser, R.L. Theriault, U.  Buzdar, P.J. Dempsey, R. Rouzier,
N. Sneige, J.S. Ross, T. Vidaurre, H.L. Gomez, G.N. Hortobagyi, and L.
Pustzai (2006). Pharmacogenomic predictor of sensitivity to preoperative
chemotherapy with Paclitaxel and Fluorouracil, Doxorubicin, and
Cyclophosphamide in breast cancer, <em>Journal of Clinical Oncology</em>, vol.
24(26), pp. 4236&ndash;4244.
</p>

<hr>
<h2 id='exampleData'>A simulated toy dataset that includes 2 data matrices (from 2 related
tasks).</h2><span id='topic+exampleData'></span>

<h3>Description</h3>

<p>A simulated toy dataset that includes 2 data matrices (from 2 related
tasks). Each data matrix is about 100 features observed in 200 samples. The
two data matrices are about exactly the same set of 100 features. This
multi-task dataset is generated from two related random graphs. Please run
demo(simule) to learn the basic functions provided by this package.  For
further details, please read the original paper:
&lt;http://link.springer.com/article/10.1007/s10994-017-5635-7&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exampleData)
</code></pre>


<h3>Format</h3>

<p>The format is: List of 2 matrices $ : num [1:200, 1:100] -0.0982
-0.2417 -1.704 0.4 ...  ..- attr(*, &quot;dimnames&quot;)=List of 2 .. ..$ : NULL ..
..$ : NULL $ : num [1:200, 1:100] -0.161 0.41 0.17 0. ...  ..- attr(*,
&quot;dimnames&quot;)=List of 2 .. ..$ : NULL .. ..$ : NULL</p>

<hr>
<h2 id='exampleDataGraph'>A simulated toy dataset that includes 3 igraph objects</h2><span id='topic+exampleDataGraph'></span>

<h3>Description</h3>

<p>(first one being the shared graph and second and third being task specific 1 and 2 graphs)
The graphs are generated from two related random graphs and the underlaying high dimensional gaussian distribution
generates the exampleData dataset. exampleDataGraph serves as a groundtruth to compare in demo(synthetic).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exampleDataGraph)
</code></pre>


<h3>Format</h3>

<p>A list of 3 igraph objects</p>

<hr>
<h2 id='jeek'>A Fast and Scalable Joint Estimator for Integrating Additional Knowledge in
Learning Multiple Related Sparse Gaussian Graphical Models</h2><span id='topic+jeek'></span>

<h3>Description</h3>

<p>A Fast and Scalable Joint Estimator for Integrating Additional Knowledge in
Learning Multiple Related Sparse Gaussian Graphical Models. Please run
demo(jeek) to learn the basic functions provided by this package.  For
further details, please read the original paper: Beilun Wang, Arshdeep
Sekhon, Yanjun Qi (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jeek(X, lambda, W = NA, covType = "cov", parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jeek_+3A_x">X</code></td>
<td>
<p>A List of input matrices. They can be data matrices or
covariance/correlation matrices. If every matrix in the X is a symmetric
matrix, the matrices are assumed to be covariance/correlation matrices. More
details at &lt;https://github.com/QData/JEEK&gt;</p>
</td></tr>
<tr><td><code id="jeek_+3A_lambda">lambda</code></td>
<td>
<p>A positive number. The hyperparameter controls the sparsity
level of the matrices. The <code class="reqn">\lambda_n</code> in the following section:
Details.</p>
</td></tr>
<tr><td><code id="jeek_+3A_w">W</code></td>
<td>
<p>A list of weight matrices. The hyperparameter intergrating the
additional knowledge into the model. The <code class="reqn">W_{ij}</code> is large means that
node i and node j have less probability to connect with each other. The
default value of each entry is 1, which means there is no additional
knowledge in the formulation.</p>
</td></tr>
<tr><td><code id="jeek_+3A_covtype">covType</code></td>
<td>
<p>A parameter to decide which Graphical model we choose to
estimate from the input data.
</p>
<p>If covType = &quot;cov&quot;, it means that we estimate multiple sparse Gaussian
Graphical models. This option assumes that we calculate (when input X
represents data directly) or use (when X elements are symmetric representing
covariance matrices) the sample covariance matrices as input to the JEEK
algorithm.
</p>
<p>If covType = &quot;kendall&quot;, it means that we estimate multiple nonparanormal
Graphical models. This option assumes that we calculate (when input X
represents data directly) or use (when X elements are symmetric representing
correlation matrices) the kendall's tau correlation matrices as input to the
JEEK algorithm.</p>
</td></tr>
<tr><td><code id="jeek_+3A_parallel">parallel</code></td>
<td>
<p>A boolean. This parameter decides if the package will use
the multithreading architecture or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The JEEK algorithm is a novel Joint Elementary Estimator incorporating
additional Knowledge (JEEK) to infer multiple related sparse Gaussian
Graphical models from large-scale heterogeneous data. It solves the
following equation: </p>
<p style="text-align: center;"><code class="reqn"> \min\limits_{\Omega^{tot}_I, \Omega^{tot}_S}
||W^{tot}_I \circ \Omega^{tot}_I||_1 + ||W^{tot}_S\circ \Omega^{tot}_S|| </code>
</p>

<p>Subject to : </p>
<p style="text-align: center;"><code class="reqn"> ||W^{tot}_I \circ (\Omega^{tot} -
inv(T_v(\hat{\Sigma}^{tot}))) ||_{\infty} \le \lambda_n </code>
</p>
 <p style="text-align: center;"><code class="reqn"> ||W^{tot}_S
\circ (\Omega^{tot} - inv(T_v(\hat{\Sigma}^{tot}))) ||_{\infty} \le
\lambda_n </code>
</p>
 <p style="text-align: center;"><code class="reqn"> \Omega^{tot} = \Omega^{tot}_S + \Omega^{tot}_I </code>
</p>

<p>Please also see the equation (3.7) in our paper. The <code class="reqn">\lambda_n</code> is the
hyperparameter controlling the sparsity level of the matrices and it is the
<code>lambda</code> in our function. For further details, please see our paper:
Beilun Wang, Arshdeep Sekhon, Yanjun Qi. A Fast and Scalable Joint Estimator
for Integrating Additional Knowledge in Learning Multiple Related Sparse
Gaussian Graphical Models. ICML 2018
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Graphs</code></td>
<td>
<p>A list of the estimated inverse covariance/correlation
matrices.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Beilun Wang
</p>


<h3>References</h3>

<p>Beilun Wang, Arshdeep Sekhon, Yanjun Qi. A Fast and Scalable
Joint Estimator for Integrating Additional Knowledge in Learning Multiple
Related Sparse Gaussian Graphical Models. &lt;arXiv:1806.00548&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(exampleData)
result = jeek(X = exampleData, 0.3, covType = "cov", parallel = TRUE)
plot.jeek(results)

## End(Not run)
</code></pre>

<hr>
<h2 id='nip_37_data'>NIPS word count dataset</h2><span id='topic+nip_37_data'></span>

<h3>Description</h3>

<p>This NIPS Conference Papers 1987-2015 Data set is avaiable at UCI Machine Learning Repository.
The original dataset is in the form of a 11463 x 5812 matrix of word counts (11463 words and 5812 conference papers)
Due to the size of the original dataset, it is preprocessed and reduced to a list of two matrices (2900 x 37 and 2911 x 37)
The dataset consists of two tasks (early (up to 2006) and recent (after 2006) NIPS conference papers) with 37 words
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nip_37_data)
</code></pre>


<h3>Format</h3>

<p>a list of two nonnegative integer matrices (1:2900, 1:37) and (1:2911,1:37)
Columns are named with year_paperid and rows are names with word name</p>


<h3>References</h3>

<p>'Poisson Random Fields for Dynamic Feature Models'. Perrone V., Jenkins P. A., Spano D., Teh Y. W. (2016)
</p>

<hr>
<h2 id='plot.jeek'>Plot jeek result specified by user input</h2><span id='topic+plot.jeek'></span>

<h3>Description</h3>

<p>This function can plot and return multiple sparse graphs distinguished by edge colors
from the result generated by jeek
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jeek'
plot(x, graphlabel = NULL, type = "task",
  neighbouroption = "task", subID = NULL, index = NULL,
  graphlayout = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.jeek_+3A_x">x</code></td>
<td>
<p>output generated from the &quot;jeek&quot; function (jeek class)</p>
</td></tr>
<tr><td><code id="plot.jeek_+3A_graphlabel">graphlabel</code></td>
<td>
<p>vertex names for the graph, there are three options:
(1) NA (no label)
(2) NULL (default numeric label according to the feature order)
(3) a vector of labels (a vector of labels cooresponding to x)
deault value is NULL</p>
</td></tr>
<tr><td><code id="plot.jeek_+3A_type">type</code></td>
<td>
<p>type of graph, there are four options:
(1) &quot;task&quot; (graph for each task (including shared part) specified further by subID (task number))
(2) &quot;share&quot; (shared graph for all tasks)
(3) &quot;taskspecific&quot; (graph for each task specific (excluding shared part)
specified further by subID (task number) )
(4) &quot;neighbour&quot; (zoom into nodes in the graph specified further by neighbouroptoin, subID (task number)
and index (node id))</p>
</td></tr>
<tr><td><code id="plot.jeek_+3A_neighbouroption">neighbouroption</code></td>
<td>
<p>determines what type of graph to zoom into when parameter type is &quot;neighbour&quot;
There are two options:
(1) &quot;task&quot; (zoom into graph for each task (including shared part))
(2) &quot;taskspecific&quot; (zoom into graph for each task specific (excluding shared part))</p>
</td></tr>
<tr><td><code id="plot.jeek_+3A_subid">subID</code></td>
<td>
<p>selects which task to display
(1) 0 (only allowed when type is task or type is neighbour and neighbouroption is task) (selecting share graph)
(2) positive task number (selects a task number)
(3) a vector of task number (selects multiple tasks)
(4) NULL (selects all tasks (all graphs))</p>
</td></tr>
<tr><td><code id="plot.jeek_+3A_index">index</code></td>
<td>
<p>determines which node(s) to zoom into when parameter type is &quot;neighbour&quot;
could either be an integer or vector of integers representing node ids
(zoom into one node or multiple nodes)</p>
</td></tr>
<tr><td><code id="plot.jeek_+3A_graphlayout">graphlayout</code></td>
<td>
<p>layout for the graph (two column matrix specifying x,y coordinates of each node in graph)
if not provided, igraph will use the default layout_nicely() function present the graph</p>
</td></tr>
<tr><td><code id="plot.jeek_+3A_...">...</code></td>
<td>
<p>extra parameters passed to plot.igraph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>when only the simulresult is provided, the function will plot all graphs with default numeric labels
User can specify multiple subID and multiple index to zoom in multiple nodes on multiple graphs
Each graph will include a decriptive title and legend to indicate correspondence between edge color and task.
The function will plot graph and return an igraph object at the same time
</p>


<h3>Value</h3>

<p>a plot of graph / subgraph from jeek result specified by user input
</p>


<h3>Author(s)</h3>

<p>Beilun Wang, Zhaoyang Wang (Author), Beilun Wang (maintainer)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(exampleData)
result = jeek(X = exampleData, 0.3, covType = "cov", parallel = TRUE)
plot.jeek(result)

## End(Not run)
</code></pre>

<hr>
<h2 id='returngraph'>return igraph object from jeek result specified by user input</h2><span id='topic+returngraph'></span>

<h3>Description</h3>

<p>This function can return an igraph object from jeek result for user to work with directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returngraph(x, type = "task", neighbouroption = "task", subID = NULL,
  index = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="returngraph_+3A_x">x</code></td>
<td>
<p>output generated from jeek function (jeek class)</p>
</td></tr>
<tr><td><code id="returngraph_+3A_type">type</code></td>
<td>
<p>type of graph, there are four options:
(1) &quot;task&quot; (graph for each task (including shared part) specified further by subID (task number))
(2) &quot;share&quot; (shared graph for all tasks)
(3) &quot;taskspecific&quot; (graph for each task specific (excluding shared part)
specified further by subID (task number) )
(4) &quot;neighbour&quot; (zoom into nodes in the graph specified further by neighbouroptoin, subID (task number)
and index (node id))</p>
</td></tr>
<tr><td><code id="returngraph_+3A_neighbouroption">neighbouroption</code></td>
<td>
<p>determines what type of graph to zoom into when parameter type is &quot;neighbour&quot;
There are two options:
(1) &quot;task&quot; (zoom into graph for each task (including shared part))
(2) &quot;taskspecific&quot; (zoom into graph for each task specific (excluding shared part))</p>
</td></tr>
<tr><td><code id="returngraph_+3A_subid">subID</code></td>
<td>
<p>selects which task to display
(1) 0 (only allowed when type is task or type is neighbour and neighbouroption is task) (selecting share graph)
(2) positive task number (selects a task number)
(3) a vector of task number (selects multiple tasks)
(4) NULL (selects all tasks (all graphs))</p>
</td></tr>
<tr><td><code id="returngraph_+3A_index">index</code></td>
<td>
<p>determines which node(s) to zoom into when parameter type is &quot;neighbour&quot;
could either be an integer or vector of integers representing node ids
(zoom into one node or multiple nodes)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the function aims to provide users the flexibility to explore and visualize the graph on their own
generated from jeek
</p>


<h3>Value</h3>

<p>an igraph object of graph / subgraph from jeek result specified by user input
</p>


<h3>Author(s)</h3>

<p>Beilun Wang, Zhaoyang Wang (Author), Beilun Wang (maintainer)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(exampleData)
result = jeek(X = exampleData, 0.3, covType = "cov", parallel = TRUE)
graph = returngraph(result)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
