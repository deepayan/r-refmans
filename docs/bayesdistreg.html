<!DOCTYPE html><html lang="en"><head><title>Help for package bayesdistreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesdistreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asymcnfB'><p>Asymmetric simultaneous bayesian confidence bands</p></a></li>
<li><a href='#distreg'><p>Bayesian distribution regression</p></a></li>
<li><a href='#distreg_cfa'><p>Counterfactual bayesian distribution regression</p></a></li>
<li><a href='#distreg_cfa.sas'><p>Semi-asymptotic counterfactual distribution</p></a></li>
<li><a href='#distreg.asymp'><p>Asymptotic distribution regression</p></a></li>
<li><a href='#distreg.sas'><p>Semi-asymptotic bayesian distribution</p></a></li>
<li><a href='#dr_asympar'><p>Binary glm object at several threshold values</p></a></li>
<li><a href='#fitdist'><p>The distribution of mean fitted logit probabilities</p></a></li>
<li><a href='#fitlogit'><p>Fitted logit probabilities</p></a></li>
<li><a href='#IndepMH'><p>Independence Metropolis-Hastings Algorithm</p></a></li>
<li><a href='#indicat'><p>Indicator function</p></a></li>
<li><a href='#jdpar.asymp'><p>Joint asymptotic mutivariate density of parameters</p></a></li>
<li><a href='#jntCBOM'><p>Montiel Olea and Plagborg-Moller (2018) confidence bands</p></a></li>
<li><a href='#lapl_aprx'><p>Laplace approximation of posterior to normal</p></a></li>
<li><a href='#lapl_aprx2'><p>Laplace approximation of posterior to normal</p></a></li>
<li><a href='#logit'><p>Logit likelihood function</p></a></li>
<li><a href='#LogitLink'><p>Logit function</p></a></li>
<li><a href='#par_distreg'><p>Parallel compute bayesian distribution regression</p></a></li>
<li><a href='#parLply'><p>Parallel compute</p></a></li>
<li><a href='#posterior'><p>Posterior distribution</p></a></li>
<li><a href='#prior_n'><p>Normal Prior distribution</p></a></li>
<li><a href='#prior_u'><p>Uniform Prior distribution</p></a></li>
<li><a href='#quant_bdr'><p>Quantile conversion of a bayesian distribution matrix</p></a></li>
<li><a href='#RWMH'><p>Random Walk Metropolis-Hastings Algorithm</p></a></li>
<li><a href='#simcnfB'><p>Symmetric simultaneous bayesian confidence bands</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Distribution Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emmanuel Tsyawo &lt;estsyawo@temple.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Bayesian Distribution Regression methods. This package contains functions for three estimators (non-asymptotic, semi-asymptotic and asymptotic) and related routines for Bayesian Distribution Regression in Huang and Tsyawo (2018) &lt;<a href="https://doi.org/10.2139%2Fssrn.3048658">doi:10.2139/ssrn.3048658</a>&gt; which is also the recommended reference to cite for this package. The functions can be grouped into three (3) categories. The first computes the logit likelihood function and posterior densities under uniform and normal priors. The second contains Independence and Random Walk Metropolis-Hastings Markov Chain Monte Carlo (MCMC) algorithms as functions and the third category of functions are useful for semi-asymptotic and asymptotic Bayesian distribution regression inference.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, sandwich, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-01-31 20:45:33 UTC; Selorm</td>
</tr>
<tr>
<td>Author:</td>
<td>Emmanuel Tsyawo [aut, cre],
  Weige Huang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-02-05 22:44:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='asymcnfB'>Asymmetric simultaneous bayesian confidence bands</h2><span id='topic+asymcnfB'></span>

<h3>Description</h3>

<p><code>asymcnfB</code> obtains asymmetric bayesian distribution confidence bands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asymcnfB(DF, DFmat, alpha = 0.05, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asymcnfB_+3A_df">DF</code></td>
<td>
<p>the target distribution/quantile function as a vector</p>
</td></tr>
<tr><td><code id="asymcnfB_+3A_dfmat">DFmat</code></td>
<td>
<p>the matrix of draws of the distribution, rows correspond to 
elements in <code>DF</code></p>
</td></tr>
<tr><td><code id="asymcnfB_+3A_alpha">alpha</code></td>
<td>
<p>level such that <code>1-alpha</code> is the desired probability of coverage</p>
</td></tr>
<tr><td><code id="asymcnfB_+3A_scale">scale</code></td>
<td>
<p>logical for scaling using the inter-quartile range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cstar - a constant to add and subtract from DF to create 
confidence bands if no scaling=FALSE else a vector of length DF.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(14); m=matrix(rbeta(500,1,4),nrow = 5) + 1:5
DF = apply(m,1,mean); plot(1:5,DF,type="l",ylim = c(min(m),max(m)), xlab = "Index")
asyCB&lt;- asymcnfB(DF,DFmat = m)
lines(1:5,DF-asyCB$cmin,lty=2); lines(1:5,DF+asyCB$cmax,lty=2)

</code></pre>

<hr>
<h2 id='distreg'>Bayesian distribution regression</h2><span id='topic+distreg'></span>

<h3>Description</h3>

<p><code>distreg</code> draws randomly from the density of F(yo) at a threshold value yo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distreg(thresh, data0, MH = "IndepMH", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distreg_+3A_thresh">thresh</code></td>
<td>
<p>threshold value that is used to binarise the continuous outcome variable</p>
</td></tr>
<tr><td><code id="distreg_+3A_data0">data0</code></td>
<td>
<p>original data set with the first column being the continuous outcome variable</p>
</td></tr>
<tr><td><code id="distreg_+3A_mh">MH</code></td>
<td>
<p>metropolis-hastings algorithm to use; default:&quot;IndepMH&quot;, alternative &quot;RWMH&quot;</p>
</td></tr>
<tr><td><code id="distreg_+3A_...">...</code></td>
<td>
<p>any additional inputs to pass to the MH algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitob a vector of fitted values corresponding to the distribution at threshold thresh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data0=faithful[,c(2,1)]; qnt&lt;-quantile(data0[,1],0.25)
distob&lt;- distreg(qnt,data0,iter = 102, burn = 2); 
plot(density(distob,.1),main="Kernel density plot")

</code></pre>

<hr>
<h2 id='distreg_cfa'>Counterfactual bayesian distribution regression</h2><span id='topic+distreg_cfa'></span>

<h3>Description</h3>

<p><code>distreg</code> draws randomly from the density of counterfactual of F(yo) at a threshold 
value yo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distreg_cfa(thresh, data0, MH = "IndepMH", cft, cfIND, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distreg_cfa_+3A_thresh">thresh</code></td>
<td>
<p>threshold value that is used to binarise the continuous outcome variable</p>
</td></tr>
<tr><td><code id="distreg_cfa_+3A_data0">data0</code></td>
<td>
<p>original data set with the first column being the continuous outcome variable</p>
</td></tr>
<tr><td><code id="distreg_cfa_+3A_mh">MH</code></td>
<td>
<p>metropolis-hastings algorithm to use; default:&quot;IndepMH&quot;, alternative &quot;RWMH&quot;</p>
</td></tr>
<tr><td><code id="distreg_cfa_+3A_cft">cft</code></td>
<td>
<p>column vector of counterfactual treatment</p>
</td></tr>
<tr><td><code id="distreg_cfa_+3A_cfind">cfIND</code></td>
<td>
<p>the column index(indices) of treatment variable(s) to replace with <code>cft</code> 
in <code>data0</code></p>
</td></tr>
<tr><td><code id="distreg_cfa_+3A_...">...</code></td>
<td>
<p>any additional inputs to pass to the MH algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>robj a list of a vector of fitted values corresponding to random draws from
F(yo), counterfactual F(yo), and the parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data0=faithful[,c(2,1)]; qnt&lt;-quantile(data0[,1],0.25)
cfIND=2 #Note: the first column is the outcome variable. 
cft=0.95*data0[,cfIND] # a decrease by 5%
dist_cfa&lt;- distreg_cfa(qnt,data0,cft,cfIND,MH="IndepMH",iter = 102, burn = 2)
par(mfrow=c(1,2)); plot(density(dist_cfa$counterfactual,.1),main="Original")
plot(density(dist_cfa$counterfactual,.1),main="Counterfactual"); par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='distreg_cfa.sas'>Semi-asymptotic counterfactual distribution</h2><span id='topic+distreg_cfa.sas'></span>

<h3>Description</h3>

<p><code>distreg_cfa.sas</code> takes input object from dr_asympar() for counterfactual semi 
asymptotic bayesian distribution. This involves taking random draws from the normal 
approximation of the posterior at each threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distreg_cfa.sas(ind, drabj, data, cft, cfIND, vcovfn = "vcov",
  iter = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distreg_cfa.sas_+3A_ind">ind</code></td>
<td>
<p>index of object in list <code>drabj</code> (i.e. a threshold value) from which to take draws</p>
</td></tr>
<tr><td><code id="distreg_cfa.sas_+3A_drabj">drabj</code></td>
<td>
<p>object from dr_asympar()</p>
</td></tr>
<tr><td><code id="distreg_cfa.sas_+3A_data">data</code></td>
<td>
<p>dataframe, first column is the outcome</p>
</td></tr>
<tr><td><code id="distreg_cfa.sas_+3A_cft">cft</code></td>
<td>
<p>column vector of counterfactual treatment</p>
</td></tr>
<tr><td><code id="distreg_cfa.sas_+3A_cfind">cfIND</code></td>
<td>
<p>the column index(indices) of treatment variable(s) to replace with <code>cft</code> 
in <code>data0</code></p>
</td></tr>
<tr><td><code id="distreg_cfa.sas_+3A_vcovfn">vcovfn</code></td>
<td>
<p>a string denoting the function to extract the variance-covariance. Defaults at
&quot;vcov&quot;. Other variance-covariance estimators in the sandwich package are usable.</p>
</td></tr>
<tr><td><code id="distreg_cfa.sas_+3A_iter">iter</code></td>
<td>
<p>number of draws to simulate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitob vector of random draws from density of F(yo) using semi-asymptotic BDR
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = faithful$waiting
x = scale(cbind(faithful$eruptions,faithful$eruptions^2))
qtaus = quantile(y,c(0.05,0.25,0.5,0.75,0.95))
drabj&lt;- dr_asympar(y=y,x=x,thresh = qtaus); data = data.frame(y,x)
cfIND=2 #Note: the first column is the outcome variable. 
cft=0.95*data[,cfIND] # a decrease by 5%
cfa.sasobj&lt;- distreg_cfa.sas(ind=2,drabj,data,cft,cfIND,vcovfn="vcov")
par(mfrow=c(1,2)); plot(density(cfa.sasobj$original,.1),main="Original")
plot(density(cfa.sasobj$counterfactual,.1),main="Counterfactual"); par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='distreg.asymp'>Asymptotic distribution regression</h2><span id='topic+distreg.asymp'></span>

<h3>Description</h3>

<p><code>distreg.asymp</code> takes input object from dr_asympar() for asymptotic bayesian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distreg.asymp(ind, drabj, data, vcovfn = "vcov", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distreg.asymp_+3A_ind">ind</code></td>
<td>
<p>index of object in list <code>drabj</code> (i.e. a threshold value) from which to take draws</p>
</td></tr>
<tr><td><code id="distreg.asymp_+3A_drabj">drabj</code></td>
<td>
<p>object from dr_asympar()</p>
</td></tr>
<tr><td><code id="distreg.asymp_+3A_data">data</code></td>
<td>
<p>dataframe, first column is the outcome</p>
</td></tr>
<tr><td><code id="distreg.asymp_+3A_vcovfn">vcovfn</code></td>
<td>
<p>a string denoting the function to extract the variance-covariance. Defaults at
&quot;vcov&quot;. Other variance-covariance estimators in the sandwich package are usable.</p>
</td></tr>
<tr><td><code id="distreg.asymp_+3A_...">...</code></td>
<td>
<p>additional input to pass to <code>vcovfn</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mean <code>Fhat</code> and a variance <code>varF</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = faithful$waiting
x = scale(cbind(faithful$eruptions,faithful$eruptions^2))
qtaus = quantile(y,c(0.05,0.25,0.5,0.75,0.95))
drabj&lt;- dr_asympar(y=y,x=x,thresh = qtaus); data = data.frame(y,x)
(asymp.obj&lt;- distreg.asymp(ind=2,drabj,data,vcovfn="vcov"))

</code></pre>

<hr>
<h2 id='distreg.sas'>Semi-asymptotic bayesian distribution</h2><span id='topic+distreg.sas'></span>

<h3>Description</h3>

<p><code>distreg.sas</code> takes input object from dr_asympar() for semi asymptotic bayesian 
distribution. This involves taking random draws from the normal approximation of the 
posterior at each threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distreg.sas(ind, drabj, data, vcovfn = "vcov", iter = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distreg.sas_+3A_ind">ind</code></td>
<td>
<p>index of object in list <code>drabj</code> (i.e. a threshold value) from which to take draws</p>
</td></tr>
<tr><td><code id="distreg.sas_+3A_drabj">drabj</code></td>
<td>
<p>object from dr_asympar()</p>
</td></tr>
<tr><td><code id="distreg.sas_+3A_data">data</code></td>
<td>
<p>dataframe, first column is the outcome</p>
</td></tr>
<tr><td><code id="distreg.sas_+3A_vcovfn">vcovfn</code></td>
<td>
<p>a string denoting the function to extract the variance-covariance. Defaults at
&quot;vcov&quot;. Other variance-covariance estimators in the sandwich package are usable.</p>
</td></tr>
<tr><td><code id="distreg.sas_+3A_iter">iter</code></td>
<td>
<p>number of draws to simulate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitob vector of random draws from density of F(yo) using semi-asymptotic BDR
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = faithful$waiting
x = scale(cbind(faithful$eruptions,faithful$eruptions^2))
qtaus = quantile(y,c(0.05,0.25,0.5,0.75,0.95))
drabj&lt;- dr_asympar(y=y,x=x,thresh = qtaus); data = data.frame(y,x)
drsas1 = lapply(1:5,distreg.sas,drabj=drabj,data=data,iter=100)
drsas2 = lapply(1:5,distreg.sas,drabj=drabj,data=data,vcovfn="vcovHC",iter=100)
par(mfrow=c(3,2));invisible(lapply(1:5,function(i)plot(density(drsas1[[i]],.1))));par(mfrow=c(1,1))
par(mfrow=c(3,2));invisible(lapply(1:5,function(i)plot(density(drsas2[[i]],.1))));par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='dr_asympar'>Binary glm object at several threshold values</h2><span id='topic+dr_asympar'></span>

<h3>Description</h3>

<p><code>dr_asympar</code> computes a normal approximation of the likelihood at a vector of threshold
values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dr_asympar(y, x, thresh, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dr_asympar_+3A_y">y</code></td>
<td>
<p>outcome variable</p>
</td></tr>
<tr><td><code id="dr_asympar_+3A_x">x</code></td>
<td>
<p>matrix of covariates</p>
</td></tr>
<tr><td><code id="dr_asympar_+3A_thresh">thresh</code></td>
<td>
<p>vector of threshold values on the support of outcome y</p>
</td></tr>
<tr><td><code id="dr_asympar_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code>lapl_aprx2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of glm objects corresponding to <code>thresh</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = faithful$waiting
x = scale(cbind(faithful$eruptions,faithful$eruptions^2))
qtaus = quantile(y,c(0.05,0.25,0.5,0.75,0.95))
drabj&lt;- dr_asympar(y=y,x=x,thresh = qtaus)
lapply(drabj,coef); lapply(drabj,vcov) 
# mean and covariance at respective threshold values

</code></pre>

<hr>
<h2 id='fitdist'>The distribution of mean fitted logit probabilities</h2><span id='topic+fitdist'></span>

<h3>Description</h3>

<p><code>fitdist</code> function generates a vector of mean fitted probabilities that constitute the 
distribution. This involves marginalising out covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitdist(Matparam, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitdist_+3A_matparam">Matparam</code></td>
<td>
<p>an M x k matrix of parameter draws, each being a 1 x k vector</p>
</td></tr>
<tr><td><code id="fitdist_+3A_data">data</code></td>
<td>
<p>dataframe used to obtain Matparam</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dist fitted (marginalised) distribution
</p>

<hr>
<h2 id='fitlogit'>Fitted logit probabilities</h2><span id='topic+fitlogit'></span>

<h3>Description</h3>

<p><code>fitlogit</code> obtains a vector of fitted logit probabilities given parameters (pars)
and data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitlogit(pars, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitlogit_+3A_pars">pars</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id="fitlogit_+3A_data">data</code></td>
<td>
<p>data frame. The first column of the data frame ought to be the binary dependent 
variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vec vector of fitted logit probabilities
</p>

<hr>
<h2 id='IndepMH'>Independence Metropolis-Hastings Algorithm</h2><span id='topic+IndepMH'></span>

<h3>Description</h3>

<p><code>IndepMH</code> computes random draws of parameters using a specified proposal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IndepMH(data, propob = NULL, posterior = NULL, iter = 1500,
  burn = 500, vscale = 1.5, start = NULL, prior = "Uniform",
  mu = 0, sig = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IndepMH_+3A_data">data</code></td>
<td>
<p>data required for the posterior distribution</p>
</td></tr>
<tr><td><code id="IndepMH_+3A_propob">propob</code></td>
<td>
<p>a list of mean and variance-covariance of the normal proposal distribution (default:NULL)</p>
</td></tr>
<tr><td><code id="IndepMH_+3A_posterior">posterior</code></td>
<td>
<p>the posterior distribution. It is set to null in order to use the logit posterior.
The user can specify log posterior as a function of parameters and data (pars,data)</p>
</td></tr>
<tr><td><code id="IndepMH_+3A_iter">iter</code></td>
<td>
<p>number of random draws desired (default: 1500)</p>
</td></tr>
<tr><td><code id="IndepMH_+3A_burn">burn</code></td>
<td>
<p>burn-in period for the MH algorithm (default: 500)</p>
</td></tr>
<tr><td><code id="IndepMH_+3A_vscale">vscale</code></td>
<td>
<p>a positive value to scale up or down the variance-covariance matrix in
the proposal distribution</p>
</td></tr>
<tr><td><code id="IndepMH_+3A_start">start</code></td>
<td>
<p>starting values of parameters for the MH algorithm.
It is automatically generated but the user can also specify.</p>
</td></tr>
<tr><td><code id="IndepMH_+3A_prior">prior</code></td>
<td>
<p>the prior distribution (default: &quot;Normal&quot;, alternative: &quot;Uniform&quot;)</p>
</td></tr>
<tr><td><code id="IndepMH_+3A_mu">mu</code></td>
<td>
<p>the mean of the normal prior distribution (default:0)</p>
</td></tr>
<tr><td><code id="IndepMH_+3A_sig">sig</code></td>
<td>
<p>the variance of the normal prior distribution (default:10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>val a list of matrix of draws pardraws and the acceptance rate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = indicat(faithful$waiting,70)
x = scale(cbind(faithful$eruptions,faithful$eruptions^2))
data = data.frame(y,x); propob&lt;- lapl_aprx(y,x)
IndepMH_n&lt;- IndepMH(data=data,propob,iter = 102, burn = 2) # prior="Normal"
IndepMH_u&lt;- IndepMH(data=data,propob,prior="Uniform",iter = 102, burn = 2) # prior="Uniform"
par(mfrow=c(3,1));invisible(apply(IndepMH_n$Matpram,2,function(x)plot(density(x))))
invisible(apply(IndepMH_u$Matpram,2,function(x)plot(density(x))));par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='indicat'>Indicator function</h2><span id='topic+indicat'></span>

<h3>Description</h3>

<p>This function creates 0-1 indicators for a given threshold y0 and vector y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indicat(y, y0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indicat_+3A_y">y</code></td>
<td>
<p>vector y</p>
</td></tr>
<tr><td><code id="indicat_+3A_y0">y0</code></td>
<td>
<p>threshold value y0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>val
</p>

<hr>
<h2 id='jdpar.asymp'>Joint asymptotic mutivariate density of parameters</h2><span id='topic+jdpar.asymp'></span>

<h3>Description</h3>

<p><code>jdpar.asymp</code> takes input object from dr_asympar() for asymptotic bayesian distribution.
It returns objects for joint mutivariate density of parameters across several thresholds.
Check for positive definiteness of the covariance matrix, else exclude thresholds yielding
negative eigen values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jdpar.asymp(drabj, data, jdF = FALSE, vcovfn = "vcovHC", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jdpar.asymp_+3A_drabj">drabj</code></td>
<td>
<p>object from dr_asympar()</p>
</td></tr>
<tr><td><code id="jdpar.asymp_+3A_data">data</code></td>
<td>
<p>dataframe, first column is the outcome</p>
</td></tr>
<tr><td><code id="jdpar.asymp_+3A_jdf">jdF</code></td>
<td>
<p>logical to return joint density of F(yo) across thresholds in drabj</p>
</td></tr>
<tr><td><code id="jdpar.asymp_+3A_vcovfn">vcovfn</code></td>
<td>
<p>a string denoting the function to extract the variance-covariance. Defaults at
&quot;vcov&quot;. Other variance-covariance estimators in the sandwich package are usable.</p>
</td></tr>
<tr><td><code id="jdpar.asymp_+3A_...">...</code></td>
<td>
<p>additional input to pass to <code>vcovfn</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean vector Theta and variance-covariance matrix vcovpar of parameters across 
thresholds and if <code>jdF=TRUE</code>, 
a mean vector <code>mnF</code> and a variance-covariance matrix <code>vcovF</code> of F(yo)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = faithful$waiting
x = scale(cbind(faithful$eruptions,faithful$eruptions^2))
qtaus = quantile(y,c(0.05,0.25,0.5,0.75,0.95))
drabj&lt;- dr_asympar(y=y,x=x,thresh = qtaus); data = data.frame(y,x)
(drjasy = jdpar.asymp(drabj=drabj,data=data,jdF=TRUE))

</code></pre>

<hr>
<h2 id='jntCBOM'>Montiel Olea and Plagborg-Moller (2018) confidence bands</h2><span id='topic+jntCBOM'></span>

<h3>Description</h3>

<p><code>jntCBOM</code> implements calibrated symmetric confidence bands (algorithm 2)
in Montiel Olea and Plagborg-Moller (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jntCBOM(DF, DFmat, alpha = 0.05, eps = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jntCBOM_+3A_df">DF</code></td>
<td>
<p>the target distribution/quantile function as a vector</p>
</td></tr>
<tr><td><code id="jntCBOM_+3A_dfmat">DFmat</code></td>
<td>
<p>the matrix of draws of the distribution, rows correspond to 
indices elements in <code>DF</code></p>
</td></tr>
<tr><td><code id="jntCBOM_+3A_alpha">alpha</code></td>
<td>
<p>level such that <code>1-alpha</code> is the desired probability of coverage</p>
</td></tr>
<tr><td><code id="jntCBOM_+3A_eps">eps</code></td>
<td>
<p>steps by which the grid on 1-alpha:alpha/2 is searched.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>CB - confidence band, zeta - the optimal level
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(14); m=matrix(rbeta(500,1,4),nrow = 5) + 1:5
DF = apply(m,1,mean); plot(1:5,DF,type="l",ylim = c(min(m),max(m)), xlab = "Index")
jOMCB&lt;- jntCBOM(DF,DFmat = m)
lines(1:5,jOMCB$CB[,1],lty=2); lines(1:5,jOMCB$CB[,2],lty=2)

</code></pre>

<hr>
<h2 id='lapl_aprx'>Laplace approximation of posterior to normal</h2><span id='topic+lapl_aprx'></span>

<h3>Description</h3>

<p>This function generates mode and variance-covariance for a normal proposal
distribution for the bayesian logit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapl_aprx(y, x, glmobj = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lapl_aprx_+3A_y">y</code></td>
<td>
<p>the binary dependent variable y</p>
</td></tr>
<tr><td><code id="lapl_aprx_+3A_x">x</code></td>
<td>
<p>the matrix of independent variables.</p>
</td></tr>
<tr><td><code id="lapl_aprx_+3A_glmobj">glmobj</code></td>
<td>
<p>logical for returning the logit glm object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>val A list of mode variance-covariance matrix, and scale factor for
proposal draws from the multivariate normal distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> y = indicat(faithful$waiting,mean(faithful$waiting)) 
 x = scale(cbind(faithful$eruptions,faithful$eruptions^2))
 gg&lt;- lapl_aprx(y,x)

</code></pre>

<hr>
<h2 id='lapl_aprx2'>Laplace approximation of posterior to normal</h2><span id='topic+lapl_aprx2'></span>

<h3>Description</h3>

<p><code>lapl_aprx2</code> is a more flexible alternative to <code>lapl_aprx</code>. This creates
<code>glm</code> objects from which joint asymptotic distributions can be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapl_aprx2(y, x, family = "binomial", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lapl_aprx2_+3A_y">y</code></td>
<td>
<p>the binary dependent variable y</p>
</td></tr>
<tr><td><code id="lapl_aprx2_+3A_x">x</code></td>
<td>
<p>the matrix of independent variables.</p>
</td></tr>
<tr><td><code id="lapl_aprx2_+3A_family">family</code></td>
<td>
<p>a parameter to be passed <code>glm()</code>, defaults to the logit model</p>
</td></tr>
<tr><td><code id="lapl_aprx2_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to <code>glm()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>val A list of mode variance-covariance matrix, and scale factor for
proposal draws from the multivariate normal distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = indicat(faithful$waiting,mean(faithful$waiting)) 
x = scale(cbind(faithful$eruptions,faithful$eruptions^2))
(gg&lt;- lapl_aprx2(y,x)); coef(gg); vcov(gg)

</code></pre>

<hr>
<h2 id='logit'>Logit likelihood function</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p><code>logit</code> is the logistic likelihood function given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(start, data, Log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_+3A_start">start</code></td>
<td>
<p>vector of starting values</p>
</td></tr>
<tr><td><code id="logit_+3A_data">data</code></td>
<td>
<p>dataframe. The first column should be the dependent variable.</p>
</td></tr>
<tr><td><code id="logit_+3A_log">Log</code></td>
<td>
<p>a logical input (defaults to <code>True</code>) to take the log of the likelihood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>like returns the likelihood function value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = indicat(faithful$waiting,mean(faithful$waiting)) 
x = scale(cbind(faithful$eruptions,faithful$eruptions^2))
data = data.frame(y,x)
logit(rep(0,3),data)
</code></pre>

<hr>
<h2 id='LogitLink'>Logit function</h2><span id='topic+LogitLink'></span>

<h3>Description</h3>

<p>This is the link function for logit regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogitLink(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LogitLink_+3A_x">x</code></td>
<td>
<p>Random variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>val Probability value from the logistic function
</p>

<hr>
<h2 id='par_distreg'>Parallel compute bayesian distribution regression</h2><span id='topic+par_distreg'></span>

<h3>Description</h3>

<p><code>par_distreg</code> uses parallel computation to compute bayesian distribution regression for a given
vector of threshold values and a data (with first column being the continuous outcome variable)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_distreg(thresh, data0, fn = distreg, no_cores = 1,
  type = "PSOCK", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="par_distreg_+3A_thresh">thresh</code></td>
<td>
<p>vector of threshold values.</p>
</td></tr>
<tr><td><code id="par_distreg_+3A_data0">data0</code></td>
<td>
<p>the original data set with a continous dependent variable in the first column</p>
</td></tr>
<tr><td><code id="par_distreg_+3A_fn">fn</code></td>
<td>
<p>bayesian distribution regression function. the default is distreg provided in the package</p>
</td></tr>
<tr><td><code id="par_distreg_+3A_no_cores">no_cores</code></td>
<td>
<p>number of cores for parallel computation</p>
</td></tr>
<tr><td><code id="par_distreg_+3A_type">type</code></td>
<td>
<p><code>type</code> passed to <code>makeCluster()</code> in the package <code>parallel</code></p>
</td></tr>
<tr><td><code id="par_distreg_+3A_...">...</code></td>
<td>
<p>any additional input parameters to pass to fn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mat a G x M matrix of output (G is the length of thresh, M is the number of draws)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data0=faithful[,c(2,1)]; qnts&lt;-quantile(data0[,1],c(0.05,0.25,0.5,0.75,0.95))
out&lt;- par_distreg(qnts,data0,no_cores=1,iter = 102, burn = 2)
par(mfrow=c(3,2));invisible(apply(out,1,function(x)plot(density(x,30))));par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='parLply'>Parallel compute</h2><span id='topic+parLply'></span>

<h3>Description</h3>

<p><code>parLply</code> uses <code>parlapply</code> from the <code>parallel</code> package with 
a function as input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parLply(vec, fn, type = "FORK", no_cores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parLply_+3A_vec">vec</code></td>
<td>
<p>vector of inputs over which to parallel compute</p>
</td></tr>
<tr><td><code id="parLply_+3A_fn">fn</code></td>
<td>
<p>the function</p>
</td></tr>
<tr><td><code id="parLply_+3A_type">type</code></td>
<td>
<p>this option is set to &quot;FORK&quot;, use &quot;PSOCK&quot; on windows</p>
</td></tr>
<tr><td><code id="parLply_+3A_no_cores">no_cores</code></td>
<td>
<p>the number of cores to use. Defaults at 1</p>
</td></tr>
<tr><td><code id="parLply_+3A_...">...</code></td>
<td>
<p>extra inputs to <code>fn()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>out parallel computed output
</p>

<hr>
<h2 id='posterior'>Posterior distribution</h2><span id='topic+posterior'></span>

<h3>Description</h3>

<p><code>posterior</code> computes the value of the posterior at parameter values <code>pars</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior(pars, data, Log = TRUE, mu = 0, sig = 25,
  prior = "Normal")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_+3A_pars">pars</code></td>
<td>
<p>parameter values</p>
</td></tr>
<tr><td><code id="posterior_+3A_data">data</code></td>
<td>
<p>dataframe. The first column must be the binary dependent variable</p>
</td></tr>
<tr><td><code id="posterior_+3A_log">Log</code></td>
<td>
<p>logical to take the log of the posterior.(defaults to TRUE)</p>
</td></tr>
<tr><td><code id="posterior_+3A_mu">mu</code></td>
<td>
<p>mean of prior of each parameter value in case the prior is Normal (default: 0)</p>
</td></tr>
<tr><td><code id="posterior_+3A_sig">sig</code></td>
<td>
<p>standard deviation of prior of each parameter in case the prior is Normal 
(default: 25)</p>
</td></tr>
<tr><td><code id="posterior_+3A_prior">prior</code></td>
<td>
<p>string input of &quot;Normal&quot; or &quot;Uniform&quot; prior distribution to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>val value function of the posterior
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = indicat(faithful$waiting,mean(faithful$waiting)) 
x = scale(cbind(faithful$eruptions,faithful$eruptions^2))
data = data.frame(y,x)
posterior(rep(0,3),data,Log = FALSE,mu=0,sig = 10,prior = "Normal") # no log
posterior(rep(0,3),data,Log = TRUE,mu=0,sig = 10,prior = "Normal") # log
posterior(rep(0,3),data,Log = TRUE) # use default values

</code></pre>

<hr>
<h2 id='prior_n'>Normal Prior distribution</h2><span id='topic+prior_n'></span>

<h3>Description</h3>

<p>This normal prior distribution is a product of univariate N(mu,sig)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_n(pars, mu, sig, Log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_n_+3A_pars">pars</code></td>
<td>
<p>parameter values</p>
</td></tr>
<tr><td><code id="prior_n_+3A_mu">mu</code></td>
<td>
<p>mean value of each parameter value</p>
</td></tr>
<tr><td><code id="prior_n_+3A_sig">sig</code></td>
<td>
<p>standard deviation of each parameter value</p>
</td></tr>
<tr><td><code id="prior_n_+3A_log">Log</code></td>
<td>
<p>logical to take the log of prior or not (defaults to FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>val Product of probability values for each parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prior_n(rep(0,6),0,10,Log = TRUE) #log of prior
prior_n(rep(0,6),0,10,Log = FALSE) #no log

</code></pre>

<hr>
<h2 id='prior_u'>Uniform Prior distribution</h2><span id='topic+prior_u'></span>

<h3>Description</h3>

<p>This uniform prior distribution proportional to 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_u(pars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_u_+3A_pars">pars</code></td>
<td>
<p>parameter values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>val value of joint prior =1 for the uniform prior
</p>

<hr>
<h2 id='quant_bdr'>Quantile conversion of a bayesian distribution matrix</h2><span id='topic+quant_bdr'></span>

<h3>Description</h3>

<p><code>quant_bdr</code> converts a bayesian distribution regression matrix from <code>par_distreg()</code>
output to a matrix of quantile distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quant_bdr(taus, thresh, mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quant_bdr_+3A_taus">taus</code></td>
<td>
<p>a vector of quantile indices</p>
</td></tr>
<tr><td><code id="quant_bdr_+3A_thresh">thresh</code></td>
<td>
<p>a vector of threshold values used in a <code>par_distreg()</code> type function</p>
</td></tr>
<tr><td><code id="quant_bdr_+3A_mat">mat</code></td>
<td>
<p>bayesian distribution regression output matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>qmat matrix of quantile distribution
</p>

<hr>
<h2 id='RWMH'>Random Walk Metropolis-Hastings Algorithm</h2><span id='topic+RWMH'></span>

<h3>Description</h3>

<p><code>RWMH</code> computes random draws of parameters using a specified proposal distribution.
The default is the normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RWMH(data, propob = NULL, posterior = NULL, iter = 1500,
  burn = 500, vscale = 1.5, start = NULL, prior = "Normal",
  mu = 0, sig = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RWMH_+3A_data">data</code></td>
<td>
<p>data required for the posterior distribution. First column is the outcome</p>
</td></tr>
<tr><td><code id="RWMH_+3A_propob">propob</code></td>
<td>
<p>a list of mean and variance-covariance of the normal proposal distribution
(default: NULL i.e. internally generated)</p>
</td></tr>
<tr><td><code id="RWMH_+3A_posterior">posterior</code></td>
<td>
<p>the posterior distribution. It is set to null in order to use the logit posterior.
The user can specify log posterior as a function of parameters and data (pars,data)</p>
</td></tr>
<tr><td><code id="RWMH_+3A_iter">iter</code></td>
<td>
<p>number of random draws desired</p>
</td></tr>
<tr><td><code id="RWMH_+3A_burn">burn</code></td>
<td>
<p>burn-in period for the Random Walk MH algorithm</p>
</td></tr>
<tr><td><code id="RWMH_+3A_vscale">vscale</code></td>
<td>
<p>a positive value to scale up or down the variance-covariance matrix in
the proposal distribution</p>
</td></tr>
<tr><td><code id="RWMH_+3A_start">start</code></td>
<td>
<p>starting values of parameters for the MH algorithm.
It is automatically generated from the proposal distribution but the user can also specify.</p>
</td></tr>
<tr><td><code id="RWMH_+3A_prior">prior</code></td>
<td>
<p>the prior distribution (default: &quot;Normal&quot;, alternative: &quot;Uniform&quot;)</p>
</td></tr>
<tr><td><code id="RWMH_+3A_mu">mu</code></td>
<td>
<p>the mean of the normal prior distribution (default:0)</p>
</td></tr>
<tr><td><code id="RWMH_+3A_sig">sig</code></td>
<td>
<p>the variance of the normal prior distribution (default:10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>val a list of matrix of draws Matpram and the acceptance rate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = indicat(faithful$waiting,70)
x = scale(cbind(faithful$eruptions,faithful$eruptions^2))
data = data.frame(y,x); propob&lt;- lapl_aprx(y,x)
RWMHob_n&lt;- RWMH(data=data,propob,iter = 102, burn = 2) # prior="Normal"
RWMHob_u&lt;- RWMH(data=data,propob,prior="Uniform",iter = 102, burn = 2)
par(mfrow=c(3,1));invisible(apply(RWMHob_n$Matpram,2,function(x)plot(density(x))))
invisible(apply(RWMHob_u$Matpram,2,function(x)plot(density(x))));par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='simcnfB'>Symmetric simultaneous bayesian confidence bands</h2><span id='topic+simcnfB'></span>

<h3>Description</h3>

<p><code>simcnfB</code> obtains symmetric bayesian distribution confidence bands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simcnfB(DF, DFmat, alpha = 0.05, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simcnfB_+3A_df">DF</code></td>
<td>
<p>the target distribution/quantile function as a vector</p>
</td></tr>
<tr><td><code id="simcnfB_+3A_dfmat">DFmat</code></td>
<td>
<p>the matrix of draws of the distribution, rows correspond to 
elements in <code>DF</code></p>
</td></tr>
<tr><td><code id="simcnfB_+3A_alpha">alpha</code></td>
<td>
<p>level such that <code>1-alpha</code> is the desired probability of coverage</p>
</td></tr>
<tr><td><code id="simcnfB_+3A_scale">scale</code></td>
<td>
<p>logical for scaling using the inter-quartile range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cstar - a constant to add and subtract from DF to create 
confidence bands if no scaling=FALSE else a vector of length DF.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(14); m=matrix(rbeta(500,1,4),nrow = 5) + 1:5
DF = apply(m,1,mean); plot(1:5,DF,type="l",ylim = c(0,max(m)), xlab = "Index")
symCB&lt;- simcnfB(DF,DFmat = m)
lines(1:5,DF-symCB,lty=2); lines(1:5,DF+symCB,lty=2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
