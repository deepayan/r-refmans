<!DOCTYPE html><html><head><title>Help for package bde</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bde}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bde'><p>Generic bounded density constructor</p></a></li>
<li><a href='#beta_0.75_0.65'><p>Synthetic dataset from a beta distribution</p></a></li>
<li><a href='#beta_1_10'><p>Synthetic dataset from a beta distribution</p></a></li>
<li><a href='#beta_5_10'><p>Synthetic dataset from a beta distribution</p></a></li>
<li><a href='#boundedDensity'><p><code>BoundedDensity</code> generator method</p></a></li>
<li><a href='#BoundedDensity'><p>Class <code>"BoundedDensity"</code></p></a></li>
<li><a href='#brVitale'><p><code>BrVitale</code> generator method</p></a></li>
<li><a href='#BrVitale'><p>Class <code>"BrVitale"</code></p></a></li>
<li><a href='#chen99Kernel'><p><code>chen99Kernel</code> generator method</p></a></li>
<li><a href='#Chen99Kernel'><p>Class <code>"Chen99Kernel"</code></p></a></li>
<li><a href='#density'><p>Probability Density Function (pdf)</p></a></li>
<li><a href='#distribution'><p>Cumulative Density Function (cdf)</p></a></li>
<li><a href='#eruption'><p>Eruption lengths of Old Faithful geyser</p></a></li>
<li><a href='#getb'><p>Accesor method for <code>b</code> slot</p></a></li>
<li><a href='#getc'><p>Accesor method for <code>c</code> slot</p></a></li>
<li><a href='#getdataPoints'><p>Accesor method for <code>dataPoints</code> slot</p></a></li>
<li><a href='#getdataPointsCache'><p>Accesor method for <code>DataPointsCache</code> slot</p></a></li>
<li><a href='#getdensityCache'><p>Accesor method for <code>densityCache</code> slot</p></a></li>
<li><a href='#getdensityEstimator'><p>Accesor method for <code>gamma</code> slot</p></a></li>
<li><a href='#getdistributionCache'><p>Accesor method for <code>distributionCache</code> slot</p></a></li>
<li><a href='#getgamma'><p>Accesor method for <code>gamma</code> slot</p></a></li>
<li><a href='#getm'><p>Accesor method for <code>m</code> slot</p></a></li>
<li><a href='#getM'><p>Accesor method for <code>M</code> slot</p></a></li>
<li><a href='#getmodified'><p>Accesor method for <code>modified</code> slot</p></a></li>
<li><a href='#getmu'><p>Accesor method for <code>Mu</code> slot</p></a></li>
<li><a href='#getSubclasses'><p>List of subclasses</p></a></li>
<li><a href='#gplot'><p>Bounded Density Plotting based on ggplot2</p></a></li>
<li><a href='#hirukawaJLNKernel'><p><code>HirukawaJLNKernel</code> generator method</p></a></li>
<li><a href='#HirukawaJLNKernel'><p>Class <code>"HirukawaJLNKernel"</code></p></a></li>
<li><a href='#hirukawaTSKernel'><p><code>HirukawaTSKernel</code> generator method</p></a></li>
<li><a href='#HirukawaTSKernel'><p>Class <code>"HirukawaTSKernel"</code></p></a></li>
<li><a href='#jonesCorrectionMuller91BoundaryKernel'><p><code>JonesCorrectionMuller91BoundaryKernel</code> generator method</p></a></li>
<li><a href='#JonesCorrectionMuller91BoundaryKernel'><p>Class <code>"JonesCorrectionMuller91BoundaryKernel"</code></p></a></li>
<li><a href='#jonesCorrectionMuller94BoundaryKernel'><p><code>JonesCorrectionMuller94BoundaryKernel</code> generator method</p></a></li>
<li><a href='#JonesCorrectionMuller94BoundaryKernel'><p>Class <code>"JonesCorrectionMuller94BoundaryKernel"</code></p></a></li>
<li><a href='#kakizawaB1'><p><code>KakizawaB1</code> generator method</p></a></li>
<li><a href='#KakizawaB1'><p>Class <code>"KakizawaB1"</code></p></a></li>
<li><a href='#kakizawaB2'><p><code>KakizawaB2</code> generator method</p></a></li>
<li><a href='#KakizawaB2'><p>Class <code>"KakizawaB2"</code></p></a></li>
<li><a href='#kakizawaB3'><p><code>KakizawaB3</code> generator method</p></a></li>
<li><a href='#KakizawaB3'><p>Class <code>"KakizawaB3"</code></p></a></li>
<li><a href='#launchApp'><p>Shiny launch application</p></a></li>
<li><a href='#lines'><p>Add a Bounded Density pdf to a Plot</p></a></li>
<li><a href='#macroBetaChen99Kernel'><p><code>MacroBetaChen99Kernel</code> generator method</p></a></li>
<li><a href='#MacroBetaChen99Kernel'><p>Class <code>"MacroBetaChen99Kernel"</code></p></a></li>
<li><a href='#macroBetaHirukawaJLNKernel'><p><code>MacroBetaHirukawaJLNKernel</code> generator method</p></a></li>
<li><a href='#MacroBetaHirukawaJLNKernel'><p>Class <code>"MacroBetaHirukawaJLNKernel"</code></p></a></li>
<li><a href='#macroBetaHirukawaTSKernel'><p><code>MacroBetaHirukawaTSKernel</code> generator method</p></a></li>
<li><a href='#MacroBetaHirukawaTSKernel'><p>Class <code>"MacroBetaHirukawaTSKernel"</code></p></a></li>
<li><a href='#microBetaChen99Kernel'><p><code>MicroBetaChen99Kernel</code> generator method</p></a></li>
<li><a href='#MicroBetaChen99Kernel'><p>Class <code>"MicroBetaChen99Kernel"</code></p></a></li>
<li><a href='#mise'><p>Mean Integrated Squared Error</p></a></li>
<li><a href='#muller91BoundaryKernel'><p><code>Muller91BoundaryKernel</code> generator method</p></a></li>
<li><a href='#Muller91BoundaryKernel'><p>Class <code>"Muller91BoundaryKernel"</code></p></a></li>
<li><a href='#muller94BoundaryKernel'><p><code>Muller94BoundaryKernel</code> generator method</p></a></li>
<li><a href='#Muller94BoundaryKernel'><p>Class <code>"Muller94BoundaryKernel"</code></p></a></li>
<li><a href='#noBoundaryKernel'><p><code>NoBoundaryKernel</code> generator method</p></a></li>
<li><a href='#NoBoundaryKernel'><p>Class <code>"NoBoundaryKernel"</code></p></a></li>
<li><a href='#normalizedBoundaryKernel'><p><code>NormalizedBoundaryKernel</code> generator method</p></a></li>
<li><a href='#NormalizedBoundaryKernel'><p>Class <code>"NormalizedBoundaryKernel"</code></p></a></li>
<li><a href='#plot'><p>Bounded Density Plotting</p></a></li>
<li><a href='#quantile'><p>Quantile</p></a></li>
<li><a href='#rsample'><p>Random sample</p></a></li>
<li><a href='#suicide.r'><p>Scaled data from suicide risk data</p></a></li>
<li><a href='#tgaussian'><p>Synthetic dataset from a truncated Gaussian distribution</p></a></li>
<li><a href='#tuna.r'><p>Scaled <code>tuna</code> data</p></a></li>
<li><a href='#vitale'><p><code>Vitale</code> generator method</p></a></li>
<li><a href='#Vitale'><p>Class <code>"Vitale"</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bounded Density Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2013-06-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Guzman Santafe, Borja Calvo, Aritz Perez and Jose A. Lozano</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guzman Santafe &lt;guzman.santafe@unavarra.es&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), shiny, ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of S4 classes which implements different methods to estimate and deal with densities in bounded domains. That is, densities defined within the interval [lower.limit, upper.limit], where lower.limit and upper.limit are values that can be set by the user.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Collate:</td>
<td>BoundedDensity.R KernelDensity.R Chen99Kernel.R
MicroBetaChen99Kernel.R MacroBetaChen99Kernel.R
BoundaryKernel.R NoBoundaryKernel.R NormalizedBoundaryKernel.R
Muller91BoundaryKernel.R
JonesCorrectionMuller91BoundaryKernel.R
Muller94BoundaryKernel.R
JonesCorrectionMuller94BoundaryKernel.R BernsteinPolynomials.R
Vitale.R BrVitale.R KakizawaB1.R KakizawaB2.R KakizawaB3.R
HirukawaJLNKernel.R HirukawaTSKernel.R
MacroBetaHirukawaJLNKernel.R MacroBetaHirukawaTSKernel.R
utils.R bde.R</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-10 14:29:44 UTC; hornik</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-10 14:39:25 UTC</td>
</tr>
</table>
<hr>
<h2 id='bde'>Generic bounded density constructor</h2><span id='topic+bde'></span>

<h3>Description</h3>

<p>Function to access all the methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bde(dataPoints,dataPointsCache=NULL,estimator,b=length(sample)^{-2/5}, 
    lower.limit=0, upper.limit=1,options=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bde_+3A_datapoints">dataPoints</code></td>
<td>
<p>Vector containing the points to be used to estimate the density.</p>
</td></tr>
<tr><td><code id="bde_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>Points where the density has to be estimated. If omitted, 101 points equally distributed in the [lower.limit,upper.limit] interval are used</p>
</td></tr>
<tr><td><code id="bde_+3A_estimator">estimator</code></td>
<td>
<p>Density estimator to be used. This has to be one of the following:
</p>

<ul>
<li><p><code>"betakernel"</code>: Chen's beta kernel density estimator
</p>
</li>
<li><p><code>"vitale"</code>: Vitale's Bernstein polynomial based estimator
</p>
</li>
<li><p><code>"boundarykernel"</code>: Boundary kernel based density estimators, as proposed by Muller et al.
</p>
</li>
<li><p><code>"kakizawa"</code>: Kakizawa's density estimators
</p>
</li></ul>

</td></tr>
<tr><td><code id="bde_+3A_b">b</code></td>
<td>
<p>Bandwidth to be used. Note that in the case of Vitale's estimator the m parameter is set at <code>1/b</code></p>
</td></tr>
<tr><td><code id="bde_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="bde_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr> 
<tr><td><code id="bde_+3A_options">options</code></td>
<td>
<p>A list containing the different options available for the estimators:</p>
</td></tr>
</table>

<ul>
<li><p>betakernel:
</p>

<ul>
<li><p><code>"modified"</code>: a logical value indicating whether the modified kernel has to be used or not. False by default
</p>
</li>
<li><p><code>"normalization"</code>: a string: <code>"none"</code>, to use the original kernels, <code>"densitywise"</code> to use the macrobeta kernels and <code>"kernelwise"</code> to use the microbeta kernels. If not specified, no normalization is used
</p>
</li>
<li><p><code>"mbc"</code>: a string indicating the multiplicative bias correction to be used: <code>"none"</code>, no correction is used, <code>"jnl"</code> Hirukawa's JNL approach, <code>"ts"</code> Hirukawa's TS approach. If not specified, no correction is used
</p>
</li>
<li><p><code>"c"</code>: a numeric value between 0 and 1 corresponding to the <code>c</code> parameter in the TS correction (it is only taken into consideration if TS correction is selected). Default value is set to 0.5
</p>
</li></ul>

</li>
<li><p>vitale:
</p>

<ul>
<li><p><code>"biasreduced"</code>: a logical value. If true, Leblanc's bias reduced estimator is used; otherwise the original estimator is used. False by default
</p>
</li></ul>

</li>
<li><p>boundarykernel:
</p>

<ul>
<li><p><code>"mu"</code>: numeric parameter to indicate the kind of kernel. Options are 0, for the rectangular function, 1 for Epanechnikov's kernel, 2 for the quadratic and 3 for the biquadratic. Default value is set at 1
</p>
</li>
<li><p><code>"method"</code>: a string indicating the functions to be used: <code>"Muller94"</code> (default value), <code>"Muller91"</code>, <code>"Normalize"</code> or <code>"None"</code>
</p>
</li>
<li><p><code>"corrected"</code>: a logical value indicating whether Jones' non-negativity correction should be used. By default it is set to false
</p>
</li></ul>

</li>
<li><p>kakizawa:
</p>

<ul>
<li><p><code>"method"</code>: a string indicating the function to be used <code>"b1"</code>, <code>"b2"</code> or <code>"b3"</code> (default value).
</p>
</li>
<li><p><code>"estimator"</code>: a Bounded Density estimator. See all accepted classes here with <code>getSubclasses("BoundedDensity")</code>. If no estimator is provided, a Muller94BoundaryKernel estimator with default parameters and the same dataPoints as those give for the Kakizawa estimator is used.
</p>
</li>
<li><p><code>"gamma"</code>: in case that <code>b1</code> function is used the <code>gamma</code> parameter is required. This parameter takes 0.5 as default value.
</p>
</li></ul>

</li></ul>


<hr>
<h2 id='beta_0.75_0.65'>Synthetic dataset from a beta distribution</h2><span id='topic+beta_0.75_0.65'></span>

<h3>Description</h3>

<p>This is a synthetic generated dataset sampling a beta distribution with parameters <code>shape1 = 0.75</code> and <code>shape2 = 0.65</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_0.75_0.65</code></pre>


<h3>Format</h3>

<p>A vector containing 10000 observations.</p>

<hr>
<h2 id='beta_1_10'>Synthetic dataset from a beta distribution</h2><span id='topic+beta_1_10'></span>

<h3>Description</h3>

<p>This is a synthetic generated dataset sampling a beta distribution with parameters <code>shape1 = 1</code> and <code>shape2 = 10</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_1_10</code></pre>


<h3>Format</h3>

<p>A vector containing 10000 observations.</p>

<hr>
<h2 id='beta_5_10'>Synthetic dataset from a beta distribution</h2><span id='topic+beta_5_10'></span>

<h3>Description</h3>

<p>This is a synthetic generated dataset sampling a beta distribution with parameters <code>shape1 = 5</code> and <code>shape2 = 10</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_5_10</code></pre>


<h3>Format</h3>

<p>A vector containing 10000 observations.</p>

<hr>
<h2 id='boundedDensity'><code>BoundedDensity</code> generator method</h2><span id='topic+boundedDensity'></span><span id='topic+boundedDensity-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>BoundedDensity</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundedDensity(x,densities,lower.limit=0,upper.limit=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundedDensity_+3A_x">x</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval.</p>
</td></tr>
<tr><td><code id="boundedDensity_+3A_densities">densities</code></td>
<td>
<p>a numeric vector containing the density for each point in <code>x</code></p>
</td></tr>
<tr><td><code id="boundedDensity_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="boundedDensity_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+BoundedDensity-class">BoundedDensity</a></code> class for more details.

</p>

<hr>
<h2 id='BoundedDensity'>Class <code>"BoundedDensity"</code></h2><span id='topic+BoundedDensity'></span><span id='topic+BoundedDensity-class'></span>

<h3>Description</h3>

<p>This class deals with generic estimations of a bounded densities. The probability density function is approximated by providing a set of data points in a lower and upper bounded interval and their associated densities. Using this information, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+boundedDensity">boundedDensity</a></code>.

</p>


<h3>Slots</h3>


<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data points and its densities
a &lt;- seq(0,1,0.01)
b &lt;- dbeta(a,5,10)

# create the density model
model &lt;- boundedDensity(x=a,densities=b)

# examples of usual functions
density(model,0.5)

distribution(model,0.2,discreteApproximation=FALSE)
distribution(model,0.2,discreteApproximation=TRUE)
 
# graphical representation
hist(b,freq=FALSE)
lines(model, col="red",lwd=2)

</code></pre>

<hr>
<h2 id='brVitale'><code>BrVitale</code> generator method</h2><span id='topic+brVitale'></span><span id='topic+brVitale-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>BrVitale</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brVitale(dataPoints, m=round(length(dataPoints)^(2/5)), M=NULL, dataPointsCache=NULL, 
          lower.limit = 0, upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brVitale_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr> 
<tr><td><code id="brVitale_+3A_m">m</code></td>
<td>
<p>a integer value indicating the order of the polynomial approximation. <code>m</code> must take values greater than 0</p>
</td></tr>
<tr><td><code id="brVitale_+3A_m">M</code></td>
<td>
<p>a numeric value indicating the parameter for bias reduction, with <code>m &gt; M</code>. If <code>M=NULL</code>, the value <code>m/2</code>, which leads to optimal MISE (mean integrated squared error) properties, is taken as default</p>
</td></tr>
<tr><td><code id="brVitale_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>
<tr><td><code id="brVitale_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="brVitale_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>   
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+BrVitale-class">BrVitale</a></code> class for more details.

</p>

<hr>
<h2 id='BrVitale'>Class <code>"BrVitale"</code></h2><span id='topic+BrVitale'></span><span id='topic+BrVitale-class'></span>

<h3>Description</h3>

<p>This class deals with bias reduced version of Vitale (1975) Bernstein Polynomial approximation as described in Leblanc (2009). The polynomial estimator is computed using the provided data samples. Using this polynomial estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+brVitale">brVitale</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>m</code>:</dt><dd><p>the order of the polynomial approximation</p>
</dd>    
<dt><code>M</code>:</dt><dd><p>a numeric parameter for bias reduction. Usually this parameter is set to <code>m/2</code> since it leads to optimal MISE (mean integrated squared error) properties</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getm</dt><dd><p>See <code>"<a href="#topic+getm">getm</a>"</code> for details</p>
</dd> 
<dt>getM</dt><dd><p>See <code>"<a href="#topic+getM">getM</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Vitale, R. A. (1975). A Bernstein polynomial approach to density function estimation.
<em>tatistical Inference and Related Topics</em>, 2, 87-99.
</p>
<p>Leblanc, A. (2010). A bias-reduced approach to density estimation using Bernstein polynomials.
<em>Journal of Nonparametric Statistics</em>, 22(4), 459-475.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
model &lt;- brVitale(dataPoints = tuna.r, m = 25, M = 25/2)


# examples of usual functions
density(model,0.5)

distribution(model,0.5,discreteApproximation=FALSE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Tuna Data")
lines(model, col="red",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(model,show=TRUE,includePoints=TRUE)
</code></pre>

<hr>
<h2 id='chen99Kernel'><code>chen99Kernel</code> generator method</h2><span id='topic+chen99Kernel'></span><span id='topic+chen99Kernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>Chen99Kernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chen99Kernel(dataPoints, b=length(dataPoints)^(-2/5), dataPointsCache=NULL, 
              modified = FALSE, lower.limit = 0, upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chen99Kernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr> 
<tr><td><code id="chen99Kernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>
<tr><td><code id="chen99Kernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>
<tr><td><code id="chen99Kernel_+3A_modified">modified</code></td>
<td>
<p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</td></tr>
<tr><td><code id="chen99Kernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="chen99Kernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>   
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+Chen99Kernel-class">Chen99Kernel</a></code> class for more details.

</p>

<hr>
<h2 id='Chen99Kernel'>Class <code>"Chen99Kernel"</code></h2><span id='topic+Chen99Kernel'></span><span id='topic+Chen99Kernel-class'></span>

<h3>Description</h3>

<p>This class deals with Kernel estimators for bounded densities as described in Chen's 99 paper. The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+chen99Kernel">chen99Kernel</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>modified</code>:</dt><dd><p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmodified</dt><dd><p>See <code>"<a href="#topic+getmodified">getmodified</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Chen, S. X. (1999). Beta kernel estimators for density functions.
<em>Computational Statistics &amp; Data Analysis</em>, 31, 131-145.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
kernel.noModified &lt;- chen99Kernel(dataPoints = tuna.r, b = 0.01, modified = FALSE)
kernel.Modified &lt;- chen99Kernel(dataPoints = tuna.r, b = 0.01, modified = TRUE)

# examples of usual functions
density(kernel.noModified,0.5)
density(kernel.Modified,0.5)

distribution(kernel.noModified,1,discreteApproximation=FALSE)
distribution(kernel.noModified,1,discreteApproximation=TRUE)
 
distribution(kernel.Modified,1,discreteApproximation=FALSE)
distribution(kernel.Modified,1,discreteApproximation=TRUE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Chen99 Kernels Tuna Data")
lines(kernel.noModified,col="red",lwd=2)
lines(kernel.Modified,col="blue",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(list("KernelNoModified"=kernel.noModified,
                "KernelModified"=kernel.Modified),show=TRUE)
</code></pre>

<hr>
<h2 id='density'>Probability Density Function (pdf)</h2><span id='topic+density'></span><span id='topic+density-method'></span><span id='topic+density+2CBoundedDensity-method'></span><span id='topic+density+2CChen99Kernel-method'></span><span id='topic+density+2CMicroBetaChen99Kernel-method'></span><span id='topic+density+2CMacroBetaChen99Kernel-method'></span><span id='topic+density+2CBoundaryKernel-method'></span><span id='topic+density+2CNoBoundaryKernel-method'></span><span id='topic+density+2CMuller91BoundaryKernel-method'></span><span id='topic+density+2CMuller94BoundaryKernel-method'></span><span id='topic+density+2CNormalizedBoundaryKernel-method'></span><span id='topic+density+2CVitale-method'></span><span id='topic+density+2CBrVitale-method'></span><span id='topic+density+2CKakizawaB1-method'></span><span id='topic+density+2CKakizawaB2-method'></span><span id='topic+density+2CKakizawaB3-method'></span><span id='topic+density+2CHirukawaJLNKernel-method'></span><span id='topic+density+2CHirukawaTSKernel-method'></span><span id='topic+density+2CMacroBetaHirukawaJLNKernel-method'></span><span id='topic+density+2CMacroBetaHirukawaTSKernel-method'></span><span id='topic+density+2CJonesCorrectionMuller91BoundaryKernel-method'></span><span id='topic+density+2CJonesCorrectionMuller94BoundaryKernel-method'></span>

<h3>Description</h3>

<p>Density function for the given bounded density object.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_+3A_x">x</code></td>
<td>
<p>A bounded density estimator. See all the accepted classes here by running the command <code>getSubclasses("BoundedDensity")</code>. This parameter is named <code>x</code> instead of <code>.Object</code> to agree with other already defined density methods</p>
</td></tr>
<tr><td><code id="density_+3A_values">values</code></td>
<td>
<p>Vector of points where the density function is evaluated. These points must be in the interval [<code>x@lower.limit,x@upper.limit</code>]. This parameter is named <code>values</code> instead of <code>x</code> to agree with other already defined density methods</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>density(x,values)</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='distribution'>Cumulative Density Function (cdf)</h2><span id='topic+distribution'></span><span id='topic+distribution-methods'></span><span id='topic+distribution+2CBoundedDensity-method'></span><span id='topic+distribution+2CKernelDensity-method'></span><span id='topic+distribution+2CChen99Kernel-method'></span><span id='topic+distribution+2CMicroBetaChen99Kernel-method'></span><span id='topic+distribution+2CMacroBetaChen99Kernel-method'></span><span id='topic+distribution+2CBoundaryKernel-method'></span><span id='topic+distribution+2CNoBoundaryKernel-method'></span><span id='topic+distribution+2CMuller91BoundaryKernel-method'></span><span id='topic+distribution+2CMuller94BoundaryKernel-method'></span><span id='topic+distribution+2CJonesCorrectionMuller91BoundaryKernel-method'></span><span id='topic+distribution+2CJonesCorrectionMuller94BoundaryKernel-method'></span><span id='topic+distribution+2CNormalizedBoundaryKernel-method'></span><span id='topic+distribution+2CBernsteinPolynomials-method'></span><span id='topic+distribution+2CVitale-method'></span><span id='topic+distribution+2CBrVitale-method'></span><span id='topic+distribution+2CKakizawaB1-method'></span><span id='topic+distribution+2CKakizawaB2-method'></span><span id='topic+distribution+2CKakizawaB3-method'></span><span id='topic+distribution+2CHirukawaJLNKernel-method'></span><span id='topic+distribution+2CHirukawaTSKernel-method'></span><span id='topic+distribution+2CMacroBetaHirukawaJLNKernel-method'></span><span id='topic+distribution+2CMacroBetaHirukawaTSKernel-method'></span>

<h3>Description</h3>

<p>Distribution function for the given bounded density object
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribution_+3A_.object">.Object</code></td>
<td>
<p>A bounded density estimator. See all the accepted classes here by running the command <code>getSubclasses("BoundedDensity")</code>.</p>
</td></tr>
<tr><td><code id="distribution_+3A_x">x</code></td>
<td>
<p>Vector of points where the density function is evaluated. These points must be in the interval [<code>.Object@lower.limit,.Object@upper.limit</code>]</p>
</td></tr>
<tr><td><code id="distribution_+3A_discreteapproximation">discreteApproximation</code></td>
<td>
<p>Logical; if <code>TRUE</code> the distribution function is computed using a discrete approximation using the values cached in <code>dataPointsCache</code> and <code>densityCache</code>. Otherwise, the integral of the density function is evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>discreteApproximation</code> is not specified it assumes the default value <code>TRUE</code>. When the distribution function is used with a <code>BoundedDensity</code> object, <code>discreteApproximation</code> value is and a discrete approximation is always obtained.
</p>


<h3>Methods</h3>


<dl>
<dt><code>distribution(.Object,x,discreteApproximation=TRUE)</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='eruption'>Eruption lengths of Old Faithful geyser</h2><span id='topic+eruption'></span>

<h3>Description</h3>

<p>The dataset comprises lengths (in minutes) of eruptions of Old Faithful geyser in Yellowstone National Park, USA. The data are within the interval [1.67,4.93].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eruption</code></pre>


<h3>Format</h3>

<p>A vector containing 107 observations.</p>


<h3>Source</h3>

<p>The data were obtained from Silverman (1996) Table 2.2</p>


<h3>References</h3>

<p>Silverman, B. (1986). <em>Density Estimation for Statistics and Data Analysis</em>. 
Chapman &amp; Hall
</p>
<p>Weisberg, S. (1980). <em>Applied linear regression</em>.
John Wiley &amp; Sons, Canada
</p>

<hr>
<h2 id='getb'>Accesor method for <code>b</code> slot</h2><span id='topic+getb'></span><span id='topic+getb-methods'></span><span id='topic+getb+2CKernelDensity-method'></span><span id='topic+getb+2CChen99Kernel-method'></span><span id='topic+getb+2CMicroBetaChen99Kernel-method'></span><span id='topic+getb+2CMacroBetaChen99Kernel-method'></span><span id='topic+getb+2CNoBoundaryKernel-method'></span><span id='topic+getb+2CMuller91BoundaryKernel-method'></span><span id='topic+getb+2CMuller94BoundaryKernel-method'></span><span id='topic+getb+2CNormalizedBoundaryKernel-method'></span><span id='topic+getb+2CHirukawaJLNKernel-method'></span><span id='topic+getb+2CHirukawaTSKernel-method'></span><span id='topic+getb+2CMacroBetaHirukawaJLNKernel-method'></span><span id='topic+getb+2CMacroBetaHirukawaTSKernel-method'></span>

<h3>Description</h3>

<p>This method obtains the values stored in the <code>b</code> slot of a bounded density object. This slot contains the bandwidth parameter for the kernel estimator.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getb_+3A_.object">.Object</code></td>
<td>
<p>A kernel density estimator.  See all the accepted classes here by running the command <code>getSubclasses("KernelDensity")</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>getb(.Object)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='getc'>Accesor method for <code>c</code> slot</h2><span id='topic+getc'></span><span id='topic+getc-methods'></span><span id='topic+getc+2CHirukawaTSKernel-method'></span>

<h3>Description</h3>

<p>This method obtains the values stored in the <code>c</code> slot of a HirukawaTSKernel object. This parameter is used in the kernel estimation as a smoothing parameter.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getc_+3A_.object">.Object</code></td>
<td>
<p>A <code><a href="#topic+HirukawaTSKernel-class">HirukawaTSKernel</a></code> or a <code><a href="#topic+MacroBetaHirukawaTSKernel-class">MacroBetaHirukawaTSKernel</a></code> object.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>getc(.Object)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='getdataPoints'>Accesor method for <code>dataPoints</code> slot</h2><span id='topic+getdataPoints'></span><span id='topic+getdataPoints-methods'></span><span id='topic+getdataPoints+2CKernelDensity-method'></span><span id='topic+getdataPoints+2CChen99kernel-method'></span><span id='topic+getdataPoints+2CMicroBetaChen99Kernel-method'></span><span id='topic+getdataPoints+2CMacroBetaChen99Kernel-method'></span><span id='topic+getdataPoints+2CNoBoundaryKernel-method'></span><span id='topic+getdataPoints+2CMuller91BoundaryKernel-method'></span><span id='topic+getdataPoints+2CMuller94BoundaryKernel-method'></span><span id='topic+getdataPoints+2CNormalizedBoundaryKernel-method'></span><span id='topic+getdataPoints+2CBernsteinPolynomials-method'></span><span id='topic+getdataPoints+2CVitale-method'></span><span id='topic+getdataPoints+2CBrVitale-method'></span><span id='topic+getdataPoints+2CKakizawaB1-method'></span><span id='topic+getdataPoints+2CKakizawaB2-method'></span><span id='topic+getdataPoints+2CKakizawaB3-method'></span><span id='topic+getdataPoints+2CHirukawaJLNKernel-method'></span><span id='topic+getdataPoints+2CHirukawaTSKernel-method'></span><span id='topic+getdataPoints+2CMacroBetaHirukawaJLNKernel-method'></span><span id='topic+getdataPoints+2CMacroBetaHirukawaTSKernel-method'></span>

<h3>Description</h3>

<p>This method obtains the values stored in the <code>DataPoints</code> slot of a bounded density object. This slot contains the data sample used to estimate the density model.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getdataPoints_+3A_.object">.Object</code></td>
<td>
<p>A bounded density estimator.  See all the accepted classes by running the commands <code>getSubclasses("KernelDensity")</code> and <code>getSubclasses("BernsteinPolynomials")</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>getdataPoints(.Object)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='getdataPointsCache'>Accesor method for <code>DataPointsCache</code> slot</h2><span id='topic+getdataPointsCache'></span><span id='topic+getdataPointsCache-methods'></span><span id='topic+getdataPointsCache+2CBoundedDensity-method'></span><span id='topic+getdataPointsCache+2CChen99Kernel-method'></span><span id='topic+getdataPointsCache+2CMicroBetaChen99Kernel-method'></span><span id='topic+getdataPointsCache+2CMacroBetaChen99Kernel-method'></span><span id='topic+getdataPointsCache+2CNoBoundaryKernel-method'></span><span id='topic+getdataPointsCache+2CMuller91BoundaryKernel-method'></span><span id='topic+getdataPointsCache+2CMuller94BoundaryKernel-method'></span><span id='topic+getdataPointsCache+2CNormalizedBoundaryKernel-method'></span><span id='topic+getdataPointsCache+2CVitale-method'></span><span id='topic+getdataPointsCache+2CBrVitale-method'></span><span id='topic+getdataPointsCache+2CKakizawaB1-method'></span><span id='topic+getdataPointsCache+2CKakizawaB2-method'></span><span id='topic+getdataPointsCache+2CKakizawaB3-method'></span><span id='topic+getdataPointsCache+2CHirukawaJLNKernel-method'></span><span id='topic+getdataPointsCache+2CHirukawaTSKernel-method'></span><span id='topic+getdataPointsCache+2CMacroBetaHirukawaJLNKernel-method'></span><span id='topic+getdataPointsCache+2CMacroBetaHirukawaTSKernel-method'></span>

<h3>Description</h3>

<p>This method obtains the values stored in the <code>dataPointsCache</code> slot of a bounded density object.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getdataPointsCache_+3A_.object">.Object</code></td>
<td>
<p>A bounded density estimator.  See all the accepted classes here by running the command <code>getSubclasses("BoundedDensity")</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>getdataPointsCache(.Object)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='getdensityCache'>Accesor method for <code>densityCache</code> slot</h2><span id='topic+getdensityCache'></span><span id='topic+getdensityCache-methods'></span><span id='topic+getdensityCache+2CBoundedDensity-method'></span><span id='topic+getdensityCache+2CChen99Kernel-method'></span><span id='topic+getdensityCache+2CMicroBetaChen99Kernel-method'></span><span id='topic+getdensityCache+2CMacroBetaChen99Kernel-method'></span><span id='topic+getdensityCache+2CNoBoundaryKernel-method'></span><span id='topic+getdensityCache+2CMuller91BoundaryKernel-method'></span><span id='topic+getdensityCache+2CMuller94BoundaryKernel-method'></span><span id='topic+getdensityCache+2CNormalizedBoundaryKernel-method'></span><span id='topic+getdensityCache+2CVitale-method'></span><span id='topic+getdensityCache+2CBrVitale-method'></span><span id='topic+getdensityCache+2CKakizawaB1-method'></span><span id='topic+getdensityCache+2CKakizawaB2-method'></span><span id='topic+getdensityCache+2CKakizawaB3-method'></span><span id='topic+getdensityCache+2CHirukawaJLNKernel-method'></span><span id='topic+getdensityCache+2CHirukawaTSKernel-method'></span><span id='topic+getdensityCache+2CMacroBetaHirukawaJLNKernel-method'></span><span id='topic+getdensityCache+2CMacroBetaHirukawaTSKernel-method'></span>

<h3>Description</h3>

<p>This method obtains the values stored in the <code>DensityCache</code> slot of a bounded density object
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getdensityCache_+3A_.object">.Object</code></td>
<td>
<p>A bounded density estimator.  See all the accepted classes here by running the command <code>getSubclasses("BoundedDensity")</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>getdensityCache(.Object)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='getdensityEstimator'>Accesor method for <code>gamma</code> slot</h2><span id='topic+getdensityEstimator'></span><span id='topic+getdensityEstimator-methods'></span><span id='topic+getdensityEstimator+2CKakizawaB1-method'></span><span id='topic+getdensityEstimator+2CKakizawaB2-method'></span><span id='topic+getdensityEstimator+2CKakizawaB3-method'></span>

<h3>Description</h3>

<p>This method obtains the class name of the object stored in the <code>densityEstimator</code> slot of a KakizawaB1, KakizawaB2 or KakizawaB3 object.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getdensityEstimator_+3A_.object">.Object</code></td>
<td>
<p>A <code><a href="#topic+KakizawaB1-class">KakizawaB1</a></code>, <code><a href="#topic+KakizawaB2-class">KakizawaB2</a></code> or <code><a href="#topic+KakizawaB3-class">KakizawaB3</a></code> object.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>getdensityEstimator(.Object)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='getdistributionCache'>Accesor method for <code>distributionCache</code> slot</h2><span id='topic+getdistributionCache'></span><span id='topic+getdistributionCache-methods'></span><span id='topic+getdistributionCache+2CBoundedDensity-method'></span><span id='topic+getdistributionCache+2CChen99Kernel-method'></span><span id='topic+getdistributionCache+2CMicroBetaChen99Kernel-method'></span><span id='topic+getdistributionCache+2CMacroBetaChen99Kernel-method'></span><span id='topic+getdistributionCache+2CNoBoundaryKernel-method'></span><span id='topic+getdistributionCache+2CMuller91BoundaryKernel-method'></span><span id='topic+getdistributionCache+2CMuller94BoundaryKernel-method'></span><span id='topic+getdistributionCache+2CNormalizedBoundaryKernel-method'></span><span id='topic+getdistributionCache+2CVitale-method'></span><span id='topic+getdistributionCache+2CBrVitale-method'></span><span id='topic+getdistributionCache+2CKakizawaB1-method'></span><span id='topic+getdistributionCache+2CKakizawaB2-method'></span><span id='topic+getdistributionCache+2CKakizawaB3-method'></span><span id='topic+getdistributionCache+2CHirukawaJLNKernel-method'></span><span id='topic+getdistributionCache+2CHirukawaTSKernel-method'></span><span id='topic+getdistributionCache+2CMacroBetaHirukawaJLNKernel-method'></span><span id='topic+getdistributionCache+2CMacroBetaHirukawaTSKernel-method'></span>

<h3>Description</h3>

<p>This method obtains the values stored in the <code>DistributionCache</code> slot of a bounded density object.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getdistributionCache_+3A_.object">.Object</code></td>
<td>
<p>A bounded density estimator.  See all the accepted classes here by running the command <code>getSubclasses("BoundedDensity")</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>getdistributionCache(.Object)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='getgamma'>Accesor method for <code>gamma</code> slot</h2><span id='topic+getgamma'></span><span id='topic+getgamma-methods'></span><span id='topic+getgamma+2CKakizawaB1-method'></span>

<h3>Description</h3>

<p>This method obtains the values stored in the <code>gamma</code> slot of a KakizawaB1 object. This slot contains a parameter used in the B1 approximation using Bernstein polynomials.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getgamma_+3A_.object">.Object</code></td>
<td>
<p>A <code><a href="#topic+KakizawaB1-class">KakizawaB1</a></code> object.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>getgamma(.Object)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='getm'>Accesor method for <code>m</code> slot</h2><span id='topic+getm'></span><span id='topic+getm-methods'></span><span id='topic+getm+2CBernsteinPolynomials-method'></span><span id='topic+getm+2CVitale-method'></span>

<h3>Description</h3>

<p>This method obtains the values stored in the <code>m</code> slot of a BernsteinPolynomials object. This slot contains the order of the polynomial expansion.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getm_+3A_.object">.Object</code></td>
<td>
<p>A boundary kernel density estimator. See all the accepted classes here with  <code>getSubclasses("BernsteinPolynomials")</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>getm(.Object)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='getM'>Accesor method for <code>M</code> slot</h2><span id='topic+getM'></span><span id='topic+getM-methods'></span><span id='topic+getM+2CBernsteinPolynomials-method'></span><span id='topic+getM+2CBrVitale-method'></span>

<h3>Description</h3>

<p>This method obtains the values stored in the <code>M</code> slot of a BrVitale object. This slot contains parameter for bias reduction.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getM_+3A_.object">.Object</code></td>
<td>
<p>A <code><a href="#topic+BrVitale-class">BrVitale</a></code> Object.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>getM(.Object)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='getmodified'>Accesor method for <code>modified</code> slot</h2><span id='topic+getmodified'></span><span id='topic+getmodified-methods'></span><span id='topic+getmodified+2CChen99Kernel-method'></span><span id='topic+getmodified+2CMicroBetaChen99Kernel-method'></span><span id='topic+getmodified+2CMacroBetaChen99Kernel-method'></span><span id='topic+getmodified+2CHirukawaJLNKernel-method'></span><span id='topic+getmodified+2CHirukawaTSKernel-method'></span><span id='topic+getmodified+2CMacroBetaHirukawaJLNKernel-method'></span>

<h3>Description</h3>

<p>This method obtains the values stored in the <code>modified</code> slot of a Kernel density object. The value of this slot is <code>TRUE</code> if a modified version of the kernel estimator is used and <code>FALSE</code> otherwise.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getmodified_+3A_.object">.Object</code></td>
<td>
<p>A kernel density estimator.  See all the accepted classes here by running the command <code>getSubclasses("KernelDensity")</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>getgetmodified(.Object)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='getmu'>Accesor method for <code>Mu</code> slot</h2><span id='topic+getmu'></span><span id='topic+getmu-methods'></span><span id='topic+getmu+2CBoundaryKernel-method'></span><span id='topic+getmu+2CNoBoundaryKernel-method'></span>

<h3>Description</h3>

<p>This method obtains the values stored in the <code>mu</code> slot of a Boundary Kernel object. This slot contains the degree of smoothing for the boundary kernel estimator. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (bicuadratic kernel) or 3 (tricuadratic kernel).
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getmu_+3A_.object">.Object</code></td>
<td>
<p>A boundary kernel density estimator. See all the accepted classes here with <code>getSubclasses("BoundaryKernel")</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>getmu(.Object)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='getSubclasses'>List of subclasses</h2><span id='topic+getSubclasses'></span>

<h3>Description</h3>

<p>This method returns a list containing the name of the class given as parameter and all the subclasses. Virtual classes are excluded from the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubclasses(className)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSubclasses_+3A_classname">className</code></td>
<td>
<p>a string with the name of a S4 class</p>
</td></tr>   
</table>


<h3>Examples</h3>

<pre><code class='language-R'># show the names of the class BoundedDensity and all its subclasses
getSubclasses("BoundedDensity")

# show the names of the class Chen99Kernel and all its subclasses
getSubclasses("Chen99Kernel")

</code></pre>

<hr>
<h2 id='gplot'>Bounded Density Plotting based on ggplot2</h2><span id='topic+gplot'></span><span id='topic+gplot-methods'></span><span id='topic+gplot+2Clist-method'></span><span id='topic+gplot+2CBoundedDensity-method'></span><span id='topic+gplot+2CKernelDensity-method'></span><span id='topic+gplot+2CChen99Kernel-method'></span><span id='topic+gplot+2CMicroBetaChen99Kernel-method'></span><span id='topic+gplot+2CMacroBetaChen99Kernel-method'></span><span id='topic+gplot+2CBoundaryKernel-method'></span><span id='topic+gplot+2CNoBoundaryKernel-method'></span><span id='topic+gplot+2CMuller91BoundaryKernel-method'></span><span id='topic+gplot+2CJonesCorrectionMuller91BoundaryKernel-method'></span><span id='topic+gplot+2CMuller94BoundaryKernel-method'></span><span id='topic+gplot+2CJonesCorrectionMuller94BoundaryKernel-method'></span><span id='topic+gplot+2CNormalizedBoundaryKernel-method'></span><span id='topic+gplot+2CBernsteinPolynomials-method'></span><span id='topic+gplot+2CVitale-method'></span><span id='topic+gplot+2CBrVitale-method'></span><span id='topic+gplot+2CKakizawaB1-method'></span><span id='topic+gplot+2CKakizawaB2-method'></span><span id='topic+gplot+2CKakizawaB3-method'></span><span id='topic+gplot+2CHirukawaJLNKernel-method'></span><span id='topic+gplot+2CHirukawaTSKernel-method'></span><span id='topic+gplot+2CMacroBetaHirukawaJLNKernel-method'></span><span id='topic+gplot+2CMacroBetaHirukawaTSKernel-method'></span>

<h3>Description</h3>

<p>Function to plot bounded density probability density functions.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="gplot_+3A_.object">.Object</code></td>
<td>
<p>A bounded density estimator or a list of bounded density estimators. See all the accepted classes here by running the command <code>getSubclasses("BoundedDensity")</code>.</p>
</td></tr>
<tr><td><code id="gplot_+3A_show">show</code></td>
<td>
<p>Logical value. If <code>FALSE</code> the density of the <code>BoundedDensity</code> object in <code>.Object</code> is not plotted but only the <code>ggplot2</code> graphical object is returned. This object can be used for further modifications and plots. If <code>TRUE</code> <code>ggplot2</code> graphical object is returned and also the density is plotted.</p>
</td></tr>
<tr><td><code id="gplot_+3A_includepoints">includePoints</code></td>
<td>
<p>Logical value. It determines whether or not the point used to estimate the density (<code>dataPoints</code>) are included in the plot. Note that, in order to improve the visualization, the points are jittered in the Y axis. When the amount of points is very high, jittering is not enough; in that case, the <code>alpha</code> parameter can be used to control the transparency of the points.</p>
</td></tr>
<tr><td><code id="gplot_+3A_lwd">lwd</code></td>
<td>
<p>Usual line width graphical parameter. See <code>?par</code> for more information</p>
</td></tr>
<tr><td><code id="gplot_+3A_alpha">alpha</code></td>
<td>
<p>A value between 0 and 1 indicating the transparency of the points when they are included in the plot</p>
</td></tr>  
</table>


<h3>Methods</h3>


<dl>
<dt><code>gplot(.Object,show=FALSE,includePoints=FALSE,lwd=1,alpha=1)</code></dt><dd>

</dd>
</dl>


<h3>References</h3>

<p>Wickham, H. (2009). <em>ggplot2: Elegant Graphics for Data Analysis</em>.
Springer.
</p>

<hr>
<h2 id='hirukawaJLNKernel'><code>HirukawaJLNKernel</code> generator method</h2><span id='topic+hirukawaJLNKernel'></span><span id='topic+hirukawaJLNKernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>HirukawaJLNKernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hirukawaJLNKernel(dataPoints, b, dataPointsCache=NULL, modified = FALSE, 
                  lower.limit = 0, upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hirukawaJLNKernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr> 
<tr><td><code id="hirukawaJLNKernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>
<tr><td><code id="hirukawaJLNKernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>
<tr><td><code id="hirukawaJLNKernel_+3A_modified">modified</code></td>
<td>
<p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</td></tr>
<tr><td><code id="hirukawaJLNKernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="hirukawaJLNKernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>  
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+HirukawaJLNKernel-class">HirukawaJLNKernel</a></code> class for more details.

</p>

<hr>
<h2 id='HirukawaJLNKernel'>Class <code>"HirukawaJLNKernel"</code></h2><span id='topic+HirukawaJLNKernel'></span><span id='topic+HirukawaJLNKernel-class'></span>

<h3>Description</h3>

<p>This class deals with the JLN Kernel estimator as described in Hirukawa (2010). The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+hirukawaJLNKernel">hirukawaJLNKernel</a></code>.
</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>modified</code>:</dt><dd><p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</dd>    
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmodified</dt><dd><p>See <code>"<a href="#topic+getmodified">getmodified</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Hirukawa, M. (2010). Nonparametric multiplicative bias correction for kernel-type density estimation on the unit interval.
<em>Computational Statistics &amp; Data Analysis</em>, 54(2), 473-495.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
kernel.noModified &lt;- hirukawaJLNKernel(dataPoints = tuna.r, b = 0.01, modified = FALSE)
kernel.Modified &lt;- hirukawaJLNKernel(dataPoints = tuna.r, b = 0.01, modified = TRUE)

# examples of usual functions
density(kernel.noModified,0.5)
density(kernel.Modified,0.5)

distribution(kernel.noModified,1,discreteApproximation=FALSE)
distribution(kernel.noModified,1,discreteApproximation=TRUE)
 
distribution(kernel.Modified,1,discreteApproximation=FALSE)
distribution(kernel.Modified,1,discreteApproximation=TRUE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Chen99 Kernels Tuna Data")
lines(kernel.noModified, col="red",lwd=2)
lines(kernel.Modified,col="blue",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(list("noModified"=kernel.noModified, 
          "modified"=kernel.Modified), show=TRUE)

</code></pre>

<hr>
<h2 id='hirukawaTSKernel'><code>HirukawaTSKernel</code> generator method</h2><span id='topic+hirukawaTSKernel'></span><span id='topic+hirukawaTSKernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>HirukawaTSKernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hirukawaTSKernel(dataPoints, c, b=length(dataPoints)^(-2/5), dataPointsCache=NULL, 
                  modified = FALSE, lower.limit = 0, upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hirukawaTSKernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="hirukawaTSKernel_+3A_c">c</code></td>
<td>
<p>a numeric value between 0 and 1. This parameter is used in the TS approximation as a smoothing parameter</p>
</td></tr>
<tr><td><code id="hirukawaTSKernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>   
<tr><td><code id="hirukawaTSKernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>
<tr><td><code id="hirukawaTSKernel_+3A_modified">modified</code></td>
<td>
<p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</td></tr>
<tr><td><code id="hirukawaTSKernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="hirukawaTSKernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>  
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+HirukawaTSKernel-class">HirukawaTSKernel</a></code> class for more details.

</p>

<hr>
<h2 id='HirukawaTSKernel'>Class <code>"HirukawaTSKernel"</code></h2><span id='topic+HirukawaTSKernel'></span><span id='topic+HirukawaTSKernel-class'></span>

<h3>Description</h3>

<p>This class deals with the TS Kernel estimator as described in Hirukawa (2010). The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+hirukawaTSKernel">hirukawaTSKernel</a></code>.
</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>modified</code>:</dt><dd><p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</dd>    
<dt><code>c</code>:</dt><dd><p>a numeric value between 0 and 1. This parameter is used in the TS approximation as a smoothing parameter</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmodified</dt><dd><p>See <code>"<a href="#topic+getmodified">getmodified</a>"</code> for details</p>
</dd> 
<dt>getc</dt><dd><p>See <code>"<a href="#topic+getc">getc</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Hirukawa, M. (2010). Nonparametric multiplicative bias correction for kernel-type density estimation on the unit interval.
<em>Computational Statistics &amp; Data Analysis</em>, 54(2), 473-495.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
kernel.noModified &lt;- hirukawaTSKernel(dataPoints = tuna.r, b = 0.01, 
                      modified = FALSE, c = 0.5)
kernel.Modified &lt;- hirukawaTSKernel(dataPoints = tuna.r, b = 0.01,
                      modified = TRUE, c = 0.5)

# examples of usual functions
density(kernel.noModified,0.5)
density(kernel.Modified,0.5)

distribution(kernel.noModified,1,discreteApproximation=FALSE)
distribution(kernel.noModified,1,discreteApproximation=TRUE)
 
distribution(kernel.Modified,1,discreteApproximation=FALSE)
distribution(kernel.Modified,1,discreteApproximation=TRUE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Chen99 Kernels Tuna Data")
lines(kernel.noModified,col="red",lwd=2)
lines(kernel.Modified,col="blue",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(list("noModified"=kernel.noModified, 
          "modified"=kernel.Modified), show=TRUE)
</code></pre>

<hr>
<h2 id='jonesCorrectionMuller91BoundaryKernel'><code>JonesCorrectionMuller91BoundaryKernel</code> generator method</h2><span id='topic+jonesCorrectionMuller91BoundaryKernel'></span><span id='topic+jonesCorrectionMuller91BoundaryKernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>JonesCorrectionMuller91BoundaryKernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jonesCorrectionMuller91BoundaryKernel(dataPoints, mu=1, b=length(dataPoints)^(-2/5), 
                                      dataPointsCache=NULL, lower.limit = 0, 
                                      upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jonesCorrectionMuller91BoundaryKernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="jonesCorrectionMuller91BoundaryKernel_+3A_mu">mu</code></td>
<td>
<p>a integer value indicating the degree of smoothness for the boundary kernel. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (biweight kernel) or 3 (triweight kernel)</p>
</td></tr>
<tr><td><code id="jonesCorrectionMuller91BoundaryKernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>
<tr><td><code id="jonesCorrectionMuller91BoundaryKernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>
<tr><td><code id="jonesCorrectionMuller91BoundaryKernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="jonesCorrectionMuller91BoundaryKernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>  
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+JonesCorrectionMuller91BoundaryKernel-class">JonesCorrectionMuller91BoundaryKernel</a></code> class for more details.

</p>

<hr>
<h2 id='JonesCorrectionMuller91BoundaryKernel'>Class <code>"JonesCorrectionMuller91BoundaryKernel"</code></h2><span id='topic+JonesCorrectionMuller91BoundaryKernel'></span><span id='topic+JonesCorrectionMuller91BoundaryKernel-class'></span>

<h3>Description</h3>

<p>This class deals with nonnegative boundary correction of the <code><a href="#topic+muller91BoundaryKernel">muller91BoundaryKernel</a></code> estimators for bounded densities. In this normalization, two kernel functions are needed. The first kernel funciton -<code>K(u)</code>- is the kernel function used in <code><a href="#topic+muller91BoundaryKernel">muller91BoundaryKernel</a></code> (using left boundary, interior or right boundary kernel functions as needed). For the second kernel function, the popular choice <code>L(u) = u * K(u)</code> is taken. The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations. Note that the renormalization of this kernel estimator guarantees nonnegative values for the density function but the cumulative density function may takes values greater than 1.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+jonesCorrectionMuller91BoundaryKernel">jonesCorrectionMuller91BoundaryKernel</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>mu</code>:</dt><dd><p>a integer value indicating the degree of smoothness for the boundary kernel. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (biweight kernel) or 3 (triweight kernel)</p>
</dd>
<dt><code>normalizedKernel</code>:</dt><dd><p>this slot is used to save a NormalizedBoundaryKernel object used in the normalization. It is only for internal use</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmu</dt><dd><p>See <code>"<a href="#topic+getmu">getmu</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Jones, M. C. and Foster, P. J. (1996). A simple nonnegative boundary correction method for kernel density estimation.
<em>Statistica Sinica</em>, 6, 1005-1013.
</p>
<p>Muller, H. (1991). Smooth optimum kernel estimators near endpoints.
<em>Biometrika</em>, 78(3), 521-530.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
kernel &lt;-jonesCorrectionMuller91BoundaryKernel(dataPoints = tuna.r, b = 0.01, mu = 2)


# examples of usual functions
density(kernel,0.5)

distribution(kernel,0.5,discreteApproximation=FALSE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Tuna Data")
lines(kernel, col="red",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(kernel, show=TRUE, includePoints=TRUE)

</code></pre>

<hr>
<h2 id='jonesCorrectionMuller94BoundaryKernel'><code>JonesCorrectionMuller94BoundaryKernel</code> generator method</h2><span id='topic+jonesCorrectionMuller94BoundaryKernel'></span><span id='topic+jonesCorrectionMuller94BoundaryKernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>JonesCorrectionMuller94BoundaryKernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jonesCorrectionMuller94BoundaryKernel(dataPoints, mu=1, b=length(dataPoints)^(-2/5), 
                                      dataPointsCache=NULL, lower.limit = 0, 
                                      upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jonesCorrectionMuller94BoundaryKernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="jonesCorrectionMuller94BoundaryKernel_+3A_mu">mu</code></td>
<td>
<p>a integer value indicating the degree of smoothness for the boundary kernel. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (biweight kernel) or 3 (triweight kernel)</p>
</td></tr>
<tr><td><code id="jonesCorrectionMuller94BoundaryKernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>
<tr><td><code id="jonesCorrectionMuller94BoundaryKernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>
<tr><td><code id="jonesCorrectionMuller94BoundaryKernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="jonesCorrectionMuller94BoundaryKernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>  
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+JonesCorrectionMuller94BoundaryKernel-class">JonesCorrectionMuller94BoundaryKernel</a></code> class for more details.

</p>

<hr>
<h2 id='JonesCorrectionMuller94BoundaryKernel'>Class <code>"JonesCorrectionMuller94BoundaryKernel"</code></h2><span id='topic+JonesCorrectionMuller94BoundaryKernel'></span><span id='topic+JonesCorrectionMuller94BoundaryKernel-class'></span>

<h3>Description</h3>

<p>This class deals with nonnegative boundary correction of the <code><a href="#topic+muller94BoundaryKernel">muller94BoundaryKernel</a></code> estimators for bounded densities. In this normalization, two kernel functions are needed. The first kernel funciton -<code>K(u)</code>- is the kernel function used in <code><a href="#topic+muller94BoundaryKernel">muller94BoundaryKernel</a></code> (using left boundary, interior or right boundary kernel functions as needed). For the second kernel function, the popular choice <code>L(u) = u * K(u)</code> is taken. The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations. Note that the renormalization of this kernel estimator guarantees nonnegative values for the density function but the cumulative density function may takes values greater than 1.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+jonesCorrectionMuller94BoundaryKernel">jonesCorrectionMuller94BoundaryKernel</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>mu</code>:</dt><dd><p>a integer value indicating the degree of smoothness for the boundary kernel. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (biweight kernel) or 3 (triweight kernel)</p>
</dd>
<dt><code>normalizedKernel</code>:</dt><dd><p>this slot is used to save a NormalizedBoundaryKernel object used in the normalization. It is only for internal use</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>    
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmu</dt><dd><p>See <code>"<a href="#topic+getmu">getmu</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Jones, M. C. and Foster, P. J. (1996). A simple nonnegative boundary correction method for kernel density estimation.
<em>Statistica Sinica</em>, 6, 1005-1013.
</p>
<p>Muller, H. and Wang, J. (1994). Hazard rate estimation under random censoring with varying kernels and bandwidths.
<em>Biometrics</em>, 50(1), 61-76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data points to cache densities and distribution
cache &lt;- seq(0,1,0.01)

# create the model 
kernel &lt;-jonesCorrectionMuller94BoundaryKernel(dataPoints = tuna.r, b = 0.01, mu = 2, 
                                                dataPointsCache = cache)


# examples of usual functions
density(kernel,0.5)

distribution(kernel,0.5,discreteApproximation=FALSE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Tuna Data")
lines(kernel, col="red",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(kernel, show=TRUE, includePoints = TRUE)
</code></pre>

<hr>
<h2 id='kakizawaB1'><code>KakizawaB1</code> generator method</h2><span id='topic+kakizawaB1'></span><span id='topic+kakizawaB1-methods'></span><span id='topic+kakizawaB1+2CKakizawaB1-method'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>KakizawaB1</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kakizawaB1(dataPoints,estimator=NULL,m=round(length(dataPoints)^(2/5)),gamma=0.5,
            dataPointsCache=NULL, lower.limit = 0, upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kakizawaB1_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="kakizawaB1_+3A_estimator">estimator</code></td>
<td>
<p>A bounded density estimator. See all the accepted classes here with getSubclasses(&quot;BoundedDensity&quot;). If no estimator is provided here (default value = NULL), a Muller94BoundaryKernel estimator with default parameters and the same dataPoints as those give for the Kakizawa estimator is used.</p>
</td></tr>
<tr><td><code id="kakizawaB1_+3A_m">m</code></td>
<td>
<p>a integer value indicating the order of the polynomial approximation. <code>m</code> must take values greater than 0</p>
</td></tr>
<tr><td><code id="kakizawaB1_+3A_gamma">gamma</code></td>
<td>
<p>a numeric value between 0 and 1. This parameter is used in the B1 approximation using Bernstein polynomials</p>
</td></tr>
<tr><td><code id="kakizawaB1_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>
<tr><td><code id="kakizawaB1_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="kakizawaB1_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>   
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+KakizawaB1-class">KakizawaB1</a></code> class for more details.

</p>

<hr>
<h2 id='KakizawaB1'>Class <code>"KakizawaB1"</code></h2><span id='topic+KakizawaB1'></span><span id='topic+KakizawaB1-class'></span>

<h3>Description</h3>

<p>This class deals with B1 approximation to kernel density estimation as described in Kakizawa (2004). This is a Berstein polynomial approximation of the density function which uses BoundedDensity objects instead of a polynomial function. By contrast to the original Kakizawa's approach where only boundary kernels are used, here, any BoundedDensity object is allowed. Using this estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+kakizawaB1">kakizawaB1</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>gamma</code>:</dt><dd><p>a numeric value between 0 and 1. This parameter is used in the B1 approximation using Bernstein polynomials</p>
</dd>
<dt><code>densityEstimator</code>:</dt><dd><p>a BoundedDensity object used to estimate the density</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getm</dt><dd><p>See <code>"<a href="#topic+getm">getm</a>"</code> for details</p>
</dd>     
<dt>getgamma</dt><dd><p>See <code>"<a href="#topic+getgamma">getgamma</a>"</code> for details</p>
</dd>     
<dt>getdensityEstimator</dt><dd><p>See <code>"<a href="#topic+getdensityEstimator">getdensityEstimator</a>"</code> for details</p>
</dd>     
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Kakizawa, Y. (2004). Bernstein polynomial probability density estimation.
<em>Journal of Nonparametric Statistics</em>, 16(5), 709-729.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
# we use a MicroBetaChen99Kernel is used as estimator y KakizawaB1 approximation
est &lt;- microBetaChen99Kernel(dataPoints = tuna.r, b = 0.01, modified = FALSE)
model &lt;- kakizawaB1(dataPoints = tuna.r, m = 25, gamma = 0.25)


# examples of usual functions
density(model,0.5)

distribution(model,0.5,discreteApproximation=FALSE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Tuna Data")
lines(model, col="red",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(model, show=TRUE, includePoints=TRUE)
</code></pre>

<hr>
<h2 id='kakizawaB2'><code>KakizawaB2</code> generator method</h2><span id='topic+kakizawaB2'></span><span id='topic+kakizawaB2-methods'></span><span id='topic+kakizawaB2+2CKakizawaB2-method'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>KakizawaB2</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kakizawaB2(dataPoints, estimator=NULL,m=round(length(dataPoints)^(2/5)),
            dataPointsCache=NULL, lower.limit = 0, upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kakizawaB2_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="kakizawaB2_+3A_estimator">estimator</code></td>
<td>
<p>A bounded density estimator. See all the accepted classes here with getSubclasses(&quot;BoundedDensity&quot;). If no estimator is provided here (default value = NULL), a Muller94BoundaryKernel estimator with default parameters and the same dataPoints as those give for the Kakizawa estimator is used.</p>
</td></tr>
<tr><td><code id="kakizawaB2_+3A_m">m</code></td>
<td>
<p>a integer value indicating the order of the polynomial approximation. <code>m</code> must take values greater than 0</p>
</td></tr>      
<tr><td><code id="kakizawaB2_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>  
<tr><td><code id="kakizawaB2_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="kakizawaB2_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>   
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+KakizawaB2-class">KakizawaB2</a></code> class for more details.

</p>

<hr>
<h2 id='KakizawaB2'>Class <code>"KakizawaB2"</code></h2><span id='topic+KakizawaB2'></span><span id='topic+KakizawaB2-class'></span>

<h3>Description</h3>

<p>This class deals with B2 approximation to kernel density estimation as described in Kakizawa (2004). This is a Berstein polynomial approximation of the density function which uses BoundedDensity objects instead of a polynomial function. By contrast to the original Kakizawa's approach where only boundary kernels are used, here, any BoundedDensity object is allowed. Using this estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+kakizawaB2">kakizawaB2</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>densityEstimator</code>:</dt><dd><p>a BoundedDensity object used to estimate the density</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getm</dt><dd><p>See <code>"<a href="#topic+getm">getm</a>"</code> for details</p>
</dd>         
<dt>getdensityEstimator</dt><dd><p>See <code>"<a href="#topic+getdensityEstimator">getdensityEstimator</a>"</code> for details</p>
</dd>     
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Kakizawa, Y. (2004). Bernstein polynomial probability density estimation.
<em>Journal of Nonparametric Statistics</em>, 16(5), 709-729.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
# we use a MicroBetaChen99Kernel is used as estimator y KakizawaB1 approximation
est &lt;- microBetaChen99Kernel(dataPoints = tuna.r, b = 0.01, modified = FALSE)
model &lt;- kakizawaB2(dataPoints = tuna.r, m = 25, estimator = est)


# examples of usual functions
density(model,0.5)

distribution(model,0.5,discreteApproximation=FALSE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Tuna Data")
lines(model, col="red",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(model, show=TRUE, includePoints=TRUE)
</code></pre>

<hr>
<h2 id='kakizawaB3'><code>KakizawaB3</code> generator method</h2><span id='topic+kakizawaB3'></span><span id='topic+kakizawaB3-methods'></span><span id='topic+kakizawaB3+2CKakizawaB3-method'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>KakizawaB3</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kakizawaB3(dataPoints, estimator=NULL,m=round(length(dataPoints)^(2/5)),
            dataPointsCache=NULL, lower.limit = 0, upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kakizawaB3_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>  
<tr><td><code id="kakizawaB3_+3A_estimator">estimator</code></td>
<td>
<p>A bounded density estimator. See all the accepted classes here with getSubclasses(&quot;BoundedDensity&quot;). If no estimator is provided here (default value = NULL), a Muller94BoundaryKernel estimator with default parameters and the same dataPoints as those give for the Kakizawa estimator is used.</p>
</td></tr>
<tr><td><code id="kakizawaB3_+3A_m">m</code></td>
<td>
<p>a integer value indicating the order of the polynomial approximation. <code>m</code> must take values greater than 0</p>
</td></tr>    
<tr><td><code id="kakizawaB3_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr> 
<tr><td><code id="kakizawaB3_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="kakizawaB3_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>   
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+KakizawaB3-class">KakizawaB3</a></code> class for more details.

</p>

<hr>
<h2 id='KakizawaB3'>Class <code>"KakizawaB3"</code></h2><span id='topic+KakizawaB3'></span><span id='topic+KakizawaB3-class'></span>

<h3>Description</h3>

<p>This class deals with B3 approximation to kernel density estimation as described in Kakizawa (2004). This is a Berstein polynomial approximation of the density function which uses BoundedDensity objects instead of a polynomial function. By contrast to the original Kakizawa's approach where only boundary kernels are used, here, any BoundedDensity object is allowed. Using this estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+kakizawaB3">kakizawaB3</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>densityEstimator</code>:</dt><dd><p>a BoundedDensity object used to estimate the density</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getm</dt><dd><p>See <code>"<a href="#topic+getm">getm</a>"</code> for details</p>
</dd>         
<dt>getdensityEstimator</dt><dd><p>See <code>"<a href="#topic+getdensityEstimator">getdensityEstimator</a>"</code> for details</p>
</dd>     
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Kakizawa, Y. (2004). Bernstein polynomial probability density estimation.
<em>Journal of Nonparametric Statistics</em>, 16(5), 709-729.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
# we use a MicroBetaChen99Kernel is used as estimator y KakizawaB1 approximation
est &lt;- microBetaChen99Kernel(dataPoints = tuna.r, b = 0.01, modified = FALSE)
model &lt;- kakizawaB3(dataPoints = tuna.r, m = 25, estimator = est)


# examples of usual functions
density(model,0.5)

distribution(model,0.5,discreteApproximation=FALSE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Tuna Data")
lines(model, col="red",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(model, show=TRUE, includePoints=TRUE)
</code></pre>

<hr>
<h2 id='launchApp'>Shiny launch application</h2><span id='topic+launchApp'></span>

<h3>Description</h3>

<p>Runs the shiny service for the bde package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launchApp(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="launchApp_+3A_...">...</code></td>
<td>
<p>no parameters are needed</p>
</td></tr>      
</table>

<hr>
<h2 id='lines'>Add a Bounded Density pdf to a Plot</h2><span id='topic+lines'></span><span id='topic+lines-methods'></span><span id='topic+lines+2CBoundedDensity-method'></span><span id='topic+lines+2CKernelDensity-method'></span><span id='topic+lines+2CChen99Kernel-method'></span><span id='topic+lines+2CMicroBetaChen99Kernel-method'></span><span id='topic+lines+2CMacroBetaChen99Kernel-method'></span><span id='topic+lines+2CBoundaryKernel-method'></span><span id='topic+lines+2CNoBoundaryKernel-method'></span><span id='topic+lines+2CMuller91BoundaryKernel-method'></span><span id='topic+lines+2CJonesCorrectionMuller91BoundaryKernel-method'></span><span id='topic+lines+2CMuller94BoundaryKernel-method'></span><span id='topic+lines+2CJonesCorrectionMuller94BoundaryKernel-method'></span><span id='topic+lines+2CNormalizedBoundaryKernel-method'></span><span id='topic+lines+2CBernsteinPolynomials-method'></span><span id='topic+lines+2CVitale-method'></span><span id='topic+lines+2CBrVitale-method'></span><span id='topic+lines+2CKakizawaB1-method'></span><span id='topic+lines+2CKakizawaB2-method'></span><span id='topic+lines+2CKakizawaB3-method'></span><span id='topic+lines+2CHirukawaJLNKernel-method'></span><span id='topic+lines+2CHirukawaTSKernel-method'></span><span id='topic+lines+2CMacroBetaHirukawaJLNKernel-method'></span><span id='topic+lines+2CMacroBetaHirukawaTSKernel-method'></span>

<h3>Description</h3>

<p>Function to draw a bounded density probability density functions in the current plot.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines_+3A_x">x</code></td>
<td>
<p>A bounded density estimator.See all the accepted classes here by running the command <code>getSubclasses("BoundedDensity")</code>.</p>
</td></tr>
<tr><td><code id="lines_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>lines(x,...)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='macroBetaChen99Kernel'><code>MacroBetaChen99Kernel</code> generator method</h2><span id='topic+macroBetaChen99Kernel'></span><span id='topic+macroBetaChen99Kernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>MacroBetaChen99Kernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>macroBetaChen99Kernel(dataPoints, b=length(dataPoints)^(-2/5), dataPointsCache=NULL, 
                      modified = FALSE, lower.limit = 0, upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="macroBetaChen99Kernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="macroBetaChen99Kernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>
<tr><td><code id="macroBetaChen99Kernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>
<tr><td><code id="macroBetaChen99Kernel_+3A_modified">modified</code></td>
<td>
<p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</td></tr>
<tr><td><code id="macroBetaChen99Kernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="macroBetaChen99Kernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>   
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+MacroBetaChen99Kernel-class">MacroBetaChen99Kernel</a></code> class for more details.

</p>

<hr>
<h2 id='MacroBetaChen99Kernel'>Class <code>"MacroBetaChen99Kernel"</code></h2><span id='topic+MacroBetaChen99Kernel'></span><span id='topic+MacroBetaChen99Kernel-class'></span>

<h3>Description</h3>

<p>This class deals with the density-wise normalization (macro beta) of the Chen's 99 Kernel estimator (as described in Gourierous and Monfort, 2006). The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+macroBetaChen99Kernel">macroBetaChen99Kernel</a></code>.
</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>modified</code>:</dt><dd><p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</dd>
<dt><code>normalizationConst</code>:</dt><dd><p> this slot is used to save the density-wise normalization constant. It is only for internal use</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmodified</dt><dd><p>See <code>"<a href="#topic+getmodified">getmodified</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Chen, S. X. (1999). Beta kernel estimators for density functions.
<em>Computational Statistics &amp; Data Analysis</em>, 31, 131-145.
</p>
<p>Gourieroux, C. and Monfort, A. (2006). (Non) consistency of the Beta Kernel Estimator for Recovery Rate Distribution.
<em>Working Paper 2006-31</em>, Centre de Recherche en Economie et Statistique.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
kernel.noModified &lt;- macroBetaChen99Kernel(dataPoints = tuna.r, b = 0.01,
                        modified = FALSE)
kernel.Modified &lt;- macroBetaChen99Kernel(dataPoints = tuna.r, b = 0.01,
                        modified = TRUE)

# examples of usual functions
density(kernel.noModified,0.5)
density(kernel.Modified,0.5)

distribution(kernel.noModified,1,discreteApproximation=FALSE)
distribution(kernel.noModified,1,discreteApproximation=TRUE)
 
distribution(kernel.Modified,1,discreteApproximation=FALSE)
distribution(kernel.Modified,1,discreteApproximation=TRUE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Chen99 Kernels Tuna Data")
lines(kernel.noModified, col="red",lwd=2)
lines(kernel.Modified,col="blue",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(list("noModified"=kernel.noModified, 
          "modified"=kernel.Modified), show=TRUE)
</code></pre>

<hr>
<h2 id='macroBetaHirukawaJLNKernel'><code>MacroBetaHirukawaJLNKernel</code> generator method</h2><span id='topic+macroBetaHirukawaJLNKernel'></span><span id='topic+macroBetaHirukawaJLNKernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>MacroBetaHirukawaJLNKernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>macroBetaHirukawaJLNKernel(dataPoints, b=length(dataPoints)^(-2/5), dataPointsCache=NULL,
                            modified = FALSE, lower.limit = 0, upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="macroBetaHirukawaJLNKernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="macroBetaHirukawaJLNKernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>  
<tr><td><code id="macroBetaHirukawaJLNKernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr> 
<tr><td><code id="macroBetaHirukawaJLNKernel_+3A_modified">modified</code></td>
<td>
<p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</td></tr>
<tr><td><code id="macroBetaHirukawaJLNKernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="macroBetaHirukawaJLNKernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>   
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+MacroBetaHirukawaJLNKernel-class">MacroBetaHirukawaJLNKernel</a></code> class for more details.

</p>

<hr>
<h2 id='MacroBetaHirukawaJLNKernel'>Class <code>"MacroBetaHirukawaJLNKernel"</code></h2><span id='topic+MacroBetaHirukawaJLNKernel'></span><span id='topic+MacroBetaHirukawaJLNKernel-class'></span>

<h3>Description</h3>

<p>This class deals with the density-wise normalization (macro beta) of the JLN Kernel estimator as described in Hirukawa (2010). The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+macroBetaHirukawaJLNKernel">macroBetaHirukawaJLNKernel</a></code>.
</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>modified</code>:</dt><dd><p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</dd>  
<dt><code>normalizationConst</code>:</dt><dd><p> this slot is used to save the density-wise normalization constant. It is only for internal use</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmodified</dt><dd><p>See <code>"<a href="#topic+getmodified">getmodified</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Hirukawa, M. (2010). Nonparametric multiplicative bias correction for kernel-type density estimation on the unit interval.
<em>Computational Statistics &amp; Data Analysis</em>, 54(2), 473-495.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
kernel.noModified &lt;- macroBetaHirukawaJLNKernel(dataPoints = tuna.r, b = 0.01,
                        modified = FALSE)
kernel.Modified &lt;- macroBetaHirukawaJLNKernel(dataPoints = tuna.r, b = 0.01,
                        modified = TRUE)

# examples of usual functions
density(kernel.noModified,0.5)
density(kernel.Modified,0.5)

distribution(kernel.noModified,1,discreteApproximation=FALSE)
distribution(kernel.noModified,1,discreteApproximation=TRUE)
 
distribution(kernel.Modified,1,discreteApproximation=FALSE)
distribution(kernel.Modified,1,discreteApproximation=TRUE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Chen99 Kernels Tuna Data")
lines(kernel.noModified, col="red",lwd=2)
lines(kernel.Modified,col="blue",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(list("noModified"=kernel.noModified, 
          "modified"=kernel.Modified), show=TRUE)
</code></pre>

<hr>
<h2 id='macroBetaHirukawaTSKernel'><code>MacroBetaHirukawaTSKernel</code> generator method</h2><span id='topic+macroBetaHirukawaTSKernel'></span><span id='topic+macroBetaHirukawaTSKernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>MacroBetaHirukawaTSKernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>macroBetaHirukawaTSKernel(dataPoints, c, b=length(dataPoints)^(-2/5),
                          dataPointsCache=NULL, modified = FALSE, lower.limit = 0, 
                          upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="macroBetaHirukawaTSKernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>   
<tr><td><code id="macroBetaHirukawaTSKernel_+3A_c">c</code></td>
<td>
<p>a numeric value between 0 and 1. This parameter is used in the TS approximation as a smoothing parameter</p>
</td></tr>
<tr><td><code id="macroBetaHirukawaTSKernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>
<tr><td><code id="macroBetaHirukawaTSKernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>
<tr><td><code id="macroBetaHirukawaTSKernel_+3A_modified">modified</code></td>
<td>
<p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</td></tr>
<tr><td><code id="macroBetaHirukawaTSKernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="macroBetaHirukawaTSKernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>  
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+MacroBetaHirukawaTSKernel-class">MacroBetaHirukawaTSKernel</a></code> class for more details.

</p>

<hr>
<h2 id='MacroBetaHirukawaTSKernel'>Class <code>"MacroBetaHirukawaTSKernel"</code></h2><span id='topic+MacroBetaHirukawaTSKernel'></span><span id='topic+MacroBetaHirukawaTSKernel-class'></span>

<h3>Description</h3>

<p>This class deals with the density-wise normalization (macro beta) of the TS Kernel estimator as described in Hirukawa (2010). The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+macroBetaHirukawaTSKernel">macroBetaHirukawaTSKernel</a></code>.
</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>modified</code>:</dt><dd><p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</dd>       
<dt><code>c</code>:</dt><dd><p>a numeric value between 0 and 1. This parameter is used in the TS approximation as a smoothing parameter</p>
</dd>
<dt><code>normalizationConst</code>:</dt><dd><p> this slot is used to save the density-wise normalization constant. It is only for internal use</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmodified</dt><dd><p>See <code>"<a href="#topic+getmodified">getmodified</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Hirukawa, M. (2010). Nonparametric multiplicative bias correction for kernel-type density estimation on the unit interval.
<em>Computational Statistics &amp; Data Analysis</em>, 54(2), 473-495.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
kernel.noModified &lt;- macroBetaHirukawaTSKernel(dataPoints = tuna.r, b = 0.01,
                      modified = FALSE, c = 0.5)
kernel.Modified &lt;- macroBetaHirukawaTSKernel(dataPoints = tuna.r, b = 0.01,
                      modified = TRUE, c = 0.5)

# examples of usual functions
density(kernel.noModified,0.5)
density(kernel.Modified,0.5)

distribution(kernel.noModified,1,discreteApproximation=FALSE)
distribution(kernel.noModified,1,discreteApproximation=TRUE)
 
distribution(kernel.Modified,1,discreteApproximation=FALSE)
distribution(kernel.Modified,1,discreteApproximation=TRUE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Chen99 Kernels Tuna Data")
lines(kernel.noModified,col="red",lwd=2)
lines(kernel.Modified,col="blue",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(list("noModified"=kernel.noModified, 
          "modified"=kernel.Modified), show=TRUE)
</code></pre>

<hr>
<h2 id='microBetaChen99Kernel'><code>MicroBetaChen99Kernel</code> generator method</h2><span id='topic+microBetaChen99Kernel'></span><span id='topic+microBetaChen99Kernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>MicroBetaChen99Kernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>microBetaChen99Kernel(dataPoints, b=length(dataPoints)^(-2/5), dataPointsCache=NULL, 
                      modified = FALSE, lower.limit = 0, upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="microBetaChen99Kernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="microBetaChen99Kernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>
<tr><td><code id="microBetaChen99Kernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>
<tr><td><code id="microBetaChen99Kernel_+3A_modified">modified</code></td>
<td>
<p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</td></tr>
<tr><td><code id="microBetaChen99Kernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="microBetaChen99Kernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>   
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+MicroBetaChen99Kernel-class">MicroBetaChen99Kernel</a></code> class for more details.

</p>

<hr>
<h2 id='MicroBetaChen99Kernel'>Class <code>"MicroBetaChen99Kernel"</code></h2><span id='topic+MicroBetaChen99Kernel'></span><span id='topic+MicroBetaChen99Kernel-class'></span>

<h3>Description</h3>

<p>This class deals with the kernel-wise normalization of the Chen's 99 Kernel estimator (as described in Gourierous and Monfort, 2006). The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+microBetaChen99Kernel">microBetaChen99Kernel</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>modified</code>:</dt><dd><p>if <code>TRUE</code>, the modified version of the kernel estimator is used</p>
</dd>
<dt><code>normalizationConstants</code>:</dt><dd><p> this slot is used to save the kernel-wise normalization constants. It is only for internal use</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmodified</dt><dd><p>See <code>"<a href="#topic+getmodified">getmodified</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Chen, S. X. (1999). Beta kernel estimators for density functions.
<em>Computational Statistics &amp; Data Analysis</em>, 31, 131-145.
</p>
<p>Gourieroux, C. and Monfort, A. (2006). (Non) consistency of the Beta Kernel Estimator for Recovery Rate Distribution.
<em>Working Paper 2006-31</em>, Centre de Recherche en Economie et Statistique.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
kernel.noModified &lt;- microBetaChen99Kernel(dataPoints = tuna.r, b = 0.01,
                      modified = FALSE)
kernel.Modified &lt;- microBetaChen99Kernel(dataPoints = tuna.r, b = 0.01,
                      modified = TRUE)

# examples of usual functions
density(kernel.noModified,0.5)
density(kernel.Modified,0.5)

distribution(kernel.noModified,1,discreteApproximation=FALSE)
distribution(kernel.noModified,1,discreteApproximation=TRUE)
 
distribution(kernel.Modified,1,discreteApproximation=FALSE)
distribution(kernel.Modified,1,discreteApproximation=TRUE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Chen99 Kernels Tuna Data")
lines(kernel.noModified, col="red",lwd=2)
lines(kernel.Modified,col="blue",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(list("noModified"=kernel.noModified, 
          "modified"=kernel.Modified), show=TRUE)
</code></pre>

<hr>
<h2 id='mise'>Mean Integrated Squared Error</h2><span id='topic+mise'></span>

<h3>Description</h3>

<p>Computes the mean integrated squared error (MISE) for two given Bounded density objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mise(model1,model2,discreteApproximation = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mise_+3A_model1">model1</code></td>
<td>
<p>a bounded density object. See <code>getSubclasses("BoundedDensity")</code> to see all the allowed class objects</p>
</td></tr>   
<tr><td><code id="mise_+3A_model2">model2</code></td>
<td>
<p>a bounded density object. See <code>getSubclasses("BoundedDensity")</code> to see all the allowed class objects</p>
</td></tr>   
<tr><td><code id="mise_+3A_discreteapproximation">discreteApproximation</code></td>
<td>
<p>If <code>TRUE</code>, the mise is calculated using the data stored in the cache. Otherwise the integral is computed.</p>
</td></tr>   
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# a general approximation to a Beta(1,10) distribution using BoundedDensity objects
cache &lt;- seq(0,1,0.01)
dens  &lt;- dbeta(cache,1,10)
bd    &lt;- boundedDensity(x=cache,densities=dens)

# a BrVitale approximation to the Beta(1,10) distribution using a random data sample to 
# learn the model
dataSample &lt;- rbeta(100,1,10)
kernel     &lt;- hirukawaTSKernel(dataPoints=dataSample, b=0.1, c=0.3, 
                                dataPointsCache=cache, modified=FALSE)

# compute the mise
mise(bd,kernel,discreteApproximation=TRUE)
mise(bd,kernel,discreteApproximation=FALSE)
</code></pre>

<hr>
<h2 id='muller91BoundaryKernel'><code>Muller91BoundaryKernel</code> generator method</h2><span id='topic+muller91BoundaryKernel'></span><span id='topic+muller91BoundaryKernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>Muller91BoundaryKernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muller91BoundaryKernel(dataPoints,  mu=1, b=length(dataPoints)^(-2/5), 
                        dataPointsCache=NULL, lower.limit = 0, 
                        upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muller91BoundaryKernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="muller91BoundaryKernel_+3A_mu">mu</code></td>
<td>
<p>a integer value indicating the degree of smoothness for the boundary kernel. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (biweight kernel) or 3 (triweight kernel)</p>
</td></tr>
<tr><td><code id="muller91BoundaryKernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>   
<tr><td><code id="muller91BoundaryKernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>  
<tr><td><code id="muller91BoundaryKernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="muller91BoundaryKernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+Muller91BoundaryKernel-class">Muller91BoundaryKernel</a></code> class for more details.

</p>

<hr>
<h2 id='Muller91BoundaryKernel'>Class <code>"Muller91BoundaryKernel"</code></h2><span id='topic+Muller91BoundaryKernel'></span><span id='topic+Muller91BoundaryKernel-class'></span>

<h3>Description</h3>

<p>This class deals with Kernel estimators for bounded densities using boundary kernel described in Muller (1991). The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations. Note that this kernel estimator is not normalized and therefore it is not a probability distribution (the cumulative density function may return values greater than 1).
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+muller91BoundaryKernel">muller91BoundaryKernel</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>mu</code>:</dt><dd><p>a integer value indicating the degree of smoothness for the boundary kernel. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (biweight kernel) or 3 (triweight kernel)</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmu</dt><dd><p>See <code>"<a href="#topic+getmu">getmu</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Muller, H. (1991). Smooth optimum kernel estimators near endpoints.
<em>Biometrika</em>, 78(3), 521-530.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
kernel &lt;- muller91BoundaryKernel(dataPoints = tuna.r, b = 0.01, mu = 2)


# examples of usual functions
density(kernel,0.5)

distribution(kernel,0.5,discreteApproximation=FALSE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Tuna Data")
lines(kernel, col="red",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(kernel, show=TRUE, includePoints=TRUE)
</code></pre>

<hr>
<h2 id='muller94BoundaryKernel'><code>Muller94BoundaryKernel</code> generator method</h2><span id='topic+muller94BoundaryKernel'></span><span id='topic+muller94BoundaryKernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>Muller94BoundaryKernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muller94BoundaryKernel(dataPoints, mu=1, b=length(dataPoints)^(-2/5), 
                        dataPointsCache=NULL, lower.limit = 0, 
                        upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muller94BoundaryKernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="muller94BoundaryKernel_+3A_mu">mu</code></td>
<td>
<p>a integer value indicating the degree of smoothness for the boundary kernel. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (biweight kernel) or 3 (triweight kernel)</p>
</td></tr>
<tr><td><code id="muller94BoundaryKernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>
<tr><td><code id="muller94BoundaryKernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>
<tr><td><code id="muller94BoundaryKernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="muller94BoundaryKernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+Muller94BoundaryKernel-class">Muller94BoundaryKernel</a></code> class for more details.

</p>

<hr>
<h2 id='Muller94BoundaryKernel'>Class <code>"Muller94BoundaryKernel"</code></h2><span id='topic+Muller94BoundaryKernel'></span><span id='topic+Muller94BoundaryKernel-class'></span>

<h3>Description</h3>

<p>This class deals with Kernel estimators for bounded densities using boundary kernel described in Muller and Wang (1994). The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations. Note that this kernel estimator is not normalized and therefore it is not a probability distribution (the cumulative density function may return values greater than 1).
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+muller94BoundaryKernel">muller94BoundaryKernel</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>mu</code>:</dt><dd><p>a integer value indicating the degree of smoothness for the boundary kernel. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (biweight kernel) or 3 (triweight kernel)</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmu</dt><dd><p>See <code>"<a href="#topic+getmu">getmu</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Muller, H. and Wang, J. (1994). Hazard rate estimation under random censoring with varying kernels and bandwidths.
<em>Biometrics</em>, 50(1), 61-76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
kernel &lt;- muller94BoundaryKernel(dataPoints = tuna.r, b = 0.01, mu = 2)


# examples of usual functions
density(kernel,0.5)

distribution(kernel,0.5,discreteApproximation=FALSE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Tuna Data")
lines(kernel, col="red",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(kernel, show=TRUE, includePoints=TRUE)
</code></pre>

<hr>
<h2 id='noBoundaryKernel'><code>NoBoundaryKernel</code> generator method</h2><span id='topic+noBoundaryKernel'></span><span id='topic+noBoundaryKernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>NoBoundaryKernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noBoundaryKernel(dataPoints, mu=1, b=length(dataPoints)^(-2/5), 
                  dataPointsCache=NULL, lower.limit = 0, 
                  upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noBoundaryKernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="noBoundaryKernel_+3A_mu">mu</code></td>
<td>
<p>a integer value indicating the degree of smoothness for the boundary kernel. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (biweight kernel) or 3 (triweight kernel)</p>
</td></tr>
<tr><td><code id="noBoundaryKernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>
<tr><td><code id="noBoundaryKernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>  
<tr><td><code id="noBoundaryKernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="noBoundaryKernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>   
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+NoBoundaryKernel-class">NoBoundaryKernel</a></code> class for more details.

</p>

<hr>
<h2 id='NoBoundaryKernel'>Class <code>"NoBoundaryKernel"</code></h2><span id='topic+NoBoundaryKernel'></span><span id='topic+NoBoundaryKernel-class'></span>

<h3>Description</h3>

<p>This class deals with Kernel estimators for bounded densities using boundary kernels where the same kernel function is used for all regions: left boundary, interior and right boundary. The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations. Note that this kernel estimator is not normalized and therefore it is not a probability distribution (the cumulative density function may return values greater than 1).
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+noBoundaryKernel">noBoundaryKernel</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>mu</code>:</dt><dd><p>a integer value indicating the degree of smoothness for the boundary kernel. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (biweight kernel) or 3 (triweight kernel)</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmu</dt><dd><p>See <code>"<a href="#topic+getmu">getmu</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
kernel &lt;- noBoundaryKernel(dataPoints = tuna.r, b = 0.01, mu = 2)


# examples of usual functions
density(kernel,0.5)

distribution(kernel,0.5,discreteApproximation=FALSE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Tuna Data")
lines(kernel, col="red",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(kernel, show=TRUE, includePoints=TRUE)
</code></pre>

<hr>
<h2 id='normalizedBoundaryKernel'><code>NormalizedBoundaryKernel</code> generator method</h2><span id='topic+normalizedBoundaryKernel'></span><span id='topic+normalizedBoundaryKernel-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>NormalizedBoundaryKernel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizedBoundaryKernel(dataPoints, mu=1, b=length(dataPoints)^(-2/5), 
                          dataPointsCache=NULL, lower.limit = 0, 
                          upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizedBoundaryKernel_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="normalizedBoundaryKernel_+3A_mu">mu</code></td>
<td>
<p>a integer value indicating the degree of smoothness for the boundary kernel. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (biweight kernel) or 3 (triweight kernel)</p>
</td></tr>
<tr><td><code id="normalizedBoundaryKernel_+3A_b">b</code></td>
<td>
<p>the bandwidth of the kernel estimator</p>
</td></tr>   
<tr><td><code id="normalizedBoundaryKernel_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>
<tr><td><code id="normalizedBoundaryKernel_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="normalizedBoundaryKernel_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>      
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+NormalizedBoundaryKernel-class">NormalizedBoundaryKernel</a></code> class for more details.

</p>

<hr>
<h2 id='NormalizedBoundaryKernel'>Class <code>"NormalizedBoundaryKernel"</code></h2><span id='topic+NormalizedBoundaryKernel'></span><span id='topic+NormalizedBoundaryKernel-class'></span>

<h3>Description</h3>

<p>This class deals with Kernel estimators for bounded densities using renormalized boundary kernel described in Kakizawa (2004). The kernel estimator is computed using the provided data samples. Using this kernel estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations. Note that, the renormalization of this kernel guarantees non-negative density values. However, despite its name, the normalized boundary kernel is not a probability distribution (the cumulative density function may return values greater than 1).
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+normalizedBoundaryKernel">normalizedBoundaryKernel</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>b</code>:</dt><dd><p>the bandwidth of the kernel estimator</p>
</dd>
<dt><code>mu</code>:</dt><dd><p>a integer value indicating the degree of smoothness for the boundary kernel. <code>mu</code> can take the following values: 0 (uniform kernel), 1 (Epanechnikov kernel), 2 (biweight kernel) or 3 (triweight kernel)</p>
</dd>
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getb</dt><dd><p>See <code>"<a href="#topic+getb">getb</a>"</code> for details</p>
</dd> 
<dt>getmu</dt><dd><p>See <code>"<a href="#topic+getmu">getmu</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Kakizawa, Y. (2004). Bernstein polynomial probability density estimation.
<em>Journal of Nonparametric Statistics</em>, 16(5), 709-729.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
kernel &lt;- normalizedBoundaryKernel(dataPoints = tuna.r, b = 0.01, mu = 2)


# examples of usual functions
density(kernel,0.5)

distribution(kernel,0.5,discreteApproximation=FALSE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Tuna Data")
lines(kernel,col="red",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(kernel, show=TRUE, includePoints=TRUE)
</code></pre>

<hr>
<h2 id='plot'>Bounded Density Plotting</h2><span id='topic+plot'></span><span id='topic+plot-methods'></span><span id='topic+plot+2CBoundedDensity-method'></span><span id='topic+plot+2CKernelDensity-method'></span><span id='topic+plot+2CChen99Kernel-method'></span><span id='topic+plot+2CMicroBetaChen99Kernel-method'></span><span id='topic+plot+2CMacroBetaChen99Kernel-method'></span><span id='topic+plot+2CBoundaryKernel-method'></span><span id='topic+plot+2CNoBoundaryKernel-method'></span><span id='topic+plot+2CMuller91BoundaryKernel-method'></span><span id='topic+plot+2CJonesCorrectionMuller91BoundaryKernel-method'></span><span id='topic+plot+2CMuller94BoundaryKernel-method'></span><span id='topic+plot+2CJonesCorrectionMuller94BoundaryKernel-method'></span><span id='topic+plot+2CNormalizedBoundaryKernel-method'></span><span id='topic+plot+2CBernsteinPolynomials-method'></span><span id='topic+plot+2CVitale-method'></span><span id='topic+plot+2CBrVitale-method'></span><span id='topic+plot+2CKakizawaB1-method'></span><span id='topic+plot+2CKakizawaB2-method'></span><span id='topic+plot+2CKakizawaB3-method'></span><span id='topic+plot+2CHirukawaJLNKernel-method'></span><span id='topic+plot+2CHirukawaTSKernel-method'></span><span id='topic+plot+2CMacroBetaHirukawaJLNKernel-method'></span><span id='topic+plot+2CMacroBetaHirukawaTSKernel-method'></span>

<h3>Description</h3>

<p>Function to plot bounded density probability density functions.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>A bounded density estimator. See all the accepted classes here by running the command <code>getSubclasses("BoundedDensity")</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code>, <code id="plot_+3A_type">type</code>, <code id="plot_+3A_xlab">xlab</code>, <code id="plot_+3A_ylab">ylab</code></td>
<td>
<p>Graphical parameters with default values (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as (other) graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>plot(x,main="Bounded density",type="l",xlab="X",ylab="Density",...)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='quantile'>Quantile</h2><span id='topic+quantile'></span><span id='topic+quantile-methods'></span><span id='topic+quantile+2CBoundedDensity-method'></span><span id='topic+quantile+2CChen99Kernel-method'></span><span id='topic+quantile+2CMicroBetaChen99Kernel-method'></span><span id='topic+quantile+2CMacroBetaChen99Kernel-method'></span><span id='topic+quantile+2CBoundaryKernel-method'></span><span id='topic+quantile+2CNoBoundaryKernel-method'></span><span id='topic+quantile+2CMuller91BoundaryKernel-method'></span><span id='topic+quantile+2CJonesCorrectionMuller91BoundaryKernel-method'></span><span id='topic+quantile+2CMuller94BoundaryKernel-method'></span><span id='topic+quantile+2CJonesCorrectionMuller94BoundaryKernel-method'></span><span id='topic+quantile+2CNormalizedBoundaryKernel-method'></span><span id='topic+quantile+2CVitale-method'></span><span id='topic+quantile+2CBrVitale-method'></span><span id='topic+quantile+2CKakizawaB1-method'></span><span id='topic+quantile+2CKakizawaB2-method'></span><span id='topic+quantile+2CKakizawaB3-method'></span><span id='topic+quantile+2CHirukawaJLNKernel-method'></span><span id='topic+quantile+2CHirukawaTSKernel-method'></span><span id='topic+quantile+2CMacroBetaHirukawaJLNKernel-method'></span><span id='topic+quantile+2CMacroBetaHirukawaTSKernel-method'></span>

<h3>Description</h3>

<p>Quantile function for the given bounded density object.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_+3A_x">x</code></td>
<td>
<p>A bounded density estimator. See all the accepted classes here by running the command <code>getSubclasses("BoundedDensity")</code>.This parameter is named <code>x</code> instead of <code>.Object</code> to agree with other already defined density methods.</p>
</td></tr>
<tr><td><code id="quantile_+3A_p">p</code></td>
<td>
<p>Vector of probabilities</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>quantile(x,p)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='rsample'>Random sample</h2><span id='topic+rsample'></span><span id='topic+rsample-methods'></span><span id='topic+rsample+2CBoundedDensity-method'></span><span id='topic+rsample+2CChen99Kernel-method'></span><span id='topic+rsample+2CMicroBetaChen99Kernel-method'></span><span id='topic+rsample+2CMacroBetaChen99Kernel-method'></span><span id='topic+rsample+2CBoundaryKernel-method'></span><span id='topic+rsample+2CNoBoundaryKernel-method'></span><span id='topic+rsample+2CMuller91BoundaryKernel-method'></span><span id='topic+rsample+2CJonesCorrectionMuller91BoundaryKernel-method'></span><span id='topic+rsample+2CMuller94BoundaryKernel-method'></span><span id='topic+rsample+2CJonesCorrectionMuller94BoundaryKernel-method'></span><span id='topic+rsample+2CNormalizedBoundaryKernel-method'></span><span id='topic+rsample+2CVitale-method'></span><span id='topic+rsample+2CBrVitale-method'></span><span id='topic+rsample+2CKakizawaB1-method'></span><span id='topic+rsample+2CKakizawaB2-method'></span><span id='topic+rsample+2CKakizawaB3-method'></span><span id='topic+rsample+2CHirukawaJLNKernel-method'></span><span id='topic+rsample+2CHirukawaTSKernel-method'></span><span id='topic+rsample+2CMacroBetaHirukawaJLNKernel-method'></span><span id='topic+rsample+2CMacroBetaHirukawaTSKernel-method'></span>

<h3>Description</h3>

<p>Random generator function for the given bounded density object.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsample_+3A_.object">.Object</code></td>
<td>
<p>A bounded density estimator. See all the accepted classes here by running the command <code>getSubclasses("BoundedDensity")</code>.</p>
</td></tr>
<tr><td><code id="rsample_+3A_n">n</code></td>
<td>
<p>number of random observations to be generated</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>rsample(.Object,n)</code></dt><dd>

</dd>
</dl>

<hr>
<h2 id='suicide.r'>Scaled data from suicide risk data</h2><span id='topic+suicide.r'></span>

<h3>Description</h3>

<p>The dataset comprises lengths (in days) of psychiatric treatment spells for patients used as controls in a study of suicide risks. The data have been scaled to the interval [0,1] by dividing each data sample by the maximum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suicide.r</code></pre>


<h3>Format</h3>

<p>A vector containing 86 observations.</p>


<h3>Source</h3>

<p>The data were obtained from Silverman (1996) Table 2.1</p>


<h3>References</h3>

<p>Silverman, B. (1986). <em>Density Estimation for Statistics and Data Analysis</em>. 
Chapman &amp; Hall
</p>
<p>Copas, J. B. and Fryer, M. J. (1980). Density estimation and suicide risks in psychiatric treatment.
<em>Journal of the Royal Statistical Society. Series A</em>, 143(2), 167-176
</p>

<hr>
<h2 id='tgaussian'>Synthetic dataset from a truncated Gaussian distribution</h2><span id='topic+tgaussian'></span>

<h3>Description</h3>

<p>This is a synthetic generated dataset sampling a truncated Gaussian distribution on the interval [0,1] with <code>mean=0</code> and <code>sd=0.25</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tgaussian</code></pre>


<h3>Format</h3>

<p>A vector containing 10000 observations.</p>

<hr>
<h2 id='tuna.r'>Scaled <code>tuna</code> data</h2><span id='topic+tuna.r'></span>

<h3>Description</h3>

<p>The <code>tuna</code> data come from an aerial line transect survey of Southern Bluefin Tuna in the Great Australian Bight and it is included in the <code>boot</code> package. The <code>tuna.r</code> data is a scaled version of the <code>tuna</code> data within the [0,1] interval. This new data set is obtained as follows:
</p>
<p><code>library(boot)</code>
</p>
<p><code>tuna.r &lt;- tuna$y/17</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuna.r</code></pre>


<h3>Format</h3>

<p>A vector containing 64 observations.</p>


<h3>Source</h3>

<p>The data were obtained from 
</p>
<p>Chen, S.X. (1996). Empirical likelihood confidence intervals for nonparametric density estimation. 
<em>Biometrica</em>, 83, 329-341.</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+tuna">tuna</a></code>
</p>

<hr>
<h2 id='vitale'><code>Vitale</code> generator method</h2><span id='topic+vitale'></span><span id='topic+vitale-generator'></span>

<h3>Description</h3>

<p>User friendly constructor method for <code>Vitale</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vitale(dataPoints, m=round(length(dataPoints)^(2/5)), dataPointsCache=NULL, 
        lower.limit = 0, upper.limit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vitale_+3A_datapoints">dataPoints</code></td>
<td>
<p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</td></tr>
<tr><td><code id="vitale_+3A_m">m</code></td>
<td>
<p>a integer value indicating the order of the polynomial approximation. <code>m</code> must take values greater than 0</p>
</td></tr>
<tr><td><code id="vitale_+3A_datapointscache">dataPointsCache</code></td>
<td>
<p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval. These points are used for convenience to cache density and distribution values. If <code>dataPointsCache=NULL</code> the values are initialized to a sequence of 101 equally spaced values from <code>lower.limit</code> to <code>upper.limit</code></p>
</td></tr>    
<tr><td><code id="vitale_+3A_lower.limit">lower.limit</code></td>
<td>
<p>a numeric value for the lower limit of the bounded interval for the data</p>
</td></tr>
<tr><td><code id="vitale_+3A_upper.limit">upper.limit</code></td>
<td>
<p>a numeric value for the upper limit of the bounded interval for the data. That is, the data is with   the <code>[lower.limit,upper.limit]</code> interval</p>
</td></tr>    
</table>


<h3>Details</h3>


<p>See <code><a href="#topic+Vitale-class">Vitale</a></code> class for more details.

</p>

<hr>
<h2 id='Vitale'>Class <code>"Vitale"</code></h2><span id='topic+Vitale'></span><span id='topic+Vitale-class'></span>

<h3>Description</h3>

<p>This class deals with Vitale (1975) Bernstein Polynomial approximation as described in Leblanc (2009). The polynomial estimator is computed using the provided data samples. Using this polynomial estimator, the methods implemented in the class can be used to compute densities, values of the distribution function, quantiles, sample the distribution and obtain graphical representations. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by using the generator function <code><a href="#topic+vitale">vitale</a></code>.

</p>


<h3>Slots</h3>

   
<dl>
<dt><code>dataPointsCache</code>:</dt><dd><p>a numeric vector containing points within the <code>[lower.limit,upper.limit]</code> interval</p>
</dd>
<dt><code>densityCache</code>:</dt><dd><p>a numeric vector containing the density for each point in <code>dataPointsCache</code></p>
</dd>
<dt><code>distributionCache</code>:</dt><dd><p>a numeric vector used to cache the values of the distribution function. This slot is included to improve the performance of the methods when multiple calculations of the distribution function are used</p>
</dd>
<dt><code>dataPoints</code>:</dt><dd><p>a numeric vector containing data samples within the <code>[lower.limit,upper.limit]</code> interval. These data samples are used to obtain the kernel estimator</p>
</dd>
<dt><code>m</code>:</dt><dd><p>the order of the polynomial approximation</p>
</dd> 
<dt><code>lower.limit</code>:</dt><dd><p>a numeric value for the lower limit of the bounded interval for the data</p>
</dd>
<dt><code>upper.limit</code>:</dt><dd><p>a numeric value for the upper limit of the bounded interval for the data</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>density</dt><dd><p>See <code>"<a href="#topic+density">density</a>"</code> for details</p>
</dd> 
<dt>distribution</dt><dd><p>See <code>"<a href="#topic+distribution">distribution</a>"</code> for details</p>
</dd> 
<dt>quantile</dt><dd><p>See <code>"<a href="#topic+quantile">quantile</a>"</code> for details</p>
</dd> 
<dt>rsample</dt><dd><p>See <code>"<a href="#topic+rsample">rsample</a>"</code> for details</p>
</dd> 
<dt>plot</dt><dd><p>See <code>"<a href="#topic+plot">plot</a>"</code> for details</p>
</dd> 
<dt>getdataPointsCache</dt><dd><p>See <code>"<a href="#topic+getdataPointsCache">getdataPointsCache</a>"</code> for details</p>
</dd> 
<dt>getdensityCache</dt><dd><p>See <code>"<a href="#topic+getdensityCache">getdensityCache</a>"</code> for details</p>
</dd> 
<dt>getdistributionCache</dt><dd><p>See <code>"<a href="#topic+getdistributionCache">getdistributionCache</a>"</code> for details</p>
</dd> 
<dt>getdataPoints</dt><dd><p>See <code>"<a href="#topic+getdataPoints">getdataPoints</a>"</code> for details</p>
</dd> 
<dt>getm</dt><dd><p>See <code>"<a href="#topic+getm">getm</a>"</code> for details</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>Guzman Santafe, Borja Calvo and Aritz Perez
</p>


<h3>References</h3>

<p>Vitale, R. A. (1975). A Bernstein polynomial approach to density function estimation.
<em>Statistical Inference and Related Topics</em>, 2, 87-99.
</p>
<p>Leblanc, A. (2010). A bias-reduced approach to density estimation using Bernstein polynomials.
<em>Journal of Nonparametric Statistics</em>, 22(4), 459-475.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the model 
model &lt;- vitale(dataPoints = tuna.r, m = 25)


# examples of usual functions
density(model,0.5)

distribution(model,0.5,discreteApproximation=FALSE)
 
# graphical representation
hist(tuna.r,freq=FALSE,main="Tuna Data")
lines(model, col="red",lwd=2)

# graphical representation using ggplot2 
graph &lt;- gplot(model, show=TRUE, includePoints=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
