<!DOCTYPE html><html lang="en"><head><title>Help for package BTSR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BTSR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BARC.functions'><p>Functions to simulate, extract components and fit BARC models</p></a></li>
<li><a href='#BARFIMA.functions'><p>Functions to simulate, extract components and fit BARFIMA models</p></a></li>
<li><a href='#btsr.functions'><p>Generic functions to simulate, extract components and fit BTSR models</p></a></li>
<li><a href='#BTSR.Package'><p>BTSR: Bounded Time Series Regression.</p></a></li>
<li><a href='#coefs.start'><p>Initial values for optimization</p></a></li>
<li><a href='#fit.control'><p>Default control list</p></a></li>
<li><a href='#GARFIMA.functions'><p>Functions to simulate, extract components and fit GARFIMA models</p></a></li>
<li><a href='#KARFIMA.functions'><p>Functions to simulate, extract components and fit KARFIMA models</p></a></li>
<li><a href='#link.btsr'><p>Create a Link for BTSR models</p></a></li>
<li><a href='#predict.btsr'><p>Predict method for BTSR</p></a></li>
<li><a href='#print.btsr'><p>Print Method of class BTSR</p></a></li>
<li><a href='#summary'><p>Summary Method of class BTSR</p></a></li>
<li><a href='#UWARFIMA.functions'><p>Functions to simulate, extract components and fit UWARFIMA models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-22</td>
</tr>
<tr>
<td>Title:</td>
<td>Bounded Time Series Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Copyright:</td>
<td>see file COPYRIGHTS</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulate, estimate and forecast a wide range of regression based dynamic models for bounded time series, covering the most commonly applied models in the literature. The main calculations are done in 'FORTRAN', which translates into very fast algorithms. The main references are 
   Bayer et al. (2017)  &lt;<a href="https://doi.org/10.1016%2Fj.jhydrol.2017.10.006">doi:10.1016/j.jhydrol.2017.10.006</a>&gt;, 
   Pumi et al. (2019) &lt;<a href="https://doi.org/10.1016%2Fj.jspi.2018.10.001">doi:10.1016/j.jspi.2018.10.001</a>&gt;, 
   Pumi et al. (2021) &lt;<a href="https://doi.org/10.1111%2Fsjos.12439">doi:10.1111/sjos.12439</a>&gt; and 
	 Pumi et al. (2022) &lt;<a href="https://doi.org/10.48550/arXiv.2211.02097">doi:10.48550/arXiv.2211.02097</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-22 18:49:39 UTC; Taiane</td>
</tr>
<tr>
<td>Author:</td>
<td>Taiane Schaedler Prass
    <a href="https://orcid.org/0000-0003-3136-909X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    com],
  Guilherme Pumi <a href="https://orcid.org/0000-0002-6256-3170"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, aut],
  FÃ¡bio Mariano Bayer
    <a href="https://orcid.org/0000-0002-1464-0805"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Jack Joseph Dongarra [ctb],
  Cleve Moler [ctb],
  Gilbert Wright Stewart [ctb],
  Ciyou Zhu [ctb],
  Richard H. Byrd [ctb],
  Jorge Nocedal [ctb],
  Jose Luis Morales [ctb],
  Peihuang Lu-Chen [ctb],
  John Burkardt [ctb],
  Alan Miller [ctb],
  B.E. Schneider [ctb],
  Alfred H. Morris [ctb],
  D.E. Shaw [ctb],
  Robert W.M. Wedderburn [ctb],
  Jason Blevins [ctb],
  Brian Wichman [ctb],
  David Hill [ctb],
  Hiroshi Takano [ctb],
  George Marsaglia [ctb],
  Jean-Michel Brankart [ctb],
  Steve Kifowit [ctb],
  Donald E. Knuth [ctb],
  Catherine Loader [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Taiane Schaedler Prass &lt;taianeprass@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-23 22:50:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='BARC.functions'>Functions to simulate, extract components and fit BARC models</h2><span id='topic+BARC.functions'></span><span id='topic+BARC.sim'></span><span id='topic+BARC.extract'></span><span id='topic+BARC.fit'></span>

<h3>Description</h3>

<p>These functions can be used to simulate, extract components
and fit any model of the class <code>barc</code>. A model with
class <code>barc</code> is a special case of a model with class <code>btsr</code> .
See &lsquo;The BTSR structure&rsquo; in <code><a href="#topic+BARC.functions">BARC.functions</a></code> for
more details on the general structure. See &lsquo;Details&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BARC.sim(n = 1, burn = 0, xreg = NULL, map = 4, coefs = list(alpha =
  0, beta = NULL, phi = NULL, theta = 0.5, nu = 20, u0 = pi/4),
  y.start = NULL, xreg.start = NULL, xregar = TRUE, error.scale = 0,
  complete = FALSE, linkg = c("linear", "linear"), linkh = "linear",
  ctt.h = 1, seed = NULL, rngtype = 2, debug = FALSE)

BARC.extract(yt, xreg = NULL, nnew = 0, xnew = NULL, p, r,
  coefs = list(), lags = list(), fixed.values = list(),
  fixed.lags = list(), y.start = NULL, xreg.start = NULL,
  xregar = TRUE, error.scale = 0, map = 4, linkg = c("linear",
  "linear"), linkh = "linear", ctt.h = 1, llk = TRUE, sco = FALSE,
  info = FALSE, debug = FALSE)

BARC.fit(yt, xreg = NULL, nnew = 0, xnew = NULL, p = 0, r = 1,
  start = list(), lags = list(), fixed.values = list(),
  ignore.start = FALSE, fixed.lags = list(), lower = list(nu = 0, u0 =
  0), upper = list(nu = Inf, u0 = 1), map = 4, linkg = c("linear",
  "linear"), linkh = "linear", ctt.h = 1, sco = FALSE, info = FALSE,
  xregar = TRUE, y.start = NULL, xreg.start = NULL, error.scale = 0,
  control = list(), report = TRUE, debug = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BARC.functions_+3A_n">n</code></td>
<td>
<p>a strictly positive integer. The sample size of yt (after burn-in).
Default is 1.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_burn">burn</code></td>
<td>
<p>a non-negative integer. length of &quot;burn-in&quot; period. Default is 0.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_xreg">xreg</code></td>
<td>
<p>optionally, a vector or matrix of external regressors.
For simulation purposes, the length of xreg must be <code>n+burn</code>.
Default is <code>NULL</code>. For extraction or fitting purposes, the length
of <code>xreg</code> must be the same as the length of the observed time series
<code class="reqn">y_t</code>.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_map">map</code></td>
<td>
<p>a non-negative integer from 1 to 5 corresponding to the map function.
Default is 4. See &lsquo;The map function&rsquo;.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_coefs">coefs</code></td>
<td>
<p>a list with the coefficients of the model. An empty list will result
in an error. The arguments that can be passed through this list are:
</p>

<ul>
<li> <p><code>alpha</code> optionally, a numeric value corresponding to the intercept.
If the argument is missing, it will be treated as zero. See
&lsquo;The BTSR structure&rsquo; in <code><a href="#topic+btsr.functions">btsr.functions</a></code>.
</p>
</li>
<li> <p><code>beta</code> optionally, a vector of coefficients corresponding to the
regressors in <code>xreg</code>. If <code>xreg</code> is provided but <code>beta</code> is
missing in the <code>coefs</code> list, an error message is issued.
</p>
</li>
<li> <p><code>phi</code> optionally, for the simulation function this must be a vector
of size <code class="reqn">p</code>, corresponding to the autoregressive coefficients
(including the ones that are zero), where <code class="reqn">p</code> is the AR order. For
the extraction and fitting functions, this is a vector with the non-fixed
values in the vector of autoregressive coefficients.
</p>
</li>
<li> <p><code>theta</code> the parameter (or vector of parameters) corresponding
to the map function. If <code>map = 5</code> this value is ignored. For simulation,
purposes, the default is <code>map = 4</code> and <code>theta = 0.5</code>.
</p>
</li>
<li> <p><code>nu</code> the dispersion parameter. If missing, an error message is issued.
</p>
</li>
<li> <p><code>u0</code> a numeric value in the interval <code class="reqn">(0,1)</code>, corresponding
to the value of the random variable <code class="reqn">U_0</code>. For simulation purposes, the
default is <code>u0 = pi/4</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="BARC.functions_+3A_y.start">y.start</code></td>
<td>
<p>optionally, a initial value for yt (to be used
in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">g_2(y_t) = 0</code>, for <code class="reqn">t &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_xreg.start">xreg.start</code></td>
<td>
<p>optionally, a vector of initial value for xreg
(to be used in the recursions). Default is <code>NULL</code>, in which case, the
recursion assumes that <code class="reqn">X_t = 0</code>, for <code class="reqn">t &lt; 1</code>. If <code>xregar = FALSE</code>
this argument is ignored.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_xregar">xregar</code></td>
<td>
<p>logical; indicates if xreg is to be included in the
AR part of the model.  See &lsquo;The BTSR structure&rsquo;. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_error.scale">error.scale</code></td>
<td>
<p>the scale for the error term. See &lsquo;The BTSR structure&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code>. Default is 0.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_complete">complete</code></td>
<td>
<p>logical; if <code>FALSE</code> the function returns only the simulated
time series yt, otherwise, additional time series are provided.
Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_linkg">linkg</code></td>
<td>
<p>character or a two character vector indicating which
links must be used in the model.  See &lsquo;The BTSR structure&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code> for details and <code><a href="#topic+link.btsr">link.btsr</a></code>
for valid links. If only one value is provided, the same link is used
for <code class="reqn">mu_t</code> and for <code class="reqn">y_t</code> in the AR part of the model.
Default is <code>c("linear", "linear")</code></p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_linkh">linkh</code></td>
<td>
<p>a character indicating which link must be associated to the
the chaotic process.  See &lsquo;The BTSR structure&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code> for details and <code><a href="#topic+link.btsr">link.btsr</a></code>
for valid links. Default is <code>"linear"</code>.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_ctt.h">ctt.h</code></td>
<td>
<p>numeric; the constant to be associated to the link <code class="reqn">h</code>,
when <code>linkh = "linear"</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_seed">seed</code></td>
<td>
<p>optionally, an integer which gives the value of the fixed
seed to be used by the random number generator. If missing, a random integer
is chosen uniformly from 1,000 to 10,000.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_rngtype">rngtype</code></td>
<td>
<p>optionally, an integer indicating which random number generator
is to be used. Default is 2. See &lsquo;Common Arguments&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code>.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_debug">debug</code></td>
<td>
<p>logical, if <code>TRUE</code> the output from FORTRAN is return (for
debuggin purposes).  Default is <code>FALSE</code> for all models.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_yt">yt</code></td>
<td>
<p>a numeric vector with the observed time series. If missing, an error
message is issued.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_nnew">nnew</code></td>
<td>
<p>optionally, the number of out-of sample predicted values required.
Default is 0.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_xnew">xnew</code></td>
<td>
<p>a vector or matrix, with <code>nnew</code> observations of the
regressors observed/predicted values corresponding to the period of
out-of-sample forecast. If <code>xreg = NULL</code>, <code>xnew</code> is ignored.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_p">p</code></td>
<td>
<p>a non-negative integer. The order of AR polynomial.
If missing, the value of <code>p</code> is calculated from length(coefs$phi)
and length(fixed.values$phi). For fitting, the default is 0.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_r">r</code></td>
<td>
<p>a non-negative integer. The size of the vector theta.
If missing, the value of <code>t</code> is calculated from length(coefs$theta)
and length(fixed.values$theta). For fitting, the default is 1.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_lags">lags</code></td>
<td>
<p>optionally, a list with the lags that the values in <code>coefs</code> correspond to.
The names of the entries in this list must match the ones in <code>coefs</code>.
For one dimensional coefficients, the <code>lag</code> is obviously always 1 and can
be suppressed. An empty list indicates that either the argument <code>fixed.lags</code>
is provided or all lags must be used.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_fixed.values">fixed.values</code></td>
<td>
<p>optionally, a list with the values of the coefficients
that are fixed. By default, if a given vector (such as the vector of AR coefficients)
has fixed values and the corresponding entry in this list is empty, the fixed values
are set as zero. The names of the entries in this list must match the ones
in <code>coefs</code>.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_fixed.lags">fixed.lags</code></td>
<td>
<p>optionally, a list with the lags that the fixed values
in <code>fixed.values</code> correspond to. The names of the entries in this list must
match the ones in <code>fixed.values</code>. ##' For one dimensional coefficients, the
<code>lag</code> is obviously always 1 and can be suppressed. If an empty list is provided
and the model has fixed lags, the argument <code>lags</code> is used as reference.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_llk">llk</code></td>
<td>
<p>logical, if <code>TRUE</code> the value of the log-likelihood function
is returned. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_sco">sco</code></td>
<td>
<p>logical, if <code>TRUE</code> the score vector is returned.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_info">info</code></td>
<td>
<p>logical, if <code>TRUE</code> the information matrix is returned.
Default is <code>FALSE</code>. For the fitting function, <code>info</code> is automatically
set to <code>TRUE</code> when <code>report = TRUE</code>.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_start">start</code></td>
<td>
<p>a list with the starting values for the non-fixed coefficients
of the model. If an empty list is provided, the function <code><a href="#topic+coefs.start">coefs.start</a></code>
is used to obtain starting values for the parameters.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_ignore.start">ignore.start</code></td>
<td>
<p>logical,  if starting values are not provided, the
function uses the default values and <code>ignore.start</code> is ignored.
In case starting values are provided and <code>ignore.start = TRUE</code>, those
starting values are ignored and recalculated. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_lower">lower</code></td>
<td>
<p>optionally, list with the lower bounds for the
parameters. The names of the entries in these lists must match the ones
in <code>start</code>. The default is to assume that the parameters have no lower
bound except for <code>nu</code>, for which de default is 0. Only the bounds for
bounded parameters need to be specified.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_upper">upper</code></td>
<td>
<p>optionally, list with the upper bounds for the
parameters. The names of the entries in these lists must match the ones
in <code>start</code>. The default is to assume that the parameters have no upper
bound. Only the bounds for bounded parameters need to be specified.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_control">control</code></td>
<td>
<p>a list with configurations to be passed to the
optimization subroutines. Missing arguments will receive default values. See
<cite><a href="#topic+fit.control">fit.control</a></cite>.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_report">report</code></td>
<td>
<p>logical, if <code>TRUE</code> the summary from model estimation is
printed and <code>info</code> is automatically set to <code>TRUE</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="BARC.functions_+3A_...">...</code></td>
<td>
<p>further arguments passed to the internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Neither the beta regression or an i.i.d. sample
from a beta distribution can be obtained as special cases of the
<code class="reqn">\beta</code>ARC model since the term <code class="reqn">h(T(U_0))</code> is always present
</p>
<p>The model from Pumi et al. (2021) is obtained by setting
<code>xregar = TRUE</code> (so that the regressors are included in the AR
part of the model) and using the same link for <code class="reqn">y_t</code> and <code class="reqn">\mu_t</code>.
</p>
<p>The function <code>BARC.sim</code> generates a random sample from a
<code class="reqn">\beta</code>ARC(p) model.
</p>
<p>The function <code>BARC.extract</code> allows the user to extract the
components <code class="reqn">y_t</code>, <code class="reqn">\mu_t</code>,  <code class="reqn">\eta_t = g(\mu_t)</code>, <code class="reqn">r_t</code>,
<code class="reqn">T^t(u_0)</code>, the log-likelihood, and the vectors and matrices used to
calculate the score vector and the information matrix associated to a given
set of parameters.
</p>
<p>This function can be used by any user to create an objective function
that can be passed to optimization functions not available in BTSR Package.
At this point, there is no other use for which this function was intended.
</p>
<p>The function <code>BARC.fit</code> fits a BARC model to a given univariate time
series. For now, available optimization algorithms are <code>"L-BFGS-B"</code> and
<code>"Nelder-Mead"</code>. Both methods accept bounds for the parameters. For
<code>"Nelder-Mead"</code>, bounds are set via parameter transformation.
</p>


<h3>Value</h3>

<p>The function <code>BARC.sim</code> returns the simulated time series yt  by default.
If <code>complete = TRUE</code>, a list with the following components
is returned instead:
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"BARC"</code>
</p>
</li>
<li> <p><code>yt</code>: the simulated time series
</p>
</li>
<li> <p><code>mut</code>: the conditional mean
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g(\mu_t)</code>
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if included in the model).
</p>
</li>
<li> <p><code>debug</code>: the output from FORTRAN (if requested).
</p>
</li></ul>

<p>The function <code>BARC.extract</code> returns a list with the following components.
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"BARC"</code>.
</p>
</li>
<li> <p><code>coefs</code>: the coefficients of the model passed through the
<code>coefs</code> argument.
</p>
</li>
<li> <p><code>yt</code>: the observed time series.
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g_2(y_t)</code>.
</p>
</li>
<li> <p><code>mut</code>: the conditional mean.
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g_1(\mu_t)</code>.
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>.
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if included in the model).
</p>
</li>
<li> <p><code>TS</code>: the chaotic process <code class="reqn">T^t(u0)</code>.
</p>
</li>
<li> <p><code>sll</code>: the sum of the conditional log-likelihood (if requested).
</p>
</li>
<li> <p><code>sco</code>: the score vector  (if requested).
</p>
</li>
<li> <p><code>info</code>: the information matrix  (if requested).
</p>
</li>
<li> <p><code>Drho</code>, <code>T</code>, <code>E</code>, <code>h</code>: additional matrices and vectors
used to calculate the score vector and the information matrix.  (if requested).
</p>
</li>
<li> <p><code>yt.new</code>: the out-of-sample forecast  (if requested).
</p>
</li>
<li> <p><code>Ts.new</code>: the out-of-sample forecast for the chaotic
process (if requested).
</p>
</li>
<li> <p><code>out.Fortran</code>: FORTRAN output  (if requested).
</p>
</li></ul>

<p>The function <code>btsr.fit</code> returns a list with the following components.
Each particular model can have additional components in this list.
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"BARC"</code>
</p>
</li>
<li> <p><code>convergence</code>: An integer code. 0 indicates successful completion.
The error codes depend on the algorithm used.
</p>
</li>
<li> <p><code>message</code>: A character string giving any additional information
returned by the optimizer, or NULL.
</p>
</li>
<li> <p><code>counts</code>: an integer giving the number of function evaluations.
</p>
</li>
<li> <p><code>control</code>: a list of control parameters.
</p>
</li>
<li> <p><code>start</code>: the starting values used by the algorithm.
</p>
</li>
<li> <p><code>coefficients</code>: 	The best set of parameters found.
</p>
</li>
<li> <p><code>n</code>: the sample size used for estimation.
</p>
</li>
<li> <p><code>series</code>: the observed time series
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g_2(y_t)</code>
</p>
</li>
<li> <p><code>fitted.values</code>: the conditional mean, which corresponds to
the in-sample forecast, also denoted fitted values
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g_1(\mu_t)</code>
</p>
</li>
<li> <p><code>error.scale</code>: the scale for the error term.
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>residual</code>: the observed minus the fitted values. The same as
the <code>error</code> term if <code>error.scale = 0</code>.
</p>
</li>
<li> <p><code>forecast</code>: the out-of-sample forecast for <code class="reqn">y_t</code> (if requested).
</p>
</li>
<li> <p><code>Ts.forecas</code>: the out-of-sample forecast for <code class="reqn">T^t(u_0)</code>
(if requested).
</p>
</li>
<li> <p><code>xnew</code>: the observations of the regressors observed/predicted
values corresponding to the period of out-of-sample forecast.
Only inlcudes if <code>xreg</code> is not <code>NULL</code> and <code>nnew &gt; 0</code>.
</p>
</li>
<li> <p><code>sll</code>: the sum of the conditional log-likelihood (if requested)
</p>
</li>
<li> <p><code>info.Matrix</code>: the information matrix  (if requested)
</p>
</li>
<li> <p><code>configs</code>: a list with the configurations adopted to fit the model.
This information is used by the prediction function.
</p>
</li>
<li> <p><code>out.Fortran</code>: FORTRAN output  (if requested)
</p>
</li>
<li> <p><code>call</code>: a string with the description of the fitted model.
</p>
</li></ul>



<h3>The map function</h3>

<p>The map function <code class="reqn">T:[0,1] \to [0,1]</code> is a dynamical system, i.e.,
a function, potentially depending on a <code class="reqn">r</code>-dimensional vector of
parameters <code class="reqn">\theta</code>. Available choices are
</p>

<ul>
<li> <p><code>map = 1</code>, <code class="reqn">\theta = k</code>, for <code class="reqn">k</code> integer greater
or equal to 2.
</p>
<p style="text-align: center;"><code class="reqn">T(u) = (ku)(mod 1)</code>
</p>

</li>
<li> <p><code>map = 2</code>, <code class="reqn">0 \le \theta \le 1</code>
</p>
<p style="text-align: center;"><code class="reqn">T(u) = \frac{u}{\theta}I_( u &lt; \theta) +
          \theta\frac{(u - \theta)}{(1 - \theta)}I(u \ge \theta)</code>
</p>

</li>
<li> <p><code>map = 3</code> (logistic map), <code class="reqn"> 0 \le \theta \le 4</code>,
</p>
<p style="text-align: center;"><code class="reqn">T(u) = \theta(1-\theta)</code>
</p>

</li>
<li> <p><code>map = 4</code> (Manneville-Pomeau map), <code class="reqn">0 &lt; \theta &lt; 1</code>
</p>
<p style="text-align: center;"><code class="reqn">T(u) = (u + u^{1+\theta})(mod 1)</code>
</p>

</li>
<li> <p><code>map = 5</code> (Lasota-Mackey's map),
</p>
<p style="text-align: center;"><code class="reqn">T(u) = \frac{u}{(1 - u)}I(u \le 0.5) + (2u - 1)I(u &gt; 0.5)</code>
</p>

</li></ul>



<h3>References</h3>

<p>Pumi, G.; Prass, T.S. and Souza, R.R. (2021). A dynamic model for
double bounded time series with chaotic driven conditional averages.
Scandinavian Journal of Statistics. Vol 48 (1), 68-86.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+btsr.sim">btsr.sim</a></code>, <code><a href="#topic+btsr.extract">btsr.extract</a></code>, <code><a href="#topic+btsr.fit">btsr.fit</a></code>
</p>
<p><code><a href="#topic+btsr.extract">btsr.extract</a></code>
</p>
<p><code><a href="#topic+btsr.fit">btsr.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- BARC.sim(linkg = "linear", linkh = "linear",
              n = 100, seed = 2021, complete = TRUE, ctt.h = 0.6,
             coefs = list(nu = 15, theta = 0.85, u0 = pi/4))

plot.ts(m1$yt)
lines(m1$mut, col = "red")

 #------------------------------------------------------------
 # Generating a sample from a BARC model
 #------------------------------------------------------------

 m1 &lt;- BARC.sim(linkg = "linear", linkh = "linear",
               n = 100, seed = 2021, complete = TRUE, ctt.h = 0.6,
               coefs = list(nu = 15, theta = 0.85, u0 = pi/4))

 #------------------------------------------------------------
 #  Extracting the conditional time series given yt and
 #  a set of parameters
 #------------------------------------------------------------

  e1 = BARC.extract(yt = m1$yt, map = 4, ctt.h = 0.6,
                    coefs = list(nu = 15, theta = 0.85),
                    fixed.values = list(u0 = pi/4),
                    linkg = "linear", linkh = "linear", llk = TRUE,
                    sco = TRUE, info = TRUE)

 #----------------------------------------------------
 # comparing the simulated and the extracted values
 #----------------------------------------------------
 cbind(head(m1$mut), head(e1$mut))

 #---------------------------------------------------------
 # the log-likelihood, score vector and information matrix
 # score vector and information matrix are obtained
 # numerically.
 #---------------------------------------------------------
 e1$sll
 e1$score
 e1$info.Matrix


 #------------------------------------------------------------
 # Generating a sample from a BARC model
 #------------------------------------------------------------

 m1 &lt;- BARC.sim(linkg = "linear", linkh = "linear",
               n = 100, seed = 2021, complete = TRUE, ctt.h = 0.6,
               coefs = list(nu = 15, theta = 0.85, u0 = pi/4))

 #------------------------------------------------------------
 #  Fitting a BARC model. Assuming only alpha fixed.
 #------------------------------------------------------------
  f1 = BARC.fit(yt = m1$yt, map = 4, ctt.h = 0.6,
                start = list(nu = 10, theta = 0.6, u0 = 0.5),
                lower = list(nu = 0, theta = 0, u0 = 0),
                upper = list(theta = 1, u0 = 1),
                fixed.values = list(alpha = 0),
                control = list(iprint = -1, method = "Nelder-Mead"))

  coefficients(f1)

  plot.ts(m1$yt)
  lines(f1$fitted.values, col = "red")

 #------------------------------------------------------------
 #  Out-of-sample forecast
 #------------------------------------------------------------
 pred = predict(f1, nnew = 5)
 pred$forecast
 pred$Ts.forecast

</code></pre>

<hr>
<h2 id='BARFIMA.functions'>Functions to simulate, extract components and fit BARFIMA models</h2><span id='topic+BARFIMA.functions'></span><span id='topic+BARFIMA.sim'></span><span id='topic+BARFIMA.extract'></span><span id='topic+BARFIMA.fit'></span>

<h3>Description</h3>

<p>These functions can be used to simulate, extract components
and fit any model of the class <code>barfima</code>. A model with
class <code>barfima</code> is a special case of a model with class <code>btsr</code> .
See &lsquo;The BTSR structure&rsquo; in <code><a href="#topic+btsr.functions">btsr.functions</a></code> for
more details on the general structure.
</p>
<p>The <code class="reqn">\beta</code>ARMA model, the beta regression and a i.i.d. sample
from a beta distribution can be obtained as special cases.
See &lsquo;Details&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BARFIMA.sim(n = 1, burn = 0, xreg = NULL, coefs = list(alpha = 0, beta
  = NULL, phi = NULL, theta = NULL, d = 0, nu = 20), y.start = NULL,
  xreg.start = NULL, xregar = TRUE, error.scale = 1, complete = FALSE,
  inf = 1000, linkg = c("logit", "logit"), seed = NULL, rngtype = 2,
  debug = FALSE)

BARFIMA.extract(yt, xreg = NULL, nnew = 0, xnew = NULL, p, q,
  coefs = list(), lags = list(), fixed.values = list(),
  fixed.lags = list(), y.start = NULL, xreg.start = NULL,
  xregar = TRUE, error.scale = 1, inf = 1000, m = 0,
  linkg = c("logit", "logit"), llk = TRUE, sco = FALSE, info = FALSE,
  extra = FALSE, debug = FALSE)

BARFIMA.fit(yt, xreg = NULL, nnew = 0, xnew = NULL, p = 0, d = TRUE,
  q = 0, m = 0, inf = 1000, start = list(), ignore.start = FALSE,
  lags = list(), fixed.values = list(), fixed.lags = list(),
  lower = list(nu = 0), upper = list(nu = Inf), linkg = c("logit",
  "logit"), sco = FALSE, info = FALSE, extra = FALSE, xregar = TRUE,
  y.start = NULL, xreg.start = NULL, error.scale = 1, control = list(),
  report = TRUE, debug = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BARFIMA.functions_+3A_n">n</code></td>
<td>
<p>a strictly positive integer. The sample size of yt (after burn-in).
Default is 1.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_burn">burn</code></td>
<td>
<p>a non-negative integer. The length of the &quot;burn-in&quot; period. Default is 0.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_xreg">xreg</code></td>
<td>
<p>optionally, a vector or matrix of external regressors.
For simulation purposes, the length of xreg must be <code>n+burn</code>.
Default is <code>NULL</code>. For extraction or fitting purposes, the length
of <code>xreg</code> must be the same as the length of the observed time series
<code class="reqn">y_t</code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_coefs">coefs</code></td>
<td>
<p>a list with the coefficients of the model. An empty list will result
in an error. The arguments that can be passed through this list are:
</p>

<ul>
<li> <p><code>alpha</code> optionally, a numeric value corresponding to the intercept.
If the argument is missing, it will be treated as zero. See
&lsquo;The BTSR structure&rsquo; in <code><a href="#topic+btsr.functions">btsr.functions</a></code>.
</p>
</li>
<li> <p><code>beta</code> optionally, a vector of coefficients corresponding to the
regressors in <code>xreg</code>. If <code>xreg</code> is provided but <code>beta</code> is
missing in the <code>coefs</code> list, an error message is issued.
</p>
</li>
<li> <p><code>phi</code> optionally, for the simulation function this must be a vector
of size <code class="reqn">p</code>, corresponding to the autoregressive coefficients
(including the ones that are zero), where <code class="reqn">p</code> is the AR order. For
the extraction and fitting functions, this is a vector with the non-fixed
values in the vector of autoregressive coefficients.
</p>
</li>
<li> <p><code>theta</code> optionally, for the simulation function this must be a vector
of size <code class="reqn">q</code>, corresponding to the moving average coefficients
(including the ones that are zero), where <code class="reqn">q</code> is the MA order. For
the extraction and fitting functions, this is a vector with the non-fixed
values in the vector of moving average coefficients.
</p>
</li>
<li> <p><code>d</code> optionally, a numeric value corresponding to the long memory
parameter. If the argument is missing, it will be treated as zero.
</p>
</li>
<li> <p><code>nu</code> the dispersion parameter. If missing, an error message is issued.
</p>
</li></ul>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_y.start">y.start</code></td>
<td>
<p>optionally, an initial value for yt (to be used
in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">g_2(y_t) = 0</code>, for <code class="reqn">t &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_xreg.start">xreg.start</code></td>
<td>
<p>optionally, a vector of initial value for xreg
(to be used in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">X_t = 0</code>, for <code class="reqn">t &lt; 1</code>. If <code>xregar = FALSE</code> this argument
is ignored.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_xregar">xregar</code></td>
<td>
<p>logical; indicates if xreg is to be included in the
AR part of the model.  See &lsquo;The BTSR structure&rsquo;. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_error.scale">error.scale</code></td>
<td>
<p>the scale for the error term. See &lsquo;The BTSR structure&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code>. Default is 1.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_complete">complete</code></td>
<td>
<p>logical; if <code>FALSE</code> the function returns only the simulated
time series yt, otherwise, additional time series are provided.
Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_inf">inf</code></td>
<td>
<p>the truncation point for infinite sums. Default is 1,000.
In practice, the Fortran subroutine uses <code class="reqn">inf = q</code>, if <code class="reqn">d = 0</code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_linkg">linkg</code></td>
<td>
<p>character or a two character vector indicating which
links must be used in the model.  See &lsquo;The BTSR structure&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code> for details and <code><a href="#topic+link.btsr">link.btsr</a></code>
for valid links. If only one value is provided, the same link is used
for <code class="reqn">mu_t</code> and for <code class="reqn">y_t</code> in the AR part of the model.
Default is <code>c("logit", "logit")</code>. For the linear link, the constant
will be always 1.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_seed">seed</code></td>
<td>
<p>optionally, an integer which gives the value of the fixed
seed to be used by the random number generator. If missing, a random integer
is chosen uniformly from 1,000 to 10,000.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_rngtype">rngtype</code></td>
<td>
<p>optionally, an integer indicating which random number generator
is to be used. Default is 2: the Mersenne Twister algorithm. See &lsquo;Common Arguments&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_debug">debug</code></td>
<td>
<p>logical, if <code>TRUE</code> the output from FORTRAN is return (for
debugging purposes).  Default is <code>FALSE</code> for all models.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_yt">yt</code></td>
<td>
<p>a numeric vector with the observed time series. If missing, an error
message is issued.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_nnew">nnew</code></td>
<td>
<p>optionally, the number of out-of sample predicted values required.
Default is 0.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_xnew">xnew</code></td>
<td>
<p>a vector or matrix, with <code>nnew</code> observations of the
regressors observed/predicted values corresponding to the period of
out-of-sample forecast. If <code>xreg = NULL</code>, <code>xnew</code> is ignored.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_p">p</code></td>
<td>
<p>a non-negative integer. The order of AR polynomial.
If missing, the value of <code>p</code> is calculated from length(coefs$phi)
and length(fixed.values$phi). For fitting, the default is 0.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_q">q</code></td>
<td>
<p>a non-negative integer. The order of the MA polynomial.
If missing, the value of <code>q</code> is calculated from length(coefs$theta)
and length(fixed.values$theta). For fitting, the default is 0.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_lags">lags</code></td>
<td>
<p>optionally, a list with the lags that the values in <code>coefs</code> correspond to.
The names of the entries in this list must match the ones in <code>coefs</code>.
For one dimensional coefficients, the <code>lag</code> is obviously always 1 and can
be suppressed. An empty list indicates that either the argument <code>fixed.lags</code>
is provided or all lags must be used.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_fixed.values">fixed.values</code></td>
<td>
<p>optionally, a list with the values of the coefficients
that are fixed. By default, if a given vector (such as the vector of AR coefficients)
has fixed values and the corresponding entry in this list is empty, the fixed values
are set as zero. The names of the entries in this list must match the ones
in <code>coefs</code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_fixed.lags">fixed.lags</code></td>
<td>
<p>optionally, a list with the lags that the fixed values
in <code>fixed.values</code> correspond to. The names of the entries in this list must
match the ones in <code>fixed.values</code>. ##' For one dimensional coefficients, the
<code>lag</code> is obviously always 1 and can be suppressed. If an empty list is provided
and the model has fixed lags, the argument <code>lags</code> is used as reference.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_m">m</code></td>
<td>
<p>a non-negative integer indicating the starting time for the sum of the
partial log-likelihoods, that is <code class="reqn">\ell = \sum_{t = m+1}^n \ell_t</code>. Default is
0.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_llk">llk</code></td>
<td>
<p>logical, if <code>TRUE</code> the value of the log-likelihood function
is returned. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_sco">sco</code></td>
<td>
<p>logical, if <code>TRUE</code> the score vector is returned.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_info">info</code></td>
<td>
<p>logical, if <code>TRUE</code> the information matrix is returned.
Default is <code>FALSE</code>. For the fitting function, <code>info</code> is automatically
set to <code>TRUE</code> when <code>report = TRUE</code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_extra">extra</code></td>
<td>
<p>logical, if <code>TRUE</code> the matrices and vectors used to
calculate the score vector and the information matrix are returned.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_d">d</code></td>
<td>
<p>logical, if <code>TRUE</code>, the parameter <code>d</code> is included
in the model either as fixed or non-fixed. If <code>d = FALSE</code> the value is
fixed as 0. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_start">start</code></td>
<td>
<p>a list with the starting values for the non-fixed coefficients
of the model. If an empty list is provided, the function <code><a href="#topic+coefs.start">coefs.start</a></code>
is used to obtain starting values for the parameters.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_ignore.start">ignore.start</code></td>
<td>
<p>logical,  if starting values are not provided, the
function uses the default values and <code>ignore.start</code> is ignored.
In case starting values are provided and <code>ignore.start = TRUE</code>, those
starting values are ignored and recalculated. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_lower">lower</code></td>
<td>
<p>optionally, list with the lower bounds for the
parameters. The names of the entries in these lists must match the ones
in <code>start</code>. The default is to assume that the parameters have no lower
bound except for <code>nu</code>, for which de default is 0. Only the bounds for
bounded parameters need to be specified.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_upper">upper</code></td>
<td>
<p>optionally, list with the upper bounds for the
parameters. The names of the entries in these lists must match the ones
in <code>start</code>. The default is to assume that the parameters have no upper
bound. Only the bounds for bounded parameters need to be specified.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_control">control</code></td>
<td>
<p>a list with configurations to be passed to the
optimization subroutines. Missing arguments will receive default values. See
<cite><a href="#topic+fit.control">fit.control</a></cite>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_report">report</code></td>
<td>
<p>logical, if <code>TRUE</code> the summary from model estimation is
printed and <code>info</code> is automatically set to <code>TRUE</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="BARFIMA.functions_+3A_...">...</code></td>
<td>
<p>further arguments passed to the internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">\beta</code>ARMA model  and the beta regression can be
obtained as special cases of the <code class="reqn">\beta</code>ARFIMA model.
</p>

<ul>
<li> <p><code class="reqn">\beta</code>ARFIMA: the model from Pumi et al. (2019) is obtained by setting
<code>error.scale = 1</code> (predictive scale) and <code>xregar = TRUE</code> (so that the
regressors are included in the AR part of the model). Variations of this model are
obtained by changing  <code>error.scale</code>, <code>xregar</code> and/or by using different
links for <code class="reqn">y[t]</code> (in the AR part of the model) and <code class="reqn">\mu[t]</code>.
</p>
</li>
<li> <p><code class="reqn">\beta</code>ARMA: the model from Rocha and Cribari-Neto (2009, 2017) is
obtained by setting <code>coefs$d = 0</code> and <code>d = FALSE</code> and  <code>error.scale = 1</code>
(predictive scale). Variations of this model are obtained by changing the error scale
and/or by using a different link for <code class="reqn">y[t]</code> in the AR part of the model.
</p>
</li>
<li><p> beta regression: the model from Ferrari and Cribari-Neto (2004) is
obtained by setting <code>p = 0</code>, <code>q = 0</code> and <code>coefs$d = 0</code> and <code>d = FALSE</code>.
The <code>error.scale</code> is irrelevant. The second argument in <code>linkg</code> is irrelevant.
</p>
</li>
<li><p> an i.i.d. sample from a Beta distribution with parameters
<code>shape1</code> and <code>shape2</code> (compatible with the one from <code><a href="stats.html#topic+rbeta">rbeta</a></code>)
is obtained by  setting <code>linkg = "linear"</code>, <code>p = 0</code>, <code>q = 0</code>,
<code>d = FALSE</code> and, in the coefficient list, <code>alpha = shape1/(shape1+shape2)</code>
and <code>nu = shape1+shape2</code>. (<code>error.scale</code> and <code>xregar</code> are
irrelevant)
</p>
</li></ul>

<p>The function <code>BARFIMA.sim</code> generates a random sample from a <code class="reqn">\beta</code>ARFIMA(p,d,q)
model.
</p>
<p>The function <code>BARFIMA.extract</code> allows the user to extract the
components <code class="reqn">y_t</code>, <code class="reqn">\mu_t</code>,  <code class="reqn">\eta_t = g(\mu_t)</code>, <code class="reqn">r_t</code>,
the log-likelihood, and the vectors and matrices used to calculate the
score vector and the information matrix associated to a given set of parameters.
</p>
<p>This function can be used by any user to create an objective function
that can be passed to optimization algorithms not available in the BTSR Package.
</p>
<p>The function <code>BARFIMA.fit</code> fits a BARFIMA model to a given univariate time
series. For now, available optimization algorithms are <code>"L-BFGS-B"</code> and
<code>"Nelder-Mead"</code>. Both methods accept bounds for the parameters. For
<code>"Nelder-Mead"</code>, bounds are set via parameter transformation.
</p>


<h3>Value</h3>

<p>The function <code>BARFIMA.sim</code> returns the simulated time series yt  by default.
If <code>complete = TRUE</code>, a list with the following components
is returned instead:
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"BARFIMA"</code>
</p>
</li>
<li> <p><code>yt</code>: the simulated time series
</p>
</li>
<li> <p><code>mut</code>: the conditional mean
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g(\mu_t)</code>
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if included in the model).
</p>
</li>
<li> <p><code>debug</code>: the output from FORTRAN (if requested).
</p>
</li></ul>

<p>The function <code>BARFIMA.extract</code> returns a list with the following components.
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"BARFIMA"</code>
</p>
</li>
<li> <p><code>coefs</code>: the coefficients of the model passed through the
<code>coefs</code> argument
</p>
</li>
<li> <p><code>yt</code>: the observed time series
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g_2(y_t)</code>
</p>
</li>
<li> <p><code>mut</code>: the conditional mean
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g_1(\mu_t)</code>
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if included in the model).
</p>
</li>
<li> <p><code>sll</code>: the sum of the conditional log-likelihood (if requested)
</p>
</li>
<li> <p><code>sco</code>: the score vector  (if requested)
</p>
</li>
<li> <p><code>info</code>: the information matrix  (if requested)
</p>
</li>
<li> <p><code>Drho</code>, <code>T</code>, <code>E</code>, <code>h</code>: additional matrices and vectors
used to calculate the score vector and the information matrix.  (if requested)
</p>
</li>
<li> <p><code>yt.new</code>: the out-of-sample forecast  (if requested)
</p>
</li>
<li> <p><code>out.Fortran</code>: FORTRAN output  (if requested)
</p>
</li></ul>

<p>The function <code>btsr.fit</code> returns a list with the following components.
Each particular model can have additional components in this list.
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"BARFIMA"</code>
</p>
</li>
<li> <p><code>convergence</code>: An integer code. 0 indicates successful completion.
The error codes depend on the algorithm used.
</p>
</li>
<li> <p><code>message</code>: A character string giving any additional information
returned by the optimizer, or NULL.
</p>
</li>
<li> <p><code>counts</code>: an integer giving the number of function evaluations.
</p>
</li>
<li> <p><code>control</code>: a list of control parameters.
</p>
</li>
<li> <p><code>start</code>: the starting values used by the algorithm.
</p>
</li>
<li> <p><code>coefficients</code>: 	The best set of parameters found.
</p>
</li>
<li> <p><code>n</code>: the sample size used for estimation.
</p>
</li>
<li> <p><code>series</code>: the observed time series
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g_2(y_t)</code>
</p>
</li>
<li> <p><code>fitted.values</code>: the conditional mean, which corresponds to
the in-sample forecast, also denoted fitted values
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g_1(\mu_t)</code>
</p>
</li>
<li> <p><code>error.scale</code>: the scale for the error term.
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>residual</code>: the observed minus the fitted values. The same as
the <code>error</code> term if <code>error.scale = 0</code>.
</p>
</li>
<li> <p><code>forecast</code>: the out-of-sample forecast (if requested).
</p>
</li>
<li> <p><code>xnew</code>: the observations of the regressors observed/predicted
values corresponding to the period of out-of-sample forecast.
Only inlcudes if <code>xreg</code> is not <code>NULL</code> and <code>nnew &gt; 0</code>.
</p>
</li>
<li> <p><code>sll</code>: the sum of the conditional log-likelihood (if requested)
</p>
</li>
<li> <p><code>info.Matrix</code>: the information matrix  (if requested)
</p>
</li>
<li> <p><code>configs</code>: a list with the configurations adopted to fit the model.
This information is used by the prediction function.
</p>
</li>
<li> <p><code>out.Fortran</code>: FORTRAN output  (if requested)
</p>
</li>
<li> <p><code>call</code>: a string with the description of the fitted model.
</p>
</li></ul>



<h3>References</h3>

<p>Ferrari, S.L.P. and Cribari-Neto, F. (2004). Beta regression for modelling rates
and proportions. J. Appl. Stat. 31 (7), 799-815.
</p>
<p>Pumi, G.; Valk, M.; Bisognin, C.; Bayer, F.M. and Prass, T.S.  (2019).
Beta autoregressive fractionally integrated moving average models. Journal of
Statistical Planning and Inference (200), 196-212.
</p>
<p>Rocha, A.V. and Cribari-Neto, F. (2009). Beta autoregressive moving average models.
Test 18 (3), 529â545.
</p>
<p>Rocha, A.V. and Cribari-Neto, F. (2017). Erratum to: Beta autoregressive moving
average models. Test 26 (2), 451-459.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+btsr.sim">btsr.sim</a></code>
</p>
<p><code><a href="#topic+btsr.extract">btsr.extract</a></code>
</p>
<p><code><a href="#topic+btsr.fit">btsr.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a Beta model were mut does not vary with time
# yt ~ Beta(a,b), a = mu*nu, b = (1-mu)*nu

y &lt;- BARFIMA.sim(linkg = "linear", n = 1000, seed = 2021,
                 coefs = list(alpha = 0.2, nu = 20))
hist(y)

 #------------------------------------------------------------
 # Generating a Beta model were mut does not vary with time
 # yt ~ Beta(a,b), a = mu*nu, b = (1-mu)*nu
 #------------------------------------------------------------

 m1 &lt;- BARFIMA.sim(linkg = "linear",n = 100,
                   complete = TRUE, seed = 2021,
                   coefs = list(alpha = 0.2, nu = 20))

 #------------------------------------------------------------
 #  Extracting the conditional time series given yt and
 #  a set of parameters
 #------------------------------------------------------------

 # Assuming that all coefficients are non-fixed
 e1 = BARFIMA.extract(yt = m1$yt, coefs = list(alpha = 0.2, nu = 20),
                      link = "linear", llk = TRUE,
                      sco = TRUE, info = TRUE)

 #----------------------------------------------------
 # comparing the simulated and the extracted values
 #----------------------------------------------------
 cbind(head(m1$mut), head(e1$mut))

 #---------------------------------------------------------
 # the log-likelihood, score vector and information matrix
 #---------------------------------------------------------
 e1$sll
 e1$score
 e1$info.Matrix


# Generating a Beta model were mut does not vary with time
# yt ~ Beta(a,b), a = mu*nu, b = (1-mu)*nu

y &lt;- BARFIMA.sim(linkg = "linear", n = 100, seed = 2021,
               coefs = list(alpha = 0.2, nu = 20))

# fitting the model
f &lt;- BARFIMA.fit(yt = y, report = TRUE,
                 start = list(alpha = 0.5, nu = 10),
                 linkg = "linear", d = FALSE)

</code></pre>

<hr>
<h2 id='btsr.functions'>Generic functions to simulate, extract components and fit BTSR models</h2><span id='topic+btsr.functions'></span><span id='topic+btsr.sim'></span><span id='topic+btsr.extract'></span><span id='topic+btsr.fit'></span>

<h3>Description</h3>

<p>These generic functions can be used to simulate, extract components
and fit any model of the class <code>btsr</code>. All functions are wrappers
for the corresponding function associated to the chosen model.
See &lsquo;The BTSR structure&rsquo; and &lsquo;Common Arguments&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>btsr.sim(model, complete = FALSE, ...)

btsr.extract(model, ...)

btsr.fit(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="btsr.functions_+3A_model">model</code></td>
<td>
<p>character; one of <code>"BARFIMA"</code>, <code>"GARFIMA"</code>,
<code>"KARFIMA"</code>, <code>"BARC"</code>.</p>
</td></tr>
<tr><td><code id="btsr.functions_+3A_complete">complete</code></td>
<td>
<p>logical; if <code>FALSE</code> the function returns only the simulated
time series yt, otherwise, additional time series are provided.
Default is <code>FALSE</code> for all models.</p>
</td></tr>
<tr><td><code id="btsr.functions_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions, according to
the model selected in the argument <code>model</code>. See &lsquo;Common Arguments&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>btsr.sim</code> is used to generate random samples
from BTSR models. See &lsquo;The BTSR structure&rsquo;.
</p>
<p>The function <code>btsr.extract</code> allows the user to extract the
components <code class="reqn">y_t</code>, <code class="reqn">\mu_t</code>,  <code class="reqn">\eta_t = g(\mu_t)</code>, <code class="reqn">r_t</code>,
the log-likelihood, and the vectors and matrices used to calculate the
score vector and the information matrix associated to a given set of parameters.
</p>
<p>This function can be used by any user to create an objective function
that can be passed to optimization functions not available in BTSR Package.
At this point, there is no other use for which this function was intended.
</p>
<p>The function <code>btsr.fit</code> fits a BTSR model to a given univariate time
series. For now, available optimization algorithms are <code>"L-BFGS-B"</code> and
<code>"Nelder-Mead"</code>. Both methods accept bounds for the parameters. For
<code>"Nelder-Mead"</code>, bounds are set via parameter transformation.
</p>


<h3>Value</h3>

<p>The function <code>btsr.sim</code> returns the simulated time series yt  by default.
If <code>complete = TRUE</code>, a list with the following components
is returned instead:
</p>

<ul>
<li> <p><code>model</code>: character; one of <code>"BARFIMA"</code>, <code>"GARFIMA"</code>,
<code>"KARFIMA"</code>, <code>"BARC"</code>. (same as the input argument)
</p>
</li>
<li> <p><code>yt</code>: the simulated time series
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g2(y_t)</code>
</p>
</li>
<li> <p><code>mut</code>: the conditional mean
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g(\mu_t)</code>
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if included in the model).
</p>
</li>
<li> <p><code>debug</code>: the output from FORTRAN (if requested).
</p>
</li></ul>

<p>The function <code>btsr.extract</code> returns a list with the following components.
Each particular model can have additional components in this list.
</p>

<ul>
<li> <p><code>model</code>: character; one of <code>"BARFIMA"</code>, <code>"GARFIMA"</code>,
<code>"KARFIMA"</code>, <code>"BARC"</code>. (same as the input argument)
</p>
</li>
<li> <p><code>coefs</code>: the coefficients of the model passed through the
<code>coefs</code> argument
</p>
</li>
<li> <p><code>yt</code>: the observed time series
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g_2(y_t)</code>
</p>
</li>
<li> <p><code>mut</code>: the conditional mean
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g_1(\mu_t)</code>
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if included in the model).
</p>
</li>
<li> <p><code>forecast</code>: the out-of-sample forecast (if requested).
</p>
</li>
<li> <p><code>xnew</code>: the observations of the regressors observed/predicted
values corresponding to the period of out-of-sample forecast.
Only inlcudes if <code>xreg</code> is not <code>NULL</code> and <code>nnew &gt; 0</code>.
</p>
</li>
<li> <p><code>sll</code>: the sum of the conditional log-likelihood (if requested)
</p>
</li>
<li> <p><code>sco</code>: the score vector  (if requested)
</p>
</li>
<li> <p><code>info</code>: the information matrix  (if requested)
</p>
</li>
<li> <p><code>Drho</code>, <code>T</code>, <code>E</code>, <code>h</code>: additional matrices and vectors
used to calculate the score vector and the information matrix.  (if requested)
</p>
</li>
<li> <p><code>yt.new</code>: the out-of-sample forecast  (if requested)
</p>
</li>
<li> <p><code>out.Fortran</code>: FORTRAN output  (if requested)
</p>
</li></ul>

<p>The function <code>btsr.fit</code> returns a list with the following components.
Each particular model can have additional components in this list.
</p>

<ul>
<li> <p><code>model</code>: character; one of <code>"BARFIMA"</code>, <code>"GARFIMA"</code>,
<code>"KARFIMA"</code>, <code>"BARC"</code>. (same as the input argument)
</p>
</li>
<li> <p><code>convergence</code>: An integer code. 0 indicates successful completion.
The error codes depend on the algorithm used.
</p>
</li>
<li> <p><code>message</code>: A character string giving any additional information
returned by the optimizer, or NULL.
</p>
</li>
<li> <p><code>counts</code>: an integer giving the number of function evaluations.
</p>
</li>
<li> <p><code>control</code>: a list of control parameters.
</p>
</li>
<li> <p><code>start</code>: the starting values used by the algorithm.
</p>
</li>
<li> <p><code>coefficients</code>: 	The best set of parameters found.
</p>
</li>
<li> <p><code>n</code>: the sample size used for estimation.
</p>
</li>
<li> <p><code>series</code>: the observed time series
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g_2(y_t)</code>
</p>
</li>
<li> <p><code>fitted.values</code>: the conditional mean, which corresponds to
the in-sample forecast, also denoted fitted values
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g_1(\mu_t)</code>
</p>
</li>
<li> <p><code>error.scale</code>: the scale for the error term.
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>residuals</code>: the observed minus the fitted values. The same as
the <code>error</code> term if <code>error.scale = 0</code>.
</p>
</li>
<li> <p><code>sll</code>: the sum of the conditional log-likelihood (if requested)
</p>
</li>
<li> <p><code>info.Matrix</code>: the information matrix  (if requested)
</p>
</li>
<li> <p><code>configs</code>: a list with the configurations adopted to fit the model.
This information is used by the prediction function.
</p>
</li>
<li> <p><code>out.Fortran</code>: FORTRAN output  (if requested)
</p>
</li>
<li> <p><code>call</code>: a string with the description of the fitted model.
</p>
</li></ul>



<h3>The BTSR structure</h3>

<p>The general structure of the deterministic part of a BTSR model is
</p>
<p style="text-align: center;"><code class="reqn">g_1(\mu_t) = \alpha + X_t\beta +
 \sum_{j=1}^p \phi_j[g_2(y_{t-j}) - I_{xregar}X_{t-j}\beta] + h_t</code>
</p>

<p>where
</p>

<ul>
<li> <p><code class="reqn">I_{xregar}</code> is 0, if <code>xreg</code> is not included in the AR part of the model and 1,
otherwise
</p>
</li>
<li><p> the term <code class="reqn">h_t</code> depends on the argument <code>model</code>:
</p>

<ul>
<li><p> for BARC models: <code class="reqn">h_t =  h(T^{t-1}(u_0))</code>
</p>
</li>
<li><p> otherwise: <code class="reqn">h_t =  \sum_{k = 1}^\infty c_k r_{t-k}</code>
</p>
</li></ul>

</li>
<li> <p><code class="reqn">g_1</code> and <code class="reqn">g_2</code> are the links defined in <code>linkg</code>.
Notice that <code class="reqn">g_2</code> is only used in the AR part of the model and, typically,
<code class="reqn">g_1 = g_2</code>.
</p>
</li>
<li> <p><code class="reqn">r_t</code> depends on the <code>error.scale</code> adopted:
</p>

<ul>
<li><p>  if <code>error.scale = 0</code>: <code class="reqn">r_t = y_t - \mu_t</code> (data scale)
</p>
</li>
<li><p> if <code>error.scale = 1</code>:  <code class="reqn">r_t = g_1(y_t) - g_1(\mu_t)</code>
(predictive scale)
</p>
</li></ul>

</li>
<li> <p><code class="reqn">c_k</code> are the coefficients of <code class="reqn">(1-L)^d\theta(L)</code>.
In particular, if <code class="reqn">d = 0</code>, then <code class="reqn">c_k = \theta_k</code>, for
<code class="reqn">k = 1, \dots, q</code>.
</p>
</li></ul>



<h3>Common Arguments</h3>

<p>In what follows we describe some of the arguments that are
commom to all BTSR models. For more details on extra arguments,
see the corresponding function associated to the selected model.
</p>


<h4>Simulation Function</h4>

<p>Common arguments passed through <code>"..."</code> in <code>btsr.sim</code> are:
</p>

<ul>
<li> <p><code>n</code> a strictly positive integer. The sample size of yt (after burn-in).
Default for all models is 1.
</p>
</li>
<li> <p><code>burn</code> a non-negative integer. length of &quot;burn-in&quot; period.
Default for all models is 0.
</p>
</li>
<li> <p><code>xreg</code> optionally, a vector or matrix of external regressors.
For simulation purposes, the length of xreg must be <code>n+burn</code>.
Default for all models is <code>NULL</code>
</p>
</li>
<li> <p><code>coefs</code> a list with the coefficients of the model. Each model has
its default. An empty list will result in an error. The arguments in this list
are:
</p>

<ul>
<li> <p><code>alpha</code> optionally, A numeric value corresponding to the intercept.
If the argument is missing, it will be treated as zero.
</p>
</li>
<li> <p><code>beta</code> optionally, a vector of coefficients corresponding to the
regressors in <code>xreg</code>. If <code>xreg</code> is provided but <code>beta</code> is
missing in the <code>coefs</code> list, an error message is issued.
</p>
</li>
<li> <p><code>phi</code> optionally, a vector of size <code class="reqn">p</code>, corresponding to the
autoregressive coefficients (including the ones that are zero), where <code class="reqn">p</code>
is the AR order.
</p>
</li>
<li> <p><code>nu</code> the dispersion parameter. If missing, an error message is issued.
</p>
</li>
<li> <p><code>rho, y.lower, y.upper, theta, d, u0</code> model specif arguments.
See the documentation corresponding to each model.
</p>
</li></ul>

</li>
<li> <p><code>y.start</code> optionally, a initial value for yt (to be used
in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">g_2(y_t) = 0</code>, for <code class="reqn">t &lt; 1</code>.
</p>
</li>
<li> <p><code>xreg.start</code> optionally, a vector of initial value for xreg
(to be used in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">X_t = 0</code>, for <code class="reqn">t &lt; 1</code>. If <code>xregar = FALSE</code> this argument
is ignored.
</p>
</li>
<li> <p><code>xregar</code> logical; indicates if xreg is to be included in the
AR part of the model.  See &lsquo;The BTSR structure&rsquo;. Default is <code>TRUE</code>.
</p>
</li>
<li> <p><code>error.scale</code> the scale for the error term. See also &lsquo;The BTSR structure&rsquo;.
Each model has its default.
</p>
</li>
<li> <p><code>inf</code> the truncation point for infinite sums. Default is 1000.
In practice, the Fortran subroutine uses <code class="reqn">inf = q</code>, if <code class="reqn">d = 0</code>.
BARC models do not have this argument.
</p>
</li>
<li> <p><code>linkg</code> character or a two character vector indicating which
links must be used in the model.  See &lsquo;The BTSR structure&rsquo;.
If only one value is provided, the same link is used for <code class="reqn">mu_t</code> and
for <code class="reqn">y_t</code> in the AR part of the model. Each model has its default.
</p>
</li>
<li> <p><code>seed</code> optionally, an integer which gives the value of the fixed
seed to be used by the random number generator. If missing, a random integer
is chosen uniformly from 1,000 to 10,000.
</p>
</li>
<li> <p><code>rngtype</code> optionally, an integer indicating which random number generator
is to be used. Default is 2. The current options are:
</p>

<ul>
<li> <p><code>0</code>: Jason Blevins algorithm. Available at <a href="https://jblevins.org/log/openmp">https://jblevins.org/log/openmp</a>
</p>
</li>
<li> <p><code>1</code>: Wichmann-Hill algorithm  (Wichmann and Hill, 1982).
</p>
</li>
<li> <p><code>2</code>: Mersenne Twister algorithm (Matsumoto and Nishimura, 1998).
FORTRAN code adapted from <a href="https://jblevins.org/mirror/amiller/mt19937.f90">https://jblevins.org/mirror/amiller/mt19937.f90</a> and
<a href="https://jblevins.org/mirror/amiller/mt19937a.f90">https://jblevins.org/mirror/amiller/mt19937a.f90</a>
</p>
</li>
<li> <p><code>3</code>: Marsaglia-MultiCarry algorithm - kiss 32. Random number generator suggested
by George Marsaglia in &quot;Random numbers for C: The END?&quot; posted on sci.crypt.random-numbers
in 1999.
</p>
</li>
<li> <p><code>4</code>: Marsaglia-MultiCarry algorithm - kiss 64. 	Based on the
64-bit KISS (Keep It Simple Stupid) random number generator distributed by
George Marsaglia in <a href="https://groups.google.com/d/topic/comp.lang.fortran/qFv18ql_WlU">https://groups.google.com/d/topic/comp.lang.fortran/qFv18ql_WlU</a>
</p>
</li>
<li> <p><code>5</code>: Knuth's 2002 algorithm (Knuth, 202). FORTRAN code adapted
from <a href="https://www-cs-faculty.stanford.edu/~knuth/programs/frng.f">https://www-cs-faculty.stanford.edu/~knuth/programs/frng.f</a>
</p>
</li>
<li> <p><code>6</code>: L'Ecuyer's 1999 algorithm - 64-bits (L'Ecuyer, 1999).
FORTRAN code adapted from <a href="https://jblevins.org/mirror/amiller/lfsr258.f90">https://jblevins.org/mirror/amiller/lfsr258.f90</a>
</p>
</li></ul>

<p>For more details on these algorithms see <code><a href="base.html#topic+Random">Random</a></code> and references
therein.
</p>
</li>
<li> <p><code>debug</code> logical, if <code>TRUE</code> the output from FORTRAN is return (for
debuggin purposes).  Default is <code>FALSE</code> for all models.
</p>
</li></ul>




<h4>Extracting Function</h4>

<p>Common arguments passed through <code>"..."</code> in <code>btsr.extract</code> are:
</p>

<ul>
<li> <p><code>yt</code> a numeric vector with the observed time series. If missing, an error
message is issued.
</p>
</li>
<li> <p><code>xreg</code> optionally, a vector or matrix with the regressor's values.
Default is <code>NULL</code> for all models.
</p>
</li>
<li> <p><code>nnew</code> optionally, the number of out-of sample predicted values required.
Default is 0 for all models.
</p>
</li>
<li> <p><code>xnew</code> a vector or matrix, with <code>nnew</code> observations of the
regressors observed/predicted values corresponding to the period of
out-of-sample forecast. If <code>xreg = NULL</code>, <code>xnew</code> is ignored.
</p>
</li>
<li> <p><code>p</code> a non-negative integer. The order of AR polynomial.
If missing, the value of <code>p</code> is calculated from length(coefs$phi)
and length(fixed.values$phi).
</p>
</li>
<li> <p><code>q,r</code> a non-negative integer. The order of the MA polynomial and
the size of the vector of parameters for the map function (BARC only).
If missing, the argument is calcualted based on length(coefs$theta)
and length(fixed.values$theta).
</p>
</li>
<li> <p><code>coefs</code> a list with the coefficients of the model. Each model has
its default. Passing both, <code>coefs</code> and <code>fixed.values</code> empty
will result in an error. The arguments in this list are
</p>

<ul>
<li> <p><code>alpha</code> a numeric value corresponding to the intercept.
If missing, will be set as zero.
</p>
</li>
<li> <p><code>beta</code> a vector of coefficients corresponding to the
regressors in <code>xreg</code>. If <code>xreg</code> is provided but <code>beta</code> is
missing in the <code>coefs</code> list, an error message is issued.
</p>
</li>
<li> <p><code>phi</code> a vector with the non-fixed values in the vector of
AR coefficients.
</p>
</li>
<li> <p><code>nu</code> the dispersion parameter. If missing, an error message is issued.
</p>
</li>
<li> <p><code>theta, d, u0</code> model specific arguments. See the documentation
corresponding to each model.
</p>
</li></ul>

</li>
<li> <p><code>lags</code> optionally, a list with the lags that the values in <code>coefs</code> correspond to.
The names of the entries in this list must match the ones in <code>coefs</code>.
For one dimensional coefficients, the <code>lag</code> is obviously always 1 and can
be suppressed. An empty list indicates that either the argument <code>fixed.lags</code>
is provided or all lags must be used.
</p>
</li>
<li> <p><code>fixed.values</code> optionally, a list with the values of the coefficients
that are fixed. By default, if a given vector (such as the vector of AR coefficients)
has fixed values and the corresponding entry in this list is empty, the fixed values
are set as zero. The names of the entries in this list must match the ones
in <code>coefs</code>.
</p>
</li>
<li> <p><code>fixed.lags</code> optionally, a list with the lags that the fixed values
in <code>fixed.values</code> correspond to. The names of the entries in this list must
match the ones in <code>fixed.values</code>. ##' For one dimensional coefficients, the
<code>lag</code> is obviously always 1 and can be suppressed. If an empty list is provided
and the model has fixed lags, the argument <code>lags</code> is used as reference.
</p>
</li>
<li> <p><code>y.start</code> optionally, a initial value for yt (to be used
in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">g_2(y_t) = 0</code>, for <code class="reqn">t &lt; 1</code>.
</p>
</li>
<li> <p><code>xreg.start</code> optionally, a vector of initial value for xreg
(to be used in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">X_t = 0</code>, for <code class="reqn">t &lt; 1</code>. If <code>xregar = FALSE</code> this argument
is ignored.
</p>
</li>
<li> <p><code>xregar</code> logical; indicates if xreg is to be included in the
AR part of the model.  See &lsquo;The BTSR structure&rsquo;. Default is <code>TRUE</code>.
</p>
</li>
<li> <p><code>error.scale</code> the scale for the error term. See also &lsquo;The BTSR structure&rsquo;.
Each model has its default.
</p>
</li>
<li> <p><code>inf</code> the truncation point for infinite sums. Default is 1.
BARC models do not have this argument.
</p>
</li>
<li> <p><code>m</code> a non-negative integer indicating the starting time for the sum of the
partial log-likelihoods, that is <code class="reqn">\ell = \sum_{t = m+1}^n \ell_t</code>. Default is
0.
</p>
</li>
<li> <p><code>linkg</code> character or a two character vector indicating which
links must be used in the model.  See &lsquo;The BTSR structure&rsquo;.
If only one value is provided, the same link is used for <code class="reqn">mu_t</code> and
for <code class="reqn">y_t</code> in the AR part of the model. Each model has its default.
</p>
</li>
<li> <p><code>llk</code> logical, if <code>TRUE</code> the value of the log-likelihood function
is returned. Default is <code>TRUE</code> for all models.
</p>
</li>
<li> <p><code>sco</code> logical, if <code>TRUE</code> the score vector is returned.
Default is <code>FALSE</code> for all models.
</p>
</li>
<li> <p><code>info</code> logical, if <code>TRUE</code> the information matrix is returned.
Default is <code>FALSE</code> for all models.
</p>
</li>
<li> <p><code>extra</code> logical, if <code>TRUE</code> the matrices and vectors used to
calculate the score vector and the information matrix are returned.
Default is <code>FALSE</code> for all models.
</p>
</li>
<li> <p><code>debug</code> logical, if <code>TRUE</code> the output from FORTRAN is return (for
debuggin purposes).  Default is <code>FALSE</code> for all models.
</p>
</li></ul>




<h4>Fitting Function</h4>

<p>Common arguments passed through <code>"..."</code> in <code>btsr.fit</code> are the same as
in <code><a href="#topic+btsr.extract">btsr.extract</a></code> plus the following:
</p>

<ul>
<li> <p><code>d</code> logical, if <code>TRUE</code>, the parameter <code>d</code> is included
in the model either as fixed or non-fixed. If <code>d = FALSE</code> the value is
fixed as 0. The default is <code>TRUE</code> for all models, except BARC that does
not have this parameter.
</p>
</li>
<li> <p><code>start</code> a list with the starting values for the non-fixed coefficients
of the model. If an empty list is provided, the function <code><a href="#topic+coefs.start">coefs.start</a></code>
is used to obtain starting values for the parameters.
</p>
</li>
<li> <p><code>ignore.start</code> logical,  if starting values are not provided, the
function uses the default values and <code>ignore.start</code> is ignored.
In case starting values are provided and <code>ignore.start = TRUE</code>, those
starting values are ignored and recalculated. The default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>lower, upper</code> optionally, list with the lower and upper bounds for the
parameters. The names of the entries in these lists must match the ones
in <code>start</code>. The default is to assume that the parameters are unbounded.
Only the bounds for bounded parameters need to be specified.
</p>
</li>
<li> <p><code>control</code> a list with configurations to be passed to the
optimization subroutines. Missing arguments will receive default values. See
<cite><a href="#topic+fit.control">fit.control</a></cite>.
</p>
</li>
<li> <p><code>report</code> logical, if <code>TRUE</code> the summary from model estimation is
printed and <code>info</code> is automatically set to <code>TRUE</code>. Default is <code>TRUE</code>.
</p>
</li></ul>




<h3>References</h3>

<p>Knuth, D. E. (2002). The Art of Computer Programming. Volume 2,
third edition, ninth printing.
</p>
<p>L'Ecuyer, P. (1999). Good parameters and implementations for combined
multiple recursive random number generators. Operations Research, 47,
159-164. <a href="doi:10.1287/opre.47.1.159.">doi:10.1287/opre.47.1.159.</a>
</p>
<p>Matsumoto, M. and Nishimura, T. (1998). Mersenne Twister: A 623-dimensionally
equidistributed uniform pseudo-random number generator, ACM Transactions on
Modeling and Computer Simulation, 8, 3-30.
</p>
<p>Wichmann, B. A. and Hill, I. D. (1982). Algorithm AS 183: An Efficient
and Portable Pseudo-random Number Generator. Applied Statistics, 31, 188-190;
Remarks: 34, 198 and 35, 89. <a href="doi:10.2307/2347988.">doi:10.2307/2347988.</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BARFIMA.sim">BARFIMA.sim</a></code>,  <code><a href="#topic+GARFIMA.sim">GARFIMA.sim</a></code>,
<code><a href="#topic+KARFIMA.sim">KARFIMA.sim</a></code>,  <code><a href="#topic+BARC.sim">BARC.sim</a></code>
</p>
<p><code><a href="#topic+BARFIMA.extract">BARFIMA.extract</a></code>,  <code><a href="#topic+GARFIMA.extract">GARFIMA.extract</a></code>,
<code><a href="#topic+KARFIMA.extract">KARFIMA.extract</a></code>,  <code><a href="#topic+BARC.extract">BARC.extract</a></code>
</p>
<p><code><a href="#topic+BARFIMA.fit">BARFIMA.fit</a></code>,  <code><a href="#topic+GARFIMA.fit">GARFIMA.fit</a></code>,
<code><a href="#topic+KARFIMA.fit">KARFIMA.fit</a></code>,  <code><a href="#topic+BARC.fit">BARC.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a Beta model were mut does not vary with time
# yt ~ Beta(a,b), a = mu*nu, b = (1-mu)*nu

y &lt;- btsr.sim(model= "BARFIMA", linkg = "linear",
               n = 1000, seed = 2021,
               coefs = list(alpha = 0.2, nu = 20))
hist(y)

 #------------------------------------------------------------
 # Generating a Beta model were mut does not vary with time
 # yt ~ Beta(a,b), a = mu*nu, b = (1-mu)*nu
 #------------------------------------------------------------

 m1 &lt;- btsr.sim(model= "BARFIMA", linkg = "linear",
                n = 100, seed = 2021, complete = TRUE,
                coefs = list(alpha = 0.2, nu = 20))

 #------------------------------------------------------------
 #  Extracting the conditional time series given yt and
 #  a set of parameters
 #------------------------------------------------------------

 # Assuming that all coefficients are non-fixed
 e1 = btsr.extract(model = "BARFIMA", yt = m1$yt,
                  coefs = list(alpha = 0.2, nu = 20),
                  link = "linear", llk = TRUE,
                  sco = TRUE, info = TRUE)

 # Assuming that all coefficients are fixed
 e2 = btsr.extract(model = "BARFIMA", yt = m1$yt,
                  fixed.values = list(alpha = 0.2, nu = 20),
                  link = "linear", llk = TRUE,
                  sco = TRUE, info = TRUE)

 # Assuming at least one fixed coefficient and one non-fixed
 e3 = btsr.extract(model = "BARFIMA", yt = m1$yt,
                  fixed.values = list(alpha = 0.2, nu = 20),
                  link = "linear", llk = TRUE,
                  sco = TRUE, info = TRUE)
 e4 = btsr.extract(model = "BARFIMA", yt = m1$yt,
                  fixed.values = list(alpha = 0.2, nu = 20),
                  link = "linear", llk = TRUE,
                  sco = TRUE, info = TRUE)

 #----------------------------------------------------
 # comparing the simulated and the extracted values
 #----------------------------------------------------
 cbind(head(m1$mut), head(e1$mut), head(e2$mut), head(e3$mut), head(e4$mut))

 #----------------------------------------------------
 # comparing the log-likelihood values obtained (must be the all equal)
 #----------------------------------------------------
 c(e1$sll, e2$sll, e3$sll, e4$sll)

 #----------------------------------------------------
 # comparing the score vectors:
 #----------------------------------------------------
 # - e1 must have 2 values: dl/dmu and dl/dnu
 # - e2 must be empty
 # - e3 and e4 must have one value corresponding
 #    to the non-fixed coefficient
 #----------------------------------------------------
  e1$score
  e2$score
  e3$score
  e4$score

 #----------------------------------------------------
 # comparing the information matrices.
 #----------------------------------------------------
 # - e1 must be a 2x2 matrix
 # - e2 must be empty
 # - e3 and e4 must have one value corresponding
 #    to the non-fixed coefficient
 #----------------------------------------------------
  e1$info.Matrix
  e2$info.Matrix
  e3$info.Matrix
  e4$info.Matrix


# Generating a Beta model were mut does not vary with time
# yt ~ Beta(a,b), a = mu*nu, b = (1-mu)*nu

y &lt;- btsr.sim(model= "BARFIMA", linkg = "linear",
               n = 100, seed = 2021,
               coefs = list(alpha = 0.2, nu = 20))

# fitting the model
f &lt;- btsr.fit(model = "BARFIMA", yt = y, report = TRUE,
             start = list(alpha = 0.5, nu = 10),
             linkg = "linear", d = FALSE)

</code></pre>

<hr>
<h2 id='BTSR.Package'>BTSR: Bounded Time Series Regression.</h2><span id='topic+BTSR.Package'></span><span id='topic+_PACKAGE'></span><span id='topic+BTSR'></span>

<h3>Description</h3>

<p>The BTSR package provides functions to simulate, estimate and forecast a
wide range of regression based dynamic models for bounded time series. The
package covers the most commonly applied models in the literature.
The package's main calculations are done in FORTRAN, which translates into
very fast algorithms.
</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass <a href="mailto:taianeprass@gmail.com">taianeprass@gmail.com</a>
</p>

<hr>
<h2 id='coefs.start'>Initial values for optimization</h2><span id='topic+coefs.start'></span>

<h3>Description</h3>

<p>This function calculates initial values for the parameter vector,
to pass to the optimization function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefs.start(model = "Generic", yt, linkg = c("linear", "linear"),
  xreg = NULL, p = 0, q = 0, d = TRUE, y.start = NULL,
  y.lower = -Inf, y.upper = Inf, lags = list(), fixed.values = list(),
  fixed.lags = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coefs.start_+3A_model">model</code></td>
<td>
<p>character; The model to be fitted to the data. One of
<code>"BARFIMA"</code>, <code>"KARFIMA"</code>, <code>"GARFIMA"</code>, <code>"BARC"</code>.
Default is &quot;Generic&quot; so that no specific structure is assumed.</p>
</td></tr>
<tr><td><code id="coefs.start_+3A_yt">yt</code></td>
<td>
<p>a univariate time series. Missing values (NA's)
are not  allowed.</p>
</td></tr>
<tr><td><code id="coefs.start_+3A_linkg">linkg</code></td>
<td>
<p>character; one of  <code>"linear"</code>, <code>"logit"</code>,
<code>"log"</code>, <code>"loglog"</code>, <code>"cloglog"</code>.
If only one name is provided, the same link will be used for the conditional mean, that is
to define <code class="reqn">g(\mu)</code> and for the observed time series in the AR part
of the model, that is, <code class="reqn">g(y[t])</code>.</p>
</td></tr>
<tr><td><code id="coefs.start_+3A_xreg">xreg</code></td>
<td>
<p>optional; a vector or matrix of external regressors,
which must have the same number of rows as x.</p>
</td></tr>
<tr><td><code id="coefs.start_+3A_p">p</code></td>
<td>
<p>an integer; the AR order. Default is zero.</p>
</td></tr>
<tr><td><code id="coefs.start_+3A_q">q</code></td>
<td>
<p>an integer; for <code>BARC</code> models represents the dimension of
the parameter associated to the map <code class="reqn">T</code>. For other models is the
MA order. Default is zero.</p>
</td></tr>
<tr><td><code id="coefs.start_+3A_d">d</code></td>
<td>
<p>logical; if FALSE, <code class="reqn">d</code> is fixed as zero. Default is TRUE.</p>
</td></tr>
<tr><td><code id="coefs.start_+3A_y.start">y.start</code></td>
<td>
<p>optional; an initialization value for <code class="reqn">y[t]</code>,
for <code class="reqn">t \le 0</code>, to be used in the AR recursion. If not provided,
the default assume <code class="reqn">y[t] = 0</code>, when using a <code>"linear"</code> link for
<code class="reqn">yt</code>, and <code class="reqn">g(y[t]) = 0</code>, otherwise.</p>
</td></tr>
<tr><td><code id="coefs.start_+3A_y.lower">y.lower</code></td>
<td>
<p>lower limit for the distribution support.
Default is <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="coefs.start_+3A_y.upper">y.upper</code></td>
<td>
<p>upper limit for the distribution support.
Default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="coefs.start_+3A_lags">lags</code></td>
<td>
<p>optional; a list with the components <code>beta</code>,
<code>phi</code> and <code>theta</code> specifying which lags must be included
in the model. An empty list or missing component indicates that, based on the values <code>nreg</code>,
<code>p</code>  e <code>q</code>), all lags must be includes in the model.</p>
</td></tr>
<tr><td><code id="coefs.start_+3A_fixed.values">fixed.values</code></td>
<td>
<p>optional; a list with the fixed values for
each component, if any. If fixed values are provided, either <code>lags</code>
or <code>fixed.lags</code> must also be provided.</p>
</td></tr>
<tr><td><code id="coefs.start_+3A_fixed.lags">fixed.lags</code></td>
<td>
<p>optional; a list with the components <code>beta</code>,
<code>phi</code> and <code>theta</code> specifying which lags must be fixed.
An empty list implies that fixed values will be set based on
<code>lags</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with starting values for the parameters of the selected
model. Possible outputs are:
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>the intercept</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the coefficients for the regressors</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>the AR coefficients</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>for BARC models, the map parameter.  For any other model,
the MA coefficients</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>the long memory parameter</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>the precison parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mu = 0.5
nu = 20

yt = rbeta(100, shape1 = mu*nu, shape2 = (1-mu)*nu)
coefs.start(model = "BARFIMA", yt = yt,
            linkg = "linear", d = FALSE,
            y.lower = 0, y.upper = 1)

yt = rgamma(100, shape = nu, rate = mu*nu)
coefs.start(model = "GARFIMA", yt = yt,
            linkg = "linear", d = FALSE,
            y.lower = 0, y.upper = Inf)

</code></pre>

<hr>
<h2 id='fit.control'>Default control list</h2><span id='topic+fit.control'></span>

<h3>Description</h3>

<p>Sets default values for constants  used by the optimization functions
in FORTRAN
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.control(control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.control_+3A_control">control</code></td>
<td>
<p>a list with configurations to be passed to the
optimization subroutines. Missing arguments will receive default values.
See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>control</code> argument is a list that can supply any of the
following components:
</p>

<dl>
<dt><code>method</code></dt><dd><p>The optimization method. Current available options
are <code>"L-BFGS-B"</code> and <code>"Nelder-Mead"</code>. Default is <code>"L-BFGS-B"</code>.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>The maximum number of iterations. Defaults to <code>1000</code>.</p>
</dd>
<dt><code>iprint</code></dt><dd><p>The frequency of reports if <code>control$trace</code>
is positive. Defaults is -1 (no report).
</p>

<ul>
<li><p> For <code>"L-BFGS-B"</code> method:
</p>
<p>iprint&lt;0    no output is generated;
</p>
<p>iprint=0    print only one line at the last iteration;
</p>
<p>0&lt;iprint&lt;99 print also f and |proj g| every iprint iterations;
</p>
<p>iprint=99   print details of every iteration except n-vectors;
</p>
<p>iprint=100  print also the changes of active set and final x;
</p>
<p>iprint&gt;100  print details of every iteration including x and g;
</p>
</li>
<li><p> For <code>"Nelder-Mead"</code> method:
</p>
<p>iprint&lt;0 No printing
</p>
<p>iprint=0 Printing of parameter values and the function
Value after initial evidence of convergence.
</p>
<p>iprint&gt;0 As for iprint = 0 plus progress reports after every
Iprint evaluations, plus printing for the initial simplex.
</p>
</li></ul>
</dd>
<dt><code>factr</code></dt><dd><p>controls the convergence of the <code>"L-BFGS-B"</code>
method. Convergence occurs when the reduction in the objective is
within this factor of the machine tolerance. The iteration will stop when
</p>
<p style="text-align: center;"><code class="reqn">(f^k - f^{k+1})/max\{|f^k|,|f^{k+1}|,1\} \le factr*epsmch</code>
</p>

<p>where epsmch is the machine precision, which is automatically
generated by the code. Typical values
for <code>factr</code>: 1.e+12 for low accuracy; 1.e+7 for moderate accuracy;
1.e+1 for extremely high accuracy. Default is <code>1e7</code>, that is a
tolerance of about <code>1e-8</code>.</p>
</dd>
<dt><code>pgtol</code></dt><dd><p>helps control the convergence of the <code>"L-BFGS-B"</code>
method. It is a tolerance on the projected gradient in the current
search direction. the iteration will stop when
</p>
<p style="text-align: center;"><code class="reqn">max\{|proj g_i |, i = 1, ..., n\} \le pgtol</code>
</p>

<p>where <code class="reqn">pg_i</code> is the ith component of the projected gradient.
Default is <code>1e-12</code>.</p>
</dd>
<dt><code>stopcr</code></dt><dd><p>The criterion applied to the standard deviation of
the values of objective function at the points of the simplex, for
&quot;Nelder-Mead&quot; method.</p>
</dd>
</dl>



<h3>Value</h3>

<p>a list with all arguments in &lsquo;Details&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BTSR::fit.control()

</code></pre>

<hr>
<h2 id='GARFIMA.functions'>Functions to simulate, extract components and fit GARFIMA models</h2><span id='topic+GARFIMA.functions'></span><span id='topic+GARFIMA.sim'></span><span id='topic+GARFIMA.extract'></span><span id='topic+GARFIMA.fit'></span>

<h3>Description</h3>

<p>These functions can be used to simulate, extract components
and fit any model of the class <code>garfima</code>. A model with
class <code>garfima</code> is a special case of a model with class <code>btsr</code> .
See &lsquo;The BTSR structure&rsquo; in <code><a href="#topic+btsr.functions">btsr.functions</a></code> for
more details on the general structure.
</p>
<p>The <code class="reqn">\gamma</code>ARMA model, the gamma regression and a i.i.d. sample
from a gamma distribution can be obtained as special cases.
See &lsquo;Details&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GARFIMA.sim(n = 1, burn = 0, xreg = NULL, coefs = list(alpha = 0, beta
  = NULL, phi = NULL, theta = NULL, d = 0, nu = 20), y.start = NULL,
  xreg.start = NULL, xregar = TRUE, error.scale = 0, complete = FALSE,
  inf = 1000, linkg = c("log", "log"), seed = NULL, rngtype = 2,
  debug = FALSE)

GARFIMA.extract(yt, xreg = NULL, nnew = 0, xnew = NULL, p, q,
  coefs = list(), lags = list(), fixed.values = list(),
  fixed.lags = list(), y.start = NULL, xreg.start = NULL,
  xregar = TRUE, error.scale = 0, inf = 1000, m = 0, linkg = c("log",
  "log"), llk = TRUE, sco = FALSE, info = FALSE, extra = FALSE,
  debug = FALSE)

GARFIMA.fit(yt, xreg = NULL, nnew = 0, xnew = NULL, p = 0, d = TRUE,
  q = 0, m = 0, inf = 1000, start = list(), ignore.start = FALSE,
  lags = list(), fixed.values = list(), fixed.lags = list(),
  lower = list(nu = 0), upper = list(nu = Inf), linkg = c("log", "log"),
  sco = TRUE, info = FALSE, extra = FALSE, xregar = TRUE,
  y.start = NULL, xreg.start = NULL, error.scale = 0, control = list(),
  report = TRUE, debug = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GARFIMA.functions_+3A_n">n</code></td>
<td>
<p>a strictly positive integer. The sample size of yt (after burn-in).
Default is 1.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_burn">burn</code></td>
<td>
<p>a non-negative integer. The length of the &quot;burn-in&quot; period. Default is 0.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_xreg">xreg</code></td>
<td>
<p>optionally, a vector or matrix of external regressors.
For simulation purposes, the length of xreg must be <code>n+burn</code>.
Default is <code>NULL</code>. For extraction or fitting purposes, the length
of <code>xreg</code> must be the same as the length of the observed time series
<code class="reqn">y_t</code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_coefs">coefs</code></td>
<td>
<p>a list with the coefficients of the model. An empty list will result
in an error. The arguments that can be passed through this list are:
</p>

<ul>
<li> <p><code>alpha</code> optionally, a numeric value corresponding to the intercept.
If the argument is missing, it will be treated as zero. See
&lsquo;The BTSR structure&rsquo; in <code><a href="#topic+btsr.functions">btsr.functions</a></code>.
</p>
</li>
<li> <p><code>beta</code> optionally, a vector of coefficients corresponding to the
regressors in <code>xreg</code>. If <code>xreg</code> is provided but <code>beta</code> is
missing in the <code>coefs</code> list, an error message is issued.
</p>
</li>
<li> <p><code>phi</code> optionally, for the simulation function this must be a vector
of size <code class="reqn">p</code>, corresponding to the autoregressive coefficients
(including the ones that are zero), where <code class="reqn">p</code> is the AR order. For
the extraction and fitting functions, this is a vector with the non-fixed
values in the vector of autoregressive coefficients.
</p>
</li>
<li> <p><code>theta</code> optionally, for the simulation function this must be a vector
of size <code class="reqn">q</code>, corresponding to the moving average coefficients
(including the ones that are zero), where <code class="reqn">q</code> is the MA order. For
the extraction and fitting functions, this is a vector with the non-fixed
values in the vector of moving average coefficients.
</p>
</li>
<li> <p><code>d</code> optionally, a numeric value corresponding to the long memory
parameter. If the argument is missing, it will be treated as zero.
</p>
</li>
<li> <p><code>nu</code> the dispersion parameter. If missing, an error message is issued.
</p>
</li></ul>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_y.start">y.start</code></td>
<td>
<p>optionally, an initial value for yt (to be used
in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">g_2(y_t) = 0</code>, for <code class="reqn">t &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_xreg.start">xreg.start</code></td>
<td>
<p>optionally, a vector of initial value for xreg
(to be used in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">X_t = 0</code>, for <code class="reqn">t &lt; 1</code>. If <code>xregar = FALSE</code> this argument
is ignored.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_xregar">xregar</code></td>
<td>
<p>logical; indicates if xreg is to be included in the
AR part of the model.  See &lsquo;The BTSR structure&rsquo;. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_error.scale">error.scale</code></td>
<td>
<p>the scale for the error term. See &lsquo;The BTSR structure&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code>. Default is 0.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_complete">complete</code></td>
<td>
<p>logical; if <code>FALSE</code> the function returns only the simulated
time series yt, otherwise, additional time series are provided.
Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_inf">inf</code></td>
<td>
<p>the truncation point for infinite sums. Default is 1,000.
In practice, the Fortran subroutine uses <code class="reqn">inf = q</code>, if <code class="reqn">d = 0</code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_linkg">linkg</code></td>
<td>
<p>character or a two character vector indicating which
links must be used in the model.  See &lsquo;The BTSR structure&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code> for details and <code><a href="#topic+link.btsr">link.btsr</a></code>
for valid links. If only one value is provided, the same link is used
for <code class="reqn">mu_t</code> and for <code class="reqn">y_t</code> in the AR part of the model.
Default is <code>c("log", "log")</code>. For the linear link, the constant
will be always 1.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_seed">seed</code></td>
<td>
<p>optionally, an integer which gives the value of the fixed
seed to be used by the random number generator. If missing, a random integer
is chosen uniformly from 1,000 to 10,000.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_rngtype">rngtype</code></td>
<td>
<p>optionally, an integer indicating which random number generator
is to be used. Default is 2: the Mersenne Twister algorithm. See &lsquo;Common Arguments&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_debug">debug</code></td>
<td>
<p>logical, if <code>TRUE</code> the output from FORTRAN is return (for
debugging purposes).  Default is <code>FALSE</code> for all models.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_yt">yt</code></td>
<td>
<p>a numeric vector with the observed time series. If missing, an error
message is issued.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_nnew">nnew</code></td>
<td>
<p>optionally, the number of out-of sample predicted values required.
Default is 0.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_xnew">xnew</code></td>
<td>
<p>a vector or matrix, with <code>nnew</code> observations of the
regressors observed/predicted values corresponding to the period of
out-of-sample forecast. If <code>xreg = NULL</code>, <code>xnew</code> is ignored.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_p">p</code></td>
<td>
<p>a non-negative integer. The order of AR polynomial.
If missing, the value of <code>p</code> is calculated from length(coefs$phi)
and length(fixed.values$phi). For fitting, the default is 0.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_q">q</code></td>
<td>
<p>a non-negative integer. The order of the MA polynomial.
If missing, the value of <code>q</code> is calculated from length(coefs$theta)
and length(fixed.values$theta). For fitting, the default is 0.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_lags">lags</code></td>
<td>
<p>optionally, a list with the lags that the values in <code>coefs</code> correspond to.
The names of the entries in this list must match the ones in <code>coefs</code>.
For one dimensional coefficients, the <code>lag</code> is obviously always 1 and can
be suppressed. An empty list indicates that either the argument <code>fixed.lags</code>
is provided or all lags must be used.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_fixed.values">fixed.values</code></td>
<td>
<p>optionally, a list with the values of the coefficients
that are fixed. By default, if a given vector (such as the vector of AR coefficients)
has fixed values and the corresponding entry in this list is empty, the fixed values
are set as zero. The names of the entries in this list must match the ones
in <code>coefs</code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_fixed.lags">fixed.lags</code></td>
<td>
<p>optionally, a list with the lags that the fixed values
in <code>fixed.values</code> correspond to. The names of the entries in this list must
match the ones in <code>fixed.values</code>. ##' For one dimensional coefficients, the
<code>lag</code> is obviously always 1 and can be suppressed. If an empty list is provided
and the model has fixed lags, the argument <code>lags</code> is used as reference.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_m">m</code></td>
<td>
<p>a non-negative integer indicating the starting time for the sum of the
partial log-likelihoods, that is <code class="reqn">\ell = \sum_{t = m+1}^n \ell_t</code>. Default is
0.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_llk">llk</code></td>
<td>
<p>logical, if <code>TRUE</code> the value of the log-likelihood function
is returned. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_sco">sco</code></td>
<td>
<p>logical, if <code>TRUE</code> the score vector is returned.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_info">info</code></td>
<td>
<p>logical, if <code>TRUE</code> the information matrix is returned.
Default is <code>FALSE</code>. For the fitting function, <code>info</code> is automatically
set to <code>TRUE</code> when <code>report = TRUE</code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_extra">extra</code></td>
<td>
<p>logical, if <code>TRUE</code> the matrices and vectors used to
calculate the score vector and the information matrix are returned.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_d">d</code></td>
<td>
<p>logical, if <code>TRUE</code>, the parameter <code>d</code> is included
in the model either as fixed or non-fixed. If <code>d = FALSE</code> the value is
fixed as 0. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_start">start</code></td>
<td>
<p>a list with the starting values for the non-fixed coefficients
of the model. If an empty list is provided, the function <code><a href="#topic+coefs.start">coefs.start</a></code>
is used to obtain starting values for the parameters.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_ignore.start">ignore.start</code></td>
<td>
<p>logical,  if starting values are not provided, the
function uses the default values and <code>ignore.start</code> is ignored.
In case starting values are provided and <code>ignore.start = TRUE</code>, those
starting values are ignored and recalculated. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_lower">lower</code></td>
<td>
<p>optionally, list with the lower bounds for the
parameters. The names of the entries in these lists must match the ones
in <code>start</code>. The default is to assume that the parameters have no lower
bound except for <code>nu</code>, for which de default is 0. Only the bounds for
bounded parameters need to be specified.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_upper">upper</code></td>
<td>
<p>optionally, list with the upper bounds for the
parameters. The names of the entries in these lists must match the ones
in <code>start</code>. The default is to assume that the parameters have no upper
bound. Only the bounds for bounded parameters need to be specified.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_control">control</code></td>
<td>
<p>a list with configurations to be passed to the
optimization subroutines. Missing arguments will receive default values. See
<cite><a href="#topic+fit.control">fit.control</a></cite>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_report">report</code></td>
<td>
<p>logical, if <code>TRUE</code> the summary from model estimation is
printed and <code>info</code> is automatically set to <code>TRUE</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GARFIMA.functions_+3A_...">...</code></td>
<td>
<p>further arguments passed to the internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">\gamma</code>ARMA model  and the gamma regression can be
obtained as special cases of the <code class="reqn">\gamma</code>ARFIMA model.
</p>

<ul>
<li> <p><code class="reqn">\gamma</code>ARFIMA: is obtained by default.
</p>
</li>
<li> <p><code class="reqn">\gamma</code>ARMA: is obtained by setting <code>d = 0</code>.
</p>
</li>
<li><p> gamma regression: is obtained by setting <code>p = 0</code>, <code>q = 0</code>
and <code>d = FALSE</code>. The <code>error.scale</code> is irrelevant.
The second argument in <code>linkg</code> is irrelevant.
</p>
</li>
<li><p> an i.i.d. sample from a Gamma distribution with parameters
<code>shape</code> and <code>scale</code> (compatible with the one from <code><a href="stats.html#topic+rgamma">rgamma</a></code>)
is obtained by  setting <code>linkg = "linear"</code>, <code>p = 0</code>, <code>q = 0</code>,
<code>coefs$d = 0</code>, <code>d = FALSE</code> and, in the coefficient list,
<code>alpha = shape*scale</code> and <code>nu = shape</code>. (<code>error.scale</code> and
<code>xregar</code> are irrelevant)
</p>
</li></ul>

<p>The function <code>GARFIMA.sim</code> generates a random sample from a <code class="reqn">\gamma</code>ARFIMA(p,d,q)
model.
</p>
<p>The function <code>GARFIMA.extract</code> allows the user to extract the
components <code class="reqn">y_t</code>, <code class="reqn">\mu_t</code>,  <code class="reqn">\eta_t = g(\mu_t)</code>, <code class="reqn">r_t</code>,
the log-likelihood, and the vectors and matrices used to calculate the
score vector and the information matrix associated to a given set of parameters.
</p>
<p>This function can be used by any user to create an objective function
that can be passed to optimization algorithms not available in the BTSR Package.
</p>
<p>The function <code>GARFIMA.fit</code> fits a GARFIMA model to a given univariate time
series. For now, available optimization algorithms are <code>"L-BFGS-B"</code> and
<code>"Nelder-Mead"</code>. Both methods accept bounds for the parameters. For
<code>"Nelder-Mead"</code>, bounds are set via parameter transformation.
</p>


<h3>Value</h3>

<p>The function <code>GARFIMA.sim</code> returns the simulated time series yt  by default.
If <code>complete = TRUE</code>, a list with the following components
is returned instead:
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"GARFIMA"</code>
</p>
</li>
<li> <p><code>yt</code>: the simulated time series
</p>
</li>
<li> <p><code>mut</code>: the conditional mean
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g(\mu_t)</code>
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if included in the model).
</p>
</li>
<li> <p><code>debug</code>: the output from FORTRAN (if requested).
</p>
</li></ul>

<p>The function <code>GARFIMA.extract</code> returns a list with the following components.
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"GARFIMA"</code>
</p>
</li>
<li> <p><code>coefs</code>: the coefficients of the model passed through the
<code>coefs</code> argument
</p>
</li>
<li> <p><code>yt</code>: the observed time series
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g_2(y_t)</code>
</p>
</li>
<li> <p><code>mut</code>: the conditional mean
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g_1(\mu_t)</code>
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if included in the model).
</p>
</li>
<li> <p><code>sll</code>: the sum of the conditional log-likelihood (if requested)
</p>
</li>
<li> <p><code>sco</code>: the score vector  (if requested)
</p>
</li>
<li> <p><code>info</code>: the information matrix  (if requested)
</p>
</li>
<li> <p><code>Drho</code>, <code>T</code>, <code>E</code>, <code>h</code>: additional matrices and vectors
used to calculate the score vector and the information matrix.  (if requested)
</p>
</li>
<li> <p><code>yt.new</code>: the out-of-sample forecast  (if requested)
</p>
</li>
<li> <p><code>out.Fortran</code>: FORTRAN output  (if requested)
</p>
</li></ul>

<p>The function <code>btsr.fit</code> returns a list with the following components.
Each particular model can have additional components in this list.
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"GARFIMA"</code>
</p>
</li>
<li> <p><code>convergence</code>: An integer code. 0 indicates successful completion.
The error codes depend on the algorithm used.
</p>
</li>
<li> <p><code>message</code>: A character string giving any additional information
returned by the optimizer, or NULL.
</p>
</li>
<li> <p><code>counts</code>: an integer giving the number of function evaluations.
</p>
</li>
<li> <p><code>control</code>: a list of control parameters.
</p>
</li>
<li> <p><code>start</code>: the starting values used by the algorithm.
</p>
</li>
<li> <p><code>coefficients</code>: 	The best set of parameters found.
</p>
</li>
<li> <p><code>n</code>: the sample size used for estimation.
</p>
</li>
<li> <p><code>series</code>: the observed time series
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g_2(y_t)</code>
</p>
</li>
<li> <p><code>fitted.values</code>: the conditional mean, which corresponds to
the in-sample forecast, also denoted fitted values
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g_1(\mu_t)</code>
</p>
</li>
<li> <p><code>error.scale</code>: the scale for the error term.
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>residual</code>: the observed minus the fitted values. The same as
the <code>error</code> term if <code>error.scale = 0</code>.
</p>
</li>
<li> <p><code>forecast</code>: the out-of-sample forecast (if requested).
</p>
</li>
<li> <p><code>xnew</code>: the observations of the regressors observed/predicted
values corresponding to the period of out-of-sample forecast.
Only inlcudes if <code>xreg</code> is not <code>NULL</code> and <code>nnew &gt; 0</code>.
</p>
</li>
<li> <p><code>sll</code>: the sum of the conditional log-likelihood (if requested)
</p>
</li>
<li> <p><code>info.Matrix</code>: the information matrix  (if requested)
</p>
</li>
<li> <p><code>configs</code>: a list with the configurations adopted to fit the model.
This information is used by the prediction function.
</p>
</li>
<li> <p><code>out.Fortran</code>: FORTRAN output  (if requested)
</p>
</li>
<li> <p><code>call</code>: a string with the description of the fitted model.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+btsr.sim">btsr.sim</a></code>
</p>
<p><code><a href="#topic+btsr.extract">btsr.extract</a></code>
</p>
<p><code><a href="#topic+btsr.fit">btsr.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a Gamma model were mut does not vary with time
# yt ~ Gamma(a,b), a = nu (shape), b = mu/nu (scale)

y &lt;- GARFIMA.sim(linkg = "linear", n = 1000, seed = 2021,
                 coefs = list(alpha = 0.2, nu = 20))
hist(y)

 #------------------------------------------------------------
 # Generating a Gamma model were mut does not vary with time
 # yt ~ Gamma(a,b), a = nu (shape), b = mu/nu (scale)
 #------------------------------------------------------------

 m1 &lt;- GARFIMA.sim(linkg = "linear",n = 100,
                   complete = TRUE, seed = 2021,
                   coefs = list(alpha = 0.2, nu = 20))

 #------------------------------------------------------------
 #  Extracting the conditional time series given yt and
 #  a set of parameters
 #------------------------------------------------------------

 # Assuming that all coefficients are non-fixed
 e1 = GARFIMA.extract(yt = m1$yt, coefs = list(alpha = 0.2, nu = 20),
                      link = "linear", llk = TRUE,
                      sco = TRUE, info = TRUE)

 #----------------------------------------------------
 # comparing the simulated and the extracted values
 #----------------------------------------------------
 cbind(head(m1$mut), head(e1$mut))

 #---------------------------------------------------------
 # the log-likelihood, score vector and information matrix
 #---------------------------------------------------------
 e1$sll
 e1$score
 e1$info.Matrix


# Generating a Beta model were mut does not vary with time
# yt ~ Beta(a,b), a = mu*nu, b = (1-mu)*nu

y &lt;- GARFIMA.sim(linkg = "linear", n = 100, seed = 2021,
               coefs = list(alpha = 0.2, nu = 20))

# fitting the model
f &lt;- GARFIMA.fit(yt = y, report = TRUE,
                 start = list(alpha = 0.5, nu = 10),
                 linkg = "linear", d = FALSE)

</code></pre>

<hr>
<h2 id='KARFIMA.functions'>Functions to simulate, extract components and fit KARFIMA models</h2><span id='topic+KARFIMA.functions'></span><span id='topic+KARFIMA.sim'></span><span id='topic+KARFIMA.extract'></span><span id='topic+KARFIMA.fit'></span>

<h3>Description</h3>

<p>These functions can be used to simulate, extract components
and fit any model of the class <code>karfima</code>. A model with
class <code>karfima</code> is a special case of a model with class <code>btsr</code> .
See &lsquo;The BTSR structure&rsquo; in <code><a href="#topic+btsr.functions">btsr.functions</a></code> for
more details on the general structure.
</p>
<p>The KARMA model, the Kumaraswamy regression and a i.i.d. sample
from a Kumaraswamy distribution can be obtained as special cases.
See &lsquo;Details&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KARFIMA.sim(n = 1, burn = 0, xreg = NULL, rho = 0.5, y.lower = 0,
  y.upper = 1, coefs = list(alpha = 0, beta = NULL, phi = NULL, theta =
  NULL, d = 0, nu = 20), y.start = NULL, xreg.start = NULL,
  xregar = TRUE, error.scale = 1, complete = FALSE, inf = 1000,
  linkg = c("logit", "logit"), seed = NULL, rngtype = 2, debug = FALSE)

KARFIMA.extract(yt, xreg = NULL, nnew = 0, xnew = NULL, p, q,
  rho = 0.5, y.lower = 0, y.upper = 1, coefs = list(), lags = list(),
  fixed.values = list(), fixed.lags = list(), y.start = NULL,
  xreg.start = NULL, xregar = TRUE, error.scale = 1, inf = 1000,
  m = 0, linkg = c("logit", "logit"), llk = TRUE, sco = FALSE,
  info = FALSE, extra = FALSE, debug = FALSE)

KARFIMA.fit(yt, xreg = NULL, nnew = 0, xnew = NULL, p = 0, d = TRUE,
  q = 0, m = 0, inf = 1000, rho = 0.5, y.lower = 0, y.upper = 1,
  start = list(), ignore.start = FALSE, lags = list(),
  fixed.values = list(), fixed.lags = list(), lower = list(nu = 0),
  upper = list(nu = Inf), linkg = c("logit", "logit"), sco = FALSE,
  info = FALSE, extra = FALSE, xregar = TRUE, y.start = NULL,
  xreg.start = NULL, error.scale = 1, control = list(), report = TRUE,
  debug = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KARFIMA.functions_+3A_n">n</code></td>
<td>
<p>a strictly positive integer. The sample size of yt (after burn-in).
Default is 1.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_burn">burn</code></td>
<td>
<p>a non-negative integer. The length of the &quot;burn-in&quot; period. Default is 0.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_xreg">xreg</code></td>
<td>
<p>optionally, a vector or matrix of external regressors.
For simulation purposes, the length of xreg must be <code>n+burn</code>.
Default is <code>NULL</code>. For extraction or fitting purposes, the length
of <code>xreg</code> must be the same as the length of the observed time series
<code class="reqn">y_t</code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_rho">rho</code></td>
<td>
<p>a positive number, between 0 and 1, indicating the quantile
to be modeled so that <code class="reqn">\mu_t</code> is the conditional <code class="reqn">rho</code>-quantile.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_y.lower">y.lower</code></td>
<td>
<p>the lower limit for the density support. Default is 0.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_y.upper">y.upper</code></td>
<td>
<p>the upper limit for the density support. Default is 1.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_coefs">coefs</code></td>
<td>
<p>a list with the coefficients of the model. An empty list will result
in an error. The arguments that can be passed through this list are:
</p>

<ul>
<li> <p><code>alpha</code> optionally, a numeric value corresponding to the intercept.
If the argument is missing, it will be treated as zero. See
&lsquo;The BTSR structure&rsquo; in <code><a href="#topic+btsr.functions">btsr.functions</a></code>.
</p>
</li>
<li> <p><code>beta</code> optionally, a vector of coefficients corresponding to the
regressors in <code>xreg</code>. If <code>xreg</code> is provided but <code>beta</code> is
missing in the <code>coefs</code> list, an error message is issued.
</p>
</li>
<li> <p><code>phi</code> optionally, for the simulation function this must be a vector
of size <code class="reqn">p</code>, corresponding to the autoregressive coefficients
(including the ones that are zero), where <code class="reqn">p</code> is the AR order. For
the extraction and fitting functions, this is a vector with the non-fixed
values in the vector of autoregressive coefficients.
</p>
</li>
<li> <p><code>theta</code> optionally, for the simulation function this must be a vector
of size <code class="reqn">q</code>, corresponding to the moving average coefficients
(including the ones that are zero), where <code class="reqn">q</code> is the MA order. For
the extraction and fitting functions, this is a vector with the non-fixed
values in the vector of moving average coefficients.
</p>
</li>
<li> <p><code>d</code> optionally, a numeric value corresponding to the long memory
parameter. If the argument is missing, it will be treated as zero.
</p>
</li>
<li> <p><code>nu</code> the dispersion parameter. If missing, an error message is issued.
</p>
</li></ul>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_y.start">y.start</code></td>
<td>
<p>optionally, an initial value for yt (to be used
in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">g_2(y_t) = 0</code>, for <code class="reqn">t &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_xreg.start">xreg.start</code></td>
<td>
<p>optionally, a vector of initial value for xreg
(to be used in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">X_t = 0</code>, for <code class="reqn">t &lt; 1</code>. If <code>xregar = FALSE</code> this argument
is ignored.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_xregar">xregar</code></td>
<td>
<p>logical; indicates if xreg is to be included in the
AR part of the model.  See &lsquo;The BTSR structure&rsquo;. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_error.scale">error.scale</code></td>
<td>
<p>the scale for the error term. See &lsquo;The BTSR structure&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code>. Default is 1.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_complete">complete</code></td>
<td>
<p>logical; if <code>FALSE</code> the function returns only the simulated
time series yt, otherwise, additional time series are provided.
Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_inf">inf</code></td>
<td>
<p>the truncation point for infinite sums. Default is 1,000.
In practice, the Fortran subroutine uses <code class="reqn">inf = q</code>, if <code class="reqn">d = 0</code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_linkg">linkg</code></td>
<td>
<p>character or a two character vector indicating which
links must be used in the model.  See &lsquo;The BTSR structure&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code> for details and <code><a href="#topic+link.btsr">link.btsr</a></code>
for valid links. If only one value is provided, the same link is used
for <code class="reqn">mu_t</code> and for <code class="reqn">y_t</code> in the AR part of the model.
Default is <code>c("logit", "logit")</code>. For the linear link, the constant
will be always 1.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_seed">seed</code></td>
<td>
<p>optionally, an integer which gives the value of the fixed
seed to be used by the random number generator. If missing, a random integer
is chosen uniformly from 1,000 to 10,000.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_rngtype">rngtype</code></td>
<td>
<p>optionally, an integer indicating which random number generator
is to be used. Default is 2: the Mersenne Twister algorithm. See &lsquo;Common Arguments&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_debug">debug</code></td>
<td>
<p>logical, if <code>TRUE</code> the output from FORTRAN is return (for
debugging purposes).  Default is <code>FALSE</code> for all models.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_yt">yt</code></td>
<td>
<p>a numeric vector with the observed time series. If missing, an error
message is issued.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_nnew">nnew</code></td>
<td>
<p>optionally, the number of out-of sample predicted values required.
Default is 0.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_xnew">xnew</code></td>
<td>
<p>a vector or matrix, with <code>nnew</code> observations of the
regressors observed/predicted values corresponding to the period of
out-of-sample forecast. If <code>xreg = NULL</code>, <code>xnew</code> is ignored.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_p">p</code></td>
<td>
<p>a non-negative integer. The order of AR polynomial.
If missing, the value of <code>p</code> is calculated from length(coefs$phi)
and length(fixed.values$phi). For fitting, the default is 0.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_q">q</code></td>
<td>
<p>a non-negative integer. The order of the MA polynomial.
If missing, the value of <code>q</code> is calculated from length(coefs$theta)
and length(fixed.values$theta). For fitting, the default is 0.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_lags">lags</code></td>
<td>
<p>optionally, a list with the lags that the values in <code>coefs</code> correspond to.
The names of the entries in this list must match the ones in <code>coefs</code>.
For one dimensional coefficients, the <code>lag</code> is obviously always 1 and can
be suppressed. An empty list indicates that either the argument <code>fixed.lags</code>
is provided or all lags must be used.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_fixed.values">fixed.values</code></td>
<td>
<p>optionally, a list with the values of the coefficients
that are fixed. By default, if a given vector (such as the vector of AR coefficients)
has fixed values and the corresponding entry in this list is empty, the fixed values
are set as zero. The names of the entries in this list must match the ones
in <code>coefs</code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_fixed.lags">fixed.lags</code></td>
<td>
<p>optionally, a list with the lags that the fixed values
in <code>fixed.values</code> correspond to. The names of the entries in this list must
match the ones in <code>fixed.values</code>. ##' For one dimensional coefficients, the
<code>lag</code> is obviously always 1 and can be suppressed. If an empty list is provided
and the model has fixed lags, the argument <code>lags</code> is used as reference.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_m">m</code></td>
<td>
<p>a non-negative integer indicating the starting time for the sum of the
partial log-likelihoods, that is <code class="reqn">\ell = \sum_{t = m+1}^n \ell_t</code>. Default is
0.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_llk">llk</code></td>
<td>
<p>logical, if <code>TRUE</code> the value of the log-likelihood function
is returned. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_sco">sco</code></td>
<td>
<p>logical, if <code>TRUE</code> the score vector is returned.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_info">info</code></td>
<td>
<p>logical, if <code>TRUE</code> the information matrix is returned.
Default is <code>FALSE</code>. For the fitting function, <code>info</code> is automatically
set to <code>TRUE</code> when <code>report = TRUE</code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_extra">extra</code></td>
<td>
<p>logical, if <code>TRUE</code> the matrices and vectors used to
calculate the score vector and the information matrix are returned.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_d">d</code></td>
<td>
<p>logical, if <code>TRUE</code>, the parameter <code>d</code> is included
in the model either as fixed or non-fixed. If <code>d = FALSE</code> the value is
fixed as 0. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_start">start</code></td>
<td>
<p>a list with the starting values for the non-fixed coefficients
of the model. If an empty list is provided, the function <code><a href="#topic+coefs.start">coefs.start</a></code>
is used to obtain starting values for the parameters.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_ignore.start">ignore.start</code></td>
<td>
<p>logical,  if starting values are not provided, the
function uses the default values and <code>ignore.start</code> is ignored.
In case starting values are provided and <code>ignore.start = TRUE</code>, those
starting values are ignored and recalculated. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_lower">lower</code></td>
<td>
<p>optionally, list with the lower bounds for the
parameters. The names of the entries in these lists must match the ones
in <code>start</code>. The default is to assume that the parameters have no lower
bound except for <code>nu</code>, for which de default is 0. Only the bounds for
bounded parameters need to be specified.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_upper">upper</code></td>
<td>
<p>optionally, list with the upper bounds for the
parameters. The names of the entries in these lists must match the ones
in <code>start</code>. The default is to assume that the parameters have no upper
bound. Only the bounds for bounded parameters need to be specified.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_control">control</code></td>
<td>
<p>a list with configurations to be passed to the
optimization subroutines. Missing arguments will receive default values. See
<cite><a href="#topic+fit.control">fit.control</a></cite>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_report">report</code></td>
<td>
<p>logical, if <code>TRUE</code> the summary from model estimation is
printed and <code>info</code> is automatically set to <code>TRUE</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="KARFIMA.functions_+3A_...">...</code></td>
<td>
<p>further arguments passed to the internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The KARMA model  and the Kumaraswamy regression can be
obtained as special cases of the KARFIMA model.
</p>

<ul>
<li><p> KARFIMA: is obtained by default.
</p>
</li>
<li><p> KARMA: is obtained by setting <code>d = 0</code>.
</p>
</li>
<li><p> Kumaraswamy regression: is obtained by setting <code>p = 0</code>,
<code>q = 0</code> and <code>d = FALSE</code>. The <code>error.scale</code> is irrelevant.
The second argument in <code>linkg</code> is irrelevant.
</p>
</li>
<li><p> an i.i.d. sample from a Kumaraswamy distribution
is obtained by  setting <code>linkg = "linear"</code>, <code>p = 0</code>, <code>q = 0</code>,
<code>coefs$d = 0</code>, <code>d = FALSE</code>. (<code>error.scale</code> and
<code>xregar</code> are irrelevant)
</p>
</li></ul>

<p>The function <code>KARFIMA.sim</code> generates a random sample from a KARFIMA(p,d,q)
model.
</p>
<p>The function <code>KARFIMA.extract</code> allows the user to extract the
components <code class="reqn">y_t</code>, <code class="reqn">\mu_t</code>,  <code class="reqn">\eta_t = g(\mu_t)</code>, <code class="reqn">r_t</code>,
the log-likelihood, and the vectors and matrices used to calculate the
score vector and the information matrix associated to a given set of parameters.
</p>
<p>This function can be used by any user to create an objective function
that can be passed to optimization algorithms not available in the BTSR Package.
</p>
<p>The function <code>KARFIMA.fit</code> fits a KARFIMA model to a given univariate time
series. For now, available optimization algorithms are <code>"L-BFGS-B"</code> and
<code>"Nelder-Mead"</code>. Both methods accept bounds for the parameters. For
<code>"Nelder-Mead"</code>, bounds are set via parameter transformation.
</p>


<h3>Value</h3>

<p>The function <code>KARFIMA.sim</code> returns the simulated time series yt  by default.
If <code>complete = TRUE</code>, a list with the following components
is returned instead:
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"KARFIMA"</code>
</p>
</li>
<li> <p><code>yt</code>: the simulated time series
</p>
</li>
<li> <p><code>mut</code>: the conditional mean
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g(\mu_t)</code>
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if included in the model).
</p>
</li>
<li> <p><code>debug</code>: the output from FORTRAN (if requested).
</p>
</li></ul>

<p>The function <code>KARFIMA.extract</code> returns a list with the following components.
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"KARFIMA"</code>
</p>
</li>
<li> <p><code>coefs</code>: the coefficients of the model passed through the
<code>coefs</code> argument
</p>
</li>
<li> <p><code>yt</code>: the observed time series
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g_2(y_t)</code>
</p>
</li>
<li> <p><code>mut</code>: the conditional mean
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g_1(\mu_t)</code>
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if included in the model).
</p>
</li>
<li> <p><code>sll</code>: the sum of the conditional log-likelihood (if requested)
</p>
</li>
<li> <p><code>sco</code>: the score vector  (if requested)
</p>
</li>
<li> <p><code>info</code>: the information matrix  (if requested)
</p>
</li>
<li> <p><code>Drho</code>, <code>T</code>, <code>E</code>, <code>h</code>: additional matrices and vectors
used to calculate the score vector and the information matrix.  (if requested)
</p>
</li>
<li> <p><code>yt.new</code>: the out-of-sample forecast  (if requested)
</p>
</li>
<li> <p><code>out.Fortran</code>: FORTRAN output  (if requested)
</p>
</li></ul>

<p>The function <code>btsr.fit</code> returns a list with the following components.
Each particular model can have additional components in this list.
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"KARFIMA"</code>
</p>
</li>
<li> <p><code>convergence</code>: An integer code. 0 indicates successful completion.
The error codes depend on the algorithm used.
</p>
</li>
<li> <p><code>message</code>: A character string giving any additional information
returned by the optimizer, or NULL.
</p>
</li>
<li> <p><code>counts</code>: an integer giving the number of function evaluations.
</p>
</li>
<li> <p><code>control</code>: a list of control parameters.
</p>
</li>
<li> <p><code>start</code>: the starting values used by the algorithm.
</p>
</li>
<li> <p><code>coefficients</code>: 	The best set of parameters found.
</p>
</li>
<li> <p><code>n</code>: the sample size used for estimation.
</p>
</li>
<li> <p><code>series</code>: the observed time series
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g_2(y_t)</code>
</p>
</li>
<li> <p><code>fitted.values</code>: the conditional mean, which corresponds to
the in-sample forecast, also denoted fitted values
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g_1(\mu_t)</code>
</p>
</li>
<li> <p><code>error.scale</code>: the scale for the error term.
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>residual</code>: the observed minus the fitted values. The same as
the <code>error</code> term if <code>error.scale = 0</code>.
</p>
</li>
<li> <p><code>forecast</code>: the out-of-sample forecast (if requested).
</p>
</li>
<li> <p><code>xnew</code>: the observations of the regressors observed/predicted
values corresponding to the period of out-of-sample forecast.
Only inlcudes if <code>xreg</code> is not <code>NULL</code> and <code>nnew &gt; 0</code>.
</p>
</li>
<li> <p><code>sll</code>: the sum of the conditional log-likelihood (if requested)
</p>
</li>
<li> <p><code>info.Matrix</code>: the information matrix  (if requested)
</p>
</li>
<li> <p><code>configs</code>: a list with the configurations adopted to fit the model.
This information is used by the prediction function.
</p>
</li>
<li> <p><code>out.Fortran</code>: FORTRAN output  (if requested)
</p>
</li>
<li> <p><code>call</code>: a string with the description of the fitted model.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+btsr.sim">btsr.sim</a></code>
</p>
<p><code><a href="#topic+btsr.extract">btsr.extract</a></code>
</p>
<p><code><a href="#topic+btsr.fit">btsr.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a Kumaraswamy model were mut does not vary with time
# For linear link, alpha = mu
#
# Warning:
#      |log(1-rho)| &gt;&gt; |log(1 - mu^nu)|
# may cause numerical instability.

y &lt;- KARFIMA.sim(linkg = "linear", n = 1000, seed = 2021,
                 coefs = list(alpha = 0.7, nu = 2))
hist(y)

 #------------------------------------------------------------
 # Generating a Kumaraswamy model were mut does not vary with time
 # For linear link, alpha = mu
 #
 # Warning:
 #      |log(1-rho)| &gt;&gt; |log(1 - mu^nu)|
 # may cause numerical instability.
 #------------------------------------------------------------

 m1 &lt;- KARFIMA.sim(linkg = "linear",n = 100,
                   complete = TRUE, seed = 2021,
                   coefs = list(alpha = 0.7, nu = 2))

 #------------------------------------------------------------
 #  Extracting the conditional time series given yt and
 #  a set of parameters
 #------------------------------------------------------------

 # Assuming that all coefficients are non-fixed
 e1 = KARFIMA.extract(yt = m1$yt, coefs = list(alpha = 0.7, nu = 2),
                      link = "linear", llk = TRUE,
                      sco = TRUE, info = TRUE)

 #----------------------------------------------------
 # comparing the simulated and the extracted values
 #----------------------------------------------------
 cbind(head(m1$mut), head(e1$mut))

 #---------------------------------------------------------
 # the log-likelihood, score vector and information matrix
 #---------------------------------------------------------
 e1$sll
 e1$score
 e1$info.Matrix


# Generating a Kumaraswamy model were mut does not vary with time
# For linear link, alpha = mu
#
# Warning:
#      |log(1-rho)| &gt;&gt; |log(1 - mu^nu)|
# may cause numerical instability.

y &lt;- KARFIMA.sim(linkg = "logit", n = 100, seed = 2021,
               coefs = list(alpha = 0.7, nu = 2))

# fitting the model
f &lt;- KARFIMA.fit(yt = y, report = TRUE,
                 start = list(alpha = 0.5, nu = 1),
                 linkg = "logit", d = FALSE)

</code></pre>

<hr>
<h2 id='link.btsr'>Create a Link for BTSR models</h2><span id='topic+link.btsr'></span>

<h3>Description</h3>

<p>Given the name of a link, this function returns a link function,
an inverse link function, the derivative   <code class="reqn">d\eta / d\mu</code>
and the derivative <code class="reqn">d\mu / d\eta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link.btsr(link)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="link.btsr_+3A_link">link</code></td>
<td>
<p>character; one of  <code>"linear"</code>, <code>"logit"</code>,
<code>"log"</code>, <code>"loglog"</code>, <code>"cloglog"</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available links are:
</p>
<p>linear: <code class="reqn">f(x) = ax</code>, for <code class="reqn">a</code> real.  The parameter is set using the
argument <code>ctt.ll</code>, when invoking the functions created by <code>link.btsr</code>
</p>
<p>logit:  <code class="reqn">f(x) = log(x/(1-x))</code>
</p>
<p>log:    <code class="reqn">f(x) = log(x)</code>
</p>
<p>loglog: <code class="reqn">f(x) = log(-log(x))</code>
</p>
<p>cloglog: <code class="reqn">f(x) = log(-log(1-x))</code>
</p>


<h3>Value</h3>

<p>An object of class <code>"link-btsr"</code>, a list with components
</p>
<table role = "presentation">
<tr><td><code>linkfun</code></td>
<td>
<p>Link function <code>function(mu)</code></p>
</td></tr>
<tr><td><code>linkinv</code></td>
<td>
<p>Inverse link function <code>function(eta)</code></p>
</td></tr>
<tr><td><code>linkdif</code></td>
<td>
<p>Derivative <code>function(mu)</code> <code class="reqn">d\eta / d\mu</code></p>
</td></tr>
<tr><td><code>mu.eta</code></td>
<td>
<p>Derivative <code>function(eta)</code> <code class="reqn">d\mu / d\eta</code></p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>a name to be used for the link</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mylink &lt;- BTSR::link.btsr("linear")
y = 0.8
a = 3.4
gy = a*y

mylink$linkfun(mu = y, ctt.ll = a); gy
mylink$linkinv(eta = gy, ctt.ll = a); y
mylink$diflink(mu = y, ctt.ll = a); a
mylink$mu.eta(eta = gy, ctt.ll = a); 1/a


</code></pre>

<hr>
<h2 id='predict.btsr'>Predict method for BTSR</h2><span id='topic+predict.btsr'></span>

<h3>Description</h3>

<p>Predicted values based on btsr object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'btsr'
predict(object, newdata, nnew = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.btsr_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from <code>"btsr"</code></p>
</td></tr>
<tr><td><code id="predict.btsr_+3A_newdata">newdata</code></td>
<td>
<p>A matrix with new values for the regressors.   If omitted
and <code>"xreg"</code> is present in the model, the fitted values are returned.
If the model does not include regressors, the functions will use
the value of <code>nnew</code>.</p>
</td></tr>
<tr><td><code id="predict.btsr_+3A_nnew">nnew</code></td>
<td>
<p>number of out-of-sample forecasts required. If <code>newdata</code> is
provided, <code>nnew</code> is ignored.</p>
</td></tr>
<tr><td><code id="predict.btsr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.btsr</code> produces predicted values, obtained by evaluating
the regression function in the frame <code>newdata</code>.
</p>
<p>If <code>newdata</code> is omitted the predictions are based on the data
used for the fit.
</p>
<p>For now, prediction intervals are not provided.
</p>


<h3>Value</h3>

<p>A list with the following arguments
</p>
<table role = "presentation">
<tr><td><code>series</code></td>
<td>
<p>The original time series yt.</p>
</td></tr>
<tr><td><code>xreg</code></td>
<td>
<p>The original regressors (if any).</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The in-sample forecast given by <code class="reqn">\mu_t</code>.</p>
</td></tr>
<tr><td><code>etat</code></td>
<td>
<p>In-sample values of <code class="reqn">g(\mu[t])</code>.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>The error term (depends on the argument <code>error.scale</code>)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The (in-sample) residuals, that is, the observed minus the predicted values.
Same as error when <code>error.scale</code> = 0</p>
</td></tr>
<tr><td><code>forecast</code></td>
<td>
<p>The predicted values for yt.</p>
</td></tr>
<tr><td><code>TS</code></td>
<td>
<p>only for <code>"BARC"</code> models. The iterated map.</p>
</td></tr>
<tr><td><code>Ts.forecast</code></td>
<td>
<p>only for <code>"BARC"</code> models. The predicted values
of the iterated map.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> #------------------------------------------------------------
 # Generating a Beta model were mut does not vary with time
 # yt ~ Beta(a,b), a = mu*nu, b = (1-mu)*nu
 #------------------------------------------------------------

y &lt;- btsr.sim(model= "BARFIMA", linkg = "linear",
               n = 100, seed = 2021,
               coefs = list(alpha = 0.2, nu = 20))

# fitting the model
f &lt;- btsr.fit(model = "BARFIMA", yt = y, report = TRUE,
             start = list(alpha = 0.5, nu = 10),
             linkg = "linear", d = FALSE)

pred = predict(f, nnew = 5)
pred$forecast

</code></pre>

<hr>
<h2 id='print.btsr'>Print Method of class BTSR</h2><span id='topic+print.btsr'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>btsr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'btsr'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.btsr_+3A_x">x</code></td>
<td>
<p>object of class <code>btsr</code>.</p>
</td></tr>
<tr><td><code id="print.btsr_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.btsr_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.
They are ignored in this function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users are not encouraged to call these internal functions directly.
Internal functions for package BTSR.
</p>


<h3>Value</h3>

<p>Invisibly returns its argument, <code>x</code>.
</p>

<hr>
<h2 id='summary'>Summary Method of class BTSR</h2><span id='topic+summary'></span><span id='topic+summary.btsr'></span><span id='topic+print.summary.btsr'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"btsr"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'btsr'
summary(object, ...)

## S3 method for class 'summary.btsr'
print(x, digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>object of class <code>"btsr"</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.btsr"</code>,
usually, a result of a call to <code>summary.btsr</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_digits">digits</code></td>
<td>
<p>minimal number of significant digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>,
&lsquo;significance stars&rsquo; are printed for each coefficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.btsr</code> tries to be smart about formatting the
coefficients, standard errors, etc. and additionally provides
&lsquo;significance stars&rsquo;.
</p>


<h3>Value</h3>

<p>The function <code>summary.btsr</code> computes and returns a list
of summary statistics of the fitted model given in <code>object</code>.
Returns a list of class <code>summary.btsr</code>, which contains the
following components:
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>the corresponding model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals of the model. Depends on the definition
of <code>error.scale</code>. If error.scale= 1, <code class="reqn">residuals = g(y) - g(\mu)</code>.
If error.scale = 0, <code class="reqn">residuals = y - \mu</code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">k \times 4</code> matrix with columns for
the estimated coefficient, its standard error, z-statistic and corresponding
(two-sided) p-value. Aliased coefficients are omitted.</p>
</td></tr>
<tr><td><code>aliased</code></td>
<td>
<p>named logical vector showing if the original coefficients
are aliased.</p>
</td></tr>
<tr><td><code>sigma.res</code></td>
<td>
<p>the square root of the estimated variance of the random
error </p>
<p style="text-align: center;"><code class="reqn">\hat\sigma^2 = \frac{1}{n-k}\sum_i{r_i^2},</code>
</p>

<p>where <code class="reqn">r_i</code> is the <code class="reqn">i</code>-th residual, <code>residuals[i]</code>.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">(k, n-k, k*)</code>, the first
being the number of non-aliased coefficients, the last being the total
number of coefficients.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>a <code class="reqn">k \times k</code> matrix of (unscaled) covariances.
The inverse ov the information matrix.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the sum of the log-likelihood values</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the AIC value. <code class="reqn">AIC = -2*loglik+2*k</code>.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>the BIC value. <code class="reqn">BIC = -2*loglik + log(n)*k</code>.</p>
</td></tr>
<tr><td><code>hqc</code></td>
<td>
<p>the HQC value. <code class="reqn">HQC = -2*loglik + log(log(n))*k</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='UWARFIMA.functions'>Functions to simulate, extract components and fit UWARFIMA models</h2><span id='topic+UWARFIMA.functions'></span><span id='topic+UWARFIMA.sim'></span><span id='topic+UWARFIMA.extract'></span><span id='topic+UWARFIMA.fit'></span>

<h3>Description</h3>

<p>These functions can be used to simulate, extract components
and fit any model of the class <code>uwarfima</code>. A model with
class <code>uwarfima</code> is a special case of a model with class <code>btsr</code> .
See &lsquo;The BTSR structure&rsquo; in <code><a href="#topic+btsr.functions">btsr.functions</a></code> for
more details on the general structure.
</p>
<p>The UWARMA model, the Unit-Weibull regression and a i.i.d. sample
from a Unit-Weibull distribution can be obtained as special cases.
See &lsquo;Details&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UWARFIMA.sim(n = 1, burn = 0, xreg = NULL, rho = 0.5,
  coefs = list(alpha = 0, beta = NULL, phi = NULL, theta = NULL, d = 0, nu =
  20), y.start = NULL, xreg.start = NULL, xregar = TRUE,
  error.scale = 1, complete = FALSE, inf = 1000, linkg = c("logit",
  "logit"), seed = NULL, rngtype = 2, debug = FALSE)

UWARFIMA.extract(yt, xreg = NULL, nnew = 0, xnew = NULL, p, q,
  rho = 0.5, coefs = list(), lags = list(), fixed.values = list(),
  fixed.lags = list(), y.start = NULL, xreg.start = NULL,
  xregar = TRUE, error.scale = 1, inf = 1000, m = 0,
  linkg = c("logit", "logit"), llk = TRUE, sco = FALSE, info = FALSE,
  extra = FALSE, debug = FALSE)

UWARFIMA.fit(yt, xreg = NULL, nnew = 0, xnew = NULL, p = 0, d = TRUE,
  q = 0, m = 0, inf = 1000, rho = 0.5, start = list(),
  ignore.start = FALSE, lags = list(), fixed.values = list(),
  fixed.lags = list(), lower = list(nu = 0), upper = list(nu = Inf),
  linkg = c("logit", "logit"), sco = FALSE, info = FALSE,
  extra = FALSE, xregar = TRUE, y.start = NULL, xreg.start = NULL,
  error.scale = 1, control = list(), report = TRUE, debug = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UWARFIMA.functions_+3A_n">n</code></td>
<td>
<p>a strictly positive integer. The sample size of yt (after burn-in).
Default is 1.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_burn">burn</code></td>
<td>
<p>a non-negative integer. Length of the &quot;burn-in&quot; period. Default is 0.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_xreg">xreg</code></td>
<td>
<p>optionally, a vector or matrix of external regressors.
For simulation purposes, the length of xreg must be <code>n+burn</code>.
Default is <code>NULL</code>. For extraction or fitting purposes, the length
of <code>xreg</code> must be the same as the length of the observed time series
<code class="reqn">y_t</code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_rho">rho</code></td>
<td>
<p>a positive number, between 0 and 1, indicating the quantile
to be modeled. In this case, <code class="reqn">\mu_t</code> corresponds to the conditional
<code class="reqn">rho</code>-quantile of the distribution.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_coefs">coefs</code></td>
<td>
<p>a list with the coefficients of the model. An empty list will result
in an error. The arguments that can be passed through this list are:
</p>

<ul>
<li> <p><code>alpha</code> optionally, a numeric value corresponding to the intercept.
If the argument is missing, it will be treated as zero. See
&lsquo;The BTSR structure&rsquo; in <code><a href="#topic+btsr.functions">btsr.functions</a></code>.
</p>
</li>
<li> <p><code>beta</code> optionally, a vector of coefficients corresponding to the
regressors in <code>xreg</code>. If <code>xreg</code> is provided but <code>beta</code> is
missing in the <code>coefs</code> list, an error message is issued.
</p>
</li>
<li> <p><code>phi</code> optionally, for the simulation function this must be a vector
of size <code class="reqn">p</code>, corresponding to the autoregressive coefficients
(including the ones that are zero), where <code class="reqn">p</code> is the AR order. For
the extraction and fitting functions, this is a vector with the non-fixed
values in the vector of autoregressive coefficients.
</p>
</li>
<li> <p><code>theta</code> optionally, for the simulation function this must be a vector
of size <code class="reqn">q</code>, corresponding to the moving average coefficients
(including the ones that are zero), where <code class="reqn">q</code> is the MA order. For
the extraction and fitting functions, this is a vector with the non-fixed
values in the vector of moving average coefficients.
</p>
</li>
<li> <p><code>d</code> optionally, a numeric value corresponding to the long memory
parameter. If the argument is missing, it will be treated as zero.
</p>
</li>
<li> <p><code>nu</code> is a shape parameter. If missing, an error message is issued.
</p>
</li></ul>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_y.start">y.start</code></td>
<td>
<p>optionally, an initial value for yt (to be used
in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">g_2(y_t) = 0</code>, for <code class="reqn">t &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_xreg.start">xreg.start</code></td>
<td>
<p>optionally, a vector of initial value for xreg
(to be used in the recursions). Default is <code>NULL</code>, in which case, the recursion assumes
that <code class="reqn">X_t = 0</code>, for <code class="reqn">t &lt; 1</code>. If <code>xregar = FALSE</code> this argument
is ignored.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_xregar">xregar</code></td>
<td>
<p>logical; indicates if xreg is to be included in the
AR part of the model.  See &lsquo;The BTSR structure&rsquo;. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_error.scale">error.scale</code></td>
<td>
<p>the scale for the error term. See &lsquo;The BTSR structure&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code>. Default is 1.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_complete">complete</code></td>
<td>
<p>logical; if <code>FALSE</code> the function returns only the simulated
time series yt, otherwise, additional time series are provided (see below).
Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_inf">inf</code></td>
<td>
<p>the truncation point for infinite sums. Default is 1,000.
In practice, the Fortran subroutine uses <code class="reqn">inf = q</code>, if <code class="reqn">d = 0</code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_linkg">linkg</code></td>
<td>
<p>character or a two character vector indicating which
links must be used in the model.  See &lsquo;The BTSR structure&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code> for details and <code><a href="#topic+link.btsr">link.btsr</a></code>
for valid links. If only one value is provided, the same link is used
for <code class="reqn">mu_t</code> and for <code class="reqn">y_t</code> in the AR part of the model.
Default is <code>c("logit", "logit")</code>. For the linear link, the constant
will be always 1.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_seed">seed</code></td>
<td>
<p>optionally, an integer which gives the value of the fixed
seed to be used by the random number generator. If missing, a random integer
is chosen uniformly from 1,000 to 10,000.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_rngtype">rngtype</code></td>
<td>
<p>optionally, an integer indicating which random number generator
is to be used. Default is 2: the Mersenne Twister algorithm. See &lsquo;Common Arguments&rsquo;
in <code><a href="#topic+btsr.functions">btsr.functions</a></code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_debug">debug</code></td>
<td>
<p>logical, if <code>TRUE</code> the output from FORTRAN is return (for
debugging purposes).  Default is <code>FALSE</code> for all models.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_yt">yt</code></td>
<td>
<p>a numeric vector with the observed time series. If missing, an error
message is issued.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_nnew">nnew</code></td>
<td>
<p>optionally, the number of out-of sample predicted values required.
Default is 0.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_xnew">xnew</code></td>
<td>
<p>a vector or matrix, with <code>nnew</code> observations of the
regressors observed/predicted values corresponding to the period of
out-of-sample forecast. If <code>xreg = NULL</code>, <code>xnew</code> is ignored.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_p">p</code></td>
<td>
<p>a non-negative integer. The order of AR polynomial.
If missing, the value of <code>p</code> is calculated from length(coefs$phi)
and length(fixed.values$phi). For fitting, the default is 0.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_q">q</code></td>
<td>
<p>a non-negative integer. The order of the MA polynomial.
If missing, the value of <code>q</code> is calculated from length(coefs$theta)
and length(fixed.values$theta). For fitting, the default is 0.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_lags">lags</code></td>
<td>
<p>optionally, a list with the lags that the values in <code>coefs</code> correspond to.
The names of the entries in this list must match the ones in <code>coefs</code>.
For one dimensional coefficients, the <code>lag</code> is obviously always 1 and can
be suppressed. An empty list indicates that either the argument <code>fixed.lags</code>
is provided or all lags must be used.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_fixed.values">fixed.values</code></td>
<td>
<p>optionally, a list with the values of the coefficients
that are fixed. By default, if a given vector (such as the vector of AR coefficients)
has fixed values and the corresponding entry in this list is empty, the fixed values
are set as zero. The names of the entries in this list must match the ones
in <code>coefs</code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_fixed.lags">fixed.lags</code></td>
<td>
<p>optionally, a list with the lags that the fixed values
in <code>fixed.values</code> correspond to. The names of the entries in this list must
match the ones in <code>fixed.values</code>. ##' For one dimensional coefficients, the
<code>lag</code> is obviously always 1 and can be suppressed. If an empty list is provided
and the model has fixed lags, the argument <code>lags</code> is used as reference.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_m">m</code></td>
<td>
<p>a non-negative integer indicating the starting time for the sum of the
partial log-likelihoods, that is <code class="reqn">\ell = \sum_{t = m+1}^n \ell_t</code>. Default is
0.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_llk">llk</code></td>
<td>
<p>logical, if <code>TRUE</code> the value of the log-likelihood function
is returned. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_sco">sco</code></td>
<td>
<p>logical, if <code>TRUE</code> the score vector is returned.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_info">info</code></td>
<td>
<p>logical, if <code>TRUE</code> the information matrix is returned.
Default is <code>FALSE</code>. For the fitting function, <code>info</code> is automatically
set to <code>TRUE</code> when <code>report = TRUE</code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_extra">extra</code></td>
<td>
<p>logical, if <code>TRUE</code> the matrices and vectors used to
calculate the score vector and the information matrix are returned.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_d">d</code></td>
<td>
<p>logical, if <code>TRUE</code>, the parameter <code>d</code> is included
in the model either as fixed or non-fixed. If <code>d = FALSE</code> the value is
fixed as 0. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_start">start</code></td>
<td>
<p>a list with the starting values for the non-fixed coefficients
of the model. If an empty list is provided, the function <code><a href="#topic+coefs.start">coefs.start</a></code>
is used to obtain starting values for the parameters.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_ignore.start">ignore.start</code></td>
<td>
<p>logical,  if starting values are not provided, the
function uses the default values and <code>ignore.start</code> is ignored.
In case starting values are provided and <code>ignore.start = TRUE</code>, those
starting values are ignored and recalculated. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_lower">lower</code></td>
<td>
<p>optionally, list with the lower bounds for the
parameters. The names of the entries in these lists must match the ones
in <code>start</code>. The default is to assume that the parameters have no lower
bound except for <code>nu</code>, for which de default is 0. Only the bounds for
bounded parameters need to be specified.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_upper">upper</code></td>
<td>
<p>optionally, list with the upper bounds for the
parameters. The names of the entries in these lists must match the ones
in <code>start</code>. The default is to assume that the parameters have no upper
bound. Only the bounds for bounded parameters need to be specified.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_control">control</code></td>
<td>
<p>a list with configurations to be passed to the
optimization subroutines. Missing arguments will receive default values. See
<cite><a href="#topic+fit.control">fit.control</a></cite>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_report">report</code></td>
<td>
<p>logical, if <code>TRUE</code> the summary from model estimation is
printed and <code>info</code> is automatically set to <code>TRUE</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="UWARFIMA.functions_+3A_...">...</code></td>
<td>
<p>further arguments passed to the internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The UWARMA model and the Unit-Weibull regression can be
obtained as special cases of the UWARFIMA model.
</p>

<ul>
<li><p> UWARFIMA: is obtained by default.
</p>
</li>
<li><p> UWARMA: is obtained by setting <code>d = 0</code>.
</p>
</li>
<li><p> Unit-Weibull regression: is obtained by setting <code>p = 0</code>,
<code>q = 0</code> and <code>d = FALSE</code>. The <code>error.scale</code> is irrelevant.
The second argument in <code>linkg</code> is irrelevant.
</p>
</li>
<li><p> an i.i.d. sample from a Unit-Weibull distribution
is obtained by  setting <code>linkg = "linear"</code>, <code>p = 0</code>, <code>q = 0</code>,
<code>coefs$d = 0</code>, <code>d = FALSE</code>. (<code>error.scale</code> and
<code>xregar</code> are irrelevant)
</p>
</li></ul>

<p>The function <code>UWARFIMA.sim</code> generates a random sample from a UWARFIMA(p,d,q)
model.
</p>
<p>The function <code>UWARFIMA.extract</code> allows the user to extract the
components <code class="reqn">y_t</code>, <code class="reqn">\mu_t</code>,  <code class="reqn">\eta_t = g(\mu_t)</code>, <code class="reqn">r_t</code>,
the log-likelihood, and the vectors and matrices used to calculate the
score vector and the information matrix associated to a given set of parameters.
</p>
<p>This function can be used by any user to create an objective function
that can be passed to optimization algorithms not available in the BTSR Package.
</p>
<p>The function <code>UWARFIMA.fit</code> fits a UWARFIMA model to a given univariate time
series. For now, available optimization algorithms are <code>"L-BFGS-B"</code> and
<code>"Nelder-Mead"</code>. Both methods accept bounds for the parameters. For
<code>"Nelder-Mead"</code>, bounds are set via parameter transformation.
</p>


<h3>Value</h3>

<p>The function <code>UWARFIMA.sim</code> returns the simulated time series yt  by default.
If <code>complete = TRUE</code>, a list with the following components
is returned instead:
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"UWARFIMA"</code>
</p>
</li>
<li> <p><code>yt</code>: the simulated time series
</p>
</li>
<li> <p><code>mut</code>: the conditional mean
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g(\mu_t)</code>
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if included in the model).
</p>
</li>
<li> <p><code>debug</code>: the output from FORTRAN (if requested).
</p>
</li></ul>

<p>The function <code>UWARFIMA.extract</code> returns a list with the following components.
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"UWARFIMA"</code>
</p>
</li>
<li> <p><code>coefs</code>: the coefficients of the model passed through the
<code>coefs</code> argument
</p>
</li>
<li> <p><code>yt</code>: the observed time series
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g_2(y_t)</code>
</p>
</li>
<li> <p><code>mut</code>: the conditional mean
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g_1(\mu_t)</code>
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>xreg</code>: the regressors (if included in the model).
</p>
</li>
<li> <p><code>sll</code>: the sum of the conditional log-likelihood (if requested)
</p>
</li>
<li> <p><code>sco</code>: the score vector  (if requested)
</p>
</li>
<li> <p><code>info</code>: the information matrix  (if requested)
</p>
</li>
<li> <p><code>Drho</code>, <code>T</code>, <code>E</code>, <code>h</code>: additional matrices and vectors
used to calculate the score vector and the information matrix.  (if requested)
</p>
</li>
<li> <p><code>yt.new</code>: the out-of-sample forecast  (if requested)
</p>
</li>
<li> <p><code>out.Fortran</code>: FORTRAN output  (if requested)
</p>
</li></ul>

<p>The function <code>btsr.fit</code> returns a list with the following components.
Each particular model can have additional components in this list.
</p>

<ul>
<li> <p><code>model</code>: string with the text <code>"UWARFIMA"</code>
</p>
</li>
<li> <p><code>convergence</code>: An integer code. 0 indicates successful completion.
The error codes depend on the algorithm used.
</p>
</li>
<li> <p><code>message</code>: A character string giving any additional information
returned by the optimizer, or NULL.
</p>
</li>
<li> <p><code>counts</code>: an integer giving the number of function evaluations.
</p>
</li>
<li> <p><code>control</code>: a list of control parameters.
</p>
</li>
<li> <p><code>start</code>: the starting values used by the algorithm.
</p>
</li>
<li> <p><code>coefficients</code>: 	The best set of parameters found.
</p>
</li>
<li> <p><code>n</code>: the sample size used for estimation.
</p>
</li>
<li> <p><code>series</code>: the observed time series
</p>
</li>
<li> <p><code>gyt</code>: the transformed time series <code class="reqn">g_2(y_t)</code>
</p>
</li>
<li> <p><code>fitted.values</code>: the conditional mean, which corresponds to
the in-sample forecast, also denoted fitted values
</p>
</li>
<li> <p><code>etat</code>: the linear predictor <code class="reqn">g_1(\mu_t)</code>
</p>
</li>
<li> <p><code>error.scale</code>: the scale for the error term.
</p>
</li>
<li> <p><code>error</code>: the error term <code class="reqn">r_t</code>
</p>
</li>
<li> <p><code>residual</code>: the observed minus the fitted values. The same as
the <code>error</code> term if <code>error.scale = 0</code>.
</p>
</li>
<li> <p><code>forecast</code>: the out-of-sample forecast (if requested).
</p>
</li>
<li> <p><code>xnew</code>: the observations of the regressors observed/predicted
values corresponding to the period of out-of-sample forecast.
Only inlcudes if <code>xreg</code> is not <code>NULL</code> and <code>nnew &gt; 0</code>.
</p>
</li>
<li> <p><code>sll</code>: the sum of the conditional log-likelihood (if requested)
</p>
</li>
<li> <p><code>info.Matrix</code>: the information matrix  (if requested)
</p>
</li>
<li> <p><code>configs</code>: a list with the configurations adopted to fit the model.
This information is used by the prediction function.
</p>
</li>
<li> <p><code>out.Fortran</code>: FORTRAN output  (if requested)
</p>
</li>
<li> <p><code>call</code>: a string with the description of the fitted model.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+btsr.sim">btsr.sim</a></code>
</p>
<p><code><a href="#topic+btsr.extract">btsr.extract</a></code>
</p>
<p><code><a href="#topic+btsr.fit">btsr.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a Unit-Weibull  model were mut does not vary with time
# For linear link, alpha = mu

y &lt;- UWARFIMA.sim(linkg = "linear", n = 1000, seed = 2021,
                 coefs = list(alpha = 0.7, nu = 2))
hist(y)

 #------------------------------------------------------------
 # Generating a Unit-Weibull model were mut does not vary with time
 # For linear link, alpha = mu
 #------------------------------------------------------------

 m1 &lt;- UWARFIMA.sim(linkg = "linear",n = 100,
                   complete = TRUE, seed = 2021,
                   coefs = list(alpha = 0.7, nu = 2))

 #------------------------------------------------------------
 #  Extracting the conditional time series given yt and
 #  a set of parameters
 #------------------------------------------------------------

 # Assuming that all coefficients are non-fixed
 e1 = UWARFIMA.extract(yt = m1$yt, coefs = list(alpha = 0.7, nu = 2),
                      link = "linear", llk = TRUE,
                      sco = TRUE, info = TRUE)

 #----------------------------------------------------
 # comparing the simulated and the extracted values
 #----------------------------------------------------
 cbind(head(m1$mut), head(e1$mut))

 #---------------------------------------------------------
 # the log-likelihood, score vector and information matrix
 #---------------------------------------------------------
 e1$sll
 e1$score
 e1$info.Matrix


# Generating a Unit-Weibull model were mut does not vary with time
# For linear link, alpha = mu

y &lt;- UWARFIMA.sim(linkg = "logit", n = 100, seed = 2021,
               coefs = list(alpha = 0.7, nu = 2))

# fitting the model
f &lt;- UWARFIMA.fit(yt = y, report = TRUE,
                 start = list(alpha = 0.5, nu = 1),
                 linkg = "logit", d = FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
