<!DOCTYPE html><html><head><title>Help for package protViz</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {protViz}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AA'><p>AA - amino acid table</p></a></li>
<li><a href='#aa2mass'><p>determine the weight if a fiven amino acid sequence</p></a></li>
<li><a href='#ADPR'><p>ADP Ribosylated Peptide</p></a></li>
<li><a href='#as.psmSet'>
<p>psmSet - a set of peptide spectrum matches</p></a></li>
<li><a href='#assignPlatePosition'><p>Assign an instrument queue configuration to a plate</p></a></li>
<li><a href='#averagine'><p>averagine - a data set conatining isotope envelopes of averagine</p>
peptides</a></li>
<li><a href='#blockRandom'><p>Derive a randomization of a table.</p></a></li>
<li><a href='#centroid'>
<p>Centroid a spectrum acquired in profile mode</p></a></li>
<li><a href='#de_novo'><p>de-novo on tandem ms</p></a></li>
<li><a href='#deisotoper'><p>find isotop pattern in a given mass spectrum</p></a></li>
<li><a href='#Fasta'>
<p>FASTA format reader</p></a></li>
<li><a href='#fetuinLFQ'><p>fetuinLFQ - A  data set for evaluation of relative and absolute label-free quantification methods.</p></a></li>
<li><a href='#findNN'><p>find index of nearest neighbor</p></a></li>
<li><a href='#fragmentIon'><p>Compute the b and y Fragment Ions of a Peptide Sequence</p></a></li>
<li><a href='#genMod'><p>Generates all possible modification of a given peptide seqence and modification pattern</p></a></li>
<li><a href='#HexNAc'><p>HexNAc - Analysis of N-HexNAc glycopeptides by LC-MS/MS, using HCD and ETD</p>
fragmentation techniques</a></li>
<li><a href='#insertSamples'><p>Insert sample on a given position</p></a></li>
<li><a href='#iRTpeptides'><p>iRT peptides - independent retention time peptides</p></a></li>
<li><a href='#iTRAQ'><p>iTRAQ - A small 8-plex iTRAQ  data set with confident identified peptides from 5 proteins.</p></a></li>
<li><a href='#iTRAQ2GroupAnalysis'><p>iTRAQ two group analysis</p></a></li>
<li><a href='#lcmsmap'><p>LC-MS Map</p></a></li>
<li><a href='#mascot'>
<p>Generic methods for mascot results</p></a></li>
<li><a href='#massDeviationPlot'><p>Mass Deviation Plot</p></a></li>
<li><a href='#msms'><p>A data set containing tandem mass spectra of an LCMS experiment.</p></a></li>
<li><a href='#parentIonMass'><p>Compute Parent Ion Mass of a Peptide Sequence</p></a></li>
<li><a href='#peakplot'><p>Labelling of Peptide Fragment Mass Spectra</p></a></li>
<li><a href='#pgImporter'><p>Progenesis Importer Function</p></a></li>
<li><a href='#pgLFQaov'><p>iTRAQ two group analysis</p></a></li>
<li><a href='#pgLFQfeature'><p>pgLFQfeature - A data set with a featuremap export ProgenesisLCMS</p></a></li>
<li><a href='#pgLFQprot'><p>pgLFQprot - A data set with a featuremap export ProgenesisLCMS</p></a></li>
<li><a href='#pgLFQtNpq'><p>Label Free Quantification using the top N peptide approach</p></a></li>
<li><a href='#pressureProfile'><p>NanoLC pressure profile</p></a></li>
<li><a href='#pressureProfilePlot'><p>Plotting pressure profile data from Eksigent LC pumps</p></a></li>
<li><a href='#pressureProfileSummary'><p>A misc function for finding NN time slots in pressure profile data.</p></a></li>
<li><a href='#psm'><p>Compute a matching between a peptide sequence and a MS2 spectrum</p></a></li>
<li><a href='#PTM_MarkerFinder'><p>PTM MarkerFinder</p></a></li>
<li><a href='#PTM_MarkerFinder_util'><p>PTM MarkerFinder util plot</p></a></li>
<li><a href='#ssrc'><p>Sequence Specific Retention Calculator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Visualizing and Analyzing Mass Spectrometry Related Data in
Proteomics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.9</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0)</td>
</tr>
<tr>
<td>RcppModules:</td>
<td>FastaMod</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice, testthat, xtable</td>
</tr>
<tr>
<td>Description:</td>
<td>Helps with quality checks, visualizations 
    and analysis of mass spectrometry data, coming from proteomics 
    experiments. The package is developed, tested and used at the Functional 
    Genomics Center Zurich <a href="https://fgcz.ch">https://fgcz.ch</a>. We use this package
    mainly for prototyping, teaching, and having fun with proteomics data.
    But it can also be used to do data analysis for small scale data sets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cpanse/protViz/">https://github.com/cpanse/protViz/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cpanse/protViz/issues">https://github.com/cpanse/protViz/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>aa2mass.R centroid.R comet.R deisotoper.R de_novo.R findNN.R
fragmentIon.R genMod.R iTRAQ2GroupAnalysis.R lcmsmap.R mascot.R
mdp.R parentIonMass.R peakplot.R pepxml.R pgImporter.R pgLFQ.R
pp.R psm.R queue.R PTM_MarkerFinder.R ssrc.R zzz.R
RcppExports.R protViz-package.R</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 16:44:28 UTC; cp</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Panse <a href="https://orcid.org/0000-0003-1975-3064"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jonas Grossmann <a href="https://orcid.org/0000-0002-6899-9020"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Simon Barkow-Oesterreicher [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Panse &lt;cp@fgcz.ethz.ch&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 18:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='AA'>AA - amino acid table</h2><span id='topic+AA'></span>

<h3>Description</h3>

<p>Among other attributes it contains '1-letter code', 'monoisotopic mass' and 
'average mass' of each amino acids.
</p>


<h3>Format</h3>

<p>contains a table</p>


<h3>Value</h3>

<p>returns a <code>data.frame</code></p>


<h3>Author(s)</h3>

<p>Christian Panse 2013
</p>


<h3>See Also</h3>


<ul>
<li><p><a href="https://www.matrixscience.com/help/aa_help.html">https://www.matrixscience.com/help/aa_help.html</a>
</p>
</li>
<li><p><a href="https://education.expasy.org/student_projects/isotopident/htdocs/aa-list.html">https://education.expasy.org/student_projects/isotopident/htdocs/aa-list.html</a>
</p>
</li>
<li><p><a href="https://www.unimod.org">https://www.unimod.org</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
    data(AA)
    AA
    AA.lm&lt;-lm(AA$Monoisotopic ~ AA$Average)

    plot(AA$Monoisotopic, AA$Average); 
    abline(AA.lm, col='grey')
    text(AA$Monoisotopic, AA$Average, AA$letter1, pos=3)

    plot(AA$Average-AA$Monoisotopic)  
    axis(3,1:20,AA$letter1); 
    abline(v=1:20,col='grey')

	
	
    # computes monoisotopic mass out of formula using the CDK package
    ## Not run: 
    	if (require(rcdk)){
	plot(AA$Monoisotopic, 
	     sapply(AA$formula, function(x){
		     get.formula(as.character(x), charge = 1)@mass
	     }))
	}
    
## End(Not run)
    ## Not run: 
	    if (require(XML)){
	unimodurl &lt;- url("http://www.unimod.org/xml/unimod_tables.xml")
	unimod.list &lt;- XML::xmlToList(
	  XML::xmlParse(
	    scan(unimodurl, what = character())))
	unimod.AA &lt;- data.frame(
	  do.call('rbind', unimod.list$amino_acids))
	rownames(unimod.AA) &lt;- unimod.AA$one_letter
	    }
    
## End(Not run)
</code></pre>

<hr>
<h2 id='aa2mass'>determine the weight if a fiven amino acid sequence</h2><span id='topic+aa2mass'></span>

<h3>Description</h3>

<p>The function determines the weight of each amino acid fiven sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    aa2mass(peptideSequence, mass=AA$Monoisotopic, letter1=AA$letter1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aa2mass_+3A_peptidesequence">peptideSequence</code></td>
<td>
<p>a double vector which can be considered as query objects.</p>
</td></tr>
<tr><td><code id="aa2mass_+3A_mass">mass</code></td>
<td>
<p>A vector of size 20 containing the weight of the AA.</p>
</td></tr>
<tr><td><code id="aa2mass_+3A_letter1">letter1</code></td>
<td>
<p>AA letter 1 code in the same size and order as the <code>mass</code> attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the computation no C-Term and N-Term is considered.
<code>aa2mass</code> is useful if you have AA modifications.
</p>


<h3>Author(s)</h3>

<p>Christian Panse 2014
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    peptides&lt;-c('HTLNQIDSVK', 'ALGGEDVR', 'TPIVGQPSIPGGPVR')

    C_term &lt;- 17.002740
    N_term &lt;- 1.007825
    H_ &lt;- 1.008

    unlist(lapply(aa2mass(peptides), sum)) + C_term + N_term + H_ - parentIonMass(peptides)

    # determine the fragment ions
    lapply(aa2mass(peptides), function(x){fragmentIon(x)[[1]]})

    # an example with [STY] AA modification

    peptide&lt;-'HTLNQIDSVK'
    mod &lt;- rep(0.0, nchar(peptide)); mod[8] &lt;- 79.998;
    
    aa2mass(peptide)[[1]] + mod

</code></pre>

<hr>
<h2 id='ADPR'>ADP Ribosylated Peptide</h2><span id='topic+ADPR'></span><span id='topic+ADPR.lim'></span><span id='topic+ADPR.ms2'></span><span id='topic+ADPR.annotation'></span>

<h3>Description</h3>

<p>Data for reproducing Figures 1-5 in <a href="https://doi.org/10.1021/jasms.0c00040">doi:10.1021/jasms.0c00040</a>.
</p>


<h3>Author(s)</h3>

<p>Christian Panse 2022
</p>

<hr>
<h2 id='as.psmSet'>
psmSet - a set of peptide spectrum matches
</h2><span id='topic+as.psmSet'></span><span id='topic+is.psmSet'></span><span id='topic+as.psmSet.mascot'></span><span id='topic+as.psmSet'></span>

<h3>Description</h3>

<p>defines a class of peptide spectrum matches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
is.psmSet(object)


 ## S3 method for class 'mascot'
as.psmSet(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.psmSet_+3A_object">object</code></td>
<td>

<p>an <code>psmSet</code> S3 class object
</p>
</td></tr>
<tr><td><code id="as.psmSet_+3A_...">...</code></td>
<td>
<p>whatoever</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the <code>is.psmSet</code> method checks if the as input given objects fullfills the 
proterties to be an <code>psmSet</code> object.
</p>
<p><code>as.psmSet</code> transformas an object into a <code>psmSet</code> object.
</p>


<h3>Value</h3>

<p>while <code>is.psmSet</code> returns <code>TRUE</code> or <code>FALSE</code>, 
<code>as.psmSet</code> returns an instance of <code>psmSet</code> or <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Christian Panse 2017
</p>

<hr>
<h2 id='assignPlatePosition'>Assign an instrument queue configuration to a plate</h2><span id='topic+assignPlatePosition'></span>

<h3>Description</h3>

<p>The function implements a space-filling curve mapping 1D to 2D.
This function aims to assign a sequence of samples to an instrument plate,
e.g., 48 well plate 85.4x127.5mm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignPlatePosition(
  S,
  x = as.character(1:8),
  y = c("A", "B", "C", "D", "E", "F"),
  plate = 1:4,
  volume = 1,
  reserve = 46:48
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignPlatePosition_+3A_s">S</code></td>
<td>
<p>input data frame</p>
</td></tr>
<tr><td><code id="assignPlatePosition_+3A_x">x</code></td>
<td>
<p>a vector of possible x-coordinates of the plate</p>
</td></tr>
<tr><td><code id="assignPlatePosition_+3A_y">y</code></td>
<td>
<p>a vector of possible y-coordinates of the plate</p>
</td></tr>
<tr><td><code id="assignPlatePosition_+3A_plate">plate</code></td>
<td>
<p>a vector of plates</p>
</td></tr>
<tr><td><code id="assignPlatePosition_+3A_volume">volume</code></td>
<td>
<p>injection volume</p>
</td></tr>
<tr><td><code id="assignPlatePosition_+3A_reserve">reserve</code></td>
<td>
<p>block plate positions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris[c(1:15, 51:65, 101:115), ] |&gt;
  blockRandom(x = "Species", check=FALSE) |&gt;
  assignPlatePosition()
</code></pre>

<hr>
<h2 id='averagine'>averagine - a data set conatining isotope envelopes of averagine
peptides</h2><span id='topic+averagine'></span>

<h3>Description</h3>

<p>generated using proteowizards <code>IsotopeEnvelopeEstimator</code> class.
</p>


<h3>Format</h3>

<p>first column mass, column 1:8 l2 normalized isotope intensities</p>


<h3>Author(s)</h3>

<p>Witold Wolski and Christian Panse 2013
</p>


<h3>References</h3>

<p>A general approach to calculating isotopic distributions for mass spectrometry James A. Yergey Volume 52, Issues 2 1 
September 1983, Pages 3379
</p>
<p><a href="https://doi.org/10.1016/0020-7381%2883%2985053-0">doi:10.1016/0020-7381(83)85053-0</a>
<a href="https://proteowizard.sourceforge.io/">https://proteowizard.sourceforge.io/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(averagine)
r&lt;-seq(0,1,length=200); cm&lt;-c(rgb(r,r,r), '#555599')
image(m&lt;-as.matrix(averagine), col=rev(cm), axes=FALSE, main='protViz
averagine data - normalized isotope intensities ',
sub='the blue color indicates fields with value 0.',
xlab='isotops',
ylab='mass');
box()
axis(1, seq(0,1,length=nrow(m)), 1:nrow(m));
axis(2, seq(0,1,length=10), colnames(m)[seq(1,ncol(m), length=10)])

</code></pre>

<hr>
<h2 id='blockRandom'>Derive a randomization of a table.</h2><span id='topic+blockRandom'></span>

<h3>Description</h3>

<p>Derive a randomization of a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockRandom(S, x = NA, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockRandom_+3A_s">S</code></td>
<td>
<p>a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="blockRandom_+3A_x">x</code></td>
<td>
<p>the column name of the group used for the block randomization.</p>
</td></tr>
<tr><td><code id="blockRandom_+3A_check">check</code></td>
<td>
<p>check if the size of each group is equal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a randomization order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
iris[c(1:2, 51:52, 101:103), ] |&gt;
  blockRandom(x = "Species", check=FALSE)
</code></pre>

<hr>
<h2 id='centroid'>
Centroid a spectrum acquired in profile mode
</h2><span id='topic+centroid'></span><span id='topic+profile'></span>

<h3>Description</h3>

<p>returns a centroid spectrum of a recorded profile mode spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid(mZ, intensity, tolppm=100, debug=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroid_+3A_mz">mZ</code></td>
<td>
<p>Numerical vector of profile recorded data and sorted mZ values.</p>
</td></tr>
<tr><td><code id="centroid_+3A_intensity">intensity</code></td>
<td>
<p>corresponding intensity values.</p>
</td></tr>
<tr><td><code id="centroid_+3A_tolppm">tolppm</code></td>
<td>
<p>maximal distance in Da between to profile mZ values. default is set to 100ppm.</p>
</td></tr>
<tr><td><code id="centroid_+3A_debug">debug</code></td>
<td>
<p>if true all peak profiles are plotted. default is false.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the method is tested on an Orbitrap Fusion Lumos FSN20242 data set.
</p>


<h3>Value</h3>

<p>returns a <code>data.frame</code> with a mZ and a intensity column.
</p>


<h3>Note</h3>

<p>thanks to Nienke Meekel and Andrea Brunner (kwrwater.nl) and Witold E. Wolski.
</p>


<h3>Author(s)</h3>

<p>Christian Panse and Jonas Grossmann, April 2020
</p>


<h3>See Also</h3>


<ul>
<li><p><a href="https://github.com/lgatto/MSnbase/blob/2b6d6f5162e7464c39b48d0daa4d981c6ec30bbd/R/functions-Spectrum.R#L649">MSnbase functions-Spectrum.R</a>
</p>
</li>
<li><p><a href="https://proteowizard.sourceforge.io/">https://proteowizard.sourceforge.io/</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>   # Orbitrap Fusion Lumos FSN20242 
   # p2722/.../.../stds_pos_neg_MS_highconc_UVPD_50_300.raw
   # scan 1959
   # CC(C)(C)C(O)C(OC1=CC=C(Cl)C=C1)N1C=NC=N1	1
   # exact.mass 295.1088
   # FTMS + p ESI d Full ms2 296.1162@uvpd50.00 

    p &lt;- protViz:::.getProfileMS2()
    
    # determine eps
    plot((diff(p$mZ)) ~ p$mZ[2:length(p$mZ)], log='y');
    abline(h=0.1, col='red')
    points(p$mZ , 1E-4 * p$mZ, col='grey', type='l')
    abline(v=296.1162, col='cyan')

    op &lt;- par(mfrow=c(2, 1))
    plot(p$mZ, p$intensity, type='h',
      main='profile', xlim=c(100,300))
    abline(v=296.1162, col='cyan')
    
    plot(centroid(p$mZ, p$intensity),type='h',
      main="centroid",xlim=c(100,300))
    par(op)
    
    
    op &lt;- par(mfrow=c(2, 1), ask = TRUE)
        rv &lt;- centroid(p$mZ, p$intensity, debug = TRUE)

</code></pre>

<hr>
<h2 id='de_novo'>de-novo on tandem ms</h2><span id='topic+de_novo'></span>

<h3>Description</h3>

<p>This function computes the mass differences of MS2 peaks and matches the        'delta masses' to the amino acid weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    de_novo(data)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="de_novo_+3A_data">data</code></td>
<td>
<p>ms data set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should only be used for demonstration!
</p>


<h3>Author(s)</h3>

<p>Christian Panse 2013
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(msms)
    de_novo(msms[[1]])
</code></pre>

<hr>
<h2 id='deisotoper'>find isotop pattern in a given mass spectrum</h2><span id='topic+deisotoper'></span>

<h3>Description</h3>

<p><code>deisotoper</code> returns the indices and scores of the isotop pattern.
The score is computed by considering the isotop L2 norm of a given iostop
model. <code>protViz</code> contains the <code>averagine</code> data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    deisotoper(data, Z=1:4, isotopPatternDF=averagine, massError=0.005, plot=FALSE)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deisotoper_+3A_data">data</code></td>
<td>
<p>A mass spectrometric measurement containing a list.</p>
</td></tr>
<tr><td><code id="deisotoper_+3A_z">Z</code></td>
<td>
<p>Charge states to be considered. The default is <code>Z=1:4</code></p>
</td></tr>
<tr><td><code id="deisotoper_+3A_isotoppatterndf">isotopPatternDF</code></td>
<td>
<p> a data frame containing isotope envelopes of peptide averagine.</p>
</td></tr>
<tr><td><code id="deisotoper_+3A_masserror">massError</code></td>
<td>
<p> mass error in Dalton. default is 0.005.</p>
</td></tr>
<tr><td><code id="deisotoper_+3A_plot">plot</code></td>
<td>
<p>boolean if the isotops should be plotted. The default is false.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of the <code>deisotoper</code> function is a <code>list</code> data structure containing 
for each input MS data set a <code>result</code>, <code>score</code>, and <code>group</code> lists.
</p>
<p><code>result</code> is a list which contains for each charge state a list of isotop groups.
Analoge to <code>result</code> a score is provide in the <code>score</code> list.
</p>
<p><code>group</code> provides information about the charge states of each isotop cluster.
</p>
<p>The algorithm for finding the isotop chains as implemented in protViz is based on the idea of 
'Features-Based Deisotoping Method for Tandem Mass Spectra'.
Each peak represents one node of a graph <code>G=(V,E)</code> with <code>V = {1, ..., n}</code>.
The edges are defined by <code>(v, node_array_G[v])</code> iff <code>node_array_G[v] &gt; -1</code>.
In other words an edge is defined between two peaks if the mZ difference is below the given 
massError. The isotop chains are determined by a DFS run.
The time complexity is <code>O(n log (n))</code> where n is the number of peaks.
</p>


<h3>Author(s)</h3>

<p>Witold Eryk Wolski, Christian Trachsel, and Christian Panse 2013 
</p>


<h3>References</h3>

<p>isotopic-cluster graphs:
</p>
<p>Features-Based Deisotoping Method for Tandem Mass Spectra,
Zheng Yuan Jinhong Shi Wenjun Lin Bolin Chen and Fang-Xiang Wu
Advances in Bioinformatics
Volume 2011 (2011), Article ID 210805, 12 pages
<a href="https://doi.org/10.1155/2011/210805">doi:10.1155/2011/210805</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # example1 - tandem ms
    x &lt;- list(mZ = c(726.068, 726.337, 726.589, 726.842, 727.343, 727.846, 728.346, 
        728.846, 729.348, 730.248, 730.336, 730.581, 730.836),
        intensity = c(6.77850e+03, 2.81688e+04, 6.66884e+04, 1.22032e+07, 
            9.90405e+06, 4.61409e+06, 1.50973e+06, 3.33996e+05, 5.09421e+04, 
            1.15869e+03, 2.14788e+03, 5.37853e+03, 5.79094e+02))

    # the plain C interface function
    out1 &lt;- .Call("deisotoper_main", x$mZ, x$intensity, Z=1:4, averagine, 
        massError=0.01, PACKAGE="protViz")

    out&lt;-deisotoper(data=list(x), Z=2:4, isotopPatternDF=averagine)

    # example2 - a ms from heavy labeld peptide in water background    
    x &lt;- list(mZ=c(642.572, 643.054, 643.569, 644.062, 644.557),
        intensity=c(17000, 25000, 12000, 9000,4000))

    diff(x$mZ)
    diff(x$mZ,lag=2)
    diff(x$mZ, difference=2)

    out2&lt;-deisotoper(data=list(x), Z=1:2, isotopPatternDF=averagine, 
        massError=0.02, plot=TRUE)

</code></pre>

<hr>
<h2 id='Fasta'>
FASTA format reader
</h2><span id='topic+FASTA'></span><span id='topic+Fasta'></span><span id='topic+fasta'></span>

<h3>Description</h3>

<p>Implements as Rcpp module performing tryptic digests and summaries.
The support is limited for protein sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fasta
</code></pre>


<h3>Value</h3>

<p>returns a <code>list</code> or <code>vector</code>  objects.
</p>


<h3>Author(s)</h3>

<p>Christian Panse &lt;cp@fgcz.ethz.ch&gt; 2006-2017
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/FASTA_format">https://en.wikipedia.org/wiki/FASTA_format</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># &gt;sp|P12763|FETUA_BOVIN Alpha-2-HS-glycoprotein OS=Bos taurus
  fname &lt;- system.file("extdata", name='P12763.fasta', package = "protViz")
  F &lt;- Fasta$new(fname)
  F
  F$summary()
  F$getTrypticPeptides()
  
  plot(parentIonMass(F$getTrypticPeptides()), ssrc(F$getTrypticPeptides()),
    log='xy')
  text(parentIonMass(F$getTrypticPeptides()), ssrc(F$getTrypticPeptides()), 
    F$getTrypticPeptides(), pos=3, cex=0.5)

</code></pre>

<hr>
<h2 id='fetuinLFQ'>fetuinLFQ - A  data set for evaluation of relative and absolute label-free quantification methods.</h2><span id='topic+fetuinLFQ'></span><span id='topic+apex'></span><span id='topic+empai'></span><span id='topic+t3pq'></span>

<h3>Description</h3>

<p>This data set contains the read-out abundance
for three different methods (APEX, emPAI, T3PQ) for seven proteins from
a complex yeast background (abundance levels unchanged) and the
Fetuin that was spiked into the extracts in
concentrations ranging from 20fmol to 300fmol on column (in triplicates).
</p>
<p>Samples were analyzed on a LTQ-FTICR Ultra mass spectrometer (Thermo
Fischer Scientific, Bremen, Germany) coupled to an
Eksigent-Nano-HPLC system (Eksigent Technologies, Dublin (CA), USA).
</p>
<p>The data can be derived out of the mzXML files:
</p>
<p>1       186240760       2008-12-11      20080816_01_fetuin.mzXML
</p>
<p>2       179013841       2008-12-11      20080816_02_fetuin_0.mzXML
</p>
<p>3       178692924       2008-12-11      20080816_03_fetuin_0.mzXML
</p>
<p>4       178608302       2008-12-11      20080816_04_fetuin_0.mzXML
</p>
<p>5       180995463       2008-12-11      20080816_05_fetuin_20.mzXML
</p>
<p>6       175934898       2008-12-11      20080816_06_fetuin_20.mzXML
</p>
<p>7       178364454       2008-12-11      20080816_07_fetuin_20.mzXML
</p>
<p>8       184376874       2008-12-11      20080816_08_fetuin_40.mzXML
</p>
<p>9       187205031       2008-12-11      20080816_09_fetuin_40.mzXML
</p>
<p>10      185646382       2008-12-11      20080816_10_fetuin_40.mzXML
</p>
<p>11      183498944       2008-12-11      20080816_11_fetuin_60.mzXML
</p>
<p>12      184752098       2008-12-11      20080816_12_fetuin_60.mzXML
</p>
<p>13      186243524       2008-12-11      20080816_13_fetuin_60.mzXML
</p>
<p>14      187794055       2008-12-11      20080816_14_fetuin_80.mzXML
</p>
<p>15      183463368       2008-12-11      20080816_15_fetuin_80.mzXML
</p>
<p>16      186331090       2008-12-11      20080816_16_fetuin_80.mzXML
</p>
<p>17      188027950       2008-12-11      20080816_17_fetuin_100.mzXML
</p>
<p>18      186881098       2008-12-11      20080816_18_fetuin_100.mzXML
</p>
<p>19      187219923       2008-12-11      20080816_19_fetuin_100.mzXML
</p>
<p>20      187157009       2008-12-11      20080816_20_fetuin_120.mzXML
</p>
<p>21      190008885       2008-12-11      20080816_21_fetuin_120.mzXML
</p>
<p>22      184226648       2008-12-11      20080816_22_fetuin_120.mzXML
</p>
<p>23      190681343       2008-12-11      20080816_23_fetuin_160.mzXML
</p>
<p>24      194653066       2008-12-11      20080816_24_fetuin_160.mzXML
</p>
<p>25      191045349       2008-12-11      20080816_25_fetuin_160.mzXML
</p>
<p>26      184869491       2008-12-11      20080816_26_fetuin_200.mzXML
</p>
<p>27      185490782       2008-12-11      20080816_27_fetuin_200.mzXML
</p>
<p>28      185635558       2008-12-11      20080816_28_fetuin_200.mzXML
</p>
<p>29      187743192       2008-12-11      20080816_29_fetuin_300.mzXML
</p>
<p>30      190613235       2008-12-11      20080816_30_fetuin_300.mzXML
</p>
<p>31      189570723       2008-12-11      20080816_31_fetuin_300.mzXML
</p>
<p>32      226404551       2008-12-11      20080819_32_fetuin.mzXML
</p>
<p>contained in a 3GBytes compressed tar ball
<a href="http://fgcz-data.uzh.ch/public/fqms.tgz">http://fgcz-data.uzh.ch/public/fqms.tgz</a> md5=af804e209844d055c0eded716ef9eea8.
</p>
<p>The t3pq data can be derived using the code from <a href="https://sourceforge.net/projects/fqms/">https://sourceforge.net/projects/fqms/</a>
</p>


<h3>Format</h3>

<p>A data set with approx. 600 rows and four variables, 4KBytes file size, derived out of 32 single LC-MS runs, 5GBytes size, of a protein mixture.</p>


<h3>Author(s)</h3>

<p>Christian Panse 2009, 2010
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1016/j.jprot.2010.05.011">doi:10.1016/j.jprot.2010.05.011</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lattice)
data(fetuinLFQ)

cv&lt;-1-1:7/10
t&lt;-trellis.par.get("strip.background")
t$col&lt;-(rgb(cv,cv,cv))
trellis.par.set("strip.background",t)

my.xlab="Fetuin concentration spiked into experiment [fmol]"
my.ylab&lt;-"Abundance"

xyplot(abundance~conc|prot*method, 
    data=fetuinLFQ$apex, 
    groups=prot,
    aspect=1,
    panel = function(x, y, subscripts, groups) {
        if (groups[subscripts][1] == "Fetuin")  {
            panel.fill(col="#ffcccc")
        }
                panel.grid(h=-1,v=-1)
                panel.xyplot(x, y)
                panel.loess(x,y, span=1)
            },
    xlab=my.xlab,
    ylab=my.ylab
)


xyplot(abundance~conc|prot*method,
    data=fetuinLFQ$empai,
    groups=prot,
    aspect=1,
    panel = function(x, y, subscripts, groups) {
        if (groups[subscripts][1] == "Fetuin")  {
            panel.fill(col="#ffcccc")
        }
                panel.grid(h=-1,v=-1)
                panel.xyplot(x, y)
                panel.loess(x,y, span=1)
            },
    xlab=my.xlab,
    ylab=my.ylab
)


xyplot(abundance~conc|prot*method,
    data=fetuinLFQ$t3pq,
    groups=prot,
    aspect=1,
    panel = function(x, y, subscripts, groups) {
        if (groups[subscripts][1] == "Fetuin")  {
            panel.fill(col="#ffcccc")
        }
                panel.grid(h=-1,v=-1)
                panel.xyplot(x, y)
                panel.loess(x,y, span=1)
        if (groups[subscripts][1] == "Fetuin")  {
            panel.text(min(fetuinLFQ$t3pq$conc),
                max(fetuinLFQ$t3pq$abundance),
                paste("R-squared:", 
                round(summary(lm(x~y))$r.squared,2)),
                cex=0.75,
                pos=4)
        }
            },
    xlab=my.xlab,
    ylab=my.ylab
)


</code></pre>

<hr>
<h2 id='findNN'>find index of nearest neighbor</h2><span id='topic+NN'></span><span id='topic+findNN'></span><span id='topic+findNN_'></span><span id='topic+lower_bound_'></span>

<h3>Description</h3>

<p>Given a vector of sorted double values <code>vec</code> of size
<code>n</code> and a vector of <code>m</code> query objects <code>q</code>. 
</p>
<p><code>findNN</code> determines for each element <code>q[i]</code> in <code>q</code> 
the nearest neighbor index <code>o</code> so that the following remains true:
</p>
<p>there is no element <code>k</code> with <code>1</code> <code class="reqn">\le</code> <code>k</code> 
<code class="reqn">\le</code> <code>n</code> and <code>k</code> is not <code>o</code> so that 
</p>
<p><code>abs(vec[k] - q[i])</code> &lt; <code>abs(vec[o] - q[i])</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    findNN(q, vec, check) 
    findNN_(q, vec, check) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findNN_+3A_q">q</code></td>
<td>
<p>a double vector which can be considered as query objects.</p>
</td></tr>
<tr><td><code id="findNN_+3A_vec">vec</code></td>
<td>
<p>a sorted double vector which can be considered as a data base.</p>
</td></tr>
<tr><td><code id="findNN_+3A_check">check</code></td>
<td>
<p>boolean enables test if <code>vec</code> is sorted. default is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The internal algorithm of <code>findNN</code> is implemented as binary search.
<code>findNN</code> has <code class="reqn">O(m * log_2(n))</code> time complexity where n is defined as 
<code>length(vec)</code> and m is <code>length(m)</code>. 
</p>
<p><code>findNN</code> is implemented using C library function - bsearch(),
while <code>findNN_</code> uses C++11 STL function lower_bound().
</p>


<h3>Author(s)</h3>

<p>Christian Panse 2007, 2008, 2009, 2010, 2012 , 2015
based on the C++ STL lower_bound method.
</p>


<h3>References</h3>


<ul>
<li><p><a href="https://cplusplus.com/reference/algorithm/lower_bound/">https://cplusplus.com/reference/algorithm/lower_bound/</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+findInterval">findInterval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    (NNidx &lt;- findNN(q &lt;- c(1, 1.0001, 1.24, 1.26), DB &lt;- seq(1, 5 , by = 0.25)))
    (NNidx == c(1, 1, 2, 2))

    DB &lt;- sort(rnorm(100, mean=100, sd = 10))

    # should be 0
    unique(DB[findNN(DB,DB)] - DB)

    q &lt;- rnorm(100, mean=100)

    idx.NN &lt;- findNN(q,DB)
    hist(DB[findNN(q,DB)] - q)

    # definition of findNN holds
    i &lt;- 1:5
    findNN(3.5, i)

    i &lt;- 1:6
    findNN(3.5, i)
    
     # compare ANSI-C binary search with C++ std::lower_bound
    DB &lt;- c(rep(1.0, 3), rep(2.0, 3))
    q &lt;- c(-1, 1.0, 1.01, 1.5, 1.9)
    abs(DB[findNN(q, DB)] - q)
    abs(DB[findNN_(q, DB)] - q)


    DB &lt;- sort(rnorm(100, mean=100, sd=10))
    # should be 0
    unique(DB[findNN_(DB,DB)] - DB)

    q &lt;- rnorm(100, mean=100)

    idx.NN &lt;- findNN_(q, DB)
    hist(DB[findNN_(q, DB)] - q)

    # definition of findNN_ holds
    i &lt;- 1:5
    findNN_(3.5, i)

    i &lt;- 1:6
    findNN_(3.5, i)
</code></pre>

<hr>
<h2 id='fragmentIon'>Compute the b and y Fragment Ions of a Peptide Sequence</h2><span id='topic+fragmentIon'></span><span id='topic+as.data.frame.fragmentIonSet'></span><span id='topic+bymatrix'></span><span id='topic+ionseries'></span><span id='topic+defaultIon'></span>

<h3>Description</h3>

<p>The function computes the fragment ions of a peptide sequence,
according to the rules of fragmentation in a collision cell.
It can be either CID fragmentation (collision-induced dissociation)
or ETD (electron transfer dissociation) which are common in proteomics
experiments. All are in a positive mode.
</p>
<p>If multiple peptide sequences are given it returns a list of fragment ion table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    fragmentIon(sequence, FUN, modified, modification, N_term, C_term)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fragmentIon_+3A_sequence">sequence</code></td>
<td>
<p>peptide sequence encoded as character sequence using the 20 amino acid letters or a double vector of amino acid weights.</p>
</td></tr>
<tr><td><code id="fragmentIon_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to compute further ions. 
If no function is assigned <code>fragmentIon</code> will use <code>defaultIon</code>.</p>
</td></tr>
<tr><td><code id="fragmentIon_+3A_modified">modified</code></td>
<td>
<p>a vector of interger containing the varmod id of the peptide position.</p>
</td></tr>
<tr><td><code id="fragmentIon_+3A_modification">modification</code></td>
<td>
<p>a double vector of defining the varmod mass in Dalton.</p>
</td></tr>
<tr><td><code id="fragmentIon_+3A_n_term">N_term</code></td>
<td>
<p>N-Term mass in Dalton. Default is set to 1.007825.</p>
</td></tr>
<tr><td><code id="fragmentIon_+3A_c_term">C_term</code></td>
<td>
<p>C-Term mass in Dalton. Default is set to 17.002740.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fragment ions of a peptide can be computed following the rules proposed in PMID:6525415.
Beside the <code>b</code> and <code>y</code> ions the <code>FUN</code> argument of <code>fragmentIon</code> defines
which ions are computed.
the default ions beeing computed are defined in the function <code>defaultIon</code>.
The are no limits for defining other forms of fragment ions for ETD (c and z ions) CID (b and y ions).
</p>
<p>NOTE:
for simplicity, we have set a Carbamidomethyl (C) fixed modification with 
160.030649 (Cysteine mono mass is 103.00919).
The fixed modifications setting are not enabled in the package yet.
</p>
<p>If only a vector of amino acids weights is given <code>fragmentIon</code> computes the ions series according to weights.
If this case applies, the function returns only a list having one data frame.
</p>


<h3>Author(s)</h3>

<p>Christian Panse, Bertran Gerrits 2006. 
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1002/bms.1200111109">doi:10.1002/bms.1200111109</a>
</p>
<p>Protein Sequencing and Identification Using Tandem Mass Spectrometry, 
Michael Kinter and Nicholas E. Sherman, 
Wiley-Interscience; 1st edition (September 18, 2000)
</p>


<h3>See Also</h3>

<p>first used in <code><a href="#topic+peakplot">peakplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
peptide.AA&lt;-"KINHSFLR";

peptide.AA.weights &lt;- c(128.09496,113.08406,114.04293,
    137.05891,87.03203,147.06841,113.08406,156.10111);

fragmentIon(peptide.AA);

fragmentIon(peptide.AA.weights);

HCD_Ion &lt;- function(b, y){
    return(cbind(b = b, y = y))
}


ETD_Ion &lt;- function(b, y){
    Hydrogen &lt;- 1.007825
    Oxygen &lt;- 15.994915
    Nitrogen &lt;- 14.003074

    y_0 &lt;- y - Oxygen - Hydrogen - Hydrogen
    c &lt;- b + (Nitrogen + (3 * Hydrogen))
    z &lt;- y - (Nitrogen + (3 * Hydrogen))

    return(cbind(y_0, c, z))
}

fragmentIon(peptide.AA, FUN = ETD_Ion)
        
peptides&lt;-c('HTLNQIDSVK', 'ALGGEDVR', 'TPIVGQPSIPGGPVR')

pim &lt;- parentIonMass(peptides)
fi &lt;- fragmentIon(peptides)
(df &lt;- as.data.frame(fi))

op &lt;- par(mfrow=c(3,1)); 
for (i in 1:length(peptides)){
    plot(0, 0,
    xlab='m/Z',
    ylab='',
    xlim=range(c(fi[[i]]$b,fi[[i]]$y)),
    ylim=c(0,1),
    type='n',
    axes=FALSE,
    sub=paste(peptides[i], "/", pim[i], "Da"));
    box()
    axis(1, fi[[i]]$b, round(fi[[i]]$b,1), las=2)
    axis(1, fi[[i]]$y, round(fi[[i]]$y,1), las=2)

    pepSeq&lt;-strsplit(peptides[i], "")
    axis(3,fi[[i]]$b, paste("b", row.names(fi[[i]]),sep=''),las=2)
    axis(3,fi[[i]]$y, paste("y", row.names(fi[[i]]),sep=''),las=2)

    text(fi[[i]]$b, rep(0.3, nchar(peptides[i])), 
    pepSeq[[1]],pos=3,cex=4, lwd=4, col="#aaaaaaaa")

    abline(v=fi[[i]]$b, col='red') 
    abline(v=fi[[i]]$y, col='blue',lwd=2)
}
par(op)


fi &lt;- fragmentIon(c("ATSFYK","XGXFNAGVGK"))[[2]]
fi$b[1] + fi$y[9]
fi$b[2] + fi$y[8]


ION2C &lt;- function(b, y){
    Hydrogen &lt;- 1.007825
    Oxygen &lt;- 15.994915
    Nitrogen &lt;- 14.003074

    # yo &lt;- fi$y - Oxygen - Hydrogen - Hydrogen
    c &lt;- b + (Nitrogen + (3 * Hydrogen))
    z &lt;- y - (Nitrogen + (3 * Hydrogen))
    
    # compute doubly charged fragment ions
    b2 &lt;- (b + Hydrogen) / 2
    y2 &lt;- (y + Hydrogen) / 2

    return(cbind(b, y, b2 ,y2))
}


</code></pre>

<hr>
<h2 id='genMod'>Generates all possible modification of a given peptide seqence and modification pattern</h2><span id='topic+genMod'></span>

<h3>Description</h3>

<p>This function can be used to screen precursor masses for meaningful mass shifts which could correspond to post translational modifications.
We suggest to only use a maxiumum of a handful of mass shifts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    genMod(sequences, modificationPattern, nModification=2)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genMod_+3A_sequences">sequences</code></td>
<td>
<p>peptide sequences encoded as character sequence using the 20 amino acid letters.</p>
</td></tr>
<tr><td><code id="genMod_+3A_modificationpattern">modificationPattern</code></td>
<td>
<p>a rbind list structure containing the mono and avg mass as well as the description of a the modifications.</p>
</td></tr>
<tr><td><code id="genMod_+3A_nmodification">nModification</code></td>
<td>
<p>number of maximal modifications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>t.b.d.
</p>


<h3>Author(s)</h3>

<p>Hubert Rehrauer and Christian Panse 2012
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ptm.0&lt;-cbind(AA="-",
        mono=0.0, avg=0.0, desc="unmodified", unimodAccID=NA)

    ptm.616&lt;-cbind(AA='S',
        mono=-27.010899, avg=NA, desc="Substituition",
            unimodAccID=616)

    ptm.651&lt;-cbind(AA='N',
        mono=27.010899, avg=NA, desc="Substituition",
            unimodAccID=651)


    m&lt;-as.data.frame(rbind(ptm.0, ptm.616, ptm.651))

    genMod(c('TAFDEAIAELDTLNEESYK','TAFDEAIAELDTLSEESYK'), m$AA)

</code></pre>

<hr>
<h2 id='HexNAc'>HexNAc - Analysis of N-HexNAc glycopeptides by LC-MS/MS, using HCD and ETD
fragmentation techniques</h2><span id='topic+HexNAc'></span>

<h3>Description</h3>

<p><code>HexNAc</code> is intented for demonstration of the <code>PTM_MarkerFinder</code> methode
descriped in [PROTEOMICS pmic.201300036].
It contains the mass pattern (m/z) of 
<code>c(126.05495, 138.05495, 144.06552, 168.06552, 186.07608, 204.08665)</code>.
</p>
<p>A sample containing enriched glycopeptides from yeast was
analysed by LC-MS/MS on a LTQ-Orbitrap Velos instrument using sequential
HCD and ETD fragmentation techniques.
The dataset contains only 11 tandem mass spectra extracted from this
experiment. Three pairs of HCD/ETD spectra correspond to peptides carrying
N-HexNAc modification identified with high confidence (6 spectra in total).
One pair of HCD/ETD spectra corresponds to peptides carrying N-HexNAc
modification, identified with very low confidence (2 spectra in total). The
remaining 3 spectra are from unmodified peptides.
</p>


<h3>Format</h3>

<p>A data set consists of eleven tandem mass spectra.</p>


<h3>Author(s)</h3>

<p>Paolo Nanni, Christian Panse, 2013
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    data(HexNAc)
    HexNAc[[1]]

    plot(HexNAc[[1]]$mZ, HexNAc[[1]]$intensity, type='h')

</code></pre>

<hr>
<h2 id='insertSamples'>Insert sample on a given position</h2><span id='topic+insertSamples'></span>

<h3>Description</h3>

<p>Insert sample on a given position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insertSamples(
  S,
  stdName = "autoQC01",
  stdPosX = "8",
  stdPosY = "F",
  plate = 1,
  volume = 2,
  method = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insertSamples_+3A_s">S</code></td>
<td>
<p>input <code>data.frame</code></p>
</td></tr>
<tr><td><code id="insertSamples_+3A_stdname">stdName</code></td>
<td>
<p>name of the sample</p>
</td></tr>
<tr><td><code id="insertSamples_+3A_stdposx">stdPosX</code></td>
<td>
<p>x location on the plate</p>
</td></tr>
<tr><td><code id="insertSamples_+3A_stdposy">stdPosY</code></td>
<td>
<p>y location on the plate</p>
</td></tr>
<tr><td><code id="insertSamples_+3A_plate">plate</code></td>
<td>
<p>number of the plate</p>
</td></tr>
<tr><td><code id="insertSamples_+3A_volume">volume</code></td>
<td>
<p>injection volume</p>
</td></tr>
<tr><td><code id="insertSamples_+3A_method">method</code></td>
<td>
<p>a path to the method file (optional)</p>
</td></tr>
<tr><td><code id="insertSamples_+3A_...">...</code></td>
<td>
<p>addition parameter, e.g.,  <code>howoften = 1</code> <code>howmany = 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris[c(1:15,51:65,101:115), ] |&gt;
  assignPlatePosition() |&gt;
  insertSamples(howoften=4, begin=FALSE, end=FALSE,
    stdPosX='6', stdPosY='F', plate=1, stdName = "clean")
    
</code></pre>

<hr>
<h2 id='iRTpeptides'>iRT peptides - independent retention time peptides</h2><span id='topic+iRTpeptides'></span><span id='topic+irt'></span><span id='topic+iRT'></span>

<h3>Description</h3>

<p><code>iRTpeptides</code> data are used for <code>genSwathIonLib</code> rt normalization 
assuming.
</p>


<h3>Format</h3>

<p>contains a table</p>


<h3>Author(s)</h3>

<p>Jonas Grossmann and Christian Panse 2013
</p>


<h3>References</h3>

<p>Using iRT, a normalized retention time for more targeted measurement of peptides.
Escher C, Reiter L, MacLean B, Ossola R, Herzog F, Chilton J, MacCoss MJ, Rinner O.
Source
Proteomics. 2012 Apr;12(8):1111-21. doi: 10.1002/pmic.201100463.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    plot(sort(iRTpeptides$rt))

    plot(pim&lt;-parentIonMass(as.character(iRTpeptides$peptide)) ~ iRTpeptides$rt)

</code></pre>

<hr>
<h2 id='iTRAQ'>iTRAQ - A small 8-plex iTRAQ  data set with confident identified peptides from 5 proteins.</h2><span id='topic+iTRAQ'></span>

<h3>Description</h3>

<p>This dataset contains quantification data from iTRAQ (isobaric tag for relative and absolute quantification) LC-MSMS identified peptides using the software ProteinPilot from ABSciex. 
The data is generated on a Thermo LTQ-Oribtrap. The mascot generic files are produced with MascotDistiller and searched with ProteinPilot V.4. The peptide summary export is used and filtered towards confident peptides (Confidence above 90) and only columns with Protein accession, peptide sequence, the 8 reporter ion channels (area) are kept as well as the protein description. The rest of the peptide summary is deleted. This data is only a small illustrative part out of the whole data produced.
The package design is done in a way, that it is not restricted to ProteinPilot exports but can be used with all other kind of iTRAQ tools, as long as each reporter channel with areas or intensities can be exported. The main point of this function is, to get a hand on what peptides and proteins are used to quantify. Also to be able to not use ratio based quantification but to clearly specify the input and the experimental design.</p>


<h3>Format</h3>

<p>A data set with approx. 260 rows and 10 variables, 40KBytes file size, derived from biological data from an iTRAQ project..</p>


<h3>Author(s)</h3>

<p>Jonas Grossmann, Christian Panse, 2012
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1016/j.jprot.2012.09.011">doi:10.1016/j.jprot.2012.09.011</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    data(iTRAQ)
    iTRAQ[1:10,]

</code></pre>

<hr>
<h2 id='iTRAQ2GroupAnalysis'>iTRAQ two group analysis</h2><span id='topic+iTRAQ2GroupAnalysis'></span>

<h3>Description</h3>

<p>The function performes a two group analysis with a t-test for data sets like <code>iTRAQ</code>. Result files are generated where the 2 groups are compared for each protein, while a p-value is calculated. If plot equals TRUE, the boxplots are drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    iTRAQ2GroupAnalysis(data, group1, group2, 
        INDEX, FUN=function(x){return(x)}, plot)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iTRAQ2GroupAnalysis_+3A_data">data</code></td>
<td>
<p>a data set like iTRAQ.</p>
</td></tr>
<tr><td><code id="iTRAQ2GroupAnalysis_+3A_group1">group1</code></td>
<td>
<p>a vector of column ids.</p>
</td></tr>
<tr><td><code id="iTRAQ2GroupAnalysis_+3A_group2">group2</code></td>
<td>
<p>a vector of column ids.</p>
</td></tr>
<tr><td><code id="iTRAQ2GroupAnalysis_+3A_index">INDEX</code></td>
<td>
<p>list of factors, each of same length as <code>X</code>.  The elements are coerced to factors by <code>as.factor</code>.</p>
</td></tr>
<tr><td><code id="iTRAQ2GroupAnalysis_+3A_fun">FUN</code></td>
<td>
<p>function for doing the data transformation, e.g. log, asinh.</p>
</td></tr>
<tr><td><code id="iTRAQ2GroupAnalysis_+3A_plot">plot</code></td>
<td>
<p>boolean. if TRUE boxplots are drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>t.b.d.
</p>


<h3>Author(s)</h3>

<p>Christian Panse, Jonas Grossmann 2011
</p>


<h3>Examples</h3>

<pre><code class='language-R'>       data(iTRAQ)
       par(mfrow=c(2,3))
       qProt&lt;-iTRAQ2GroupAnalysis(data=iTRAQ, 
        group1=c(3,4,5,6), 
        group2=7:10, INDEX=iTRAQ$prot, plot=TRUE)
       qProt
       qPeptide&lt;-iTRAQ2GroupAnalysis(data=iTRAQ, 
        group1=c(3,4,5,6), 
        group2=7:10, 
        INDEX=paste(iTRAQ$prot,iTRAQ$peptide), plot=FALSE)
</code></pre>

<hr>
<h2 id='lcmsmap'>LC-MS Map</h2><span id='topic+pep3d'></span><span id='topic+lcmsmap'></span><span id='topic+lcmsoverview'></span><span id='topic+plot.psmSet'></span>

<h3>Description</h3>

<p>The function graphs a LC-MS map having for all charge states and each single charge state.
The rt is on the x axis and the y axis represents the peptide mass. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    lcmsmap(data, charges=2:3, score.cutoff = 30, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcmsmap_+3A_data">data</code></td>
<td>
<p>an R data  object as it can be obtained by <code>mascotDat2RData.pl</code> or 
by using mascots export function.</p>
</td></tr>
<tr><td><code id="lcmsmap_+3A_charges">charges</code></td>
<td>
<p>a vector of charge states to be displayed.</p>
</td></tr>
<tr><td><code id="lcmsmap_+3A_score.cutoff">score.cutoff</code></td>
<td>
<p>a numeric value taken as score cut-off.</p>
</td></tr>
<tr><td><code id="lcmsmap_+3A_...">...</code></td>
<td>
<p>pass arguments to <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Panse and Jonas Grossmann 2013; 
</p>


<h3>References</h3>

<p>idea taken from from the ISB TPP Pep3D view
PMID: 15228367
</p>

<hr>
<h2 id='mascot'>
Generic methods for mascot results
</h2><span id='topic+mascot'></span><span id='topic+plot.mascot'></span><span id='topic+plot.mascot_query'></span><span id='topic+is.mascot'></span><span id='topic+is.mascot_query'></span><span id='topic+as.data.frame.mascot'></span><span id='topic+summary.mascot'></span><span id='topic+summary.cometdecoy'></span><span id='topic+as.psm.mascot_query'></span>

<h3>Description</h3>

<p>does something with a <code>mascot</code> object using the package's functions, 
e.g., <code><a href="#topic+peakplot">peakplot</a></code> or <code><a href="#topic+lcmsmap">lcmsmap</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  ## S3 method for class 'mascot'
is(object, class2)

  ## S3 method for class 'mascot'
plot(x, ...)
  
  ## S3 method for class 'mascot'
as.data.frame(x, ...)
  
  ## S3 method for class 'mascot'
summary(object, ...)
  
  ## S3 method for class 'mascot_query'
is(object, class2)
    
  ## S3 method for class 'mascot_query'
plot(x, obj = NULL, FUN = defaultIon, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mascot_+3A_x">x</code></td>
<td>

<p>a <code>mascot_query</code> or <code>mascot</code> S3 class object.
</p>
</td></tr>
<tr><td><code id="mascot_+3A_object">object</code></td>
<td>

<p>a <code>mascot</code> S3 class object.
</p>
</td></tr>
<tr><td><code id="mascot_+3A_obj">obj</code></td>
<td>

<p>a <code>mascot</code> S3 class object.
</p>
</td></tr>
<tr><td><code id="mascot_+3A_class2">class2</code></td>
<td>

<p>dummy
</p>
</td></tr>
<tr><td><code id="mascot_+3A_...">...</code></td>
<td>

<p>arguments will be passwed through.
</p>
</td></tr>
<tr><td><code id="mascot_+3A_fun">FUN</code></td>
<td>

<p>ion series.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the object has been generated by using the mascot server command
<code>./export_dat_2.pl $EXPORTOPTIONS file=$DAT</code>.
</p>
<p><code>$EXPORTOPTIONS</code> is defined as <code>"_minpeplen=5 _server_mudpit_switch=0.000000001 _showsubsets=1 _sigthreshold=0.05 do_export=1 export_format=XML group_family=1 pep_calc_mr=1 pep_delta=1 pep_end=1 pep_exp_mr=1 pep_exp_mz=1 pep_exp_z=1 pep_expect=1 pep_isbold=1 pep_isunique=1 pep_miss=1 pep_query=1 pep_rank=1 pep_scan_title=1 pep_score=1 pep_seq=1 pep_start=1 pep_var_mod=1 peptide_master=1 prot_acc=1 prot_cover=1 prot_desc=1 prot_empai=1 prot_hit_num=1 prot_len=1 prot_mass=1 prot_matches=1 prot_pi=1 prot_score=1 prot_seq=1 protein_master=1 query_master=1 query_params=1 query_peaks=1 query_qualifiers=1 query_raw=1 query_title=1 search_master=1 show_format=1 show_header=1 show_masses=1 show_mods=1 show_params=1 show_pep_dupes=1 use_homology=1 user=command line"</code>.
</p>
<p><code>$DAT</code> defines the mascot result file.
</p>
<p>The output is written as XML file the following command is applied:
<code>XML::xmlToList(XML::xmlParse(xml_file_name))</code>.
</p>
<p><a href="XML.html#topic+xmlParse">xmlParse</a> and <a href="XML.html#topic+xmlToList">xmlToList</a> are function of the XML package.
</p>


<h3>Value</h3>

<p>returns the <a href="#topic+peakplot">peakplot</a> return value. 
</p>


<h3>Author(s)</h3>

<p>Christian Panse, 2017
</p>


<h3>References</h3>

<p><a href="http://www.matrixscience.com/mascot_support_v2_6.html">http://www.matrixscience.com/mascot_support_v2_6.html</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.mascot">summary.mascot</a></code>
</p>
</li>
<li> <p><code><a href="#topic+peakplot">peakplot</a></code>
</p>
</li>
<li> <p><a href="https://CRAN.R-project.org/package=XML">https://CRAN.R-project.org/package=XML</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # plot the top ten highes scored PSMs
  par(ask = TRUE)
  idx &lt;- order(protViz:::.mascot.get.pep_score(S), decreasing = TRUE)[1:10]
  rv.peakplot &lt;- lapply(S$queries[idx], plot)
  
  
  myAA &lt;- do.call('rbind', lapply(F225712$masses, 
    function(x){
      data.frame(letter1=as.character(x$.attrs), mass=as.numeric(x$text))
      }))
      
  aa2mass("ELVISR", mass=myAA$mass[1:25], letter1 = myAA$letter1[1:25])
  

## End(Not run)
</code></pre>

<hr>
<h2 id='massDeviationPlot'>Mass Deviation Plot</h2><span id='topic+massDeviationPlot'></span><span id='topic+mdp'></span>

<h3>Description</h3>

<p><code>massDeviationPlot</code> computes the mass deviation of a data set having 
the list attributes <code>pepmass</code> and <code>peptideSequence</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    mdp(data, sub)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="massDeviationPlot_+3A_data">data</code></td>
<td>
<p>an R data  object as it can be obtained by <code>mascotDat2RData.pl</code></p>
</td></tr>
<tr><td><code id="massDeviationPlot_+3A_sub">sub</code></td>
<td>
<p>a sub title for the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this version it igrnoes modified peptides.
</p>


<h3>Author(s)</h3>

<p>Christian Panse 2012-2013; 
</p>


<h3>References</h3>

<p>Zubarev R, Mann M.
On the proper use of mass accuracy in proteomics.
Mol Cell Proteomics. 2007 Mar;6(3):377-81. Epub 2006 Dec 12.
PMID: 17164402 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    # load("F178767.Rdata")
    # pdf("massError.pdf",12,9)
    # massDeviationPlot (F178767)
    # dev.off()

</code></pre>

<hr>
<h2 id='msms'>A data set containing tandem mass spectra of an LCMS experiment.</h2><span id='topic+msms'></span>

<h3>Description</h3>

<p>The purpose of <code>msms</code> is for the demonstration of the peptide 
identification methods, e.g., <code>peakplot</code> or <code>psm</code>.
</p>
<p><code>msms</code> contains two tandem mass spectra meassured on a linear ion 
trap coupled to an Orbitrap mass analyzer 
(Thermo Scientific, Bremen, Germany).
</p>
<p>The protein sample originates from 10
mouse brain homogenate, prepared in sterile PBS containing protease
inhibitors (Complete; Riche, Switzerland) by repeated extrusion through
syringe needles of successive smaller size. To remove gross cellular
debris the homogenate was centrifuged for 10 min at 2400 rpm
at 4 degrees centigrade.
</p>
<p>The data were acquired withing the Sixth Framework Programm (FP6-37457). 
The project was called SysProt.
</p>


<h3>Author(s)</h3>

<p>Dorothea Rutishauser, Jonas Grossmann, Christian Panse 2008
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    data(msms)
    peakplot("TAFDEAIAELDTLNEESYK", msms[[1]])

</code></pre>

<hr>
<h2 id='parentIonMass'>Compute Parent Ion Mass of a Peptide Sequence</h2><span id='topic+parentIonMass'></span><span id='topic+pim'></span><span id='topic+pepmass'></span>

<h3>Description</h3>

<p>It computes the parent ion mass of a vector of peptide sequences. The weights of the amino acids and the C-Term are hard coded in the C function.
Important: The precursor mass is calculated with an additional proton, so to speak the singly charged precursor!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    parentIonMass(sequence, fixmod, NTerm)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parentIonMass_+3A_sequence">sequence</code></td>
<td>
<p>peptide sequence encoded as character sequence using the 20 amino acid letters.</p>
</td></tr>
<tr><td><code id="parentIonMass_+3A_fixmod">fixmod</code></td>
<td>
<p>a double vector of length 26 defining the amino acid mass.</p>
</td></tr>
<tr><td><code id="parentIonMass_+3A_nterm">NTerm</code></td>
<td>
<p>a double value defining the weight of the NTerm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>parentIonMass</code> function reqires one argument <code>secuence</code>.
</p>


<h3>Author(s)</h3>

<p>Christian Panse 2006
</p>


<h3>Examples</h3>

<pre><code class='language-R'>        
        fetuin&lt;-list( sequence=c('MK', 'SFVLLFCLAQLWGCHSIPLDPVAGYK',
        'EPACDDPDTEQAALAAVDYINK',
        'HLPR', 'GYK', 'HTLNQIDSVK', 'VWPR',
        'RPTGEVYDIEIDTLETTCHVLDPTPLANCSVR',
        'QQTQHAVEGDCDIHVLK', 'QDGQFSVLFTK',
        'CDSSPDSAEDVR', 'K', 'LCPDCPLLAPLNDSR',
        'VVHAVEVALATFNAESNGSYLQLVEISR',
        'AQFVPLPVSVSVEFAVAATDCIAK',
        'EVVDPTK', 'CNLLAEK', 'QYGFCK',
        'GSVIQK', 'ALGGEDVR',
        'VTCTLFQTQPVIPQPQPDGAEAEAPSAVPDAAGPTPSAAGPPVASVVVGPSVVAVPLPLHR',
        'AHYDLR', 'HTFSGVASVESSSGEAFHVGK',
        'TPIVGQPSIPGGPVR', 'LCPGR', 'IR', 'YFK', 'I'),
        description=
            "FETUA_BOVIN Alpha-2-HS-glycoprotein ")

        plot(peptideMass&lt;-parentIonMass(sequence=fetuin$sequence), 
            sub=list(fetuin$description, cex=0.75), 
            main="tryptic digested peptides")


        AA&lt;-c(71.037114, 114.534940, 160.030649, 115.026943, 129.042593, 147.068414, 
            57.021464, 137.058912, 113.084064, 0.000000, 128.094963, 113.084064, 
            131.040485, 114.042927, 0.000000, 97.052764, 128.058578, 156.101111, 
            87.032028, 101.047679, 150.953630, 99.068414, 186.079313, 111.000000, 
            163.063329, 128.550590)

        parentIonMass(c("ELVIS", "ELVISK"), fixmod=AA)
</code></pre>

<hr>
<h2 id='peakplot'>Labelling of Peptide Fragment Mass Spectra</h2><span id='topic+peakplot.label'></span><span id='topic+peakplot.putlabel'></span><span id='topic+peakplot.pie'></span><span id='topic+peakplot'></span><span id='topic+protViz'></span><span id='topic+peaklist'></span><span id='topic+peaklistSet'></span><span id='topic+plot.psm'></span>

<h3>Description</h3>

<p><code>peakplot</code> labels a mass spectrum from a peptide sequence  
assignment by using the <code>psm</code> function with the appropriate 
fragment ion labels.
Using <code>peakplot</code> it is possible to compute the fragment ion 
coverage and customize the fragmentation ions used for labelling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    peakplot(peptideSequence, spec, 
        FUN=defaultIon, 
        fi=fragmentIon(peptideSequence, FUN=FUN)[[1]],
        sub=paste(peptideSequence, spec$title, sep=" / "),
        itol=0.6,
        pattern.abc="[abc].*",
        pattern.xyz="[xyz].*",
        ion.axes=TRUE, ...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peakplot_+3A_peptidesequence">peptideSequence</code></td>
<td>
<p>peptide sequence encoded as a character sequence using 
the 20 amino acid letter code.</p>
</td></tr>
<tr><td><code id="peakplot_+3A_spec">spec</code></td>
<td>
<p>a <code>peaklist</code> or a tandem mass spec data structure which is a list having two 
eq sized vectors calles mZ and intensity. mZ values are sorted.</p>
</td></tr>
<tr><td><code id="peakplot_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to compute further ions. If no 
function is assigned <code>fragmentIon</code> will
use <code>defaultIon</code>.</p>
</td></tr>
<tr><td><code id="peakplot_+3A_fi">fi</code></td>
<td>
<p>fragment ion table, if not specified 
<code>fragmentIon(sequence, FUN=FUN)[[1]]</code> is called.
This argument is useful if you have PTM or specific ion series.</p>
</td></tr>
<tr><td><code id="peakplot_+3A_sub">sub</code></td>
<td>
<p>a sub title for the plot</p>
</td></tr>
<tr><td><code id="peakplot_+3A_itol">itol</code></td>
<td>
<p>fragment ion tolerance default is 0.6 Dalton. values below are considered as hit.</p>
</td></tr>
<tr><td><code id="peakplot_+3A_pattern.abc">pattern.abc</code></td>
<td>
<p><code>regexpr pattern</code> for a, b, c like ions. if the pattern does not match ion are not plotted.</p>
</td></tr>
<tr><td><code id="peakplot_+3A_pattern.xyz">pattern.xyz</code></td>
<td>
<p><code>regexpr pattern</code> for x, y, z like ions.</p>
</td></tr>
<tr><td><code id="peakplot_+3A_ion.axes">ion.axes</code></td>
<td>
<p>boolean default is <code>TRUE</code>. determines whether the fragment ion labels should be plotted instead of m/z values.</p>
</td></tr>
<tr><td><code id="peakplot_+3A_...">...</code></td>
<td>
<p>passed to the default plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>peakplot</code> computes the in-silico fragment ion, using the 
<code><a href="#topic+fragmentIon">fragmentIon</a></code> function, and matches them again with
the MS2. If the mass error between the in-silico peak and the measured one 
is below 0.6 Da (default setting), the peptide spectrum match 
(<code><a href="#topic+psm">psm</a></code>) is considered as a hit.
</p>
<p>The major objective of the labelling is the avoidance of overlapping labels, for 
which purpose <code>peakplot</code> applies filtering. A label is only drawn if the 
corresponding ion count of the m/z peak is higher than a given threshold. 
Experience from several hundred annotations shows that the 0.9 percentile is 
a good cut-off value. To most efficiently use the limited screen and printout 
space and to ensure that labels representing important local peaks are also 
considered for the drawing, <code>peakplot</code> divides the display space into a 
number of bins depending on the peptide sequence length along the m/z axis. 
From these bins, the top n labels are ordered according to abundance. For the 
visual clustering effect, the abc and xyz ions are drawn on different y-axis 
levels using different colors. Ion types considered for labelling is 
dependent on the instrument setting applied during the initial search.
</p>


<h3>Value</h3>

<p>returns a list object containing all the peptide spectrum match relevant
information.
</p>


<h3>Author(s)</h3>

<p>Bertran Gerrits, Christian Panse 
</p>
<p>2006-2017; 
</p>


<h3>References</h3>


<ul>
<li><p> PEAKPLOT: Visualizing Fragmented Peptide Mass Spectra in Proteomics (2009)
Panse Christian, Gerrits Bertran, Schlapbach Ralph, useR!2009,
</p>
<p>abstract: <a href="https://www.r-project.org/conferences/useR-2009/abstracts/pdf/Panse+Gerrits+Schlapbach.pdf">https://www.r-project.org/conferences/useR-2009/abstracts/pdf/Panse+Gerrits+Schlapbach.pdf</a>,
</p>
<p>slides: <a href="https://www.r-project.org/conferences/useR-2009/slides/Panse+Gerrits+Schlapbach.pdf">https://www.r-project.org/conferences/useR-2009/slides/Panse+Gerrits+Schlapbach.pdf</a>.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+mascot">mascot</a>
</p>
</li>
<li><p><code><a href="#topic+fragmentIon">fragmentIon</a></code>
</p>
</li>
<li><p><code><a href="#topic+psm">psm</a></code>
</p>
</li>
<li><p><code><a href="#topic+PTM_MarkerFinder">PTM_MarkerFinder</a></code>
</p>
</li>
<li> <p><code><a href="#topic+peakplot">peakplot</a></code> has been used for generating 
figures and supplemental material in:  
</p>
<p><a href="https://doi.org/10.1074/mcp.M600046-MCP200">doi:10.1074/mcp.M600046-MCP200</a>,
<a href="https://doi.org/10.1038/msb4100182">doi:10.1038/msb4100182</a>,
<a href="https://doi.org/10.1371/journal.pone.0036980">doi:10.1371/journal.pone.0036980</a>,
<a href="https://doi.org/10.1002/pmic.201300036">doi:10.1002/pmic.201300036</a>,
<a href="https://doi.org/10.1074/mcp.M115.052548">doi:10.1074/mcp.M115.052548</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
    data(msms)
    op &lt;- par(mfrow=c(2,1))
    peakplot("TAFDEAIAELDTLNEESYK", msms[[1]])
    peakplot("TAFDEAIAELDTLSEESYK", msms[[2]])
    par(op)


    # filter cand. fragment ions
    fi &lt;- fragmentIon("TAFDEAIAELDTLNEESYK")
    fi.cyz &lt;- as.data.frame(cbind(c=fi[[1]]$c, y=fi[[1]]$y, z=fi[[1]]$z))

    p &lt;- peakplot("TAFDEAIAELDTLNEESYK", spec=msms[[1]],
        fi=fi.cyz,
        itol=0.6,
        ion.axes=FALSE)
        
          
    # customizing the ion series
    ions &lt;- function(b, y){
      Hydrogen &lt;- 1.007825
      Oxygen &lt;- 15.994915
      Nitrogen &lt;- 14.003074
  
      y0 &lt;- fi$y - Oxygen - Hydrogen - Hydrogen
      c &lt;- b + (Nitrogen + (3 * Hydrogen))
      z &lt;- y - (Nitrogen + (3 * Hydrogen))
      
      return(cbind(b, y, c ,z, y0))
  }
</code></pre>

<hr>
<h2 id='pgImporter'>Progenesis Importer Function</h2><span id='topic+pgImporter'></span>

<h3>Description</h3>

<p>The function reads a CSV file which is exported using ProgenesisLCMS. The object is flexible when it comes to exported fields, ideally, everything is in the CSV. 
The delimiter is a semicolon (this setting is ProgenesisLCMS version AND system language setting sensitive). All the information is kept and accessible.
</p>
<p>There is an option which allows you to switch the separator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    pgImporter(file, sep=';')

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgImporter_+3A_file">file</code></td>
<td>
<p>A csv file.</p>
</td></tr>
<tr><td><code id="pgImporter_+3A_sep">sep</code></td>
<td>
<p>The field separator character. default vaule is set to a semicolon.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This importer is dedicated to the commercial software ProgenesisLCMS. Nevertheless it is has a simple structure and can be adapted and used also for other maps.
</p>
<p>todo: Pass an additonal argument to the pgImporter function which 
allows to define the separator.
</p>


<h3>Author(s)</h3>

<p>Christian Panse, Hubert Rehauer, Jonas Grossmann 2012
</p>

<hr>
<h2 id='pgLFQaov'>iTRAQ two group analysis</h2><span id='topic+pgLFQaov'></span>

<h3>Description</h3>

<p>The function performes an ANOVA for data sets like <code>pgLFQ</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    pgLFQaov(data, groups, names, idx, plot, FUN)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgLFQaov_+3A_data">data</code></td>
<td>
<p>a data set like <code>pgLFq</code>.</p>
</td></tr>
<tr><td><code id="pgLFQaov_+3A_groups">groups</code></td>
<td>
<p>a factor.</p>
</td></tr>
<tr><td><code id="pgLFQaov_+3A_names">names</code></td>
<td>
<p>a vector of strings for the main attribute of each plot.</p>
</td></tr>
<tr><td><code id="pgLFQaov_+3A_idx">idx</code></td>
<td>
<p>a integer vector of indice to be processed.</p>
</td></tr>
<tr><td><code id="pgLFQaov_+3A_plot">plot</code></td>
<td>
<p>logical.  If 'TRUE' (non default), a boxplot is drawn.</p>
</td></tr>
<tr><td><code id="pgLFQaov_+3A_fun">FUN</code></td>
<td>
<p>function for doing the data transformation, e.g. <code>log</code>, <code>asinh</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methode performs an oav analysis using the R <code>oav</code> function.
It returns a vector of the ANOVA <code>"Pr(&gt;F)"</code> values in the same order.
</p>


<h3>Author(s)</h3>

<p>Christian Panse, Jonas Grossmann 2012
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    data(pgLFQprot)

    par(mfrow=c(4,3))
    ANOVA&lt;-pgLFQaov(pgLFQprot$"Normalized abundance",
        groups=as.factor(pgLFQprot$grouping),
        names=pgLFQprot$output$Accession,
        plot=TRUE)
    ANOVA


</code></pre>

<hr>
<h2 id='pgLFQfeature'>pgLFQfeature - A data set with a featuremap export ProgenesisLCMS</h2><span id='topic+pgLFQfeature'></span>

<h3>Description</h3>

<p>This data set contains a fraction of the most abundant features from 24 LC-MSMS runs measured on 
an Orbitrap-Velos. The data contains digested proteins from human HeLa cells infected with Shigella bacteria grown on a time course.
It is structured in a way, that 6 biological replicates from 4 conditions are measured (Not_infected, Infected_1hr, Infected_2hr, Infected_3hr). 
The 24 LC-MSMS runs are aligned with each other and a so called mastermap (feature map) is generated where &quot;normalized volumes&quot; on MS1 are extracted for all features in the respective LC-MSMS runs. Some of the features are further annotated with peptide sequences and protein accessions (using the Mascot search algorithm and an ion score cutoff of 25).
</p>
<p>We realized, depending on your language and keyboard setting, the separator for the FeatureData as well as for ProteinMeasurements are different (semicolon and commas are used depending on your setting). We assume, that semicolons are and the individual cells are escaped by &quot;. If this differes, we have an option that can be switched in the pgImporter function.
</p>
<p>More information on the commercial software can be found here:
<a href="http://www.nonlinear.com/products/progenesis/lc-ms/overview/">http://www.nonlinear.com/products/progenesis/lc-ms/overview/</a>.
</p>


<h3>Format</h3>

<p>A data object from ProgenesisImporter.R</p>


<h3>Author(s)</h3>

<p>Christian Panse, Jonas Grossmann 2012
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1016/j.jprot.2010.05.011">doi:10.1016/j.jprot.2010.05.011</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pgLFQfeature)
op&lt;-par(mfrow=c(1,1),mar=c(18,18,4,1),cex=0.5)
samples&lt;-names(pgLFQfeature$"Normalized abundance")
image(cor(asinh(pgLFQfeature$"Normalized abundance")),
    col=gray(seq(0,1,length=20)),
    main='pgLFQfeature correlation',
    axes=FALSE)

axis(1,at=seq(from=0, to=1, 
    length.out=length(samples)), 
    labels=samples, las=2)

axis(2,at=seq(from=0, to=1, 
    length.out=length(samples)), labels=samples, las=2)
par(op)

# example assemble (and quantify) all proteins from peptides 
# using intensities from the master(feature) map
# 1239 features
pgLFQfeature$peptideInfo$Sequence[1239]
pgLFQfeature$peptideInfo$Protein[1239]
# conflicts can be produced through: 
# 1. shared peptides, 
# 2. mapping to more than one peptide, 
# 3. rank two above threshold
pgLFQfeature$output$Included[1239]
pgLFQfeature$"Normalized abundance"[1239,]

# tNpq
    par(mfrow=c(4,3), mar=c(1,1,4,1))
    for (i in 1:12)
        pgLFQtNpq(QuantitativeValue=pgLFQfeature$"Normalized abundance", 
        peptide=pgLFQfeature$peptideInfo$Sequence, 
        protein=pgLFQfeature$peptideInfo$Protein, N=i)

</code></pre>

<hr>
<h2 id='pgLFQprot'>pgLFQprot - A data set with a featuremap export ProgenesisLCMS</h2><span id='topic+pgLFQprot'></span>

<h3>Description</h3>

<p>This data set contain the top 250 most abundant Proteins identified from 24 LC-MSMS runs measured on 
an Orbitrap-Velos. The original data contains digested proteins from HeLa cells infected with Shigella bacteria grown in a time course.
It is structured in a way, that 6 biological replicates from 4 conditions are measured (Not_infected, Infected_1hr, Infected_2hr, Infected_3hr). 
The 24 LC-MSMS runs are aligned with each other using ProgenesisLCMS. &quot;Normalized volumes&quot; on MS1 are extracted for all features in the respective LC-MSMS runs. The features with an annotation such as peptide sequences and protein accessions (using Mascot search algorithm) are assembled to proteins. Features volumes are stacked (for non conflicting features) to generate the quantitative protein value for each LC-MSMS run.
The csv file is an exported Protein data map.
</p>
<p>We realized, depending on your language and keyboard setting, the separator for the FeatureData as well as for ProteinMeasurements are different (semicolon and commas are used depending on your setting). We assume, that semicolons are and the individual cells are escaped by &quot;. If this differes, we have an option that can be switched in the pgImporter function.
</p>
<p>More information on the commercial software can be found here:
<a href="http://www.nonlinear.com/products/progenesis/lc-ms/overview/">http://www.nonlinear.com/products/progenesis/lc-ms/overview/</a>.
</p>


<h3>Format</h3>

<p>A data object from ProgenesisImporter.R</p>


<h3>Author(s)</h3>

<p>Christian Panse, Jonas Grossmann 2012
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1016/j.jprot.2010.05.011">doi:10.1016/j.jprot.2010.05.011</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pgLFQprot)
op&lt;-par(mfrow=c(1,1),mar=c(18,18,4,1),cex=0.5)
samples&lt;-names(pgLFQprot$"Normalized abundance")
image(cor(asinh(pgLFQprot$"Normalized abundance")),
    main='pgLFQprot correlation',
    axes=FALSE,
    col=gray(seq(0,1,length=20)))
axis(1,at=seq(from=0, to=1, 
    length.out=length(samples)), labels=samples, las=2)
axis(2,at=seq(from=0, to=1, 
    length.out=length(samples)), labels=samples, las=2)
par(op)

</code></pre>

<hr>
<h2 id='pgLFQtNpq'>Label Free Quantification using the top N peptide approach</h2><span id='topic+pgLFQtNpq'></span><span id='topic+tNpq'></span>

<h3>Description</h3>

<p>This Function implements the recently emerged TopN strategy which 
uses only the top N intense features for calculating the 
proteinVolume. This approach should reveal a quantitative protein 
value, which should make the protein itself comparable within one 
condition. This allows to estimate protein stochiometries and 
simplifies modelling and calculations with copy numbers per cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    pgLFQtNpq(QuantitativeValue, 
    peptide, protein, N=3, plot=TRUE, FUN=asinh)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgLFQtNpq_+3A_quantitativevalue">QuantitativeValue</code></td>
<td>
<p>a data set like 
<code>pgLFQfeature$"Normalized abundance"</code>.</p>
</td></tr>
<tr><td><code id="pgLFQtNpq_+3A_peptide">peptide</code></td>
<td>
<p>a vector of peptide sequences.</p>
</td></tr>
<tr><td><code id="pgLFQtNpq_+3A_protein">protein</code></td>
<td>
<p>a vector of protein information.</p>
</td></tr>
<tr><td><code id="pgLFQtNpq_+3A_n">N</code></td>
<td>
<p>top <code>N</code> peptide flyers.</p>
</td></tr>
<tr><td><code id="pgLFQtNpq_+3A_plot">plot</code></td>
<td>
<p>logical.  If 'TRUE' (non default), a boxplot is drawn.</p>
</td></tr>
<tr><td><code id="pgLFQtNpq_+3A_fun">FUN</code></td>
<td>
<p>function for doing the data transformation for the 
correlation matrix for the image plot, default transformation is 
<code>asinh</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approach has first been described by Silva et al. in 2005 for 
Waters Q-tof instruments running in the MSe mode. Grossmann et al, 
showed in 2010 that this approach also works for more widely spread 
instruments such as Orbitrap-Velos or FTICR instruments from Thermo.
</p>
<p>todo: 
additional columns (or additonal object) for 'protein names' 
and the total number of features assigned to protein in the master map.
The length should be the same as for how many Ns chosen in the assembly method.
Double check, if 'empty' protein names.. - basically - not assigned features.. 
are also in the list! - get rid of it.
</p>


<h3>Author(s)</h3>

<p>Christian Panse, Jonas Grossmann 2012
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1074/mcp.M500230-MCP200">doi:10.1074/mcp.M500230-MCP200</a>
<a href="https://doi.org/10.1016/j.jprot.2010.05.011">doi:10.1016/j.jprot.2010.05.011</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    data(pgLFQfeature)
    par(mfrow=c(2,4), mar=c(4,4,4,1))
    for (i in c(1, 2, 3, 4)){
        tNpq&lt;-pgLFQtNpq(QuantitativeValue=pgLFQfeature$"Normalized abundance",
            peptide=pgLFQfeature$peptideInfo$Sequence,
            protein=pgLFQfeature$peptideInfo$Protein, 
            N=i)
    }

    for (i in c(1, 2, 3, 4)){
        tNpq&lt;-pgLFQtNpq(QuantitativeValue=pgLFQfeature$"Normalized abundance",
            peptide=pgLFQfeature$peptideInfo$Sequence,
            protein=pgLFQfeature$peptideInfo$Protein, 
            plot=FALSE,
            N=i)

        boxplot(t(tNpq), xlab='proteins', ylab='protein value')
    }
</code></pre>

<hr>
<h2 id='pressureProfile'>NanoLC pressure profile</h2><span id='topic+pressureProfile'></span>

<h3>Description</h3>

<p>pressureProfile is a data frame with a variable number of 
cases (rows) and two variables (columns) named time(min), Pc(psi)
</p>


<h3>Details</h3>

<p>The <code>pressureProfile</code> data set gives the flow profile in nL/min and 
the pressure profile in psi as a function of time, respectively, for 24 
consecutive injections on an Eksigent NanoLC-Ultra 1D plus system.
</p>
<p>The dataset consists of 24 HPLC pressure profiles of 140 min. Data was 
acquired with a Eksigent NanoLC-Ultra 1D plus system. Samples were 
separated with a 100 1E-6m ID. column of 150 mm lenght packed with C-18 
AQ 200A beads (Dr. Maisch GmbH). The column was heated to a temperature 
of 50 grad C during the entire run. Acquisition queue was as follows:
</p>
<p>- A block of three (3) samples with a gradient length of 140 min was 
allways followed a autocalibration run with a gradient length of 25 min.
</p>
<p>- A total of seven (7) such blocks was acquired to cover the entire 
dataset.
</p>


<h3>Author(s)</h3>

<p>Christian Trachsel 2012
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pressureProfile)
ppp(pressureProfile[pressureProfile$filename=="F01",])

par(mfrow=c(1,1))
pps.data&lt;-pps(pressureProfile, time=seq(1,140,by=5))
boxplot(Pc~time, data=pps.data, 
    xlab='time [in minutes]', ylab='Pc(psi)')

library(lattice)
pps.data&lt;-pps(pressureProfile, time=seq(25,40,by=5))
xyplot(Pc ~ as.factor(file) | paste("time =", as.character(time), "minutes"),
    panel = function(x, y){
        m&lt;-sum(y)/length(y)
        m5&lt;-(max(y)-min(y))*0.05
        panel.abline(h=c(m-m5,m,m+m5), col=rep("#ffcccc",3),lwd=c(2,4,2))
        panel.grid(h=-1, v=0)
        panel.xyplot(x, y)
    },
    ylab='Pc [psi]',
    layout=c(1,4),
    sub='The three read lines indicate avg plus min 5%.',
    scales = list(x = list(rot = 45)),
    data=pps.data)

</code></pre>

<hr>
<h2 id='pressureProfilePlot'>Plotting pressure profile data from Eksigent LC pumps</h2><span id='topic+pressureProfilePlot'></span><span id='topic+ppp'></span>

<h3>Description</h3>

<p>plots the pressure profiles data on a scatter plot <code>Pc</code> versus <code>time</code> grouped by time range. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    ppp(data)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pressureProfilePlot_+3A_data">data</code></td>
<td>
<p>A data set like <code>pressureProfile</code>. The data must have an attribute <code>file</code>, <code>time</code>, and <code>Pc</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a useful function to generate an overview over a sequence of measurments run with the same LC gradient. It shows the behaviour of the LC pumps basically the pressures over the whole gradient are plotted to spot sources of problems. 
</p>


<h3>Author(s)</h3>

<p>Bernd Roschitzki, Christian Trachsel, Christian Panse 2012
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    data(pressureProfile)
    ppp(pressureProfile[pressureProfile$filename=="F12",])

</code></pre>

<hr>
<h2 id='pressureProfileSummary'>A misc function for finding NN time slots in pressure profile data.</h2><span id='topic+pressureProfileSummary'></span><span id='topic+pps'></span>

<h3>Description</h3>

<p>The function computes a list of Pc values for the in time provided NN using findNN. 
It returns file, time, timediff and the Pc valyes as list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    pps(data, time)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pressureProfileSummary_+3A_data">data</code></td>
<td>
<p>the data set to be plotted. It reqires the following attributes: <code>Pc, file, time</code>.</p>
</td></tr>
<tr><td><code id="pressureProfileSummary_+3A_time">time</code></td>
<td>
<p>specifies the timeslots to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is useful for levelplots. It can be used to make a quality check over a sequence of experiments. At our site, it is used in conjugtion with Eksigent pumps. These devices store a text file at the instrument pc. These files are preprocessed as specified in the file structure.
</p>


<h3>Author(s)</h3>

<p>Christian Panse 2012
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lattice)
data(pressureProfile)

# do the pre processing
pps.data&lt;-pps(pressureProfile, time=seq(25,40,by=5))

print(xyplot(Pc ~ as.factor(file) | paste("time =", 
    as.character(time), "minutes"),
    panel = function(x, y){
        m&lt;-sum(y)/length(y)
        m5&lt;-(max(y)-min(y))*0.05
        panel.abline(h=c(m-m5,m,m+m5), 
            col=rep("#ffcccc",3),lwd=c(1,2,1))
        panel.grid(h=-1, v=0)
        panel.xyplot(x, y)
    },
    ylab='Pc [psi]',
    layout=c(1,4),
    sub='The three read lines indicate avg plus min 5%.',
    scales = list(x = list(rot = 45)),
    data=pps.data))

</code></pre>

<hr>
<h2 id='psm'>Compute a matching between a peptide sequence and a MS2 spectrum</h2><span id='topic+psm'></span><span id='topic+is.psm'></span><span id='topic+summary.psmSet'></span><span id='topic+as.data.frame.psmSet'></span>

<h3>Description</h3>

<p>The function computes a matching between a given peptide sequence and a given tandem mass spectrum (MS2).
<code><a href="#topic+psm">psm</a></code> determines for each fragment ion mass peak the smallest mass error to a peak in the theretical spectrum from the peptide sequence.
If the mass error is below the given <code>fragmentIonError</code> the match is considered a hit. 
<code>psm</code> returns a list of computed fragment ions and a vector of the mass error (Da and ppm).
<code><a href="#topic+psm">psm</a></code> uses a generic <code>ANSI-C</code> function to determines the nearest mass peak of array of double 
values.
If the <code>plot</code> is set to <code>TRUE</code> an error plot is drawn.
</p>
<p>The function <code>psm</code> reqires the arguments <code>sequence</code> and <code>spec</code>. All other arguments are optional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    psm(sequence, 
        spec, 
        FUN=defaultIon,
        plot=TRUE, 
        fi=fragmentIon(sequence, FUN=FUN)[[1]],
        fragmentIonError)

 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psm_+3A_sequence">sequence</code></td>
<td>
<p>peptide sequence encoded as character sequence using the 20 amino acid letters.</p>
</td></tr>
<tr><td><code id="psm_+3A_spec">spec</code></td>
<td>
<p>MS2 which is a R list having a sorted mZ vector and an intensity vector of the same size.</p>
</td></tr>
<tr><td><code id="psm_+3A_fun">FUN</code></td>
<td>
<p>this function is passed to the <code>fragmentIon</code> function. the function to be applied to compute further ions. If no function is assigned <code><a href="#topic+fragmentIon">fragmentIon</a></code> will
use <code>defaultIon</code>.</p>
</td></tr>
<tr><td><code id="psm_+3A_plot">plot</code></td>
<td>
<p>boolean if the error plot function is to be called.</p>
</td></tr>
<tr><td><code id="psm_+3A_fi">fi</code></td>
<td>
<p>fragment ion table, if not specified <code>fragmentIon(sequence, FUN=FUN)[[1]]</code> is called. </p>
</td></tr>
<tr><td><code id="psm_+3A_fragmentionerror">fragmentIonError</code></td>
<td>
<p>fragment ion error cut-off. default is 0.6 Da. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be very useful to make assignements to spectra. Moreover it is used for validation or clairifying ambiguities between different sequences assigned to the same spectrum. Additinally it can be used to generate spectral libraries.
</p>


<h3>Value</h3>

<p> returns a psm match.</p>


<h3>Author(s)</h3>

<p>Christian Panse 2007, 2008, 2009, 2010, 2012, 2017
</p>


<h3>See Also</h3>

<p><code><a href="#topic+peakplot">peakplot</a></code> and <code><a href="#topic+fragmentIon">fragmentIon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
spec &lt;- list(scans=1138,
    title="178: (rt=22.3807) [20080816_23_fetuin_160.RAW]",
    rtinseconds=1342.8402,
    charge=2,
    mZ=c(195.139940, 221.211970, 239.251780, 290.221750, 
    316.300770, 333.300050, 352.258420, 448.384360, 466.348830, 
    496.207570, 509.565910, 538.458310, 547.253380, 556.173940, 
    560.358050, 569.122080, 594.435500, 689.536940, 707.624790, 
    803.509240, 804.528220, 822.528020, 891.631250, 909.544400, 
    916.631600, 973.702160, 990.594520, 999.430580, 1008.583600, 
    1017.692500, 1027.605900),
    intensity=c(931.8, 322.5, 5045, 733.9, 588.8, 9186, 604.6,
    1593, 531.8, 520.4, 976.4, 410.5, 2756, 2279, 5819, 2.679e+05,
    1267, 1542, 979.2, 9577, 3283, 9441, 1520, 1310, 1.8e+04,
    587.5, 2685, 671.7, 3734, 8266, 3309)
    )

m &lt;- psm('HTLNQIDSVK', spec,plot=TRUE)
hist(m$mZ.Da.error)
hist(m$mZ.ppm.error)

</code></pre>

<hr>
<h2 id='PTM_MarkerFinder'>PTM MarkerFinder</h2><span id='topic+PTM_MarkerFinder'></span><span id='topic+pPTM'></span><span id='topic+findMz'></span><span id='topic+findMz.mascot'></span><span id='topic+findMz.psmSet'></span>

<h3>Description</h3>

<p><code>PTM_MarkerFinder</code> is a fucntion to identify and validate spectra from
peptides carrying post-translational modifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
PTM_MarkerFinder(data,
    modification,
    modificationName,
    mZmarkerIons,
    minNumberIons=2,
    itol_ppm=10,
    minMarkerIntensityRatio=5,
    mgfFilename=-1,
    PEAKPLOT=TRUE
    )

findMz(data, mZmarkerIons, itol_ppm = 10, minNumberIons = 2, minMarkerIntensityRatio = 10)

## S3 method for class 'psmSet'
findMz(data, mZmarkerIons, itol_ppm, minNumberIons, minMarkerIntensityRatio)

## S3 method for class 'mascot'
findMz(data, mZmarkerIons, itol_ppm = 10, minNumberIons = 2, minMarkerIntensityRatio = 10)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PTM_MarkerFinder_+3A_data">data</code></td>
<td>
<p>A list of spectra where each list 
element contains a list of <code>mZ, intensity</code> 
vectors. This object can be received by using the 
<code>mascotDat2RData.pl</code> perl script.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_+3A_modification">modification</code></td>
<td>
<p>A double vector containing the 
mono mass PTMs.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_+3A_modificationname">modificationName</code></td>
<td>
<p>A character vector containing the 
Name of the PTMs. This is the string which will show up in 
the peptide sequence in square brackets.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_+3A_mzmarkerions">mZmarkerIons</code></td>
<td>
<p>The m/z patterns which should be 
searched.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_+3A_minnumberions">minNumberIons</code></td>
<td>
<p>Minimal number of marker ions to 
be found for further analysis.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_+3A_itol_ppm">itol_ppm</code></td>
<td>
<p>The ion tolerance of the marker ions 
in ppm. default is set to 10ppm.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_+3A_minmarkerintensityratio">minMarkerIntensityRatio</code></td>
<td>
<p>The marker ions 
intencity percentage compared to the sum of all peak 
intensities.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_+3A_mgffilename">mgfFilename</code></td>
<td>
<p>if a mgf(mascot generic file) filename is given, 
the function writes an mgf file containing
only the ms2 having the <code>mZmarkerIons</code>.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_+3A_peakplot">PEAKPLOT</code></td>
<td>
<p>If this boolean is <code>FALSE</code> the <code>peakplot</code> function is not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function screens MS2 spectra for the presence of fragment ions specific Post
Translational Modifications (PTMs). The function requires an R-object containing
the mass spectrometric measurement, the peptide assignments, potential
modification information, and a list of marker ions. The R-object can be
retrieved right out of the Mascot Server search result dat files using a perl
script <code>mascotDat2RData.pl</code> which is included in the package's <code>exec/</code> 
directory.
</p>
<p>The functions iterates over each spectrum of the mass spectrometric measurement
and searches for the as input provided marker ions. If a certain number of
marker ions (default is, that two marker ions are required) are found and the
maker ion intensity ratio is higher than a given threshold, the tandem mass
spectrum is considered as HCD scan type and the corresponding ion series are
drawn using the protViz:peakplot methode. Furthermore the function is searching
for the corresponding ETD scan having the same peptide mass
by screening the succeeding scans for ETD spectra. If such a spectrum is found
the peptide spectrum assignment containing the c, z, and y ions is drawn. Note
that the PTM MarkerFinder expects the ETD scan right after the HCD scan. If the
MS protocol changes the PTM MarkerFinder methode has to be adapted.
</p>
<p>For each HCD scan PTM MarkerFinder plots both HCD and ETD scans, a ppm error
versus maker ion m/z scatter plot, a intensity versus marker ion m/z plot, and
two pie charts where the relative and absolute maker ion intensity are shown.
</p>
<p>As a summery report the function returns a table containing the following column
attributes: &quot;scans&quot;, &quot;mZ&quot;, &quot;markerIonMZ&quot;, &quot;markerIonIntensity&quot;,
&quot;markerIonMzError&quot;, &quot;markerIonPpmError&quot;, and &quot;query&quot; which can be used for
statistics.
</p>
<p>Furthermore, if <code>mgfFilename</code> is defined, a Mascot Generic File
(MGF) is created containig the HCD scans (having the marker ions) and the corresponding
ETD scans.
</p>


<h3>Author(s)</h3>

<p>Paolo Nanni, Peter Gehrig, Christian Panse 2011-2013;
</p>


<h3>References</h3>


<ul>
<li><p> Nanni P, Panse C, Gehrig P, Mueller S, Grossmann J, Schlapbach R.(2013),
PTM MarkerFinder, a software tool to detect and validate spectra from 
peptides carrying post-translational modifications.
Proteomics. 2013 Aug;13(15):2251-5.
<a href="https://doi.org/10.1002/pmic.201300036">doi:10.1002/pmic.201300036</a>.
</p>
</li>
<li>  <p><code>ADP_Ribose &lt;- c(136.0618, 250.0935, 348.0704, 428.0367)</code> marker ions have been used in:
Bilan V, Leutert M, Nanni P, Panse C, Hottiger MO.
Combining Higher-Energy Collision Dissociation and Electron-Transfer/Higher-Energy Collision Dissociation Fragmentation in a Product-Dependent Manner Confidently Assigns Proteomewide ADP-Ribose Acceptor Sites,
Anal. Chem., 2017, 89 (3), pp 1523-1530
<a href="https://doi.org/10.1021/acs.analchem.6b03365">doi:10.1021/acs.analchem.6b03365</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+peakplot">peakplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    # some marker ions
    
    Glykan_MarkerIons &lt;- c(109.02841, 127.03897, 145.04954, 163.06010, 325.11292)
    
    HexNAc_MarkerIons &lt;- c(126.05495, 138.05495, 144.06552, 168.06552, 186.07608, 204.08665)

    # DOI: 10.1021/acs.analchem.6b03365
    # Anal Chem 2017 Feb 13;89(3):1523-1530. Epub 2017 Jan 13.
    ADP_Ribose &lt;- c(136.0618, 250.0935, 348.0704, 428.0367)
    
    data(HexNAc)

    # prepare modification
    ptm.0 &lt;- cbind(AA="-",
        mono=0.0, avg=0.0, desc="unmodified", unimodAccID=NA)
      
    ptm.1 &lt;- cbind(AA='N', 
          mono=317.122300, avg=NA, desc="HexNAc",
                  unimodAccID=2)
        
    ptm.2 &lt;- cbind(AA='M',
            mono=147.035400, avg=NA, desc="Oxidation",
                    unimodAccID=1)

    m &lt;- as.data.frame(rbind(ptm.0, ptm.1, ptm.2), stringsAsFactors = TRUE)

    S &lt;- PTM_MarkerFinder(data=HexNAc, modification=m$mono, 
        modificationName=m$desc,
        minMarkerIntensityRatio=3,
        itol_ppm=20,
        mZmarkerIons=HexNAc_MarkerIons) 


    boxplot(markerIonIntensity ~ markerIonMZ,
        data=S,
        log='y',
        main='Summary plot: boxplot of marker ion intensities from all pPTM spectra',
        xlab='markerIon m/z', 
        ylab='log10 based marker ion intensity')

    # export
    w &lt;- reshape(S[,c(1,7,3,4)],
        direction='wide', 
        timevar="markerIonMZ",
	idvar=c('scans','query'))

    write.table(w,
        file=file.path(tempdir(), "HexNAc_PTM_markerFinder.csv"),
        sep=',',
	row.names=FALSE,
	col.names=TRUE,
	quote=FALSE)
</code></pre>

<hr>
<h2 id='PTM_MarkerFinder_util'>PTM MarkerFinder util plot</h2><span id='topic+PTM_MarkerFinder_util'></span>

<h3>Description</h3>

<p><code>PTM_MarkerFinder_util</code> is a utility function for <code>PTM_MarkerFinder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
PTM_MarkerFinder_util(dataFileName, 
    mZmarkerIons,
    minMarkerIntensityRatio,
    minNumberIons,
    itol_ppm,
    write_csv)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PTM_MarkerFinder_util_+3A_datafilename">dataFileName</code></td>
<td>
<p>RData file name without 'RData' ending.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_util_+3A_mzmarkerions">mZmarkerIons</code></td>
<td>
<p>A double vector of the m/z patterns which should be searched.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_util_+3A_minmarkerintensityratio">minMarkerIntensityRatio</code></td>
<td>
<p>The marker ions 
intencity percentage compared to the sum of all peak 
intensities.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_util_+3A_minnumberions">minNumberIons</code></td>
<td>
<p>Minimal number of marker ions to 
be found for further analysis.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_util_+3A_itol_ppm">itol_ppm</code></td>
<td>
<p>The ion tolerance of the marker ions 
in ppm. default is set to 10ppm.</p>
</td></tr>
<tr><td><code id="PTM_MarkerFinder_util_+3A_write_csv">write_csv</code></td>
<td>
<p>boolean.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots summeries in form of boxplots pie charts and scatter plots of the found marker ions.
</p>


<h3>Author(s)</h3>

<p>Paolo Nanni, Christian Panse 2012-2013;
</p>

<hr>
<h2 id='ssrc'>Sequence Specific Retention Calculator</h2><span id='topic+ssrc'></span><span id='topic+hydrophobicity'></span>

<h3>Description</h3>

<p>This function returns as output one hydrophobicity value 
for a given sequence of amino acids (tryptic peptide)
which can be used to predict the retention times.
The calculation is based on the method described in PMID:15238601.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    ssrc(x, H = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssrc_+3A_x">x</code></td>
<td>
<p>sequence of amino acids, e.g., <code>x="ELIVSK"</code></p>
</td></tr>
<tr><td><code id="ssrc_+3A_h">H</code></td>
<td>
<p>A list of retention coefficients. The default is set to the values of PMID:15238601 table II column 2(Rc values).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Panse, Christian Trachsel 2015
</p>


<h3>References</h3>

<p>Krokhin, O. V. et al. An improved model for prediction of retention times of tryptic peptides in ion
pair reversed-phase HPLC: its application to protein peptide mapping by off-line HPLC-MALDI MS.
Mol. Cell Proteomics 3, 908-919 (2004).
<a href="https://doi.org/10.1074/mcp.M400031-MCP200">doi:10.1074/mcp.M400031-MCP200</a>
</p>


<h3>See Also</h3>

 

<ul>
<li> <p><code><a href="#topic+iRTpeptides">iRTpeptides</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
  # example of table iv [PMID:15238601]
  lapply(c("SCHTAVGR", "SCHTGLGR", "EDLIAYLK"), ssrc)
  
  plot(sapply(as.character(iRTpeptides$peptide), ssrc) ~  iRTpeptides$rt)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
