<!DOCTYPE html><html><head><title>Help for package editrules</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {editrules}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#editrules-package'><p>An overview of the function of package <code>editrules</code></p></a></li>
<li><a href='#+5B.editmatrix'><p>Row index operator for <code>editmatrix</code></p></a></li>
<li><a href='#adddummies'><p>Add dummy variable to the data.frames, these are needed for errorlocations etc.</p></a></li>
<li><a href='#adjacency'><p>Derive adjecency matrix from collection of edits</p></a></li>
<li><a href='#as.character.cateditmatrix'><p>Coerce an cateditmatrix to a <code>character</code> vector</p></a></li>
<li><a href='#as.editmatrix'><p>Coerce a matrix to an edit matrix.</p></a></li>
<li><a href='#as.editset'><p>Coerce x to an editset</p></a></li>
<li><a href='#as.lp.mip'><p>Coerces a <code>mip</code> object into an lpsolve object</p></a></li>
<li><a href='#as.mip'><p>Write an editset into a mip representation</p></a></li>
<li><a href='#asLevels'><p>Transform a found solution into a categorical record</p></a></li>
<li><a href='#backtracker'><p>Backtracker: a flexible and generic binary search program</p></a></li>
<li><a href='#blocks'><p>Decompose a matrix or edits into independent blocks</p></a></li>
<li><a href='#cateditmatrix'><p>Create an editmatrix with categorical variables</p></a></li>
<li><a href='#checkDatamodel'><p>Check data against a datamodel</p></a></li>
<li><a href='#condition'><p>Get condition matrix from an editset.</p></a></li>
<li><a href='#contains'><p>Determine which edits contain which variable(s)</p></a></li>
<li><a href='#contains.boolmat'><p>Determine if a boolean matrix contains <code>var</code></p></a></li>
<li><a href='#datamodel'><p>Summarize data model of an editarray in a data.frame</p></a></li>
<li><a href='#disjunct'><p>Decouple a set of conditional edits</p></a></li>
<li><a href='#duplicated.editarray'><p>Check for duplicate edit rules</p></a></li>
<li><a href='#duplicated.editmatrix'><p>Check for duplicate edit rules</p></a></li>
<li><a href='#echelon'><p>Bring an (edit) matrix to reduced row echelon form.</p></a></li>
<li><a href='#editarray'><p>Parse textual, categorical edit rules to an editarray</p></a></li>
<li><a href='#editfile'><p>Read edits edits from free-form textfile</p></a></li>
<li><a href='#editmatrix'><p>Create an editmatrix</p></a></li>
<li><a href='#editnames'><p>Names of edits</p></a></li>
<li><a href='#editrules.plotting'><p>Graphical representation of edits</p></a></li>
<li><a href='#edits'><p>Example editrules, used in vignette</p></a></li>
<li><a href='#editset'><p>Read general edits</p></a></li>
<li><a href='#editType'><p>Determine edittypes in editset based on 'contains(E)'</p></a></li>
<li><a href='#eliminate'><p>Eliminate a variable from a set of edit rules</p></a></li>
<li><a href='#errorLocalizer'><p>Create a backtracker object for error localization</p></a></li>
<li><a href='#errorLocalizer_mip'><p>Localize errors using a MIP approach.</p></a></li>
<li><a href='#errorLocation'><p>The errorLocation object</p></a></li>
<li><a href='#expandEdits'><p>Expand an edit expression</p></a></li>
<li><a href='#fcf.env'><p>Field code forest algorithm</p></a></li>
<li><a href='#generateEdits'><p>Derive all essentially new implicit edits</p></a></li>
<li><a href='#getA'><p>Returns the coefficient matrix <code>A</code> of linear (in)equalities</p></a></li>
<li><a href='#getAb'><p>Returns augmented matrix representation of edit set.</p></a></li>
<li><a href='#getArr'><p>Get named logical array from editarray</p></a></li>
<li><a href='#getb'><p>Returns the constant part <code>b</code> of a linear (in)equality</p></a></li>
<li><a href='#getH'><p>Returns the derivation history of an edit matrix or array</p></a></li>
<li><a href='#getInd'><p>get index list from editmatrix</p></a></li>
<li><a href='#getlevels'><p>retrieve level names from editarray</p></a></li>
<li><a href='#getnames'><p>retrieve edit names from editarray</p></a></li>
<li><a href='#getOps'><p>Returns the operator part of a linear (in)equality <code>editmatrix</code> E</p></a></li>
<li><a href='#getSep'><p>get seprator used to seperate variables from levels in editarray</p></a></li>
<li><a href='#getUpperBounds'><p>Get upperbounds of edits, given the boundaries of all variables</p></a></li>
<li><a href='#getVars'><p>get names of variables in a set of edits</p></a></li>
<li><a href='#getVars.cateditmatrix'><p>Returns the variable names of an (in)equality <code>editmatrix</code> E</p></a></li>
<li><a href='#getVars.editarray'><p>get variable names in editarray</p></a></li>
<li><a href='#getVars.editlist'><p>get variable names</p></a></li>
<li><a href='#getVars.editmatrix'><p>Returns the variable names of an (in)equality <code>editmatrix</code> E</p></a></li>
<li><a href='#impliedValues'><p>Retrieve values stricktly implied by rules</p></a></li>
<li><a href='#ind2char'><p>Derive textual representation from (partial) indices</p></a></li>
<li><a href='#indFromArray'><p>Compute index from array part of editarray</p></a></li>
<li><a href='#is.editrules'><p>Check object class</p></a></li>
<li><a href='#isFeasible'><p>Check consistency of set of edits</p></a></li>
<li><a href='#isNormalized'><p>Check if an editmatrix is normalized</p></a></li>
<li><a href='#isObviouslyInfeasible'><p>Check for obvious contradictions in a set of edits</p></a></li>
<li><a href='#isObviouslyRedundant'><p>Find obvious redundancies in set of edits</p></a></li>
<li><a href='#isSubset'><p>Check which edits are dominated by other ones.</p></a></li>
<li><a href='#localize'><p>Workhorse function for localizeErrors</p></a></li>
<li><a href='#localizeErrors'><p>Localize errors on records in a data.frame.</p></a></li>
<li><a href='#nedits'><p>Number of edits</p>
Count the number of edits in a collection of edits.</a></li>
<li><a href='#neweditarray'><p>editarray: logical array where every column corresponds to one</p>
level of one variable. Every row is an edit. Every edit denotes
a *forbidden* combination.</a></li>
<li><a href='#neweditmatrix'><p>Create an <code>editmatrix</code> object from its constituing attributes.</p></a></li>
<li><a href='#newerrorlocation'><p>Generate new errorlocation object</p></a></li>
<li><a href='#normalize'><p>Normalizes an editmatrix</p></a></li>
<li><a href='#parseCat'><p>Parse a categorical edit expression</p></a></li>
<li><a href='#parseCatEdit'><p>parse categorial edit</p></a></li>
<li><a href='#parseEdits'><p>Parse a character vector of edits</p></a></li>
<li><a href='#parseMix'><p>Parse a mixed edit</p></a></li>
<li><a href='#parseNum'><p>Parse a numerical edit expression</p></a></li>
<li><a href='#print.backtracker'><p>print a backtracker</p></a></li>
<li><a href='#print.cateditmatrix'><p>print cateditmatrix</p></a></li>
<li><a href='#print.editarray'><p>print  editarray</p></a></li>
<li><a href='#print.editlist'><p>print editset</p></a></li>
<li><a href='#print.editmatrix'><p>print editmatrix</p></a></li>
<li><a href='#print.editset'><p>print editset</p></a></li>
<li><a href='#print.editsummary'><p>summary</p></a></li>
<li><a href='#print.errorLocation'><p>Print object of class errorLocation</p></a></li>
<li><a href='#print.locationsummary'><p>summary</p></a></li>
<li><a href='#print.violatedEdits'><p>Print violatedEdits</p></a></li>
<li><a href='#reduce'><p>Remove redundant variables and edits.</p></a></li>
<li><a href='#removeRedundantDummies'><p>Remove redundant dummy variables</p></a></li>
<li><a href='#separate'><p>Separate an editset into its disconnected blocks and simplify</p></a></li>
<li><a href='#simplify'><p>Simplify logical mixed edits in an editset</p></a></li>
<li><a href='#softEdits'><p>Derive editmatrix with soft constraints based on boundaries of variables. This is a utility function that is used for</p>
constructing a mip/lp problem.</a></li>
<li><a href='#softEdits.cateditmatrix'><p>Derive editmatrix with soft constraints. This is a utility function that is used for</p>
constructing a mip/lp problem.</a></li>
<li><a href='#softEdits.editarray'><p>Derive editmatrix with soft constraints based on boundaries of variables. This is a utility function that is used for</p>
constructing a mip/lp problem.</a></li>
<li><a href='#softEdits.editmatrix'><p>Derive editmatrix with soft constraints based on boundaries of variables. This is a utility function that is used for</p>
constructing a mip/lp problem.</a></li>
<li><a href='#substValue'><p>Replace a variable by a value in a set of edits.</p></a></li>
<li><a href='#violatedEdits'><p>Check data against constraints</p></a></li>
<li><a href='#writeELAsMip'><p>Rewrite an editset and reported values into the components needed for a mip solver</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Edwin de Jonge &lt;edwindjonge@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Parsing, Applying, and Manipulating Data Cleaning Rules</td>
</tr>
<tr>
<td>LazyData:</td>
<td>no</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Edwin de Jonge, Mark van der Loo</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates reading and manipulating (multivariate) data restrictions
    (edit rules) on numerical and categorical data. Rules can be defined with common R syntax
    and parsed to an internal (matrix-like format). Rules can be manipulated with
    variable elimination and value substitution methods, allowing for feasibility checks
    and more. Data can be tested against the rules and erroneous fields can be found based
    on Fellegi and Holt's generalized principle. Rules dependencies can be visualized with 
    using the 'igraph' package.</td>
</tr>
<tr>
<td>Version:</td>
<td>2.9.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.12.0), igraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>lpSolveAPI</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/data-cleaning/editrules">https://github.com/data-cleaning/editrules</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/data-cleaning/editrules/issues">https://github.com/data-cleaning/editrules/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'adjacency.R' 'as.igraph.R' 'editset.R' 'editarray.R'
'editmatrix.R' 'as.matrix.R' 'backtracker.R' 'blocks.R' 'c.R'
'cateditmatrix.R' 'checkDatamodel.R' 'checkRows.R' 'contains.R'
'disjunct.R' 'duplicated.R' 'echelon.R' 'editAttr.R'
'editarrayAttr.R' 'editfile.R' 'editmatrixAttr.R'
'editrules-data.R' 'eliminate.R' 'errorLocalizer.R'
'errorLocalizer_mip.R' 'errorLocation.R' 'expandEdits.R'
'generateEdits.R' 'getH.R' 'getUpperBounds.R' 'getVars.R'
'is.R' 'isFeasible.R' 'isObviouslyInfeasible.R'
'isObviouslyRedundant.R' 'isSubset.R' 'list2env.R'
'localizeErrors.R' 'mip.R' 'parseCat.R' 'parseEdits.R'
'parseMix.R' 'parseNum.R' 'perturbWeights.R' 'pkg.R' 'plot.R'
'plot_errorLocation.R' 'print.R' 'reduce.R' 'removeRedundant.R'
'softEdits.R' 'str.R' 'subsetting.R' 'substValue.R' 'summary.R'
'violatedEdits.R' 'writeELAsMip.R' 'zzz.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-01 21:06:29 UTC; edwin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-01 21:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='editrules-package'>An overview of the function of package <code>editrules</code></h2><span id='topic+editrules-package'></span>

<h3>Description</h3>

<p>The <code>editrules</code> package aims to provide an environment to conveniently
define, read and check recordwise data constraints including 
</p>

<ul>
<li><p>Linear (in)equality constraints for numerical data,
</p>
</li>
<li><p>Constraints on value combinations of categorical data
</p>
</li>
<li><p>Conditional constraints on numerical and/or mixed data
</p>
</li></ul>

<p>In literature these constraints, or restrictions are refered to as &ldquo;edits&rdquo;. 
<code>editrules</code> can perform common rule
set manipulations like variable elimination and value substitution, and 
offers error localization functionality based on the
(generalized) paradigm of Fellegi and Holt. Under this paradigm, one determines
the smallest (weighted) number of variables to adapt such that no (additional or derived) 
rules are violated. The paradigm is based on the assumption that errors
are distributed randomly over the variables and there is no detectable cause of
error. It also decouples the detection of corrupt variables from their
correction. For some types of error, such as sign flips, typing errors or
rounding errors, this assumption does not hold. These errors can be detected
and are closely related to their resolution. The reader is referred to the
<span class="pkg">deducorrect</span> package for treating such errors.
</p>


<h3>I. Define edits</h3>

<p><code>editrules</code> provides several methods for creating edits from a <code>character</code>
, <code>expression</code>, <code>data.frame</code> or a text file.
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+editfile">editfile</a></code>     </td><td style="text-align: left;"> Read  conditional numerical, numerical and categorical constraints from textfile </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+editset">editset</a></code>     </td><td style="text-align: left;"> Create conditional numerical, numerical and categorical constraints </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+editmatrix">editmatrix</a></code> </td><td style="text-align: left;"> Create a linear constraint matrix for numerical data </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+editarray">editarray</a></code>  </td><td style="text-align: left;"> Create value combination constraints for categorical data </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>II. Check and find errors in data</h3>

<p><code>editrules</code> provides several method for checking <code>data.frame</code>s with edits
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+violatedEdits">violatedEdits</a></code> </td><td style="text-align: left;"> Find out which record violates which edit. </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+localizeErrors">localizeErrors</a></code>  </td><td style="text-align: left;"> Localize erroneous fields using Fellegi and Holt's principle. </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+errorLocalizer">errorLocalizer</a></code>  </td><td style="text-align: left;"> Low-level error localization function using B&amp;B algorithm </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that you can call <code>plot</code>, <code>summary</code> and <code>print</code>  on results of these functions.
</p>


<h3>IV. Manipulate and check edits</h3>

<p><code>editrules</code> provides several methods for manipulating edits
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+substValue">substValue</a></code> </td><td style="text-align: left;"> Substitute a value in a set of rules </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+eliminate">eliminate</a></code> </td><td style="text-align: left;"> Derive implied rules by variable elimination </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+reduce">reduce</a></code> </td><td style="text-align: left;"> Remove unconstraint variables </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+isFeasible">isFeasible</a></code> </td><td style="text-align: left;"> Check for contradictions </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="base.html#topic+duplicated">duplicated</a></code> </td><td style="text-align: left;"> Find duplicated rules </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+blocks">blocks</a></code> </td><td style="text-align: left;"> Decompose rules into independent blocks </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+disjunct">disjunct</a></code> </td><td style="text-align: left;"> Decouple conditional edits into disjunct edit sets</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+separate">separate</a></code> </td><td style="text-align: left;"> Decompose rules in blocks and decouple conditinal edits </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+generateEdits">generateEdits</a></code> </td><td style="text-align: left;"> Generate all nonredundant implicit edits (<code><a href="#topic+editarray">editarray</a></code> only) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>V. Plot and coerce edits</h3>

<p><code>editrules</code> provides several methods for plotting and coercion.
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+editrules.plotting">editrules.plotting</a></code> </td><td style="text-align: left;"> Plot edit-variable connectivity graph </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="igraph.html#topic+as.igraph">as.igraph</a></code> </td><td style="text-align: left;"> Coerce to edit-variable connectivity <code>igraph</code> object </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>as.character</code> </td><td style="text-align: left;"> Coerce edits to <code>character</code> representation </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>as.data.frame</code> </td><td style="text-align: left;"> Store <code>character</code> representation in <code>data.frame</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<hr>
<h2 id='+5B.editmatrix'>Row index operator for <code>editmatrix</code></h2><span id='topic++5B.editmatrix'></span><span id='topic++5B.cateditmatrix'></span><span id='topic++5B.editarray'></span><span id='topic++5B.editset'></span><span id='topic++5B.editlist'></span>

<h3>Description</h3>

<p>Use this operator to select edits from an editmatrix or editarray object.
</p>
<p>Row index operator for <code>cateditmatrix</code>
</p>
<p>Row index operator for <code>editarray</code>
</p>
<p>Row index operator for <code>editset</code>
Note: the datamodel is not changed
</p>
<p>Index operator for <code>editlist</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editmatrix'
x[i, j, ...]

## S3 method for class 'editarray'
x[i, j, ...]

## S3 method for class 'editarray'
x[i, j, ...]

## S3 method for class 'editset'
x[i, j, ...]

## S3 method for class 'editlist'
x[i, j, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.editmatrix_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+editmatrix">editmatrix</a></code> or <code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
<tr><td><code id="+2B5B.editmatrix_+3A_i">i</code></td>
<td>
<p>the row index in the edit matrix (numeric, logical or rowname)</p>
</td></tr>
<tr><td><code id="+2B5B.editmatrix_+3A_j">j</code></td>
<td>
<p>the column index in the edit matrix</p>
</td></tr>
<tr><td><code id="+2B5B.editmatrix_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods. Currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='adddummies'>Add dummy variable to the data.frames, these are needed for errorlocations etc.</h2><span id='topic+adddummies'></span>

<h3>Description</h3>

<p>Add dummy variable to the data.frames, these are needed for errorlocations etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adddummies(E, dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adddummies_+3A_e">E</code></td>
<td>
<p>editset</p>
</td></tr>
<tr><td><code id="adddummies_+3A_dat">dat</code></td>
<td>
<p>data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with dummy variables added
</p>

<hr>
<h2 id='adjacency'>Derive adjecency matrix from collection of edits</h2><span id='topic+adjacency'></span><span id='topic+adjacency.editmatrix'></span><span id='topic+adjacency.editarray'></span><span id='topic+adjacency.editset'></span><span id='topic+as.igraph.editmatrix'></span><span id='topic+as.igraph.editarray'></span><span id='topic+as.igraph.editset'></span>

<h3>Description</h3>

<p>A set of edits can be represented as a graph where every vertex is
an edit. Two vertices are connected if they have at least one variable
in <code>vars</code> in common.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacency(E, nodetype = c("all", "rules", "vars"), rules = rownames(E),
  vars = getVars(E), ...)

## S3 method for class 'editmatrix'
adjacency(E, nodetype = c("all", "rules", "vars"),
  rules = rownames(E), vars = getVars(E), ...)

## S3 method for class 'editarray'
adjacency(E, nodetype = c("all", "rules", "vars"),
  rules = rownames(E), vars = getVars(E), ...)

## S3 method for class 'editset'
adjacency(E, nodetype = c("all", "rules", "vars"),
  rules = c(rownames(E$num), rownames(E$mixcat)), vars = getVars(E), ...)

## S3 method for class 'editmatrix'
as.igraph(x, nodetype = c("all", "rules", "vars"),
  rules = editnames(x), vars = getVars(x), weighted = TRUE, ...)

## S3 method for class 'editarray'
as.igraph(x, nodetype = c("all", "rules", "vars"),
  rules = editnames(x), vars = getVars(x), weighted = TRUE, ...)

## S3 method for class 'editset'
as.igraph(x, nodetype = c("all", "rules", "vars"),
  rules = editnames(x), vars = getVars(x), weighted = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacency_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editmatrix">editmatrix</a></code>, <code><a href="#topic+editarray">editarray</a></code> or <code><a href="#topic+editset">editset</a></code></p>
</td></tr>
<tr><td><code id="adjacency_+3A_nodetype">nodetype</code></td>
<td>
<p>adjacency between rules, vars or both?</p>
</td></tr>
<tr><td><code id="adjacency_+3A_rules">rules</code></td>
<td>
<p>selection of edits</p>
</td></tr>
<tr><td><code id="adjacency_+3A_vars">vars</code></td>
<td>
<p>selection of variables</p>
</td></tr>
<tr><td><code id="adjacency_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods</p>
</td></tr>
<tr><td><code id="adjacency_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+editmatrix">editmatrix</a></code>, <code><a href="#topic+editarray">editarray</a></code> or <code><a href="#topic+editset">editset</a></code></p>
</td></tr>
<tr><td><code id="adjacency_+3A_weighted">weighted</code></td>
<td>
<p>see <code><a href="igraph.html#topic+graph.adjacency">graph.adjacency</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>adjacency</code> returns the adjacency matrix. The elements of the matrix
count the number of variables shared by the edits indicated in the row- and 
column names. The adjacency matrix can be converted to an igraph object with 
<code>graph.adjacency</code>from the <code>igraph</code> package.
</p>
<p><code>as.igraph</code> converts a set of edits to an <code>igraph</code> object directly.
</p>


<h3>Value</h3>

<p>the adjacency matrix of edits in <code>E</code> with resect to 
the variables in <code>vars</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.editmatrix">plot.editmatrix</a></code>, <code><a href="#topic+plot.editarray">plot.editarray</a></code>, <code><a href="#topic+plot.editset">plot.editset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Examples with linear (in)equality edits

# load predefined edits from package
data(edits)
edits

# convert to editmatrix
E &lt;- editmatrix(edits)

## Not run:
# (Note to reader: the Not run directive only prevents the examle commands from
# running when package is built)

# Total edit graph
plot(E)

# Graph with dependent edits
plot(E, nodetype="rules")

# Graph with dependent variables
plot(E, nodetype="vars")

# Total edit graph, but with curved lines (option from igraph package)
plot(E, edge.curved=TRUE)


# graph, plotting just the connections caused by variable 't'
plot(E,vars='t')

## End(Not run) 

# here's an example with a broken record.
r &lt;- c(ct = 100, ch = 30, cp = 70, p=30,t=130 ) 
violatedEdits(E,r)
errorLocalizer(E,r)$searchBest()$adapt

# we color the violated edits and the variables that have to be adapted

## Not run
set.seed(1) # (for reprodicibility)
plot(E,
     adapt=errorLocalizer(E,r)$searchBest()$adapt,   
     violated=violatedEdits(E,r))
## End(Not run) 



# extract total graph (as igraph object)
as.igraph(E)

# extract graph with edges related to variable 't' and 'ch'
as.igraph(E,vars=c('t','ch'))

# extract total adjacency matrix
adjacency(E)

# extract adjacency matrix related to variables t and 'ch'
adjacency(E,vars=c('t','ch'))

## Examples with categorical edits

# generate an editarray:
E &lt;- editarray(expression(
    age %in% c('&lt;15','16-65','&gt;65'),
    employment %in% c('unemployed','employed','retired'),
    salary %in% c('none','low','medium','high'),
    if (age == '&lt;15') employment=='unemployed',
    if (salary != 'none') employment != 'unemployed',
    if (employment == 'unemployed') salary == 'none'))


## Not run:
# plot total edit graph
plot(E)

# plot with a different layout
plot(E,layout=layout.circle)

# plot edit graph, just the connections caused by 'salary'
plot(E,vars='salary')

## End(Not run)

# extract edit graph
as.igraph(E)

# extract edit graph, just the connections caused by 'salary'
as.igraph(E,vars='salary')

# extract adjacency matrix
adjacency(E)

# extract adjacency matrix, only caused by 'employment'
adjacency(E,vars='employment')





</code></pre>

<hr>
<h2 id='as.character.cateditmatrix'>Coerce an cateditmatrix to a <code>character</code> vector</h2><span id='topic+as.character.cateditmatrix'></span>

<h3>Description</h3>

<p>Derives readable editrules from an editmatrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cateditmatrix'
as.character(x, asIfStatement = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.cateditmatrix_+3A_x">x</code></td>
<td>
<p>cateditmatrix object to be printed</p>
</td></tr>
<tr><td><code id="as.character.cateditmatrix_+3A_asifstatement">asIfStatement</code></td>
<td>
<p>if <code>TRUE</code> the representation will be an <code>if</code> statement.</p>
</td></tr>
<tr><td><code id="as.character.cateditmatrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='as.editmatrix'>Coerce a matrix to an edit matrix.</h2><span id='topic+as.editmatrix'></span>

<h3>Description</h3>

<p><code>as.editmatrix</code> interpretes the matrix as an editmatrix.
The columns of the matrix
are the variables and the rows are the edit rules (contraints).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.editmatrix(A, b = numeric(nrow(A)), ops = rep("==", nrow(A)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.editmatrix_+3A_a">A</code></td>
<td>
<p>matrix to be transformed into an <code><a href="#topic+editmatrix">editmatrix</a></code>.</p>
</td></tr>
<tr><td><code id="as.editmatrix_+3A_b">b</code></td>
<td>
<p>Constant, a <code>numeric</code> of <code>length(nrow(x))</code>, defaults to 0</p>
</td></tr>
<tr><td><code id="as.editmatrix_+3A_ops">ops</code></td>
<td>
<p>Operators, <code>character</code> of <code>length(nrow(x))</code> with the equality operators, defaults to &quot;==&quot;</p>
</td></tr>
<tr><td><code id="as.editmatrix_+3A_...">...</code></td>
<td>
<p>further attributes that will be attached to the resulting editmatrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If only argument <code>x</code> is given (the default), the resulting editmatrix is of the form <code class="reqn">Ax=0</code>. 
This can be influenced by using the parameters <code>b</code> and <code>ops</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>editmatrix</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+editmatrix">editmatrix</a></code>
</p>

<hr>
<h2 id='as.editset'>Coerce x to an editset</h2><span id='topic+as.editset'></span>

<h3>Description</h3>

<p><code>x</code> may be an editset, editmatrix, editarray or character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.editset(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.editset_+3A_x">x</code></td>
<td>
<p>object or vector to be coerced to an editset</p>
</td></tr>
<tr><td><code id="as.editset_+3A_...">...</code></td>
<td>
<p>extra parameters that will be passed to <code>as.character</code>, if necessary</p>
</td></tr>
</table>

<hr>
<h2 id='as.lp.mip'>Coerces a <code>mip</code> object into an lpsolve object</h2><span id='topic+as.lp.mip'></span>

<h3>Description</h3>

<p><code>as.lp.mip</code> transforms a mip object into a lpSolveApi object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.lp.mip(mip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.lp.mip_+3A_mip">mip</code></td>
<td>
<p>object of type <code>mip</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+as.mip">as.mip</a></code>, <code><a href="lpSolveAPI.html#topic+make.lp">make.lp</a></code>
</p>

<hr>
<h2 id='as.mip'>Write an editset into a mip representation</h2><span id='topic+as.mip'></span>

<h3>Description</h3>

<p>Writes an editset or an object coercable to an editset as a mip problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.mip(E, x = NULL, weight = NULL, M = 1e+07, epsilon = 0.001,
  prefix = "delta.", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mip_+3A_e">E</code></td>
<td>
<p>an <code>link{editset}</code> or an object that is coerciable to an 
<code>editset</code></p>
</td></tr>
<tr><td><code id="as.mip_+3A_x">x</code></td>
<td>
<p>named <code>list</code>/<code>vector</code> with variable values</p>
</td></tr>
<tr><td><code id="as.mip_+3A_weight">weight</code></td>
<td>
<p>reliability weights for values of <code>x</code></p>
</td></tr>
<tr><td><code id="as.mip_+3A_m">M</code></td>
<td>
<p>Constant that is used for allowing the values to differ from <code>x</code></p>
</td></tr>
<tr><td><code id="as.mip_+3A_epsilon">epsilon</code></td>
<td>
<p>Constant that is used for converting '&lt;' into '&lt;='</p>
</td></tr>
<tr><td><code id="as.mip_+3A_prefix">prefix</code></td>
<td>
<p>prefix for dummy variables that are created</p>
</td></tr>
<tr><td><code id="as.mip_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mip object containing al information for transforming it 
into an lp/mip problem
</p>

<hr>
<h2 id='asLevels'>Transform a found solution into a categorical record</h2><span id='topic+asLevels'></span>

<h3>Description</h3>

<p>Transform a found solution into a categorical record
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asLevels(x)
</code></pre>

<hr>
<h2 id='backtracker'>Backtracker: a flexible and generic binary search program</h2><span id='topic+backtracker'></span><span id='topic+choicepoint'></span>

<h3>Description</h3>

<p><code>backtracker</code> creates a binary search program that can be started by calling the <code>$searchNext</code> function
It walks a binary tree depth first. For all left nodes <code>choiceLeft</code> is evaluated, for all right nodes 
<code>choiceRight</code> is evaluated. A solution is found if <code>isSolution</code> evaluates to <code>TRUE</code>. 
In that case <code>$searchNext</code> will return all variables in the search environment in a <code>list</code>
If <code>isSolution</code> evaluates to NULL it will continue to search deaper.
If <code>isSolution</code> evaluates to <code>FALSE</code> it stops at the current node and goes up the next search node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backtracker(isSolution, choiceLeft, choiceRight, list = NULL,
  maxdepth = Inf, maxduration = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backtracker_+3A_issolution">isSolution</code></td>
<td>
<p><code>expression</code> that should evaluate to <code>TRUE</code> when a solution is found.</p>
</td></tr>
<tr><td><code id="backtracker_+3A_choiceleft">choiceLeft</code></td>
<td>
<p><code>expression</code> that will be evaluated for a left node</p>
</td></tr>
<tr><td><code id="backtracker_+3A_choiceright">choiceRight</code></td>
<td>
<p><code>expression</code> that will be evaluated for a right node</p>
</td></tr>
<tr><td><code id="backtracker_+3A_list">list</code></td>
<td>
<p><code>list</code> with variables that will be added to the search environment</p>
</td></tr>
<tr><td><code id="backtracker_+3A_maxdepth">maxdepth</code></td>
<td>
<p><code>integer</code> maximum depth of the search tree</p>
</td></tr>
<tr><td><code id="backtracker_+3A_maxduration">maxduration</code></td>
<td>
<p><code>integer</code> Default maximum search time for <code>$searchNext()</code> and <code>$searchAll()</code></p>
</td></tr>
<tr><td><code id="backtracker_+3A_...">...</code></td>
<td>
<p>named variables that will be added to the search environment</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Methods</h4>


<dl>
<dt><code>$searchNext(..., VERBOSE=FALSE)</code></dt><dd><p>Search next solution, can
be called repeatedly until there is no solution left. Named variables will be
added to the search environment, this feature can be used to direct the search
in subsequent calls to <code>searchNext</code>. VERBOSE=TRUE will print all
intermediate search steps and results. It can be used to debug the expressions
in the backtracker</p>
</dd>
<dt><code>$searchAll(..., VERBOSE=FALSE)</code></dt><dd><p>Return all solutions as a list</p>
</dd>
<dt><code>$reset()</code></dt><dd><p>Resets the <code>backtracker</code> to its initial state.</p>
</dd>
</dl>




<h3>Value</h3>

<p>backtracker object, see Methods for a description of the methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bt &lt;- backtracker( isSolution= { 
                                 if (y == 0) return(TRUE)
                                 if (x == 0) return(FALSE)
                               }
                 , choiceLeft = { x &lt;- x - 1; y &lt;- y}
                 , choiceRight = { y &lt;- y - 1; x &lt;- x}
                 # starting values for x and y
                 , x=2
                 , y=1
                 )

bt$searchNext(VERBOSE=TRUE)
bt$searchNext(VERBOSE=TRUE)

# next search will return NULL because there is no more solution
bt$searchNext()

bt$reset()




</code></pre>

<hr>
<h2 id='blocks'>Decompose a matrix or edits into independent blocks</h2><span id='topic+blocks'></span><span id='topic+blockIndex'></span>

<h3>Description</h3>

<p><code>blocks</code> returns a <code>list</code> of independent blocks <code class="reqn">M_i</code> such that
<code class="reqn">M=M_1\oplus M_2\oplus\cdots\oplus M_n</code>.
</p>
<p><code>blockIndex</code> returns a list of row indices in a <code>logical</code> matrix <code>D</code> designating independent blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocks(M)

blockIndex(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blocks_+3A_m">M</code></td>
<td>
<p><code>matrix</code>, <code><a href="#topic+editmatrix">editmatrix</a></code>, editarray or editset to be decomposed into independent blocks</p>
</td></tr>
<tr><td><code id="blocks_+3A_d">D</code></td>
<td>
<p>matrix of type <code>logical</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of independent subobjects of <code>M</code>.
</p>
<p><code>list</code> of row indices in <code>D</code> indicating independent blocks.
Empty rows (i.e. every column <code>FALSE</code>) are ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three seperate blocks
E &lt;- editmatrix( expression( 
  x1 + x2 == x3,
  x3 + x4 == x5,
  x5 + x6 == x7,
  y1 + y2 == y3,
  z1 + z2 == z3
))
blocks(E)

# four seperate blocks
E &lt;- editmatrix(expression( 
  x1 + x2 == x3,
  x3 + x4 == x5,
  x8 + x6 == x7,
  y1 + y2 == y3,
  z1 + z2 == z3
))
blocks(E)

# two categorical blocks
E &lt;- editarray(expression(
 x %in% c('a','b','c'),
 y %in% c('d','e'),
 z %in% c('f','g'),
 u %in% c('w','t'),
 if ( x == 'a') y != 'd',
 if ( z == 'f') u != 'w'
))
blocks(E)


</code></pre>

<hr>
<h2 id='cateditmatrix'>Create an editmatrix with categorical variables</h2><span id='topic+cateditmatrix'></span>

<h3>Description</h3>

<p><code>cateditmatrix</code> is an alternative representation of a categorial edit. 
The default representation in editrules is <code><a href="#topic+editarray">editarray</a></code>, but cateditmatrix is useful for
transforming and solving categorical edit into a mixed integer programming problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cateditmatrix(x, sep = ":", env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cateditmatrix_+3A_x">x</code></td>
<td>
<p><code>character or expression</code> with categorical edits</p>
</td></tr>
<tr><td><code id="cateditmatrix_+3A_sep">sep</code></td>
<td>
<p>seperator to be used in naming categories within variables.</p>
</td></tr>
<tr><td><code id="cateditmatrix_+3A_env">env</code></td>
<td>
<p>environment in which <code>x</code> will be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cateditmatrix object, which is a specialized <code><a href="#topic+editmatrix">editmatrix</a></code>
</p>

<hr>
<h2 id='checkDatamodel'>Check data against a datamodel</h2><span id='topic+checkDatamodel'></span>

<h3>Description</h3>

<p>Categorical variables in <code>dat</code> which also occur in <code>E</code> are checked against the datamodel for 
those variables. Numerical variables are checked against edits in <code>E</code> that contain only a single
variable (e.g. <code class="reqn">x &gt; 0</code>). Values violating such edits as well as empty values are set to adapt.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDatamodel(E, dat, weight = rep(1, ncol(dat)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkDatamodel_+3A_e">E</code></td>
<td>
<p>an object of class <code><a href="#topic+editset">editset</a></code>, <code><a href="#topic+editarray">editarray</a></code>, or <code><a href="#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
<tr><td><code id="checkDatamodel_+3A_dat">dat</code></td>
<td>
<p>a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="checkDatamodel_+3A_weight">weight</code></td>
<td>
<p>vector of weigths for every variable of <code>dat</code> or an array of weight of the same dimensions as <code>dat</code>.</p>
</td></tr>
<tr><td><code id="checkDatamodel_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+errorLocation">errorLocation</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+errorLocation">errorLocation</a></code>, <code><a href="#topic+localizeErrors">localizeErrors</a></code>.
</p>

<hr>
<h2 id='condition'>Get condition matrix from an editset.</h2><span id='topic+condition'></span>

<h3>Description</h3>

<p>Get condition matrix from an editset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condition_+3A_e">E</code></td>
<td>
<p>an <code><a href="#topic+editset">editset</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="#topic+editmatrix">editmatrix</a></code>, holding conditions under which the editset is relevant.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+disjunct">disjunct</a></code>, <code><a href="#topic+separate">separate</a></code>, <code><a href="#topic+editset">editset</a></code>
</p>

<hr>
<h2 id='contains'>Determine which edits contain which variable(s)</h2><span id='topic+contains'></span><span id='topic+contains.matrix'></span><span id='topic+contains.editmatrix'></span><span id='topic+contains.editarray'></span><span id='topic+contains.cateditmatrix'></span><span id='topic+contains.editset'></span>

<h3>Description</h3>

<p>For an <code><a href="#topic+editmatrix">editmatrix</a></code>, variables with coefficients smaller than
<code>tol</code> are considered not to be contained in an edit.
</p>
<p>matrix method for contains
</p>
<p>editmatrix method for contains
</p>
<p>contains method for editarray
</p>
<p>contains method for cateditmatrix
</p>
<p>contains method for editset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contains(E, var = NULL, ...)

## S3 method for class 'matrix'
contains(E, var = NULL, tol = sqrt(.Machine$double.eps),
  ...)

## S3 method for class 'editmatrix'
contains(E, var = NULL,
  tol = sqrt(.Machine$double.eps), ...)

## S3 method for class 'editarray'
contains(E, var = NULL, ...)

## S3 method for class 'editset'
contains(E, var = NULL, ...)

## S3 method for class 'editset'
contains(E, var = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contains_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editarray">editarray</a></code>, <code><a href="#topic+editmatrix">editmatrix</a></code>, <code><a href="#topic+editset">editset</a></code>, or <code>matrix</code></p>
</td></tr>
<tr><td><code id="contains_+3A_var">var</code></td>
<td>
<p><code>character</code>, names of a categorical variables in <code>E</code>. If var=NULL, all variables are treated.</p>
</td></tr>
<tr><td><code id="contains_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods</p>
</td></tr>
<tr><td><code id="contains_+3A_tol">tol</code></td>
<td>
<p>tolerance to check zero-entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code> vector of length nrow(E), TRUE for edits containing <code>var</code>
</p>

<hr>
<h2 id='contains.boolmat'>Determine if a boolean matrix contains <code>var</code></h2><span id='topic+contains.boolmat'></span>

<h3>Description</h3>

<p>Determine if a boolean matrix contains <code>var</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boolmat'
contains(A, ind, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contains.boolmat_+3A_a">A</code></td>
<td>
<p>array</p>
</td></tr>
<tr><td><code id="contains.boolmat_+3A_ind">ind</code></td>
<td>
<p>index</p>
</td></tr>
<tr><td><code id="contains.boolmat_+3A_var">var</code></td>
<td>
<p>variable name</p>
</td></tr>
</table>

<hr>
<h2 id='datamodel'>Summarize data model of an editarray in a data.frame</h2><span id='topic+datamodel'></span>

<h3>Description</h3>

<p>Summarize data model of an editarray in a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datamodel(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datamodel_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> describing the categorical variables and their levels.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkDatamodel">checkDatamodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
E &lt;- editarray(expression(
    age %in% c('under aged','adult'),
    positionInHouseholda  %in% c('marriage partner', 'child', 'other'),
    maritalStatus %in% c('unmarried','married','widowed','divorced'),
    if (maritalStatus %in% c('married','widowed','divorced') ) positionInHousehold != 'child',
    if ( age == 'under aged') maritalStatus == 'unmarried'
    )
)
datamodel(E)
</code></pre>

<hr>
<h2 id='disjunct'>Decouple a set of conditional edits</h2><span id='topic+disjunct'></span>

<h3>Description</h3>

<p>An editset is transformed to a list of <code><a href="#topic+editset">editset</a>s</code> 
which do not contain any conditional numeric/categorical edits anymore. Each <code><a href="#topic+editset">editset</a></code> gains an
attribute <code><a href="#topic+condition">condition</a></code>, which holds the series of assumptions made to 
decouple the original edits. This attribute will be printed when not <code>NULL</code>. Warning: this may be slow
for large, highly entangled sets of edits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disjunct(E, type = c("list", "env"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disjunct_+3A_e">E</code></td>
<td>
<p>Object of class <code><a href="#topic+editset">editset</a></code></p>
</td></tr>
<tr><td><code id="disjunct_+3A_type">type</code></td>
<td>
<p>Return type: <code>list</code> (default) for <code>editlist</code>, <code>env</code> for <code>editenv</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>editlist</code> (<code>editenv</code>), which is nothing more than a <code>list</code> (<code>environment</code>) of 
<code>editsets</code> with a class attribute. Each element has an attribute 'condition' showing which conditions 
were assumed to derive the editset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+separate">separate</a></code>, <code><a href="#topic+condition">condition</a></code>, <code><a href="#topic+blocks">blocks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

E &lt;- editset(expression(
    x + y == z,
    if ( x &gt; 0 ) y &gt; 0,
    x &gt;= 0,
    y &gt;= 0,
    z &gt;= 0,
    A %in% letters[1:4],
    B %in% letters[1:4],
    if (A %in% c('a','b')) y &gt; 0,
    if (A == 'c' ) B %in% letters[1:3]
))

disjunct(E)




</code></pre>

<hr>
<h2 id='duplicated.editarray'>Check for duplicate edit rules</h2><span id='topic+duplicated.editarray'></span>

<h3>Description</h3>

<p>Check for duplicate edit rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editarray'
duplicated(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicated.editarray_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
<tr><td><code id="duplicated.editarray_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='duplicated.editmatrix'>Check for duplicate edit rules</h2><span id='topic+duplicated.editmatrix'></span>

<h3>Description</h3>

<p>Check for duplicate edit rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editmatrix'
duplicated(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicated.editmatrix_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
<tr><td><code id="duplicated.editmatrix_+3A_...">...</code></td>
<td>
<p>options to be passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector
</p>

<hr>
<h2 id='echelon'>Bring an (edit) matrix to reduced row echelon form.</h2><span id='topic+echelon'></span><span id='topic+echelon.editmatrix'></span><span id='topic+echelon.matrix'></span><span id='topic+echelon.editmatrix'></span><span id='topic+echelon.matrix'></span><span id='topic+echelon.editset'></span>

<h3>Description</h3>

<p>If <code>E</code> is a matrix, a matrix in reduced row echelon form is returned.
If <code>E</code> is an <code><a href="#topic+editmatrix">editmatrix</a></code> the equality part of <code>E</code> is transformed
to reduced row echelon form. For an <code><a href="#topic+editset">editset</a></code>, the numerical part is
transformed to reduced row echelon form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>echelon(E, ...)

## S3 method for class 'editmatrix'
echelon(E, ...)

## S3 method for class 'matrix'
echelon(E, tol = sqrt(.Machine$double.eps), ...)

## S3 method for class 'editset'
echelon(E, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="echelon_+3A_e">E</code></td>
<td>
<p>a matrix or editmatrix</p>
</td></tr>
<tr><td><code id="echelon_+3A_...">...</code></td>
<td>
<p>options to pass on to further methods.</p>
</td></tr>
<tr><td><code id="echelon_+3A_tol">tol</code></td>
<td>
<p>tolerance that will be used to determine if a coefficient equals zero.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+eliminate">eliminate</a></code>, <code><a href="#topic+substValue">substValue</a></code>
</p>

<hr>
<h2 id='editarray'>Parse textual, categorical edit rules to an editarray</h2><span id='topic+editarray'></span><span id='topic+as.character.editarray'></span><span id='topic+as.data.frame.editarray'></span><span id='topic+as.expression.editarray'></span><span id='topic+as.matrix.editarray'></span><span id='topic+c.editarray'></span><span id='topic+summary.editarray'></span>

<h3>Description</h3>

<p>An <code>editarray</code> is a boolean array (with some extra attributes) 
where each row contains an edit restriction on purely categorical data. 
The function <code>editarray</code> converts (a vector of) edit(s)
in <code>character</code> or <code>expression</code> from to an <code>editarray</code> object. 
Edits may also be read from a <code><a href="base.html#topic+data.frame">data.frame</a></code>, in which case it must have at least
a <code>character</code> column  with the name <code>edit</code>. It is not 
strictly necessary, but hightly recommended that the datamodel (i.e. the possible levels
for a variable) is included explicitly in the edits using an <code>%in%</code> statement, as shown
in the examples below. The function <code><a href="#topic+editfile">editfile</a></code> can read categorical edits from a 
free-form text file.
</p>
<p>Convert to character
</p>
<p>convert to data.frame
</p>
<p>Convert to expression
</p>
<p>convert to matrix
</p>
<p>Combine editarrays
</p>
<p>summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editarray(editrules, sep = ":", env = parent.frame())

## S3 method for class 'editarray'
as.character(x, useIf = TRUE, datamodel = TRUE, ...)

## S3 method for class 'editarray'
as.data.frame(x, ...)

## S3 method for class 'editarray'
as.expression(x, ...)

## S3 method for class 'editarray'
as.matrix(x, ...)

## S3 method for class 'editarray'
c(...)

## S3 method for class 'editarray'
summary(object, useBlocks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editarray_+3A_editrules">editrules</code></td>
<td>
<p><code>character</code> or <code>expression</code> vector.</p>
</td></tr>
<tr><td><code id="editarray_+3A_sep">sep</code></td>
<td>
<p>textual separator, to be used internally for separating variable from category names.</p>
</td></tr>
<tr><td><code id="editarray_+3A_env">env</code></td>
<td>
<p>environment to evaluate the rhs of '==' or '%in%' in.</p>
</td></tr>
<tr><td><code id="editarray_+3A_x">x</code></td>
<td>
<p>editarray object</p>
</td></tr>
<tr><td><code id="editarray_+3A_useif">useIf</code></td>
<td>
<p><code>logical</code>. Use if( &lt;condition&gt; ) &lt;statement&gt; or !&lt;condition&gt; | &lt;statement&gt; ?</p>
</td></tr>
<tr><td><code id="editarray_+3A_datamodel">datamodel</code></td>
<td>
<p><code>logical</code>. Include datamodel explicitly?</p>
</td></tr>
<tr><td><code id="editarray_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="editarray_+3A_object">object</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="editarray_+3A_useblocks">useBlocks</code></td>
<td>
<p><code>logical</code> Summarize each block?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>editarray</code> : An object of class <code>editarray</code>
</p>
<p><code>as.data.frame</code>: <code>data.frame</code> with columns 'name', 'edit' and 'description'.
</p>
<p><code>as.matrix</code>: The boolean matrix part of the <code>editarray</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+editrules.plotting">editrules.plotting</a></code>, <code><a href="#topic+violatedEdits">violatedEdits</a></code>, <code><a href="#topic+localizeErrors">localizeErrors</a></code>,
<code><a href="#topic+editfile">editfile</a></code>, <code><a href="#topic+editset">editset</a></code>, <code><a href="#topic+editmatrix">editmatrix</a></code>, <code><a href="#topic+getVars">getVars</a></code>,
<code><a href="#topic+blocks">blocks</a></code>, <code><a href="#topic+eliminate">eliminate</a></code>, <code><a href="#topic+substValue">substValue</a></code>, <code><a href="#topic+isFeasible">isFeasible</a></code> 
<code><a href="#topic+generateEdits">generateEdits</a></code>, <code><a href="#topic+contains">contains</a></code>, <code><a href="#topic+is.editarray">is.editarray</a></code>, <code><a href="#topic+isSubset">isSubset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Here is the prototypical categorical edit: men cannot be pregnant.
E &lt;- editarray(expression(
    gender %in% c('male','female'),
    pregnant %in% c('yes','no'),
    if( gender == 'male' ) pregnant == 'no'
    )
)
E

# an editarray has a summary method:
summary(E)

# A yes/no variable may also be modeled as a logical:
editarray(expression(
    gender %in% c('male','female'),
    pregnant %in% c(TRUE, FALSE),
    if( gender == 'male' ) pregnant == FALSE
    )
)

# or, shorter (and using a character vector as input): 
editarray(expression(
    gender %in% c('male','female'),
    pregnant %in% c(TRUE, FALSE),
    if( gender == 'male' ) !pregnant
    )
)

# the \%in\% statement may be used at will
editarray(expression(
    gender %in% c('male','female'),
    pregnant %in% c(TRUE, FALSE),
    positionInHousehold %in% c('marriage partner', 'child', 'other'),
    maritalStatus %in% c('unmarried','married','widowed','divorced'),
    if( gender == 'male' ) !pregnant,
    if( maritalStatus %in% c(
          'unmarried',
          'widowed',
          'divorced')
      ) !positionInHousehold %in% c('marriage partner','child')
    )
)





# Here is the prototypical categorical edit: men cannot be pregnant.
E &lt;- editarray(expression(
    gender %in% c('male','female'),
    pregnant %in% c('yes','no'),
    if( gender == 'male' ) pregnant == 'no'
    )
)
E

# an editarray has a summary method:
summary(E)

# A yes/no variable may also be modeled as a logical:
editarray(expression(
    gender %in% c('male','female'),
    pregnant %in% c(TRUE, FALSE),
    if( gender == 'male' ) pregnant == FALSE
    )
)

# or, shorter (and using a character vector as input): 
editarray(expression(
    gender %in% c('male','female'),
    pregnant %in% c(TRUE, FALSE),
    if( gender == 'male' ) !pregnant
    )
)

# the \%in\% statement may be used at will
editarray(expression(
    gender %in% c('male','female'),
    pregnant %in% c(TRUE, FALSE),
    positionInHousehold %in% c('marriage partner', 'child', 'other'),
    maritalStatus %in% c('unmarried','married','widowed','divorced'),
    if( gender == 'male' ) !pregnant,
    if( maritalStatus %in% c(
          'unmarried',
          'widowed',
          'divorced')
      ) !positionInHousehold %in% c('marriage partner','child')
    )
)




</code></pre>

<hr>
<h2 id='editfile'>Read edits edits from free-form textfile</h2><span id='topic+editfile'></span>

<h3>Description</h3>

<p>This utility function allows for free editrule definition in a file. One can extract
only the numerical (<code>type='num'</code>), only the categorical (<code>type='cat'</code>) or all
edits (default) in which case an <code><a href="#topic+editset">editset</a></code> is returned. 
The function first parses all assignments in the file, so it is possible to compute or read
a list of categories defining a datamodel for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editfile(file, type = c("all", "num", "cat", "mix"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editfile_+3A_file">file</code></td>
<td>
<p>name of text file to read in</p>
</td></tr>
<tr><td><code id="editfile_+3A_type">type</code></td>
<td>
<p>type of edits to extract. Currently, only 'num' (numerical), 'cat' (categorical)  and 'all' are implemented.</p>
</td></tr>
<tr><td><code id="editfile_+3A_...">...</code></td>
<td>
<p>extra parameters that are currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+editset">editset</a></code> with all edits if <code>type=all</code>, <code><a href="#topic+editarray">editarray</a></code> if <code>type='cat'</code>, 
<code><a href="#topic+editmatrix">editmatrix</a></code> if <code>type='num'</code>, <code><a href="#topic+editset">editset</a></code> with conditional edits if <code>type='mix'</code>. 
If the return value is a <code>list</code>, the elements are named <code>numedits</code> and <code>catedits</code>.
</p>

<hr>
<h2 id='editmatrix'>Create an editmatrix</h2><span id='topic+editmatrix'></span><span id='topic+as.data.frame.editmatrix'></span><span id='topic+as.character.editmatrix'></span><span id='topic+as.expression.editmatrix'></span><span id='topic+as.matrix.editmatrix'></span><span id='topic+c.editmatrix'></span><span id='topic+str.editmatrix'></span><span id='topic+summary.editmatrix'></span>

<h3>Description</h3>

<p>An <code>editmatrix</code> is a numerical matrix and a set of comparison operators representing
a linear system of (in)equations.  
The function <code>editmatrix</code> generates an editmatrix from a <code>character</code> vector, an <code>expression</code>
vector or a <code>data.frame</code> with at least the column <code>edit</code>. The function <code><a href="#topic+editfile">editfile</a></code> 
reads edits from a free-form textfile, function <code><a href="#topic+as.editmatrix">as.editmatrix</a></code> converts a matrix, a vector of
constants and a vector of operators to an <code>editmatrix</code>
</p>
<p>convert to matrix
</p>
<p>Combine editmatrices
</p>
<p>summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editmatrix(editrules, normalize = TRUE)

## S3 method for class 'editmatrix'
as.data.frame(x, ...)

## S3 method for class 'editmatrix'
as.character(x, ...)

## S3 method for class 'editmatrix'
as.expression(x, ...)

## S3 method for class 'editmatrix'
as.matrix(x, ...)

## S3 method for class 'editmatrix'
c(...)

## S3 method for class 'editmatrix'
str(object, ...)

## S3 method for class 'editmatrix'
summary(object, useBlocks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editmatrix_+3A_editrules">editrules</code></td>
<td>
<p>A <code>character</code> or <code>expression</code> vecotr with (in)equalities written in R syntax.
Alternatively, a <code>data.frame</code> with a column named <code>edits</code>, see details.</p>
</td></tr>
<tr><td><code id="editmatrix_+3A_normalize">normalize</code></td>
<td>
<p><code>logical</code> specifying if all edits should be transformed (see description)</p>
</td></tr>
<tr><td><code id="editmatrix_+3A_x">x</code></td>
<td>
<p>editmatrix object</p>
</td></tr>
<tr><td><code id="editmatrix_+3A_...">...</code></td>
<td>
<p>Arguments to pass to or from other methods</p>
</td></tr>
<tr><td><code id="editmatrix_+3A_object">object</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="editmatrix_+3A_useblocks">useBlocks</code></td>
<td>
<p><code>logical</code> Summarize each block?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the <code>editmatrix</code> is normalized, meaning that all comparison operators are converted
to one of <code>&lt;</code>, <code>&lt;=</code>, or <code>==</code>. Users may specify edits using any of the operators
<code>&lt;, &lt;=, ==, &gt;=, &gt;</code> (see examples below). However it is highly recommended to let <code>editmatrix</code> parse them into normal
form as all functions operating on editmatrices expect or convert it to normal form anyway.
</p>


<h3>Value</h3>

<p><code>editmatrix</code> : An object of class <code>editmatrix</code>
</p>
<p><code>as.data.frame</code> a 3-column <code>data.frame</code> with columns 'name' and 'edit'. 
If the input editmatrix has a <code>description</code> attribute a third column is returned.
</p>
<p><code>as.matrix</code>: Augmented <code>matrix</code> of <code>editmatrix</code>. (See also <code><a href="#topic+getAb">getAb</a></code>).
</p>


<h3>Note</h3>

<p>since version 2.0-0, the behaviour of <code>as.data.frame.editmatrix</code> changed to be more symmetrical 
with <code>editmatrix.data.frame</code> and <code>as.data.frame.editarray</code>. 
Use <code>editrules:::toDataFrame</code> (unsupported) for the old behaviour.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+editrules.plotting">editrules.plotting</a></code>, <code><a href="#topic+violatedEdits">violatedEdits</a></code>, <code><a href="#topic+localizeErrors">localizeErrors</a></code>,
<code><a href="#topic+normalize">normalize</a></code>, <code><a href="#topic+contains">contains</a></code>, <code><a href="#topic+is.editmatrix">is.editmatrix</a></code>,
<code><a href="#topic+getA">getA</a></code>, <code><a href="#topic+getAb">getAb</a></code>, <code><a href="#topic+getb">getb</a></code>, <code><a href="#topic+getOps">getOps</a></code> <code><a href="#topic+getVars">getVars</a></code>,
<code><a href="#topic+eliminate">eliminate</a></code>, <code><a href="#topic+substValue">substValue</a></code>, <code><a href="#topic+isFeasible">isFeasible</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using a character vector to define contraints
E &lt;- editmatrix(c("x+3*y==2*z", "x==z"))
print(E)

# Using a expression vector to define contraints
E &lt;- editmatrix(expression(x+3*y==2*z, x==z))
print(E)

# an editmatrix also has a summary method:
summary(E)

# select rows from an editmatrix:
E &lt;- editmatrix(c("x+3*y==2*z", "x &gt;= z"))
E[getOps(E) == "=="]


#Using data.frame to define constraints
E.df &lt;- data.frame(
    name =c("A","B","C"),
    edit = c("x == y",    
            "z + w == y + x",
            "z == y + 2*w"),
    description = c(
            "these variables should be equal","","")

)
print(E.df)

E &lt;- editmatrix(E.df)
print(E)
# Using a character vector to define contraints
E &lt;- editmatrix(c("x+3*y==2*z", "x==z"))
print(E)

# Using a expression vector to define contraints
E &lt;- editmatrix(expression(x+3*y==2*z, x==z))
print(E)

# an editmatrix also has a summary method:
summary(E)

# select rows from an editmatrix:
E &lt;- editmatrix(c("x+3*y==2*z", "x &gt;= z"))
E[getOps(E) == "=="]


#Using data.frame to define constraints
E.df &lt;- data.frame(
    name =c("A","B","C"),
    edit = c("x == y",    
            "z + w == y + x",
            "z == y + 2*w"),
    description = c(
            "these variables should be equal","","")

)
print(E.df)

E &lt;- editmatrix(E.df)
print(E)
</code></pre>

<hr>
<h2 id='editnames'>Names of edits</h2><span id='topic+editnames'></span>

<h3>Description</h3>

<p>Retrieve edit names from editset, -array or -matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editnames(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editnames_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editset">editset</a></code>, <code><a href="#topic+editarray">editarray</a></code> or <code><a href="#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='editrules.plotting'>Graphical representation of edits</h2><span id='topic+editrules.plotting'></span><span id='topic+plot.editmatrix'></span><span id='topic+plot.editset'></span><span id='topic+plot.editarray'></span><span id='topic+plot.editarray'></span><span id='topic+plot.editset'></span>

<h3>Description</h3>

<p>Plots a graph, showing which variables occur in what edits. By default,
squares represent edits, circles represent variables and an edge connecing
a variable with an edit indicates that the edit contains the variable.
</p>
<p>plot method for editarray
</p>
<p>plot method for editset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editmatrix'
plot(x, nodetype = "all", rules = editnames(x),
  vars = getVars(x), violated = logical(nedits(x)),
  adapt = logical(length(getVars(x))), nabbreviate = 5,
  layout = igraph::layout.fruchterman.reingold, edgecolor = "steelblue",
  rulecolor = "khaki1", varcolor = "lightblue1",
  violatedcolor = "sienna1", adaptcolor = "sienna1", ...)

## S3 method for class 'editarray'
plot(x, nodetype = "all", rules = editnames(x),
  vars = getVars(x), violated = logical(nedits(x)),
  adapt = logical(length(getVars(x))), nabbreviate = 5,
  layout = igraph::layout.fruchterman.reingold, edgecolor = "steelblue",
  rulecolor = "khaki1", varcolor = "lightblue1",
  violatedcolor = "sienna1", adaptcolor = "sienna1", ...)

## S3 method for class 'editset'
plot(x, nodetype = "all", rules = editnames(x),
  vars = getVars(x), violated = logical(nedits(x)),
  adapt = logical(length(getVars(x))), nabbreviate = 5,
  layout = igraph::layout.fruchterman.reingold, edgecolor = "steelblue",
  rulecolor = "khaki1", varcolor = "lightblue1",
  violatedcolor = "sienna1", adaptcolor = "sienna1", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editrules.plotting_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_nodetype">nodetype</code></td>
<td>
<p><code>'rules'</code>, <code>'vars'</code> or <code>'all'</code>.</p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_rules">rules</code></td>
<td>
<p>selection of edits</p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_vars">vars</code></td>
<td>
<p>selection of variables</p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_violated">violated</code></td>
<td>
<p>A named <code>logical</code> vector of length <code>nrow(E)</code>. Ingnored when <code>nodetype='vars'</code></p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_adapt">adapt</code></td>
<td>
<p>A named <code>logical</code> vector of <code>length(getVars(E))</code>. Ignored when <code>nodetype='rules'</code></p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_nabbreviate">nabbreviate</code></td>
<td>
<p><code>integer</code> To how many characters should variable and edit names be abbreviated?</p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_layout">layout</code></td>
<td>
<p>an <code>igraph</code> layout function. See <code>?igraph::layout</code></p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_edgecolor">edgecolor</code></td>
<td>
<p>Color of edges and node frames</p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_rulecolor">rulecolor</code></td>
<td>
<p>Color of rule nodes (ignored when <code>nodetype='vars'</code>)</p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_varcolor">varcolor</code></td>
<td>
<p>Color of variable nodes (ignored when <code>nodetype='rules'</code>)</p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_violatedcolor">violatedcolor</code></td>
<td>
<p>Color of nodes corresponding to violated edits (ignored when <code>nodetype='vars'</code>)</p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_adaptcolor">adaptcolor</code></td>
<td>
<p>Color of nodes corresponding to variables to adapt (ignored when <code>nodetype='rules'</code>)</p>
</td></tr>
<tr><td><code id="editrules.plotting_+3A_...">...</code></td>
<td>
<p>further  arguments to be passed to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the chosen <code>nodetype</code>, this function can plot
three types of graphs based on an edit set.
</p>

<ul>
<li><p>If <code>nodetype="all"</code> (default), the full bipartite graph is plotted. Each
variable is represented by a square node while each edit is represented by a circular
node. An edge is drawn when a variable occurs in an edit.
</p>
</li>
<li><p>If <code>nodetype="vars"</code> the variable graph is drawn. Each node represents a
variable, and an edge is drawn between two nodes if the variables occur together in at
least one edit. The edge width relates to the number of edits connecting two variables.
</p>
</li>
<li><p>If <code>nodetype="rules"</code> the rule graph is drawn. Each node represents an edit
rule and an edge is drawn between two nodes if they share at least one variable. The 
edge width relates to the number of edits connecting the two edit rules.
</p>
</li></ul>

<p>The boolean vectors <code>violated</code> and <code>adapt</code> can be used to color violated 
edits or variables which have to be adapted. The vectors must have named elements,
so variables and edit names can be matched.
</p>
<p>The function works by coercing an editmatrix to an <code>igraph</code> object, and therefore
relies on the plotting capabilities of the igraph package. For more finetuning,
use <code><a href="igraph.html#topic+as.igraph">as.igraph</a></code> and see <code>?igraph.plotting</code>.
</p>
<p>The default layout generated by the Fruchterman-Reingold algorithm. The resulting  
layout is one of several optimal layouts, generated randomly (using a attration-repulsion 
model between the nodes). To reproduce layouts, use fix a randseed before calling the plot 
function.
</p>


<h3>References</h3>

<p>Csardi G, Nepusz T: The igraph software package for complex network
research, InterJournal, Complex Systems 1695. 2006. http://igraph.sf.net
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+as.igraph">as.igraph</a></code>, <code><a href="#topic+adjacency">adjacency</a></code>, <code>igraph.plotting</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Examples with linear (in)equality edits

# load predefined edits from package
data(edits)
edits

# convert to editmatrix
E &lt;- editmatrix(edits)

## Not run:
# (Note to reader: the Not run directive only prevents the examle commands from
# running when package is built)

# Total edit graph
plot(E)

# Graph with dependent edits
plot(E, nodetype="rules")

# Graph with dependent variables
plot(E, nodetype="vars")

# Total edit graph, but with curved lines (option from igraph package)
plot(E, edge.curved=TRUE)


# graph, plotting just the connections caused by variable 't'
plot(E,vars='t')

## End(Not run) 

# here's an example with a broken record.
r &lt;- c(ct = 100, ch = 30, cp = 70, p=30,t=130 ) 
violatedEdits(E,r)
errorLocalizer(E,r)$searchBest()$adapt

# we color the violated edits and the variables that have to be adapted

## Not run
set.seed(1) # (for reprodicibility)
plot(E,
     adapt=errorLocalizer(E,r)$searchBest()$adapt,   
     violated=violatedEdits(E,r))
## End(Not run) 



# extract total graph (as igraph object)
as.igraph(E)

# extract graph with edges related to variable 't' and 'ch'
as.igraph(E,vars=c('t','ch'))

# extract total adjacency matrix
adjacency(E)

# extract adjacency matrix related to variables t and 'ch'
adjacency(E,vars=c('t','ch'))

## Examples with categorical edits

# generate an editarray:
E &lt;- editarray(expression(
    age %in% c('&lt;15','16-65','&gt;65'),
    employment %in% c('unemployed','employed','retired'),
    salary %in% c('none','low','medium','high'),
    if (age == '&lt;15') employment=='unemployed',
    if (salary != 'none') employment != 'unemployed',
    if (employment == 'unemployed') salary == 'none'))


## Not run:
# plot total edit graph
plot(E)

# plot with a different layout
plot(E,layout=layout.circle)

# plot edit graph, just the connections caused by 'salary'
plot(E,vars='salary')

## End(Not run)

# extract edit graph
as.igraph(E)

# extract edit graph, just the connections caused by 'salary'
as.igraph(E,vars='salary')

# extract adjacency matrix
adjacency(E)

# extract adjacency matrix, only caused by 'employment'
adjacency(E,vars='employment')





</code></pre>

<hr>
<h2 id='edits'>Example editrules, used in vignette</h2><span id='topic+edits'></span>

<h3>Description</h3>

<p>Some example editrules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(edits)
</code></pre>

<hr>
<h2 id='editset'>Read general edits</h2><span id='topic+editset'></span><span id='topic+as.character.editset'></span><span id='topic+as.data.frame.editset'></span><span id='topic+c.editset'></span><span id='topic+summary.editset'></span>

<h3>Description</h3>

<p>An <code>editset</code> combines numerical (linear), categorical and conditional restrictions
in a single object. Internally, it consists of two <code><a href="#topic+editmatrix">editmatrices</a></code> 
and an <code><a href="#topic+editarray">editarray</a></code>.
</p>
<p>summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editset(editrules, env = new.env())

## S3 method for class 'editset'
as.character(x, datamodel = TRUE, useIf = TRUE,
  dummies = FALSE, ...)

## S3 method for class 'editset'
as.data.frame(x, ...)

## S3 method for class 'editset'
c(...)

## S3 method for class 'editset'
summary(object, useBlocks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editset_+3A_editrules">editrules</code></td>
<td>
<p><code>character</code> vector, <code>expression</code> vector or <code>data.frame</code> (see details) containing edits.</p>
</td></tr>
<tr><td><code id="editset_+3A_env">env</code></td>
<td>
<p>environment to parse categorical edits in (normally, users need not specify this)</p>
</td></tr>
<tr><td><code id="editset_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+editset">editset</a></code></p>
</td></tr>
<tr><td><code id="editset_+3A_datamodel">datamodel</code></td>
<td>
<p>include datamodel?</p>
</td></tr>
<tr><td><code id="editset_+3A_useif">useIf</code></td>
<td>
<p>return vectorized version?</p>
</td></tr>
<tr><td><code id="editset_+3A_dummies">dummies</code></td>
<td>
<p>return datamodel for dummy variables?</p>
</td></tr>
<tr><td><code id="editset_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods</p>
</td></tr>
<tr><td><code id="editset_+3A_object">object</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="editset_+3A_useblocks">useBlocks</code></td>
<td>
<p><code>logical</code> Summarize each block?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>editset</code> converts a <code>character</code> or <code>expression</code> vector to an editset.
Alternatively, a <code>data.frame</code> with a column called <code>edit</code> can be supplied. Function
<code><a href="#topic+editfile">editfile</a></code> reads edits from a free-form textfile.
</p>


<h3>Value</h3>

<p><code>editset</code>: An object of class <code>editset</code>
</p>
<p><code>as.data.frame</code>: a <code>data.frame</code> with columns 'name' and 'edit'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+editrules.plotting">editrules.plotting</a></code>, <code><a href="#topic+violatedEdits">violatedEdits</a></code>, <code><a href="#topic+localizeErrors">localizeErrors</a></code>,
<code><a href="#topic+getVars">getVars</a></code>, <code><a href="#topic+disjunct">disjunct</a></code>, <code><a href="#topic+eliminate">eliminate</a></code>, <code><a href="#topic+substValue">substValue</a></code>, 
<code><a href="#topic+isFeasible">isFeasible</a></code>, <code><a href="#topic+contains">contains</a></code>, <code><a href="#topic+is.editset">is.editset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# edits can be read from a vector of expressions 
E &lt;- editset(expression(
    if ( x &gt; 0 ) y &gt; 0,
    x + y == z,
    A %in% letters[1:2],
    B %in% letters[2:3],
    if ( A == 'a') B == 'b',
    if ( A == 'b') x &gt;= 0,
    u + v == w,
    if ( u &gt;= 0 ) w &gt;= 0
))
E
summary(E)
as.data.frame(E)
getVars(E)
getVars(E,type='cat')
getVars(E,type='num')


## see also editfile
E &lt;- editfile(system.file('script/edits/mixedits.R',package='editrules'))
E
summary(E)
as.data.frame(E)
getVars(E)
getVars(E,type='cat')
getVars(E,type='num')




# edits can be read from a vector of expressions 
E &lt;- editset(expression(
    if ( x &gt; 0 ) y &gt; 0,
    x + y == z,
    A %in% letters[1:2],
    B %in% letters[2:3],
    if ( A == 'a') B == 'b',
    if ( A == 'b') x &gt;= 0,
    u + v == w,
    if ( u &gt;= 0 ) w &gt;= 0
))
E
summary(E)
as.data.frame(E)
getVars(E)
getVars(E,type='cat')
getVars(E,type='num')


## see also editfile
E &lt;- editfile(system.file('script/edits/mixedits.R',package='editrules'))
E
summary(E)
as.data.frame(E)
getVars(E)
getVars(E,type='cat')
getVars(E,type='num')



</code></pre>

<hr>
<h2 id='editType'>Determine edittypes in editset based on 'contains(E)'</h2><span id='topic+editType'></span>

<h3>Description</h3>

<p>Determines edittypes based on the variables they contain (not on names of edits).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editType(E, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editType_+3A_e">E</code></td>
<td>
<p>editset</p>
</td></tr>
<tr><td><code id="editType_+3A_m">m</code></td>
<td>
<p>if you happen to have <code>contains(E)</code> handy, it needs not be recalculated.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+contains">contains</a></code>
</p>

<hr>
<h2 id='eliminate'>Eliminate a variable from a set of edit rules</h2><span id='topic+eliminate'></span><span id='topic+eliminate.editmatrix'></span><span id='topic+eliminate.editarray'></span><span id='topic+eliminate.editset'></span><span id='topic+eliminate.editlist'></span>

<h3>Description</h3>

<p>Eliminating a variable amounts to deriving all (non-redundant) edits not containing
that variable. Geometrically, it can be seen as a projection of the solution space
(records obeying all edits) along the eliminated variable's axis. If the solution space
is non-concex (as is the usually case when conditional edits are involved), multiple
projections of convex subregions are performed.
</p>
<p>For objects of class <code><a href="#topic+editmatrix">editmatrix</a></code>, Fourier-Motzkin elimination 
is used to eliminate a variable from the of linear (in)equality restrictions.
An observation of Kohler (1967) is used to reduce the number of implied 
restrictions. Obvious redundancies of the type 0 &lt; 1 are removed as well.
</p>
<p>For categorical edits in an <code><a href="#topic+editarray">editarray</a></code>, the elimination 
method is based on repeated logical reduction on categories. See Van der Loo (2012) for 
a description.
</p>
<p>For an <code><a href="#topic+editset">editset</a></code>, <code>E</code> is transformed to an <code><a href="#topic+disjunct">editlist</a></code>.
Each element of an <code><a href="#topic+disjunct">editlist</a></code> describes a convex subregion of the 
total solution space of the <code><a href="#topic+editset">editset</a></code>. After this, the elimination method for 
<code><a href="#topic+disjunct">editlist</a></code> is called.
</p>
<p>For an <code><a href="#topic+disjunct">editlist</a></code>, the variable is eliminated from each
consituting <code><a href="#topic+editset">editset</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eliminate(E, var, ...)

## S3 method for class 'editmatrix'
eliminate(E, var, ...)

## S3 method for class 'editarray'
eliminate(E, var, ...)

## S3 method for class 'editset'
eliminate(E, var, ...)

## S3 method for class 'editlist'
eliminate(E, var, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eliminate_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editmatrix">editmatrix</a></code> or <code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
<tr><td><code id="eliminate_+3A_var">var</code></td>
<td>
<p>name of variable to be eliminated</p>
</td></tr>
<tr><td><code id="eliminate_+3A_...">...</code></td>
<td>
<p>argumemts to be passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>E</code> is an <code><a href="#topic+editmatrix">editmatrix</a></code> or <code><a href="#topic+editarray">editarray</a></code>, an object of the same class
is returned. A returned <code><a href="#topic+editmatrix">editmatrix</a></code> contains an extra <code>history</code> attribute which is used
to reduce the number of generated edits in consecutive eliminations (see <code><a href="#topic+getH">getH</a></code>). If <code>E</code> is an <code><a href="#topic+editset">editset</a></code>,
an object of class <code><a href="#topic+disjunct">editlist</a></code> is returned.
</p>


<h3>References</h3>

<p>D.A. Kohler (1967) Projections of convex polyhedral sets, Operational Research
Center Report , ORC 67-29, University of California, Berkely.
</p>
<p>H.P. Williams (1986) Fourier's method of linear programming and its dual,
The American Mathematical Monthly 93, 681-695
</p>
<p>M.P.J. van der Loo (2012) Variable elimination and edit generation with a flavour of 
semigroup algebra (submitted).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+substValue">substValue</a></code>, <code><a href="#topic+isObviouslyInfeasible">isObviouslyInfeasible</a></code>, <code><a href="#topic+isObviouslyRedundant">isObviouslyRedundant</a></code>,
<code><a href="#topic+generateEdits">generateEdits</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The following is an example by Williams (1986). Eliminating all variables
# except z maximizes -4x1 + 5x2 +3x3:
P &lt;- editmatrix(c(
     "4*x1 - 5*x2 - 3*x3 + z &lt;= 0",
     "-x1 + x2 -x3 &lt;= 2",
     "x1 + x2 + 2*x3 &lt;= 3",
     "-x1 &lt;= 0",
     "-x2 &lt;= 0",
     "-x3 &lt;= 0"))
# eliminate 1st variable
(P1 &lt;- eliminate(P, "x1", fancynames=TRUE))
# eliminate 2nd variable. Note that redundant rows have been eliminated
(P2 &lt;- eliminate(P1, "x2", fancynames=TRUE))
# finally, the answer:
(P3 &lt;- eliminate(P2, "x3", fancynames=TRUE))

# check which original edits were used in deriving the new ones
getH(P3)

# check how many variables were eliminated
geth(P3)


# An  example with an equality and two inequalities
# The only thing to do is solving for x in e1 and substitute in e3.
(E &lt;- editmatrix(c(
    "2*x + y == 1",
    "y &gt; 0",
    "x &gt; 0"),normalize=TRUE))
eliminate(E,"x", fancynames=TRUE)


# This example has two equalities, and it's solution 
# is the origin (x,y)=(0,0)
(E &lt;- editmatrix(c(
    "y &lt;= 1 - x",
    "y &gt;= -1 + x",
    "x == y",
    "y ==-2*x" ),normalize=TRUE))
eliminate(E,"x", fancynames=TRUE)

# this example has no solution, the equalities demand (x,y) = (0,2)
# while the inequalities demand y &lt;= 1
(E &lt;- editmatrix(c(
    "y &lt;= 1 - x",
    "y &gt;= -1 + x",
    "y == 2 - x",
    "y == -2 + x" ),normalize=TRUE))
# this happens to result in an obviously unfeasable system:
isObviouslyInfeasible(eliminate(E,"x"))


# for categorical data, elimination amounts to logical derivartions. For
# example
E &lt;- editarray(expression(
    age %in% c('under aged','adult'),
    positionInHousehold %in% c('marriage partner', 'child', 'other'),
    maritalStatus %in% c('unmarried','married','widowed','divorced'),
    if (maritalStatus %in% c('married','widowed','divorced') ) 
        positionInHousehold != 'child',
    if (maritalStatus == 'unmarried') 
        positionInHousehold != 'marriage partner' ,
    if ( age == 'under aged') maritalStatus == 'unmarried'
    )
)
E

# by eliminating 'maritalStatus' we can deduce that under aged persones cannot
# be partner in marriage.
eliminate(E,"maritalStatus")

E &lt;- editarray(expression(
    age %in% c('under aged','adult'),
    positionInHousehold %in% c('marriage partner', 'child', 'other'),
    maritalStatus %in% c('unmarried','married','widowed','divorced'),
    if (maritalStatus %in% c('married','widowed','divorced') ) 
        positionInHousehold != 'child',
    if (maritalStatus == 'unmarried') 
        positionInHousehold != 'marriage partner' ,
    if ( age == 'under aged') 
        maritalStatus == 'unmarried'
    )
)
E

# by eliminating 'maritalStatus' we can deduce that under aged persones cannot
# be partner in marriage.
eliminate(E,"maritalStatus")





</code></pre>

<hr>
<h2 id='errorLocalizer'>Create a backtracker object for error localization</h2><span id='topic+errorLocalizer'></span><span id='topic+errorLocalizer.editset'></span><span id='topic+errorLocalizer.editmatrix'></span><span id='topic+errorLocalizer.editarray'></span><span id='topic+errorLocalizer.editlist'></span>

<h3>Description</h3>

<p>Create a backtracker object for error localization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errorLocalizer(E, x, ...)

## S3 method for class 'editset'
errorLocalizer(E, x, ...)

## S3 method for class 'editmatrix'
errorLocalizer(E, x, weight = rep(1, length(x)),
  maxadapt = length(x), maxweight = sum(weight), maxduration = 600,
  tol = sqrt(.Machine$double.eps), ...)

## S3 method for class 'editarray'
errorLocalizer(E, x, weight = rep(1, length(x)),
  maxadapt = length(x), maxweight = sum(weight), maxduration = 600, ...)

## S3 method for class 'editlist'
errorLocalizer(E, x, weight = rep(1, length(x)),
  maxadapt = length(x), maxweight = sum(weight), maxduration = 600, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errorLocalizer_+3A_e">E</code></td>
<td>
<p>an <code><a href="#topic+editmatrix">editmatrix</a></code> or an <code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
<tr><td><code id="errorLocalizer_+3A_x">x</code></td>
<td>
<p>a named numerical <code>vector</code> or <code>list</code> (if E is an editmatrix), a named character <code>vector</code> or <code>list</code> (if E is an editarray), 
or a named <code>list</code> if E is an <code><a href="#topic+disjunct">editlist</a></code> or <code><a href="#topic+editset">editset</a></code>.
This is the record for which errors will be localized.</p>
</td></tr>
<tr><td><code id="errorLocalizer_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to other methods (e.g. reliability weights)</p>
</td></tr>
<tr><td><code id="errorLocalizer_+3A_weight">weight</code></td>
<td>
<p>a <code>lengt(x)</code> positive weight vector. The weights are assumed to be in the same order as the variables in <code>x</code>.</p>
</td></tr>
<tr><td><code id="errorLocalizer_+3A_maxadapt">maxadapt</code></td>
<td>
<p>maximum number of variables to adapt</p>
</td></tr>
<tr><td><code id="errorLocalizer_+3A_maxweight">maxweight</code></td>
<td>
<p>maximum weight of solution, if weights are not given, this is equal to the 
maximum number of variables to adapt.</p>
</td></tr>
<tr><td><code id="errorLocalizer_+3A_maxduration">maxduration</code></td>
<td>
<p>maximum time (in seconds), for <code>$searchNext()</code>, <code>$searchAll()</code> (not for <code>$searchBest</code>, use 
<code>$searchBest(maxdration=&lt;duration&gt;)</code> in stead)</p>
</td></tr>
<tr><td><code id="errorLocalizer_+3A_tol">tol</code></td>
<td>
<p>tolerance passed to <code>link{isObviouslyInfeasible}</code> (used to check for bound conditions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+backtracker">backtracker</a></code>. Each execution of <code>$searchNext()</code> yields a solution
in the form of a <code>list</code> (see details). Executing <code>$searchBest()</code> returns the lowest-weight solution.
When multiple solotions with the same weight are found, <code>$searchBest()</code> picks one at random.
</p>


<h3>Details</h3>

<p>Generate a <code><a href="#topic+backtracker">backtracker</a></code> object for error localization in numerical, categorical, or mixed data.
This function generates the workhorse program, called by <code><a href="#topic+localizeErrors">localizeErrors</a></code> with <code>method=localizer</code>.
</p>
<p>The returned <code><a href="#topic+backtracker">backtracker</a></code> can be used to run a branch-and-bound algorithm which finds
the least (weighted) number of variables in <code>x</code> that need to be adapted so that all restrictions 
in <code>E</code> can be satisfied. (Generalized principle of Fellegi and Holt (1976)).
</p>
<p>The B&amp;B tree is set up so that in in one branche,
a variable is assumed correct and its value subsituted in <code>E</code>, while in the other
branche a variable is assumed incorrect and <code><a href="#topic+eliminate">eliminated</a></code> from <code>E</code>. 
See De Waal (2003), chapter 8 or De Waal, Pannekoek and Scholtus (2011) for 
a concise description of the B&amp;B algorithm. 
</p>
<p>Every call to <code>&lt;backtracker&gt;$searchNext()</code> returns one solution <code>list</code>, consisting of
</p>

<ul>
<li><p>w: The solution weight. 
</p>
</li>
<li><p>adapt: <code>logical</code> indicating whether a variable should be adapted (<code>TRUE</code>) or not</p>
</li></ul>

<p>Every subsequent call leads either to <code>NULL</code>, in which case either all solutions have been found,
or <code>maxduration</code> was exceeded. The property <code>&lt;backtracker&gt;$maxdurationExceeded</code> indicates if this is
the case. Otherwise, a new solution with a weight <code>w</code> not higher than the weight of the last found solution
is returned.
</p>
<p>Alternatively <code>&lt;backtracker&gt;$searchBest()</code> will return the best solution found within <code>maxduration</code> seconds.
If multiple equivalent solutions are found, a random one is returned.
</p>
<p>The backtracker is prepared such that missing data in the input record <code>x</code> is already
set to adapt, and missing variables have been eliminated already.
</p>
<p>The backtracker will crash when <code>E</code> is an <code><a href="#topic+editarray">editarray</a></code> and one or more values are
not in the datamodel specified by <code>E</code>. The more user-friendly function <code><a href="#topic+localizeErrors">localizeErrors</a></code>
circumvents this. See also <code><a href="#topic+checkDatamodel">checkDatamodel</a></code>.
</p>


<h3>Numerical stability issues</h3>

<p>For records with a large numerical range (<em>eg</em> 1-1E9), the error locations represent solutions that
will allow repairing the record to within roundoff errors. We highly recommend that you round near-zero 
values (for example, everything <code>&lt;= sqrt(.Machine$double.eps)</code>) and scale a record with values larger
than or equal to 1E9 with a constant factor.
</p>


<h3>Note</h3>

<p>This method is potentially very slow for objects of class <code><a href="#topic+editset">editset</a></code> that contain 
many conditional restrictions.  Consider using <code><a href="#topic+localizeErrors">localizeErrors</a></code> with the option 
<code>method="mip"</code> in such cases.
</p>


<h3>References</h3>

<p>I.P. Fellegi and D. Holt (1976). A systematic approach to automatic edit and imputation. 
Journal of the American Statistical Association 71, pp 17-25
</p>
<p>T. De Waal (2003) Processing of unsave and erroneous data.  PhD thesis, Erasmus Research institute 
of management, Erasmus university Rotterdam. 
http://www.cbs.nl/nl-NL/menu/methoden/onderzoek-methoden/onderzoeksrapporten/proefschriften/2008-proefschrift-de-waal.htm
</p>
<p>T. De Waal, Pannekoek, J. and Scholtus, S. (2011) Handbook of Statistical Data Editing. Wiley Handbooks
on Survey Methodology.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+errorLocalizer_mip">errorLocalizer_mip</a></code>, <code><a href="#topic+localizeErrors">localizeErrors</a></code>, <code><a href="#topic+checkDatamodel">checkDatamodel</a></code>, <code><a href="#topic+violatedEdits">violatedEdits</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### examples with numerical edits
# example with a single editrule
# p = profit, c = cost, t = turnover
E &lt;- editmatrix(c("p + c == t"))
cp &lt;- errorLocalizer(E, x=c(p=755, c=125, t=200))
# x obviously violates E. With all weights equal, changing any variable will do.
# first solution:
cp$searchNext()
# second solution:
cp$searchNext()
# third solution:
cp$searchNext()
# there are no more solution since changing more variables would increase the
# weight, so the result of the next statement is NULL:
cp$searchNext()

# Increasing the reliability weight of turnover, yields 2 solutions:
cp &lt;- errorLocalizer(E, x=c(p=755, c=125, t=200), weight=c(1,1,2))
# first solution:
cp$searchNext()
# second solution:
cp$searchNext()
# no more solutions available:
cp$searchNext()


# A case with two restrictions. The second restriction demands that
# c/t &gt;= 0.6 (cost should be more than 60% of turnover)
E &lt;- editmatrix(c(
        "p + c == t",
        "c - 0.6*t &gt;= 0"))
cp &lt;- errorLocalizer(E,x=c(p=755,c=125,t=200))
# Now, there's only one solution, but we need two runs to find it (the 1st one
# has higher weight)
cp$searchNext()
cp$searchNext()

# With the searchBest() function, the lowest weifght solution is found at once:
errorLocalizer(E,x=c(p=755,c=125,t=200))$searchBest()


# An example with missing data.
E &lt;- editmatrix(c(
    "p + c1 + c2 == t",
    "c1 - 0.3*t &gt;= 0",
    "p &gt; 0",
    "c1 &gt; 0",
    "c2 &gt; 0",
    "t &gt; 0"))
cp &lt;- errorLocalizer(E,x=c(p=755, c1=50, c2=NA,t=200))
# (Note that e2 is violated.)
# There are two solutions. Both demand that c2 is adapted:
cp$searchNext()
cp$searchNext()

##### Examples with categorical edits
# 
# 3 variables, recording age class, position in household, and marital status:
# We define the datamodel and the rules
E &lt;- editarray(expression(
    age %in% c('under aged','adult'),
    maritalStatus %in% c('unmarried','married','widowed','divorced'),
    positionInHousehold %in% c('marriage partner', 'child', 'other'),
    if( age == 'under aged' ) 
        maritalStatus == 'unmarried',
    if( maritalStatus %in% c('married','widowed','divorced')) 
        !positionInHousehold %in% c('marriage partner','child')
    )
)
E

# Let's define a record with an obvious error:
r &lt;- c(
  age = 'under aged', 
  maritalStatus='married', 
  positionInHousehold='child')
# The age class and position in household are consistent, while the marital
# status conflicts.  Therefore, changing only the marital status (in stead of
# both age class and postition in household) seems reasonable. 
el &lt;- errorLocalizer(E,r)
el$searchNext()










</code></pre>

<hr>
<h2 id='errorLocalizer_mip'>Localize errors using a MIP approach.</h2><span id='topic+errorLocalizer_mip'></span>

<h3>Description</h3>

<p>Localize errors using a MIP approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errorLocalizer_mip(E, x, weight = rep(1, length(x)), maxduration = 600L,
  verbose = "neutral", lpcontrol = getOption("er.lpcontrol"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errorLocalizer_mip_+3A_e">E</code></td>
<td>
<p>an <code><a href="#topic+editset">editset</a></code>, <code><a href="#topic+editmatrix">editmatrix</a></code>, or <code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
<tr><td><code id="errorLocalizer_mip_+3A_x">x</code></td>
<td>
<p>named <code>numeric</code> with data</p>
</td></tr>
<tr><td><code id="errorLocalizer_mip_+3A_weight">weight</code></td>
<td>
<p><code>numeric</code> with weights</p>
</td></tr>
<tr><td><code id="errorLocalizer_mip_+3A_maxduration">maxduration</code></td>
<td>
<p>number of seconds that is spent on finding a solution</p>
</td></tr>
<tr><td><code id="errorLocalizer_mip_+3A_verbose">verbose</code></td>
<td>
<p>verbosity argument that will be passed on to <code>solve</code> lpSolveAPI</p>
</td></tr>
<tr><td><code id="errorLocalizer_mip_+3A_lpcontrol">lpcontrol</code></td>
<td>
<p>named <code>list</code>  of arguments that will be passed on to <code><a href="lpSolveAPI.html#topic+lp.control">lp.control</a></code>. <code>maxduration</code> will override
<code>lpSolve</code>'s <code>timeout</code> argument.</p>
</td></tr>
<tr><td><code id="errorLocalizer_mip_+3A_...">...</code></td>
<td>
<p>other arguments that will be passed on to <code>solve</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with solution weight <code>w</code>, <code>logical</code> <code>adapt</code> stating what to adapt,  
<code>x_feasible</code> and the lp problem (an <code>lpExtPtr</code> object)
</p>


<h3>Details</h3>

<p><code>errorLocalizer_mip</code> uses <code>E</code> and <code>x</code> to define a mixed integer problem
and solves this problem using <code>lpSolveApi</code>. This function can be much faster then <code><a href="#topic+errorLocalizer">errorLocalizer</a></code> 
but does not return the degeneracy of a solution. However it does return an bonus: 
<code>x_feasible</code>, a feasible solution.
</p>


<h3>References</h3>

<p>E. De Jonge and Van der Loo, M. (2012) Error localization as a mixed-integer program in 
editrules (included with the package)
</p>
<p>lp_solve and Kjell Konis. (2011). lpSolveAPI: R Interface for
lp_solve version 5.5.2.0. R package version 5.5.2.0-5.
http://CRAN.R-project.org/package=lpSolveAPI
</p>


<h3>See Also</h3>

<p><code><a href="#topic+localizeErrors">localizeErrors</a></code>, <code><a href="#topic+errorLocalizer">errorLocalizer</a></code>, <code><a href="#topic+errorLocation">errorLocation</a></code>
</p>

<hr>
<h2 id='errorLocation'>The errorLocation object</h2><span id='topic+errorLocation'></span><span id='topic+plot.errorLocation'></span><span id='topic+summary.errorLocation'></span>

<h3>Description</h3>

<p>Object storing information on error locations in a dataset.
</p>
<p>summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'errorLocation'
plot(x, topn = min(10, ncol(x$adapt)), ...)

## S3 method for class 'errorLocation'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errorLocation_+3A_x">x</code></td>
<td>
<p>errorLocation object</p>
</td></tr>
<tr><td><code id="errorLocation_+3A_topn">topn</code></td>
<td>
<p>Number of variables to show in 'errors per variable plot'. Only the top-n are are shown. 
By default the top-20 variables with the most errors are shown.</p>
</td></tr>
<tr><td><code id="errorLocation_+3A_...">...</code></td>
<td>
<p>other arguments that will be transferred to <code>barplot</code></p>
</td></tr>
<tr><td><code id="errorLocation_+3A_object">object</code></td>
<td>
<p>an R object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>errorlocation</code> objects consists of the following slots wich can be 
accessed with the dollar operator, just like with lists. Right now the only
functions creating such objects are <code><a href="#topic+localizeErrors">localizeErrors</a></code> and <code><a href="#topic+checkDatamodel">checkDatamodel</a></code>.
</p>

<ul>
<li><p><code>adapt</code> a <code>logical</code> array where each row/column shows which record/variable should be adapted.
</p>
</li>
<li><p><code>status</code> A <code>data.frame</code> with the same number of rows as <code>adapt</code>. It contains the following
columns
</p>

<ul>
<li><p><code>weight</code> weight of the found solution
</p>
</li>
<li><p><code>degeneracy</code> number of equivalent solutions found
</p>
</li>
<li><p><code>user</code> user time used to generate solution (as in <code>sys.time</code>)
</p>
</li>
<li><p><code>system</code> system time used to generate solution (as in <code>sys.time</code>)
</p>
</li>
<li><p><code>elapsed</code> elapsed time used to generate solution (as in <code>sys.time</code>)
</p>
</li>
<li><p><code>maxDurationExceeded</code> Was the maximum search time reached?
</p>
</li>
<li><p><code>memfail</code> Indicates whether a branch was broken off due to memory allocation failure (branch and bound only)
</p>
</li></ul>


</li>
<li><p><code>method</code> The error localization method used, can be &quot;mip&quot;, &quot;localizer&quot; or &quot;checkDatamodel&quot;.
</p>
</li>
<li><p><code>call</code> The R calls to the function generating the object.
</p>
</li>
<li><p><code>user</code> <code>character</code> user who generated the object.
</p>
</li>
<li><p><code>timestamp</code> <code>character</code> timestamp.
</p>
</li></ul>

<p>It is possible to <code>plot</code> objects of class <code>errorLocation</code>. An overview containing
three or four graphs will be plotted in a new window. Axes in scatterplots are set to logarithmic
if their scales maxima exceed 50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+localizeErrors">localizeErrors</a></code>, <code><a href="#topic+checkDatamodel">checkDatamodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# an editmatrix and some data:
E &lt;- editmatrix(c(
    "x + y == z",
    "x &gt; 0",
    "y &gt; 0",
    "z &gt; 0"))

dat &lt;- data.frame(
    x = c(1,-1,1),
    y = c(-1,1,1),
    z = c(2,0,2))

# localize all errors in the data
err &lt;- localizeErrors(E,dat)

summary(err)

# what has to be adapted:
err$adapt
# weight, number of equivalent solutions, timings,
err$status


## Not run

# Demonstration of verbose processing
# construct 2-block editmatrix
F &lt;- editmatrix(c(
    "x + y == z",
    "x &gt; 0",
    "y &gt; 0",
    "z &gt; 0",
    "w &gt; 10"))
# Using 'dat' as defined above, generate some extra records
dd &lt;- dat
for ( i in 1:5 ) dd &lt;- rbind(dd,dd)
dd$w &lt;- sample(12,nrow(dd),replace=TRUE)

# localize errors verbosely
(err &lt;- localizeErrors(F,dd,verbose=TRUE))

# printing is cut off, use summary for an overview
summary(err)

# or plot (not very informative in this artificial example)
plot(err)

## End(Not run)

for ( d in dir("../pkg/R",full.names=TRUE)) dmp &lt;- source(d)
# Example with different weights for each record
E &lt;- editmatrix('x + y == z')
dat &lt;- data.frame(
    x = c(1,1),
    y = c(1,1),
    z = c(1,1))

# At equal weights, both records have three solutions (degeneracy): adapt x, y
# or z:
localizeErrors(E,dat)$status

# Set different weights per record (lower weight means lower reliability):
w &lt;- matrix(c(
    1,2,2,
    2,2,1),nrow=2,byrow=TRUE)

localizeErrors(E,dat,weight=w)


# an example with categorical variables
E &lt;- editarray(expression(
    age %in% c('under aged','adult'),
    maritalStatus %in% c('unmarried','married','widowed','divorced'),
    positionInHousehold %in% c('marriage partner', 'child', 'other'),
    if( age == 'under aged' ) maritalStatus == 'unmarried',
    if( maritalStatus %in% c('married','widowed','divorced')) 
      !positionInHousehold %in% c('marriage partner','child')
    )
)
E

#
dat &lt;- data.frame(
    age = c('under aged','adult','adult' ),
    maritalStatus=c('married','unmarried','widowed' ), 
    positionInHousehold=c('child','other','marriage partner')
)
dat
localizeErrors(E,dat)
# the last record of dat has 2 degenerate solutions. Running  the last command
# a few times demonstrates that one of those solutions is chosen at random.

# Increasing the weight of  'positionInHousehold' for example, makes the best
# solution unique again
localizeErrors(E,dat,weight=c(1,1,2))


# an example with mixed data:

E &lt;- editset(expression(
    x + y == z,
    2*u  + 0.5*v == 3*w,
    w &gt;= 0,
    if ( x &gt; 0 ) y &gt; 0,
    x &gt;= 0,
    y &gt;= 0,
    z &gt;= 0,
    A %in% letters[1:4],
    B %in% letters[1:4],
    C %in% c(TRUE,FALSE),
    D %in% letters[5:8],
    if ( A %in% c('a','b') ) y &gt; 0,
    if ( A == 'c' ) B %in% letters[1:3],
    if ( !C == TRUE) D %in% c('e','f')
))

set.seed(1)
dat &lt;- data.frame(
    x = sample(-1:8),
    y = sample(-1:8),
    z = sample(10),
    u = sample(-1:8),
    v = sample(-1:8),
    w = sample(10),
    A = sample(letters[1:4],10,replace=TRUE),
    B = sample(letters[1:4],10,replace=TRUE),
    C = sample(c(TRUE,FALSE),10,replace=TRUE),
    D = sample(letters[5:9],10,replace=TRUE),
    stringsAsFactors=FALSE
)

(el &lt;-localizeErrors(E,dat,verbose=TRUE))





</code></pre>

<hr>
<h2 id='expandEdits'>Expand an edit expression</h2><span id='topic+expandEdits'></span>

<h3>Description</h3>

<p>Often many numeric variables have the same constraints. <code>expandEdits</code> is
a utility function to define edits for multiple variables. See the examples for the syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandEdits(s, prefix = "_", useSum = TRUE, asExpression = is.language(s),
  env = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandEdits_+3A_s">s</code></td>
<td>
<p>edit expression, can be a <code>character</code> or <code>expression</code> vector</p>
</td></tr>
<tr><td><code id="expandEdits_+3A_prefix">prefix</code></td>
<td>
<p>prefix for variables to be expanded</p>
</td></tr>
<tr><td><code id="expandEdits_+3A_usesum">useSum</code></td>
<td>
<p>if <code>TRUE</code> sum expressions will be expanded</p>
</td></tr>
<tr><td><code id="expandEdits_+3A_asexpression">asExpression</code></td>
<td>
<p>if <code>TRUE</code> an <code><a href="base.html#topic+expression">expression</a></code> will be returned in stead of a <code>character</code></p>
</td></tr>
<tr><td><code id="expandEdits_+3A_env">env</code></td>
<td>
<p>enviroment that will be used to find variables to be expanded</p>
</td></tr>
<tr><td><code id="expandEdits_+3A_...">...</code></td>
<td>
<p>variables used in the expansion</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> or <code>expression</code> vector with expanded expressions
</p>

<hr>
<h2 id='fcf.env'>Field code forest algorithm</h2><span id='topic+fcf.env'></span>

<h3>Description</h3>

<p>Workhorse function for <code><a href="#topic+generateEdits">generateEdits</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcf.env(E, totreat, env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fcf.env_+3A_e">E</code></td>
<td>
<p>an editarray</p>
</td></tr>
<tr><td><code id="fcf.env_+3A_env">env</code></td>
<td>
<p>an environment where all editmatrices will be stored</p>
</td></tr>
<tr><td><code id="fcf.env_+3A_vars">vars</code></td>
<td>
<p>variable names still to be eliminated from E</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+generateEdits">generateEdits</a></code>, <code><a href="#topic+editarray">editarray</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

E &lt;- editarray(expression(
    a %in% letters[1:4],
    b %in% letters[5:8],
    if ( a %in% c('a','b') ) b %in% c('e','f'),
    if ( a %in% c('c','d') ) b %in% c('h')
))

generateEdits(E)

## Not run
# load 60 edits (36 variables) from demonstration file
E &lt;- editfile(system.file('script/bench/edits.R',package='editrules'),type='cat')
F &lt;- generateEdits(E)

summary(F$edits)
F$nodes
F$dudation

## End(Not run)
</code></pre>

<hr>
<h2 id='generateEdits'>Derive all essentially new implicit edits</h2><span id='topic+generateEdits'></span>

<h3>Description</h3>

<p>Implements the Field Code Forest (FCF) algorithm of Garfinkel et al (1986) to 
derive all essentially new implicit edits from an editarray. The FCF is really
a single, highly unbalanced tree. This algorithm traverses the tree, pruning many 
unnecessary branches, uses <code><a href="#topic+blocks">blocks</a></code> to divide and conquer, and 
optimizes traversing order. See Van der Loo (2012) for a description
of the algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateEdits(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateEdits_+3A_e">E</code></td>
<td>
<p>An <code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-element named <code>list</code>, where element <code>E</code> is an <code><a href="#topic+editarray">editarray</a></code> containing all 
generated edits. <code>nodes</code> contains information on the number of nodes in the tree and vs the number of nodes
traversed and <code>duration</code> contains user, system and elapsed time inseconds.
The <code><a href="#topic+editarray">summary</a></code> method for <code><a href="#topic+editarray">editarray</a></code> prints this information.
</p>


<h3>References</h3>

<p>R.S. Garfinkel, A.S. Kunnathur and G.E. Liepins (1986). 
Optimal imputation of erroneous data: categorical data, general edits.
Operations Research 34, 744-751.
</p>
<p>M.P.J. Van der Loo (2012). Variable elimination and edit generation with a flavour of 
semigroup algebra (submitted)
</p>

<hr>
<h2 id='getA'>Returns the coefficient matrix <code>A</code> of linear (in)equalities</h2><span id='topic+getA'></span>

<h3>Description</h3>

<p>Returns the coefficient matrix <code>A</code> of linear (in)equalities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getA(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getA_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> matrix <code>A</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+editmatrix">editmatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
E &lt;- editmatrix(c( "x+3*y == 2*z"
                 , "x &gt; 2")
                 )
print(E)
                 
# get editrules, useful for storing and maintaining the rules external from your script
as.data.frame(E)
                 
# get coeficient matrix of inequalities
getA(E)

# get augmented matrix of linear edit set
getAb(E)

# get constants of inequalities (i.e. c(0, 2))                
getb(E)

# get operators of inequalities (i.e. c("==","&gt;"))
getOps(E)

# get variables of inequalities (i.e. c("x","y","z"))
getVars(E)

# isNormalized
isNormalized(E)

#normalized E
E &lt;- normalize(E)
E

# is het now normalized?
isNormalized(E)
</code></pre>

<hr>
<h2 id='getAb'>Returns augmented matrix representation of edit set.</h2><span id='topic+getAb'></span>

<h3>Description</h3>

<p>For a system of linear (in)equations of the form <code class="reqn">Ax \odot b</code>, <code class="reqn">\odot\in\{&lt;,\leq,=\}</code>,
the matrix <code class="reqn">A|b</code> is called the augmented matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAb(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAb_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> matrix <code>A|b</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+editmatrix">editmatrix</a></code> <code><a href="#topic+as.matrix.editmatrix">as.matrix.editmatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
E &lt;- editmatrix(c( "x+3*y == 2*z"
                 , "x &gt; 2")
                 )
print(E)
                 
# get editrules, useful for storing and maintaining the rules external from your script
as.data.frame(E)
                 
# get coeficient matrix of inequalities
getA(E)

# get augmented matrix of linear edit set
getAb(E)

# get constants of inequalities (i.e. c(0, 2))                
getb(E)

# get operators of inequalities (i.e. c("==","&gt;"))
getOps(E)

# get variables of inequalities (i.e. c("x","y","z"))
getVars(E)

# isNormalized
isNormalized(E)

#normalized E
E &lt;- normalize(E)
E

# is het now normalized?
isNormalized(E)
</code></pre>

<hr>
<h2 id='getArr'>Get named logical array from editarray</h2><span id='topic+getArr'></span>

<h3>Description</h3>

<p>Get named logical array from editarray
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getArr(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getArr_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical array
</p>

<hr>
<h2 id='getb'>Returns the constant part <code>b</code> of a linear (in)equality</h2><span id='topic+getb'></span>

<h3>Description</h3>

<p>Returns the constant part <code>b</code> of a linear (in)equality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getb(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getb_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> vector <code>b</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+editmatrix">editmatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
E &lt;- editmatrix(c( "x+3*y == 2*z"
                 , "x &gt; 2")
                 )
print(E)
                 
# get editrules, useful for storing and maintaining the rules external from your script
as.data.frame(E)
                 
# get coeficient matrix of inequalities
getA(E)

# get augmented matrix of linear edit set
getAb(E)

# get constants of inequalities (i.e. c(0, 2))                
getb(E)

# get operators of inequalities (i.e. c("==","&gt;"))
getOps(E)

# get variables of inequalities (i.e. c("x","y","z"))
getVars(E)

# isNormalized
isNormalized(E)

#normalized E
E &lt;- normalize(E)
E

# is het now normalized?
isNormalized(E)
</code></pre>

<hr>
<h2 id='getH'>Returns the derivation history of an edit matrix or array</h2><span id='topic+getH'></span><span id='topic+geth'></span>

<h3>Description</h3>

<p>Function <code><a href="#topic+eliminate">eliminate</a></code> tracks the history of edits in a logical array H.
H has nrow(E) rows and the number of columns is the number of
edits in the <code><a href="#topic+editmatrix">editmatrix</a></code> as it was first defined. If 
H[i,j1], H[i,j2],...,H[i,jn] are <code>TRUE</code>, then E[i,] is some 
(positive, linear) combination of original edits E[j1,], E[j2,],...,E[jn,]
</p>
<p>h records the number of variables eliminated from E by <code><a href="#topic+eliminate">eliminate</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getH(E)

geth(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getH_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attributes H and h are used to detect redundant derived edits.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+editmatrix">editmatrix</a></code>, <code><a href="#topic+eliminate">eliminate</a></code>
</p>
<p><code><a href="#topic+editmatrix">editmatrix</a></code>, <code><a href="#topic+eliminate">eliminate</a></code>
</p>

<hr>
<h2 id='getInd'>get index list from editmatrix</h2><span id='topic+getInd'></span>

<h3>Description</h3>

<p>The 'ind' attribute is a named list of named integer vectors. The list names are the 
variable names. The vectors in the list index the columns in the editarray associated with the
variables. The names of the vectors are the names of the columns of the editarray.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInd(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInd_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list, indexing category levels in the editarray (columns)
</p>

<hr>
<h2 id='getlevels'>retrieve level names from editarray</h2><span id='topic+getlevels'></span>

<h3>Description</h3>

<p>retrieve level names from editarray
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getlevels(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getlevels_+3A_editarray">editarray</code></td>
<td>
<p><code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>

<hr>
<h2 id='getnames'>retrieve edit names from editarray</h2><span id='topic+getnames'></span>

<h3>Description</h3>

<p>retrieve edit names from editarray
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getnames(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getnames_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>

<hr>
<h2 id='getOps'>Returns the operator part of a linear (in)equality <code>editmatrix</code> E</h2><span id='topic+getOps'></span>

<h3>Description</h3>

<p>Returns the operator part of a linear (in)equality <code>editmatrix</code> E
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOps(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOps_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> vector with the (in)equality operators.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+editmatrix">editmatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
E &lt;- editmatrix(c( "x+3*y == 2*z"
                 , "x &gt; 2")
                 )
print(E)
                 
# get editrules, useful for storing and maintaining the rules external from your script
as.data.frame(E)
                 
# get coeficient matrix of inequalities
getA(E)

# get augmented matrix of linear edit set
getAb(E)

# get constants of inequalities (i.e. c(0, 2))                
getb(E)

# get operators of inequalities (i.e. c("==","&gt;"))
getOps(E)

# get variables of inequalities (i.e. c("x","y","z"))
getVars(E)

# isNormalized
isNormalized(E)

#normalized E
E &lt;- normalize(E)
E

# is het now normalized?
isNormalized(E)
</code></pre>

<hr>
<h2 id='getSep'>get seprator used to seperate variables from levels in editarray</h2><span id='topic+getSep'></span>

<h3>Description</h3>

<p>get seprator used to seperate variables from levels in editarray
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSep(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSep_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>

<hr>
<h2 id='getUpperBounds'>Get upperbounds of edits, given the boundaries of all variables</h2><span id='topic+getUpperBounds'></span>

<h3>Description</h3>

<p>Get upperbounds of edits, given the boundaries of all variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUpperBounds(E, xlim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUpperBounds_+3A_e">E</code></td>
<td>
<p><code>editmatrix</code></p>
</td></tr>
<tr><td><code id="getUpperBounds_+3A_xlim">xlim</code></td>
<td>
<p><code>matrix</code> with columns lower and upper, and rows are variables (in same order as E)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with upperbounds per edit and a possible value
</p>

<hr>
<h2 id='getVars'>get names of variables in a set of edits</h2><span id='topic+getVars'></span><span id='topic+getVars.editset'></span><span id='topic+getVars.NULL'></span>

<h3>Description</h3>

<p>get names of variables in a set of edits
</p>
<p>getr variable names
</p>
<p>get variable names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVars(E, ...)

## S3 method for class 'editset'
getVars(E, type = c("all", "num", "cat", "mix", "dummy"),
  ...)

## S3 method for class 'NULL'
getVars(E, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVars_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editset">editset</a></code>, <code><a href="#topic+editmatrix">editmatrix</a></code>, or <code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
<tr><td><code id="getVars_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to or from other methods</p>
</td></tr>
<tr><td><code id="getVars_+3A_type">type</code></td>
<td>
<p>(editset- or list only) select which variables to return. <code>all</code> means all (except dummies), <code>num</code> means 
all numericals, <code>cat</code> means all categoricals, <code>mix</code> means those numericals appearing in a logical 
constraint and <code>dummy</code> means dummy variables connecting the logical with numerical constraints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> vector with the names of the variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getA">getA</a></code>, <code><a href="#topic+getb">getb</a></code>, <code><a href="#topic+getAb">getAb</a></code>, <code><a href="#topic+getOps">getOps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
E &lt;- editmatrix(c( "x+3*y == 2*z"
                 , "x &gt; 2")
                 )
getVars(E)

E &lt;- editarray(expression(
    gender %in% c('male','female'),
    pregnant %in% c(TRUE, FALSE),
    if( gender == 'male' ) pregnant == FALSE
    )
)

getVars(E)

</code></pre>

<hr>
<h2 id='getVars.cateditmatrix'>Returns the variable names of an (in)equality <code>editmatrix</code> E</h2><span id='topic+getVars.cateditmatrix'></span>

<h3>Description</h3>

<p>Returns the variable names of an (in)equality <code>editmatrix</code> E
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cateditmatrix'
getVars(E, type = c("uniquevar", "colnames", "var",
  "cat"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVars.cateditmatrix_+3A_type">type</code></td>
<td>
<p>should unique variable names, colnames, all variable names or category names be extracted?</p>
</td></tr>
</table>

<hr>
<h2 id='getVars.editarray'>get variable names in editarray</h2><span id='topic+getVars.editarray'></span>

<h3>Description</h3>

<p>get variable names in editarray
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editarray'
getVars(E, type = "cat", ...)
</code></pre>

<hr>
<h2 id='getVars.editlist'>get variable names</h2><span id='topic+getVars.editlist'></span>

<h3>Description</h3>

<p>get variable names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editlist'
getVars(E, ...)
</code></pre>

<hr>
<h2 id='getVars.editmatrix'>Returns the variable names of an (in)equality <code>editmatrix</code> E</h2><span id='topic+getVars.editmatrix'></span>

<h3>Description</h3>

<p>Returns the variable names of an (in)equality <code>editmatrix</code> E
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editmatrix'
getVars(E, ...)
</code></pre>

<hr>
<h2 id='impliedValues'>Retrieve values stricktly implied by rules</h2><span id='topic+impliedValues'></span><span id='topic+impliedValues.editmatrix'></span>

<h3>Description</h3>

<p>Retrieve values stricktly implied by rules
</p>
<p>Detects cases where two inequalities imply an equality, e.g. <code class="reqn">x\leq 0</code> and <code class="reqn">x\geq0</code>
implies <code class="reqn">x=0</code>. Also detects straight equalities, e.g. <code class="reqn">x==0</code> implies <code class="reqn">x=0</code>. Such
cases arise frequently when manipulating edits by value subsitution or variable elimination.
The function recursively detects equalities and combined inequalities that imply fixed values, 
substitutes those fixed values and looks for new implied values until no new values are found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impliedValues(E, ...)

## S3 method for class 'editmatrix'
impliedValues(E, tol = sqrt(.Machine$double.eps), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impliedValues_+3A_e">E</code></td>
<td>
<p>editmatrix</p>
</td></tr>
<tr><td><code id="impliedValues_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
<tr><td><code id="impliedValues_+3A_tol">tol</code></td>
<td>
<p>Maximum deviation for two values to be considered equal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector, whose names are variable names and values are unique values implied by the rules.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduce">reduce</a></code>, <code><a href="#topic+substValue">substValue</a></code>, <code><a href="#topic+eliminate">eliminate</a></code>
</p>

<hr>
<h2 id='ind2char'>Derive textual representation from (partial) indices</h2><span id='topic+ind2char'></span>

<h3>Description</h3>

<p>Derive textual representation from (partial) indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind2char(ivd, ind = ivd, invert = logical(length(ivd)), useEqual = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind2char_+3A_ind">ind</code></td>
<td>
<p>a <code>list</code>, usually a (part of) the 'ind' attribute of an editarray</p>
</td></tr>
<tr><td><code id="ind2char_+3A_invert">invert</code></td>
<td>
<p><code>logical</code> vector of  lenght length(ind)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For every entry in <code>ind</code>, a character vector is returned where each entry
is a statement of the form <code>"&lt;var&gt; %in% c('&lt;cat1&gt;',...,'&lt;catN&gt;')" or "&lt;var&gt; == '&lt;catt&gt;'"</code>
if invert==TRUE. If invert==FALSE, the negation of the above statements is returned.
</p>

<hr>
<h2 id='indFromArray'>Compute index from array part of editarray</h2><span id='topic+indFromArray'></span>

<h3>Description</h3>

<p>Compute index from array part of editarray
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indFromArray(A, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indFromArray_+3A_a">A</code></td>
<td>
<p>boolean array</p>
</td></tr>
<tr><td><code id="indFromArray_+3A_sep">sep</code></td>
<td>
<p>separator</p>
</td></tr>
</table>

<hr>
<h2 id='is.editrules'>Check object class</h2><span id='topic+is.editrules'></span><span id='topic+is.editset'></span><span id='topic+is.editmatrix'></span><span id='topic+is.editarray'></span><span id='topic+is.editset'></span><span id='topic+is.editmatrix'></span><span id='topic+is.editarray'></span>

<h3>Description</h3>

<p>Check object class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.editset(x)

is.editmatrix(x)

is.editarray(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.editrules_+3A_x">x</code></td>
<td>
<p>object to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code>
</p>

<hr>
<h2 id='isFeasible'>Check consistency of set of edits</h2><span id='topic+isFeasible'></span>

<h3>Description</h3>

<p>When variables are <code><a href="#topic+eliminate">eliminated</a></code> one by one
from a set of edits, eventually either no edits are left or an 
<code><a href="#topic+isObviouslyInfeasible">obvious contradiction</a></code> is encountered.
In the    case no records can obey all edits in the set which is therefore
<code>inFeasible</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isFeasible(E, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isFeasible_+3A_e">E</code></td>
<td>
<p>an <code><a href="#topic+editmatrix">editmatrix</a></code>, <code><a href="#topic+editarray">editarray</a></code> or <code><a href="#topic+editset">editset</a></code></p>
</td></tr>
<tr><td><code id="isFeasible_+3A_warn">warn</code></td>
<td>
<p>logical: should a warning be emitted when system is infeasible?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE
</p>


<h3>Note</h3>

<p>This function can potentially take a long time to complete, especially
when many connected (conditional) edits are present. Consider using <code><a href="#topic+blocks">blocks</a></code>
to check feasibility of indendent blocks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isObviouslyInfeasible">isObviouslyInfeasible</a></code>, <code><a href="#topic+isObviouslyRedundant">isObviouslyRedundant</a></code>
</p>

<hr>
<h2 id='isNormalized'>Check if an editmatrix is normalized</h2><span id='topic+isNormalized'></span>

<h3>Description</h3>

<p>Check if an editmatrix is normalized
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNormalized(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isNormalized_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE when all comparison operators of <code>E</code> are in {<code>&lt;,&lt;=,==</code>}
</p>


<h3>See Also</h3>

<p><code><a href="#topic+editmatrix">editmatrix</a></code>
</p>

<hr>
<h2 id='isObviouslyInfeasible'>Check for obvious contradictions in a set of edits</h2><span id='topic+isObviouslyInfeasible'></span><span id='topic+isObviouslyInfeasible.editmatrix'></span><span id='topic+isObviouslyInfeasible.editarray'></span><span id='topic+isObviouslyInfeasible.editset'></span><span id='topic+isObviouslyInfeasible.editlist'></span><span id='topic+isObviouslyInfeasible.editenv'></span>

<h3>Description</h3>

<p>Obvious contradictions are edits of the form <code class="reqn">1 &lt; 0</code>, or categorical
edits defining that a record fails for any value combination If
this function evaluates to <code>TRUE</code>, the set of edits is guaranteed
infeasible. If it evaluates to <code>FALSE</code> this does not garuantee feasibility.
See <code><a href="#topic+isFeasible">isFeasible</a></code> for a complete test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isObviouslyInfeasible(E, ...)

## S3 method for class 'editmatrix'
isObviouslyInfeasible(E, tol = sqrt(.Machine$double.eps),
  ...)

## S3 method for class 'editarray'
isObviouslyInfeasible(E, ...)

## S3 method for class 'editset'
isObviouslyInfeasible(E, ...)

## S3 method for class 'editlist'
isObviouslyInfeasible(E, ...)

## S3 method for class 'editenv'
isObviouslyInfeasible(E, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isObviouslyInfeasible_+3A_e">E</code></td>
<td>
<p>An <code><a href="#topic+editset">editset</a></code>, <code><a href="#topic+editmatrix">editmatrix</a></code>, <code><a href="#topic+editarray">editarray</a></code>, <code><a href="#topic+disjunct">editlist</a></code> or <code><a href="#topic+disjunct">editenv</a></code></p>
</td></tr>
<tr><td><code id="isObviouslyInfeasible_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="isObviouslyInfeasible_+3A_tol">tol</code></td>
<td>
<p>Tolerance for checking against zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> for objects of class <code><a href="#topic+editset">editset</a></code>, <code><a href="#topic+editarray">editarray</a></code> or <code><a href="#topic+editmatrix">editmatrix</a></code>. 
A <code>logical</code>  vector in the case of an <code><a href="#topic+disjunct">editlist</a></code> or <code><a href="#topic+disjunct">editset</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isObviouslyRedundant">isObviouslyRedundant</a></code>, <code><a href="#topic+isFeasible">isFeasible</a></code>
</p>
<p><code><a href="#topic+eliminate">eliminate</a></code> <code><a href="#topic+editmatrix">editmatrix</a></code>
</p>

<hr>
<h2 id='isObviouslyRedundant'>Find obvious redundancies in set of edits</h2><span id='topic+isObviouslyRedundant'></span><span id='topic+isObviouslyRedundant.editmatrix'></span><span id='topic+isObviouslyRedundant.editarray'></span><span id='topic+isObviouslyRedundant.editset'></span><span id='topic+isObviouslyRedundant.editlist'></span><span id='topic+isObviouslyRedundant.editenv'></span>

<h3>Description</h3>

<p>Detect simple redundancies such as duplicates or edits of the form <code>0 &lt; 1</code> or <code>0 == 0</code>.
For categorical edits, simple redundancies are edits that define an empty subregion
of the space of all possible records (no record can ever be contained in such a region).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isObviouslyRedundant(E, duplicates = TRUE, ...)

## S3 method for class 'editmatrix'
isObviouslyRedundant(E, duplicates = TRUE, ...)

## S3 method for class 'editarray'
isObviouslyRedundant(E, duplicates = TRUE, ...)

## S3 method for class 'editset'
isObviouslyRedundant(E, duplicates = rep(TRUE, 2), ...)

## S3 method for class 'editlist'
isObviouslyRedundant(E, duplicates = rep(TRUE, 2), ...)

## S3 method for class 'editenv'
isObviouslyRedundant(E, duplicates = rep(TRUE, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isObviouslyRedundant_+3A_e">E</code></td>
<td>
<p>An <code><a href="#topic+editset">editset</a></code>, <code><a href="#topic+editmatrix">editmatrix</a></code>, <code><a href="#topic+editarray">editarray</a></code>, 
<code><a href="#topic+disjunct">editlist</a></code> or <code><a href="#topic+disjunct">editenv</a></code></p>
</td></tr>
<tr><td><code id="isObviouslyRedundant_+3A_duplicates">duplicates</code></td>
<td>
<p><code>logical</code>: check for duplicate edits? For an <code><a href="#topic+editset">editset</a></code>, 
<code><a href="base.html#topic+duplicated">editlist</a></code> or <code><a href="base.html#topic+duplicated">editenv</a></code> this should be a logical
2-vector indicating which of the numerical or categorical edits should be checked for duplicates.</p>
</td></tr>
<tr><td><code id="isObviouslyRedundant_+3A_...">...</code></td>
<td>
<p>parameters to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector indicating which edits are (obviously) redundant
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isObviouslyInfeasible">isObviouslyInfeasible</a></code>, <code><a href="#topic+isSubset">isSubset</a></code>
</p>

<hr>
<h2 id='isSubset'>Check which edits are dominated by other ones.</h2><span id='topic+isSubset'></span>

<h3>Description</h3>

<p>An edit defines a subregion of the space of all possible value combinations 
of a record. Records in this region are interpreted as invalid. An edit rule
which defines a region equal to or contained in the region defined by another
edit is redundant. (In data editing literature, this is often referred to as 
a <em>domination</em> relation.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isSubset(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isSubset_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code> vector indicating if an edit is a subset of at least one other edit.
</p>

<hr>
<h2 id='localize'>Workhorse function for localizeErrors</h2><span id='topic+localize'></span>

<h3>Description</h3>

<p>Workhorse function for localizeErrors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localize(E, dat, verbose, pretext = "Processing", call = sys.call(), weight,
  maxduration, method = c("bb", "mip", "localizer"), retrieve, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localize_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editmatrix">editmatrix</a></code> or <code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
<tr><td><code id="localize_+3A_dat">dat</code></td>
<td>
<p><code>data.frame</code></p>
</td></tr>
<tr><td><code id="localize_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> print progress report during run?</p>
</td></tr>
<tr><td><code id="localize_+3A_pretext">pretext</code></td>
<td>
<p><code>character</code> text to print before progress report</p>
</td></tr>
<tr><td><code id="localize_+3A_weight">weight</code></td>
<td>
<p>a <code>nrow(dat)xncol(dat)</code> array of weights</p>
</td></tr>
<tr><td><code id="localize_+3A_maxduration">maxduration</code></td>
<td>
<p>max time for searchBest()</p>
</td></tr>
<tr><td><code id="localize_+3A_method">method</code></td>
<td>
<p>should branch and bound (&quot;bb&quot;) or mix integer programming (&quot;mip&quot;) be used?</p>
</td></tr>
<tr><td><code id="localize_+3A_retrieve">retrieve</code></td>
<td>
<p>return <code>best</code> or <code>first</code> found solution (bb method only)</p>
</td></tr>
</table>

<hr>
<h2 id='localizeErrors'>Localize errors on records in a data.frame.</h2><span id='topic+localizeErrors'></span>

<h3>Description</h3>

<p>For each record in a <code>data.frame</code>, the least (weighted) number of fields is
determined which can be adapted or imputed so that no edit in <code>E</code> is violated. Anymore.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localizeErrors(E, dat, verbose = FALSE, weight = rep(1, ncol(dat)),
  maxduration = 600, method = c("bb", "mip", "localizer"),
  useBlocks = TRUE, retrieve = c("best", "first"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localizeErrors_+3A_e">E</code></td>
<td>
<p>an object of class <code><a href="#topic+editset">editset</a></code> <code><a href="#topic+editmatrix">editmatrix</a></code> or <code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
<tr><td><code id="localizeErrors_+3A_dat">dat</code></td>
<td>
<p>a <code>data.frame</code> with variables in E.</p>
</td></tr>
<tr><td><code id="localizeErrors_+3A_verbose">verbose</code></td>
<td>
<p>print progress to screen?</p>
</td></tr>
<tr><td><code id="localizeErrors_+3A_weight">weight</code></td>
<td>
<p>Vector of positive weights for every variable in <code>dat</code>, or 
an <code>array</code> or <code>data.frame</code> of weights with the same dimensions as <code>dat</code>.</p>
</td></tr>
<tr><td><code id="localizeErrors_+3A_maxduration">maxduration</code></td>
<td>
<p>maximum time for <code>$searchBest()</code> to find the best solution for a single record.</p>
</td></tr>
<tr><td><code id="localizeErrors_+3A_method">method</code></td>
<td>
<p>should errorlocalizer (&quot;bb&quot;) or mix integer programming (&quot;mip&quot;) be used?</p>
</td></tr>
<tr><td><code id="localizeErrors_+3A_useblocks">useBlocks</code></td>
<td>
<p><code>DEPRECATED</code>. Process error localization seperatly for independent blocks in <code>E</code> (always <code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="localizeErrors_+3A_retrieve">retrieve</code></td>
<td>
<p>Return the first found solution or the best solution? (&quot;bb&quot; method only).</p>
</td></tr>
<tr><td><code id="localizeErrors_+3A_...">...</code></td>
<td>
<p>Further options to be passed to <code><a href="#topic+errorLocalizer">errorLocalizer</a></code> or <code><a href="#topic+errorLocalizer_mip">errorLocalizer_mip</a></code>. Specifically, when
<code>method='mip'</code>, the parameter <code>lpcontrol</code> is a list of options passed to <code>lpSolveAPI</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For performance purposes, the edits are split in independent <code><a href="#topic+blocks">blocks</a></code> which are processed
separately. Also, a quick vectorized check with <code><a href="#topic+checkDatamodel">checkDatamodel</a></code> is performed first to
exclude variables violating their one-dimensional bounds from further calculations.
</p>
<p>By default, all weights are set equal to one (each variable is considered equally reliable). If a vector 
of weights is passed, the weights are assumed to be in the same order as the columns of <code>dat</code>. By passing
an array of weights (of same dimensions as <code>dat</code>) separate weights can be specified for each record.
</p>
<p>In general, the solution to an error localization problem need not be unique, especially when no weights 
are defined. In such cases, <code>localizeErrors</code> chooses a solution randomly. See <code><a href="#topic+errorLocalizer">errorLocalizer</a></code>
for more control options.
</p>
<p>Error localization can be performed by the Branch and Bound method of De Waal (2003) (option <code>method="localizer"</code>, the default) 
or by rewriting the problem as a mixed-integer programming (MIP) problem (<code>method="mip"</code>) which is parsed to
the <code>lpsolve</code> library. The former case uses <code><a href="#topic+errorLocalizer">errorLocalizer</a></code> and is very reliable in terms
of numerical stability, but may be slower in some cases (see note below). The MIP approach is much faster, 
but requires that upper and lower bounds are set on each numerical variable. Sensible bounds are derived
automatically (see the vignette on error localization as MIP), but could cause instabilities in very rare cases.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+errorLocation">errorLocation</a></code>
</p>


<h3>Note</h3>

<p>As of version 2.8.1 method 'bb' is not available for conditional numeric (e.g: <code>if (x&gt;0) y&gt;0</code>)
or conditional edits of mixed type (e.g. <code>if (A=='a') x&gt;0</code>).
</p>


<h3>References</h3>

<p>T. De Waal (2003) Processing of Erroneous and Unsafe Data. PhD thesis, University of Rotterdam.
</p>
<p>E. De Jonge and Van der Loo, M. (2012) Error localization as a mixed-integer program in 
editrules (included with the package)
</p>
<p>lp_solve and Kjell Konis. (2011). lpSolveAPI: R Interface for
lp_solve version 5.5.2.0. R package version 5.5.2.0-5.
http://CRAN.R-project.org/package=lpSolveAPI
</p>


<h3>See Also</h3>

<p><code><a href="#topic+errorLocalizer">errorLocalizer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# an editmatrix and some data:
E &lt;- editmatrix(c(
    "x + y == z",
    "x &gt; 0",
    "y &gt; 0",
    "z &gt; 0"))

dat &lt;- data.frame(
    x = c(1,-1,1),
    y = c(-1,1,1),
    z = c(2,0,2))

# localize all errors in the data
err &lt;- localizeErrors(E,dat)

summary(err)

# what has to be adapted:
err$adapt
# weight, number of equivalent solutions, timings,
err$status


## Not run

# Demonstration of verbose processing
# construct 2-block editmatrix
F &lt;- editmatrix(c(
    "x + y == z",
    "x &gt; 0",
    "y &gt; 0",
    "z &gt; 0",
    "w &gt; 10"))
# Using 'dat' as defined above, generate some extra records
dd &lt;- dat
for ( i in 1:5 ) dd &lt;- rbind(dd,dd)
dd$w &lt;- sample(12,nrow(dd),replace=TRUE)

# localize errors verbosely
(err &lt;- localizeErrors(F,dd,verbose=TRUE))

# printing is cut off, use summary for an overview
summary(err)

# or plot (not very informative in this artificial example)
plot(err)

## End(Not run)

for ( d in dir("../pkg/R",full.names=TRUE)) dmp &lt;- source(d)
# Example with different weights for each record
E &lt;- editmatrix('x + y == z')
dat &lt;- data.frame(
    x = c(1,1),
    y = c(1,1),
    z = c(1,1))

# At equal weights, both records have three solutions (degeneracy): adapt x, y
# or z:
localizeErrors(E,dat)$status

# Set different weights per record (lower weight means lower reliability):
w &lt;- matrix(c(
    1,2,2,
    2,2,1),nrow=2,byrow=TRUE)

localizeErrors(E,dat,weight=w)


# an example with categorical variables
E &lt;- editarray(expression(
    age %in% c('under aged','adult'),
    maritalStatus %in% c('unmarried','married','widowed','divorced'),
    positionInHousehold %in% c('marriage partner', 'child', 'other'),
    if( age == 'under aged' ) maritalStatus == 'unmarried',
    if( maritalStatus %in% c('married','widowed','divorced')) 
      !positionInHousehold %in% c('marriage partner','child')
    )
)
E

#
dat &lt;- data.frame(
    age = c('under aged','adult','adult' ),
    maritalStatus=c('married','unmarried','widowed' ), 
    positionInHousehold=c('child','other','marriage partner')
)
dat
localizeErrors(E,dat)
# the last record of dat has 2 degenerate solutions. Running  the last command
# a few times demonstrates that one of those solutions is chosen at random.

# Increasing the weight of  'positionInHousehold' for example, makes the best
# solution unique again
localizeErrors(E,dat,weight=c(1,1,2))


# an example with mixed data:

E &lt;- editset(expression(
    x + y == z,
    2*u  + 0.5*v == 3*w,
    w &gt;= 0,
    if ( x &gt; 0 ) y &gt; 0,
    x &gt;= 0,
    y &gt;= 0,
    z &gt;= 0,
    A %in% letters[1:4],
    B %in% letters[1:4],
    C %in% c(TRUE,FALSE),
    D %in% letters[5:8],
    if ( A %in% c('a','b') ) y &gt; 0,
    if ( A == 'c' ) B %in% letters[1:3],
    if ( !C == TRUE) D %in% c('e','f')
))

set.seed(1)
dat &lt;- data.frame(
    x = sample(-1:8),
    y = sample(-1:8),
    z = sample(10),
    u = sample(-1:8),
    v = sample(-1:8),
    w = sample(10),
    A = sample(letters[1:4],10,replace=TRUE),
    B = sample(letters[1:4],10,replace=TRUE),
    C = sample(c(TRUE,FALSE),10,replace=TRUE),
    D = sample(letters[5:9],10,replace=TRUE),
    stringsAsFactors=FALSE
)

(el &lt;-localizeErrors(E,dat,verbose=TRUE))





</code></pre>

<hr>
<h2 id='nedits'>Number of edits
Count the number of edits in a collection of edits.</h2><span id='topic+nedits'></span>

<h3>Description</h3>

<p>Number of edits
Count the number of edits in a collection of edits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nedits(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nedits_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editset">editset</a></code>, <code><a href="#topic+editarray">editarray</a></code> or <code><a href="#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='neweditarray'>editarray: logical array where every column corresponds to one
level of one variable. Every row is an edit. Every edit denotes
a *forbidden* combination.</h2><span id='topic+neweditarray'></span>

<h3>Description</h3>

<p>editarray: logical array where every column corresponds to one
level of one variable. Every row is an edit. Every edit denotes
a *forbidden* combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neweditarray(E, ind, sep, names = NULL, levels = colnames(E), ...)
</code></pre>

<hr>
<h2 id='neweditmatrix'>Create an <code>editmatrix</code> object from its constituing attributes.</h2><span id='topic+neweditmatrix'></span>

<h3>Description</h3>

<p>This function is for internal purposes, please use <code><a href="#topic+editmatrix">editmatrix</a></code> for creating an editmatrix object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neweditmatrix(A, ops, normalized = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neweditmatrix_+3A_a">A</code></td>
<td>
<p>An augmented <code>matrix</code> of the form <code>A|b</code></p>
</td></tr>
<tr><td><code id="neweditmatrix_+3A_ops">ops</code></td>
<td>
<p>a character vector with the comparison operator of every edit.</p>
</td></tr>
<tr><td><code id="neweditmatrix_+3A_normalized">normalized</code></td>
<td>
<p><code>logical</code> TRUE or FALSE</p>
</td></tr>
<tr><td><code id="neweditmatrix_+3A_...">...</code></td>
<td>
<p>optional attributes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an S3 object of class <code>editmatrix</code>
</p>

<hr>
<h2 id='newerrorlocation'>Generate new errorlocation object</h2><span id='topic+newerrorlocation'></span>

<h3>Description</h3>

<p>Generate new errorlocation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newerrorlocation(adapt, status, call = sys.call(-1), method,
  user = Sys.info()["user"], timestamp = date())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newerrorlocation_+3A_adapt">adapt</code></td>
<td>
<p>Logical array of same dimensions of dataset, indicating which variable have to be changed per record</p>
</td></tr>
<tr><td><code id="newerrorlocation_+3A_status">status</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="newerrorlocation_+3A_call">call</code></td>
<td>
<p>A <code>call</code> object</p>
</td></tr>
<tr><td><code id="newerrorlocation_+3A_user">user</code></td>
<td>
<p><code>character</code> username</p>
</td></tr>
<tr><td><code id="newerrorlocation_+3A_timestamp">timestamp</code></td>
<td>
<p><code>character</code> returned by <code>date()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='normalize'>Normalizes an editmatrix</h2><span id='topic+normalize'></span>

<h3>Description</h3>

<p>An set of linear edits of the form <code class="reqn">{\bf a}\cdot{\bf x}\odot b</code> with 
is called normalized when all  <code class="reqn">\odot\in\{==,\leq,&lt;\}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If E was normalized, the original editmatrix is returned, otherwise 
a new normalized editmatrix will be returned
</p>


<h3>See Also</h3>

<p><code><a href="#topic+editmatrix">editmatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
E &lt;- editmatrix(c( "x+3*y == 2*z"
                 , "x &gt; 2")
                 )
print(E)
                 
# get editrules, useful for storing and maintaining the rules external from your script
as.data.frame(E)
                 
# get coeficient matrix of inequalities
getA(E)

# get augmented matrix of linear edit set
getAb(E)

# get constants of inequalities (i.e. c(0, 2))                
getb(E)

# get operators of inequalities (i.e. c("==","&gt;"))
getOps(E)

# get variables of inequalities (i.e. c("x","y","z"))
getVars(E)

# isNormalized
isNormalized(E)

#normalized E
E &lt;- normalize(E)
E

# is het now normalized?
isNormalized(E)
</code></pre>

<hr>
<h2 id='parseCat'>Parse a categorical edit expression</h2><span id='topic+parseCat'></span>

<h3>Description</h3>

<p>Parse a categorical edit expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseCat(x, val = NA, edit = logical(0), sep = ":", useLogical = FALSE,
  env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseCat_+3A_x">x</code></td>
<td>
<p>a valid R expression</p>
</td></tr>
<tr><td><code id="parseCat_+3A_val">val</code></td>
<td>
<p>logical (scalar)</p>
</td></tr>
<tr><td><code id="parseCat_+3A_edit">edit</code></td>
<td>
<p>logical (vector)</p>
</td></tr>
<tr><td><code id="parseCat_+3A_sep">sep</code></td>
<td>
<p>edit separator</p>
</td></tr>
<tr><td><code id="parseCat_+3A_uselogical">useLogical</code></td>
<td>
<p>(logical), should logicals be treated as a factor or as a logical?</p>
</td></tr>
</table>

<hr>
<h2 id='parseCatEdit'>parse categorial edit</h2><span id='topic+parseCatEdit'></span>

<h3>Description</h3>

<p>parse categorial edit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseCatEdit(el)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseCatEdit_+3A_e">e</code></td>
<td>
<p><code>expression</code> with a single edit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named <code>numeric</code> with coefficients
</p>

<hr>
<h2 id='parseEdits'>Parse a character vector of edits</h2><span id='topic+parseEdits'></span>

<h3>Description</h3>

<p>This function wraps the native <code>parse</code> function in a <code>tryCatch</code>.
The function is <code>editrules</code> internal. It tries to give a meaningfull error message when
parsing fails for some reason.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseEdits(E, type = c("all", "num", "cat", "mix"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseEdits_+3A_e">E</code></td>
<td>
<p><code>character</code></p>
</td></tr>
<tr><td><code id="parseEdits_+3A_type">type</code></td>
<td>
<p>optional filter for type of edit, may be <code>"all"</code>, <code>"num"</code>
<code>"cat"</code> or <code>"mix"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The edits in <code>E</code> parsed to R expressions.
</p>

<hr>
<h2 id='parseMix'>Parse a mixed edit</h2><span id='topic+parseMix'></span>

<h3>Description</h3>

<p>parseMix replaces all numerical edits with a generated dummy boolean variable and returns the resulting categorical
edit plus the list of found of numerical edits. These expressions should be handled further by <code>parseCat</code> and 
<code>parseNum</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseMix(e, editname = "", numid = 0, negate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseMix_+3A_e">e</code></td>
<td>
<p>expression to be parsed</p>
</td></tr>
<tr><td><code id="parseMix_+3A_numid">numid</code></td>
<td>
<p>starting number for dummy name generation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with categorical expression (<code>cat</code>), which is normalized,  a numerical expression (codenums) 
and a negated version of this  expression (codenegNums)
</p>

<hr>
<h2 id='parseNum'>Parse a numerical edit expression</h2><span id='topic+parseNum'></span>

<h3>Description</h3>

<p>Parse a numerical edit expression into a named <code>numeric</code>.
The <code>names</code> are the names of the variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseNum(e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseNum_+3A_e">e</code></td>
<td>
<p>a valid R expression</p>
</td></tr>
</table>

<hr>
<h2 id='print.backtracker'>print a backtracker</h2><span id='topic+print.backtracker'></span>

<h3>Description</h3>

<p>print a backtracker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'backtracker'
print(x, ..., VERBOSE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.backtracker_+3A_x">x</code></td>
<td>
<p>backtracker object to be printed</p>
</td></tr>
<tr><td><code id="print.backtracker_+3A_...">...</code></td>
<td>
<p>other parameters passed to print method</p>
</td></tr>
<tr><td><code id="print.backtracker_+3A_verbose">VERBOSE</code></td>
<td>
<p>should all variables be printed?</p>
</td></tr>
</table>

<hr>
<h2 id='print.cateditmatrix'>print cateditmatrix</h2><span id='topic+print.cateditmatrix'></span>

<h3>Description</h3>

<p>print cateditmatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cateditmatrix'
print(x, textOnly = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cateditmatrix_+3A_x">x</code></td>
<td>
<p>cateditmatrix object to be printed</p>
</td></tr>
<tr><td><code id="print.cateditmatrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.editarray'>print  editarray</h2><span id='topic+print.editarray'></span>

<h3>Description</h3>

<p>print  editarray
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editarray'
print(x, textOnly = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.editarray_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
<tr><td><code id="print.editarray_+3A_textonly">textOnly</code></td>
<td>
<p>If <code>FALSE</code>, also print internal structure</p>
</td></tr>
<tr><td><code id="print.editarray_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.editlist'>print editset</h2><span id='topic+print.editlist'></span>

<h3>Description</h3>

<p>print editset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editlist'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.editlist_+3A_x">x</code></td>
<td>
<p>editset object to be printed</p>
</td></tr>
<tr><td><code id="print.editlist_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.editmatrix'>print editmatrix</h2><span id='topic+print.editmatrix'></span>

<h3>Description</h3>

<p>print editmatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editmatrix'
print(x, textOnly = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.editmatrix_+3A_x">x</code></td>
<td>
<p>editmatrix object to be printed</p>
</td></tr>
<tr><td><code id="print.editmatrix_+3A_textonly">textOnly</code></td>
<td>
<p>If <code>FALSE</code>, also print internal structure</p>
</td></tr>
<tr><td><code id="print.editmatrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.editset'>print editset</h2><span id='topic+print.editset'></span>

<h3>Description</h3>

<p>print editset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editset'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.editset_+3A_x">x</code></td>
<td>
<p>editset object to be printed</p>
</td></tr>
<tr><td><code id="print.editset_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.editsummary'>summary</h2><span id='topic+print.editsummary'></span>

<h3>Description</h3>

<p>summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editsummary'
print(x, ...)
</code></pre>

<hr>
<h2 id='print.errorLocation'>Print object of class errorLocation</h2><span id='topic+print.errorLocation'></span>

<h3>Description</h3>

<p>Print object of class errorLocation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'errorLocation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.errorLocation_+3A_x">x</code></td>
<td>
<p>object of class errorLocation</p>
</td></tr>
<tr><td><code id="print.errorLocation_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods</p>
</td></tr>
</table>

<hr>
<h2 id='print.locationsummary'>summary</h2><span id='topic+print.locationsummary'></span>

<h3>Description</h3>

<p>summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locationsummary'
print(x, ...)
</code></pre>

<hr>
<h2 id='print.violatedEdits'>Print violatedEdits</h2><span id='topic+print.violatedEdits'></span>

<h3>Description</h3>

<p>Print violatedEdits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'violatedEdits'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.violatedEdits_+3A_x">x</code></td>
<td>
<p>violatedEdits</p>
</td></tr>
</table>

<hr>
<h2 id='reduce'>Remove redundant variables and edits.</h2><span id='topic+reduce'></span><span id='topic+reduce.editmatrix'></span><span id='topic+reduce.editarray'></span><span id='topic+reduce.editset'></span>

<h3>Description</h3>

<p>Remove variables which are not contained in any edit and remove edits which are 
<code><a href="#topic+isObviouslyRedundant">obviously redundant</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce(E, ...)

## S3 method for class 'editmatrix'
reduce(E, tol = sqrt(.Machine$double.eps), ...)

## S3 method for class 'editarray'
reduce(E, ...)

## S3 method for class 'editset'
reduce(E, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editmatrix">editmatrix</a></code> or <code><a href="#topic+editarray">editarray</a></code></p>
</td></tr>
<tr><td><code id="reduce_+3A_...">...</code></td>
<td>
<p>arguments to pass to other methods</p>
</td></tr>
<tr><td><code id="reduce_+3A_tol">tol</code></td>
<td>
<p>elements of <code>E</code> with absolute value &lt; <code>tol</code> are considered 0.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+contains">contains</a></code>, <code><a href="#topic+eliminate">eliminate</a></code>, <code><a href="#topic+substValue">substValue</a></code>
</p>

<hr>
<h2 id='removeRedundantDummies'>Remove redundant dummy variables</h2><span id='topic+removeRedundantDummies'></span>

<h3>Description</h3>

<p>Remove duplicated dummy variables from an editset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeRedundantDummies(E, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeRedundantDummies_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editset">editset</a></code></p>
</td></tr>
<tr><td><code id="removeRedundantDummies_+3A_tol">tol</code></td>
<td>
<p>positive number</p>
</td></tr>
</table>

<hr>
<h2 id='separate'>Separate an editset into its disconnected blocks and simplify</h2><span id='topic+separate'></span>

<h3>Description</h3>

<p>The input edits are separated into disjunct blocks, and simplified to
<code>editmatrix</code> or <code><a href="#topic+editarray">editarray</a></code> where possible. Remaining
<code><a href="#topic+editset">editsets</a></code> are separated into <code><a href="#topic+disjunct">disjunct</a></code>  
<code><a href="#topic+disjunct">editlists</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_+3A_e">E</code></td>
<td>
<p>An <code><a href="#topic+editset">editset</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> where each element is either an <code><a href="#topic+editmatrix">editmatrix</a></code>, an <code><a href="#topic+editarray">editarray</a></code>
or an object of class <code><a href="#topic+disjunct">editlist</a></code> which cannot be simplified further.
</p>


<h3>References</h3>

<p>M. van der Loo and De Jonge, E. (2012). Manipulation of conditional restrictions and error localization
with the editrules package. Discussion paper 2012xx, Statistics Netherlands, The Hague 
(included with the package).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blocks">blocks</a></code>, <code><a href="#topic+disjunct">disjunct</a></code>, <code><a href="#topic+condition">condition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

E &lt;- editset(expression(
    x + y == z,
    2*u  + 0.5*v == 3*w,
    w &gt;= 0,
    if ( x &gt; 0 ) y &gt; 0,
    x &gt;= 0,
    y &gt;= 0,
    z &gt;= 0,
    A %in% letters[1:4],
    B %in% letters[1:4],
    C %in% c(TRUE,FALSE),
    D %in% letters[5:8],
    if ( A %in% c('a','b') ) y &gt; 0,
    if ( A == 'c' ) B %in% letters[1:3],
    if ( !C == TRUE) D %in% c('e','f')
))

(L &lt;- separate(E))

sapply(L,class)






</code></pre>

<hr>
<h2 id='simplify'>Simplify logical mixed edits in an editset</h2><span id='topic+simplify'></span>

<h3>Description</h3>

<p>Logical edits consisting of a single numerical statement are
inverted and added to the <code>editmatrix</code> (<code>\$num</code>) of the editset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify(E, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_+3A_e">E</code></td>
<td>
<p>an editset</p>
</td></tr>
<tr><td><code id="simplify_+3A_m">m</code></td>
<td>
<p><code>contains(E)</code>. Speeds up calculation if you have one handy.</p>
</td></tr>
</table>

<hr>
<h2 id='softEdits'>Derive editmatrix with soft constraints based on boundaries of variables. This is a utility function that is used for 
constructing a mip/lp problem.</h2><span id='topic+softEdits'></span>

<h3>Description</h3>

<p>Derive editmatrix with soft constraints based on boundaries of variables. This is a utility function that is used for 
constructing a mip/lp problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>softEdits(E, prefix = "delta.", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="softEdits_+3A_e">E</code></td>
<td>
<p>normalized <code>editmatrix</code></p>
</td></tr>
<tr><td><code id="softEdits_+3A_prefix">prefix</code></td>
<td>
<p><code>character</code> used for naming dummy variables in matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='softEdits.cateditmatrix'>Derive editmatrix with soft constraints. This is a utility function that is used for 
constructing a mip/lp problem.</h2><span id='topic+softEdits.cateditmatrix'></span>

<h3>Description</h3>

<p>Derive editmatrix with soft constraints. This is a utility function that is used for 
constructing a mip/lp problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cateditmatrix'
softEdits(E, prefix = "delta.", postfix = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="softEdits.cateditmatrix_+3A_e">E</code></td>
<td>
<p>normalized <code>editmatrix</code></p>
</td></tr>
<tr><td><code id="softEdits.cateditmatrix_+3A_prefix">prefix</code></td>
<td>
<p><code>character</code> used for naming dummy variables in matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='softEdits.editarray'>Derive editmatrix with soft constraints based on boundaries of variables. This is a utility function that is used for 
constructing a mip/lp problem.</h2><span id='topic+softEdits.editarray'></span>

<h3>Description</h3>

<p>Derive editmatrix with soft constraints based on boundaries of variables. This is a utility function that is used for 
constructing a mip/lp problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editarray'
softEdits(E, prefix = "delta.", postfix = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="softEdits.editarray_+3A_e">E</code></td>
<td>
<p>normalized <code>editmatrix</code></p>
</td></tr>
<tr><td><code id="softEdits.editarray_+3A_prefix">prefix</code></td>
<td>
<p><code>character</code> used for naming dummy variables in matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='softEdits.editmatrix'>Derive editmatrix with soft constraints based on boundaries of variables. This is a utility function that is used for 
constructing a mip/lp problem.</h2><span id='topic+softEdits.editmatrix'></span>

<h3>Description</h3>

<p>Derive editmatrix with soft constraints based on boundaries of variables. This is a utility function that is used for 
constructing a mip/lp problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'editmatrix'
softEdits(E, prefix = "delta.", postfix = "",
  M = 1e+07, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="softEdits.editmatrix_+3A_e">E</code></td>
<td>
<p>normalized <code>editmatrix</code></p>
</td></tr>
<tr><td><code id="softEdits.editmatrix_+3A_prefix">prefix</code></td>
<td>
<p><code>character</code> used for naming dummy variables in matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='substValue'>Replace a variable by a value in a set of edits.</h2><span id='topic+substValue'></span><span id='topic+substValue.editmatrix'></span><span id='topic+substValue.editarray'></span><span id='topic+substValue.editset'></span><span id='topic+substValue.editlist'></span><span id='topic+substValue.editenv'></span>

<h3>Description</h3>

<p>Replace a variable by a value in a set of edits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substValue(E, var, value, ...)

## S3 method for class 'editmatrix'
substValue(E, var, value, reduce = FALSE,
  removeredundant = TRUE, ...)

## S3 method for class 'editarray'
substValue(E, var, value, reduce = FALSE, ...)

## S3 method for class 'editset'
substValue(E, var, value, simplify = TRUE, ...)

## S3 method for class 'editlist'
substValue(E, var, value, ...)

## S3 method for class 'editenv'
substValue(E, var, value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="substValue_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editset">editset</a></code>, <code><a href="#topic+editmatrix">editmatrix</a></code>, <code><a href="#topic+editarray">editarray</a></code>, 
<code><a href="#topic+disjunct">editlist</a></code> or <code><a href="#topic+disjunct">editenv</a></code></p>
</td></tr>
<tr><td><code id="substValue_+3A_var">var</code></td>
<td>
<p><code>character</code> with name(s) of variable(s) to substitute</p>
</td></tr>
<tr><td><code id="substValue_+3A_value">value</code></td>
<td>
<p>vector with value(s) of variable(s)</p>
</td></tr>
<tr><td><code id="substValue_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods</p>
</td></tr>
<tr><td><code id="substValue_+3A_reduce">reduce</code></td>
<td>
<p><code>logical</code> should the result be simplified? For <code><a href="#topic+editmatrix">editmatrix</a></code> this has the same effect
as calling the function <code><a href="#topic+reduce">reduce</a></code>. For <code><a href="#topic+editarray">editarray</a></code>, the datamodel of the substituted variable
is reduced to a single value, and the variable itself is not removed.</p>
</td></tr>
<tr><td><code id="substValue_+3A_removeredundant">removeredundant</code></td>
<td>
<p><code>logical</code>. Should empty rows be removed?</p>
</td></tr>
<tr><td><code id="substValue_+3A_simplify">simplify</code></td>
<td>
<p>Simplify editset by moving logical edits containing a single
numerical statement to the pure numerical part? (This is mostly for internal purposes
and overwriting the default should normally not be necessary for package users).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>E</code>, with variables replaced by values
</p>


<h3>Note</h3>

<p>At the moment, objects of class <code><a href="#topic+disjunct">editenv</a></code> are converted to <code>list</code>
prior to processing (so no performance is gained there) and reconverted afterwards.
</p>


<h3>References</h3>

<p>Value substitution is extensively described in the package vignettes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eliminate">eliminate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

E &lt;- editmatrix(expression(
    x + y == z,
    2*y &lt; 10,
    3*x + 1.5*u &lt; 7,
    z &gt;= 0
    )
)

# single value
substValue(E,'z',10)
# multiple values
substValue(E,c('x','y'),c(1,3))
# remove substituted variable from edits
substValue(E,'z',10,reduce=TRUE)
# do not remove redundant row:
substValue(E,'z',10,removeredundant=FALSE)


# example with an editset
E &lt;- editset(expression(
    x  + y == z,
    x &gt;= 0,
    y &gt;= 0,
    A %in% c('a1','a2'),
    B %in% c('b1','b2'),
    if ( x &gt; 0 ) y &gt; 0,
    if ( y &gt; 0 ) x &gt; 0,
    if ( A == 'a' ) B == 'b',
    if ( A == 'b' ) y &gt; 3
    )
)

# substitute pure numerical variable
substValue(E,'z',10)
# substitute pure categorical variable
substValue(E,'A','a1')
# substitute variable appearing in logical constraints
substValue(E,'x',3)



</code></pre>

<hr>
<h2 id='violatedEdits'>Check data against constraints</h2><span id='topic+violatedEdits'></span><span id='topic+violatedEdits.character'></span><span id='topic+violatedEdits.editmatrix'></span><span id='topic+violatedEdits.editarray'></span><span id='topic+violatedEdits.editset'></span><span id='topic+plot.violatedEdits'></span><span id='topic+summary.violatedEdits'></span><span id='topic+as.data.frame.violatedEdits'></span>

<h3>Description</h3>

<p>Determine which record violates which edits. Returns <code>NA</code> when edits
cannot be checked because of missing values in the data.
</p>

<ul>
<li><p>For rules of the form Ax == b  |Ax - b| &lt;= tol is returned.
</p>
</li>
<li><p>For rules of the form Ax &lt; b, Ax - b &lt; tol is returned.
</p>
</li>
<li><p>For rules of the form Ax &lt;= b Ax- b &lt;= tol is returned.
</p>
</li></ul>

<p>For numerical records, the default tolerance is 0. When working with doubles, 
the square root of machina accuracy is a resonable alternative (<code>sqrt(.Machine\$double.eps)</code>).
The editmatrix is <cite><a href="#topic+normalize">normalized</a></cite> before checks are performed.
</p>
<p>Plot summary statistics on violatedEdits
</p>
<p>as.data.frame violatedEdits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>violatedEdits(E, dat, ...)

## S3 method for class 'character'
violatedEdits(E, dat, name = NULL, ...)

## S3 method for class 'editmatrix'
violatedEdits(E, dat, tol = 0, ...)

## S3 method for class 'editarray'
violatedEdits(E, dat, datamodel = TRUE, ...)

## S3 method for class 'editset'
violatedEdits(E, dat, datamodel = TRUE, ...)

## S3 method for class 'violatedEdits'
plot(x, topn = min(10, ncol(x)), ...)

## S3 method for class 'violatedEdits'
summary(object, E = NULL, minfreq = 1, ...)

## S3 method for class 'violatedEdits'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="violatedEdits_+3A_e">E</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> vector with constraintsm, <code><a href="#topic+editset">editset</a></code>, <code><a href="#topic+editmatrix">editmatrix</a></code> or <code><a href="#topic+editarray">editarray</a></code>.</p>
</td></tr>
<tr><td><code id="violatedEdits_+3A_dat">dat</code></td>
<td>
<p><code>data.frame</code> with data that should be checked, if a named vector is supplied it will converted internally to a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="violatedEdits_+3A_...">...</code></td>
<td>
<p>further arguments that can be used by methods implementing this generic function</p>
</td></tr>
<tr><td><code id="violatedEdits_+3A_name">name</code></td>
<td>
<p>name of edits</p>
</td></tr>
<tr><td><code id="violatedEdits_+3A_tol">tol</code></td>
<td>
<p>tolerance to check rules against.</p>
</td></tr>
<tr><td><code id="violatedEdits_+3A_datamodel">datamodel</code></td>
<td>
<p>Also check against datamodel?</p>
</td></tr>
<tr><td><code id="violatedEdits_+3A_x">x</code></td>
<td>
<p><code>violatedEdits</code> object.</p>
</td></tr>
<tr><td><code id="violatedEdits_+3A_topn">topn</code></td>
<td>
<p>Top <code>n</code> edits to be plotted.</p>
</td></tr>
<tr><td><code id="violatedEdits_+3A_object">object</code></td>
<td>
<p><code>violatedEdits</code> object</p>
</td></tr>
<tr><td><code id="violatedEdits_+3A_minfreq">minfreq</code></td>
<td>
<p>minimum freq for edit to be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>violatedEdits</code>, which is a logical <code>nrow(dat)Xnedits(E)</code> matrix with an extra <code>class</code> attribute
for overloading purposes.
</p>


<h3>Note</h3>

<p>When summarizing an object of class <code>violatedEdits</code>, every 
empty value is counted as one edit violation when counting violations per record.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkDatamodel">checkDatamodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using character vector to define contraints
E &lt;- editmatrix(c( "x+3*y==2*z"
                  , "x==z"
                  )
                )
                
dat &lt;- data.frame( x = c(0,2,1)
                 , y = c(0,0,1)
                 , z = c(0,1,1)
                 )
print(dat)

ve &lt;- violatedEdits(E,dat)

print(ve)
summary(ve, E)
plot(ve)

# An example with categorical data:

E &lt;- editarray(expression(
    gender %in% c('male','female'),
    pregnant %in% c(TRUE, FALSE),
    if( gender == 'male' ) !pregnant
    )
)
print(E)

dat &lt;- data.frame(
    gender=c('male','male','female','cylon'), 
    pregnant=c(TRUE,FALSE,TRUE,TRUE)
)

print(dat)
# Standard, the datamodel is checked as well,
violatedEdits(E,dat)

# but we may turn this of
violatedEdits(E,dat,datamodel=FALSE)


</code></pre>

<hr>
<h2 id='writeELAsMip'>Rewrite an editset and reported values into the components needed for a mip solver</h2><span id='topic+writeELAsMip'></span>

<h3>Description</h3>

<p>Rewrite an editset and reported values into the components needed for a mip solver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeELAsMip(E, x, weight = rep(1, length(x)), M = 1e+07, epsilon = 0.001,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeELAsMip_+3A_e">E</code></td>
<td>
<p><code><a href="#topic+editset">editset</a></code> or any object that is coercable to an editset.</p>
</td></tr>
<tr><td><code id="writeELAsMip_+3A_x">x</code></td>
<td>
<p>named <code>list</code> or <code>vector</code> with data</p>
</td></tr>
<tr><td><code id="writeELAsMip_+3A_weight">weight</code></td>
<td>
<p>vector with weights of the variable in the same order as x</p>
</td></tr>
<tr><td><code id="writeELAsMip_+3A_m">M</code></td>
<td>
<p>maximum allowed difference between reported value and corrected value</p>
</td></tr>
<tr><td><code id="writeELAsMip_+3A_epsilon">epsilon</code></td>
<td>
<p>offset needed for writing a strict inequality into a an inequality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with an editmatrix, objfn, binvars, numvars, M and epsilon
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
