<!DOCTYPE html><html><head><title>Help for package moder</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {moder}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mode_all'><p>All modes</p></a></li>
<li><a href='#mode_count'><p>Modal count</p></a></li>
<li><a href='#mode_count_range'><p>Modal count range</p></a></li>
<li><a href='#mode_first'><p>The first-appearing mode</p></a></li>
<li><a href='#mode_frequency'><p>Modal frequency</p></a></li>
<li><a href='#mode_frequency_range'><p>Modal frequency range</p></a></li>
<li><a href='#mode_is_trivial'><p>Is the mode trivial?</p></a></li>
<li><a href='#mode_single'><p>The single mode</p></a></li>
<li><a href='#mode-possible'><p>Possible sets of modes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Mode Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Determines single or multiple modes (most frequent values).
    Checks if missing values make this impossible, and returns 'NA'
    in this case. Dependency-free source code. See Franzese and Iuliano (2019)
    &lt;<a href="https://doi.org/10.1016%2FB978-0-12-809633-8.20354-3">doi:10.1016/B978-0-12-809633-8.20354-3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, knitr, rmarkdown, stats, testthat (&ge; 3.0.0), utils</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lhdjung/moder">https://github.com/lhdjung/moder</a>, <a href="https://lhdjung.github.io/moder/">https://lhdjung.github.io/moder/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lhdjung/moder/issues">https://github.com/lhdjung/moder/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-05 16:59:41 UTC; lukasjung</td>
</tr>
<tr>
<td>Author:</td>
<td>Lukas Jung [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lukas Jung &lt;jung-lukas@gmx.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-07 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mode_all'>All modes</h2><span id='topic+mode_all'></span>

<h3>Description</h3>

<p><code>mode_all()</code> returns the set of all modes in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_all(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode_all_+3A_x">x</code></td>
<td>
<p>A vector to search for its modes.</p>
</td></tr>
<tr><td><code id="mode_all_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean. Should missing values in <code>x</code> be removed before
computation proceeds? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with all modes (values tied for most frequent) in <code>x</code>. If
the modes can't be determined because of missing values,
returns <code>NA</code> instead.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+mode_first">mode_first()</a></code> for the first-appearing mode.
</p>
</li>
<li> <p><code><a href="#topic+mode_single">mode_single()</a></code> for the <em>only</em> mode, or <code>NA</code> if there are more.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Both `3` and `4` are the modes:
mode_all(c(1, 2, 3, 3, 4, 4))

# Only `8` is:
mode_all(c(8, 8, 9))

# Can't determine the modes here --
# `9` might be another mode:
mode_all(c(8, 8, 9, NA))

# Either `1` or `2` could be a
# single mode, depending on `NA`:
mode_all(c(1, 1, 2, 2, NA))

# `1` is the most frequent value,
# no matter what `NA` stands for:
mode_all(c(1, 1, 1, 2, NA))

# Ignore `NA`s with `na.rm = TRUE`
# (there should be good reasons for this!):
mode_all(c(8, 8, 9, NA), na.rm = TRUE)
mode_all(c(1, 1, 2, 2, NA), na.rm = TRUE)
</code></pre>

<hr>
<h2 id='mode_count'>Modal count</h2><span id='topic+mode_count'></span>

<h3>Description</h3>

<p><code>mode_count()</code> counts the modes in a vector. Thin wrapper around
<code><a href="#topic+mode_all">mode_all()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_count(x, na.rm = FALSE, max_unique = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode_count_+3A_x">x</code></td>
<td>
<p>A vector to search for its modes.</p>
</td></tr>
<tr><td><code id="mode_count_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean. Should missing values in <code>x</code> be removed before
computation proceeds? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mode_count_+3A_max_unique">max_unique</code></td>
<td>
<p>Numeric or string. If the maximum number of unique values
in <code>x</code> is known, set <code>max_unique</code> to that number. This rules out that <code>NA</code>s
represent values beyond that number (see examples). Set it to <code>"known"</code>
instead if no values beyond those already known can occur. Default is
<code>NULL</code>, which assumes no maximum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer. Number of modes (values tied for most frequent) in <code>x</code>. If
the modes can't be determined because of missing values,
returns <code>NA</code> instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There are two modes, `3` and `4`:
mode_count(c(1, 2, 3, 3, 4, 4))

# Only one mode, `8`:
mode_count(c(8, 8, 9))

# Can't determine the number of modes
# here -- `9` might be another mode:
mode_count(c(8, 8, 9, NA))

# Either `1` or `2` could be a
# single mode, depending on `NA`:
mode_count(c(1, 1, 2, 2, NA))

# `1` is the most frequent value,
# no matter what `NA` stands for:
mode_count(c(1, 1, 1, 2, NA))

# Ignore `NA`s with `na.rm = TRUE`
# (there should be good reasons for this!):
mode_count(c(8, 8, 9, NA), na.rm = TRUE)
mode_count(c(1, 1, 2, 2, NA), na.rm = TRUE)
</code></pre>

<hr>
<h2 id='mode_count_range'>Modal count range</h2><span id='topic+mode_count_range'></span>

<h3>Description</h3>

<p><code>mode_count_range()</code> determines the minimal and maximal number
of modes given the number of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_count_range(x, max_unique = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode_count_range_+3A_x">x</code></td>
<td>
<p>A vector to search for its possible modes.</p>
</td></tr>
<tr><td><code id="mode_count_range_+3A_max_unique">max_unique</code></td>
<td>
<p>Numeric or string. If the maximum number of unique values
in <code>x</code> is known, set <code>max_unique</code> to that number. This rules out that <code>NA</code>s
represent values beyond that number (see examples). Set it to <code>"known"</code>
instead if no values beyond those already known can occur. Default is
<code>NULL</code>, which assumes no maximum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a factor, <code>max_unique</code> should be <code>"known"</code> or there is a
warning. This is because a factor's levels are supposed to include all of
its possible values.
</p>


<h3>Value</h3>

<p>Integer (length 2). Minimal and maximal number of modes (values tied
for most frequent) in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If `NA` is `7` or `8`, that number is
# the only mode; otherwise, both numbers
# are modes:
mode_count_range(c(7, 7, 8, 8, NA))

# Same result here -- `7` is the only mode
# unless `NA` is secretly `8`, in which case
# there are two modes:
mode_count_range(c(7, 7, 7, 8, 8, NA))

# But now, there is now way for `8` to be
# as frequent as `7`:
mode_count_range(c(7, 7, 7, 7, 8, 8, NA))

# The `NA`s might form a new mode here
# if they are both, e.g., `9`:
mode_count_range(c(7, 7, 8, 8, NA, NA))

# However, if there can be no values beyond
# those already known -- `7` and `8` --
# the `NA`s can't form a new mode.
# Specify this with `max_unique = "known"`:
mode_count_range(c(7, 7, 8, 8, NA, NA), max_unique = "known")
</code></pre>

<hr>
<h2 id='mode_first'>The first-appearing mode</h2><span id='topic+mode_first'></span>

<h3>Description</h3>

<p><code>mode_first()</code> returns the mode that appears first in a vector, i.e., before
any other modes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_first(x, na.rm = FALSE, accept = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode_first_+3A_x">x</code></td>
<td>
<p>A vector to search for its first mode.</p>
</td></tr>
<tr><td><code id="mode_first_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean. Should missing values in <code>x</code> be removed before
computation proceeds? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mode_first_+3A_accept">accept</code></td>
<td>
<p>Boolean. Should the first-appearing value known to be a mode be
accepted? If <code>FALSE</code> (the default), returns <code>NA</code> if a value that appears
earlier might be another mode due to missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first mode (most frequent value) in <code>x</code>. If it can't be
determined because of missing values, returns <code>NA</code> instead.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+mode_all">mode_all()</a></code> for the full set of modes.
</p>
</li>
<li> <p><code><a href="#topic+mode_single">mode_single()</a></code> for the <em>only</em> mode, or <code>NA</code> if there are more.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># `2` is most frequent:
mode_first(c(1, 2, 2, 2, 3))

# Can't determine the first mode --
# it might be `1` or `2` depending
# on the true value behind `NA:
mode_first(c(1, 1, 2, 2, NA))

# Ignore `NA`s with `na.rm = TRUE`
# (there should be good reasons for this!):
mode_first(c(1, 1, 2, 2, NA), na.rm = TRUE)

# `1` is the most frequent value,
# no matter what `NA` stands for:
mode_first(c(1, 1, 1, 2, NA))

# By default, the function insists on
# the first mode, so it won't accept the
# first value *known* to be a mode if an
# earlier value might be a mode, too:
mode_first(c(1, 2, 2, NA))

# You may accept the first-known mode:
mode_first(c(1, 2, 2, NA), accept = TRUE)
</code></pre>

<hr>
<h2 id='mode_frequency'>Modal frequency</h2><span id='topic+mode_frequency'></span>

<h3>Description</h3>

<p>Call <code>mode_frequency()</code> to get the number of times that a
vector's mode appears in the vector.
</p>
<p>See <code><a href="#topic+mode_frequency_range">mode_frequency_range()</a></code> for bounds on an unknown frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_frequency(x, na.rm = FALSE, max_unique = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode_frequency_+3A_x">x</code></td>
<td>
<p>A vector to check for its modal frequency.</p>
</td></tr>
<tr><td><code id="mode_frequency_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean. Should missing values in <code>x</code> be removed before
computation proceeds? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mode_frequency_+3A_max_unique">max_unique</code></td>
<td>
<p>Numeric or string. If the maximum number of unique values
in <code>x</code> is known, set <code>max_unique</code> to that number. This rules out that <code>NA</code>s
represent values beyond that number (see examples). Set it to <code>"known"</code>
instead if no values beyond those already known can occur. Default is
<code>NULL</code>, which assumes no maximum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default (<code>na.rm = FALSE</code>), the function returns <code>NA</code> if any
values are missing. That is because missings make the frequency uncertain
even if the mode is known: any missing value may or may not be the mode,
and hence count towards the modal frequency.
</p>


<h3>Value</h3>

<p>Integer (length 1) or <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mode_first">mode_first()</a></code>, which the function wraps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The mode, `9`, appears three times:
mode_frequency(c(7, 8, 8, 9, 9, 9))

# With missing values, the frequency
# is unknown, even if the mode isn't:
mode_frequency(c(1, 1, NA))

# You can ignore this problem and
# determine the frequency among known values
# (there should be good reasons for this!):
mode_frequency(c(1, 1, NA), na.rm = TRUE)
</code></pre>

<hr>
<h2 id='mode_frequency_range'>Modal frequency range</h2><span id='topic+mode_frequency_range'></span>

<h3>Description</h3>

<p><code>mode_frequency_range()</code> determines the minimum and maximum
number of times that a vector's mode appears in the vector. The minimum
assumes that no <code>NA</code>s are the mode; the maximum assumes that all <code>NA</code>s are.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_frequency_range(x, max_unique = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode_frequency_range_+3A_x">x</code></td>
<td>
<p>A vector to check for its modal frequency.</p>
</td></tr>
<tr><td><code id="mode_frequency_range_+3A_max_unique">max_unique</code></td>
<td>
<p>Numeric or string. If the maximum number of unique values
in <code>x</code> is known, set <code>max_unique</code> to that number. This rules out that <code>NA</code>s
represent values beyond that number (see examples). Set it to <code>"known"</code>
instead if no values beyond those already known can occur. Default is
<code>NULL</code>, which assumes no maximum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are no <code>NA</code>s in <code>x</code>, the two return values are identical.
If all <code>x</code> values are <code>NA</code>, the return values are <code>1</code> (no two <code>x</code> values
are the same) and the total number of values (all <code>x</code> values are the same).
</p>


<h3>Value</h3>

<p>Integer (length 2).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mode_frequency">mode_frequency()</a></code>, for the precise frequency (or <code>NA</code> if it can't
be determined).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The mode is `7`. It appears four or
# five times because the `NA` might
# also be a `7`:
mode_frequency_range(c(7, 7, 7, 7, 8, 8, NA))

# All of `"c"`, `"d"`, and `"e"` are the modes,
# and each of them appears twice:
mode_frequency_range(c("a", "b", "c", "c", "d", "d", "e", "e"))
</code></pre>

<hr>
<h2 id='mode_is_trivial'>Is the mode trivial?</h2><span id='topic+mode_is_trivial'></span>

<h3>Description</h3>

<p><code>mode_is_trivial()</code> checks whether all values in a given vector
are equally frequent. The mode is not too informative in such cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_is_trivial(x, na.rm = FALSE, max_unique = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode_is_trivial_+3A_x">x</code></td>
<td>
<p>A vector to search for its modes.</p>
</td></tr>
<tr><td><code id="mode_is_trivial_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean. Should missing values in <code>x</code> be removed before
computation proceeds? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mode_is_trivial_+3A_max_unique">max_unique</code></td>
<td>
<p>Numeric or string. If the maximum number of unique values
in <code>x</code> is known, set <code>max_unique</code> to that number. This rules out that <code>NA</code>s
represent values beyond that number (see examples). Set it to <code>"known"</code>
instead if no values beyond those already known can occur. Default is
<code>NULL</code>, which assumes no maximum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns <code>TRUE</code> whenever <code>x</code> has length &lt; 3 because no
value is more frequent than another one. Otherwise, it returns <code>NA</code> in
these cases:
</p>

<ul>
<li><p> Some <code>x</code> values are missing and all known values are equal. Thus, it is
unknown whether there is a value with a different frequency.
</p>
</li>
<li><p> All known values are modes if the <code>NA</code>s &quot;fill up&quot; the non-modal values
exactly, i.e., without any <code>NA</code>s remaining.
</p>
</li>
<li><p> Some <code>NA</code>s remain after &quot;filling up&quot; the non-modal values with <code>NA</code>s (so
that they are hypothetically modes), and the number of remaining <code>NA</code>s is
divisible by the number of unique known values.
</p>
</li>
<li><p> There are so many missing values that they might form mode-sized groups
of values that are not among the known values, and the number of <code>NA</code>s is
divisible by the modal frequency so that all (partly hypothetical) values
might be equally frequent. You can limit the number of such hypothetical
values by specifying <code>max_unique</code>. The function might then return <code>FALSE</code>
instead of <code>NA</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Boolean (length 1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The mode is trivial if
# all values are equal...
mode_is_trivial(c(1, 1, 1))

# ...and even if all unique
# values are equally frequent:
mode_is_trivial(c(1, 1, 2, 2))

# It's also trivial if
# all values are different:
mode_is_trivial(c(1, 2, 3))

# Here, the mode is nontrivial
# because `1` is more frequent than `2`:
mode_is_trivial(c(1, 1, 2))

# Two of the `NA`s might be `8`s, and
# the other three might represent a value
# different from both `7` and `8`. Thus,
# it's possible that all three distinct
# values are equally frequent:
mode_is_trivial(c(7, 7, 7, 8, rep(NA, 5)))

# The same is not true if all values,
# even the missing ones, must represent
# one of the known values:
mode_is_trivial(c(7, 7, 7, 8, rep(NA, 5)), max_unique = "known")
</code></pre>

<hr>
<h2 id='mode_single'>The single mode</h2><span id='topic+mode_single'></span>

<h3>Description</h3>

<p><code>mode_single()</code> returns the only mode in a vector. If there are multiple
modes, it returns <code>NA</code> by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_single(x, na.rm = FALSE, accept = FALSE, multiple = "NA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode_single_+3A_x">x</code></td>
<td>
<p>A vector to search for its mode.</p>
</td></tr>
<tr><td><code id="mode_single_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean. Should missing values in <code>x</code> be removed before
computation proceeds? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mode_single_+3A_accept">accept</code></td>
<td>
<p>Boolean. Should the minimum set of modes be accepted to check
for a single mode? If <code>FALSE</code> (the default), insists on the complete set
and returns <code>NA</code> if it can't be determined.</p>
</td></tr>
<tr><td><code id="mode_single_+3A_multiple">multiple</code></td>
<td>
<p>String or integer (length 1), or a function. What to do if
<code>x</code> has multiple modes. The default returns <code>NA</code>. All other options rely on
the modal values: &quot;<code style="white-space: pre;">&#8288;min"&#8288;</code>, <code>"max"</code>, <code>"mean"</code>, <code>"median"</code>, <code>"first"</code>,
<code>"last"</code>, and <code>"random"</code>. Alternatively, <code>multiple</code> can be an index number,
or a function that summarizes the modes. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>accept</code> is <code>FALSE</code> (the default), the set of modes is obtained
via <code>mode_all()</code> instead of <code>mode_possible_min()</code>. Set it to <code>TRUE</code> to
avoid returning <code>NA</code> when some, though not all modes are known. The purpose
of the default is to insist on a single mode.
</p>
<p>If <code>x</code> is a string vector and <code>multiple</code> is <code>"min"</code> or <code>"max"</code>, the mode is
selected lexically, just like <code>min(letters)</code> returns <code>"a"</code>. The <code>"mean"</code>
and <code>"median"</code> options return <code>NA</code> with a warning. For factors, <code>"min"</code>,
<code>"max"</code>, and <code>"median"</code> are errors, but <code>"mean"</code> returns <code>NA</code> with a
warning. These are inconsistencies in base R.
</p>
<p>The <code>multiple</code> options <code>"first"</code> and <code>"last"</code> always select the mode that
appears first or last in <code>x</code>. Index numbers, like <code>multiple = 2</code>, allow you
to select more flexibly. If <code>multiple</code> is a function, its output must be
length 1.
</p>


<h3>Value</h3>

<p>The only mode (most frequent value) in <code>x</code>. If it can't be determined
because of missing values, <code>NA</code> is returned instead. By default, <code>NA</code> is
also returned if there are multiple modes (<code>multiple = "NA"</code>).
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+mode_first">mode_first()</a></code> for the first-appearing mode.
</p>
</li>
<li> <p><code><a href="#topic+mode_all">mode_all()</a></code> for the complete set of modes.
</p>
</li>
<li> <p><code><a href="#topic+mode_possible_min">mode_possible_min()</a></code> for the minimal set of modes.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># `8` is the only mode:
mode_single(c(8, 8, 9))

# With more than one mode, the function
# returns `NA`:
mode_single(c(1, 2, 3, 3, 4, 4))

# Can't determine the modes here --
# `9` might be another mode:
mode_single(c(8, 8, 9, NA))

# Accept `8` anyways if it's
# sufficient to just have any mode:
mode_single(c(8, 8, 9, NA), accept = TRUE)

# `1` is the most frequent value,
# no matter what `NA` stands for:
mode_single(c(1, 1, 1, 2, NA))

# Ignore `NA`s with `na.rm = TRUE`
# (there should be good reasons for this!):
mode_single(c(8, 8, 9, NA), na.rm = TRUE)
</code></pre>

<hr>
<h2 id='mode-possible'>Possible sets of modes</h2><span id='topic+mode-possible'></span><span id='topic+mode_possible_min'></span><span id='topic+mode_possible_max'></span>

<h3>Description</h3>

<p><code>mode_possible_min()</code> and <code>mode_possible_max()</code> determine the
minimal and maximal sets of modes from among known modes, given the number
of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_possible_min(x, multiple = FALSE)

mode_possible_max(x, multiple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode-possible_+3A_x">x</code></td>
<td>
<p>A vector to search for its possible modes.</p>
</td></tr>
<tr><td><code id="mode-possible_+3A_multiple">multiple</code></td>
<td>
<p>Boolean. If <code>multiple</code> is set to <code>TRUE</code>, the functions return
multiple modes with the same frequency, even if some values are missing.
Default is <code>FALSE</code> because <code>NA</code>s may tip the balance between values that
are equally frequent among the known values. Thus, if <code>multiple = TRUE</code>,
the functions don't necessarily return the minimal or maximal sets of
modes, but all values that <em>might</em> be part of those sets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a vector with the minimal or maximal possible sets of
modes (values tied for most frequent) in <code>x</code>. If the functions can't
determine these possible modes because of missing values, they return
<code>NA</code> by default (<code>multiple = FALSE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mode_count_range">mode_count_range()</a></code> for the minimal and maximal <em>numbers</em> of
possible modes. They can always be determined, even if the present
functions return <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "a" is guaranteed to be a mode,
# "b" might also be one, but
# "c" is impossible:
mode_possible_min(c("a", "a", "a", "b", "b", "c", NA))
mode_possible_max(c("a", "a", "a", "b", "b", "c", NA))

# Only `8` can possibly be the mode
# because, even if `NA` is `7`, it's
# still less frequent than `8`:
mode_possible_min(c(7, 7, 8, 8, 8, 8, NA))
mode_possible_max(c(7, 7, 8, 8, 8, 8, NA))

# No clear minimal or maximal set
# of modes because `NA` may tip
# the balance between `1` and `2`
# towards a single mode:
mode_possible_min(c(1, 1, 2, 2, 3, 4, 5, NA))
mode_possible_max(c(1, 1, 2, 2, 3, 4, 5, NA))

# With `multiple = TRUE`, the functions
# return all values that might be part of
# the min / max sets of modes; not these
# sets themselves:
mode_possible_min(c(1, 1, 2, 2, 3, 4, 5, NA), multiple = TRUE)
mode_possible_max(c(1, 1, 2, 2, 3, 4, 5, NA), multiple = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
