<!DOCTYPE html><html><head><title>Help for package TesiproV</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TesiproV}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#debug.print'><p>internal  Helper function to debug more easy</p></a></li>
<li><a href='#dlt'><p>Density Function for logarithmic student T distritbution</p></a></li>
<li><a href='#FORM'><p>First Order Reliablity Method</p></a></li>
<li><a href='#MC_CRUDE'><p>Crude MonteCarlo Simulation</p></a></li>
<li><a href='#MC_IS'><p>MonteCarlo Simulation with importance sampling</p></a></li>
<li><a href='#MC_SubSam'><p>MonteCarlo with Subset-Sampling</p></a></li>
<li><a href='#MVFOSM'><p>MVFOSM</p></a></li>
<li><a href='#PARAM_BASEVAR-class'><p>Object for parametric variable</p></a></li>
<li><a href='#PARAM_DETVAR-class'><p>Object for parametric deterministic variable</p></a></li>
<li><a href='#PARAM_LSF-class'><p>System Limit State Functions</p></a></li>
<li><a href='#plt'><p>Probablity Function for logarithmic student T distritbution</p></a></li>
<li><a href='#PROB_BASEVAR-class'><p>Object to store the distribution model for base vars</p></a></li>
<li><a href='#PROB_DETVAR-class'><p>Object to store a deterministic model for base vars</p></a></li>
<li><a href='#PROB_MACHINE-class'><p>Object to store prob machines</p></a></li>
<li><a href='#qlt'><p>Quantil Function for logarithmic student T distritbution</p></a></li>
<li><a href='#rlt'><p>Random Realisation-Function for logarithmic student T distritbution</p></a></li>
<li><a href='#SORM'><p>Reliability Analysis at Biberach University of applied sciences</p></a></li>
<li><a href='#SYS_LSF-class'><p>System Limit State Functions</p></a></li>
<li><a href='#SYS_PARAM-class'><p>Object for parametric Studies</p></a></li>
<li><a href='#SYS_PROB-class'><p>System Probabliation Solution Object</p></a></li>
<li><a href='#TesiproV'><p>TesiproV: A package for the calculation of reliability and failure probability in civil engineering</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculation of Reliability and Failure Probability in Civil
Engineering</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Konstantin Nille-Hauf &lt;konstantin.nillehauf@googlemail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate the failure probability of civil engineering problems with Level I up to Level III Methods. Have fun and enjoy. References: Spaethe (1991, ISBN:3-211-82348-4) "Die Sicherheit tragender Baukonstruktionen", AU,BECK (2001) "Estimation of small failure probabilities in high dimensions by subset simulation." &lt;<a href="https://doi.org/10.1016%2FS0266-8920%2801%2900019-4">doi:10.1016/S0266-8920(01)00019-4</a>&gt;, Breitung (1989) "Asymptotic approximations for probability integrals." &lt;<a href="https://doi.org/10.1016%2F0266-8920%2889%2990024-6">doi:10.1016/0266-8920(89)90024-6</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.hochschule-biberach.de/transfer/forschung/institut-fuer-konstruktiven-ingenieurbau">https://www.hochschule-biberach.de/transfer/forschung/institut-fuer-konstruktiven-ingenieurbau</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, evd</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>pracma, nloptr, methods, edfun, ggplot2, gridExtra</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-25 14:00:29 UTC; Nille-Hauf</td>
</tr>
<tr>
<td>Author:</td>
<td>Konstantin Nille-Hauf [aut, cre],
  Tania Feiri [aut],
  Marcus Ricker [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-25 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='debug.print'>internal  Helper function to debug more easy</h2><span id='topic+debug.print'></span>

<h3>Description</h3>

<p>internal  Helper function to debug more easy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>debug.print(infoLevel, flag = "", values, msg = "", type = "INFO")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="debug.print_+3A_infolevel">infoLevel</code></td>
<td>
<p>If 0, no Output (just Errors), if 1 little output, if 2 bigger output</p>
</td></tr>
<tr><td><code id="debug.print_+3A_flag">flag</code></td>
<td>
<p>Parse additonal info</p>
</td></tr>
<tr><td><code id="debug.print_+3A_values">values</code></td>
<td>
<p>If you check variables then post this into values</p>
</td></tr>
<tr><td><code id="debug.print_+3A_msg">msg</code></td>
<td>
<p>here add some extra msg</p>
</td></tr>
<tr><td><code id="debug.print_+3A_type">type</code></td>
<td>
<p>Type can be &quot;INFO&quot; or &quot;ERROR&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>(C) 2021 - M. Ricker, K. Nille-Hauf, T. Feiri - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>

<hr>
<h2 id='dlt'>Density Function for logarithmic student T distritbution</h2><span id='topic+dlt'></span>

<h3>Description</h3>

<p>Density Function for logarithmic student T distritbution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlt(x, m, s, n, nue)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlt_+3A_x">x</code></td>
<td>
<p>quantiles</p>
</td></tr>
<tr><td><code id="dlt_+3A_m">m</code></td>
<td>
<p>mean (1. parameter)</p>
</td></tr>
<tr><td><code id="dlt_+3A_s">s</code></td>
<td>
<p>standard deviation (2. parameter)</p>
</td></tr>
<tr><td><code id="dlt_+3A_n">n</code></td>
<td>
<p>3. paramter</p>
</td></tr>
<tr><td><code id="dlt_+3A_nue">nue</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>density
</p>


<h3>Author(s)</h3>

<p>(C) 2021 - K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dlt(0.5,3,6,2,5)

</code></pre>

<hr>
<h2 id='FORM'>First Order Reliablity Method</h2><span id='topic+FORM'></span>

<h3>Description</h3>

<p>Method to calculate failure probability for structural engineering using approximation of limit state function
with linear part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FORM(
  lsf,
  lDistr,
  n_optim = 10,
  loctol = 0.01,
  optim_type = "rackfies",
  debug.level = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FORM_+3A_lsf">lsf</code></td>
<td>
<p>objective function with limit state function in form of <code>function(R,E) {R-E}</code>. Supplied by a SYS_ object, do not supply yourself.</p>
</td></tr>
<tr><td><code id="FORM_+3A_ldistr">lDistr</code></td>
<td>
<p>list ob distribiutions regarding the distribution object of TesiproV. Supplied by a SYS_ object, do not supply yourself.</p>
</td></tr>
<tr><td><code id="FORM_+3A_n_optim">n_optim</code></td>
<td>
<p>number of opimaziationcycles (not recommended/need for lagrangian algorithms).</p>
</td></tr>
<tr><td><code id="FORM_+3A_loctol">loctol</code></td>
<td>
<p>Tolerance of the local solver algorithm</p>
</td></tr>
<tr><td><code id="FORM_+3A_optim_type">optim_type</code></td>
<td>
<p>Optimaziationtypes. Available: Augmented Lagrangian Algorithm (use: &quot;auglag&quot;),
Rackwitz-Fissler Algorithm (use: &quot;rackfies&quot;).</p>
</td></tr>
<tr><td><code id="FORM_+3A_debug.level">debug.level</code></td>
<td>
<p>If 0 no additional info if 2 high output during calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results will be provided within a list with the following objects.
</p>
<p>beta HasoferLind Beta Index
</p>
<p>pf probablity of failure
</p>
<p>u_points solution points
</p>
<p>dy gradients
</p>


<h3>Author(s)</h3>

<p>(C) 2021 - K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>


<h3>References</h3>

<p>HASOFER AM, LIND NC. An exact and invarient first order reliability format. J Eng Mech Div Proc ASCE 1974;100(1):111–21.
</p>
<p>Rackwitz-Fiessler: RACKWITZ R., FIESSLER B. Structural reliability under combined random load sequences. Comput Struct 1978;9(5), S. 489–94.
</p>
<p>Optimised algorithm: YPMA, J., JOHNSON, S.G., BORCHERS, H.W., EDDELBUETTEL, D., RIPLEY, B., HORNIK K., CHIQUET, J., ADLER, A., nloptr: R Interface to NLopt. R package. 2020. Version 1.2.2.
</p>
<p>Spaethe, G.: Die Sicherheit tragender Baukonstruktionen, 2. Aufl. Wien: Springer, 1991. – ISBN 3-211-82348-4
</p>

<hr>
<h2 id='MC_CRUDE'>Crude MonteCarlo Simulation</h2><span id='topic+MC_CRUDE'></span>

<h3>Description</h3>

<p>Method to calculate failure probability for structural engineering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MC_CRUDE(
  lsf,
  lDistr,
  cov_user = 0.05,
  n_batch = 400,
  n_max = 1e+07,
  use_threads = 6,
  dataRecord = TRUE,
  debug.level = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC_CRUDE_+3A_lsf">lsf</code></td>
<td>
<p>objective function with limit state function in form of function(x) x[1]+x[2]...</p>
</td></tr>
<tr><td><code id="MC_CRUDE_+3A_ldistr">lDistr</code></td>
<td>
<p>list ob distribiutions regarding the distribution object of TesiproV</p>
</td></tr>
<tr><td><code id="MC_CRUDE_+3A_cov_user">cov_user</code></td>
<td>
<p>The Coefficent of variation the simulation should reach</p>
</td></tr>
<tr><td><code id="MC_CRUDE_+3A_n_batch">n_batch</code></td>
<td>
<p>Size per batch for parallel computing</p>
</td></tr>
<tr><td><code id="MC_CRUDE_+3A_n_max">n_max</code></td>
<td>
<p>maximum of iteration the MC should do - its like a stop criterion</p>
</td></tr>
<tr><td><code id="MC_CRUDE_+3A_use_threads">use_threads</code></td>
<td>
<p>Number of threads for parallel computing, use_threds=1 for single core. Doesnt work on windows!</p>
</td></tr>
<tr><td><code id="MC_CRUDE_+3A_datarecord">dataRecord</code></td>
<td>
<p>If True all single steps are recorded and available in the results file after on</p>
</td></tr>
<tr><td><code id="MC_CRUDE_+3A_debug.level">debug.level</code></td>
<td>
<p>If 0 no additional info, if 2 high output during calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results will be provided within a list with the following objects. Acess them with &quot;$&quot;-accessor
</p>
<p>pf probablity of failure
</p>
<p>pf_FORM probablity of failure of the FORM Algorithm
</p>
<p>var variation
</p>
<p>cov_mc coefficent of the monteCarlo
</p>
<p>n_mc number of iterations done
</p>


<h3>Author(s)</h3>

<p>(C) 2021 - M. Ricker, K. Nille-Hauf, T. Feiri - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>


<h3>References</h3>

<p>Spaethe, G.: Die Sicherheit tragender Baukonstruktionen, 2. Aufl. Wien: Springer, 1991. – ISBN 3-211-82348-4
</p>

<hr>
<h2 id='MC_IS'>MonteCarlo Simulation with importance sampling</h2><span id='topic+MC_IS'></span>

<h3>Description</h3>

<p>Method to calculate failure probability for structural engineering using a simulation method with
importance sampling (a method to reduce the amount of needed samples)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MC_IS(
  lsf,
  lDistr,
  cov_user = 0.05,
  n_batch = 16,
  n_max = 1e+06,
  use_threads = 6,
  sys_type = "parallel",
  dataRecord = TRUE,
  beta_l = 100,
  densityType = "norm",
  dps = NULL,
  debug.level = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC_IS_+3A_lsf">lsf</code></td>
<td>
<p>objective function with limit state function in form of function(x) x[1]+x[2]...</p>
</td></tr>
<tr><td><code id="MC_IS_+3A_ldistr">lDistr</code></td>
<td>
<p>Distributions in input space</p>
</td></tr>
<tr><td><code id="MC_IS_+3A_cov_user">cov_user</code></td>
<td>
<p>The Coefficent of variation the simulation should reach</p>
</td></tr>
<tr><td><code id="MC_IS_+3A_n_batch">n_batch</code></td>
<td>
<p>Size per batch for parallel computing</p>
</td></tr>
<tr><td><code id="MC_IS_+3A_n_max">n_max</code></td>
<td>
<p>maximum of iteration the MC should do - its like a stop criterion</p>
</td></tr>
<tr><td><code id="MC_IS_+3A_use_threads">use_threads</code></td>
<td>
<p>determine how many threads to split the work (1=singlecore, 2^n = multicore)</p>
</td></tr>
<tr><td><code id="MC_IS_+3A_sys_type">sys_type</code></td>
<td>
<p>Determine if parallel or serial system (in case MCIS calculates a system)</p>
</td></tr>
<tr><td><code id="MC_IS_+3A_datarecord">dataRecord</code></td>
<td>
<p>If True all single steps are recorded and available in the results file afteron</p>
</td></tr>
<tr><td><code id="MC_IS_+3A_beta_l">beta_l</code></td>
<td>
<p>In Systemcalculation: LSF´s with beta higher than beta_l wont be considered</p>
</td></tr>
<tr><td><code id="MC_IS_+3A_densitytype">densityType</code></td>
<td>
<p>determines what distributiontype should be taken for the h() density</p>
</td></tr>
<tr><td><code id="MC_IS_+3A_dps">dps</code></td>
<td>
<p>Vector of design points that sould be taken instead of the result of a FORM analysis</p>
</td></tr>
<tr><td><code id="MC_IS_+3A_debug.level">debug.level</code></td>
<td>
<p>If 0 no additional info if 2 high output during calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results will be provided within a list with the following objects. Acess them with &quot;$&quot;-accessor
</p>
<p>pf probablity of failure
</p>
<p>pf_FORM probablity of failure of the FORM Algorithm
</p>
<p>var variation
</p>
<p>cov_mc coefficent of the monteCarlo
</p>
<p>n_mc number of iterations done
</p>


<h3>Author(s)</h3>

<p>(C) 2021 - K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>


<h3>References</h3>

<p>DITLEVSEN O, MADSEN H. Structural reliability methods, vol. 178. New York: Wiley; 1996.
</p>
<p>Spaethe, G.: Die Sicherheit tragender Baukonstruktionen, 2. Aufl. Wien: Springer, 1991. – ISBN 3-211-82348-4
</p>

<hr>
<h2 id='MC_SubSam'>MonteCarlo with Subset-Sampling</h2><span id='topic+MC_SubSam'></span>

<h3>Description</h3>

<p>MonteCarlo with Subset-Sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MC_SubSam(
  lsf,
  lDistr,
  Nsubset = 1e+05,
  p0 = 0.1,
  MaxSubsets = 10,
  Alpha = 0.05,
  variance = "uniform",
  debug.level = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC_SubSam_+3A_lsf">lsf</code></td>
<td>
<p>limit-state function</p>
</td></tr>
<tr><td><code id="MC_SubSam_+3A_ldistr">lDistr</code></td>
<td>
<p>list of basevariables in input space</p>
</td></tr>
<tr><td><code id="MC_SubSam_+3A_nsubset">Nsubset</code></td>
<td>
<p>number of samples in each simulation level</p>
</td></tr>
<tr><td><code id="MC_SubSam_+3A_p0">p0</code></td>
<td>
<p>level probability or conditional probability</p>
</td></tr>
<tr><td><code id="MC_SubSam_+3A_maxsubsets">MaxSubsets</code></td>
<td>
<p>maximum number of simulation levels that are used to terminate the simulation procedure to avoid infinite loop when the target domain cannot be reached</p>
</td></tr>
<tr><td><code id="MC_SubSam_+3A_alpha">Alpha</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="MC_SubSam_+3A_variance">variance</code></td>
<td>
<p>gaussian, uniform</p>
</td></tr>
<tr><td><code id="MC_SubSam_+3A_debug.level">debug.level</code></td>
<td>
<p>If 0 no additional info if 2 high output during calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results are provided within a list() of the following elements:
</p>
<p>beta
</p>
<p>pf
</p>
<p>betaCI and pfCI are the corresponding confidence intervals
</p>
<p>CoV COV of the result
</p>
<p>NumOfSubsets Amount of Markov-Chains
</p>
<p>NumOfEvalLSF_nom Markov-Chains times Iterations
</p>
<p>NumOfEvalLSF_eff Internal counter that shows the real evaluations of the lsf
</p>
<p>runtime Duration since start to finish of the function
</p>


<h3>Author(s)</h3>

<p>(C) 2021 - K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>


<h3>References</h3>

<p>AU, S. K. &amp; BECK, J. L. Estimation of small failure probabilities in high dimensions by subset simulation. Probabilistic Engineering Mechanics, 2001, 16.4: 263-277.
</p>

<hr>
<h2 id='MVFOSM'>MVFOSM</h2><span id='topic+MVFOSM'></span>

<h3>Description</h3>

<p>MVFOSM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MVFOSM(lsf, lDistr, h = 1e-04, isExpression = FALSE, debug.level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVFOSM_+3A_lsf">lsf</code></td>
<td>
<p>LSF Definition, can be Expression or Function. Defined by the FLAG isExpression (see below)</p>
</td></tr>
<tr><td><code id="MVFOSM_+3A_ldistr">lDistr</code></td>
<td>
<p>List of Distributions</p>
</td></tr>
<tr><td><code id="MVFOSM_+3A_h">h</code></td>
<td>
<p>If isExpression is False, than Finite Difference Method is used for partial deviation. h is the Windowsize</p>
</td></tr>
<tr><td><code id="MVFOSM_+3A_isexpression">isExpression</code></td>
<td>
<p>Boolean, If TRUE lsf has to be typeof expression, otherwise lsf has to be type of function()</p>
</td></tr>
<tr><td><code id="MVFOSM_+3A_debug.level">debug.level</code></td>
<td>
<p>If 0 no additional info if 2 high output during calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>beta, pf, design.point in x space, alphas, runtime
</p>


<h3>Author(s)</h3>

<p>(C) 2021 - K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau#'
</p>


<h3>References</h3>

<p>FREUDENTHAL, A.M. Safety and the probability of structural failure. Am Soc Civil Eng Trans 1956; 121(2843):1337–97.
</p>

<hr>
<h2 id='PARAM_BASEVAR-class'>Object for parametric variable</h2><span id='topic+PARAM_BASEVAR-class'></span><span id='topic+PARAM_BASEVAR'></span>

<h3>Description</h3>

<p>Object to create parametric basic variables
</p>


<h3>Fields</h3>


<dl>
<dt><code>ParamValues</code></dt><dd><p>A vector of values of the parametric studie (e.g. c(1,3,5,7) or seq(1,10,2))</p>
</dd>
<dt><code>ParamType</code></dt><dd><p>A field to determine what should be parametric. Possible is: &quot;Mean&quot;, &quot;Sd&quot;, &quot;DistributionType&quot;</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>(C) 2021 - K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>

<hr>
<h2 id='PARAM_DETVAR-class'>Object for parametric deterministic variable</h2><span id='topic+PARAM_DETVAR-class'></span><span id='topic+PARAM_DETVAR'></span>

<h3>Description</h3>

<p>Object to create parametric deterministic variables
</p>


<h3>Fields</h3>


<dl>
<dt><code>ParamValues</code></dt><dd><p>A vector of values. The first element goes with the first run, second element with second run and so on.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>(C) 2021 - K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>

<hr>
<h2 id='PARAM_LSF-class'>System Limit State Functions</h2><span id='topic+PARAM_LSF-class'></span><span id='topic+PARAM_LSF'></span>

<h3>Description</h3>

<p>Interface for LSF through PROB_LSF. No changes.
</p>


<h3>Author(s)</h3>

<p>(C) 2021 - K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>

<hr>
<h2 id='plt'>Probablity Function for logarithmic student T distritbution</h2><span id='topic+plt'></span>

<h3>Description</h3>

<p>Probablity Function for logarithmic student T distritbution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt(q, m, s, n, nue)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plt_+3A_q">q</code></td>
<td>
<p>quantiles</p>
</td></tr>
<tr><td><code id="plt_+3A_m">m</code></td>
<td>
<p>mean (1. parameter)</p>
</td></tr>
<tr><td><code id="plt_+3A_s">s</code></td>
<td>
<p>standard deviation (2. parameter)</p>
</td></tr>
<tr><td><code id="plt_+3A_n">n</code></td>
<td>
<p>3. paramter</p>
</td></tr>
<tr><td><code id="plt_+3A_nue">nue</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>density
</p>


<h3>Author(s)</h3>

<p>(C) 2021 - M. Ricker, K. Nille-Hauf, T. Feiri - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>

<hr>
<h2 id='PROB_BASEVAR-class'>Object to store the distribution model for base vars</h2><span id='topic+PROB_BASEVAR-class'></span><span id='topic+PROB_BASEVAR'></span>

<h3>Description</h3>

<p>Object to store the distribution model for base vars...
</p>


<h3>Fields</h3>


<dl>
<dt><code>Id</code></dt><dd><p>Place in vector of objective functional expression function(x)x[id]</p>
</dd>
<dt><code>Name</code></dt><dd><p>name like f_ck, used in the limit state function as input name</p>
</dd>
<dt><code>Description</code></dt><dd><p>Used for better understanding of vars</p>
</dd>
<dt><code>DistributionType</code></dt><dd><p>Distributiontypes like &quot;norm&quot;, &quot;lnorm&quot;, &quot;weibull&quot;, &quot;t&quot;, &quot;gamma&quot;, etc...</p>
</dd>
<dt><code>Package</code></dt><dd><p>The name of the package the Distribution should be taken from (e.g. &quot;evd&quot;)</p>
</dd>
<dt><code>Mean</code></dt><dd><p>The Mean Value of this Basisvariable</p>
</dd>
<dt><code>Sd</code></dt><dd><p>The SD Value of this Basisvariable</p>
</dd>
<dt><code>Cov</code></dt><dd><p>The Cov fitting to Mean and Sd.</p>
</dd>
<dt><code>x0</code></dt><dd><p>Shiftingparameter</p>
</dd>
<dt><code>DistributionParameters</code></dt><dd><p>Inputparameters of the distribution, may be calculated internally</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>prepare()</code></dt><dd><p>Runs the transformations (from mean, sd -&gt; parameters or the other way round) and checks COV, MEAN and SD fitting together.
If distribution is not available an error ll be thrown.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>(C) 2021 - K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var1 &lt;- PROB_BASEVAR(Name="var1", Description="yield strength",
DistributionType="norm", Mean=500, Sd=60)
var1$prepare()

var2 &lt;- PROB_BASEVAR(Name="var2", Description="Load",
DistributionType="gumbel",Package="evd",Mean=40, Sd=3)
var2$prepare()

</code></pre>

<hr>
<h2 id='PROB_DETVAR-class'>Object to store a deterministic model for base vars</h2><span id='topic+PROB_DETVAR-class'></span><span id='topic+PROB_DETVAR'></span>

<h3>Description</h3>

<p>Object to store a deterministic model for base vars
</p>


<h3>Fields</h3>


<dl>
<dt><code>Id</code></dt><dd><p>Place in vector of objective functional expression function(x)x[id]</p>
</dd>
<dt><code>Name</code></dt><dd><p>readable name like f_ck, used for transform expression to objective function</p>
</dd>
<dt><code>Description</code></dt><dd><p>- Used for better understanding of vars</p>
</dd>
<dt><code>Value</code></dt><dd><p>- The deterministic value that sould be used (as mean for the normal distribution with infinite small sd)</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>(C) 2021 - K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>form_rf&lt;-PROB_MACHINE(name="FORM RF",fCall="FORM",options=list("n_optim"=20,
"loctol"=0.001, "optim_type"="rackfies"))
sorm &lt;- PROB_MACHINE(name="SORM",fCall="SORM")
mcis&lt;-PROB_MACHINE(name="MC IS",fCall="MC_IS",options=list("cov_user" = 0.05, "n_max"=300000))
mcsus&lt;-PROB_MACHINE(name="MC SuS",fCall="MC_SubSam")

</code></pre>

<hr>
<h2 id='PROB_MACHINE-class'>Object to store prob machines</h2><span id='topic+PROB_MACHINE-class'></span><span id='topic+PROB_MACHINE'></span>

<h3>Description</h3>

<p>Object to store prob machines
</p>


<h3>Fields</h3>


<dl>
<dt><code>name</code></dt><dd><p>individual name</p>
</dd>
<dt><code>fCall</code></dt><dd><p>Function Call of the method. Possible is: &quot;MVFOSM&quot;,&quot;FORM&quot;, &quot;SORM&quot;, &quot;MC_Crude&quot;, &quot;MC_IS&quot;, &quot;MC_SubSam&quot;</p>
</dd>
<dt><code>options</code></dt><dd><p>additional options for the method provided as a list. For form e.g. options=list(&quot;optim_type&quot;=&quot;rackfies&quot;).
To get insight of all available settings of each method open the help with ?FORM, ?SORM, ?MC_IS etc.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>(C) 2021 - M. Ricker, K. Nille-Hauf, T. Feiri - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>

<hr>
<h2 id='qlt'>Quantil Function for logarithmic student T distritbution</h2><span id='topic+qlt'></span>

<h3>Description</h3>

<p>Quantil Function for logarithmic student T distritbution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qlt(p, m, s, n, nue)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qlt_+3A_p">p</code></td>
<td>
<p>probablity</p>
</td></tr>
<tr><td><code id="qlt_+3A_m">m</code></td>
<td>
<p>mean (1. parameter)</p>
</td></tr>
<tr><td><code id="qlt_+3A_s">s</code></td>
<td>
<p>standard deviation (2. parameter)</p>
</td></tr>
<tr><td><code id="qlt_+3A_n">n</code></td>
<td>
<p>3. paramter</p>
</td></tr>
<tr><td><code id="qlt_+3A_nue">nue</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quantile
</p>


<h3>Author(s)</h3>

<p>(C) 2021 - M. Ricker, K. Nille-Hauf, T. Feiri - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>

<hr>
<h2 id='rlt'>Random Realisation-Function for logarithmic student T distritbution</h2><span id='topic+rlt'></span>

<h3>Description</h3>

<p>Random Realisation-Function for logarithmic student T distritbution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlt(n_vals, m, s, n, nue)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlt_+3A_n_vals">n_vals</code></td>
<td>
<p>number of realisations</p>
</td></tr>
<tr><td><code id="rlt_+3A_m">m</code></td>
<td>
<p>mean (1. parameter)</p>
</td></tr>
<tr><td><code id="rlt_+3A_s">s</code></td>
<td>
<p>standard deviation (2. parameter)</p>
</td></tr>
<tr><td><code id="rlt_+3A_n">n</code></td>
<td>
<p>3. paramter</p>
</td></tr>
<tr><td><code id="rlt_+3A_nue">nue</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>random number
</p>


<h3>Author(s)</h3>

<p>(C) 2021 - M. Ricker, K. Nille-Hauf, T. Feiri - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>

<hr>
<h2 id='SORM'>Reliability Analysis at Biberach University of applied sciences</h2><span id='topic+SORM'></span>

<h3>Description</h3>

<p># S. Marelli, and B. Sudret, UQLab: A framework for uncertainty quantification in Matlab, Proc. 2nd Int. Conf. on Vulnerability, Risk Analysis and Management (ICVRAM2014), Liverpool (United Kingdom), 2014, 2554-2563.
S. Lacaze and S. Missoum, CODES: A Toolbox For Computational Design, Version 1.0, 2015, URL: www.codes.arizona.edu/toolbox.
X. Z. Wu, Implementing statistical fitting and reliability analysis for geotechnical engineering problems in R. Georisk: Assessment and Management of Risk for Engineered Systems and Geohazards, 2017, 11.2: 173-188.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SORM(lsf, lDistr, debug.level = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SORM_+3A_lsf">lsf</code></td>
<td>
<p>objective function with limit state function in form of function(x) x[1]+x[2]...</p>
</td></tr>
<tr><td><code id="SORM_+3A_ldistr">lDistr</code></td>
<td>
<p>list ob distribiutions regarding the distribution object of TesiproV</p>
</td></tr>
<tr><td><code id="SORM_+3A_debug.level">debug.level</code></td>
<td>
<p>If 0 no additional info if 2 high output during calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results will be provided within a list with the following objects. Acess them with &quot;$&quot;-accessor
</p>
<p>beta ... HasoferLind Beta Index
</p>
<p>pf ... probablity of failure
</p>
<p>u_points ... solution points
</p>
<p>dy ... gradients
</p>


<h3>Author(s)</h3>

<p>(C) 2021 -  T. Feiri, K. Nille-Hauf, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>


<h3>References</h3>

<p>Breitung, K. (1989). Asymptotic approximations for probability integrals. Probabilistic Engineering Mechanics 4(4), 187–190. 9, 10
</p>
<p>Cai, G. Q. and I. Elishakoff (1994). Refined second-order reliability analysis. Structural Safety 14(4), 267–276. 9, 10
</p>
<p>Hohenbichler, M., S. Gollwitzer, W. Kruse, and R. Rackwitz (1987). New light on first- and second order reliability methods. Structural Safety 4, 267–284. 10
</p>
<p>Tvedt, L. (1990). Distribution of quadratic forms in normal space – Applications to structural reliability. Journal of Engineering Mechanics 116(6), 1183–1197. 10
</p>

<hr>
<h2 id='SYS_LSF-class'>System Limit State Functions</h2><span id='topic+SYS_LSF-class'></span><span id='topic+SYS_LSF'></span>

<h3>Description</h3>

<p>Object that represents a limit state function
</p>


<h3>Fields</h3>


<dl>
<dt><code>expr</code></dt><dd><p>prepared for expression like SYS_LSF$expr &lt;- expression(f_ck - d_nom)...</p>
</dd>
<dt><code>func</code></dt><dd><p>prepared for objective functions like SYS_LSF$func &lt;- function(x)return(x[1] + x[2])</p>
</dd>
<dt><code>vars</code></dt><dd><p>needs list of PROB_BASEVAR-Object</p>
</dd>
<dt><code>name</code></dt><dd><p>Can be added for better recognition. Otherwise the problem will be called &quot;Unkown Problem&quot;</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>ExpressionToFunction()</code></dt><dd><p>Transforms a valid expression into a objective function. Need the set of Variables with correct spelled names and IDs</p>
</dd>
<dt><code>check()</code></dt><dd><p>Checks all variables. You dont need to execute this, since the system object will do anyway.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>(C) 2021 - K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list_of_vars &lt;- list(PROB_BASEVAR(),PROB_BASEVAR())
lsf1 &lt;- SYS_LSF(name="my first lsf", vars=list_of_vars)
lsf1$func &lt;- function(var1,var2){var1-var2}

</code></pre>

<hr>
<h2 id='SYS_PARAM-class'>Object for parametric Studies</h2><span id='topic+SYS_PARAM-class'></span><span id='topic+SYS_PARAM'></span>

<h3>Description</h3>

<p>Object to create probabilistic problems in parametric studies context. There are no changes how to use compared with SYS_PROB
</p>


<h3>Fields</h3>


<dl>
<dt><code>beta_params</code></dt><dd><p>Outputfield: See the beta values of the studie</p>
</dd>
<dt><code>res_params</code></dt><dd><p>Outputfield: See the the full result output of each run</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>printResults(path = "")</code></dt><dd><p>TesiproV can create a report file with all the necessary data for you. If you provide a path (or filename, without ending) it will store
the data there, otherwise it will report to the console. Set the path via setwd() or check it via getwd().</p>
</dd>
<dt><code>runMachines()</code></dt><dd><p>Starts solving all given problems (sys_input) with all given algorithms (probMachines). After that one can access via $res...1</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>(C) 2021 - M. Ricker, K. Nille-Hauf, T. Feiri - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>

<hr>
<h2 id='SYS_PROB-class'>System Probabliation Solution Object</h2><span id='topic+SYS_PROB-class'></span><span id='topic+SYS_PROB'></span>

<h3>Description</h3>

<p>Object to create probabilistic problems. Including Equation, List of Basisvariable, and Solutionmachines
</p>


<h3>Fields</h3>


<dl>
<dt><code>sys_input</code></dt><dd><p>List of SYS_LSFs</p>
</dd>
<dt><code>sys_type</code></dt><dd><p>determining serial or parallel system, not implemented yet</p>
</dd>
<dt><code>probMachines</code></dt><dd><p>list of PROB_MACHINES</p>
</dd>
<dt><code>res_single</code></dt><dd><p>grab results after .runMachines()</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>calculateSystemProbability(calcType = "simpleBounds", params = list())</code></dt><dd><p>Calculates the system probablity if more than one lsf is given and a system_type (serial or parallel) is set.
If calcType is empty (or simpleBounds), only simpleBounds are applied to further calculation of single soultions.
If calcType is MCIS, than a Monte Carlo Importance Sampling Method is used (only for parallel systems available).
If calcType is MCC, than a Crude Monte Carlo Simulation is used.
If calcType is MCSUS, than the Subset Sampling Algorithm ll be used.
You can pass arguments to methods via the params field, while the argument has to be a named list (for example check the vignette).</p>
</dd>
<dt><code>plotGraph(plotType = "sim.performance")</code></dt><dd><p>not finally implemented. Do not use.</p>
</dd>
<dt><code>printResults(path = "")</code></dt><dd><p>TesiproV can create a report file with all the necessary data for you. If you provide a path (or filename, without ending) it will store
the data there, otherwise it will report to the console. Set the path via setwd() or check it via getwd().</p>
</dd>
<dt><code>runMachines()</code></dt><dd><p>Starts solving all given problems (sys_input) with all given algorithms (probMachines). After that one can access via $res...1</p>
</dd>
<dt><code>saveProject(level, filename = "tesiprov_project")</code></dt><dd><p>You can save your calculation project with saveProject().
There are four different levels of detail to save
1st Level: Only the beta values
2nd Level: The result Objects of single or systemcalculation
3th Level: All The Probablity System Object, including limit state functions, machines and solutions
4th Level: An image of your entire workspace</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>(C) 2021 - K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ps &lt;- SYS_PROB(
sys_input=list(SYS_LSF(),SYS_LSF()),
probMachines=list(PROB_MACHINE()),
sys_type="serial")
## Not run: 
ps$runMachines()
ps$beta_sys
ps$res_sys
ps$printResults("example_1")
ps$saveProject(4,"example_1")

## End(Not run)

</code></pre>

<hr>
<h2 id='TesiproV'>TesiproV: A package for the calculation of reliability and failure probability in civil engineering</h2><span id='topic+TesiproV'></span>

<h3>Description</h3>

<p>The Package provides three main types of objects:
</p>

<ol>
<li><p> Objects for modeling base variables
</p>
</li>
<li><p> Objects for modeling limit state functions and systems of them
</p>
</li>
<li><p> Objects for modeling solving algorithms
</p>
</li></ol>



<h3>Details</h3>

<p>By creating and combining those objects, one is able to model quite complex problems in terms of structural reliablity calculation.
For normally distributed variables there might be an workflow to calculate correlated problems (but no systems then).
There is also implemented a new distribution (logStudentT, often used for conrete compression strength) to show how one can implement
your very own or maybe combined multi modal distribution and use it with TesiproV.
</p>


<h3>Objects for base variables</h3>

<p><code>PROB_BASEVAR</code>, <code>PROB_DETVAR</code>, <code>PARAM_BASEVAR</code>, <code>PARAM_DETVAR</code>
</p>


<h3>Limit state functions</h3>

<p><code>SYS_LSF</code>, <code>PROB_SYS</code>, <code>PARAM_SYS</code>
</p>


<h3>Solving algorithms</h3>

<p><code>PROB_MACHINE</code>
</p>


<h3>Author(s)</h3>

<p>(C) 2021 -  K. Nille-Hauf, T. Feiri, M. Ricker - Hochschule Biberach, Institut fuer Konstruktiven Ingenieurbau
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
