<!DOCTYPE html><html><head><title>Help for package anMC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {anMC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anMC-package'><p>anMC: Compute High Dimensional Orthant Probabilities</p></a></li>
<li><a href='#ANMC_Gauss'><p>ANMC estimate for the remainder</p></a></li>
<li><a href='#conservativeEstimate'><p>Computationally efficient conservative estimate</p></a></li>
<li><a href='#get_chronotime'><p>Measure elapsed time with C++11 chrono library</p></a></li>
<li><a href='#MC_Gauss'><p>MC estimate for the remainder</p></a></li>
<li><a href='#mvrnormArma'><p>Sample from multivariate normal distribution with C++</p></a></li>
<li><a href='#ProbaMax'><p>Probability of exceedance of maximum of Gaussian vector</p></a></li>
<li><a href='#ProbaMin'><p>Probability of exceedance of minimum of Gaussian vector</p></a></li>
<li><a href='#selectActiveDims'><p>Select active dimensions for small dimensional estimate</p></a></li>
<li><a href='#selectQdims'><p>Iteratively select active dimensions</p></a></li>
<li><a href='#trmvrnorm_rej_cpp'><p>Sample from truncated multivariate normal distribution with C++</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Compute High Dimensional Orthant Probabilities</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-22</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dario Azzimonti &lt;dario.azzimonti@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computationally efficient method to estimate orthant probabilities of high-dimensional Gaussian vectors. Further implements a function to compute conservative estimates of excursion sets under Gaussian random field priors. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.1080/10618600.2017.1360781">https://doi.org/10.1080/10618600.2017.1360781</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>mvtnorm</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DiceKriging, TruncatedNormal</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 07:47:20 UTC; dario.azzimonti</td>
</tr>
<tr>
<td>Author:</td>
<td>Dario Azzimonti <a href="https://orcid.org/0000-0001-5080-3061"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anMC-package'>anMC: Compute High Dimensional Orthant Probabilities</h2><span id='topic+anMC'></span><span id='topic+anMC-package'></span>

<h3>Description</h3>

<p>Computationally efficient method to estimate orthant probabilities of high-dimensional Gaussian vectors. Further implements a function to compute conservative estimates of excursion sets under Gaussian random field priors.
</p>


<h3>Details</h3>

<p>Efficient estimation of high dimensional orthant probabilities. The package main functions are: </p>

<ul>
<li> <p><code><a href="#topic+ProbaMax">ProbaMax</a></code>: the main function for high dimensional othant probabilities. Computes <code class="reqn">P(max X &gt; t)</code>, where <code class="reqn">X</code> is a Gaussian vector and <code class="reqn">t</code> is the selected threshold. It implements the <code>GANMC</code> algorithm and allows for user-defined sampler and core probability estimates.
</p>
</li>
<li> <p><code><a href="#topic+ProbaMin">ProbaMin</a></code>: analogous of <code>ProbaMax</code> for the problem <code class="reqn">P(min X &lt; t)</code>, where <code class="reqn">X</code> is a Gaussian vector and <code class="reqn">t</code> is the selected threshold.  It implements the <code>GANMC</code> algorithm and allows for user-defined sampler and core probability estimates.
</p>
</li>
<li> <p><code><a href="#topic+conservativeEstimate">conservativeEstimate</a></code>: the main function for conservative estimates computation. Requires the mean and covariance of the posterior field at a discretization design.
</p>
</li></ul>



<h3>Note</h3>

<p>This work was supported in part by the Swiss National Science Foundation, grant number 146354 and the Hasler Foundation, grant number 16065. Thanks to David Ginsbourger for the fruitful discussions and his continuous help in testing and improving the package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dario Azzimonti <a href="mailto:dario.azzimonti@gmail.com">dario.azzimonti@gmail.com</a> (<a href="https://orcid.org/0000-0001-5080-3061">ORCID</a>) [copyright holder]
</p>


<h3>References</h3>

<p>Azzimonti, D. and Ginsbourger, D. (2018). Estimating orthant probabilities of high dimensional Gaussian vectors with an application to set estimation. Journal of Computational and Graphical Statistics, 27(2), 255-267. <a href="https://doi.org/10.1080/10618600.2017.1360781">doi:10.1080/10618600.2017.1360781</a>
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>
<p>Bolin, D. and Lindgren, F. (2015). Excursion and contour uncertainty regions for latent Gaussian models. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 77(1):85&ndash;106.
</p>
<p>Chevalier, C. (2013). Fast uncertainty reduction strategies relying on Gaussian process models. PhD thesis, University of Bern.
</p>
<p>Dickmann, F. and Schweizer, N. (2014). Faster comparison of stopping times by nested conditional Monte Carlo. arXiv preprint arXiv:1402.0243.
</p>
<p>Genz, A. (1992). Numerical computation of multivariate normal probabilities. Journal of Computational and Graphical Statistics, 1(2):141&ndash;149.
</p>
<p>Genz, A. and Bretz, F. (2009). Computation of Multivariate Normal and t Probabilities. Lecture Notes in Statistics 195. Springer-Verlag.
</p>
<p>Horrace, W. C. (2005). Some results on the multivariate truncated normal distribution. Journal of Multivariate Analysis, 94(1):209&ndash;221.
</p>
<p>Robert, C. P. (1995). Simulation of truncated normal variables. Statistics and Computing, 5(2):121&ndash;125.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://doi.org/10.1080/10618600.2017.1360781">doi:10.1080/10618600.2017.1360781</a>
</p>
</li></ul>


<hr>
<h2 id='ANMC_Gauss'>ANMC estimate for the remainder</h2><span id='topic+ANMC_Gauss'></span>

<h3>Description</h3>

<p>Asymmetric nested Monte Carlo estimation of <code class="reqn">P(max X^{-q} &gt; threshold | max X^{q} \le threshold)</code> where X is a normal vector. It is used for the bias correction in <code><a href="#topic+ProbaMax">ProbaMax</a></code> and <code><a href="#topic+ProbaMin">ProbaMin</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANMC_Gauss(
  compBdg,
  problem,
  delta = 0.4,
  type = "M",
  trmvrnorm = trmvrnorm_rej_cpp,
  typeReturn = 0,
  verb = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ANMC_Gauss_+3A_compbdg">compBdg</code></td>
<td>
<p>total computational budget in seconds.</p>
</td></tr>
<tr><td><code id="ANMC_Gauss_+3A_problem">problem</code></td>
<td>
<p>list defining the problem with mandatory fields </p>

<ul>
<li><p> muEq = mean vector of <code class="reqn">X^{q}</code>;
</p>
</li>
<li><p> sigmaEq = covariance matrix of <code class="reqn">X^q</code>;
</p>
</li>
<li><p> threshold = fixed threshold <code class="reqn">t</code>;
</p>
</li>
<li><p> muEmq = mean vector of <code class="reqn">X^{-q}</code>;
</p>
</li>
<li><p> wwCondQ = &ldquo;weights&rdquo; for <code class="reqn">X^{-q} | X^q</code> [the vector <code class="reqn">\Sigma^{-q,q}(\Sigma^q)^{-1}</code>];
</p>
</li>
<li><p> sigmaCondQChol = Cholesky factorization of the conditional covariance matrix <code class="reqn">\Sigma^{-q | q}</code>;
</p>
</li></ul>
</td></tr>
<tr><td><code id="ANMC_Gauss_+3A_delta">delta</code></td>
<td>
<p>total proportion of budget assigned to initial estimate (default 0.4), the actual proportion used might be smaller.</p>
</td></tr>
<tr><td><code id="ANMC_Gauss_+3A_type">type</code></td>
<td>
<p>type of excursion: &quot;m&quot;, for minimum below threshold or &quot;M&quot;, for maximum above threshold.</p>
</td></tr>
<tr><td><code id="ANMC_Gauss_+3A_trmvrnorm">trmvrnorm</code></td>
<td>
<p>function to generate truncated multivariate normal samples, it must have the following signature trmvrnorm(n,mu,sigma,upper,lower,verb), where </p>

<ul>
<li> <p><code>n</code>: number of simulations;
</p>
</li>
<li> <p><code>mu</code>: mean vector of the Normal variable of dimension <code class="reqn">d</code>;
</p>
</li>
<li> <p><code>sigma</code>: covariance matrix of dimension <code class="reqn">d x d</code>;
</p>
</li>
<li> <p><code>upper</code>: vector of upper limits of length <code>d</code>;
</p>
</li>
<li> <p><code>lower</code>: vector of lower limits of length <code>d</code>;
</p>
</li>
<li> <p><code>verb</code>: the level of verbosity 3 basic, 4 extended.
</p>
</li></ul>

<p>It must return a matrix <code class="reqn">d x n</code> of realizations. If not specified, the rejection sampler <code><a href="#topic+trmvrnorm_rej_cpp">trmvrnorm_rej_cpp</a></code> is used.</p>
</td></tr>
<tr><td><code id="ANMC_Gauss_+3A_typereturn">typeReturn</code></td>
<td>
<p>integer chosen between </p>

<ul>
<li><p> 0 a number with only the probability estimation;
</p>
</li>
<li><p> 1 light return: a list with the probability estimator, the variance of the estimator, the vectors of conditional quantities used to obtain m^* and the system dependent parameters;
</p>
</li>
<li><p> 2 heavy return: the same list as light return with also the computational times and additional intermediate parameters.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ANMC_Gauss_+3A_verb">verb</code></td>
<td>
<p>level of verbosity (0,1 for this function), also sets the verbosity of trmvrnorm (to verb-1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimated probability of excursion, see <code>typeReturn</code> for details.
</p>


<h3>References</h3>

<p>Azzimonti, D. and Ginsbourger, D. (2018). Estimating orthant probabilities of high dimensional Gaussian vectors with an application to set estimation. Journal of Computational and Graphical Statistics, 27(2), 255-267. Preprint at <a href="https://hal.science/hal-01289126">hal-01289126</a>
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>
<p>Dickmann, F. and Schweizer, N. (2014). Faster comparison of stopping times by nested conditional Monte Carlo. arXiv preprint arXiv:1402.0243.
</p>
<p>Genz, A. (1992). Numerical computation of multivariate normal probabilities. Journal of Computational and Graphical Statistics, 1(2):141&ndash;149.
</p>

<hr>
<h2 id='conservativeEstimate'>Computationally efficient conservative estimate</h2><span id='topic+conservativeEstimate'></span>

<h3>Description</h3>

<p>Computes conservative estimates with two step GANMC procedure for a Gaussian vector. The probability is approximated with a biased low dimensional estimator and the bias is corrected with a MC estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conservativeEstimate(
  alpha = 0.95,
  pred,
  design,
  threshold,
  pn = NULL,
  type = "&gt;",
  verb = 1,
  lightReturn = T,
  algo = "GANMC"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conservativeEstimate_+3A_alpha">alpha</code></td>
<td>
<p>probability of conservative estimate.</p>
</td></tr>
<tr><td><code id="conservativeEstimate_+3A_pred">pred</code></td>
<td>
<p>list containing mean vector (pred$mean) and covariance matrix (pred$cov).</p>
</td></tr>
<tr><td><code id="conservativeEstimate_+3A_design">design</code></td>
<td>
<p>a matrix of size <code>length(pred$mean)</code>x(input space dimension) that contains the design where <code>pred$mean</code> was computed.</p>
</td></tr>
<tr><td><code id="conservativeEstimate_+3A_threshold">threshold</code></td>
<td>
<p>threshold, real number.</p>
</td></tr>
<tr><td><code id="conservativeEstimate_+3A_pn">pn</code></td>
<td>
<p>coverage probability function, vector of the same length as pred$mean (if not specified it is computed).</p>
</td></tr>
<tr><td><code id="conservativeEstimate_+3A_type">type</code></td>
<td>
<p>type of excursion: &quot;&gt;&quot; for excursion above threshold or &quot;&lt;&quot; for below.</p>
</td></tr>
<tr><td><code id="conservativeEstimate_+3A_verb">verb</code></td>
<td>
<p>level of verbosity, integer from 1&ndash;7.</p>
</td></tr>
<tr><td><code id="conservativeEstimate_+3A_lightreturn">lightReturn</code></td>
<td>
<p>boolean for light return.</p>
</td></tr>
<tr><td><code id="conservativeEstimate_+3A_algo">algo</code></td>
<td>
<p>choice of algorithm for computing probabilities (&quot;GANMC&quot;, &quot;GMC&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the conservative estimate (<code>set</code>), the Vorob'ev level (<code>lvs</code>). If <code>lightReturn=FALSE</code>, it also returns the actual probability of the set (<code>proba</code>) and the variance of this estimate (<code>vars</code>).
</p>


<h3>References</h3>

<p>Azzimonti, D. and Ginsbourger, D. (2018). Estimating orthant probabilities of high dimensional Gaussian vectors with an application to set estimation. Journal of Computational and Graphical Statistics, 27(2), 255-267. Preprint at <a href="https://hal.science/hal-01289126">hal-01289126</a>
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>
<p>Bolin, D. and Lindgren, F. (2015). Excursion and contour uncertainty regions for latent Gaussian models. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 77(1):85&ndash;106.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
# Compute conservative estimate of excursion set of testfun below threshold
# Initialize
testfun&lt;-function(x){return(((3*x^2+7*x-3)*exp(-1*(x)^2)*cos(5*pi*x^2)-1.2*x^2))}
mDet&lt;- 1500

# Uniform design points
set.seed(42)
doe&lt;-runif(n = 8)
res&lt;-testfun(doe)
threshold&lt;-0
# create km
smallKm &lt;- DiceKriging::km(design = matrix(doe,ncol=1),
response = res,covtype = "matern5_2",coef.trend = -1,coef.cov = c(0.05),coef.var = 1.1)
# prediction at newdata
newdata&lt;-data.frame(matrix(seq(0,1,,mDet),ncol=1)); colnames(newdata)&lt;-colnames(smallKm@X)
pred&lt;-DiceKriging::predict.km(object = smallKm,newdata = newdata,type = "UK",cov.compute = TRUE)

## Not run: 
# Plot (optional)
plot(seq(0,1,,mDet),pred$mean,type='l')
points(doe,res,pch=10)
abline(h = threshold)
lines(seq(0,1,,mDet),pred$mean+pred$sd,lty=2,col=1)
lines(seq(0,1,,mDet),pred$mean-pred$sd,lty=2,col=1)

## End(Not run)
# Compute the coverage function
pn&lt;-pnorm((threshold-pred$mean)/pred$sd)

## Not run: 
pred$cov &lt;- pred$cov + 1e-7*diag(nrow = nrow(pred$cov),ncol = ncol(pred$cov))
CE&lt;-conservativeEstimate(alpha = 0.95,pred = pred,design = as.matrix(newdata),
threshold = threshold,type = "&lt;",verb=1, pn=pn,algo = "ANMC")
points(newdata[CE$set,],rep(-0.1,mDet)[CE$set],col=4,pch="-",cex=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_chronotime'>Measure elapsed time with C++11 chrono library</h2><span id='topic+get_chronotime'></span>

<h3>Description</h3>

<p>Returns a time indicator that can be used to accurately measure elapsed time. The C++11 clock used is <code>chrono::high_resolution_clock</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_chronotime()
</code></pre>


<h3>Value</h3>

<p>A double with the number of nanoseconds elapsed since a fixed epoch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Measure 1 second sleep
initT&lt;-get_chronotime()
Sys.sleep(1)
measT&lt;-(get_chronotime()-initT)*1e-9
cat("1 second passed in ",measT," seconds.\n")
</code></pre>

<hr>
<h2 id='MC_Gauss'>MC estimate for the remainder</h2><span id='topic+MC_Gauss'></span>

<h3>Description</h3>

<p>Standard Monte Carlo estimate for <code class="reqn">P(max X^{-q} &gt;threshold | max X^{q}\le threshold)</code> or <code class="reqn">P(min X^{-q} &lt;threshold | min X^{q}\ge threshold)</code> where X is a normal vector. It is used for the bias correction in <code><a href="#topic+ProbaMax">ProbaMax</a></code> and <code><a href="#topic+ProbaMin">ProbaMin</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MC_Gauss(
  compBdg,
  problem,
  delta = 0.1,
  type = "M",
  trmvrnorm = trmvrnorm_rej_cpp,
  typeReturn = 0,
  verb = 0,
  params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC_Gauss_+3A_compbdg">compBdg</code></td>
<td>
<p>total computational budget in seconds.</p>
</td></tr>
<tr><td><code id="MC_Gauss_+3A_problem">problem</code></td>
<td>
<p>list defining the problem with mandatory fields: </p>

<ul>
<li><p> muEq = mean vector of <code class="reqn">X^{q}</code>;
</p>
</li>
<li><p> sigmaEq = covariance matrix of <code class="reqn">X^q</code>;
</p>
</li>
<li><p> threshold = threshold;
</p>
</li>
<li><p> muEmq = mean vector of <code class="reqn">X^{-q}</code>;
</p>
</li>
<li><p> wwCondQ = &ldquo;weights&rdquo; for <code class="reqn">X^{-q} | X^q</code> [ the vector <code class="reqn">\Sigma^{-q,q}(\Sigma^q)^{-1}</code>];
</p>
</li>
<li><p> sigmaCondQChol = Cholesky factorization of the conditional covariance matrix <code class="reqn">\Sigma^{-q | q}</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="MC_Gauss_+3A_delta">delta</code></td>
<td>
<p>total proportion of budget assigned to initial estimate (default 0.1), the actual proportion used might be smaller.</p>
</td></tr>
<tr><td><code id="MC_Gauss_+3A_type">type</code></td>
<td>
<p>type of excursion: &quot;m&quot;, for minimum below threshold or &quot;M&quot;, for maximum above threshold.</p>
</td></tr>
<tr><td><code id="MC_Gauss_+3A_trmvrnorm">trmvrnorm</code></td>
<td>
<p>function to generate truncated multivariate normal samples, it must have the following signature trmvrnorm(n,mu,sigma,upper,lower,verb), where </p>

<ul>
<li> <p><code>n</code>: number of simulations;
</p>
</li>
<li> <p><code>mu</code>: mean vector of the Normal variable of dimension <code class="reqn">d</code>;
</p>
</li>
<li> <p><code>sigma</code>: covariance matrix of dimension <code class="reqn">d x d</code>;
</p>
</li>
<li> <p><code>upper</code>: vector of upper limits of length <code>d</code>;
</p>
</li>
<li> <p><code>lower</code>: vector of lower limits of length <code>d</code>;
</p>
</li>
<li> <p><code>verb</code>: the level of verbosity 3 basic, 4 extended.
</p>
</li></ul>

<p>It must return a matrix <code class="reqn">d x n</code> of realizations. If not specified, the rejection sampler <code><a href="#topic+trmvrnorm_rej_cpp">trmvrnorm_rej_cpp</a></code> is used.</p>
</td></tr>
<tr><td><code id="MC_Gauss_+3A_typereturn">typeReturn</code></td>
<td>
<p>integer: 0 (only the estimate) or 1 (heavy return with variance of the estimate, parameters of the estimator and computational times).</p>
</td></tr>
<tr><td><code id="MC_Gauss_+3A_verb">verb</code></td>
<td>
<p>the level of verbosity, also sets the verbosity of trmvrnorm (to verb-1).</p>
</td></tr>
<tr><td><code id="MC_Gauss_+3A_params">params</code></td>
<td>
<p>system dependent parameters (if NULL they are estimated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimated probability of excursion, see <code>typeReturn</code> for details.
</p>


<h3>References</h3>

<p>Azzimonti, D. and Ginsbourger, D. (2018). Estimating orthant probabilities of high dimensional Gaussian vectors with an application to set estimation. Journal of Computational and Graphical Statistics, 27(2), 255-267. Preprint at <a href="https://hal.science/hal-01289126">hal-01289126</a>
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>
<p>Genz, A. (1992). Numerical computation of multivariate normal probabilities. Journal of Computational and Graphical Statistics, 1(2):141&ndash;149.
</p>

<hr>
<h2 id='mvrnormArma'>Sample from multivariate normal distribution with C++</h2><span id='topic+mvrnormArma'></span>

<h3>Description</h3>

<p>Simulates realizations from a multivariate normal with mean mu and covariance matrix sigma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvrnormArma(n, mu, sigma, chol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvrnormArma_+3A_n">n</code></td>
<td>
<p>number of simulations.</p>
</td></tr>
<tr><td><code id="mvrnormArma_+3A_mu">mu</code></td>
<td>
<p>mean vector.</p>
</td></tr>
<tr><td><code id="mvrnormArma_+3A_sigma">sigma</code></td>
<td>
<p>covariance matrix or Cholesky decomposition of the matrix (see chol).</p>
</td></tr>
<tr><td><code id="mvrnormArma_+3A_chol">chol</code></td>
<td>
<p>integer, if 0 sigma is a covariance matrix, otherwise it is the Cholesky decomposition of the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code class="reqn">d x n</code> containing the samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate 1000 realizations from a multivariate normal vector
mu &lt;- rep(0,200)
Sigma &lt;- diag(rep(1,200))
realizations&lt;-mvrnormArma(n=1000,mu = mu,sigma=Sigma, chol=0)
empMean&lt;-rowMeans(realizations)
empCov&lt;-cov(t(realizations))
# check if the sample mean is close to the actual mean
maxErrorOnMean&lt;-max(abs(mu-empMean))
# check if we can estimate correctly the covariance matrix
maxErrorOnVar&lt;-max(abs(rep(1,200)-diag(empCov)))
maxErrorOnCov&lt;-max(abs(empCov[lower.tri(empCov)]))
## Not run: 
plot(density(realizations[2,]))

## End(Not run)
</code></pre>

<hr>
<h2 id='ProbaMax'>Probability of exceedance of maximum of Gaussian vector</h2><span id='topic+ProbaMax'></span>

<h3>Description</h3>

<p>Computes <code class="reqn">P(max X &gt; threshold)</code>
with choice of algorithm between ANMC_Gauss and MC_Gauss.
By default, the computationally expensive sampling parts are computed with the Rcpp functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProbaMax(
  cBdg,
  threshold,
  mu,
  Sigma,
  E = NULL,
  q = NULL,
  pn = NULL,
  lightReturn = T,
  method = 4,
  verb = 0,
  Algo = "ANMC",
  trmvrnorm = trmvrnorm_rej_cpp,
  pmvnorm_usr = pmvnorm
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProbaMax_+3A_cbdg">cBdg</code></td>
<td>
<p>computational budget.</p>
</td></tr>
<tr><td><code id="ProbaMax_+3A_threshold">threshold</code></td>
<td>
<p>threshold.</p>
</td></tr>
<tr><td><code id="ProbaMax_+3A_mu">mu</code></td>
<td>
<p>mean vector.</p>
</td></tr>
<tr><td><code id="ProbaMax_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix.</p>
</td></tr>
<tr><td><code id="ProbaMax_+3A_e">E</code></td>
<td>
<p>discretization design for the field. If <code>NULL</code>, a simplex-lattice design n,n is used, with <code>n=length(mu)</code>. In this case the choice of method=4,5 are not advised.</p>
</td></tr>
<tr><td><code id="ProbaMax_+3A_q">q</code></td>
<td>
<p>number of active dimensions, it can be either </p>

<ul>
<li><p> an integer: in this case the optimal <code>q</code> active dimension are chosen;
</p>
</li>
<li><p> a numeric vector of length 2: this is the range where to search for the best number of active dimensions;
</p>
</li>
<li> <p><code>NULL</code>: q is selected as the best number of active dimensions in the feasible range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ProbaMax_+3A_pn">pn</code></td>
<td>
<p>coverage probability function evaluated with <code>mu</code>, <code>Sigma</code>. If <code>NULL</code> it is computed automatically.</p>
</td></tr>
<tr><td><code id="ProbaMax_+3A_lightreturn">lightReturn</code></td>
<td>
<p>boolean, if <code>TRUE</code> light return.</p>
</td></tr>
<tr><td><code id="ProbaMax_+3A_method">method</code></td>
<td>
<p>method chosen to select the active dimensions.  See <code><a href="#topic+selectActiveDims">selectActiveDims</a></code> for details.</p>
</td></tr>
<tr><td><code id="ProbaMax_+3A_verb">verb</code></td>
<td>
<p>level of verbosity (0-5), selects verbosity also for <code><a href="#topic+ANMC_Gauss">ANMC_Gauss</a></code> (verb-1) and <code><a href="#topic+MC_Gauss">MC_Gauss</a></code> (verb-1).</p>
</td></tr>
<tr><td><code id="ProbaMax_+3A_algo">Algo</code></td>
<td>
<p>choice of algorithm to compute the remainder Rq (&quot;ANMC&quot; or &quot;MC&quot;).</p>
</td></tr>
<tr><td><code id="ProbaMax_+3A_trmvrnorm">trmvrnorm</code></td>
<td>
<p>function to generate truncated multivariate normal samples, it must have the following signature <code>trmvrnorm(n,mu,sigma,upper,lower,verb)</code>, where </p>

<ul>
<li> <p><code>n</code>: number of simulations;
</p>
</li>
<li> <p><code>mu</code>: mean vector of the Normal variable of dimension <code class="reqn">d</code>;
</p>
</li>
<li> <p><code>sigma</code>: covariance matrix of dimension <code class="reqn">d x d</code>;
</p>
</li>
<li> <p><code>upper</code>: vector of upper limits of length <code>d</code>;
</p>
</li>
<li> <p><code>lower</code>: vector of lower limits of length <code>d</code>;
</p>
</li>
<li> <p><code>verb</code>: the level of verbosity 3 basic, 4 extended.
</p>
</li></ul>

<p>It must return a matrix <code class="reqn">d x n</code> of realizations. If not specified, the rejection sampler <code><a href="#topic+trmvrnorm_rej_cpp">trmvrnorm_rej_cpp</a></code> is used.</p>
</td></tr>
<tr><td><code id="ProbaMax_+3A_pmvnorm_usr">pmvnorm_usr</code></td>
<td>
<p>function to compute core probability on active dimensions. Inputs: </p>

<ul>
<li> <p><code>lower:</code> the vector of lower limits of length <code>d</code>.
</p>
</li>
<li> <p><code>upper:</code> the vector of upper limits of length <code>d</code>.
</p>
</li>
<li> <p><code>mean:</code> the mean vector of length <code>d</code>.
</p>
</li>
<li> <p><code>sigma:</code> the covariance matrix of dimension <code>d</code>.
</p>
</li></ul>

<p>returns a the probability value with attribute &quot;error&quot;, the absolute error. Default is the function <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code> from the package <code>mvtnorm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li><p><code>probability</code>: The probability estimate
</p>
</li>
<li><p><code>variance</code>: the variance of the probability estimate
</p>
</li>
<li><p><code>q</code>:the number of selected active dimensions
</p>
</li></ul>

<p>If <code>lightReturn=F</code> then the list also contains:
</p>

<ul>
<li><p><code>aux_probabilities</code>:  a list with the probability estimates: <code>probability</code> the actual probability, <code>pq</code> the biased estimator <code class="reqn">p_q</code>, <code>Rq</code> the conditional probability <code class="reqn">R_q</code>
</p>
</li>
<li><p><code>Eq</code>: the points of the design <code class="reqn">E</code> selected for <code class="reqn">p_q</code>
</p>
</li>
<li><p><code>indQ</code>: the indices of the active dimensions chosen for <code class="reqn">p_q</code>
</p>
</li>
<li><p><code>resRq</code>: The list returned by the MC method used for <code class="reqn">R_q</code>
</p>
</li></ul>



<h3>References</h3>

<p>Azzimonti, D. and Ginsbourger, D. (2018). Estimating orthant probabilities of high dimensional Gaussian vectors with an application to set estimation. Journal of Computational and Graphical Statistics, 27(2), 255-267. Preprint at <a href="https://hal.science/hal-01289126">hal-01289126</a>
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>
<p>Chevalier, C. (2013). Fast uncertainty reduction strategies relying on Gaussian process models. PhD thesis, University of Bern.
</p>
<p>Dickmann, F. and Schweizer, N. (2014). Faster comparison of stopping times by nested conditional Monte Carlo. arXiv preprint arXiv:1402.0243.
</p>
<p>Genz, A. (1992). Numerical computation of multivariate normal probabilities. Journal of Computational and Graphical Statistics, 1(2):141&ndash;149.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Compute probability P(X \in (-\infty,0]) with X~N(0,Sigma)
d&lt;-200     # example dimension
mu&lt;-rep(0,d)    # mean of the normal vector
# correlation structure (Miwa et al. 2003, Craig 2008, Botev 2016)
Sigma&lt;-0.5*diag(d)+ 0.5*rep(1,d)%*%t(rep(1,d))

pANMC&lt;-ProbaMax(cBdg=20, q=min(50,d/2), E=seq(0,1,,d), threshold=0, mu=mu, Sigma=Sigma,
 pn = NULL, lightReturn = TRUE, method = 3, verb = 2, Algo = "ANMC")
proba&lt;-1-pANMC$probability

# Percentage error
abs(1-pANMC$probability-1/(d+1))/(1/(d+1))


# Implement ProbaMax with user defined function for active dimension probability estimate
if(!requireNamespace("TruncatedNormal", quietly = TRUE)) {
stop("Package TruncatedNormal needed for this example to work. Please install it.",
     call. = FALSE)
}

# define pmvnorm_usr with the function mvNcdf from the package TruncatedNormal
pmvnorm_usr&lt;-function(lower,upper,mean,sigma){
    pMET&lt;-TruncatedNormal::mvNcdf(l = lower-mean,u = upper-mean,Sig = sigma,n = 5e4)
    res&lt;-pMET$prob
    attr(res,"error")&lt;-pMET$relErr
    return(res)
}

pANMC&lt;-ProbaMax(cBdg=20, q=min(50,d/2), E=seq(0,1,,d), threshold=0, mu=mu, Sigma=Sigma,
 pn = NULL, lightReturn = TRUE, method = 3, verb = 2, Algo = "ANMC",pmvnorm_usr=pmvnorm_usr)
proba&lt;-1-pANMC$probability

# Percentage error
abs(1-pANMC$probability-1/(d+1))/(1/(d+1))


# Implement ProbaMax with user defined function for truncated normal sampling

if(!requireNamespace("tmg", quietly = TRUE)) {
stop("Package tmg needed for this example to work. Please install it.",
     call. = FALSE)
}
trmvrnorm_usr&lt;-function(n,mu,sigma,upper,lower,verb){
  M&lt;-chol2inv(chol(sigma))
 r=as.vector(M%*%mu)

 if(all(lower==-Inf) &amp;&amp; all(upper==Inf)){
   f&lt;- NULL
   g&lt;- NULL
 }else{
   if(all(lower==-Inf)){
     f&lt;--diag(length(mu))
     g&lt;-upper
     initial&lt;-(upper-1)/2
   }else if(all(upper==Inf)){
     f&lt;-diag(length(mu))
     g&lt;- -lower
     initial&lt;-2*(lower+1)
   }else{
     f&lt;-rbind(-diag(length(mu)),diag(length(mu)))
     g&lt;-c(upper,-lower)
     initial&lt;-(upper-lower)/2
   }
 }
 reals_tmg&lt;-tmg::rtmg(n=n,M=M,r=r,initial = initial,f=f,g=g)

 return(t(reals_tmg))
}

pANMC&lt;-ProbaMax(cBdg=20, q=min(50,d/2), E=seq(0,1,,d), threshold=0, mu=mu, Sigma=Sigma,
 pn = NULL, lightReturn = TRUE, method = 3, verb = 2, Algo = "ANMC",trmvrnorm=trmvrnorm_usr)
proba&lt;-1-pANMC$probability

# Percentage error
abs(1-pANMC$probability-1/(d+1))/(1/(d+1))

## End(Not run)
</code></pre>

<hr>
<h2 id='ProbaMin'>Probability of exceedance of minimum of Gaussian vector</h2><span id='topic+ProbaMin'></span>

<h3>Description</h3>

<p>Computes <code class="reqn">P(min X \le threshold)</code>
with choice of algorithm between ANMC_Gauss and MC_Gauss.
By default, the computationally expensive sampling parts are computed with the Rcpp functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProbaMin(
  cBdg,
  threshold,
  mu,
  Sigma,
  E = NULL,
  q = NULL,
  pn = NULL,
  lightReturn = T,
  method = 4,
  verb = 0,
  Algo = "ANMC",
  trmvrnorm = trmvrnorm_rej_cpp,
  pmvnorm_usr = pmvnorm
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProbaMin_+3A_cbdg">cBdg</code></td>
<td>
<p>computational budget.</p>
</td></tr>
<tr><td><code id="ProbaMin_+3A_threshold">threshold</code></td>
<td>
<p>threshold.</p>
</td></tr>
<tr><td><code id="ProbaMin_+3A_mu">mu</code></td>
<td>
<p>mean vector.</p>
</td></tr>
<tr><td><code id="ProbaMin_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix.</p>
</td></tr>
<tr><td><code id="ProbaMin_+3A_e">E</code></td>
<td>
<p>discretization design for the field. If <code>NULL</code>, a simplex-lattice design n,n is used, with <code>n=length(mu)</code>. In this case the choice of method=4,5 are not advised.</p>
</td></tr>
<tr><td><code id="ProbaMin_+3A_q">q</code></td>
<td>
<p>number of active dimensions, it can be either </p>

<ul>
<li><p> an integer: in this case the optimal <code>q</code> active dimension are chosen;
</p>
</li>
<li><p> a numeric vector of length 2: this is the range where to search for the best number of active dimensions;
</p>
</li>
<li> <p><code>NULL</code>: q is selected as the best number of active dimensions in the feasible range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ProbaMin_+3A_pn">pn</code></td>
<td>
<p>coverage probability function evaluated with <code>mu</code>, <code>Sigma</code>. If <code>NULL</code> it is computed automatically.</p>
</td></tr>
<tr><td><code id="ProbaMin_+3A_lightreturn">lightReturn</code></td>
<td>
<p>boolean, if <code>TRUE</code> light return.</p>
</td></tr>
<tr><td><code id="ProbaMin_+3A_method">method</code></td>
<td>
<p>method chosen to select the active dimensions. See <code><a href="#topic+selectActiveDims">selectActiveDims</a></code> for details.</p>
</td></tr>
<tr><td><code id="ProbaMin_+3A_verb">verb</code></td>
<td>
<p>level of verbosity (0-5), selects verbosity also for <code><a href="#topic+ANMC_Gauss">ANMC_Gauss</a></code> (verb-1) and <code><a href="#topic+MC_Gauss">MC_Gauss</a></code> (verb-1).</p>
</td></tr>
<tr><td><code id="ProbaMin_+3A_algo">Algo</code></td>
<td>
<p>choice of algorithm to compute the remainder Rq (&quot;ANMC&quot; or &quot;MC&quot;).</p>
</td></tr>
<tr><td><code id="ProbaMin_+3A_trmvrnorm">trmvrnorm</code></td>
<td>
<p>function to generate truncated multivariate normal samples, it must have the following signature <code>trmvrnorm(n,mu,sigma,upper,lower,verb)</code>, where </p>

<ul>
<li> <p><code>n</code>: number of simulations;
</p>
</li>
<li> <p><code>mu</code>: mean vector of the Normal variable of dimension <code class="reqn">d</code>;
</p>
</li>
<li> <p><code>sigma</code>: covariance matrix of dimension <code class="reqn">d x d</code>;
</p>
</li>
<li> <p><code>upper</code>: vector of upper limits of length <code>d</code>;
</p>
</li>
<li> <p><code>lower</code>: vector of lower limits of length <code>d</code>;
</p>
</li>
<li> <p><code>verb</code>: the level of verbosity 3 basic, 4 extended.
</p>
</li></ul>

<p>It must return a matrix <code class="reqn">d x n</code> of realizations. If not specified, the rejection sampler <code><a href="#topic+trmvrnorm_rej_cpp">trmvrnorm_rej_cpp</a></code> is used.</p>
</td></tr>
<tr><td><code id="ProbaMin_+3A_pmvnorm_usr">pmvnorm_usr</code></td>
<td>
<p>function to compute core probability on active dimensions. Inputs: </p>

<ul>
<li> <p><code>lower:</code> the vector of lower limits of length <code>d</code>.
</p>
</li>
<li> <p><code>upper:</code> the vector of upper limits of length <code>d</code>.
</p>
</li>
<li> <p><code>mean:</code> the mean vector of length <code>d</code>.
</p>
</li>
<li> <p><code>sigma:</code> the covariance matrix of dimension <code>d</code>.
</p>
</li></ul>

<p>returns a the probability value with attribute &quot;error&quot;, the absolute error. Default is the function <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code> from the package <code>mvtnorm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li><p><code>probability</code>: The probability estimate
</p>
</li>
<li><p><code>variance</code>: the variance of the probability estimate
</p>
</li>
<li><p><code>q</code>:the number of selected active dimensions
</p>
</li></ul>

<p>If <code>lightReturn=F</code> then the list also contains:
</p>

<ul>
<li><p><code>aux_probabilities</code>:  a list with the probability estimates: <code>probability</code> the actual probability, <code>pq</code> the biased estimator <code class="reqn">p_q</code>, <code>Rq</code> the conditional probability <code class="reqn">R_q</code>
</p>
</li>
<li><p><code>Eq</code>: the points of the design <code class="reqn">E</code> selected for <code class="reqn">p_q</code>
</p>
</li>
<li><p><code>indQ</code>: the indices of the active dimensions chosen for <code class="reqn">p_q</code>
</p>
</li>
<li><p><code>resRq</code>: The list returned by the MC method used for <code class="reqn">R_q</code>
</p>
</li></ul>



<h3>References</h3>

<p>Azzimonti, D. and Ginsbourger, D. (2018). Estimating orthant probabilities of high dimensional Gaussian vectors with an application to set estimation. Journal of Computational and Graphical Statistics, 27(2), 255-267. Preprint at <a href="https://hal.science/hal-01289126">hal-01289126</a>
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>
<p>Chevalier, C. (2013). Fast uncertainty reduction strategies relying on Gaussian process models. PhD thesis, University of Bern.
</p>
<p>Dickmann, F. and Schweizer, N. (2014). Faster comparison of stopping times by nested conditional Monte Carlo. arXiv preprint arXiv:1402.0243.
</p>
<p>Genz, A. (1992). Numerical computation of multivariate normal probabilities. Journal of Computational and Graphical Statistics, 1(2):141&ndash;149.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Compute probability P(X \in [0,\infty]) with X~N(0,Sigma)
d&lt;-200     # example dimension
mu&lt;-rep(0,d)    # mean of the normal vector
# correlation structure (Miwa et al. 2003, Craig 2008, Botev 2016)
Sigma&lt;-0.5*diag(d)+ 0.5*rep(1,d)%*%t(rep(1,d))
pANMC&lt;-ProbaMin(cBdg=20, q=min(50,d/2), E=seq(0,1,,d), threshold=0, mu=mu, Sigma=Sigma,
 pn = NULL, lightReturn = TRUE, method = 3, verb = 2, Algo = "ANMC")
proba&lt;-1-pANMC$probability

# Percentage error
abs(1-pANMC$probability-1/(d+1))/(1/(d+1))


# Implement ProbaMin with user defined function for active dimension probability estimate
if(!requireNamespace("TruncatedNormal", quietly = TRUE)) {
stop("TruncatedNormal needed for this example to work. Please install it.",
     call. = FALSE)
}
# define pmvnorm_usr with the function mvNcdf from the package TruncatedNormal
pmvnorm_usr&lt;-function(lower,upper,mean,sigma){
    pMET&lt;-TruncatedNormal::mvNcdf(l = lower-mean,u = upper-mean,Sig = sigma,n = 5e4)
    res&lt;-pMET$prob
    attr(res,"error")&lt;-pMET$relErr
    return(res)
}
pANMC&lt;-ProbaMin(cBdg=20, q=min(50,d/2), E=seq(0,1,,d), threshold=0, mu=mu, Sigma=Sigma,
 pn = NULL, lightReturn = TRUE, method = 3, verb = 2, Algo = "ANMC",pmvnorm_usr=pmvnorm_usr)
proba&lt;-1-pANMC$probability

# Percentage error
abs(1-pANMC$probability-1/(d+1))/(1/(d+1))

# Implement ProbaMin with user defined function for truncated normal sampling

if(!requireNamespace("tmg", quietly = TRUE)) {
stop("Package tmg needed for this example to work. Please install it.",
     call. = FALSE)
}
trmvrnorm_usr&lt;-function(n,mu,sigma,upper,lower,verb){
 M&lt;-chol2inv(chol(sigma))
 r=as.vector(M%*%mu)

 if(all(lower==-Inf) &amp;&amp; all(upper==Inf)){
   f&lt;- NULL
   g&lt;- NULL
 }else{
   if(all(lower==-Inf)){
     f&lt;--diag(length(mu))
     g&lt;-upper
     initial&lt;-(upper-1)/2
   }else if(all(upper==Inf)){
     f&lt;-diag(length(mu))
     g&lt;- -lower
     initial&lt;-2*(lower+1)
   }else{
     f&lt;-rbind(-diag(length(mu)),diag(length(mu)))
     g&lt;-c(upper,-lower)
     initial&lt;-(upper-lower)/2
   }
 }
 reals_tmg&lt;-tmg::rtmg(n=n,M=M,r=r,initial = initial,f=f,g=g)

 return(t(reals_tmg))
}

pANMC&lt;-ProbaMin(cBdg=20, q=min(50,d/2), E=seq(0,1,,d), threshold=0, mu=mu, Sigma=Sigma,
 pn = NULL, lightReturn = TRUE, method = 3, verb = 2, Algo = "ANMC",trmvrnorm=trmvrnorm_usr)
proba&lt;-1-pANMC$probability

# Percentage error
abs(1-pANMC$probability-1/(d+1))/(1/(d+1))

## End(Not run)
</code></pre>

<hr>
<h2 id='selectActiveDims'>Select active dimensions for small dimensional estimate</h2><span id='topic+selectActiveDims'></span>

<h3>Description</h3>

<p>The function <code>selectActiveDims</code> selects the active dimensions for the computation of <code class="reqn">p_q</code> with an heuristic method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectActiveDims(
  q = NULL,
  E,
  threshold,
  mu,
  Sigma,
  pn = NULL,
  method = 1,
  verb = 0,
  pmvnorm_usr = pmvnorm
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectActiveDims_+3A_q">q</code></td>
<td>
<p>either the fixed number of active dimensions or the range where the number of active dimensions is chosen with <code>selectQdims</code>. If <code>NULL</code> the function <code><a href="#topic+selectQdims">selectQdims</a></code> is called.</p>
</td></tr>
<tr><td><code id="selectActiveDims_+3A_e">E</code></td>
<td>
<p>discretization design for the field.</p>
</td></tr>
<tr><td><code id="selectActiveDims_+3A_threshold">threshold</code></td>
<td>
<p>threshold.</p>
</td></tr>
<tr><td><code id="selectActiveDims_+3A_mu">mu</code></td>
<td>
<p>mean vector.</p>
</td></tr>
<tr><td><code id="selectActiveDims_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix.</p>
</td></tr>
<tr><td><code id="selectActiveDims_+3A_pn">pn</code></td>
<td>
<p>coverage probability function based on <code>threshold</code>, <code>mu</code> and <code>Sigma</code>. If <code>NULL</code> it is computed.</p>
</td></tr>
<tr><td><code id="selectActiveDims_+3A_method">method</code></td>
<td>
<p>integer chosen between </p>

<ul>
<li><p> 0  selects by taking equally spaced indexes in mu;
</p>
</li>
<li><p> 1  samples from pn;
</p>
</li>
<li><p> 2  samples from pn*(1-pn);
</p>
</li>
<li><p> 3  samples from pn adjusting for the distance (tries to explore all modes);
</p>
</li>
<li><p> 4  samples from pn*(1-pn) adjusting for the distance (tries to explore all modes);
</p>
</li>
<li><p> 5  samples with uniform probabilities.
</p>
</li></ul>
</td></tr>
<tr><td><code id="selectActiveDims_+3A_verb">verb</code></td>
<td>
<p>level of verbosity: 0 returns nothing, 1 returns minimal info</p>
</td></tr>
<tr><td><code id="selectActiveDims_+3A_pmvnorm_usr">pmvnorm_usr</code></td>
<td>
<p>function to compute core probability on active dimensions. Inputs: </p>

<ul>
<li> <p><code>lower:</code> the vector of lower limits of length <code>d</code>.
</p>
</li>
<li> <p><code>upper:</code> the vector of upper limits of length <code>d</code>.
</p>
</li>
<li> <p><code>mean:</code> the mean vector of length <code>d</code>.
</p>
</li>
<li> <p><code>sigma:</code> the covariance matrix of dimension <code>d</code>.
</p>
</li></ul>

<p>returns a the probability value with attribute &quot;error&quot;, the absolute error. Default is the function <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code> from the package <code>mvtnorm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers denoting the chosen active dimensions of the vector mu.
</p>


<h3>References</h3>

<p>Azzimonti, D. and Ginsbourger, D. (2018). Estimating orthant probabilities of high dimensional Gaussian vectors with an application to set estimation. Journal of Computational and Graphical Statistics, 27(2), 255-267. Preprint at <a href="https://hal.science/hal-01289126">hal-01289126</a>
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>
<p>Chevalier, C. (2013). Fast uncertainty reduction strategies relying on Gaussian process models. PhD thesis, University of Bern.
</p>
<p>Genz, A. (1992). Numerical computation of multivariate normal probabilities. Journal of Computational and Graphical Statistics, 1(2):141&ndash;149.
</p>

<hr>
<h2 id='selectQdims'>Iteratively select active dimensions</h2><span id='topic+selectQdims'></span>

<h3>Description</h3>

<p>The function <code>selectQdims</code> iteratively selects the number of active dimensions and the dimensions themselves for the computation of <code class="reqn">p_q</code>.
The number of dimensions is increased until <code class="reqn">p_{q}-p_{q-1}</code> is smaller than the error of the procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectQdims(
  E,
  threshold,
  mu,
  Sigma,
  pn = NULL,
  method = 1,
  reducedReturn = T,
  verb = 0,
  limits = NULL,
  pmvnorm_usr = pmvnorm
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectQdims_+3A_e">E</code></td>
<td>
<p>discretization design for the field.</p>
</td></tr>
<tr><td><code id="selectQdims_+3A_threshold">threshold</code></td>
<td>
<p>threshold.</p>
</td></tr>
<tr><td><code id="selectQdims_+3A_mu">mu</code></td>
<td>
<p>mean vector.</p>
</td></tr>
<tr><td><code id="selectQdims_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix.</p>
</td></tr>
<tr><td><code id="selectQdims_+3A_pn">pn</code></td>
<td>
<p>coverage probability function based on <code>threshold</code>, <code>mu</code> and <code>Sigma</code>. If <code>NULL</code> it is computed.</p>
</td></tr>
<tr><td><code id="selectQdims_+3A_method">method</code></td>
<td>
<p>integer chosen between </p>

<ul>
<li><p> 0  selects by taking equally spaced indexes in mu;
</p>
</li>
<li><p> 1  samples from pn;
</p>
</li>
<li><p> 2  samples from pn*(1-pn);
</p>
</li>
<li><p> 3  samples from pn adjusting for the distance (tries to explore all modes);
</p>
</li>
<li><p> 4  samples from pn*(1-pn) adjusting for the distance (tries to explore all modes);
</p>
</li>
<li><p> 5  samples with uniform probabilities.
</p>
</li></ul>
</td></tr>
<tr><td><code id="selectQdims_+3A_reducedreturn">reducedReturn</code></td>
<td>
<p>boolean to select the type of return. See Value for further details.</p>
</td></tr>
<tr><td><code id="selectQdims_+3A_verb">verb</code></td>
<td>
<p>level of verbosity: 0 returns nothing, 1 returns minimal info.</p>
</td></tr>
<tr><td><code id="selectQdims_+3A_limits">limits</code></td>
<td>
<p>numeric vector of length 2 with q_min and q_max. If <code>NULL</code> initialized at c(10,300)</p>
</td></tr>
<tr><td><code id="selectQdims_+3A_pmvnorm_usr">pmvnorm_usr</code></td>
<td>
<p>function to compute core probability on active dimensions. Inputs: </p>

<ul>
<li> <p><code>lower:</code> the vector of lower limits of length <code>d</code>.
</p>
</li>
<li> <p><code>upper:</code> the vector of upper limits of length <code>d</code>.
</p>
</li>
<li> <p><code>mean:</code> the mean vector of length <code>d</code>.
</p>
</li>
<li> <p><code>sigma:</code> the covariance matrix of dimension <code>d</code>.
</p>
</li></ul>

<p>returns a the probability value with attribute &quot;error&quot;, the absolute error. Default is the function <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code> from the package <code>mvtnorm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>reducedReturn=F</code> returns a list containing
</p>

<ul>
<li><p><code>indQ</code>: the indices of the active dimensions chosen for <code class="reqn">p_q</code>;
</p>
</li>
<li><p><code>pq</code>: the biased estimator <code class="reqn">p_q</code> with attribute <code>error</code>, the estimated absolute error;
</p>
</li>
<li><p><code>Eq</code>: the points of the design <code class="reqn">E</code> selected for <code class="reqn">p_q</code>;
</p>
</li>
<li><p><code>muEq</code>: the subvector of <code>mu</code> selected for <code class="reqn">p_q</code>;
</p>
</li>
<li><p><code>KEq</code>: the submatrix of <code>Sigma</code> composed by the indexes selected for <code class="reqn">p_q</code>.
</p>
</li></ul>

<p>Otherwise it returns only <code>indQ</code>.
</p>


<h3>References</h3>

<p>Azzimonti, D. and Ginsbourger, D. (2018). Estimating orthant probabilities of high dimensional Gaussian vectors with an application to set estimation. Journal of Computational and Graphical Statistics, 27(2), 255-267. Preprint at <a href="https://hal.science/hal-01289126">hal-01289126</a>
</p>
<p>Chevalier, C. (2013). Fast uncertainty reduction strategies relying on Gaussian process models. PhD thesis, University of Bern.
</p>
<p>Genz, A. (1992). Numerical computation of multivariate normal probabilities. Journal of Computational and Graphical Statistics, 1(2):141&ndash;149.
</p>

<hr>
<h2 id='trmvrnorm_rej_cpp'>Sample from truncated multivariate normal distribution with C++</h2><span id='topic+trmvrnorm_rej_cpp'></span>

<h3>Description</h3>

<p>Simulates realizations from a truncated multivariate normal with mean mu, covariance matrix sigma in the bounds lower upper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trmvrnorm_rej_cpp(n, mu, sigma, lower, upper, verb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trmvrnorm_rej_cpp_+3A_n">n</code></td>
<td>
<p>number of simulations.</p>
</td></tr>
<tr><td><code id="trmvrnorm_rej_cpp_+3A_mu">mu</code></td>
<td>
<p>mean vector.</p>
</td></tr>
<tr><td><code id="trmvrnorm_rej_cpp_+3A_sigma">sigma</code></td>
<td>
<p>covariance matrix.</p>
</td></tr>
<tr><td><code id="trmvrnorm_rej_cpp_+3A_lower">lower</code></td>
<td>
<p>vector of lower bounds.</p>
</td></tr>
<tr><td><code id="trmvrnorm_rej_cpp_+3A_upper">upper</code></td>
<td>
<p>vector of upper bounds.</p>
</td></tr>
<tr><td><code id="trmvrnorm_rej_cpp_+3A_verb">verb</code></td>
<td>
<p>level of verbosity: if lower than 3 nothing, 3 minimal, 4 extended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code class="reqn">d x n</code> containing the samples.
</p>


<h3>References</h3>

<p>Horrace, W. C. (2005). Some results on the multivariate truncated normal distribution. Journal of Multivariate Analysis, 94(1):209&ndash;221.
</p>
<p>Robert, C. P. (1995). Simulation of truncated normal variables. Statistics and Computing, 5(2):121&ndash;125.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate 1000 realizations from a truncated multivariate normal vector
mu &lt;- rep(0,10)
Sigma &lt;- diag(rep(1,10))
upper &lt;- rep(3,10)
lower &lt;- rep(-0.5,10)
realizations&lt;-trmvrnorm_rej_cpp(n=1000,mu = mu,sigma=Sigma, lower =lower, upper= upper,verb=3)
empMean&lt;-rowMeans(realizations)
empCov&lt;-cov(t(realizations))
# check if the sample mean is close to the actual mean
maxErrorOnMean&lt;-max(abs(mu-empMean))
# check if we can estimate correctly the covariance matrix
maxErrorOnVar&lt;-max(abs(rep(1,200)-diag(empCov)))
maxErrorOnCov&lt;-max(abs(empCov[lower.tri(empCov)]))
## Not run: 
plot(density(realizations[1,]))
hist(realizations[1,],breaks="FD")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
